{"sha": "f03122f2a7626772fe13ab77f677141377104502", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAzMTIyZjJhNzYyNjc3MmZlMTNhYjc3ZjY3NzE0MTM3NzEwNDUwMg==", "commit": {"author": {"name": "Carl Love", "email": "cel@us.ibm.com", "date": "2020-06-06T21:56:08Z"}, "committer": {"name": "Carl Love", "email": "cel@us.ibm.com", "date": "2021-06-09T16:10:56Z"}, "message": "RS6000 add 128-bit Integer Operations part 1\n\n2021-06-07  Carl Love  <cel@us.ibm.com>\n\ngcc/ChangeLog\n\n\t* config/rs6000/altivec.h (vec_dive, vec_mod): Add define for new\n\tbuiltins.\n\t* config/rs6000/altivec.md (UNSPEC_VMULEUD, UNSPEC_VMULESD,\n\tUNSPEC_VMULOUD, UNSPEC_VMULOSD): New unspecs.\n\t(altivec_eqv1ti, altivec_gtv1ti, altivec_gtuv1ti, altivec_vmuleud,\n\taltivec_vmuloud, altivec_vmulesd, altivec_vmulosd, altivec_vrlq,\n\taltivec_vrlqmi, altivec_vrlqmi_inst, altivec_vrlqnm,\n\taltivec_vrlqnm_inst, altivec_vslq, altivec_vsrq, altivec_vsraq,\n\taltivec_vcmpequt_p, altivec_vcmpgtst_p, altivec_vcmpgtut_p): New\n\tdefine_insn.\n\t(vec_widen_umult_even_v2di, vec_widen_smult_even_v2di,\n\tvec_widen_umult_odd_v2di, vec_widen_smult_odd_v2di, altivec_vrlqmi,\n\taltivec_vrlqnm): New define_expands.\n\t* config/rs6000/rs6000-builtin.def (VCMPEQUT_P, VCMPGTST_P,\n\tVCMPGTUT_P): Add macro expansions.\n\t(BU_P10V_AV_P): Add builtin predicate definition.\n\t(VCMPGTUT, VCMPGTST, VCMPEQUT, CMPNET, CMPGE_1TI,\n\tCMPGE_U1TI, CMPLE_1TI, CMPLE_U1TI, VNOR_V1TI_UNS, VNOR_V1TI, VCMPNET_P,\n\tVCMPAET_P, VMULEUD, VMULESD, VMULOUD, VMULOSD, VRLQ,\n\tVSLQ, VSRQ, VSRAQ, VRLQNM, DIV_V1TI, UDIV_V1TI, DIVES_V1TI, DIVEU_V1TI,\n\tMODS_V1TI, MODU_V1TI, VRLQMI): New macro expansions.\n\t(VRLQ, VSLQ, VSRQ, VSRAQ, DIVE, MOD): New overload expansions.\n\t* config/rs6000/rs6000-call.c (P10_BUILTIN_VCMPEQUT,\n\tP10V_BUILTIN_CMPGE_1TI, P10V_BUILTIN_CMPGE_U1TI,\n\tP10V_BUILTIN_VCMPGTUT, P10V_BUILTIN_VCMPGTST,\n\tP10V_BUILTIN_CMPLE_1TI, P10V_BUILTIN_VCMPLE_U1TI,\n\tP10V_BUILTIN_DIV_V1TI, P10V_BUILTIN_UDIV_V1TI,\n\tP10V_BUILTIN_VMULESD, P10V_BUILTIN_VMULEUD,\n\tP10V_BUILTIN_VMULOSD, P10V_BUILTIN_VMULOUD,\n\tP10V_BUILTIN_VNOR_V1TI, P10V_BUILTIN_VNOR_V1TI_UNS,\n\tP10V_BUILTIN_VRLQ, P10V_BUILTIN_VRLQMI,\n\tP10V_BUILTIN_VRLQNM, P10V_BUILTIN_VSLQ,\n\tP10V_BUILTIN_VSRQ, P10V_BUILTIN_VSRAQ,\n\tP10V_BUILTIN_VCMPGTUT_P, P10V_BUILTIN_VCMPGTST_P,\n\tP10V_BUILTIN_VCMPEQUT_P, P10V_BUILTIN_VCMPGTUT_P,\n\tP10V_BUILTIN_VCMPGTST_P, P10V_BUILTIN_CMPNET,\n\tP10V_BUILTIN_VCMPNET_P, P10V_BUILTIN_VCMPAET_P,\n\tP10V_BUILTIN_DIVES_V1TI, P10V_BUILTIN_MODS_V1TI,\n\tP10V_BUILTIN_MODU_V1TI):\n\tNew overloaded definitions.\n\t(rs6000_gimple_fold_builtin) [P10V_BUILTIN_VCMPEQUT,\n\tP10V_BUILTIN_CMPNET, P10V_BUILTIN_CMPGE_1TI,\n\tP10V_BUILTIN_CMPGE_U1TI, P10V_BUILTIN_VCMPGTUT,\n\tP10V_BUILTIN_VCMPGTST, P10V_BUILTIN_CMPLE_1TI,\n\tP10V_BUILTIN_CMPLE_U1TI]: New case statements.\n\t(rs6000_init_builtins) [bool_V1TI_type_node, int_ftype_int_v1ti_v1ti]:\n\tNew assignments.\n\t(altivec_init_builtins): New E_V1TImode case statement.\n\t(builtin_function_type)[P10_BUILTIN_128BIT_VMULEUD,\n\tP10_BUILTIN_128BIT_VMULOUD, P10_BUILTIN_128BIT_DIVEU_V1TI,\n\tP10_BUILTIN_128BIT_MODU_V1TI, P10_BUILTIN_CMPGE_U1TI,\n\tP10_BUILTIN_VCMPGTUT, P10_BUILTIN_VCMPEQUT]: New case statements.\n\t* config/rs6000/rs6000.c (rs6000_handle_altivec_attribute) [E_TImode,\n\tE_V1TImode]: New case statements.\n\t* config/rs6000/rs6000.h (rs6000_builtin_type_index): New enum\n\tvalue RS6000_BTI_bool_V1TI.\n\t* config/rs6000/vector.md (vector_gtv1ti,vector_nltv1ti,\n\tvector_gtuv1ti, vector_nltuv1ti, vector_ngtv1ti, vector_ngtuv1ti,\n\tvector_eq_v1ti_p, vector_ne_v1ti_p, vector_ae_v1ti_p,\n\tvector_gt_v1ti_p, vector_gtu_v1ti_p, vrotlv1ti3, vashlv1ti3,\n\tvlshrv1ti3, vashrv1ti3): New define_expands.\n\t* config/rs6000/vsx.md (UNSPEC_VSX_DIVSQ, UNSPEC_VSX_DIVUQ,\n\tUNSPEC_VSX_DIVESQ, UNSPEC_VSX_DIVEUQ, UNSPEC_VSX_MODSQ,\n\tUNSPEC_VSX_MODUQ): New unspecs.\n\t(mulv2di3, vsx_div_v1ti, vsx_udiv_v1ti, vsx_dives_v1ti,\n\tvsx_diveu_v1ti,\tvsx_mods_v1ti, vsx_modu_v1ti, xxswapd_v1ti): New\n\tdefine_insns.\n\t(vcmpnet): New define_expand.\n\t* doc/extend.texi: Add documentation for the new builtins vec_rl,\n\tvec_rlmi, vec_rlnm, vec_sl, vec_sr, vec_sra, vec_mule, vec_mulo,\n\tvec_div, vec_dive, vec_mod, vec_cmpeq, vec_cmpne, vec_cmpgt, vec_cmplt,\n\tvec_cmpge, vec_cmple, vec_all_eq, vec_all_ne, vec_all_gt, vec_all_lt,\n\tvec_all_ge, vec_all_le, vec_any_eq, vec_any_ne, vec_any_gt, vec_any_lt,\n\tvec_any_ge, vec_any_le.\n\ngcc/testsuite/ChangeLog\n\n\t* gcc.target/powerpc/int_128bit-runnable.c: New test file.", "tree": {"sha": "3e7b70eb56a1f9cac0f928b03854f51764bd7d6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e7b70eb56a1f9cac0f928b03854f51764bd7d6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f03122f2a7626772fe13ab77f677141377104502", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f03122f2a7626772fe13ab77f677141377104502", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f03122f2a7626772fe13ab77f677141377104502", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f03122f2a7626772fe13ab77f677141377104502/comments", "author": {"login": "carlelove", "id": 86435705, "node_id": "MDQ6VXNlcjg2NDM1NzA1", "avatar_url": "https://avatars.githubusercontent.com/u/86435705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carlelove", "html_url": "https://github.com/carlelove", "followers_url": "https://api.github.com/users/carlelove/followers", "following_url": "https://api.github.com/users/carlelove/following{/other_user}", "gists_url": "https://api.github.com/users/carlelove/gists{/gist_id}", "starred_url": "https://api.github.com/users/carlelove/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carlelove/subscriptions", "organizations_url": "https://api.github.com/users/carlelove/orgs", "repos_url": "https://api.github.com/users/carlelove/repos", "events_url": "https://api.github.com/users/carlelove/events{/privacy}", "received_events_url": "https://api.github.com/users/carlelove/received_events", "type": "User", "site_admin": false}, "committer": {"login": "carlelove", "id": 86435705, "node_id": "MDQ6VXNlcjg2NDM1NzA1", "avatar_url": "https://avatars.githubusercontent.com/u/86435705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carlelove", "html_url": "https://github.com/carlelove", "followers_url": "https://api.github.com/users/carlelove/followers", "following_url": "https://api.github.com/users/carlelove/following{/other_user}", "gists_url": "https://api.github.com/users/carlelove/gists{/gist_id}", "starred_url": "https://api.github.com/users/carlelove/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carlelove/subscriptions", "organizations_url": "https://api.github.com/users/carlelove/orgs", "repos_url": "https://api.github.com/users/carlelove/repos", "events_url": "https://api.github.com/users/carlelove/events{/privacy}", "received_events_url": "https://api.github.com/users/carlelove/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2142e34340523e1553c0dc131f657893f307e291", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2142e34340523e1553c0dc131f657893f307e291", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2142e34340523e1553c0dc131f657893f307e291"}], "stats": {"total": 3141, "additions": 3137, "deletions": 4}, "files": [{"sha": "314695a43ca1f6a45419679f38f1c88a3e940089", "filename": "gcc/config/rs6000/altivec.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fconfig%2Frs6000%2Faltivec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fconfig%2Frs6000%2Faltivec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.h?ref=f03122f2a7626772fe13ab77f677141377104502", "patch": "@@ -715,6 +715,9 @@ __altivec_scalar_pred(vec_any_nle,\n #define vec_step(x) __builtin_vec_step (* (__typeof__ (x) *) 0)\n \n #ifdef _ARCH_PWR10\n+#define vec_dive __builtin_vec_dive\n+#define vec_mod  __builtin_vec_mod\n+\n /* May modify these macro definitions if future capabilities overload\n    with support for different vector argument and result types.  */\n #define vec_cntlzm(a, b)\t__builtin_altivec_vclzdm (a, b)"}, {"sha": "0fa69b7e99f7315a19b24d454d5049ccc7baf93c", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=f03122f2a7626772fe13ab77f677141377104502", "patch": "@@ -39,12 +39,16 @@\n    UNSPEC_VMULESH\n    UNSPEC_VMULEUW\n    UNSPEC_VMULESW\n+   UNSPEC_VMULEUD\n+   UNSPEC_VMULESD\n    UNSPEC_VMULOUB\n    UNSPEC_VMULOSB\n    UNSPEC_VMULOUH\n    UNSPEC_VMULOSH\n    UNSPEC_VMULOUW\n    UNSPEC_VMULOSW\n+   UNSPEC_VMULOUD\n+   UNSPEC_VMULOSD\n    UNSPEC_VPKPX\n    UNSPEC_VPACK_SIGN_SIGN_SAT\n    UNSPEC_VPACK_SIGN_UNS_SAT\n@@ -619,6 +623,14 @@\n   \"vcmpbfp %0,%1,%2\"\n   [(set_attr \"type\" \"veccmp\")])\n \n+(define_insn \"altivec_eqv1ti\"\n+  [(set (match_operand:V1TI 0 \"altivec_register_operand\" \"=v\")\n+     (eq:V1TI (match_operand:V1TI 1 \"altivec_register_operand\" \"v\")\n+              (match_operand:V1TI 2 \"altivec_register_operand\" \"v\")))]\n+  \"TARGET_POWER10\"\n+  \"vcmpequq %0,%1,%2\"\n+  [(set_attr \"type\" \"veccmpfx\")])\n+\n (define_insn \"altivec_eq<mode>\"\n   [(set (match_operand:VI2 0 \"altivec_register_operand\" \"=v\")\n \t(eq:VI2 (match_operand:VI2 1 \"altivec_register_operand\" \"v\")\n@@ -635,6 +647,14 @@\n   \"vcmpgts<VI_char> %0,%1,%2\"\n   [(set_attr \"type\" \"veccmpfx\")])\n \n+(define_insn \"*altivec_gtv1ti\"\n+  [(set (match_operand:V1TI 0 \"altivec_register_operand\" \"=v\")\n+\t(gt:V1TI (match_operand:V1TI 1 \"altivec_register_operand\" \"v\")\n+\t\t (match_operand:V1TI 2 \"altivec_register_operand\" \"v\")))]\n+  \"TARGET_POWER10\"\n+  \"vcmpgtsq %0,%1,%2\"\n+  [(set_attr \"type\" \"veccmpfx\")])\n+\n (define_insn \"*altivec_gtu<mode>\"\n   [(set (match_operand:VI2 0 \"altivec_register_operand\" \"=v\")\n \t(gtu:VI2 (match_operand:VI2 1 \"altivec_register_operand\" \"v\")\n@@ -643,6 +663,14 @@\n   \"vcmpgtu<VI_char> %0,%1,%2\"\n   [(set_attr \"type\" \"veccmpfx\")])\n \n+(define_insn \"*altivec_gtuv1ti\"\n+  [(set (match_operand:V1TI 0 \"altivec_register_operand\" \"=v\")\n+\t(gtu:V1TI (match_operand:V1TI 1 \"altivec_register_operand\" \"v\")\n+\t\t  (match_operand:V1TI 2 \"altivec_register_operand\" \"v\")))]\n+  \"TARGET_POWER10\"\n+  \"vcmpgtuq %0,%1,%2\"\n+  [(set_attr \"type\" \"veccmpfx\")])\n+\n (define_insn \"*altivec_eqv4sf\"\n   [(set (match_operand:V4SF 0 \"altivec_register_operand\" \"=v\")\n \t(eq:V4SF (match_operand:V4SF 1 \"altivec_register_operand\" \"v\")\n@@ -1693,6 +1721,19 @@\n  DONE;\n })\n \n+(define_expand \"vec_widen_umult_even_v2di\"\n+  [(use (match_operand:V1TI 0 \"register_operand\"))\n+   (use (match_operand:V2DI 1 \"register_operand\"))\n+   (use (match_operand:V2DI 2 \"register_operand\"))]\n+  \"TARGET_POWER10\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    emit_insn (gen_altivec_vmuleud (operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_altivec_vmuloud (operands[0], operands[1], operands[2]));\n+ DONE;\n+})\n+\n (define_expand \"vec_widen_smult_even_v4si\"\n   [(use (match_operand:V2DI 0 \"register_operand\"))\n    (use (match_operand:V4SI 1 \"register_operand\"))\n@@ -1706,6 +1747,19 @@\n   DONE;\n })\n \n+(define_expand \"vec_widen_smult_even_v2di\"\n+  [(use (match_operand:V1TI 0 \"register_operand\"))\n+   (use (match_operand:V2DI 1 \"register_operand\"))\n+   (use (match_operand:V2DI 2 \"register_operand\"))]\n+  \"TARGET_POWER10\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    emit_insn (gen_altivec_vmulesd (operands[0], operands[1], operands[2]));\n+ else\n+    emit_insn (gen_altivec_vmulosd (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n (define_expand \"vec_widen_umult_odd_v16qi\"\n   [(use (match_operand:V8HI 0 \"register_operand\"))\n    (use (match_operand:V16QI 1 \"register_operand\"))\n@@ -1771,6 +1825,19 @@\n   DONE;\n })\n \n+(define_expand \"vec_widen_umult_odd_v2di\"\n+  [(use (match_operand:V1TI 0 \"register_operand\"))\n+   (use (match_operand:V2DI 1 \"register_operand\"))\n+   (use (match_operand:V2DI 2 \"register_operand\"))]\n+  \"TARGET_POWER10\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    emit_insn (gen_altivec_vmuloud (operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_altivec_vmuleud (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n (define_expand \"vec_widen_smult_odd_v4si\"\n   [(use (match_operand:V2DI 0 \"register_operand\"))\n    (use (match_operand:V4SI 1 \"register_operand\"))\n@@ -1784,6 +1851,19 @@\n   DONE;\n })\n \n+(define_expand \"vec_widen_smult_odd_v2di\"\n+  [(use (match_operand:V1TI 0 \"register_operand\"))\n+   (use (match_operand:V2DI 1 \"register_operand\"))\n+   (use (match_operand:V2DI 2 \"register_operand\"))]\n+  \"TARGET_POWER10\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    emit_insn (gen_altivec_vmulosd (operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_altivec_vmulesd (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n (define_insn \"altivec_vmuleub\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n         (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n@@ -1865,6 +1945,15 @@\n   \"vmuleuw %0,%1,%2\"\n   [(set_attr \"type\" \"veccomplex\")])\n \n+(define_insn \"altivec_vmuleud\"\n+  [(set (match_operand:V1TI 0 \"register_operand\" \"=v\")\n+       (unspec:V1TI [(match_operand:V2DI 1 \"register_operand\" \"v\")\n+                     (match_operand:V2DI 2 \"register_operand\" \"v\")]\n+                    UNSPEC_VMULEUD))]\n+  \"TARGET_POWER10\"\n+  \"vmuleud %0,%1,%2\"\n+  [(set_attr \"type\" \"veccomplex\")])\n+\n (define_insn \"altivec_vmulouw\"\n   [(set (match_operand:V2DI 0 \"register_operand\" \"=v\")\n        (unspec:V2DI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n@@ -1874,6 +1963,15 @@\n   \"vmulouw %0,%1,%2\"\n   [(set_attr \"type\" \"veccomplex\")])\n \n+(define_insn \"altivec_vmuloud\"\n+  [(set (match_operand:V1TI 0 \"register_operand\" \"=v\")\n+       (unspec:V1TI [(match_operand:V2DI 1 \"register_operand\" \"v\")\n+                     (match_operand:V2DI 2 \"register_operand\" \"v\")]\n+                    UNSPEC_VMULOUD))]\n+  \"TARGET_POWER10\"\n+  \"vmuloud %0,%1,%2\"\n+  [(set_attr \"type\" \"veccomplex\")])\n+\n (define_insn \"altivec_vmulesw\"\n   [(set (match_operand:V2DI 0 \"register_operand\" \"=v\")\n        (unspec:V2DI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n@@ -1883,6 +1981,15 @@\n   \"vmulesw %0,%1,%2\"\n   [(set_attr \"type\" \"veccomplex\")])\n \n+(define_insn \"altivec_vmulesd\"\n+  [(set (match_operand:V1TI 0 \"register_operand\" \"=v\")\n+       (unspec:V1TI [(match_operand:V2DI 1 \"register_operand\" \"v\")\n+                     (match_operand:V2DI 2 \"register_operand\" \"v\")]\n+                    UNSPEC_VMULESD))]\n+  \"TARGET_POWER10\"\n+  \"vmulesd %0,%1,%2\"\n+  [(set_attr \"type\" \"veccomplex\")])\n+\n (define_insn \"altivec_vmulosw\"\n   [(set (match_operand:V2DI 0 \"register_operand\" \"=v\")\n        (unspec:V2DI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n@@ -1892,6 +1999,15 @@\n   \"vmulosw %0,%1,%2\"\n   [(set_attr \"type\" \"veccomplex\")])\n \n+(define_insn \"altivec_vmulosd\"\n+  [(set (match_operand:V1TI 0 \"register_operand\" \"=v\")\n+       (unspec:V1TI [(match_operand:V2DI 1 \"register_operand\" \"v\")\n+                     (match_operand:V2DI 2 \"register_operand\" \"v\")]\n+                    UNSPEC_VMULOSD))]\n+  \"TARGET_POWER10\"\n+  \"vmulosd %0,%1,%2\"\n+  [(set_attr \"type\" \"veccomplex\")])\n+\n ;; Vector pack/unpack\n (define_insn \"altivec_vpkpx\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n@@ -1985,6 +2101,15 @@\n   \"vrl<VI_char> %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n+(define_insn \"altivec_vrlq\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n+        (rotate:V1TI (match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n+                     (match_operand:V1TI 2 \"vsx_register_operand\" \"v\")))]\n+  \"TARGET_POWER10\"\n+;; rotate amount in needs to be in bits[57:63] of operand2.\n+  \"vrlq %0,%1,%2\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n (define_insn \"altivec_vrl<VI_char>mi\"\n   [(set (match_operand:VIlong 0 \"register_operand\" \"=v\")\n         (unspec:VIlong [(match_operand:VIlong 1 \"register_operand\" \"v\")\n@@ -1995,6 +2120,34 @@\n   \"vrl<VI_char>mi %0,%1,%3\"\n   [(set_attr \"type\" \"veclogical\")])\n \n+(define_expand \"altivec_vrlqmi\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"vsx_register_operand\")\n+\t\t      (match_operand:V1TI 2 \"vsx_register_operand\")\n+\t\t      (match_operand:V1TI 3 \"vsx_register_operand\")]\n+\t\t     UNSPEC_VRLMI))]\n+  \"TARGET_POWER10\"\n+{\n+  /* Mask bit begin, end fields need to be in bits [41:55] of 128-bit operand2.\n+     Shift amount in needs to be put in bits[57:63] of 128-bit operand2. */\n+  rtx tmp = gen_reg_rtx (V1TImode);\n+\n+  emit_insn (gen_xxswapd_v1ti (tmp, operands[3]));\n+  emit_insn (gen_altivec_vrlqmi_inst (operands[0], operands[1], operands[2],\n+\t\t\t\t      tmp));\n+  DONE;\n+})\n+\n+(define_insn \"altivec_vrlqmi_inst\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 2 \"vsx_register_operand\" \"0\")\n+\t\t      (match_operand:V1TI 3 \"vsx_register_operand\" \"v\")]\n+\t\t     UNSPEC_VRLMI))]\n+  \"TARGET_POWER10\"\n+  \"vrlqmi %0,%1,%3\"\n+  [(set_attr \"type\" \"veclogical\")])\n+\n (define_insn \"altivec_vrl<VI_char>nm\"\n   [(set (match_operand:VIlong 0 \"register_operand\" \"=v\")\n         (unspec:VIlong [(match_operand:VIlong 1 \"register_operand\" \"v\")\n@@ -2004,6 +2157,31 @@\n   \"vrl<VI_char>nm %0,%1,%2\"\n   [(set_attr \"type\" \"veclogical\")])\n \n+(define_expand \"altivec_vrlqnm\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"vsx_register_operand\")\n+\t\t      (match_operand:V1TI 2 \"vsx_register_operand\")]\n+\t\t     UNSPEC_VRLNM))]\n+  \"TARGET_POWER10\"\n+{\n+  /* Shift amount in needs to be put in bits[57:63] of 128-bit operand2. */\n+  rtx tmp = gen_reg_rtx (V1TImode);\n+\n+  emit_insn (gen_xxswapd_v1ti (tmp, operands[2]));\n+  emit_insn (gen_altivec_vrlqnm_inst (operands[0], operands[1], tmp));\n+  DONE;\n+})\n+\n+(define_insn \"altivec_vrlqnm_inst\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 2 \"vsx_register_operand\" \"v\")]\n+\t\t     UNSPEC_VRLNM))]\n+  \"TARGET_POWER10\"\n+  ;; rotate and mask bits need to be in upper 64-bits of operand2.\n+  \"vrlqnm %0,%1,%2\"\n+  [(set_attr \"type\" \"veclogical\")])\n+\n (define_insn \"altivec_vsl\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n@@ -2048,6 +2226,15 @@\n   \"vsl<VI_char> %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n+(define_insn \"altivec_vslq\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n+\t(ashift:V1TI (match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n+\t\t     (match_operand:V1TI 2 \"vsx_register_operand\" \"v\")))]\n+  \"TARGET_POWER10\"\n+  /* Shift amount in needs to be in bits[57:63] of 128-bit operand. */\n+  \"vslq %0,%1,%2\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n (define_insn \"*altivec_vsr<VI_char>\"\n   [(set (match_operand:VI2 0 \"register_operand\" \"=v\")\n         (lshiftrt:VI2 (match_operand:VI2 1 \"register_operand\" \"v\")\n@@ -2056,6 +2243,15 @@\n   \"vsr<VI_char> %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n+(define_insn \"altivec_vsrq\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n+\t(lshiftrt:V1TI (match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n+\t\t       (match_operand:V1TI 2 \"vsx_register_operand\" \"v\")))]\n+  \"TARGET_POWER10\"\n+  /* Shift amount in needs to be in bits[57:63] of 128-bit operand. */\n+  \"vsrq %0,%1,%2\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n (define_insn \"*altivec_vsra<VI_char>\"\n   [(set (match_operand:VI2 0 \"register_operand\" \"=v\")\n         (ashiftrt:VI2 (match_operand:VI2 1 \"register_operand\" \"v\")\n@@ -2064,6 +2260,15 @@\n   \"vsra<VI_char> %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n+(define_insn \"altivec_vsraq\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n+\t(ashiftrt:V1TI (match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n+\t\t       (match_operand:V1TI 2 \"vsx_register_operand\" \"v\")))]\n+  \"TARGET_POWER10\"\n+  /* Shift amount in needs to be in bits[57:63] of 128-bit operand. */\n+  \"vsraq %0,%1,%2\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n (define_insn \"altivec_vsr\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n@@ -2624,6 +2829,18 @@\n   \"vcmpequ<VI_char>. %0,%1,%2\"\n   [(set_attr \"type\" \"veccmpfx\")])\n \n+(define_insn \"altivec_vcmpequt_p\"\n+  [(set (reg:CC CR6_REGNO)\n+\t(unspec:CC [(eq:CC (match_operand:V1TI 1 \"altivec_register_operand\" \"v\")\n+\t\t\t   (match_operand:V1TI 2 \"altivec_register_operand\" \"v\"))]\n+\t\t   UNSPEC_PREDICATE))\n+   (set (match_operand:V1TI 0 \"altivec_register_operand\" \"=v\")\n+\t(eq:V1TI (match_dup 1)\n+\t\t (match_dup 2)))]\n+  \"TARGET_POWER10\"\n+  \"vcmpequq. %0,%1,%2\"\n+  [(set_attr \"type\" \"veccmpfx\")])\n+\n (define_insn \"*altivec_vcmpgts<VI_char>_p\"\n   [(set (reg:CC CR6_REGNO)\n \t(unspec:CC [(gt:CC (match_operand:VI2 1 \"register_operand\" \"v\")\n@@ -2636,6 +2853,18 @@\n   \"vcmpgts<VI_char>. %0,%1,%2\"\n   [(set_attr \"type\" \"veccmpfx\")])\n \n+(define_insn \"*altivec_vcmpgtst_p\"\n+  [(set (reg:CC CR6_REGNO)\n+\t(unspec:CC [(gt:CC (match_operand:V1TI 1 \"register_operand\" \"v\")\n+\t\t\t   (match_operand:V1TI 2 \"register_operand\" \"v\"))]\n+\t\t   UNSPEC_PREDICATE))\n+   (set (match_operand:V1TI 0 \"register_operand\" \"=v\")\n+\t(gt:V1TI (match_dup 1)\n+\t\t (match_dup 2)))]\n+  \"TARGET_POWER10\"\n+  \"vcmpgtsq. %0,%1,%2\"\n+  [(set_attr \"type\" \"veccmpfx\")])\n+\n (define_insn \"*altivec_vcmpgtu<VI_char>_p\"\n   [(set (reg:CC CR6_REGNO)\n \t(unspec:CC [(gtu:CC (match_operand:VI2 1 \"register_operand\" \"v\")\n@@ -2648,6 +2877,18 @@\n   \"vcmpgtu<VI_char>. %0,%1,%2\"\n   [(set_attr \"type\" \"veccmpfx\")])\n \n+(define_insn \"*altivec_vcmpgtut_p\"\n+  [(set (reg:CC CR6_REGNO)\n+\t(unspec:CC [(gtu:CC (match_operand:V1TI 1 \"register_operand\" \"v\")\n+\t\t\t    (match_operand:V1TI 2 \"register_operand\" \"v\"))]\n+\t\t   UNSPEC_PREDICATE))\n+   (set (match_operand:V1TI 0 \"register_operand\" \"=v\")\n+\t(gtu:V1TI (match_dup 1)\n+\t\t  (match_dup 2)))]\n+  \"TARGET_POWER10\"\n+  \"vcmpgtuq. %0,%1,%2\"\n+  [(set_attr \"type\" \"veccmpfx\")])\n+\n (define_insn \"*altivec_vcmpeqfp_p\"\n   [(set (reg:CC CR6_REGNO)\n \t(unspec:CC [(eq:CC (match_operand:V4SF 1 \"register_operand\" \"v\")"}, {"sha": "dba22825b792890db863d9a9b81b61234fdf5483", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=f03122f2a7626772fe13ab77f677141377104502", "patch": "@@ -1269,6 +1269,15 @@\n \t\t     | RS6000_BTC_TERNARY),\t\t\t\t\\\n \t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n \n+/* See the comment on BU_ALTIVEC_P.  */\n+#define BU_P10V_AV_P(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_P (P10V_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_altivec_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P10,\t \t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_PREDICATE),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n #define BU_P10V_AV_X(ENUM, NAME, ATTR)\t\t\t\t\t\\\n   RS6000_BUILTIN_X (P10_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n \t\t    \"__builtin_altivec_\" NAME,\t\t/* NAME */\t\\\n@@ -2880,6 +2889,10 @@ BU_P9_OVERLOAD_2 (CMPRB2,\t\"byte_in_either_range\")\n BU_P9_OVERLOAD_2 (CMPEQB,\t\"byte_in_set\")\n \f\n /* Builtins for scalar instructions added in ISA 3.1 (power10).  */\n+BU_P10V_AV_P (VCMPEQUT_P,\t\"vcmpequt_p\",\tCONST,\tvector_eq_v1ti_p)\n+BU_P10V_AV_P (VCMPGTST_P,\t\"vcmpgtst_p\",\tCONST,\tvector_gt_v1ti_p)\n+BU_P10V_AV_P (VCMPGTUT_P,\t\"vcmpgtut_p\",\tCONST,\tvector_gtu_v1ti_p)\n+\n BU_P10_POWERPC64_MISC_2 (CFUGED, \"cfuged\", CONST, cfuged)\n BU_P10_POWERPC64_MISC_2 (CNTLZDM, \"cntlzdm\", CONST, cntlzdm)\n BU_P10_POWERPC64_MISC_2 (CNTTZDM, \"cnttzdm\", CONST, cnttzdm)\n@@ -2900,7 +2913,36 @@ BU_P10V_VSX_2 (XXGENPCVM_V16QI, \"xxgenpcvm_v16qi\", CONST, xxgenpcvm_v16qi)\n BU_P10V_VSX_2 (XXGENPCVM_V8HI, \"xxgenpcvm_v8hi\", CONST, xxgenpcvm_v8hi)\n BU_P10V_VSX_2 (XXGENPCVM_V4SI, \"xxgenpcvm_v4si\", CONST, xxgenpcvm_v4si)\n BU_P10V_VSX_2 (XXGENPCVM_V2DI, \"xxgenpcvm_v2di\", CONST, xxgenpcvm_v2di)\n-\n+BU_P10V_AV_2 (VCMPGTUT,\t\t\"vcmpgtut\",\tCONST,\tvector_gtuv1ti)\n+BU_P10V_AV_2 (VCMPGTST,\t\t\"vcmpgtst\",\tCONST,\tvector_gtv1ti)\n+BU_P10V_AV_2 (VCMPEQUT,\t\t\"vcmpequt\",\tCONST,\teqvv1ti3)\n+BU_P10V_AV_2 (CMPNET,\t\t\"vcmpnet\",\tCONST,\tvcmpnet)\n+BU_P10V_AV_2 (CMPGE_1TI,\t\"cmpge_1ti\",    CONST,  vector_nltv1ti)\n+BU_P10V_AV_2 (CMPGE_U1TI,\t\"cmpge_u1ti\",   CONST,  vector_nltuv1ti)\n+BU_P10V_AV_2 (CMPLE_1TI,\t\"cmple_1ti\",    CONST,  vector_ngtv1ti)\n+BU_P10V_AV_2 (CMPLE_U1TI,\t\"cmple_u1ti\",   CONST,  vector_ngtuv1ti)\n+BU_P10V_AV_2 (VNOR_V1TI_UNS,\t\"vnor_v1ti_uns\",CONST,\tnorv1ti3)\n+BU_P10V_AV_2 (VNOR_V1TI,\t\"vnor_v1ti\",\tCONST,\tnorv1ti3)\n+BU_P10V_AV_2 (VCMPNET_P,\t\"vcmpnet_p\",\tCONST,\tvector_ne_v1ti_p)\n+BU_P10V_AV_2 (VCMPAET_P,\t\"vcmpaet_p\",\tCONST,\tvector_ae_v1ti_p)\n+\n+BU_P10V_AV_2 (VMULEUD,\t\"vmuleud\",\tCONST,\tvec_widen_umult_even_v2di)\n+BU_P10V_AV_2 (VMULESD,\t\"vmulesd\",\tCONST,\tvec_widen_smult_even_v2di)\n+BU_P10V_AV_2 (VMULOUD,\t\"vmuloud\",\tCONST,\tvec_widen_umult_odd_v2di)\n+BU_P10V_AV_2 (VMULOSD,\t\"vmulosd\",\tCONST,\tvec_widen_smult_odd_v2di)\n+BU_P10V_AV_2 (VRLQ,\t\t\"vrlq\",\t\tCONST,\tvrotlv1ti3)\n+BU_P10V_AV_2 (VSLQ,\t\t\"vslq\",\t\tCONST,\tvashlv1ti3)\n+BU_P10V_AV_2 (VSRQ,\t\t\"vsrq\",\t\tCONST,\tvlshrv1ti3)\n+BU_P10V_AV_2 (VSRAQ,\t\t\"vsraq\",\tCONST,\tvashrv1ti3)\n+BU_P10V_AV_2 (VRLQNM,\t\"vrlqnm\",\tCONST,\taltivec_vrlqnm)\n+BU_P10V_AV_2 (DIV_V1TI,\t\"div_1ti\",      CONST,  vsx_div_v1ti)\n+BU_P10V_AV_2 (UDIV_V1TI,\t\"udiv_1ti\",     CONST,  vsx_udiv_v1ti)\n+BU_P10V_AV_2 (DIVES_V1TI,\t\"dives\",\tCONST,\tvsx_dives_v1ti)\n+BU_P10V_AV_2 (DIVEU_V1TI,\t\"diveu\",\tCONST,\tvsx_diveu_v1ti)\n+BU_P10V_AV_2 (MODS_V1TI,\t\"mods\",\t\tCONST,\tvsx_mods_v1ti)\n+BU_P10V_AV_2 (MODU_V1TI,\t\"modu\",\t\tCONST,\tvsx_modu_v1ti)\n+\n+BU_P10V_AV_3 (VRLQMI,\t\"vrlqmi\",\tCONST,\taltivec_vrlqmi)\n BU_P10V_AV_3 (VEXTRACTBL, \"vextdubvlx\", CONST, vextractlv16qi)\n BU_P10V_AV_3 (VEXTRACTHL, \"vextduhvlx\", CONST, vextractlv8hi)\n BU_P10V_AV_3 (VEXTRACTWL, \"vextduwvlx\", CONST, vextractlv4si)\n@@ -3025,6 +3067,10 @@ BU_P10_OVERLOAD_2 (CLRR, \"clrr\")\n BU_P10_OVERLOAD_2 (GNB, \"gnb\")\n BU_P10_OVERLOAD_4 (XXEVAL, \"xxeval\")\n BU_P10_OVERLOAD_2 (XXGENPCVM, \"xxgenpcvm\")\n+BU_P10_OVERLOAD_2 (VRLQ, \"vrlq\")\n+BU_P10_OVERLOAD_2 (VSLQ, \"vslq\")\n+BU_P10_OVERLOAD_2 (VSRQ, \"vsrq\")\n+BU_P10_OVERLOAD_2 (VSRAQ, \"vsraq\")\n \n BU_P10_OVERLOAD_3 (EXTRACTL, \"extractl\")\n BU_P10_OVERLOAD_3 (EXTRACTH, \"extracth\")"}, {"sha": "d1f29a5a4dc6305736530b2d099db3ae3ef0eba5", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 135, "deletions": 1, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=f03122f2a7626772fe13ab77f677141377104502", "patch": "@@ -843,6 +843,10 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n     RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },\n   { ALTIVEC_BUILTIN_VEC_CMPEQ, P8V_BUILTIN_VCMPEQUD,\n     RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_CMPEQ, P10V_BUILTIN_VCMPEQUT,\n+    RS6000_BTI_bool_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_CMPEQ, P10V_BUILTIN_VCMPEQUT,\n+    RS6000_BTI_bool_V1TI, RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI, 0 },\n   { ALTIVEC_BUILTIN_VEC_CMPEQ, ALTIVEC_BUILTIN_VCMPEQFP,\n     RS6000_BTI_bool_V4SI, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },\n   { ALTIVEC_BUILTIN_VEC_CMPEQ, VSX_BUILTIN_XVCMPEQDP,\n@@ -889,6 +893,12 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { ALTIVEC_BUILTIN_VEC_CMPGE, VSX_BUILTIN_CMPGE_U2DI,\n     RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI,\n     RS6000_BTI_unsigned_V2DI, 0},\n+\n+  { ALTIVEC_BUILTIN_VEC_CMPGE, P10V_BUILTIN_CMPGE_1TI,\n+    RS6000_BTI_bool_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, 0},\n+  { ALTIVEC_BUILTIN_VEC_CMPGE, P10V_BUILTIN_CMPGE_U1TI,\n+    RS6000_BTI_bool_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, 0},\n   { ALTIVEC_BUILTIN_VEC_CMPGT, ALTIVEC_BUILTIN_VCMPGTUB,\n     RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0 },\n   { ALTIVEC_BUILTIN_VEC_CMPGT, ALTIVEC_BUILTIN_VCMPGTSB,\n@@ -903,8 +913,12 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n     RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },\n   { ALTIVEC_BUILTIN_VEC_CMPGT, P8V_BUILTIN_VCMPGTUD,\n     RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_CMPGT, P10V_BUILTIN_VCMPGTUT,\n+    RS6000_BTI_bool_V1TI, RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI, 0 },\n   { ALTIVEC_BUILTIN_VEC_CMPGT, P8V_BUILTIN_VCMPGTSD,\n     RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_CMPGT, P10V_BUILTIN_VCMPGTST,\n+    RS6000_BTI_bool_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, 0 },\n   { ALTIVEC_BUILTIN_VEC_CMPGT, ALTIVEC_BUILTIN_VCMPGTFP,\n     RS6000_BTI_bool_V4SI, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },\n   { ALTIVEC_BUILTIN_VEC_CMPGT, VSX_BUILTIN_XVCMPGTDP,\n@@ -947,6 +961,11 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { ALTIVEC_BUILTIN_VEC_CMPLE, VSX_BUILTIN_CMPLE_U2DI,\n     RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI,\n     RS6000_BTI_unsigned_V2DI, 0},\n+  { ALTIVEC_BUILTIN_VEC_CMPLE, P10V_BUILTIN_CMPLE_1TI,\n+    RS6000_BTI_bool_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, 0},\n+  { ALTIVEC_BUILTIN_VEC_CMPLE, P10V_BUILTIN_CMPLE_U1TI,\n+    RS6000_BTI_bool_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, 0},\n   { ALTIVEC_BUILTIN_VEC_CMPLT, ALTIVEC_BUILTIN_VCMPGTUB,\n     RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0 },\n   { ALTIVEC_BUILTIN_VEC_CMPLT, ALTIVEC_BUILTIN_VCMPGTSB,\n@@ -1086,6 +1105,11 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { VSX_BUILTIN_VEC_DIV, P10V_BUILTIN_DIVU_V2DI,\n     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n     RS6000_BTI_unsigned_V2DI, 0 },\n+  { VSX_BUILTIN_VEC_DIV, P10V_BUILTIN_DIV_V1TI,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, 0 },\n+  { VSX_BUILTIN_VEC_DIV, P10V_BUILTIN_UDIV_V1TI,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, 0 },\n \n   { P10_BUILTIN_VEC_DIVE, P10V_BUILTIN_DIVES_V4SI,\n     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },\n@@ -1097,6 +1121,11 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { P10_BUILTIN_VEC_DIVE, P10V_BUILTIN_DIVEU_V2DI,\n     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n     RS6000_BTI_unsigned_V2DI, 0 },\n+  { P10_BUILTIN_VEC_DIVE, P10V_BUILTIN_DIVES_V1TI,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, 0 },\n+  { P10_BUILTIN_VEC_DIVE, P10V_BUILTIN_DIVEU_V1TI,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, 0 },\n \n   { P10_BUILTIN_VEC_MOD, P10V_BUILTIN_MODS_V4SI,\n     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },\n@@ -1108,6 +1137,11 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { P10_BUILTIN_VEC_MOD, P10V_BUILTIN_MODU_V2DI,\n     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n     RS6000_BTI_unsigned_V2DI, 0 },\n+  { P10_BUILTIN_VEC_MOD, P10V_BUILTIN_MODS_V1TI,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, 0 },\n+  { P10_BUILTIN_VEC_MOD, P10V_BUILTIN_MODU_V1TI,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, 0 },\n \n   { VSX_BUILTIN_VEC_DOUBLE, VSX_BUILTIN_XVCVSXDDP,\n     RS6000_BTI_V2DF, RS6000_BTI_V2DI, 0, 0 },\n@@ -1973,6 +2007,11 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { ALTIVEC_BUILTIN_VEC_MULE, P8V_BUILTIN_VMULEUW,\n     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V4SI,\n     RS6000_BTI_unsigned_V4SI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_MULE, P10V_BUILTIN_VMULESD,\n+    RS6000_BTI_V1TI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_MULE, P10V_BUILTIN_VMULEUD,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V2DI,\n+    RS6000_BTI_unsigned_V2DI, 0 },\n   { ALTIVEC_BUILTIN_VEC_VMULEUB, ALTIVEC_BUILTIN_VMULEUB,\n     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0 },\n   { ALTIVEC_BUILTIN_VEC_VMULESB, ALTIVEC_BUILTIN_VMULESB,\n@@ -1996,6 +2035,11 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { ALTIVEC_BUILTIN_VEC_MULO, P8V_BUILTIN_VMULOUW,\n     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V4SI,\n     RS6000_BTI_unsigned_V4SI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_MULO, P10V_BUILTIN_VMULOSD,\n+    RS6000_BTI_V1TI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_MULO, P10V_BUILTIN_VMULOUD,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V2DI,\n+    RS6000_BTI_unsigned_V2DI, 0 },\n   { ALTIVEC_BUILTIN_VEC_MULO, ALTIVEC_BUILTIN_VMULOSH,\n     RS6000_BTI_V4SI, RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0 },\n   { ALTIVEC_BUILTIN_VEC_VMULOSH, ALTIVEC_BUILTIN_VMULOSH,\n@@ -2038,6 +2082,16 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },\n   { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V2DI,\n     RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_NOR, P10V_BUILTIN_VNOR_V1TI,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_bool_V1TI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_NOR, P10V_BUILTIN_VNOR_V1TI,\n+    RS6000_BTI_V1TI, RS6000_BTI_bool_V1TI, RS6000_BTI_V1TI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_NOR, P10V_BUILTIN_VNOR_V1TI_UNS,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_NOR, P10V_BUILTIN_VNOR_V1TI_UNS,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI, RS6000_BTI_bool_V1TI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_NOR, P10V_BUILTIN_VNOR_V1TI_UNS,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_bool_V1TI, RS6000_BTI_unsigned_V1TI, 0 },\n   { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V2DI_UNS,\n     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n   { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V2DI_UNS,\n@@ -2299,6 +2353,11 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n   { ALTIVEC_BUILTIN_VEC_RL, P8V_BUILTIN_VRLD,\n     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_RL, P10V_BUILTIN_VRLQ,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_unsigned_V1TI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_RL, P10V_BUILTIN_VRLQ,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, 0 },\n   { ALTIVEC_BUILTIN_VEC_VRLW, ALTIVEC_BUILTIN_VRLW,\n     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_unsigned_V4SI, 0 },\n   { ALTIVEC_BUILTIN_VEC_VRLW, ALTIVEC_BUILTIN_VRLW,\n@@ -2317,12 +2376,23 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { P9V_BUILTIN_VEC_RLMI, P9V_BUILTIN_VRLDMI,\n     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI },\n+  { P9V_BUILTIN_VEC_RLMI, P10V_BUILTIN_VRLQMI,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI,\n+    RS6000_BTI_V1TI, RS6000_BTI_unsigned_V1TI },\n+  { P9V_BUILTIN_VEC_RLMI, P10V_BUILTIN_VRLQMI,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI },\n   { P9V_BUILTIN_VEC_RLNM, P9V_BUILTIN_VRLWNM,\n     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,\n     RS6000_BTI_unsigned_V4SI, 0 },\n   { P9V_BUILTIN_VEC_RLNM, P9V_BUILTIN_VRLDNM,\n     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n     RS6000_BTI_unsigned_V2DI, 0 },\n+  { P9V_BUILTIN_VEC_RLNM, P10V_BUILTIN_VRLQNM,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, 0 },\n+  { P9V_BUILTIN_VEC_RLNM, P10V_BUILTIN_VRLQNM,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_unsigned_V1TI, 0 },\n   { ALTIVEC_BUILTIN_VEC_SL, ALTIVEC_BUILTIN_VSLB,\n     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_unsigned_V16QI, 0 },\n   { ALTIVEC_BUILTIN_VEC_SL, ALTIVEC_BUILTIN_VSLB,\n@@ -2339,6 +2409,11 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n   { ALTIVEC_BUILTIN_VEC_SL, P8V_BUILTIN_VSLD,\n     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_SL, P10V_BUILTIN_VSLQ,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_unsigned_V1TI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_SL, P10V_BUILTIN_VSLQ,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, 0 },\n   { ALTIVEC_BUILTIN_VEC_SQRT, VSX_BUILTIN_XVSQRTDP,\n     RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0, 0 },\n   { ALTIVEC_BUILTIN_VEC_SQRT, VSX_BUILTIN_XVSQRTSP,\n@@ -2535,6 +2610,11 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n   { ALTIVEC_BUILTIN_VEC_SR, P8V_BUILTIN_VSRD,\n     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_SR, P10V_BUILTIN_VSRQ,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_unsigned_V1TI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_SR, P10V_BUILTIN_VSRQ,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, 0 },\n   { ALTIVEC_BUILTIN_VEC_VSRW, ALTIVEC_BUILTIN_VSRW,\n     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_unsigned_V4SI, 0 },\n   { ALTIVEC_BUILTIN_VEC_VSRW, ALTIVEC_BUILTIN_VSRW,\n@@ -2563,6 +2643,11 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n   { ALTIVEC_BUILTIN_VEC_SRA, P8V_BUILTIN_VSRAD,\n     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_SRA, P10V_BUILTIN_VSRAQ,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_unsigned_V1TI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_SRA, P10V_BUILTIN_VSRAQ,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, 0 },\n   { ALTIVEC_BUILTIN_VEC_VSRAW, ALTIVEC_BUILTIN_VSRAW,\n     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_unsigned_V4SI, 0 },\n   { ALTIVEC_BUILTIN_VEC_VSRAW, ALTIVEC_BUILTIN_VSRAW,\n@@ -4180,12 +4265,16 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI },\n   { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P8V_BUILTIN_VCMPGTUD_P,\n     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI },\n+  { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P10V_BUILTIN_VCMPGTUT_P,\n+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI },\n   { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P8V_BUILTIN_VCMPGTSD_P,\n     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI },\n   { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P8V_BUILTIN_VCMPGTSD_P,\n     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI },\n   { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P8V_BUILTIN_VCMPGTSD_P,\n     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V2DI, RS6000_BTI_V2DI },\n+  { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P10V_BUILTIN_VCMPGTST_P,\n+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V1TI, RS6000_BTI_V1TI },\n   { ALTIVEC_BUILTIN_VEC_VCMPGT_P, ALTIVEC_BUILTIN_VCMPGTFP_P,\n     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V4SF, RS6000_BTI_V4SF },\n   { ALTIVEC_BUILTIN_VEC_VCMPGT_P, VSX_BUILTIN_XVCMPGTDP_P,\n@@ -4250,6 +4339,10 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V2DI, RS6000_BTI_V2DI },\n   { ALTIVEC_BUILTIN_VEC_VCMPEQ_P, P8V_BUILTIN_VCMPEQUD_P,\n     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI },\n+  { ALTIVEC_BUILTIN_VEC_VCMPEQ_P, P10V_BUILTIN_VCMPEQUT_P,\n+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V1TI, RS6000_BTI_V1TI },\n+  { ALTIVEC_BUILTIN_VEC_VCMPEQ_P, P10V_BUILTIN_VCMPEQUT_P,\n+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI },\n   { ALTIVEC_BUILTIN_VEC_VCMPEQ_P, ALTIVEC_BUILTIN_VCMPEQFP_P,\n     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V4SF, RS6000_BTI_V4SF },\n   { ALTIVEC_BUILTIN_VEC_VCMPEQ_P, VSX_BUILTIN_XVCMPEQDP_P,\n@@ -4301,12 +4394,16 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI },\n   { ALTIVEC_BUILTIN_VEC_VCMPGE_P, P8V_BUILTIN_VCMPGTUD_P,\n     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI },\n+  { ALTIVEC_BUILTIN_VEC_VCMPGE_P, P10V_BUILTIN_VCMPGTUT_P,\n+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI },\n   { ALTIVEC_BUILTIN_VEC_VCMPGE_P, P8V_BUILTIN_VCMPGTSD_P,\n     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI },\n   { ALTIVEC_BUILTIN_VEC_VCMPGE_P, P8V_BUILTIN_VCMPGTSD_P,\n     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI },\n   { ALTIVEC_BUILTIN_VEC_VCMPGE_P, P8V_BUILTIN_VCMPGTSD_P,\n     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V2DI, RS6000_BTI_V2DI },\n+  { ALTIVEC_BUILTIN_VEC_VCMPGE_P, P10V_BUILTIN_VCMPGTST_P,\n+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V1TI, RS6000_BTI_V1TI },\n   { ALTIVEC_BUILTIN_VEC_VCMPGE_P, ALTIVEC_BUILTIN_VCMPGEFP_P,\n     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V4SF, RS6000_BTI_V4SF },\n   { ALTIVEC_BUILTIN_VEC_VCMPGE_P, VSX_BUILTIN_XVCMPGEDP_P,\n@@ -4955,6 +5052,12 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { ALTIVEC_BUILTIN_VEC_CMPNE, P9V_BUILTIN_CMPNEW,\n     RS6000_BTI_bool_V4SI, RS6000_BTI_unsigned_V4SI,\n     RS6000_BTI_unsigned_V4SI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_CMPNE, P10V_BUILTIN_CMPNET,\n+    RS6000_BTI_bool_V1TI, RS6000_BTI_V1TI,\n+    RS6000_BTI_V1TI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_CMPNE, P10V_BUILTIN_CMPNET,\n+    RS6000_BTI_bool_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, 0 },\n \n   /* The following 2 entries have been deprecated.  */\n   { P9V_BUILTIN_VEC_VCMPNE_P, P9V_BUILTIN_VCMPNEB_P,\n@@ -5055,6 +5158,10 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { P9V_BUILTIN_VEC_VCMPNE_P, P9V_BUILTIN_VCMPNED_P,\n     RS6000_BTI_INTSI, RS6000_BTI_bool_V2DI,\n     RS6000_BTI_bool_V2DI, 0 },\n+  { P9V_BUILTIN_VEC_VCMPNE_P, P10V_BUILTIN_VCMPNET_P,\n+    RS6000_BTI_INTSI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, 0 },\n+  { P9V_BUILTIN_VEC_VCMPNE_P, P10V_BUILTIN_VCMPNET_P,\n+    RS6000_BTI_INTSI, RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI, 0 },\n \n   { P9V_BUILTIN_VEC_VCMPNE_P, P9V_BUILTIN_VCMPNEFP_P,\n     RS6000_BTI_INTSI, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },\n@@ -5160,7 +5267,10 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { P9V_BUILTIN_VEC_VCMPAE_P, P9V_BUILTIN_VCMPAED_P,\n     RS6000_BTI_INTSI, RS6000_BTI_bool_V2DI,\n     RS6000_BTI_bool_V2DI, 0 },\n-\n+  { P9V_BUILTIN_VEC_VCMPAE_P, P10V_BUILTIN_VCMPAET_P,\n+    RS6000_BTI_INTSI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, 0 },\n+  { P9V_BUILTIN_VEC_VCMPAE_P, P10V_BUILTIN_VCMPAET_P,\n+    RS6000_BTI_INTSI, RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI, 0 },\n   { P9V_BUILTIN_VEC_VCMPAE_P, P9V_BUILTIN_VCMPAEFP_P,\n     RS6000_BTI_INTSI, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },\n   { P9V_BUILTIN_VEC_VCMPAE_P, P9V_BUILTIN_VCMPAEDP_P,\n@@ -12552,12 +12662,14 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case ALTIVEC_BUILTIN_VCMPEQUH:\n     case ALTIVEC_BUILTIN_VCMPEQUW:\n     case P8V_BUILTIN_VCMPEQUD:\n+    case P10V_BUILTIN_VCMPEQUT:\n       fold_compare_helper (gsi, EQ_EXPR, stmt);\n       return true;\n \n     case P9V_BUILTIN_CMPNEB:\n     case P9V_BUILTIN_CMPNEH:\n     case P9V_BUILTIN_CMPNEW:\n+    case P10V_BUILTIN_CMPNET:\n       fold_compare_helper (gsi, NE_EXPR, stmt);\n       return true;\n \n@@ -12569,6 +12681,8 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case VSX_BUILTIN_CMPGE_U4SI:\n     case VSX_BUILTIN_CMPGE_2DI:\n     case VSX_BUILTIN_CMPGE_U2DI:\n+    case P10V_BUILTIN_CMPGE_1TI:\n+    case P10V_BUILTIN_CMPGE_U1TI:\n       fold_compare_helper (gsi, GE_EXPR, stmt);\n       return true;\n \n@@ -12580,6 +12694,8 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case ALTIVEC_BUILTIN_VCMPGTUW:\n     case P8V_BUILTIN_VCMPGTUD:\n     case P8V_BUILTIN_VCMPGTSD:\n+    case P10V_BUILTIN_VCMPGTUT:\n+    case P10V_BUILTIN_VCMPGTST:\n       fold_compare_helper (gsi, GT_EXPR, stmt);\n       return true;\n \n@@ -12591,6 +12707,8 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case VSX_BUILTIN_CMPLE_U4SI:\n     case VSX_BUILTIN_CMPLE_2DI:\n     case VSX_BUILTIN_CMPLE_U2DI:\n+    case P10V_BUILTIN_CMPLE_1TI:\n+    case P10V_BUILTIN_CMPLE_U1TI:\n       fold_compare_helper (gsi, LE_EXPR, stmt);\n       return true;\n \n@@ -13318,6 +13436,8 @@ rs6000_init_builtins (void)\n \t\t\t\t\t    ? \"__vector __bool long\"\n \t\t\t\t\t    : \"__vector __bool long long\",\n \t\t\t\t\t    bool_long_long_type_node, 2);\n+  bool_V1TI_type_node = rs6000_vector_type (\"__vector __bool __int128\",\n+\t\t\t\t\t    intTI_type_node, 1);\n   pixel_V8HI_type_node = rs6000_vector_type (\"__vector __pixel\",\n \t\t\t\t\t     pixel_type_node, 8);\n \n@@ -13515,6 +13635,10 @@ altivec_init_builtins (void)\n     = build_function_type_list (integer_type_node,\n \t\t\t\tinteger_type_node, V2DI_type_node,\n \t\t\t\tV2DI_type_node, NULL_TREE);\n+  tree int_ftype_int_v1ti_v1ti\n+    = build_function_type_list (integer_type_node,\n+\t\t\t\tinteger_type_node, V1TI_type_node,\n+\t\t\t\tV1TI_type_node, NULL_TREE);\n   tree void_ftype_v4si\n     = build_function_type_list (void_type_node, V4SI_type_node, NULL_TREE);\n   tree v8hi_ftype_void\n@@ -13882,6 +14006,9 @@ altivec_init_builtins (void)\n \tcase E_VOIDmode:\n \t  type = int_ftype_int_opaque_opaque;\n \t  break;\n+\tcase E_V1TImode:\n+\t  type = int_ftype_int_v1ti_v1ti;\n+\t  break;\n \tcase E_V2DImode:\n \t  type = int_ftype_int_v2di_v2di;\n \t  break;\n@@ -14487,12 +14614,16 @@ builtin_function_type (machine_mode mode_ret, machine_mode mode_arg0,\n     case P10V_BUILTIN_XXGENPCVM_V2DI:\n     case P10V_BUILTIN_DIVEU_V4SI:\n     case P10V_BUILTIN_DIVEU_V2DI:\n+    case P10V_BUILTIN_DIVEU_V1TI:\n     case P10V_BUILTIN_DIVU_V4SI:\n     case P10V_BUILTIN_DIVU_V2DI:\n+    case P10V_BUILTIN_MODU_V1TI:\n     case P10V_BUILTIN_MODU_V2DI:\n     case P10V_BUILTIN_MODU_V4SI:\n     case P10V_BUILTIN_MULHU_V2DI:\n     case P10V_BUILTIN_MULHU_V4SI:\n+    case P10V_BUILTIN_VMULEUD:\n+    case P10V_BUILTIN_VMULOUD:\n       h.uns_p[0] = 1;\n       h.uns_p[1] = 1;\n       h.uns_p[2] = 1;\n@@ -14592,10 +14723,13 @@ builtin_function_type (machine_mode mode_ret, machine_mode mode_arg0,\n     case VSX_BUILTIN_CMPGE_U8HI:\n     case VSX_BUILTIN_CMPGE_U4SI:\n     case VSX_BUILTIN_CMPGE_U2DI:\n+    case P10V_BUILTIN_CMPGE_U1TI:\n     case ALTIVEC_BUILTIN_VCMPGTUB:\n     case ALTIVEC_BUILTIN_VCMPGTUH:\n     case ALTIVEC_BUILTIN_VCMPGTUW:\n     case P8V_BUILTIN_VCMPGTUD:\n+    case P10V_BUILTIN_VCMPGTUT:\n+    case P10V_BUILTIN_VCMPEQUT:\n       h.uns_p[1] = 1;\n       h.uns_p[2] = 1;\n       break;"}, {"sha": "328dc10a61b25e06b7d30b4c64b675e4bf523f65", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f03122f2a7626772fe13ab77f677141377104502", "patch": "@@ -20217,6 +20217,7 @@ rs6000_handle_altivec_attribute (tree *node,\n     case 'b':\n       switch (mode)\n \t{\n+\tcase E_TImode: case E_V1TImode: result = bool_V1TI_type_node; break;\n \tcase E_DImode: case E_V2DImode: result = bool_V2DI_type_node; break;\n \tcase E_SImode: case E_V4SImode: result = bool_V4SI_type_node; break;\n \tcase E_HImode: case E_V8HImode: result = bool_V8HI_type_node; break;"}, {"sha": "4ca6372435d68df53822c6462d2da9c64e339876", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=f03122f2a7626772fe13ab77f677141377104502", "patch": "@@ -2321,7 +2321,6 @@ extern int frame_pointer_needed;\n #define RS6000_BTM_MMA\t\tMASK_MMA\t/* ISA 3.1 MMA.  */\n #define RS6000_BTM_P10\t\tMASK_POWER10\n \n-\n #define RS6000_BTM_COMMON\t(RS6000_BTM_ALTIVEC\t\t\t\\\n \t\t\t\t | RS6000_BTM_VSX\t\t\t\\\n \t\t\t\t | RS6000_BTM_P8_VECTOR\t\t\t\\\n@@ -2434,6 +2433,7 @@ enum rs6000_builtin_type_index\n   RS6000_BTI_bool_V8HI,          /* __vector __bool short */\n   RS6000_BTI_bool_V4SI,          /* __vector __bool int */\n   RS6000_BTI_bool_V2DI,          /* __vector __bool long */\n+  RS6000_BTI_bool_V1TI,          /* __vector __bool 128-bit */\n   RS6000_BTI_pixel_V8HI,         /* __vector __pixel */\n   RS6000_BTI_long,\t         /* long_integer_type_node */\n   RS6000_BTI_unsigned_long,      /* long_unsigned_type_node */\n@@ -2487,6 +2487,7 @@ enum rs6000_builtin_type_index\n #define bool_V8HI_type_node\t      (rs6000_builtin_types[RS6000_BTI_bool_V8HI])\n #define bool_V4SI_type_node\t      (rs6000_builtin_types[RS6000_BTI_bool_V4SI])\n #define bool_V2DI_type_node\t      (rs6000_builtin_types[RS6000_BTI_bool_V2DI])\n+#define bool_V1TI_type_node\t      (rs6000_builtin_types[RS6000_BTI_bool_V1TI])\n #define pixel_V8HI_type_node\t      (rs6000_builtin_types[RS6000_BTI_pixel_V8HI])\n \n #define long_long_integer_type_internal_node  (rs6000_builtin_types[RS6000_BTI_long_long])"}, {"sha": "ea88a97322fcb66b147c235483130f194367f3c1", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 185, "deletions": 1, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=f03122f2a7626772fe13ab77f677141377104502", "patch": "@@ -53,7 +53,7 @@\n (define_mode_iterator VEC_N [V4SI V4SF V2DI V2DF V1TI KF TF])\n \n ;; Vector comparison modes\n-(define_mode_iterator VEC_C [V16QI V8HI V4SI V2DI V4SF V2DF])\n+(define_mode_iterator VEC_C [V16QI V8HI V4SI V2DI V4SF V2DF V1TI])\n \n ;; Vector init/extract modes\n (define_mode_iterator VEC_E [V16QI V8HI V4SI V2DI V4SF V2DF])\n@@ -697,13 +697,31 @@\n   operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n })\n \n+(define_expand \"vector_nltv1ti\"\n+  [(set (match_operand:V1TI 3 \"vlogical_operand\")\n+\t(gt:V1TI (match_operand:V1TI 2 \"vlogical_operand\")\n+\t\t (match_operand:V1TI 1 \"vlogical_operand\")))\n+   (set (match_operand:V1TI 0 \"vlogical_operand\")\n+        (not:V1TI (match_dup 3)))]\n+  \"TARGET_POWER10\"\n+{\n+  operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n+})\n+\n (define_expand \"vector_gtu<mode>\"\n   [(set (match_operand:VEC_I 0 \"vint_operand\")\n \t(gtu:VEC_I (match_operand:VEC_I 1 \"vint_operand\")\n \t\t   (match_operand:VEC_I 2 \"vint_operand\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\")\n \n+(define_expand \"vector_gtuv1ti\"\n+  [(set (match_operand:V1TI 0 \"altivec_register_operand\")\n+\t(gtu:V1TI (match_operand:V1TI 1 \"altivec_register_operand\")\n+\t\t  (match_operand:V1TI 2 \"altivec_register_operand\")))]\n+  \"TARGET_POWER10\"\n+  \"\")\n+\n ; >= for integer vectors: swap operands and apply not-greater-than\n (define_expand \"vector_nltu<mode>\"\n   [(set (match_operand:VEC_I 3 \"vlogical_operand\")\n@@ -716,6 +734,17 @@\n   operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n })\n \n+(define_expand \"vector_nltuv1ti\"\n+  [(set (match_operand:V1TI 3 \"vlogical_operand\")\n+\t(gtu:V1TI (match_operand:V1TI 2 \"vlogical_operand\")\n+\t\t  (match_operand:V1TI 1 \"vlogical_operand\")))\n+   (set (match_operand:V1TI 0 \"vlogical_operand\")\n+\t(not:V1TI (match_dup 3)))]\n+  \"TARGET_POWER10\"\n+{\n+  operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n+})\n+\n (define_expand \"vector_geu<mode>\"\n   [(set (match_operand:VEC_I 0 \"vint_operand\")\n \t(geu:VEC_I (match_operand:VEC_I 1 \"vint_operand\")\n@@ -735,6 +764,17 @@\n   operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n })\n \n+(define_expand \"vector_ngtv1ti\"\n+  [(set (match_operand:V1TI 3 \"vlogical_operand\")\n+\t(gt:V1TI (match_operand:V1TI 1 \"vlogical_operand\")\n+\t\t (match_operand:V1TI 2 \"vlogical_operand\")))\n+   (set (match_operand:V1TI 0 \"vlogical_operand\")\n+        (not:V1TI (match_dup 3)))]\n+  \"TARGET_POWER10\"\n+{\n+  operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n+})\n+\n (define_expand \"vector_ngtu<mode>\"\n   [(set (match_operand:VEC_I 3 \"vlogical_operand\")\n \t(gtu:VEC_I (match_operand:VEC_I 1 \"vlogical_operand\")\n@@ -746,6 +786,17 @@\n   operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n })\n \n+(define_expand \"vector_ngtuv1ti\"\n+  [(set (match_operand:V1TI 3 \"vlogical_operand\")\n+\t(gtu:V1TI (match_operand:V1TI 1 \"vlogical_operand\")\n+\t\t  (match_operand:V1TI 2 \"vlogical_operand\")))\n+   (set (match_operand:V1TI 0 \"vlogical_operand\")\n+        (not:V1TI (match_dup 3)))]\n+  \"TARGET_POWER10\"\n+{\n+  operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n+})\n+\n ; There are 14 possible vector FP comparison operators, gt and eq of them have\n ; been expanded above, so just support 12 remaining operators here.\n \n@@ -894,6 +945,18 @@\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\")\n \n+(define_expand \"vector_eq_v1ti_p\"\n+  [(parallel\n+    [(set (reg:CC CR6_REGNO)\n+\t  (unspec:CC [(eq:CC (match_operand:V1TI 1 \"altivec_register_operand\")\n+\t\t\t     (match_operand:V1TI 2 \"altivec_register_operand\"))]\n+\t\t     UNSPEC_PREDICATE))\n+     (set (match_operand:V1TI 0 \"vlogical_operand\")\n+\t  (eq:V1TI (match_dup 1)\n+\t\t   (match_dup 2)))])]\n+  \"TARGET_POWER10\"\n+  \"\")\n+\n ;; This expansion handles the V16QI, V8HI, and V4SI modes in the\n ;; implementation of the vec_all_ne built-in functions on Power9.\n (define_expand \"vector_ne_<mode>_p\"\n@@ -976,6 +1039,23 @@\n   operands[3] = gen_reg_rtx (V2DImode);\n })\n \n+(define_expand \"vector_ne_v1ti_p\"\n+  [(parallel\n+    [(set (reg:CC CR6_REGNO)\n+\t  (unspec:CC [(eq:CC (match_operand:V1TI 1 \"altivec_register_operand\")\n+\t\t\t     (match_operand:V1TI 2 \"altivec_register_operand\"))]\n+\t\t     UNSPEC_PREDICATE))\n+     (set (match_dup 3)\n+\t  (eq:V1TI (match_dup 1)\n+\t\t   (match_dup 2)))])\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(eq:SI (reg:CC CR6_REGNO)\n+\t       (const_int 0)))]\n+  \"TARGET_POWER10\"\n+{\n+  operands[3] = gen_reg_rtx (V1TImode);\n+})\n+\n ;; This expansion handles the V2DI mode in the implementation of the\n ;; vec_any_eq built-in function on Power9.\n ;;\n@@ -1002,6 +1082,26 @@\n   operands[3] = gen_reg_rtx (V2DImode);\n })\n \n+(define_expand \"vector_ae_v1ti_p\"\n+  [(parallel\n+    [(set (reg:CC CR6_REGNO)\n+\t  (unspec:CC [(eq:CC (match_operand:V1TI 1 \"altivec_register_operand\")\n+\t\t\t     (match_operand:V1TI 2 \"altivec_register_operand\"))]\n+\t\t     UNSPEC_PREDICATE))\n+     (set (match_dup 3)\n+\t  (eq:V1TI (match_dup 1)\n+\t\t   (match_dup 2)))])\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(eq:SI (reg:CC CR6_REGNO)\n+\t       (const_int 0)))\n+   (set (match_dup 0)\n+\t(xor:SI (match_dup 0)\n+\t\t(const_int 1)))]\n+  \"TARGET_POWER10\"\n+{\n+  operands[3] = gen_reg_rtx (V1TImode);\n+})\n+\n ;; This expansion handles the V4SF and V2DF modes in the Power9\n ;; implementation of the vec_all_ne built-in functions.  Note that the\n ;; expansions for this pattern with these modes makes no use of power9-\n@@ -1061,6 +1161,18 @@\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\")\n \n+(define_expand \"vector_gt_v1ti_p\"\n+  [(parallel\n+    [(set (reg:CC CR6_REGNO)\n+\t  (unspec:CC [(gt:CC (match_operand:V1TI 1 \"vlogical_operand\")\n+\t\t\t     (match_operand:V1TI 2 \"vlogical_operand\"))]\n+\t\t     UNSPEC_PREDICATE))\n+     (set (match_operand:V1TI 0 \"vlogical_operand\")\n+\t  (gt:V1TI (match_dup 1)\n+\t\t   (match_dup 2)))])]\n+  \"TARGET_POWER10\"\n+  \"\")\n+\n (define_expand \"vector_ge_<mode>_p\"\n   [(parallel\n     [(set (reg:CC CR6_REGNO)\n@@ -1085,6 +1197,18 @@\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\")\n \n+(define_expand \"vector_gtu_v1ti_p\"\n+  [(parallel\n+    [(set (reg:CC CR6_REGNO)\n+\t  (unspec:CC [(gtu:CC (match_operand:V1TI 1 \"altivec_register_operand\")\n+\t\t\t      (match_operand:V1TI 2 \"altivec_register_operand\"))]\n+\t\t     UNSPEC_PREDICATE))\n+     (set (match_operand:V1TI 0 \"altivec_register_operand\")\n+\t  (gtu:V1TI (match_dup 1)\n+\t\t    (match_dup 2)))])]\n+  \"TARGET_POWER10\"\n+  \"\")\n+\n ;; AltiVec/VSX predicates.\n \n ;; This expansion is triggered during expansion of predicate built-in\n@@ -1460,6 +1584,20 @@\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\")\n \n+(define_expand \"vrotlv1ti3\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n+        (rotate:V1TI (match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n+                     (match_operand:V1TI 2 \"vsx_register_operand\" \"v\")))]\n+  \"TARGET_POWER10\"\n+{\n+  /* Shift amount in needs to be put in bits[57:63] of 128-bit operand2. */\n+  rtx tmp = gen_reg_rtx (V1TImode);\n+\n+  emit_insn (gen_xxswapd_v1ti (tmp, operands[2]));\n+  emit_insn (gen_altivec_vrlq (operands[0], operands[1], tmp));\n+  DONE;\n+})\n+\n ;; Expanders for rotatert to make use of vrotl\n (define_expand \"vrotr<mode>3\"\n   [(set (match_operand:VEC_I 0 \"vint_operand\")\n@@ -1481,6 +1619,21 @@\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\")\n \n+;; No immediate version of this 128-bit instruction\n+(define_expand \"vashlv1ti3\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n+\t(ashift:V1TI (match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n+\t\t     (match_operand:V1TI 2 \"vsx_register_operand\" \"v\")))]\n+  \"TARGET_POWER10\"\n+{\n+  /* Shift amount in needs to be put in bits[57:63] of 128-bit operand2. */\n+  rtx tmp = gen_reg_rtx (V1TImode);\n+\n+  emit_insn (gen_xxswapd_v1ti (tmp, operands[2]));\n+  emit_insn (gen_altivec_vslq (operands[0], operands[1], tmp));\n+  DONE;\n+})\n+\n ;; Expanders for logical shift right on each vector element\n (define_expand \"vlshr<mode>3\"\n   [(set (match_operand:VEC_I 0 \"vint_operand\")\n@@ -1489,13 +1642,44 @@\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\")\n \n+;; No immediate version of this 128-bit instruction\n+(define_expand \"vlshrv1ti3\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n+\t(lshiftrt:V1TI (match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n+\t\t       (match_operand:V1TI 2 \"vsx_register_operand\" \"v\")))]\n+  \"TARGET_POWER10\"\n+{\n+  /* Shift amount in needs to be put into bits[57:63] of 128-bit operand2. */\n+  rtx tmp = gen_reg_rtx (V1TImode);\n+\n+  emit_insn (gen_xxswapd_v1ti (tmp, operands[2]));\n+  emit_insn (gen_altivec_vsrq (operands[0], operands[1], tmp));\n+  DONE;\n+})\n+\n ;; Expanders for arithmetic shift right on each vector element\n (define_expand \"vashr<mode>3\"\n   [(set (match_operand:VEC_I 0 \"vint_operand\")\n \t(ashiftrt:VEC_I (match_operand:VEC_I 1 \"vint_operand\")\n \t\t\t(match_operand:VEC_I 2 \"vint_operand\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\")\n+\n+;; No immediate version of this 128-bit instruction\n+(define_expand \"vashrv1ti3\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n+\t(ashiftrt:V1TI (match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n+\t\t       (match_operand:V1TI 2 \"vsx_register_operand\" \"v\")))]\n+  \"TARGET_POWER10\"\n+{\n+  /* Shift amount in needs to be put into bits[57:63] of 128-bit operand2. */\n+  rtx tmp = gen_reg_rtx (V1TImode);\n+\n+  emit_insn (gen_xxswapd_v1ti (tmp, operands[2]));\n+  emit_insn (gen_altivec_vsraq (operands[0], operands[1], tmp));\n+  DONE;\n+})\n+\n \f\n ;; Vector reduction expanders for VSX\n ; The (VEC_reduc:..."}, {"sha": "5403d02151034658e8031e1f795b45e9cebfe6b9", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=f03122f2a7626772fe13ab77f677141377104502", "patch": "@@ -302,6 +302,12 @@\n    UNSPEC_VSX_XXSPLTD\n    UNSPEC_VSX_DIVSD\n    UNSPEC_VSX_DIVUD\n+   UNSPEC_VSX_DIVSQ\n+   UNSPEC_VSX_DIVUQ\n+   UNSPEC_VSX_DIVESQ\n+   UNSPEC_VSX_DIVEUQ\n+   UNSPEC_VSX_MODSQ\n+   UNSPEC_VSX_MODUQ\n    UNSPEC_VSX_MULSD\n    UNSPEC_VSX_SIGN_EXTEND\n    UNSPEC_VSX_XVCVBF16SPN\n@@ -1781,6 +1787,61 @@\n }\n   [(set_attr \"type\" \"div\")])\n \n+;; Vector integer signed/unsigned divide\n+(define_insn \"vsx_div_v1ti\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 2 \"vsx_register_operand\" \"v\")]\n+\t\t     UNSPEC_VSX_DIVSQ))]\n+  \"TARGET_POWER10\"\n+  \"vdivsq %0,%1,%2\"\n+  [(set_attr \"type\" \"div\")])\n+\n+(define_insn \"vsx_udiv_v1ti\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 2 \"vsx_register_operand\" \"v\")]\n+\t\t     UNSPEC_VSX_DIVUQ))]\n+  \"TARGET_POWER10\"\n+  \"vdivuq %0,%1,%2\"\n+  [(set_attr \"type\" \"div\")])\n+\n+(define_insn \"vsx_dives_v1ti\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 2 \"vsx_register_operand\" \"v\")]\n+\t\t     UNSPEC_VSX_DIVESQ))]\n+  \"TARGET_POWER10\"\n+  \"vdivesq %0,%1,%2\"\n+  [(set_attr \"type\" \"div\")])\n+\n+(define_insn \"vsx_diveu_v1ti\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 2 \"vsx_register_operand\" \"v\")]\n+\t\t     UNSPEC_VSX_DIVEUQ))]\n+  \"TARGET_POWER10\"\n+  \"vdiveuq %0,%1,%2\"\n+  [(set_attr \"type\" \"div\")])\n+\n+(define_insn \"vsx_mods_v1ti\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 2 \"vsx_register_operand\" \"v\")]\n+\t\t     UNSPEC_VSX_MODSQ))]\n+  \"TARGET_POWER10\"\n+  \"vmodsq %0,%1,%2\"\n+  [(set_attr \"type\" \"div\")])\n+\n+(define_insn \"vsx_modu_v1ti\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 2 \"vsx_register_operand\" \"v\")]\n+\t\t     UNSPEC_VSX_MODUQ))]\n+  \"TARGET_POWER10\"\n+  \"vmoduq %0,%1,%2\"\n+  [(set_attr \"type\" \"div\")])\n+\n ;; *tdiv* instruction returning the FG flag\n (define_expand \"vsx_tdiv<mode>3_fg\"\n   [(set (match_dup 3)\n@@ -3126,6 +3187,21 @@\n   \"xxpermdi %x0,%x1,%x1,2\"\n   [(set_attr \"type\" \"vecperm\")])\n \n+;; Swap upper/lower 64-bit values in a 128-bit vector\n+(define_insn \"xxswapd_v1ti\"\n+  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n+     (subreg:V1TI\n+\t  (vec_select:V2DI\n+\t    (subreg:V2DI\n+\t      (match_operand:V1TI 1 \"vsx_register_operand\" \"v\") 0 )\n+\t  (parallel [(const_int 1)(const_int 0)]))\n+           0))]\n+  \"TARGET_POWER10\"\n+;; AIX does not support extended mnemonic xxswapd.  Use the basic\n+;; mnemonic xxpermdi instead.\n+  \"xxpermdi %x0,%x1,%x1,2\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n (define_insn \"xxgenpcvm_<mode>_internal\"\n   [(set (match_operand:VSX_EXTRACT_I4 0 \"altivec_register_operand\" \"=wa\")\n \t(unspec:VSX_EXTRACT_I4\n@@ -5525,6 +5601,19 @@\n   \"vcmpneb %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n+;; Vector Compare Not Equal v1ti (specified/not+eq:)\n+(define_expand \"vcmpnet\"\n+  [(set (match_operand:V1TI 0 \"altivec_register_operand\")\n+\t(not:V1TI\n+\t  (eq:V1TI (match_operand:V1TI 1 \"altivec_register_operand\")\n+\t\t   (match_operand:V1TI 2 \"altivec_register_operand\"))))]\n+   \"TARGET_POWER10\"\n+{\n+  emit_insn (gen_eqvv1ti3 (operands[0], operands[1], operands[2]));\n+  emit_insn (gen_one_cmplv1ti2 (operands[0], operands[0]));\n+  DONE;\n+})\n+\n ;; Vector Compare Not Equal or Zero Byte\n (define_insn \"vcmpnezb\"\n   [(set (match_operand:V16QI 0 \"altivec_register_operand\" \"=v\")"}, {"sha": "47b919c7e1bee19d4d51e69c68c64633875d28d2", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03122f2a7626772fe13ab77f677141377104502/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=f03122f2a7626772fe13ab77f677141377104502", "patch": "@@ -20174,6 +20174,177 @@ Generate PCV from specified Mask size, as if implemented by the\n immediate value is either 0, 1, 2 or 3.\n @findex vec_genpcvm\n \n+@smallexample\n+@exdent vector unsigned __int128 vec_rl (vector unsigned __int128 A,\n+                                         vector unsigned __int128 B);\n+@exdent vector signed __int128 vec_rl (vector signed __int128 A,\n+                                       vector unsigned __int128 B);\n+@end smallexample\n+\n+Result value: Each element of R is obtained by rotating the corresponding element\n+of A left by the number of bits specified by the corresponding element of B.\n+\n+\n+@smallexample\n+@exdent vector unsigned __int128 vec_rlmi (vector unsigned __int128,\n+                                           vector unsigned __int128,\n+                                           vector unsigned __int128);\n+@exdent vector signed __int128 vec_rlmi (vector signed __int128,\n+                                         vector signed __int128,\n+                                         vector unsigned __int128);\n+@end smallexample\n+\n+Returns the result of rotating the first input and inserting it under mask\n+into the second input.  The first bit in the mask, the last bit in the mask are\n+obtained from the two 7-bit fields bits [108:115] and bits [117:123]\n+respectively of the second input.  The shift is obtained from the third input\n+in the 7-bit field [125:131] where all bits counted from zero at the left.\n+\n+@smallexample\n+@exdent vector unsigned __int128 vec_rlnm (vector unsigned __int128,\n+                                           vector unsigned __int128,\n+                                           vector unsigned __int128);\n+@exdent vector signed __int128 vec_rlnm (vector signed __int128,\n+                                         vector unsigned __int128,\n+                                         vector unsigned __int128);\n+@end smallexample\n+\n+Returns the result of rotating the first input and ANDing it with a mask.  The\n+first bit in the mask and the last bit in the mask are obtained from the two\n+7-bit fields bits [117:123] and bits [125:131] respectively of the second\n+input.  The shift is obtained from the third input in the 7-bit field bits\n+[125:131] where all bits counted from zero at the left.\n+\n+@smallexample\n+@exdent vector unsigned __int128 vec_sl(vector unsigned __int128 A, vector unsigned __int128 B);\n+@exdent vector signed __int128 vec_sl(vector signed __int128 A, vector unsigned __int128 B);\n+@end smallexample\n+\n+Result value: Each element of R is obtained by shifting the corresponding element of\n+A left by the number of bits specified by the corresponding element of B.\n+\n+@smallexample\n+@exdent vector unsigned __int128 vec_sr(vector unsigned __int128 A, vector unsigned __int128 B);\n+@exdent vector signed __int128 vec_sr(vector signed __int128 A, vector unsigned __int128 B);\n+@end smallexample\n+\n+Result value: Each element of R is obtained by shifting the corresponding element of\n+A right by the number of bits specified by the corresponding element of B.\n+\n+@smallexample\n+@exdent vector unsigned __int128 vec_sra(vector unsigned __int128 A, vector unsigned __int128 B);\n+@exdent vector signed __int128 vec_sra(vector signed __int128 A, vector unsigned __int128 B);\n+@end smallexample\n+\n+Result value: Each element of R is obtained by arithmetic shifting the corresponding\n+element of A right by the number of bits specified by the corresponding element of B.\n+\n+@smallexample\n+@exdent vector unsigned __int128 vec_mule (vector unsigned long long,\n+                                           vector unsigned long long);\n+@exdent vector signed __int128 vec_mule (vector signed long long,\n+                                         vector signed long long);\n+@end smallexample\n+\n+Returns a vector containing a 128-bit integer result of multiplying the even\n+doubleword elements of the two inputs.\n+\n+@smallexample\n+@exdent vector unsigned __int128 vec_mulo (vector unsigned long long,\n+                                           vector unsigned long long);\n+@exdent vector signed __int128 vec_mulo (vector signed long long,\n+                                         vector signed long long);\n+@end smallexample\n+\n+Returns a vector containing a 128-bit integer result of multiplying the odd\n+doubleword elements of the two inputs.\n+\n+@smallexample\n+@exdent vector unsigned __int128 vec_div (vector unsigned __int128,\n+                                          vector unsigned __int128);\n+@exdent vector signed __int128 vec_div (vector signed __int128,\n+                                        vector signed __int128);\n+@end smallexample\n+\n+Returns the result of dividing the first operand by the second operand. An\n+attempt to divide any value by zero or to divide the most negative signed\n+128-bit integer by negative one results in an undefined value.\n+\n+@smallexample\n+@exdent vector unsigned __int128 vec_dive (vector unsigned __int128,\n+                                           vector unsigned __int128);\n+@exdent vector signed __int128 vec_dive (vector signed __int128,\n+                                         vector signed __int128);\n+@end smallexample\n+\n+The result is produced by shifting the first input left by 128 bits and\n+dividing by the second.  If an attempt is made to divide by zero or the result\n+is larger than 128 bits, the result is undefined.\n+\n+@smallexample\n+@exdent vector unsigned __int128 vec_mod (vector unsigned __int128,\n+                                          vector unsigned __int128);\n+@exdent vector signed __int128 vec_mod (vector signed __int128,\n+                                        vector signed __int128);\n+@end smallexample\n+\n+The result is the modulo result of dividing the first input  by the second\n+input.\n+\n+The following builtins perform 128-bit vector comparisons.  The\n+@code{vec_all_xx}, @code{vec_any_xx}, and @code{vec_cmpxx}, where @code{xx} is\n+one of the operations @code{eq, ne, gt, lt, ge, le} perform pairwise\n+comparisons between the elements at the same positions within their two vector\n+arguments.  The @code{vec_all_xx}function returns a non-zero value if and only\n+if all pairwise comparisons are true.  The @code{vec_any_xx} function returns\n+a non-zero value if and only if at least one pairwise comparison is true.  The\n+@code{vec_cmpxx}function returns a vector of the same type as its two\n+arguments, within which each element consists of all ones to denote that\n+specified logical comparison of the corresponding elements was true.\n+Otherwise, the element of the returned vector contains all zeros.\n+\n+@smallexample\n+vector bool __int128 vec_cmpeq (vector signed __int128, vector signed __int128);\n+vector bool __int128 vec_cmpeq (vector unsigned __int128, vector unsigned __int128);\n+vector bool __int128 vec_cmpne (vector signed __int128, vector signed __int128);\n+vector bool __int128 vec_cmpne (vector unsigned __int128, vector unsigned __int128);\n+vector bool __int128 vec_cmpgt (vector signed __int128, vector signed __int128);\n+vector bool __int128 vec_cmpgt (vector unsigned __int128, vector unsigned __int128);\n+vector bool __int128 vec_cmplt (vector signed __int128, vector signed __int128);\n+vector bool __int128 vec_cmplt (vector unsigned __int128, vector unsigned __int128);\n+vector bool __int128 vec_cmpge (vector signed __int128, vector signed __int128);\n+vector bool __int128 vec_cmpge (vector unsigned __int128, vector unsigned __int128);\n+vector bool __int128 vec_cmple (vector signed __int128, vector signed __int128);\n+vector bool __int128 vec_cmple (vector unsigned __int128, vector unsigned __int128);\n+\n+int vec_all_eq (vector signed __int128, vector signed __int128);\n+int vec_all_eq (vector unsigned __int128, vector unsigned __int128);\n+int vec_all_ne (vector signed __int128, vector signed __int128);\n+int vec_all_ne (vector unsigned __int128, vector unsigned __int128);\n+int vec_all_gt (vector signed __int128, vector signed __int128);\n+int vec_all_gt (vector unsigned __int128, vector unsigned __int128);\n+int vec_all_lt (vector signed __int128, vector signed __int128);\n+int vec_all_lt (vector unsigned __int128, vector unsigned __int128);\n+int vec_all_ge (vector signed __int128, vector signed __int128);\n+int vec_all_ge (vector unsigned __int128, vector unsigned __int128);\n+int vec_all_le (vector signed __int128, vector signed __int128);\n+int vec_all_le (vector unsigned __int128, vector unsigned __int128);\n+\n+int vec_any_eq (vector signed __int128, vector signed __int128);\n+int vec_any_eq (vector unsigned __int128, vector unsigned __int128);\n+int vec_any_ne (vector signed __int128, vector signed __int128);\n+int vec_any_ne (vector unsigned __int128, vector unsigned __int128);\n+int vec_any_gt (vector signed __int128, vector signed __int128);\n+int vec_any_gt (vector unsigned __int128, vector unsigned __int128);\n+int vec_any_lt (vector signed __int128, vector signed __int128);\n+int vec_any_lt (vector unsigned __int128, vector unsigned __int128);\n+int vec_any_ge (vector signed __int128, vector signed __int128);\n+int vec_any_ge (vector unsigned __int128, vector unsigned __int128);\n+int vec_any_le (vector signed __int128, vector signed __int128);\n+int vec_any_le (vector unsigned __int128, vector unsigned __int128);\n+@end smallexample\n+\n+\n @node PowerPC Hardware Transactional Memory Built-in Functions\n @subsection PowerPC Hardware Transactional Memory Built-in Functions\n GCC provides two interfaces for accessing the Hardware Transactional"}, {"sha": "042758c8684f4d8fcaf7e086ada6bf07fcab7f7b", "filename": "gcc/testsuite/gcc.target/powerpc/int_128bit-runnable.c", "status": "added", "additions": 2263, "deletions": 0, "changes": 2263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03122f2a7626772fe13ab77f677141377104502/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fint_128bit-runnable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03122f2a7626772fe13ab77f677141377104502/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fint_128bit-runnable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fint_128bit-runnable.c?ref=f03122f2a7626772fe13ab77f677141377104502", "patch": "@@ -0,0 +1,2263 @@\n+/* { dg-do run } */\n+/* { dg-options \"-mcpu=power10 -save-temps\" } */\n+/* { dg-require-effective-target power10_hw } */\n+\n+/* Check that the expected 128-bit instructions are generated if the processor\n+   supports the 128-bit integer instructions. */\n+/* { dg-final { scan-assembler-times {\\mvslq\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mvsrq\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mvsraq\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mvrlq\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mvrlqnm\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mvrlqmi\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mvcmpuq\\M} 0 } } */\n+/* { dg-final { scan-assembler-times {\\mvcmpsq\\M} 0 } } */\n+/* { dg-final { scan-assembler-times {\\mvcmpequq\\M} 0 } } */\n+/* { dg-final { scan-assembler-times {\\mvcmpequq.\\M} 16 } } */\n+/* { dg-final { scan-assembler-times {\\mvcmpgtsq\\M} 0 } } */\n+/* { dg-final { scan-assembler-times {\\mvcmpgtsq.\\M} 16 } } */\n+/* { dg-final { scan-assembler-times {\\mvcmpgtuq\\M} 0 } } */\n+/* { dg-final { scan-assembler-times {\\mvcmpgtuq.\\M} 16 } } */\n+/* { dg-final { scan-assembler-times {\\mvmuleud\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvmuloud\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvmulesd\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvmulosd\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvmulld\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvdivsq\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvdivuq\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvdivesq\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvdiveuq\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvmodsq\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvmoduq\\M} 1 } } */\n+\n+#include <altivec.h>\n+\n+#define DEBUG 0\n+\n+#if DEBUG\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+\n+void print_i128(__int128_t val)\n+{\n+  printf(\" %lld %llu (0x%llx %llx)\",\n+\t (signed long long)(val >> 64),\n+\t (unsigned long long)(val & 0xFFFFFFFFFFFFFFFF),\n+\t (unsigned long long)(val >> 64),\n+\t (unsigned long long)(val & 0xFFFFFFFFFFFFFFFF));\n+}\n+#endif\n+\n+void abort (void);\n+\n+int main ()\n+{\n+  int i, result_int;\n+\n+  __int128_t arg1, result;\n+  __uint128_t uarg2;\n+\n+  vector signed long long int vec_arg1_di, vec_arg2_di;\n+  vector signed long long int vec_result_di, vec_expected_result_di;\n+  vector unsigned long long int vec_uarg1_di, vec_uarg2_di, vec_uarg3_di;\n+  vector unsigned long long int vec_uresult_di;\n+  vector unsigned long long int vec_uexpected_result_di;\n+  \n+  __int128_t expected_result;\n+  __uint128_t uexpected_result;\n+\n+  vector __int128 vec_arg1, vec_arg2, vec_result;\n+  vector unsigned __int128 vec_uarg1, vec_uarg2, vec_uarg3, vec_uresult;\n+  vector bool __int128  vec_result_bool;\n+  \n+  /* test shift 128-bit integers.\n+     Note, shift amount is given by the lower 7-bits of the shift amount. */\n+  vec_arg1[0] = 3;\n+  vec_uarg2[0] = 2;\n+  expected_result = vec_arg1[0]*4;\n+\n+  vec_result = vec_sl (vec_arg1, vec_uarg2);\n+\n+  if (vec_result[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_sl(int128, uint128):  \");\n+    print_i128(vec_arg1[0]);\n+    printf(\" << %lld\", vec_uarg2[0] & 0xFF);\n+    printf(\" = \");\n+    print_i128(vec_result[0]);\n+    printf(\"\\n does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  arg1 = 3;\n+  uarg2 = 4;\n+  expected_result = arg1*16;\n+\n+  result = arg1 << uarg2;\n+\n+  if (result != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: int128 << uint128):  \");\n+    print_i128(arg1);\n+    printf(\" << %lld\", uarg2 & 0xFF);\n+    printf(\" = \");\n+    print_i128(result);\n+    printf(\"\\n does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg1[0] = 3;\n+  vec_uarg2[0] = 2;\n+  uexpected_result = vec_uarg1[0]*4;\n+  \n+  vec_uresult = vec_sl (vec_uarg1, vec_uarg2);\n+\n+  if (vec_uresult[0] != uexpected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_sl(uint128, uint128):  \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\" << %lld\", vec_uarg2[0] & 0xFF);\n+    printf(\" = \");\n+    print_i128(vec_uresult[0]);\n+    printf(\"\\n does not match expected_result = \");\n+    print_i128(uexpected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg1[0] = 12;\n+  vec_uarg2[0] = 2;\n+  expected_result = vec_arg1[0]/4;\n+\n+  vec_result = vec_sr (vec_arg1, vec_uarg2);\n+\n+  if (vec_result[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_sr(int128, uint128):  \");\n+    print_i128(vec_arg1[0]);\n+    printf(\" >> %lld\", vec_uarg2[0] & 0xFF);\n+    printf(\" = \");\n+    print_i128(vec_result[0]);\n+    printf(\"\\n does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg1[0] = 48;\n+  vec_uarg2[0] = 2;\n+  uexpected_result = vec_uarg1[0]/4;\n+  \n+  vec_uresult = vec_sr (vec_uarg1, vec_uarg2);\n+\n+  if (vec_uresult[0] != uexpected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_sr(uint128, uint128):  \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\" >> %lld\", vec_uarg2[0] & 0xFF);\n+    printf(\" = \");\n+    print_i128(vec_uresult[0]);\n+    printf(\"\\n does not match expected_result = \");\n+    print_i128(uexpected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  arg1 = 48;\n+  uarg2 = 4;\n+  expected_result = arg1/16;\n+\n+  result = arg1 >> uarg2;\n+\n+  if (result != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: int128 >> uint128:  \");\n+    print_i128(arg1);\n+    printf(\" >> %lld\", uarg2 & 0xFF);\n+    printf(\" = \");\n+    print_i128(result);\n+    printf(\"\\n does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg1[0] = 0x1234567890ABCDEFULL;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 0xAABBCCDDEEFF1122ULL;\n+  vec_uarg2[0] = 32;\n+  expected_result = 0x0000000012345678ULL;\n+  expected_result = (expected_result << 64) | 0x90ABCDEFAABBCCDDULL;\n+\n+  vec_result = vec_sra (vec_arg1, vec_uarg2);\n+  \n+  if (vec_result[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_sra(int128, uint128):  \");\n+    print_i128(vec_arg1[0]);\n+    printf(\" >> %lld = \\n\", vec_uarg2[0]);\n+    print_i128(vec_result[0]);\n+    printf(\"\\n does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg1[0] = 0xAABBCCDDEEFF1122ULL;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 0x1234567890ABCDEFULL;\n+  vec_uarg2[0] = 48;\n+  uexpected_result = 0xFFFFFFFFFFFFAABBLL;\n+  uexpected_result = (uexpected_result << 64) | 0xCCDDEEFF11221234ULL;\n+\n+  vec_uresult = vec_sra (vec_uarg1, vec_uarg2);\n+\n+  if (vec_uresult[0] != uexpected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_sra(uint128, uint128):  \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\" >> %lld = \\n\", vec_uarg2[0] & 0xFF);\n+    print_i128(vec_uresult[0]);\n+    printf(\"\\n does not match expected_result = \");\n+    print_i128(uexpected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg1[0] = 0x1234567890ABCDEFULL;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 0xAABBCCDDEEFF1122ULL;\n+  vec_uarg2[0] = 32;\n+  expected_result = 0x90ABCDEFAABBCCDDULL;\n+  expected_result = (expected_result << 64) | 0xEEFF112212345678ULL;\n+\n+  vec_result = vec_rl (vec_arg1, vec_uarg2);\n+  \n+  if (vec_result[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_rl(int128, uint128):  \");\n+    print_i128(vec_arg1[0]);\n+    printf(\" >> %lld = \\n\", vec_uarg2[0]);\n+    print_i128(vec_result[0]);\n+    printf(\"\\n does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg1[0] = 0xAABBCCDDEEFF1122ULL;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 0x1234567890ABCDEFULL;\n+  vec_uarg2[0] = 48;\n+  uexpected_result = 0x11221234567890ABULL;\n+  uexpected_result = (uexpected_result << 64) | 0xCDEFAABBCCDDEEFFULL;\n+\n+  vec_uresult = vec_rl (vec_uarg1, vec_uarg2);\n+\n+  if (vec_uresult[0] != uexpected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_rl(uint128, uint128):  \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\" >> %lld = \\n\", vec_uarg2[0]);\n+    print_i128(vec_uresult[0]);\n+    printf(\"\\n does not match expected_result = \");\n+    print_i128(uexpected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  /* vec_rlnm(arg1, arg2, arg3)\n+     result - rotate each element of arg1 left by shift in element of arg2.\n+       Then AND with mask whose  start/stop bits are specified in element of\n+       arg3.  */\n+  vec_arg1[0] = 0x1234567890ABCDEFULL;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 0xAABBCCDDEEFF1122ULL;\n+  vec_uarg2[0] = 32;\n+  vec_uarg3[0] = (32 << 8) | 95;\n+  expected_result = 0xaabbccddULL;\n+  expected_result = (expected_result << 64) | 0xeeff112200000000ULL;\n+\n+  vec_result = vec_rlnm (vec_arg1, vec_uarg2, vec_uarg3);\n+  \n+  if (vec_result[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_rlnm(int128, uint128, uint128):  \");\n+    print_i128(vec_arg1[0]);\n+    printf(\" << %lld = \\n\", vec_uarg3[0] & 0xFF);\n+    print_i128(vec_result[0]);\n+    printf(\"\\n does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  \n+\n+  /* vec_rlnm(arg1, arg2, arg3)\n+     result - rotate each element of arg1 left by shift in element of arg2;\n+     then AND with mask whose  start/stop bits are specified in element of\n+     arg3.  */\n+  vec_uarg1[0] = 0xAABBCCDDEEFF1122ULL;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 0x1234567890ABCDEFULL;\n+  vec_uarg2[0] = 48;\n+  vec_uarg3[0] = (8 << 8) | 119;\n+\n+  uexpected_result = 0x00221234567890ABULL;\n+  uexpected_result = (uexpected_result << 64) | 0xCDEFAABBCCDDEE00ULL;\n+\n+  vec_uresult = vec_rlnm (vec_uarg1, vec_uarg2, vec_uarg3);\n+\n+  if (vec_uresult[0] != uexpected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_rlnm(uint128, uint128, uint128):  \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\" << %lld = \\n\", vec_uarg3[0] & 0xFF);\n+    print_i128(vec_uresult[0]);\n+    printf(\"\\n does not match expected_result = \");\n+    print_i128(uexpected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  /*  vec_rlmi(R, A, B)\n+      Result value: Each element of R is obtained by rotating the corresponding\n+      element of A left by the number of bits specified by the corresponding element\n+      of B.  */\n+\n+  vec_arg1[0] = 0x1234567890ABCDEFULL;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 0xAABBCCDDEEFF1122ULL;\n+  vec_arg2[0] = 0x000000000000DEADULL;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 0x0000BEEF00000000ULL;\n+  vec_uarg3[0] = 96 << 16 | 127 << 8 | 32;\n+  expected_result = 0x000000000000DEADULL;\n+  expected_result = (expected_result << 64) | 0x0000BEEF12345678ULL;\n+\n+  vec_result = vec_rlmi (vec_arg1, vec_arg2, vec_uarg3);\n+  \n+  if (vec_result[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_rlmi(int128, int128, uint128):  \");\n+    print_i128(vec_arg1[0]);\n+    printf(\" << %lld = \\n\", vec_uarg2_di[1] & 0xFF);\n+    print_i128(vec_result[0]);\n+    printf(\"\\n does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  /* vec_rlmi(R, A, B)\n+     Result value: Each element of R is obtained by rotating the corresponding\n+     element of A left by the number of bits specified by the corresponding element\n+     of B.  */\n+\n+  vec_uarg1[0] = 0xAABBCCDDEEFF1122ULL;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 0x1234567890ABCDEFULL;\n+  vec_uarg2[0] = 0xDEAD000000000000ULL;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 0x000000000000BEEFULL;\n+  vec_uarg3[0] = 16 << 16 | 111 << 8 | 48;\n+  uexpected_result = 0xDEAD1234567890ABULL;\n+  uexpected_result = (uexpected_result << 64) | 0xCDEFAABBCCDDBEEFULL;\n+\n+  vec_uresult = vec_rlmi (vec_uarg1, vec_uarg2, vec_uarg3);\n+\n+  if (vec_uresult[0] != uexpected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_rlmi(uint128, unit128, uint128):  \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\" << %lld = \\n\", vec_uarg3[1] & 0xFF);\n+    print_i128(vec_uresult[0]);\n+    printf(\"\\n does not match expected_result = \");\n+    print_i128(uexpected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  /* 128-bit compare tests, result is all 1's if true */\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1[0] = 2468;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  uexpected_result = 0xFFFFFFFFFFFFFFFFULL;\n+  uexpected_result = (uexpected_result << 64) | 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vec_result_bool = vec_cmpgt (vec_uarg1, vec_uarg2);\n+\n+  if (vec_result_bool[0] != uexpected_result) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned vec_cmpgt ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(uexpected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg1[0] = 12468;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  expected_result = 0xFFFFFFFFFFFFFFFFULL;\n+  expected_result = (expected_result << 64) | 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vec_result_bool = vec_cmpgt (vec_arg1, vec_arg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: signed vec_cmpgt ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+\n+  vec_arg1[0] = 12468;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = -1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  expected_result = 0x0ULL;\n+\n+  vec_result_bool = vec_cmpeq (vec_arg1, vec_arg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR:not equal signed vec_cmpeq ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  vec_arg1 = vec_arg2;\n+  expected_result = 0xFFFFFFFFFFFFFFFFULL;\n+  expected_result = (expected_result << 64) | 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vec_result_bool = vec_cmpeq (vec_arg1, vec_arg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: signed equal vec_cmpeq ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg1[0] = 12468;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  expected_result = 0x0ULL;\n+\n+  vec_result_bool = vec_cmpeq (vec_uarg1, vec_uarg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned  not equal vec_cmpeq ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1 = vec_uarg2;\n+\n+  expected_result = 0xFFFFFFFFFFFFFFFFULL;\n+  expected_result = (expected_result << 64) | 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vec_result_bool = vec_cmpeq (vec_uarg1, vec_uarg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: equal unsigned vec_cmpeq ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg1[0] = 12468;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  expected_result = 0xFFFFFFFFFFFFFFFFULL;\n+  expected_result = (expected_result << 64) | 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vec_result_bool = vec_cmpne (vec_uarg1, vec_uarg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned  not equal vec_cmpne ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1 = vec_uarg2;\n+  expected_result = 0x0ULL;\n+\n+  vec_result_bool = vec_cmpne (vec_uarg1, vec_uarg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: equal unsigned vec_cmpne ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg1[0] = 12468;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = -1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  expected_result = 0xFFFFFFFFFFFFFFFFULL;\n+  expected_result = (expected_result << 64) | 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vec_result_bool = vec_cmpne (vec_arg1, vec_arg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR:not equal signed vec_cmpne ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  vec_arg1 = vec_arg2;\n+  expected_result = 0x0ULL;\n+\n+  vec_result_bool = vec_cmpne (vec_arg1, vec_arg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: signed equal vec_cmpne ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg1[0] = 12468;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  expected_result = 0x0;\n+\n+  vec_result_bool = vec_cmplt (vec_uarg1, vec_uarg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned  arg1 > arg2 vec_cmplt ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg1[0] = 1234;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 12468;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  expected_result = 0xFFFFFFFFFFFFFFFFULL;\n+  expected_result = (expected_result << 64) | 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vec_result_bool = vec_cmplt (vec_uarg1, vec_uarg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned  arg1 < arg2 vec_cmplt ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1 = vec_uarg2;\n+  expected_result = 0x0ULL;\n+\n+  vec_result_bool = vec_cmplt (vec_uarg1, vec_uarg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR:  unsigned arg1 = arg2 vec_cmplt ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg1[0] = 12468;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = -1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  expected_result = 0x0;\n+\n+  vec_result_bool = vec_cmplt (vec_arg1, vec_arg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: signed  arg1 > arg2 vec_cmplt ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg1[0] = -1234;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = 12468;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  expected_result = 0xFFFFFFFFFFFFFFFFULL;\n+  expected_result = (expected_result << 64) | 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vec_result_bool = vec_cmplt (vec_arg1, vec_arg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: signed  arg1 < arg2 vec_cmplt ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  vec_arg1 = vec_arg2;\n+  expected_result = 0x0ULL;\n+\n+  vec_result_bool = vec_cmplt (vec_arg1, vec_arg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 = arg2 vec_cmplt ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+   \n+  vec_uarg1[0] = 12468;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  expected_result = 0x0;\n+\n+  vec_result_bool = vec_cmple (vec_uarg1, vec_uarg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned  arg1 > arg2 vec_cmple ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg1[0] = 1234;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 12468;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  expected_result = 0xFFFFFFFFFFFFFFFFULL;\n+  expected_result = (expected_result << 64) | 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vec_result_bool = vec_cmple (vec_uarg1, vec_uarg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned  arg1 < arg2 vec_cmple ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1 = vec_uarg2;\n+  expected_result = 0xFFFFFFFFFFFFFFFFULL;\n+  expected_result = (expected_result << 64) | 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vec_result_bool = vec_cmple (vec_uarg1, vec_uarg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR:  unsigned arg1 = arg2 vec_cmple ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg1[0] = 12468;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = -1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  expected_result = 0x0;\n+\n+  vec_result_bool = vec_cmple (vec_arg1, vec_arg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: signed  arg1 > arg2 vec_cmple ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg1[0] = -1234;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = 12468;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  expected_result = 0xFFFFFFFFFFFFFFFFULL;\n+  expected_result = (expected_result << 64) | 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vec_result_bool = vec_cmple (vec_arg1, vec_arg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: signed  arg1 < arg2 vec_cmple ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  vec_arg1 = vec_arg2;\n+  expected_result = 0xFFFFFFFFFFFFFFFFULL;\n+  expected_result = (expected_result << 64) | 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vec_result_bool = vec_cmple (vec_arg1, vec_arg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 = arg2 vec_cmple ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg1[0] = 12468;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  expected_result = 0xFFFFFFFFFFFFFFFFULL;\n+  expected_result = (expected_result << 64) | 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vec_result_bool = vec_cmpge (vec_uarg1, vec_uarg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned  arg1 > arg2 vec_cmpge ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg1[0] = 1234;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 12468;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  expected_result = 0x0;\n+\n+  vec_result_bool = vec_cmpge (vec_uarg1, vec_uarg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned  arg1 < arg2 vec_cmpge ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1 = vec_uarg2;\n+  expected_result = 0xFFFFFFFFFFFFFFFFULL;\n+  expected_result = (expected_result << 64) | 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vec_result_bool = vec_cmpge (vec_uarg1, vec_uarg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR:  unsigned arg1 = arg2 vec_cmpge ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg1[0] = 12468;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = -1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  expected_result = 0xFFFFFFFFFFFFFFFFULL;\n+  expected_result = (expected_result << 64) | 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vec_result_bool = vec_cmpge (vec_arg1, vec_arg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: signed  arg1 > arg2 vec_cmpge ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg1[0] = -1234;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = 12468;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  expected_result = 0x0;\n+\n+  vec_result_bool = vec_cmpge (vec_arg1, vec_arg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: signed  arg1 < arg2 vec_cmpge ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  vec_arg1 = vec_arg2;\n+  expected_result = 0xFFFFFFFFFFFFFFFFULL;\n+  expected_result = (expected_result << 64) | 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vec_result_bool = vec_cmpge (vec_arg1, vec_arg2);\n+\n+  if (vec_result_bool[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 = arg2 vec_cmpge ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\");\n+    print_i128(vec_result_bool[0]);\n+    printf(\"\\n Result does not match expected_result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+#if 1\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  vec_arg1 = vec_arg2;\n+\n+  result_int = vec_all_eq (vec_arg1, vec_arg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 = arg2 vec_all_eq ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_arg1[0] = -234;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+\n+  result_int = vec_all_eq (vec_arg1, vec_arg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 != arg2 vec_all_eq ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1 = vec_uarg2;\n+\n+  result_int = vec_all_eq (vec_uarg1, vec_uarg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 = uarg2 vec_all_eq ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg1[0] = 234;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+\n+  result_int = vec_all_eq (vec_uarg1, vec_uarg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 != uarg2 vec_all_eq ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  vec_arg1 = vec_arg2;\n+\n+  result_int = vec_all_ne (vec_arg1, vec_arg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 = arg2 vec_all_ne ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_arg1[0] = -234;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+\n+  result_int = vec_all_ne (vec_arg1, vec_arg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 != arg2 vec_all_ne ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1 = vec_uarg2;\n+\n+  result_int = vec_all_ne (vec_uarg1, vec_uarg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 = uarg2 vec_all_ne ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg1[0] = 234;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+\n+  result_int = vec_all_ne (vec_uarg1, vec_uarg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 != uarg2 vec_all_ne ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  vec_arg1 = vec_arg2;\n+\n+  result_int = vec_all_lt (vec_arg1, vec_arg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 = arg2 vec_all_lt ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_arg1[0] = -234;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+\n+  result_int = vec_all_lt (vec_arg1, vec_arg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 != arg2 vec_all_lt ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1 = vec_uarg2;\n+\n+  result_int = vec_all_lt (vec_uarg1, vec_uarg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 = uarg2 vec_all_lt ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg1[0] = 234;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+\n+  result_int = vec_all_lt (vec_uarg1, vec_uarg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 != uarg2 vec_all_lt ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  vec_arg1 = vec_arg2;\n+\n+  result_int = vec_all_le (vec_arg1, vec_arg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 = arg2 vec_all_le ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_arg1[0] = -234;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+\n+  result_int = vec_all_le (vec_arg1, vec_arg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 != arg2 vec_all_le ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1 = vec_uarg2;\n+\n+  result_int = vec_all_le (vec_uarg1, vec_uarg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 = uarg2 vec_all_le ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg1[0] = 234;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+\n+  result_int = vec_all_le (vec_uarg1, vec_uarg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 != uarg2 vec_all_le ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  vec_arg1 = vec_arg2;\n+\n+  result_int = vec_all_gt (vec_arg1, vec_arg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 = arg2 vec_all_gt ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_arg1[0] = -234;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+\n+  result_int = vec_all_gt (vec_arg1, vec_arg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 != arg2 vec_all_gt ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1 = vec_uarg2;\n+\n+  result_int = vec_all_gt (vec_uarg1, vec_uarg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 = uarg2 vec_all_gt ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg1[0] = 234;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+\n+  result_int = vec_all_gt (vec_uarg1, vec_uarg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 != uarg2 vec_all_gt ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  vec_arg1 = vec_arg2;\n+\n+  result_int = vec_all_ge (vec_arg1, vec_arg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 = arg2 vec_all_ge ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_arg1[0] = -234;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+\n+  result_int = vec_all_ge (vec_arg1, vec_arg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 != arg2 vec_all_ge ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1 = vec_uarg2;\n+\n+  result_int = vec_all_ge (vec_uarg1, vec_uarg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 = uarg2 vec_all_ge ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg1[0] = 234;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+\n+  result_int = vec_all_ge (vec_uarg1, vec_uarg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 != uarg2 vec_all_ge ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  vec_arg1 = vec_arg2;\n+\n+  result_int = vec_any_eq (vec_arg1, vec_arg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 = arg2 vec_any_eq ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_arg1[0] = -234;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+\n+  result_int = vec_any_eq (vec_arg1, vec_arg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 != arg2 vec_any_eq ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1 = vec_uarg2;\n+\n+  result_int = vec_any_eq (vec_uarg1, vec_uarg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 = uarg2 vec_any_eq ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg1[0] = 234;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+\n+  result_int = vec_any_eq (vec_uarg1, vec_uarg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 != uarg2 vec_any_eq ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  vec_arg1 = vec_arg2;\n+\n+  result_int = vec_any_ne (vec_arg1, vec_arg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 = arg2 vec_any_ne ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_arg1[0] = -234;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+\n+  result_int = vec_any_ne (vec_arg1, vec_arg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 != arg2 vec_any_ne ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1 = vec_uarg2;\n+\n+  result_int = vec_any_ne (vec_uarg1, vec_uarg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 = uarg2 vec_any_ne ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg1[0] = 234;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+\n+  result_int = vec_any_ne (vec_uarg1, vec_uarg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 != uarg2 vec_any_ne ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  vec_arg1 = vec_arg2;\n+\n+  result_int = vec_any_lt (vec_arg1, vec_arg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 = arg2 vec_any_lt ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_arg1[0] = -234;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+\n+  result_int = vec_any_lt (vec_arg1, vec_arg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 != arg2 vec_any_lt ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1 = vec_uarg2;\n+\n+  result_int = vec_any_lt (vec_uarg1, vec_uarg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 = uarg2 vec_any_lt ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg1[0] = 234;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+\n+  result_int = vec_any_lt (vec_uarg1, vec_uarg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 != uarg2 vec_any_lt ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  vec_arg1 = vec_arg2;\n+\n+  result_int = vec_any_gt (vec_arg1, vec_arg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 = arg2 vec_any_gt ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_arg1[0] = -234;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+\n+  result_int = vec_any_gt (vec_arg1, vec_arg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 != arg2 vec_any_gt ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1 = vec_uarg2;\n+\n+  result_int = vec_any_gt (vec_uarg1, vec_uarg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 = uarg2 vec_any_gt ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg1[0] = 234;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+\n+  result_int = vec_any_gt (vec_uarg1, vec_uarg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 != uarg2 vec_any_gt ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  vec_arg1 = vec_arg2;\n+\n+  result_int = vec_any_le (vec_arg1, vec_arg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 = arg2 vec_any_le ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_arg1[0] = -234;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+\n+  result_int = vec_any_le (vec_arg1, vec_arg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 != arg2 vec_any_le ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1 = vec_uarg2;\n+\n+  result_int = vec_any_le (vec_uarg1, vec_uarg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 = uarg2 vec_any_le ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg1[0] = 234;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+\n+  result_int = vec_any_le (vec_uarg1, vec_uarg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 != uarg2 vec_any_le ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+  vec_arg1 = vec_arg2;\n+\n+  result_int = vec_any_ge (vec_arg1, vec_arg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 = arg2 vec_any_ge ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_arg1[0] = -234;\n+  vec_arg1[0] = (vec_arg1[0] << 64) | 4567;\n+  vec_arg2[0] = 1234;\n+  vec_arg2[0] = (vec_arg2[0] << 64) | 4567;\n+\n+  result_int = vec_any_ge (vec_arg1, vec_arg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: signed arg1 != arg2 vec_any_ge ( \");\n+    print_i128(vec_arg1[0]);\n+    printf(\", \");\n+    print_i128(vec_arg2[0]);\n+    printf(\") failed.\\n\\n\");\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+  vec_uarg1 = vec_uarg2;\n+\n+  result_int = vec_any_ge (vec_uarg1, vec_uarg2);\n+\n+  if (!result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 = uarg2 vec_any_ge ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg1[0] = 234;\n+  vec_uarg1[0] = (vec_uarg1[0] << 64) | 4567;\n+  vec_uarg2[0] = 1234;\n+  vec_uarg2[0] = (vec_uarg2[0] << 64) | 4567;\n+\n+  result_int = vec_any_ge (vec_uarg1, vec_uarg2);\n+\n+  if (result_int) {\n+#if DEBUG\n+    printf(\"ERROR: unsigned uarg1 != uarg2 vec_any_gt ( \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\", \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\") failed.\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+#endif\n+\n+  /* Vector multiply Even and Odd tests */\n+  vec_arg1_di[0] = 200;\n+  vec_arg1_di[1] = 400;\n+  vec_arg2_di[0] = 1234;\n+  vec_arg2_di[1] = 4567;\n+  expected_result = vec_arg1_di[0] * vec_arg2_di[0];\n+\n+  vec_result = vec_mule (vec_arg1_di, vec_arg2_di);\n+\n+  if (vec_result[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_mule (signed, signed) failed.\\n\");\n+    printf(\" vec_arg1_di[0] = %lld\\n\", vec_arg1_di[0]);\n+    printf(\" vec_arg2_di[0] = %lld\\n\", vec_arg2_di[0]);\n+    printf(\"Result = \");\n+    print_i128(vec_result[0]);\n+    printf(\"\\nExpected Result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_arg1_di[0] = -200;\n+  vec_arg1_di[1] = -400;\n+  vec_arg2_di[0] = 1234;\n+  vec_arg2_di[1] = 4567;\n+  expected_result = vec_arg1_di[1] * vec_arg2_di[1];\n+\n+  vec_result = vec_mulo (vec_arg1_di, vec_arg2_di);\n+\n+  if (vec_result[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_mulo (signed, signed) failed.\\n\");\n+    printf(\" vec_arg1_di[1] = %lld\\n\", vec_arg1_di[1]);\n+    printf(\" vec_arg2_di[1] = %lld\\n\", vec_arg2_di[1]);\n+    printf(\"Result = \");\n+    print_i128(vec_result[0]);\n+    printf(\"\\nExpected Result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg1_di[0] = 200;\n+  vec_uarg1_di[1] = 400;\n+  vec_uarg2_di[0] = 1234;\n+  vec_uarg2_di[1] = 4567;\n+  uexpected_result = vec_uarg1_di[0] * vec_uarg2_di[0];\n+\n+  vec_uresult = vec_mule (vec_uarg1_di, vec_uarg2_di);\n+\n+  if (vec_uresult[0] != uexpected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_mule (unsigned, unsigned) failed.\\n\");\n+    printf(\" vec_uarg1_di[1] = %lld\\n\", vec_uarg1_di[1]);\n+    printf(\" vec_uarg2_di[1] = %lld\\n\", vec_uarg2_di[1]);\n+    printf(\"Result = \");\n+    print_i128(vec_uresult[0]);\n+    printf(\"\\nExpected Result = \");\n+    print_i128(uexpected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+  \n+  vec_uarg1_di[0] = 200;\n+  vec_uarg1_di[1] = 400;\n+  vec_uarg2_di[0] = 1234;\n+  vec_uarg2_di[1] = 4567;\n+  uexpected_result = vec_uarg1_di[1] * vec_uarg2_di[1];\n+\n+  vec_uresult = vec_mulo (vec_uarg1_di, vec_uarg2_di);\n+\n+  if (vec_uresult[0] != uexpected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_mulo (unsigned, unsigned) failed.\\n\");\n+    printf(\" vec_uarg1_di[0] = %lld\\n\", vec_uarg1_di[0]);\n+    printf(\" vec_uarg2_di[0] = %lld\\n\", vec_uarg2_di[0]);\n+    printf(\"Result = \");\n+    print_i128(vec_uresult[0]);\n+    printf(\"\\nExpected Result = \");\n+    print_i128(uexpected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  /* Vector Multiply Longword */\n+  vec_arg1_di[0] = 100;\n+  vec_arg1_di[1] = -123456;\n+\n+  vec_arg2_di[0] = 123;\n+  vec_arg2_di[1] = 1000;\n+\n+  vec_expected_result_di[0] = 12300;\n+  vec_expected_result_di[1] = -123456000;\n+\n+  vec_result_di = vec_arg1_di * vec_arg2_di;\n+\n+  for (i = 0; i<2; i++) {\n+    if (vec_result_di[i] != vec_expected_result_di[i]) {\n+#if DEBUG\n+      printf(\"ERROR: vector multipy [%d] ((long long) %lld) =  \", i,\n+\t     vec_result_di[i]);\n+      printf(\"\\n does not match expected_result [%d] = ((long long) %lld)\", i,\n+\t     vec_expected_result_di[i]);\n+      printf(\"\\n\\n\");\n+#else\n+      abort();\n+#endif\n+    }\n+  }\n+\n+  /* Vector Divide Quadword */\n+  vec_arg1[0] = -12345678;\n+  vec_arg2[0] = 2;\n+  expected_result = -6172839;\n+\n+  vec_result = vec_div (vec_arg1, vec_arg2);\n+\n+  if (vec_result[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_div (signed, signed) failed.\\n\");\n+    printf(\"vec_arg1[0] = \");\n+    print_i128(vec_arg1[0]);\n+    printf(\"\\nvec_arg2[0] = \");\n+    print_i128(vec_arg2[0]);\n+    printf(\"\\nResult = \");\n+    print_i128(vec_result[0]);\n+    printf(\"\\nExpected result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg1[0] = 24680;\n+  vec_uarg2[0] = 4;\n+  uexpected_result = 6170;\n+\n+  vec_uresult = vec_div (vec_uarg1, vec_uarg2);\n+\n+  if (vec_uresult[0] != uexpected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_div (unsigned, unsigned) failed.\\n\");\n+    printf(\"vec_uarg1[0] = \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\"\\nvec_uarg2[0] = \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\"\\nResult = \");\n+    print_i128(vec_uresult[0]);\n+    printf(\"\\nExpected result = \");\n+    print_i128(uexpected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  /* Vector Divide Extended Quadword */\n+  vec_arg1[0] = -20;        // has 128-bit of zero concatenated onto it\n+  vec_arg2[0] = 0x2000000000000000;\n+  vec_arg2[0] = vec_arg2[0] << 64;\n+  expected_result = -160;\n+\n+  vec_result = vec_dive (vec_arg1, vec_arg2);\n+\n+  if (vec_result[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_dive (signed, signed) failed.\\n\");\n+    printf(\"vec_arg1[0] = \");\n+    print_i128(vec_arg1[0]);\n+    printf(\"\\nvec_arg2[0] = \");\n+    print_i128(vec_arg2[0]);\n+    printf(\"\\nResult = \");\n+    print_i128(vec_result[0]);\n+    printf(\"\\nExpected result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg1[0] = 20;        // has 128-bit of zero concatenated onto it\n+  vec_uarg2[0] = 0x4000000000000000;\n+  vec_uarg2[0] = vec_uarg2[0] << 64;\n+  uexpected_result = 80;\n+\n+  vec_uresult = vec_dive (vec_uarg1, vec_uarg2);\n+\n+  if (vec_uresult[0] != uexpected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_dive (unsigned, unsigned) failed.\\n\");\n+    printf(\"vec_uarg1[0] = \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\"\\nvec_uarg2[0] = \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\"\\nResult = \");\n+    print_i128(vec_uresult[0]);\n+    printf(\"\\nExpected result = \");\n+    print_i128(uexpected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  /* Vector modulo quad word  */\n+  vec_arg1[0] = -12345675;\n+  vec_arg2[0] = 2;\n+  expected_result = -1;\n+\n+  vec_result = vec_mod (vec_arg1, vec_arg2);\n+\n+  if (vec_result[0] != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_mod (signed, signed) failed.\\n\");\n+    printf(\"vec_arg1[0] = \");\n+    print_i128(vec_arg1[0]);\n+    printf(\"\\nvec_arg2[0] = \");\n+    print_i128(vec_arg2[0]);\n+    printf(\"\\nResult = \");\n+    print_i128(vec_result[0]);\n+    printf(\"\\nExpected result = \");\n+    print_i128(expected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  vec_uarg1[0] = 24685;\n+  vec_uarg2[0] = 4;\n+  uexpected_result = 1;\n+\n+  vec_uresult = vec_mod (vec_uarg1, vec_uarg2);\n+\n+  if (vec_uresult[0] != uexpected_result) {\n+#if DEBUG\n+    printf(\"ERROR: vec_mod (unsigned, unsigned) failed.\\n\");\n+    printf(\"vec_uarg1[0] = \");\n+    print_i128(vec_uarg1[0]);\n+    printf(\"\\nvec_uarg2[0] = \");\n+    print_i128(vec_uarg2[0]);\n+    printf(\"\\nResult = \");\n+    print_i128(vec_uresult[0]);\n+    printf(\"\\nExpected result = \");\n+    print_i128(uexpected_result);\n+    printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  return 0;\n+}"}]}