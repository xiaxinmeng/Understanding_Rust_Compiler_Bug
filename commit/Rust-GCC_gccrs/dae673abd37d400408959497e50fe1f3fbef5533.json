{"sha": "dae673abd37d400408959497e50fe1f3fbef5533", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFlNjczYWJkMzdkNDAwNDA4OTU5NDk3ZTUwZmUxZjNmYmVmNTUzMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-07T08:42:12Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-07T14:55:33Z"}, "message": "tree-optimization/97307 - improve sinking of loads\n\nThis improves the heuristics finding a sink location for loads that does\nnot cross any store.\n\n2020-10-07  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/97307\n\t* tree-ssa-sink.c (statement_sink_location): Change heuristic\n\tfor not skipping stores to look for virtual definitions\n\trather than uses.\n\n\t* gcc.dg/tree-ssa/ssa-sink-17.c: New testcase.\n\t* gcc.dg/vect/pr65947-3.c: XFAIL.", "tree": {"sha": "2e35816a5dae16baaaf334b5cb1013b54e24cdfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e35816a5dae16baaaf334b5cb1013b54e24cdfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dae673abd37d400408959497e50fe1f3fbef5533", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dae673abd37d400408959497e50fe1f3fbef5533", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dae673abd37d400408959497e50fe1f3fbef5533", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dae673abd37d400408959497e50fe1f3fbef5533/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "592fe221735bdaa375b1834dd49ce125d0b600d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/592fe221735bdaa375b1834dd49ce125d0b600d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/592fe221735bdaa375b1834dd49ce125d0b600d8"}], "stats": {"total": 65, "additions": 43, "deletions": 22}, "files": [{"sha": "cf2e2a0f76641f030fda3af4277aeaf640958985", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-17.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae673abd37d400408959497e50fe1f3fbef5533/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sink-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae673abd37d400408959497e50fe1f3fbef5533/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sink-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sink-17.c?ref=dae673abd37d400408959497e50fe1f3fbef5533", "patch": "@@ -0,0 +1,15 @@\n+/* PR tree-optimization/97307  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-sink-details\" } */\n+\n+int pure_f(int a, int b) __attribute__((pure));\n+int my_f(int a, int b)\n+{\n+  int x = pure_f(a, b);\n+  if (a > 0)\n+    return x;\n+  return a;\n+}\n+\n+/* We should sink the call to pure_f to the if block.  */\n+/* { dg-final { scan-tree-dump \"Sinking # VUSE\" \"sink\" } } */"}, {"sha": "8a2608cf0f15055da5d5187f2bf27dd1df45e183", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-3.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae673abd37d400408959497e50fe1f3fbef5533/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae673abd37d400408959497e50fe1f3fbef5533/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-3.c?ref=dae673abd37d400408959497e50fe1f3fbef5533", "patch": "@@ -51,6 +51,9 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" } } */\n+/* XFAILed because of the fix for PR97307 which sinks the load of a[i], preventing\n+   if-conversion to happen.  */\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 2 \"vect\" { target vect_fold_extract_last } } } */\n /* { dg-final { scan-tree-dump-not \"condition expression based on integer induction.\" \"vect\" } } */"}, {"sha": "ba8e5577e9c38a1145e458ee7b00bbfe58979af9", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae673abd37d400408959497e50fe1f3fbef5533/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae673abd37d400408959497e50fe1f3fbef5533/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=dae673abd37d400408959497e50fe1f3fbef5533", "patch": "@@ -369,10 +369,9 @@ statement_sink_location (gimple *stmt, basic_block frombb,\n \treturn false;\n \n       /* If this is a load then do not sink past any stores.\n-\t ???  This is overly simple but cheap.  We basically look\n-\t for an existing load with the same VUSE in the path to one\n-\t of the sink candidate blocks and we adjust commondom to the\n-\t nearest to commondom.  */\n+\t Look for virtual definitions in the path from frombb to the sink\n+\t location computed from the real uses and if found, adjust\n+\t that it a common dominator.  */\n       if (gimple_vuse (stmt))\n \t{\n \t  /* Do not sink loads from hard registers.  */\n@@ -383,29 +382,33 @@ statement_sink_location (gimple *stmt, basic_block frombb,\n \n \t  imm_use_iterator imm_iter;\n \t  use_operand_p use_p;\n-\t  basic_block found = NULL;\n \t  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, gimple_vuse (stmt))\n \t    {\n \t      gimple *use_stmt = USE_STMT (use_p);\n \t      basic_block bb = gimple_bb (use_stmt);\n-\t      /* For PHI nodes the block we know sth about\n-\t\t is the incoming block with the use.  */\n+\t      /* For PHI nodes the block we know sth about is the incoming block\n+\t\t with the use.  */\n \t      if (gimple_code (use_stmt) == GIMPLE_PHI)\n-\t\tbb = EDGE_PRED (bb, PHI_ARG_INDEX_FROM_USE (use_p))->src;\n-\t      /* Any dominator of commondom would be ok with\n-\t         adjusting commondom to that block.  */\n-\t      bb = nearest_common_dominator (CDI_DOMINATORS, bb, commondom);\n-\t      if (!found)\n-\t\tfound = bb;\n-\t      else if (dominated_by_p (CDI_DOMINATORS, bb, found))\n-\t\tfound = bb;\n-\t      /* If we can't improve, stop.  */\n-\t      if (found == commondom)\n-\t\tbreak;\n+\t\t{\n+\t\t  /* In case the PHI node post-dominates the current insert location\n+\t\t     we can disregard it.  */\n+\t\t  if (commondom != bb\n+\t\t      && dominated_by_p (CDI_POST_DOMINATORS, commondom, bb))\n+\t\t    continue;\n+\t\t  bb = EDGE_PRED (bb, PHI_ARG_INDEX_FROM_USE (use_p))->src;\n+\t\t}\n+\t      else if (!gimple_vdef (use_stmt))\n+\t\tcontinue;\n+\t      /* If the use is not dominated by the path entry it is not on\n+\t\t the path.  */\n+\t      if (!dominated_by_p (CDI_DOMINATORS, bb, frombb))\n+\t\tcontinue;\n+\t      /* There is no easy way to disregard defs not on the path from\n+\t\t frombb to commondom so just consider them all.  */\n+\t      commondom = nearest_common_dominator (CDI_DOMINATORS, bb, commondom);\n+\t      if (commondom == frombb)\n+\t\treturn false;\n \t    }\n-\t  commondom = found;\n-\t  if (commondom == frombb)\n-\t    return false;\n \t}\n \n       /* Our common dominator has to be dominated by frombb in order to be a"}]}