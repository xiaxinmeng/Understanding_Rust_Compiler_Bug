{"sha": "644cb69f803dc904c271885272e70f032ce56a97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ0Y2I2OWY4MDNkYzkwNGMyNzE4ODUyNzJlNzBmMDMyY2U1NmE5Nw==", "commit": {"author": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2005-10-03T07:22:20Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2005-10-03T07:22:20Z"}, "message": "re PR libfortran/19308 (I/O library should support more real and integer kinds)\n\n\tPR libfortran/19308\n\tPR fortran/20120\n\tPR libfortran/22437\n\n\t* Makefile.am: Add generated files for large real and integers\n\tkinds. Add a rule to create the kinds.inc c99_protos.inc files.\n\tUse kinds.inc to preprocess Fortran generated files.\n\t* libgfortran.h: Add macro definitions for GFC_INTEGER_16_HUGE,\n\tGFC_REAL_10_HUGE and GFC_REAL_16_HUGE. Add types gfc_array_i16,\n\tgfc_array_r10, gfc_array_r16, gfc_array_c10, gfc_array_c16,\n\tgfc_array_l16.\n\t* mk-kinds-h.sh: Define macros HAVE_GFC_LOGICAL_* and\n\tHAVE_GFC_COMPLEX_* when these types are available.\n\t* intrinsics/ishftc.c (ishftc16): New function for GFC_INTEGER_16.\n\t* m4/all.m4, m4/any.m4, m4/count.m4, m4/cshift1.m4, m4/dotprod.m4,\n\tm4/dotprodc.m4, m4/dotprodl.m4, m4/eoshift1.m4, m4/eoshift3.m4,\n\tm4/exponent.m4, m4/fraction.m4, m4/in_pack.m4, m4/in_unpack.m4,\n\tm4/matmul.m4, m4/matmull.m4, m4/maxloc0.m4, m4/maxloc1.m4,\n\tm4/maxval.m4, m4/minloc0.m4, m4/minloc1.m4, m4/minval.m4, m4/mtype.m4,\n\tm4/nearest.m4, m4/pow.m4, m4/product.m4, m4/reshape.m4,\n\tm4/set_exponent.m4, m4/shape.m4, m4/specific.m4, m4/specific2.m4,\n\tm4/sum.m4, m4/transpose.m4: Protect generated functions with\n\tappropriate \"#if defined (HAVE_GFC_type_kind)\" preprocessor directives.\n\t* Makefile.in: Regenerate.\n\t* all files in generated/: Regenerate.\n\n\t* f95-lang.c (DO_DEFINE_MATH_BUILTIN): Add support for long\n\tdouble builtin function.\n\t(gfc_init_builtin_functions): Add mfunc_longdouble,\n\tmfunc_clongdouble and func_clongdouble_longdouble trees. Build\n\tthem for round, trunc, cabs, copysign and pow functions.\n\t* iresolve.c (gfc_resolve_reshape, gfc_resolve_transpose): Add\n\tcase for kind 10 and 16.\n\t* trans-decl.c: Add trees for cpowl10, cpowl16, ishftc16,\n\texponent10 and exponent16.\n\t(gfc_build_intrinsic_function_decls): Build nodes for int16,\n\treal10, real16, complex10 and complex16 types. Build all possible\n\tcombinations for function _gfortran_pow_?n_?n. Build function\n\tcalls cpowl10, cpowl16, ishftc16, exponent10 and exponent16.\n\t* trans-expr.c (gfc_conv_power_op): Add case for integer(16),\n\treal(10) and real(16).\n\t* trans-intrinsic.c: Add suppport for long double builtin\n\tfunctions in BUILT_IN_FUNCTION, LIBM_FUNCTION and LIBF_FUNCTION\n\tmacros.\n\t(gfc_conv_intrinsic_aint): Add case for integer(16), real(10) and\n\treal(16) kinds.\n\t(gfc_build_intrinsic_lib_fndecls): Add support for real10_decl\n\tand real16_decl in library functions.\n\t(gfc_get_intrinsic_lib_fndecl): Add cases for real and complex\n\tkinds 10 and 16.\n\t(gfc_conv_intrinsic_exponent): Add cases for real(10) and real(16)\n\tkinds.\n\t(gfc_conv_intrinsic_sign): Likewise.\n\t(gfc_conv_intrinsic_ishftc): Add case for integer(16) kind.\n\t* trans-types.c (gfc_get_int_type, gfc_get_real_type,\n\tgfc_get_complex_type, gfc_get_logical_type): Doesn't error out in\n\tthe case of kinds not available.\n\t* trans.h: Declare trees for cpowl10, cpowl16, ishftc16,\n\texponent10 and exponent16.\n\n\t* gfortran.dg/large_real_kind_2.F90: New test.\n\t* gfortran.dg/large_integer_kind_2.f90: New test.\n\nFrom-SVN: r104889", "tree": {"sha": "8bb857b1bc8bb03e3ba5509a8bba4513942fff4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bb857b1bc8bb03e3ba5509a8bba4513942fff4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/644cb69f803dc904c271885272e70f032ce56a97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/644cb69f803dc904c271885272e70f032ce56a97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/644cb69f803dc904c271885272e70f032ce56a97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/644cb69f803dc904c271885272e70f032ce56a97/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41a182c62d6314c2c3c138ebe358da485691f1b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41a182c62d6314c2c3c138ebe358da485691f1b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41a182c62d6314c2c3c138ebe358da485691f1b7"}], "stats": {"total": 36362, "additions": 35858, "deletions": 504}, "files": [{"sha": "0a8c4438a9b1ac30dd21b4eae9325a15e97c1953", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -1,3 +1,40 @@\n+2005-10-03  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR fortran/20120\n+\t* f95-lang.c (DO_DEFINE_MATH_BUILTIN): Add support for long\n+\tdouble builtin function.\n+\t(gfc_init_builtin_functions): Add mfunc_longdouble,\n+\tmfunc_clongdouble and func_clongdouble_longdouble trees. Build\n+\tthem for round, trunc, cabs, copysign and pow functions.\n+\t* iresolve.c (gfc_resolve_reshape, gfc_resolve_transpose): Add\n+\tcase for kind 10 and 16.\n+\t* trans-decl.c: Add trees for cpowl10, cpowl16, ishftc16,\n+\texponent10 and exponent16.\n+\t(gfc_build_intrinsic_function_decls): Build nodes for int16,\n+\treal10, real16, complex10 and complex16 types. Build all possible\n+\tcombinations for function _gfortran_pow_?n_?n. Build function\n+\tcalls cpowl10, cpowl16, ishftc16, exponent10 and exponent16.\n+\t* trans-expr.c (gfc_conv_power_op): Add case for integer(16),\n+\treal(10) and real(16).\n+\t* trans-intrinsic.c: Add suppport for long double builtin\n+\tfunctions in BUILT_IN_FUNCTION, LIBM_FUNCTION and LIBF_FUNCTION\n+\tmacros.\n+\t(gfc_conv_intrinsic_aint): Add case for integer(16), real(10) and\n+\treal(16) kinds.\n+\t(gfc_build_intrinsic_lib_fndecls): Add support for real10_decl\n+\tand real16_decl in library functions.\n+\t(gfc_get_intrinsic_lib_fndecl): Add cases for real and complex\n+\tkinds 10 and 16.\n+\t(gfc_conv_intrinsic_exponent): Add cases for real(10) and real(16)\n+\tkinds.\n+\t(gfc_conv_intrinsic_sign): Likewise.\n+\t(gfc_conv_intrinsic_ishftc): Add case for integer(16) kind.\n+\t* trans-types.c (gfc_get_int_type, gfc_get_real_type,\n+\tgfc_get_complex_type, gfc_get_logical_type): Doesn't error out in\n+\tthe case of kinds not available.\n+\t* trans.h: Declare trees for cpowl10, cpowl16, ishftc16,\n+\texponent10 and exponent16.\n+\n 2005-10-01  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/16404"}, {"sha": "b28980b33617364b689d1c26bf6ecd00d81fc809", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -718,6 +718,8 @@ gfc_define_builtin (const char * name,\n \n \n #define DO_DEFINE_MATH_BUILTIN(code, name, argtype, tbase) \\\n+    gfc_define_builtin (\"__builtin_\" name \"l\", tbase##longdouble[argtype], \\\n+                       BUILT_IN_ ## code ## L, name \"l\", true); \\\n     gfc_define_builtin (\"__builtin_\" name, tbase##double[argtype], \\\n \t\t\tBUILT_IN_ ## code, name, true); \\\n     gfc_define_builtin (\"__builtin_\" name \"f\", tbase##float[argtype], \\\n@@ -726,11 +728,9 @@ gfc_define_builtin (const char * name,\n #define DEFINE_MATH_BUILTIN(code, name, argtype) \\\n     DO_DEFINE_MATH_BUILTIN (code, name, argtype, mfunc_)\n \n-/* The middle-end is missing builtins for some complex math functions, so\n-   we don't use them yet.  */\n #define DEFINE_MATH_BUILTIN_C(code, name, argtype) \\\n-    DO_DEFINE_MATH_BUILTIN (code, name, argtype, mfunc_)\n-/*    DO_DEFINE_MATH_BUILTIN (C##code, \"c\" name, argtype, mfunc_c)*/\n+    DO_DEFINE_MATH_BUILTIN (code, name, argtype, mfunc_) \\\n+    DO_DEFINE_MATH_BUILTIN (C##code, \"c\" name, argtype, mfunc_c)\n \n \n /* Create function types for builtin functions.  */\n@@ -760,48 +760,68 @@ gfc_init_builtin_functions (void)\n {\n   tree mfunc_float[3];\n   tree mfunc_double[3];\n+  tree mfunc_longdouble[3];\n   tree mfunc_cfloat[3];\n   tree mfunc_cdouble[3];\n+  tree mfunc_clongdouble[3];\n   tree func_cfloat_float;\n   tree func_cdouble_double;\n+  tree func_clongdouble_longdouble;\n   tree ftype;\n   tree tmp;\n \n   build_builtin_fntypes (mfunc_float, float_type_node);\n   build_builtin_fntypes (mfunc_double, double_type_node);\n+  build_builtin_fntypes (mfunc_longdouble, long_double_type_node);\n   build_builtin_fntypes (mfunc_cfloat, complex_float_type_node);\n   build_builtin_fntypes (mfunc_cdouble, complex_double_type_node);\n+  build_builtin_fntypes (mfunc_clongdouble, complex_long_double_type_node);\n \n   tmp = tree_cons (NULL_TREE, complex_float_type_node, void_list_node);\n   func_cfloat_float = build_function_type (float_type_node, tmp);\n \n   tmp = tree_cons (NULL_TREE, complex_double_type_node, void_list_node);\n   func_cdouble_double = build_function_type (double_type_node, tmp);\n \n+  tmp = tree_cons (NULL_TREE, complex_long_double_type_node, void_list_node);\n+  func_clongdouble_longdouble =\n+    build_function_type (long_double_type_node, tmp);\n+\n #include \"mathbuiltins.def\"\n \n   /* We define these separately as the fortran versions have different\n      semantics (they return an integer type) */\n+  gfc_define_builtin (\"__builtin_roundl\", mfunc_longdouble[0], \n+\t\t      BUILT_IN_ROUNDL, \"roundl\", true);\n   gfc_define_builtin (\"__builtin_round\", mfunc_double[0], \n \t\t      BUILT_IN_ROUND, \"round\", true);\n   gfc_define_builtin (\"__builtin_roundf\", mfunc_float[0], \n \t\t      BUILT_IN_ROUNDF, \"roundf\", true);\n+\n+  gfc_define_builtin (\"__builtin_truncl\", mfunc_longdouble[0],\n+\t\t      BUILT_IN_TRUNCL, \"truncl\", true);\n   gfc_define_builtin (\"__builtin_trunc\", mfunc_double[0],\n                       BUILT_IN_TRUNC, \"trunc\", true);\n   gfc_define_builtin (\"__builtin_truncf\", mfunc_float[0],\n                       BUILT_IN_TRUNCF, \"truncf\", true);\n \n+  gfc_define_builtin (\"__builtin_cabsl\", func_clongdouble_longdouble, \n+\t\t      BUILT_IN_CABSL, \"cabsl\", true);\n   gfc_define_builtin (\"__builtin_cabs\", func_cdouble_double, \n \t\t      BUILT_IN_CABS, \"cabs\", true);\n   gfc_define_builtin (\"__builtin_cabsf\", func_cfloat_float, \n \t\t      BUILT_IN_CABSF, \"cabsf\", true);\n  \n+  gfc_define_builtin (\"__builtin_copysignl\", mfunc_longdouble[1], \n+\t\t      BUILT_IN_COPYSIGNL, \"copysignl\", true);\n   gfc_define_builtin (\"__builtin_copysign\", mfunc_double[1], \n \t\t      BUILT_IN_COPYSIGN, \"copysign\", true);\n   gfc_define_builtin (\"__builtin_copysignf\", mfunc_float[1], \n \t\t      BUILT_IN_COPYSIGNF, \"copysignf\", true);\n \n   /* These are used to implement the ** operator.  */\n+  gfc_define_builtin (\"__builtin_powl\", mfunc_longdouble[1], \n+\t\t      BUILT_IN_POWL, \"powl\", true);\n   gfc_define_builtin (\"__builtin_pow\", mfunc_double[1], \n \t\t      BUILT_IN_POW, \"pow\", true);\n   gfc_define_builtin (\"__builtin_powf\", mfunc_float[1], "}, {"sha": "195f05ed990e3635bb1c4284ad91549594bcb18d", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -1217,7 +1217,8 @@ gfc_resolve_reshape (gfc_expr * f, gfc_expr * source, gfc_expr * shape,\n     {\n     case 4:\n     case 8:\n-    /* case 16: */\n+    case 10:\n+    case 16:\n       if (source->ts.type == BT_COMPLEX)\n \tf->value.function.name =\n \t  gfc_get_string (PREFIX(\"reshape_%c%d\"),\n@@ -1538,6 +1539,8 @@ gfc_resolve_transpose (gfc_expr * f, gfc_expr * matrix)\n     {\n     case 4:\n     case 8:\n+    case 10:\n+    case 16:\n       switch (matrix->ts.type)\n         {\n         case BT_COMPLEX:"}, {"sha": "3f656ddc01fc8055840c35565ed747a7fe933fd8", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 87, "deletions": 29, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -94,13 +94,18 @@ tree gfor_fndecl_associated;\n /* Math functions.  Many other math functions are handled in\n    trans-intrinsic.c.  */\n \n-gfc_powdecl_list gfor_fndecl_math_powi[3][2];\n+gfc_powdecl_list gfor_fndecl_math_powi[4][3];\n tree gfor_fndecl_math_cpowf;\n tree gfor_fndecl_math_cpow;\n+tree gfor_fndecl_math_cpowl10;\n+tree gfor_fndecl_math_cpowl16;\n tree gfor_fndecl_math_ishftc4;\n tree gfor_fndecl_math_ishftc8;\n+tree gfor_fndecl_math_ishftc16;\n tree gfor_fndecl_math_exponent4;\n tree gfor_fndecl_math_exponent8;\n+tree gfor_fndecl_math_exponent10;\n+tree gfor_fndecl_math_exponent16;\n \n \n /* String functions.  */\n@@ -1691,11 +1696,16 @@ gfc_build_intrinsic_function_decls (void)\n {\n   tree gfc_int4_type_node = gfc_get_int_type (4);\n   tree gfc_int8_type_node = gfc_get_int_type (8);\n+  tree gfc_int16_type_node = gfc_get_int_type (16);\n   tree gfc_logical4_type_node = gfc_get_logical_type (4);\n   tree gfc_real4_type_node = gfc_get_real_type (4);\n   tree gfc_real8_type_node = gfc_get_real_type (8);\n+  tree gfc_real10_type_node = gfc_get_real_type (10);\n+  tree gfc_real16_type_node = gfc_get_real_type (16);\n   tree gfc_complex4_type_node = gfc_get_complex_type (4);\n   tree gfc_complex8_type_node = gfc_get_complex_type (8);\n+  tree gfc_complex10_type_node = gfc_get_complex_type (10);\n+  tree gfc_complex16_type_node = gfc_get_complex_type (16);\n \n   /* String functions.  */\n   gfor_fndecl_copy_string =\n@@ -1793,37 +1803,56 @@ gfc_build_intrinsic_function_decls (void)\n \n   /* Power functions.  */\n   {\n-    tree type;\n-    tree itype;\n-    int kind;\n-    int ikind;\n-    static int kinds[2] = {4, 8};\n-    char name[PREFIX_LEN + 10]; /* _gfortran_pow_?n_?n */\n-\n-    for (ikind=0; ikind < 2; ikind++)\n+    tree ctype, rtype, itype, jtype;\n+    int rkind, ikind, jkind;\n+#define NIKINDS 3\n+#define NRKINDS 4\n+    static int ikinds[NIKINDS] = {4, 8, 16};\n+    static int rkinds[NRKINDS] = {4, 8, 10, 16};\n+    char name[PREFIX_LEN + 12]; /* _gfortran_pow_?n_?n */\n+\n+    for (ikind=0; ikind < NIKINDS; ikind++)\n       {\n-\titype = gfc_get_int_type (kinds[ikind]);\n-\tfor (kind = 0; kind < 2; kind ++)\n+\titype = gfc_get_int_type (ikinds[ikind]);\n+\n+\tfor (jkind=0; jkind < NIKINDS; jkind++)\n+\t  {\n+\t    jtype = gfc_get_int_type (ikinds[jkind]);\n+\t    if (itype && jtype)\n+\t      {\n+\t\tsprintf(name, PREFIX(\"pow_i%d_i%d\"), ikinds[ikind],\n+\t\t\tikinds[jkind]);\n+\t\tgfor_fndecl_math_powi[jkind][ikind].integer =\n+\t\t  gfc_build_library_function_decl (get_identifier (name),\n+\t\t    jtype, 2, jtype, itype);\n+\t      }\n+\t  }\n+\n+\tfor (rkind = 0; rkind < NRKINDS; rkind ++)\n \t  {\n-\t    type = gfc_get_int_type (kinds[kind]);\n-\t    sprintf(name, PREFIX(\"pow_i%d_i%d\"), kinds[kind], kinds[ikind]);\n-\t    gfor_fndecl_math_powi[kind][ikind].integer =\n-\t      gfc_build_library_function_decl (get_identifier (name),\n-\t\t  type, 2, type, itype);\n-\n-\t    type = gfc_get_real_type (kinds[kind]);\n-\t    sprintf(name, PREFIX(\"pow_r%d_i%d\"), kinds[kind], kinds[ikind]);\n-\t    gfor_fndecl_math_powi[kind][ikind].real =\n-\t      gfc_build_library_function_decl (get_identifier (name),\n-\t\t  type, 2, type, itype);\n-\n-\t    type = gfc_get_complex_type (kinds[kind]);\n-\t    sprintf(name, PREFIX(\"pow_c%d_i%d\"), kinds[kind], kinds[ikind]);\n-\t    gfor_fndecl_math_powi[kind][ikind].cmplx =\n-\t      gfc_build_library_function_decl (get_identifier (name),\n-\t\t  type, 2, type, itype);\n+\t    rtype = gfc_get_real_type (rkinds[rkind]);\n+\t    if (rtype && itype)\n+\t      {\n+\t\tsprintf(name, PREFIX(\"pow_r%d_i%d\"), rkinds[rkind],\n+\t\t\tikinds[ikind]);\n+\t\tgfor_fndecl_math_powi[rkind][ikind].real =\n+\t\t  gfc_build_library_function_decl (get_identifier (name),\n+\t\t    rtype, 2, rtype, itype);\n+\t      }\n+\n+\t    ctype = gfc_get_complex_type (rkinds[rkind]);\n+\t    if (ctype && itype)\n+\t      {\n+\t\tsprintf(name, PREFIX(\"pow_c%d_i%d\"), rkinds[rkind],\n+\t\t\tikinds[ikind]);\n+\t\tgfor_fndecl_math_powi[rkind][ikind].cmplx =\n+\t\t  gfc_build_library_function_decl (get_identifier (name),\n+\t\t    ctype, 2,ctype, itype);\n+\t      }\n \t  }\n       }\n+#undef NIKINDS\n+#undef NRKINDS\n   }\n \n   gfor_fndecl_math_cpowf =\n@@ -1834,6 +1863,17 @@ gfc_build_intrinsic_function_decls (void)\n     gfc_build_library_function_decl (get_identifier (\"cpow\"),\n \t\t\t\t     gfc_complex8_type_node,\n \t\t\t\t     1, gfc_complex8_type_node);\n+  if (gfc_complex10_type_node)\n+    gfor_fndecl_math_cpowl10 =\n+      gfc_build_library_function_decl (get_identifier (\"cpowl\"),\n+\t\t\t\t       gfc_complex10_type_node, 1,\n+\t\t\t\t       gfc_complex10_type_node);\n+  if (gfc_complex16_type_node)\n+    gfor_fndecl_math_cpowl16 =\n+      gfc_build_library_function_decl (get_identifier (\"cpowl\"),\n+\t\t\t\t       gfc_complex16_type_node, 1,\n+\t\t\t\t       gfc_complex16_type_node);\n+\n   gfor_fndecl_math_ishftc4 =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"ishftc4\")),\n \t\t\t\t     gfc_int4_type_node,\n@@ -1843,7 +1883,15 @@ gfc_build_intrinsic_function_decls (void)\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"ishftc8\")),\n \t\t\t\t     gfc_int8_type_node,\n \t\t\t\t     3, gfc_int8_type_node,\n-\t\t\t\t     gfc_int8_type_node, gfc_int8_type_node);\n+\t\t\t\t     gfc_int4_type_node, gfc_int4_type_node);\n+  if (gfc_int16_type_node)\n+    gfor_fndecl_math_ishftc16 =\n+      gfc_build_library_function_decl (get_identifier (PREFIX(\"ishftc16\")),\n+\t\t\t\t       gfc_int16_type_node, 3,\n+\t\t\t\t       gfc_int16_type_node,\n+\t\t\t\t       gfc_int4_type_node,\n+\t\t\t\t       gfc_int4_type_node);\n+\n   gfor_fndecl_math_exponent4 =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"exponent_r4\")),\n \t\t\t\t     gfc_int4_type_node,\n@@ -1852,6 +1900,16 @@ gfc_build_intrinsic_function_decls (void)\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"exponent_r8\")),\n \t\t\t\t     gfc_int4_type_node,\n \t\t\t\t     1, gfc_real8_type_node);\n+  if (gfc_real10_type_node)\n+    gfor_fndecl_math_exponent10 =\n+      gfc_build_library_function_decl (get_identifier (PREFIX(\"exponent_r10\")),\n+\t\t\t\t       gfc_int4_type_node, 1,\n+\t\t\t\t       gfc_real10_type_node);\n+  if (gfc_real16_type_node)\n+    gfor_fndecl_math_exponent16 =\n+      gfc_build_library_function_decl (get_identifier (PREFIX(\"exponent_r16\")),\n+\t\t\t\t       gfc_int4_type_node, 1,\n+\t\t\t\t       gfc_real16_type_node);\n \n   /* Other functions.  */\n   gfor_fndecl_size0 ="}, {"sha": "7c6b4097bae83d2f5e908864e2979a27d65a32dd", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -691,6 +691,10 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \t  ikind = 1;\n \t  break;\n \n+\tcase 16:\n+\t  ikind = 2;\n+\t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -712,13 +716,23 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \t  kind = 1;\n \t  break;\n \n+\tcase 10:\n+\t  kind = 2;\n+\t  break;\n+\n+\tcase 16:\n+\t  kind = 3;\n+\t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n       \n       switch (expr->value.op.op1->ts.type)\n \t{\n \tcase BT_INTEGER:\n+\t  if (kind == 3) /* Case 16 was not handled properly above.  */\n+\t    kind = 2;\n \t  fndecl = gfor_fndecl_math_powi[kind][ikind].integer;\n \t  break;\n \n@@ -744,6 +758,10 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \tcase 8:\n \t  fndecl = built_in_decls[BUILT_IN_POW];\n \t  break;\n+\tcase 10:\n+\tcase 16:\n+\t  fndecl = built_in_decls[BUILT_IN_POWL];\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -758,6 +776,12 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \tcase 8:\n \t  fndecl = gfor_fndecl_math_cpow;\n \t  break;\n+\tcase 10:\n+\t  fndecl = gfor_fndecl_math_cpowl10;\n+\t  break;\n+\tcase 16:\n+\t  fndecl = gfor_fndecl_math_cpowl16;\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}"}, {"sha": "1d958e18ad74650c502bafc4f49670e54f80408c", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 90, "deletions": 25, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -52,14 +52,18 @@ typedef struct gfc_intrinsic_map_t\tGTY(())\n \n   /* Enum value from the \"language-independent\", aka C-centric, part\n      of gcc, or END_BUILTINS of no such value set.  */\n-  /* ??? There are now complex variants in builtins.def, though we\n-     don't currently do anything with them.  */\n-  enum built_in_function code4;\n-  enum built_in_function code8;\n+  enum built_in_function code_r4;\n+  enum built_in_function code_r8;\n+  enum built_in_function code_r10;\n+  enum built_in_function code_r16;\n+  enum built_in_function code_c4;\n+  enum built_in_function code_c8;\n+  enum built_in_function code_c10;\n+  enum built_in_function code_c16;\n \n   /* True if the naming pattern is to prepend \"c\" for complex and\n      append \"f\" for kind=4.  False if the naming pattern is to\n-     prepend \"_gfortran_\" and append \"[rc][48]\".  */\n+     prepend \"_gfortran_\" and append \"[rc](4|8|10|16)\".  */\n   bool libm_name;\n \n   /* True if a complex version of the function exists.  */\n@@ -74,32 +78,42 @@ typedef struct gfc_intrinsic_map_t\tGTY(())\n   /* Cache decls created for the various operand types.  */\n   tree real4_decl;\n   tree real8_decl;\n+  tree real10_decl;\n+  tree real16_decl;\n   tree complex4_decl;\n   tree complex8_decl;\n+  tree complex10_decl;\n+  tree complex16_decl;\n }\n gfc_intrinsic_map_t;\n \n /* ??? The NARGS==1 hack here is based on the fact that (c99 at least)\n    defines complex variants of all of the entries in mathbuiltins.def\n    except for atan2.  */\n-#define BUILT_IN_FUNCTION(ID, NAME, HAVE_COMPLEX) \\\n-  { GFC_ISYM_ ## ID, BUILT_IN_ ## ID ## F, BUILT_IN_ ## ID, true, \\\n-    HAVE_COMPLEX, true, NAME, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE},\n-\n-#define DEFINE_MATH_BUILTIN(id, name, argtype) \\\n-  BUILT_IN_FUNCTION (id, name, false)\n-\n-/* TODO: Use builtin function for complex intrinsics.  */\n-#define DEFINE_MATH_BUILTIN_C(id, name, argtype) \\\n-  BUILT_IN_FUNCTION (id, name, true)\n+#define DEFINE_MATH_BUILTIN(ID, NAME, ARGTYPE) \\\n+  { GFC_ISYM_ ## ID, BUILT_IN_ ## ID ## F, BUILT_IN_ ## ID, \\\n+    BUILT_IN_ ## ID ## L, BUILT_IN_ ## ID ## L, 0, 0, 0, 0, true, \\\n+    false, true, NAME, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, \\\n+    NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE},\n+\n+#define DEFINE_MATH_BUILTIN_C(ID, NAME, ARGTYPE) \\\n+  { GFC_ISYM_ ## ID, BUILT_IN_ ## ID ## F, BUILT_IN_ ## ID, \\\n+    BUILT_IN_ ## ID ## L, BUILT_IN_ ## ID ## L, BUILT_IN_C ## ID ## F, \\\n+    BUILT_IN_C ## ID, BUILT_IN_C ## ID ## L, BUILT_IN_C ## ID ## L, true, \\\n+    true, true, NAME, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, \\\n+    NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE},\n \n #define LIBM_FUNCTION(ID, NAME, HAVE_COMPLEX) \\\n-  { GFC_ISYM_ ## ID, END_BUILTINS, END_BUILTINS, true, HAVE_COMPLEX, true, \\\n-    NAME, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE }\n+  { GFC_ISYM_ ## ID, END_BUILTINS, END_BUILTINS, END_BUILTINS, END_BUILTINS, \\\n+    END_BUILTINS, END_BUILTINS, END_BUILTINS, END_BUILTINS, \\\n+    true, HAVE_COMPLEX, true, NAME, NULL_TREE, NULL_TREE, NULL_TREE, \\\n+    NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE }\n \n #define LIBF_FUNCTION(ID, NAME, HAVE_COMPLEX) \\\n-  { GFC_ISYM_ ## ID, END_BUILTINS, END_BUILTINS, false, HAVE_COMPLEX, true, \\\n-    NAME, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE }\n+  { GFC_ISYM_ ## ID, END_BUILTINS, END_BUILTINS, END_BUILTINS, END_BUILTINS, \\\n+    END_BUILTINS, END_BUILTINS, END_BUILTINS, END_BUILTINS, \\\n+    false, HAVE_COMPLEX, true, NAME, NULL_TREE, NULL_TREE, NULL_TREE, \\\n+    NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE }\n \n static GTY(()) gfc_intrinsic_map_t gfc_intrinsic_map[] =\n {\n@@ -122,7 +136,6 @@ static GTY(()) gfc_intrinsic_map_t gfc_intrinsic_map[] =\n };\n #undef DEFINE_MATH_BUILTIN\n #undef DEFINE_MATH_BUILTIN_C\n-#undef BUILT_IN_FUNCTION\n #undef LIBM_FUNCTION\n #undef LIBF_FUNCTION\n \n@@ -336,6 +349,11 @@ gfc_conv_intrinsic_aint (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \tcase 8:\n \t  n = BUILT_IN_ROUND;\n \t  break;\n+\n+\tcase 10:\n+\tcase 16:\n+\t  n = BUILT_IN_ROUNDL;\n+\t  break;\n \t}\n       break;\n \n@@ -349,6 +367,11 @@ gfc_conv_intrinsic_aint (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \tcase 8:\n \t  n = BUILT_IN_TRUNC;\n \t  break;\n+\n+\tcase 10:\n+\tcase 16:\n+\t  n = BUILT_IN_TRUNCL;\n+\t  break;\n \t}\n       break;\n \n@@ -469,10 +492,22 @@ gfc_build_intrinsic_lib_fndecls (void)\n   /* Add GCC builtin functions.  */\n   for (m = gfc_intrinsic_map; m->id != GFC_ISYM_NONE; m++)\n     {\n-      if (m->code4 != END_BUILTINS)\n-        m->real4_decl = built_in_decls[m->code4];\n-      if (m->code8 != END_BUILTINS)\n-\tm->real8_decl = built_in_decls[m->code8];\n+      if (m->code_r4 != END_BUILTINS)\n+\tm->real4_decl = built_in_decls[m->code_r4];\n+      if (m->code_r8 != END_BUILTINS)\n+\tm->real8_decl = built_in_decls[m->code_r8];\n+      if (m->code_r10 != END_BUILTINS)\n+\tm->real10_decl = built_in_decls[m->code_r10];\n+      if (m->code_r16 != END_BUILTINS)\n+\tm->real16_decl = built_in_decls[m->code_r16];\n+      if (m->code_c4 != END_BUILTINS)\n+\tm->complex4_decl = built_in_decls[m->code_c4];\n+      if (m->code_c8 != END_BUILTINS)\n+\tm->complex8_decl = built_in_decls[m->code_c8];\n+      if (m->code_c10 != END_BUILTINS)\n+\tm->complex10_decl = built_in_decls[m->code_c10];\n+      if (m->code_c16 != END_BUILTINS)\n+\tm->complex16_decl = built_in_decls[m->code_c16];\n     }\n }\n \n@@ -501,6 +536,12 @@ gfc_get_intrinsic_lib_fndecl (gfc_intrinsic_map_t * m, gfc_expr * expr)\n \tcase 8:\n \t  pdecl = &m->real8_decl;\n \t  break;\n+\tcase 10:\n+\t  pdecl = &m->real10_decl;\n+\t  break;\n+\tcase 16:\n+\t  pdecl = &m->real16_decl;\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -517,6 +558,12 @@ gfc_get_intrinsic_lib_fndecl (gfc_intrinsic_map_t * m, gfc_expr * expr)\n \tcase 8:\n \t  pdecl = &m->complex8_decl;\n \t  break;\n+\tcase 10:\n+\t  pdecl = &m->complex10_decl;\n+\t  break;\n+\tcase 16:\n+\t  pdecl = &m->complex16_decl;\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -529,7 +576,8 @@ gfc_get_intrinsic_lib_fndecl (gfc_intrinsic_map_t * m, gfc_expr * expr)\n \n   if (m->libm_name)\n     {\n-      gcc_assert (ts->kind == 4 || ts->kind == 8);\n+      gcc_assert (ts->kind == 4 || ts->kind == 8 || ts->kind == 10\n+                 || ts->kind == 16);\n       snprintf (name, sizeof (name), \"%s%s%s\",\n \t\tts->type == BT_COMPLEX ? \"c\" : \"\",\n \t\tm->name,\n@@ -615,6 +663,12 @@ gfc_conv_intrinsic_exponent (gfc_se * se, gfc_expr * expr)\n     case 8:\n       fndecl = gfor_fndecl_math_exponent8;\n       break;\n+    case 10:\n+      fndecl = gfor_fndecl_math_exponent10;\n+      break;\n+    case 16:\n+      fndecl = gfor_fndecl_math_exponent16;\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -734,6 +788,10 @@ gfc_conv_intrinsic_abs (gfc_se * se, gfc_expr * expr)\n \tcase 8:\n \t  n = BUILT_IN_CABS;\n \t  break;\n+\tcase 10:\n+\tcase 16:\n+\t  n = BUILT_IN_CABSL;\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -896,6 +954,10 @@ gfc_conv_intrinsic_sign (gfc_se * se, gfc_expr * expr)\n \tcase 8:\n \t  tmp = built_in_decls[BUILT_IN_COPYSIGN];\n \t  break;\n+\tcase 10:\n+\tcase 16:\n+\t  tmp = built_in_decls[BUILT_IN_COPYSIGNL];\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -1861,6 +1923,9 @@ gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n \tcase 8:\n \t  tmp = gfor_fndecl_math_ishftc8;\n \t  break;\n+\tcase 16:\n+\t  tmp = gfor_fndecl_math_ishftc16;\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}"}, {"sha": "6482df811612190a2c663a8b946562c9b9db641d", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -566,29 +566,29 @@ gfc_init_types (void)\n tree\n gfc_get_int_type (int kind)\n {\n-  int index = gfc_validate_kind (BT_INTEGER, kind, false);\n-  return gfc_integer_types[index];\n+  int index = gfc_validate_kind (BT_INTEGER, kind, true);\n+  return index < 0 ? 0 : gfc_integer_types[index];\n }\n \n tree\n gfc_get_real_type (int kind)\n {\n-  int index = gfc_validate_kind (BT_REAL, kind, false);\n-  return gfc_real_types[index];\n+  int index = gfc_validate_kind (BT_REAL, kind, true);\n+  return index < 0 ? 0 : gfc_real_types[index];\n }\n \n tree\n gfc_get_complex_type (int kind)\n {\n-  int index = gfc_validate_kind (BT_COMPLEX, kind, false);\n-  return gfc_complex_types[index];\n+  int index = gfc_validate_kind (BT_COMPLEX, kind, true);\n+  return index < 0 ? 0 : gfc_complex_types[index];\n }\n \n tree\n gfc_get_logical_type (int kind)\n {\n-  int index = gfc_validate_kind (BT_LOGICAL, kind, false);\n-  return gfc_logical_types[index];\n+  int index = gfc_validate_kind (BT_LOGICAL, kind, true);\n+  return index < 0 ? 0 : gfc_logical_types[index];\n }\n \f\n /* Create a character type with the given kind and length.  */"}, {"sha": "e64640cfd0c4312960885127313dd0a63f357357", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -471,13 +471,18 @@ typedef struct gfc_powdecl_list GTY(())\n }\n gfc_powdecl_list;\n \n-extern GTY(()) gfc_powdecl_list gfor_fndecl_math_powi[3][2];\n+extern GTY(()) gfc_powdecl_list gfor_fndecl_math_powi[4][3];\n extern GTY(()) tree gfor_fndecl_math_cpowf;\n extern GTY(()) tree gfor_fndecl_math_cpow;\n+extern GTY(()) tree gfor_fndecl_math_cpowl10;\n+extern GTY(()) tree gfor_fndecl_math_cpowl16;\n extern GTY(()) tree gfor_fndecl_math_ishftc4;\n extern GTY(()) tree gfor_fndecl_math_ishftc8;\n+extern GTY(()) tree gfor_fndecl_math_ishftc16;\n extern GTY(()) tree gfor_fndecl_math_exponent4;\n extern GTY(()) tree gfor_fndecl_math_exponent8;\n+extern GTY(()) tree gfor_fndecl_math_exponent10;\n+extern GTY(()) tree gfor_fndecl_math_exponent16;\n \n /* String functions.  */\n extern GTY(()) tree gfor_fndecl_copy_string;"}, {"sha": "ea8a2a7dd5a5fad79021acb5d0449fe84c1c1141", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -1,3 +1,9 @@\n+2005-10-03  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR libfortran/19308\n+\t* gfortran.dg/large_real_kind_2.F90: New test.\n+\t* gfortran.dg/large_integer_kind_2.f90: New test.\n+\n 2005-10-03  Uros Bizjak  <uros@kss-loka.si>\n \n \t* lib/target-supports.exp (check_effective_target_vect_shift):"}, {"sha": "68e64ab8ee43b0b994ccf9c995250718c87c0179", "filename": "gcc/testsuite/gfortran.dg/large_integer_kind_2.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ftestsuite%2Fgfortran.dg%2Flarge_integer_kind_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ftestsuite%2Fgfortran.dg%2Flarge_integer_kind_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flarge_integer_kind_2.f90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do run }\n+! { dg-require-effective-target fortran_large_int }\n+\n+! Testing library calls on large integer kinds (larger than kind=8)\n+  implicit none\n+\n+  integer,parameter :: k = selected_int_kind (range (0_8) + 1)\n+\n+  integer(kind=k) :: i, j\n+  integer(8) :: a, b\n+\n+  i = 0; j = 1; a = i; b = j\n+  if (i ** j /= a ** b) call abort\n+\n+end"}, {"sha": "4eb5a7fd8831c217e48cba4b25602e9306a8cad9", "filename": "gcc/testsuite/gfortran.dg/large_real_kind_2.F90", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ftestsuite%2Fgfortran.dg%2Flarge_real_kind_2.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/gcc%2Ftestsuite%2Fgfortran.dg%2Flarge_real_kind_2.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flarge_real_kind_2.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,106 @@\n+! { dg-do run }\n+! { dg-require-effective-target fortran_large_real }\n+\n+! Testing library calls on large real kinds (larger than kind=8)\n+  implicit none\n+\n+  integer,parameter :: k = selected_real_kind (precision (0.0_8) + 1)\n+  real(8),parameter :: eps = 1e-8\n+\n+  real(kind=k) :: x, x1\n+  real(8) :: y, y1\n+  complex(kind=k) :: z, z1\n+  complex(8) :: w, w1\n+\n+#define TEST_FUNCTION(func,val) \\\n+ x = val ;\\\n+ y = x ;\\\n+ x = func (x) ;\\\n+ y = func (y) ;\\\n+ if (abs((y - x) / y) > eps) call abort\n+  \n+#define CTEST_FUNCTION(func,valc) \\\n+ z = valc ;\\\n+ w = z ;\\\n+ z = func (z) ;\\\n+ w = func (w) ;\\\n+ if (abs((z - w) / w) > eps) call abort\n+\n+ TEST_FUNCTION(cos,17.456)\n+ TEST_FUNCTION(sin,17.456)\n+ TEST_FUNCTION(tan,1.456)\n+ TEST_FUNCTION(cosh,-2.45)\n+ TEST_FUNCTION(sinh,7.1)\n+ TEST_FUNCTION(tanh,12.7)\n+ TEST_FUNCTION(acos,0.78)\n+ TEST_FUNCTION(asin,-0.24)\n+ TEST_FUNCTION(atan,-17.123)\n+ TEST_FUNCTION(acosh,0.2)\n+ TEST_FUNCTION(asinh,0.3)\n+ TEST_FUNCTION(atanh,0.4)\n+ TEST_FUNCTION(exp,1.74)\n+ TEST_FUNCTION(log,0.00178914)\n+ TEST_FUNCTION(log10,123789.123)\n+ TEST_FUNCTION(sqrt,789.1356)\n+ TEST_FUNCTION(erf,1.45123231)\n+ TEST_FUNCTION(erfc,-0.123789)\n+\n+ CTEST_FUNCTION(cos,(17.456,-1.123))\n+ CTEST_FUNCTION(sin,(17.456,-7.6))\n+ CTEST_FUNCTION(exp,(1.74,-1.01))\n+ CTEST_FUNCTION(log,(0.00178914,-1.207))\n+ CTEST_FUNCTION(sqrt,(789.1356,2.4))\n+\n+#define TEST_POWER(val1,val2) \\\n+ x = val1 ; \\\n+ y = x ; \\\n+ x1 = val2 ; \\\n+ y1 = x1; \\\n+ if (abs((x**x1 - y**y1)/(y**y1)) > eps) call abort\n+ \n+#define CTEST_POWER(val1,val2) \\\n+ z = val1 ; \\\n+ w = z ; \\\n+ z1 = val2 ; \\\n+ w1 = z1; \\\n+ if (abs((z**z1 - w**w1)/(w**w1)) > eps) call abort\n+\n+ CTEST_POWER (1.0,1.0)\n+ CTEST_POWER (1.0,5.4)\n+ CTEST_POWER (1.0,-5.4)\n+ CTEST_POWER (1.0,0.0)\n+ CTEST_POWER (-1.0,1.0)\n+ CTEST_POWER (-1.0,5.4)\n+ CTEST_POWER (-1.0,-5.4)\n+ CTEST_POWER (-1.0,0.0)\n+ CTEST_POWER (0.0,1.0)\n+ CTEST_POWER (0.0,5.4)\n+ CTEST_POWER (0.0,-5.4)\n+ CTEST_POWER (0.0,0.0)\n+ CTEST_POWER (7.6,1.0)\n+ CTEST_POWER (7.6,5.4)\n+ CTEST_POWER (7.6,-5.4)\n+ CTEST_POWER (7.6,0.0)\n+ CTEST_POWER (-7.6,1.0)\n+ CTEST_POWER (-7.6,5.4)\n+ CTEST_POWER (-7.6,-5.4)\n+ CTEST_POWER (-7.6,0.0)\n+\n+ CTEST_POWER ((10.78,123.213),(14.123,13279.5))\n+ CTEST_POWER ((-10.78,123.213),(14.123,13279.5))\n+ CTEST_POWER ((10.78,-123.213),(14.123,13279.5))\n+ CTEST_POWER ((10.78,123.213),(-14.123,13279.5))\n+ CTEST_POWER ((10.78,123.213),(14.123,-13279.5))\n+ CTEST_POWER ((-10.78,-123.213),(14.123,13279.5))\n+ CTEST_POWER ((-10.78,123.213),(-14.123,13279.5))\n+ CTEST_POWER ((-10.78,123.213),(14.123,-13279.5))\n+ CTEST_POWER ((10.78,-123.213),(-14.123,13279.5))\n+ CTEST_POWER ((10.78,-123.213),(14.123,-13279.5))\n+ CTEST_POWER ((10.78,123.213),(-14.123,-13279.5))\n+ CTEST_POWER ((-10.78,-123.213),(-14.123,13279.5))\n+ CTEST_POWER ((-10.78,-123.213),(14.123,-13279.5))\n+ CTEST_POWER ((-10.78,123.213),(-14.123,-13279.5))\n+ CTEST_POWER ((10.78,-123.213),(-14.123,-13279.5))\n+ CTEST_POWER ((-10.78,-123.213),(-14.123,-13279.5))\n+ \n+end"}, {"sha": "34b07eb12d4307b17d81235a5e2398a6cb524ce8", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -1,3 +1,29 @@\n+2005-10-03  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR libfortran/19308\n+\tPR libfortran/22437\n+\t* Makefile.am: Add generated files for large real and integers\n+\tkinds. Add a rule to create the kinds.inc c99_protos.inc files.\n+\tUse kinds.inc to preprocess Fortran generated files.\n+\t* libgfortran.h: Add macro definitions for GFC_INTEGER_16_HUGE,\n+\tGFC_REAL_10_HUGE and GFC_REAL_16_HUGE. Add types gfc_array_i16,\n+\tgfc_array_r10, gfc_array_r16, gfc_array_c10, gfc_array_c16,\n+\tgfc_array_l16.\n+\t* mk-kinds-h.sh: Define macros HAVE_GFC_LOGICAL_* and\n+\tHAVE_GFC_COMPLEX_* when these types are available.\n+\t* intrinsics/ishftc.c (ishftc16): New function for GFC_INTEGER_16.\n+\t* m4/all.m4, m4/any.m4, m4/count.m4, m4/cshift1.m4, m4/dotprod.m4,\n+\tm4/dotprodc.m4, m4/dotprodl.m4, m4/eoshift1.m4, m4/eoshift3.m4,\n+\tm4/exponent.m4, m4/fraction.m4, m4/in_pack.m4, m4/in_unpack.m4,\n+\tm4/matmul.m4, m4/matmull.m4, m4/maxloc0.m4, m4/maxloc1.m4,\n+\tm4/maxval.m4, m4/minloc0.m4, m4/minloc1.m4, m4/minval.m4, m4/mtype.m4,\n+\tm4/nearest.m4, m4/pow.m4, m4/product.m4, m4/reshape.m4,\n+\tm4/set_exponent.m4, m4/shape.m4, m4/specific.m4, m4/specific2.m4,\n+\tm4/sum.m4, m4/transpose.m4: Protect generated functions with\n+\tappropriate \"#if defined (HAVE_GFC_type_kind)\" preprocessor directives.\n+\t* Makefile.in: Regenerate.\n+\t* all files in generated/: Regenerate.\n+\n 2005-10-01  Jakub Jelinek  <jakub@redhat.com>\n \n \t* runtime/memory.c (malloc_t): Remove.\n@@ -65,7 +91,7 @@\n \t* config.h.in: Regenerate.\n \t* libgfortan.h (isfinite): undef if broken, set if needed.\n \t(isnan): undef if broken, set if needed.\n-        (fpclassify): undef if broken, set if needed.\n+\t(fpclassify): undef if broken, set if needed.\n \t* io/write.c: Remove TODO comment about working isfinite.\n \t* intrinsics/c99_functions.c (round): Use isfinite instead\n \tof fpclassify."}, {"sha": "cac343b1da63a8c947a50a47bb0fb4c8297ddfc3", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 291, "deletions": 92, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -108,181 +108,313 @@ libgfortran.h\n \n i_all_c= \\\n generated/all_l4.c \\\n-generated/all_l8.c\n+generated/all_l8.c \\\n+generated/all_l16.c\n \n i_any_c= \\\n generated/any_l4.c \\\n-generated/any_l8.c\n+generated/any_l8.c \\\n+generated/any_l16.c\n \n i_count_c= \\\n generated/count_4_l4.c \\\n generated/count_8_l4.c \\\n+generated/count_16_l4.c \\\n generated/count_4_l8.c \\\n-generated/count_8_l8.c\n+generated/count_8_l8.c \\\n+generated/count_16_l8.c \\\n+generated/count_4_l16.c \\\n+generated/count_8_l16.c \\\n+generated/count_16_l16.c\n \n i_maxloc0_c= \\\n generated/maxloc0_4_i4.c \\\n generated/maxloc0_8_i4.c \\\n+generated/maxloc0_16_i4.c \\\n generated/maxloc0_4_i8.c \\\n generated/maxloc0_8_i8.c \\\n+generated/maxloc0_16_i8.c \\\n+generated/maxloc0_4_i16.c \\\n+generated/maxloc0_8_i16.c \\\n+generated/maxloc0_16_i16.c \\\n generated/maxloc0_4_r4.c \\\n generated/maxloc0_8_r4.c \\\n+generated/maxloc0_16_r4.c \\\n generated/maxloc0_4_r8.c \\\n-generated/maxloc0_8_r8.c\n+generated/maxloc0_8_r8.c \\\n+generated/maxloc0_16_r8.c \\\n+generated/maxloc0_4_r10.c \\\n+generated/maxloc0_8_r10.c \\\n+generated/maxloc0_16_r10.c \\\n+generated/maxloc0_4_r16.c \\\n+generated/maxloc0_8_r16.c \\\n+generated/maxloc0_16_r16.c\n \n i_maxloc1_c= \\\n generated/maxloc1_4_i4.c \\\n generated/maxloc1_8_i4.c \\\n+generated/maxloc1_16_i4.c \\\n generated/maxloc1_4_i8.c \\\n generated/maxloc1_8_i8.c \\\n+generated/maxloc1_16_i8.c \\\n+generated/maxloc1_4_i16.c \\\n+generated/maxloc1_8_i16.c \\\n+generated/maxloc1_16_i16.c \\\n generated/maxloc1_4_r4.c \\\n generated/maxloc1_8_r4.c \\\n+generated/maxloc1_16_r4.c \\\n generated/maxloc1_4_r8.c \\\n-generated/maxloc1_8_r8.c\n+generated/maxloc1_8_r8.c \\\n+generated/maxloc1_16_r8.c \\\n+generated/maxloc1_4_r10.c \\\n+generated/maxloc1_8_r10.c \\\n+generated/maxloc1_16_r10.c \\\n+generated/maxloc1_4_r16.c \\\n+generated/maxloc1_8_r16.c \\\n+generated/maxloc1_16_r16.c\n \n i_maxval_c= \\\n generated/maxval_i4.c \\\n generated/maxval_i8.c \\\n+generated/maxval_i16.c \\\n generated/maxval_r4.c \\\n-generated/maxval_r8.c\n+generated/maxval_r8.c \\\n+generated/maxval_r10.c \\\n+generated/maxval_r16.c\n \n i_minloc0_c= \\\n generated/minloc0_4_i4.c \\\n generated/minloc0_8_i4.c \\\n+generated/minloc0_16_i4.c \\\n generated/minloc0_4_i8.c \\\n generated/minloc0_8_i8.c \\\n+generated/minloc0_16_i8.c \\\n+generated/minloc0_4_i16.c \\\n+generated/minloc0_8_i16.c \\\n+generated/minloc0_16_i16.c \\\n generated/minloc0_4_r4.c \\\n generated/minloc0_8_r4.c \\\n+generated/minloc0_16_r4.c \\\n generated/minloc0_4_r8.c \\\n-generated/minloc0_8_r8.c\n+generated/minloc0_8_r8.c \\\n+generated/minloc0_16_r8.c \\\n+generated/minloc0_4_r10.c \\\n+generated/minloc0_8_r10.c \\\n+generated/minloc0_16_r10.c \\\n+generated/minloc0_4_r16.c \\\n+generated/minloc0_8_r16.c \\\n+generated/minloc0_16_r16.c\n \n i_minloc1_c= \\\n generated/minloc1_4_i4.c \\\n generated/minloc1_8_i4.c \\\n+generated/minloc1_16_i4.c \\\n generated/minloc1_4_i8.c \\\n generated/minloc1_8_i8.c \\\n+generated/minloc1_16_i8.c \\\n+generated/minloc1_4_i16.c \\\n+generated/minloc1_8_i16.c \\\n+generated/minloc1_16_i16.c \\\n generated/minloc1_4_r4.c \\\n generated/minloc1_8_r4.c \\\n+generated/minloc1_16_r4.c \\\n generated/minloc1_4_r8.c \\\n-generated/minloc1_8_r8.c\n+generated/minloc1_8_r8.c \\\n+generated/minloc1_16_r8.c \\\n+generated/minloc1_4_r10.c \\\n+generated/minloc1_8_r10.c \\\n+generated/minloc1_16_r10.c \\\n+generated/minloc1_4_r16.c \\\n+generated/minloc1_8_r16.c \\\n+generated/minloc1_16_r16.c\n \n i_minval_c= \\\n generated/minval_i4.c \\\n generated/minval_i8.c \\\n+generated/minval_i16.c \\\n generated/minval_r4.c \\\n-generated/minval_r8.c\n+generated/minval_r8.c \\\n+generated/minval_r10.c \\\n+generated/minval_r16.c\n \n i_sum_c= \\\n generated/sum_i4.c \\\n generated/sum_i8.c \\\n+generated/sum_i16.c \\\n generated/sum_r4.c \\\n generated/sum_r8.c \\\n+generated/sum_r10.c \\\n+generated/sum_r16.c \\\n generated/sum_c4.c \\\n-generated/sum_c8.c\n+generated/sum_c8.c \\\n+generated/sum_c10.c \\\n+generated/sum_c16.c\n \n i_product_c= \\\n generated/product_i4.c \\\n generated/product_i8.c \\\n+generated/product_i16.c \\\n generated/product_r4.c \\\n generated/product_r8.c \\\n+generated/product_r10.c \\\n+generated/product_r16.c \\\n generated/product_c4.c \\\n-generated/product_c8.c\n+generated/product_c8.c \\\n+generated/product_c10.c \\\n+generated/product_c16.c\n \n i_dotprod_c= \\\n generated/dotprod_i4.c \\\n generated/dotprod_i8.c \\\n+generated/dotprod_i16.c \\\n generated/dotprod_r4.c \\\n-generated/dotprod_r8.c\n+generated/dotprod_r8.c \\\n+generated/dotprod_r10.c \\\n+generated/dotprod_r16.c\n \n i_dotprodl_c= \\\n generated/dotprod_l4.c \\\n-generated/dotprod_l8.c\n+generated/dotprod_l8.c \\\n+generated/dotprod_l16.c\n \n i_dotprodc_c= \\\n generated/dotprod_c4.c \\\n-generated/dotprod_c8.c\n+generated/dotprod_c8.c \\\n+generated/dotprod_c10.c \\\n+generated/dotprod_c16.c\n \n i_matmul_c= \\\n generated/matmul_i4.c \\\n generated/matmul_i8.c \\\n+generated/matmul_i16.c \\\n generated/matmul_r4.c \\\n generated/matmul_r8.c \\\n+generated/matmul_r10.c \\\n+generated/matmul_r16.c \\\n generated/matmul_c4.c \\\n-generated/matmul_c8.c\n+generated/matmul_c8.c \\\n+generated/matmul_c10.c \\\n+generated/matmul_c16.c\n \n i_matmull_c= \\\n generated/matmul_l4.c \\\n-generated/matmul_l8.c\n+generated/matmul_l8.c \\\n+generated/matmul_l16.c\n \n i_transpose_c= \\\n generated/transpose_i4.c \\\n generated/transpose_i8.c \\\n+generated/transpose_i16.c \\\n generated/transpose_c4.c \\\n-generated/transpose_c8.c\n+generated/transpose_c8.c \\\n+generated/transpose_c10.c \\\n+generated/transpose_c16.c\n \n i_shape_c= \\\n generated/shape_i4.c \\\n-generated/shape_i8.c\n+generated/shape_i8.c \\\n+generated/shape_i16.c\n \n i_reshape_c= \\\n generated/reshape_i4.c \\\n generated/reshape_i8.c \\\n+generated/reshape_i16.c \\\n generated/reshape_c4.c \\\n-generated/reshape_c8.c\n+generated/reshape_c8.c \\\n+generated/reshape_c10.c \\\n+generated/reshape_c16.c\n \n i_eoshift1_c= \\\n generated/eoshift1_4.c \\\n-generated/eoshift1_8.c\n+generated/eoshift1_8.c \\\n+generated/eoshift1_16.c\n \n i_eoshift3_c= \\\n generated/eoshift3_4.c \\\n-generated/eoshift3_8.c\n+generated/eoshift3_8.c \\\n+generated/eoshift3_16.c\n \n i_cshift1_c= \\\n generated/cshift1_4.c \\\n-generated/cshift1_8.c\n+generated/cshift1_8.c \\\n+generated/cshift1_16.c\n \n in_pack_c = \\\n generated/in_pack_i4.c \\\n generated/in_pack_i8.c \\\n+generated/in_pack_i16.c \\\n generated/in_pack_c4.c \\\n-generated/in_pack_c8.c\n+generated/in_pack_c8.c \\\n+generated/in_pack_c10.c \\\n+generated/in_pack_c16.c\n \n in_unpack_c = \\\n generated/in_unpack_i4.c \\\n generated/in_unpack_i8.c \\\n+generated/in_unpack_i16.c \\\n generated/in_unpack_c4.c \\\n-generated/in_unpack_c8.c\n+generated/in_unpack_c8.c \\\n+generated/in_unpack_c10.c \\\n+generated/in_unpack_c16.c\n \n i_exponent_c = \\\n generated/exponent_r4.c \\\n-generated/exponent_r8.c\n+generated/exponent_r8.c \\\n+generated/exponent_r10.c \\\n+generated/exponent_r16.c\n \n i_fraction_c = \\\n generated/fraction_r4.c \\\n-generated/fraction_r8.c\n+generated/fraction_r8.c \\\n+generated/fraction_r10.c \\\n+generated/fraction_r16.c\n \n i_nearest_c = \\\n generated/nearest_r4.c \\\n-generated/nearest_r8.c\n+generated/nearest_r8.c \\\n+generated/nearest_r10.c \\\n+generated/nearest_r16.c\n \n i_set_exponent_c = \\\n generated/set_exponent_r4.c \\\n-generated/set_exponent_r8.c\n+generated/set_exponent_r8.c \\\n+generated/set_exponent_r10.c \\\n+generated/set_exponent_r16.c\n \n i_pow_c = \\\n generated/pow_i4_i4.c \\\n generated/pow_i8_i4.c \\\n+generated/pow_i16_i4.c \\\n generated/pow_r4_i4.c \\\n generated/pow_r8_i4.c \\\n+generated/pow_r10_i4.c \\\n+generated/pow_r16_i4.c \\\n generated/pow_c4_i4.c \\\n generated/pow_c8_i4.c \\\n+generated/pow_c10_i4.c \\\n+generated/pow_c16_i4.c \\\n generated/pow_i4_i8.c \\\n generated/pow_i8_i8.c \\\n+generated/pow_i16_i8.c \\\n generated/pow_r4_i8.c \\\n generated/pow_r8_i8.c \\\n+generated/pow_r10_i8.c \\\n+generated/pow_r16_i8.c \\\n generated/pow_c4_i8.c \\\n-generated/pow_c8_i8.c\n+generated/pow_c8_i8.c \\\n+generated/pow_c10_i8.c \\\n+generated/pow_c16_i8.c \\\n+generated/pow_i4_i16.c \\\n+generated/pow_i8_i16.c \\\n+generated/pow_i16_i16.c \\\n+generated/pow_r4_i16.c \\\n+generated/pow_r8_i16.c \\\n+generated/pow_r10_i16.c \\\n+generated/pow_r16_i16.c \\\n+generated/pow_c4_i16.c \\\n+generated/pow_c8_i16.c \\\n+generated/pow_c10_i16.c \\\n+generated/pow_c16_i16.c\n \n m4_files= m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/any.m4 m4/count.m4 m4/maxloc0.m4 m4/maxloc1.m4 m4/maxval.m4 \\\n@@ -300,74 +432,135 @@ gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_eoshift3_c) $(i_cshift1_c) $(i_reshape_c) $(in_pack_c) $(in_unpack_c) \\\n     $(i_exponent_c) $(i_fraction_c) $(i_nearest_c) $(i_set_exponent_c) \\\n     $(i_pow_c) \\\n-    selected_int_kind.inc selected_real_kind.inc kinds.h\n+    selected_int_kind.inc selected_real_kind.inc kinds.h \\\n+    kinds.inc c99_protos.inc\n \n # Machine generated specifics\n gfor_built_specific_src= \\\n-generated/_abs_c4.f90 \\\n-generated/_abs_c8.f90 \\\n-generated/_abs_i4.f90 \\\n-generated/_abs_i8.f90 \\\n-generated/_abs_r4.f90 \\\n-generated/_abs_r8.f90 \\\n-generated/_exp_r4.f90 \\\n-generated/_exp_r8.f90 \\\n-generated/_exp_c4.f90 \\\n-generated/_exp_c8.f90 \\\n-generated/_log_r4.f90 \\\n-generated/_log_r8.f90 \\\n-generated/_log_c4.f90 \\\n-generated/_log_c8.f90 \\\n-generated/_log10_r4.f90 \\\n-generated/_log10_r8.f90 \\\n-generated/_sqrt_r4.f90 \\\n-generated/_sqrt_r8.f90 \\\n-generated/_sqrt_c4.f90 \\\n-generated/_sqrt_c8.f90 \\\n-generated/_asin_r4.f90 \\\n-generated/_asin_r8.f90 \\\n-generated/_acos_r4.f90 \\\n-generated/_acos_r8.f90 \\\n-generated/_atan_r4.f90 \\\n-generated/_atan_r8.f90 \\\n-generated/_sin_r4.f90 \\\n-generated/_sin_r8.f90 \\\n-generated/_sin_c4.f90 \\\n-generated/_sin_c8.f90 \\\n-generated/_cos_r4.f90 \\\n-generated/_cos_r8.f90 \\\n-generated/_cos_c4.f90 \\\n-generated/_cos_c8.f90 \\\n-generated/_tan_r4.f90 \\\n-generated/_tan_r8.f90 \\\n-generated/_sinh_r4.f90 \\\n-generated/_sinh_r8.f90 \\\n-generated/_cosh_r4.f90 \\\n-generated/_cosh_r8.f90 \\\n-generated/_tanh_r4.f90 \\\n-generated/_tanh_r8.f90 \\\n-generated/_conjg_c4.f90 \\\n-generated/_conjg_c8.f90 \\\n-generated/_aint_r4.f90 \\\n-generated/_aint_r8.f90 \\\n-generated/_anint_r4.f90 \\\n-generated/_anint_r8.f90\n+generated/_abs_c4.F90 \\\n+generated/_abs_c8.F90 \\\n+generated/_abs_c10.F90 \\\n+generated/_abs_c16.F90 \\\n+generated/_abs_i4.F90 \\\n+generated/_abs_i8.F90 \\\n+generated/_abs_i16.F90 \\\n+generated/_abs_r4.F90 \\\n+generated/_abs_r8.F90 \\\n+generated/_abs_r10.F90 \\\n+generated/_abs_r16.F90 \\\n+generated/_exp_r4.F90 \\\n+generated/_exp_r8.F90 \\\n+generated/_exp_r10.F90 \\\n+generated/_exp_r16.F90 \\\n+generated/_exp_c4.F90 \\\n+generated/_exp_c8.F90 \\\n+generated/_exp_c10.F90 \\\n+generated/_exp_c16.F90 \\\n+generated/_log_r4.F90 \\\n+generated/_log_r8.F90 \\\n+generated/_log_r10.F90 \\\n+generated/_log_r16.F90 \\\n+generated/_log_c4.F90 \\\n+generated/_log_c8.F90 \\\n+generated/_log_c10.F90 \\\n+generated/_log_c16.F90 \\\n+generated/_log10_r4.F90 \\\n+generated/_log10_r8.F90 \\\n+generated/_log10_r10.F90 \\\n+generated/_log10_r16.F90 \\\n+generated/_sqrt_r4.F90 \\\n+generated/_sqrt_r8.F90 \\\n+generated/_sqrt_r10.F90 \\\n+generated/_sqrt_r16.F90 \\\n+generated/_sqrt_c4.F90 \\\n+generated/_sqrt_c8.F90 \\\n+generated/_sqrt_c10.F90 \\\n+generated/_sqrt_c16.F90 \\\n+generated/_asin_r4.F90 \\\n+generated/_asin_r8.F90 \\\n+generated/_asin_r10.F90 \\\n+generated/_asin_r16.F90 \\\n+generated/_acos_r4.F90 \\\n+generated/_acos_r8.F90 \\\n+generated/_acos_r10.F90 \\\n+generated/_acos_r16.F90 \\\n+generated/_atan_r4.F90 \\\n+generated/_atan_r8.F90 \\\n+generated/_atan_r10.F90 \\\n+generated/_atan_r16.F90 \\\n+generated/_sin_r4.F90 \\\n+generated/_sin_r8.F90 \\\n+generated/_sin_r10.F90 \\\n+generated/_sin_r16.F90 \\\n+generated/_sin_c4.F90 \\\n+generated/_sin_c8.F90 \\\n+generated/_sin_c10.F90 \\\n+generated/_sin_c16.F90 \\\n+generated/_cos_r4.F90 \\\n+generated/_cos_r8.F90 \\\n+generated/_cos_r10.F90 \\\n+generated/_cos_r16.F90 \\\n+generated/_cos_c4.F90 \\\n+generated/_cos_c8.F90 \\\n+generated/_cos_c10.F90 \\\n+generated/_cos_c16.F90 \\\n+generated/_tan_r4.F90 \\\n+generated/_tan_r8.F90 \\\n+generated/_tan_r10.F90 \\\n+generated/_tan_r16.F90 \\\n+generated/_sinh_r4.F90 \\\n+generated/_sinh_r8.F90 \\\n+generated/_sinh_r10.F90 \\\n+generated/_sinh_r16.F90 \\\n+generated/_cosh_r4.F90 \\\n+generated/_cosh_r8.F90 \\\n+generated/_cosh_r10.F90 \\\n+generated/_cosh_r16.F90 \\\n+generated/_tanh_r4.F90 \\\n+generated/_tanh_r8.F90 \\\n+generated/_tanh_r10.F90 \\\n+generated/_tanh_r16.F90 \\\n+generated/_conjg_c4.F90 \\\n+generated/_conjg_c8.F90 \\\n+generated/_conjg_c10.F90 \\\n+generated/_conjg_c16.F90 \\\n+generated/_aint_r4.F90 \\\n+generated/_aint_r8.F90 \\\n+generated/_aint_r10.F90 \\\n+generated/_aint_r16.F90 \\\n+generated/_anint_r4.F90 \\\n+generated/_anint_r8.F90 \\\n+generated/_anint_r10.F90 \\\n+generated/_anint_r16.F90\n \n gfor_built_specific2_src= \\\n-generated/_sign_i4.f90 \\\n-generated/_sign_i8.f90 \\\n-generated/_sign_r4.f90 \\\n-generated/_sign_r8.f90 \\\n-generated/_dim_i4.f90 \\\n-generated/_dim_i8.f90 \\\n-generated/_dim_r4.f90 \\\n-generated/_dim_r8.f90 \\\n-generated/_atan2_r4.f90 \\\n-generated/_atan2_r8.f90 \\\n-generated/_mod_i4.f90 \\\n-generated/_mod_i8.f90 \\\n-generated/_mod_r4.f90 \\\n-generated/_mod_r8.f90\n+generated/_sign_i4.F90 \\\n+generated/_sign_i8.F90 \\\n+generated/_sign_i16.F90 \\\n+generated/_sign_r4.F90 \\\n+generated/_sign_r8.F90 \\\n+generated/_sign_r10.F90 \\\n+generated/_sign_r16.F90 \\\n+generated/_dim_i4.F90 \\\n+generated/_dim_i8.F90 \\\n+generated/_dim_i16.F90 \\\n+generated/_dim_r4.F90 \\\n+generated/_dim_r8.F90 \\\n+generated/_dim_r10.F90 \\\n+generated/_dim_r16.F90 \\\n+generated/_atan2_r4.F90 \\\n+generated/_atan2_r8.F90 \\\n+generated/_atan2_r10.F90 \\\n+generated/_atan2_r16.F90 \\\n+generated/_mod_i4.F90 \\\n+generated/_mod_i8.F90 \\\n+generated/_mod_i16.F90 \\\n+generated/_mod_r4.F90 \\\n+generated/_mod_r8.F90\n+# There are commented out due to a bug in the way the front-end\n+# handles MOD\n+#generated/_mod_r10.F90\n+#generated/_mod_r16.F90\n \n gfor_specific_src= \\\n $(gfor_built_specific_src) \\\n@@ -387,6 +580,12 @@ I_M4_DEPS1=$(I_M4_DEPS) m4/ifunction.m4\n kinds.h: $(srcdir)/mk-kinds-h.sh\n \t$(SHELL) $(srcdir)/mk-kinds-h.sh '$(FCCOMPILE)' > $@\n \n+kinds.inc: kinds.h\n+\tgrep '^#' < kinds.h > $@\n+\n+c99_protos.inc: $(srcdir)/c99_protos.h\n+\tgrep '^#' < $(srcdir)/c99_protos.h > $@\n+\n selected_int_kind.inc: $(srcdir)/mk-sik-inc.sh\n \t$(SHELL) $(srcdir)/mk-sik-inc.sh '$(FCCOMPILE)' > $@\n "}, {"sha": "c4d3be6ef1138f6640f34707ca02cd24c3b7eccf", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 1150, "deletions": 340, "changes": 1490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "8e76b3474f79a6648a3f6383ba0706d511415f7a", "filename": "libgfortran/generated/_abs_c10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_c10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_c10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_abs_c10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+#ifdef HAVE_CABSL\n+\n+elemental function specific__abs_c10 (parm)\n+   complex (kind=10), intent (in) :: parm\n+   complex (kind=10) :: specific__abs_c10\n+\n+   specific__abs_c10 = abs (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "acc7f22dfa47b295cf42e55fd1367fab751a3d56", "filename": "libgfortran/generated/_abs_c16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_c16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_c16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_abs_c16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+#ifdef HAVE_CABSL\n+\n+elemental function specific__abs_c16 (parm)\n+   complex (kind=16), intent (in) :: parm\n+   complex (kind=16) :: specific__abs_c16\n+\n+   specific__abs_c16 = abs (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "a87fcf6c4a48e181fa1299e67f1fa42071ee2470", "filename": "libgfortran/generated/_abs_c4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_c4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_c4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_abs_c4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_4)\n+#ifdef HAVE_CABSF\n+\n elemental function specific__abs_c4 (parm)\n    complex (kind=4), intent (in) :: parm\n    complex (kind=4) :: specific__abs_c4\n \n    specific__abs_c4 = abs (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_abs_c4.f90"}, {"sha": "294c0027b5d42f9538ed8d22521a548c68f720a1", "filename": "libgfortran/generated/_abs_c8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_c8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_c8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_abs_c8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_8)\n+#ifdef HAVE_CABS\n+\n elemental function specific__abs_c8 (parm)\n    complex (kind=8), intent (in) :: parm\n    complex (kind=8) :: specific__abs_c8\n \n    specific__abs_c8 = abs (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_abs_c8.f90"}, {"sha": "afbb67f480eaf12341e125c795b5a15365d892b0", "filename": "libgfortran/generated/_abs_i16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_i16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_i16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_abs_i16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+\n+\n+elemental function specific__abs_i16 (parm)\n+   integer (kind=16), intent (in) :: parm\n+   integer (kind=16) :: specific__abs_i16\n+\n+   specific__abs_i16 = abs (parm)\n+end function\n+\n+\n+#endif"}, {"sha": "4037d3473aeb349dbf239a4453d14ac73f4dd28a", "filename": "libgfortran/generated/_abs_i4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_i4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_i4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_abs_i4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_INTEGER_4)\n+\n+\n elemental function specific__abs_i4 (parm)\n    integer (kind=4), intent (in) :: parm\n    integer (kind=4) :: specific__abs_i4\n \n    specific__abs_i4 = abs (parm)\n end function\n+\n+\n+#endif", "previous_filename": "libgfortran/generated/_abs_i4.f90"}, {"sha": "1f2e4244cf984a0c83fe9e21564d43355ccb1360", "filename": "libgfortran/generated/_abs_i8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_i8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_i8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_abs_i8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_INTEGER_8)\n+\n+\n elemental function specific__abs_i8 (parm)\n    integer (kind=8), intent (in) :: parm\n    integer (kind=8) :: specific__abs_i8\n \n    specific__abs_i8 = abs (parm)\n end function\n+\n+\n+#endif", "previous_filename": "libgfortran/generated/_abs_i8.f90"}, {"sha": "4d76a1eafa9faae5763eab383a71c0720159b35e", "filename": "libgfortran/generated/_abs_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_abs_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+#ifdef HAVE_FABSL\n+\n+elemental function specific__abs_r10 (parm)\n+   real (kind=10), intent (in) :: parm\n+   real (kind=10) :: specific__abs_r10\n+\n+   specific__abs_r10 = abs (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "3c7d8a74f3107e6bbc58b096b6b143cde63d5867", "filename": "libgfortran/generated/_abs_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_abs_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+#ifdef HAVE_FABSL\n+\n+elemental function specific__abs_r16 (parm)\n+   real (kind=16), intent (in) :: parm\n+   real (kind=16) :: specific__abs_r16\n+\n+   specific__abs_r16 = abs (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "31ef426f2acc4fc2a98c24f02482e819d6d36a63", "filename": "libgfortran/generated/_abs_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_abs_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+#ifdef HAVE_FABSF\n+\n elemental function specific__abs_r4 (parm)\n    real (kind=4), intent (in) :: parm\n    real (kind=4) :: specific__abs_r4\n \n    specific__abs_r4 = abs (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_abs_r4.f90"}, {"sha": "c0b4ce1febe42680578c0a32e971fd8a83a325e3", "filename": "libgfortran/generated/_abs_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_abs_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_abs_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+#ifdef HAVE_FABS\n+\n elemental function specific__abs_r8 (parm)\n    real (kind=8), intent (in) :: parm\n    real (kind=8) :: specific__abs_r8\n \n    specific__abs_r8 = abs (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_abs_r8.f90"}, {"sha": "d7be7c8940e34d8817288483f5733eb1a0fe6845", "filename": "libgfortran/generated/_acos_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_acos_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_acos_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_acos_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+#ifdef HAVE_ACOSL\n+\n+elemental function specific__acos_r10 (parm)\n+   real (kind=10), intent (in) :: parm\n+   real (kind=10) :: specific__acos_r10\n+\n+   specific__acos_r10 = acos (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "f0c6dde0863d9a6c4ef2cf16fab596ae4b3e0784", "filename": "libgfortran/generated/_acos_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_acos_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_acos_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_acos_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+#ifdef HAVE_ACOSL\n+\n+elemental function specific__acos_r16 (parm)\n+   real (kind=16), intent (in) :: parm\n+   real (kind=16) :: specific__acos_r16\n+\n+   specific__acos_r16 = acos (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "9e1b97b0e6a0434cd26696a9e30335cdf17d0071", "filename": "libgfortran/generated/_acos_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_acos_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_acos_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_acos_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+#ifdef HAVE_ACOSF\n+\n elemental function specific__acos_r4 (parm)\n    real (kind=4), intent (in) :: parm\n    real (kind=4) :: specific__acos_r4\n \n    specific__acos_r4 = acos (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_acos_r4.f90"}, {"sha": "3bded77850329f5e588ebddd93d9eae57d0fb355", "filename": "libgfortran/generated/_acos_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_acos_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_acos_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_acos_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+#ifdef HAVE_ACOS\n+\n elemental function specific__acos_r8 (parm)\n    real (kind=8), intent (in) :: parm\n    real (kind=8) :: specific__acos_r8\n \n    specific__acos_r8 = acos (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_acos_r8.f90"}, {"sha": "2448baa53e850569ac2200a36c070f474d501448", "filename": "libgfortran/generated/_aint_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_aint_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_aint_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_aint_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+#ifdef HAVE_TRUNCL\n+\n+elemental function specific__aint_r10 (parm)\n+   real (kind=10), intent (in) :: parm\n+   real (kind=10) :: specific__aint_r10\n+\n+   specific__aint_r10 = aint (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "9903ad4af19e69e7c20a169e658426cab406cb49", "filename": "libgfortran/generated/_aint_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_aint_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_aint_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_aint_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+#ifdef HAVE_TRUNCL\n+\n+elemental function specific__aint_r16 (parm)\n+   real (kind=16), intent (in) :: parm\n+   real (kind=16) :: specific__aint_r16\n+\n+   specific__aint_r16 = aint (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "4fb714588340dd1772da97938361fedc7c875165", "filename": "libgfortran/generated/_aint_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_aint_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_aint_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_aint_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+#ifdef HAVE_TRUNCF\n+\n elemental function specific__aint_r4 (parm)\n    real (kind=4), intent (in) :: parm\n    real (kind=4) :: specific__aint_r4\n \n    specific__aint_r4 = aint (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_aint_r4.f90"}, {"sha": "f860c7ae38260718f324e080b40aabc05d891646", "filename": "libgfortran/generated/_aint_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_aint_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_aint_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_aint_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+#ifdef HAVE_TRUNC\n+\n elemental function specific__aint_r8 (parm)\n    real (kind=8), intent (in) :: parm\n    real (kind=8) :: specific__aint_r8\n \n    specific__aint_r8 = aint (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_aint_r8.f90"}, {"sha": "1652417943f03e5db69c4bdb8ec77db637a0072a", "filename": "libgfortran/generated/_anint_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_anint_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_anint_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_anint_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+#ifdef HAVE_ROUNDL\n+\n+elemental function specific__anint_r10 (parm)\n+   real (kind=10), intent (in) :: parm\n+   real (kind=10) :: specific__anint_r10\n+\n+   specific__anint_r10 = anint (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "48e1dffb1c3a089b17bff70bed85fd67401b521d", "filename": "libgfortran/generated/_anint_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_anint_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_anint_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_anint_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+#ifdef HAVE_ROUNDL\n+\n+elemental function specific__anint_r16 (parm)\n+   real (kind=16), intent (in) :: parm\n+   real (kind=16) :: specific__anint_r16\n+\n+   specific__anint_r16 = anint (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "c1c955ce5e89235f6f61c97b1228248b1abd6c29", "filename": "libgfortran/generated/_anint_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_anint_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_anint_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_anint_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+#ifdef HAVE_ROUNDF\n+\n elemental function specific__anint_r4 (parm)\n    real (kind=4), intent (in) :: parm\n    real (kind=4) :: specific__anint_r4\n \n    specific__anint_r4 = anint (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_anint_r4.f90"}, {"sha": "6c72678944de1c8bd6b12cd927abf287127332a1", "filename": "libgfortran/generated/_anint_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_anint_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_anint_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_anint_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+#ifdef HAVE_ROUND\n+\n elemental function specific__anint_r8 (parm)\n    real (kind=8), intent (in) :: parm\n    real (kind=8) :: specific__anint_r8\n \n    specific__anint_r8 = anint (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_anint_r8.f90"}, {"sha": "80939fa3a18ac894b80433b86eff7ae7919fedf5", "filename": "libgfortran/generated/_asin_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_asin_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_asin_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_asin_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+#ifdef HAVE_ASINL\n+\n+elemental function specific__asin_r10 (parm)\n+   real (kind=10), intent (in) :: parm\n+   real (kind=10) :: specific__asin_r10\n+\n+   specific__asin_r10 = asin (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "76e37b6f6a5fedd8020f22b9d73ce4ac2d1ac6d1", "filename": "libgfortran/generated/_asin_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_asin_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_asin_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_asin_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+#ifdef HAVE_ASINL\n+\n+elemental function specific__asin_r16 (parm)\n+   real (kind=16), intent (in) :: parm\n+   real (kind=16) :: specific__asin_r16\n+\n+   specific__asin_r16 = asin (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "cd77113879fef69d813e1cf59c09f0ef6b8d30ac", "filename": "libgfortran/generated/_asin_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_asin_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_asin_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_asin_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+#ifdef HAVE_ASINF\n+\n elemental function specific__asin_r4 (parm)\n    real (kind=4), intent (in) :: parm\n    real (kind=4) :: specific__asin_r4\n \n    specific__asin_r4 = asin (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_asin_r4.f90"}, {"sha": "c31f2bc8db3d28ed8ddf8c2899e092b634702437", "filename": "libgfortran/generated/_asin_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_asin_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_asin_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_asin_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+#ifdef HAVE_ASIN\n+\n elemental function specific__asin_r8 (parm)\n    real (kind=8), intent (in) :: parm\n    real (kind=8) :: specific__asin_r8\n \n    specific__asin_r8 = asin (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_asin_r8.f90"}, {"sha": "cc9a170bd2d6e67ce3d2d7b6016123b05a32a292", "filename": "libgfortran/generated/_atan2_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_atan2_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_atan2_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_atan2_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+\n+#ifdef HAVE_ATAN2L\n+\n+elemental function specific__atan2_r10 (p1, p2)\n+   real (kind=10), intent (in) :: p1, p2\n+   real (kind=10) :: specific__atan2_r10\n+\n+   specific__atan2_r10 = atan2 (p1, p2)\n+end function\n+\n+#endif\n+\n+#endif"}, {"sha": "f56aabef8e3804156f00e4d2cb9a3afe77c4254a", "filename": "libgfortran/generated/_atan2_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_atan2_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_atan2_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_atan2_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+\n+#ifdef HAVE_ATAN2L\n+\n+elemental function specific__atan2_r16 (p1, p2)\n+   real (kind=16), intent (in) :: p1, p2\n+   real (kind=16) :: specific__atan2_r16\n+\n+   specific__atan2_r16 = atan2 (p1, p2)\n+end function\n+\n+#endif\n+\n+#endif"}, {"sha": "52ecf7917bab06fc1561e8367507e0891a735176", "filename": "libgfortran/generated/_atan2_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_atan2_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_atan2_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_atan2_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+\n+#ifdef HAVE_ATAN2F\n+\n elemental function specific__atan2_r4 (p1, p2)\n    real (kind=4), intent (in) :: p1, p2\n    real (kind=4) :: specific__atan2_r4\n \n    specific__atan2_r4 = atan2 (p1, p2)\n end function\n+\n+#endif\n+\n+#endif", "previous_filename": "libgfortran/generated/_atan2_r4.f90"}, {"sha": "752b16539873940d5caf447ac092e87297c4514b", "filename": "libgfortran/generated/_atan2_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_atan2_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_atan2_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_atan2_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+\n+#ifdef HAVE_ATAN2\n+\n elemental function specific__atan2_r8 (p1, p2)\n    real (kind=8), intent (in) :: p1, p2\n    real (kind=8) :: specific__atan2_r8\n \n    specific__atan2_r8 = atan2 (p1, p2)\n end function\n+\n+#endif\n+\n+#endif", "previous_filename": "libgfortran/generated/_atan2_r8.f90"}, {"sha": "195d9414f5281e2e57a32b62fd023176e14327bd", "filename": "libgfortran/generated/_atan_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_atan_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_atan_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_atan_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+#ifdef HAVE_ATANL\n+\n+elemental function specific__atan_r10 (parm)\n+   real (kind=10), intent (in) :: parm\n+   real (kind=10) :: specific__atan_r10\n+\n+   specific__atan_r10 = atan (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "2691a34fd372cbd217f45c99650352a4a25654c3", "filename": "libgfortran/generated/_atan_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_atan_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_atan_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_atan_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+#ifdef HAVE_ATANL\n+\n+elemental function specific__atan_r16 (parm)\n+   real (kind=16), intent (in) :: parm\n+   real (kind=16) :: specific__atan_r16\n+\n+   specific__atan_r16 = atan (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "4e88ab24f6978811a831d329c532d3584ea0addf", "filename": "libgfortran/generated/_atan_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_atan_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_atan_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_atan_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+#ifdef HAVE_ATANF\n+\n elemental function specific__atan_r4 (parm)\n    real (kind=4), intent (in) :: parm\n    real (kind=4) :: specific__atan_r4\n \n    specific__atan_r4 = atan (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_atan_r4.f90"}, {"sha": "a99de95447ba4f5fe5492a576f20d65a220e6419", "filename": "libgfortran/generated/_atan_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_atan_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_atan_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_atan_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+#ifdef HAVE_ATAN\n+\n elemental function specific__atan_r8 (parm)\n    real (kind=8), intent (in) :: parm\n    real (kind=8) :: specific__atan_r8\n \n    specific__atan_r8 = atan (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_atan_r8.f90"}, {"sha": "1fa158d283c844d328349a95905e19700eeb90e3", "filename": "libgfortran/generated/_conjg_c10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_conjg_c10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_conjg_c10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_conjg_c10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+\n+\n+elemental function specific__conjg_c10 (parm)\n+   complex (kind=10), intent (in) :: parm\n+   complex (kind=10) :: specific__conjg_c10\n+\n+   specific__conjg_c10 = conjg (parm)\n+end function\n+\n+\n+#endif"}, {"sha": "13c8e147830f919f5daadfb3369289c667df8dba", "filename": "libgfortran/generated/_conjg_c16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_conjg_c16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_conjg_c16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_conjg_c16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+\n+\n+elemental function specific__conjg_c16 (parm)\n+   complex (kind=16), intent (in) :: parm\n+   complex (kind=16) :: specific__conjg_c16\n+\n+   specific__conjg_c16 = conjg (parm)\n+end function\n+\n+\n+#endif"}, {"sha": "a4409c94f495ec5a1dad5d8b68fd1ee9a7a8cb9d", "filename": "libgfortran/generated/_conjg_c4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_conjg_c4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_conjg_c4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_conjg_c4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_4)\n+\n+\n elemental function specific__conjg_c4 (parm)\n    complex (kind=4), intent (in) :: parm\n    complex (kind=4) :: specific__conjg_c4\n \n    specific__conjg_c4 = conjg (parm)\n end function\n+\n+\n+#endif", "previous_filename": "libgfortran/generated/_conjg_c4.f90"}, {"sha": "f1c1254c9707136a692ca5210047a7fa6ab7ecc8", "filename": "libgfortran/generated/_conjg_c8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_conjg_c8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_conjg_c8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_conjg_c8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_8)\n+\n+\n elemental function specific__conjg_c8 (parm)\n    complex (kind=8), intent (in) :: parm\n    complex (kind=8) :: specific__conjg_c8\n \n    specific__conjg_c8 = conjg (parm)\n end function\n+\n+\n+#endif", "previous_filename": "libgfortran/generated/_conjg_c8.f90"}, {"sha": "018394cc91934bed724ca67686204d5c71330315", "filename": "libgfortran/generated/_cos_c10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cos_c10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cos_c10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_cos_c10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+#ifdef HAVE_CCOSL\n+\n+elemental function specific__cos_c10 (parm)\n+   complex (kind=10), intent (in) :: parm\n+   complex (kind=10) :: specific__cos_c10\n+\n+   specific__cos_c10 = cos (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "ac6bc876862935957a0676607f424663fcf86a77", "filename": "libgfortran/generated/_cos_c16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cos_c16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cos_c16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_cos_c16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+#ifdef HAVE_CCOSL\n+\n+elemental function specific__cos_c16 (parm)\n+   complex (kind=16), intent (in) :: parm\n+   complex (kind=16) :: specific__cos_c16\n+\n+   specific__cos_c16 = cos (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "e49469577bc262c7f0b7e93bda8f5a823801e9c6", "filename": "libgfortran/generated/_cos_c4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cos_c4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cos_c4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_cos_c4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_4)\n+#ifdef HAVE_CCOSF\n+\n elemental function specific__cos_c4 (parm)\n    complex (kind=4), intent (in) :: parm\n    complex (kind=4) :: specific__cos_c4\n \n    specific__cos_c4 = cos (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_cos_c4.f90"}, {"sha": "d3daf6e1360d3450db5163d8dbea9d3cc4832234", "filename": "libgfortran/generated/_cos_c8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cos_c8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cos_c8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_cos_c8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_8)\n+#ifdef HAVE_CCOS\n+\n elemental function specific__cos_c8 (parm)\n    complex (kind=8), intent (in) :: parm\n    complex (kind=8) :: specific__cos_c8\n \n    specific__cos_c8 = cos (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_cos_c8.f90"}, {"sha": "142cb4b947f7fc6aca7c9e4ea4f0a429ed62e8db", "filename": "libgfortran/generated/_cos_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cos_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cos_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_cos_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+#ifdef HAVE_COSL\n+\n+elemental function specific__cos_r10 (parm)\n+   real (kind=10), intent (in) :: parm\n+   real (kind=10) :: specific__cos_r10\n+\n+   specific__cos_r10 = cos (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "434639755c4849e1ba0d4c06a936d243be0bcfab", "filename": "libgfortran/generated/_cos_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cos_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cos_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_cos_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+#ifdef HAVE_COSL\n+\n+elemental function specific__cos_r16 (parm)\n+   real (kind=16), intent (in) :: parm\n+   real (kind=16) :: specific__cos_r16\n+\n+   specific__cos_r16 = cos (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "ddf2509a272a5e22876925dd8d59a4f5c43f7972", "filename": "libgfortran/generated/_cos_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cos_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cos_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_cos_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+#ifdef HAVE_COSF\n+\n elemental function specific__cos_r4 (parm)\n    real (kind=4), intent (in) :: parm\n    real (kind=4) :: specific__cos_r4\n \n    specific__cos_r4 = cos (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_cos_r4.f90"}, {"sha": "d45a11aa33cd4e84c668c093160be3cf5c436b3b", "filename": "libgfortran/generated/_cos_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cos_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cos_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_cos_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+#ifdef HAVE_COS\n+\n elemental function specific__cos_r8 (parm)\n    real (kind=8), intent (in) :: parm\n    real (kind=8) :: specific__cos_r8\n \n    specific__cos_r8 = cos (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_cos_r8.f90"}, {"sha": "9c7d3fbdf88367ab5028be4ea00be5ce98a3ae47", "filename": "libgfortran/generated/_cosh_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cosh_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cosh_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_cosh_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+#ifdef HAVE_COSHL\n+\n+elemental function specific__cosh_r10 (parm)\n+   real (kind=10), intent (in) :: parm\n+   real (kind=10) :: specific__cosh_r10\n+\n+   specific__cosh_r10 = cosh (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "ac28f9965900298bcbee5d1b1a74332b9923027f", "filename": "libgfortran/generated/_cosh_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cosh_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cosh_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_cosh_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+#ifdef HAVE_COSHL\n+\n+elemental function specific__cosh_r16 (parm)\n+   real (kind=16), intent (in) :: parm\n+   real (kind=16) :: specific__cosh_r16\n+\n+   specific__cosh_r16 = cosh (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "289c9bc0e24a1856f62dc6dfc33480a805d3ec77", "filename": "libgfortran/generated/_cosh_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cosh_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cosh_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_cosh_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+#ifdef HAVE_COSHF\n+\n elemental function specific__cosh_r4 (parm)\n    real (kind=4), intent (in) :: parm\n    real (kind=4) :: specific__cosh_r4\n \n    specific__cosh_r4 = cosh (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_cosh_r4.f90"}, {"sha": "6b47452298c69001dd49e12c1735ac16bf97510e", "filename": "libgfortran/generated/_cosh_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cosh_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_cosh_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_cosh_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+#ifdef HAVE_COSH\n+\n elemental function specific__cosh_r8 (parm)\n    real (kind=8), intent (in) :: parm\n    real (kind=8) :: specific__cosh_r8\n \n    specific__cosh_r8 = cosh (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_cosh_r8.f90"}, {"sha": "55a1a521a88295c988abdd59bfc80e6640ed3175", "filename": "libgfortran/generated/_dim_i16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_dim_i16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_dim_i16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_dim_i16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+\n+\n+\n+elemental function specific__dim_i16 (p1, p2)\n+   integer (kind=16), intent (in) :: p1, p2\n+   integer (kind=16) :: specific__dim_i16\n+\n+   specific__dim_i16 = dim (p1, p2)\n+end function\n+\n+\n+\n+#endif"}, {"sha": "2fd8658460ae09a158b4aa001bcaa36ff1e3cd68", "filename": "libgfortran/generated/_dim_i4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_dim_i4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_dim_i4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_dim_i4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_INTEGER_4)\n+\n+\n+\n elemental function specific__dim_i4 (p1, p2)\n    integer (kind=4), intent (in) :: p1, p2\n    integer (kind=4) :: specific__dim_i4\n \n    specific__dim_i4 = dim (p1, p2)\n end function\n+\n+\n+\n+#endif", "previous_filename": "libgfortran/generated/_dim_i4.f90"}, {"sha": "e861d9eb8416b8fc33c1dc67be52025bd5070b4a", "filename": "libgfortran/generated/_dim_i8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_dim_i8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_dim_i8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_dim_i8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_INTEGER_8)\n+\n+\n+\n elemental function specific__dim_i8 (p1, p2)\n    integer (kind=8), intent (in) :: p1, p2\n    integer (kind=8) :: specific__dim_i8\n \n    specific__dim_i8 = dim (p1, p2)\n end function\n+\n+\n+\n+#endif", "previous_filename": "libgfortran/generated/_dim_i8.f90"}, {"sha": "1e7743d667193be188917d1f68beaa4861514cef", "filename": "libgfortran/generated/_dim_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_dim_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_dim_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_dim_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+\n+\n+\n+elemental function specific__dim_r10 (p1, p2)\n+   real (kind=10), intent (in) :: p1, p2\n+   real (kind=10) :: specific__dim_r10\n+\n+   specific__dim_r10 = dim (p1, p2)\n+end function\n+\n+\n+\n+#endif"}, {"sha": "97a048890e3e8055913cdfdb1126386588038f2b", "filename": "libgfortran/generated/_dim_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_dim_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_dim_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_dim_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+\n+\n+\n+elemental function specific__dim_r16 (p1, p2)\n+   real (kind=16), intent (in) :: p1, p2\n+   real (kind=16) :: specific__dim_r16\n+\n+   specific__dim_r16 = dim (p1, p2)\n+end function\n+\n+\n+\n+#endif"}, {"sha": "465b28489aa352cb8e8a713a5f75e4f868fb8263", "filename": "libgfortran/generated/_dim_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_dim_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_dim_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_dim_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+\n+\n+\n elemental function specific__dim_r4 (p1, p2)\n    real (kind=4), intent (in) :: p1, p2\n    real (kind=4) :: specific__dim_r4\n \n    specific__dim_r4 = dim (p1, p2)\n end function\n+\n+\n+\n+#endif", "previous_filename": "libgfortran/generated/_dim_r4.f90"}, {"sha": "3e6b3379fe26509077e768b7e3d88ac3ece89f6a", "filename": "libgfortran/generated/_dim_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_dim_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_dim_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_dim_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+\n+\n+\n elemental function specific__dim_r8 (p1, p2)\n    real (kind=8), intent (in) :: p1, p2\n    real (kind=8) :: specific__dim_r8\n \n    specific__dim_r8 = dim (p1, p2)\n end function\n+\n+\n+\n+#endif", "previous_filename": "libgfortran/generated/_dim_r8.f90"}, {"sha": "bcf1f2bdd8733758acde51e5259557b945217bbb", "filename": "libgfortran/generated/_exp_c10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_exp_c10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_exp_c10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_exp_c10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+#ifdef HAVE_CEXPL\n+\n+elemental function specific__exp_c10 (parm)\n+   complex (kind=10), intent (in) :: parm\n+   complex (kind=10) :: specific__exp_c10\n+\n+   specific__exp_c10 = exp (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "58527bc536ab66970f6194091745858ed7280c4c", "filename": "libgfortran/generated/_exp_c16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_exp_c16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_exp_c16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_exp_c16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+#ifdef HAVE_CEXPL\n+\n+elemental function specific__exp_c16 (parm)\n+   complex (kind=16), intent (in) :: parm\n+   complex (kind=16) :: specific__exp_c16\n+\n+   specific__exp_c16 = exp (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "6fba6756be9c63e692cb53fb4924f9abc50ab219", "filename": "libgfortran/generated/_exp_c4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_exp_c4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_exp_c4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_exp_c4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_4)\n+#ifdef HAVE_CEXPF\n+\n elemental function specific__exp_c4 (parm)\n    complex (kind=4), intent (in) :: parm\n    complex (kind=4) :: specific__exp_c4\n \n    specific__exp_c4 = exp (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_exp_c4.f90"}, {"sha": "cbc82a156dd0d079d8443b19787ed7ba59a36fef", "filename": "libgfortran/generated/_exp_c8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_exp_c8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_exp_c8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_exp_c8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_8)\n+#ifdef HAVE_CEXP\n+\n elemental function specific__exp_c8 (parm)\n    complex (kind=8), intent (in) :: parm\n    complex (kind=8) :: specific__exp_c8\n \n    specific__exp_c8 = exp (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_exp_c8.f90"}, {"sha": "86bf749943a8aec6ea7fe2b5bc376c45d6de5f0a", "filename": "libgfortran/generated/_exp_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_exp_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_exp_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_exp_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+#ifdef HAVE_EXPL\n+\n+elemental function specific__exp_r10 (parm)\n+   real (kind=10), intent (in) :: parm\n+   real (kind=10) :: specific__exp_r10\n+\n+   specific__exp_r10 = exp (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "4aaee9eb17d8d069318cbd96afae8523359dbabe", "filename": "libgfortran/generated/_exp_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_exp_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_exp_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_exp_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+#ifdef HAVE_EXPL\n+\n+elemental function specific__exp_r16 (parm)\n+   real (kind=16), intent (in) :: parm\n+   real (kind=16) :: specific__exp_r16\n+\n+   specific__exp_r16 = exp (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "d76fb143cc649b304bc7cbaffeefb3d376bf636b", "filename": "libgfortran/generated/_exp_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_exp_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_exp_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_exp_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+#ifdef HAVE_EXPF\n+\n elemental function specific__exp_r4 (parm)\n    real (kind=4), intent (in) :: parm\n    real (kind=4) :: specific__exp_r4\n \n    specific__exp_r4 = exp (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_exp_r4.f90"}, {"sha": "d529810ca57cce13563edc8dec1f913253861bfc", "filename": "libgfortran/generated/_exp_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_exp_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_exp_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_exp_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+#ifdef HAVE_EXP\n+\n elemental function specific__exp_r8 (parm)\n    real (kind=8), intent (in) :: parm\n    real (kind=8) :: specific__exp_r8\n \n    specific__exp_r8 = exp (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_exp_r8.f90"}, {"sha": "19aeac5c1befd58251403867cf924299542861ca", "filename": "libgfortran/generated/_log10_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log10_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log10_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_log10_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+#ifdef HAVE_LOG10L\n+\n+elemental function specific__log10_r10 (parm)\n+   real (kind=10), intent (in) :: parm\n+   real (kind=10) :: specific__log10_r10\n+\n+   specific__log10_r10 = log10 (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "c03002aa45604c78e2bff4f48697eafdc598ba04", "filename": "libgfortran/generated/_log10_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log10_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log10_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_log10_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+#ifdef HAVE_LOG10L\n+\n+elemental function specific__log10_r16 (parm)\n+   real (kind=16), intent (in) :: parm\n+   real (kind=16) :: specific__log10_r16\n+\n+   specific__log10_r16 = log10 (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "c772527ae861d56d61b77cc73fba2f464640226b", "filename": "libgfortran/generated/_log10_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log10_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log10_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_log10_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+#ifdef HAVE_LOG10F\n+\n elemental function specific__log10_r4 (parm)\n    real (kind=4), intent (in) :: parm\n    real (kind=4) :: specific__log10_r4\n \n    specific__log10_r4 = log10 (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_log10_r4.f90"}, {"sha": "396570989e6af5af6fd31fa424c457fff1445039", "filename": "libgfortran/generated/_log10_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log10_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log10_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_log10_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+#ifdef HAVE_LOG10\n+\n elemental function specific__log10_r8 (parm)\n    real (kind=8), intent (in) :: parm\n    real (kind=8) :: specific__log10_r8\n \n    specific__log10_r8 = log10 (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_log10_r8.f90"}, {"sha": "e3f6934e6288d948943f42c93ce259a418385ac1", "filename": "libgfortran/generated/_log_c10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log_c10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log_c10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_log_c10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+#ifdef HAVE_CLOGL\n+\n+elemental function specific__log_c10 (parm)\n+   complex (kind=10), intent (in) :: parm\n+   complex (kind=10) :: specific__log_c10\n+\n+   specific__log_c10 = log (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "776140a7e78bc452f7c5b8f5bad1b895bf3ec8ad", "filename": "libgfortran/generated/_log_c16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log_c16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log_c16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_log_c16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+#ifdef HAVE_CLOGL\n+\n+elemental function specific__log_c16 (parm)\n+   complex (kind=16), intent (in) :: parm\n+   complex (kind=16) :: specific__log_c16\n+\n+   specific__log_c16 = log (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "923bdd573cab4acb5c03f9958d3906c05b555a67", "filename": "libgfortran/generated/_log_c4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log_c4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log_c4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_log_c4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_4)\n+#ifdef HAVE_CLOGF\n+\n elemental function specific__log_c4 (parm)\n    complex (kind=4), intent (in) :: parm\n    complex (kind=4) :: specific__log_c4\n \n    specific__log_c4 = log (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_log_c4.f90"}, {"sha": "0df0dd83d2d15c6f8f0d14e04ca43f2dd828cafb", "filename": "libgfortran/generated/_log_c8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log_c8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log_c8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_log_c8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_8)\n+#ifdef HAVE_CLOG\n+\n elemental function specific__log_c8 (parm)\n    complex (kind=8), intent (in) :: parm\n    complex (kind=8) :: specific__log_c8\n \n    specific__log_c8 = log (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_log_c8.f90"}, {"sha": "d8938818053b7d79bfb7d03ed9274d85a2cc0c93", "filename": "libgfortran/generated/_log_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_log_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+#ifdef HAVE_LOGL\n+\n+elemental function specific__log_r10 (parm)\n+   real (kind=10), intent (in) :: parm\n+   real (kind=10) :: specific__log_r10\n+\n+   specific__log_r10 = log (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "5013656e9da8d0405c563346481fd78467ca6b4c", "filename": "libgfortran/generated/_log_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_log_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+#ifdef HAVE_LOGL\n+\n+elemental function specific__log_r16 (parm)\n+   real (kind=16), intent (in) :: parm\n+   real (kind=16) :: specific__log_r16\n+\n+   specific__log_r16 = log (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "6a742377648d01a379b3d040d88286669f283664", "filename": "libgfortran/generated/_log_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_log_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+#ifdef HAVE_LOGF\n+\n elemental function specific__log_r4 (parm)\n    real (kind=4), intent (in) :: parm\n    real (kind=4) :: specific__log_r4\n \n    specific__log_r4 = log (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_log_r4.f90"}, {"sha": "8383bbfd36a996ae01e169bfb73d6bb23815a5f5", "filename": "libgfortran/generated/_log_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_log_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_log_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+#ifdef HAVE_LOG\n+\n elemental function specific__log_r8 (parm)\n    real (kind=8), intent (in) :: parm\n    real (kind=8) :: specific__log_r8\n \n    specific__log_r8 = log (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_log_r8.f90"}, {"sha": "571db409bf9e732da37c7a51c535cbb5a4490823", "filename": "libgfortran/generated/_mod_i16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_mod_i16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_mod_i16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_mod_i16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+\n+\n+\n+elemental function specific__mod_i16 (p1, p2)\n+   integer (kind=16), intent (in) :: p1, p2\n+   integer (kind=16) :: specific__mod_i16\n+\n+   specific__mod_i16 = mod (p1, p2)\n+end function\n+\n+\n+\n+#endif"}, {"sha": "ec6f81dee2a0051cf46006647bb35f439bc04326", "filename": "libgfortran/generated/_mod_i4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_mod_i4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_mod_i4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_mod_i4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_INTEGER_4)\n+\n+\n+\n elemental function specific__mod_i4 (p1, p2)\n    integer (kind=4), intent (in) :: p1, p2\n    integer (kind=4) :: specific__mod_i4\n \n    specific__mod_i4 = mod (p1, p2)\n end function\n+\n+\n+\n+#endif", "previous_filename": "libgfortran/generated/_mod_i4.f90"}, {"sha": "e34278b13eca85209a2eaf7461699dd337442c69", "filename": "libgfortran/generated/_mod_i8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_mod_i8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_mod_i8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_mod_i8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_INTEGER_8)\n+\n+\n+\n elemental function specific__mod_i8 (p1, p2)\n    integer (kind=8), intent (in) :: p1, p2\n    integer (kind=8) :: specific__mod_i8\n \n    specific__mod_i8 = mod (p1, p2)\n end function\n+\n+\n+\n+#endif", "previous_filename": "libgfortran/generated/_mod_i8.f90"}, {"sha": "6742ee488affe0d1b8b5c0c946855a7c0c6c01d8", "filename": "libgfortran/generated/_mod_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_mod_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_mod_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_mod_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+\n+\n+\n elemental function specific__mod_r4 (p1, p2)\n    real (kind=4), intent (in) :: p1, p2\n    real (kind=4) :: specific__mod_r4\n \n    specific__mod_r4 = mod (p1, p2)\n end function\n+\n+\n+\n+#endif", "previous_filename": "libgfortran/generated/_mod_r4.f90"}, {"sha": "3cc7e1651114b53847d75b060cfd210c910ca274", "filename": "libgfortran/generated/_mod_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_mod_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_mod_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_mod_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+\n+\n+\n elemental function specific__mod_r8 (p1, p2)\n    real (kind=8), intent (in) :: p1, p2\n    real (kind=8) :: specific__mod_r8\n \n    specific__mod_r8 = mod (p1, p2)\n end function\n+\n+\n+\n+#endif", "previous_filename": "libgfortran/generated/_mod_r8.f90"}, {"sha": "50e492c3f802aa4026d3bba0aa66683219ffce4a", "filename": "libgfortran/generated/_sign_i16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sign_i16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sign_i16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sign_i16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+\n+\n+\n+elemental function specific__sign_i16 (p1, p2)\n+   integer (kind=16), intent (in) :: p1, p2\n+   integer (kind=16) :: specific__sign_i16\n+\n+   specific__sign_i16 = sign (p1, p2)\n+end function\n+\n+\n+\n+#endif"}, {"sha": "d9ea551c6d9d2fdd3b52379bf07bd1c41762903a", "filename": "libgfortran/generated/_sign_i4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sign_i4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sign_i4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sign_i4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_INTEGER_4)\n+\n+\n+\n elemental function specific__sign_i4 (p1, p2)\n    integer (kind=4), intent (in) :: p1, p2\n    integer (kind=4) :: specific__sign_i4\n \n    specific__sign_i4 = sign (p1, p2)\n end function\n+\n+\n+\n+#endif", "previous_filename": "libgfortran/generated/_sign_i4.f90"}, {"sha": "241fb8b0f1c9c948d34899f9d43b58ed27a61919", "filename": "libgfortran/generated/_sign_i8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sign_i8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sign_i8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sign_i8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_INTEGER_8)\n+\n+\n+\n elemental function specific__sign_i8 (p1, p2)\n    integer (kind=8), intent (in) :: p1, p2\n    integer (kind=8) :: specific__sign_i8\n \n    specific__sign_i8 = sign (p1, p2)\n end function\n+\n+\n+\n+#endif", "previous_filename": "libgfortran/generated/_sign_i8.f90"}, {"sha": "002330f0d80c71972a7b04e7e953f4e1b48587e4", "filename": "libgfortran/generated/_sign_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sign_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sign_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sign_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+\n+\n+\n+elemental function specific__sign_r10 (p1, p2)\n+   real (kind=10), intent (in) :: p1, p2\n+   real (kind=10) :: specific__sign_r10\n+\n+   specific__sign_r10 = sign (p1, p2)\n+end function\n+\n+\n+\n+#endif"}, {"sha": "8377969c67aebbaae679474bf1128472d81cdcd5", "filename": "libgfortran/generated/_sign_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sign_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sign_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sign_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+\n+\n+\n+elemental function specific__sign_r16 (p1, p2)\n+   real (kind=16), intent (in) :: p1, p2\n+   real (kind=16) :: specific__sign_r16\n+\n+   specific__sign_r16 = sign (p1, p2)\n+end function\n+\n+\n+\n+#endif"}, {"sha": "e11f15d093edac30133d2e9484a7269c93517152", "filename": "libgfortran/generated/_sign_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sign_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sign_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sign_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+\n+\n+\n elemental function specific__sign_r4 (p1, p2)\n    real (kind=4), intent (in) :: p1, p2\n    real (kind=4) :: specific__sign_r4\n \n    specific__sign_r4 = sign (p1, p2)\n end function\n+\n+\n+\n+#endif", "previous_filename": "libgfortran/generated/_sign_r4.f90"}, {"sha": "66f8dee53a52e9444c2850487fd405d0c48e8238", "filename": "libgfortran/generated/_sign_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sign_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sign_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sign_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+\n+\n+\n elemental function specific__sign_r8 (p1, p2)\n    real (kind=8), intent (in) :: p1, p2\n    real (kind=8) :: specific__sign_r8\n \n    specific__sign_r8 = sign (p1, p2)\n end function\n+\n+\n+\n+#endif", "previous_filename": "libgfortran/generated/_sign_r8.f90"}, {"sha": "2c34b3c931d2f674f67dcf5f4c85d2fd1c6b607e", "filename": "libgfortran/generated/_sin_c10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sin_c10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sin_c10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sin_c10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+#ifdef HAVE_CSINL\n+\n+elemental function specific__sin_c10 (parm)\n+   complex (kind=10), intent (in) :: parm\n+   complex (kind=10) :: specific__sin_c10\n+\n+   specific__sin_c10 = sin (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "75a7108795fe52f868614f30ce2460458a5bb6dd", "filename": "libgfortran/generated/_sin_c16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sin_c16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sin_c16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sin_c16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+#ifdef HAVE_CSINL\n+\n+elemental function specific__sin_c16 (parm)\n+   complex (kind=16), intent (in) :: parm\n+   complex (kind=16) :: specific__sin_c16\n+\n+   specific__sin_c16 = sin (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "0efc127d87f7317035e7f3a6668e817f0ca06c94", "filename": "libgfortran/generated/_sin_c4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sin_c4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sin_c4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sin_c4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_4)\n+#ifdef HAVE_CSINF\n+\n elemental function specific__sin_c4 (parm)\n    complex (kind=4), intent (in) :: parm\n    complex (kind=4) :: specific__sin_c4\n \n    specific__sin_c4 = sin (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_sin_c4.f90"}, {"sha": "73a27a42e69c909c858b6cd7fbb19fc6d6230ea8", "filename": "libgfortran/generated/_sin_c8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sin_c8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sin_c8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sin_c8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_8)\n+#ifdef HAVE_CSIN\n+\n elemental function specific__sin_c8 (parm)\n    complex (kind=8), intent (in) :: parm\n    complex (kind=8) :: specific__sin_c8\n \n    specific__sin_c8 = sin (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_sin_c8.f90"}, {"sha": "55f5871fc3decdf47f259bdfd23ad0424da9bf7c", "filename": "libgfortran/generated/_sin_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sin_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sin_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sin_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+#ifdef HAVE_SINL\n+\n+elemental function specific__sin_r10 (parm)\n+   real (kind=10), intent (in) :: parm\n+   real (kind=10) :: specific__sin_r10\n+\n+   specific__sin_r10 = sin (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "3757cc0b1f8e5023b08fe478caf9efc53184f470", "filename": "libgfortran/generated/_sin_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sin_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sin_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sin_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+#ifdef HAVE_SINL\n+\n+elemental function specific__sin_r16 (parm)\n+   real (kind=16), intent (in) :: parm\n+   real (kind=16) :: specific__sin_r16\n+\n+   specific__sin_r16 = sin (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "4fea10356e91a19152715f9dc48f9aac82ac9d50", "filename": "libgfortran/generated/_sin_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sin_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sin_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sin_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+#ifdef HAVE_SINF\n+\n elemental function specific__sin_r4 (parm)\n    real (kind=4), intent (in) :: parm\n    real (kind=4) :: specific__sin_r4\n \n    specific__sin_r4 = sin (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_sin_r4.f90"}, {"sha": "e35c3d1c25452527a9cb449742350fccfe417963", "filename": "libgfortran/generated/_sin_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sin_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sin_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sin_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+#ifdef HAVE_SIN\n+\n elemental function specific__sin_r8 (parm)\n    real (kind=8), intent (in) :: parm\n    real (kind=8) :: specific__sin_r8\n \n    specific__sin_r8 = sin (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_sin_r8.f90"}, {"sha": "7aa5e98a2f374f7844e9bf38fccb6130a015ab3f", "filename": "libgfortran/generated/_sinh_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sinh_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sinh_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sinh_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+#ifdef HAVE_SINHL\n+\n+elemental function specific__sinh_r10 (parm)\n+   real (kind=10), intent (in) :: parm\n+   real (kind=10) :: specific__sinh_r10\n+\n+   specific__sinh_r10 = sinh (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "6ea69470788b6ac387cab3a55ba014127193f116", "filename": "libgfortran/generated/_sinh_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sinh_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sinh_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sinh_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+#ifdef HAVE_SINHL\n+\n+elemental function specific__sinh_r16 (parm)\n+   real (kind=16), intent (in) :: parm\n+   real (kind=16) :: specific__sinh_r16\n+\n+   specific__sinh_r16 = sinh (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "1101debe9025f7eb69782287996efb904620a939", "filename": "libgfortran/generated/_sinh_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sinh_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sinh_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sinh_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+#ifdef HAVE_SINHF\n+\n elemental function specific__sinh_r4 (parm)\n    real (kind=4), intent (in) :: parm\n    real (kind=4) :: specific__sinh_r4\n \n    specific__sinh_r4 = sinh (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_sinh_r4.f90"}, {"sha": "63eb8d5c2465a6e5cc7774c06a9e2b315c70d64f", "filename": "libgfortran/generated/_sinh_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sinh_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sinh_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sinh_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+#ifdef HAVE_SINH\n+\n elemental function specific__sinh_r8 (parm)\n    real (kind=8), intent (in) :: parm\n    real (kind=8) :: specific__sinh_r8\n \n    specific__sinh_r8 = sinh (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_sinh_r8.f90"}, {"sha": "2159a6b93aaa4e0cb5c21982c981796cfc148376", "filename": "libgfortran/generated/_sqrt_c10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sqrt_c10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sqrt_c10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sqrt_c10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+#ifdef HAVE_CSQRTL\n+\n+elemental function specific__sqrt_c10 (parm)\n+   complex (kind=10), intent (in) :: parm\n+   complex (kind=10) :: specific__sqrt_c10\n+\n+   specific__sqrt_c10 = sqrt (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "2ee9c83a1bbb8e388c3c16d14bdf563532869303", "filename": "libgfortran/generated/_sqrt_c16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sqrt_c16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sqrt_c16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sqrt_c16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+#ifdef HAVE_CSQRTL\n+\n+elemental function specific__sqrt_c16 (parm)\n+   complex (kind=16), intent (in) :: parm\n+   complex (kind=16) :: specific__sqrt_c16\n+\n+   specific__sqrt_c16 = sqrt (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "1e88a3d6e5db5b04ef8197fd804a293284247e9e", "filename": "libgfortran/generated/_sqrt_c4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sqrt_c4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sqrt_c4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sqrt_c4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_4)\n+#ifdef HAVE_CSQRTF\n+\n elemental function specific__sqrt_c4 (parm)\n    complex (kind=4), intent (in) :: parm\n    complex (kind=4) :: specific__sqrt_c4\n \n    specific__sqrt_c4 = sqrt (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_sqrt_c4.f90"}, {"sha": "edd5e399b0b7ab84258bb642eb47be65445ba57d", "filename": "libgfortran/generated/_sqrt_c8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sqrt_c8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sqrt_c8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sqrt_c8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_8)\n+#ifdef HAVE_CSQRT\n+\n elemental function specific__sqrt_c8 (parm)\n    complex (kind=8), intent (in) :: parm\n    complex (kind=8) :: specific__sqrt_c8\n \n    specific__sqrt_c8 = sqrt (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_sqrt_c8.f90"}, {"sha": "2ea81ba56cbd3b9856d04a7eef845039aa9a60dd", "filename": "libgfortran/generated/_sqrt_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sqrt_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sqrt_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sqrt_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+#ifdef HAVE_SQRTL\n+\n+elemental function specific__sqrt_r10 (parm)\n+   real (kind=10), intent (in) :: parm\n+   real (kind=10) :: specific__sqrt_r10\n+\n+   specific__sqrt_r10 = sqrt (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "5ecd027bd1be0416863a16e44345260523e1138d", "filename": "libgfortran/generated/_sqrt_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sqrt_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sqrt_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sqrt_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+#ifdef HAVE_SQRTL\n+\n+elemental function specific__sqrt_r16 (parm)\n+   real (kind=16), intent (in) :: parm\n+   real (kind=16) :: specific__sqrt_r16\n+\n+   specific__sqrt_r16 = sqrt (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "43c710f0dd2ef38e84339846e1272005fd9371d5", "filename": "libgfortran/generated/_sqrt_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sqrt_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sqrt_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sqrt_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+#ifdef HAVE_SQRTF\n+\n elemental function specific__sqrt_r4 (parm)\n    real (kind=4), intent (in) :: parm\n    real (kind=4) :: specific__sqrt_r4\n \n    specific__sqrt_r4 = sqrt (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_sqrt_r4.f90"}, {"sha": "2f710962b8f7ee5183e83cc81835e8339321d8e7", "filename": "libgfortran/generated/_sqrt_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sqrt_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_sqrt_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sqrt_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+#ifdef HAVE_SQRT\n+\n elemental function specific__sqrt_r8 (parm)\n    real (kind=8), intent (in) :: parm\n    real (kind=8) :: specific__sqrt_r8\n \n    specific__sqrt_r8 = sqrt (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_sqrt_r8.f90"}, {"sha": "d4c06ae4a86bbe9b5791ac3dde7973d9607ff9db", "filename": "libgfortran/generated/_tan_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_tan_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_tan_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_tan_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+#ifdef HAVE_TANL\n+\n+elemental function specific__tan_r10 (parm)\n+   real (kind=10), intent (in) :: parm\n+   real (kind=10) :: specific__tan_r10\n+\n+   specific__tan_r10 = tan (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "5a6f61a3f9dfd2493ad4dda7b1b7025bac5394a0", "filename": "libgfortran/generated/_tan_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_tan_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_tan_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_tan_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+#ifdef HAVE_TANL\n+\n+elemental function specific__tan_r16 (parm)\n+   real (kind=16), intent (in) :: parm\n+   real (kind=16) :: specific__tan_r16\n+\n+   specific__tan_r16 = tan (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "ee8f438d7e279d41ba7d6eb339325df3a84ffa5c", "filename": "libgfortran/generated/_tan_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_tan_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_tan_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_tan_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+#ifdef HAVE_TANF\n+\n elemental function specific__tan_r4 (parm)\n    real (kind=4), intent (in) :: parm\n    real (kind=4) :: specific__tan_r4\n \n    specific__tan_r4 = tan (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_tan_r4.f90"}, {"sha": "f2e357b2dd1e0917268567c48aa0e01ac86fefe3", "filename": "libgfortran/generated/_tan_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_tan_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_tan_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_tan_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+#ifdef HAVE_TAN\n+\n elemental function specific__tan_r8 (parm)\n    real (kind=8), intent (in) :: parm\n    real (kind=8) :: specific__tan_r8\n \n    specific__tan_r8 = tan (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_tan_r8.f90"}, {"sha": "5d04f65475da364d8f9a809acde38aaf394be6bd", "filename": "libgfortran/generated/_tanh_r10.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_tanh_r10.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_tanh_r10.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_tanh_r10.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+#ifdef HAVE_TANHL\n+\n+elemental function specific__tanh_r10 (parm)\n+   real (kind=10), intent (in) :: parm\n+   real (kind=10) :: specific__tanh_r10\n+\n+   specific__tanh_r10 = tanh (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "9a858b5c071ca24a55241d4d469a53d91feba9ab", "filename": "libgfortran/generated/_tanh_r16.F90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_tanh_r16.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_tanh_r16.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_tanh_r16.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,51 @@\n+!   Copyright 2002 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 2 of the License, or (at your option) any later version.\n+\n+!In addition to the permissions in the GNU General Public License, the\n+!Free Software Foundation gives you unlimited permission to link the\n+!compiled version of this file into combinations with other programs,\n+!and to distribute those combinations without any restriction coming\n+!from the use of this file.  (The General Public License restrictions\n+!do apply in other respects; for example, they cover modification of\n+!the file, and distribution when not linked into a combine\n+!executable.)\n+!\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!You should have received a copy of the GNU General Public\n+!License along with libgfortran; see the file COPYING.  If not,\n+!write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+!Boston, MA 02110-1301, USA.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+#ifdef HAVE_TANHL\n+\n+elemental function specific__tanh_r16 (parm)\n+   real (kind=16), intent (in) :: parm\n+   real (kind=16) :: specific__tanh_r16\n+\n+   specific__tanh_r16 = tanh (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "0872fe66540e54c8394c1505f86e3b8011a9394b", "filename": "libgfortran/generated/_tanh_r4.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_tanh_r4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_tanh_r4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_tanh_r4.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_4)\n+#ifdef HAVE_TANHF\n+\n elemental function specific__tanh_r4 (parm)\n    real (kind=4), intent (in) :: parm\n    real (kind=4) :: specific__tanh_r4\n \n    specific__tanh_r4 = tanh (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_tanh_r4.f90"}, {"sha": "40a6668e403c71890a3f3b4eecb4d4bfcf1d9fc6", "filename": "libgfortran/generated/_tanh_r8.F90", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_tanh_r8.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2F_tanh_r8.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_tanh_r8.F90?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -30,9 +30,22 @@\n !This file is machine generated.\n \n \n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_8)\n+#ifdef HAVE_TANH\n+\n elemental function specific__tanh_r8 (parm)\n    real (kind=8), intent (in) :: parm\n    real (kind=8) :: specific__tanh_r8\n \n    specific__tanh_r8 = tanh (parm)\n end function\n+\n+#endif\n+#endif", "previous_filename": "libgfortran/generated/_tanh_r8.f90"}, {"sha": "40851eb2c19d763b75c07b4b1d51a380f82789d0", "filename": "libgfortran/generated/all_l16.c", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fall_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fall_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,177 @@\n+/* Implementation of the ALL intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_LOGICAL_16) && defined (HAVE_GFC_LOGICAL_16)\n+\n+\n+extern void all_l16 (gfc_array_l16 *, gfc_array_l16 *, index_type *);\n+export_proto(all_l16);\n+\n+void\n+all_l16 (gfc_array_l16 *retarray, gfc_array_l16 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_LOGICAL_16 *base;\n+  GFC_LOGICAL_16 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_LOGICAL_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_LOGICAL_16 *src;\n+      GFC_LOGICAL_16 result;\n+      src = base;\n+      {\n+\n+  /* Return true only if all the elements are set.  */\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 1;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (! *src)\n+    {\n+      result = 0;\n+      break;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "246ec07a5074b72b6acb8fbbea75370d125361e2", "filename": "libgfortran/generated/all_l4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fall_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fall_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_LOGICAL_4) && defined (HAVE_GFC_LOGICAL_4)\n+\n+\n extern void all_l4 (gfc_array_l4 *, gfc_array_l4 *, index_type *);\n export_proto(all_l4);\n \n@@ -171,3 +174,4 @@ all_l4 (gfc_array_l4 *retarray, gfc_array_l4 *array, index_type *pdim)\n     }\n }\n \n+#endif"}, {"sha": "996ce3560bf98f4952c147ee32c72fcdec9a4b38", "filename": "libgfortran/generated/all_l8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fall_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fall_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_LOGICAL_8) && defined (HAVE_GFC_LOGICAL_8)\n+\n+\n extern void all_l8 (gfc_array_l8 *, gfc_array_l8 *, index_type *);\n export_proto(all_l8);\n \n@@ -171,3 +174,4 @@ all_l8 (gfc_array_l8 *retarray, gfc_array_l8 *array, index_type *pdim)\n     }\n }\n \n+#endif"}, {"sha": "cf4798e7962bd019fd03bb9dd0711179df7f8314", "filename": "libgfortran/generated/any_l16.c", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fany_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fany_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,177 @@\n+/* Implementation of the ANY intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_LOGICAL_16) && defined (HAVE_GFC_LOGICAL_16)\n+\n+\n+extern void any_l16 (gfc_array_l16 *, gfc_array_l16 *, index_type *);\n+export_proto(any_l16);\n+\n+void\n+any_l16 (gfc_array_l16 *retarray, gfc_array_l16 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_LOGICAL_16 *base;\n+  GFC_LOGICAL_16 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_LOGICAL_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_LOGICAL_16 *src;\n+      GFC_LOGICAL_16 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  /* Return true if any of the elements are set.  */\n+  if (*src)\n+    {\n+      result = 1;\n+      break;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "994014a2cacf1bfeddbfe7ecd913643267ab156a", "filename": "libgfortran/generated/any_l4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fany_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fany_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_LOGICAL_4) && defined (HAVE_GFC_LOGICAL_4)\n+\n+\n extern void any_l4 (gfc_array_l4 *, gfc_array_l4 *, index_type *);\n export_proto(any_l4);\n \n@@ -171,3 +174,4 @@ any_l4 (gfc_array_l4 *retarray, gfc_array_l4 *array, index_type *pdim)\n     }\n }\n \n+#endif"}, {"sha": "9d52b15c509468ec4eeaee4d5d4099ed0ca8a225", "filename": "libgfortran/generated/any_l8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fany_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fany_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_LOGICAL_8) && defined (HAVE_GFC_LOGICAL_8)\n+\n+\n extern void any_l8 (gfc_array_l8 *, gfc_array_l8 *, index_type *);\n export_proto(any_l8);\n \n@@ -171,3 +174,4 @@ any_l8 (gfc_array_l8 *retarray, gfc_array_l8 *array, index_type *pdim)\n     }\n }\n \n+#endif"}, {"sha": "8cb795faf5ebfebc301615b161cf39ff89eac8ae", "filename": "libgfortran/generated/count_16_l16.c", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_16_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_16_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_16_l16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,173 @@\n+/* Implementation of the COUNT intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_LOGICAL_16) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void count_16_l16 (gfc_array_i16 *, gfc_array_l16 *, index_type *);\n+export_proto(count_16_l16);\n+\n+void\n+count_16_l16 (gfc_array_i16 *retarray, gfc_array_l16 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_LOGICAL_16 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_LOGICAL_16 *src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src)\n+    result++;\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "f4af5ba31525d3d2e3370acb60ba03be954c0b7a", "filename": "libgfortran/generated/count_16_l4.c", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_16_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_16_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_16_l4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,173 @@\n+/* Implementation of the COUNT intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_LOGICAL_4) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void count_16_l4 (gfc_array_i16 *, gfc_array_l4 *, index_type *);\n+export_proto(count_16_l4);\n+\n+void\n+count_16_l4 (gfc_array_i16 *retarray, gfc_array_l4 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_LOGICAL_4 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_LOGICAL_4 *src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src)\n+    result++;\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "6134f5b13c685969f90c5fc64cf1e7e5d40f7ca9", "filename": "libgfortran/generated/count_16_l8.c", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_16_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_16_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_16_l8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,173 @@\n+/* Implementation of the COUNT intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_LOGICAL_8) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void count_16_l8 (gfc_array_i16 *, gfc_array_l8 *, index_type *);\n+export_proto(count_16_l8);\n+\n+void\n+count_16_l8 (gfc_array_i16 *retarray, gfc_array_l8 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_LOGICAL_8 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_LOGICAL_8 *src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src)\n+    result++;\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "cbd1717df2550db3d2738f4ec7a7ab1ca167feb6", "filename": "libgfortran/generated/count_4_l16.c", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_4_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_4_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_4_l16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,173 @@\n+/* Implementation of the COUNT intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_LOGICAL_16) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void count_4_l16 (gfc_array_i4 *, gfc_array_l16 *, index_type *);\n+export_proto(count_4_l16);\n+\n+void\n+count_4_l16 (gfc_array_i4 *retarray, gfc_array_l16 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_LOGICAL_16 *base;\n+  GFC_INTEGER_4 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_LOGICAL_16 *src;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src)\n+    result++;\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "aa98bfc66c1d93f21428a8194689214cc0ceba88", "filename": "libgfortran/generated/count_4_l4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_4_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_4_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_4_l4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_LOGICAL_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n extern void count_4_l4 (gfc_array_i4 *, gfc_array_l4 *, index_type *);\n export_proto(count_4_l4);\n \n@@ -167,3 +170,4 @@ count_4_l4 (gfc_array_i4 *retarray, gfc_array_l4 *array, index_type *pdim)\n     }\n }\n \n+#endif"}, {"sha": "fe9eae530cf7f9187956248840e71cac47b8bde2", "filename": "libgfortran/generated/count_4_l8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_4_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_4_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_4_l8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_LOGICAL_8) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n extern void count_4_l8 (gfc_array_i4 *, gfc_array_l8 *, index_type *);\n export_proto(count_4_l8);\n \n@@ -167,3 +170,4 @@ count_4_l8 (gfc_array_i4 *retarray, gfc_array_l8 *array, index_type *pdim)\n     }\n }\n \n+#endif"}, {"sha": "4df2aeb82147368f4aed3c1a1231b2a7433f2afa", "filename": "libgfortran/generated/count_8_l16.c", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_8_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_8_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_8_l16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,173 @@\n+/* Implementation of the COUNT intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_LOGICAL_16) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void count_8_l16 (gfc_array_i8 *, gfc_array_l16 *, index_type *);\n+export_proto(count_8_l16);\n+\n+void\n+count_8_l16 (gfc_array_i8 *retarray, gfc_array_l16 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_LOGICAL_16 *base;\n+  GFC_INTEGER_8 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_LOGICAL_16 *src;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src)\n+    result++;\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "b32b30e173a16b3d807832ce6b1af4a1eff8cc4e", "filename": "libgfortran/generated/count_8_l4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_8_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_8_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_8_l4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_LOGICAL_4) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n extern void count_8_l4 (gfc_array_i8 *, gfc_array_l4 *, index_type *);\n export_proto(count_8_l4);\n \n@@ -167,3 +170,4 @@ count_8_l4 (gfc_array_i8 *retarray, gfc_array_l4 *array, index_type *pdim)\n     }\n }\n \n+#endif"}, {"sha": "670fc1d1cf1aa2d24d323dc772c896ef5838a6e9", "filename": "libgfortran/generated/count_8_l8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_8_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcount_8_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_8_l8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_LOGICAL_8) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n extern void count_8_l8 (gfc_array_i8 *, gfc_array_l8 *, index_type *);\n export_proto(count_8_l8);\n \n@@ -167,3 +170,4 @@ count_8_l8 (gfc_array_i8 *retarray, gfc_array_l8 *array, index_type *pdim)\n     }\n }\n \n+#endif"}, {"sha": "bff20d3b4be1dae04a2fbbfb7880280a6b5d33aa", "filename": "libgfortran/generated/cshift1_16.c", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcshift1_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcshift1_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,225 @@\n+/* Implementation of the CSHIFT intrinsic\n+   Copyright 2003 Free Software Foundation, Inc.\n+   Contributed by Feng Wang <wf_cs@yahoo.com>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+\n+static void\n+cshift1 (gfc_array_char * ret, const gfc_array_char * array,\n+\t const gfc_array_i16 * h, const GFC_INTEGER_16 * pwhich, index_type size)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  char *rptr;\n+  char *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const char *sptr;\n+  const char *src;\n+  /* h.* indicates the  array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  if (which < 0 || (which + 1) > GFC_DESCRIPTOR_RANK (array))\n+    runtime_error (\"Argument 'DIM' is out of range in call to 'CSHIFT'\");\n+\n+  if (ret->data == NULL)\n+    {\n+      int i;\n+\n+      ret->data = internal_malloc_size (size * size0 ((array_t *)array));\n+      ret->offset = 0;\n+      ret->dtype = array->dtype;\n+      for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n+        {\n+          ret->dim[i].lbound = 0;\n+          ret->dim[i].ubound = array->dim[i].ubound - array->dim[i].lbound;\n+\n+          if (i == 0)\n+            ret->dim[i].stride = 1;\n+          else\n+            ret->dim[i].stride = (ret->dim[i-1].ubound + 1) * ret->dim[i-1].stride;\n+        }\n+    }\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = size;\n+  soffset = size;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = ret->dim[dim].stride * size;\n+          if (roffset == 0)\n+            roffset = size;\n+          soffset = array->dim[dim].stride * size;\n+          if (soffset == 0)\n+            soffset = size;\n+          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          rstride[n] = ret->dim[dim].stride * size;\n+          sstride[n] = array->dim[dim].stride * size;\n+\n+          hstride[n] = h->dim[n].stride;\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = size;\n+  if (rstride[0] == 0)\n+    rstride[0] = size;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->data;\n+  sptr = array->data;\n+  hptr = h->data;\n+\n+  while (rptr)\n+    {\n+      /* Do the  for this dimension.  */\n+      sh = *hptr;\n+      sh = (div (sh, len)).rem;\n+      if (sh < 0)\n+        sh += len;\n+\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+\n+      for (n = 0; n < len; n++)\n+        {\n+          memcpy (dest, src, size);\n+          dest += roffset;\n+          if (n == len - sh - 1)\n+            src = sptr;\n+          else\n+            src += soffset;\n+        }\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+\t  hptr -= hstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+void cshift1_16 (gfc_array_char *, const gfc_array_char *,\n+\t\t\t   const gfc_array_i16 *, const GFC_INTEGER_16 *);\n+export_proto(cshift1_16);\n+\n+void\n+cshift1_16 (gfc_array_char * ret,\n+\t\t      const gfc_array_char * array,\n+\t\t      const gfc_array_i16 * h, const GFC_INTEGER_16 * pwhich)\n+{\n+  cshift1 (ret, array, h, pwhich, GFC_DESCRIPTOR_SIZE (array));\n+}\n+\n+void cshift1_16_char (gfc_array_char * ret, GFC_INTEGER_4,\n+\t\t\t\t  const gfc_array_char * array,\n+\t\t\t\t  const gfc_array_i16 * h, const GFC_INTEGER_16 * pwhich,\n+\t\t\t\t  GFC_INTEGER_4);\n+export_proto(cshift1_16_char);\n+\n+void\n+cshift1_16_char (gfc_array_char * ret,\n+\t\t\t     GFC_INTEGER_4 ret_length __attribute__((unused)),\n+\t\t\t     const gfc_array_char * array,\n+\t\t\t     const gfc_array_i16 * h, const GFC_INTEGER_16 * pwhich,\n+\t\t\t     GFC_INTEGER_4 array_length)\n+{\n+  cshift1 (ret, array, h, pwhich, array_length);\n+}\n+\n+#endif"}, {"sha": "9f9bea07c1ecc08ff2ebbeff4b294dc8633982be", "filename": "libgfortran/generated/cshift1_4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcshift1_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcshift1_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <string.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_INTEGER_4)\n+\n static void\n cshift1 (gfc_array_char * ret, const gfc_array_char * array,\n \t const gfc_array_i4 * h, const GFC_INTEGER_4 * pwhich, index_type size)\n@@ -219,3 +221,5 @@ cshift1_4_char (gfc_array_char * ret,\n {\n   cshift1 (ret, array, h, pwhich, array_length);\n }\n+\n+#endif"}, {"sha": "3a7c509b00c2f6cf911c55f0711d73c4e7b8fe68", "filename": "libgfortran/generated/cshift1_8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcshift1_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fcshift1_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <string.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_INTEGER_8)\n+\n static void\n cshift1 (gfc_array_char * ret, const gfc_array_char * array,\n \t const gfc_array_i8 * h, const GFC_INTEGER_8 * pwhich, index_type size)\n@@ -219,3 +221,5 @@ cshift1_8_char (gfc_array_char * ret,\n {\n   cshift1 (ret, array, h, pwhich, array_length);\n }\n+\n+#endif"}, {"sha": "3fa5955e200bf25f318439641dadad6fef5406dd", "filename": "libgfortran/generated/dotprod_c10.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fdotprod_c10.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,82 @@\n+/* Implementation of the DOT_PRODUCT intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+   and Feng Wang <fengwang@nudt.edu.cn>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+\n+typedef GFC_ARRAY_DESCRIPTOR(GFC_MAX_DIMENSIONS, char) char_array;\n+\n+extern GFC_COMPLEX_10 dot_product_c10 (gfc_array_c10 * a, gfc_array_c10 * b);\n+export_proto(dot_product_c10);\n+\n+/* Both parameters will already have been converted to the result type.  */\n+GFC_COMPLEX_10\n+dot_product_c10 (gfc_array_c10 * a, gfc_array_c10 * b)\n+{\n+  GFC_COMPLEX_10 *pa;\n+  GFC_COMPLEX_10 *pb;\n+  GFC_COMPLEX_10 res;\n+  GFC_COMPLEX_10 conjga;\n+  index_type count;\n+  index_type astride;\n+  index_type bstride;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 1\n+          && GFC_DESCRIPTOR_RANK (b) == 1);\n+\n+  if (a->dim[0].stride == 0)\n+    a->dim[0].stride = 1;\n+  if (b->dim[0].stride == 0)\n+    b->dim[0].stride = 1;\n+\n+  astride = a->dim[0].stride;\n+  bstride = b->dim[0].stride;\n+  count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+  res = 0;\n+  pa = a->data;\n+  pb = b->data;\n+\n+  while (count--)\n+    {\n+      COMPLEX_ASSIGN(conjga, REALPART (*pa), -IMAGPART (*pa));\n+      res += conjga * *pb;\n+      pa += astride;\n+      pb += bstride;\n+    }\n+\n+  return res;\n+}\n+\n+#endif"}, {"sha": "a526b533d4401e1f89dcc191f191654e2d3eab89", "filename": "libgfortran/generated/dotprod_c16.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fdotprod_c16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,82 @@\n+/* Implementation of the DOT_PRODUCT intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+   and Feng Wang <fengwang@nudt.edu.cn>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+\n+typedef GFC_ARRAY_DESCRIPTOR(GFC_MAX_DIMENSIONS, char) char_array;\n+\n+extern GFC_COMPLEX_16 dot_product_c16 (gfc_array_c16 * a, gfc_array_c16 * b);\n+export_proto(dot_product_c16);\n+\n+/* Both parameters will already have been converted to the result type.  */\n+GFC_COMPLEX_16\n+dot_product_c16 (gfc_array_c16 * a, gfc_array_c16 * b)\n+{\n+  GFC_COMPLEX_16 *pa;\n+  GFC_COMPLEX_16 *pb;\n+  GFC_COMPLEX_16 res;\n+  GFC_COMPLEX_16 conjga;\n+  index_type count;\n+  index_type astride;\n+  index_type bstride;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 1\n+          && GFC_DESCRIPTOR_RANK (b) == 1);\n+\n+  if (a->dim[0].stride == 0)\n+    a->dim[0].stride = 1;\n+  if (b->dim[0].stride == 0)\n+    b->dim[0].stride = 1;\n+\n+  astride = a->dim[0].stride;\n+  bstride = b->dim[0].stride;\n+  count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+  res = 0;\n+  pa = a->data;\n+  pb = b->data;\n+\n+  while (count--)\n+    {\n+      COMPLEX_ASSIGN(conjga, REALPART (*pa), -IMAGPART (*pa));\n+      res += conjga * *pb;\n+      pa += astride;\n+      pb += bstride;\n+    }\n+\n+  return res;\n+}\n+\n+#endif"}, {"sha": "ea27dd8457e8cd048c22f12d82a635befd343103", "filename": "libgfortran/generated/dotprod_c4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fdotprod_c4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_COMPLEX_4)\n+\n typedef GFC_ARRAY_DESCRIPTOR(GFC_MAX_DIMENSIONS, char) char_array;\n \n extern GFC_COMPLEX_4 dot_product_c4 (gfc_array_c4 * a, gfc_array_c4 * b);\n@@ -76,3 +78,5 @@ dot_product_c4 (gfc_array_c4 * a, gfc_array_c4 * b)\n \n   return res;\n }\n+\n+#endif"}, {"sha": "aec5fb5a3bce8da36b01dfc15b7307d9d0e41a4a", "filename": "libgfortran/generated/dotprod_c8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fdotprod_c8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_COMPLEX_8)\n+\n typedef GFC_ARRAY_DESCRIPTOR(GFC_MAX_DIMENSIONS, char) char_array;\n \n extern GFC_COMPLEX_8 dot_product_c8 (gfc_array_c8 * a, gfc_array_c8 * b);\n@@ -76,3 +78,5 @@ dot_product_c8 (gfc_array_c8 * a, gfc_array_c8 * b)\n \n   return res;\n }\n+\n+#endif"}, {"sha": "1c3e5825d0e6506a3f83a3078a76746b850cfc5f", "filename": "libgfortran/generated/dotprod_i16.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fdotprod_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,79 @@\n+/* Implementation of the DOT_PRODUCT intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+\n+typedef GFC_ARRAY_DESCRIPTOR(GFC_MAX_DIMENSIONS, char) char_array;\n+\n+extern GFC_INTEGER_16 dot_product_i16 (gfc_array_i16 * a, gfc_array_i16 * b);\n+export_proto(dot_product_i16);\n+\n+/* Both parameters will already have been converted to the result type.  */\n+GFC_INTEGER_16\n+dot_product_i16 (gfc_array_i16 * a, gfc_array_i16 * b)\n+{\n+  GFC_INTEGER_16 *pa;\n+  GFC_INTEGER_16 *pb;\n+  GFC_INTEGER_16 res;\n+  index_type count;\n+  index_type astride;\n+  index_type bstride;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 1\n+          && GFC_DESCRIPTOR_RANK (b) == 1);\n+\n+  if (a->dim[0].stride == 0)\n+    a->dim[0].stride = 1;\n+  if (b->dim[0].stride == 0)\n+    b->dim[0].stride = 1;\n+\n+  astride = a->dim[0].stride;\n+  bstride = b->dim[0].stride;\n+  count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+  res = 0;\n+  pa = a->data;\n+  pb = b->data;\n+\n+  while (count--)\n+    {\n+      res += *pa * *pb;\n+      pa += astride;\n+      pb += bstride;\n+    }\n+\n+  return res;\n+}\n+\n+#endif"}, {"sha": "aaf8b8d4efa1f78cd7fc40330954d586f52abc40", "filename": "libgfortran/generated/dotprod_i4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fdotprod_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -33,6 +33,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_INTEGER_4)\n+\n typedef GFC_ARRAY_DESCRIPTOR(GFC_MAX_DIMENSIONS, char) char_array;\n \n extern GFC_INTEGER_4 dot_product_i4 (gfc_array_i4 * a, gfc_array_i4 * b);\n@@ -73,3 +75,5 @@ dot_product_i4 (gfc_array_i4 * a, gfc_array_i4 * b)\n \n   return res;\n }\n+\n+#endif"}, {"sha": "44af1f15954acc7bce39a7c83485be645d43a020", "filename": "libgfortran/generated/dotprod_i8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fdotprod_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -33,6 +33,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_INTEGER_8)\n+\n typedef GFC_ARRAY_DESCRIPTOR(GFC_MAX_DIMENSIONS, char) char_array;\n \n extern GFC_INTEGER_8 dot_product_i8 (gfc_array_i8 * a, gfc_array_i8 * b);\n@@ -73,3 +75,5 @@ dot_product_i8 (gfc_array_i8 * a, gfc_array_i8 * b)\n \n   return res;\n }\n+\n+#endif"}, {"sha": "977eb4a3915659ef1b0bf0f936719a7269a24995", "filename": "libgfortran/generated/dotprod_l16.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fdotprod_l16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,89 @@\n+/* Implementation of the DOT_PRODUCT intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_LOGICAL_16)\n+\n+extern GFC_LOGICAL_16 dot_product_l16 (gfc_array_l4 *, gfc_array_l4 *);\n+export_proto(dot_product_l16);\n+\n+GFC_LOGICAL_16\n+dot_product_l16 (gfc_array_l4 * a, gfc_array_l4 * b)\n+{\n+  GFC_LOGICAL_4 *pa;\n+  GFC_LOGICAL_4 *pb;\n+  index_type count;\n+  index_type astride;\n+  index_type bstride;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 1\n+          && GFC_DESCRIPTOR_RANK (b) == 1);\n+\n+  if (a->dim[0].stride == 0)\n+    a->dim[0].stride = 1;\n+  if (b->dim[0].stride == 0)\n+    b->dim[0].stride = 1;\n+\n+  astride = a->dim[0].stride;\n+  bstride = b->dim[0].stride;\n+  count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+\n+  pa = a->data;\n+  if (GFC_DESCRIPTOR_SIZE (a) != 4)\n+    {\n+      assert (GFC_DESCRIPTOR_SIZE (a) == 8);\n+      pa = GFOR_POINTER_L8_TO_L4 (pa);\n+      astride <<= 1;\n+    }\n+  pb = b->data;\n+  if (GFC_DESCRIPTOR_SIZE (b) != 4)\n+    {\n+      assert (GFC_DESCRIPTOR_SIZE (b) == 8);\n+      pb = GFOR_POINTER_L8_TO_L4 (pb);\n+      bstride <<= 1;\n+    }\n+\n+  while (count--)\n+    {\n+      if (*pa && *pb)\n+        return 1;\n+\n+      pa += astride;\n+      pb += bstride;\n+    }\n+\n+  return 0;\n+}\n+\n+#endif"}, {"sha": "50db3981285395e4ed3296da92b0ce3833bf6db3", "filename": "libgfortran/generated/dotprod_l4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fdotprod_l4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -33,6 +33,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_LOGICAL_4)\n+\n extern GFC_LOGICAL_4 dot_product_l4 (gfc_array_l4 *, gfc_array_l4 *);\n export_proto(dot_product_l4);\n \n@@ -83,3 +85,5 @@ dot_product_l4 (gfc_array_l4 * a, gfc_array_l4 * b)\n \n   return 0;\n }\n+\n+#endif"}, {"sha": "f857d08ecd56890cae87d256586cfc9cc70a2ecd", "filename": "libgfortran/generated/dotprod_l8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fdotprod_l8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -33,6 +33,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_LOGICAL_8)\n+\n extern GFC_LOGICAL_8 dot_product_l8 (gfc_array_l4 *, gfc_array_l4 *);\n export_proto(dot_product_l8);\n \n@@ -83,3 +85,5 @@ dot_product_l8 (gfc_array_l4 * a, gfc_array_l4 * b)\n \n   return 0;\n }\n+\n+#endif"}, {"sha": "055c28837c4ad489fdeec4c47b2c076b18d73eca", "filename": "libgfortran/generated/dotprod_r10.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fdotprod_r10.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,79 @@\n+/* Implementation of the DOT_PRODUCT intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+\n+typedef GFC_ARRAY_DESCRIPTOR(GFC_MAX_DIMENSIONS, char) char_array;\n+\n+extern GFC_REAL_10 dot_product_r10 (gfc_array_r10 * a, gfc_array_r10 * b);\n+export_proto(dot_product_r10);\n+\n+/* Both parameters will already have been converted to the result type.  */\n+GFC_REAL_10\n+dot_product_r10 (gfc_array_r10 * a, gfc_array_r10 * b)\n+{\n+  GFC_REAL_10 *pa;\n+  GFC_REAL_10 *pb;\n+  GFC_REAL_10 res;\n+  index_type count;\n+  index_type astride;\n+  index_type bstride;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 1\n+          && GFC_DESCRIPTOR_RANK (b) == 1);\n+\n+  if (a->dim[0].stride == 0)\n+    a->dim[0].stride = 1;\n+  if (b->dim[0].stride == 0)\n+    b->dim[0].stride = 1;\n+\n+  astride = a->dim[0].stride;\n+  bstride = b->dim[0].stride;\n+  count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+  res = 0;\n+  pa = a->data;\n+  pb = b->data;\n+\n+  while (count--)\n+    {\n+      res += *pa * *pb;\n+      pa += astride;\n+      pb += bstride;\n+    }\n+\n+  return res;\n+}\n+\n+#endif"}, {"sha": "e14eaac4208e08a83c3e40d00a2635c40ec21c5c", "filename": "libgfortran/generated/dotprod_r16.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fdotprod_r16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,79 @@\n+/* Implementation of the DOT_PRODUCT intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+\n+typedef GFC_ARRAY_DESCRIPTOR(GFC_MAX_DIMENSIONS, char) char_array;\n+\n+extern GFC_REAL_16 dot_product_r16 (gfc_array_r16 * a, gfc_array_r16 * b);\n+export_proto(dot_product_r16);\n+\n+/* Both parameters will already have been converted to the result type.  */\n+GFC_REAL_16\n+dot_product_r16 (gfc_array_r16 * a, gfc_array_r16 * b)\n+{\n+  GFC_REAL_16 *pa;\n+  GFC_REAL_16 *pb;\n+  GFC_REAL_16 res;\n+  index_type count;\n+  index_type astride;\n+  index_type bstride;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 1\n+          && GFC_DESCRIPTOR_RANK (b) == 1);\n+\n+  if (a->dim[0].stride == 0)\n+    a->dim[0].stride = 1;\n+  if (b->dim[0].stride == 0)\n+    b->dim[0].stride = 1;\n+\n+  astride = a->dim[0].stride;\n+  bstride = b->dim[0].stride;\n+  count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+  res = 0;\n+  pa = a->data;\n+  pb = b->data;\n+\n+  while (count--)\n+    {\n+      res += *pa * *pb;\n+      pa += astride;\n+      pb += bstride;\n+    }\n+\n+  return res;\n+}\n+\n+#endif"}, {"sha": "bae99ab3f3664de4c535358dc7ea28c378113233", "filename": "libgfortran/generated/dotprod_r4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fdotprod_r4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -33,6 +33,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_REAL_4)\n+\n typedef GFC_ARRAY_DESCRIPTOR(GFC_MAX_DIMENSIONS, char) char_array;\n \n extern GFC_REAL_4 dot_product_r4 (gfc_array_r4 * a, gfc_array_r4 * b);\n@@ -73,3 +75,5 @@ dot_product_r4 (gfc_array_r4 * a, gfc_array_r4 * b)\n \n   return res;\n }\n+\n+#endif"}, {"sha": "84a6aaa011093ec6d470afefb3a5510d64bc52f4", "filename": "libgfortran/generated/dotprod_r8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fdotprod_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fdotprod_r8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -33,6 +33,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_REAL_8)\n+\n typedef GFC_ARRAY_DESCRIPTOR(GFC_MAX_DIMENSIONS, char) char_array;\n \n extern GFC_REAL_8 dot_product_r8 (gfc_array_r8 * a, gfc_array_r8 * b);\n@@ -73,3 +75,5 @@ dot_product_r8 (gfc_array_r8 * a, gfc_array_r8 * b)\n \n   return res;\n }\n+\n+#endif"}, {"sha": "c548fef3ae47e53a441b776222d44763e03f5d3e", "filename": "libgfortran/generated/eoshift1_16.c", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Feoshift1_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Feoshift1_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift1_16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,251 @@\n+/* Implementation of the EOSHIFT intrinsic\n+   Copyright 2002, 2005 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+\n+static void\n+eoshift1 (gfc_array_char *ret, const gfc_array_char *array, const gfc_array_i16 *h,\n+\t  const char *pbound, const GFC_INTEGER_16 *pwhich, index_type size,\n+\t  char filler)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  char *rptr;\n+  char *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const char *sptr;\n+  const char *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+  GFC_INTEGER_16 delta;\n+\n+  /* The compiler cannot figure out that these are set, initialize\n+     them to avoid warnings.  */\n+  len = 0;\n+  soffset = 0;\n+  roffset = 0;\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+\n+  if (ret->data == NULL)\n+    {\n+      int i;\n+\n+      ret->data = internal_malloc_size (size * size0 ((array_t *)array));\n+      ret->offset = 0;\n+      ret->dtype = array->dtype;\n+      for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n+        {\n+          ret->dim[i].lbound = 0;\n+          ret->dim[i].ubound = array->dim[i].ubound - array->dim[i].lbound;\n+\n+          if (i == 0)\n+            ret->dim[i].stride = 1;\n+          else\n+            ret->dim[i].stride = (ret->dim[i-1].ubound + 1) * ret->dim[i-1].stride;\n+        }\n+    }\n+\n+  n = 0;\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = ret->dim[dim].stride * size;\n+          if (roffset == 0)\n+            roffset = size;\n+          soffset = array->dim[dim].stride * size;\n+          if (soffset == 0)\n+            soffset = size;\n+          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          rstride[n] = ret->dim[dim].stride * size;\n+          sstride[n] = array->dim[dim].stride * size;\n+\n+          hstride[n] = h->dim[n].stride;\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = size;\n+  if (rstride[0] == 0)\n+    rstride[0] = size;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->data;\n+  sptr = array->data;\n+  hptr = h->data;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      if (( sh >= 0 ? sh : -sh ) > len)\n+\t{\n+\t  delta = len;\n+\t  sh = len;\n+\t}\n+      else\n+\tdelta = (sh >= 0) ? sh: -sh;\n+\n+      if (sh > 0)\n+        {\n+          src = &sptr[delta * soffset];\n+          dest = rptr;\n+        }\n+      else\n+        {\n+          src = sptr;\n+          dest = &rptr[delta * roffset];\n+        }\n+      for (n = 0; n < len - delta; n++)\n+        {\n+          memcpy (dest, src, size);\n+          dest += roffset;\n+          src += soffset;\n+        }\n+      if (sh < 0)\n+        dest = rptr;\n+      n = delta;\n+\n+      if (pbound)\n+\twhile (n--)\n+\t  {\n+\t    memcpy (dest, pbound, size);\n+\t    dest += roffset;\n+\t  }\n+      else\n+\twhile (n--)\n+\t  {\n+\t    memset (dest, filler, size);\n+\t    dest += roffset;\n+\t  }\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+\t  hptr -= hstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+void eoshift1_16 (gfc_array_char *, const gfc_array_char *,\n+\t\t\t    const gfc_array_i16 *, const char *, const GFC_INTEGER_16 *);\n+export_proto(eoshift1_16);\n+\n+void\n+eoshift1_16 (gfc_array_char *ret, const gfc_array_char *array,\n+\t\t       const gfc_array_i16 *h, const char *pbound,\n+\t\t       const GFC_INTEGER_16 *pwhich)\n+{\n+  eoshift1 (ret, array, h, pbound, pwhich, GFC_DESCRIPTOR_SIZE (array), 0);\n+}\n+\n+void eoshift1_16_char (gfc_array_char *, GFC_INTEGER_4,\n+\t\t\t\t   const gfc_array_char *, const gfc_array_i16 *,\n+\t\t\t\t   const char *, const GFC_INTEGER_16 *,\n+\t\t\t\t   GFC_INTEGER_4, GFC_INTEGER_4);\n+export_proto(eoshift1_16_char);\n+\n+void\n+eoshift1_16_char (gfc_array_char *ret,\n+\t\t\t      GFC_INTEGER_4 ret_length __attribute__((unused)),\n+\t\t\t      const gfc_array_char *array, const gfc_array_i16 *h,\n+\t\t\t      const char *pbound, const GFC_INTEGER_16 *pwhich,\n+\t\t\t      GFC_INTEGER_4 array_length,\n+\t\t\t      GFC_INTEGER_4 bound_length\n+\t\t\t\t__attribute__((unused)))\n+{\n+  eoshift1 (ret, array, h, pbound, pwhich, array_length, ' ');\n+}\n+\n+#endif"}, {"sha": "8045679ce921fb12b261c823f0e0ef408a1d393b", "filename": "libgfortran/generated/eoshift1_4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Feoshift1_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Feoshift1_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift1_4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <string.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_INTEGER_4)\n+\n static void\n eoshift1 (gfc_array_char *ret, const gfc_array_char *array, const gfc_array_i4 *h,\n \t  const char *pbound, const GFC_INTEGER_4 *pwhich, index_type size,\n@@ -245,3 +247,5 @@ eoshift1_4_char (gfc_array_char *ret,\n {\n   eoshift1 (ret, array, h, pbound, pwhich, array_length, ' ');\n }\n+\n+#endif"}, {"sha": "bcc53ab705461b4599f562319ba55bc17e71aaab", "filename": "libgfortran/generated/eoshift1_8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Feoshift1_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Feoshift1_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift1_8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <string.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_INTEGER_8)\n+\n static void\n eoshift1 (gfc_array_char *ret, const gfc_array_char *array, const gfc_array_i8 *h,\n \t  const char *pbound, const GFC_INTEGER_8 *pwhich, index_type size,\n@@ -245,3 +247,5 @@ eoshift1_8_char (gfc_array_char *ret,\n {\n   eoshift1 (ret, array, h, pbound, pwhich, array_length, ' ');\n }\n+\n+#endif"}, {"sha": "d03c1c7f1c9ee00c25dff6b0e7d895c9b23d2bc0", "filename": "libgfortran/generated/eoshift3_16.c", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Feoshift3_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Feoshift3_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift3_16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,273 @@\n+/* Implementation of the EOSHIFT intrinsic\n+   Copyright 2002, 2005 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+\n+static void\n+eoshift3 (gfc_array_char *ret, const gfc_array_char *array, const gfc_array_i16 *h,\n+\t  const gfc_array_char *bound, const GFC_INTEGER_16 *pwhich,\n+\t  index_type size, char filler)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  char *rptr;\n+  char *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const char *sptr;\n+  const char *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+  /* b.* indicates the bound array.  */\n+  index_type bstride[GFC_MAX_DIMENSIONS];\n+  index_type bstride0;\n+  const char *bptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+  GFC_INTEGER_16 delta;\n+\n+  /* The compiler cannot figure out that these are set, initialize\n+     them to avoid warnings.  */\n+  len = 0;\n+  soffset = 0;\n+  roffset = 0;\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  if (ret->data == NULL)\n+    {\n+      int i;\n+\n+      ret->data = internal_malloc_size (size * size0 ((array_t *)array));\n+      ret->offset = 0;\n+      ret->dtype = array->dtype;\n+      for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n+        {\n+          ret->dim[i].lbound = 0;\n+          ret->dim[i].ubound = array->dim[i].ubound - array->dim[i].lbound;\n+\n+          if (i == 0)\n+            ret->dim[i].stride = 1;\n+          else\n+            ret->dim[i].stride = (ret->dim[i-1].ubound + 1) * ret->dim[i-1].stride;\n+        }\n+    }\n+\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = ret->dim[dim].stride * size;\n+          if (roffset == 0)\n+            roffset = size;\n+          soffset = array->dim[dim].stride * size;\n+          if (soffset == 0)\n+            soffset = size;\n+          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          rstride[n] = ret->dim[dim].stride * size;\n+          sstride[n] = array->dim[dim].stride * size;\n+\n+          hstride[n] = h->dim[n].stride;\n+          if (bound)\n+            bstride[n] = bound->dim[n].stride * size;\n+          else\n+            bstride[n] = 0;\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = size;\n+  if (rstride[0] == 0)\n+    rstride[0] = size;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+  if (bound && bstride[0] == 0)\n+    bstride[0] = size;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  bstride0 = bstride[0];\n+  rptr = ret->data;\n+  sptr = array->data;\n+  hptr = h->data;\n+  if (bound)\n+    bptr = bound->data;\n+  else\n+    bptr = NULL;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      if (( sh >= 0 ? sh : -sh ) > len)\n+\t{\n+\t  delta = len;\n+\t  sh = len;\n+\t}\n+      else\n+\tdelta = (sh >= 0) ? sh: -sh;\n+\n+      if (sh > 0)\n+        {\n+          src = &sptr[delta * soffset];\n+          dest = rptr;\n+        }\n+      else\n+        {\n+          src = sptr;\n+          dest = &rptr[delta * roffset];\n+        }\n+      for (n = 0; n < len - delta; n++)\n+        {\n+          memcpy (dest, src, size);\n+          dest += roffset;\n+          src += soffset;\n+        }\n+      if (sh < 0)\n+        dest = rptr;\n+      n = delta;\n+\n+      if (bptr)\n+\twhile (n--)\n+\t  {\n+\t    memcpy (dest, bptr, size);\n+\t    dest += roffset;\n+\t  }\n+      else\n+\twhile (n--)\n+\t  {\n+\t    memset (dest, filler, size);\n+\t    dest += roffset;\n+\t  }\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      bptr += bstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+\t  hptr -= hstride[n] * extent[n];\n+          bptr -= bstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+              bptr += bstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+extern void eoshift3_16 (gfc_array_char *, const gfc_array_char *,\n+\t\t\t\t   const gfc_array_i16 *, const gfc_array_char *,\n+\t\t\t\t   const GFC_INTEGER_16 *);\n+export_proto(eoshift3_16);\n+\n+void\n+eoshift3_16 (gfc_array_char *ret, const gfc_array_char *array,\n+\t\t       const gfc_array_i16 *h, const gfc_array_char *bound,\n+\t\t       const GFC_INTEGER_16 *pwhich)\n+{\n+  eoshift3 (ret, array, h, bound, pwhich, GFC_DESCRIPTOR_SIZE (array), 0);\n+}\n+\n+extern void eoshift3_16_char (gfc_array_char *, GFC_INTEGER_4,\n+\t\t\t\t\t  const gfc_array_char *,\n+\t\t\t\t\t  const gfc_array_i16 *,\n+\t\t\t\t\t  const gfc_array_char *,\n+\t\t\t\t\t  const GFC_INTEGER_16 *, GFC_INTEGER_4,\n+\t\t\t\t\t  GFC_INTEGER_4);\n+export_proto(eoshift3_16_char);\n+\n+void\n+eoshift3_16_char (gfc_array_char *ret,\n+\t\t\t      GFC_INTEGER_4 ret_length __attribute__((unused)),\n+\t\t\t      const gfc_array_char *array, const gfc_array_i16 *h,\n+\t\t\t      const gfc_array_char *bound,\n+\t\t\t      const GFC_INTEGER_16 *pwhich,\n+\t\t\t      GFC_INTEGER_4 array_length,\n+\t\t\t      GFC_INTEGER_4 bound_length\n+\t\t\t\t__attribute__((unused)))\n+{\n+  eoshift3 (ret, array, h, bound, pwhich, array_length, ' ');\n+}\n+\n+#endif"}, {"sha": "2b84ece377cc0f0e47291c43321398214d37b2c1", "filename": "libgfortran/generated/eoshift3_4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Feoshift3_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Feoshift3_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift3_4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <string.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_INTEGER_4)\n+\n static void\n eoshift3 (gfc_array_char *ret, const gfc_array_char *array, const gfc_array_i4 *h,\n \t  const gfc_array_char *bound, const GFC_INTEGER_4 *pwhich,\n@@ -267,3 +269,5 @@ eoshift3_4_char (gfc_array_char *ret,\n {\n   eoshift3 (ret, array, h, bound, pwhich, array_length, ' ');\n }\n+\n+#endif"}, {"sha": "ba2ef1faa339337b5c536bff68f9b8901a42a61a", "filename": "libgfortran/generated/eoshift3_8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Feoshift3_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Feoshift3_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift3_8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <string.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_INTEGER_8)\n+\n static void\n eoshift3 (gfc_array_char *ret, const gfc_array_char *array, const gfc_array_i8 *h,\n \t  const gfc_array_char *bound, const GFC_INTEGER_8 *pwhich,\n@@ -267,3 +269,5 @@ eoshift3_8_char (gfc_array_char *ret,\n {\n   eoshift3 (ret, array, h, bound, pwhich, array_length, ' ');\n }\n+\n+#endif"}, {"sha": "da2d33b12620501d5668b048893dabe88d500dee", "filename": "libgfortran/generated/exponent_r10.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fexponent_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fexponent_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fexponent_r10.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,49 @@\n+/* Implementation of the EXPONENT intrinsic\n+   Copyright 2003 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <math.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_10) && defined (HAVE_FREXPL)\n+\n+extern GFC_INTEGER_4 exponent_r10 (GFC_REAL_10 s);\n+export_proto(exponent_r10);\n+\n+GFC_INTEGER_4\n+exponent_r10 (GFC_REAL_10 s)\n+{\n+  int ret;\n+  frexpl (s, &ret);\n+  return ret;\n+}\n+\n+#endif"}, {"sha": "de1769e3144391e43a6fa735661bd0bf4687bc44", "filename": "libgfortran/generated/exponent_r16.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fexponent_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fexponent_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fexponent_r16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,49 @@\n+/* Implementation of the EXPONENT intrinsic\n+   Copyright 2003 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <math.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_16) && defined (HAVE_FREXPL)\n+\n+extern GFC_INTEGER_4 exponent_r16 (GFC_REAL_16 s);\n+export_proto(exponent_r16);\n+\n+GFC_INTEGER_4\n+exponent_r16 (GFC_REAL_16 s)\n+{\n+  int ret;\n+  frexpl (s, &ret);\n+  return ret;\n+}\n+\n+#endif"}, {"sha": "9a9c7ebfcfeb5f18caf351740b0feae269952836", "filename": "libgfortran/generated/exponent_r4.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fexponent_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fexponent_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fexponent_r4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -27,10 +27,14 @@ You should have received a copy of the GNU General Public\n License along with libgfortran; see the file COPYING.  If not,\n write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n #include <math.h>\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_REAL_4) && defined (HAVE_FREXPF)\n+\n extern GFC_INTEGER_4 exponent_r4 (GFC_REAL_4 s);\n export_proto(exponent_r4);\n \n@@ -41,3 +45,5 @@ exponent_r4 (GFC_REAL_4 s)\n   frexpf (s, &ret);\n   return ret;\n }\n+\n+#endif"}, {"sha": "d41bf9a44c023813a2cd8b16d963aa8f1bb68a9f", "filename": "libgfortran/generated/exponent_r8.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fexponent_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fexponent_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fexponent_r8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -27,10 +27,14 @@ You should have received a copy of the GNU General Public\n License along with libgfortran; see the file COPYING.  If not,\n write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n #include <math.h>\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_REAL_8) && defined (HAVE_FREXP)\n+\n extern GFC_INTEGER_4 exponent_r8 (GFC_REAL_8 s);\n export_proto(exponent_r8);\n \n@@ -41,3 +45,5 @@ exponent_r8 (GFC_REAL_8 s)\n   frexp (s, &ret);\n   return ret;\n }\n+\n+#endif"}, {"sha": "aac9811af5e49b357f48f0774a18741518fa98bd", "filename": "libgfortran/generated/fraction_r10.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Ffraction_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Ffraction_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffraction_r10.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,48 @@\n+/* Implementation of the FRACTION intrinsic\n+   Copyright 2003 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <math.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_10) && defined (HAVE_FREXPL)\n+\n+extern GFC_REAL_10 fraction_r10 (GFC_REAL_10 s);\n+export_proto(fraction_r10);\n+\n+GFC_REAL_10\n+fraction_r10 (GFC_REAL_10 s)\n+{\n+  int dummy_exp;\n+  return frexpl (s, &dummy_exp);\n+}\n+\n+#endif"}, {"sha": "399682a8344a0c93167063f2d438997798ecedcf", "filename": "libgfortran/generated/fraction_r16.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Ffraction_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Ffraction_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffraction_r16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,48 @@\n+/* Implementation of the FRACTION intrinsic\n+   Copyright 2003 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <math.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_16) && defined (HAVE_FREXPL)\n+\n+extern GFC_REAL_16 fraction_r16 (GFC_REAL_16 s);\n+export_proto(fraction_r16);\n+\n+GFC_REAL_16\n+fraction_r16 (GFC_REAL_16 s)\n+{\n+  int dummy_exp;\n+  return frexpl (s, &dummy_exp);\n+}\n+\n+#endif"}, {"sha": "252335041d158517389668880295fc9b97a4ea1e", "filename": "libgfortran/generated/fraction_r4.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Ffraction_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Ffraction_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffraction_r4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -27,10 +27,14 @@ You should have received a copy of the GNU General Public\n License along with libgfortran; see the file COPYING.  If not,\n write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n #include <math.h>\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_REAL_4) && defined (HAVE_FREXPF)\n+\n extern GFC_REAL_4 fraction_r4 (GFC_REAL_4 s);\n export_proto(fraction_r4);\n \n@@ -40,3 +44,5 @@ fraction_r4 (GFC_REAL_4 s)\n   int dummy_exp;\n   return frexpf (s, &dummy_exp);\n }\n+\n+#endif"}, {"sha": "492e4540a81472493fd26c04af0ef5e038332201", "filename": "libgfortran/generated/fraction_r8.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Ffraction_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Ffraction_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffraction_r8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -27,10 +27,14 @@ You should have received a copy of the GNU General Public\n License along with libgfortran; see the file COPYING.  If not,\n write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n #include <math.h>\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_REAL_8) && defined (HAVE_FREXP)\n+\n extern GFC_REAL_8 fraction_r8 (GFC_REAL_8 s);\n export_proto(fraction_r8);\n \n@@ -40,3 +44,5 @@ fraction_r8 (GFC_REAL_8 s)\n   int dummy_exp;\n   return frexp (s, &dummy_exp);\n }\n+\n+#endif"}, {"sha": "5a91d9765bc07b017f99eb0a9331ba546b17cec2", "filename": "libgfortran/generated/in_pack_c10.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_pack_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_pack_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_c10.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,126 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+\n+/* Allocates a block of memory with internal_malloc if the array needs\n+   repacking.  */\n+\n+GFC_COMPLEX_10 *\n+internal_pack_c10 (gfc_array_c10 * source)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type ssize;\n+  const GFC_COMPLEX_10 *src;\n+  GFC_COMPLEX_10 *dest;\n+  GFC_COMPLEX_10 *destptr;\n+  int n;\n+  int packed;\n+\n+  if (source->dim[0].stride == 0)\n+    {\n+      source->dim[0].stride = 1;\n+      return source->data;\n+    }\n+\n+  dim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  packed = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = source->dim[n].stride;\n+      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        {\n+          /* Do nothing.  */\n+          packed = 1;\n+          break;\n+        }\n+\n+      if (ssize != stride[n])\n+        packed = 0;\n+\n+      ssize *= extent[n];\n+    }\n+\n+  if (packed)\n+    return source->data;\n+\n+  /* Allocate storage for the destination.  */\n+  destptr = (GFC_COMPLEX_10 *)internal_malloc_size (ssize * sizeof (GFC_COMPLEX_10));\n+  dest = destptr;\n+  src = source->data;\n+  stride0 = stride[0];\n+\n+\n+  while (src)\n+    {\n+      /* Copy the data.  */\n+      *(dest++) = *src;\n+      /* Advance to the next element.  */\n+      src += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          src -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              src = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              src += stride[n];\n+            }\n+        }\n+    }\n+  return destptr;\n+}\n+\n+#endif"}, {"sha": "d52249b648f5b611898d28f9e63f313dee1364e6", "filename": "libgfortran/generated/in_pack_c16.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_pack_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_pack_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_c16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,126 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+\n+/* Allocates a block of memory with internal_malloc if the array needs\n+   repacking.  */\n+\n+GFC_COMPLEX_16 *\n+internal_pack_c16 (gfc_array_c16 * source)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type ssize;\n+  const GFC_COMPLEX_16 *src;\n+  GFC_COMPLEX_16 *dest;\n+  GFC_COMPLEX_16 *destptr;\n+  int n;\n+  int packed;\n+\n+  if (source->dim[0].stride == 0)\n+    {\n+      source->dim[0].stride = 1;\n+      return source->data;\n+    }\n+\n+  dim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  packed = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = source->dim[n].stride;\n+      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        {\n+          /* Do nothing.  */\n+          packed = 1;\n+          break;\n+        }\n+\n+      if (ssize != stride[n])\n+        packed = 0;\n+\n+      ssize *= extent[n];\n+    }\n+\n+  if (packed)\n+    return source->data;\n+\n+  /* Allocate storage for the destination.  */\n+  destptr = (GFC_COMPLEX_16 *)internal_malloc_size (ssize * sizeof (GFC_COMPLEX_16));\n+  dest = destptr;\n+  src = source->data;\n+  stride0 = stride[0];\n+\n+\n+  while (src)\n+    {\n+      /* Copy the data.  */\n+      *(dest++) = *src;\n+      /* Advance to the next element.  */\n+      src += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          src -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              src = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              src += stride[n];\n+            }\n+        }\n+    }\n+  return destptr;\n+}\n+\n+#endif"}, {"sha": "a4fd70909d598711c90c32cd738426bdedf6713c", "filename": "libgfortran/generated/in_pack_c4.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_pack_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_pack_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_c4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -33,6 +33,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_COMPLEX_4)\n+\n /* Allocates a block of memory with internal_malloc if the array needs\n    repacking.  */\n \n@@ -121,3 +123,4 @@ internal_pack_c4 (gfc_array_c4 * source)\n   return destptr;\n }\n \n+#endif"}, {"sha": "a3c6214026ef085f6285a72cb24e067869172fd0", "filename": "libgfortran/generated/in_pack_c8.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_pack_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_pack_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_c8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -33,6 +33,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_COMPLEX_8)\n+\n /* Allocates a block of memory with internal_malloc if the array needs\n    repacking.  */\n \n@@ -121,3 +123,4 @@ internal_pack_c8 (gfc_array_c8 * source)\n   return destptr;\n }\n \n+#endif"}, {"sha": "b8c6c29d6f7cea86ebcdbe9ded091e694beec1f4", "filename": "libgfortran/generated/in_pack_i16.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_pack_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_pack_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,126 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+\n+/* Allocates a block of memory with internal_malloc if the array needs\n+   repacking.  */\n+\n+GFC_INTEGER_16 *\n+internal_pack_16 (gfc_array_i16 * source)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type ssize;\n+  const GFC_INTEGER_16 *src;\n+  GFC_INTEGER_16 *dest;\n+  GFC_INTEGER_16 *destptr;\n+  int n;\n+  int packed;\n+\n+  if (source->dim[0].stride == 0)\n+    {\n+      source->dim[0].stride = 1;\n+      return source->data;\n+    }\n+\n+  dim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  packed = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = source->dim[n].stride;\n+      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        {\n+          /* Do nothing.  */\n+          packed = 1;\n+          break;\n+        }\n+\n+      if (ssize != stride[n])\n+        packed = 0;\n+\n+      ssize *= extent[n];\n+    }\n+\n+  if (packed)\n+    return source->data;\n+\n+  /* Allocate storage for the destination.  */\n+  destptr = (GFC_INTEGER_16 *)internal_malloc_size (ssize * sizeof (GFC_INTEGER_16));\n+  dest = destptr;\n+  src = source->data;\n+  stride0 = stride[0];\n+\n+\n+  while (src)\n+    {\n+      /* Copy the data.  */\n+      *(dest++) = *src;\n+      /* Advance to the next element.  */\n+      src += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          src -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              src = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              src += stride[n];\n+            }\n+        }\n+    }\n+  return destptr;\n+}\n+\n+#endif"}, {"sha": "4452c644d715ea664324edcbc8b423014a2974d9", "filename": "libgfortran/generated/in_pack_i4.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_pack_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_pack_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -33,6 +33,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_INTEGER_4)\n+\n /* Allocates a block of memory with internal_malloc if the array needs\n    repacking.  */\n \n@@ -121,3 +123,4 @@ internal_pack_4 (gfc_array_i4 * source)\n   return destptr;\n }\n \n+#endif"}, {"sha": "35e48422897b52367b19511eec13df745f5b970a", "filename": "libgfortran/generated/in_pack_i8.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_pack_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_pack_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -33,6 +33,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_INTEGER_8)\n+\n /* Allocates a block of memory with internal_malloc if the array needs\n    repacking.  */\n \n@@ -121,3 +123,4 @@ internal_pack_8 (gfc_array_i8 * source)\n   return destptr;\n }\n \n+#endif"}, {"sha": "d7983f96ce657857f79f349dc9d6bbbfc7828218", "filename": "libgfortran/generated/in_unpack_c10.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_unpack_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_unpack_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_c10.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,114 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+\n+void\n+internal_unpack_c10 (gfc_array_c10 * d, const GFC_COMPLEX_10 * src)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type dsize;\n+  GFC_COMPLEX_10 *dest;\n+  int n;\n+\n+  dest = d->data;\n+  if (src == dest || !src)\n+    return;\n+\n+  if (d->dim[0].stride == 0)\n+    d->dim[0].stride = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (d);\n+  dsize = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = d->dim[n].stride;\n+      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        abort ();\n+\n+      if (dsize == stride[n])\n+        dsize *= extent[n];\n+      else\n+        dsize = 0;\n+    }\n+\n+  if (dsize != 0)\n+    {\n+      memcpy (dest, src, dsize * sizeof (GFC_COMPLEX_10));\n+      return;\n+    }\n+\n+  stride0 = stride[0];\n+\n+  while (dest)\n+    {\n+      /* Copy the data.  */\n+      *dest = *(src++);\n+      /* Advance to the next element.  */\n+      dest += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          dest -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              dest = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              dest += stride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "9f1baf279113c5088d921f213592f49b35ca4c3a", "filename": "libgfortran/generated/in_unpack_c16.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_unpack_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_unpack_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_c16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,114 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+\n+void\n+internal_unpack_c16 (gfc_array_c16 * d, const GFC_COMPLEX_16 * src)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type dsize;\n+  GFC_COMPLEX_16 *dest;\n+  int n;\n+\n+  dest = d->data;\n+  if (src == dest || !src)\n+    return;\n+\n+  if (d->dim[0].stride == 0)\n+    d->dim[0].stride = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (d);\n+  dsize = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = d->dim[n].stride;\n+      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        abort ();\n+\n+      if (dsize == stride[n])\n+        dsize *= extent[n];\n+      else\n+        dsize = 0;\n+    }\n+\n+  if (dsize != 0)\n+    {\n+      memcpy (dest, src, dsize * sizeof (GFC_COMPLEX_16));\n+      return;\n+    }\n+\n+  stride0 = stride[0];\n+\n+  while (dest)\n+    {\n+      /* Copy the data.  */\n+      *dest = *(src++);\n+      /* Advance to the next element.  */\n+      dest += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          dest -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              dest = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              dest += stride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "965b53a9c70e6261a3940943e1b5992e13a9f62a", "filename": "libgfortran/generated/in_unpack_c4.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_unpack_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_unpack_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_c4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <string.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_COMPLEX_4)\n+\n void\n internal_unpack_c4 (gfc_array_c4 * d, const GFC_COMPLEX_4 * src)\n {\n@@ -109,3 +111,4 @@ internal_unpack_c4 (gfc_array_c4 * d, const GFC_COMPLEX_4 * src)\n     }\n }\n \n+#endif"}, {"sha": "b5d747a7a99baf360d020f9d7f286853bde55ad0", "filename": "libgfortran/generated/in_unpack_c8.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_unpack_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_unpack_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_c8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <string.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_COMPLEX_8)\n+\n void\n internal_unpack_c8 (gfc_array_c8 * d, const GFC_COMPLEX_8 * src)\n {\n@@ -109,3 +111,4 @@ internal_unpack_c8 (gfc_array_c8 * d, const GFC_COMPLEX_8 * src)\n     }\n }\n \n+#endif"}, {"sha": "680b5dd2b59bafe8d5f09797f1d6a195094bb8e9", "filename": "libgfortran/generated/in_unpack_i16.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_unpack_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_unpack_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,114 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+internal_unpack_16 (gfc_array_i16 * d, const GFC_INTEGER_16 * src)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type dsize;\n+  GFC_INTEGER_16 *dest;\n+  int n;\n+\n+  dest = d->data;\n+  if (src == dest || !src)\n+    return;\n+\n+  if (d->dim[0].stride == 0)\n+    d->dim[0].stride = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (d);\n+  dsize = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = d->dim[n].stride;\n+      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        abort ();\n+\n+      if (dsize == stride[n])\n+        dsize *= extent[n];\n+      else\n+        dsize = 0;\n+    }\n+\n+  if (dsize != 0)\n+    {\n+      memcpy (dest, src, dsize * sizeof (GFC_INTEGER_16));\n+      return;\n+    }\n+\n+  stride0 = stride[0];\n+\n+  while (dest)\n+    {\n+      /* Copy the data.  */\n+      *dest = *(src++);\n+      /* Advance to the next element.  */\n+      dest += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          dest -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              dest = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              dest += stride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "6cf7bd2f273008fd7990e26ea3d6d48a46d00f65", "filename": "libgfortran/generated/in_unpack_i4.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_unpack_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_unpack_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <string.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_INTEGER_4)\n+\n void\n internal_unpack_4 (gfc_array_i4 * d, const GFC_INTEGER_4 * src)\n {\n@@ -109,3 +111,4 @@ internal_unpack_4 (gfc_array_i4 * d, const GFC_INTEGER_4 * src)\n     }\n }\n \n+#endif"}, {"sha": "1d4f0e459ab86ab8afd73af5e8c68da75eceadee", "filename": "libgfortran/generated/in_unpack_i8.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_unpack_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fin_unpack_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <string.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_INTEGER_8)\n+\n void\n internal_unpack_8 (gfc_array_i8 * d, const GFC_INTEGER_8 * src)\n {\n@@ -109,3 +111,4 @@ internal_unpack_8 (gfc_array_i8 * d, const GFC_INTEGER_8 * src)\n     }\n }\n \n+#endif"}, {"sha": "801649aa29de5f915f7a2b1524f01636d36df51b", "filename": "libgfortran/generated/matmul_c10.c", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c10.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,221 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright 2002, 2005 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+\n+/* This is a C version of the following fortran pseudo-code. The key\n+   point is the loop order -- we access all arrays column-first, which\n+   improves the performance enough to boost galgel spec score by 50%.\n+\n+   DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n+   C = 0\n+   DO J=1,N\n+     DO K=1,COUNT\n+       DO I=1,M\n+         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+*/\n+\n+extern void matmul_c10 (gfc_array_c10 * retarray, gfc_array_c10 * a, gfc_array_c10 * b);\n+export_proto(matmul_c10);\n+\n+void\n+matmul_c10 (gfc_array_c10 * retarray, gfc_array_c10 * a, gfc_array_c10 * b)\n+{\n+  GFC_COMPLEX_10 *abase;\n+  GFC_COMPLEX_10 *bbase;\n+  GFC_COMPLEX_10 *dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+  */\n+\n+  if (retarray->data == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n+          retarray->dim[0].stride = 1;\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n+          retarray->dim[0].stride = 1;\n+        }\n+      else\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n+          retarray->dim[0].stride = 1;\n+\n+          retarray->dim[1].lbound = 0;\n+          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n+          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+        }\n+\n+      retarray->data\n+\t= internal_malloc_size (sizeof (GFC_COMPLEX_10) * size0 ((array_t *) retarray));\n+      retarray->offset = 0;\n+    }\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+  if (retarray->dim[0].stride == 0)\n+    retarray->dim[0].stride = 1;\n+  if (a->dim[0].stride == 0)\n+    a->dim[0].stride = 1;\n+  if (b->dim[0].stride == 0)\n+    b->dim[0].stride = 1;\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = retarray->dim[0].stride;\n+    }\n+  else\n+    {\n+      rxstride = retarray->dim[0].stride;\n+      rystride = retarray->dim[1].stride;\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = a->dim[0].stride;\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+    }\n+  else\n+    {\n+      axstride = a->dim[0].stride;\n+      aystride = a->dim[1].stride;\n+\n+      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n+      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+    }\n+\n+  assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = b->dim[0].stride;\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = b->dim[0].stride;\n+      bystride = b->dim[1].stride;\n+      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+    }\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      GFC_COMPLEX_10 *bbase_y;\n+      GFC_COMPLEX_10 *dest_y;\n+      GFC_COMPLEX_10 *abase_n;\n+      GFC_COMPLEX_10 bbase_yn;\n+\n+      if (rystride == ycount)\n+\tmemset (dest, 0, (sizeof (GFC_COMPLEX_10) * size0((array_t *) retarray)));\n+      else\n+\t{\n+\t  for (y = 0; y < ycount; y++)\n+\t    for (x = 0; x < xcount; x++)\n+\t      dest[x + y*rystride] = (GFC_COMPLEX_10)0;\n+\t}\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = bbase + y*bystride;\n+\t  dest_y = dest + y*rystride;\n+\t  for (n = 0; n < count; n++)\n+\t    {\n+\t      abase_n = abase + n*aystride;\n+\t      bbase_yn = bbase_y[n];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+    }\n+}\n+\n+#endif"}, {"sha": "fb4870cba39c65d6f0795ddc50e86d9a7527d018", "filename": "libgfortran/generated/matmul_c16.c", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,221 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright 2002, 2005 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+\n+/* This is a C version of the following fortran pseudo-code. The key\n+   point is the loop order -- we access all arrays column-first, which\n+   improves the performance enough to boost galgel spec score by 50%.\n+\n+   DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n+   C = 0\n+   DO J=1,N\n+     DO K=1,COUNT\n+       DO I=1,M\n+         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+*/\n+\n+extern void matmul_c16 (gfc_array_c16 * retarray, gfc_array_c16 * a, gfc_array_c16 * b);\n+export_proto(matmul_c16);\n+\n+void\n+matmul_c16 (gfc_array_c16 * retarray, gfc_array_c16 * a, gfc_array_c16 * b)\n+{\n+  GFC_COMPLEX_16 *abase;\n+  GFC_COMPLEX_16 *bbase;\n+  GFC_COMPLEX_16 *dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+  */\n+\n+  if (retarray->data == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n+          retarray->dim[0].stride = 1;\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n+          retarray->dim[0].stride = 1;\n+        }\n+      else\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n+          retarray->dim[0].stride = 1;\n+\n+          retarray->dim[1].lbound = 0;\n+          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n+          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+        }\n+\n+      retarray->data\n+\t= internal_malloc_size (sizeof (GFC_COMPLEX_16) * size0 ((array_t *) retarray));\n+      retarray->offset = 0;\n+    }\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+  if (retarray->dim[0].stride == 0)\n+    retarray->dim[0].stride = 1;\n+  if (a->dim[0].stride == 0)\n+    a->dim[0].stride = 1;\n+  if (b->dim[0].stride == 0)\n+    b->dim[0].stride = 1;\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = retarray->dim[0].stride;\n+    }\n+  else\n+    {\n+      rxstride = retarray->dim[0].stride;\n+      rystride = retarray->dim[1].stride;\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = a->dim[0].stride;\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+    }\n+  else\n+    {\n+      axstride = a->dim[0].stride;\n+      aystride = a->dim[1].stride;\n+\n+      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n+      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+    }\n+\n+  assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = b->dim[0].stride;\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = b->dim[0].stride;\n+      bystride = b->dim[1].stride;\n+      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+    }\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      GFC_COMPLEX_16 *bbase_y;\n+      GFC_COMPLEX_16 *dest_y;\n+      GFC_COMPLEX_16 *abase_n;\n+      GFC_COMPLEX_16 bbase_yn;\n+\n+      if (rystride == ycount)\n+\tmemset (dest, 0, (sizeof (GFC_COMPLEX_16) * size0((array_t *) retarray)));\n+      else\n+\t{\n+\t  for (y = 0; y < ycount; y++)\n+\t    for (x = 0; x < xcount; x++)\n+\t      dest[x + y*rystride] = (GFC_COMPLEX_16)0;\n+\t}\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = bbase + y*bystride;\n+\t  dest_y = dest + y*rystride;\n+\t  for (n = 0; n < count; n++)\n+\t    {\n+\t      abase_n = abase + n*aystride;\n+\t      bbase_yn = bbase_y[n];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+    }\n+}\n+\n+#endif"}, {"sha": "8c9a7104ca8490eab70454d6d026f998a2636dec", "filename": "libgfortran/generated/matmul_c4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_COMPLEX_4)\n+\n /* This is a C version of the following fortran pseudo-code. The key\n    point is the loop order -- we access all arrays column-first, which\n    improves the performance enough to boost galgel spec score by 50%.\n@@ -215,3 +217,5 @@ matmul_c4 (gfc_array_c4 * retarray, gfc_array_c4 * a, gfc_array_c4 * b)\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n }\n+\n+#endif"}, {"sha": "7b713f1343ab5fc4a2aba36fbc0b41c84fc0fa21", "filename": "libgfortran/generated/matmul_c8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_COMPLEX_8)\n+\n /* This is a C version of the following fortran pseudo-code. The key\n    point is the loop order -- we access all arrays column-first, which\n    improves the performance enough to boost galgel spec score by 50%.\n@@ -215,3 +217,5 @@ matmul_c8 (gfc_array_c8 * retarray, gfc_array_c8 * a, gfc_array_c8 * b)\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n }\n+\n+#endif"}, {"sha": "adbfbedaeb2e5ba9341c056e0fe4e229d038c73a", "filename": "libgfortran/generated/matmul_i16.c", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,221 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright 2002, 2005 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+\n+/* This is a C version of the following fortran pseudo-code. The key\n+   point is the loop order -- we access all arrays column-first, which\n+   improves the performance enough to boost galgel spec score by 50%.\n+\n+   DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n+   C = 0\n+   DO J=1,N\n+     DO K=1,COUNT\n+       DO I=1,M\n+         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+*/\n+\n+extern void matmul_i16 (gfc_array_i16 * retarray, gfc_array_i16 * a, gfc_array_i16 * b);\n+export_proto(matmul_i16);\n+\n+void\n+matmul_i16 (gfc_array_i16 * retarray, gfc_array_i16 * a, gfc_array_i16 * b)\n+{\n+  GFC_INTEGER_16 *abase;\n+  GFC_INTEGER_16 *bbase;\n+  GFC_INTEGER_16 *dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+  */\n+\n+  if (retarray->data == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n+          retarray->dim[0].stride = 1;\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n+          retarray->dim[0].stride = 1;\n+        }\n+      else\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n+          retarray->dim[0].stride = 1;\n+\n+          retarray->dim[1].lbound = 0;\n+          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n+          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+        }\n+\n+      retarray->data\n+\t= internal_malloc_size (sizeof (GFC_INTEGER_16) * size0 ((array_t *) retarray));\n+      retarray->offset = 0;\n+    }\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+  if (retarray->dim[0].stride == 0)\n+    retarray->dim[0].stride = 1;\n+  if (a->dim[0].stride == 0)\n+    a->dim[0].stride = 1;\n+  if (b->dim[0].stride == 0)\n+    b->dim[0].stride = 1;\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = retarray->dim[0].stride;\n+    }\n+  else\n+    {\n+      rxstride = retarray->dim[0].stride;\n+      rystride = retarray->dim[1].stride;\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = a->dim[0].stride;\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+    }\n+  else\n+    {\n+      axstride = a->dim[0].stride;\n+      aystride = a->dim[1].stride;\n+\n+      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n+      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+    }\n+\n+  assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = b->dim[0].stride;\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = b->dim[0].stride;\n+      bystride = b->dim[1].stride;\n+      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+    }\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      GFC_INTEGER_16 *bbase_y;\n+      GFC_INTEGER_16 *dest_y;\n+      GFC_INTEGER_16 *abase_n;\n+      GFC_INTEGER_16 bbase_yn;\n+\n+      if (rystride == ycount)\n+\tmemset (dest, 0, (sizeof (GFC_INTEGER_16) * size0((array_t *) retarray)));\n+      else\n+\t{\n+\t  for (y = 0; y < ycount; y++)\n+\t    for (x = 0; x < xcount; x++)\n+\t      dest[x + y*rystride] = (GFC_INTEGER_16)0;\n+\t}\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = bbase + y*bystride;\n+\t  dest_y = dest + y*rystride;\n+\t  for (n = 0; n < count; n++)\n+\t    {\n+\t      abase_n = abase + n*aystride;\n+\t      bbase_yn = bbase_y[n];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+    }\n+}\n+\n+#endif"}, {"sha": "abace324d95da63419276e9a21aac575d6822bac", "filename": "libgfortran/generated/matmul_i4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_INTEGER_4)\n+\n /* This is a C version of the following fortran pseudo-code. The key\n    point is the loop order -- we access all arrays column-first, which\n    improves the performance enough to boost galgel spec score by 50%.\n@@ -215,3 +217,5 @@ matmul_i4 (gfc_array_i4 * retarray, gfc_array_i4 * a, gfc_array_i4 * b)\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n }\n+\n+#endif"}, {"sha": "9820e405cd0472b935456ebeac4fa093654fca2d", "filename": "libgfortran/generated/matmul_i8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_INTEGER_8)\n+\n /* This is a C version of the following fortran pseudo-code. The key\n    point is the loop order -- we access all arrays column-first, which\n    improves the performance enough to boost galgel spec score by 50%.\n@@ -215,3 +217,5 @@ matmul_i8 (gfc_array_i8 * retarray, gfc_array_i8 * a, gfc_array_i8 * b)\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n }\n+\n+#endif"}, {"sha": "28dce3a242253bc45bb01604db2163ff596a50fc", "filename": "libgfortran/generated/matmul_l16.c", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_l16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,196 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright 2002, 2005 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_LOGICAL_16)\n+\n+/* Dimensions: retarray(x,y) a(x, count) b(count,y).\n+   Either a or b can be rank 1.  In this case x or y is 1.  */\n+\n+extern void matmul_l16 (gfc_array_l16 *, gfc_array_l4 *, gfc_array_l4 *);\n+export_proto(matmul_l16);\n+\n+void\n+matmul_l16 (gfc_array_l16 * retarray, gfc_array_l4 * a, gfc_array_l4 * b)\n+{\n+  GFC_INTEGER_4 *abase;\n+  GFC_INTEGER_4 *bbase;\n+  GFC_LOGICAL_16 *dest;\n+  index_type rxstride;\n+  index_type rystride;\n+  index_type xcount;\n+  index_type ycount;\n+  index_type xstride;\n+  index_type ystride;\n+  index_type x;\n+  index_type y;\n+\n+  GFC_INTEGER_4 *pa;\n+  GFC_INTEGER_4 *pb;\n+  index_type astride;\n+  index_type bstride;\n+  index_type count;\n+  index_type n;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+  if (retarray->data == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n+          retarray->dim[0].stride = 1;\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n+          retarray->dim[0].stride = 1;\n+        }\n+      else\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n+          retarray->dim[0].stride = 1;\n+          \n+          retarray->dim[1].lbound = 0;\n+          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n+          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+        }\n+          \n+      retarray->data\n+\t= internal_malloc_size (sizeof (GFC_LOGICAL_16) * size0 ((array_t *) retarray));\n+      retarray->offset = 0;\n+    }\n+\n+  abase = a->data;\n+  if (GFC_DESCRIPTOR_SIZE (a) != 4)\n+    {\n+      assert (GFC_DESCRIPTOR_SIZE (a) == 8);\n+      abase = GFOR_POINTER_L8_TO_L4 (abase);\n+    }\n+  bbase = b->data;\n+  if (GFC_DESCRIPTOR_SIZE (b) != 4)\n+    {\n+      assert (GFC_DESCRIPTOR_SIZE (b) == 8);\n+      bbase = GFOR_POINTER_L8_TO_L4 (bbase);\n+    }\n+  dest = retarray->data;\n+\n+  if (retarray->dim[0].stride == 0)\n+    retarray->dim[0].stride = 1;\n+  if (a->dim[0].stride == 0)\n+    a->dim[0].stride = 1;\n+  if (b->dim[0].stride == 0)\n+    b->dim[0].stride = 1;\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      rxstride = retarray->dim[0].stride;\n+      rystride = rxstride;\n+    }\n+  else\n+    {\n+      rxstride = retarray->dim[0].stride;\n+      rystride = retarray->dim[1].stride;\n+    }\n+\n+  /* If we have rank 1 parameters, zero the absent stride, and set the size to\n+     one.  */\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      astride = a->dim[0].stride;\n+      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+      xstride = 0;\n+      rxstride = 0;\n+      xcount = 1;\n+    }\n+  else\n+    {\n+      astride = a->dim[1].stride;\n+      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n+      xstride = a->dim[0].stride;\n+      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+    }\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      bstride = b->dim[0].stride;\n+      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+      ystride = 0;\n+      rystride = 0;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bstride = b->dim[0].stride;\n+      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+      ystride = b->dim[1].stride;\n+      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+    }\n+\n+  for (y = 0; y < ycount; y++)\n+    {\n+      for (x = 0; x < xcount; x++)\n+        {\n+          /* Do the summation for this element.  For real and integer types\n+             this is the same as DOT_PRODUCT.  For complex types we use do\n+             a*b, not conjg(a)*b.  */\n+          pa = abase;\n+          pb = bbase;\n+          *dest = 0;\n+\n+          for (n = 0; n < count; n++)\n+            {\n+              if (*pa && *pb)\n+                {\n+                  *dest = 1;\n+                  break;\n+                }\n+              pa += astride;\n+              pb += bstride;\n+            }\n+\n+          dest += rxstride;\n+          abase += xstride;\n+        }\n+      abase -= xstride * xcount;\n+      bbase += ystride;\n+      dest += rystride - (rxstride * xcount);\n+    }\n+}\n+\n+#endif"}, {"sha": "da6681479a50e5d9d226b8cc65ded96092df29c6", "filename": "libgfortran/generated/matmul_l4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_l4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -33,6 +33,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_LOGICAL_4)\n+\n /* Dimensions: retarray(x,y) a(x, count) b(count,y).\n    Either a or b can be rank 1.  In this case x or y is 1.  */\n \n@@ -190,3 +192,5 @@ matmul_l4 (gfc_array_l4 * retarray, gfc_array_l4 * a, gfc_array_l4 * b)\n       dest += rystride - (rxstride * xcount);\n     }\n }\n+\n+#endif"}, {"sha": "22c1a660941cf5d6eda45d3c4b27a89f45bd6d6a", "filename": "libgfortran/generated/matmul_l8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_l8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -33,6 +33,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_LOGICAL_8)\n+\n /* Dimensions: retarray(x,y) a(x, count) b(count,y).\n    Either a or b can be rank 1.  In this case x or y is 1.  */\n \n@@ -190,3 +192,5 @@ matmul_l8 (gfc_array_l8 * retarray, gfc_array_l4 * a, gfc_array_l4 * b)\n       dest += rystride - (rxstride * xcount);\n     }\n }\n+\n+#endif"}, {"sha": "8aa342da2f4a69fcd9bcaf3e50f667c1c072465d", "filename": "libgfortran/generated/matmul_r10.c", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r10.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,221 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright 2002, 2005 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_REAL_10)\n+\n+/* This is a C version of the following fortran pseudo-code. The key\n+   point is the loop order -- we access all arrays column-first, which\n+   improves the performance enough to boost galgel spec score by 50%.\n+\n+   DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n+   C = 0\n+   DO J=1,N\n+     DO K=1,COUNT\n+       DO I=1,M\n+         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+*/\n+\n+extern void matmul_r10 (gfc_array_r10 * retarray, gfc_array_r10 * a, gfc_array_r10 * b);\n+export_proto(matmul_r10);\n+\n+void\n+matmul_r10 (gfc_array_r10 * retarray, gfc_array_r10 * a, gfc_array_r10 * b)\n+{\n+  GFC_REAL_10 *abase;\n+  GFC_REAL_10 *bbase;\n+  GFC_REAL_10 *dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+  */\n+\n+  if (retarray->data == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n+          retarray->dim[0].stride = 1;\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n+          retarray->dim[0].stride = 1;\n+        }\n+      else\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n+          retarray->dim[0].stride = 1;\n+\n+          retarray->dim[1].lbound = 0;\n+          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n+          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+        }\n+\n+      retarray->data\n+\t= internal_malloc_size (sizeof (GFC_REAL_10) * size0 ((array_t *) retarray));\n+      retarray->offset = 0;\n+    }\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+  if (retarray->dim[0].stride == 0)\n+    retarray->dim[0].stride = 1;\n+  if (a->dim[0].stride == 0)\n+    a->dim[0].stride = 1;\n+  if (b->dim[0].stride == 0)\n+    b->dim[0].stride = 1;\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = retarray->dim[0].stride;\n+    }\n+  else\n+    {\n+      rxstride = retarray->dim[0].stride;\n+      rystride = retarray->dim[1].stride;\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = a->dim[0].stride;\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+    }\n+  else\n+    {\n+      axstride = a->dim[0].stride;\n+      aystride = a->dim[1].stride;\n+\n+      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n+      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+    }\n+\n+  assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = b->dim[0].stride;\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = b->dim[0].stride;\n+      bystride = b->dim[1].stride;\n+      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+    }\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      GFC_REAL_10 *bbase_y;\n+      GFC_REAL_10 *dest_y;\n+      GFC_REAL_10 *abase_n;\n+      GFC_REAL_10 bbase_yn;\n+\n+      if (rystride == ycount)\n+\tmemset (dest, 0, (sizeof (GFC_REAL_10) * size0((array_t *) retarray)));\n+      else\n+\t{\n+\t  for (y = 0; y < ycount; y++)\n+\t    for (x = 0; x < xcount; x++)\n+\t      dest[x + y*rystride] = (GFC_REAL_10)0;\n+\t}\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = bbase + y*bystride;\n+\t  dest_y = dest + y*rystride;\n+\t  for (n = 0; n < count; n++)\n+\t    {\n+\t      abase_n = abase + n*aystride;\n+\t      bbase_yn = bbase_y[n];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_REAL_10)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+    }\n+}\n+\n+#endif"}, {"sha": "549f39ea6ca1d036adb3e52e1cd9823eeca06210", "filename": "libgfortran/generated/matmul_r16.c", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,221 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright 2002, 2005 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+\n+/* This is a C version of the following fortran pseudo-code. The key\n+   point is the loop order -- we access all arrays column-first, which\n+   improves the performance enough to boost galgel spec score by 50%.\n+\n+   DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n+   C = 0\n+   DO J=1,N\n+     DO K=1,COUNT\n+       DO I=1,M\n+         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+*/\n+\n+extern void matmul_r16 (gfc_array_r16 * retarray, gfc_array_r16 * a, gfc_array_r16 * b);\n+export_proto(matmul_r16);\n+\n+void\n+matmul_r16 (gfc_array_r16 * retarray, gfc_array_r16 * a, gfc_array_r16 * b)\n+{\n+  GFC_REAL_16 *abase;\n+  GFC_REAL_16 *bbase;\n+  GFC_REAL_16 *dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+  */\n+\n+  if (retarray->data == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n+          retarray->dim[0].stride = 1;\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n+          retarray->dim[0].stride = 1;\n+        }\n+      else\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n+          retarray->dim[0].stride = 1;\n+\n+          retarray->dim[1].lbound = 0;\n+          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n+          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+        }\n+\n+      retarray->data\n+\t= internal_malloc_size (sizeof (GFC_REAL_16) * size0 ((array_t *) retarray));\n+      retarray->offset = 0;\n+    }\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+  if (retarray->dim[0].stride == 0)\n+    retarray->dim[0].stride = 1;\n+  if (a->dim[0].stride == 0)\n+    a->dim[0].stride = 1;\n+  if (b->dim[0].stride == 0)\n+    b->dim[0].stride = 1;\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = retarray->dim[0].stride;\n+    }\n+  else\n+    {\n+      rxstride = retarray->dim[0].stride;\n+      rystride = retarray->dim[1].stride;\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = a->dim[0].stride;\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+    }\n+  else\n+    {\n+      axstride = a->dim[0].stride;\n+      aystride = a->dim[1].stride;\n+\n+      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n+      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+    }\n+\n+  assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = b->dim[0].stride;\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = b->dim[0].stride;\n+      bystride = b->dim[1].stride;\n+      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+    }\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      GFC_REAL_16 *bbase_y;\n+      GFC_REAL_16 *dest_y;\n+      GFC_REAL_16 *abase_n;\n+      GFC_REAL_16 bbase_yn;\n+\n+      if (rystride == ycount)\n+\tmemset (dest, 0, (sizeof (GFC_REAL_16) * size0((array_t *) retarray)));\n+      else\n+\t{\n+\t  for (y = 0; y < ycount; y++)\n+\t    for (x = 0; x < xcount; x++)\n+\t      dest[x + y*rystride] = (GFC_REAL_16)0;\n+\t}\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = bbase + y*bystride;\n+\t  dest_y = dest + y*rystride;\n+\t  for (n = 0; n < count; n++)\n+\t    {\n+\t      abase_n = abase + n*aystride;\n+\t      bbase_yn = bbase_y[n];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_REAL_16)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+    }\n+}\n+\n+#endif"}, {"sha": "b1d3eb77c9d464bfce60eb4aa07c7150cff072c7", "filename": "libgfortran/generated/matmul_r4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_REAL_4)\n+\n /* This is a C version of the following fortran pseudo-code. The key\n    point is the loop order -- we access all arrays column-first, which\n    improves the performance enough to boost galgel spec score by 50%.\n@@ -215,3 +217,5 @@ matmul_r4 (gfc_array_r4 * retarray, gfc_array_r4 * a, gfc_array_r4 * b)\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n }\n+\n+#endif"}, {"sha": "df9fc3e6a0ead568afc0a5247aba13f151cfe8ed", "filename": "libgfortran/generated/matmul_r8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmatmul_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include \"libgfortran.h\"\n \n+#if defined (HAVE_GFC_REAL_8)\n+\n /* This is a C version of the following fortran pseudo-code. The key\n    point is the loop order -- we access all arrays column-first, which\n    improves the performance enough to boost galgel spec score by 50%.\n@@ -215,3 +217,5 @@ matmul_r8 (gfc_array_r8 * retarray, gfc_array_r8 * a, gfc_array_r8 * b)\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n }\n+\n+#endif"}, {"sha": "ca934a14d7007f08a846a75da8fcffa2df6106bd", "filename": "libgfortran/generated/maxloc0_16_i16.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,292 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc0_16_i16 (gfc_array_i16 * retarray, gfc_array_i16 *array);\n+export_proto(maxloc0_16_i16);\n+\n+void\n+maxloc0_16_i16 (gfc_array_i16 * retarray, gfc_array_i16 *array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_INTEGER_16 maxval;\n+\n+  maxval = -GFC_INTEGER_16_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_16_i16 (gfc_array_i16 *, gfc_array_i16 *, gfc_array_l4 *);\n+export_proto(mmaxloc0_16_i16);\n+\n+void\n+mmaxloc0_16_i16 (gfc_array_i16 * retarray, gfc_array_i16 *array,\n+\t\t\t\t  gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+  GFC_INTEGER_16 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_INTEGER_16 maxval;\n+\n+  maxval = -GFC_INTEGER_16_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && *base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+#endif"}, {"sha": "9dcd7b48a50cda3bb58a9797fab42cfd2a84e20e", "filename": "libgfortran/generated/maxloc0_16_i4.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,292 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc0_16_i4 (gfc_array_i16 * retarray, gfc_array_i4 *array);\n+export_proto(maxloc0_16_i4);\n+\n+void\n+maxloc0_16_i4 (gfc_array_i16 * retarray, gfc_array_i4 *array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_4 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_INTEGER_4 maxval;\n+\n+  maxval = -GFC_INTEGER_4_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_16_i4 (gfc_array_i16 *, gfc_array_i4 *, gfc_array_l4 *);\n+export_proto(mmaxloc0_16_i4);\n+\n+void\n+mmaxloc0_16_i4 (gfc_array_i16 * retarray, gfc_array_i4 *array,\n+\t\t\t\t  gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+  GFC_INTEGER_4 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_INTEGER_4 maxval;\n+\n+  maxval = -GFC_INTEGER_4_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && *base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+#endif"}, {"sha": "d8a6261ea4457c626aae10c638d80b41fdcea838", "filename": "libgfortran/generated/maxloc0_16_i8.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,292 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc0_16_i8 (gfc_array_i16 * retarray, gfc_array_i8 *array);\n+export_proto(maxloc0_16_i8);\n+\n+void\n+maxloc0_16_i8 (gfc_array_i16 * retarray, gfc_array_i8 *array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_8 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_INTEGER_8 maxval;\n+\n+  maxval = -GFC_INTEGER_8_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_16_i8 (gfc_array_i16 *, gfc_array_i8 *, gfc_array_l4 *);\n+export_proto(mmaxloc0_16_i8);\n+\n+void\n+mmaxloc0_16_i8 (gfc_array_i16 * retarray, gfc_array_i8 *array,\n+\t\t\t\t  gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+  GFC_INTEGER_8 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_INTEGER_8 maxval;\n+\n+  maxval = -GFC_INTEGER_8_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && *base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+#endif"}, {"sha": "1f0dfb0383e9bbf7ae67f623008a78c0cb261b3b", "filename": "libgfortran/generated/maxloc0_16_r10.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,292 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc0_16_r10 (gfc_array_i16 * retarray, gfc_array_r10 *array);\n+export_proto(maxloc0_16_r10);\n+\n+void\n+maxloc0_16_r10 (gfc_array_i16 * retarray, gfc_array_r10 *array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_REAL_10 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_REAL_10 maxval;\n+\n+  maxval = -GFC_REAL_10_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_16_r10 (gfc_array_i16 *, gfc_array_r10 *, gfc_array_l4 *);\n+export_proto(mmaxloc0_16_r10);\n+\n+void\n+mmaxloc0_16_r10 (gfc_array_i16 * retarray, gfc_array_r10 *array,\n+\t\t\t\t  gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+  GFC_REAL_10 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_REAL_10 maxval;\n+\n+  maxval = -GFC_REAL_10_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && *base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+#endif"}, {"sha": "d9e3780470cb8134f4306909608cc5662306f598", "filename": "libgfortran/generated/maxloc0_16_r16.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,292 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc0_16_r16 (gfc_array_i16 * retarray, gfc_array_r16 *array);\n+export_proto(maxloc0_16_r16);\n+\n+void\n+maxloc0_16_r16 (gfc_array_i16 * retarray, gfc_array_r16 *array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_REAL_16 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_REAL_16 maxval;\n+\n+  maxval = -GFC_REAL_16_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_16_r16 (gfc_array_i16 *, gfc_array_r16 *, gfc_array_l4 *);\n+export_proto(mmaxloc0_16_r16);\n+\n+void\n+mmaxloc0_16_r16 (gfc_array_i16 * retarray, gfc_array_r16 *array,\n+\t\t\t\t  gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+  GFC_REAL_16 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_REAL_16 maxval;\n+\n+  maxval = -GFC_REAL_16_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && *base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+#endif"}, {"sha": "6e0e92aa372cebbe7a4f6b2a505df7e083dc0992", "filename": "libgfortran/generated/maxloc0_16_r4.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,292 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc0_16_r4 (gfc_array_i16 * retarray, gfc_array_r4 *array);\n+export_proto(maxloc0_16_r4);\n+\n+void\n+maxloc0_16_r4 (gfc_array_i16 * retarray, gfc_array_r4 *array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_REAL_4 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_REAL_4 maxval;\n+\n+  maxval = -GFC_REAL_4_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_16_r4 (gfc_array_i16 *, gfc_array_r4 *, gfc_array_l4 *);\n+export_proto(mmaxloc0_16_r4);\n+\n+void\n+mmaxloc0_16_r4 (gfc_array_i16 * retarray, gfc_array_r4 *array,\n+\t\t\t\t  gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+  GFC_REAL_4 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_REAL_4 maxval;\n+\n+  maxval = -GFC_REAL_4_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && *base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+#endif"}, {"sha": "878e21e1e16f0718d6081afec2bfef5ae35f1fcc", "filename": "libgfortran/generated/maxloc0_16_r8.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,292 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc0_16_r8 (gfc_array_i16 * retarray, gfc_array_r8 *array);\n+export_proto(maxloc0_16_r8);\n+\n+void\n+maxloc0_16_r8 (gfc_array_i16 * retarray, gfc_array_r8 *array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_REAL_8 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_REAL_8 maxval;\n+\n+  maxval = -GFC_REAL_8_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_16_r8 (gfc_array_i16 *, gfc_array_r8 *, gfc_array_l4 *);\n+export_proto(mmaxloc0_16_r8);\n+\n+void\n+mmaxloc0_16_r8 (gfc_array_i16 * retarray, gfc_array_r8 *array,\n+\t\t\t\t  gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+  GFC_REAL_8 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_REAL_8 maxval;\n+\n+  maxval = -GFC_REAL_8_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && *base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+#endif"}, {"sha": "e41953010aa5b18fc00b95f3541df2516878b5a0", "filename": "libgfortran/generated/maxloc0_4_i16.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,292 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void maxloc0_4_i16 (gfc_array_i4 * retarray, gfc_array_i16 *array);\n+export_proto(maxloc0_4_i16);\n+\n+void\n+maxloc0_4_i16 (gfc_array_i4 * retarray, gfc_array_i16 *array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *base;\n+  GFC_INTEGER_4 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_INTEGER_16 maxval;\n+\n+  maxval = -GFC_INTEGER_16_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_4_i16 (gfc_array_i4 *, gfc_array_i16 *, gfc_array_l4 *);\n+export_proto(mmaxloc0_4_i16);\n+\n+void\n+mmaxloc0_4_i16 (gfc_array_i4 * retarray, gfc_array_i16 *array,\n+\t\t\t\t  gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+  GFC_INTEGER_16 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_INTEGER_16 maxval;\n+\n+  maxval = -GFC_INTEGER_16_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && *base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+#endif"}, {"sha": "d88212411cf18ac6b75b7fb52cdaa2a7cc96b5d6", "filename": "libgfortran/generated/maxloc0_4_i4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -36,6 +36,8 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+\n \n extern void maxloc0_4_i4 (gfc_array_i4 * retarray, gfc_array_i4 *array);\n export_proto(maxloc0_4_i4);\n@@ -286,3 +288,5 @@ mmaxloc0_4_i4 (gfc_array_i4 * retarray, gfc_array_i4 *array,\n     }\n   }\n }\n+\n+#endif"}, {"sha": "e709d8308f131e4fa3accd041792a0ea1b28d1e2", "filename": "libgfortran/generated/maxloc0_4_i8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -36,6 +36,8 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_4)\n+\n \n extern void maxloc0_4_i8 (gfc_array_i4 * retarray, gfc_array_i8 *array);\n export_proto(maxloc0_4_i8);\n@@ -286,3 +288,5 @@ mmaxloc0_4_i8 (gfc_array_i4 * retarray, gfc_array_i8 *array,\n     }\n   }\n }\n+\n+#endif"}, {"sha": "63b4ab3b3456ccf64476eac7ac1f511108fa969f", "filename": "libgfortran/generated/maxloc0_4_r10.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,292 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void maxloc0_4_r10 (gfc_array_i4 * retarray, gfc_array_r10 *array);\n+export_proto(maxloc0_4_r10);\n+\n+void\n+maxloc0_4_r10 (gfc_array_i4 * retarray, gfc_array_r10 *array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_REAL_10 *base;\n+  GFC_INTEGER_4 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_REAL_10 maxval;\n+\n+  maxval = -GFC_REAL_10_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_4_r10 (gfc_array_i4 *, gfc_array_r10 *, gfc_array_l4 *);\n+export_proto(mmaxloc0_4_r10);\n+\n+void\n+mmaxloc0_4_r10 (gfc_array_i4 * retarray, gfc_array_r10 *array,\n+\t\t\t\t  gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+  GFC_REAL_10 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_REAL_10 maxval;\n+\n+  maxval = -GFC_REAL_10_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && *base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+#endif"}, {"sha": "41cecafe38a4f9d9452c8c050dbcf138ca86b666", "filename": "libgfortran/generated/maxloc0_4_r16.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,292 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void maxloc0_4_r16 (gfc_array_i4 * retarray, gfc_array_r16 *array);\n+export_proto(maxloc0_4_r16);\n+\n+void\n+maxloc0_4_r16 (gfc_array_i4 * retarray, gfc_array_r16 *array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_REAL_16 *base;\n+  GFC_INTEGER_4 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_REAL_16 maxval;\n+\n+  maxval = -GFC_REAL_16_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_4_r16 (gfc_array_i4 *, gfc_array_r16 *, gfc_array_l4 *);\n+export_proto(mmaxloc0_4_r16);\n+\n+void\n+mmaxloc0_4_r16 (gfc_array_i4 * retarray, gfc_array_r16 *array,\n+\t\t\t\t  gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+  GFC_REAL_16 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_REAL_16 maxval;\n+\n+  maxval = -GFC_REAL_16_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && *base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+#endif"}, {"sha": "3eba4f2cc24dc0a2a4e68a5bf57b874b00f68b29", "filename": "libgfortran/generated/maxloc0_4_r4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -36,6 +36,8 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_4)\n+\n \n extern void maxloc0_4_r4 (gfc_array_i4 * retarray, gfc_array_r4 *array);\n export_proto(maxloc0_4_r4);\n@@ -286,3 +288,5 @@ mmaxloc0_4_r4 (gfc_array_i4 * retarray, gfc_array_r4 *array,\n     }\n   }\n }\n+\n+#endif"}, {"sha": "3a5f3f2d38a894bee608bf76327aa20fa3c25718", "filename": "libgfortran/generated/maxloc0_4_r8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -36,6 +36,8 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_4)\n+\n \n extern void maxloc0_4_r8 (gfc_array_i4 * retarray, gfc_array_r8 *array);\n export_proto(maxloc0_4_r8);\n@@ -286,3 +288,5 @@ mmaxloc0_4_r8 (gfc_array_i4 * retarray, gfc_array_r8 *array,\n     }\n   }\n }\n+\n+#endif"}, {"sha": "52316ed08502ca30a71dd8309102fad84f33ad88", "filename": "libgfortran/generated/maxloc0_8_i16.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,292 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void maxloc0_8_i16 (gfc_array_i8 * retarray, gfc_array_i16 *array);\n+export_proto(maxloc0_8_i16);\n+\n+void\n+maxloc0_8_i16 (gfc_array_i8 * retarray, gfc_array_i16 *array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *base;\n+  GFC_INTEGER_8 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_INTEGER_16 maxval;\n+\n+  maxval = -GFC_INTEGER_16_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_8_i16 (gfc_array_i8 *, gfc_array_i16 *, gfc_array_l4 *);\n+export_proto(mmaxloc0_8_i16);\n+\n+void\n+mmaxloc0_8_i16 (gfc_array_i8 * retarray, gfc_array_i16 *array,\n+\t\t\t\t  gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+  GFC_INTEGER_16 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_INTEGER_16 maxval;\n+\n+  maxval = -GFC_INTEGER_16_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && *base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+#endif"}, {"sha": "aa37b6d1f38bfc14a54c25cc3f9017b13030635e", "filename": "libgfortran/generated/maxloc0_8_i4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -36,6 +36,8 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n+\n \n extern void maxloc0_8_i4 (gfc_array_i8 * retarray, gfc_array_i4 *array);\n export_proto(maxloc0_8_i4);\n@@ -286,3 +288,5 @@ mmaxloc0_8_i4 (gfc_array_i8 * retarray, gfc_array_i4 *array,\n     }\n   }\n }\n+\n+#endif"}, {"sha": "8c825c4a45aaaff06048c8f0f99890859c54490a", "filename": "libgfortran/generated/maxloc0_8_i8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -36,6 +36,8 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_8)\n+\n \n extern void maxloc0_8_i8 (gfc_array_i8 * retarray, gfc_array_i8 *array);\n export_proto(maxloc0_8_i8);\n@@ -286,3 +288,5 @@ mmaxloc0_8_i8 (gfc_array_i8 * retarray, gfc_array_i8 *array,\n     }\n   }\n }\n+\n+#endif"}, {"sha": "6add1779ef1868c4ce042df68d20c07431d542ee", "filename": "libgfortran/generated/maxloc0_8_r10.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,292 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void maxloc0_8_r10 (gfc_array_i8 * retarray, gfc_array_r10 *array);\n+export_proto(maxloc0_8_r10);\n+\n+void\n+maxloc0_8_r10 (gfc_array_i8 * retarray, gfc_array_r10 *array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_REAL_10 *base;\n+  GFC_INTEGER_8 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_REAL_10 maxval;\n+\n+  maxval = -GFC_REAL_10_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_8_r10 (gfc_array_i8 *, gfc_array_r10 *, gfc_array_l4 *);\n+export_proto(mmaxloc0_8_r10);\n+\n+void\n+mmaxloc0_8_r10 (gfc_array_i8 * retarray, gfc_array_r10 *array,\n+\t\t\t\t  gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+  GFC_REAL_10 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_REAL_10 maxval;\n+\n+  maxval = -GFC_REAL_10_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && *base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+#endif"}, {"sha": "92f0884f7a5fe727dc3ce058efb85c702f9620dd", "filename": "libgfortran/generated/maxloc0_8_r16.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,292 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void maxloc0_8_r16 (gfc_array_i8 * retarray, gfc_array_r16 *array);\n+export_proto(maxloc0_8_r16);\n+\n+void\n+maxloc0_8_r16 (gfc_array_i8 * retarray, gfc_array_r16 *array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_REAL_16 *base;\n+  GFC_INTEGER_8 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_REAL_16 maxval;\n+\n+  maxval = -GFC_REAL_16_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_8_r16 (gfc_array_i8 *, gfc_array_r16 *, gfc_array_l4 *);\n+export_proto(mmaxloc0_8_r16);\n+\n+void\n+mmaxloc0_8_r16 (gfc_array_i8 * retarray, gfc_array_r16 *array,\n+\t\t\t\t  gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+  GFC_REAL_16 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  GFC_REAL_16 maxval;\n+\n+  maxval = -GFC_REAL_16_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && *base > maxval)\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+#endif"}, {"sha": "07cebb377027415714c449b82f4c4c4d28654e25", "filename": "libgfortran/generated/maxloc0_8_r4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -36,6 +36,8 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_8)\n+\n \n extern void maxloc0_8_r4 (gfc_array_i8 * retarray, gfc_array_r4 *array);\n export_proto(maxloc0_8_r4);\n@@ -286,3 +288,5 @@ mmaxloc0_8_r4 (gfc_array_i8 * retarray, gfc_array_r4 *array,\n     }\n   }\n }\n+\n+#endif"}, {"sha": "92f2805a5b2431d1f5d310a9802cfecf28f8fedf", "filename": "libgfortran/generated/maxloc0_8_r8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -36,6 +36,8 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_8)\n+\n \n extern void maxloc0_8_r8 (gfc_array_i8 * retarray, gfc_array_r8 *array);\n export_proto(maxloc0_8_r8);\n@@ -286,3 +288,5 @@ mmaxloc0_8_r8 (gfc_array_i8 * retarray, gfc_array_r8 *array,\n     }\n   }\n }\n+\n+#endif"}, {"sha": "d9666bdbe1b6ea89a08663097001a807e3524707", "filename": "libgfortran/generated/maxloc1_16_i16.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,347 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc1_16_i16 (gfc_array_i16 *, gfc_array_i16 *, index_type *);\n+export_proto(maxloc1_16_i16);\n+\n+void\n+maxloc1_16_i16 (gfc_array_i16 *retarray, gfc_array_i16 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_INTEGER_16 *src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  GFC_INTEGER_16 maxval;\n+  maxval = -GFC_INTEGER_16_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_16_i16 (gfc_array_i16 *, gfc_array_i16 *, index_type *,\n+\t\t\t\t\t       gfc_array_l4 *);\n+export_proto(mmaxloc1_16_i16);\n+\n+void\n+mmaxloc1_16_i16 (gfc_array_i16 * retarray, gfc_array_i16 * array,\n+\t\t\t\t  index_type *pdim, gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 *dest;\n+  GFC_INTEGER_16 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      GFC_INTEGER_16 *src;\n+      GFC_LOGICAL_4 *msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_INTEGER_16 maxval;\n+  maxval = -GFC_INTEGER_16_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "9df85ec107a67b44051d2c1a981391b8c772cfcd", "filename": "libgfortran/generated/maxloc1_16_i4.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,347 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc1_16_i4 (gfc_array_i16 *, gfc_array_i4 *, index_type *);\n+export_proto(maxloc1_16_i4);\n+\n+void\n+maxloc1_16_i4 (gfc_array_i16 *retarray, gfc_array_i4 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_INTEGER_4 *src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  GFC_INTEGER_4 maxval;\n+  maxval = -GFC_INTEGER_4_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_16_i4 (gfc_array_i16 *, gfc_array_i4 *, index_type *,\n+\t\t\t\t\t       gfc_array_l4 *);\n+export_proto(mmaxloc1_16_i4);\n+\n+void\n+mmaxloc1_16_i4 (gfc_array_i16 * retarray, gfc_array_i4 * array,\n+\t\t\t\t  index_type *pdim, gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 *dest;\n+  GFC_INTEGER_4 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      GFC_INTEGER_4 *src;\n+      GFC_LOGICAL_4 *msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_INTEGER_4 maxval;\n+  maxval = -GFC_INTEGER_4_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "8d6e003f38365a635983ce1c4426b922d6e5a071", "filename": "libgfortran/generated/maxloc1_16_i8.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,347 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc1_16_i8 (gfc_array_i16 *, gfc_array_i8 *, index_type *);\n+export_proto(maxloc1_16_i8);\n+\n+void\n+maxloc1_16_i8 (gfc_array_i16 *retarray, gfc_array_i8 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_INTEGER_8 *src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  GFC_INTEGER_8 maxval;\n+  maxval = -GFC_INTEGER_8_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_16_i8 (gfc_array_i16 *, gfc_array_i8 *, index_type *,\n+\t\t\t\t\t       gfc_array_l4 *);\n+export_proto(mmaxloc1_16_i8);\n+\n+void\n+mmaxloc1_16_i8 (gfc_array_i16 * retarray, gfc_array_i8 * array,\n+\t\t\t\t  index_type *pdim, gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 *dest;\n+  GFC_INTEGER_8 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      GFC_INTEGER_8 *src;\n+      GFC_LOGICAL_4 *msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_INTEGER_8 maxval;\n+  maxval = -GFC_INTEGER_8_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "64b277005acab24f92f7b45d1435624068384f50", "filename": "libgfortran/generated/maxloc1_16_r10.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,347 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc1_16_r10 (gfc_array_i16 *, gfc_array_r10 *, index_type *);\n+export_proto(maxloc1_16_r10);\n+\n+void\n+maxloc1_16_r10 (gfc_array_i16 *retarray, gfc_array_r10 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_10 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_REAL_10 *src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  GFC_REAL_10 maxval;\n+  maxval = -GFC_REAL_10_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_16_r10 (gfc_array_i16 *, gfc_array_r10 *, index_type *,\n+\t\t\t\t\t       gfc_array_l4 *);\n+export_proto(mmaxloc1_16_r10);\n+\n+void\n+mmaxloc1_16_r10 (gfc_array_i16 * retarray, gfc_array_r10 * array,\n+\t\t\t\t  index_type *pdim, gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 *dest;\n+  GFC_REAL_10 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      GFC_REAL_10 *src;\n+      GFC_LOGICAL_4 *msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_REAL_10 maxval;\n+  maxval = -GFC_REAL_10_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "f6718083f5cf3923d30093a77110382eca494e81", "filename": "libgfortran/generated/maxloc1_16_r16.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,347 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc1_16_r16 (gfc_array_i16 *, gfc_array_r16 *, index_type *);\n+export_proto(maxloc1_16_r16);\n+\n+void\n+maxloc1_16_r16 (gfc_array_i16 *retarray, gfc_array_r16 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_16 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_REAL_16 *src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  GFC_REAL_16 maxval;\n+  maxval = -GFC_REAL_16_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_16_r16 (gfc_array_i16 *, gfc_array_r16 *, index_type *,\n+\t\t\t\t\t       gfc_array_l4 *);\n+export_proto(mmaxloc1_16_r16);\n+\n+void\n+mmaxloc1_16_r16 (gfc_array_i16 * retarray, gfc_array_r16 * array,\n+\t\t\t\t  index_type *pdim, gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 *dest;\n+  GFC_REAL_16 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      GFC_REAL_16 *src;\n+      GFC_LOGICAL_4 *msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_REAL_16 maxval;\n+  maxval = -GFC_REAL_16_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "902e97c994e928c3c70a1d87f53a7e9fbbc9d82e", "filename": "libgfortran/generated/maxloc1_16_r4.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,347 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc1_16_r4 (gfc_array_i16 *, gfc_array_r4 *, index_type *);\n+export_proto(maxloc1_16_r4);\n+\n+void\n+maxloc1_16_r4 (gfc_array_i16 *retarray, gfc_array_r4 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_4 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_REAL_4 *src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  GFC_REAL_4 maxval;\n+  maxval = -GFC_REAL_4_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_16_r4 (gfc_array_i16 *, gfc_array_r4 *, index_type *,\n+\t\t\t\t\t       gfc_array_l4 *);\n+export_proto(mmaxloc1_16_r4);\n+\n+void\n+mmaxloc1_16_r4 (gfc_array_i16 * retarray, gfc_array_r4 * array,\n+\t\t\t\t  index_type *pdim, gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 *dest;\n+  GFC_REAL_4 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      GFC_REAL_4 *src;\n+      GFC_LOGICAL_4 *msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_REAL_4 maxval;\n+  maxval = -GFC_REAL_4_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "3e28d6706e28b0dfc780b0dfa6e461177bc5186e", "filename": "libgfortran/generated/maxloc1_16_r8.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,347 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc1_16_r8 (gfc_array_i16 *, gfc_array_r8 *, index_type *);\n+export_proto(maxloc1_16_r8);\n+\n+void\n+maxloc1_16_r8 (gfc_array_i16 *retarray, gfc_array_r8 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_8 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_REAL_8 *src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  GFC_REAL_8 maxval;\n+  maxval = -GFC_REAL_8_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_16_r8 (gfc_array_i16 *, gfc_array_r8 *, index_type *,\n+\t\t\t\t\t       gfc_array_l4 *);\n+export_proto(mmaxloc1_16_r8);\n+\n+void\n+mmaxloc1_16_r8 (gfc_array_i16 * retarray, gfc_array_r8 * array,\n+\t\t\t\t  index_type *pdim, gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 *dest;\n+  GFC_REAL_8 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      GFC_REAL_8 *src;\n+      GFC_LOGICAL_4 *msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_REAL_8 maxval;\n+  maxval = -GFC_REAL_8_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "8ca2cf1195be633e301e962ec01cf4c32a5e8913", "filename": "libgfortran/generated/maxloc1_4_i16.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,347 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void maxloc1_4_i16 (gfc_array_i4 *, gfc_array_i16 *, index_type *);\n+export_proto(maxloc1_4_i16);\n+\n+void\n+maxloc1_4_i16 (gfc_array_i4 *retarray, gfc_array_i16 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 *base;\n+  GFC_INTEGER_4 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_INTEGER_16 *src;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      {\n+\n+  GFC_INTEGER_16 maxval;\n+  maxval = -GFC_INTEGER_16_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_4)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_4_i16 (gfc_array_i4 *, gfc_array_i16 *, index_type *,\n+\t\t\t\t\t       gfc_array_l4 *);\n+export_proto(mmaxloc1_4_i16);\n+\n+void\n+mmaxloc1_4_i16 (gfc_array_i4 * retarray, gfc_array_i16 * array,\n+\t\t\t\t  index_type *pdim, gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 *dest;\n+  GFC_INTEGER_16 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      GFC_INTEGER_16 *src;\n+      GFC_LOGICAL_4 *msrc;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_INTEGER_16 maxval;\n+  maxval = -GFC_INTEGER_16_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_4)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "06a657cca4e9644ae8f55a74f5e9c37e9c760339", "filename": "libgfortran/generated/maxloc1_4_i4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -36,6 +36,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n extern void maxloc1_4_i4 (gfc_array_i4 *, gfc_array_i4 *, index_type *);\n export_proto(maxloc1_4_i4);\n \n@@ -341,3 +344,4 @@ mmaxloc1_4_i4 (gfc_array_i4 * retarray, gfc_array_i4 * array,\n     }\n }\n \n+#endif"}, {"sha": "f03b36ca6a671148f09ee122a63c887fdb576bd3", "filename": "libgfortran/generated/maxloc1_4_i8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -36,6 +36,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n extern void maxloc1_4_i8 (gfc_array_i4 *, gfc_array_i8 *, index_type *);\n export_proto(maxloc1_4_i8);\n \n@@ -341,3 +344,4 @@ mmaxloc1_4_i8 (gfc_array_i4 * retarray, gfc_array_i8 * array,\n     }\n }\n \n+#endif"}, {"sha": "854b0b8042e5ced5cbf3c7cec890049021c27c13", "filename": "libgfortran/generated/maxloc1_4_r10.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,347 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void maxloc1_4_r10 (gfc_array_i4 *, gfc_array_r10 *, index_type *);\n+export_proto(maxloc1_4_r10);\n+\n+void\n+maxloc1_4_r10 (gfc_array_i4 *retarray, gfc_array_r10 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_10 *base;\n+  GFC_INTEGER_4 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_REAL_10 *src;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      {\n+\n+  GFC_REAL_10 maxval;\n+  maxval = -GFC_REAL_10_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_4)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_4_r10 (gfc_array_i4 *, gfc_array_r10 *, index_type *,\n+\t\t\t\t\t       gfc_array_l4 *);\n+export_proto(mmaxloc1_4_r10);\n+\n+void\n+mmaxloc1_4_r10 (gfc_array_i4 * retarray, gfc_array_r10 * array,\n+\t\t\t\t  index_type *pdim, gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 *dest;\n+  GFC_REAL_10 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      GFC_REAL_10 *src;\n+      GFC_LOGICAL_4 *msrc;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_REAL_10 maxval;\n+  maxval = -GFC_REAL_10_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_4)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "fdabd1ae4f25cda7c66e30f7321e4594b052690f", "filename": "libgfortran/generated/maxloc1_4_r16.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,347 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void maxloc1_4_r16 (gfc_array_i4 *, gfc_array_r16 *, index_type *);\n+export_proto(maxloc1_4_r16);\n+\n+void\n+maxloc1_4_r16 (gfc_array_i4 *retarray, gfc_array_r16 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_16 *base;\n+  GFC_INTEGER_4 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_REAL_16 *src;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      {\n+\n+  GFC_REAL_16 maxval;\n+  maxval = -GFC_REAL_16_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_4)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_4_r16 (gfc_array_i4 *, gfc_array_r16 *, index_type *,\n+\t\t\t\t\t       gfc_array_l4 *);\n+export_proto(mmaxloc1_4_r16);\n+\n+void\n+mmaxloc1_4_r16 (gfc_array_i4 * retarray, gfc_array_r16 * array,\n+\t\t\t\t  index_type *pdim, gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 *dest;\n+  GFC_REAL_16 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      GFC_REAL_16 *src;\n+      GFC_LOGICAL_4 *msrc;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_REAL_16 maxval;\n+  maxval = -GFC_REAL_16_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_4)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "34510e7de1a1454dde7393cbffdde35b0c109c46", "filename": "libgfortran/generated/maxloc1_4_r4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -36,6 +36,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n extern void maxloc1_4_r4 (gfc_array_i4 *, gfc_array_r4 *, index_type *);\n export_proto(maxloc1_4_r4);\n \n@@ -341,3 +344,4 @@ mmaxloc1_4_r4 (gfc_array_i4 * retarray, gfc_array_r4 * array,\n     }\n }\n \n+#endif"}, {"sha": "ea67079c6c0e3aeb6c3cfb45a925e878122ab1e7", "filename": "libgfortran/generated/maxloc1_4_r8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -36,6 +36,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n extern void maxloc1_4_r8 (gfc_array_i4 *, gfc_array_r8 *, index_type *);\n export_proto(maxloc1_4_r8);\n \n@@ -341,3 +344,4 @@ mmaxloc1_4_r8 (gfc_array_i4 * retarray, gfc_array_r8 * array,\n     }\n }\n \n+#endif"}, {"sha": "f3ba50b32c3fe5b058f84a6127f01aae976fa60c", "filename": "libgfortran/generated/maxloc1_8_i16.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,347 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void maxloc1_8_i16 (gfc_array_i8 *, gfc_array_i16 *, index_type *);\n+export_proto(maxloc1_8_i16);\n+\n+void\n+maxloc1_8_i16 (gfc_array_i8 *retarray, gfc_array_i16 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 *base;\n+  GFC_INTEGER_8 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_INTEGER_16 *src;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      {\n+\n+  GFC_INTEGER_16 maxval;\n+  maxval = -GFC_INTEGER_16_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_8)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_8_i16 (gfc_array_i8 *, gfc_array_i16 *, index_type *,\n+\t\t\t\t\t       gfc_array_l4 *);\n+export_proto(mmaxloc1_8_i16);\n+\n+void\n+mmaxloc1_8_i16 (gfc_array_i8 * retarray, gfc_array_i16 * array,\n+\t\t\t\t  index_type *pdim, gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 *dest;\n+  GFC_INTEGER_16 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      GFC_INTEGER_16 *src;\n+      GFC_LOGICAL_4 *msrc;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_INTEGER_16 maxval;\n+  maxval = -GFC_INTEGER_16_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_8)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "1c095ff7bb97c90d0c13cf07d2723c232593f5ef", "filename": "libgfortran/generated/maxloc1_8_i4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -36,6 +36,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n extern void maxloc1_8_i4 (gfc_array_i8 *, gfc_array_i4 *, index_type *);\n export_proto(maxloc1_8_i4);\n \n@@ -341,3 +344,4 @@ mmaxloc1_8_i4 (gfc_array_i8 * retarray, gfc_array_i4 * array,\n     }\n }\n \n+#endif"}, {"sha": "ee6d269f3070aa121dd7c62b6686943a0ccd61f3", "filename": "libgfortran/generated/maxloc1_8_i8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -36,6 +36,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n extern void maxloc1_8_i8 (gfc_array_i8 *, gfc_array_i8 *, index_type *);\n export_proto(maxloc1_8_i8);\n \n@@ -341,3 +344,4 @@ mmaxloc1_8_i8 (gfc_array_i8 * retarray, gfc_array_i8 * array,\n     }\n }\n \n+#endif"}, {"sha": "67c77330142a6b170439ad92f615ea2e668992e8", "filename": "libgfortran/generated/maxloc1_8_r10.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,347 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void maxloc1_8_r10 (gfc_array_i8 *, gfc_array_r10 *, index_type *);\n+export_proto(maxloc1_8_r10);\n+\n+void\n+maxloc1_8_r10 (gfc_array_i8 *retarray, gfc_array_r10 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_10 *base;\n+  GFC_INTEGER_8 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_REAL_10 *src;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      {\n+\n+  GFC_REAL_10 maxval;\n+  maxval = -GFC_REAL_10_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_8)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_8_r10 (gfc_array_i8 *, gfc_array_r10 *, index_type *,\n+\t\t\t\t\t       gfc_array_l4 *);\n+export_proto(mmaxloc1_8_r10);\n+\n+void\n+mmaxloc1_8_r10 (gfc_array_i8 * retarray, gfc_array_r10 * array,\n+\t\t\t\t  index_type *pdim, gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 *dest;\n+  GFC_REAL_10 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      GFC_REAL_10 *src;\n+      GFC_LOGICAL_4 *msrc;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_REAL_10 maxval;\n+  maxval = -GFC_REAL_10_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_8)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "d0b607f25dc32b735b17984a89effb6f7f8951c2", "filename": "libgfortran/generated/maxloc1_8_r16.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,347 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void maxloc1_8_r16 (gfc_array_i8 *, gfc_array_r16 *, index_type *);\n+export_proto(maxloc1_8_r16);\n+\n+void\n+maxloc1_8_r16 (gfc_array_i8 *retarray, gfc_array_r16 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_16 *base;\n+  GFC_INTEGER_8 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_REAL_16 *src;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      {\n+\n+  GFC_REAL_16 maxval;\n+  maxval = -GFC_REAL_16_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_8)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_8_r16 (gfc_array_i8 *, gfc_array_r16 *, index_type *,\n+\t\t\t\t\t       gfc_array_l4 *);\n+export_proto(mmaxloc1_8_r16);\n+\n+void\n+mmaxloc1_8_r16 (gfc_array_i8 * retarray, gfc_array_r16 * array,\n+\t\t\t\t  index_type *pdim, gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 *dest;\n+  GFC_REAL_16 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      GFC_REAL_16 *src;\n+      GFC_LOGICAL_4 *msrc;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_REAL_16 maxval;\n+  maxval = -GFC_REAL_16_HUGE;\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src > maxval)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_8)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "a7dd5ca1c0e65ab728e9b95c3a21b235b362982d", "filename": "libgfortran/generated/maxloc1_8_r4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -36,6 +36,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n extern void maxloc1_8_r4 (gfc_array_i8 *, gfc_array_r4 *, index_type *);\n export_proto(maxloc1_8_r4);\n \n@@ -341,3 +344,4 @@ mmaxloc1_8_r4 (gfc_array_i8 * retarray, gfc_array_r4 * array,\n     }\n }\n \n+#endif"}, {"sha": "188a4105a5c0a897fc112186fc19580de45f284d", "filename": "libgfortran/generated/maxloc1_8_r8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -36,6 +36,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n \n \n+#if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n extern void maxloc1_8_r8 (gfc_array_i8 *, gfc_array_r8 *, index_type *);\n export_proto(maxloc1_8_r8);\n \n@@ -341,3 +344,4 @@ mmaxloc1_8_r8 (gfc_array_i8 * retarray, gfc_array_r8 * array,\n     }\n }\n \n+#endif"}, {"sha": "cdcfe0207274feaa4c665c800a4585dbe59d34d3", "filename": "libgfortran/generated/maxval_i16.c", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97", "patch": "@@ -0,0 +1,336 @@\n+/* Implementation of the MAXVAL intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxval_i16 (gfc_array_i16 *, gfc_array_i16 *, index_type *);\n+export_proto(maxval_i16);\n+\n+void\n+maxval_i16 (gfc_array_i16 *retarray, gfc_array_i16 *array, index_type *pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      GFC_INTEGER_16 *src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  result = -GFC_INTEGER_16_HUGE;\n+        if (len <= 0)\n+\t  *dest = -GFC_INTEGER_16_HUGE;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > result)\n+    result = *src;\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxval_i16 (gfc_array_i16 *, gfc_array_i16 *, index_type *,\n+\t\t\t\t\t       gfc_array_l4 *);\n+export_proto(mmaxval_i16);\n+\n+void\n+mmaxval_i16 (gfc_array_i16 * retarray, gfc_array_i16 * array,\n+\t\t\t\t  index_type *pdim, gfc_array_l4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 *dest;\n+  GFC_INTEGER_16 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  /* TODO:  It should be a front end job to correctly set the strides.  */\n+\n+  if (array->dim[0].stride == 0)\n+    array->dim[0].stride = 1;\n+\n+  if (mask->dim[0].stride == 0)\n+    mask->dim[0].stride = 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      GFC_INTEGER_16 *src;\n+      GFC_LOGICAL_4 *msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = -GFC_INTEGER_16_HUGE;\n+        if (len <= 0)\n+\t  *dest = -GFC_INTEGER_16_HUGE;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src > result)\n+    result = *src;\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "5f1ba4d65b1516e5f226eef7e2ce43dd5dacdfda", "filename": "libgfortran/generated/maxval_i4.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "f1d16f3b389870efc57b28fba08e42e7ea475652", "filename": "libgfortran/generated/maxval_i8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "07c7d7d462a4b066156df3ac06f1fcd24593955e", "filename": "libgfortran/generated/maxval_r10.c", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r10.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "0f8f246fb176d75131b645d75dfffe51d3333ffd", "filename": "libgfortran/generated/maxval_r16.c", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r16.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "4d56bbf5b163f90f073ed2f31e6dcb42890f56cd", "filename": "libgfortran/generated/maxval_r4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r4.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "d84e18ccd0cfeeead8ff29263040b5b4cf7938c4", "filename": "libgfortran/generated/maxval_r8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fmaxval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r8.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "af097faad01d325be74af66428d611ac0bdb8f1f", "filename": "libgfortran/generated/minloc0_16_i16.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "156938158fe6b6864882c472a95111d20d6f59a9", "filename": "libgfortran/generated/minloc0_16_i4.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "57af8927c5b9c92c5424dd4ae552a66b53b5b438", "filename": "libgfortran/generated/minloc0_16_i8.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "58ed79d5fef92055b3ca4521dabfa8c142f4fe4e", "filename": "libgfortran/generated/minloc0_16_r10.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r10.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "90c8c311df779b086824a2e7257572eeb19f6bd3", "filename": "libgfortran/generated/minloc0_16_r16.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r16.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "6fba3ddd12b6071017a915dcbe92460ede3646de", "filename": "libgfortran/generated/minloc0_16_r4.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r4.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "37b9e178e1129a477f1ee851b49a9bfd96f1a01c", "filename": "libgfortran/generated/minloc0_16_r8.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r8.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "068bbd5137c80abd863615b86a95cf7828895d41", "filename": "libgfortran/generated/minloc0_4_i16.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "e3b15ae895b804f04992dcf492493754bf278e27", "filename": "libgfortran/generated/minloc0_4_i4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "a0214913eb19450f9bc86e3d739ae68afd8534a6", "filename": "libgfortran/generated/minloc0_4_i8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "3f5ddd95d2e117a2e11c54e5e64a56e8acbb6d02", "filename": "libgfortran/generated/minloc0_4_r10.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r10.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "82c5f6a01b26bf4ccbd88e781d2d7f52195671ad", "filename": "libgfortran/generated/minloc0_4_r16.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r16.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "f8cce29a119f2b404a7b428586d1945b01cc4eb4", "filename": "libgfortran/generated/minloc0_4_r4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r4.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "dbfa667abad6749c1d00cdd9812a5dd94bf1f0e9", "filename": "libgfortran/generated/minloc0_4_r8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r8.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "8fabf52e46e5958315a094be7247e16762960f65", "filename": "libgfortran/generated/minloc0_8_i16.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "49fe0f4b36e6e8d6307ae2ed51b8d3fc29e5db7b", "filename": "libgfortran/generated/minloc0_8_i4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "d4327f05546fa045126b93b6963bb4c571cf79be", "filename": "libgfortran/generated/minloc0_8_i8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "2cd231b387a7036ae56f6043d4a4ff9ddc569613", "filename": "libgfortran/generated/minloc0_8_r10.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r10.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "ff5925bd8eb58806ff71daf171f428973ebf9891", "filename": "libgfortran/generated/minloc0_8_r16.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r16.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "a522c75516252f847809c34f3f29cfe3cefc5540", "filename": "libgfortran/generated/minloc0_8_r4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r4.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "ba3cfe625ee36f7546526e028f854ab80902bfce", "filename": "libgfortran/generated/minloc0_8_r8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r8.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "906030c9b6dbc74f16b481f7ffa07ede8dfd5c33", "filename": "libgfortran/generated/minloc1_16_i16.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "b7fe1a0843f7f535f7989ab9f839a60839964800", "filename": "libgfortran/generated/minloc1_16_i4.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "20c17f2a9cbd8880f9601ffdb03b5e878cc7ca4a", "filename": "libgfortran/generated/minloc1_16_i8.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "48519c2697e8074bce113d37453ff03a5f37d9e8", "filename": "libgfortran/generated/minloc1_16_r10.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r10.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "41fed8a3067a4bb496bdd9a1bdc61e3b1f1455fa", "filename": "libgfortran/generated/minloc1_16_r16.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r16.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "b3a4017a9f77b8baadf90fb07d0f7f1765f74cec", "filename": "libgfortran/generated/minloc1_16_r4.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r4.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "a9a0267aa5abe5e5e216ea0a589124a7278848de", "filename": "libgfortran/generated/minloc1_16_r8.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r8.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "3446a1a585c16ed161c58d7cfcd12dfdd756cb07", "filename": "libgfortran/generated/minloc1_4_i16.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "f7207192b1c2396a714c0e9f4d32acf7d8c6e775", "filename": "libgfortran/generated/minloc1_4_i4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "b049b19d755994599f60001c96e28de2f68cbd5b", "filename": "libgfortran/generated/minloc1_4_i8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "983db754f5f637988d0007b90a4478ae8da3257e", "filename": "libgfortran/generated/minloc1_4_r10.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r10.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "68f142125c9136ece42acb9121eb0e4ef91f1409", "filename": "libgfortran/generated/minloc1_4_r16.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r16.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "e7191fd4de48564370ac7be102b9eb17a5ae1662", "filename": "libgfortran/generated/minloc1_4_r4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r4.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "9d4c981cdc78ba5e3f05595116312af06db49122", "filename": "libgfortran/generated/minloc1_4_r8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r8.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "13c2cb74a42aee8f259e638f8fb308646f38c562", "filename": "libgfortran/generated/minloc1_8_i16.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "f682c10936c3dbe11fccb6f3c72075a338d73068", "filename": "libgfortran/generated/minloc1_8_i4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "9a2a5231b5a29cd2982a4cca48ec2d3a5ed0cf97", "filename": "libgfortran/generated/minloc1_8_i8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "2058453584adb2aa7ccb4fcb28fccd6e2b0eb9a5", "filename": "libgfortran/generated/minloc1_8_r10.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r10.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "e417f620ba657a4fa8a46e917eabd743f00aad28", "filename": "libgfortran/generated/minloc1_8_r16.c", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r16.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "8f154dce2756d63350fcadbcac34d4e1ab8b4cca", "filename": "libgfortran/generated/minloc1_8_r4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r4.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "20a757a9217f4962f97d20ff79f1bb027d90a8e0", "filename": "libgfortran/generated/minloc1_8_r8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r8.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "34963ae9725b7fb96933d911929f7a8c0eb8b8df", "filename": "libgfortran/generated/minval_i16.c", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i16.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "826d2e902e26485b85bf56deea178455096d680f", "filename": "libgfortran/generated/minval_i4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i4.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}, {"sha": "e58a97ba90d35575758165d811498ba951125913", "filename": "libgfortran/generated/minval_i8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644cb69f803dc904c271885272e70f032ce56a97/libgfortran%2Fgenerated%2Fminval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i8.c?ref=644cb69f803dc904c271885272e70f032ce56a97"}]}