{"sha": "515a7242ff3435dc83e8a5ea31660156f7fdc33f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE1YTcyNDJmZjM0MzVkYzgzZThhNWVhMzE2NjAxNTZmN2ZkYzMzZg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-03-30T23:14:37Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-03-30T23:14:37Z"}, "message": "(allocate_dynamic_stack_space): Test STACK_BOUNDARY against BIGGEST_ALIGNMENT at run time instead of at compile time.\n\n(allocate_dynamic_stack_space): Test STACK_BOUNDARY against\nBIGGEST_ALIGNMENT at run time instead of at compile time.  Give\nMUST_ALIGN macro a value, and test this value in if statements.\n\nFrom-SVN: r9263", "tree": {"sha": "61aca7a7fec789e3dcdeec4216db91dd7c9daaf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61aca7a7fec789e3dcdeec4216db91dd7c9daaf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/515a7242ff3435dc83e8a5ea31660156f7fdc33f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/515a7242ff3435dc83e8a5ea31660156f7fdc33f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/515a7242ff3435dc83e8a5ea31660156f7fdc33f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/515a7242ff3435dc83e8a5ea31660156f7fdc33f/comments", "author": null, "committer": null, "parents": [{"sha": "4084f7897a07c80284b862e2e8c8bbc3fae1a5f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4084f7897a07c80284b862e2e8c8bbc3fae1a5f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4084f7897a07c80284b862e2e8c8bbc3fae1a5f4"}], "stats": {"total": 35, "additions": 8, "deletions": 27}, "files": [{"sha": "814633cdcad0d430ce251e876ea995d3584ee2c8", "filename": "gcc/explow.c", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515a7242ff3435dc83e8a5ea31660156f7fdc33f/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515a7242ff3435dc83e8a5ea31660156f7fdc33f/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=515a7242ff3435dc83e8a5ea31660156f7fdc33f", "patch": "@@ -949,24 +949,13 @@ allocate_dynamic_stack_space (size, target, known_align)\n      If we have to align, we must leave space in SIZE for the hole\n      that might result from the alignment operation.  */\n \n-#if defined (STACK_DYNAMIC_OFFSET) || defined(STACK_POINTER_OFFSET) || defined (ALLOCATE_OUTGOING_ARGS)\n-#define MUST_ALIGN\n-#endif\n-\n-#if ! defined (MUST_ALIGN) && (!defined(STACK_BOUNDARY) || STACK_BOUNDARY < BIGGEST_ALIGNMENT)\n-#define MUST_ALIGN\n+#if defined (STACK_DYNAMIC_OFFSET) || defined (STACK_POINTER_OFFSET) || defined (ALLOCATE_OUTGOING_ARGS) || ! defined (STACK_BOUNDARY)\n+#define MUST_ALIGN 1\n+#else\n+#define MUST_ALIGN (STACK_BOUNDARY < BIGGEST_ALIGNMENT)\n #endif\n \n-#ifdef MUST_ALIGN\n-\n-#if 0 /* It turns out we must always make extra space, if MUST_ALIGN\n-\t because we must always round the address up at the end,\n-\t because we don't know whether the dynamic offset\n-\t will mess up the desired alignment.  */\n-  /* If we have to round the address up regardless of known_align,\n-     make extra space regardless, also.  */\n-  if (known_align % BIGGEST_ALIGNMENT != 0)\n-#endif\n+  if (MUST_ALIGN)\n     {\n       if (GET_CODE (size) == CONST_INT)\n \tsize = GEN_INT (INTVAL (size)\n@@ -977,8 +966,6 @@ allocate_dynamic_stack_space (size, target, known_align)\n \t\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);\n     }\n \n-#endif\n-\n #ifdef SETJMP_VIA_SAVE_AREA\n   /* If setjmp restores regs from a save area in the stack frame,\n      avoid clobbering the reg save area.  Note that the offset of\n@@ -1011,8 +998,8 @@ allocate_dynamic_stack_space (size, target, known_align)\n #ifdef STACK_BOUNDARY\n   /* If we added a variable amount to SIZE,\n      we can no longer assume it is aligned.  */\n-#if !defined (SETJMP_VIA_SAVE_AREA) && !defined (MUST_ALIGN)\n-  if (known_align % STACK_BOUNDARY != 0)\n+#if !defined (SETJMP_VIA_SAVE_AREA)\n+  if (! MUST_ALIGN && known_align % STACK_BOUNDARY != 0)\n #endif\n     size = round_push (size);\n #endif\n@@ -1054,12 +1041,7 @@ allocate_dynamic_stack_space (size, target, known_align)\n   emit_move_insn (target, virtual_stack_dynamic_rtx);\n #endif\n \n-#ifdef MUST_ALIGN\n-#if 0  /* Even if we know the stack pointer has enough alignment,\n-\t  there's no way to tell whether virtual_stack_dynamic_rtx shares that\n-\t  alignment, so we still need to round the address up.  */\n-  if (known_align % BIGGEST_ALIGNMENT != 0)\n-#endif\n+  if (MUST_ALIGN)\n     {\n       /* CEIL_DIV_EXPR needs to worry about the addition overflowing,\n \t but we know it can't.  So add ourselves and then do TRUNC_DIV_EXPR. */\n@@ -1073,7 +1055,6 @@ allocate_dynamic_stack_space (size, target, known_align)\n \t\t\t    GEN_INT (BIGGEST_ALIGNMENT / BITS_PER_UNIT),\n \t\t\t    NULL_RTX, 1);\n     }\n-#endif\n   \n   /* Some systems require a particular insn to refer to the stack\n      to make the pages exist.  */"}]}