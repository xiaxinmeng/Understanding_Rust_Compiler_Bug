{"sha": "8122fbff770bcff183a9c3c72e8092c0ca32150b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODEyMmZiZmY3NzBiY2ZmMTgzYTljM2M3MmU4MDkyYzBjYTMyMTUwYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-10T18:41:33Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-10T18:41:33Z"}, "message": "openmp: Implement OpenMP 5.1 atomics, so far for C only\n\nThis patch implements OpenMP 5.1 atomics (with clarifications from upcoming 5.2).\nThe most important changes are that it is now possible to write (for C/C++,\nfor Fortran it was possible before already) min/max atomics and more importantly\ncompare and exchange in various forms.\nAlso, acq_rel is now allowed on read/write and acq_rel/acquire are allowed on\nupdate, and there are new compare, weak and fail clauses.\n\n2021-09-10  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* tree-core.h (enum omp_memory_order): Add OMP_MEMORY_ORDER_MASK,\n\tOMP_FAIL_MEMORY_ORDER_UNSPECIFIED, OMP_FAIL_MEMORY_ORDER_RELAXED,\n\tOMP_FAIL_MEMORY_ORDER_ACQUIRE, OMP_FAIL_MEMORY_ORDER_RELEASE,\n\tOMP_FAIL_MEMORY_ORDER_ACQ_REL, OMP_FAIL_MEMORY_ORDER_SEQ_CST and\n\tOMP_FAIL_MEMORY_ORDER_MASK enumerators.\n\t(OMP_FAIL_MEMORY_ORDER_SHIFT): Define.\n\t* gimple-pretty-print.c (dump_gimple_omp_atomic_load,\n\tdump_gimple_omp_atomic_store): Print [weak] for weak atomic\n\tload/store.\n\t* gimple.h (enum gf_mask): Change GF_OMP_ATOMIC_MEMORY_ORDER\n\tto 6-bit mask, adjust GF_OMP_ATOMIC_NEED_VALUE value and add\n\tGF_OMP_ATOMIC_WEAK.\n\t(gimple_omp_atomic_weak_p, gimple_omp_atomic_set_weak): New inline\n\tfunctions.\n\t* tree.h (OMP_ATOMIC_WEAK): Define.\n\t* tree-pretty-print.c (dump_omp_atomic_memory_order): Adjust for\n\tfail memory order being encoded in the same enum and also print\n\tfail clause if present.\n\t(dump_generic_node): Print weak clause if OMP_ATOMIC_WEAK.\n\t* gimplify.c (goa_stabilize_expr): Add target_expr and rhs arguments,\n\thandle pre_p == NULL case as a test mode that only returns value\n\tbut doesn't change gimplify nor change anything otherwise, adjust\n\trecursive calls, add MODIFY_EXPR, ADDR_EXPR, COND_EXPR, TARGET_EXPR\n\tand CALL_EXPR handling, adjust COMPOUND_EXPR handling for\n\t__builtin_clear_padding calls, for !rhs gimplify as lvalue rather\n\tthan rvalue.\n\t(gimplify_omp_atomic): Adjust goa_stabilize_expr caller.  Handle\n\tCOND_EXPR rhs.  Set weak flag on gimple load/store for\n\tOMP_ATOMIC_WEAK.\n\t* omp-expand.c (omp_memory_order_to_fail_memmodel): New function.\n\t(omp_memory_order_to_memmodel): Adjust for fail clause encoded\n\tin the same enum.\n\t(expand_omp_atomic_cas): New function.\n\t(expand_omp_atomic_pipeline): Use omp_memory_order_to_fail_memmodel\n\tfunction.\n\t(expand_omp_atomic): Attempt to optimize atomic compare and exchange\n\tusing expand_omp_atomic_cas.\ngcc/c-family/\n\t* c-common.h (c_finish_omp_atomic): Add r and weak arguments.\n\t* c-omp.c: Include gimple-fold.h.\n\t(c_finish_omp_atomic): Add r and weak arguments.  Add support for\n\tOpenMP 5.1 atomics.\ngcc/c/\n\t* c-parser.c (c_parser_conditional_expression): If omp_atomic_lhs and\n\tcond.value is >, < or == with omp_atomic_lhs as one of the operands,\n\tdon't call build_conditional_expr, instead build a COND_EXPR directly.\n\t(c_parser_binary_expression): Avoid calling parser_build_binary_op\n\tif omp_atomic_lhs even in more cases for >, < or ==.\n\t(c_parser_omp_atomic): Update function comment for OpenMP 5.1 atomics,\n\tparse OpenMP 5.1 atomics and fail, compare and weak clauses, allow\n\tacq_rel on atomic read/write and acq_rel/acquire clauses on update.\n\t* c-typeck.c (build_binary_op): For flag_openmp only handle\n\tMIN_EXPR/MAX_EXPR.\ngcc/cp/\n\t* parser.c (cp_parser_omp_atomic): Allow acq_rel on atomic read/write\n\tand acq_rel/acquire clauses on update.\n\t* semantics.c (finish_omp_atomic): Adjust c_finish_omp_atomic caller.\ngcc/testsuite/\n\t* c-c++-common/gomp/atomic-17.c (foo): Add tests for atomic read,\n\twrite or update with acq_rel clause and atomic update with acquire clause.\n\t* c-c++-common/gomp/atomic-18.c (foo): Adjust expected diagnostics\n\twording, remove tests moved to atomic-17.c.\n\t* c-c++-common/gomp/atomic-21.c: Expect only 2 omp atomic release and\n\t2 omp atomic acq_rel directives instead of 4 omp atomic release.\n\t* c-c++-common/gomp/atomic-25.c: New test.\n\t* c-c++-common/gomp/atomic-26.c: New test.\n\t* c-c++-common/gomp/atomic-27.c: New test.\n\t* c-c++-common/gomp/atomic-28.c: New test.\n\t* c-c++-common/gomp/atomic-29.c: New test.\n\t* c-c++-common/gomp/atomic-30.c: New test.\n\t* c-c++-common/goacc-gomp/atomic.c: Expect 1 omp atomic release and\n\t1 omp atomic_acq_rel instead of 2 omp atomic release directives.\n\t* gcc.dg/gomp/atomic-5.c: Adjust expected error diagnostic wording.\n\t* g++.dg/gomp/atomic-18.C:Expect 4 omp atomic release and\n\t1 omp atomic_acq_rel instead of 5 omp atomic release directives.\nlibgomp/\n\t* testsuite/libgomp.c-c++-common/atomic-19.c: New test.\n\t* testsuite/libgomp.c-c++-common/atomic-20.c: New test.\n\t* testsuite/libgomp.c-c++-common/atomic-21.c: New test.", "tree": {"sha": "ce01fc417dc7920da04a312ab2abcd350adec6c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce01fc417dc7920da04a312ab2abcd350adec6c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8122fbff770bcff183a9c3c72e8092c0ca32150b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8122fbff770bcff183a9c3c72e8092c0ca32150b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8122fbff770bcff183a9c3c72e8092c0ca32150b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8122fbff770bcff183a9c3c72e8092c0ca32150b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7f84702b364d49824ca97d4a2fc01567301d784", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7f84702b364d49824ca97d4a2fc01567301d784", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7f84702b364d49824ca97d4a2fc01567301d784"}], "stats": {"total": 2218, "additions": 2091, "deletions": 127}, "files": [{"sha": "849cefab8824b729b42ba611af9e79b6a6822b6f", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -1223,8 +1223,8 @@ extern tree c_finish_omp_critical (location_t, tree, tree, tree);\n extern tree c_finish_omp_ordered (location_t, tree, tree);\n extern void c_finish_omp_barrier (location_t);\n extern tree c_finish_omp_atomic (location_t, enum tree_code, enum tree_code,\n-\t\t\t\t tree, tree, tree, tree, tree, bool,\n-\t\t\t\t enum omp_memory_order, bool = false);\n+\t\t\t\t tree, tree, tree, tree, tree, tree, bool,\n+\t\t\t\t enum omp_memory_order, bool, bool = false);\n extern bool c_omp_depend_t_p (tree);\n extern void c_finish_omp_depobj (location_t, tree, enum omp_clause_depend_kind,\n \t\t\t\t tree);"}, {"sha": "75184a362384b143a82d227daa5b2c49acd4438d", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 167, "deletions": 6, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n #include \"langhooks.h\"\n #include \"bitmap.h\"\n+#include \"gimple-fold.h\"\n \n \n /* Complete a #pragma oacc wait construct.  LOC is the location of\n@@ -215,15 +216,17 @@ c_finish_omp_taskyield (location_t loc)\n tree\n c_finish_omp_atomic (location_t loc, enum tree_code code,\n \t\t     enum tree_code opcode, tree lhs, tree rhs,\n-\t\t     tree v, tree lhs1, tree rhs1, bool swapped,\n-\t\t     enum omp_memory_order memory_order, bool test)\n+\t\t     tree v, tree lhs1, tree rhs1, tree r, bool swapped,\n+\t\t     enum omp_memory_order memory_order, bool weak,\n+\t\t     bool test)\n {\n-  tree x, type, addr, pre = NULL_TREE;\n+  tree x, type, addr, pre = NULL_TREE, rtmp = NULL_TREE, vtmp = NULL_TREE;\n   HOST_WIDE_INT bitpos = 0, bitsize = 0;\n+  enum tree_code orig_opcode = opcode;\n \n   if (lhs == error_mark_node || rhs == error_mark_node\n       || v == error_mark_node || lhs1 == error_mark_node\n-      || rhs1 == error_mark_node)\n+      || rhs1 == error_mark_node || r == error_mark_node)\n     return error_mark_node;\n \n   /* ??? According to one reading of the OpenMP spec, complex type are\n@@ -243,6 +246,12 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n       error_at (loc, \"%<_Atomic%> expression in %<#pragma omp atomic%>\");\n       return error_mark_node;\n     }\n+  if (r && r != void_list_node && !INTEGRAL_TYPE_P (TREE_TYPE (r)))\n+    {\n+      error_at (loc, \"%<#pragma omp atomic compare capture%> with non-integral \"\n+\t\t     \"comparison result\");\n+      return error_mark_node;\n+    }\n \n   if (opcode == RDIV_EXPR)\n     opcode = TRUNC_DIV_EXPR;\n@@ -299,6 +308,7 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n       x = build1 (OMP_ATOMIC_READ, type, addr);\n       SET_EXPR_LOCATION (x, loc);\n       OMP_ATOMIC_MEMORY_ORDER (x) = memory_order;\n+      gcc_assert (!weak);\n       if (blhs)\n \tx = build3_loc (loc, BIT_FIELD_REF, TREE_TYPE (blhs), x,\n \t\t\tbitsize_int (bitsize), bitsize_int (bitpos));\n@@ -313,12 +323,29 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n     {\n       lhs = build3_loc (loc, BIT_FIELD_REF, TREE_TYPE (blhs), lhs,\n \t\t\tbitsize_int (bitsize), bitsize_int (bitpos));\n-      if (swapped)\n+      if (opcode == COND_EXPR)\n+\t{\n+\t  bool save = in_late_binary_op;\n+\t  in_late_binary_op = true;\n+\t  std::swap (rhs, rhs1);\n+\t  rhs1 = build_binary_op (loc, EQ_EXPR, lhs, rhs1, true);\n+\t  in_late_binary_op = save;\n+\t}\n+      else if (swapped)\n \trhs = build_binary_op (loc, opcode, rhs, lhs, true);\n       else if (opcode != NOP_EXPR)\n \trhs = build_binary_op (loc, opcode, lhs, rhs, true);\n       opcode = NOP_EXPR;\n     }\n+  else if (opcode == COND_EXPR)\n+    {\n+      bool save = in_late_binary_op;\n+      in_late_binary_op = true;\n+      std::swap (rhs, rhs1);\n+      rhs1 = build_binary_op (loc, EQ_EXPR, lhs, rhs1, true);\n+      in_late_binary_op = save;\n+      opcode = NOP_EXPR;\n+    }\n   else if (swapped)\n     {\n       rhs = build_binary_op (loc, opcode, rhs, lhs, true);\n@@ -343,13 +370,108 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n   if (blhs)\n     rhs = build3_loc (loc, BIT_INSERT_EXPR, type, new_lhs,\n \t\t      rhs, bitsize_int (bitpos));\n+  if (orig_opcode == COND_EXPR)\n+    {\n+      if (error_operand_p (rhs1))\n+\treturn error_mark_node;\n+      gcc_assert (TREE_CODE (rhs1) == EQ_EXPR);\n+      tree cmptype = TREE_TYPE (TREE_OPERAND (rhs1, 0));\n+      if (SCALAR_FLOAT_TYPE_P (cmptype))\n+\t{\n+\t  bool clear_padding = false;\n+\t  if (BITS_PER_UNIT == 8 && CHAR_BIT == 8)\n+\t    {\n+\t      HOST_WIDE_INT sz = int_size_in_bytes (cmptype), i;\n+\t      gcc_assert (sz > 0);\n+\t      unsigned char *buf = XALLOCAVEC (unsigned char, sz);\n+\t      memset (buf, ~0, sz);\n+\t      clear_type_padding_in_mask (cmptype, buf);\n+\t      for (i = 0; i < sz; i++)\n+\t\tif (buf[i] != (unsigned char) ~0)\n+\t\t  {\n+\t\t    clear_padding = true;\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\t  tree inttype = NULL_TREE;\n+\t  if (!clear_padding && tree_fits_uhwi_p (TYPE_SIZE (cmptype)))\n+\t    {\n+\t      HOST_WIDE_INT prec = tree_to_uhwi (TYPE_SIZE (cmptype));\n+\t      inttype = c_common_type_for_size (prec, 1);\n+\t      if (inttype\n+\t\t  && (!tree_int_cst_equal (TYPE_SIZE (cmptype),\n+\t\t\t\t\t   TYPE_SIZE (inttype))\n+\t\t      || TYPE_PRECISION (inttype) != prec))\n+\t\tinttype = NULL_TREE;\n+\t    }\n+\t  if (inttype)\n+\t    {\n+\t      TREE_OPERAND (rhs1, 0)\n+\t\t= build1_loc (loc, VIEW_CONVERT_EXPR, inttype,\n+\t\t\t      TREE_OPERAND (rhs1, 0));\n+\t      TREE_OPERAND (rhs1, 1)\n+\t\t= build1_loc (loc, VIEW_CONVERT_EXPR, inttype,\n+\t\t\t      TREE_OPERAND (rhs1, 1));\n+\t    }\n+\t  else\n+\t    {\n+\t      tree pcmptype = build_pointer_type (cmptype);\n+\t      tree tmp1 = create_tmp_var_raw (cmptype);\n+\t      TREE_ADDRESSABLE (tmp1) = 1;\n+\t      DECL_CONTEXT (tmp1) = current_function_decl;\n+\t      tmp1 = build4 (TARGET_EXPR, cmptype, tmp1,\n+\t\t\t     TREE_OPERAND (rhs1, 0), NULL, NULL);\n+\t      tmp1 = build1 (ADDR_EXPR, pcmptype, tmp1);\n+\t      tree tmp2 = create_tmp_var_raw (cmptype);\n+\t      TREE_ADDRESSABLE (tmp2) = 1;\n+\t      DECL_CONTEXT (tmp2) = current_function_decl;\n+\t      tmp2 = build4 (TARGET_EXPR, cmptype, tmp2,\n+\t\t\t     TREE_OPERAND (rhs1, 1), NULL, NULL);\n+\t      tmp2 = build1 (ADDR_EXPR, pcmptype, tmp2);\n+\t      tree fndecl = builtin_decl_explicit (BUILT_IN_MEMCMP);\n+\t      rhs1 = build_call_expr_loc (loc, fndecl, 3, tmp1, tmp2,\n+\t\t\t\t\t  TYPE_SIZE_UNIT (cmptype));\n+\t      rhs1 = build2 (EQ_EXPR, boolean_type_node, rhs1,\n+\t\t\t     integer_zero_node);\n+\t      if (clear_padding)\n+\t\t{\n+\t\t  fndecl = builtin_decl_explicit (BUILT_IN_CLEAR_PADDING);\n+\t\t  tree cp1 = build_call_expr_loc (loc, fndecl, 1, tmp1);\n+\t\t  tree cp2 = build_call_expr_loc (loc, fndecl, 1, tmp2);\n+\t\t  rhs1 = omit_two_operands_loc (loc, boolean_type_node,\n+\t\t\t\t\t\trhs1, cp2, cp1);\n+\t\t}\n+\t    }\n+\t}\n+      if (r)\n+\t{\n+\t  tree var = create_tmp_var (boolean_type_node);\n+\t  DECL_CONTEXT (var) = current_function_decl;\n+\t  rtmp = build4 (TARGET_EXPR, boolean_type_node, var,\n+\t\t\t NULL, NULL, NULL);\n+\t  save = in_late_binary_op;\n+\t  in_late_binary_op = true;\n+\t  x = build_modify_expr (loc, var, NULL_TREE, NOP_EXPR,\n+\t\t\t\t loc, rhs1, NULL_TREE);\n+\t  in_late_binary_op = save;\n+\t  if (x == error_mark_node)\n+\t    return error_mark_node;\n+\t  gcc_assert (TREE_CODE (x) == MODIFY_EXPR\n+\t\t      && TREE_OPERAND (x, 0) == var);\n+\t  TREE_OPERAND (x, 0) = rtmp;\n+\t  rhs1 = omit_one_operand_loc (loc, boolean_type_node, x, rtmp);\n+\t}\n+      rhs = build3_loc (loc, COND_EXPR, type, rhs1, rhs, new_lhs);\n+      rhs1 = NULL_TREE;\n+    }\n \n   /* Punt the actual generation of atomic operations to common code.  */\n   if (code == OMP_ATOMIC)\n     type = void_type_node;\n   x = build2 (code, type, addr, rhs);\n   SET_EXPR_LOCATION (x, loc);\n   OMP_ATOMIC_MEMORY_ORDER (x) = memory_order;\n+  OMP_ATOMIC_WEAK (x) = weak;\n \n   /* Generally it is hard to prove lhs1 and lhs are the same memory\n      location, just diagnose different variables.  */\n@@ -412,8 +534,25 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n \t\t\t  bitsize_int (bitsize), bitsize_int (bitpos));\n \t  type = TREE_TYPE (blhs);\n \t}\n-      x = build_modify_expr (loc, v, NULL_TREE, NOP_EXPR,\n+      if (r)\n+\t{\n+\t  vtmp = create_tmp_var (TREE_TYPE (x));\n+\t  DECL_CONTEXT (vtmp) = current_function_decl;\n+\t}\n+      else\n+\tvtmp = v;\n+      x = build_modify_expr (loc, vtmp, NULL_TREE, NOP_EXPR,\n \t\t\t     loc, x, NULL_TREE);\n+      if (x == error_mark_node)\n+\treturn error_mark_node;\n+      if (r)\n+\t{\n+\t  vtmp = build4 (TARGET_EXPR, boolean_type_node, vtmp,\n+\t\t\t NULL, NULL, NULL);\n+\t  gcc_assert (TREE_CODE (x) == MODIFY_EXPR\n+\t\t      && TREE_OPERAND (x, 0) == TARGET_EXPR_SLOT (vtmp));\n+\t  TREE_OPERAND (x, 0) = vtmp;\n+\t}\n       if (rhs1 && rhs1 != orig_lhs)\n \t{\n \t  tree rhs1addr = build_unary_op (loc, ADDR_EXPR, rhs1, false);\n@@ -446,6 +585,28 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n \n   if (pre)\n     x = omit_one_operand_loc (loc, type, x, pre);\n+  if (r && r != void_list_node)\n+    {\n+      in_late_binary_op = true;\n+      tree x2 = build_modify_expr (loc, r, NULL_TREE, NOP_EXPR,\n+\t\t\t\t   loc, rtmp, NULL_TREE);\n+      in_late_binary_op = save;\n+      if (x2 == error_mark_node)\n+\treturn error_mark_node;\n+      x = omit_one_operand_loc (loc, TREE_TYPE (x2), x2, x);\n+    }\n+  if (v && vtmp != v)\n+    {\n+      in_late_binary_op = true;\n+      tree x2 = build_modify_expr (loc, v, NULL_TREE, NOP_EXPR,\n+\t\t\t\t   loc, vtmp, NULL_TREE);\n+      in_late_binary_op = save;\n+      if (x2 == error_mark_node)\n+\treturn error_mark_node;\n+      x2 = build3_loc (loc, COND_EXPR, void_type_node, rtmp,\n+\t\t       void_node, x2);\n+      x = omit_one_operand_loc (loc, TREE_TYPE (x2), x2, x);\n+    }\n   return x;\n }\n "}, {"sha": "d82c042cfdae5717de2df797431533c1fbf71f39", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 466, "deletions": 38, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -7663,10 +7663,21 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after,\n   c_inhibit_evaluation_warnings -= cond.value == truthvalue_true_node;\n   location_t loc1 = make_location (exp1.get_start (), exp1.src_range);\n   location_t loc2 = make_location (exp2.get_start (), exp2.src_range);\n-  ret.value = build_conditional_expr (colon_loc, cond.value,\n-\t\t\t\t      cond.original_code == C_MAYBE_CONST_EXPR,\n-\t\t\t\t      exp1.value, exp1.original_type, loc1,\n-\t\t\t\t      exp2.value, exp2.original_type, loc2);\n+  if (__builtin_expect (omp_atomic_lhs != NULL, 0)\n+      && (TREE_CODE (cond.value) == GT_EXPR\n+\t  || TREE_CODE (cond.value) == LT_EXPR\n+\t  || TREE_CODE (cond.value) == EQ_EXPR)\n+      && c_tree_equal (exp2.value, omp_atomic_lhs)\n+      && (c_tree_equal (TREE_OPERAND (cond.value, 0), omp_atomic_lhs)\n+\t  || c_tree_equal (TREE_OPERAND (cond.value, 1), omp_atomic_lhs)))\n+    ret.value = build3_loc (colon_loc, COND_EXPR, TREE_TYPE (omp_atomic_lhs),\n+\t\t\t    cond.value, exp1.value, exp2.value);\n+  else\n+    ret.value\n+      = build_conditional_expr (colon_loc, cond.value,\n+\t\t\t\tcond.original_code == C_MAYBE_CONST_EXPR,\n+\t\t\t\texp1.value, exp1.original_type, loc1,\n+\t\t\t\texp2.value, exp2.original_type, loc2);\n   ret.original_code = ERROR_MARK;\n   if (exp1.value == error_mark_node || exp2.value == error_mark_node)\n     ret.original_type = NULL;\n@@ -7849,15 +7860,27 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after,\n       = convert_lvalue_to_rvalue (stack[sp].loc,\t\t\t      \\\n \t\t\t\t  stack[sp].expr, true, true);\t\t      \\\n     if (__builtin_expect (omp_atomic_lhs != NULL_TREE, 0) && sp == 1\t      \\\n-\t&& c_parser_peek_token (parser)->type == CPP_SEMICOLON\t\t      \\\n-\t&& ((1 << stack[sp].prec)\t\t\t\t\t      \\\n-\t    & ((1 << PREC_BITOR) | (1 << PREC_BITXOR) | (1 << PREC_BITAND)    \\\n-\t       | (1 << PREC_SHIFT) | (1 << PREC_ADD) | (1 << PREC_MULT)))     \\\n+\t&& ((c_parser_next_token_is (parser, CPP_SEMICOLON)\t\t      \\\n+\t     && ((1 << stack[sp].prec)\t\t\t\t\t      \\\n+\t\t & ((1 << PREC_BITOR) | (1 << PREC_BITXOR)\t\t      \\\n+\t\t     | (1 << PREC_BITAND) | (1 << PREC_SHIFT)\t\t      \\\n+\t\t     | (1 << PREC_ADD) | (1 << PREC_MULT)\t\t      \\\n+\t\t     | (1 << PREC_EQ))))\t\t\t\t      \\\n+\t    || ((c_parser_next_token_is (parser, CPP_QUERY)\t\t      \\\n+\t\t || (omp_atomic_lhs == void_list_node\t\t\t      \\\n+\t\t     && c_parser_next_token_is (parser, CPP_CLOSE_PAREN)))    \\\n+\t\t&& (stack[sp].prec == PREC_REL || stack[sp].prec == PREC_EQ)))\\\n \t&& stack[sp].op != TRUNC_MOD_EXPR\t\t\t\t      \\\n+\t&& stack[sp].op != GE_EXPR\t\t\t\t\t      \\\n+\t&& stack[sp].op != LE_EXPR\t\t\t\t\t      \\\n+\t&& stack[sp].op != NE_EXPR\t\t\t\t\t      \\\n \t&& stack[0].expr.value != error_mark_node\t\t\t      \\\n \t&& stack[1].expr.value != error_mark_node\t\t\t      \\\n-\t&& (c_tree_equal (stack[0].expr.value, omp_atomic_lhs)\t\t      \\\n-\t    || c_tree_equal (stack[1].expr.value, omp_atomic_lhs)))\t      \\\n+\t&& (omp_atomic_lhs == void_list_node\t\t\t\t      \\\n+\t    || c_tree_equal (stack[0].expr.value, omp_atomic_lhs)\t      \\\n+\t    || c_tree_equal (stack[1].expr.value, omp_atomic_lhs)\t      \\\n+\t    || (stack[sp].op == EQ_EXPR\t\t\t\t\t      \\\n+\t\t&& c_parser_peek_2nd_token (parser)->keyword == RID_IF)))     \\\n       {\t\t\t\t\t\t\t\t\t      \\\n \ttree t = make_node (stack[1].op);\t\t\t\t      \\\n \tTREE_TYPE (t) = TREE_TYPE (stack[0].expr.value);\t\t      \\\n@@ -17655,14 +17678,45 @@ c_parser_omp_allocate (location_t loc, c_parser *parser)\n    capture-block:\n      { v = x; update-stmt; } | { update-stmt; v = x; } | { v = x; x = expr; }\n \n-  where x and v are lvalue expressions with scalar type.\n+   OpenMP 5.1:\n+   # pragma omp atomic compare new-line\n+     conditional-update-atomic\n+\n+   # pragma omp atomic compare capture new-line\n+     conditional-update-capture-atomic\n+\n+   conditional-update-atomic:\n+     cond-expr-stmt | cond-update-stmt\n+   cond-expr-stmt:\n+     x = expr ordop x ? expr : x;\n+     x = x ordop expr ? expr : x;\n+     x = x == e ? d : x;\n+   cond-update-stmt:\n+     if (expr ordop x) { x = expr; }\n+     if (x ordop expr) { x = expr; }\n+     if (x == e) { x = d; }\n+   ordop:\n+     <, >\n+   conditional-update-capture-atomic:\n+     v = cond-expr-stmt\n+     { v = x; cond-expr-stmt }\n+     { cond-expr-stmt v = x; }\n+     { v = x; cond-update-stmt }\n+     { cond-update-stmt v = x; }\n+     if (x == e) { x = d; } else { v = x; }\n+     { r = x == e; if (r) { x = d; } }\n+     { r = x == e; if (r) { x = d; } else { v = x; } }\n+\n+  where x, r and v are lvalue expressions with scalar type,\n+  expr, e and d are expressions with scalar type and e might be\n+  the same as v.\n \n   LOC is the location of the #pragma token.  */\n \n static void\n c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n {\n-  tree lhs = NULL_TREE, rhs = NULL_TREE, v = NULL_TREE;\n+  tree lhs = NULL_TREE, rhs = NULL_TREE, v = NULL_TREE, r = NULL_TREE;\n   tree lhs1 = NULL_TREE, rhs1 = NULL_TREE;\n   tree stmt, orig_lhs, unfolded_lhs = NULL_TREE, unfolded_lhs1 = NULL_TREE;\n   enum tree_code code = ERROR_MARK, opcode = NOP_EXPR;\n@@ -17674,6 +17728,12 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n   bool non_lvalue_p;\n   bool first = true;\n   tree clauses = NULL_TREE;\n+  bool capture = false;\n+  bool compare = false;\n+  bool weak = false;\n+  enum omp_memory_order fail = OMP_MEMORY_ORDER_UNSPECIFIED;\n+  bool no_semicolon = false;\n+  bool extra_scope = false;\n \n   while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n     {\n@@ -17692,21 +17752,66 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n \t  enum tree_code new_code = ERROR_MARK;\n \t  enum omp_memory_order new_memory_order\n \t    = OMP_MEMORY_ORDER_UNSPECIFIED;\n+\t  bool new_capture = false;\n+\t  bool new_compare = false;\n+\t  bool new_weak = false;\n+\t  enum omp_memory_order new_fail = OMP_MEMORY_ORDER_UNSPECIFIED;\n \n \t  if (!strcmp (p, \"read\"))\n \t    new_code = OMP_ATOMIC_READ;\n \t  else if (!strcmp (p, \"write\"))\n \t    new_code = NOP_EXPR;\n \t  else if (!strcmp (p, \"update\"))\n \t    new_code = OMP_ATOMIC;\n-\t  else if (!strcmp (p, \"capture\"))\n+\t  else if (openacc && !strcmp (p, \"capture\"))\n \t    new_code = OMP_ATOMIC_CAPTURE_NEW;\n \t  else if (openacc)\n \t    {\n \t      p = NULL;\n \t      error_at (cloc, \"expected %<read%>, %<write%>, %<update%>, \"\n \t\t\t      \"or %<capture%> clause\");\n \t    }\n+\t  else if (!strcmp (p, \"capture\"))\n+\t    new_capture = true;\n+\t  else if (!strcmp (p, \"compare\"))\n+\t    new_compare = true;\n+\t  else if (!strcmp (p, \"weak\"))\n+\t    new_weak = true;\n+\t  else if (!strcmp (p, \"fail\"))\n+\t    {\n+\t      matching_parens parens;\n+\n+\t      c_parser_consume_token (parser);\n+\t      if (!parens.require_open (parser))\n+\t\tcontinue;\n+\n+\t      if (c_parser_next_token_is (parser, CPP_NAME))\n+\t\t{\n+\t\t  const char *q\n+\t\t    = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\n+\t\t  if (!strcmp (q, \"seq_cst\"))\n+\t\t    new_fail = OMP_MEMORY_ORDER_SEQ_CST;\n+\t\t  else if (!strcmp (q, \"acquire\"))\n+\t\t    new_fail = OMP_MEMORY_ORDER_ACQUIRE;\n+\t\t  else if (!strcmp (q, \"relaxed\"))\n+\t\t    new_fail = OMP_MEMORY_ORDER_RELAXED;\n+\t\t}\n+\n+\t      if (new_fail != OMP_MEMORY_ORDER_UNSPECIFIED)\n+\t\t{\n+\t\t  c_parser_consume_token (parser);\n+\t\t  if (fail != OMP_MEMORY_ORDER_UNSPECIFIED)\n+\t\t    error_at (cloc, \"too many %qs clauses\", \"fail\");\n+\t\t  else\n+\t\t    fail = new_fail;\n+\t\t}\n+\t      else\n+\t\tc_parser_error (parser, \"expected %<seq_cst%>, %<acquire%> \"\n+\t\t\t\t\t\"or %<relaxed%>\");\n+\t      parens.skip_until_found_close (parser);\n+\t      continue;\n+\t    }\n \t  else if (!strcmp (p, \"seq_cst\"))\n \t    new_memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n \t  else if (!strcmp (p, \"acq_rel\"))\n@@ -17727,8 +17832,9 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n \t    {\n \t      p = NULL;\n \t      error_at (cloc, \"expected %<read%>, %<write%>, %<update%>, \"\n-\t\t\t      \"%<capture%>, %<seq_cst%>, %<acq_rel%>, \"\n-\t\t\t      \"%<release%>, %<relaxed%> or %<hint%> clause\");\n+\t\t\t      \"%<capture%>, %<compare%>, %<weak%>, %<fail%>, \"\n+\t\t\t      \"%<seq_cst%>, %<acq_rel%>, %<release%>, \"\n+\t\t\t      \"%<relaxed%> or %<hint%> clause\");\n \t    }\n \t  if (p)\n \t    {\n@@ -17751,6 +17857,27 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n \t\t  else\n \t\t    memory_order = new_memory_order;\n \t\t}\n+\t      else if (new_capture)\n+\t\t{\n+\t\t  if (capture)\n+\t\t    error_at (cloc, \"too many %qs clauses\", \"capture\");\n+\t\t  else\n+\t\t    capture = true;\n+\t\t}\n+\t      else if (new_compare)\n+\t\t{\n+\t\t  if (compare)\n+\t\t    error_at (cloc, \"too many %qs clauses\", \"compare\");\n+\t\t  else\n+\t\t    compare = true;\n+\t\t}\n+\t      else if (new_weak)\n+\t\t{\n+\t\t  if (weak)\n+\t\t    error_at (cloc, \"too many %qs clauses\", \"weak\");\n+\t\t  else\n+\t\t    weak = true;\n+\t\t}\n \t      c_parser_consume_token (parser);\n \t      continue;\n \t    }\n@@ -17761,6 +17888,30 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n \n   if (code == ERROR_MARK)\n     code = OMP_ATOMIC;\n+  if (capture)\n+    {\n+      if (code != OMP_ATOMIC)\n+\terror_at (loc, \"%qs clause is incompatible with %<read%> or %<write%> \"\n+\t\t       \"clauses\", \"capture\");\n+      else\n+\tcode = OMP_ATOMIC_CAPTURE_NEW;\n+    }\n+  if (compare && code != OMP_ATOMIC && code != OMP_ATOMIC_CAPTURE_NEW)\n+    {\n+      error_at (loc, \"%qs clause is incompatible with %<read%> or %<write%> \"\n+\t\t      \"clauses\", \"compare\");\n+      compare = false;\n+    }\n+  if (fail != OMP_MEMORY_ORDER_UNSPECIFIED && !compare)\n+    {\n+      error_at (loc, \"%qs clause requires %qs clause\", \"fail\", \"compare\");\n+      fail = OMP_MEMORY_ORDER_UNSPECIFIED;\n+    }\n+  if (weak && !compare)\n+    {\n+      error_at (loc, \"%qs clause requires %qs clause\", \"weak\", \"compare\");\n+      weak = false;\n+    }\n   if (openacc)\n     memory_order = OMP_MEMORY_ORDER_RELAXED;\n   else if (memory_order == OMP_MEMORY_ORDER_UNSPECIFIED)\n@@ -17785,7 +17936,6 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n \t      memory_order = OMP_MEMORY_ORDER_ACQUIRE;\n \t      break;\n \t    case NOP_EXPR: /* atomic write */\n-\t    case OMP_ATOMIC:\n \t      memory_order = OMP_MEMORY_ORDER_RELEASE;\n \t      break;\n \t    default:\n@@ -17801,36 +17951,32 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n     switch (code)\n       {\n       case OMP_ATOMIC_READ:\n-\tif (memory_order == OMP_MEMORY_ORDER_ACQ_REL\n-\t    || memory_order == OMP_MEMORY_ORDER_RELEASE)\n+\tif (memory_order == OMP_MEMORY_ORDER_RELEASE)\n \t  {\n \t    error_at (loc, \"%<#pragma omp atomic read%> incompatible with \"\n-\t\t\t   \"%<acq_rel%> or %<release%> clauses\");\n+\t\t\t   \"%<release%> clause\");\n \t    memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n \t  }\n+\telse if (memory_order == OMP_MEMORY_ORDER_ACQ_REL)\n+\t  memory_order = OMP_MEMORY_ORDER_ACQUIRE;\n \tbreak;\n       case NOP_EXPR: /* atomic write */\n-\tif (memory_order == OMP_MEMORY_ORDER_ACQ_REL\n-\t    || memory_order == OMP_MEMORY_ORDER_ACQUIRE)\n+\tif (memory_order == OMP_MEMORY_ORDER_ACQUIRE)\n \t  {\n \t    error_at (loc, \"%<#pragma omp atomic write%> incompatible with \"\n-\t\t\t   \"%<acq_rel%> or %<acquire%> clauses\");\n-\t    memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n-\t  }\n-\tbreak;\n-      case OMP_ATOMIC:\n-     /* case OMP_ATOMIC_CAPTURE_NEW: - or update to OpenMP 5.1 */\n-\tif (memory_order == OMP_MEMORY_ORDER_ACQ_REL\n-\t    || memory_order == OMP_MEMORY_ORDER_ACQUIRE)\n-\t  {\n-\t    error_at (loc, \"%<#pragma omp atomic update%> incompatible with \"\n-\t\t\t   \"%<acq_rel%> or %<acquire%> clauses\");\n+\t\t\t   \"%<acquire%> clause\");\n \t    memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n \t  }\n+\telse if (memory_order == OMP_MEMORY_ORDER_ACQ_REL)\n+\t  memory_order = OMP_MEMORY_ORDER_RELEASE;\n \tbreak;\n       default:\n \tbreak;\n       }\n+  if (fail != OMP_MEMORY_ORDER_UNSPECIFIED)\n+    memory_order\n+      = (enum omp_memory_order) (memory_order\n+\t\t\t\t | (fail << OMP_FAIL_MEMORY_ORDER_SHIFT));\n \n   switch (code)\n     {\n@@ -17879,6 +18025,9 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n \t  c_parser_consume_token (parser);\n \t  structured_block = true;\n \t}\n+      else if (compare\n+\t       && c_parser_next_token_is_keyword (parser, RID_IF))\n+\tbreak;\n       else\n \t{\n \t  v = c_parser_cast_expression (parser, NULL).value;\n@@ -17890,6 +18039,12 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n \t    v = non_lvalue (v);\n \t  if (!c_parser_require (parser, CPP_EQ, \"expected %<=%>\"))\n \t    goto saw_error;\n+\t  if (compare && c_parser_next_token_is_keyword (parser, RID_IF))\n+\t    {\n+\t      eloc = c_parser_peek_token (parser)->location;\n+\t      error_at (eloc, \"expected expression\");\n+\t      goto saw_error;\n+\t    }\n \t}\n       break;\n     default:\n@@ -17899,6 +18054,179 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n   /* For structured_block case we don't know yet whether\n      old or new x should be captured.  */\n restart:\n+  if (compare && c_parser_next_token_is_keyword (parser, RID_IF))\n+    {\n+      c_parser_consume_token (parser);\n+\n+      matching_parens parens;\n+      if (!parens.require_open (parser))\n+\tgoto saw_error;\n+      eloc = c_parser_peek_token (parser)->location;\n+      c_expr cmp_expr;\n+      if (r)\n+\t{\n+\t  cmp_expr = c_parser_cast_expression (parser, NULL);\n+\t  cmp_expr = default_function_array_conversion (eloc, cmp_expr);\n+\t}\n+      else\n+\tcmp_expr = c_parser_binary_expression (parser, NULL, void_list_node);\n+      parens.skip_until_found_close (parser);\n+      if (cmp_expr.value == error_mark_node)\n+\tgoto saw_error;\n+      if (r)\n+\t{\n+\t  if (!c_tree_equal (cmp_expr.value, unfolded_lhs))\n+\t    goto bad_if;\n+\t  cmp_expr.value = rhs1;\n+\t  rhs1 = NULL_TREE;\n+\t  gcc_assert (TREE_CODE (cmp_expr.value) == EQ_EXPR);\n+\t}\n+      if (TREE_CODE (cmp_expr.value) == EQ_EXPR)\n+\t;\n+      else if (!structured_block && code == OMP_ATOMIC_CAPTURE_NEW)\n+\t{\n+\t  error_at (EXPR_LOC_OR_LOC (cmp_expr.value, eloc),\n+\t\t    \"expected %<==%> comparison in %<if%> condition\");\n+\t  goto saw_error;\n+\t}\n+      else if (TREE_CODE (cmp_expr.value) != GT_EXPR\n+\t       && TREE_CODE (cmp_expr.value) != LT_EXPR)\n+\t{\n+\t  error_at (EXPR_LOC_OR_LOC (cmp_expr.value, eloc),\n+\t\t    \"expected %<==%>, %<<%> or %<>%> comparison in %<if%> \"\n+\t\t    \"condition\");\n+\t  goto saw_error;\n+\t}\n+      if (!c_parser_require (parser, CPP_OPEN_BRACE, \"expected %<{%>\"))\n+\tgoto saw_error;\n+\n+      extra_scope = true;\n+      eloc = c_parser_peek_token (parser)->location;\n+      expr = c_parser_cast_expression (parser, NULL);\n+      lhs = expr.value;\n+      expr = default_function_array_conversion (eloc, expr);\n+      unfolded_lhs = expr.value;\n+      lhs = c_fully_fold (lhs, false, NULL, true);\n+      orig_lhs = lhs;\n+      if (lhs == error_mark_node)\n+\tgoto saw_error;\n+      if (!lvalue_p (unfolded_lhs))\n+\tlhs = non_lvalue (lhs);\n+      if (!c_parser_next_token_is (parser, CPP_EQ))\n+\t{\n+\t  c_parser_error (parser, \"expected %<=%>\");\n+\t  goto saw_error;\n+\t}\n+      c_parser_consume_token (parser);\n+      eloc = c_parser_peek_token (parser)->location;\n+      expr = c_parser_expr_no_commas (parser, NULL);\n+      rhs1 = expr.value;\n+\n+      if (!c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n+\tgoto saw_error;\n+\n+      if (!c_parser_require (parser, CPP_CLOSE_BRACE, \"expected %<}%>\"))\n+\tgoto saw_error;\n+\n+      extra_scope = false;\n+      no_semicolon = true;\n+\n+      if (c_tree_equal (TREE_OPERAND (cmp_expr.value, 0), unfolded_lhs))\n+\t{\n+\t  if (TREE_CODE (cmp_expr.value) == EQ_EXPR)\n+\t    {\n+\t      opcode = COND_EXPR;\n+\t      rhs = c_fully_fold (TREE_OPERAND (cmp_expr.value, 1),\n+\t\t\t\t  false, NULL, true);\n+\t      rhs1 = c_fully_fold (rhs1, false, NULL, true);\n+\t    }\n+\t  else if (c_tree_equal (TREE_OPERAND (cmp_expr.value, 1), rhs1))\n+\t    {\n+\t      opcode = (TREE_CODE (cmp_expr.value) == GT_EXPR\n+\t\t\t? MIN_EXPR : MAX_EXPR);\n+\t      rhs = c_fully_fold (rhs1, false, NULL, true);\n+\t      rhs1 = c_fully_fold (TREE_OPERAND (cmp_expr.value, 0),\n+\t\t\t\t   false, NULL, true);\n+\t    }\n+\t  else\n+\t    goto bad_if;\n+\t}\n+      else if (TREE_CODE (cmp_expr.value) == EQ_EXPR)\n+\tgoto bad_if;\n+      else if (c_tree_equal (TREE_OPERAND (cmp_expr.value, 1), unfolded_lhs)\n+\t       && c_tree_equal (TREE_OPERAND (cmp_expr.value, 0), rhs1))\n+\t{\n+\t  opcode = (TREE_CODE (cmp_expr.value) == GT_EXPR\n+\t\t    ? MAX_EXPR : MIN_EXPR);\n+\t  rhs = c_fully_fold (rhs1, false, NULL, true);\n+\t  rhs1 = c_fully_fold (TREE_OPERAND (cmp_expr.value, 1),\n+\t\t\t       false, NULL, true);\n+\t}\n+      else\n+\t{\n+\tbad_if:\n+\t  c_parser_error (parser,\n+\t\t\t  \"invalid form of %<#pragma omp atomic compare%>\");\n+\t  goto saw_error;\n+\t}\n+\n+      if (c_parser_next_token_is_keyword (parser, RID_ELSE))\n+\t{\n+\t  if (code != OMP_ATOMIC_CAPTURE_NEW\n+\t      || (structured_block && r == NULL_TREE)\n+\t      || TREE_CODE (cmp_expr.value) != EQ_EXPR)\n+\t    {\n+\t      eloc = c_parser_peek_token (parser)->location;\n+\t      error_at (eloc, \"unexpected %<else%>\");\n+\t      goto saw_error;\n+\t    }\n+\n+\t  c_parser_consume_token (parser);\n+\n+\t  if (!c_parser_require (parser, CPP_OPEN_BRACE, \"expected %<{%>\"))\n+\t    goto saw_error;\n+\n+\t  extra_scope = true;\n+\t  v = c_parser_cast_expression (parser, NULL).value;\n+\t  non_lvalue_p = !lvalue_p (v);\n+\t  v = c_fully_fold (v, false, NULL, true);\n+\t  if (v == error_mark_node)\n+\t    goto saw_error;\n+\t  if (non_lvalue_p)\n+\t    v = non_lvalue (v);\n+\t  if (!c_parser_require (parser, CPP_EQ, \"expected %<=%>\"))\n+\t    goto saw_error;\n+\n+\t  expr = c_parser_expr_no_commas (parser, NULL);\n+\n+\t  if (!c_tree_equal (expr.value, unfolded_lhs))\n+\t    goto bad_if;\n+\n+\t  if (!c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n+\t    goto saw_error;\n+\n+\t  if (!c_parser_require (parser, CPP_CLOSE_BRACE, \"expected %<}%>\"))\n+\t    goto saw_error;\n+\n+\t  extra_scope = false;\n+\t  code = OMP_ATOMIC_CAPTURE_OLD;\n+\t  if (r == NULL_TREE)\n+\t    /* Signal to c_finish_omp_atomic that in\n+\t       if (x == e) { x = d; } else { v = x; }\n+\t       case the store to v should be conditional.  */\n+\t    r = void_list_node;\n+\t}\n+      else if (code == OMP_ATOMIC_CAPTURE_NEW && !structured_block)\n+\t{\n+\t  c_parser_require_keyword (parser, RID_ELSE, \"expected %<else%>\");\n+\t  goto saw_error;\n+\t}\n+      else if (code == OMP_ATOMIC_CAPTURE_NEW\n+\t       && r != NULL_TREE\n+\t       && v == NULL_TREE)\n+\tcode = OMP_ATOMIC;\n+      goto stmt_done;\n+    }\n   eloc = c_parser_peek_token (parser)->location;\n   expr = c_parser_cast_expression (parser, NULL);\n   lhs = expr.value;\n@@ -17908,9 +18236,14 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n   orig_lhs = lhs;\n   switch (TREE_CODE (lhs))\n     {\n+    invalid_compare:\n+      error_at (eloc, \"invalid form of %<pragma omp atomic compare%>\");\n+      /* FALLTHRU */\n     case ERROR_MARK:\n     saw_error:\n       c_parser_skip_to_end_of_block_or_statement (parser);\n+      if (extra_scope && c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n+\tc_parser_consume_token (parser);\n       if (structured_block)\n \t{\n \t  if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n@@ -17933,6 +18266,8 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n       unfolded_lhs = NULL_TREE;\n       opcode = PLUS_EXPR;\n       rhs = integer_one_node;\n+      if (compare)\n+\tgoto invalid_compare;\n       break;\n \n     case POSTDECREMENT_EXPR:\n@@ -17944,6 +18279,8 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n       unfolded_lhs = NULL_TREE;\n       opcode = MINUS_EXPR;\n       rhs = integer_one_node;\n+      if (compare)\n+\tgoto invalid_compare;\n       break;\n \n     case COMPOUND_EXPR:\n@@ -17973,6 +18310,8 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n \t\t  && !structured_block\n \t\t  && TREE_CODE (orig_lhs) == COMPOUND_EXPR)\n \t\tcode = OMP_ATOMIC_CAPTURE_OLD;\n+\t      if (compare)\n+\t\tgoto invalid_compare;\n \t      break;\n \t    }\n \t  if (TREE_CODE (TREE_OPERAND (lhs, 1)) == TRUTH_NOT_EXPR\n@@ -17988,13 +18327,20 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n \t\t  && !structured_block\n \t\t  && TREE_CODE (orig_lhs) == COMPOUND_EXPR)\n \t\tcode = OMP_ATOMIC_CAPTURE_OLD;\n+\t      if (compare)\n+\t\tgoto invalid_compare;\n \t      break;\n \t    }\n \t}\n       /* FALLTHRU */\n     default:\n       if (!lvalue_p (unfolded_lhs))\n \tlhs = non_lvalue (lhs);\n+      if (compare && !c_parser_next_token_is (parser, CPP_EQ))\n+\t{\n+\t  c_parser_error (parser, \"expected %<=%>\");\n+\t  goto saw_error;\n+\t}\n       switch (c_parser_peek_token (parser)->type)\n \t{\n \tcase CPP_MULT_EQ:\n@@ -18041,6 +18387,8 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n \t    case BIT_AND_EXPR:\n \t    case BIT_IOR_EXPR:\n \t    case BIT_XOR_EXPR:\n+\t      if (compare)\n+\t\tbreak;\n \t      if (c_tree_equal (TREE_OPERAND (rhs1, 0), unfolded_lhs))\n \t\t{\n \t\t  opcode = TREE_CODE (rhs1);\n@@ -18061,6 +18409,78 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n \t\t  goto stmt_done;\n \t\t}\n \t      break;\n+\t    case COND_EXPR:\n+\t      if (!compare)\n+\t\tbreak;\n+\t      if (TREE_CODE (TREE_OPERAND (rhs1, 0)) != GT_EXPR\n+\t\t  && TREE_CODE (TREE_OPERAND (rhs1, 0)) != LT_EXPR\n+\t\t  && TREE_CODE (TREE_OPERAND (rhs1, 0)) != EQ_EXPR)\n+\t\tbreak;\n+\t      if (!TREE_OPERAND (rhs1, 1))\n+\t\tbreak;\n+\t      if (!c_tree_equal (TREE_OPERAND (rhs1, 2), unfolded_lhs))\n+\t\tbreak;\n+\t      if (c_tree_equal (TREE_OPERAND (TREE_OPERAND (rhs1, 0), 0),\n+\t\t\t\tunfolded_lhs))\n+\t\t{\n+\t\t  if (TREE_CODE (TREE_OPERAND (rhs1, 0)) == EQ_EXPR)\n+\t\t    {\n+\t\t      opcode = COND_EXPR;\n+\t\t      rhs = c_fully_fold (TREE_OPERAND (TREE_OPERAND (rhs1,\n+\t\t\t\t\t\t\t\t      0), 1),\n+\t\t\t\t\t  false, NULL, true);\n+\t\t      rhs1 = c_fully_fold (TREE_OPERAND (rhs1, 1), false,\n+\t\t\t\t\t   NULL, true);\n+\t\t      goto stmt_done;\n+\t\t    }\n+\t\t  if (c_tree_equal (TREE_OPERAND (TREE_OPERAND (rhs1, 0), 1),\n+\t\t\t\t    TREE_OPERAND (rhs1, 1)))\n+\t\t    {\n+\t\t      opcode = (TREE_CODE (TREE_OPERAND (rhs1, 0)) == GT_EXPR\n+\t\t\t\t? MIN_EXPR : MAX_EXPR);\n+\t\t      rhs = c_fully_fold (TREE_OPERAND (rhs1, 1), false, NULL,\n+\t\t\t\t\t  true);\n+\t\t      rhs1 = c_fully_fold (TREE_OPERAND (TREE_OPERAND (rhs1,\n+\t\t\t\t\t\t\t\t       0), 0),\n+\t\t\t\t\t   false, NULL, true);\n+\t\t      goto stmt_done;\n+\t\t    }\n+\t\t}\n+\t      else if (TREE_CODE (TREE_OPERAND (rhs1, 0)) == EQ_EXPR)\n+\t\tbreak;\n+\t      else if (c_tree_equal (TREE_OPERAND (TREE_OPERAND (rhs1, 0), 1),\n+\t\t\t\t     unfolded_lhs))\n+\t\t{\n+\t\t  if (c_tree_equal (TREE_OPERAND (TREE_OPERAND (rhs1, 0), 0),\n+\t\t\t\t    TREE_OPERAND (rhs1, 1)))\n+\t\t    {\n+\t\t      opcode = (TREE_CODE (TREE_OPERAND (rhs1, 0)) == GT_EXPR\n+\t\t\t\t? MAX_EXPR : MIN_EXPR);\n+\t\t      rhs = c_fully_fold (TREE_OPERAND (rhs1, 1), false, NULL,\n+\t\t\t\t\t  true);\n+\t\t      rhs1 = c_fully_fold (TREE_OPERAND (TREE_OPERAND (rhs1,\n+\t\t\t\t\t\t\t\t       0), 1),\n+\t\t\t\t\t   false, NULL, true);\n+\t\t      goto stmt_done;\n+\t\t    }\n+\t\t}\n+\t      break;\n+\t    case EQ_EXPR:\n+\t      if (!compare\n+\t\t  || code != OMP_ATOMIC_CAPTURE_NEW\n+\t\t  || !structured_block\n+\t\t  || v\n+\t\t  || r)\n+\t\tbreak;\n+\t      if (c_parser_next_token_is (parser, CPP_SEMICOLON)\n+\t\t  && c_parser_peek_2nd_token (parser)->keyword == RID_IF)\n+\t\t{\n+\t\t  r = lhs;\n+\t\t  lhs = NULL_TREE;\n+\t\t  c_parser_consume_token (parser);\n+\t\t  goto restart;\n+\t\t}\n+\t      break;\n \t    case ERROR_MARK:\n \t      goto saw_error;\n \t    default:\n@@ -18109,10 +18529,12 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n       break;\n     }\n stmt_done:\n-  if (structured_block && code == OMP_ATOMIC_CAPTURE_NEW)\n+  if (structured_block && code == OMP_ATOMIC_CAPTURE_NEW && r == NULL_TREE)\n     {\n-      if (!c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n+      if (!no_semicolon\n+\t  && !c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n \tgoto saw_error;\n+      no_semicolon = false;\n       v = c_parser_cast_expression (parser, NULL).value;\n       non_lvalue_p = !lvalue_p (v);\n       v = c_fully_fold (v, false, NULL, true);\n@@ -18135,10 +18557,16 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n     }\n   if (structured_block)\n     {\n-      c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+      if (!no_semicolon)\n+\tc_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n       c_parser_require (parser, CPP_CLOSE_BRACE, \"expected %<}%>\");\n     }\n done:\n+  if (weak && opcode != COND_EXPR)\n+    {\n+      error_at (loc, \"%<weak%> clause requires atomic equality comparison\");\n+      weak = false;\n+    }\n   if (unfolded_lhs && unfolded_lhs1\n       && !c_tree_equal (unfolded_lhs, unfolded_lhs1))\n     {\n@@ -18147,12 +18575,12 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n       stmt = error_mark_node;\n     }\n   else\n-    stmt = c_finish_omp_atomic (loc, code, opcode, lhs, rhs, v, lhs1, rhs1,\n-\t\t\t\tswapped, memory_order);\n+    stmt = c_finish_omp_atomic (loc, code, opcode, lhs, rhs, v, lhs1, rhs1, r,\n+\t\t\t\tswapped, memory_order, weak);\n   if (stmt != error_mark_node)\n     add_stmt (stmt);\n \n-  if (!structured_block)\n+  if (!structured_block && !no_semicolon)\n     c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n }\n "}, {"sha": "49d1bb067a00994d011d6e13bd7b2c066f05f4a1", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -12426,6 +12426,13 @@ build_binary_op (location_t location, enum tree_code code,\n \tmaybe_warn_bool_compare (location, code, orig_op0, orig_op1);\n       break;\n \n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+      /* Used for OpenMP atomics.  */\n+      gcc_assert (flag_openmp);\n+      common = 1;\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "e44c5c6b57cdb811f08e92ff857a1628d45557dc", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -40193,7 +40193,6 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n \t      memory_order = OMP_MEMORY_ORDER_ACQUIRE;\n \t      break;\n \t    case NOP_EXPR: /* atomic write */\n-\t    case OMP_ATOMIC:\n \t      memory_order = OMP_MEMORY_ORDER_RELEASE;\n \t      break;\n \t    default:\n@@ -40209,31 +40208,24 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n     switch (code)\n       {\n       case OMP_ATOMIC_READ:\n-\tif (memory_order == OMP_MEMORY_ORDER_ACQ_REL\n-\t    || memory_order == OMP_MEMORY_ORDER_RELEASE)\n+\tif (memory_order == OMP_MEMORY_ORDER_RELEASE)\n \t  {\n \t    error_at (loc, \"%<#pragma omp atomic read%> incompatible with \"\n-\t\t\t   \"%<acq_rel%> or %<release%> clauses\");\n+\t\t\t   \"%<release%> clause\");\n \t    memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n \t  }\n+\telse if (memory_order == OMP_MEMORY_ORDER_ACQ_REL)\n+\t  memory_order = OMP_MEMORY_ORDER_ACQUIRE;\n \tbreak;\n       case NOP_EXPR: /* atomic write */\n-\tif (memory_order == OMP_MEMORY_ORDER_ACQ_REL\n-\t    || memory_order == OMP_MEMORY_ORDER_ACQUIRE)\n+\tif (memory_order == OMP_MEMORY_ORDER_ACQUIRE)\n \t  {\n \t    error_at (loc, \"%<#pragma omp atomic write%> incompatible with \"\n-\t\t\t   \"%<acq_rel%> or %<acquire%> clauses\");\n-\t    memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n-\t  }\n-\tbreak;\n-      case OMP_ATOMIC:\n-\tif (memory_order == OMP_MEMORY_ORDER_ACQ_REL\n-\t    || memory_order == OMP_MEMORY_ORDER_ACQUIRE)\n-\t  {\n-\t    error_at (loc, \"%<#pragma omp atomic update%> incompatible with \"\n-\t\t\t   \"%<acq_rel%> or %<acquire%> clauses\");\n+\t\t\t   \"%<acquire%> clause\");\n \t    memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n \t  }\n+\telse if (memory_order == OMP_MEMORY_ORDER_ACQ_REL)\n+\t  memory_order = OMP_MEMORY_ORDER_RELEASE;\n \tbreak;\n       default:\n \tbreak;"}, {"sha": "94e6b181d5dc25a9a6fad646f44431b08d5f1072", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -9956,7 +9956,7 @@ finish_omp_atomic (location_t loc, enum tree_code code, enum tree_code opcode,\n \t  return;\n \t}\n       stmt = c_finish_omp_atomic (loc, code, opcode, lhs, rhs,\n-\t\t\t\t  v, lhs1, rhs1, swapped, mo,\n+\t\t\t\t  v, lhs1, rhs1, NULL_TREE, swapped, mo, false,\n \t\t\t\t  processing_template_decl != 0);\n       if (stmt == error_mark_node)\n \treturn;"}, {"sha": "0ca4a949612313e1429e5d4d25160b398019016b", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -2563,6 +2563,8 @@ dump_gimple_omp_atomic_load (pretty_printer *buffer, const gomp_atomic_load *gs,\n \t\t\t\t    gimple_omp_atomic_memory_order (gs));\n       if (gimple_omp_atomic_need_value_p (gs))\n \tpp_string (buffer, \" [needed]\");\n+      if (gimple_omp_atomic_weak_p (gs))\n+\tpp_string (buffer, \" [weak]\");\n       newline_and_indent (buffer, spc + 2);\n       dump_generic_node (buffer, gimple_omp_atomic_load_lhs (gs),\n \t  \t\t spc, flags, false);\n@@ -2597,6 +2599,8 @@ dump_gimple_omp_atomic_store (pretty_printer *buffer,\n       pp_space (buffer);\n       if (gimple_omp_atomic_need_value_p (gs))\n \tpp_string (buffer, \"[needed] \");\n+      if (gimple_omp_atomic_weak_p (gs))\n+\tpp_string (buffer, \"[weak] \");\n       pp_left_paren (buffer);\n       dump_generic_node (buffer, gimple_omp_atomic_store_val (gs),\n \t  \t\t spc, flags, false);"}, {"sha": "303623b3cedb2273458f42119cf6303bef2d4f43", "filename": "gcc/gimple.h", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -194,8 +194,9 @@ enum gf_mask {\n     GF_OMP_RETURN_NOWAIT\t= 1 << 0,\n \n     GF_OMP_SECTION_LAST\t\t= 1 << 0,\n-    GF_OMP_ATOMIC_MEMORY_ORDER  = (1 << 3) - 1,\n-    GF_OMP_ATOMIC_NEED_VALUE\t= 1 << 3,\n+    GF_OMP_ATOMIC_MEMORY_ORDER  = (1 << 6) - 1,\n+    GF_OMP_ATOMIC_NEED_VALUE\t= 1 << 6,\n+    GF_OMP_ATOMIC_WEAK\t\t= 1 << 7,\n     GF_PREDICT_TAKEN\t\t= 1 << 15\n };\n \n@@ -2446,6 +2447,29 @@ gimple_omp_atomic_set_need_value (gimple *g)\n }\n \n \n+/* Return true if OMP atomic load/store statement G has the\n+   GF_OMP_ATOMIC_WEAK flag set.  */\n+\n+static inline bool\n+gimple_omp_atomic_weak_p (const gimple *g)\n+{\n+  if (gimple_code (g) != GIMPLE_OMP_ATOMIC_LOAD)\n+    GIMPLE_CHECK (g, GIMPLE_OMP_ATOMIC_STORE);\n+  return (gimple_omp_subcode (g) & GF_OMP_ATOMIC_WEAK) != 0;\n+}\n+\n+\n+/* Set the GF_OMP_ATOMIC_WEAK flag on G.  */\n+\n+static inline void\n+gimple_omp_atomic_set_weak (gimple *g)\n+{\n+  if (gimple_code (g) != GIMPLE_OMP_ATOMIC_LOAD)\n+    GIMPLE_CHECK (g, GIMPLE_OMP_ATOMIC_STORE);\n+  g->subcode |= GF_OMP_ATOMIC_WEAK;\n+}\n+\n+\n /* Return the memory order of the OMP atomic load/store statement G.  */\n \n static inline enum omp_memory_order"}, {"sha": "66dfd25ad21379042a2a40c9993844757058a6b0", "filename": "gcc/gimplify.c", "status": "modified", "additions": 138, "deletions": 23, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -13859,14 +13859,15 @@ goa_lhs_expr_p (tree expr, tree addr)\n \n static int\n goa_stabilize_expr (tree *expr_p, gimple_seq *pre_p, tree lhs_addr,\n-\t\t    tree lhs_var)\n+\t\t    tree lhs_var, tree &target_expr, bool rhs)\n {\n   tree expr = *expr_p;\n   int saw_lhs;\n \n   if (goa_lhs_expr_p (expr, lhs_addr))\n     {\n-      *expr_p = lhs_var;\n+      if (pre_p)\n+\t*expr_p = lhs_var;\n       return 1;\n     }\n   if (is_gimple_val (expr))\n@@ -13878,11 +13879,11 @@ goa_stabilize_expr (tree *expr_p, gimple_seq *pre_p, tree lhs_addr,\n     case tcc_binary:\n     case tcc_comparison:\n       saw_lhs |= goa_stabilize_expr (&TREE_OPERAND (expr, 1), pre_p, lhs_addr,\n-\t\t\t\t     lhs_var);\n+\t\t\t\t     lhs_var, target_expr, true);\n       /* FALLTHRU */\n     case tcc_unary:\n       saw_lhs |= goa_stabilize_expr (&TREE_OPERAND (expr, 0), pre_p, lhs_addr,\n-\t\t\t\t     lhs_var);\n+\t\t\t\t     lhs_var, target_expr, true);\n       break;\n     case tcc_expression:\n       switch (TREE_CODE (expr))\n@@ -13894,36 +13895,131 @@ goa_stabilize_expr (tree *expr_p, gimple_seq *pre_p, tree lhs_addr,\n \tcase TRUTH_XOR_EXPR:\n \tcase BIT_INSERT_EXPR:\n \t  saw_lhs |= goa_stabilize_expr (&TREE_OPERAND (expr, 1), pre_p,\n-\t\t\t\t\t lhs_addr, lhs_var);\n+\t\t\t\t\t lhs_addr, lhs_var, target_expr, true);\n \t  /* FALLTHRU */\n \tcase TRUTH_NOT_EXPR:\n \t  saw_lhs |= goa_stabilize_expr (&TREE_OPERAND (expr, 0), pre_p,\n-\t\t\t\t\t lhs_addr, lhs_var);\n+\t\t\t\t\t lhs_addr, lhs_var, target_expr, true);\n+\t  break;\n+\tcase MODIFY_EXPR:\n+\t  saw_lhs |= goa_stabilize_expr (&TREE_OPERAND (expr, 1), pre_p,\n+\t\t\t\t\t lhs_addr, lhs_var, target_expr, true);\n+\t  /* FALLTHRU */\n+\tcase ADDR_EXPR:\n+\t  saw_lhs |= goa_stabilize_expr (&TREE_OPERAND (expr, 0), pre_p,\n+\t\t\t\t\t lhs_addr, lhs_var, target_expr, false);\n \t  break;\n \tcase COMPOUND_EXPR:\n+\t  /* Special-case __builtin_clear_padding call before\n+\t     __builtin_memcmp.  */\n+\t  if (TREE_CODE (TREE_OPERAND (expr, 0)) == CALL_EXPR)\n+\t    {\n+\t      tree fndecl = get_callee_fndecl (TREE_OPERAND (expr, 0));\n+\t      if (fndecl\n+\t\t  && fndecl_built_in_p (fndecl, BUILT_IN_CLEAR_PADDING)\n+\t\t  && VOID_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 0))))\n+\t\t{\n+\t\t  saw_lhs = goa_stabilize_expr (&TREE_OPERAND (expr, 0), pre_p,\n+\t\t\t\t\t\tlhs_addr, lhs_var,\n+\t\t\t\t\t\ttarget_expr, true);\n+\t\t  if (!saw_lhs)\n+\t\t    {\n+\t\t      expr = TREE_OPERAND (expr, 1);\n+\t\t      if (!pre_p)\n+\t\t\treturn goa_stabilize_expr (&expr, pre_p, lhs_addr,\n+\t\t\t\t\t\t   lhs_var, target_expr, true);\n+\t\t      *expr_p = expr;\n+\t\t      return goa_stabilize_expr (expr_p, pre_p, lhs_addr,\n+\t\t\t\t\t\t lhs_var, target_expr, true);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      saw_lhs |= goa_stabilize_expr (&TREE_OPERAND (expr, 1),\n+\t\t\t\t\t\t     pre_p, lhs_addr, lhs_var,\n+\t\t\t\t\t\t     target_expr, rhs);\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n \t  /* Break out any preevaluations from cp_build_modify_expr.  */\n \t  for (; TREE_CODE (expr) == COMPOUND_EXPR;\n \t       expr = TREE_OPERAND (expr, 1))\n-\t    gimplify_stmt (&TREE_OPERAND (expr, 0), pre_p);\n+\t    if (pre_p)\n+\t      gimplify_stmt (&TREE_OPERAND (expr, 0), pre_p);\n+\t  if (!pre_p)\n+\t    return goa_stabilize_expr (&expr, pre_p, lhs_addr, lhs_var,\n+\t\t\t\t       target_expr, rhs);\n \t  *expr_p = expr;\n-\t  return goa_stabilize_expr (expr_p, pre_p, lhs_addr, lhs_var);\n+\t  return goa_stabilize_expr (expr_p, pre_p, lhs_addr, lhs_var,\n+\t\t\t\t     target_expr, rhs);\n+\tcase COND_EXPR:\n+\t  if (!goa_stabilize_expr (&TREE_OPERAND (expr, 0), NULL, lhs_addr,\n+\t\t\t\t   lhs_var, target_expr, true))\n+\t    break;\n+\t  saw_lhs |= goa_stabilize_expr (&TREE_OPERAND (expr, 0), pre_p,\n+\t\t\t\t\t lhs_addr, lhs_var, target_expr, true);\n+\t  saw_lhs |= goa_stabilize_expr (&TREE_OPERAND (expr, 1), pre_p,\n+\t\t\t\t\t lhs_addr, lhs_var, target_expr, true);\n+\t  saw_lhs |= goa_stabilize_expr (&TREE_OPERAND (expr, 2), pre_p,\n+\t\t\t\t\t lhs_addr, lhs_var, target_expr, true);\n+\t  break;\n+\tcase TARGET_EXPR:\n+\t  if (TARGET_EXPR_INITIAL (expr))\n+\t    {\n+\t      if (expr == target_expr)\n+\t\tsaw_lhs = 1;\n+\t      else\n+\t\t{\n+\t\t  saw_lhs = goa_stabilize_expr (&TARGET_EXPR_INITIAL (expr),\n+\t\t\t\t\t\tpre_p, lhs_addr, lhs_var,\n+\t\t\t\t\t\ttarget_expr, true);\n+\t\t  if (saw_lhs && target_expr == NULL_TREE && pre_p)\n+\t\t    target_expr = expr;\n+\t\t}\n+\t    }\n+\t  break;\n \tdefault:\n \t  break;\n \t}\n       break;\n     case tcc_reference:\n-      if (TREE_CODE (expr) == BIT_FIELD_REF)\n+      if (TREE_CODE (expr) == BIT_FIELD_REF\n+\t  || TREE_CODE (expr) == VIEW_CONVERT_EXPR)\n \tsaw_lhs |= goa_stabilize_expr (&TREE_OPERAND (expr, 0), pre_p,\n-\t\t\t\t       lhs_addr, lhs_var);\n+\t\t\t\t       lhs_addr, lhs_var, target_expr, true);\n+      break;\n+    case tcc_vl_exp:\n+      if (TREE_CODE (expr) == CALL_EXPR)\n+\t{\n+\t  if (tree fndecl = get_callee_fndecl (expr))\n+\t    if (fndecl_built_in_p (fndecl, BUILT_IN_CLEAR_PADDING)\n+\t\t|| fndecl_built_in_p (fndecl, BUILT_IN_MEMCMP))\n+\t      {\n+\t\tint nargs = call_expr_nargs (expr);\n+\t\tfor (int i = 0; i < nargs; i++)\n+\t\t  saw_lhs |= goa_stabilize_expr (&CALL_EXPR_ARG (expr, i),\n+\t\t\t\t\t\t pre_p, lhs_addr, lhs_var,\n+\t\t\t\t\t\t target_expr, true);\n+\t      }\n+\t  if (saw_lhs == 0 && VOID_TYPE_P (TREE_TYPE (expr)))\n+\t    {\n+\t      if (pre_p)\n+\t\tgimplify_stmt (&expr, pre_p);\n+\t      return 0;\n+\t    }\n+\t}\n       break;\n     default:\n       break;\n     }\n \n-  if (saw_lhs == 0)\n+  if (saw_lhs == 0 && pre_p)\n     {\n       enum gimplify_status gs;\n-      gs = gimplify_expr (expr_p, pre_p, NULL, is_gimple_val, fb_rvalue);\n+      if (rhs)\n+\tgs = gimplify_expr (expr_p, pre_p, NULL, is_gimple_val, fb_rvalue);\n+      else\n+\tgs = gimplify_expr (expr_p, pre_p, NULL, is_gimple_lvalue, fb_lvalue);\n       if (gs != GS_ALL_DONE)\n \tsaw_lhs = -1;\n     }\n@@ -13943,9 +14039,12 @@ gimplify_omp_atomic (tree *expr_p, gimple_seq *pre_p)\n   tree tmp_load;\n   gomp_atomic_load *loadstmt;\n   gomp_atomic_store *storestmt;\n+  tree target_expr = NULL_TREE;\n \n   tmp_load = create_tmp_reg (type);\n-  if (rhs && goa_stabilize_expr (&rhs, pre_p, addr, tmp_load) < 0)\n+  if (rhs\n+      && goa_stabilize_expr (&rhs, pre_p, addr, tmp_load, target_expr,\n+\t\t\t     true) < 0)\n     return GS_ERROR;\n \n   if (gimplify_expr (&addr, pre_p, NULL, is_gimple_val, fb_rvalue)\n@@ -13959,11 +14058,14 @@ gimplify_omp_atomic (tree *expr_p, gimple_seq *pre_p)\n     {\n       /* BIT_INSERT_EXPR is not valid for non-integral bitfield\n \t representatives.  Use BIT_FIELD_REF on the lhs instead.  */\n-      if (TREE_CODE (rhs) == BIT_INSERT_EXPR\n+      tree rhsarg = rhs;\n+      if (TREE_CODE (rhs) == COND_EXPR)\n+\trhsarg = TREE_OPERAND (rhs, 1);\n+      if (TREE_CODE (rhsarg) == BIT_INSERT_EXPR\n \t  && !INTEGRAL_TYPE_P (TREE_TYPE (tmp_load)))\n \t{\n-\t  tree bitpos = TREE_OPERAND (rhs, 2);\n-\t  tree op1 = TREE_OPERAND (rhs, 1);\n+\t  tree bitpos = TREE_OPERAND (rhsarg, 2);\n+\t  tree op1 = TREE_OPERAND (rhsarg, 1);\n \t  tree bitsize;\n \t  tree tmp_store = tmp_load;\n \t  if (TREE_CODE (*expr_p) == OMP_ATOMIC_CAPTURE_OLD)\n@@ -13972,24 +14074,37 @@ gimplify_omp_atomic (tree *expr_p, gimple_seq *pre_p)\n \t    bitsize = bitsize_int (TYPE_PRECISION (TREE_TYPE (op1)));\n \t  else\n \t    bitsize = TYPE_SIZE (TREE_TYPE (op1));\n-\t  gcc_assert (TREE_OPERAND (rhs, 0) == tmp_load);\n-\t  tree t = build2_loc (EXPR_LOCATION (rhs),\n+\t  gcc_assert (TREE_OPERAND (rhsarg, 0) == tmp_load);\n+\t  tree t = build2_loc (EXPR_LOCATION (rhsarg),\n \t\t\t       MODIFY_EXPR, void_type_node,\n-\t\t\t       build3_loc (EXPR_LOCATION (rhs), BIT_FIELD_REF,\n-\t\t\t\t\t   TREE_TYPE (op1), tmp_store, bitsize,\n-\t\t\t\t\t   bitpos), op1);\n+\t\t\t       build3_loc (EXPR_LOCATION (rhsarg),\n+\t\t\t\t\t   BIT_FIELD_REF, TREE_TYPE (op1),\n+\t\t\t\t\t   tmp_store, bitsize, bitpos), op1);\n+\t  if (TREE_CODE (rhs) == COND_EXPR)\n+\t    t = build3_loc (EXPR_LOCATION (rhs), COND_EXPR, void_type_node,\n+\t\t\t    TREE_OPERAND (rhs, 0), t, void_node);\n \t  gimplify_and_add (t, pre_p);\n \t  rhs = tmp_store;\n \t}\n-      if (gimplify_expr (&rhs, pre_p, NULL, is_gimple_val, fb_rvalue)\n-\t  != GS_ALL_DONE)\n+      bool save_allow_rhs_cond_expr = gimplify_ctxp->allow_rhs_cond_expr;\n+      if (TREE_CODE (rhs) == COND_EXPR)\n+\tgimplify_ctxp->allow_rhs_cond_expr = true;\n+      enum gimplify_status gs = gimplify_expr (&rhs, pre_p, NULL,\n+\t\t\t\t\t       is_gimple_val, fb_rvalue);\n+      gimplify_ctxp->allow_rhs_cond_expr = save_allow_rhs_cond_expr;\n+      if (gs != GS_ALL_DONE)\n \treturn GS_ERROR;\n     }\n \n   if (TREE_CODE (*expr_p) == OMP_ATOMIC_READ)\n     rhs = tmp_load;\n   storestmt\n     = gimple_build_omp_atomic_store (rhs, OMP_ATOMIC_MEMORY_ORDER (*expr_p));\n+  if (TREE_CODE (*expr_p) != OMP_ATOMIC_READ && OMP_ATOMIC_WEAK (*expr_p))\n+    {\n+      gimple_omp_atomic_set_weak (loadstmt);\n+      gimple_omp_atomic_set_weak (storestmt);\n+    }\n   gimplify_seq_add_stmt (pre_p, storestmt);\n   switch (TREE_CODE (*expr_p))\n     {"}, {"sha": "159ae0e1647baf318e85366069f3b119a1872f38", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 308, "deletions": 15, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -8487,22 +8487,58 @@ expand_omp_synch (struct omp_region *region)\n     }\n }\n \n+/* Translate enum omp_memory_order to enum memmodel for the embedded\n+   fail clause in there.  */\n+\n+static enum memmodel\n+omp_memory_order_to_fail_memmodel (enum omp_memory_order mo)\n+{\n+  switch (mo & OMP_FAIL_MEMORY_ORDER_MASK)\n+    {\n+    case OMP_FAIL_MEMORY_ORDER_UNSPECIFIED:\n+      switch (mo & OMP_MEMORY_ORDER_MASK)\n+\t{\n+\tcase OMP_MEMORY_ORDER_RELAXED: return MEMMODEL_RELAXED;\n+\tcase OMP_MEMORY_ORDER_ACQUIRE: return MEMMODEL_ACQUIRE;\n+\tcase OMP_MEMORY_ORDER_RELEASE: return MEMMODEL_RELAXED;\n+\tcase OMP_MEMORY_ORDER_ACQ_REL: return MEMMODEL_ACQUIRE;\n+\tcase OMP_MEMORY_ORDER_SEQ_CST: return MEMMODEL_SEQ_CST;\n+\tdefault: break;\n+\t}\n+      gcc_unreachable ();\n+    case OMP_FAIL_MEMORY_ORDER_RELAXED: return MEMMODEL_RELAXED;\n+    case OMP_FAIL_MEMORY_ORDER_ACQUIRE: return MEMMODEL_ACQUIRE;\n+    case OMP_FAIL_MEMORY_ORDER_SEQ_CST: return MEMMODEL_SEQ_CST;\n+    default: gcc_unreachable ();\n+    }\n+}\n+\n /* Translate enum omp_memory_order to enum memmodel.  The two enums\n    are using different numbers so that OMP_MEMORY_ORDER_UNSPECIFIED\n-   is 0.  */\n+   is 0 and omp_memory_order has the fail mode encoded in it too.  */\n \n static enum memmodel\n omp_memory_order_to_memmodel (enum omp_memory_order mo)\n {\n-  switch (mo)\n-    {\n-    case OMP_MEMORY_ORDER_RELAXED: return MEMMODEL_RELAXED;\n-    case OMP_MEMORY_ORDER_ACQUIRE: return MEMMODEL_ACQUIRE;\n-    case OMP_MEMORY_ORDER_RELEASE: return MEMMODEL_RELEASE;\n-    case OMP_MEMORY_ORDER_ACQ_REL: return MEMMODEL_ACQ_REL;\n-    case OMP_MEMORY_ORDER_SEQ_CST: return MEMMODEL_SEQ_CST;\n+  enum memmodel ret, fail_ret;\n+  switch (mo & OMP_MEMORY_ORDER_MASK)\n+    {\n+    case OMP_MEMORY_ORDER_RELAXED: ret = MEMMODEL_RELAXED; break;\n+    case OMP_MEMORY_ORDER_ACQUIRE: ret = MEMMODEL_ACQUIRE; break;\n+    case OMP_MEMORY_ORDER_RELEASE: ret = MEMMODEL_RELEASE; break;\n+    case OMP_MEMORY_ORDER_ACQ_REL: ret = MEMMODEL_ACQ_REL; break;\n+    case OMP_MEMORY_ORDER_SEQ_CST: ret = MEMMODEL_SEQ_CST; break;\n     default: gcc_unreachable ();\n     }\n+  /* If we drop the -Winvalid-memory-model warning for C++17 P0418R2,\n+     we can just return ret here unconditionally.  Otherwise, work around\n+     it here and make sure fail memmodel is not stronger.  */\n+  if ((mo & OMP_FAIL_MEMORY_ORDER_MASK) == OMP_FAIL_MEMORY_ORDER_UNSPECIFIED)\n+    return ret;\n+  fail_ret = omp_memory_order_to_fail_memmodel (mo);\n+  if (fail_ret > ret)\n+    return fail_ret;\n+  return ret;\n }\n \n /* A subroutine of expand_omp_atomic.  Attempt to implement the atomic\n@@ -8782,6 +8818,261 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n   return true;\n }\n \n+/* A subroutine of expand_omp_atomic.  Attempt to implement the atomic\n+   compare and exchange as an ATOMIC_COMPARE_EXCHANGE internal function.\n+   Returns false if the expression is not of the proper form.  */\n+\n+static bool\n+expand_omp_atomic_cas (basic_block load_bb, tree addr,\n+\t\t       tree loaded_val, tree stored_val, int index)\n+{\n+  /* We expect to find the following sequences:\n+\n+   load_bb:\n+       GIMPLE_OMP_ATOMIC_LOAD (tmp, mem)\n+\n+   store_bb:\n+       val = tmp == e ? d : tmp;\n+       GIMPLE_OMP_ATOMIC_STORE (val)\n+\n+     or in store_bb instead:\n+       tmp2 = tmp == e;\n+       val = tmp2 ? d : tmp;\n+       GIMPLE_OMP_ATOMIC_STORE (val)\n+\n+     or:\n+       tmp3 = VIEW_CONVERT_EXPR<integral_type>(tmp);\n+       val = e == tmp3 ? d : tmp;\n+       GIMPLE_OMP_ATOMIC_STORE (val)\n+\n+     etc.  */\n+\n+\n+  basic_block store_bb = single_succ (load_bb);\n+  gimple_stmt_iterator gsi = gsi_last_nondebug_bb (store_bb);\n+  gimple *store_stmt = gsi_stmt (gsi);\n+  if (!store_stmt || gimple_code (store_stmt) != GIMPLE_OMP_ATOMIC_STORE)\n+    return false;\n+  gsi_prev_nondebug (&gsi);\n+  if (gsi_end_p (gsi))\n+    return false;\n+  gimple *condexpr_stmt = gsi_stmt (gsi);\n+  if (!is_gimple_assign (condexpr_stmt)\n+      || gimple_assign_rhs_code (condexpr_stmt) != COND_EXPR)\n+    return false;\n+  if (!operand_equal_p (gimple_assign_lhs (condexpr_stmt), stored_val, 0))\n+    return false;\n+  gimple *cond_stmt = NULL;\n+  gimple *vce_stmt = NULL;\n+  gsi_prev_nondebug (&gsi);\n+  if (!gsi_end_p (gsi))\n+    {\n+      cond_stmt = gsi_stmt (gsi);\n+      if (!is_gimple_assign (cond_stmt))\n+\treturn false;\n+      if (gimple_assign_rhs_code (cond_stmt) == EQ_EXPR)\n+\t{\n+\t  gsi_prev_nondebug (&gsi);\n+\t  if (!gsi_end_p (gsi))\n+\t    {\n+\t      vce_stmt = gsi_stmt (gsi);\n+\t      if (!is_gimple_assign (vce_stmt)\n+\t\t  || gimple_assign_rhs_code (vce_stmt) != VIEW_CONVERT_EXPR)\n+\t\treturn false;\n+\t    }\n+\t}\n+      else if (gimple_assign_rhs_code (cond_stmt) == VIEW_CONVERT_EXPR)\n+\tstd::swap (vce_stmt, cond_stmt);\n+      else\n+\treturn false;\n+      if (vce_stmt)\n+\t{\n+\t  tree vce_rhs = gimple_assign_rhs1 (vce_stmt);\n+\t  if (TREE_CODE (vce_rhs) != VIEW_CONVERT_EXPR\n+\t      || !operand_equal_p (TREE_OPERAND (vce_rhs, 0), loaded_val))\n+\t    return false;\n+\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (vce_rhs))\n+\t      || !SCALAR_FLOAT_TYPE_P (TREE_TYPE (loaded_val))\n+\t      || !tree_int_cst_equal (TYPE_SIZE (TREE_TYPE (vce_rhs)),\n+\t\t\t\t      TYPE_SIZE (TREE_TYPE (loaded_val))))\n+\t    return false;\n+\t  gsi_prev_nondebug (&gsi);\n+\t  if (!gsi_end_p (gsi))\n+\t    return false;\n+\t}\n+    }\n+  tree cond = gimple_assign_rhs1 (condexpr_stmt);\n+  tree cond_op1, cond_op2;\n+  if (cond_stmt)\n+    {\n+      if (!operand_equal_p (cond, gimple_assign_lhs (cond_stmt)))\n+\treturn false;\n+      cond_op1 = gimple_assign_rhs1 (cond_stmt);\n+      cond_op2 = gimple_assign_rhs2 (cond_stmt);\n+    }\n+  else if (TREE_CODE (cond) != EQ_EXPR && TREE_CODE (cond) != NE_EXPR)\n+    return false;\n+  else\n+    {\n+      cond_op1 = TREE_OPERAND (cond, 0);\n+      cond_op2 = TREE_OPERAND (cond, 1);\n+    }\n+  tree d;\n+  if (TREE_CODE (cond) == NE_EXPR)\n+    {\n+      if (!operand_equal_p (gimple_assign_rhs2 (condexpr_stmt), loaded_val))\n+\treturn false;\n+      d = gimple_assign_rhs3 (condexpr_stmt);\n+    }\n+  else if (!operand_equal_p (gimple_assign_rhs3 (condexpr_stmt), loaded_val))\n+    return false;\n+  else\n+    d = gimple_assign_rhs2 (condexpr_stmt);\n+  tree e = vce_stmt ? gimple_assign_lhs (vce_stmt) : loaded_val;\n+  if (operand_equal_p (e, cond_op1))\n+    e = cond_op2;\n+  else if (operand_equal_p (e, cond_op2))\n+    e = cond_op1;\n+  else\n+    return false;\n+\n+  location_t loc = gimple_location (store_stmt);\n+  gimple *load_stmt = last_stmt (load_bb);\n+  bool need_new = gimple_omp_atomic_need_value_p (store_stmt);\n+  bool need_old = gimple_omp_atomic_need_value_p (load_stmt);\n+  bool weak = gimple_omp_atomic_weak_p (load_stmt);\n+  enum omp_memory_order omo = gimple_omp_atomic_memory_order (load_stmt);\n+  tree mo = build_int_cst (NULL, omp_memory_order_to_memmodel (omo));\n+  tree fmo = build_int_cst (NULL, omp_memory_order_to_fail_memmodel (omo));\n+  gcc_checking_assert (!need_old || !need_new);\n+\n+  enum built_in_function fncode\n+    = (enum built_in_function) ((int) BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_N\n+\t\t\t\t+ index + 1);\n+  tree cmpxchg = builtin_decl_explicit (fncode);\n+  if (cmpxchg == NULL_TREE)\n+    return false;\n+  tree itype = TREE_TYPE (TREE_TYPE (cmpxchg));\n+\n+  if (!can_compare_and_swap_p (TYPE_MODE (itype), true)\n+      || !can_atomic_load_p (TYPE_MODE (itype)))\n+    return false;\n+\n+  tree type = TYPE_MAIN_VARIANT (TREE_TYPE (loaded_val));\n+  if (SCALAR_FLOAT_TYPE_P (type) && !vce_stmt)\n+    return false;\n+\n+  gsi = gsi_for_stmt (store_stmt);\n+  if (!useless_type_conversion_p (itype, TREE_TYPE (e)))\n+    {\n+      tree ne = create_tmp_reg (itype);\n+      gimple *g = gimple_build_assign (ne, NOP_EXPR, e);\n+      gimple_set_location (g, loc);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      e = ne;\n+    }\n+  if (!useless_type_conversion_p (itype, TREE_TYPE (d)))\n+    {\n+      tree nd = create_tmp_reg (itype);\n+      enum tree_code code;\n+      if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (d)))\n+\t{\n+\t  code = VIEW_CONVERT_EXPR;\n+\t  d = build1 (VIEW_CONVERT_EXPR, itype, d);\n+\t}\n+      else\n+\tcode = NOP_EXPR;\n+      gimple *g = gimple_build_assign (nd, code, d);\n+      gimple_set_location (g, loc);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      d = nd;\n+    }\n+\n+  tree ctype = build_complex_type (itype);\n+  int flag = int_size_in_bytes (itype) + (weak ? 256 : 0);\n+  gimple *g\n+    = gimple_build_call_internal (IFN_ATOMIC_COMPARE_EXCHANGE, 6, addr, e, d,\n+\t\t\t\t  build_int_cst (integer_type_node, flag),\n+\t\t\t\t  mo, fmo);\n+  tree cres = create_tmp_reg (ctype);\n+  gimple_call_set_lhs (g, cres);\n+  gimple_set_location (g, loc);\n+  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\n+  if (cond_stmt || need_old || need_new)\n+    {\n+      tree im = create_tmp_reg (itype);\n+      g = gimple_build_assign (im, IMAGPART_EXPR,\n+\t\t\t       build1 (IMAGPART_EXPR, itype, cres));\n+      gimple_set_location (g, loc);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\n+      tree re = NULL_TREE;\n+      if (need_old || need_new)\n+\t{\n+\t  re = create_tmp_reg (itype);\n+\t  g = gimple_build_assign (re, REALPART_EXPR,\n+\t\t\t\t   build1 (REALPART_EXPR, itype, cres));\n+\t  gimple_set_location (g, loc);\n+\t  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t}\n+\n+      if (cond_stmt)\n+\t{\n+\t  g = gimple_build_assign (gimple_assign_lhs (cond_stmt),\n+\t\t\t\t   NOP_EXPR, im);\n+\t  gimple_set_location (g, loc);\n+\t  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t}\n+      else if (need_new)\n+\t{\n+\t  g = gimple_build_assign (create_tmp_reg (itype), COND_EXPR,\n+\t\t\t\t   build2 (NE_EXPR, boolean_type_node,\n+\t\t\t\t\t   im, build_zero_cst (itype)),\n+\t\t\t\t   d, re);\n+\t  gimple_set_location (g, loc);\n+\t  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t  re = gimple_assign_lhs (g);\n+\t}\n+\n+      if (need_old || need_new)\n+\t{\n+\t  tree v = need_old ? loaded_val : stored_val;\n+\t  enum tree_code code;\n+\t  if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (v)))\n+\t    {\n+\t      code = VIEW_CONVERT_EXPR;\n+\t      re = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (v), re);\n+\t    }\n+\t  else if (!useless_type_conversion_p (TREE_TYPE (v), itype))\n+\t    code = NOP_EXPR;\n+\t  else\n+\t    code = TREE_CODE (re);\n+\t  g = gimple_build_assign (v, code, re);\n+\t  gimple_set_location (g, loc);\n+\t  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t}\n+    }\n+\n+  gsi_remove (&gsi, true);\n+  gsi = gsi_for_stmt (load_stmt);\n+  gsi_remove (&gsi, true);\n+  gsi = gsi_for_stmt (condexpr_stmt);\n+  gsi_remove (&gsi, true);\n+  if (cond_stmt)\n+    {\n+      gsi = gsi_for_stmt (cond_stmt);\n+      gsi_remove (&gsi, true);\n+    }\n+  if (vce_stmt)\n+    {\n+      gsi = gsi_for_stmt (vce_stmt);\n+      gsi_remove (&gsi, true);\n+    }\n+\n+  return true;\n+}\n+\n /* A subroutine of expand_omp_atomic.  Implement the atomic operation as:\n \n       oldval = *addr;\n@@ -8825,13 +9116,8 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n   gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_ATOMIC_LOAD);\n   location_t loc = gimple_location (gsi_stmt (si));\n   enum omp_memory_order omo = gimple_omp_atomic_memory_order (gsi_stmt (si));\n-  enum memmodel imo = omp_memory_order_to_memmodel (omo);\n-  tree mo = build_int_cst (NULL, imo);\n-  if (imo == MEMMODEL_RELEASE)\n-    imo = MEMMODEL_RELAXED;\n-  else if (imo == MEMMODEL_ACQ_REL)\n-    imo = MEMMODEL_ACQUIRE;\n-  tree fmo = build_int_cst (NULL, imo);\n+  tree mo = build_int_cst (NULL, omp_memory_order_to_memmodel (omo));\n+  tree fmo = build_int_cst (NULL, omp_memory_order_to_fail_memmodel (omo));\n \n   /* For floating-point values, we'll need to view-convert them to integers\n      so that we can perform the atomic compare and swap.  Simplify the\n@@ -9114,6 +9400,13 @@ expand_omp_atomic (struct omp_region *region)\n \t\t\t\t\t     loaded_val, stored_val, index))\n \t    return;\n \n+\t  /* When possible, use ATOMIC_COMPARE_EXCHANGE ifn without a loop.  */\n+\t  if (store_bb == single_succ (load_bb)\n+\t      && !gimple_in_ssa_p (cfun)\n+\t      && expand_omp_atomic_cas (load_bb, addr, loaded_val, stored_val,\n+\t\t\t\t\tindex))\n+\t    return;\n+\n \t  /* If we don't have specialized __sync builtins, try and implement\n \t     as a compare and swap loop.  */\n \t  if (expand_omp_atomic_pipeline (load_bb, store_bb, addr,"}, {"sha": "e1ab03e5b559f448d6c95baf5cfd32fb507cfb8b", "filename": "gcc/testsuite/c-c++-common/goacc-gomp/atomic.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fatomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fatomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fatomic.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -37,7 +37,8 @@ foo ()\n \n /* { dg-final { scan-tree-dump-times \"i = #pragma omp atomic read acquire\" 1 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"i = #pragma omp atomic read relaxed\" 1 \"original\" } } */\n-/* { dg-final { scan-tree-dump-times \"#pragma omp atomic release\" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"#pragma omp atomic acq_rel\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"#pragma omp atomic release\" 1 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"#pragma omp atomic relaxed\" 2 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"v = #pragma omp atomic capture acq_rel\" 1  \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"v = #pragma omp atomic capture relaxed\" 2 \"original\" } } */"}, {"sha": "001887eab15be8f029963d02121dda9dcf3a509f", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-17.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-17.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -22,8 +22,18 @@ foo ()\n   v = i = i + 1;\n   #pragma omp atomic read acquire\n   v = i;\n+  #pragma omp atomic acq_rel read\n+  v = i;\n   #pragma omp atomic release,write\n   i = v;\n+  #pragma omp atomic write,acq_rel\n+  i = v;\n   #pragma omp atomic hint(1),update,release\n   f = f + 2.0;\n+  #pragma omp atomic update ,acquire\n+  i = i + 1;\n+  #pragma omp atomic acq_rel update\n+  i = i + 1;\n+  #pragma omp atomic acq_rel,hint(0)\n+  i = i + 1;\n }"}, {"sha": "b389c6a0df8e35b779c1ef4bdf1b9aac652a2c66", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-18.c", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-18.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -8,28 +8,18 @@ foo (int j)\n   i = i + 1;\n   #pragma omp atomic seq_cst release\t/* { dg-error \"too many memory order clauses\" } */\n   i = i + 1;\n-  #pragma omp atomic read,release\t/* { dg-error \"incompatible with 'acq_rel' or 'release' clauses\" } */\n+  #pragma omp atomic read,release\t/* { dg-error \"incompatible with 'release' clause\" } */\n   v = i;\n-  #pragma omp atomic acq_rel read\t/* { dg-error \"incompatible with 'acq_rel' or 'release' clauses\" } */\n-  v = i;\n-  #pragma omp atomic write acq_rel\t/* { dg-error \"incompatible with 'acq_rel' or 'acquire' clauses\" } */\n-  i = v;\n-  #pragma omp atomic acquire , write\t/* { dg-error \"incompatible with 'acq_rel' or 'acquire' clauses\" } */\n+  #pragma omp atomic acquire , write\t/* { dg-error \"incompatible with 'acquire' clause\" } */\n   i = v;\n-  #pragma omp atomic update ,acquire\t/* { dg-error \"incompatible with 'acq_rel' or 'acquire' clauses\" } */\n-  i = i + 1;\n-  #pragma omp atomic acq_rel update\t/* { dg-error \"incompatible with 'acq_rel' or 'acquire' clauses\" } */\n-  i = i + 1;\n-  #pragma omp atomic acq_rel,hint(0)\t/* { dg-error \"incompatible with 'acq_rel' or 'acquire' clauses\" } */\n-  i = i + 1;\n-  #pragma omp atomic acquire\t\t/* { dg-error \"incompatible with 'acq_rel' or 'acquire' clauses\" } */\n-  i = i + 1;\n-  #pragma omp atomic capture hint (0) capture\t/* { dg-error \"too many atomic clauses\" } */\n+  #pragma omp atomic capture hint (0) capture\t/* { dg-error \"too many 'capture' clauses\" \"\" { target c } } */\n+\t\t\t\t\t/* { dg-error \"too many atomic clauses\" \"\" { target c++ } .-1 } */\n   v = i = i + 1;\n   #pragma omp atomic hint(j + 2)\t/* { dg-error \"constant integer expression\" } */\n   i = i + 1;\n   #pragma omp atomic hint(f)\t\t/* { dg-error \"integ\" } */\n   i = i + 1;\n-  #pragma omp atomic foobar\t\t/* { dg-error \"expected 'read', 'write', 'update', 'capture', 'seq_cst', 'acq_rel', 'release', 'relaxed' or 'hint' clause\" } */\n-  i = i + 1;\t\t\t\t/* { dg-error \"expected end of line before\" \"\" { target *-*-* } .-1 } */\n+  #pragma omp atomic foobar\t\t/* { dg-error \"expected 'read', 'write', 'update', 'capture', 'compare', 'weak', 'fail', 'seq_cst', 'acq_rel', 'release', 'relaxed' or 'hint' clause\" \"\" { target c } } */\n+\t\t\t\t\t/* { dg-error \"expected 'read', 'write', 'update', 'capture', 'seq_cst', 'acq_rel', 'release', 'relaxed' or 'hint' clause\" \"\" { target c++ } .-1 } */\n+  i = i + 1;\t\t\t\t/* { dg-error \"expected end of line before\" \"\" { target *-*-* } .-2 } */\n }"}, {"sha": "12b1237bad2a8d10b7b7a13426a1cb03e5f5e0ca", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-21.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-21.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -1,6 +1,7 @@\n /* { dg-do compile } */\n /* { dg-additional-options \"-fdump-tree-original\" } */\n-/* { dg-final { scan-tree-dump-times \"omp atomic release\" 4 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"omp atomic release\" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"omp atomic acq_rel\" 2 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"omp atomic read acquire\" 1 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"omp atomic capture acq_rel\" 1 \"original\" } } */\n "}, {"sha": "a5196a5e305181ac22fd11be5ef0182dc758a3db", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-25.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-25.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do compile { target c } } */\n+\n+int x, r, z;\n+double d, v;\n+long double ld;\n+\n+void\n+foo (int y, double e, long double f)\n+{\n+  #pragma omp atomic compare update seq_cst\n+  x = x > y ? y : x;\n+  #pragma omp atomic compare relaxed\n+  d = e > d ? e : d;\n+  #pragma omp atomic compare\n+  d = f < d ? f : d;\n+  #pragma omp atomic compare seq_cst fail(relaxed)\n+  x = 12U < x ? 12U : x;\n+  #pragma omp atomic compare\n+  x = x == 7 ? 24 : x;\n+  #pragma omp atomic compare\n+  x = x == 123UL ? 256LL : x;\n+  #pragma omp atomic compare\n+  ld = ld == f ? f + 5.0L : ld;\n+  #pragma omp atomic compare\n+  if (x == 9) { x = 5; }\n+  #pragma omp atomic compare\n+  if (x > 5) { x = 5; }\n+  #pragma omp atomic compare\n+  if (7 > x) { x = 7; }\n+  #pragma omp atomic compare update capture seq_cst fail(acquire)\n+  v = d = f > d ? f : d;\n+  #pragma omp atomic update capture compare\n+  v = x = x < 24ULL ? 24ULL : x;\n+  #pragma omp atomic compare, capture, update\n+  v = x = x == e ? f : x;\n+  #pragma omp atomic capture compare\n+  { v = d; if (d > e) { d = e; } }\n+  #pragma omp atomic compare capture\n+  { if (e < d) { d = e; } v = d; }\n+  #pragma omp atomic compare capture\n+  { y = x; if (x == 42) { x = 7; } }\n+  #pragma omp atomic capture compare weak\n+  { if (x == 42) { x = 7; } y = x; }\n+  #pragma omp atomic capture compare fail(seq_cst)\n+  if (d == 8.0) { d = 16.0; } else { v = d; }\n+  #pragma omp atomic capture compare\n+  { r = x == 8; if (r) { x = 24; } }\n+  #pragma omp atomic compare capture\n+  { r = x == y; if (r) { x = y + 6; } else { z = x; } }\n+}"}, {"sha": "c7e65db09241c135a8d62fe954d99de51204436b", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-26.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-26.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile { target c } } */\n+\n+int x;\n+double d;\n+\n+double\n+foo (int y, double e, long double f)\n+{\n+  double v;\n+  #pragma omp atomic compare compare\t/* { dg-error \"too many 'compare' clauses\" } */\n+  x = x > y ? y : x;\n+  #pragma omp atomic compare fail(seq_cst) fail(seq_cst)\t/* { dg-error \"too many 'fail' clauses\" } */\n+  d = e > d ? e : d;\n+  #pragma omp atomic compare,fail(seq_cst),fail(relaxed)\t/* { dg-error \"too many 'fail' clauses\" } */\n+  d = e > d ? e : d;\n+  #pragma omp atomic compare weak weak\t/* { dg-error \"too many 'weak' clauses\" } */\n+  d = d == e ? e + 1.0 : d;\n+  #pragma omp atomic read capture\t/* { dg-error \"'capture' clause is incompatible with 'read' or 'write' clauses\" } */\n+  v = d;\n+  #pragma omp atomic capture, write\t/* { dg-error \"'capture' clause is incompatible with 'read' or 'write' clauses\" } */\n+  d = v;\n+  #pragma omp atomic read compare\t/* { dg-error \"'compare' clause is incompatible with 'read' or 'write' clauses\" } */\n+  v = d;\n+  #pragma omp atomic compare, write\t/* { dg-error \"'compare' clause is incompatible with 'read' or 'write' clauses\" } */\n+  d = v;\n+  #pragma omp atomic read fail(seq_cst)\t/* { dg-error \"'fail' clause requires 'compare' clause\" } */\n+  v = d;\n+  #pragma omp atomic fail(relaxed), write\t/* { dg-error \"'fail' clause requires 'compare' clause\" } */\n+  d = v;\n+  #pragma omp atomic fail(relaxed) update\t/* { dg-error \"'fail' clause requires 'compare' clause\" } */\n+  d += 3.0;\n+  #pragma omp atomic fail(relaxed)\t/* { dg-error \"'fail' clause requires 'compare' clause\" } */\n+  d += 3.0;\n+  #pragma omp atomic capture fail(relaxed)\t/* { dg-error \"'fail' clause requires 'compare' clause\" } */\n+  v = d += 3.0;\n+  #pragma omp atomic read weak\t\t/* { dg-error \"'weak' clause requires 'compare' clause\" } */\n+  v = d;\n+  #pragma omp atomic weak, write\t/* { dg-error \"'weak' clause requires 'compare' clause\" } */\n+  d = v;\n+  #pragma omp atomic weak update\t/* { dg-error \"'weak' clause requires 'compare' clause\" } */\n+  d += 3.0;\n+  #pragma omp atomic weak\t\t/* { dg-error \"'weak' clause requires 'compare' clause\" } */\n+  d += 3.0;\n+  #pragma omp atomic capture weak\t/* { dg-error \"'weak' clause requires 'compare' clause\" } */\n+  v = d += 3.0;\n+  #pragma omp atomic compare,weak\t/* { dg-error \"'weak' clause requires atomic equality comparison\" } */\n+  d = e > d ? e : d;\n+  #pragma omp atomic compare fail\t/* { dg-error \"expected '\\\\\\(' before end of line\" } */\n+  d = e > d ? e : d;\n+  #pragma omp atomic compare fail(\t/* { dg-error \"expected 'seq_cst', 'acquire' or 'relaxed' before end of line\" } */\n+  d = e > d ? e : d;\n+  #pragma omp atomic compare fail()\t/* { dg-error \"expected 'seq_cst', 'acquire' or 'relaxed' before '\\\\\\)' token\" } */\n+  d = e > d ? e : d;\n+  #pragma omp atomic compare fail(foobar)\t/* { dg-error \"expected 'seq_cst', 'acquire' or 'relaxed' before 'foobar'\" } */\n+  d = e > d ? e : d;\n+  #pragma omp atomic compare fail(acq_rel)\t/* { dg-error \"expected 'seq_cst', 'acquire' or 'relaxed' before 'acq_rel'\" } */\n+  d = e > d ? e : d;\n+  #pragma omp atomic compare fail(release)\t/* { dg-error \"expected 'seq_cst', 'acquire' or 'relaxed' before 'release'\" } */\n+  d = e > d ? e : d;\n+  #pragma omp atomic compare fail(seq_cst\t/* { dg-error \"expected '\\\\\\)' before end of line\" } */\n+  d = e > d ? e : d;\n+  return v;\n+}"}, {"sha": "3d6171740519746f9e54356ee56c767a1da325b7", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-27.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-27.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -0,0 +1,41 @@\n+/* PR middle-end/88968 */\n+/* { dg-do compile { target c } } */\n+\n+struct __attribute__((packed)) S {\n+  unsigned int a : 16;\n+  unsigned int b : 1;\n+} s;\n+\n+void\n+foo (int y, int z)\n+{\n+  #pragma omp atomic compare\n+  s.a = s.a == y ? z : s.a;\n+}\n+\n+int\n+bar (int y, int z)\n+{\n+  int r;\n+  #pragma omp atomic compare capture\n+  { r = s.a == y; if (r) { s.a = z; } }\n+  return r;\n+}\n+\n+int\n+baz (int y, int z)\n+{\n+  int v;\n+  #pragma omp atomic compare capture\n+  if (s.a == y) { s.a = z; } else { v = s.a; }\n+  return v;\n+}\n+\n+int\n+qux (int y, int z)\n+{\n+  int v;\n+  #pragma omp atomic compare capture\n+  v = s.a = s.a == y ? z : s.a;\n+  return v;\n+}"}, {"sha": "50cf22307a6cfb0cd9c68b4e29a9d0e7dae57720", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-28.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-28.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile { target c } } */\n+/* { dg-additional-options \"-O2 -fdump-tree-ompexp\" } */\n+/* { dg-final { scan-tree-dump-times \"\\.ATOMIC_COMPARE_EXCHANGE \\\\\\(\\[^\\n\\r]*, 4, 5, 5\\\\\\);\" 1 \"ompexp\" { target sync_int_long } } } */\n+/* { dg-final { scan-tree-dump-times \"\\.ATOMIC_COMPARE_EXCHANGE \\\\\\(\\[^\\n\\r]*, 4, 4, 2\\\\\\);\" 1 \"ompexp\" { target sync_int_long } } } */\n+/* { dg-final { scan-tree-dump-times \"\\.ATOMIC_COMPARE_EXCHANGE \\\\\\(\\[^\\n\\r]*, 260, 5, 0\\\\\\);\" 1 \"ompexp\" { target sync_int_long } } } */\n+/* { dg-final { scan-tree-dump-times \"\\.ATOMIC_COMPARE_EXCHANGE \\\\\\(\\[^\\n\\r]*, 4, 0, 0\\\\\\);\" 1 \"ompexp\" { target sync_int_long } } } */\n+/* { dg-final { scan-tree-dump-not \"__atomic_load_4 \\\\\\(\" \"ompexp\" { target sync_int_long } } } */\n+\n+int x;\n+\n+void\n+foo (int y, int z)\n+{\n+  #pragma omp atomic compare seq_cst\n+  x = x == y ? z : x;\n+}\n+\n+int\n+bar (int y, int z)\n+{\n+  int r;\n+  #pragma omp atomic compare capture acq_rel fail (acquire)\n+  { r = x == y; if (r) { x = z; } }\n+  return r;\n+}\n+\n+int\n+baz (int y, int z)\n+{\n+  int v;\n+  #pragma omp atomic compare capture seq_cst fail (relaxed) weak\n+  if (x == y) { x = z; } else { v = x; }\n+  return v;\n+}\n+\n+int\n+qux (int y, int z)\n+{\n+  int v;\n+  #pragma omp atomic compare capture\n+  v = x = x == y ? z : x;\n+  return v;\n+}"}, {"sha": "e574c48fd55494fcbc353828752100630d8ec1aa", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-29.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-29.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile { target c } } */\n+/* { dg-additional-options \"-O2 -fdump-tree-ompexp\" } */\n+/* { dg-final { scan-tree-dump-times \"\\.ATOMIC_COMPARE_EXCHANGE \\\\\\(\\[^\\n\\r]*, 8, 5, 5\\\\\\);\" 1 \"ompexp\" { target sync_int_long } } } */\n+/* { dg-final { scan-tree-dump-times \"\\.ATOMIC_COMPARE_EXCHANGE \\\\\\(\\[^\\n\\r]*, 8, 4, 2\\\\\\);\" 1 \"ompexp\" { target sync_int_long } } } */\n+/* { dg-final { scan-tree-dump-times \"\\.ATOMIC_COMPARE_EXCHANGE \\\\\\(\\[^\\n\\r]*, 264, 5, 0\\\\\\);\" 1 \"ompexp\" { target sync_int_long } } } */\n+/* { dg-final { scan-tree-dump-times \"\\.ATOMIC_COMPARE_EXCHANGE \\\\\\(\\[^\\n\\r]*, 8, 0, 0\\\\\\);\" 1 \"ompexp\" { target sync_int_long } } } */\n+/* { dg-final { scan-tree-dump-not \"__atomic_load_8 \\\\\\(\" \"ompexp\" { target sync_int_long } } } */\n+\n+double x;\n+\n+void\n+foo (double y, double z)\n+{\n+  #pragma omp atomic compare seq_cst\n+  x = x == y ? z : x;\n+}\n+\n+double\n+bar (double y, double z)\n+{\n+  int r;\n+  #pragma omp atomic compare capture acq_rel fail (acquire)\n+  { r = x == y; if (r) { x = z; } }\n+  return r;\n+}\n+\n+double\n+baz (double y, double z)\n+{\n+  double v;\n+  #pragma omp atomic compare capture seq_cst fail (relaxed) weak\n+  if (x == y) { x = z; } else { v = x; }\n+  return v;\n+}\n+\n+double\n+qux (double y, double z)\n+{\n+  double v;\n+  #pragma omp atomic compare capture\n+  v = x = x == y ? z : x;\n+  return v;\n+}"}, {"sha": "f36de7087798d956bbf1f37b0c6cbd527587104b", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-30.c", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-30.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -0,0 +1,137 @@\n+/* { dg-do compile { target c } } */\n+\n+int x;\n+double d, g;\n+\n+double\n+foo (int y, double e, long double f)\n+{\n+  double v;\n+  int r, r2 = 0;\n+  #pragma omp atomic capture compare\n+  v = if (d == e) { d = f; };\t/* { dg-error \"expected expression\" } */\n+  #pragma omp atomic compare\n+  if;\t\t\t\t/* { dg-error \"expected '\\\\\\(' before ';' token\" } */\n+  #pragma omp atomic compare\n+  if (d >= e) { d = e; }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" } */\n+  #pragma omp atomic compare\n+  if (d <= e) { d = e; }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" } */\n+  #pragma omp atomic compare\n+  if (d != e) { d = e; }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" } */\n+  #pragma omp atomic compare\n+  if (d + e) { d = e; }\t\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" } */\n+  #pragma omp atomic capture compare\n+  { r = d >= e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" } */\n+  #pragma omp atomic capture compare\n+  { r = d <= e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" } */\n+  #pragma omp atomic capture compare\n+  { r = d > e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" } */\n+  #pragma omp atomic capture compare\n+  { r = d < e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" } */\n+  #pragma omp atomic capture compare\n+  { r = d != e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" } */\n+  #pragma omp atomic capture compare\n+  { r = d + e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" } */\n+  #pragma omp atomic capture compare\n+  { r = d == e; if (r2) { d = f; } }\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before '\\{' token\" } */\n+  #pragma omp atomic capture compare\n+  if (d > e) { d = e; }\t\t\t/* { dg-error \"expected '==' comparison in 'if' condition\" } */\n+  #pragma omp atomic capture compare\n+  if (d < e) { d = e; }\t\t\t/* { dg-error \"expected '==' comparison in 'if' condition\" } */\n+  #pragma omp atomic compare\n+  if (d < e) d = e;\t\t\t/* { dg-error \"expected '\\{' before 'd'\" } */\n+  #pragma omp atomic compare\n+  if (d == e) d = e + 1.0;\t\t/* { dg-error \"expected '\\{' before 'd'\" } */\n+  #pragma omp atomic compare\n+  if (d < e) { d += e; }\t\t/* { dg-error \"expected '=' before '\\\\\\+=' token\" } */\n+  #pragma omp atomic compare\n+  if (d < e) { d = e };\t\t\t/* { dg-error \"expected ';' before '\\}' token\" } */\n+  #pragma omp atomic compare\n+  if (d < e) { d = e; e = 1.0; }\t/* { dg-error \"expected '\\}' before 'e'\" } */\n+  #pragma omp atomic compare\n+  if (e == d) { d = f; };\t\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before ';' token\" } */\n+  #pragma omp atomic compare\n+  if (e == d) { g = f; };\t\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before ';' token\" } */\n+  #pragma omp atomic compare\n+  if (d < e) { g = e; };\t\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before ';' token\" } */\n+  #pragma omp atomic compare\n+  if (d > e) { g = e; };\t\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before ';' token\" } */\n+  #pragma omp atomic compare\n+  if (d < e) { d = g; };\t\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before ';' token\" } */\n+  #pragma omp atomic compare\n+  if (d > e) { d = g; };\t\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before ';' token\" } */\n+  #pragma omp atomic compare\n+  if (d == e) { d = f; } else ;\t\t/* { dg-error \"unexpected 'else'\" } */\n+  #pragma omp atomic compare capture\n+  { if (d == e) { d = f; } else { v = d; } v = d; }\t\t/* { dg-error \"unexpected 'else'\" } */\n+  #pragma omp atomic compare\n+  if (d < e) { d = e; } else { v = d; }\t/* { dg-error \"unexpected 'else'\" } */\n+  #pragma omp atomic compare capture\n+  if (d == e) { d = f; } else v = d;\t/* { dg-error \"expected '\\{' before 'v'\" } */\n+  #pragma omp atomic compare capture\n+  if (d == e) { d = f; } else { v += d;\t}\t/* { dg-error \"expected '=' before '\\\\\\+=' token\" } */\n+  #pragma omp atomic compare capture\n+  if (d == e) { d = f; } else { v = e; }\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before ';' token\" } */\n+  #pragma omp atomic compare capture\n+  if (d == e) { d = f; } else { v = d };\t/* { dg-error \"expected ';' before '\\}' token\" } */\n+  #pragma omp atomic compare capture\n+  if (d == e) { d = f; };\t\t/* { dg-error \"expected 'else' before ';' token\" } */\n+  #pragma omp atomic compare\n+  x++;\t\t\t\t\t/* { dg-error \"invalid form of 'pragma omp atomic compare'\" } */\n+  #pragma omp atomic compare\n+  x--;\t\t\t\t\t/* { dg-error \"invalid form of 'pragma omp atomic compare'\" } */\n+  #pragma omp atomic compare\n+  ++x;\t\t\t\t\t/* { dg-error \"invalid form of 'pragma omp atomic compare'\" } */\n+  #pragma omp atomic compare\n+  --x;\t\t\t\t\t/* { dg-error \"invalid form of 'pragma omp atomic compare'\" } */\n+  #pragma omp atomic compare\n+  x += 3;\t\t\t\t/* { dg-error \"expected '=' before '\\\\\\+=' token\" } */\n+  #pragma omp atomic compare\n+  x -= 5;\t\t\t\t/* { dg-error \"expected '=' before '-=' token\" } */\n+  #pragma omp atomic compare\n+  x *= 2;\t\t\t\t/* { dg-error \"expected '=' before '\\\\\\*=' token\" } */\n+  #pragma omp atomic compare\n+  x |= 5;\t\t\t\t/* { dg-error \"expected '=' before '\\\\\\|=' token\" } */\n+  #pragma omp atomic compare\n+  x &= ~5;\t\t\t\t/* { dg-error \"expected '=' before '\\\\\\&=' token\" } */\n+  #pragma omp atomic compare\n+  x ^= 5;\t\t\t\t/* { dg-error \"expected '=' before '\\\\\\^=' token\" } */\n+  #pragma omp atomic compare\n+  x = x + 3;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n+  #pragma omp atomic compare\n+  x = x - 5;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n+  #pragma omp atomic compare\n+  x = 2 * x;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n+  #pragma omp atomic compare\n+  x = 5 | x;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n+  #pragma omp atomic compare\n+  x = x & ~5;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n+  #pragma omp atomic compare\n+  x = x | 5;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n+  #pragma omp atomic compare\n+  x = x >= 5 ? 5 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n+  #pragma omp atomic compare\n+  x = x <= 5 ? 5 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n+  #pragma omp atomic compare\n+  x = x != 5 ? 7 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n+  #pragma omp atomic compare\n+  x = 5 == x ? 7 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n+  #pragma omp atomic compare\n+  x = x == 5 ? x : 7;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n+  #pragma omp atomic compare\n+  x = x == 5 ? 9 : 7;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n+  #pragma omp atomic compare\n+  x = x > 5 ? 6 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n+  #pragma omp atomic compare\n+  x = x < 5 ? 6 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n+  #pragma omp atomic compare\n+  x = x > 5 ? x : 6;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n+  #pragma omp atomic compare\n+  x = x < 5 ? x : 6;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n+  #pragma omp atomic capture\n+  r = x == 5;\t\t\t\t/* { dg-error \"invalid operator for '#pragma omp atomic' before '==' token\" } */\n+  #pragma omp atomic capture compare\n+  r = x == 5;\t\t\t\t/* { dg-error \"expected '=' before '==' token\" } */\n+  #pragma omp atomic capture compare\t/* { dg-error \"'#pragma omp atomic compare capture' with non-integral comparison result\" } */\n+  { v = x == 5; if (v) { x = 6; } }\n+}"}, {"sha": "adaee849a4cfc0a2d2ea9c6374a4177d8ed21aaf", "filename": "gcc/testsuite/g++.dg/gomp/atomic-18.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-18.C?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -1,6 +1,7 @@\n // { dg-do compile }\n // { dg-additional-options \"-fdump-tree-original\" }\n-// { dg-final { scan-tree-dump-times \"omp atomic release\" 5 \"original\" } }\n+// { dg-final { scan-tree-dump-times \"omp atomic release\" 4 \"original\" } }\n+// { dg-final { scan-tree-dump-times \"omp atomic acq_rel\" 1 \"original\" } }\n // { dg-final { scan-tree-dump-times \"omp atomic seq_cst\" 1 \"original\" } }\n // { dg-final { scan-tree-dump-times \"omp atomic relaxed\" 2 \"original\" } }\n // { dg-final { scan-tree-dump-times \"omp atomic capture acq_rel\" 3 \"original\" } }"}, {"sha": "36d142266e8cf574d4a5460e2f245496205b4e9a", "filename": "gcc/testsuite/gcc.dg/gomp/atomic-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-5.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -27,7 +27,7 @@ void f1(void)\n   #pragma omp atomic\n     bar() += 1;\t\t/* { dg-error \"lvalue required\" } */\n   #pragma omp atomic a\t/* { dg-error \"expected end of line\" } */\n-    x++;\t\t/* { dg-error \"expected 'read', 'write', 'update', 'capture', 'seq_cst', 'acq_rel', 'release', 'relaxed' or 'hint' clause\" \"\" { target *-*-* } .-1 } */\n+    x++;\t\t/* { dg-error \"expected 'read', 'write', 'update', 'capture', 'compare', 'weak', 'fail', 'seq_cst', 'acq_rel', 'release', 'relaxed' or 'hint' clause\" \"\" { target *-*-* } .-1 } */\n   #pragma omp atomic\n     ;\t\t\t/* { dg-error \"expected expression\" } */\n   #pragma omp atomic"}, {"sha": "d3d2a8d812f17c19dbd3d2d615315884cc154cfb", "filename": "gcc/tree-core.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -583,8 +583,17 @@ enum omp_memory_order {\n   OMP_MEMORY_ORDER_ACQUIRE,\n   OMP_MEMORY_ORDER_RELEASE,\n   OMP_MEMORY_ORDER_ACQ_REL,\n-  OMP_MEMORY_ORDER_SEQ_CST\n-};\n+  OMP_MEMORY_ORDER_SEQ_CST,\n+  OMP_MEMORY_ORDER_MASK = 7,\n+  OMP_FAIL_MEMORY_ORDER_UNSPECIFIED = OMP_MEMORY_ORDER_UNSPECIFIED * 8,\n+  OMP_FAIL_MEMORY_ORDER_RELAXED = OMP_MEMORY_ORDER_RELAXED * 8,\n+  OMP_FAIL_MEMORY_ORDER_ACQUIRE = OMP_MEMORY_ORDER_ACQUIRE * 8,\n+  OMP_FAIL_MEMORY_ORDER_RELEASE = OMP_MEMORY_ORDER_RELEASE * 8,\n+  OMP_FAIL_MEMORY_ORDER_ACQ_REL = OMP_MEMORY_ORDER_ACQ_REL * 8,\n+  OMP_FAIL_MEMORY_ORDER_SEQ_CST = OMP_MEMORY_ORDER_SEQ_CST * 8,\n+  OMP_FAIL_MEMORY_ORDER_MASK = OMP_MEMORY_ORDER_MASK * 8\n+};\n+#define OMP_FAIL_MEMORY_ORDER_SHIFT 3\n \n /* There is a TYPE_QUAL value for each type qualifier.  They can be\n    combined by bitwise-or to form the complete set of qualifiers for a"}, {"sha": "32225b8bca8bdb0b3ea56e805a5da2bc096aeee6", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -1492,7 +1492,7 @@ dump_block_node (pretty_printer *pp, tree block, int spc, dump_flags_t flags)\n void\n dump_omp_atomic_memory_order (pretty_printer *pp, enum omp_memory_order mo)\n {\n-  switch (mo)\n+  switch (mo & OMP_MEMORY_ORDER_MASK)\n     {\n     case OMP_MEMORY_ORDER_RELAXED:\n       pp_string (pp, \" relaxed\");\n@@ -1514,6 +1514,22 @@ dump_omp_atomic_memory_order (pretty_printer *pp, enum omp_memory_order mo)\n     default:\n       gcc_unreachable ();\n     }\n+  switch (mo & OMP_FAIL_MEMORY_ORDER_MASK)\n+    {\n+    case OMP_FAIL_MEMORY_ORDER_RELAXED:\n+      pp_string (pp, \" fail(relaxed)\");\n+      break;\n+    case OMP_FAIL_MEMORY_ORDER_SEQ_CST:\n+      pp_string (pp, \" fail(seq_cst)\");\n+      break;\n+    case OMP_FAIL_MEMORY_ORDER_ACQUIRE:\n+      pp_string (pp, \" fail(acquire)\");\n+      break;\n+    case OMP_FAIL_MEMORY_ORDER_UNSPECIFIED:\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n }\n \n /* Helper to dump a MEM_REF node.  */\n@@ -3629,6 +3645,8 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n \n     case OMP_ATOMIC:\n       pp_string (pp, \"#pragma omp atomic\");\n+      if (OMP_ATOMIC_WEAK (node))\n+\tpp_string (pp, \" weak\");\n       dump_omp_atomic_memory_order (pp, OMP_ATOMIC_MEMORY_ORDER (node));\n       newline_and_indent (pp, spc + 2);\n       dump_generic_node (pp, TREE_OPERAND (node, 0), spc, flags, false);\n@@ -3649,6 +3667,8 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n     case OMP_ATOMIC_CAPTURE_OLD:\n     case OMP_ATOMIC_CAPTURE_NEW:\n       pp_string (pp, \"#pragma omp atomic capture\");\n+      if (OMP_ATOMIC_WEAK (node))\n+\tpp_string (pp, \" weak\");\n       dump_omp_atomic_memory_order (pp, OMP_ATOMIC_MEMORY_ORDER (node));\n       newline_and_indent (pp, spc + 2);\n       dump_generic_node (pp, TREE_OPERAND (node, 0), spc, flags, false);"}, {"sha": "7274ba75f599ce0136f0c99ce6e14e4747d6a737", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -1529,6 +1529,11 @@ class auto_suppress_location_wrappers\n   (TREE_RANGE_CHECK (NODE, OMP_ATOMIC, \\\n \t\t     OMP_ATOMIC_CAPTURE_NEW)->base.u.omp_atomic_memory_order)\n \n+/* Weak clause on OMP_ATOMIC*.  */\n+#define OMP_ATOMIC_WEAK(NODE) \\\n+  (TREE_RANGE_CHECK (NODE, OMP_ATOMIC, \\\n+\t\t     OMP_ATOMIC_CAPTURE_NEW)->base.public_flag)\n+\n /* True on a PRIVATE clause if its decl is kept around for debugging\n    information only and its DECL_VALUE_EXPR is supposed to point\n    to what it has been remapped to.  */"}, {"sha": "3aee228a20ecd06d9789be5f07f85825605d1203", "filename": "libgomp/testsuite/libgomp.c-c++-common/atomic-19.c", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-19.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -0,0 +1,274 @@\n+// { dg-do run { target c } }\n+\n+extern\n+#ifdef __cplusplus\n+\"C\"\n+#endif\n+void abort (void);\n+int x = 6;\n+int w, y;\n+\n+int *\n+foo (void)\n+{\n+  if (w)\n+    abort ();\n+  return &y;\n+}\n+\n+int\n+main ()\n+{\n+  int v, r;\n+  #pragma omp atomic compare\n+  x = x > 8 ? 8 : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic compare\n+  x = x > 4 ? 4 : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 4)\n+    abort ();\n+  #pragma omp atomic compare capture\n+  v = x = x < 8 ? 8 : x;\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; x = x < 12 ? 12 : x; }\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; x = x < 4 ? 4 : x; }\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic write\n+  x = -32;\n+  #pragma omp atomic capture compare seq_cst fail(relaxed)\n+  { x = 12U < x ? 12U : x; v = x; }\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic compare\n+  x = x == 12 ? 16 : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16)\n+    abort ();\n+  r = 57;\n+  #pragma omp atomic compare capture\n+  v = x = x == 15 ? r + 7 : x;\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic capture, update, compare seq_cst fail(acquire)\n+  { v = x; x = x == 73ULL - r ? 12LL : x; }\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic update, compare, capture\n+  { x = x == 69LL - r ? (unsigned char) 6 : x; v = x; }\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x > 8) { x = 8; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x > 4) { x = 4; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 4)\n+    abort ();\n+  #pragma omp atomic compare capture\n+  { if (x < 8) { x = 8; } v = x; }\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; if (x < 12) { x = 12; } }\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; if (x < 4) { x = 4; } }\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic write\n+  x = -32;\n+  #pragma omp atomic capture compare seq_cst fail(relaxed)\n+  { if (12U < x) { x = 12U; } v = x; }\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x == 12) { x = 16; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16)\n+    abort ();\n+  r = 57;\n+  #pragma omp atomic compare capture\n+  { if (x == 15) { x = r + 7; } v = x; }\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic capture, update, compare seq_cst fail(acquire)\n+  { v = x; if (x == 73ULL - r) { x = 12LL; } }\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic update, compare, capture\n+  { if (x == 69LL - r) { x = (unsigned char) 6; } v = x; }\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  v = 24;\n+  #pragma omp atomic compare capture\n+  if (x == 12) { x = 16; } else { v = x; }\n+  if (v != 6)\n+    abort ();\n+  v = 32;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  v = 147;\n+  #pragma omp atomic capture compare\n+  if (x == 6) { x = 57; } else { v = x; }\n+  if (v != 147)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 57)\n+    abort ();\n+  #pragma omp atomic update, capture, compare, weak, seq_cst, fail (relaxed)\n+  { r = x == 137; if (r) { x = 174; } }\n+  if (r)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 57)\n+    abort ();\n+  #pragma omp atomic compare capture fail (relaxed)\n+  { r = x == 57; if (r) { x = 6; } }\n+  if (r != 1)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  v = -5;\n+  #pragma omp atomic capture compare\n+  { r = x == 17; if (r) { x = 25; } else { v = x; } }\n+  if (r || v != 6)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  v = 15;\n+  #pragma omp atomic capture compare\n+  { r = x == 6; if (r) { x = 23; } else { v = x; } }\n+  if (r != 1 || v != 15)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 23)\n+    abort ();\n+  w = 1;\n+  #pragma omp atomic compare capture\n+  if (x == 23) { x = 57; } else { foo ()[0] = x; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 57)\n+    abort ();\n+  #pragma omp atomic capture update compare\n+  { r = x == 57; if (r) { x = 23; } else { foo ()[0] = x; } }\n+  if (r != 1)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 23)\n+    abort ();\n+  w = 0;\n+  #pragma omp atomic compare capture\n+  if (x == 24) { x = 57; } else { foo ()[0] = x; }\n+  if (y != 23)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 23)\n+    abort ();\n+  y = -5;\n+  #pragma omp atomic capture update compare\n+  {\n+    r = x == 57;\n+    if (r)\n+      {\n+\tx = 27;\n+      }\n+    else\n+      {\n+\tfoo ()[0] = x;\n+      }\n+  }\n+  if (r || y != 23)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 23)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "571a714238dc7eb19d1a025598e9049dbb1ee2b7", "filename": "libgomp/testsuite/libgomp.c-c++-common/atomic-20.c", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-20.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -0,0 +1,203 @@\n+// { dg-do run { target c } }\n+\n+extern\n+#ifdef __cplusplus\n+\"C\"\n+#endif\n+void abort (void);\n+float x = 6.0f;\n+\n+int\n+main ()\n+{\n+  float v;\n+  int r;\n+  #pragma omp atomic compare\n+  x = x > 8.0f ? 8.0f : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  #pragma omp atomic compare\n+  x = x > 4.0f ? 4.0f : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 4.0f)\n+    abort ();\n+  #pragma omp atomic compare capture\n+  v = x = x < 8.0f ? 8.0f : x;\n+  if (v != 8.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; x = x < 12.0f ? 12.0f : x; }\n+  if (v != 8.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; x = x < 4.0f ? 4.0f : x; }\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic compare\n+  x = x == 12.0 ? 16.0L : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16.0)\n+    abort ();\n+  r = 57;\n+  #pragma omp atomic compare capture\n+  v = x = x == 15.0f ? r + 7.0f : x;\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic capture, update, compare seq_cst fail(acquire)\n+  { v = x; x = x == 73.0L - r ? 12.0f : x; }\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic update, compare, capture\n+  { x = x == 69.0 - r ? 6.0f : x; v = x; }\n+  if (v != 6.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x > 8.0f) { x = 8.0f; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x > 4.0) { x = 4.0; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 4.0f)\n+    abort ();\n+  #pragma omp atomic compare capture\n+  { if (x < 8.0f) { x = 8.0f; } v = x; }\n+  if (v != 8.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 8.0f)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; if (x < 12.0f) { x = 12.0f; } }\n+  if (v != 8.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; if (x < 4.0L) { x = 4.0L; } }\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x == 12.0f) { x = 16.0L; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16.0f)\n+    abort ();\n+  r = 57.0;\n+  #pragma omp atomic compare capture\n+  { if (x == 15.0f) { x = r + 7.0f; } v = x; }\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic capture, update, compare seq_cst fail(acquire)\n+  { v = x; if (x == 73.0L - r) { x = 12.0L; } }\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic update, compare, capture\n+  { if (x == 69.0L - r) { x = 6.0; } v = x; }\n+  if (v != 6.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  v = 24;\n+  #pragma omp atomic compare capture\n+  if (x == 12.0f) { x = 16.0f; } else { v = x; }\n+  if (v != 6.0f)\n+    abort ();\n+  v = 32.0f;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  v = 147.0f;\n+  #pragma omp atomic capture compare\n+  if (x == 6.0f) { x = 57.0f; } else { v = x; }\n+  if (v != 147.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 57.0f)\n+    abort ();\n+  #pragma omp atomic update, capture, compare, weak, seq_cst, fail (relaxed)\n+  { r = x == 137.0f; if (r) { x = 174.0f; } }\n+  if (r)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 57.0f)\n+    abort ();\n+  #pragma omp atomic compare capture fail (relaxed)\n+  { r = x == 57.0f; if (r) { x = 6.0f; } }\n+  if (r != 1)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  v = -5.0f;\n+  #pragma omp atomic capture compare\n+  { r = x == 17.0L; if (r) { x = 25.0; } else { v = x; } }\n+  if (r || v != 6.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  v = 15.0f;\n+  #pragma omp atomic capture compare\n+  { r = x == 6.0f; if (r) { x = 23.0f; } else { v = x; } }\n+  if (r != 1 || v != 15.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 23.0f)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "87216e24925d5aa49f9f1434f889722ad6692e6d", "filename": "libgomp/testsuite/libgomp.c-c++-common/atomic-21.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8122fbff770bcff183a9c3c72e8092c0ca32150b/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8122fbff770bcff183a9c3c72e8092c0ca32150b/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-21.c?ref=8122fbff770bcff183a9c3c72e8092c0ca32150b", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do run { target c } }\n+\n+double d;\n+long double ld;\n+\n+int\n+main ()\n+{\n+  double e = __builtin_copysign (0.0, -1.0), v;\n+  long double le = __builtin_copysignl (0.0L, -1.0L), lv;\n+  if (__builtin_memcmp (&d, &e, sizeof (d)) != 0)\n+    {\n+      /* Verify == comparison for atomics is done as with memcmp.  */\n+      #pragma omp atomic compare\n+      d = d == e ? 5.0 : d;\n+      #pragma omp atomic read\n+      v = d;\n+      if (v != 0.0)\n+\t__builtin_abort ();\n+      #pragma omp atomic compare\n+      d = d == 0.0 ? 5.0 : d;\n+      #pragma omp atomic read\n+      v = d;\n+      if (v != 5.0)\n+\t__builtin_abort ();\n+    }\n+  if (__builtin_memcmp (&ld, &le, sizeof (ld)) != 0)\n+    {\n+      __builtin_memset (&ld, 0xff, sizeof (ld));\n+      #pragma omp atomic write\n+      ld = 0.0L;\n+      __asm volatile (\"\" : : \"g\" (&ld) : \"memory\");\n+      /* Verify == comparison for atomics is done as with memcmp\n+\t with __builtin_clear_padding if needed.  */\n+      #pragma omp atomic compare\n+      ld = ld == le ? 5.0L : ld;\n+      #pragma omp atomic read\n+      lv = ld;\n+      if (lv != 0.0L)\n+\t__builtin_abort ();\n+      #pragma omp atomic compare\n+      ld = ld == 0.0L ? 5.0L : ld;\n+      #pragma omp atomic read\n+      lv = ld;\n+      if (lv != 5.0L)\n+\t__builtin_abort ();\n+    }\n+  return 0;\n+}"}]}