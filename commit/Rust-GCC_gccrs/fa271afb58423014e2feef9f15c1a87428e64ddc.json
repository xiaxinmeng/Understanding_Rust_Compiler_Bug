{"sha": "fa271afb58423014e2feef9f15c1a87428e64ddc", "node_id": "C_kwDOANBUbNoAKGZhMjcxYWZiNTg0MjMwMTRlMmZlZWY5ZjE1YzFhODc0MjhlNjRkZGM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-08T11:21:55Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-08T11:21:55Z"}, "message": "i386: Improve vector [GL]E{,U} comparison against vector constants [PR107546]\n\nFor integer vector comparisons without XOP before AVX512{F,VL} we are\nconstrained by only GT and EQ being supported in HW.\nFor GTU we play tricks to implement it using GT or unsigned saturating\nsubtraction, for LT/LTU we swap the operands and thus turn it into\nGT/GTU.  For LE/LEU we handle it by using GT/GTU and negating the\nresult and for GE/GEU by using GT/GTU on swapped operands and negating\nthe result.\nIf the second operand is a CONST_VECTOR, we can usually do better though,\nwe can avoid the negation.  For LE/LEU cst by doing LT/LTU cst+1 (and\nthen cst+1 GT/GTU x) and for GE/GEU cst by doing GT/GTU cst-1, provided\nthere is no wrap-around on those cst+1 or cst-1.\nGIMPLE canonicalizes x < cst to x <= cst-1 etc. (the rule is smaller\nabsolute value on constant), but only for scalars or uniform vectors,\nso in some cases this undoes that canonicalization in order to avoid\nthe extra negation, but it handles also non-uniform constants.\nE.g. with -mavx2 the testcase assembly difference is:\n-       movl    $47, %eax\n+       movl    $48, %eax\n        vmovdqa %xmm0, %xmm1\n        vmovd   %eax, %xmm0\n        vpbroadcastb    %xmm0, %xmm0\n-       vpminsb %xmm0, %xmm1, %xmm0\n-       vpcmpeqb        %xmm1, %xmm0, %xmm0\n+       vpcmpgtb        %xmm1, %xmm0, %xmm0\nand\n-       vmovdqa %xmm0, %xmm1\n-       vmovdqa .LC1(%rip), %xmm0\n-       vpminsb %xmm1, %xmm0, %xmm1\n-       vpcmpeqb        %xmm1, %xmm0, %xmm0\n+       vpcmpgtb        .LC1(%rip), %xmm0, %xmm0\nwhile with just SSE2:\n-       pcmpgtb .LC0(%rip), %xmm0\n-       pxor    %xmm1, %xmm1\n-       pcmpeqb %xmm1, %xmm0\n+       movdqa  %xmm0, %xmm1\n+       movdqa  .LC0(%rip), %xmm0\n+       pcmpgtb %xmm1, %xmm0\nand\n-       movdqa  %xmm0, %xmm1\n-       movdqa  .LC1(%rip), %xmm0\n-       pcmpgtb %xmm1, %xmm0\n-       pxor    %xmm1, %xmm1\n-       pcmpeqb %xmm1, %xmm0\n+       pcmpgtb .LC1(%rip), %xmm0\n\n2022-11-08  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/107546\n\t* config/i386/predicates.md (vector_or_const_vector_operand): New\n\tpredicate.\n\t* config/i386/sse.md (vec_cmp<mode><sseintvecmodelower>,\n\tvec_cmpv2div2di, vec_cmpu<mode><sseintvecmodelower>,\n\tvec_cmpuv2div2di): Use nonimmediate_or_const_vector_operand\n\tpredicate instead of nonimmediate_operand and\n\tvector_or_const_vector_operand instead of vector_operand.\n\t* config/i386/i386-expand.cc (ix86_expand_int_sse_cmp): For\n\tLE/LEU or GE/GEU with CONST_VECTOR cop1 try to transform those\n\tinto LE/LEU or GT/GTU with larger or smaller by one cop1 if\n\tthere is no wrap-around.  Force CONST_VECTOR cop0 or cop1 into\n\tREG.  Formatting fix.\n\n\t* gcc.target/i386/pr107546.c: New test.", "tree": {"sha": "15c51f88c30653991ae0bd1d4a3747e08d660cb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15c51f88c30653991ae0bd1d4a3747e08d660cb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa271afb58423014e2feef9f15c1a87428e64ddc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa271afb58423014e2feef9f15c1a87428e64ddc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa271afb58423014e2feef9f15c1a87428e64ddc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa271afb58423014e2feef9f15c1a87428e64ddc/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee86bdd1d367bc174d7b50bd2ffa5622c4766322", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee86bdd1d367bc174d7b50bd2ffa5622c4766322", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee86bdd1d367bc174d7b50bd2ffa5622c4766322"}], "stats": {"total": 124, "additions": 113, "deletions": 11}, "files": [{"sha": "9c92b07d5cd84c64611eb66aa0ee0136ea526085", "filename": "gcc/config/i386/i386-expand.cc", "status": "modified", "additions": 81, "deletions": 5, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa271afb58423014e2feef9f15c1a87428e64ddc/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa271afb58423014e2feef9f15c1a87428e64ddc/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.cc?ref=fa271afb58423014e2feef9f15c1a87428e64ddc", "patch": "@@ -4510,15 +4510,86 @@ ix86_expand_int_sse_cmp (rtx dest, enum rtx_code code, rtx cop0, rtx cop1,\n \tcase GTU:\n \t  break;\n \n-\tcase NE:\n \tcase LE:\n \tcase LEU:\n+\t  /* x <= cst can be handled as x < cst + 1 unless there is\n+\t     wrap around in cst + 1.  */\n+\t  if (GET_CODE (cop1) == CONST_VECTOR\n+\t      && GET_MODE_INNER (mode) != TImode)\n+\t    {\n+\t      unsigned int n_elts = GET_MODE_NUNITS (mode), i;\n+\t      machine_mode eltmode = GET_MODE_INNER (mode);\n+\t      for (i = 0; i < n_elts; ++i)\n+\t\t{\n+\t\t  rtx elt = CONST_VECTOR_ELT (cop1, i);\n+\t\t  if (!CONST_INT_P (elt))\n+\t\t    break;\n+\t\t  if (code == GE)\n+\t\t    {\n+\t\t      /* For LE punt if some element is signed maximum.  */\n+\t\t      if ((INTVAL (elt) & (GET_MODE_MASK (eltmode) >> 1))\n+\t\t\t  == (GET_MODE_MASK (eltmode) >> 1))\n+\t\t\tbreak;\n+\t\t    }\n+\t\t  /* For LEU punt if some element is unsigned maximum.  */\n+\t\t  else if (elt == constm1_rtx)\n+\t\t    break;\n+\t\t}\n+\t      if (i == n_elts)\n+\t\t{\n+\t\t  rtvec v = rtvec_alloc (n_elts);\n+\t\t  for (i = 0; i < n_elts; ++i)\n+\t\t    RTVEC_ELT (v, i)\n+\t\t      = GEN_INT (INTVAL (CONST_VECTOR_ELT (cop1, i)) + 1);\n+\t\t  cop1 = gen_rtx_CONST_VECTOR (mode, v);\n+\t\t  std::swap (cop0, cop1);\n+\t\t  code = code == LE ? GT : GTU;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  /* FALLTHRU */\n+\tcase NE:\n \t  code = reverse_condition (code);\n \t  *negate = true;\n \t  break;\n \n \tcase GE:\n \tcase GEU:\n+\t  /* x >= cst can be handled as x > cst - 1 unless there is\n+\t     wrap around in cst - 1.  */\n+\t  if (GET_CODE (cop1) == CONST_VECTOR\n+\t      && GET_MODE_INNER (mode) != TImode)\n+\t    {\n+\t      unsigned int n_elts = GET_MODE_NUNITS (mode), i;\n+\t      machine_mode eltmode = GET_MODE_INNER (mode);\n+\t      for (i = 0; i < n_elts; ++i)\n+\t\t{\n+\t\t  rtx elt = CONST_VECTOR_ELT (cop1, i);\n+\t\t  if (!CONST_INT_P (elt))\n+\t\t    break;\n+\t\t  if (code == GE)\n+\t\t    {\n+\t\t      /* For GE punt if some element is signed minimum.  */\n+\t\t      if (INTVAL (elt) < 0\n+\t\t\t  && ((INTVAL (elt) & (GET_MODE_MASK (eltmode) >> 1))\n+\t\t\t      == 0))\n+\t\t\tbreak;\n+\t\t    }\n+\t\t  /* For GEU punt if some element is zero.  */\n+\t\t  else if (elt == const0_rtx)\n+\t\t    break;\n+\t\t}\n+\t      if (i == n_elts)\n+\t\t{\n+\t\t  rtvec v = rtvec_alloc (n_elts);\n+\t\t  for (i = 0; i < n_elts; ++i)\n+\t\t    RTVEC_ELT (v, i)\n+\t\t      = GEN_INT (INTVAL (CONST_VECTOR_ELT (cop1, i)) - 1);\n+\t\t  cop1 = gen_rtx_CONST_VECTOR (mode, v);\n+\t\t  code = code == GE ? GT : GTU;\n+\t\t  break;\n+\t\t}\n+\t    }\n \t  code = reverse_condition (code);\n \t  *negate = true;\n \t  /* FALLTHRU */\n@@ -4556,6 +4627,11 @@ ix86_expand_int_sse_cmp (rtx dest, enum rtx_code code, rtx cop0, rtx cop1,\n \t    }\n \t}\n \n+      if (GET_CODE (cop0) == CONST_VECTOR)\n+\tcop0 = force_reg (mode, cop0);\n+      else if (GET_CODE (cop1) == CONST_VECTOR)\n+\tcop1 = force_reg (mode, cop1);\n+\n       rtx optrue = op_true ? op_true : CONSTM1_RTX (data_mode);\n       rtx opfalse = op_false ? op_false : CONST0_RTX (data_mode);\n       if (*negate)\n@@ -4752,13 +4828,13 @@ ix86_expand_int_sse_cmp (rtx dest, enum rtx_code code, rtx cop0, rtx cop1,\n   if (*negate)\n     std::swap (op_true, op_false);\n \n+  if (GET_CODE (cop1) == CONST_VECTOR)\n+    cop1 = force_reg (mode, cop1);\n+\n   /* Allow the comparison to be done in one mode, but the movcc to\n      happen in another mode.  */\n   if (data_mode == mode)\n-    {\n-      x = ix86_expand_sse_cmp (dest, code, cop0, cop1,\n-\t\t\t       op_true, op_false);\n-    }\n+    x = ix86_expand_sse_cmp (dest, code, cop0, cop1, op_true, op_false);\n   else\n     {\n       gcc_assert (GET_MODE_SIZE (data_mode) == GET_MODE_SIZE (mode));"}, {"sha": "f995503838654969b5fa7508bc0d2c412a8b5e0b", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa271afb58423014e2feef9f15c1a87428e64ddc/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa271afb58423014e2feef9f15c1a87428e64ddc/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=fa271afb58423014e2feef9f15c1a87428e64ddc", "patch": "@@ -1235,6 +1235,13 @@\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"vector_memory_operand\")))\n \n+; Return true when OP is register_operand, vector_memory_operand\n+; or const_vector.\n+(define_predicate \"vector_or_const_vector_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"vector_memory_operand\")\n+       (match_code \"const_vector\")))\n+\n (define_predicate \"bcst_mem_operand\"\n   (and (match_code \"vec_duplicate\")\n        (and (match_test \"TARGET_AVX512F\")"}, {"sha": "9a4fc01856dd6c2f889021a1dfbc82206bb1791d", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa271afb58423014e2feef9f15c1a87428e64ddc/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa271afb58423014e2feef9f15c1a87428e64ddc/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=fa271afb58423014e2feef9f15c1a87428e64ddc", "patch": "@@ -4311,7 +4311,7 @@\n   [(set (match_operand:<sseintvecmode> 0 \"register_operand\")\n \t(match_operator:<sseintvecmode> 1 \"\"\n \t  [(match_operand:VI_256 2 \"register_operand\")\n-\t   (match_operand:VI_256 3 \"nonimmediate_operand\")]))]\n+\t   (match_operand:VI_256 3 \"nonimmediate_or_const_vector_operand\")]))]\n   \"TARGET_AVX2\"\n {\n   bool ok = ix86_expand_int_vec_cmp (operands);\n@@ -4323,7 +4323,7 @@\n   [(set (match_operand:<sseintvecmode> 0 \"register_operand\")\n \t(match_operator:<sseintvecmode> 1 \"\"\n \t  [(match_operand:VI124_128 2 \"register_operand\")\n-\t   (match_operand:VI124_128 3 \"vector_operand\")]))]\n+\t   (match_operand:VI124_128 3 \"vector_or_const_vector_operand\")]))]\n   \"TARGET_SSE2\"\n {\n   bool ok = ix86_expand_int_vec_cmp (operands);\n@@ -4335,7 +4335,7 @@\n   [(set (match_operand:V2DI 0 \"register_operand\")\n \t(match_operator:V2DI 1 \"\"\n \t  [(match_operand:V2DI 2 \"register_operand\")\n-\t   (match_operand:V2DI 3 \"vector_operand\")]))]\n+\t   (match_operand:V2DI 3 \"vector_or_const_vector_operand\")]))]\n   \"TARGET_SSE4_2\"\n {\n   bool ok = ix86_expand_int_vec_cmp (operands);\n@@ -4397,7 +4397,7 @@\n   [(set (match_operand:<sseintvecmode> 0 \"register_operand\")\n \t(match_operator:<sseintvecmode> 1 \"\"\n \t  [(match_operand:VI_256 2 \"register_operand\")\n-\t   (match_operand:VI_256 3 \"nonimmediate_operand\")]))]\n+\t   (match_operand:VI_256 3 \"nonimmediate_or_const_vector_operand\")]))]\n   \"TARGET_AVX2\"\n {\n   bool ok = ix86_expand_int_vec_cmp (operands);\n@@ -4409,7 +4409,7 @@\n   [(set (match_operand:<sseintvecmode> 0 \"register_operand\")\n \t(match_operator:<sseintvecmode> 1 \"\"\n \t  [(match_operand:VI124_128 2 \"register_operand\")\n-\t   (match_operand:VI124_128 3 \"vector_operand\")]))]\n+\t   (match_operand:VI124_128 3 \"vector_or_const_vector_operand\")]))]\n   \"TARGET_SSE2\"\n {\n   bool ok = ix86_expand_int_vec_cmp (operands);\n@@ -4421,7 +4421,7 @@\n   [(set (match_operand:V2DI 0 \"register_operand\")\n \t(match_operator:V2DI 1 \"\"\n \t  [(match_operand:V2DI 2 \"register_operand\")\n-\t   (match_operand:V2DI 3 \"vector_operand\")]))]\n+\t   (match_operand:V2DI 3 \"vector_or_const_vector_operand\")]))]\n   \"TARGET_SSE4_2\"\n {\n   bool ok = ix86_expand_int_vec_cmp (operands);"}, {"sha": "e5cf56d762058448871bfc64688088322fc230f0", "filename": "gcc/testsuite/gcc.target/i386/pr107546.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa271afb58423014e2feef9f15c1a87428e64ddc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr107546.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa271afb58423014e2feef9f15c1a87428e64ddc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr107546.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr107546.c?ref=fa271afb58423014e2feef9f15c1a87428e64ddc", "patch": "@@ -0,0 +1,19 @@\n+/* PR target/107546 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -msse2 -mno-xop -mno-avx512f\" } */\n+/* { dg-final { scan-assembler-not \"pcmpeqb\\t\" } } */\n+/* { dg-final { scan-assembler-times \"pcmpgtb\\t\" 2 } } */\n+\n+typedef signed char V __attribute__((vector_size(16)));\n+\n+V\n+foo (V x)\n+{\n+  return x < 48;\n+}\n+\n+V\n+bar (V x)\n+{\n+  return x >= (V) { 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57 };\n+}"}]}