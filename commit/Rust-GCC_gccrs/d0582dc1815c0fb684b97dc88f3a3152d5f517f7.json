{"sha": "d0582dc1815c0fb684b97dc88f3a3152d5f517f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA1ODJkYzE4MTVjMGZiNjg0Yjk3ZGM4OGYzYTMxNTJkNWY1MTdmNw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-06-06T09:45:27Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-06-06T09:45:27Z"}, "message": "re PR tree-optimization/53081 (memcpy/memset loop recognition)\n\n2012-06-06  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/53081\n\t* tree-data-ref.h (adjacent_store_dr_p): Rename to ...\n\t(adjacent_dr_p): ... this and make it work for reads, too.\n\t* tree-loop-distribution.c (enum partition_kind): Add PKIND_MEMCPY.\n\t(struct partition_s): Change main_stmt to main_dr, add\n\tsecondary_dr member.\n\t(build_size_arg_loc): Change to date data-reference and not\n\tgimplify here.\n\t(build_addr_arg_loc): New function split out from ...\n\t(generate_memset_builtin): ... here.  Use it and simplify.\n\t(generate_memcpy_builtin): New function.\n\t(generate_code_for_partition): Adjust.\n\t(classify_partition): Streamline pattern detection.  Detect\n\tmemcpy.\n\t(ldist_gen): Adjust.\n\t(tree_loop_distribution): Adjust seed statements for memcpy\n\trecognition.\n\n\t* gcc.dg/tree-ssa/ldist-20.c: New testcase.\n\t* gcc.dg/tree-ssa/loop-19.c: Add -fno-tree-loop-distribute-patterns.\n\nFrom-SVN: r188261", "tree": {"sha": "9f8f31aa67b331c5ef8513c22367a259275a267c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f8f31aa67b331c5ef8513c22367a259275a267c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0582dc1815c0fb684b97dc88f3a3152d5f517f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0582dc1815c0fb684b97dc88f3a3152d5f517f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0582dc1815c0fb684b97dc88f3a3152d5f517f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0582dc1815c0fb684b97dc88f3a3152d5f517f7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4ad4fa63349426505aecfea69a8e54aae3f88870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ad4fa63349426505aecfea69a8e54aae3f88870", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ad4fa63349426505aecfea69a8e54aae3f88870"}], "stats": {"total": 337, "additions": 235, "deletions": 102}, "files": [{"sha": "29daf152e18dcc802a7ab1af12413d803c5eeb09", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0582dc1815c0fb684b97dc88f3a3152d5f517f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0582dc1815c0fb684b97dc88f3a3152d5f517f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0582dc1815c0fb684b97dc88f3a3152d5f517f7", "patch": "@@ -1,3 +1,23 @@\n+2012-06-06  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/53081\n+\t* tree-data-ref.h (adjacent_store_dr_p): Rename to ...\n+\t(adjacent_dr_p): ... this and make it work for reads, too.\n+\t* tree-loop-distribution.c (enum partition_kind): Add PKIND_MEMCPY.\n+\t(struct partition_s): Change main_stmt to main_dr, add\n+\tsecondary_dr member.\n+\t(build_size_arg_loc): Change to date data-reference and not\n+\tgimplify here.\n+\t(build_addr_arg_loc): New function split out from ...\n+\t(generate_memset_builtin): ... here.  Use it and simplify.\n+\t(generate_memcpy_builtin): New function.\n+\t(generate_code_for_partition): Adjust.\n+\t(classify_partition): Streamline pattern detection.  Detect\n+\tmemcpy.\n+\t(ldist_gen): Adjust.\n+\t(tree_loop_distribution): Adjust seed statements for memcpy\n+\trecognition.\n+\n 2012-06-06  Matt Turner  <mattst88@gmail.com>\n \n \t* config/arm/mmintrin.h (_mm_empty): New."}, {"sha": "a219f840491f7d02355d5f5559acde6705fabc92", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0582dc1815c0fb684b97dc88f3a3152d5f517f7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0582dc1815c0fb684b97dc88f3a3152d5f517f7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d0582dc1815c0fb684b97dc88f3a3152d5f517f7", "patch": "@@ -1,3 +1,9 @@\n+2012-06-06  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/53081\n+\t* gcc.dg/tree-ssa/ldist-20.c: New testcase.\n+\t* gcc.dg/tree-ssa/loop-19.c: Add -fno-tree-loop-distribute-patterns.\n+\n 2012-06-05  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* gcc.target/powerpc/pr53487.c: New test."}, {"sha": "95ae2c04c13bda70fa9cec544bf711cad6b101d7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-20.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0582dc1815c0fb684b97dc88f3a3152d5f517f7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0582dc1815c0fb684b97dc88f3a3152d5f517f7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-20.c?ref=d0582dc1815c0fb684b97dc88f3a3152d5f517f7", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-loop-distribute-patterns -fdump-tree-ldist-details\" } */\n+\n+void foo(char *);\n+void my_memcpy (void *q, unsigned int n)\n+{\n+  unsigned i;\n+  char p[1024];\n+  for (i = 0; i < n; ++i)\n+    ((char *)p)[i] = ((char *)q)[i];\n+  foo(p);\n+}\n+\n+struct S { int i; int j; };\n+\n+void my_memcpy2 (void *q, unsigned int n)\n+{\n+  unsigned i;\n+  char p[1024];\n+  for (i = 0; i < n; ++i)\n+    ((struct S *)p)[i] = ((struct S *)q)[i];\n+  foo(p);\n+}\n+\n+char p[1024];\n+void my_memmove (unsigned int n)\n+{\n+  unsigned i;\n+  for (i = 0; i < n; ++i)\n+    p[i] = p[i+1];\n+  foo(p);\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"generated memcpy\" 2 \"ldist\" } } */\n+/* { dg-final { scan-tree-dump-times \"generated memmove\" 1 \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "36a2688f0572d2a97b21fbfca6c63d8c4c04ebb3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-19.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0582dc1815c0fb684b97dc88f3a3152d5f517f7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0582dc1815c0fb684b97dc88f3a3152d5f517f7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-19.c?ref=d0582dc1815c0fb684b97dc88f3a3152d5f517f7", "patch": "@@ -6,7 +6,7 @@\n \n /* { dg-do compile { target { i?86-*-* || { x86_64-*-* || powerpc_hard_double } } } } */\n /* { dg-require-effective-target nonpic } */\n-/* { dg-options \"-O3 -fno-prefetch-loop-arrays -fdump-tree-optimized\" } */\n+/* { dg-options \"-O3 -fno-tree-loop-distribute-patterns -fno-prefetch-loop-arrays -fdump-tree-optimized\" } */\n \n # define N      2000000\n double   a[N],c[N];"}, {"sha": "db33e328c3ed4b58eba3007e34fe090a5c0ae0c0", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0582dc1815c0fb684b97dc88f3a3152d5f517f7/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0582dc1815c0fb684b97dc88f3a3152d5f517f7/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=d0582dc1815c0fb684b97dc88f3a3152d5f517f7", "patch": "@@ -615,11 +615,8 @@ bool rdg_defs_used_in_other_loops_p (struct graph *, int);\n    with a stride equal to its unit type size.  */\n \n static inline bool\n-adjacent_store_dr_p (struct data_reference *dr)\n+adjacent_dr_p (struct data_reference *dr)\n {\n-  if (!DR_IS_WRITE (dr))\n-    return false;\n-\n   /* If this is a bitfield store bail out.  */\n   if (TREE_CODE (DR_REF (dr)) == COMPONENT_REF\n       && DECL_BIT_FIELD (TREE_OPERAND (DR_REF (dr), 1)))"}, {"sha": "58ed12b1e69003953921a1552cd05da28be24034", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 170, "deletions": 97, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0582dc1815c0fb684b97dc88f3a3152d5f517f7/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0582dc1815c0fb684b97dc88f3a3152d5f517f7/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=d0582dc1815c0fb684b97dc88f3a3152d5f517f7", "patch": "@@ -52,15 +52,16 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"tree-pass.h\"\n \n-enum partition_kind { PKIND_NORMAL, PKIND_MEMSET };\n+enum partition_kind { PKIND_NORMAL, PKIND_MEMSET, PKIND_MEMCPY };\n \n typedef struct partition_s\n {\n   bitmap stmts;\n   bool has_writes;\n   enum partition_kind kind;\n-  /* Main statement a kind != PKIND_NORMAL partition is about.  */\n-  gimple main_stmt;\n+  /* data-references a kind != PKIND_NORMAL partition is about.  */\n+  data_reference_p main_dr;\n+  data_reference_p secondary_dr;\n } *partition_t;\n \n DEF_VEC_P (partition_t);\n@@ -313,40 +314,53 @@ generate_loops_for_partition (struct loop *loop, partition_t partition,\n   free (bbs);\n }\n \n-/* Build the size argument for a memset call.  */\n+/* Build the size argument for a memory operation call.  */\n \n-static inline tree\n-build_size_arg_loc (location_t loc, tree nb_iter, tree op,\n-\t\t    gimple_seq *stmt_list)\n+static tree\n+build_size_arg_loc (location_t loc, data_reference_p dr, tree nb_iter)\n {\n-  gimple_seq stmts;\n-  tree x = fold_build2_loc (loc, MULT_EXPR, size_type_node,\n-\t\t\t    fold_convert_loc (loc, size_type_node, nb_iter),\n-\t\t\t    fold_convert_loc (loc, size_type_node,\n-\t\t\t\t\t      TYPE_SIZE_UNIT (TREE_TYPE (op))));\n-  x = force_gimple_operand (x, &stmts, true, NULL);\n-  gimple_seq_add_seq (stmt_list, stmts);\n-\n-  return x;\n+  tree size;\n+  size = fold_build2_loc (loc, MULT_EXPR, sizetype,\n+\t\t\t  fold_convert_loc (loc, sizetype, nb_iter),\n+\t\t\t  TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr))));\n+  return fold_convert_loc (loc, size_type_node, size);\n+}\n+\n+/* Build an address argument for a memory operation call.  */\n+\n+static tree\n+build_addr_arg_loc (location_t loc, data_reference_p dr, tree nb_bytes)\n+{\n+  tree addr_base;\n+\n+  addr_base = size_binop_loc (loc, PLUS_EXPR, DR_OFFSET (dr), DR_INIT (dr));\n+  addr_base = fold_convert_loc (loc, sizetype, addr_base);\n+\n+  /* Test for a negative stride, iterating over every element.  */\n+  if (tree_int_cst_sgn (DR_STEP (dr)) == -1)\n+    {\n+      addr_base = size_binop_loc (loc, MINUS_EXPR, addr_base,\n+\t\t\t\t  fold_convert_loc (loc, sizetype, nb_bytes));\n+      addr_base = size_binop_loc (loc, PLUS_EXPR, addr_base,\n+\t\t\t\t  TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr))));\n+    }\n+\n+  return fold_build_pointer_plus_loc (loc, DR_BASE_ADDRESS (dr), addr_base);\n }\n \n /* Generate a call to memset for PARTITION in LOOP.  */\n \n static void\n-generate_memset_builtin (struct loop *loop, struct graph *rdg,\n-\t\t\t partition_t partition)\n+generate_memset_builtin (struct loop *loop, partition_t partition)\n {\n   gimple_stmt_iterator gsi;\n   gimple stmt, fn_call;\n-  tree op0, nb_iter, mem, fn, addr_base, nb_bytes;\n-  gimple_seq stmt_list = NULL, stmts;\n-  struct data_reference *dr = XCNEW (struct data_reference);\n+  tree nb_iter, mem, fn, nb_bytes;\n   location_t loc;\n   tree val;\n \n-  stmt = partition->main_stmt;\n+  stmt = DR_STMT (partition->main_dr);\n   loc = gimple_location (stmt);\n-  op0 = gimple_assign_lhs (stmt);\n   if (gimple_bb (stmt) == loop->latch)\n     nb_iter = number_of_latch_executions (loop);\n   else\n@@ -355,25 +369,12 @@ generate_memset_builtin (struct loop *loop, struct graph *rdg,\n   /* The new statements will be placed before LOOP.  */\n   gsi = gsi_last_bb (loop_preheader_edge (loop)->src);\n \n-  dr = VEC_index (data_reference_p,\n-\t\t  RDG_DATAREFS (rdg, rdg_vertex_for_stmt (rdg, stmt)), 0);\n-  nb_bytes = build_size_arg_loc (loc, nb_iter, op0, &stmt_list);\n-  addr_base = size_binop_loc (loc, PLUS_EXPR, DR_OFFSET (dr), DR_INIT (dr));\n-  addr_base = fold_convert_loc (loc, sizetype, addr_base);\n-\n-  /* Test for a negative stride, iterating over every element.  */\n-  if (tree_int_cst_sgn (DR_STEP (dr)) == -1)\n-    {\n-      addr_base = size_binop_loc (loc, MINUS_EXPR, addr_base,\n-\t\t\t\t  fold_convert_loc (loc, sizetype, nb_bytes));\n-      addr_base = size_binop_loc (loc, PLUS_EXPR, addr_base,\n-\t\t\t\t  TYPE_SIZE_UNIT (TREE_TYPE (op0)));\n-    }\n-\n-  addr_base = fold_build_pointer_plus_loc (loc,\n-\t\t\t\t\t   DR_BASE_ADDRESS (dr), addr_base);\n-  mem = force_gimple_operand (addr_base, &stmts, true, NULL);\n-  gimple_seq_add_seq (&stmt_list, stmts);\n+  nb_bytes = build_size_arg_loc (loc, partition->main_dr, nb_iter);\n+  nb_bytes = force_gimple_operand_gsi (&gsi, nb_bytes, true, NULL_TREE,\n+\t\t\t\t       false, GSI_CONTINUE_LINKING);\n+  mem = build_addr_arg_loc (loc, partition->main_dr, nb_bytes);\n+  mem = force_gimple_operand_gsi (&gsi, mem, true, NULL_TREE,\n+\t\t\t\t  false, GSI_CONTINUE_LINKING);\n \n   /* This exactly matches the pattern recognition in classify_partition.  */\n   val = gimple_assign_rhs1 (stmt);\n@@ -393,15 +394,14 @@ generate_memset_builtin (struct loop *loop, struct graph *rdg,\n \t  tree tem = create_tmp_reg (integer_type_node, NULL);\n \t  tem = make_ssa_name (tem, NULL);\n \t  cstmt = gimple_build_assign_with_ops (NOP_EXPR, tem, val, NULL_TREE);\n-\t  gimple_seq_add_stmt (&stmt_list, cstmt);\n+\t  gsi_insert_after (&gsi, cstmt, GSI_CONTINUE_LINKING);\n \t  val = tem;\n \t}\n     }\n \n   fn = build_fold_addr_expr (builtin_decl_implicit (BUILT_IN_MEMSET));\n   fn_call = gimple_build_call (fn, 3, mem, val, nb_bytes);\n-  gimple_seq_add_stmt (&stmt_list, fn_call);\n-  gsi_insert_seq_after (&gsi, stmt_list, GSI_CONTINUE_LINKING);\n+  gsi_insert_after (&gsi, fn_call, GSI_CONTINUE_LINKING);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -415,6 +415,54 @@ generate_memset_builtin (struct loop *loop, struct graph *rdg,\n     }\n }\n \n+/* Generate a call to memcpy for PARTITION in LOOP.  */\n+\n+static void\n+generate_memcpy_builtin (struct loop *loop, partition_t partition)\n+{\n+  gimple_stmt_iterator gsi;\n+  gimple stmt, fn_call;\n+  tree nb_iter, dest, src, fn, nb_bytes;\n+  location_t loc;\n+  enum built_in_function kind;\n+\n+  stmt = DR_STMT (partition->main_dr);\n+  loc = gimple_location (stmt);\n+  if (gimple_bb (stmt) == loop->latch)\n+    nb_iter = number_of_latch_executions (loop);\n+  else\n+    nb_iter = number_of_exit_cond_executions (loop);\n+\n+  /* The new statements will be placed before LOOP.  */\n+  gsi = gsi_last_bb (loop_preheader_edge (loop)->src);\n+\n+  nb_bytes = build_size_arg_loc (loc, partition->main_dr, nb_iter);\n+  nb_bytes = force_gimple_operand_gsi (&gsi, nb_bytes, true, NULL_TREE,\n+\t\t\t\t       false, GSI_CONTINUE_LINKING);\n+  dest = build_addr_arg_loc (loc, partition->main_dr, nb_bytes);\n+  src = build_addr_arg_loc (loc, partition->secondary_dr, nb_bytes);\n+  if (ptr_derefs_may_alias_p (dest, src))\n+    kind = BUILT_IN_MEMMOVE;\n+  else\n+    kind = BUILT_IN_MEMCPY;\n+\n+  dest = force_gimple_operand_gsi (&gsi, dest, true, NULL_TREE,\n+\t\t\t\t   false, GSI_CONTINUE_LINKING);\n+  src = force_gimple_operand_gsi (&gsi, src, true, NULL_TREE,\n+\t\t\t\t  false, GSI_CONTINUE_LINKING);\n+  fn = build_fold_addr_expr (builtin_decl_implicit (kind));\n+  fn_call = gimple_build_call (fn, 3, dest, src, nb_bytes);\n+  gsi_insert_after (&gsi, fn_call, GSI_CONTINUE_LINKING);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      if (kind == BUILT_IN_MEMCPY)\n+\tfprintf (dump_file, \"generated memcpy\\n\");\n+      else\n+\tfprintf (dump_file, \"generated memmove\\n\");\n+    }\n+}\n+\n /* Remove and destroy the loop LOOP.  */\n \n static void\n@@ -466,13 +514,21 @@ destroy_loop (struct loop *loop)\n /* Generates code for PARTITION.  */\n \n static void\n-generate_code_for_partition (struct loop *loop, struct graph *rdg,\n+generate_code_for_partition (struct loop *loop,\n \t\t\t     partition_t partition, bool copy_p)\n {\n   switch (partition->kind)\n     {\n     case PKIND_MEMSET:\n-      generate_memset_builtin (loop, rdg, partition);\n+      generate_memset_builtin (loop, partition);\n+      /* If this is the last partition for which we generate code, we have\n+\t to destroy the loop.  */\n+      if (!copy_p)\n+\tdestroy_loop (loop);\n+      break;\n+\n+    case PKIND_MEMCPY:\n+      generate_memcpy_builtin (loop, partition);\n       /* If this is the last partition for which we generate code, we have\n \t to destroy the loop.  */\n       if (!copy_p)\n@@ -849,9 +905,11 @@ classify_partition (loop_p loop, struct graph *rdg, partition_t partition)\n   bitmap_iterator bi;\n   unsigned i;\n   tree nb_iter;\n+  data_reference_p single_load, single_store;\n \n   partition->kind = PKIND_NORMAL;\n-  partition->main_stmt = NULL;\n+  partition->main_dr = NULL;\n+  partition->secondary_dr = NULL;\n \n   if (!flag_tree_loop_distribute_patterns)\n     return;\n@@ -880,10 +938,14 @@ classify_partition (loop_p loop, struct graph *rdg, partition_t partition)\n \t}\n     }\n \n-  /* Detect memset.  */\n+  /* Detect memset and memcpy.  */\n+  single_load = NULL;\n+  single_store = NULL;\n   EXECUTE_IF_SET_IN_BITMAP (partition->stmts, 0, i, bi)\n     {\n       gimple stmt = RDG_STMT (rdg, i);\n+      data_reference_p dr;\n+      unsigned j;\n \n       if (gimple_code (stmt) == GIMPLE_PHI)\n \tcontinue;\n@@ -892,41 +954,68 @@ classify_partition (loop_p loop, struct graph *rdg, partition_t partition)\n       if (!gimple_vuse (stmt))\n \tcontinue;\n \n-      /* Exactly one store.  */\n-      if (gimple_assign_single_p (stmt)\n-\t  && !is_gimple_reg (gimple_assign_lhs (stmt)))\n+      /* Otherwise just regular loads/stores.  */\n+      if (!gimple_assign_single_p (stmt))\n+\treturn;\n+\n+      /* But exactly one store and/or load.  */\n+      for (j = 0;\n+\t   VEC_iterate (data_reference_p, RDG_DATAREFS (rdg, i), j, dr); ++j)\n \t{\n-\t  tree rhs;\n-\t  if (partition->main_stmt != NULL)\n-\t    return;\n-\t  partition->main_stmt = stmt;\n-\t  rhs = gimple_assign_rhs1 (stmt);\n-\t  if (!(integer_zerop (rhs)\n-\t\t|| integer_all_onesp (rhs)\n-\t\t|| real_zerop (rhs)\n-\t\t|| (TREE_CODE (rhs) == CONSTRUCTOR\n-\t\t    && !TREE_CLOBBER_P (rhs))\n-\t\t|| (INTEGRAL_TYPE_P (TREE_TYPE (rhs))\n-\t\t    && (TYPE_MODE (TREE_TYPE (gimple_assign_lhs (stmt)))\n-\t\t\t== TYPE_MODE (unsigned_char_type_node)))))\n-\t    return;\n-\t  if (TREE_CODE (rhs) == SSA_NAME\n-\t      && !SSA_NAME_IS_DEFAULT_DEF (rhs)\n-\t      && flow_bb_inside_loop_p\n-\t\t   (loop, gimple_bb (SSA_NAME_DEF_STMT (rhs))))\n-\t    return;\n-\t  if (VEC_length (data_reference_p, RDG_DATAREFS (rdg, i)) != 1)\n-\t    return;\n-\t  if (!adjacent_store_dr_p (VEC_index (data_reference_p,\n-\t\t\t\t\t       RDG_DATAREFS (rdg, i), 0)))\n-\t    return;\n+\t  if (DR_IS_READ (dr))\n+\t    {\n+\t      if (single_load != NULL)\n+\t\treturn;\n+\t      single_load = dr;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (single_store != NULL)\n+\t\treturn;\n+\t      single_store = dr;\n+\t    }\n \t}\n-      else\n-\treturn;\n     }\n \n-  if (partition->main_stmt != NULL)\n-    partition->kind = PKIND_MEMSET;\n+  if (single_store && !single_load)\n+    {\n+      gimple stmt = DR_STMT (single_store);\n+      tree rhs = gimple_assign_rhs1 (stmt);\n+      if (!(integer_zerop (rhs)\n+\t    || integer_all_onesp (rhs)\n+\t    || real_zerop (rhs)\n+\t    || (TREE_CODE (rhs) == CONSTRUCTOR\n+\t\t&& !TREE_CLOBBER_P (rhs))\n+\t    || (INTEGRAL_TYPE_P (TREE_TYPE (rhs))\n+\t\t&& (TYPE_MODE (TREE_TYPE (gimple_assign_lhs (stmt)))\n+\t\t    == TYPE_MODE (unsigned_char_type_node)))))\n+\treturn;\n+      if (TREE_CODE (rhs) == SSA_NAME\n+\t  && !SSA_NAME_IS_DEFAULT_DEF (rhs)\n+\t  && flow_bb_inside_loop_p (loop, gimple_bb (SSA_NAME_DEF_STMT (rhs))))\n+\treturn;\n+      if (!adjacent_dr_p (single_store))\n+\treturn;\n+      partition->kind = PKIND_MEMSET;\n+      partition->main_dr = single_store;\n+    }\n+  else if (single_store && single_load)\n+    {\n+      gimple store = DR_STMT (single_store);\n+      gimple load = DR_STMT (single_load);\n+      /* Direct aggregate copy or via an SSA name temporary.  */\n+      if (load != store\n+\t  && gimple_assign_lhs (load) != gimple_assign_rhs1 (store))\n+\treturn;\n+      if (!adjacent_dr_p (single_store)\n+\t  || !adjacent_dr_p (single_load)\n+\t  || !operand_equal_p (DR_STEP (single_store),\n+\t\t\t       DR_STEP (single_load), 0))\n+\treturn;\n+      partition->kind = PKIND_MEMCPY;\n+      partition->main_dr = single_store;\n+      partition->secondary_dr = single_load;\n+    }\n }\n \n /* For a data reference REF, return the declaration of its base\n@@ -1259,7 +1348,7 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n     dump_rdg_partitions (dump_file, partitions);\n \n   FOR_EACH_VEC_ELT (partition_t, partitions, i, partition)\n-    generate_code_for_partition (loop, rdg, partition, i < nbp - 1);\n+    generate_code_for_partition (loop, partition, i < nbp - 1);\n \n  ldist_done:\n \n@@ -1392,22 +1481,6 @@ tree_loop_distribution (void)\n \t\t  || is_gimple_reg (gimple_assign_lhs (stmt)))\n \t\tcontinue;\n \n-\t      /* If we are only performing pattern detection restrict\n-\t\t what we try to distribute to stores from constants.  */\n-\t      if (!flag_tree_loop_distribution)\n-\t\t{\n-\t\t  tree rhs = gimple_assign_rhs1 (stmt);\n-\t\t  if (!is_gimple_min_invariant (rhs)\n-\t\t      && TREE_CODE (rhs) != CONSTRUCTOR\n-\t\t      && TREE_CODE (rhs) != SSA_NAME)\n-\t\t    continue;\n-\t\t  if (TREE_CODE (rhs) == SSA_NAME\n-\t\t      && !SSA_NAME_IS_DEFAULT_DEF (rhs)\n-\t\t      && flow_bb_inside_loop_p\n-\t\t\t   (loop, gimple_bb (SSA_NAME_DEF_STMT (rhs))))\n-\t\t    continue;\n-\t\t}\n-\n \t      VEC_safe_push (gimple, heap, work_list, stmt);\n \t    }\n \t}"}]}