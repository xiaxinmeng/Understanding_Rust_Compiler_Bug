{"sha": "22bcf65c52d9edcd15b2baa55cb18d7eafe1894a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJiY2Y2NWM1MmQ5ZWRjZDE1YjJiYWE1NWNiMThkN2VhZmUxODk0YQ==", "commit": {"author": {"name": "Gerhard Tonn", "email": "GerhardTonn@swol.de", "date": "2002-04-29T04:14:44Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2002-04-29T04:14:44Z"}, "message": "Makefile.am: Add Linux for S/390 support.\n\n2002-04-29  Gerhard Tonn  <GerhardTonn@swol.de>\n\n\t* Makefile.am: Add Linux for S/390 support.\n\t* Makefile.in: Regenerate.\n\t* configure.in: Add Linux for S/390 support.\n\t* configure: Regenerate.\n\t* include/ffi.h.in: Add Linux for S/390 support.\n\t* src/s390/ffi.c: New file from libffi CVS tree.\n\t* src/s390/sysv.S: New file from libffi CVS tree.\n\nFrom-SVN: r52873", "tree": {"sha": "f39e5328a9363e97902877aab9e253339d93ad1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f39e5328a9363e97902877aab9e253339d93ad1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/comments", "author": null, "committer": null, "parents": [{"sha": "3ef3f3845cd4f9c69e3e81c2cf799854ffe3ef6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ef3f3845cd4f9c69e3e81c2cf799854ffe3ef6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ef3f3845cd4f9c69e3e81c2cf799854ffe3ef6b"}], "stats": {"total": 938, "additions": 867, "deletions": 71}, "files": [{"sha": "dc7ceddd058fce70c05f76174f5b30f3a09cb8d7", "filename": "libffi/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=22bcf65c52d9edcd15b2baa55cb18d7eafe1894a", "patch": "@@ -1,3 +1,13 @@\n+2002-04-29  Gerhard Tonn  <GerhardTonn@swol.de>\n+\n+\t* Makefile.am: Add Linux for S/390 support.\n+\t* Makefile.in: Regenerate.\n+\t* configure.in: Add Linux for S/390 support.\n+\t* configure: Regenerate.\n+\t* include/ffi.h.in: Add Linux for S/390 support.\n+\t* src/s390/ffi.c: New file from libffi CVS tree.\n+\t* src/s390/sysv.S: New file from libffi CVS tree.\n+\n 2002-04-28  Jakub Jelinek  <jakub@redhat.com>\n \n \t* configure.in (HAVE_AS_SPARC_UA_PCREL): Check for working"}, {"sha": "5281c58b7c27e1af0589bfa57546f6edb68c11c5", "filename": "libffi/Makefile.am", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=22bcf65c52d9edcd15b2baa55cb18d7eafe1894a", "patch": "@@ -15,7 +15,8 @@ EXTRA_DIST = LICENSE ChangeLog.v1 src/mips/ffi.c src/mips/n32.S \\\n \t\tsrc/powerpc/ffi_darwin.c \\\n \t\tsrc/powerpc/darwin.S src/powerpc/aix.S \\\n \t\tsrc/powerpc/darwin_closure.S src/powerpc/aix_closures.S \\\n-\t\tsrc/arm/ffi.c src/arm/sysv.S\n+\t\tsrc/arm/ffi.c src/arm/sysv.S \\\n+\t\tsrc/s390/ffi.c src/s390/sysv.S\n \n VPATH = @srcdir@:@srcdir@/src:@srcdir@/src/@TARGETDIR@\n \n@@ -103,6 +104,7 @@ TARGET_SRC_POWERPC = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closur\n TARGET_SRC_POWERPC_AIX = src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/aix_closures.S\n TARGET_SRC_POWERPC_DARWIN = src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S\n TARGET_SRC_ARM =  src/arm/sysv.S src/arm/ffi.c\n+TARGET_SRC_S390 =  src/s390/sysv.S src/s390/ffi.c\n \n ##libffi_la_SOURCES = src/debug.c src/prep_cif.c src/types.c $(TARGET_SRC_@TARGET@)\n ## Work around automake deficiency\n@@ -156,6 +158,10 @@ if ARM\n libffi_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_ARM)\n libffi_convenience_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_ARM)\n endif\n+if S390\n+libffi_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_S390)\n+libffi_convenience_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_S390)\n+endif\n \n AM_CFLAGS = -fexceptions\n "}, {"sha": "0e61ec2e2773d33998642e6663850b398e8c413d", "filename": "libffi/Makefile.in", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=22bcf65c52d9edcd15b2baa55cb18d7eafe1894a", "patch": "@@ -96,7 +96,8 @@ EXTRA_DIST = LICENSE ChangeLog.v1 src/mips/ffi.c src/mips/n32.S \\\n \t\tsrc/powerpc/ffi_darwin.c \\\n \t\tsrc/powerpc/darwin.S src/powerpc/aix.S \\\n \t\tsrc/powerpc/darwin_closure.S src/powerpc/aix_closures.S \\\n-\t\tsrc/arm/ffi.c src/arm/sysv.S\n+\t\tsrc/arm/ffi.c src/arm/sysv.S \\\n+\t\tsrc/s390/ffi.c src/s390/sysv.S\n \n \n VPATH = @srcdir@:@srcdir@/src:@srcdir@/src/@TARGETDIR@\n@@ -174,6 +175,7 @@ TARGET_SRC_POWERPC = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closur\n TARGET_SRC_POWERPC_AIX = src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/aix_closures.S\n TARGET_SRC_POWERPC_DARWIN = src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S\n TARGET_SRC_ARM = src/arm/sysv.S src/arm/ffi.c\n+TARGET_SRC_S390 = src/s390/sysv.S src/s390/ffi.c\n \n libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c \\\n \t\tsrc/raw_api.c src/java_raw_api.c\n@@ -190,6 +192,7 @@ libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c \\\n @POWERPC_AIX_TRUE@libffi_la_SOURCES = @POWERPC_AIX_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_POWERPC_AIX)\n @POWERPC_DARWIN_TRUE@libffi_la_SOURCES = @POWERPC_DARWIN_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_POWERPC_DARWIN)\n @ARM_TRUE@libffi_la_SOURCES = @ARM_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_ARM)\n+@S390_TRUE@libffi_la_SOURCES = @S390_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_S390)\n @MIPS_GCC_TRUE@libffi_convenience_la_SOURCES = @MIPS_GCC_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_MIPS_GCC)\n @MIPS_SGI_TRUE@libffi_convenience_la_SOURCES = @MIPS_SGI_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_MIPS_SGI)\n @X86_TRUE@libffi_convenience_la_SOURCES = @X86_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_X86)\n@@ -202,6 +205,7 @@ libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c \\\n @POWERPC_AIX_TRUE@libffi_convenience_la_SOURCES = @POWERPC_AIX_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_POWERPC_AIX)\n @POWERPC_DARWIN_TRUE@libffi_convenience_la_SOURCES = @POWERPC_DARWIN_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_POWERPC_DARWIN)\n @ARM_TRUE@libffi_convenience_la_SOURCES = @ARM_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_ARM)\n+@S390_TRUE@libffi_convenience_la_SOURCES = @S390_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_S390)\n \n AM_CFLAGS = -fexceptions\n \n@@ -244,6 +248,9 @@ libffi_convenience_la_LIBADD =\n @MIPS_SGI_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n @MIPS_SGI_TRUE@src/java_raw_api.lo src/mips/ffi.lo src/mips/o32.lo \\\n @MIPS_SGI_TRUE@src/mips/n32.lo\n+@S390_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n+@S390_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n+@S390_TRUE@src/s390/sysv.lo src/s390/ffi.lo\n @X86_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n @X86_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n @X86_TRUE@src/x86/ffi.lo src/x86/sysv.lo\n@@ -285,6 +292,9 @@ libffi_la_LIBADD =\n @MIPS_SGI_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n @MIPS_SGI_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n @MIPS_SGI_TRUE@src/mips/ffi.lo src/mips/o32.lo src/mips/n32.lo\n+@S390_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n+@S390_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n+@S390_TRUE@src/s390/sysv.lo src/s390/ffi.lo\n @X86_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo src/types.lo \\\n @X86_TRUE@src/raw_api.lo src/java_raw_api.lo src/x86/ffi.lo \\\n @X86_TRUE@src/x86/sysv.lo\n@@ -579,8 +589,8 @@ distdir: $(DISTFILES)\n \t-chmod 777 $(distdir)\n \t$(mkinstalldirs) $(distdir)/src/alpha $(distdir)/src/arm \\\n \t   $(distdir)/src/m68k $(distdir)/src/mips \\\n-\t   $(distdir)/src/powerpc $(distdir)/src/sparc \\\n-\t   $(distdir)/src/x86\n+\t   $(distdir)/src/powerpc $(distdir)/src/s390 \\\n+\t   $(distdir)/src/sparc $(distdir)/src/x86\n \t@for file in $(DISTFILES); do \\\n \t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n \t  if test -d $$d/$$file; then \\"}, {"sha": "7e3d5edea4bf29e066f67240c7fa0a82c2355e9e", "filename": "libffi/configure", "status": "modified", "additions": 78, "deletions": 66, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure?ref=22bcf65c52d9edcd15b2baa55cb18d7eafe1894a", "patch": "@@ -2386,6 +2386,7 @@ powerpc-*-darwin*) TARGET=POWERPC_DARWIN; TARGETDIR=powerpc;;\n powerpc-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;\n rs6000-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;\n arm*-*-linux-*) TARGET=ARM; TARGETDIR=arm;;\n+s390-*-linux-*) TARGET=S390; TARGETDIR=s390;;\n esac\n \n if test $TARGETDIR = unknown; then\n@@ -2501,8 +2502,17 @@ else\n   ARM_FALSE=\n fi\n \n+\n+if test x$TARGET = xS390; then\n+  S390_TRUE=\n+  S390_FALSE='#'\n+else\n+  S390_TRUE='#'\n+  S390_FALSE=\n+fi\n+\n echo $ac_n \"checking how to run the C preprocessor\"\"... $ac_c\" 1>&6\n-echo \"configure:2506: checking how to run the C preprocessor\" >&5\n+echo \"configure:2516: checking how to run the C preprocessor\" >&5\n # On Suns, sometimes $CPP names a directory.\n if test -n \"$CPP\" && test -d \"$CPP\"; then\n   CPP=\n@@ -2517,13 +2527,13 @@ else\n   # On the NeXT, cc -E runs the code through the compiler's parser,\n   # not just through cpp.\n   cat > conftest.$ac_ext <<EOF\n-#line 2521 \"configure\"\n+#line 2531 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2527: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2537: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2534,13 +2544,13 @@ else\n   rm -rf conftest*\n   CPP=\"${CC-cc} -E -traditional-cpp\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2538 \"configure\"\n+#line 2548 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2544: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2554: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2551,13 +2561,13 @@ else\n   rm -rf conftest*\n   CPP=\"${CC-cc} -nologo -E\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2555 \"configure\"\n+#line 2565 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2561: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2571: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2582,20 +2592,20 @@ fi\n echo \"$ac_t\"\"$CPP\" 1>&6\n \n echo $ac_n \"checking for ANSI C header files\"\"... $ac_c\" 1>&6\n-echo \"configure:2586: checking for ANSI C header files\" >&5\n+echo \"configure:2596: checking for ANSI C header files\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_stdc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2591 \"configure\"\n+#line 2601 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n #include <stdarg.h>\n #include <string.h>\n #include <float.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2599: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2609: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -2612,7 +2622,7 @@ rm -f conftest*\n if test $ac_cv_header_stdc = yes; then\n   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.\n cat > conftest.$ac_ext <<EOF\n-#line 2616 \"configure\"\n+#line 2626 \"configure\"\n #include \"confdefs.h\"\n #include <string.h>\n EOF\n@@ -2630,7 +2640,7 @@ fi\n if test $ac_cv_header_stdc = yes; then\n   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.\n cat > conftest.$ac_ext <<EOF\n-#line 2634 \"configure\"\n+#line 2644 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n EOF\n@@ -2651,7 +2661,7 @@ if test \"$cross_compiling\" = yes; then\n   :\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2655 \"configure\"\n+#line 2665 \"configure\"\n #include \"confdefs.h\"\n #include <ctype.h>\n #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')\n@@ -2662,7 +2672,7 @@ if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);\n exit (0); }\n \n EOF\n-if { (eval echo configure:2666: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:2676: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   :\n else\n@@ -2688,12 +2698,12 @@ fi\n for ac_func in memcpy\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:2692: checking for $ac_func\" >&5\n+echo \"configure:2702: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2697 \"configure\"\n+#line 2707 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -2716,7 +2726,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2720: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2730: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -2743,19 +2753,19 @@ done\n # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works\n # for constant arguments.  Useless!\n echo $ac_n \"checking for working alloca.h\"\"... $ac_c\" 1>&6\n-echo \"configure:2747: checking for working alloca.h\" >&5\n+echo \"configure:2757: checking for working alloca.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_alloca_h'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2752 \"configure\"\n+#line 2762 \"configure\"\n #include \"confdefs.h\"\n #include <alloca.h>\n int main() {\n char *p = alloca(2 * sizeof(int));\n ; return 0; }\n EOF\n-if { (eval echo configure:2759: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2769: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_header_alloca_h=yes\n else\n@@ -2776,12 +2786,12 @@ EOF\n fi\n \n echo $ac_n \"checking for alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:2780: checking for alloca\" >&5\n+echo \"configure:2790: checking for alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_alloca_works'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2785 \"configure\"\n+#line 2795 \"configure\"\n #include \"confdefs.h\"\n \n #ifdef __GNUC__\n@@ -2809,7 +2819,7 @@ int main() {\n char *p = (char *) alloca(1);\n ; return 0; }\n EOF\n-if { (eval echo configure:2813: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2823: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_func_alloca_works=yes\n else\n@@ -2841,12 +2851,12 @@ EOF\n \n \n echo $ac_n \"checking whether alloca needs Cray hooks\"\"... $ac_c\" 1>&6\n-echo \"configure:2845: checking whether alloca needs Cray hooks\" >&5\n+echo \"configure:2855: checking whether alloca needs Cray hooks\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_os_cray'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2850 \"configure\"\n+#line 2860 \"configure\"\n #include \"confdefs.h\"\n #if defined(CRAY) && ! defined(CRAY2)\n webecray\n@@ -2871,12 +2881,12 @@ echo \"$ac_t\"\"$ac_cv_os_cray\" 1>&6\n if test $ac_cv_os_cray = yes; then\n for ac_func in _getb67 GETB67 getb67; do\n   echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:2875: checking for $ac_func\" >&5\n+echo \"configure:2885: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2880 \"configure\"\n+#line 2890 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -2899,7 +2909,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2903: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2913: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -2926,15 +2936,15 @@ done\n fi\n \n echo $ac_n \"checking stack direction for C alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:2930: checking stack direction for C alloca\" >&5\n+echo \"configure:2940: checking stack direction for C alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_c_stack_direction'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n   ac_cv_c_stack_direction=0\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2938 \"configure\"\n+#line 2948 \"configure\"\n #include \"confdefs.h\"\n find_stack_direction ()\n {\n@@ -2953,7 +2963,7 @@ main ()\n   exit (find_stack_direction() < 0);\n }\n EOF\n-if { (eval echo configure:2957: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:2967: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_c_stack_direction=1\n else\n@@ -2976,13 +2986,13 @@ fi\n \n \n echo $ac_n \"checking size of short\"\"... $ac_c\" 1>&6\n-echo \"configure:2980: checking size of short\" >&5\n+echo \"configure:2990: checking size of short\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_short'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 2986 \"configure\"\n+#line 2996 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -2992,7 +3002,7 @@ int main() {\n switch (0) case 0: case (sizeof (short) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:2996: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3006: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_short=$ac_size\n else\n@@ -3015,13 +3025,13 @@ EOF\n \n \n echo $ac_n \"checking size of int\"\"... $ac_c\" 1>&6\n-echo \"configure:3019: checking size of int\" >&5\n+echo \"configure:3029: checking size of int\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_int'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3025 \"configure\"\n+#line 3035 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3031,7 +3041,7 @@ int main() {\n switch (0) case 0: case (sizeof (int) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3035: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3045: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_int=$ac_size\n else\n@@ -3054,13 +3064,13 @@ EOF\n \n \n echo $ac_n \"checking size of long\"\"... $ac_c\" 1>&6\n-echo \"configure:3058: checking size of long\" >&5\n+echo \"configure:3068: checking size of long\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_long'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3064 \"configure\"\n+#line 3074 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3070,7 +3080,7 @@ int main() {\n switch (0) case 0: case (sizeof (long) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3074: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3084: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_long=$ac_size\n else\n@@ -3093,13 +3103,13 @@ EOF\n \n \n echo $ac_n \"checking size of long long\"\"... $ac_c\" 1>&6\n-echo \"configure:3097: checking size of long long\" >&5\n+echo \"configure:3107: checking size of long long\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_long_long'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3103 \"configure\"\n+#line 3113 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3109,7 +3119,7 @@ int main() {\n switch (0) case 0: case (sizeof (long long) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3113: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3123: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_long_long=$ac_size\n else\n@@ -3132,13 +3142,13 @@ EOF\n \n \n echo $ac_n \"checking size of float\"\"... $ac_c\" 1>&6\n-echo \"configure:3136: checking size of float\" >&5\n+echo \"configure:3146: checking size of float\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_float'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3142 \"configure\"\n+#line 3152 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3148,7 +3158,7 @@ int main() {\n switch (0) case 0: case (sizeof (float) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3152: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3162: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_float=$ac_size\n else\n@@ -3171,13 +3181,13 @@ EOF\n \n \n echo $ac_n \"checking size of double\"\"... $ac_c\" 1>&6\n-echo \"configure:3175: checking size of double\" >&5\n+echo \"configure:3185: checking size of double\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_double'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3181 \"configure\"\n+#line 3191 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3187,7 +3197,7 @@ int main() {\n switch (0) case 0: case (sizeof (double) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3191: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3201: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_double=$ac_size\n else\n@@ -3210,13 +3220,13 @@ EOF\n \n \n echo $ac_n \"checking size of long double\"\"... $ac_c\" 1>&6\n-echo \"configure:3214: checking size of long double\" >&5\n+echo \"configure:3224: checking size of long double\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_long_double'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3220 \"configure\"\n+#line 3230 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3226,7 +3236,7 @@ int main() {\n switch (0) case 0: case (sizeof (long double) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3230: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3240: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_long_double=$ac_size\n else\n@@ -3250,13 +3260,13 @@ EOF\n \n \n echo $ac_n \"checking size of void *\"\"... $ac_c\" 1>&6\n-echo \"configure:3254: checking size of void *\" >&5\n+echo \"configure:3264: checking size of void *\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_void_p'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3260 \"configure\"\n+#line 3270 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3266,7 +3276,7 @@ int main() {\n switch (0) case 0: case (sizeof (void *) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3270: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3280: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_void_p=$ac_size\n else\n@@ -3289,14 +3299,14 @@ EOF\n \n \n echo $ac_n \"checking whether byte ordering is bigendian\"\"... $ac_c\" 1>&6\n-echo \"configure:3293: checking whether byte ordering is bigendian\" >&5\n+echo \"configure:3303: checking whether byte ordering is bigendian\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_c_bigendian'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_cv_c_bigendian=unknown\n # See if sys/param.h defines the BYTE_ORDER macro.\n cat > conftest.$ac_ext <<EOF\n-#line 3300 \"configure\"\n+#line 3310 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #include <sys/param.h>\n@@ -3307,11 +3317,11 @@ int main() {\n #endif\n ; return 0; }\n EOF\n-if { (eval echo configure:3311: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3321: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   # It does; now see whether it defined to BIG_ENDIAN or not.\n cat > conftest.$ac_ext <<EOF\n-#line 3315 \"configure\"\n+#line 3325 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #include <sys/param.h>\n@@ -3322,7 +3332,7 @@ int main() {\n #endif\n ; return 0; }\n EOF\n-if { (eval echo configure:3326: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3336: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_c_bigendian=yes\n else\n@@ -3342,7 +3352,7 @@ if test \"$cross_compiling\" = yes; then\n    echo $ac_n \"cross-compiling... \" 2>&6 \n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3346 \"configure\"\n+#line 3356 \"configure\"\n #include \"confdefs.h\"\n main () {\n   /* Are we little or big endian?  From Harbison&Steele.  */\n@@ -3355,7 +3365,7 @@ main () {\n   exit (u.c[sizeof (long) - 1] == 1);\n }\n EOF\n-if { (eval echo configure:3359: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:3369: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_c_bigendian=no\n else\n@@ -3373,7 +3383,7 @@ fi\n echo \"$ac_t\"\"$ac_cv_c_bigendian\" 1>&6\n if test $ac_cv_c_bigendian = unknown; then\n echo $ac_n \"checking to probe for byte ordering\"\"... $ac_c\" 1>&6\n-echo \"configure:3377: checking to probe for byte ordering\" >&5\n+echo \"configure:3387: checking to probe for byte ordering\" >&5\n \n cat >conftest.c <<EOF\n short ascii_mm[] = { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };\n@@ -3423,7 +3433,7 @@ fi\n \n if test x$TARGET == xSPARC; then\n     echo $ac_n \"checking assembler and linker support unaligned pc related relocs\"\"... $ac_c\" 1>&6\n-echo \"configure:3426: checking assembler and linker support unaligned pc related relocs\" >&5\n+echo \"configure:3437: checking assembler and linker support unaligned pc related relocs\" >&5\n if eval \"test \\\"`echo '$''{'libffi_cv_as_sparc_ua_pcrel'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3433,14 +3443,14 @@ else\n \tCFLAGS=\"$CFLAGS -fpic\"\n \tLDFLAGS=\"$LDFLAGS -shared\"\n \tcat > conftest.$ac_ext <<EOF\n-#line 3436 \"configure\"\n+#line 3447 \"configure\"\n #include \"confdefs.h\"\n asm (\".text; foo: nop; .data; .align 4; .byte 0; .uaword %r_disp32(foo); .text\");\n int main() {\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3442: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3454: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   libffi_cv_as_sparc_ua_pcrel=yes\n else\n@@ -3721,6 +3731,8 @@ s%@POWERPC_DARWIN_TRUE@%$POWERPC_DARWIN_TRUE%g\n s%@POWERPC_DARWIN_FALSE@%$POWERPC_DARWIN_FALSE%g\n s%@ARM_TRUE@%$ARM_TRUE%g\n s%@ARM_FALSE@%$ARM_FALSE%g\n+s%@S390_TRUE@%$S390_TRUE%g\n+s%@S390_FALSE@%$S390_FALSE%g\n s%@CPP@%$CPP%g\n s%@ALLOCA@%$ALLOCA%g\n s%@TARGET@%$TARGET%g"}, {"sha": "b2cb516b84acd3f2900308c1e420fec10c4c484d", "filename": "libffi/configure.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.in?ref=22bcf65c52d9edcd15b2baa55cb18d7eafe1894a", "patch": "@@ -61,6 +61,7 @@ powerpc-*-darwin*) TARGET=POWERPC_DARWIN; TARGETDIR=powerpc;;\n powerpc-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;\n rs6000-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;\n arm*-*-linux-*) TARGET=ARM; TARGETDIR=arm;;\n+s390-*-linux-*) TARGET=S390; TARGETDIR=s390;;\n esac\n \n if test $TARGETDIR = unknown; then\n@@ -79,6 +80,7 @@ AM_CONDITIONAL(POWERPC, test x$TARGET = xPOWERPC)\n AM_CONDITIONAL(POWERPC_AIX, test x$TARGET = xPOWERPC_AIX)\n AM_CONDITIONAL(POWERPC_DARWIN, test x$TARGET = xPOWERPC_DARWIN)\n AM_CONDITIONAL(ARM, test x$TARGET = xARM)\n+AM_CONDITIONAL(S390, test x$TARGET = xS390)\n \n AC_HEADER_STDC\n AC_CHECK_FUNCS(memcpy)"}, {"sha": "13aa274f405570ccc0d547d10a1adc76600de922", "filename": "libffi/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2FMakefile.in?ref=22bcf65c52d9edcd15b2baa55cb18d7eafe1894a", "patch": "@@ -99,7 +99,7 @@ DIST_COMMON =  Makefile.am Makefile.in ffi.h.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = gnutar\n+TAR = gtar\n GZIP_ENV = --best\n all: all-redirect\n .SUFFIXES:"}, {"sha": "90dfa5189b94beea7ff1c9e6400d0ed5b8245629", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=22bcf65c52d9edcd15b2baa55cb18d7eafe1894a", "patch": "@@ -251,6 +251,12 @@ typedef enum ffi_abi {\n   FFI_DEFAULT_ABI = FFI_SYSV,\n #endif\n \n+  /* ---- S390 --------------------- */\n+#ifdef S390\n+  FFI_SYSV,\n+  FFI_DEFAULT_ABI = FFI_SYSV,\n+#endif\n+\n   /* Leave this for debugging purposes */\n   FFI_LAST_ABI\n "}, {"sha": "8b514e36c266deec05467cfcc899e641b150a4dc", "filename": "libffi/src/s390/ffi.c", "status": "added", "additions": 589, "deletions": 0, "changes": 589, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2Fsrc%2Fs390%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2Fsrc%2Fs390%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fs390%2Fffi.c?ref=22bcf65c52d9edcd15b2baa55cb18d7eafe1894a", "patch": "@@ -0,0 +1,589 @@\n+/* -----------------------------------------------------------------------\n+   ffi.c - Copyright (c) 2000 Software AG\n+ \n+   S390 Foreign Function Interface\n+ \n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+ \n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+ \n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+/*====================================================================*/\n+/*                          Includes                                  */\n+/*                          --------                                  */\n+/*====================================================================*/\n+ \n+#include <ffi.h>\n+#include <ffi_common.h>\n+ \n+#include <stdlib.h>\n+#include <stdio.h>\n+ \n+/*====================== End of Includes =============================*/\n+ \n+/*====================================================================*/\n+/*                           Defines                                  */\n+/*                           -------                                  */\n+/*====================================================================*/\n+ \n+#define MAX_GPRARGS 5        /* Max. no. of GPR available             */\n+#define MAX_FPRARGS 2        /* Max. no. of FPR available             */\n+ \n+#define STR_GPR     1        /* Structure will fit in 1 or 2 GPR      */\n+#define STR_FPR     2        /* Structure will fit in a FPR           */\n+#define STR_STACK   3        /* Structure needs to go on stack        */\n+ \n+/*===================== End of Defines ===============================*/\n+ \n+/*====================================================================*/\n+/*                            Types                                   */\n+/*                            -----                                   */\n+/*====================================================================*/\n+ \n+typedef struct stackLayout\n+{\n+  int   *backChain;\n+  int   *endOfStack;\n+  int   glue[2];\n+  int   scratch[2];\n+  int   gprArgs[MAX_GPRARGS];\n+  int   notUsed;\n+  union\n+  {\n+    float  f;\n+    double d;\n+  } fprArgs[MAX_FPRARGS];\n+  int   unUsed[8];\n+  int   outArgs[100];\n+} stackLayout;\n+ \n+/*======================== End of Types ==============================*/\n+ \n+/*====================================================================*/\n+/*                          Prototypes                                */\n+/*                          ----------                                */\n+/*====================================================================*/\n+ \n+void ffi_prep_args(stackLayout *, extended_cif *);\n+static int  ffi_check_struct(ffi_type *, unsigned int *);\n+static void ffi_insert_int(int, stackLayout *, int *, int *);\n+static void ffi_insert_int64(long long, stackLayout *, int *, int *);\n+static void ffi_insert_double(double, stackLayout *, int *, int *);\n+ \n+/*====================== End of Prototypes ===========================*/\n+ \n+/*====================================================================*/\n+/*                          Externals                                 */\n+/*                          ---------                                 */\n+/*====================================================================*/\n+ \n+extern void ffi_call_SYSV(void (*)(stackLayout *, extended_cif *),\n+\t\t\t  extended_cif *,\n+\t\t\t  unsigned, unsigned,\n+\t\t\t  unsigned *,\n+\t\t\t  void (*fn)());\n+ \n+/*====================== End of Externals ============================*/\n+ \n+/*====================================================================*/\n+/*                                                                    */\n+/* Name     - ffi_check_struct.                                       */\n+/*                                                                    */\n+/* Function - Determine if a structure can be passed within a         */\n+/*            general or floating point register.                     */\n+/*                                                                    */\n+/*====================================================================*/\n+ \n+int\n+ffi_check_struct(ffi_type *arg, unsigned int *strFlags)\n+{\n+ ffi_type *element;\n+ int      i_Element;\n+ \n+ for (i_Element = 0; arg->elements[i_Element]; i_Element++) {\n+   element = arg->elements[i_Element];\n+   switch (element->type) {\n+   case FFI_TYPE_DOUBLE :\n+     *strFlags |= STR_FPR;\n+     break;\n+     \n+   case FFI_TYPE_STRUCT :\n+     *strFlags |= ffi_check_struct(element, strFlags);\n+     break;\n+     \n+   default :\n+     *strFlags |= STR_GPR;\n+   }\n+ }\n+ return (*strFlags);\n+}\n+ \n+/*======================== End of Routine ============================*/\n+ \n+/*====================================================================*/\n+/*                                                                    */\n+/* Name     - ffi_insert_int.                                         */\n+/*                                                                    */\n+/* Function - Insert an integer parameter in a register if there are  */\n+/*            spares else on the stack.                               */\n+/*                                                                    */\n+/*====================================================================*/\n+ \n+void\n+ffi_insert_int(int gprValue, stackLayout *stack,\n+               int *intArgC, int *outArgC)\n+{\n+  if (*intArgC < MAX_GPRARGS) {\n+    stack->gprArgs[*intArgC] = gprValue;\n+    *intArgC += 1;\n+  }\n+  else {\n+    stack->outArgs[*outArgC++] = gprValue;\n+    *outArgC += 1;\n+  }\n+}\n+ \n+/*======================== End of Routine ============================*/\n+ \n+/*====================================================================*/\n+/*                                                                    */\n+/* Name     - ffi_insert_int64.                                       */\n+/*                                                                    */\n+/* Function - Insert a long long parameter in registers if there are  */\n+/*            spares else on the stack.                               */\n+/*                                                                    */\n+/*====================================================================*/\n+ \n+void\n+ffi_insert_int64(long long llngValue, stackLayout *stack,\n+                 int *intArgC, int *outArgC)\n+{\n+ \n+  if (*intArgC < (MAX_GPRARGS-1)) {\n+    memcpy(&stack->gprArgs[*intArgC],\n+\t   &llngValue, sizeof(long long));\t\n+    *intArgC += 2;\n+  }\n+  else {\n+    memcpy(&stack->outArgs[*outArgC],\n+\t   &llngValue, sizeof(long long));\n+    *outArgC += 2;\n+  }\n+ \n+}\n+ \n+/*======================== End of Routine ============================*/\n+ \n+/*====================================================================*/\n+/*                                                                    */\n+/* Name     - ffi_insert_double.                                      */\n+/*                                                                    */\n+/* Function - Insert a double parameter in a FP register if there is  */\n+/*            a spare else on the stack.                              */\n+/*                                                                    */\n+/*====================================================================*/\n+ \n+void\n+ffi_insert_double(double dblValue, stackLayout *stack,\n+                  int *fprArgC, int *outArgC)\n+{\n+ \n+  if (*fprArgC < MAX_FPRARGS) {\n+    stack->fprArgs[*fprArgC].d = dblValue;\n+    *fprArgC += 1;\n+  }\n+  else {\n+    memcpy(&stack->outArgs[*outArgC],\n+\t   &dblValue,sizeof(double));\n+    *outArgC += 2;\n+  }\n+ \n+}\n+ \n+/*======================== End of Routine ============================*/\n+ \n+/*====================================================================*/\n+/*                                                                    */\n+/* Name     - ffi_prep_args.                                          */\n+/*                                                                    */\n+/* Function - Prepare parameters for call to function.                */\n+/*                                                                    */\n+/* ffi_prep_args is called by the assembly routine once stack space   */\n+/* has been allocated for the function's arguments.                   */\n+/*                                                                    */\n+/* The stack layout we want looks like this:                          */\n+/* *------------------------------------------------------------*     */\n+/* |  0     | Back chain (a 0 here signifies end of back chain) |     */\n+/* +--------+---------------------------------------------------+     */\n+/* |  4     | EOS (end of stack, not used on Linux for S390)    |     */\n+/* +--------+---------------------------------------------------+     */\n+/* |  8     | Glue used in other linkage formats                |     */\n+/* +--------+---------------------------------------------------+     */\n+/* | 12     | Glue used in other linkage formats                |     */\n+/* +--------+---------------------------------------------------+     */\n+/* | 16     | Scratch area                                      |     */\n+/* +--------+---------------------------------------------------+     */\n+/* | 20     | Scratch area                                      |     */\n+/* +--------+---------------------------------------------------+     */\n+/* | 24     | GPR parameter register 1                          |     */\n+/* +--------+---------------------------------------------------+     */\n+/* | 28     | GPR parameter register 2                          |     */\n+/* +--------+---------------------------------------------------+     */\n+/* | 32     | GPR parameter register 3                          |     */\n+/* +--------+---------------------------------------------------+     */\n+/* | 36     | GPR parameter register 4                          |     */\n+/* +--------+---------------------------------------------------+     */\n+/* | 40     | GPR parameter register 5                          |     */\n+/* +--------+---------------------------------------------------+     */\n+/* | 44     | Unused                                            |     */\n+/* +--------+---------------------------------------------------+     */\n+/* | 48     | FPR parameter register 1                          |     */\n+/* +--------+---------------------------------------------------+     */\n+/* | 56     | FPR parameter register 2                          |     */\n+/* +--------+---------------------------------------------------+     */\n+/* | 64     | Unused                                            |     */\n+/* +--------+---------------------------------------------------+     */\n+/* | 96     | Outgoing args (length x)                          |     */\n+/* +--------+---------------------------------------------------+     */\n+/* | 96+x   | Copy area for structures (length y)               |     */\n+/* +--------+---------------------------------------------------+     */\n+/* | 96+x+y | Possible stack alignment                          |     */\n+/* *------------------------------------------------------------*     */\n+/*                                                                    */\n+/*====================================================================*/\n+ \n+void\n+ffi_prep_args(stackLayout *stack, extended_cif *ecif)\n+{\n+  const unsigned bytes = ecif->cif->bytes;\n+  const unsigned flags = ecif->cif->flags;\n+ \n+  /*----------------------------------------------------------*/\n+  /* Pointer to the copy area on stack for structures         */\n+  /*----------------------------------------------------------*/\n+  char *copySpace = (char *) stack + bytes + sizeof(stackLayout);\n+ \n+  /*----------------------------------------------------------*/\n+  /* Count of general and floating point register usage       */\n+  /*----------------------------------------------------------*/\n+  int intArgC = 0,\n+    fprArgC = 0,\n+    outArgC = 0;\n+ \n+  int      i;\n+  ffi_type **ptr;\n+  void     **p_argv;\n+  size_t   structCopySize;\n+  unsigned gprValue, strFlags = 0;\n+  unsigned long long llngValue;\n+  double   dblValue;\n+ \n+  /* Now for the arguments.  */\n+  p_argv  = ecif->avalue;\n+ \n+  /*----------------------------------------------------------------------*/\n+  /* If we returning a structure then we set the first parameter register */\n+  /* to the address of where we are returning this structure              */\n+  /*----------------------------------------------------------------------*/\n+  if (flags == FFI_TYPE_STRUCT)\n+    stack->gprArgs[intArgC++] = (int) ecif->rvalue;\n+ \n+  for (ptr = ecif->cif->arg_types, i = ecif->cif->nargs;\n+       i > 0;\n+       i--, ptr++, p_argv++)\n+    {\n+      switch ((*ptr)->type) {\n+ \n+      case FFI_TYPE_FLOAT:\n+\tif (fprArgC < MAX_FPRARGS)\n+\t  stack->fprArgs[fprArgC++].f = *(float *) *p_argv;\n+\telse\n+\t  stack->outArgs[outArgC++] = *(int *) *p_argv;\n+\tbreak;\n+ \n+      case FFI_TYPE_DOUBLE:\n+\tdblValue = *(double *) *p_argv;\n+\tffi_insert_double(dblValue, stack, &fprArgC, &outArgC);\n+\tbreak;\n+\t\n+      case FFI_TYPE_UINT64:\n+      case FFI_TYPE_SINT64:\n+\tllngValue = *(unsigned long long *) *p_argv;\n+\tffi_insert_int64(llngValue, stack, &intArgC, &outArgC);\n+\tbreak;\n+ \n+      case FFI_TYPE_UINT8:\n+\tgprValue = *(unsigned char *)*p_argv;\n+\tffi_insert_int(gprValue, stack, &intArgC, &outArgC);\n+\tbreak;\n+ \n+      case FFI_TYPE_SINT8:\n+\tgprValue = *(signed char *)*p_argv;\n+\tffi_insert_int(gprValue, stack, &intArgC, &outArgC);\n+\tbreak;\n+ \n+      case FFI_TYPE_UINT16:\n+\tgprValue = *(unsigned short *)*p_argv;\n+\tffi_insert_int(gprValue, stack, &intArgC, &outArgC);\n+\tbreak;\n+ \n+      case FFI_TYPE_SINT16:\n+\tgprValue = *(signed short *)*p_argv;\n+\tffi_insert_int(gprValue, stack, &intArgC, &outArgC);\n+\tbreak;\n+ \n+      case FFI_TYPE_STRUCT:\n+\t/*--------------------------------------------------*/\n+\t/* If structure > 8 bytes then it goes on the stack */\n+\t/*--------------------------------------------------*/\n+\tif (((*ptr)->size > 8) ||\n+\t    ((*ptr)->size > 4  &&\n+\t     (*ptr)->size < 8))\n+\t  strFlags = STR_STACK;\n+\telse\n+\t  strFlags = ffi_check_struct((ffi_type *) *ptr, &strFlags);\n+ \n+\tswitch (strFlags) {\n+\t/*-------------------------------------------*/\n+\t/* Structure that will fit in one or two GPR */\n+\t/*-------------------------------------------*/\n+\tcase STR_GPR :\n+\t  if ((*ptr)->size <= 4) {\n+\t    gprValue = *(unsigned int *) *p_argv;\n+\t    gprValue = gprValue >> ((4 - (*ptr)->size) * 8);\n+\t    ffi_insert_int(gprValue, stack, &intArgC, &outArgC);\n+\t  }\n+\t  else {\n+\t    llngValue = *(unsigned long long *) *p_argv;\n+\t    ffi_insert_int64(llngValue, stack, &intArgC, &outArgC);\n+\t  }\n+\t  break;\n+ \n+\t/*-------------------------------------------*/\n+\t/* Structure that will fit in one FPR        */\n+\t/*-------------------------------------------*/\n+\tcase STR_FPR :\n+\t  dblValue = *(double *) *p_argv;\n+\t  ffi_insert_double(dblValue, stack, &fprArgC, &outArgC);\n+\t  break;\n+ \n+\t/*-------------------------------------------*/\n+\t/* Structure that must be copied to stack    */\n+\t/*-------------------------------------------*/\n+\tdefault :\n+\t  structCopySize = (((*ptr)->size + 15) & ~0xF);\n+\t  copySpace -= structCopySize;\n+\t  memcpy(copySpace, (char *)*p_argv, (*ptr)->size);\n+\t  gprValue = (unsigned) copySpace;\n+\t  if (intArgC < MAX_GPRARGS)\n+\t    stack->gprArgs[intArgC++] = gprValue;\n+\t  else\n+\t    stack->outArgs[outArgC++] = gprValue;\n+\t}\n+\tbreak;\n+ \n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+      case FFI_TYPE_LONGDOUBLE:\n+\tstructCopySize = (((*ptr)->size + 15) & ~0xF);\n+\tcopySpace -= structCopySize;\n+\tmemcpy(copySpace, (char *)*p_argv, (*ptr)->size);\n+\tgprValue = (unsigned) copySpace;\n+\tif (intArgC < MAX_GPRARGS)\n+\t  stack->gprArgs[intArgC++] = gprValue;\n+\telse\n+\t  stack->outArgs[outArgC++] = gprValue;\n+\tbreak;\n+#endif\n+ \n+      case FFI_TYPE_INT:\n+      case FFI_TYPE_UINT32:\n+      case FFI_TYPE_SINT32:\n+      case FFI_TYPE_POINTER:\n+\tgprValue = *(unsigned *)*p_argv;\n+\tif (intArgC < MAX_GPRARGS)\n+\t  stack->gprArgs[intArgC++] = gprValue;\n+\telse\n+\t  stack->outArgs[outArgC++] = gprValue;\n+\tbreak;\n+ \n+      }\n+    }\n+}\n+\n+/*======================== End of Routine ============================*/\n+ \n+/*====================================================================*/\n+/*                                                                    */\n+/* Name     - ffi_prep_cif_machdep.                                   */\n+/*                                                                    */\n+/* Function - Perform machine dependent CIF processing.               */\n+/*                                                                    */\n+/*====================================================================*/\n+ \n+ffi_status\n+ffi_prep_cif_machdep(ffi_cif *cif)\n+{\n+  int i;\n+  ffi_type **ptr;\n+  unsigned bytes;\n+  int fpArgC  = 0,\n+    intArgC = 0;\n+  unsigned flags = 0;\n+  unsigned structCopySize = 0;\n+ \n+  /*-----------------------------------------------------------------*/\n+  /* Extra space required in stack for overflow parameters.          */\n+  /*-----------------------------------------------------------------*/\n+  bytes = 0;\n+ \n+  /*--------------------------------------------------------*/\n+  /* Return value handling.  The rules are as follows:\t    */\n+  /* - 32-bit (or less) integer values are returned in gpr2 */\n+  /* - Structures are returned as pointers in gpr2\t    */\n+  /* - 64-bit integer values are returned in gpr2 and 3\t    */\n+  /* - Single/double FP values are returned in fpr0\t    */\n+  /*--------------------------------------------------------*/\n+  flags = cif->rtype->type;\n+ \n+  /*------------------------------------------------------------------------*/\n+  /* The first MAX_GPRARGS words of integer arguments, and the      \t    */\n+  /* first MAX_FPRARGS floating point arguments, go in registers; the rest  */\n+  /* goes on the stack.  Structures and long doubles (if not equivalent     */\n+  /* to double) are passed as a pointer to a copy of the structure.\t    */\n+  /* Stuff on the stack needs to keep proper alignment.  \t\t    */\n+  /*------------------------------------------------------------------------*/\n+  for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)\n+    {\n+      switch ((*ptr)->type)\n+\t{\n+\tcase FFI_TYPE_FLOAT:\n+\tcase FFI_TYPE_DOUBLE:\n+\t  fpArgC++;\n+\t  if (fpArgC > MAX_FPRARGS && intArgC%2 != 0)\n+\t    intArgC++;\n+\t  break;\n+ \n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_SINT64:\n+\t  /*----------------------------------------------------*/\n+\t  /* 'long long' arguments are passed as two words, but */\n+\t  /* either both words must fit in registers or both go */\n+\t  /* on the stack.  If they go on the stack, they must  */\n+\t  /* be 8-byte-aligned. \t\t\t \t      */\n+\t  /*----------------------------------------------------*/\n+\t  if ((intArgC == MAX_GPRARGS-1) ||\n+\t      (intArgC >= MAX_GPRARGS)   &&\n+\t      (intArgC%2 != 0))\n+\t    intArgC++;\n+\t  intArgC += 2;\n+\t  break;\n+ \n+\tcase FFI_TYPE_STRUCT:\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tcase FFI_TYPE_LONGDOUBLE:\n+#endif\n+\t  /*----------------------------------------------------*/\n+\t  /* We must allocate space for a copy of these to      */\n+\t  /* enforce pass-by-value. Pad the space up to a       */\n+\t  /* multiple of 16 bytes (the maximum alignment \t      */\n+\t  /* required for anything under the SYSV ABI). \t      */\n+\t  /*----------------------------------------------------*/\n+\t  structCopySize += ((*ptr)->size + 15) & ~0xF;\n+\t  /*----------------------------------------------------*/\n+\t  /* Fall through (allocate space for the pointer).     */\n+\t  /*----------------------------------------------------*/\n+ \n+\tdefault:\n+\t  /*----------------------------------------------------*/\n+\t  /* Everything else is passed as a 4-byte word in a    */\n+\t  /* GPR either the object itself or a pointer to it.   */\n+\t  /*----------------------------------------------------*/\n+\t  intArgC++;\n+\t  break;\n+\t}\n+    }\n+ \n+  /*-----------------------------------------------------------------*/\n+  /* Stack space.                                                    */\n+  /*-----------------------------------------------------------------*/\n+  if (intArgC > MAX_GPRARGS)\n+    bytes += (intArgC - MAX_GPRARGS) * sizeof(int);\n+  if (fpArgC > MAX_FPRARGS)\n+    bytes += (fpArgC - MAX_FPRARGS) * sizeof(double);\n+ \n+  /*-----------------------------------------------------------------*/\n+  /* The stack space allocated needs to be a multiple of 16 bytes.   */\n+  /*-----------------------------------------------------------------*/\n+  bytes = (bytes + 15) & ~0xF;\n+ \n+  /*-----------------------------------------------------------------*/\n+  /* Add in the space for the copied structures.                     */\n+  /*-----------------------------------------------------------------*/\n+  bytes += structCopySize;\n+ \n+  cif->flags = flags;\n+  cif->bytes = bytes;\n+ \n+  return FFI_OK;\n+}\n+ \n+/*======================== End of Routine ============================*/\n+ \n+/*====================================================================*/\n+/*                                                                    */\n+/* Name     - ffi_call.                                               */\n+/*                                                                    */\n+/* Function - Call the FFI routine.                                   */\n+/*                                                                    */\n+/*====================================================================*/\n+ \n+void\n+ffi_call(ffi_cif *cif,\n+\t void (*fn)(),\n+\t void *rvalue,\n+\t void **avalue)\n+{\n+  extended_cif ecif;\n+ \n+  ecif.cif    = cif;\n+  ecif.avalue = avalue;\n+ \n+  /*-----------------------------------------------------------------*/\n+  /* If the return value is a struct and we don't have a return      */\n+  /* value address then we need to make one                          */\n+  /*-----------------------------------------------------------------*/\n+  if ((rvalue == NULL) &&\n+      (cif->rtype->type == FFI_TYPE_STRUCT))\n+    ecif.rvalue = alloca(cif->rtype->size);\n+  else\n+    ecif.rvalue = rvalue;\n+ \n+  switch (cif->abi)\n+    {\n+    case FFI_SYSV:\n+      ffi_call_SYSV(ffi_prep_args,\n+\t\t    &ecif, cif->bytes,\n+\t\t    cif->flags, ecif.rvalue, fn);\n+      break;\n+ \n+    default:\n+      FFI_ASSERT(0);\n+      break;\n+    }\n+}\n+ \n+/*======================== End of Routine ============================*/"}, {"sha": "afaf1ea1ca302cbe673d9367d22adfbd9cc47441", "filename": "libffi/src/s390/sysv.S", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2Fsrc%2Fs390%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22bcf65c52d9edcd15b2baa55cb18d7eafe1894a/libffi%2Fsrc%2Fs390%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fs390%2Fsysv.S?ref=22bcf65c52d9edcd15b2baa55cb18d7eafe1894a", "patch": "@@ -0,0 +1,161 @@\n+/* -----------------------------------------------------------------------\n+   sysv.S - Copyright (c) 2000 Software AG\n+ \n+   S390 Foreign Function Interface\n+ \n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+ \n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+ \n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+ \n+#define LIBFFI_ASM\t\n+#include <ffi.h>\n+#ifdef HAVE_MACHINE_ASM_H\n+#include <machine/asm.h>\n+#endif\n+\t\n+.text\n+ \n+\t# r2:\tffi_prep_args\n+\t# r3:\t&ecif\n+\t# r4:\tcif->bytes\n+\t# r5:\tfig->flags\n+\t# r6:\tecif.rvalue\n+\t# sp+0: fn\n+ \n+\t# This assumes we are using gas.\n+\t.globl\tffi_call_SYSV\n+\t.type\tffi_call_SYSV,%function\n+ffi_call_SYSV:\n+\t# Save registers\n+\tstm\t%r7,%r15,28(%r15)\n+\tl\t%r7,96(%r15)\t       # Get A(fn)\n+\tlr\t%r0,%r15\n+\tahi\t%r15,-128\t       # Make room for my args\n+\tst\t%r0,0(%r15)\t       # Set backchain\n+\tlr\t%r11,%r15\t       # Establish my stack register\n+\tsr\t%r15,%r4\t       # Make room for fn args\n+\tahi\t%r15,-96\t       # Make room for new frame\n+\tlr\t%r10,%r15\t       # Establish stack build area\n+\tahi\t%r15,-96\t       # Stack for next call\n+\tlr\t%r1,%r7\n+\tstm\t%r2,%r7,96(%r11)       # Save args on my stack\n+ \n+#------------------------------------------------------------------\n+#\tmove first 3 parameters in registers\n+#------------------------------------------------------------------\n+\tlr\t%r9,%r2\t\t       # r9:\t &ffi_prep_args\n+\tlr\t%r2,%r10\t       # Parm 1: &stack Parm 2: &ecif\n+\tbasr\t%r14,%r9\t       # call ffi_prep_args\n+ \n+#------------------------------------------------------------------\n+#\tload  first 5 parameter registers\n+#------------------------------------------------------------------\n+\tlm\t%r2,%r6,24(%r10)\n+ \n+#------------------------------------------------------------------\n+#\tload  fp parameter registers\n+#------------------------------------------------------------------\n+\tld\t%f0,48(%r10)\n+\tld\t%f2,56(%r10)\n+ \n+#------------------------------------------------------------------\n+#\tcall  function\n+#------------------------------------------------------------------\n+\tlr\t%r15,%r10\t       # Set new stack\n+\tl\t%r9,116(%r11)\t       # Get &fn\n+\tbasr\t%r14,%r9\t       # Call function\n+ \n+#------------------------------------------------------------------\n+#\tOn return:\n+#\t   r2: Return value (r3: Return value + 4 for long long)\n+#------------------------------------------------------------------\n+ \n+#------------------------------------------------------------------\n+#\tIf the return value pointer is NULL, assume no return value.\n+#------------------------------------------------------------------\n+\ticm\t%r6,15,112(%r11)\n+\tjz\t.Lepilogue\n+ \n+\tl\t%r5,108(%r11)\t       # Get return type\n+#------------------------------------------------------------------\n+#\treturn INT\n+#------------------------------------------------------------------\n+\tchi\t%r5,FFI_TYPE_INT\n+\tjne\t.Lchk64\n+ \n+\tst\t%r2,0(%r6)\n+\tj\t.Lepilogue\n+ \n+.Lchk64:\n+#------------------------------------------------------------------\n+#\treturn LONG LONG (signed/unsigned)\n+#------------------------------------------------------------------\n+\tchi\t%r5,FFI_TYPE_UINT64\n+\tje\t.LdoLongLong\n+ \n+\tchi\t%r5,FFI_TYPE_SINT64\n+\tjne\t.LchkFloat\n+ \n+.LdoLongLong:\n+\tstm\t%r2,%r3,0(%r6)\n+\tj\t.Lepilogue\n+ \n+.LchkFloat:\n+#------------------------------------------------------------------\n+#\treturn FLOAT\n+#------------------------------------------------------------------\n+\tchi\t%r5,FFI_TYPE_FLOAT\n+\tjne\t.LchkDouble\n+ \n+\tstd\t%f0,0(%r6)\n+\tj\t.Lepilogue\n+ \n+.LchkDouble:\n+#------------------------------------------------------------------\n+#\treturn DOUBLE or LONGDOUBLE\n+#------------------------------------------------------------------\n+\tchi\t%r5,FFI_TYPE_DOUBLE\n+\tjne\t.LchkStruct\n+ \n+\tstd\t%f0,0(%r6)\n+\tstd\t%f2,8(%r6)\n+\tj\t.Lepilogue\n+ \n+.LchkStruct:\n+#------------------------------------------------------------------\n+# Structure - rvalue already set as sent as 1st parm to routine\n+#------------------------------------------------------------------\n+\tchi\t%r5,FFI_TYPE_STRUCT\n+\tje\t.Lepilogue\n+ \n+.Ldefault:\n+#------------------------------------------------------------------\n+#\treturn a pointer\n+#------------------------------------------------------------------\n+\tst\t%r2,0(%r6)\n+\tj\t.Lepilogue\n+ \n+.Lepilogue:\n+\tl\t%r15,0(%r11)\n+\tl\t%r4,56(%r15)\n+\tlm\t%r7,%r15,28(%r15)\n+\tbr\t%r4\n+ \n+.ffi_call_SYSV_end:\n+\t.size\t ffi_call_SYSV,.ffi_call_SYSV_end-ffi_call_SYSV"}]}