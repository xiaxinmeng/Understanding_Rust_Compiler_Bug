{"sha": "b080c137d7b249435e302fc38b3e3745deace292", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA4MGMxMzdkN2IyNDk0MzVlMzAyZmMzOGIzZTM3NDVkZWFjZTI5Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-08-02T21:46:08Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-08-02T21:46:08Z"}, "message": "(reload): Add IN_ADDR to IN_ADDR_ADDR when computing needs since they conflict.\n\nFrom-SVN: r14635", "tree": {"sha": "3c9ce244d96f3383f90e54dfaa1fd7fc26c9953a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c9ce244d96f3383f90e54dfaa1fd7fc26c9953a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b080c137d7b249435e302fc38b3e3745deace292", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b080c137d7b249435e302fc38b3e3745deace292", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b080c137d7b249435e302fc38b3e3745deace292", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b080c137d7b249435e302fc38b3e3745deace292/comments", "author": null, "committer": null, "parents": [{"sha": "505923a0ad799567807fdf4051b9554c56d53d52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/505923a0ad799567807fdf4051b9554c56d53d52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/505923a0ad799567807fdf4051b9554c56d53d52"}], "stats": {"total": 20, "additions": 10, "deletions": 10}, "files": [{"sha": "a3361abbfadfabb55e8f9ee1c43e714ea4a46674", "filename": "gcc/reload1.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b080c137d7b249435e302fc38b3e3745deace292/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b080c137d7b249435e302fc38b3e3745deace292/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=b080c137d7b249435e302fc38b3e3745deace292", "patch": "@@ -1193,7 +1193,6 @@ reload (first, global, dumpfile)\n \t\t      new_basic_block_needs = 1;\n \t\t    }\n \n-\n \t\t  mode = reload_inmode[i];\n \t\t  if (GET_MODE_SIZE (reload_outmode[i]) > GET_MODE_SIZE (mode))\n \t\t    mode = reload_outmode[i];\n@@ -1325,11 +1324,10 @@ reload (first, global, dumpfile)\n \t\t      for (in_max = 0, out_max = 0, k = 0;\n \t\t\t   k < reload_n_operands; k++)\n \t\t\t{\n-\t\t\t  in_max\n-\t\t\t    = MAX (in_max, insn_needs.in_addr[k].regs[j][i]);\n \t\t\t  in_max\n \t\t\t    = MAX (in_max,\n-\t\t\t\t   insn_needs.in_addr_addr[k].regs[j][i]);\n+\t\t\t\t   (insn_needs.in_addr[k].regs[j][i]\n+\t\t\t\t    + insn_needs.in_addr_addr[k].regs[j][i]));\n \t\t\t  out_max\n \t\t\t    = MAX (out_max, insn_needs.out_addr[k].regs[j][i]);\n \t\t\t  out_max\n@@ -5437,12 +5435,14 @@ choose_reload_regs (insn, avoid_return_reg)\n \t  register int r = reload_order[j];\n \n \t  /* Ignore reloads that got marked inoperative.  */\n-\t  if (reload_out[r] == 0 && reload_in[r] == 0 && ! reload_secondary_p[r])\n+\t  if (reload_out[r] == 0 && reload_in[r] == 0\n+\t      && ! reload_secondary_p[r])\n \t    continue;\n \n \t  /* If find_reloads chose a to use reload_in or reload_out as a reload\n-\t     register, we don't need to chose one.  Otherwise, try even if it found\n-\t     one since we might save an insn if we find the value lying around.  */\n+\t     register, we don't need to chose one.  Otherwise, try even if it\n+\t     found one since we might save an insn if we find the value lying\n+\t     around.  */\n \t  if (reload_in[r] != 0 && reload_reg_rtx[r] != 0\n \t      && (rtx_equal_p (reload_in[r], reload_reg_rtx[r])\n \t\t  || rtx_equal_p (reload_out[r], reload_reg_rtx[r])))\n@@ -5474,9 +5474,9 @@ choose_reload_regs (insn, avoid_return_reg)\n \t     an object that is already in a register of the desired class.\n \t     This would avoid the need for the secondary reload register.\n \t     But this is complex because we can't easily determine what\n-\t     objects might want to be loaded via this reload.  So let a register\n-\t     be allocated here.  In `emit_reload_insns' we suppress one of the\n-\t     loads in the case described above.  */\n+\t     objects might want to be loaded via this reload.  So let a\n+\t     register be allocated here.  In `emit_reload_insns' we suppress\n+\t     one of the loads in the case described above.  */\n \n \t  if (inheritance)\n \t    {"}]}