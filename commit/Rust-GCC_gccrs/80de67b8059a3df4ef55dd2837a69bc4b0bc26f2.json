{"sha": "80de67b8059a3df4ef55dd2837a69bc4b0bc26f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBkZTY3YjgwNTlhM2RmNGVmNTVkZDI4MzdhNjliYzRiMGJjMjZmMg==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2012-10-16T13:26:31Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2012-10-16T13:26:31Z"}, "message": "reload.c (find_reloads_subreg_address): Remove FORCE_REPLACE parameter.\n\n\t* reload.c (find_reloads_subreg_address): Remove FORCE_REPLACE\n\tparameter.  Always replace normal subreg with memory reference\n\twhenever possible.  Return NULL otherwise.\n\t(find_reloads_toplev): Always call find_reloads_subreg_address\n\tfor subregs of registers equivalent to a memory location.\n\tOnly recurse further if find_reloads_subreg_address fails.\n\t(find_reloads_address_1): Only call find_reloads_subreg_address\n\tfor subregs of registers equivalent to a memory location.\n\tProperly handle failure of find_reloads_subreg_address.\n\nFrom-SVN: r192499", "tree": {"sha": "41102d1f4e271cf836121d253092c752e162bdd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41102d1f4e271cf836121d253092c752e162bdd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80de67b8059a3df4ef55dd2837a69bc4b0bc26f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80de67b8059a3df4ef55dd2837a69bc4b0bc26f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80de67b8059a3df4ef55dd2837a69bc4b0bc26f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80de67b8059a3df4ef55dd2837a69bc4b0bc26f2/comments", "author": null, "committer": null, "parents": [{"sha": "16e82b2535b1dce10bd48175b11350b3301e6064", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e82b2535b1dce10bd48175b11350b3301e6064", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16e82b2535b1dce10bd48175b11350b3301e6064"}], "stats": {"total": 297, "additions": 143, "deletions": 154}, "files": [{"sha": "56a2f56e7712600c7e86ff763cf8bd4f21a55f66", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80de67b8059a3df4ef55dd2837a69bc4b0bc26f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80de67b8059a3df4ef55dd2837a69bc4b0bc26f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=80de67b8059a3df4ef55dd2837a69bc4b0bc26f2", "patch": "@@ -1,3 +1,15 @@\n+2012-10-16  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* reload.c (find_reloads_subreg_address): Remove FORCE_REPLACE\n+\tparameter.  Always replace normal subreg with memory reference\n+\twhenever possible.  Return NULL otherwise.\n+\t(find_reloads_toplev): Always call find_reloads_subreg_address\n+\tfor subregs of registers equivalent to a memory location.\n+\tOnly recurse further if find_reloads_subreg_address fails.\n+\t(find_reloads_address_1): Only call find_reloads_subreg_address\n+\tfor subregs of registers equivalent to a memory location.\n+\tProperly handle failure of find_reloads_subreg_address.\n+\n 2012-10-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/54796"}, {"sha": "91521b1633698650852bdc1aa814d6d0d90482c5", "filename": "gcc/reload.c", "status": "modified", "additions": 131, "deletions": 154, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80de67b8059a3df4ef55dd2837a69bc4b0bc26f2/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80de67b8059a3df4ef55dd2837a69bc4b0bc26f2/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=80de67b8059a3df4ef55dd2837a69bc4b0bc26f2", "patch": "@@ -282,7 +282,7 @@ static int find_reloads_address_1 (enum machine_mode, addr_space_t, rtx, int,\n static void find_reloads_address_part (rtx, rtx *, enum reg_class,\n \t\t\t\t       enum machine_mode, int,\n \t\t\t\t       enum reload_type, int);\n-static rtx find_reloads_subreg_address (rtx, int, int, enum reload_type,\n+static rtx find_reloads_subreg_address (rtx, int, enum reload_type,\n \t\t\t\t\tint, rtx, int *);\n static void copy_replacements_1 (rtx *, rtx *, int);\n static int find_inc_amount (rtx, rtx);\n@@ -4810,31 +4810,19 @@ find_reloads_toplev (rtx x, int opnum, enum reload_type type,\n \t}\n \n       /* If the subreg contains a reg that will be converted to a mem,\n-\t convert the subreg to a narrower memref now.\n-\t Otherwise, we would get (subreg (mem ...) ...),\n-\t which would force reload of the mem.\n-\n-\t We also need to do this if there is an equivalent MEM that is\n-\t not offsettable.  In that case, alter_subreg would produce an\n-\t invalid address on big-endian machines.\n-\n-\t For machines that extend byte loads, we must not reload using\n-\t a wider mode if we have a paradoxical SUBREG.  find_reloads will\n-\t force a reload in that case.  So we should not do anything here.  */\n+\t attempt to convert the whole subreg to a (narrower or wider)\n+\t memory reference instead.  If this succeeds, we're done --\n+\t otherwise fall through to check whether the inner reg still\n+\t needs address reloads anyway.  */\n \n       if (regno >= FIRST_PSEUDO_REGISTER\n-#ifdef LOAD_EXTEND_OP\n-\t  && !paradoxical_subreg_p (x)\n-#endif\n-\t  && (reg_equiv_address (regno) != 0\n-\t      || (reg_equiv_mem (regno) != 0\n-\t\t  && (! strict_memory_address_addr_space_p\n-\t\t      (GET_MODE (x), XEXP (reg_equiv_mem (regno), 0),\n-\t\t       MEM_ADDR_SPACE (reg_equiv_mem (regno)))\n-\t\t      || ! offsettable_memref_p (reg_equiv_mem (regno))\n-\t\t      || num_not_at_initial_offset))))\n-\tx = find_reloads_subreg_address (x, 1, opnum, type, ind_levels,\n-\t\t\t\t\t   insn, address_reloaded);\n+\t  && reg_equiv_memory_loc (regno) != 0)\n+\t{\n+\t  tem = find_reloads_subreg_address (x, opnum, type, ind_levels,\n+\t\t\t\t\t     insn, address_reloaded);\n+\t  if (tem)\n+\t    return tem;\n+\t}\n     }\n \n   for (copied = 0, i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n@@ -6070,12 +6058,31 @@ find_reloads_address_1 (enum machine_mode mode, addr_space_t as,\n \t      if (ira_reg_class_max_nregs [rclass][GET_MODE (SUBREG_REG (x))]\n \t\t  > reg_class_size[(int) rclass])\n \t\t{\n-\t\t  x = find_reloads_subreg_address (x, 0, opnum,\n-\t\t\t\t\t\t   ADDR_TYPE (type),\n-\t\t\t\t\t\t   ind_levels, insn, NULL);\n-\t\t  push_reload (x, NULL_RTX, loc, (rtx*) 0, rclass,\n-\t\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n-\t\t  return 1;\n+\t\t  /* If the inner register will be replaced by a memory\n+\t\t     reference, we can do this only if we can replace the\n+\t\t     whole subreg by a (narrower) memory reference.  If\n+\t\t     this is not possible, fall through and reload just\n+\t\t     the inner register (including address reloads).  */\n+\t\t  if (reg_equiv_memory_loc (REGNO (SUBREG_REG (x))) != 0)\n+\t\t    {\n+\t\t      rtx tem = find_reloads_subreg_address (x, opnum,\n+\t\t\t\t\t\t\t     ADDR_TYPE (type),\n+\t\t\t\t\t\t\t     ind_levels, insn,\n+\t\t\t\t\t\t\t     NULL);\n+\t\t      if (tem)\n+\t\t\t{\n+\t\t\t  push_reload (tem, NULL_RTX, loc, (rtx*) 0, rclass,\n+\t\t\t\t       GET_MODE (tem), VOIDmode, 0, 0,\n+\t\t\t\t       opnum, type);\n+\t\t\t  return 1;\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      push_reload (x, NULL_RTX, loc, (rtx*) 0, rclass,\n+\t\t\t\t   GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n+\t\t      return 1;\n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -6152,17 +6159,12 @@ find_reloads_address_part (rtx x, rtx *loc, enum reg_class rclass,\n }\n \f\n /* X, a subreg of a pseudo, is a part of an address that needs to be\n-   reloaded.\n-\n-   If the pseudo is equivalent to a memory location that cannot be directly\n-   addressed, make the necessary address reloads.\n+   reloaded, and the pseusdo is equivalent to a memory location.\n \n-   If address reloads have been necessary, or if the address is changed\n-   by register elimination, return the rtx of the memory location;\n-   otherwise, return X.\n-\n-   If FORCE_REPLACE is nonzero, unconditionally replace the subreg with the\n-   memory location.\n+   Attempt to replace the whole subreg by a (possibly narrower or wider)\n+   memory reference.  If this is possible, return this new memory\n+   reference, and push all required address reloads.  Otherwise,\n+   return NULL.\n \n    OPNUM and TYPE identify the purpose of the reload.\n \n@@ -6174,131 +6176,106 @@ find_reloads_address_part (rtx x, rtx *loc, enum reg_class rclass,\n    stack slots.  */\n \n static rtx\n-find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n-\t\t\t     enum reload_type type, int ind_levels, rtx insn,\n-\t\t\t     int *address_reloaded)\n+find_reloads_subreg_address (rtx x, int opnum, enum reload_type type,\n+\t\t\t     int ind_levels, rtx insn, int *address_reloaded)\n {\n+  enum machine_mode outer_mode = GET_MODE (x);\n+  enum machine_mode inner_mode = GET_MODE (SUBREG_REG (x));\n   int regno = REGNO (SUBREG_REG (x));\n   int reloaded = 0;\n+  rtx tem, orig;\n+  int offset;\n \n-  if (reg_equiv_memory_loc (regno))\n-    {\n-      /* If the address is not directly addressable, or if the address is not\n-\t offsettable, then it must be replaced.  */\n-      if (! force_replace\n-\t  && (reg_equiv_address (regno)\n-\t      || ! offsettable_memref_p (reg_equiv_mem (regno))))\n-\tforce_replace = 1;\n-\n-      if (force_replace || num_not_at_initial_offset)\n-\t{\n-\t  rtx tem = make_memloc (SUBREG_REG (x), regno);\n+  gcc_assert (reg_equiv_memory_loc (regno) != 0);\n \n-\t  /* If the address changes because of register elimination, then\n-\t     it must be replaced.  */\n-\t  if (force_replace\n-\t      || ! rtx_equal_p (tem, reg_equiv_mem (regno)))\n-\t    {\n-\t      unsigned outer_size = GET_MODE_SIZE (GET_MODE (x));\n-\t      unsigned inner_size = GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)));\n-\t      int offset;\n-\t      rtx orig = tem;\n-\n-\t      /* For big-endian paradoxical subregs, SUBREG_BYTE does not\n-\t\t hold the correct (negative) byte offset.  */\n-\t      if (BYTES_BIG_ENDIAN && outer_size > inner_size)\n-\t\toffset = inner_size - outer_size;\n-\t      else\n-\t\toffset = SUBREG_BYTE (x);\n-\n-\t      XEXP (tem, 0) = plus_constant (GET_MODE (XEXP (tem, 0)),\n-\t\t\t\t\t     XEXP (tem, 0), offset);\n-\t      PUT_MODE (tem, GET_MODE (x));\n-\t      if (MEM_OFFSET_KNOWN_P (tem))\n-\t\tset_mem_offset (tem, MEM_OFFSET (tem) + offset);\n-\t      if (MEM_SIZE_KNOWN_P (tem)\n-\t\t  && MEM_SIZE (tem) != (HOST_WIDE_INT) outer_size)\n-\t\tset_mem_size (tem, outer_size);\n-\n-\t      /* If this was a paradoxical subreg that we replaced, the\n-\t\t resulting memory must be sufficiently aligned to allow\n-\t\t us to widen the mode of the memory.  */\n-\t      if (outer_size > inner_size)\n-\t\t{\n-\t\t  rtx base;\n+  /* We cannot replace the subreg with a modified memory reference if:\n \n-\t\t  base = XEXP (tem, 0);\n-\t\t  if (GET_CODE (base) == PLUS)\n-\t\t    {\n-\t\t      if (CONST_INT_P (XEXP (base, 1))\n-\t\t\t  && INTVAL (XEXP (base, 1)) % outer_size != 0)\n-\t\t\treturn x;\n-\t\t      base = XEXP (base, 0);\n-\t\t    }\n-\t\t  if (!REG_P (base)\n-\t\t      || (REGNO_POINTER_ALIGN (REGNO (base))\n-\t\t\t  < outer_size * BITS_PER_UNIT))\n-\t\t    return x;\n-\t\t}\n+     - we have a paradoxical subreg that implicitly acts as a zero or\n+       sign extension operation due to LOAD_EXTEND_OP;\n \n-\t      reloaded = find_reloads_address (GET_MODE (tem), &tem,\n-\t\t\t\t\t       XEXP (tem, 0), &XEXP (tem, 0),\n-\t\t\t\t\t       opnum, type, ind_levels, insn);\n-\t      /* ??? Do we need to handle nonzero offsets somehow?  */\n-\t      if (!offset && !rtx_equal_p (tem, orig))\n-\t\tpush_reg_equiv_alt_mem (regno, tem);\n-\n-\t      /* For some processors an address may be valid in the\n-\t\t original mode but not in a smaller mode.  For\n-\t\t example, ARM accepts a scaled index register in\n-\t\t SImode but not in HImode.  Note that this is only\n-\t\t a problem if the address in reg_equiv_mem is already\n-\t\t invalid in the new mode; other cases would be fixed\n-\t\t by find_reloads_address as usual.\n-\n-\t\t ??? We attempt to handle such cases here by doing an\n-\t\t additional reload of the full address after the\n-\t\t usual processing by find_reloads_address.  Note that\n-\t\t this may not work in the general case, but it seems\n-\t\t to cover the cases where this situation currently\n-\t\t occurs.  A more general fix might be to reload the\n-\t\t *value* instead of the address, but this would not\n-\t\t be expected by the callers of this routine as-is.\n-\n-\t\t If find_reloads_address already completed replaced\n-\t\t the address, there is nothing further to do.  */\n-\t      if (reloaded == 0\n-\t\t  && reg_equiv_mem (regno) != 0\n-\t\t  && !strict_memory_address_addr_space_p\n-\t\t\t(GET_MODE (x), XEXP (reg_equiv_mem (regno), 0),\n-\t\t\t MEM_ADDR_SPACE (reg_equiv_mem (regno))))\n-\t\t{\n-\t\t  push_reload (XEXP (tem, 0), NULL_RTX, &XEXP (tem, 0), (rtx*) 0,\n-\t\t\t       base_reg_class (GET_MODE (tem),\n-\t\t\t\t\t       MEM_ADDR_SPACE (tem),\n-\t\t\t\t\t       MEM, SCRATCH),\n-\t\t\t       GET_MODE (XEXP (tem, 0)), VOIDmode, 0, 0,\n-\t\t\t       opnum, type);\n-\t\t  reloaded = 1;\n-\t\t}\n-\t      /* If this is not a toplevel operand, find_reloads doesn't see\n-\t\t this substitution.  We have to emit a USE of the pseudo so\n-\t\t that delete_output_reload can see it.  */\n-\t      if (replace_reloads && recog_data.operand[opnum] != x)\n-\t\t/* We mark the USE with QImode so that we recognize it\n-\t\t   as one that can be safely deleted at the end of\n-\t\t   reload.  */\n-\t\tPUT_MODE (emit_insn_before (gen_rtx_USE (VOIDmode,\n-\t\t\t\t\t\t\t SUBREG_REG (x)),\n-\t\t\t\t\t    insn), QImode);\n-\t      x = tem;\n-\t    }\n-\t}\n+     - we have a subreg that is implicitly supposed to act on the full\n+       register due to WORD_REGISTER_OPERATIONS (see also eliminate_regs);\n+\n+     - the address of the equivalent memory location is mode-dependent;  or\n+\n+     - we have a paradoxical subreg and the resulting memory is not\n+       sufficiently aligned to allow access in the wider mode.\n+\n+    In addition, we choose not to perform the replacement for *any*\n+    paradoxical subreg, even if it were possible in principle.  This\n+    is to avoid generating wider memory references than necessary.\n+\n+    This corresponds to how previous versions of reload used to handle\n+    paradoxical subregs where no address reload was required.  */\n+\n+  if (paradoxical_subreg_p (x))\n+    return NULL;\n+\n+#ifdef WORD_REGISTER_OPERATIONS\n+  if (GET_MODE_SIZE (outer_mode) < GET_MODE_SIZE (inner_mode)\n+      && ((GET_MODE_SIZE (outer_mode) - 1) / UNITS_PER_WORD\n+          == (GET_MODE_SIZE (inner_mode) - 1) / UNITS_PER_WORD))\n+    return NULL;\n+#endif\n+\n+  /* Since we don't attempt to handle paradoxical subregs, we can just\n+     call into simplify_subreg, which will handle all remaining checks\n+     for us.  */\n+  orig = make_memloc (SUBREG_REG (x), regno);\n+  offset = SUBREG_BYTE (x);\n+  tem = simplify_subreg (outer_mode, orig, inner_mode, offset);\n+  if (!tem || !MEM_P (tem))\n+    return NULL;\n+\n+  /* Now push all required address reloads, if any.  */\n+  reloaded = find_reloads_address (GET_MODE (tem), &tem,\n+\t\t\t\t   XEXP (tem, 0), &XEXP (tem, 0),\n+\t\t\t\t   opnum, type, ind_levels, insn);\n+  /* ??? Do we need to handle nonzero offsets somehow?  */\n+  if (!offset && !rtx_equal_p (tem, orig))\n+    push_reg_equiv_alt_mem (regno, tem);\n+\n+  /* For some processors an address may be valid in the original mode but\n+     not in a smaller mode.  For example, ARM accepts a scaled index register\n+     in SImode but not in HImode.  Note that this is only a problem if the\n+     address in reg_equiv_mem is already invalid in the new mode; other\n+     cases would be fixed by find_reloads_address as usual.\n+\n+     ??? We attempt to handle such cases here by doing an additional reload\n+     of the full address after the usual processing by find_reloads_address.\n+     Note that this may not work in the general case, but it seems to cover\n+     the cases where this situation currently occurs.  A more general fix\n+     might be to reload the *value* instead of the address, but this would\n+     not be expected by the callers of this routine as-is.\n+\n+     If find_reloads_address already completed replaced the address, there\n+     is nothing further to do.  */\n+  if (reloaded == 0\n+      && reg_equiv_mem (regno) != 0\n+      && !strict_memory_address_addr_space_p\n+\t\t(GET_MODE (x), XEXP (reg_equiv_mem (regno), 0),\n+\t\t MEM_ADDR_SPACE (reg_equiv_mem (regno))))\n+    {\n+      push_reload (XEXP (tem, 0), NULL_RTX, &XEXP (tem, 0), (rtx*) 0,\n+\t\t   base_reg_class (GET_MODE (tem), MEM_ADDR_SPACE (tem),\n+\t\t\t\t   MEM, SCRATCH),\n+\t\t   GET_MODE (XEXP (tem, 0)), VOIDmode, 0, 0, opnum, type);\n+      reloaded = 1;\n     }\n+\n+  /* If this is not a toplevel operand, find_reloads doesn't see this\n+     substitution.  We have to emit a USE of the pseudo so that\n+     delete_output_reload can see it.  */\n+  if (replace_reloads && recog_data.operand[opnum] != x)\n+    /* We mark the USE with QImode so that we recognize it as one that\n+       can be safely deleted at the end of reload.  */\n+    PUT_MODE (emit_insn_before (gen_rtx_USE (VOIDmode, SUBREG_REG (x)), insn),\n+\t      QImode);\n+\n   if (address_reloaded)\n     *address_reloaded = reloaded;\n \n-  return x;\n+  return tem;\n }\n \f\n /* Substitute into the current INSN the registers into which we have reloaded"}]}