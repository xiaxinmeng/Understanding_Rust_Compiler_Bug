{"sha": "9ff3c7caa816f14eac43fdf220ce6e7ccb0e84a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZmM2M3Y2FhODE2ZjE0ZWFjNDNmZGYyMjBjZTZlN2NjYjBlODRhNg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-05-29T11:37:21Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-05-29T11:37:21Z"}, "message": "alias.c (reg_known_value): Make this a VEC.\n\n\t* alias.c (reg_known_value): Make this a VEC.\n\t(reg_known_equiv_p): Make this an sbitmap.\n\t(reg_known_value_size): Remove.\n\t(get_reg_known_value, set_reg_known_value, get_reg_known_equiv_p,\n\tset_reg_known_equiv_p): Update for reg_known_value and\n\treg_known_value_size data structure change.\n\t(init_alias_analysis, end_alias_analysis): Likewise.\n\nFrom-SVN: r187953", "tree": {"sha": "da655bfd3017d0030abc94d345831bdf8586d700", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da655bfd3017d0030abc94d345831bdf8586d700"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ff3c7caa816f14eac43fdf220ce6e7ccb0e84a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ff3c7caa816f14eac43fdf220ce6e7ccb0e84a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ff3c7caa816f14eac43fdf220ce6e7ccb0e84a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ff3c7caa816f14eac43fdf220ce6e7ccb0e84a6/comments", "author": null, "committer": null, "parents": [{"sha": "92b05e72eab38351ab9a486e0e0ec9db11f4413b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92b05e72eab38351ab9a486e0e0ec9db11f4413b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92b05e72eab38351ab9a486e0e0ec9db11f4413b"}], "stats": {"total": 67, "additions": 39, "deletions": 28}, "files": [{"sha": "b7bc112177a3b0fff381ec3deaba38066ea88659", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff3c7caa816f14eac43fdf220ce6e7ccb0e84a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff3c7caa816f14eac43fdf220ce6e7ccb0e84a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ff3c7caa816f14eac43fdf220ce6e7ccb0e84a6", "patch": "@@ -1,3 +1,13 @@\n+2012-05-29  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* alias.c (reg_known_value): Make this a VEC.\n+\t(reg_known_equiv_p): Make this an sbitmap.\n+\t(reg_known_value_size): Remove.\n+\t(get_reg_known_value, set_reg_known_value, get_reg_known_equiv_p,\n+\tset_reg_known_equiv_p): Update for reg_known_value and\n+\treg_known_value_size data structure change.\n+\t(init_alias_analysis, end_alias_analysis): Likewise.\n+\n 2012-05-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/53510"}, {"sha": "03cc15db5be000a0413fdd802a514a0b24e429bb", "filename": "gcc/alias.c", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff3c7caa816f14eac43fdf220ce6e7ccb0e84a6/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff3c7caa816f14eac43fdf220ce6e7ccb0e84a6/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=9ff3c7caa816f14eac43fdf220ce6e7ccb0e84a6", "patch": "@@ -243,12 +243,9 @@ static GTY((deletable)) VEC(rtx,gc) *old_reg_base_value;\n    ? VEC_index (rtx, reg_base_value, REGNO (X)) : 0)\n \n /* Vector indexed by N giving the initial (unchanging) value known for\n-   pseudo-register N.  This array is initialized in init_alias_analysis,\n+   pseudo-register N.  This vector is initialized in init_alias_analysis,\n    and does not change until end_alias_analysis is called.  */\n-static GTY((length(\"reg_known_value_size\"))) rtx *reg_known_value;\n-\n-/* Indicates number of valid entries in reg_known_value.  */\n-static GTY(()) unsigned int reg_known_value_size;\n+static GTY(()) VEC(rtx,gc) *reg_known_value;\n \n /* Vector recording for each reg_known_value whether it is due to a\n    REG_EQUIV note.  Future passes (viz., reload) may replace the\n@@ -262,7 +259,7 @@ static GTY(()) unsigned int reg_known_value_size;\n    REG_EQUIV notes.  One could argue that the REG_EQUIV notes are\n    wrong, but solving the problem in the scheduler will likely give\n    better code, so we do it here.  */\n-static bool *reg_known_equiv_p;\n+static sbitmap reg_known_equiv_p;\n \n /* True when scanning insns from the start of the rtl to the\n    NOTE_INSN_FUNCTION_BEG note.  */\n@@ -1362,8 +1359,8 @@ get_reg_known_value (unsigned int regno)\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     {\n       regno -= FIRST_PSEUDO_REGISTER;\n-      if (regno < reg_known_value_size)\n-\treturn reg_known_value[regno];\n+      if (regno < VEC_length (rtx, reg_known_value))\n+\treturn VEC_index (rtx, reg_known_value, regno);\n     }\n   return NULL;\n }\n@@ -1376,8 +1373,8 @@ set_reg_known_value (unsigned int regno, rtx val)\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     {\n       regno -= FIRST_PSEUDO_REGISTER;\n-      if (regno < reg_known_value_size)\n-\treg_known_value[regno] = val;\n+      if (regno < VEC_length (rtx, reg_known_value))\n+\tVEC_replace (rtx, reg_known_value, regno, val);\n     }\n }\n \n@@ -1389,8 +1386,8 @@ get_reg_known_equiv_p (unsigned int regno)\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     {\n       regno -= FIRST_PSEUDO_REGISTER;\n-      if (regno < reg_known_value_size)\n-\treturn reg_known_equiv_p[regno];\n+      if (regno < VEC_length (rtx, reg_known_value))\n+\treturn TEST_BIT (reg_known_equiv_p, regno);\n     }\n   return false;\n }\n@@ -1401,8 +1398,13 @@ set_reg_known_equiv_p (unsigned int regno, bool val)\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     {\n       regno -= FIRST_PSEUDO_REGISTER;\n-      if (regno < reg_known_value_size)\n-\treg_known_equiv_p[regno] = val;\n+      if (regno < VEC_length (rtx, reg_known_value))\n+\t{\n+\t  if (val)\n+\t    SET_BIT (reg_known_equiv_p, regno);\n+\t  else\n+\t    RESET_BIT (reg_known_equiv_p, regno);\n+\t}\n     }\n }\n \n@@ -2799,13 +2801,12 @@ init_alias_analysis (void)\n   int changed, pass;\n   int i;\n   unsigned int ui;\n-  rtx insn;\n+  rtx insn, val;\n \n   timevar_push (TV_ALIAS_ANALYSIS);\n \n-  reg_known_value_size = maxreg - FIRST_PSEUDO_REGISTER;\n-  reg_known_value = ggc_alloc_cleared_vec_rtx (reg_known_value_size);\n-  reg_known_equiv_p = XCNEWVEC (bool, reg_known_value_size);\n+  reg_known_value = VEC_alloc (rtx, gc, maxreg - FIRST_PSEUDO_REGISTER);\n+  reg_known_equiv_p = sbitmap_alloc (maxreg - FIRST_PSEUDO_REGISTER);\n \n   /* If we have memory allocated from the previous run, use it.  */\n   if (old_reg_base_value)\n@@ -2931,13 +2932,13 @@ init_alias_analysis (void)\n \t\t      t = plus_constant (GET_MODE (src), t,\n \t\t\t\t\t INTVAL (XEXP (src, 1)));\n \t\t      set_reg_known_value (regno, t);\n-\t\t      set_reg_known_equiv_p (regno, 0);\n+\t\t      set_reg_known_equiv_p (regno, false);\n \t\t    }\n \t\t  else if (DF_REG_DEF_COUNT (regno) == 1\n \t\t\t   && ! rtx_varies_p (src, 1))\n \t\t    {\n \t\t      set_reg_known_value (regno, src);\n-\t\t      set_reg_known_equiv_p (regno, 0);\n+\t\t      set_reg_known_equiv_p (regno, false);\n \t\t    }\n \t\t}\n \t    }\n@@ -2964,9 +2965,12 @@ init_alias_analysis (void)\n   while (changed && ++pass < MAX_ALIAS_LOOP_PASSES);\n \n   /* Fill in the remaining entries.  */\n-  for (i = 0; i < (int)reg_known_value_size; i++)\n-    if (reg_known_value[i] == 0)\n-      reg_known_value[i] = regno_reg_rtx[i + FIRST_PSEUDO_REGISTER];\n+  FOR_EACH_VEC_ELT (rtx, reg_known_value, i, val)\n+    {\n+      int regno = i + FIRST_PSEUDO_REGISTER;\n+      if (! val)\n+\tset_reg_known_value (regno, regno_reg_rtx[regno]);\n+    }\n \n   /* Clean up.  */\n   free (new_reg_base_value);\n@@ -2989,11 +2993,8 @@ void\n end_alias_analysis (void)\n {\n   old_reg_base_value = reg_base_value;\n-  ggc_free (reg_known_value);\n-  reg_known_value = 0;\n-  reg_known_value_size = 0;\n-  free (reg_known_equiv_p);\n-  reg_known_equiv_p = 0;\n+  VEC_free (rtx, gc, reg_known_value);\n+  sbitmap_free (reg_known_equiv_p);\n }\n \n #include \"gt-alias.h\""}]}