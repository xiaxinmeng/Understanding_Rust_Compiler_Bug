{"sha": "337fa50b7b0d2964b6ebe2373224b5c1bbb61efb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM3ZmE1MGI3YjBkMjk2NGI2ZWJlMjM3MzIyNGI1YzFiYmI2MWVmYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-09-10T12:21:59Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-09-10T12:21:59Z"}, "message": "runtime/internal/atomic: new package, API copied from Go 1.7\n    \n    Copy over the Go 1.7 runtime/internal/atomic package, but implement the\n    functions in C using __atomic functions rather than using the\n    processor-specific assembler code.\n    \n    Reviewed-on: https://go-review.googlesource.com/29010\n\nFrom-SVN: r240070", "tree": {"sha": "b4415ddf1a7fca30e8f28898fc5f1a50f344315c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4415ddf1a7fca30e8f28898fc5f1a50f344315c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb/comments", "author": null, "committer": null, "parents": [{"sha": "ec1ea9cfbcd4a1285b4dfa81cb1680aed3ecd7e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec1ea9cfbcd4a1285b4dfa81cb1680aed3ecd7e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec1ea9cfbcd4a1285b4dfa81cb1680aed3ecd7e5"}], "stats": {"total": 433, "additions": 432, "deletions": 1}, "files": [{"sha": "487adbe8e50315aa933e98cf8f1142a88c76684b", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=337fa50b7b0d2964b6ebe2373224b5c1bbb61efb", "patch": "@@ -1,4 +1,4 @@\n-6e791d2f3c183d55fdcabe3df20f01c029fd6d54\n+04fe765560107e5d4c5f98c1022765930a1069f9\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "1fde5086812e440ebc904153955a6a19a5009547", "filename": "libgo/Makefile.am", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=337fa50b7b0d2964b6ebe2373224b5c1bbb61efb", "patch": "@@ -843,6 +843,8 @@ libgo_go_objs = \\\n \tnet/rpc/jsonrpc.lo \\\n \truntime/debug.lo \\\n \truntime/pprof.lo \\\n+\truntime/internal/atomic.lo \\\n+\truntime/internal/atomic_c.lo \\\n \tsync/atomic.lo \\\n \tsync/atomic_c.lo \\\n \ttext/scanner.lo \\\n@@ -2365,6 +2367,18 @@ runtime/pprof/check: $(CHECK_DEPS)\n # Also use -fno-inline to get better results from the memory profiler.\n runtime_pprof_check_GOCFLAGS = -static-libgo -fno-inline\n \n+@go_include@ runtime/internal/atomic.lo.dep\n+runtime/internal/atomic.lo.dep: $(srcdir)/go/runtime/internal/atomic/*.go\n+\t$(BUILDDEPS)\n+runtime_internal_atomic_lo_GOCFLAGS = -fgo-compiling-runtime\n+runtime/internal/atomic.lo:\n+\t$(BUILDPACKAGE)\n+runtime/internal/atomic_c.lo: go/runtime/internal/atomic/atomic.c runtime.inc runtime/internal/atomic.lo\n+\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/runtime/internal/atomic/atomic.c\n+runtime/internal/atomic/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: runtime/internal/atomic/check\n+\n @go_include@ sync/atomic.lo.dep\n sync/atomic.lo.dep: $(srcdir)/go/sync/atomic/*.go\n \t$(BUILDDEPS)\n@@ -2800,6 +2814,8 @@ runtime/debug.gox: runtime/debug.lo\n \t$(BUILDGOX)\n runtime/pprof.gox: runtime/pprof.lo\n \t$(BUILDGOX)\n+runtime/internal/atomic.gox: runtime/internal/atomic.lo\n+\t$(BUILDGOX)\n \n sync/atomic.gox: sync/atomic.lo\n \t$(BUILDGOX)\n@@ -2954,6 +2970,7 @@ TEST_PACKAGES = \\\n \tpath/filepath/check \\\n \tregexp/syntax/check \\\n \truntime/pprof/check \\\n+\truntime/internal/atomic/check \\\n \tsync/atomic/check \\\n \ttext/scanner/check \\\n \ttext/tabwriter/check \\"}, {"sha": "931a6c9e0caef2a7af529c107c262e79f8ae392f", "filename": "libgo/Makefile.in", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=337fa50b7b0d2964b6ebe2373224b5c1bbb61efb", "patch": "@@ -212,6 +212,7 @@ am__DEPENDENCIES_1 = bufio.lo bytes.lo bytes/index.lo context.lo \\\n \told/regexp.lo old/template.lo os/exec.lo os/signal.lo \\\n \tos/user.lo path/filepath.lo regexp/syntax.lo \\\n \tnet/rpc/jsonrpc.lo runtime/debug.lo runtime/pprof.lo \\\n+\truntime/internal/atomic.lo runtime/internal/atomic_c.lo \\\n \tsync/atomic.lo sync/atomic_c.lo text/scanner.lo \\\n \ttext/tabwriter.lo text/template.lo text/template/parse.lo \\\n \ttesting/iotest.lo testing/quick.lo unicode/utf16.lo \\\n@@ -1096,6 +1097,8 @@ libgo_go_objs = \\\n \tnet/rpc/jsonrpc.lo \\\n \truntime/debug.lo \\\n \truntime/pprof.lo \\\n+\truntime/internal/atomic.lo \\\n+\truntime/internal/atomic_c.lo \\\n \tsync/atomic.lo \\\n \tsync/atomic_c.lo \\\n \ttext/scanner.lo \\\n@@ -1247,6 +1250,7 @@ runtime_go_lo_GOCFLAGS = -fgo-c-header=runtime.inc.tmp -fgo-compiling-runtime\n # otherwise we can't get the line numbers.\n # Also use -fno-inline to get better results from the memory profiler.\n runtime_pprof_check_GOCFLAGS = -static-libgo -fno-inline\n+runtime_internal_atomic_lo_GOCFLAGS = -fgo-compiling-runtime\n \n # How to build a .gox file from a .lo file.\n BUILDGOX = \\\n@@ -1384,6 +1388,7 @@ TEST_PACKAGES = \\\n \tpath/filepath/check \\\n \tregexp/syntax/check \\\n \truntime/pprof/check \\\n+\truntime/internal/atomic/check \\\n \tsync/atomic/check \\\n \ttext/scanner/check \\\n \ttext/tabwriter/check \\\n@@ -4987,6 +4992,17 @@ runtime/pprof/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: runtime/pprof/check\n \n+@go_include@ runtime/internal/atomic.lo.dep\n+runtime/internal/atomic.lo.dep: $(srcdir)/go/runtime/internal/atomic/*.go\n+\t$(BUILDDEPS)\n+runtime/internal/atomic.lo:\n+\t$(BUILDPACKAGE)\n+runtime/internal/atomic_c.lo: go/runtime/internal/atomic/atomic.c runtime.inc runtime/internal/atomic.lo\n+\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/runtime/internal/atomic/atomic.c\n+runtime/internal/atomic/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: runtime/internal/atomic/check\n+\n @go_include@ sync/atomic.lo.dep\n sync/atomic.lo.dep: $(srcdir)/go/sync/atomic/*.go\n \t$(BUILDDEPS)\n@@ -5415,6 +5431,8 @@ runtime/debug.gox: runtime/debug.lo\n \t$(BUILDGOX)\n runtime/pprof.gox: runtime/pprof.lo\n \t$(BUILDGOX)\n+runtime/internal/atomic.gox: runtime/internal/atomic.lo\n+\t$(BUILDGOX)\n \n sync/atomic.gox: sync/atomic.lo\n \t$(BUILDGOX)"}, {"sha": "3393fbef44e27ed37bb036935842c2a120f0e990", "filename": "libgo/go/runtime/internal/atomic/atomic.c", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fatomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fatomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fatomic.c?ref=337fa50b7b0d2964b6ebe2373224b5c1bbb61efb", "patch": "@@ -0,0 +1,237 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include <stdint.h>\n+\n+#include \"runtime.h\"\n+\n+uint32_t Load (uint32_t *ptr)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Load\")\n+  __attribute__ ((no_split_stack));\n+\n+uint32_t\n+Load (uint32_t *ptr)\n+{\n+  return __atomic_load_n (ptr, __ATOMIC_ACQUIRE);\n+}\n+\n+void *Loadp (void *ptr)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Loadp\")\n+  __attribute__ ((no_split_stack));\n+\n+void *\n+Loadp (void *ptr)\n+{\n+  return __atomic_load_n ((void **) ptr, __ATOMIC_ACQUIRE);\n+}\n+\n+uint64_t Load64 (uint64_t *ptr)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Load64\")\n+  __attribute__ ((no_split_stack));\n+\n+uint64_t\n+Load64 (uint64_t *ptr)\n+{\n+  return __atomic_load_n (ptr, __ATOMIC_ACQUIRE);\n+}\n+\n+uintptr_t Loaduintptr (uintptr_t *ptr)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Loaduintptr\")\n+  __attribute__ ((no_split_stack));\n+\n+uintptr_t\n+Loaduintptr (uintptr_t *ptr)\n+{\n+  return __atomic_load_n (ptr, __ATOMIC_ACQUIRE);\n+}\n+\n+uintgo Loaduint (uintgo *ptr)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Loaduint\")\n+  __attribute__ ((no_split_stack));\n+\n+uintgo\n+Loaduint (uintgo *ptr)\n+{\n+  return __atomic_load_n (ptr, __ATOMIC_ACQUIRE);\n+}\n+\n+int64_t Loadint64 (int64_t *ptr)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Loadint64\")\n+  __attribute__ ((no_split_stack));\n+\n+int64_t\n+Loadint64 (int64_t *ptr)\n+{\n+  return __atomic_load_n (ptr, __ATOMIC_ACQUIRE);\n+}\n+\n+uint32_t Xadd (uint32_t *ptr, int32_t delta)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Xadd\")\n+  __attribute__ ((no_split_stack));\n+\n+uint32_t\n+Xadd (uint32_t *ptr, int32_t delta)\n+{\n+  return __atomic_add_fetch (ptr, (uint32_t) delta, __ATOMIC_SEQ_CST);\n+}\n+\n+uint64_t Xadd64 (uint64_t *ptr, int64_t delta)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Xadd64\")\n+  __attribute__ ((no_split_stack));\n+\n+uint64_t\n+Xadd64 (uint64_t *ptr, int64_t delta)\n+{\n+  return __atomic_add_fetch (ptr, (uint64_t) delta, __ATOMIC_SEQ_CST);\n+}\n+\n+uintptr_t Xadduintptr (uintptr_t *ptr, uintptr_t delta)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Xadduintptr\")\n+  __attribute__ ((no_split_stack));\n+\n+uintptr_t\n+Xadduintptr (uintptr_t *ptr, uintptr_t delta)\n+{\n+  return __atomic_add_fetch (ptr, delta, __ATOMIC_SEQ_CST);\n+}\n+\n+int64_t Xaddint64 (int64_t *ptr, int64_t delta)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Xaddint64\")\n+  __attribute__ ((no_split_stack));\n+\n+int64_t\n+Xaddint64 (int64_t *ptr, int64_t delta)\n+{\n+  return __atomic_add_fetch (ptr, delta, __ATOMIC_SEQ_CST);\n+}\n+\n+uint32_t Xchg (uint32_t *ptr, uint32_t new)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Xchg\")\n+  __attribute__ ((no_split_stack));\n+\n+uint32_t\n+Xchg (uint32_t *ptr, uint32_t new)\n+{\n+  return __atomic_exchange_n (ptr, new, __ATOMIC_SEQ_CST);\n+}\n+\n+uint64_t Xchg64 (uint64_t *ptr, uint64_t new)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Xchg64\")\n+  __attribute__ ((no_split_stack));\n+\n+uint64_t\n+Xchg64 (uint64_t *ptr, uint64_t new)\n+{\n+  return __atomic_exchange_n (ptr, new, __ATOMIC_SEQ_CST);\n+}\n+\n+uintptr_t Xchguintptr (uintptr_t *ptr, uintptr_t new)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Xchguintptr\")\n+  __attribute__ ((no_split_stack));\n+\n+uintptr_t\n+Xchguintptr (uintptr_t *ptr, uintptr_t new)\n+{\n+  return __atomic_exchange_n (ptr, new, __ATOMIC_SEQ_CST);\n+}\n+\n+void And8 (uint8_t *ptr, uint8_t val)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.And8\")\n+  __attribute__ ((no_split_stack));\n+\n+void\n+And8 (uint8_t *ptr, uint8_t val)\n+{\n+  __atomic_and_fetch (ptr, val, __ATOMIC_SEQ_CST);\n+}\n+\n+void Or8 (uint8_t *ptr, uint8_t val)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Or8\")\n+  __attribute__ ((no_split_stack));\n+\n+void\n+Or8 (uint8_t *ptr, uint8_t val)\n+{\n+  __atomic_or_fetch (ptr, val, __ATOMIC_SEQ_CST);\n+}\n+\n+_Bool Cas (uint32_t *ptr, uint32_t old, uint32_t new)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Cas\")\n+  __attribute__ ((no_split_stack));\n+\n+_Bool\n+Cas (uint32_t *ptr, uint32_t old, uint32_t new)\n+{\n+  return __atomic_compare_exchange_n (ptr, &old, new, false, __ATOMIC_SEQ_CST, __ATOMIC_RELAXED);\n+}\n+\n+_Bool Cas64 (uint64_t *ptr, uint64_t old, uint64_t new)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Cas64\")\n+  __attribute__ ((no_split_stack));\n+\n+_Bool\n+Cas64 (uint64_t *ptr, uint64_t old, uint64_t new)\n+{\n+  return __atomic_compare_exchange_n (ptr, &old, new, false, __ATOMIC_SEQ_CST, __ATOMIC_RELAXED);\n+}\n+\n+_Bool Casp1 (void **ptr, void *old, void *new)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Casp1\")\n+  __attribute__ ((no_split_stack));\n+\n+_Bool\n+Casp1 (void **ptr, void *old, void *new)\n+{\n+  return __atomic_compare_exchange_n (ptr, &old, new, false, __ATOMIC_SEQ_CST, __ATOMIC_RELAXED);\n+}\n+\n+_Bool Casuintptr (uintptr_t *ptr, uintptr_t old, uintptr_t new)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Casuintptr\")\n+  __attribute__ ((no_split_stack));\n+\n+_Bool\n+Casuintptr (uintptr_t *ptr, uintptr_t old, uintptr_t new)\n+{\n+  return __atomic_compare_exchange_n (ptr, &old, new, false, __ATOMIC_SEQ_CST, __ATOMIC_RELAXED);\n+}\n+\n+void Store (uint32_t *ptr, uint32_t val)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Store\")\n+  __attribute__ ((no_split_stack));\n+\n+void\n+Store (uint32_t *ptr, uint32_t val)\n+{\n+  __atomic_store_n (ptr, val, __ATOMIC_SEQ_CST);\n+}\n+\n+void Store64 (uint64_t *ptr, uint64_t val)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Store64\")\n+  __attribute__ ((no_split_stack));\n+\n+void\n+Store64 (uint64_t *ptr, uint64_t val)\n+{\n+  __atomic_store_n (ptr, val, __ATOMIC_SEQ_CST);\n+}\n+\n+void Storeuintptr (uintptr_t *ptr, uintptr_t val)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Storeuintptr\")\n+  __attribute__ ((no_split_stack));\n+\n+void\n+Storeuintptr (uintptr_t *ptr, uintptr_t val)\n+{\n+  __atomic_store_n (ptr, val, __ATOMIC_SEQ_CST);\n+}\n+\n+void StorepNoWB (void *ptr, void *val)\n+  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.StorepNoWB\")\n+  __attribute__ ((no_split_stack));\n+\n+void\n+StorepNoWB (void *ptr, void *val)\n+{\n+  __atomic_store_n ((void**) ptr, val, __ATOMIC_SEQ_CST);\n+}"}, {"sha": "d5dc552b9521353021b883f9681b6caa561a82ec", "filename": "libgo/go/runtime/internal/atomic/atomic_test.go", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fatomic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fatomic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fatomic_test.go?ref=337fa50b7b0d2964b6ebe2373224b5c1bbb61efb", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package atomic_test\n+\n+import (\n+\t\"runtime\"\n+\t\"runtime/internal/atomic\"\n+\t\"testing\"\n+\t\"unsafe\"\n+)\n+\n+func runParallel(N, iter int, f func()) {\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(int(N)))\n+\tdone := make(chan bool)\n+\tfor i := 0; i < N; i++ {\n+\t\tgo func() {\n+\t\t\tfor j := 0; j < iter; j++ {\n+\t\t\t\tf()\n+\t\t\t}\n+\t\t\tdone <- true\n+\t\t}()\n+\t}\n+\tfor i := 0; i < N; i++ {\n+\t\t<-done\n+\t}\n+}\n+\n+func TestXadduintptr(t *testing.T) {\n+\tconst N = 20\n+\tconst iter = 100000\n+\tinc := uintptr(100)\n+\ttotal := uintptr(0)\n+\trunParallel(N, iter, func() {\n+\t\tatomic.Xadduintptr(&total, inc)\n+\t})\n+\tif want := uintptr(N * iter * inc); want != total {\n+\t\tt.Fatalf(\"xadduintpr error, want %d, got %d\", want, total)\n+\t}\n+\ttotal = 0\n+\trunParallel(N, iter, func() {\n+\t\tatomic.Xadduintptr(&total, inc)\n+\t\tatomic.Xadduintptr(&total, uintptr(-int64(inc)))\n+\t})\n+\tif total != 0 {\n+\t\tt.Fatalf(\"xadduintpr total error, want %d, got %d\", 0, total)\n+\t}\n+}\n+\n+// Tests that xadduintptr correctly updates 64-bit values. The place where\n+// we actually do so is mstats.go, functions mSysStat{Inc,Dec}.\n+func TestXadduintptrOnUint64(t *testing.T) {\n+\t/*\tif runtime.BigEndian != 0 {\n+\t\t// On big endian architectures, we never use xadduintptr to update\n+\t\t// 64-bit values and hence we skip the test.  (Note that functions\n+\t\t// mSysStat{Inc,Dec} in mstats.go have explicit checks for\n+\t\t// big-endianness.)\n+\t\treturn\n+\t}*/\n+\tconst inc = 100\n+\tval := uint64(0)\n+\tatomic.Xadduintptr((*uintptr)(unsafe.Pointer(&val)), inc)\n+\tif inc != val {\n+\t\tt.Fatalf(\"xadduintptr should increase lower-order bits, want %d, got %d\", inc, val)\n+\t}\n+}"}, {"sha": "696736465fd1a66335ab9cd61017826490e448fb", "filename": "libgo/go/runtime/internal/atomic/gccgo.go", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fgccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fgccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fgccgo.go?ref=337fa50b7b0d2964b6ebe2373224b5c1bbb61efb", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package atomic\n+\n+// Stubs for atomic functions that in gccgo are implemented in C.\n+\n+import \"unsafe\"\n+\n+//go:noescape\n+func Load(ptr *uint32) uint32\n+\n+//go:noescape\n+func Loadp(ptr unsafe.Pointer) unsafe.Pointer\n+\n+//go:noescape\n+func Load64(ptr *uint64) uint64\n+\n+//go:noescape\n+func Xadd(ptr *uint32, delta int32) uint32\n+\n+//go:noescape\n+func Xadd64(ptr *uint64, delta int64) uint64\n+\n+//go:noescape\n+func Xadduintptr(ptr *uintptr, delta uintptr) uintptr\n+\n+//go:noescape\n+func Xchg(ptr *uint32, new uint32) uint32\n+\n+//go:noescape\n+func Xchg64(ptr *uint64, new uint64) uint64\n+\n+//go:noescape\n+func Xchguintptr(ptr *uintptr, new uintptr) uintptr\n+\n+//go:noescape\n+func And8(ptr *uint8, val uint8)\n+\n+//go:noescape\n+func Or8(ptr *uint8, val uint8)\n+\n+// NOTE: Do not add atomicxor8 (XOR is not idempotent).\n+\n+//go:noescape\n+func Cas64(ptr *uint64, old, new uint64) bool\n+\n+//go:noescape\n+func Store(ptr *uint32, val uint32)\n+\n+//go:noescape\n+func Store64(ptr *uint64, val uint64)\n+\n+// StorepNoWB performs *ptr = val atomically and without a write\n+// barrier.\n+//\n+// NO go:noescape annotation; see atomic_pointer.go.\n+func StorepNoWB(ptr unsafe.Pointer, val unsafe.Pointer)"}, {"sha": "497b98046d864cb3f64013b997b46f13ed2e632b", "filename": "libgo/go/runtime/internal/atomic/stubs.go", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/337fa50b7b0d2964b6ebe2373224b5c1bbb61efb/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fstubs.go?ref=337fa50b7b0d2964b6ebe2373224b5c1bbb61efb", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package atomic\n+\n+import \"unsafe\"\n+\n+//go:noescape\n+func Cas(ptr *uint32, old, new uint32) bool\n+\n+// NO go:noescape annotation; see atomic_pointer.go.\n+func Casp1(ptr *unsafe.Pointer, old, new unsafe.Pointer) bool\n+\n+//go:noescape\n+func Casuintptr(ptr *uintptr, old, new uintptr) bool\n+\n+//go:noescape\n+func Storeuintptr(ptr *uintptr, new uintptr)\n+\n+//go:noescape\n+func Loaduintptr(ptr *uintptr) uintptr\n+\n+//go:noescape\n+func Loaduint(ptr *uint) uint\n+\n+// TODO(matloob): Should these functions have the go:noescape annotation?\n+\n+//go:noescape\n+func Loadint64(ptr *int64) int64\n+\n+//go:noescape\n+func Xaddint64(ptr *int64, delta int64) int64"}]}