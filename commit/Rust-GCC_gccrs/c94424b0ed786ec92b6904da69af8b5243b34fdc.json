{"sha": "c94424b0ed786ec92b6904da69af8b5243b34fdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk0NDI0YjBlZDc4NmVjOTJiNjkwNGRhNjlhZjhiNTI0M2IzNGZkYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-05-28T09:26:48Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-05-28T09:26:48Z"}, "message": "openmp: Fix up handling of reduction clause on constructs combined with target [PR99928]\n\nThe reduction clause should be copied as map (tofrom: ) to combined target if\npresent, but as we need different handling of array sections between map and reduction,\ndoing that during gimplification would be harder.\n\nSo, this patch adds them during splitting, and similarly to firstprivate adds them\nwith a new flag that they should be just ignored/removed if an explicit map clause\nof the same list item is present.\n\nThe exact rules are to be decided in https://github.com/OpenMP/spec/issues/2766\nso this patch just implements something that is IMHO reasonable and exact detailed\ntestcases for the cornercases will follow once it is clarified.\n\n2021-05-28  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR middle-end/99928\ngcc/\n\t* tree.h (OMP_CLAUSE_MAP_IMPLICIT): Define.\ngcc/c-family/\n\t* c-omp.c (c_omp_split_clauses): For reduction clause if combined with\n\ttarget add a map tofrom clause with OMP_CLAUSE_MAP_IMPLICIT.\ngcc/c/\n\t* c-typeck.c (handle_omp_array_sections): Copy OMP_CLAUSE_MAP_IMPLICIT.\n\t(c_finish_omp_clauses): Move not just OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT\n\tmarked clauses last, but also OMP_CLAUSE_MAP_IMPLICIT.  Add\n\tmap_firstprivate_head bitmap, set it for GOMP_MAP_FIRSTPRIVATE_POINTER\n\tmaps and silently remove OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT if it is\n\tpresent too.  For OMP_CLAUSE_MAP_IMPLICIT silently remove the clause\n\tif present in map_head, map_field_head or map_firstprivate_head\n\tbitmaps.\ngcc/cp/\n\t* semantics.c (handle_omp_array_sections): Copy\n\tOMP_CLAUSE_MAP_IMPLICIT.\n\t(finish_omp_clauses): Move not just OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT\n\tmarked clauses last, but also OMP_CLAUSE_MAP_IMPLICIT.  Add\n\tmap_firstprivate_head bitmap, set it for GOMP_MAP_FIRSTPRIVATE_POINTER\n\tmaps and silently remove OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT if it is\n\tpresent too.  For OMP_CLAUSE_MAP_IMPLICIT silently remove the clause\n\tif present in map_head, map_field_head or map_firstprivate_head\n\tbitmaps.\ngcc/testsuite/\n\t* c-c++-common/gomp/pr99928-8.c: Remove all xfails.\n\t* c-c++-common/gomp/pr99928-9.c: Likewise.\n\t* c-c++-common/gomp/pr99928-10.c: Likewise.\n\t* c-c++-common/gomp/pr99928-16.c: New test.", "tree": {"sha": "09c1221f532cbf11a46d135d6fc4d2197d2e1f35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09c1221f532cbf11a46d135d6fc4d2197d2e1f35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c94424b0ed786ec92b6904da69af8b5243b34fdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c94424b0ed786ec92b6904da69af8b5243b34fdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c94424b0ed786ec92b6904da69af8b5243b34fdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c94424b0ed786ec92b6904da69af8b5243b34fdc/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a5de4d5af1c10a8c097de30ee4c71457216e975", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a5de4d5af1c10a8c097de30ee4c71457216e975", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a5de4d5af1c10a8c097de30ee4c71457216e975"}], "stats": {"total": 273, "additions": 190, "deletions": 83}, "files": [{"sha": "28fbb1d053714a9eb9824debff8f72165ac19869", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94424b0ed786ec92b6904da69af8b5243b34fdc/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94424b0ed786ec92b6904da69af8b5243b34fdc/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=c94424b0ed786ec92b6904da69af8b5243b34fdc", "patch": "@@ -1989,6 +1989,16 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t\t\t\"%<parallel for%>, %<parallel for simd%>\");\n \t      OMP_CLAUSE_REDUCTION_INSCAN (clauses) = 0;\n \t    }\n+\t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP)) != 0)\n+\t    {\n+\t      c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t    OMP_CLAUSE_MAP);\n+\t      OMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (clauses);\n+\t      OMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_TOFROM);\n+\t      OMP_CLAUSE_MAP_IMPLICIT (c) = 1;\n+\t      OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_TARGET];\n+\t      cclauses[C_OMP_CLAUSE_SPLIT_TARGET] = c;\n+\t    }\n \t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE)) != 0)\n \t    {\n \t      if (code == OMP_SIMD)"}, {"sha": "5f322874423c278bc61b09e9f687ceb047b8a886", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94424b0ed786ec92b6904da69af8b5243b34fdc/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94424b0ed786ec92b6904da69af8b5243b34fdc/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=c94424b0ed786ec92b6904da69af8b5243b34fdc", "patch": "@@ -13657,6 +13657,7 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \tOMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ATTACH_DETACH);\n       else\n \tOMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_FIRSTPRIVATE_POINTER);\n+      OMP_CLAUSE_MAP_IMPLICIT (c2) = OMP_CLAUSE_MAP_IMPLICIT (c);\n       if (OMP_CLAUSE_MAP_KIND (c2) != GOMP_MAP_FIRSTPRIVATE_POINTER\n \t  && !c_mark_addressable (t))\n \treturn false;\n@@ -13927,7 +13928,8 @@ tree\n c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n {\n   bitmap_head generic_head, firstprivate_head, lastprivate_head;\n-  bitmap_head aligned_head, map_head, map_field_head, oacc_reduction_head;\n+  bitmap_head aligned_head, map_head, map_field_head, map_firstprivate_head;\n+  bitmap_head oacc_reduction_head;\n   tree c, t, type, *pc;\n   tree simdlen = NULL_TREE, safelen = NULL_TREE;\n   bool branch_seen = false;\n@@ -13947,7 +13949,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n      has been seen, -2 if mixed inscan/normal reduction diagnosed.  */\n   int reduction_seen = 0;\n   bool allocate_seen = false;\n-  bool firstprivate_implicit_moved = false;\n+  bool implicit_moved = false;\n \n   bitmap_obstack_initialize (NULL);\n   bitmap_initialize (&generic_head, &bitmap_default_obstack);\n@@ -13957,6 +13959,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n   /* If ort == C_ORT_OMP_DECLARE_SIMD used as uniform_head instead.  */\n   bitmap_initialize (&map_head, &bitmap_default_obstack);\n   bitmap_initialize (&map_field_head, &bitmap_default_obstack);\n+  bitmap_initialize (&map_firstprivate_head, &bitmap_default_obstack);\n   /* If ort == C_ORT_OMP used as nontemporal_head or use_device_xxx_head\n      instead.  */\n   bitmap_initialize (&oacc_reduction_head, &bitmap_default_obstack);\n@@ -14389,28 +14392,36 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  break;\n \n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n-\t  if (OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT (c)\n-\t      && !firstprivate_implicit_moved)\n+\t  if (OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT (c) && !implicit_moved)\n \t    {\n-\t      firstprivate_implicit_moved = true;\n-\t      /* Move firstprivate clauses with\n-\t\t OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT set to the end of\n+\t    move_implicit:\n+\t      implicit_moved = true;\n+\t      /* Move firstprivate and map clauses with\n+\t\t OMP_CLAUSE_{FIRSTPRIVATE,MAP}_IMPLICIT set to the end of\n \t\t clauses chain.  */\n-\t      tree cl = NULL, *pc1 = pc, *pc2 = &cl;\n+\t      tree cl1 = NULL_TREE, cl2 = NULL_TREE;\n+\t      tree *pc1 = pc, *pc2 = &cl1, *pc3 = &cl2;\n \t      while (*pc1)\n \t\tif (OMP_CLAUSE_CODE (*pc1) == OMP_CLAUSE_FIRSTPRIVATE\n \t\t    && OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT (*pc1))\n+\t\t  {\n+\t\t    *pc3 = *pc1;\n+\t\t    pc3 = &OMP_CLAUSE_CHAIN (*pc3);\n+\t\t    *pc1 = OMP_CLAUSE_CHAIN (*pc1);\n+\t\t  }\n+\t\telse if (OMP_CLAUSE_CODE (*pc1) == OMP_CLAUSE_MAP\n+\t\t\t && OMP_CLAUSE_MAP_IMPLICIT (*pc1))\n \t\t  {\n \t\t    *pc2 = *pc1;\n \t\t    pc2 = &OMP_CLAUSE_CHAIN (*pc2);\n \t\t    *pc1 = OMP_CLAUSE_CHAIN (*pc1);\n \t\t  }\n \t\telse\n \t\t  pc1 = &OMP_CLAUSE_CHAIN (*pc1);\n-\t      *pc2 = NULL;\n-\t      *pc1 = cl;\n-\t      if (pc1 != pc)\n-\t\tcontinue;\n+\t      *pc3 = NULL;\n+\t      *pc2 = cl2;\n+\t      *pc1 = cl1;\n+\t      continue;\n \t    }\n \t  t = OMP_CLAUSE_DECL (c);\n \t  need_complete = true;\n@@ -14421,6 +14432,10 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t\"%qE is not a variable in clause %<firstprivate%>\", t);\n \t      remove = true;\n \t    }\n+\t  else if (OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT (c)\n+\t\t   && !OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT_TARGET (c)\n+\t\t   && bitmap_bit_p (&map_firstprivate_head, DECL_UID (t)))\n+\t    remove = true;\n \t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n \t\t   || bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n \t    {\n@@ -14673,6 +14688,9 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  break;\n \n \tcase OMP_CLAUSE_MAP:\n+\t  if (OMP_CLAUSE_MAP_IMPLICIT (c) && !implicit_moved)\n+\t    goto move_implicit;\n+\t  /* FALLTHRU */\n \tcase OMP_CLAUSE_TO:\n \tcase OMP_CLAUSE_FROM:\n \tcase OMP_CLAUSE__CACHE_:\n@@ -14706,6 +14724,16 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t    {\n \t\t      while (TREE_CODE (t) == COMPONENT_REF)\n \t\t\tt = TREE_OPERAND (t, 0);\n+\t\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t\t\t  && OMP_CLAUSE_MAP_IMPLICIT (c)\n+\t\t\t  && (bitmap_bit_p (&map_head, DECL_UID (t))\n+\t\t\t      || bitmap_bit_p (&map_field_head, DECL_UID (t))\n+\t\t\t      || bitmap_bit_p (&map_firstprivate_head,\n+\t\t\t\t\t       DECL_UID (t))))\n+\t\t\t{\n+\t\t\t  remove = true;\n+\t\t\t  break;\n+\t\t\t}\n \t\t      if (bitmap_bit_p (&map_field_head, DECL_UID (t)))\n \t\t\tbreak;\n \t\t      if (bitmap_bit_p (&map_head, DECL_UID (t)))\n@@ -14859,6 +14887,12 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t\t   && OMP_CLAUSE_MAP_IMPLICIT (c)\n+\t\t   && (bitmap_bit_p (&map_head, DECL_UID (t))\n+\t\t       || bitmap_bit_p (&map_field_head, DECL_UID (t))\n+\t\t       || bitmap_bit_p (&map_firstprivate_head, DECL_UID (t))))\n+\t    remove = true;\n \t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t\t   && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER)\n \t    {\n@@ -14880,7 +14914,10 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t  remove = true;\n \t\t}\n \t      else\n-\t\tbitmap_set_bit (&generic_head, DECL_UID (t));\n+\t\t{\n+\t\t  bitmap_set_bit (&generic_head, DECL_UID (t));\n+\t\t  bitmap_set_bit (&map_firstprivate_head, DECL_UID (t));\n+\t\t}\n \t    }\n \t  else if (bitmap_bit_p (&map_head, DECL_UID (t))\n \t\t   && (ort != C_ORT_OMP"}, {"sha": "fe370a21366e4db86da39d516228318dba4bafd9", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 52, "deletions": 13, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94424b0ed786ec92b6904da69af8b5243b34fdc/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94424b0ed786ec92b6904da69af8b5243b34fdc/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=c94424b0ed786ec92b6904da69af8b5243b34fdc", "patch": "@@ -5548,6 +5548,7 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t    }\n \t  else\n \t    OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_FIRSTPRIVATE_POINTER);\n+\t  OMP_CLAUSE_MAP_IMPLICIT (c2) = OMP_CLAUSE_MAP_IMPLICIT (c);\n \t  if (OMP_CLAUSE_MAP_KIND (c2) != GOMP_MAP_FIRSTPRIVATE_POINTER\n \t      && !cxx_mark_addressable (t))\n \t    return false;\n@@ -5574,6 +5575,7 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t      tree c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\t  OMP_CLAUSE_MAP);\n \t      OMP_CLAUSE_SET_MAP_KIND (c3, OMP_CLAUSE_MAP_KIND (c2));\n+\t      OMP_CLAUSE_MAP_IMPLICIT (c2) = OMP_CLAUSE_MAP_IMPLICIT (c);\n \t      OMP_CLAUSE_DECL (c3) = ptr;\n \t      if (OMP_CLAUSE_MAP_KIND (c2) == GOMP_MAP_ALWAYS_POINTER\n \t\t  || OMP_CLAUSE_MAP_KIND (c2) == GOMP_MAP_ATTACH_DETACH)\n@@ -6510,7 +6512,8 @@ tree\n finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n {\n   bitmap_head generic_head, firstprivate_head, lastprivate_head;\n-  bitmap_head aligned_head, map_head, map_field_head, oacc_reduction_head;\n+  bitmap_head aligned_head, map_head, map_field_head, map_firstprivate_head;\n+  bitmap_head oacc_reduction_head;\n   tree c, t, *pc;\n   tree safelen = NULL_TREE;\n   bool branch_seen = false;\n@@ -6527,7 +6530,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n   bool allocate_seen = false;\n   tree detach_seen = NULL_TREE;\n   bool mergeable_seen = false;\n-  bool firstprivate_implicit_moved = false;\n+  bool implicit_moved = false;\n \n   bitmap_obstack_initialize (NULL);\n   bitmap_initialize (&generic_head, &bitmap_default_obstack);\n@@ -6537,6 +6540,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n   /* If ort == C_ORT_OMP_DECLARE_SIMD used as uniform_head instead.  */\n   bitmap_initialize (&map_head, &bitmap_default_obstack);\n   bitmap_initialize (&map_field_head, &bitmap_default_obstack);\n+  bitmap_initialize (&map_firstprivate_head, &bitmap_default_obstack);\n   /* If ort == C_ORT_OMP used as nontemporal_head or use_device_xxx_head\n      instead.  */\n   bitmap_initialize (&oacc_reduction_head, &bitmap_default_obstack);\n@@ -6852,28 +6856,36 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  break;\n \n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n-\t  if (OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT (c)\n-\t      && !firstprivate_implicit_moved)\n+\t  if (OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT (c) && !implicit_moved)\n \t    {\n-\t      firstprivate_implicit_moved = true;\n-\t      /* Move firstprivate clauses with\n-\t\t OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT set to the end of\n+\t    move_implicit:\n+\t      implicit_moved = true;\n+\t      /* Move firstprivate and map clauses with\n+\t\t OMP_CLAUSE_{FIRSTPRIVATE,MAP}_IMPLICIT set to the end of\n \t\t clauses chain.  */\n-\t      tree cl = NULL, *pc1 = pc, *pc2 = &cl;\n+\t      tree cl1 = NULL_TREE, cl2 = NULL_TREE;\n+\t      tree *pc1 = pc, *pc2 = &cl1, *pc3 = &cl2;\n \t      while (*pc1)\n \t\tif (OMP_CLAUSE_CODE (*pc1) == OMP_CLAUSE_FIRSTPRIVATE\n \t\t    && OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT (*pc1))\n+\t\t  {\n+\t\t    *pc3 = *pc1;\n+\t\t    pc3 = &OMP_CLAUSE_CHAIN (*pc3);\n+\t\t    *pc1 = OMP_CLAUSE_CHAIN (*pc1);\n+\t\t  }\n+\t\telse if (OMP_CLAUSE_CODE (*pc1) == OMP_CLAUSE_MAP\n+\t\t\t && OMP_CLAUSE_MAP_IMPLICIT (*pc1))\n \t\t  {\n \t\t    *pc2 = *pc1;\n \t\t    pc2 = &OMP_CLAUSE_CHAIN (*pc2);\n \t\t    *pc1 = OMP_CLAUSE_CHAIN (*pc1);\n \t\t  }\n \t\telse\n \t\t  pc1 = &OMP_CLAUSE_CHAIN (*pc1);\n-\t      *pc2 = NULL;\n-\t      *pc1 = cl;\n-\t      if (pc1 != pc)\n-\t\tcontinue;\n+\t      *pc3 = NULL;\n+\t      *pc2 = cl2;\n+\t      *pc1 = cl1;\n+\t      continue;\n \t    }\n \t  t = omp_clause_decl_field (OMP_CLAUSE_DECL (c));\n \t  if (t)\n@@ -6904,6 +6916,10 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t  t);\n \t      remove = true;\n \t    }\n+\t  else if (OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT (c)\n+\t\t   && !OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT_TARGET (c)\n+\t\t   && bitmap_bit_p (&map_firstprivate_head, DECL_UID (t)))\n+\t    remove = true;\n \t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n \t\t   || bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n \t    {\n@@ -7620,6 +7636,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  break;\n \n \tcase OMP_CLAUSE_MAP:\n+\t  if (OMP_CLAUSE_MAP_IMPLICIT (c) && !implicit_moved)\n+\t    goto move_implicit;\n+\t  /* FALLTHRU */\n \tcase OMP_CLAUSE_TO:\n \tcase OMP_CLAUSE_FROM:\n \tcase OMP_CLAUSE__CACHE_:\n@@ -7651,6 +7670,16 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\tt = TREE_OPERAND (t, 0);\n \t\t      if (REFERENCE_REF_P (t))\n \t\t\tt = TREE_OPERAND (t, 0);\n+\t\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t\t\t  && OMP_CLAUSE_MAP_IMPLICIT (c)\n+\t\t\t  && (bitmap_bit_p (&map_head, DECL_UID (t))\n+\t\t\t      || bitmap_bit_p (&map_field_head, DECL_UID (t))\n+\t\t\t      || bitmap_bit_p (&map_firstprivate_head,\n+\t\t\t\t\t       DECL_UID (t))))\n+\t\t\t{\n+\t\t\t  remove = true;\n+\t\t\t  break;\n+\t\t\t}\n \t\t      if (bitmap_bit_p (&map_field_head, DECL_UID (t)))\n \t\t\tbreak;\n \t\t      if (bitmap_bit_p (&map_head, DECL_UID (t)))\n@@ -7831,6 +7860,13 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t\"%qD is not a pointer variable\", t);\n \t      remove = true;\n \t    }\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t\t   && OMP_CLAUSE_MAP_IMPLICIT (c)\n+\t\t   && (bitmap_bit_p (&map_head, DECL_UID (t))\n+\t\t       || bitmap_bit_p (&map_field_head, DECL_UID (t))\n+\t\t       || bitmap_bit_p (&map_firstprivate_head,\n+\t\t\t\t\tDECL_UID (t))))\n+\t    remove = true;\n \t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t\t   && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER)\n \t    {\n@@ -7852,7 +7888,10 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t  remove = true;\n \t\t}\n \t      else\n-\t\tbitmap_set_bit (&generic_head, DECL_UID (t));\n+\t\t{\n+\t\t  bitmap_set_bit (&generic_head, DECL_UID (t));\n+\t\t  bitmap_set_bit (&map_firstprivate_head, DECL_UID (t));\n+\t\t}\n \t    }\n \t  else if (bitmap_bit_p (&map_head, DECL_UID (t))\n \t\t   && !bitmap_bit_p (&map_field_head, DECL_UID (t)))"}, {"sha": "6c44600b07e42a0e0a68641d31ac6e5df1f6fa81", "filename": "gcc/testsuite/c-c++-common/gomp/pr99928-10.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94424b0ed786ec92b6904da69af8b5243b34fdc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94424b0ed786ec92b6904da69af8b5243b34fdc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-10.c?ref=c94424b0ed786ec92b6904da69af8b5243b34fdc", "patch": "@@ -95,54 +95,54 @@ bar (void)\n     #pragma omp section\n     r12[1]++;\n   }\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 60\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r13 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 60\\\\\\]\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r13 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r13\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r13 \\\\+ 4\" \"gimple\" } } */\n   #pragma omp target parallel reduction(+:r13[1:15])\n   r13[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 64\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r14 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 64\\\\\\]\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r14 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r14\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r14 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n   /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r14 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n   #pragma omp target parallel for reduction(+:r14[1:16])\n   for (int i = 0; i < 64; i++)\n     r14[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 68\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r15 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 68\\\\\\]\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r15 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r15\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r15 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n   /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r15 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n   /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r15 \\\\+ 4\" \"gimple\" } } */\n   #pragma omp target parallel for simd reduction(+:r15[1:17])\n   for (int i = 0; i < 64; i++)\n     r15[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 72\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r16 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r16\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 72\\\\\\]\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r16 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r16\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(r16\\\\)\" \"gimple\" } } *//* FIXME: Should be shared, but firstprivate is an optimization.  */\n   /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r16 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n   /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r16 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n   #pragma omp target parallel loop reduction(+:r16[1:18])\n   for (int i = 0; i < 64; i++)\n     r16[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 76\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r17 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 76\\\\\\]\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r17 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r17\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r17 \\\\+ 4\" \"gimple\" } } */\n   #pragma omp target teams reduction(+:r17[1:19])\n   r17[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 80\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r18 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 80\\\\\\]\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r18 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r18\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r18 \\\\+ 4\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r18 \\\\+ 4\" \"gimple\" } } */\n   #pragma omp target teams distribute reduction(+:r18[1:20])\n   for (int i = 0; i < 64; i++)\n     r18[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 84\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r19 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 84\\\\\\]\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r19 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r19\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r19 \\\\+ 4\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r19 \\\\+ 4\" \"gimple\" } } */\n@@ -151,8 +151,8 @@ bar (void)\n   #pragma omp target teams distribute parallel for reduction(+:r19[1:21])\n   for (int i = 0; i < 64; i++)\n     r19[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 88\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r20 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 88\\\\\\]\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r20 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r20\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r20 \\\\+ 4\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r20 \\\\+ 4\" \"gimple\" } } */\n@@ -162,18 +162,18 @@ bar (void)\n   #pragma omp target teams distribute parallel for simd reduction(+:r20[1:22])\n   for (int i = 0; i < 64; i++)\n     r20[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 92\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r21 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 92\\\\\\]\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r21 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r21\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r21 \\\\+ 4\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r21 \\\\+ 4\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r21 \\\\+ 4\" \"gimple\" } } */\n   #pragma omp target teams distribute simd reduction(+:r21[1:23])\n   for (int i = 0; i < 64; i++)\n     r21[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 96\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r22 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r22\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 96\\\\\\]\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r22 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r22\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(r22\\\\)\" \"gimple\" } } *//* FIXME: Should be shared, but firstprivate is an optimization.  */\n   /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r22 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n   /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(r22\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n@@ -182,8 +182,8 @@ bar (void)\n   #pragma omp target teams loop reduction(+:r22[1:24])\n   for (int i = 0; i < 64; i++)\n     r22[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 100\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r23 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 100\\\\\\]\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r23 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r23\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r23 \\\\+ 4\" \"gimple\" } } */\n   #pragma omp target simd reduction(+:r23[1:25])"}, {"sha": "84cd85da7cf05008c6d1b50aa8478ef3c0964f86", "filename": "gcc/testsuite/c-c++-common/gomp/pr99928-16.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94424b0ed786ec92b6904da69af8b5243b34fdc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94424b0ed786ec92b6904da69af8b5243b34fdc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-16.c?ref=c94424b0ed786ec92b6904da69af8b5243b34fdc", "patch": "@@ -0,0 +1,16 @@\n+/* PR middle-end/99928 */\n+\n+void\n+foo (void)\n+{\n+  int a[6] = {};\n+  #pragma omp target simd reduction(+:a[:3])\n+  for (int i = 0; i < 6; i++)\n+    a[0]++;\n+  #pragma omp target simd reduction(+:a[:3]) map(always, tofrom: a)\n+  for (int i = 0; i < 6; i++)\n+    a[0]++;\n+  #pragma omp target simd reduction(+:a[:3]) map(always, tofrom: a[:6])\n+  for (int i = 0; i < 6; i++)\n+    a[0]++;\n+}"}, {"sha": "27e6ad1eb36d479b51f401b30540cc1b817fd32b", "filename": "gcc/testsuite/c-c++-common/gomp/pr99928-8.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94424b0ed786ec92b6904da69af8b5243b34fdc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94424b0ed786ec92b6904da69af8b5243b34fdc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-8.c?ref=c94424b0ed786ec92b6904da69af8b5243b34fdc", "patch": "@@ -94,57 +94,57 @@ bar (void)\n     #pragma omp section\n     r12++;\n   }\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r13\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r13\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r13\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r13\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r13\\\\)\" \"gimple\" } } */\n   #pragma omp target parallel reduction(+:r13)\n   r13++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r14\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r14\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r14\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r14\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r14\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n   /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r14\\\\)\" \"gimple\" } } *//* FIXME.  */\n   #pragma omp target parallel for reduction(+:r14)\n   for (int i = 0; i < 64; i++)\n     r14++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r15\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r15\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r15\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r15\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r15\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n   /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r15\\\\)\" \"gimple\" } } *//* FIXME.  */\n   /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r15\\\\)\" \"gimple\" } } */\n   #pragma omp target parallel for simd reduction(+:r15)\n   for (int i = 0; i < 64; i++)\n     r15++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r16\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r16\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r16\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r16\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(r16\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r16\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n   /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r16\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n   #pragma omp target parallel loop reduction(+:r16)\n   for (int i = 0; i < 64; i++)\n     r16++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r17\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r17\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r17\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r17\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:r17\\\\)\" \"gimple\" } } */\n   #pragma omp target teams reduction(+:r17)\n   r17++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r18\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r18\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r18\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r18\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:r18\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r18\\\\)\" \"gimple\" } } */\n   #pragma omp target teams distribute reduction(+:r18)\n   for (int i = 0; i < 64; i++)\n     r18++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r19\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r19\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r19\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r19\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:r19\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r19\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r19\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n   /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r19\\\\)\" \"gimple\" } } *//* FIXME.  */\n   #pragma omp target teams distribute parallel for reduction(+:r19)\n   for (int i = 0; i < 64; i++)\n     r19++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r20\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r20\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r20\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r20\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:r20\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r20\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r20\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n@@ -153,16 +153,16 @@ bar (void)\n   #pragma omp target teams distribute parallel for simd reduction(+:r20)\n   for (int i = 0; i < 64; i++)\n     r20++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r21\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r21\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r21\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r21\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:r21\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r21\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r21\\\\)\" \"gimple\" } } */\n   #pragma omp target teams distribute simd reduction(+:r21)\n   for (int i = 0; i < 64; i++)\n     r21++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r22\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r22\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r22\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r22\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(r22\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r22\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n   /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(r22\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n@@ -171,8 +171,8 @@ bar (void)\n   #pragma omp target teams loop reduction(+:r22)\n   for (int i = 0; i < 64; i++)\n     r22++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r23\" \"gimple\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r23\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r23\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r23\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r23\\\\)\" \"gimple\" } } */\n   #pragma omp target simd reduction(+:r23)\n   for (int i = 0; i < 64; i++)"}, {"sha": "862352776674e412c913d745ea08e0222f89a177", "filename": "gcc/testsuite/c-c++-common/gomp/pr99928-9.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94424b0ed786ec92b6904da69af8b5243b34fdc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94424b0ed786ec92b6904da69af8b5243b34fdc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-9.c?ref=c94424b0ed786ec92b6904da69af8b5243b34fdc", "patch": "@@ -94,47 +94,47 @@ bar (void)\n     #pragma omp section\n     r12[1]++;\n   }\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r13\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r13\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r13\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r13 \\\\+ 4\" \"gimple\" } } */\n   #pragma omp target parallel reduction(+:r13[1:2])\n   r13[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r14\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r14\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r14\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r14 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n   /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r14 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n   #pragma omp target parallel for reduction(+:r14[1:2])\n   for (int i = 0; i < 64; i++)\n     r14[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r15\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r15\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r15\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r15 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n   /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r15 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n   /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r15 \\\\+ 4\" \"gimple\" } } */\n   #pragma omp target parallel for simd reduction(+:r15[1:2])\n   for (int i = 0; i < 64; i++)\n     r15[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r16\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r16\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r16\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(r16\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r16 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n   /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r16 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n   #pragma omp target parallel loop reduction(+:r16[1:2])\n   for (int i = 0; i < 64; i++)\n     r16[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r17\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r17\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r17\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r17 \\\\+ 4\" \"gimple\" } } */\n   #pragma omp target teams reduction(+:r17[1:2])\n   r17[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r18\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r18\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r18\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r18 \\\\+ 4\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r18 \\\\+ 4\" \"gimple\" } } */\n   #pragma omp target teams distribute reduction(+:r18[1:2])\n   for (int i = 0; i < 64; i++)\n     r18[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r19\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r19\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r19\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r19 \\\\+ 4\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r19 \\\\+ 4\" \"gimple\" } } */\n@@ -143,7 +143,7 @@ bar (void)\n   #pragma omp target teams distribute parallel for reduction(+:r19[1:2])\n   for (int i = 0; i < 64; i++)\n     r19[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r20\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r20\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r20\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r20 \\\\+ 4\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r20 \\\\+ 4\" \"gimple\" } } */\n@@ -153,15 +153,15 @@ bar (void)\n   #pragma omp target teams distribute parallel for simd reduction(+:r20[1:2])\n   for (int i = 0; i < 64; i++)\n     r20[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r21\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r21\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r21\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r21 \\\\+ 4\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r21 \\\\+ 4\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r21 \\\\+ 4\" \"gimple\" } } */\n   #pragma omp target teams distribute simd reduction(+:r21[1:2])\n   for (int i = 0; i < 64; i++)\n     r21[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r22\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r22\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r22\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(r22\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r22 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n@@ -171,7 +171,7 @@ bar (void)\n   #pragma omp target teams loop reduction(+:r22[1:2])\n   for (int i = 0; i < 64; i++)\n     r22[1]++;\n-  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r23\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r23\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r23\\\\)\" \"gimple\" } } */\n   /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r23 \\\\+ 4\" \"gimple\" } } */\n   #pragma omp target simd reduction(+:r23[1:2])"}, {"sha": "5935d0e9f7c8c222ea2aeb44022589033423b273", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94424b0ed786ec92b6904da69af8b5243b34fdc/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94424b0ed786ec92b6904da69af8b5243b34fdc/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c94424b0ed786ec92b6904da69af8b5243b34fdc", "patch": "@@ -1654,6 +1654,11 @@ class auto_suppress_location_wrappers\n    variable.  */\n #define OMP_CLAUSE_MAP_IN_REDUCTION(NODE) \\\n   TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP))\n+/* Nonzero on map clauses added implicitly for reduction clauses on combined\n+   or composite constructs.  They shall be removed if there is an explicit\n+   map clause.  */\n+#define OMP_CLAUSE_MAP_IMPLICIT(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)->base.default_def_flag)\n \n /* True on an OMP_CLAUSE_USE_DEVICE_PTR with an OpenACC 'if_present'\n    clause.  */"}]}