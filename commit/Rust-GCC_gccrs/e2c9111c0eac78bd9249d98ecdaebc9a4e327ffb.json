{"sha": "e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJjOTExMWMwZWFjNzhiZDkyNDlkOThlY2RhZWJjOWE0ZTMyN2ZmYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-09-18T17:28:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-09-18T17:28:40Z"}, "message": "re PR middle-end/37448 (cannot compile big function)\n\n\n\tPR middle-end/37448\n\t* ipa-reference.c (ipa_reference_local_vars_info_d,\n\tipa_reference_global_vars_info_d,\n\tipa_reference_local_vars_info_t, ipa_reference_global_vars_info_t,\n\tipa_reference_vars_info_t): Move here from ipa-reference.h\n\t(node_duplication_hook_holder, node_removal_hook_holder): New.\n\t(get_reference_vars_info_from_cgraph): Rename to ...\n\t(get_reference_vars_info): ... this one, use cgraph uids.\n\t(get_local_reference_vars_info, get_global_reference_vars_info):\n\tUse cgraph instead of decl.\n\t(ipa_reference_get_read_local, ipa_reference_get_written_local): Remove.\n\t(ipa_reference_get_read_global, ipa_reference_get_not_read_global\n\tipa_reference_get_written_global, ipa_reference_get_not_written_global): Use\n\tcgraph argument.\n\t(check_call): Simplify avail check.\n\t(scan_stmt_for_static_refs): Update.\n\t(propagate_bits): Update.\n\t(merge_callee_local_info): Remove.\n\t(init_function_info): Use cgraph nodes.\n\t(clean_function_local_data): Break out from ...\n\t(clean_function): ... here.\n\t(copy_local_bitmap, copy_global_bitmap): New functions.\n\t(duplicate_node_data, remove_node_data): New functions.\n\t(generate_summary): Register hooks; use visibility instead of\n\tmaster clones.\n\t(propafate): Use cgraph nodes; copy bitmap to each node in cycle.\n\t* ipa-reference.h (ipa_reference_local_vars_info_d,\n\tipa_reference_global_vars_info_d,\n\tipa_reference_local_vars_info_t, ipa_reference_global_vars_info_t,\n\tipa_reference_vars_info_t): Move to ipa-reference.c\n\t(ipa_reference_get_read_local, ipa_reference_get_written_local):\n\tRemove.\n\t(ipa_reference_get_read_global, ipa_reference_get_written_global,\n\tipa_reference_get_not_read_global, ipa_reference_get_not_written_global):\n\tUpdate prototype.\n\t* ipa-pure-const.c (funct_state_vec): Turn into VECtor.\n\t(init_state): Remove.\n\t(node_duplication_hook_holder, node_removal_hook_holder): New.\n\t(get_function_state, set_function_state): Use VECtor.\n\t(analyze_function): Check body availability.\n\t(add_new_function): Likewise.\n\t(duplicate_node_data, remove_node_data): New.\n\t(generate_summary): Register hooks; do not care about clones.\n\t(propafate): Do not care about clones; recursive functions are not looping.\n\t* ipa-utils.c (searchc, ipa_utils_reduced_inorder): Do not skip clones.\n\t* ipa-prop.c (edge_removal_hook_holder, node_removal_hook_holder,\n\t* edge_duplication_hook_holder, node_duplication_hook_holder): Make\n\tstatic.\n\t* tree-flow.h (function_ann_d): Remove reference_vars_info.\n\t* tree-ssa-opreands.c (add_call_clobber_ops, add_call_read_ops): Update call of\n\tipa-reference accesors.\n\nFrom-SVN: r140463", "tree": {"sha": "ebbd388fee9c2b29fa34e1972bac913405e30d33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebbd388fee9c2b29fa34e1972bac913405e30d33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb/comments", "author": null, "committer": null, "parents": [{"sha": "52d1bfd8cdae70a4c20b2e5647168a86895903ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52d1bfd8cdae70a4c20b2e5647168a86895903ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52d1bfd8cdae70a4c20b2e5647168a86895903ee"}], "stats": {"total": 661, "additions": 361, "deletions": 300}, "files": [{"sha": "0c49b73322f32410eeb2a3b822f184660ba9a454", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb", "patch": "@@ -1,3 +1,57 @@\n+2008-09-18  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/37448\n+\t* ipa-reference.c (ipa_reference_local_vars_info_d,\n+\tipa_reference_global_vars_info_d,\n+\tipa_reference_local_vars_info_t, ipa_reference_global_vars_info_t,\n+\tipa_reference_vars_info_t): Move here from ipa-reference.h\n+\t(node_duplication_hook_holder, node_removal_hook_holder): New.\n+\t(get_reference_vars_info_from_cgraph): Rename to ...\n+\t(get_reference_vars_info): ... this one, use cgraph uids.\n+\t(get_local_reference_vars_info, get_global_reference_vars_info):\n+\tUse cgraph instead of decl.\n+\t(ipa_reference_get_read_local, ipa_reference_get_written_local): Remove.\n+\t(ipa_reference_get_read_global, ipa_reference_get_not_read_global\n+\tipa_reference_get_written_global, ipa_reference_get_not_written_global): Use\n+\tcgraph argument.\n+\t(check_call): Simplify avail check.\n+\t(scan_stmt_for_static_refs): Update.\n+\t(propagate_bits): Update.\n+\t(merge_callee_local_info): Remove.\n+\t(init_function_info): Use cgraph nodes.\n+\t(clean_function_local_data): Break out from ...\n+\t(clean_function): ... here.\n+\t(copy_local_bitmap, copy_global_bitmap): New functions.\n+\t(duplicate_node_data, remove_node_data): New functions.\n+\t(generate_summary): Register hooks; use visibility instead of\n+\tmaster clones.\n+\t(propafate): Use cgraph nodes; copy bitmap to each node in cycle.\n+\t* ipa-reference.h (ipa_reference_local_vars_info_d,\n+\tipa_reference_global_vars_info_d,\n+\tipa_reference_local_vars_info_t, ipa_reference_global_vars_info_t,\n+\tipa_reference_vars_info_t): Move to ipa-reference.c\n+\t(ipa_reference_get_read_local, ipa_reference_get_written_local):\n+\tRemove.\n+\t(ipa_reference_get_read_global, ipa_reference_get_written_global,\n+\tipa_reference_get_not_read_global, ipa_reference_get_not_written_global):\n+\tUpdate prototype.\n+\t* ipa-pure-const.c (funct_state_vec): Turn into VECtor.\n+\t(init_state): Remove.\n+\t(node_duplication_hook_holder, node_removal_hook_holder): New.\n+\t(get_function_state, set_function_state): Use VECtor.\n+\t(analyze_function): Check body availability.\n+\t(add_new_function): Likewise.\n+\t(duplicate_node_data, remove_node_data): New.\n+\t(generate_summary): Register hooks; do not care about clones.\n+\t(propafate): Do not care about clones; recursive functions are not looping.\n+\t* ipa-utils.c (searchc, ipa_utils_reduced_inorder): Do not skip clones.\n+\t* ipa-prop.c (edge_removal_hook_holder, node_removal_hook_holder,\n+\t* edge_duplication_hook_holder, node_duplication_hook_holder): Make\n+\tstatic.\n+\t* tree-flow.h (function_ann_d): Remove reference_vars_info.\n+\t* tree-ssa-opreands.c (add_call_clobber_ops, add_call_read_ops): Update call of\n+\tipa-reference accesors.\n+\n 2008-09-18  Simon Baldwin  <simonb@google.com>\n \n \t* c-opts.c (c_common_handle_option): Add handling for"}, {"sha": "be1f96efa15603b85d43de369c8546a8d39f3339", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb", "patch": "@@ -40,10 +40,10 @@ VEC (ipa_node_params_t, heap) *ipa_node_params_vector;\n VEC (ipa_edge_args_t, heap) *ipa_edge_args_vector;\n \n /* Holders of ipa cgraph hooks: */\n-struct cgraph_edge_hook_list *edge_removal_hook_holder;\n-struct cgraph_node_hook_list *node_removal_hook_holder;\n-struct cgraph_2edge_hook_list *edge_duplication_hook_holder;\n-struct cgraph_2node_hook_list *node_duplication_hook_holder;\n+static struct cgraph_edge_hook_list *edge_removal_hook_holder;\n+static struct cgraph_node_hook_list *node_removal_hook_holder;\n+static struct cgraph_2edge_hook_list *edge_duplication_hook_holder;\n+static struct cgraph_2node_hook_list *node_duplication_hook_holder;\n \n /* Initialize worklist to contain all functions.  */\n struct ipa_func_list *"}, {"sha": "f21638f383eb1b977064f2de549e950b2e9acdcc", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 57, "deletions": 25, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb", "patch": "@@ -94,19 +94,14 @@ typedef struct funct_state_d * funct_state;\n \n /* Array, indexed by cgraph node uid, of function states.  */\n \n-static funct_state *funct_state_vec;\n+DEF_VEC_P (funct_state);\n+DEF_VEC_ALLOC_P (funct_state, heap);\n+static VEC (funct_state, heap) *funct_state_vec;\n \n /* Holders of ipa cgraph hooks: */\n static struct cgraph_node_hook_list *function_insertion_hook_holder;\n-\n-/* Init the function state.  */\n-\n-static void \n-init_state (void)\n-{\n-  funct_state_vec = XCNEWVEC (funct_state, cgraph_max_uid);\n-}\n-\n+static struct cgraph_2node_hook_list *node_duplication_hook_holder;\n+static struct cgraph_node_hook_list *node_removal_hook_holder;\n \n /* Init the function state.  */\n \n@@ -122,15 +117,21 @@ finish_state (void)\n static inline funct_state\n get_function_state (struct cgraph_node *node)\n {\n-  return funct_state_vec[node->uid];\n+  if (!funct_state_vec\n+      || VEC_length (funct_state, funct_state_vec) <= (unsigned int)node->uid)\n+    return NULL;\n+  return VEC_index (funct_state, funct_state_vec, node->uid);\n }\n \n /* Set the function state S for NODE.  */\n \n static inline void\n set_function_state (struct cgraph_node *node, funct_state s)\n {\n-  funct_state_vec[node->uid] = s;\n+  if (!funct_state_vec\n+      || VEC_length (funct_state, funct_state_vec) <= (unsigned int)node->uid)\n+     VEC_safe_grow_cleared (funct_state, heap, funct_state_vec, node->uid + 1);\n+  VEC_replace (funct_state, funct_state_vec, node->uid, s);\n }\n \n /* Check to see if the use (or definition when CHECKING_WRITE is true)\n@@ -585,6 +586,9 @@ analyze_function (struct cgraph_node *fn)\n   tree decl = fn->decl;\n   funct_state l = XCNEW (struct funct_state_d);\n \n+ if (cgraph_function_body_availability (fn) <= AVAIL_OVERWRITABLE)\n+   return;\n+\n   set_function_state (fn, l);\n \n   l->pure_const_state = IPA_CONST;\n@@ -683,7 +687,8 @@ analyze_function (struct cgraph_node *fn)\n static void\n add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n {\n-  funct_state_vec = XRESIZEVEC (funct_state, funct_state_vec, cgraph_max_uid);\n+ if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n+   return;\n   /* There are some shared nodes, in particular the initializers on\n      static declarations.  We do not need to scan them more than once\n      since all we would be interested in are the addressof\n@@ -694,6 +699,33 @@ add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n   visited_nodes = NULL;\n }\n \n+/* Called when new clone is inserted to callgraph late.  */\n+\n+static void\n+duplicate_node_data (struct cgraph_node *src, struct cgraph_node *dst,\n+\t \t     void *data ATTRIBUTE_UNUSED)\n+{\n+  if (get_function_state (src))\n+    {\n+      funct_state l = XNEW (struct funct_state_d);\n+      gcc_assert (!get_function_state (dst));\n+      memcpy (l, get_function_state (src), sizeof (*l));\n+      set_function_state (dst, l);\n+    }\n+}\n+\n+/* Called when new clone is inserted to callgraph late.  */\n+\n+static void\n+remove_node_data (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+{\n+  if (get_function_state (node))\n+    {\n+      free (get_function_state (node));\n+      set_function_state (node, NULL);\n+    }\n+}\n+\n \f\n /* Analyze each function in the cgraph to see if it is locally PURE or\n    CONST.  */\n@@ -703,9 +735,12 @@ generate_summary (void)\n {\n   struct cgraph_node *node;\n \n+  node_removal_hook_holder =\n+      cgraph_add_node_removal_hook (&remove_node_data, NULL);\n+  node_duplication_hook_holder =\n+      cgraph_add_node_duplication_hook (&duplicate_node_data, NULL);\n   function_insertion_hook_holder =\n       cgraph_add_function_insertion_hook (&add_new_function, NULL);\n-  init_state ();\n   /* There are some shared nodes, in particular the initializers on\n      static declarations.  We do not need to scan them more than once\n      since all we would be interested in are the addressof\n@@ -714,14 +749,12 @@ generate_summary (void)\n \n   /* Process all of the functions. \n \n-     We do not want to process any of the clones so we check that this\n-     is a master clone.  However, we do NOT process any\n-     AVAIL_OVERWRITABLE functions (these are never clones) we cannot\n+     We do NOT process any AVAIL_OVERWRITABLE functions, we cannot\n      guarantee that what we learn about the one we see will be true\n      for the one that overrides it.\n   */\n   for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed && cgraph_is_master_clone (node))\n+    if (cgraph_function_body_availability (node) > AVAIL_OVERWRITABLE)\n       analyze_function (node);\n \n   pointer_set_destroy (visited_nodes);\n@@ -745,6 +778,8 @@ propagate (void)\n   struct ipa_dfs_info * w_info;\n \n   cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n+  cgraph_remove_node_duplication_hook (node_duplication_hook_holder);\n+  cgraph_remove_node_removal_hook (node_removal_hook_holder);\n   order_pos = ipa_utils_reduced_inorder (order, true, false);\n   if (dump_file)\n     {\n@@ -788,12 +823,8 @@ propagate (void)\n \t      for (e = w->callees; e; e = e->next_callee) \n \t\t{\n \t\t  struct cgraph_node *y = e->callee;\n-\t\t  /* Only look at the master nodes and skip external nodes.  */\n-\t\t  y = cgraph_master_clone (y);\n \n-\t\t  if (w == y)\n-\t\t    looping = true;\n-\t\t  if (y)\n+\t\t  if (cgraph_function_body_availability (y) > AVAIL_OVERWRITABLE)\n \t\t    {\n \t\t      funct_state y_l = get_function_state (y);\n \t\t      if (pure_const_state < y_l->pure_const_state)\n@@ -861,19 +892,20 @@ propagate (void)\n \t  free (node->aux);\n \t  node->aux = NULL;\n \t}\n-      if (node->analyzed && cgraph_is_master_clone (node))\n+      if (cgraph_function_body_availability (node) > AVAIL_OVERWRITABLE)\n \tfree (get_function_state (node));\n     }\n   \n   free (order);\n+  VEC_free (funct_state, heap, funct_state_vec);\n   finish_state ();\n   return 0;\n }\n \n static bool\n gate_pure_const (void)\n {\n-  return (flag_ipa_pure_const \n+  return (flag_ipa_pure_const\n \t  /* Don't bother doing anything if the program has errors.  */\n \t  && !(errorcount || sorrycount));\n }"}, {"sha": "a9afd457a73e6e1aded993e5c96b1cd55ac8969d", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 214, "deletions": 190, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb", "patch": "@@ -69,6 +69,52 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n #include \"langhooks.h\"\n \n+/* The static variables defined within the compilation unit that are\n+   loaded or stored directly by function that owns this structure.  */ \n+\n+struct ipa_reference_local_vars_info_d \n+{\n+  bitmap statics_read;\n+  bitmap statics_written;\n+\n+  /* Set when this function calls another function external to the\n+     compilation unit or if the function has a asm clobber of memory.\n+     In general, such calls are modeled as reading and writing all\n+     variables (both bits on) but sometime there are attributes on the\n+     called function so we can do better.  */\n+  bool calls_read_all;\n+  bool calls_write_all;\n+};\n+\n+/* Statics that are read and written by some set of functions. The\n+   local ones are based on the loads and stores local to the function.\n+   The global ones are based on the local info as well as the\n+   transitive closure of the functions that are called.  The\n+   structures are separated to allow the global structures to be\n+   shared between several functions since every function within a\n+   strongly connected component will have the same information.  This\n+   sharing saves both time and space in the computation of the vectors\n+   as well as their translation from decl_uid form to ann_uid\n+   form.  */ \n+\n+struct ipa_reference_global_vars_info_d\n+{\n+  bitmap statics_read;\n+  bitmap statics_written;\n+  bitmap statics_not_read;\n+  bitmap statics_not_written;\n+};\n+\n+typedef struct ipa_reference_local_vars_info_d *ipa_reference_local_vars_info_t;\n+typedef struct ipa_reference_global_vars_info_d *ipa_reference_global_vars_info_t;\n+struct ipa_reference_vars_info_d \n+{\n+  ipa_reference_local_vars_info_t local;\n+  ipa_reference_global_vars_info_t global;\n+};\n+\n+typedef struct ipa_reference_vars_info_d *ipa_reference_vars_info_t;\n+\n /* This splay tree contains all of the static variables that are\n    being considered by the compilation level alias analysis.  For\n    module_at_a_time compilation, this is the set of static but not\n@@ -101,6 +147,8 @@ static bitmap_obstack global_info_obstack;\n \n /* Holders of ipa cgraph hooks: */\n static struct cgraph_node_hook_list *function_insertion_hook_holder;\n+static struct cgraph_2node_hook_list *node_duplication_hook_holder;\n+static struct cgraph_node_hook_list *node_removal_hook_holder;\n \n enum initialization_status_t\n {\n@@ -111,19 +159,37 @@ enum initialization_status_t\n \n tree memory_identifier_string;\n \n+/* Vector where the reference var infos are actually stored. */\n+DEF_VEC_P (ipa_reference_vars_info_t);\n+DEF_VEC_ALLOC_P (ipa_reference_vars_info_t, heap);\n+static VEC (ipa_reference_vars_info_t, heap) *ipa_reference_vars_vector;\n+\n /* Return the ipa_reference_vars structure starting from the cgraph NODE.  */\n static inline ipa_reference_vars_info_t\n-get_reference_vars_info_from_cgraph (struct cgraph_node * node)\n+get_reference_vars_info (struct cgraph_node *node)\n+{\n+  if (!ipa_reference_vars_vector\n+      || VEC_length (ipa_reference_vars_info_t, ipa_reference_vars_vector) <= (unsigned int)node->uid)\n+    return NULL;\n+  return VEC_index (ipa_reference_vars_info_t, ipa_reference_vars_vector, node->uid);\n+}\n+\n+/* Return the ipa_reference_vars structure starting from the cgraph NODE.  */\n+static inline void\n+set_reference_vars_info (struct cgraph_node *node, ipa_reference_vars_info_t info)\n {\n-  return get_function_ann (node->decl)->reference_vars_info;\n+  if (!ipa_reference_vars_vector\n+      || VEC_length (ipa_reference_vars_info_t, ipa_reference_vars_vector) <= (unsigned int)node->uid)\n+     VEC_safe_grow_cleared (ipa_reference_vars_info_t, heap, ipa_reference_vars_vector, node->uid + 1);\n+  VEC_replace (ipa_reference_vars_info_t, ipa_reference_vars_vector, node->uid, info);\n }\n \n /* Get a bitmap that contains all of the locally referenced static\n    variables for function FN.  */\n static ipa_reference_local_vars_info_t\n-get_local_reference_vars_info (tree fn) \n+get_local_reference_vars_info (struct cgraph_node *fn) \n {\n-  ipa_reference_vars_info_t info = get_function_ann (fn)->reference_vars_info;\n+  ipa_reference_vars_info_t info = get_reference_vars_info (fn);\n \n   if (info)\n     return info->local;\n@@ -136,9 +202,9 @@ get_local_reference_vars_info (tree fn)\n    variables for function FN.  */\n  \n static ipa_reference_global_vars_info_t\n-get_global_reference_vars_info (tree fn) \n+get_global_reference_vars_info (struct cgraph_node *fn) \n {\n-  ipa_reference_vars_info_t info = get_function_ann (fn)->reference_vars_info;\n+  ipa_reference_vars_info_t info = get_reference_vars_info (fn);\n \n   if (info)\n     return info->global;\n@@ -147,40 +213,12 @@ get_global_reference_vars_info (tree fn)\n     return NULL;\n }\n \n-/* Return a bitmap indexed by VAR_DECL uid for the static variables\n-   that may be read locally by the execution of the function fn.\n-   Returns NULL if no data is available.  */\n-\n-bitmap \n-ipa_reference_get_read_local (tree fn)\n-{\n-  ipa_reference_local_vars_info_t l = get_local_reference_vars_info (fn);\n-  if (l) \n-    return l->statics_read;\n-  else\n-    return NULL;\n-}\n-\n-/* Return a bitmap indexed by VAR_DECL uid for the static variables\n-   that may be written locally by the execution of the function fn.\n-   Returns NULL if no data is available.  */\n-\n-bitmap \n-ipa_reference_get_written_local (tree fn)\n-{\n-  ipa_reference_local_vars_info_t l = get_local_reference_vars_info (fn);\n-  if (l) \n-    return l->statics_written;\n-  else\n-    return NULL;\n-}\n-\n /* Return a bitmap indexed by VAR_DECL uid for the static variables\n    that are read during the execution of the function FN.  Returns\n    NULL if no data is available.  */\n \n bitmap \n-ipa_reference_get_read_global (tree fn) \n+ipa_reference_get_read_global (struct cgraph_node *fn) \n {\n   ipa_reference_global_vars_info_t g = get_global_reference_vars_info (fn);\n   if (g) \n@@ -195,7 +233,7 @@ ipa_reference_get_read_global (tree fn)\n    call.  Returns NULL if no data is available.  */\n \n bitmap \n-ipa_reference_get_written_global (tree fn) \n+ipa_reference_get_written_global (struct cgraph_node *fn) \n {\n   ipa_reference_global_vars_info_t g = get_global_reference_vars_info (fn);\n   if (g) \n@@ -209,7 +247,7 @@ ipa_reference_get_written_global (tree fn)\n    NULL if no data is available.  */\n \n bitmap \n-ipa_reference_get_not_read_global (tree fn) \n+ipa_reference_get_not_read_global (struct cgraph_node *fn) \n {\n   ipa_reference_global_vars_info_t g = get_global_reference_vars_info (fn);\n   if (g) \n@@ -224,7 +262,7 @@ ipa_reference_get_not_read_global (tree fn)\n    call.  Returns NULL if no data is available.  */\n \n bitmap \n-ipa_reference_get_not_written_global (tree fn) \n+ipa_reference_get_not_written_global (struct cgraph_node *fn) \n {\n   ipa_reference_global_vars_info_t g = get_global_reference_vars_info (fn);\n   if (g) \n@@ -360,7 +398,7 @@ check_call (ipa_reference_local_vars_info_t local, gimple stmt)\n       avail = cgraph_function_body_availability (callee);\n     }\n \n-  if (avail == AVAIL_NOT_AVAILABLE || avail == AVAIL_OVERWRITABLE)\n+  if (avail <= AVAIL_OVERWRITABLE)\n     if (local) \n       {\n \tif (flags & ECF_CONST) \n@@ -393,7 +431,7 @@ scan_stmt_for_static_refs (gimple_stmt_iterator *gsip,\n   bitmap_iterator bi;\n \n   if (fn)\n-    local = get_reference_vars_info_from_cgraph (fn)->local;\n+    local = get_reference_vars_info (fn)->local;\n \n   if (gimple_loaded_syms (stmt))\n     EXECUTE_IF_SET_IN_BITMAP (gimple_loaded_syms (stmt), 0, i, bi)\n@@ -472,30 +510,30 @@ get_static_name (int index)\n   return NULL;\n }\n \n-/* Or in all of the bits from every callee into X, the caller's, bit\n-   vector.  There are several cases to check to avoid the sparse\n+/* Or in all of the bits from every callee of X into X_GLOBAL, the caller's cycle,\n+   bit vector.  There are several cases to check to avoid the sparse\n    bitmap oring.  */\n \n static void\n-propagate_bits (struct cgraph_node *x)\n+propagate_bits (ipa_reference_global_vars_info_t x_global, struct cgraph_node *x)\n {\n-  ipa_reference_vars_info_t x_info = get_reference_vars_info_from_cgraph (x);\n-  ipa_reference_global_vars_info_t x_global = x_info->global;\n-\n   struct cgraph_edge *e;\n   for (e = x->callees; e; e = e->next_callee) \n     {\n       struct cgraph_node *y = e->callee;\n \n       /* Only look at the master nodes and skip external nodes.  */\n-      y = cgraph_master_clone (y);\n-      if (y)\n+      if (cgraph_function_body_availability (e->callee) > AVAIL_OVERWRITABLE)\n \t{\n-\t  if (get_reference_vars_info_from_cgraph (y))\n+\t  if (get_reference_vars_info (y))\n \t    {\n \t      ipa_reference_vars_info_t y_info \n-\t\t= get_reference_vars_info_from_cgraph (y);\n+\t\t= get_reference_vars_info (y);\n \t      ipa_reference_global_vars_info_t y_global = y_info->global;\n+\n+\t      /* Calls in current cycle do not have global computed yet.  */\n+\t      if (!y_info->global)\n+\t\tcontinue;\n \t      \n \t      if (x_global->statics_read\n \t\t  != all_module_statics)\n@@ -539,70 +577,6 @@ propagate_bits (struct cgraph_node *x)\n     }\n }\n \n-/* Look at all of the callees of X to see which ones represent inlined\n-   calls.  For each of these callees, merge their local info into\n-   TARGET and check their children recursively.  \n-\n-   This function goes away when Jan changes the inliner and IPA\n-   analysis so that this is not run between the time when inlining\n-   decisions are made and when the inlining actually occurs.  */\n-\n-static void \n-merge_callee_local_info (struct cgraph_node *target, \n-\t\t\t struct cgraph_node *x)\n-{\n-  struct cgraph_edge *e;\n-  ipa_reference_local_vars_info_t x_l = \n-    get_reference_vars_info_from_cgraph (target)->local;\n-\n-  /* Make the world safe for tail recursion.  */\n-  struct ipa_dfs_info *node_info = (struct ipa_dfs_info *) x->aux;\n-  \n-  if (node_info->aux) \n-    return;\n-\n-  node_info->aux = x;\n-\n-  for (e = x->callees; e; e = e->next_callee) \n-    {\n-      struct cgraph_node *y = e->callee;\n-      if (y->global.inlined_to) \n-\t{\n-\t  ipa_reference_vars_info_t y_info;\n-\t  ipa_reference_local_vars_info_t y_l;\n-\t  struct cgraph_node* orig_y = y;\n-\t \n-\t  y = cgraph_master_clone (y);\n-\t  if (y)\n-\t    {\n-\t      y_info = get_reference_vars_info_from_cgraph (y);\n-\t      y_l = y_info->local;\n-\t      if (x_l != y_l)\n-\t\t{\n-\t\t  bitmap_ior_into (x_l->statics_read,\n-\t\t\t\t   y_l->statics_read);\n-\t\t  bitmap_ior_into (x_l->statics_written,\n-\t\t\t\t   y_l->statics_written);\n-\t\t}\n-\t      x_l->calls_read_all |= y_l->calls_read_all;\n-\t      x_l->calls_write_all |= y_l->calls_write_all;\n-\t      merge_callee_local_info (target, y);\n-\t    }\n-\t  else \n-\t    {\n-\t      fprintf(stderr, \"suspect inlining of \");\n-\t      dump_cgraph_node (stderr, orig_y);\n-\t      fprintf(stderr, \"\\ninto \");\n-\t      dump_cgraph_node (stderr, target);\n-\t      dump_cgraph (stderr);\n-\t      gcc_assert(false);\n-\t    }\n-\t}\n-    }\n-\n-  node_info->aux = NULL;\n-}\n-\n /* The init routine for analyzing global static variable usage.  See\n    comments at top for description.  */\n static void \n@@ -653,10 +627,9 @@ init_function_info (struct cgraph_node *fn)\n     = XCNEW (struct ipa_reference_vars_info_d);\n   ipa_reference_local_vars_info_t l\n     = XCNEW (struct ipa_reference_local_vars_info_d);\n-  tree decl = fn->decl;\n \n   /* Add the info to the tree's annotation.  */\n-  get_function_ann (decl)->reference_vars_info = info;\n+  set_reference_vars_info (fn, info);\n \n   info->local = l;\n   l->statics_read = BITMAP_ALLOC (&local_info_obstack);\n@@ -728,18 +701,12 @@ analyze_function (struct cgraph_node *fn)\n   current_function_decl = NULL;\n }\n \n-/* If FN is avail == AVAIL_OVERWRITABLE, replace the effects bit\n-   vectors with worst case bit vectors.  We had to analyze it above to\n-   find out if it took the address of any statics. However, now that\n-   we know that, we can get rid of all of the other side effects.  */\n-\n+/* Remove local data associated with function FN.  */\n static void\n-clean_function (struct cgraph_node *fn)\n+clean_function_local_data (struct cgraph_node *fn)\n {\n-  ipa_reference_vars_info_t info = get_reference_vars_info_from_cgraph (fn);\n+  ipa_reference_vars_info_t info = get_reference_vars_info (fn);\n   ipa_reference_local_vars_info_t l = info->local;\n-  ipa_reference_global_vars_info_t g = info->global;\n-  \n   if (l)\n     {\n       if (l->statics_read\n@@ -749,8 +716,19 @@ clean_function (struct cgraph_node *fn)\n \t  &&l->statics_written != all_module_statics)\n \tBITMAP_FREE (l->statics_written);\n       free (l);\n+      info->local = NULL;\n     }\n+}\n+\n+/* Remove all data associated with function FN.  */\n+\n+static void\n+clean_function (struct cgraph_node *fn)\n+{\n+  ipa_reference_vars_info_t info = get_reference_vars_info (fn);\n+  ipa_reference_global_vars_info_t g = info->global;\n   \n+  clean_function_local_data (fn);\n   if (g)\n     {\n       if (g->statics_read\n@@ -769,10 +747,11 @@ clean_function (struct cgraph_node *fn)\n \t  && g->statics_not_written != all_module_statics)\n \tBITMAP_FREE (g->statics_not_written);\n       free (g);\n+      info->global = NULL;\n     }\n   \n-  free (get_function_ann (fn->decl)->reference_vars_info);\n-  get_function_ann (fn->decl)->reference_vars_info = NULL;\n+  free (get_reference_vars_info (fn));\n+  set_reference_vars_info (fn, NULL);\n }\n \n /* Called when new function is inserted to callgraph late.  */\n@@ -787,6 +766,76 @@ add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n   visited_nodes = NULL;\n }\n \n+static bitmap\n+copy_local_bitmap (bitmap src)\n+{\n+  bitmap dst;\n+  if (!src)\n+    return NULL;\n+  if (src == all_module_statics)\n+    return all_module_statics;\n+  dst = BITMAP_ALLOC (&local_info_obstack);\n+  bitmap_copy (dst, src);\n+  return dst;\n+}\n+\n+static bitmap\n+copy_global_bitmap (bitmap src)\n+{\n+  bitmap dst;\n+  if (!src)\n+    return NULL;\n+  if (src == all_module_statics)\n+    return all_module_statics;\n+  dst = BITMAP_ALLOC (&global_info_obstack);\n+  bitmap_copy (dst, src);\n+  return dst;\n+}\n+\n+/* Called when new clone is inserted to callgraph late.  */\n+\n+static void\n+duplicate_node_data (struct cgraph_node *src, struct cgraph_node *dst,\n+\t \t     void *data ATTRIBUTE_UNUSED)\n+{\n+  ipa_reference_global_vars_info_t ginfo;\n+  ipa_reference_local_vars_info_t linfo;\n+  ipa_reference_global_vars_info_t dst_ginfo;\n+  ipa_reference_local_vars_info_t dst_linfo;\n+\n+  ginfo = get_global_reference_vars_info (src);\n+  linfo = get_local_reference_vars_info (src);\n+  if (!linfo && !ginfo)\n+    return;\n+  init_function_info (dst);\n+  if (linfo)\n+    {\n+      dst_linfo = get_local_reference_vars_info (dst);\n+      dst_linfo->statics_read = copy_local_bitmap (linfo->statics_read);\n+      dst_linfo->statics_written = copy_local_bitmap (linfo->statics_written);\n+      dst_linfo->calls_read_all = linfo->calls_read_all;\n+      dst_linfo->calls_write_all = linfo->calls_write_all;\n+    }\n+  if (ginfo)\n+    {\n+      get_reference_vars_info (dst)->global = XCNEW (struct ipa_reference_global_vars_info_d);\n+      dst_ginfo = get_global_reference_vars_info (dst);\n+      dst_ginfo->statics_read = copy_global_bitmap (ginfo->statics_read);\n+      dst_ginfo->statics_written = copy_global_bitmap (ginfo->statics_written);\n+      dst_ginfo->statics_not_read = copy_global_bitmap (ginfo->statics_not_read);\n+      dst_ginfo->statics_not_written = copy_global_bitmap (ginfo->statics_not_written);\n+    }\n+}\n+\n+/* Called when node is removed.  */\n+\n+static void\n+remove_node_data (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+{\n+  if (get_reference_vars_info (node))\n+    clean_function (node);\n+}\n+\n /* Analyze each function in the cgraph to see which global or statics\n    are read or written.  */\n \n@@ -802,6 +851,10 @@ generate_summary (void)\n   \n   function_insertion_hook_holder =\n       cgraph_add_function_insertion_hook (&add_new_function, NULL);\n+  node_removal_hook_holder =\n+      cgraph_add_node_removal_hook (&remove_node_data, NULL);\n+  node_duplication_hook_holder =\n+      cgraph_add_node_duplication_hook (&duplicate_node_data, NULL);\n   ipa_init ();\n   module_statics_readonly = BITMAP_ALLOC (&local_info_obstack);\n   bm_temp = BITMAP_ALLOC (&local_info_obstack);\n@@ -822,10 +875,7 @@ generate_summary (void)\n      replaced with worst case info.  \n   */\n   for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed \n-\t&& (cgraph_is_master_clone (node)\n-\t    || (cgraph_function_body_availability (node) \n-\t\t== AVAIL_OVERWRITABLE)))\n+    if (cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       analyze_function (node);\n \n   pointer_set_destroy (visited_nodes);\n@@ -890,13 +940,10 @@ generate_summary (void)\n       }\n   \n   for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed \n-\t&& (cgraph_is_master_clone (node)\n-\t    || (cgraph_function_body_availability (node) \n-\t\t== AVAIL_OVERWRITABLE)))\n+    if (cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       {\n \tipa_reference_local_vars_info_t l;\n-\tl = get_reference_vars_info_from_cgraph (node)->local;\n+\tl = get_reference_vars_info (node)->local;\n \t\n \t/* Any variables that are not in all_module_statics are\n \t   removed from the local maps.  This will include all of the\n@@ -913,16 +960,13 @@ generate_summary (void)\n   \n   if (dump_file)\n     for (node = cgraph_nodes; node; node = node->next)\n-      if (node->analyzed \n-\t  && (cgraph_is_master_clone (node)\n-\t      || (cgraph_function_body_availability (node) \n-\t\t  == AVAIL_OVERWRITABLE)))\n+      if (cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n \t{\n \t  ipa_reference_local_vars_info_t l;\n \t  unsigned int index;\n \t  bitmap_iterator bi;\n \t  \n-\t  l = get_reference_vars_info_from_cgraph (node)->local;\n+\t  l = get_reference_vars_info (node)->local;\n \t  fprintf (dump_file, \n \t\t   \"\\nFunction name:%s/%i:\", \n \t\t   cgraph_node_name (node), node->uid);\n@@ -940,6 +984,10 @@ generate_summary (void)\n \t      fprintf(dump_file, \"%s \",\n \t\t      get_static_name (index));\n \t    }\n+\t  if (l->calls_read_all)\n+\t     fprintf (dump_file, \"\\n  calls read all: \");\n+\t  if (l->calls_write_all)\n+\t     fprintf (dump_file, \"\\n  calls read all: \");\n \t}\n }\n \f\n@@ -981,15 +1029,15 @@ propagate (void)\n       struct ipa_dfs_info * w_info;\n \n       node = order[i];\n-      node_info = get_reference_vars_info_from_cgraph (node);\n+      node_info = get_reference_vars_info (node);\n       if (!node_info) \n \t{\n \t  dump_cgraph_node (stderr, node);\n \t  dump_cgraph (stderr);\n \t  gcc_unreachable ();\n \t}\n \n-      node_info->global = node_g;\n+      gcc_assert (!node_info->global);\n       node_l = node_info->local;\n \n       read_all = node_l->calls_read_all;\n@@ -1002,7 +1050,7 @@ propagate (void)\n       while (w)\n \t{\n \t  ipa_reference_local_vars_info_t w_l = \n-\t    get_reference_vars_info_from_cgraph (w)->local;\n+\t    get_reference_vars_info (w)->local;\n \t  read_all |= w_l->calls_read_all;\n \t  write_all |= w_l->calls_write_all;\n \n@@ -1029,16 +1077,14 @@ propagate (void)\n \t\t       node_l->statics_written);\n \t}\n \n+      propagate_bits (node_g, node);\n       w_info = (struct ipa_dfs_info *) node->aux;\n       w = w_info->next_cycle;\n       while (w)\n \t{\n \t  ipa_reference_vars_info_t w_ri = \n-\t    get_reference_vars_info_from_cgraph (w);\n+\t    get_reference_vars_info (w);\n \t  ipa_reference_local_vars_info_t w_l = w_ri->local;\n-\n-\t  /* All nodes within a cycle share the same global info bitmaps.  */\n-\t  w_ri->global = node_g;\n \t  \n \t  /* These global bitmaps are initialized from the local info\n \t     of all of the nodes in the region.  However there is no\n@@ -1050,36 +1096,25 @@ propagate (void)\n \t  if (!write_all)\n \t    bitmap_ior_into (node_g->statics_written,\n \t\t\t     w_l->statics_written);\n+\t  propagate_bits (node_g, w);\n \t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n \t}\n \n-      w = node;\n-      while (w)\n-\t{\n-\t  propagate_bits (w);\n-\t  w_info = (struct ipa_dfs_info *) w->aux;\n-\t  w = w_info->next_cycle;\n-\t}\n-    }\n-\n-  /* Need to fix up the local information sets.  The information that\n-     has been gathered so far is preinlining.  However, the\n-     compilation will progress post inlining so the local sets for the\n-     inlined calls need to be merged into the callers.  Note that the\n-     local sets are not shared between all of the nodes in a cycle so\n-     those nodes in the cycle must be processed explicitly.  */\n-  for (i = 0; i < order_pos; i++ )\n-    {\n-      struct ipa_dfs_info * w_info;\n-      node = order[i];\n-      merge_callee_local_info (node, node);\n-      \n+      /* All nodes within a cycle have the same global info bitmaps.  */\n+      node_info->global = node_g;\n       w_info = (struct ipa_dfs_info *) node->aux;\n       w = w_info->next_cycle;\n       while (w)\n \t{\n-\t  merge_callee_local_info (w, w);\n+\t  ipa_reference_vars_info_t w_ri = \n+\t    get_reference_vars_info (w);\n+\n+\t  gcc_assert (!w_ri->global);\n+          w_ri->global = XCNEW (struct ipa_reference_global_vars_info_d);\n+\t  w_ri->global->statics_read = copy_global_bitmap (node_g->statics_read);\n+\t  w_ri->global->statics_written = copy_global_bitmap (node_g->statics_written);\n+\n \t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n \t}\n@@ -1097,7 +1132,7 @@ propagate (void)\n \t  struct ipa_dfs_info * w_info;\n \n \t  node = order[i];\n-\t  node_info = get_reference_vars_info_from_cgraph (node);\n+\t  node_info = get_reference_vars_info (node);\n \t  node_g = node_info->global;\n \t  node_l = node_info->local;\n \t  fprintf (dump_file, \n@@ -1123,7 +1158,7 @@ propagate (void)\n \t  while (w) \n \t    {\n \t      ipa_reference_vars_info_t w_ri = \n-\t\tget_reference_vars_info_from_cgraph (w);\n+\t\tget_reference_vars_info (w);\n \t      ipa_reference_local_vars_info_t w_l = w_ri->local;\n \t      fprintf (dump_file, \"\\n  next cycle: %s/%i \",\n \t\t       cgraph_node_name (w), w->uid);\n@@ -1170,7 +1205,7 @@ propagate (void)\n       ipa_reference_vars_info_t node_info;\n       ipa_reference_global_vars_info_t node_g;\n       node = order[i];\n-      node_info = get_reference_vars_info_from_cgraph (node);\n+      node_info = get_reference_vars_info (node);\n       node_g = node_info->global;\n       \n       /* Create the complimentary sets.  These are more useful for\n@@ -1179,11 +1214,9 @@ propagate (void)\n       node_g->statics_not_written = BITMAP_ALLOC (&global_info_obstack);\n \n       if (node_g->statics_read != all_module_statics) \n-\t{\n-\t  bitmap_and_compl (node_g->statics_not_read, \n-\t\t\t    all_module_statics,\n-\t\t\t    node_g->statics_read);\n-\t}\n+\tbitmap_and_compl (node_g->statics_not_read, \n+\t\t\t  all_module_statics,\n+\t\t\t  node_g->statics_read);\n \n       if (node_g->statics_written \n \t  != all_module_statics) \n@@ -1197,7 +1230,7 @@ propagate (void)\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       ipa_reference_vars_info_t node_info;\n-      node_info = get_reference_vars_info_from_cgraph (node);\n+      node_info = get_reference_vars_info (node);\n       /* Get rid of the aux information.  */\n       \n       if (node->aux)\n@@ -1206,19 +1239,10 @@ propagate (void)\n \t  node->aux = NULL;\n \t}\n       \n-      if (node->analyzed \n-\t  && (cgraph_function_body_availability (node) == AVAIL_OVERWRITABLE))\n+      if (cgraph_function_body_availability (node) == AVAIL_OVERWRITABLE)\n \tclean_function (node);\n       else if (node_info)\n-\t{\n-\t  /* Remove local info we no longer need.  */\n-\t  if (node_info->local->statics_read\n-\t      && node_info->local->statics_read != all_module_statics)\n-\t    BITMAP_FREE (node_info->local->statics_read);\n-\t  if (node_info->local->statics_written\n-\t      && node_info->local->statics_written != all_module_statics)\n-\t    BITMAP_FREE (node_info->local->statics_written);\n-\t}\n+\tclean_function_local_data (node);\n     }\n   bitmap_obstack_release (&local_info_obstack);\n   return 0;"}, {"sha": "7d5b36ed36bf7ea2ca21f8f1658a1c8dafe94dc6", "filename": "gcc/ipa-reference.h", "status": "modified", "additions": 4, "deletions": 53, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb/gcc%2Fipa-reference.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb/gcc%2Fipa-reference.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.h?ref=e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb", "patch": "@@ -23,60 +23,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"tree.h\"\n \n-/* The static variables defined within the compilation unit that are\n-   loaded or stored directly by function that owns this structure.  */ \n-\n-struct ipa_reference_local_vars_info_d \n-{\n-  bitmap statics_read;\n-  bitmap statics_written;\n-\n-  /* Set when this function calls another function external to the\n-     compilation unit or if the function has a asm clobber of memory.\n-     In general, such calls are modeled as reading and writing all\n-     variables (both bits on) but sometime there are attributes on the\n-     called function so we can do better.  */\n-  bool calls_read_all;\n-  bool calls_write_all;\n-};\n-\n-struct ipa_reference_global_vars_info_d\n-{\n-  bitmap statics_read;\n-  bitmap statics_written;\n-  bitmap statics_not_read;\n-  bitmap statics_not_written;\n-};\n-\n-/* Statics that are read and written by some set of functions. The\n-   local ones are based on the loads and stores local to the function.\n-   The global ones are based on the local info as well as the\n-   transitive closure of the functions that are called.  The\n-   structures are separated to allow the global structures to be\n-   shared between several functions since every function within a\n-   strongly connected component will have the same information.  This\n-   sharing saves both time and space in the computation of the vectors\n-   as well as their translation from decl_uid form to ann_uid\n-   form.  */ \n-\n-typedef struct ipa_reference_local_vars_info_d *ipa_reference_local_vars_info_t;\n-typedef struct ipa_reference_global_vars_info_d *ipa_reference_global_vars_info_t;\n-\n-struct ipa_reference_vars_info_d \n-{\n-  ipa_reference_local_vars_info_t local;\n-  ipa_reference_global_vars_info_t global;\n-};\n-\n-typedef struct ipa_reference_vars_info_d *ipa_reference_vars_info_t;\n-\n /* In ipa-reference.c  */\n-bitmap ipa_reference_get_read_local (tree fn);\n-bitmap ipa_reference_get_written_local (tree fn);\n-bitmap ipa_reference_get_read_global (tree fn);\n-bitmap ipa_reference_get_written_global (tree fn);\n-bitmap ipa_reference_get_not_read_global (tree fn);\n-bitmap ipa_reference_get_not_written_global (tree fn);\n+bitmap ipa_reference_get_read_global (struct cgraph_node *fn);\n+bitmap ipa_reference_get_written_global (struct cgraph_node *fn);\n+bitmap ipa_reference_get_not_read_global (struct cgraph_node *fn);\n+bitmap ipa_reference_get_not_written_global (struct cgraph_node *fn);\n \n #endif  /* GCC_IPA_REFERENCE_H  */\n "}, {"sha": "95e1856ac5b4dcfd4ebac0092bdecf202e439681", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb", "patch": "@@ -100,10 +100,8 @@ searchc (struct searchc_env* env, struct cgraph_node *v)\n     {\n       struct ipa_dfs_info * w_info;\n       struct cgraph_node *w = edge->callee;\n-      /* Bypass the clones and only look at the master node.  Skip\n-\t external and other bogus nodes.  */\n-      w = cgraph_master_clone (w);\n-      if (w && w->aux) \n+\n+      if (w->aux && cgraph_function_body_availability (edge->callee) > AVAIL_OVERWRITABLE)\n \t{\n \t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  if (w_info->new_node) \n@@ -168,27 +166,29 @@ ipa_utils_reduced_inorder (struct cgraph_node **order,\n   env.reduce = reduce;\n   \n   for (node = cgraph_nodes; node; node = node->next) \n-    if ((node->analyzed)\n-\t&& (cgraph_is_master_clone (node) \n-\t || (allow_overwritable \n-\t     && (cgraph_function_body_availability (node) == \n-\t\t AVAIL_OVERWRITABLE))))\n-      {\n-\t/* Reuse the info if it is already there.  */\n-\tstruct ipa_dfs_info *info = (struct ipa_dfs_info *) node->aux;\n-\tif (!info)\n-\t  info = XCNEW (struct ipa_dfs_info);\n-\tinfo->new_node = true;\n-\tinfo->on_stack = false;\n-\tinfo->next_cycle = NULL;\n-\tnode->aux = info;\n-\t\n-\tsplay_tree_insert (env.nodes_marked_new,\n-\t\t\t   (splay_tree_key)node->uid, \n-\t\t\t   (splay_tree_value)node);\n-      } \n-    else \n-      node->aux = NULL;\n+    {\n+      enum availability avail = cgraph_function_body_availability (node);\n+\n+      if (avail > AVAIL_OVERWRITABLE\n+\t  || (allow_overwritable \n+\t      && (avail == AVAIL_OVERWRITABLE)))\n+\t{\n+\t  /* Reuse the info if it is already there.  */\n+\t  struct ipa_dfs_info *info = (struct ipa_dfs_info *) node->aux;\n+\t  if (!info)\n+\t    info = XCNEW (struct ipa_dfs_info);\n+\t  info->new_node = true;\n+\t  info->on_stack = false;\n+\t  info->next_cycle = NULL;\n+\t  node->aux = info;\n+\t  \n+\t  splay_tree_insert (env.nodes_marked_new,\n+\t\t\t     (splay_tree_key)node->uid, \n+\t\t\t     (splay_tree_value)node);\n+\t} \n+      else \n+\tnode->aux = NULL;\n+    }\n   result = splay_tree_min (env.nodes_marked_new);\n   while (result)\n     {"}, {"sha": "962418895385dcdd525244b7e796b7e33a6fb9ab", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=e2c9111c0eac78bd9249d98ecdaebc9a4e327ffb", "patch": "@@ -1653,8 +1653,8 @@ add_call_clobber_ops (gimple stmt, tree callee ATTRIBUTE_UNUSED)\n   /* Get info for local and module level statics.  There is a bit\n      set for each static if the call being processed does not read\n      or write that variable.  */\n-  not_read_b = callee ? ipa_reference_get_not_read_global (callee) : NULL; \n-  not_written_b = callee ? ipa_reference_get_not_written_global (callee) : NULL;\n+  not_read_b = callee ? ipa_reference_get_not_read_global (cgraph_node (callee)) : NULL; \n+  not_written_b = callee ? ipa_reference_get_not_written_global (cgraph_node (callee)) : NULL;\n \n   /* Add a VDEF operand for every call clobbered variable.  */\n   EXECUTE_IF_SET_IN_BITMAP (gimple_call_clobbered_vars (cfun), 0, u, bi)\n@@ -1705,7 +1705,7 @@ add_call_read_ops (gimple stmt, tree callee ATTRIBUTE_UNUSED)\n   if (gimple_call_flags (stmt) & ECF_CONST)\n     return;\n \n-  not_read_b = callee ? ipa_reference_get_not_read_global (callee) : NULL;\n+  not_read_b = callee ? ipa_reference_get_not_read_global (cgraph_node (callee)) : NULL;\n \n   /* For pure functions we compute non-escaped uses separately.  */\n   if (gimple_call_flags (stmt) & ECF_PURE)"}]}