{"sha": "c8b64bf26dc94f4ab593dc3fb24aac2d9d23bf0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzhiNjRiZjI2ZGM5NGY0YWI1OTNkYzNmYjI0YWFjMmQ5ZDIzYmYwZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2002-06-30T05:06:01Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2002-06-30T05:06:01Z"}, "message": "* unroll.c (loop_iterations): Handle EQ loops.\n\nFrom-SVN: r55111", "tree": {"sha": "b780d4de1e00a64a155dab924c671d56ae29688f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b780d4de1e00a64a155dab924c671d56ae29688f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8b64bf26dc94f4ab593dc3fb24aac2d9d23bf0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8b64bf26dc94f4ab593dc3fb24aac2d9d23bf0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8b64bf26dc94f4ab593dc3fb24aac2d9d23bf0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8b64bf26dc94f4ab593dc3fb24aac2d9d23bf0e/comments", "author": null, "committer": null, "parents": [{"sha": "35aba846c1c56e15269b9b87cad3ad24b3f0de79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35aba846c1c56e15269b9b87cad3ad24b3f0de79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35aba846c1c56e15269b9b87cad3ad24b3f0de79"}], "stats": {"total": 47, "additions": 41, "deletions": 6}, "files": [{"sha": "0ec03d0327be38ac50094b52d402b39772f7087d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8b64bf26dc94f4ab593dc3fb24aac2d9d23bf0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8b64bf26dc94f4ab593dc3fb24aac2d9d23bf0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c8b64bf26dc94f4ab593dc3fb24aac2d9d23bf0e", "patch": "@@ -1,3 +1,7 @@\n+2002-06-30  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* unroll.c (loop_iterations): Handle EQ loops.\n+\n 2002-06-29  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/rs6000.md (ctrdi): Allocate pseudo for FPR"}, {"sha": "e0b0d36579d109b723cf8ab555c82f7c4c9298c8", "filename": "gcc/unroll.c", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8b64bf26dc94f4ab593dc3fb24aac2d9d23bf0e/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8b64bf26dc94f4ab593dc3fb24aac2d9d23bf0e/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=c8b64bf26dc94f4ab593dc3fb24aac2d9d23bf0e", "patch": "@@ -3941,12 +3941,6 @@ loop_iterations (loop)\n \t}\n       return 0;\n     }\n-  else if (comparison_code == EQ)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream, \"Loop iterations: EQ comparison loop.\\n\");\n-      return 0;\n-    }\n   else if (GET_CODE (final_value) != CONST_INT)\n     {\n       if (loop_dump_stream)\n@@ -3958,6 +3952,43 @@ loop_iterations (loop)\n \t}\n       return 0;\n     }\n+  else if (comparison_code == EQ)\n+    {\n+      rtx inc_once;\n+\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream, \"Loop iterations: EQ comparison loop.\\n\");\n+\n+      inc_once = gen_int_mode (INTVAL (initial_value) + INTVAL (increment),\n+\t\t\t       GET_MODE (iteration_var));\n+\n+      if (inc_once == final_value)\n+\t{\n+\t  /* The iterator value once through the loop is equal to the\n+\t     comparision value.  Either we have an infinite loop, or\n+\t     we'll loop twice.  */\n+\t  if (increment == const0_rtx)\n+\t    return 0;\n+\t  loop_info->n_iterations = 2;\n+\t}\n+      else\n+\tloop_info->n_iterations = 1;\n+\n+      if (GET_CODE (loop_info->initial_value) == CONST_INT)\n+\tloop_info->final_value\n+\t  = gen_int_mode ((INTVAL (loop_info->initial_value)\n+\t\t\t   + loop_info->n_iterations * INTVAL (increment)),\n+\t\t\t  GET_MODE (iteration_var));\n+      else\n+\tloop_info->final_value\n+\t  = plus_constant (loop_info->initial_value,\n+\t\t\t   loop_info->n_iterations * INTVAL (increment));\n+      loop_info->final_equiv_value\n+\t= gen_int_mode ((INTVAL (initial_value)\n+\t\t\t + loop_info->n_iterations * INTVAL (increment)),\n+\t\t\tGET_MODE (iteration_var));\n+      return loop_info->n_iterations;\n+    }\n \n   /* Final_larger is 1 if final larger, 0 if they are equal, otherwise -1.  */\n   if (unsigned_p)"}]}