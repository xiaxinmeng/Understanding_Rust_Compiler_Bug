{"sha": "45d44c982d3ebc4b55a029498ff9ec6156542ef0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVkNDRjOTgyZDNlYmM0YjU1YTAyOTQ5OGZmOWVjNjE1NjU0MmVmMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-31T13:18:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-31T13:18:01Z"}, "message": "(struct arg_data, expand_call): Test STRICT_ALIGN with #if.\n\nFrom-SVN: r11132", "tree": {"sha": "70c5cfd594a559ba12ee57b6bf9e41d57e9781bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70c5cfd594a559ba12ee57b6bf9e41d57e9781bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45d44c982d3ebc4b55a029498ff9ec6156542ef0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d44c982d3ebc4b55a029498ff9ec6156542ef0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45d44c982d3ebc4b55a029498ff9ec6156542ef0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d44c982d3ebc4b55a029498ff9ec6156542ef0/comments", "author": null, "committer": null, "parents": [{"sha": "be0dc4c406a13891264db924c9b08c963d02626a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be0dc4c406a13891264db924c9b08c963d02626a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be0dc4c406a13891264db924c9b08c963d02626a"}], "stats": {"total": 111, "additions": 52, "deletions": 59}, "files": [{"sha": "073a23c2b234156a0e0c837fedcfdd1e791b55d5", "filename": "gcc/calls.c", "status": "modified", "additions": 52, "deletions": 59, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d44c982d3ebc4b55a029498ff9ec6156542ef0/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d44c982d3ebc4b55a029498ff9ec6156542ef0/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=45d44c982d3ebc4b55a029498ff9ec6156542ef0", "patch": "@@ -1,5 +1,5 @@\n /* Convert function calls to rtl insns, for GNU C compiler.\n-   Copyright (C) 1989, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -95,14 +95,12 @@ struct arg_data\n   /* Place that this stack area has been saved, if needed.  */\n   rtx save_area;\n #endif\n-#ifdef STRICT_ALIGNMENT\n   /* If an argument's alignment does not permit direct copying into registers,\n      copy in smaller-sized pieces into pseudos.  These are stored in a\n      block pointed to by this field.  The next field says how many\n      word-sized pseudos we made.  */\n   rtx *aligned_regs;\n   int n_aligned_regs;\n-#endif\n };\n \n #ifdef ACCUMULATE_OUTGOING_ARGS\n@@ -1739,68 +1737,67 @@ expand_call (exp, target, ignore)\n       store_one_arg (&args[i], argblock, may_be_alloca,\n \t\t     args_size.var != 0, fndecl, reg_parm_stack_space);\n \n-#ifdef STRICT_ALIGNMENT\n   /* If we have a parm that is passed in registers but not in memory\n      and whose alignment does not permit a direct copy into registers,\n      make a group of pseudos that correspond to each register that we\n      will later fill.  */\n \n-  for (i = 0; i < num_actuals; i++)\n-    if (args[i].reg != 0 && ! args[i].pass_on_stack\n+  if (STRICT_ALIGNMENT)\n+    for (i = 0; i < num_actuals; i++)\n+      if (args[i].reg != 0 && ! args[i].pass_on_stack\n \t&& args[i].mode == BLKmode\n-\t&& (TYPE_ALIGN (TREE_TYPE (args[i].tree_value))\n-\t    < MIN (BIGGEST_ALIGNMENT, BITS_PER_WORD)))\n-      {\n-\tint bytes = int_size_in_bytes (TREE_TYPE (args[i].tree_value));\n-\tint big_endian_correction = 0;\n+\t  && (TYPE_ALIGN (TREE_TYPE (args[i].tree_value))\n+\t      < MIN (BIGGEST_ALIGNMENT, BITS_PER_WORD)))\n+\t{\n+\t  int bytes = int_size_in_bytes (TREE_TYPE (args[i].tree_value));\n+\t  int big_endian_correction = 0;\n \n-\targs[i].n_aligned_regs\n-\t  = args[i].partial ? args[i].partial\n-\t    : (bytes + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n+\t  args[i].n_aligned_regs\n+\t    = args[i].partial ? args[i].partial\n+\t      : (bytes + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n \n-\targs[i].aligned_regs = (rtx *) alloca (sizeof (rtx)\n-\t\t\t\t\t       * args[i].n_aligned_regs);\n+\t  args[i].aligned_regs = (rtx *) alloca (sizeof (rtx)\n+\t\t\t\t\t\t * args[i].n_aligned_regs);\n \n-\t/* Structures smaller than a word are aligned to the least significant\n-\t   byte (to the right).  On a BYTES_BIG_ENDIAN machine, this means we\n-\t   must skip the empty high order bytes when calculating the bit\n-\t   offset.  */\n-\tif (BYTES_BIG_ENDIAN && bytes < UNITS_PER_WORD)\n-\t  big_endian_correction = (BITS_PER_WORD  - (bytes * BITS_PER_UNIT));\n+\t  /* Structures smaller than a word are aligned to the least\n+\t     significant byte (to the right).  On a BYTES_BIG_ENDIAN machine,\n+\t     this means we must skip the empty high order bytes when\n+\t     calculating the bit offset.  */\n+\t  if (BYTES_BIG_ENDIAN && bytes < UNITS_PER_WORD)\n+\t    big_endian_correction = (BITS_PER_WORD  - (bytes * BITS_PER_UNIT));\n \n-\tfor (j = 0; j < args[i].n_aligned_regs; j++)\n-\t  {\n-\t    rtx reg = gen_reg_rtx (word_mode);\n-\t    rtx word = operand_subword_force (args[i].value, j, BLKmode);\n-\t    int bitsize = TYPE_ALIGN (TREE_TYPE (args[i].tree_value));\n-\t    int bitpos;\n-\n-\t    args[i].aligned_regs[j] = reg;\n-\n-\t    /* Clobber REG and move each partword into it.  Ensure we don't\n-\t       go past the end of the structure.  Note that the loop below\n-\t       works because we've already verified that padding\n-\t       and endianness are compatible.  */\n-\n-\t    emit_insn (gen_rtx (CLOBBER, VOIDmode, reg));\n-\n-\t    for (bitpos = 0;\n-\t\t bitpos < BITS_PER_WORD && bytes > 0;\n-\t\t bitpos += bitsize, bytes -= bitsize / BITS_PER_UNIT)\n-\t      {\n-\t\tint xbitpos = bitpos + big_endian_correction;\n-\n-\t\tstore_bit_field (reg, bitsize, xbitpos, word_mode,\n-\t\t\t\t extract_bit_field (word, bitsize, bitpos, 1,\n-\t\t\t\t\t\t    NULL_RTX, word_mode,\n-\t\t\t\t\t\t    word_mode,\n-\t\t\t\t\t\t    bitsize / BITS_PER_UNIT,\n-\t\t\t\t\t\t    BITS_PER_WORD),\n-\t\t\t\t bitsize / BITS_PER_UNIT, BITS_PER_WORD);\n-\t      }\n-\t  }\n-      }\n-#endif\n+\t  for (j = 0; j < args[i].n_aligned_regs; j++)\n+\t    {\n+\t      rtx reg = gen_reg_rtx (word_mode);\n+\t      rtx word = operand_subword_force (args[i].value, j, BLKmode);\n+\t      int bitsize = TYPE_ALIGN (TREE_TYPE (args[i].tree_value));\n+\t      int bitpos;\n+\n+\t      args[i].aligned_regs[j] = reg;\n+\n+\t      /* Clobber REG and move each partword into it.  Ensure we don't\n+\t\t go past the end of the structure.  Note that the loop below\n+\t\t works because we've already verified that padding\n+\t\t and endianness are compatible.  */\n+\n+\t      emit_insn (gen_rtx (CLOBBER, VOIDmode, reg));\n+\n+\t      for (bitpos = 0;\n+\t\t   bitpos < BITS_PER_WORD && bytes > 0;\n+\t\t   bitpos += bitsize, bytes -= bitsize / BITS_PER_UNIT)\n+\t\t{\n+\t\t  int xbitpos = bitpos + big_endian_correction;\n+\n+\t\t  store_bit_field (reg, bitsize, xbitpos, word_mode,\n+\t\t\t\t   extract_bit_field (word, bitsize, bitpos, 1,\n+\t\t\t\t\t\t      NULL_RTX, word_mode,\n+\t\t\t\t\t\t      word_mode,\n+\t\t\t\t\t\t      bitsize / BITS_PER_UNIT,\n+\t\t\t\t\t\t      BITS_PER_WORD),\n+\t\t\t\t   bitsize / BITS_PER_UNIT, BITS_PER_WORD);\n+\t\t}\n+\t    }\n+\t}\n \n   /* Now store any partially-in-registers parm.\n      This is the last place a block-move can happen.  */\n@@ -1881,15 +1878,13 @@ expand_call (exp, target, ignore)\n \t  if (nregs == -1)\n \t    emit_move_insn (reg, args[i].value);\n \n-#ifdef STRICT_ALIGNMENT\n \t  /* If we have pre-computed the values to put in the registers in\n \t     the case of non-aligned structures, copy them in now.  */\n \n \t  else if (args[i].n_aligned_regs != 0)\n \t    for (j = 0; j < args[i].n_aligned_regs; j++)\n \t      emit_move_insn (gen_rtx (REG, word_mode, REGNO (reg) + j),\n \t\t\t      args[i].aligned_regs[j]);\n-#endif\n \n \t  else if (args[i].partial == 0 || args[i].pass_on_stack)\n \t    move_block_to_reg (REGNO (reg),\n@@ -3035,12 +3030,10 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n        this case.   */\n     abort ();\n \n-#ifdef STRICT_ALIGNMENT\n   /* If this arg needs special alignment, don't load the registers\n      here.  */\n   if (arg->n_aligned_regs != 0)\n     reg = 0;\n-#endif\n   \n   /* If this is being partially passed in a register, but multiple locations\n      are specified, we assume that the one partially used is the one that is"}]}