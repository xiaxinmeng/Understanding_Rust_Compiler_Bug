{"sha": "fe08a886b290a32453dd5ff084a2af073dd26968", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUwOGE4ODZiMjkwYTMyNDUzZGQ1ZmYwODRhMmFmMDczZGQyNjk2OA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2000-12-22T15:44:42Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-12-22T15:44:42Z"}, "message": "Renamer improvements.\n\nFrom-SVN: r38463", "tree": {"sha": "6973682f1028b31171959139a0c7e95e92a07de8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6973682f1028b31171959139a0c7e95e92a07de8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe08a886b290a32453dd5ff084a2af073dd26968", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe08a886b290a32453dd5ff084a2af073dd26968", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe08a886b290a32453dd5ff084a2af073dd26968", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe08a886b290a32453dd5ff084a2af073dd26968/comments", "author": null, "committer": null, "parents": [{"sha": "e6fe680d2e00451a9b646a23a22dafc625375f76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6fe680d2e00451a9b646a23a22dafc625375f76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6fe680d2e00451a9b646a23a22dafc625375f76"}], "stats": {"total": 259, "additions": 184, "deletions": 75}, "files": [{"sha": "d1568bb84109c2f7b665bbc6808699df4f381a80", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe08a886b290a32453dd5ff084a2af073dd26968/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe08a886b290a32453dd5ff084a2af073dd26968/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe08a886b290a32453dd5ff084a2af073dd26968", "patch": "@@ -1,3 +1,23 @@\n+2000-12-22  Bernd Schmidt  <bernds@redhat.com>\n+\n+\t* regrename.c (struct du_chain): New field \"earlyclobber\".\n+\t(enum scan_actions): Remove unused entry \"note_reference\".\n+\t(enum scan_actions_name): Likewise.\n+\t(note_sets, clear_dead_regs, merge_overlapping_regs): New static\n+\tfunctions.\n+\t(regrename_optimize): Use them to compute unavailable regs; get\n+\trid of the more simpleminded code we used to have here.\n+\tUse a tick array to ensure registers are allocated in a more\n+\tround-robin way.  Disable code that only optimizes registers\n+\tthat were seen more than once.\n+\t(referenced_regs): Remove variable.\n+\t(scan_rtx_reg): New arg \"earlyclobber\".  All callers changed.\n+\tStore its value in newly generated du_chain structures.\n+\tAdd new du_chains at the end, not the start, of the list.\n+\tDon't handle the \"note_reference\" action.\n+\t(scan_rtx): New arg \"earlyclobber\".  All callers changed.\n+\t(build_def_use): Lose code to keep track of referenced regs.\n+\n 2000-12-22  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Makefile.in (sched-deps.o, sched-rgn.o): Fix dependency typo."}, {"sha": "bca986d24a40fafeada6136c2a702017397357f6", "filename": "gcc/regrename.c", "status": "modified", "additions": 164, "deletions": 75, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe08a886b290a32453dd5ff084a2af073dd26968/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe08a886b290a32453dd5ff084a2af073dd26968/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=fe08a886b290a32453dd5ff084a2af073dd26968", "patch": "@@ -57,11 +57,11 @@ struct du_chain\n   rtx *loc;\n   enum reg_class class;\n   unsigned int need_caller_save_reg:1;\n+  unsigned int earlyclobber:1;\n };\n \n enum scan_actions\n {\n-  note_reference,\n   terminate_all_read,\n   terminate_overlapping_read,\n   terminate_write,\n@@ -72,7 +72,6 @@ enum scan_actions\n \n static const char * const scan_actions_name[] =\n {\n-  \"note_reference\",\n   \"terminate_all_read\",\n   \"terminate_overlapping_read\",\n   \"terminate_write\",\n@@ -85,49 +84,138 @@ static struct obstack rename_obstack;\n \n static void do_replace PARAMS ((struct du_chain *, int));\n static void scan_rtx_reg PARAMS ((rtx, rtx *, enum reg_class,\n-\t\t\t\t  enum scan_actions, enum op_type));\n+\t\t\t\t  enum scan_actions, enum op_type, int));\n static void scan_rtx_address PARAMS ((rtx, rtx *, enum reg_class,\n \t\t\t\t      enum scan_actions, enum machine_mode));\n static void scan_rtx PARAMS ((rtx, rtx *, enum reg_class,\n-\t\t\t      enum scan_actions, enum op_type));\n-static struct du_chain *build_def_use PARAMS ((basic_block, HARD_REG_SET *));\n+\t\t\t      enum scan_actions, enum op_type, int));\n+static struct du_chain *build_def_use PARAMS ((basic_block));\n static void dump_def_use_chain PARAMS ((struct du_chain *));\n+static void note_sets PARAMS ((rtx, rtx, void *));\n+static void clear_dead_regs PARAMS ((HARD_REG_SET *, enum machine_mode, rtx));\n+static void merge_overlapping_regs PARAMS ((basic_block, HARD_REG_SET *,\n+\t\t\t\t\t    struct du_chain *));\n+\n+/* Called through note_stores from update_life.  Find sets of registers, and\n+   record them in *DATA (which is actually a HARD_REG_SET *).  */\n+\n+static void\n+note_sets (x, set, data)\n+     rtx x;\n+     rtx set ATTRIBUTE_UNUSED;\n+     void *data;\n+{\n+  HARD_REG_SET *pset = (HARD_REG_SET *) data;\n+  unsigned int regno;\n+  int nregs;\n+  if (GET_CODE (x) != REG)\n+    return;\n+  regno = REGNO (x);\n+  nregs = HARD_REGNO_NREGS (regno, GET_MODE (x));\n+  while (nregs-- > 0)\n+    SET_HARD_REG_BIT (*pset, regno + nregs);\n+}\n+\n+/* Clear all registers from *PSET for which a note of kind KIND can be found\n+   in the list NOTES.  */\n+\n+static void\n+clear_dead_regs (pset, kind, notes)\n+     HARD_REG_SET *pset;\n+     enum machine_mode kind;\n+     rtx notes;\n+{\n+  rtx note;\n+  for (note = notes; note; note = XEXP (note, 1))\n+    if (REG_NOTE_KIND (note) == kind && REG_P (XEXP (note, 0)))\n+      {\n+\trtx reg = XEXP (note, 0);\n+\tunsigned int regno = REGNO (reg);\n+\tint nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+\twhile (nregs-- > 0)\n+\t  CLEAR_HARD_REG_BIT (*pset, regno + nregs);\n+      }\n+}\n+\n+/* For a def-use chain CHAIN in basic block B, find which registers overlap\n+   its lifetime and set the corresponding bits in *PSET.  */\n+\n+static void\n+merge_overlapping_regs (b, pset, chain)\n+     basic_block b;\n+     HARD_REG_SET *pset;\n+     struct du_chain *chain;\n+{\n+  struct du_chain *t = chain;\n+  rtx insn;\n+  HARD_REG_SET live;\n+\n+  REG_SET_TO_HARD_REG_SET (live, b->global_live_at_start);\n+  insn = b->head;\n+  while (t)\n+    {\n+      /* Search forward until the next reference to the register to be\n+\t renamed.  */\n+      while (insn != t->insn)\n+\t{\n+\t  if (INSN_P (insn))\n+\t    {\n+\t      clear_dead_regs (&live, REG_DEAD, REG_NOTES (insn));\n+\t      note_stores (PATTERN (insn), note_sets, (void *) &live);\n+\t      /* Only record currently live regs if we are inside the\n+\t\t reg's live range.  */\n+\t      if (t != chain)\n+\t\tIOR_HARD_REG_SET (*pset, live);\n+\t      clear_dead_regs (&live, REG_UNUSED, REG_NOTES (insn));  \n+\t    }\n+\t  insn = NEXT_INSN (insn);\n+\t}\n+\n+      IOR_HARD_REG_SET (*pset, live);\n+\n+      /* For the last reference, also merge in all registers set in the\n+\t same insn.\n+\t @@@ We only have take earlyclobbered sets into account.  */\n+      if (! t->next_use)\n+\tnote_stores (PATTERN (insn), note_sets, (void *) pset);\n+\n+      t = t->next_use;\n+    }\n+}\n+\n+/* Perform register renaming on the current function.  */\n \n void\n regrename_optimize ()\n {\n+  int tick[FIRST_PSEUDO_REGISTER];\n+  int this_tick = 0;\n   int b;\n   char *first_obj;\n \n+  memset (tick, 0, sizeof tick);\n+\n   gcc_obstack_init (&rename_obstack);\n   first_obj = (char *) obstack_alloc (&rename_obstack, 0);\n \n   for (b = 0; b < n_basic_blocks; b++)\n     {\n       basic_block bb = BASIC_BLOCK (b);\n       struct du_chain *all_chains = 0;\n-      HARD_REG_SET regs_used;\n       HARD_REG_SET unavailable;\n       HARD_REG_SET regs_seen;\n \n-      CLEAR_HARD_REG_SET (regs_used);\n       CLEAR_HARD_REG_SET (unavailable);\n \n       if (rtl_dump_file)\n \tfprintf (rtl_dump_file, \"\\nBasic block %d:\\n\", b);\n \n-      all_chains = build_def_use (bb, &regs_used);\n+      all_chains = build_def_use (bb);\n \n       if (rtl_dump_file)\n \tdump_def_use_chain (all_chains);\n \n-      /* Available registers are not: used in the block, live at the start\n-\t live at the end, a register we've renamed to. */\n-      REG_SET_TO_HARD_REG_SET (unavailable, bb->global_live_at_start);\n-      REG_SET_TO_HARD_REG_SET (regs_seen, bb->global_live_at_end);\n-      IOR_HARD_REG_SET (unavailable, regs_seen);\n-      IOR_HARD_REG_SET (unavailable, regs_used);\n-\n+      CLEAR_HARD_REG_SET (unavailable);\n       /* Don't clobber traceback for noreturn functions.  */\n       if (frame_pointer_needed)\n \t{\n@@ -140,6 +228,7 @@ regrename_optimize ()\n       CLEAR_HARD_REG_SET (regs_seen);\n       while (all_chains)\n \t{\n+\t  int new_reg, best_new_reg = -1;\n \t  int n_uses;\n \t  struct du_chain *this = all_chains;\n \t  struct du_chain *tmp, *last;\n@@ -149,13 +238,15 @@ regrename_optimize ()\n \t  int i;\n \n \t  all_chains = this->next_chain;\n-\n+\t  \n+#if 0 /* This just disables optimization opportunities.  */\n \t  /* Only rename once we've seen the reg more than once.  */\n \t  if (! TEST_HARD_REG_BIT (regs_seen, reg))\n \t    {\n \t      SET_HARD_REG_BIT (regs_seen, reg);\n \t      continue;\n \t    }\n+#endif\n \n \t  if (fixed_regs[reg] || global_regs[reg])\n \t    continue;\n@@ -178,21 +269,25 @@ regrename_optimize ()\n \t  IOR_COMPL_HARD_REG_SET (this_unavailable,\n \t\t\t\t  reg_class_contents[last->class]);\n \n-\t  if (last->need_caller_save_reg)\n+\t  if (this->need_caller_save_reg)\n \t    IOR_HARD_REG_SET (this_unavailable, call_used_reg_set);\n \n+\t  merge_overlapping_regs (bb, &this_unavailable, this);\n+\n \t  /* Now potential_regs is a reasonable approximation, let's\n \t     have a closer look at each register still in there.  */\n \t  for (treg = 0; treg < FIRST_PSEUDO_REGISTER; treg++)\n \t    {\n+\t      new_reg = treg;\n \t      for (i = nregs - 1; i >= 0; --i)\n-\t        if (TEST_HARD_REG_BIT (this_unavailable, treg+i)\n-\t\t    || fixed_regs[treg+i]\n-\t\t    || global_regs[treg+i]\n+\t        if (TEST_HARD_REG_BIT (this_unavailable, new_reg + i)\n+\t\t    || fixed_regs[new_reg + i]\n+\t\t    || global_regs[new_reg + i]\n \t\t    /* Can't use regs which aren't saved by the prologue.  */\n-\t\t    || (! regs_ever_live[treg+i] && ! call_used_regs[treg+i])\n+\t\t    || (! regs_ever_live[new_reg + i]\n+\t\t\t&& ! call_used_regs[new_reg + i])\n #ifdef HARD_REGNO_RENAME_OK\n-\t\t    || ! HARD_REGNO_RENAME_OK (reg+i, treg+i)\n+\t\t    || ! HARD_REGNO_RENAME_OK (reg + i, new_reg + i)\n #endif\n \t\t    )\n \t\t  break;\n@@ -202,10 +297,14 @@ regrename_optimize ()\n \t      /* See whether it accepts all modes that occur in\n \t\t definition and uses.  */\n \t      for (tmp = this; tmp; tmp = tmp->next_use)\n-\t\tif (! HARD_REGNO_MODE_OK (treg, GET_MODE (*tmp->loc)))\n+\t\tif (! HARD_REGNO_MODE_OK (new_reg, GET_MODE (*tmp->loc)))\n \t\t  break;\n \t      if (! tmp)\n-\t\tbreak;\n+\t\t{\n+\t\t  if (best_new_reg == -1\n+\t\t      || tick[best_new_reg] > tick[new_reg])\n+\t\t    best_new_reg = new_reg;\n+\t\t}\n \t    }\n \n \t  if (rtl_dump_file)\n@@ -216,20 +315,18 @@ regrename_optimize ()\n \t\tfprintf (rtl_dump_file, \" crosses a call\");\n \t      }\n \n-\t  if (treg == FIRST_PSEUDO_REGISTER)\n+\t  if (best_new_reg == -1)\n \t    {\n \t      if (rtl_dump_file)\n \t\tfprintf (rtl_dump_file, \"; no available registers\\n\");\n \t      continue;\n \t    }\n \n-\t  \n-\t  for (i = nregs - 1; i >= 0; --i)\n-\t    SET_HARD_REG_BIT (unavailable, treg+i);\n-\t  do_replace (this, treg);\n+\t  do_replace (this, best_new_reg);\n+\t  tick[best_new_reg] = this_tick++;\n \n \t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \", renamed as %s\\n\", reg_names[treg]);\n+\t    fprintf (rtl_dump_file, \", renamed as %s\\n\", reg_names[best_new_reg]);\n \t}\n \n       obstack_free (&rename_obstack, first_obj);\n@@ -258,31 +355,24 @@ do_replace (chain, reg)\n }\n \n \n-static HARD_REG_SET *referenced_regs;\n static struct du_chain *open_chains;\n static struct du_chain *closed_chains;\n \n static void\n-scan_rtx_reg (insn, loc, class, action, type)\n+scan_rtx_reg (insn, loc, class, action, type, earlyclobber)\n      rtx insn;\n      rtx *loc;\n      enum reg_class class;\n      enum scan_actions action;\n      enum op_type type;\n+     int earlyclobber;\n {\n   struct du_chain **p;\n   rtx x = *loc;\n   enum machine_mode mode = GET_MODE (x);\n   int this_regno = REGNO (x);\n   int this_nregs = HARD_REGNO_NREGS (this_regno, mode);\n \n-  if (action == note_reference)\n-    {\n-      while (this_nregs-- > 0)\n-\tSET_HARD_REG_BIT (*referenced_regs, this_regno + this_nregs);\n-      return;\n-    }\n-\n   if (action == mark_write)\n     {\n       if (type == OP_OUT)\n@@ -295,6 +385,7 @@ scan_rtx_reg (insn, loc, class, action, type)\n \t  this->insn = insn;\n \t  this->class = class;\n \t  this->need_caller_save_reg = 0;\n+\t  this->earlyclobber = earlyclobber;\n \t  open_chains = this;\n \t}\n       return;\n@@ -343,12 +434,14 @@ scan_rtx_reg (insn, loc, class, action, type)\n \t\t{\n \t\t  this = (struct du_chain *)\n \t\t    obstack_alloc (&rename_obstack, sizeof (struct du_chain));\n-\t\t  this->next_use = *p;\n+\t\t  this->next_use = 0;\n \t\t  this->next_chain = (*p)->next_chain;\n \t\t  this->loc = loc;\n \t\t  this->insn = insn;\n \t\t  this->class = class;\n \t\t  this->need_caller_save_reg = 0;\n+\t\t  while (*p)\n+\t\t    p = &(*p)->next_use;\n \t\t  *p = this;\n \t\t  return;\n \t\t}\n@@ -510,7 +603,7 @@ scan_rtx_address (insn, loc, class, action, mode)\n       return;\n \n     case REG:\n-      scan_rtx_reg (insn, loc, class, action, OP_IN);\n+      scan_rtx_reg (insn, loc, class, action, OP_IN, 0);\n       return;\n \n     default:\n@@ -529,12 +622,13 @@ scan_rtx_address (insn, loc, class, action, mode)\n }\n \n static void\n-scan_rtx (insn, loc, class, action, type)\n+scan_rtx (insn, loc, class, action, type, earlyclobber)\n      rtx insn;\n      rtx *loc;\n      enum reg_class class;\n      enum scan_actions action;\n      enum op_type type;\n+     int earlyclobber;\n {\n   const char *fmt;\n   rtx x = *loc;\n@@ -554,7 +648,7 @@ scan_rtx (insn, loc, class, action, type)\n       return;\n \n     case REG:\n-      scan_rtx_reg (insn, loc, class, action, type);\n+      scan_rtx_reg (insn, loc, class, action, type, earlyclobber);\n       return;\n \n     case MEM:\n@@ -563,20 +657,20 @@ scan_rtx (insn, loc, class, action, type)\n       return;\n \n     case SET:\n-      scan_rtx (insn, &SET_SRC (x), class, action, OP_IN);\n-      scan_rtx (insn, &SET_DEST (x), class, action, OP_OUT);\n+      scan_rtx (insn, &SET_SRC (x), class, action, OP_IN, 0);\n+      scan_rtx (insn, &SET_DEST (x), class, action, OP_OUT, 0);\n       return;\n \n     case STRICT_LOW_PART:\n-      scan_rtx (insn, &XEXP (x, 0), class, action, OP_INOUT);\n+      scan_rtx (insn, &XEXP (x, 0), class, action, OP_INOUT, earlyclobber);\n       return;\n \n     case ZERO_EXTRACT:\n     case SIGN_EXTRACT: \n       scan_rtx (insn, &XEXP (x, 0), class, action,\n-\t\ttype == OP_IN ? OP_IN : OP_INOUT);\n-      scan_rtx (insn, &XEXP (x, 1), class, action, OP_IN);\n-      scan_rtx (insn, &XEXP (x, 2), class, action, OP_IN);\n+\t\ttype == OP_IN ? OP_IN : OP_INOUT, earlyclobber);\n+      scan_rtx (insn, &XEXP (x, 1), class, action, OP_IN, 0);\n+      scan_rtx (insn, &XEXP (x, 2), class, action, OP_IN, 0);\n       return;\n \n     case POST_INC:\n@@ -589,13 +683,13 @@ scan_rtx (insn, loc, class, action, type)\n       abort ();\n \n     case CLOBBER:\n-      scan_rtx (insn, &SET_DEST (x), class, action, OP_OUT);\n+      scan_rtx (insn, &SET_DEST (x), class, action, OP_OUT, 1);\n       return;\n \n     case EXPR_LIST:\n-      scan_rtx (insn, &XEXP (x, 0), class, action, type);\n+      scan_rtx (insn, &XEXP (x, 0), class, action, type, 0);\n       if (XEXP (x, 1))\n-\tscan_rtx (insn, &XEXP (x, 1), class, action, type);\n+\tscan_rtx (insn, &XEXP (x, 1), class, action, type, 0);\n       return;\n \n     default:\n@@ -606,24 +700,22 @@ scan_rtx (insn, loc, class, action, type)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tscan_rtx (insn, &XEXP (x, i), class, action, type);\n+\tscan_rtx (insn, &XEXP (x, i), class, action, type, 0);\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  scan_rtx (insn, &XVECEXP (x, i, j), class, action, type);\n+\t  scan_rtx (insn, &XVECEXP (x, i, j), class, action, type, 0);\n     }\n }\n \n /* Build def/use chain */\n \n static struct du_chain *\n-build_def_use (bb, regs_used)\n+build_def_use (bb)\n      basic_block bb;\n-     HARD_REG_SET *regs_used;\n {\n   rtx insn;\n \n   open_chains = closed_chains = NULL;\n-  referenced_regs = regs_used;\n \n   for (insn = bb->head; ; insn = NEXT_INSN (insn))\n     {\n@@ -637,9 +729,6 @@ build_def_use (bb, regs_used)\n \t  int alt;\n \t  int predicated;\n \n-\t  /* Record all mentioned registers in regs_used.  */\n-\t  scan_rtx (insn, &PATTERN (insn), NO_REGS, note_reference, OP_IN);\n-\n \t  /* Process the insn, determining its effect on the def-use\n \t     chains.  We perform the following steps with the register\n \t     references in the insn:\n@@ -681,7 +770,7 @@ build_def_use (bb, regs_used)\n \t  for (i = 0; i < n_ops; i++)\n \t    scan_rtx (insn, recog_data.operand_loc[i],\n \t\t      NO_REGS, terminate_overlapping_read,\n-\t\t      recog_data.operand_type[i]);\n+\t\t      recog_data.operand_type[i], 0);\n \n \t  /* Step 2: Close chains for which we have reads outside operands.\n \t     We do this by munging all operands into CC0, and closing \n@@ -703,7 +792,8 @@ build_def_use (bb, regs_used)\n \t      *recog_data.dup_loc[i] = cc0_rtx;\n \t    }\n \n-\t  scan_rtx (insn, &PATTERN (insn), NO_REGS, terminate_all_read, OP_IN);\n+\t  scan_rtx (insn, &PATTERN (insn), NO_REGS, terminate_all_read,\n+\t\t    OP_IN, 0);\n \n \t  for (i = 0; i < recog_data.n_dups; i++)\n \t    *recog_data.dup_loc[i] = old_dups[i];\n@@ -713,7 +803,7 @@ build_def_use (bb, regs_used)\n \t  /* Step 2B: Can't rename function call argument registers.  */\n \t  if (GET_CODE (insn) == CALL_INSN && CALL_INSN_FUNCTION_USAGE (insn))\n \t    scan_rtx (insn, &CALL_INSN_FUNCTION_USAGE (insn),\n-\t\t      NO_REGS, terminate_all_read, OP_IN);\n+\t\t      NO_REGS, terminate_all_read, OP_IN, 0);\n \n \t  /* Step 3: Append to chains for reads inside operands.  */\n \t  for (i = 0; i < n_ops + recog_data.n_dups; i++)\n@@ -734,17 +824,19 @@ build_def_use (bb, regs_used)\n \t      if (recog_op_alt[opn][alt].is_address)\n \t\tscan_rtx_address (insn, loc, class, mark_read, VOIDmode);\n \t      else\n-\t\tscan_rtx (insn, loc, class, mark_read, type);\n+\t\tscan_rtx (insn, loc, class, mark_read, type, 0);\n \t    }\n \n \t  /* Step 4: Close chains for registers that die here.\n \t     Also record updates for REG_INC notes.  */\n \t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t    {\n \t      if (REG_NOTE_KIND (note) == REG_DEAD)\n-\t\tscan_rtx (insn, &XEXP (note, 0), NO_REGS, terminate_dead, OP_IN);\n+\t\tscan_rtx (insn, &XEXP (note, 0), NO_REGS, terminate_dead,\n+\t\t\t  OP_IN, 0);\n \t      else if (REG_NOTE_KIND (note) == REG_INC)\n-\t\tscan_rtx (insn, &XEXP (note, 0), ALL_REGS, mark_read, OP_INOUT);\n+\t\tscan_rtx (insn, &XEXP (note, 0), ALL_REGS, mark_read,\n+\t\t\t  OP_INOUT, 0);\n \t    }\n \n \t  /* Step 4B: If this is a call, any chain live at this point\n@@ -753,12 +845,7 @@ build_def_use (bb, regs_used)\n \t    {\n \t      struct du_chain *p;\n \t      for (p = open_chains; p; p = p->next_chain)\n-\t\t{\n-\t\t  struct du_chain *p2;\n-\t\t  for (p2 = p; p2->next_use; p2 = p2->next_use)\n-\t\t    /* nothing */;\n-\t\t  p2->need_caller_save_reg = 1;\n-\t\t}\n+\t\tp->need_caller_save_reg = 1;\n \t    }\n \n \t  /* Step 5: Close open chains that overlap writes.  Similar to\n@@ -779,7 +866,7 @@ build_def_use (bb, regs_used)\n \t\t*recog_data.dup_loc[i] = cc0_rtx;\n \t    }\n \n-\t  scan_rtx (insn, &PATTERN (insn), NO_REGS, terminate_write, OP_IN);\n+\t  scan_rtx (insn, &PATTERN (insn), NO_REGS, terminate_write, OP_IN, 0);\n \n \t  for (i = 0; i < recog_data.n_dups; i++)\n \t    *recog_data.dup_loc[i] = old_dups[i];\n@@ -800,14 +887,16 @@ build_def_use (bb, regs_used)\n \t\tenum reg_class class = recog_op_alt[opn][alt].class;\n \n \t\tif (recog_data.operand_type[opn] == OP_OUT)\n-\t\t  scan_rtx (insn, loc, class, mark_write, OP_OUT);\n+\t\t  scan_rtx (insn, loc, class, mark_write, OP_OUT,\n+\t\t\t    recog_op_alt[opn][alt].earlyclobber);\n \t      }\n \n \t  /* Step 7: Close chains for registers that were never\n \t     really used here.  */\n \t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t    if (REG_NOTE_KIND (note) == REG_UNUSED)\n-\t      scan_rtx (insn, &XEXP (note, 0), NO_REGS, terminate_dead, OP_IN);\n+\t      scan_rtx (insn, &XEXP (note, 0), NO_REGS, terminate_dead,\n+\t\t\tOP_IN, 0);\n \t}\n       if (insn == bb->end)\n \tbreak;"}]}