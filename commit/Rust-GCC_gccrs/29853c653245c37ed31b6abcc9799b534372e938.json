{"sha": "29853c653245c37ed31b6abcc9799b534372e938", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk4NTNjNjUzMjQ1YzM3ZWQzMWI2YWJjYzk3OTliNTM0MzcyZTkzOA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-01-19T21:20:00Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-01-19T21:20:00Z"}, "message": "c++: Always check access during late-parsing of members [PR58993]\n\nThis patch removes a vestigial use of dk_no_check from\ncp_parser_late_parsing_for_member, which ideally should have been\nremoved as part of the PR41437 patch that improved access checking\ninside templates.  This allows us to correctly reject f1 and f2 in\nthe testcase access34.C below (whereas before we'd only reject f3).\n\nAdditional testing revealed a new access issue when late-parsing a hidden\nfriend within a class template.  In the testcase friend68.C below, we're\ntripping over the checking assert from friend_accessible_p(f, S::j, S, S)\nduring lookup of j in x.j (for which type_dependent_object_expression_p\nreturns false, which is why we're doing the lookup at parse time).  The\nreason for the assert failure is that DECL_FRIENDLIST(S) contains f but\nDECL_BEFRIENDING_CLASSES(f) is empty, and so friend_accessible_p (which\nlooks at DECL_BEFRIENDING_CLASSES) wants to return false, but is_friend\n(which looks at DECL_FRIENDLIST) returns true.\n\nFor sake of symmetry one would expect that DECL_BEFRIENDING_CLASSES(f)\ncontains S, but add_friend avoids updating DECL_BEFRIENDING_CLASSES when\nthe class type (S in this case) is dependent, for some reason.\n\nThis patch works around this issue by making friend_accessible_p\nconsider the DECL_FRIEND_CONTEXT of the access scope.  Thus we sidestep\nthe DECL_BEFRIENDING_CLASSES / DECL_FRIENDLIST asymmetry issue while\ncorrectly validating the x.j access at parse time.\n\nA earlier version of this patch checked friend_accessible_p instead of\nprotected_accessible_p in the DECL_FRIEND_CONTEXT hunk below, but this\nhad the side effect of making us accept the ill-formed testcase friend69.C\nbelow (ill-formed because the hidden friend g is not actually a member\nof A, so g doesn't have access to B's members despite B befriending A).\n\ngcc/cp/ChangeLog:\n\n\tPR c++/41437\n\tPR c++/58993\n\t* search.c (friend_accessible_p): If scope is a hidden friend\n\tdefined inside a dependent class, consider access from the\n\tclass.\n\t* parser.c (cp_parser_late_parsing_for_member): Don't push a\n\tdk_no_check access state.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/41437\n\tPR c++/58993\n\t* g++.dg/opt/pr87974.C: Adjust.\n\t* g++.dg/template/access34.C: New test.\n\t* g++.dg/template/friend68.C: New test.\n\t* g++.dg/template/friend69.C: New test.", "tree": {"sha": "f4de3310bfd24eb1c1bd06f2c6cee0f02c2ead35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4de3310bfd24eb1c1bd06f2c6cee0f02c2ead35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29853c653245c37ed31b6abcc9799b534372e938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29853c653245c37ed31b6abcc9799b534372e938", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29853c653245c37ed31b6abcc9799b534372e938", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29853c653245c37ed31b6abcc9799b534372e938/comments", "author": null, "committer": null, "parents": [{"sha": "c37f1d4081f5a19e39192d13e2a3acea13662e5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c37f1d4081f5a19e39192d13e2a3acea13662e5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c37f1d4081f5a19e39192d13e2a3acea13662e5a"}], "stats": {"total": 76, "additions": 69, "deletions": 7}, "files": [{"sha": "eeffc2e7ae3aa528fd3ef016dbc441a60de552b0", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29853c653245c37ed31b6abcc9799b534372e938/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29853c653245c37ed31b6abcc9799b534372e938/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=29853c653245c37ed31b6abcc9799b534372e938", "patch": "@@ -30823,10 +30823,6 @@ cp_parser_late_parsing_for_member (cp_parser* parser, tree member_function)\n       start_preparsed_function (member_function, NULL_TREE,\n \t\t\t\tSF_PRE_PARSED | SF_INCLASS_INLINE);\n \n-      /* Don't do access checking if it is a templated function.  */\n-      if (processing_template_decl)\n-\tpush_deferring_access_checks (dk_no_check);\n-\n       /* #pragma omp declare reduction needs special parsing.  */\n       if (DECL_OMP_DECLARE_REDUCTION_P (member_function))\n \t{\n@@ -30840,9 +30836,6 @@ cp_parser_late_parsing_for_member (cp_parser* parser, tree member_function)\n \tcp_parser_function_definition_after_declarator (parser,\n \t\t\t\t\t\t\t/*inline_p=*/true);\n \n-      if (processing_template_decl)\n-\tpop_deferring_access_checks ();\n-\n       /* Leave the scope of the containing function.  */\n       if (function_scope)\n \tpop_function_context ();"}, {"sha": "dd3773da4f79ee44557368c97d324ea4d28c9474", "filename": "gcc/cp/search.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29853c653245c37ed31b6abcc9799b534372e938/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29853c653245c37ed31b6abcc9799b534372e938/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=29853c653245c37ed31b6abcc9799b534372e938", "patch": "@@ -698,6 +698,14 @@ friend_accessible_p (tree scope, tree decl, tree type, tree otype)\n       if (DECL_CLASS_SCOPE_P (scope)\n \t  && friend_accessible_p (DECL_CONTEXT (scope), decl, type, otype))\n \treturn 1;\n+      /* Perhaps SCOPE is a friend function defined inside a class from which\n+\t DECL is accessible.  Checking this is necessary only when the class\n+\t is dependent, for otherwise add_friend will already have added the\n+\t class to SCOPE's DECL_BEFRIENDING_CLASSES.  */\n+      if (tree fctx = DECL_FRIEND_CONTEXT (scope))\n+\tif (dependent_type_p (fctx)\n+\t    && protected_accessible_p (decl, fctx, type, otype))\n+\t  return 1;\n     }\n \n   /* Maybe scope's template is a friend.  */"}, {"sha": "7d8357a025c7d8426f55bc349678b6339f735c4d", "filename": "gcc/testsuite/g++.dg/opt/pr87974.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29853c653245c37ed31b6abcc9799b534372e938/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr87974.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29853c653245c37ed31b6abcc9799b534372e938/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr87974.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr87974.C?ref=29853c653245c37ed31b6abcc9799b534372e938", "patch": "@@ -8,6 +8,7 @@ class i {\n     struct j {\n \tusing c = int *;\n     };\n+public:\n     using as = j::c;\n };\n template <typename> class k {"}, {"sha": "ec79f87e624858406a0719d159748f96d4085190", "filename": "gcc/testsuite/g++.dg/template/access34.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29853c653245c37ed31b6abcc9799b534372e938/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess34.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29853c653245c37ed31b6abcc9799b534372e938/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess34.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess34.C?ref=29853c653245c37ed31b6abcc9799b534372e938", "patch": "@@ -0,0 +1,29 @@\n+// PR c++/58993\n+// { dg-do compile }\n+\n+class base { void foo(); };\n+\n+template <class T>\n+struct bar : public base {\n+  void f1() {\n+    &base::foo;  // { dg-error \"private\" }\n+  }\n+\n+  template <class>\n+  void f2() {\n+    &base::foo;  // { dg-error \"private\" }\n+  }\n+\n+  void f3();\n+};\n+\n+template <class T>\n+void bar<T>::f3() {\n+  (void) &base::foo; // { dg-error \"private\" }\n+}\n+\n+int main() {\n+  bar<int>().f1();\n+  bar<int>().f2<int>();\n+  bar<int>().f3();\n+}"}, {"sha": "fa34d2c30d5475856a301c4c978e4abdd27b9c93", "filename": "gcc/testsuite/g++.dg/template/friend68.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29853c653245c37ed31b6abcc9799b534372e938/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend68.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29853c653245c37ed31b6abcc9799b534372e938/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend68.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend68.C?ref=29853c653245c37ed31b6abcc9799b534372e938", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile }\n+\n+template <class>\n+struct S {\n+  S();\n+  friend int f(S x) { return x.i + x.j; }\n+  template <class T>\n+    friend int g(S x, T) { return x.i + x.j; }\n+private:\n+  int i;\n+protected:\n+  int j;\n+};"}, {"sha": "f3086a9f980ae0030b0b32bba62c0baa5a7c5cbd", "filename": "gcc/testsuite/g++.dg/template/friend69.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29853c653245c37ed31b6abcc9799b534372e938/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend69.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29853c653245c37ed31b6abcc9799b534372e938/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend69.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend69.C?ref=29853c653245c37ed31b6abcc9799b534372e938", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile }\n+\n+struct A;\n+\n+struct B {\n+  friend struct A;\n+private:\n+  static void f();\n+protected:\n+  static void g();\n+};\n+\n+struct A {\n+  friend void g(A) {\n+    B::f(); // { dg-error \"private\" }\n+    B::g(); // { dg-error \"protected\" }\n+  }\n+};"}]}