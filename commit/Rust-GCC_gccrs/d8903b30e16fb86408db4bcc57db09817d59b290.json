{"sha": "d8903b30e16fb86408db4bcc57db09817d59b290", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg5MDNiMzBlMTZmYjg2NDA4ZGI0YmNjNTdkYjA5ODE3ZDU5YjI5MA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2004-07-09T15:12:48Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2004-07-09T15:12:48Z"}, "message": "tree-dfa.c (dump_variable): If the variable is a pointer SSA_NAME, also dump its points-to information.\n\n\n\t* tree-dfa.c (dump_variable): If the variable is a pointer\n\tSSA_NAME, also dump its points-to information.\n\t* tree-flow.h (struct ptr_info_def): Add field\n\tis_dereferenced.\n\t(dump_points_to_info_for): Declare.\n\t(debug_points_to_info_for): Declare.\n\t* tree-optimize.c (init_tree_optimization_passes): Add a\n\tsecond alias analysis pass after DOM2.\n\tMove pass_del_pta to a later spot.\n\t* tree-ssa-alias.c (compute_points_to_and_addr_escape): Do not\n\tcreate a name tags when we find a dereferenced pointer.  Just\n\tmark the pointer dereferenced.\n\t(collect_points_to_info_for): Move code to clear points-to\n\tinformation to create_name_tags.\n\t(create_name_tags): New function.\n\t(compute_flow_sensitive_aliasing): Call it.\n\t(setup_pointers_and_addressables): Mark type tags for renaming\n\there instead of ...\n\t(create_memory_tag): ... here.\n\t(merge_pointed_to_info): Do not merge PT_MALLOC attributes.\n\t(dump_points_to_info_for): Declare extern.\n\t(debug_points_to_info_for): New function.\n\nFrom-SVN: r84377", "tree": {"sha": "62b1be41a808600bc5c1a49208824c954c076c8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62b1be41a808600bc5c1a49208824c954c076c8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8903b30e16fb86408db4bcc57db09817d59b290", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8903b30e16fb86408db4bcc57db09817d59b290", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8903b30e16fb86408db4bcc57db09817d59b290", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8903b30e16fb86408db4bcc57db09817d59b290/comments", "author": null, "committer": null, "parents": [{"sha": "61ebeccf5d0aa7194753cad97082cbc3cbc49242", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ebeccf5d0aa7194753cad97082cbc3cbc49242", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61ebeccf5d0aa7194753cad97082cbc3cbc49242"}], "stats": {"total": 275, "additions": 213, "deletions": 62}, "files": [{"sha": "db3debc258945d8636f1d530221bb79fc63a6bc1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8903b30e16fb86408db4bcc57db09817d59b290/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8903b30e16fb86408db4bcc57db09817d59b290/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8903b30e16fb86408db4bcc57db09817d59b290", "patch": "@@ -1,3 +1,28 @@\n+2004-07-09  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-dfa.c (dump_variable): If the variable is a pointer\n+\tSSA_NAME, also dump its points-to information.\n+\t* tree-flow.h (struct ptr_info_def): Add field\n+\tis_dereferenced.\n+\t(dump_points_to_info_for): Declare.\n+\t(debug_points_to_info_for): Declare.\n+\t* tree-optimize.c (init_tree_optimization_passes): Add a\n+\tsecond alias analysis pass after DOM2.\n+\tMove pass_del_pta to a later spot.\n+\t* tree-ssa-alias.c (compute_points_to_and_addr_escape): Do not\n+\tcreate a name tags when we find a dereferenced pointer.  Just\n+\tmark the pointer dereferenced.\n+\t(collect_points_to_info_for): Move code to clear points-to\n+\tinformation to create_name_tags.\n+\t(create_name_tags): New function.\n+\t(compute_flow_sensitive_aliasing): Call it.\n+\t(setup_pointers_and_addressables): Mark type tags for renaming\n+\there instead of ...\n+\t(create_memory_tag): ... here.\n+\t(merge_pointed_to_info): Do not merge PT_MALLOC attributes.\n+\t(dump_points_to_info_for): Declare extern.\n+\t(debug_points_to_info_for): New function.\n+\n 2004-07-09  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* config/arc/arc.md: Switch to DFA-based scheduler description."}, {"sha": "7eab7c6687efc39fb285a250c1e71ba160c9f86a", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8903b30e16fb86408db4bcc57db09817d59b290/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8903b30e16fb86408db4bcc57db09817d59b290/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=d8903b30e16fb86408db4bcc57db09817d59b290", "patch": "@@ -534,6 +534,13 @@ void\n dump_variable (FILE *file, tree var)\n {\n   var_ann_t ann;\n+  \n+  if (TREE_CODE (var) == SSA_NAME)\n+    {\n+      if (POINTER_TYPE_P (TREE_TYPE (var)))\n+\tdump_points_to_info_for (file, var);\n+      var = SSA_NAME_VAR (var);\n+    }\n \n   if (var == NULL_TREE)\n     {\n@@ -542,9 +549,6 @@ dump_variable (FILE *file, tree var)\n     }\n \n   print_generic_expr (file, var, dump_flags);\n-  \n-  if (TREE_CODE (var) == SSA_NAME)\n-    var = SSA_NAME_VAR (var);\n \n   ann = var_ann (var);\n "}, {"sha": "cc2cb16830d14db832e4f9b5be8cb0642de8fa37", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8903b30e16fb86408db4bcc57db09817d59b290/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8903b30e16fb86408db4bcc57db09817d59b290/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=d8903b30e16fb86408db4bcc57db09817d59b290", "patch": "@@ -59,6 +59,9 @@ struct ptr_info_def GTY(())\n   /* Nonzero if the value of this pointer escapes the current function.  */\n   unsigned int value_escapes_p : 1;\n \n+  /* Nonzero if this pointer is dereferenced.  */\n+  unsigned int is_dereferenced : 1;\n+\n   /* Set of variables that this pointer may point to.  */\n   bitmap pt_vars;\n \n@@ -550,6 +553,8 @@ extern void dump_alias_info (FILE *);\n extern void debug_alias_info (void);\n extern void dump_points_to_info (FILE *);\n extern void debug_points_to_info (void);\n+extern void dump_points_to_info_for (FILE *, tree);\n+extern void debug_points_to_info_for (tree);\n \n /* Call-back function for walk_use_def_chains().  At each reaching\n    definition, a function with this prototype is called.  */"}, {"sha": "aa65ab93c223a1961ed32b4cb1e7e0575755fa7c", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8903b30e16fb86408db4bcc57db09817d59b290/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8903b30e16fb86408db4bcc57db09817d59b290/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=d8903b30e16fb86408db4bcc57db09817d59b290", "patch": "@@ -294,7 +294,6 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_may_alias);\n   NEXT_PASS (pass_tail_recursion);\n   NEXT_PASS (pass_ch);\n-  NEXT_PASS (pass_del_pta);\n   NEXT_PASS (pass_profile);\n   NEXT_PASS (pass_lower_complex);\n   NEXT_PASS (pass_sra);\n@@ -303,6 +302,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (DUP_PASS (pass_redundant_phi));\n   NEXT_PASS (DUP_PASS (pass_dce));\n   NEXT_PASS (pass_dse);\n+  NEXT_PASS (DUP_PASS (pass_may_alias));\n   NEXT_PASS (DUP_PASS (pass_forwprop));\n   NEXT_PASS (DUP_PASS (pass_phiopt));\n   NEXT_PASS (pass_ccp);\n@@ -320,6 +320,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_tail_calls);\n   NEXT_PASS (pass_late_warn_uninitialized);\n   NEXT_PASS (pass_warn_function_return);\n+  NEXT_PASS (pass_del_pta);\n   NEXT_PASS (pass_del_ssa);\n   NEXT_PASS (pass_nrv);\n   NEXT_PASS (pass_remove_useless_vars);"}, {"sha": "cc0a00a559b568e66ac39e560a86bdbfd6a7e254", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 174, "deletions": 58, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8903b30e16fb86408db4bcc57db09817d59b290/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8903b30e16fb86408db4bcc57db09817d59b290/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=d8903b30e16fb86408db4bcc57db09817d59b290", "patch": "@@ -432,21 +432,9 @@ collect_points_to_info_for (struct alias_info *ai, tree ptr)\n \n   if (!bitmap_bit_p (ai->ssa_names_visited, SSA_NAME_VERSION (ptr)))\n     {\n-      struct ptr_info_def *pi;\n-\n       bitmap_set_bit (ai->ssa_names_visited, SSA_NAME_VERSION (ptr));\n       walk_use_def_chains (ptr, collect_points_to_info_r, ai);\n-\n       VARRAY_PUSH_TREE (ai->processed_ptrs, ptr);\n-\n-      /* If we could not determine where PTR was pointing to, clear all the\n-\t other points-to information.  */\n-      pi = SSA_NAME_PTR_INFO (ptr);\n-      if (pi->pt_anything)\n-\t{\n-\t  pi->pt_malloc = 0;\n-\t  pi->pt_vars = NULL;\n-\t}\n     }\n }\n \n@@ -609,15 +597,12 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t      if (ptr_is_dereferenced_by (op, stmt, &is_store))\n \t\t{\n \t\t  /* If we found OP to point to a set of variables or\n-\t\t     malloc, then create a name memory tag for it.  This\n-\t\t     gives more precise aliasing information, which helps\n-\t\t     the optimizers.\n-\n-\t\t     FIXME: Cycles in the SSA web and the lack of SSA \n-\t\t     information for structures will prevent the creation\n-\t\t     of name tags.  Find ways around this limitation.  */\n+\t\t     malloc, then mark it as being dereferenced.  In a\n+\t\t     subsequent pass, dereferenced pointers that point\n+\t\t     to a set of variables will be assigned a name tag\n+\t\t     to alias all the variables OP points to.  */\n \t\t  if (pi->pt_malloc || pi->pt_vars)\n-\t\t    pi->name_mem_tag = get_nmt_for (op);\n+\t\t    pi->is_dereferenced = 1;\n \n \t\t  /* Keep track of how many time we've dereferenced each\n \t\t     pointer.  Again, we don't need to grow\n@@ -695,6 +680,92 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n }\n \n \n+/* Create name tags for all the pointers that have been dereferenced.\n+   We only create a name tag for a pointer P if P is found to point to\n+   a set of variables (so that we can alias them to *P) or if it is\n+   the result of a call to malloc (which means that P cannot point to\n+   anything else nor alias any other variable).\n+\n+   If two pointers P and Q point to the same set of variables, they\n+   are assigned the same name tag.  */\n+\n+static void\n+create_name_tags (struct alias_info *ai)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (ai->processed_ptrs); i++)\n+    {\n+      tree ptr = VARRAY_TREE (ai->processed_ptrs, i);\n+      struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n+\n+      /* If we could not determine where PTR was pointing to, clear\n+\t all the other points-to flags.  */\n+      pi = SSA_NAME_PTR_INFO (ptr);\n+      if (pi->pt_anything)\n+\t{\n+\t  pi->pt_malloc = 0;\n+\t  pi->pt_vars = NULL;\n+\t  pi->is_dereferenced = 0;\n+\t}\n+\n+      if (!pi->is_dereferenced)\n+\tcontinue;\n+\n+      if (pi->pt_vars)\n+\t{\n+\t  size_t j;\n+\n+\t  /* If PTR points to a set of variables, check if we don't\n+\t     have another pointer Q with the same points-to set before\n+\t     creating a tag.  If so, use Q's tag instead of creating a\n+\t     new one.\n+\n+\t     This is important for not creating unnecessary symbols\n+\t     and also for copy propagation.  If we ever need to\n+\t     propagate PTR into Q or vice-versa, we would run into\n+\t     problems if they both had different name tags because\n+\t     they would have different SSA version numbers (which\n+\t     would force us to take the name tags in and out of SSA).  */\n+\t  pi->name_mem_tag = NULL_TREE;\n+\t  for (j = 0; j < i; j++)\n+\t    {\n+\t      tree q = VARRAY_TREE (ai->processed_ptrs, j);\n+\t      struct ptr_info_def *qi = SSA_NAME_PTR_INFO (q);\n+\n+\t      if (qi\n+\t\t  && qi->pt_vars\n+\t\t  && qi->name_mem_tag\n+\t\t  && bitmap_equal_p (pi->pt_vars, qi->pt_vars))\n+\t\t{\n+\t\t  pi->name_mem_tag = qi->name_mem_tag;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  if (pi->name_mem_tag == NULL_TREE)\n+\t    pi->name_mem_tag = get_nmt_for (ptr);\n+\t}\n+      else if (pi->pt_malloc)\n+\t{\n+\t  /* Otherwise, create a unique name tag for this pointer.  */\n+\t  pi->name_mem_tag = get_nmt_for (ptr);\n+\t}\n+      else\n+\t{\n+\t  /* Only pointers that may point to malloc or other variables\n+\t     may receive a name tag.  If the pointer does not point to\n+\t     a known spot, we should use type tags.  */\n+\t  abort ();\n+\t}\n+\n+      /* Mark the new name tag for renaming.  */\n+      bitmap_set_bit (vars_to_rename, var_ann (pi->name_mem_tag)->uid);\n+    }\n+}\n+\n+\n+\n /* For every pointer P_i in AI->PROCESSED_PTRS, create may-alias sets for\n    the name memory tag (NMT) associated with P_i.  If P_i escapes, then its\n    name tag and the variables it points-to are call-clobbered.  Finally, if\n@@ -708,6 +779,8 @@ compute_flow_sensitive_aliasing (struct alias_info *ai)\n {\n   size_t i;\n \n+  create_name_tags (ai);\n+\n   for (i = 0; i < VARRAY_ACTIVE_SIZE (ai->processed_ptrs); i++)\n     {\n       size_t j;\n@@ -1173,10 +1246,10 @@ setup_pointers_and_addressables (struct alias_info *ai)\n       tree var = referenced_var (i);\n       var_ann_t v_ann = var_ann (var);\n \n-      /* Name memory tags already have flow-sensitive aliasing information, so\n-\t they need not be processed by compute_may_aliases.  Similarly,\n-\t type memory tags are already accounted for when we process their\n-\t associated pointer.  */\n+      /* Name memory tags already have flow-sensitive aliasing\n+\t information, so they need not be processed by\n+\t compute_may_aliases.  Similarly, type memory tags are already\n+\t accounted for when we process their associated pointer.  */\n       if (v_ann->mem_tag_kind != NOT_A_TAG)\n \tcontinue;\n \n@@ -1192,8 +1265,9 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t      && v_ann->mem_tag_kind == NOT_A_TAG\n \t      && !needs_to_live_in_memory (var))\n \t    {\n-\t      /* The address of VAR is not needed, remove the addressable bit,\n-\t         so that it can be optimized as a regular variable.  */\n+\t      /* The address of VAR is not needed, remove the\n+\t\t addressable bit, so that it can be optimized as a\n+\t\t regular variable.  */\n \t      mark_non_addressable (var);\n \n \t      /* Since VAR is now a regular GIMPLE register, we will need\n@@ -1227,12 +1301,18 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t  tree tag = v_ann->type_mem_tag;\n \t  var_ann_t t_ann;\n \n-\t  /* If pointer VAR still doesn't have a memory tag associated with it,\n-\t     create it now or re-use an existing one.  */\n+\t  /* If pointer VAR still doesn't have a memory tag associated\n+\t     with it, create it now or re-use an existing one.  */\n \t  if (tag == NULL_TREE)\n \t    tag = get_tmt_for (var, ai);\n \t  t_ann = var_ann (tag);\n \n+\t  /* The type tag will need to be renamed into SSA afterwards.\n+\t     Note that we cannot do this inside get_tmt_for because\n+\t     aliasing may run multiple times and we only create type\n+\t     tags the first time.  */\n+\t  bitmap_set_bit (vars_to_rename, t_ann->uid);\n+\n \t  /* Associate the tag with pointer VAR.  */\n \t  v_ann->type_mem_tag = tag;\n \n@@ -1548,7 +1628,32 @@ merge_pointed_to_info (struct alias_info *ai, tree dest, tree orig)\n   if (orig_pi)\n     {\n       dest_pi->pt_anything |= orig_pi->pt_anything;\n-      dest_pi->pt_malloc |= orig_pi->pt_malloc;\n+\n+      /* Notice that we never merge PT_MALLOC.  This attribute is only\n+\t true if the pointer is the result of a malloc() call.\n+\t Otherwise, we can end up in this situation:\n+\n+\t P_i = malloc ();\n+\t ...\n+\t P_j = P_i + X;\n+\n+\t P_j would be marked as PT_MALLOC, which is wrong because\n+\t PT_MALLOC implies that the pointer may not point to another\n+\t variable.\n+\n+\t FIXME 1: Subsequent analysis may determine that P_j\n+\t cannot alias anything else, but we are being conservative\n+\t here.\n+\n+\t FIXME 2: If the merging comes from a copy assignment, we\n+\t ought to merge PT_MALLOC, but then both pointers would end up\n+\t getting different name tags because create_name_tags is not\n+\t smart enough to determine that the two come from the same\n+\t malloc call.  Copy propagation before aliasing should cure\n+\t this.  */\n+      dest_pi->pt_malloc = 0;\n+      if (orig_pi->pt_malloc)\n+\tdest_pi->pt_anything = 1;\n \n       if (orig_pi->pt_vars)\n \t{\n@@ -1559,9 +1664,9 @@ merge_pointed_to_info (struct alias_info *ai, tree dest, tree orig)\n \t    }\n \t  else\n \t    bitmap_a_or_b (dest_pi->pt_vars,\n-\t\t\t   dest_pi->pt_vars,\n-\t\t\t   orig_pi->pt_vars);\n-      }\n+\t\t           dest_pi->pt_vars,\n+\t\t           orig_pi->pt_vars);\n+\t}\n     }\n }\n \n@@ -1821,9 +1926,8 @@ create_memory_tag (tree type, bool is_type_tag)\n   ann->mem_tag_kind = (is_type_tag) ? TYPE_TAG : NAME_TAG;\n   ann->type_mem_tag = NULL_TREE;\n \n-  /* Add the tag to the symbol table and mark it for renaming.  */\n+  /* Add the tag to the symbol table.  */\n   add_referenced_tmp_var (tag);\n-  bitmap_set_bit (vars_to_rename, ann->uid);\n \n   return tag;\n }\n@@ -2030,49 +2134,61 @@ get_ptr_info (tree t)\n \n /* Dump points-to information for SSA_NAME PTR into FILE.  */\n \n-static void\n+void\n dump_points_to_info_for (FILE *file, tree ptr)\n {\n   struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n \n   fprintf (file, \"Pointer \");\n   print_generic_expr (file, ptr, dump_flags);\n \n-  if (pi == NULL)\n-    return;\n-\n-  if (pi->name_mem_tag)\n+  if (pi)\n     {\n-      fprintf (file, \", name memory tag: \");\n-      print_generic_expr (file, pi->name_mem_tag, dump_flags);\n-    }\n+      if (pi->name_mem_tag)\n+\t{\n+\t  fprintf (file, \", name memory tag: \");\n+\t  print_generic_expr (file, pi->name_mem_tag, dump_flags);\n+\t}\n \n-  if (pi->value_escapes_p)\n-    fprintf (file, \", its value escapes\");\n+      if (pi->is_dereferenced)\n+\tfprintf (file, \", is dereferenced\");\n \n-  if (pi->pt_anything)\n-    fprintf (file, \", points-to anything\");\n+      if (pi->value_escapes_p)\n+\tfprintf (file, \", its value escapes\");\n \n-  if (pi->pt_malloc)\n-    fprintf (file, \", points-to malloc\");\n+      if (pi->pt_anything)\n+\tfprintf (file, \", points-to anything\");\n \n-  if (pi->pt_vars)\n-    {\n-      unsigned ix;\n+      if (pi->pt_malloc)\n+\tfprintf (file, \", points-to malloc\");\n \n-      fprintf (file, \", points-to vars: { \");\n-      EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, ix,\n-\t  {\n-\t    print_generic_expr (file, referenced_var (ix), dump_flags);\n-\t    fprintf (file, \" \");\n-\t  });\n-      fprintf (file, \"}\");\n+      if (pi->pt_vars)\n+\t{\n+\t  unsigned ix;\n+\n+\t  fprintf (file, \", points-to vars: { \");\n+\t  EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, ix,\n+\t      {\n+\t\tprint_generic_expr (file, referenced_var (ix), dump_flags);\n+\t\tfprintf (file, \" \");\n+\t      });\n+\t  fprintf (file, \"}\");\n+\t}\n     }\n \n   fprintf (file, \"\\n\");\n }\n \n \n+/* Dump points-to information for VAR into stderr.  */\n+\n+void\n+debug_points_to_info_for (tree var)\n+{\n+  dump_points_to_info_for (stderr, var);\n+}\n+\n+\n /* Dump points-to information into FILE.  NOTE: This function is slow, as\n    it needs to traverse the whole CFG looking for pointer SSA_NAMEs.  */\n "}]}