{"sha": "0bba3f6fb7f833ee2193c05d7f6d3fe781d332e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJiYTNmNmZiN2Y4MzNlZTIxOTNjMDVkN2Y2ZDNmZTc4MWQzMzJlOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-17T11:37:25Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-17T11:37:25Z"}, "message": "(expand_expr, case COMPONENT_REF): Don't actually do extraction from\nmemory if we want address.\n\n(emit_block_move): Fix problems in last change.\n\nFrom-SVN: r1873", "tree": {"sha": "c98db57eb4b5b2f83fce7d35e0e137f7a76c9bd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c98db57eb4b5b2f83fce7d35e0e137f7a76c9bd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bba3f6fb7f833ee2193c05d7f6d3fe781d332e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bba3f6fb7f833ee2193c05d7f6d3fe781d332e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bba3f6fb7f833ee2193c05d7f6d3fe781d332e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bba3f6fb7f833ee2193c05d7f6d3fe781d332e9/comments", "author": null, "committer": null, "parents": [{"sha": "a73f9fc940405d5f82345a726a5e8a6e071dc418", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a73f9fc940405d5f82345a726a5e8a6e071dc418", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a73f9fc940405d5f82345a726a5e8a6e071dc418"}], "stats": {"total": 21, "additions": 14, "deletions": 7}, "files": [{"sha": "80018ee479445f899abd070d468115b30a99538f", "filename": "gcc/expr.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bba3f6fb7f833ee2193c05d7f6d3fe781d332e9/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bba3f6fb7f833ee2193c05d7f6d3fe781d332e9/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0bba3f6fb7f833ee2193c05d7f6d3fe781d332e9", "patch": "@@ -1175,26 +1175,31 @@ emit_block_move (x, y, size, align)\n \t including more than one in the machine description unless\n \t the more limited one has some advantage.  */\n \n+      rtx opalign = GEN_INT (align);\n       enum machine_mode mode;\n \n       for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n \t   mode = GET_MODE_WIDER_MODE (mode))\n \t{\n \t  enum insn_code code = movstr_optab[(int) mode];\n-\t  rtx opalign = GEN_INT (align);\n \n \t  if (code != CODE_FOR_nothing\n-\t      && GET_MODE_BITSIZE (mode) < HOST_BITS_PER_WIDE_INT\n+\t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t      && (unsigned) INTVAL (size) <= GET_MODE_MASK (mode)\n-\t      && (*insn_operand_predicate[(int) code][0]) (x, Pmode)\n-\t      && (*insn_operand_predicate[(int) code][1]) (y, Pmode)\n-\t      && (*insn_operand_predicate[(int) code][3]) (opalign, VOIDmode))\n+\t      && (insn_operand_predicate[(int) code][0] == 0\n+\t\t  || (*insn_operand_predicate[(int) code][0]) (x, BLKmode))\n+\t      && (insn_operand_predicate[(int) code][1] == 0\n+\t\t  || (*insn_operand_predicate[(int) code][1]) (y, BLKmode))\n+\t      && (insn_operand_predicate[(int) code][3] == 0\n+\t\t  || (*insn_operand_predicate[(int) code][3]) (opalign,\n+\t\t\t\t\t\t\t       VOIDmode)))\n \t    {\n \t      rtx op2 = size;\n \t      rtx last = get_last_insn ();\n \t      rtx pat;\n \n-\t      if (! (*insn_operand_predicate[(int) code][2]) (op2, mode))\n+\t      if (insn_operand_predicate[(int) code][2] != 0\n+\t\t  && ! (*insn_operand_predicate[(int) code][2]) (op2, mode))\n \t\top2 = copy_to_mode_reg (mode, op2);\n \n \t      pat = GEN_FCN ((int) code) (x, y, op2, opalign);\n@@ -3662,7 +3667,9 @@ expand_expr (exp, target, tmode, modifier)\n \t  }\n \n \tif (mode1 == VOIDmode\n-\t    || (mode1 != BLKmode && ! direct_load[(int) mode1])\n+\t    || (mode1 != BLKmode && ! direct_load[(int) mode1]\n+\t\t&& modifier != EXPAND_CONST_ADDRESS\n+\t\t&& modifier != EXPAND_SUM && modifier != EXPAND_INITIALIZER)\n \t    || GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n \t  {\n \t    /* In cases where an aligned union has an unaligned object"}]}