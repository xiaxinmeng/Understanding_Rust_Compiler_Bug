{"sha": "18522563e0d346db259fc6404b54c95e4155ae48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg1MjI1NjNlMGQzNDZkYjI1OWZjNjQwNGI1NGM5NWU0MTU1YWU0OA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2004-11-15T00:18:37Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-11-15T00:18:37Z"}, "message": "re PR tree-optimization/18431 (Code for arrays and pointers are not the same)\n\n\tPR tree-optimization/18431\n\t* fold-const.c (associate_trees): Do not produce x + 0.\n\t(fold_widened_comparison, fold_sign_changed_comparison): New functions.\n\t(fold): Use them.\n\t* tree-ssa-loop-niter.c (upper_bound_in_type, lower_bound_in_type):\n\tMoved ...\n\t* tree.c (upper_bound_in_type, lower_bound_in_type): Here.\n\t* tree.h (upper_bound_in_type, lower_bound_in_type): Declare.\n\n\t* testsuite/gcc.c-torture/execute/20041114-1.c: New test.\n\nFrom-SVN: r90646", "tree": {"sha": "8a20893a5c5c0b8de8fe5ddf927281ae604e7f1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a20893a5c5c0b8de8fe5ddf927281ae604e7f1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18522563e0d346db259fc6404b54c95e4155ae48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18522563e0d346db259fc6404b54c95e4155ae48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18522563e0d346db259fc6404b54c95e4155ae48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18522563e0d346db259fc6404b54c95e4155ae48/comments", "author": null, "committer": null, "parents": [{"sha": "4d6079e03d5291b4a7e1aae7fd836661c2331fed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6079e03d5291b4a7e1aae7fd836661c2331fed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d6079e03d5291b4a7e1aae7fd836661c2331fed"}], "stats": {"total": 355, "additions": 267, "deletions": 88}, "files": [{"sha": "c26b57c832d615e0f531f10fe2561bc883cc87e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18522563e0d346db259fc6404b54c95e4155ae48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18522563e0d346db259fc6404b54c95e4155ae48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18522563e0d346db259fc6404b54c95e4155ae48", "patch": "@@ -1,3 +1,14 @@\n+2004-11-14  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/18431\n+\t* fold-const.c (associate_trees): Do not produce x + 0.\n+\t(fold_widened_comparison, fold_sign_changed_comparison): New functions.\n+\t(fold): Use them.\n+\t* tree-ssa-loop-niter.c (upper_bound_in_type, lower_bound_in_type):\n+\tMoved ...\n+\t* tree.c (upper_bound_in_type, lower_bound_in_type): Here.\n+\t* tree.h (upper_bound_in_type, lower_bound_in_type): Declare.\n+\n 2004-11-14  Eric Botcazou <ebotcazou@libertysurf.fr>\n \n \t* doc/rtl.texi (SUBREG): Adjust BYTENUM value."}, {"sha": "0d2e407692678c2d27c5afe78618347ff209cfa4", "filename": "gcc/fold-const.c", "status": "modified", "additions": 143, "deletions": 15, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18522563e0d346db259fc6404b54c95e4155ae48/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18522563e0d346db259fc6404b54c95e4155ae48/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=18522563e0d346db259fc6404b54c95e4155ae48", "patch": "@@ -1267,7 +1267,15 @@ associate_trees (tree t1, tree t2, enum tree_code code, tree type)\n \t  else if (TREE_CODE (t2) == NEGATE_EXPR)\n \t    return build2 (MINUS_EXPR, type, fold_convert (type, t1),\n \t\t\t   fold_convert (type, TREE_OPERAND (t2, 0)));\n+\t  else if (integer_zerop (t2))\n+\t    return fold_convert (type, t1);\n \t}\n+      else if (code == MINUS_EXPR)\n+\t{\n+\t  if (integer_zerop (t2))\n+\t    return fold_convert (type, t1);\n+\t}\n+\n       return build2 (code, type, fold_convert (type, t1),\n \t\t     fold_convert (type, t2));\n     }\n@@ -5972,6 +5980,127 @@ tree_swap_operands_p (tree arg0, tree arg1, bool reorder)\n   return 0;\n }\n \n+/* Fold comparison ARG0 CODE ARG1 (with result in TYPE), where\n+   ARG0 is extended to a wider type.  */\n+\n+static tree\n+fold_widened_comparison (enum tree_code code, tree type, tree arg0, tree arg1)\n+{\n+  tree arg0_unw = get_unwidened (arg0, NULL_TREE);\n+  tree arg1_unw;\n+  tree shorter_type, outer_type;\n+  tree min, max;\n+  bool above, below;\n+\n+  if (arg0_unw == arg0)\n+    return NULL_TREE;\n+  shorter_type = TREE_TYPE (arg0_unw);\n+  \n+  arg1_unw = get_unwidened (arg1, shorter_type);\n+  if (!arg1_unw)\n+    return NULL_TREE;\n+\n+  /* If possible, express the comparison in the shorter mode.  */\n+  if ((code == EQ_EXPR || code == NE_EXPR\n+       || TYPE_UNSIGNED (TREE_TYPE (arg0)) == TYPE_UNSIGNED (shorter_type))\n+      && (TREE_TYPE (arg1_unw) == shorter_type\n+\t  || (TREE_CODE (arg1_unw) == INTEGER_CST\n+\t      && int_fits_type_p (arg1_unw, shorter_type))))\n+    return fold (build (code, type, arg0_unw,\n+\t\t\tfold_convert (shorter_type, arg1_unw)));\n+\n+  if (TREE_CODE (arg1_unw) != INTEGER_CST)\n+    return NULL_TREE;\n+\n+  /* If we are comparing with the integer that does not fit into the range\n+     of the shorter type, the result is known.  */\n+  outer_type = TREE_TYPE (arg1_unw);\n+  min = lower_bound_in_type (outer_type, shorter_type);\n+  max = upper_bound_in_type (outer_type, shorter_type);\n+\n+  above = integer_nonzerop (fold_relational_const (LT_EXPR, type,\n+\t\t\t\t\t\t   max, arg1_unw));\n+  below = integer_nonzerop (fold_relational_const (LT_EXPR, type,\n+\t\t\t\t\t\t   arg1_unw, min));\n+\n+  switch (code)\n+    {\n+    case EQ_EXPR:\n+      if (above || below)\n+\treturn constant_boolean_node (false, type);\n+      break;\n+\n+    case NE_EXPR:\n+      if (above || below)\n+\treturn constant_boolean_node (true, type);\n+      break;\n+\n+    case LT_EXPR:\n+    case LE_EXPR:\n+      if (above)\n+\treturn constant_boolean_node (true, type);\n+      else if (below)\n+\treturn constant_boolean_node (false, type);;\n+\n+    case GT_EXPR:\n+    case GE_EXPR:\n+      if (above)\n+\treturn constant_boolean_node (false, type);\n+      else if (below)\n+\treturn constant_boolean_node (true, type);;\n+\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Fold comparison ARG0 CODE ARG1 (with result in TYPE), where for\n+   ARG0 just the signedness is changed.  */\n+\n+static tree\n+fold_sign_changed_comparison (enum tree_code code, tree type,\n+\t\t\t      tree arg0, tree arg1)\n+{\n+  tree arg0_inner, tmp;\n+  tree inner_type, outer_type;\n+\n+  if (TREE_CODE (arg0) != NOP_EXPR)\n+    return NULL_TREE;\n+\n+  outer_type = TREE_TYPE (arg0);\n+  arg0_inner = TREE_OPERAND (arg0, 0);\n+  inner_type = TREE_TYPE (arg0_inner);\n+\n+  if (TYPE_PRECISION (inner_type) != TYPE_PRECISION (outer_type))\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (arg1) != INTEGER_CST\n+      && !(TREE_CODE (arg1) == NOP_EXPR\n+\t   && TREE_TYPE (TREE_OPERAND (arg1, 0)) == inner_type))\n+    return NULL_TREE;\n+\n+  if (TYPE_UNSIGNED (inner_type) != TYPE_UNSIGNED (outer_type)\n+      && code != NE_EXPR\n+      && code != EQ_EXPR)\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (arg1) == INTEGER_CST)\n+    {\n+      tmp = build_int_cst_wide (inner_type,\n+\t\t\t\tTREE_INT_CST_LOW (arg1),\n+\t\t\t\tTREE_INT_CST_HIGH (arg1));\n+      arg1 = force_fit_type (tmp, 0,\n+\t\t\t     TREE_OVERFLOW (arg1),\n+\t\t\t     TREE_CONSTANT_OVERFLOW (arg1));\n+    }\n+  else\n+    arg1 = fold_convert (inner_type, arg1);\n+\n+  return fold (build (code, type, arg0_inner, arg1));\n+}\n+\n /* Tries to replace &a[idx] CODE s * delta with &a[idx CODE delta], if s is\n    step of the array.  TYPE is the type of the expression.  ADDR is the address.\n    MULT is the multiplicative expression.  If the function succeeds, the new\n@@ -8392,22 +8521,21 @@ fold (tree expr)\n \treturn fold (build2 (code, type,\n \t\t\t     TREE_OPERAND (arg0, 0), TREE_OPERAND (arg0, 1)));\n \n-      /* If we are widening one operand of an integer comparison,\n-\t see if the other operand is similarly being widened.  Perhaps we\n-\t can do the comparison in the narrower type.  */\n       else if (TREE_CODE (TREE_TYPE (arg0)) == INTEGER_TYPE\n-\t       && TREE_CODE (arg0) == NOP_EXPR\n-\t       && (tem = get_unwidened (arg0, NULL_TREE)) != arg0\n-\t       && (code == EQ_EXPR || code == NE_EXPR\n-\t\t   || TYPE_UNSIGNED (TREE_TYPE (arg0))\n-\t\t      == TYPE_UNSIGNED (TREE_TYPE (tem)))\n-\t       && (t1 = get_unwidened (arg1, TREE_TYPE (tem))) != 0\n-\t       && (TREE_TYPE (t1) == TREE_TYPE (tem)\n-\t\t   || (TREE_CODE (t1) == INTEGER_CST\n-\t\t       && TREE_CODE (TREE_TYPE (tem)) == INTEGER_TYPE\n-\t\t       && int_fits_type_p (t1, TREE_TYPE (tem)))))\n-\treturn fold (build2 (code, type, tem,\n-\t\t\t     fold_convert (TREE_TYPE (tem), t1)));\n+\t       && TREE_CODE (arg0) == NOP_EXPR)\n+\t{\n+\t  /* If we are widening one operand of an integer comparison,\n+\t     see if the other operand is similarly being widened.  Perhaps we\n+\t     can do the comparison in the narrower type.  */\n+\t  tem = fold_widened_comparison (code, type, arg0, arg1);\n+\t  if (tem)\n+\t    return tem;\n+\n+\t  /* Or if we are changing signedness.  */\n+\t  tem = fold_sign_changed_comparison (code, type, arg0, arg1);\n+\t  if (tem)\n+\t    return tem;\n+\t}\n \n       /* If this is comparing a constant with a MIN_EXPR or a MAX_EXPR of a\n \t constant, we can simplify it.  */"}, {"sha": "3fda6f68c2fd9537e0fb0b31471a971d2c7c1839", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18522563e0d346db259fc6404b54c95e4155ae48/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18522563e0d346db259fc6404b54c95e4155ae48/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=18522563e0d346db259fc6404b54c95e4155ae48", "patch": "@@ -1,3 +1,7 @@\n+2004-11-14  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* gcc.c-torture/execute/20041114-1.c: New test.\n+\n 2004-11-14  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/c99-flex-array-5.c, gcc.dg/c99-fordecl-3.c,"}, {"sha": "4f82f8aa22950be68379e17d8c5bee0a9519621b", "filename": "gcc/testsuite/gcc.c-torture/execute/20041114-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18522563e0d346db259fc6404b54c95e4155ae48/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20041114-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18522563e0d346db259fc6404b54c95e4155ae48/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20041114-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20041114-1.c?ref=18522563e0d346db259fc6404b54c95e4155ae48", "patch": "@@ -0,0 +1,35 @@\n+/* Verify that\n+   \n+   var <= 0 || ((long unsigned) (unsigned) (var - 1) < MAX_UNSIGNED_INT)\n+\n+   gets folded to 1.  */\n+\n+#include <limits.h>\n+\n+void abort (void);\n+void link_failure (void);\n+\n+volatile int v;\n+\n+void \n+foo (int var)\n+{\n+  if (!(var <= 0\n+        || ((long unsigned) (unsigned) (var - 1) < UINT_MAX)))\n+    link_failure ();\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  foo (v);\n+  return 0;\n+}\n+\n+#ifndef __OPTIMIZE__\n+void\n+link_failure (void)\n+{\n+  abort ();\n+}\n+#endif"}, {"sha": "3d4d4c0dec4544f5f702bfc3bb334ab6867d74cc", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18522563e0d346db259fc6404b54c95e4155ae48/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18522563e0d346db259fc6404b54c95e4155ae48/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=18522563e0d346db259fc6404b54c95e4155ae48", "patch": "@@ -1103,78 +1103,6 @@ compare_trees (tree a, tree b)\n   return 2;\n }\n \n-/* Returns the largest value obtainable by casting something in INNER type to\n-   OUTER type.  */\n-\n-static tree\n-upper_bound_in_type (tree outer, tree inner)\n-{\n-  unsigned HOST_WIDE_INT lo, hi;\n-  unsigned bits = TYPE_PRECISION (inner);\n-\n-  if (TYPE_UNSIGNED (outer) || TYPE_UNSIGNED (inner))\n-    {\n-      /* Zero extending in these cases.  */\n-      if (bits <= HOST_BITS_PER_WIDE_INT)\n-\t{\n-\t  hi = 0;\n-\t  lo = (~(unsigned HOST_WIDE_INT) 0)\n-\t\t  >> (HOST_BITS_PER_WIDE_INT - bits);\n-\t}\n-      else\n-\t{\n-\t  hi = (~(unsigned HOST_WIDE_INT) 0)\n-\t\t  >> (2 * HOST_BITS_PER_WIDE_INT - bits);\n-\t  lo = ~(unsigned HOST_WIDE_INT) 0;\n-\t}\n-    }\n-  else\n-    {\n-      /* Sign extending in these cases.  */\n-      if (bits <= HOST_BITS_PER_WIDE_INT)\n-\t{\n-\t  hi = 0;\n-\t  lo = (~(unsigned HOST_WIDE_INT) 0)\n-\t\t  >> (HOST_BITS_PER_WIDE_INT - bits) >> 1;\n-\t}\n-      else\n-\t{\n-\t  hi = (~(unsigned HOST_WIDE_INT) 0)\n-\t\t  >> (2 * HOST_BITS_PER_WIDE_INT - bits) >> 1;\n-\t  lo = ~(unsigned HOST_WIDE_INT) 0;\n-\t}\n-    }\n-\n-  return fold_convert (outer,\n-\t\t       build_int_cst_wide (inner, lo, hi));\n-}\n-\n-/* Returns the smallest value obtainable by casting something in INNER type to\n-   OUTER type.  */\n-\n-static tree\n-lower_bound_in_type (tree outer, tree inner)\n-{\n-  unsigned HOST_WIDE_INT lo, hi;\n-  unsigned bits = TYPE_PRECISION (inner);\n-\n-  if (TYPE_UNSIGNED (outer) || TYPE_UNSIGNED (inner))\n-    lo = hi = 0;\n-  else if (bits <= HOST_BITS_PER_WIDE_INT)\n-    {\n-      hi = ~(unsigned HOST_WIDE_INT) 0;\n-      lo = (~(unsigned HOST_WIDE_INT) 0) << (bits - 1);\n-    }\n-  else\n-    {\n-      hi = (~(unsigned HOST_WIDE_INT) 0) << (bits - HOST_BITS_PER_WIDE_INT - 1);\n-      lo = 0;\n-    }\n-\n-  return fold_convert (outer,\n-\t\t       build_int_cst_wide (inner, lo, hi));\n-}\n-\n /* Returns true if statement S1 dominates statement S2.  */\n \n static bool"}, {"sha": "654ce785857f7797d6cdd8bad38c6d7a5f4e7851", "filename": "gcc/tree.c", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18522563e0d346db259fc6404b54c95e4155ae48/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18522563e0d346db259fc6404b54c95e4155ae48/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=18522563e0d346db259fc6404b54c95e4155ae48", "patch": "@@ -6074,4 +6074,76 @@ get_case_label (tree t)\n   return CASE_LEADER_OR_LABEL (t);\n }\n \n+/* Returns the largest value obtainable by casting something in INNER type to\n+   OUTER type.  */\n+\n+tree\n+upper_bound_in_type (tree outer, tree inner)\n+{\n+  unsigned HOST_WIDE_INT lo, hi;\n+  unsigned bits = TYPE_PRECISION (inner);\n+\n+  if (TYPE_UNSIGNED (outer) || TYPE_UNSIGNED (inner))\n+    {\n+      /* Zero extending in these cases.  */\n+      if (bits <= HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  hi = 0;\n+\t  lo = (~(unsigned HOST_WIDE_INT) 0)\n+\t\t  >> (HOST_BITS_PER_WIDE_INT - bits);\n+\t}\n+      else\n+\t{\n+\t  hi = (~(unsigned HOST_WIDE_INT) 0)\n+\t\t  >> (2 * HOST_BITS_PER_WIDE_INT - bits);\n+\t  lo = ~(unsigned HOST_WIDE_INT) 0;\n+\t}\n+    }\n+  else\n+    {\n+      /* Sign extending in these cases.  */\n+      if (bits <= HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  hi = 0;\n+\t  lo = (~(unsigned HOST_WIDE_INT) 0)\n+\t\t  >> (HOST_BITS_PER_WIDE_INT - bits) >> 1;\n+\t}\n+      else\n+\t{\n+\t  hi = (~(unsigned HOST_WIDE_INT) 0)\n+\t\t  >> (2 * HOST_BITS_PER_WIDE_INT - bits) >> 1;\n+\t  lo = ~(unsigned HOST_WIDE_INT) 0;\n+\t}\n+    }\n+\n+  return fold_convert (outer,\n+\t\t       build_int_cst_wide (inner, lo, hi));\n+}\n+\n+/* Returns the smallest value obtainable by casting something in INNER type to\n+   OUTER type.  */\n+\n+tree\n+lower_bound_in_type (tree outer, tree inner)\n+{\n+  unsigned HOST_WIDE_INT lo, hi;\n+  unsigned bits = TYPE_PRECISION (inner);\n+\n+  if (TYPE_UNSIGNED (outer) || TYPE_UNSIGNED (inner))\n+    lo = hi = 0;\n+  else if (bits <= HOST_BITS_PER_WIDE_INT)\n+    {\n+      hi = ~(unsigned HOST_WIDE_INT) 0;\n+      lo = (~(unsigned HOST_WIDE_INT) 0) << (bits - 1);\n+    }\n+  else\n+    {\n+      hi = (~(unsigned HOST_WIDE_INT) 0) << (bits - HOST_BITS_PER_WIDE_INT - 1);\n+      lo = 0;\n+    }\n+\n+  return fold_convert (outer,\n+\t\t       build_int_cst_wide (inner, lo, hi));\n+}\n+\n #include \"gt-tree.h\""}, {"sha": "a8670d9298932ef7d2ac2327a77ffd2d0b368133", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18522563e0d346db259fc6404b54c95e4155ae48/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18522563e0d346db259fc6404b54c95e4155ae48/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=18522563e0d346db259fc6404b54c95e4155ae48", "patch": "@@ -3464,7 +3464,8 @@ extern int type_num_arguments (tree);\n extern bool associative_tree_code (enum tree_code);\n extern bool commutative_tree_code (enum tree_code);\n extern tree get_case_label (tree);\n-\n+extern tree upper_bound_in_type (tree, tree);\n+extern tree lower_bound_in_type (tree, tree);\n \f\n /* In stmt.c */\n "}]}