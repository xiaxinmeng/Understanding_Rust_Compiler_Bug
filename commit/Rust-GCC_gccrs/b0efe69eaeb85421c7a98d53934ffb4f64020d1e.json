{"sha": "b0efe69eaeb85421c7a98d53934ffb4f64020d1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBlZmU2OWVhZWI4NTQyMWM3YTk4ZDUzOTM0ZmZiNGY2NDAyMGQxZQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2006-02-15T09:39:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:39:06Z"}, "message": "exp_disp.ads, [...] (Expand_Dispatching_Call): If the controlling argument of the dispatching call is an abstract interface...\n\n2006-02-13  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_disp.ads, exp_disp.adb (Expand_Dispatching_Call): If the\n\tcontrolling argument of the dispatching call is an abstract interface\n\tclass-wide type then we use it directly.\n\tCheck No_Dispatching_Calls restriction.\n\t(Default_Prim_Op_Position): Remove the code that looks for the last\n\tentity in the list of aliased subprograms. This code was wrong in\n\tcase of renamings.\n\t(Fill_DT_Entry): Add assertion to avoid the use of this subprogram\n\twhen the source is compiled with the No_Dispatching_Calls restriction.\n\t(Init_Predefined_Interface_Primitives): No need to inherit primitives\n\tif we are compiling with restriction No_Dispatching_Calls.\n\t(Make_Disp_XXX): Addition of assertion to avoid the use of all these\n\tsubprograms if we are compiling under No_Dispatching_Calls restriction.\n\t(Make_DT): Generate a dispatch table with a single dummy entry if\n\twe are compiling with the No_Dispatching_Calls restriction. In\n\taddition, in this case we don't generate code that calls to the\n\tfollowing run-time subprograms: Set_Type_Kind, Inherit_DT.\n\t(Make_Select_Specific_Data_Table): Add assertion to avoid the use\n\tof this subprogram if compiling with the No_Dispatching_Calls\n\trestriction.\n\t(Expand_Type_Conversion): Instead of using the actual parameter,\n\tthe argument passed as parameter to the conversion function was\n\terroneously referenced by the expander.\n\t(Ada_Actions): Addition of Get_Predefined_Prim_Op_Address,\n\tSet_Predefined_Primitive_Op_Address and Set_Signature.\n\t(Expand_Dispatching_Call): Generate call to\n\tGet_Predefined_Prim_Op_Address for predefined primitives.\n\t(Fill_DT_Entry): Generate call to Set_Predefined_Prim_Op_Address for\n\tpredefined primitives.\n\t(Make_DT, Make_Secondary_DT): If the tagged type has no user defined\n\tprimitives we reserve one dummy entry to ensure that the tag does not\n\tpoint to some memory that is associated with some other object. In\n\taddition, remove all the old code that generated the assignments\n\tassociated with the signature of the dispatch table and replace them\n\tby a call to the new subprogram Set_Signature.\n\t(Set_All_DT_Position): Change the algorithm because now we have a\n\tseparate dispatch table associated with predefined primitive operations.\n\t(Expand_Interface_Conversion): In case of non-static offset_to_top\n\tadd explicit dereference to get access to the object after the call\n\tto displace the pointer to the object.\n\t(Expand_Interface_Thunk): Modify the generation of the actual used\n\tin the calls to the run-time function Offset_To_Top to fulfil its\n\tnew interface.\n\t(Make_DT): Add the new actuals required to call Set_Offset_To_Top.\n\nFrom-SVN: r111064", "tree": {"sha": "753775bd3fb216e28cdfcb6063a015d8fecbd34a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/753775bd3fb216e28cdfcb6063a015d8fecbd34a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0efe69eaeb85421c7a98d53934ffb4f64020d1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0efe69eaeb85421c7a98d53934ffb4f64020d1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0efe69eaeb85421c7a98d53934ffb4f64020d1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0efe69eaeb85421c7a98d53934ffb4f64020d1e/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e5cfd2f7706dc0748ed60d7f728fa8061204b9d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5cfd2f7706dc0748ed60d7f728fa8061204b9d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5cfd2f7706dc0748ed60d7f728fa8061204b9d7"}], "stats": {"total": 1006, "additions": 565, "deletions": 441}, "files": [{"sha": "a29714e976c6b906d52a021a6e426e0cf43c0cf7", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 561, "deletions": 431, "changes": 992, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0efe69eaeb85421c7a98d53934ffb4f64020d1e/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0efe69eaeb85421c7a98d53934ffb4f64020d1e/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=b0efe69eaeb85421c7a98d53934ffb4f64020d1e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,6 +40,8 @@ with Nmake;    use Nmake;\n with Namet;    use Namet;\n with Opt;      use Opt;\n with Output;   use Output;\n+with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Disp; use Sem_Disp;\n@@ -302,113 +304,122 @@ package body Exp_Disp is\n    package SEU renames Select_Expansion_Utilities;\n \n    Ada_Actions : constant array (DT_Access_Action) of RE_Id :=\n-      (CW_Membership           => RE_CW_Membership,\n-       IW_Membership           => RE_IW_Membership,\n-       DT_Entry_Size           => RE_DT_Entry_Size,\n-       DT_Prologue_Size        => RE_DT_Prologue_Size,\n-       Get_Access_Level        => RE_Get_Access_Level,\n-       Get_Entry_Index         => RE_Get_Entry_Index,\n-       Get_External_Tag        => RE_Get_External_Tag,\n-       Get_Prim_Op_Address     => RE_Get_Prim_Op_Address,\n-       Get_Prim_Op_Kind        => RE_Get_Prim_Op_Kind,\n-       Get_RC_Offset           => RE_Get_RC_Offset,\n-       Get_Remotely_Callable   => RE_Get_Remotely_Callable,\n-       Get_Tagged_Kind         => RE_Get_Tagged_Kind,\n-       Inherit_DT              => RE_Inherit_DT,\n-       Inherit_TSD             => RE_Inherit_TSD,\n-       Register_Interface_Tag  => RE_Register_Interface_Tag,\n-       Register_Tag            => RE_Register_Tag,\n-       Set_Access_Level        => RE_Set_Access_Level,\n-       Set_Entry_Index         => RE_Set_Entry_Index,\n-       Set_Expanded_Name       => RE_Set_Expanded_Name,\n-       Set_External_Tag        => RE_Set_External_Tag,\n-       Set_Interface_Table     => RE_Set_Interface_Table,\n-       Set_Offset_Index        => RE_Set_Offset_Index,\n-       Set_OSD                 => RE_Set_OSD,\n-       Set_Prim_Op_Address     => RE_Set_Prim_Op_Address,\n-       Set_Prim_Op_Kind        => RE_Set_Prim_Op_Kind,\n-       Set_RC_Offset           => RE_Set_RC_Offset,\n-       Set_Remotely_Callable   => RE_Set_Remotely_Callable,\n-       Set_SSD                 => RE_Set_SSD,\n-       Set_TSD                 => RE_Set_TSD,\n-       Set_Tagged_Kind         => RE_Set_Tagged_Kind,\n-       TSD_Entry_Size          => RE_TSD_Entry_Size,\n-       TSD_Prologue_Size       => RE_TSD_Prologue_Size);\n+      (CW_Membership                  => RE_CW_Membership,\n+       IW_Membership                  => RE_IW_Membership,\n+       DT_Entry_Size                  => RE_DT_Entry_Size,\n+       DT_Prologue_Size               => RE_DT_Prologue_Size,\n+       Get_Access_Level               => RE_Get_Access_Level,\n+       Get_Entry_Index                => RE_Get_Entry_Index,\n+       Get_External_Tag               => RE_Get_External_Tag,\n+       Get_Predefined_Prim_Op_Address => RE_Get_Predefined_Prim_Op_Address,\n+       Get_Prim_Op_Address            => RE_Get_Prim_Op_Address,\n+       Get_Prim_Op_Kind               => RE_Get_Prim_Op_Kind,\n+       Get_RC_Offset                  => RE_Get_RC_Offset,\n+       Get_Remotely_Callable          => RE_Get_Remotely_Callable,\n+       Get_Tagged_Kind                => RE_Get_Tagged_Kind,\n+       Inherit_DT                     => RE_Inherit_DT,\n+       Inherit_TSD                    => RE_Inherit_TSD,\n+       Register_Interface_Tag         => RE_Register_Interface_Tag,\n+       Register_Tag                   => RE_Register_Tag,\n+       Set_Access_Level               => RE_Set_Access_Level,\n+       Set_Entry_Index                => RE_Set_Entry_Index,\n+       Set_Expanded_Name              => RE_Set_Expanded_Name,\n+       Set_External_Tag               => RE_Set_External_Tag,\n+       Set_Interface_Table            => RE_Set_Interface_Table,\n+       Set_Offset_Index               => RE_Set_Offset_Index,\n+       Set_OSD                        => RE_Set_OSD,\n+       Set_Predefined_Prim_Op_Address => RE_Set_Predefined_Prim_Op_Address,\n+       Set_Prim_Op_Address            => RE_Set_Prim_Op_Address,\n+       Set_Prim_Op_Kind               => RE_Set_Prim_Op_Kind,\n+       Set_RC_Offset                  => RE_Set_RC_Offset,\n+       Set_Remotely_Callable          => RE_Set_Remotely_Callable,\n+       Set_Signature                  => RE_Set_Signature,\n+       Set_SSD                        => RE_Set_SSD,\n+       Set_TSD                        => RE_Set_TSD,\n+       Set_Tagged_Kind                => RE_Set_Tagged_Kind,\n+       TSD_Entry_Size                 => RE_TSD_Entry_Size,\n+       TSD_Prologue_Size              => RE_TSD_Prologue_Size);\n \n    Action_Is_Proc : constant array (DT_Access_Action) of Boolean :=\n-      (CW_Membership           => False,\n-       IW_Membership           => False,\n-       DT_Entry_Size           => False,\n-       DT_Prologue_Size        => False,\n-       Get_Access_Level        => False,\n-       Get_Entry_Index         => False,\n-       Get_External_Tag        => False,\n-       Get_Prim_Op_Address     => False,\n-       Get_Prim_Op_Kind        => False,\n-       Get_RC_Offset           => False,\n-       Get_Remotely_Callable   => False,\n-       Get_Tagged_Kind         => False,\n-       Inherit_DT              => True,\n-       Inherit_TSD             => True,\n-       Register_Interface_Tag  => True,\n-       Register_Tag            => True,\n-       Set_Access_Level        => True,\n-       Set_Entry_Index         => True,\n-       Set_Expanded_Name       => True,\n-       Set_External_Tag        => True,\n-       Set_Interface_Table     => True,\n-       Set_Offset_Index        => True,\n-       Set_OSD                 => True,\n-       Set_Prim_Op_Address     => True,\n-       Set_Prim_Op_Kind        => True,\n-       Set_RC_Offset           => True,\n-       Set_Remotely_Callable   => True,\n-       Set_SSD                 => True,\n-       Set_TSD                 => True,\n-       Set_Tagged_Kind         => True,\n-       TSD_Entry_Size          => False,\n-       TSD_Prologue_Size       => False);\n+      (CW_Membership                  => False,\n+       IW_Membership                  => False,\n+       DT_Entry_Size                  => False,\n+       DT_Prologue_Size               => False,\n+       Get_Access_Level               => False,\n+       Get_Entry_Index                => False,\n+       Get_External_Tag               => False,\n+       Get_Predefined_Prim_Op_Address => False,\n+       Get_Prim_Op_Address            => False,\n+       Get_Prim_Op_Kind               => False,\n+       Get_RC_Offset                  => False,\n+       Get_Remotely_Callable          => False,\n+       Get_Tagged_Kind                => False,\n+       Inherit_DT                     => True,\n+       Inherit_TSD                    => True,\n+       Register_Interface_Tag         => True,\n+       Register_Tag                   => True,\n+       Set_Access_Level               => True,\n+       Set_Entry_Index                => True,\n+       Set_Expanded_Name              => True,\n+       Set_External_Tag               => True,\n+       Set_Interface_Table            => True,\n+       Set_Offset_Index               => True,\n+       Set_OSD                        => True,\n+       Set_Predefined_Prim_Op_Address => True,\n+       Set_Prim_Op_Address            => True,\n+       Set_Prim_Op_Kind               => True,\n+       Set_RC_Offset                  => True,\n+       Set_Remotely_Callable          => True,\n+       Set_Signature                  => True,\n+       Set_SSD                        => True,\n+       Set_TSD                        => True,\n+       Set_Tagged_Kind                => True,\n+       TSD_Entry_Size                 => False,\n+       TSD_Prologue_Size              => False);\n \n    Action_Nb_Arg : constant array (DT_Access_Action) of Int :=\n-      (CW_Membership           => 2,\n-       IW_Membership           => 2,\n-       DT_Entry_Size           => 0,\n-       DT_Prologue_Size        => 0,\n-       Get_Access_Level        => 1,\n-       Get_Entry_Index         => 2,\n-       Get_External_Tag        => 1,\n-       Get_Prim_Op_Address     => 2,\n-       Get_Prim_Op_Kind        => 2,\n-       Get_RC_Offset           => 1,\n-       Get_Remotely_Callable   => 1,\n-       Get_Tagged_Kind         => 1,\n-       Inherit_DT              => 3,\n-       Inherit_TSD             => 2,\n-       Register_Interface_Tag  => 3,\n-       Register_Tag            => 1,\n-       Set_Access_Level        => 2,\n-       Set_Entry_Index         => 3,\n-       Set_Expanded_Name       => 2,\n-       Set_External_Tag        => 2,\n-       Set_Interface_Table     => 2,\n-       Set_Offset_Index        => 3,\n-       Set_OSD                 => 2,\n-       Set_Prim_Op_Address     => 3,\n-       Set_Prim_Op_Kind        => 3,\n-       Set_RC_Offset           => 2,\n-       Set_Remotely_Callable   => 2,\n-       Set_SSD                 => 2,\n-       Set_TSD                 => 2,\n-       Set_Tagged_Kind         => 2,\n-       TSD_Entry_Size          => 0,\n-       TSD_Prologue_Size       => 0);\n+      (CW_Membership                  => 2,\n+       IW_Membership                  => 2,\n+       DT_Entry_Size                  => 0,\n+       DT_Prologue_Size               => 0,\n+       Get_Access_Level               => 1,\n+       Get_Entry_Index                => 2,\n+       Get_External_Tag               => 1,\n+       Get_Predefined_Prim_Op_Address => 2,\n+       Get_Prim_Op_Address            => 2,\n+       Get_Prim_Op_Kind               => 2,\n+       Get_RC_Offset                  => 1,\n+       Get_Remotely_Callable          => 1,\n+       Get_Tagged_Kind                => 1,\n+       Inherit_DT                     => 3,\n+       Inherit_TSD                    => 2,\n+       Register_Interface_Tag         => 3,\n+       Register_Tag                   => 1,\n+       Set_Access_Level               => 2,\n+       Set_Entry_Index                => 3,\n+       Set_Expanded_Name              => 2,\n+       Set_External_Tag               => 2,\n+       Set_Interface_Table            => 2,\n+       Set_Offset_Index               => 3,\n+       Set_OSD                        => 2,\n+       Set_Predefined_Prim_Op_Address => 3,\n+       Set_Prim_Op_Address            => 3,\n+       Set_Prim_Op_Kind               => 3,\n+       Set_RC_Offset                  => 2,\n+       Set_Remotely_Callable          => 2,\n+       Set_Signature                  => 2,\n+       Set_SSD                        => 2,\n+       Set_TSD                        => 2,\n+       Set_Tagged_Kind                => 2,\n+       TSD_Entry_Size                 => 0,\n+       TSD_Prologue_Size              => 0);\n \n    procedure Collect_All_Interfaces (T : Entity_Id);\n    --  Ada 2005 (AI-251): Collect the whole list of interfaces that are\n    --  directly or indirectly implemented by T. Used to compute the size\n    --  of the table of interfaces.\n \n-   function Default_Prim_Op_Position (Subp : Entity_Id) return Uint;\n+   function Default_Prim_Op_Position (E : Entity_Id) return Uint;\n    --  Ada 2005 (AI-251): Returns the fixed position in the dispatch table\n    --  of the default primitive operations.\n \n@@ -453,7 +464,7 @@ package body Exp_Disp is\n             Next_Elmt (Elmt);\n          end loop;\n \n-         if not Present (Elmt) then\n+         if No (Elmt) then\n             Append_Elmt (Iface, Abstract_Interfaces (T));\n          end if;\n       end Add_Interface;\n@@ -520,17 +531,10 @@ package body Exp_Disp is\n    -- Default_Prim_Op_Position --\n    ------------------------------\n \n-   function Default_Prim_Op_Position (Subp : Entity_Id) return Uint is\n+   function Default_Prim_Op_Position (E : Entity_Id) return Uint is\n       TSS_Name : TSS_Name_Type;\n-      E        : Entity_Id := Subp;\n \n    begin\n-      --  Handle overriden subprograms\n-\n-      while Present (Alias (E)) loop\n-         E := Alias (E);\n-      end loop;\n-\n       Get_Name_String (Chars (E));\n       TSS_Name :=\n         TSS_Name_Type\n@@ -672,6 +676,8 @@ package body Exp_Disp is\n    --  Start of processing for Expand_Dispatching_Call\n \n    begin\n+      Check_Restriction (No_Dispatching_Calls, Call_Node);\n+\n       --  If this is an inherited operation that was overridden, the body\n       --  that is being called is its alias.\n \n@@ -702,7 +708,8 @@ package body Exp_Disp is\n       --  implementation of AI-260 (for the generic dispatching constructors).\n \n       if Etype (Ctrl_Arg) = RTE (RE_Tag)\n-        or else Etype (Ctrl_Arg) = RTE (RE_Interface_Tag)\n+        or else (RTE_Available (RE_Interface_Tag)\n+                  and then Etype (Ctrl_Arg) = RTE (RE_Interface_Tag))\n       then\n          CW_Typ := Class_Wide_Type (Controlling_Type (Subp));\n \n@@ -739,7 +746,6 @@ package body Exp_Disp is\n          --  Generate the Tag checks when appropriate\n \n          New_Params := New_List;\n-\n          Param := First_Actual (Call_Node);\n          while Present (Param) loop\n \n@@ -825,7 +831,7 @@ package body Exp_Disp is\n \n       --  Generate the appropriate subprogram pointer type\n \n-      if  Etype (Subp) = Typ then\n+      if Etype (Subp) = Typ then\n          Res_Typ := CW_Typ;\n       else\n          Res_Typ := Etype (Subp);\n@@ -909,12 +915,20 @@ package body Exp_Disp is\n       Set_Etype (Subp_Ptr_Typ, Subp_Ptr_Typ);\n       Set_Directly_Designated_Type (Subp_Ptr_Typ, Subp_Typ);\n \n-      --  If the controlling argument is a value of type Ada.Tag then\n-      --  use it directly.  Otherwise, the tag must be extracted from\n-      --  the controlling object.\n+      --  If the controlling argument is a value of type Ada.Tag or an abstract\n+      --  interface class-wide type then use it directly. Otherwise, the tag\n+      --  must be extracted from the controlling object.\n \n       if Etype (Ctrl_Arg) = RTE (RE_Tag)\n-        or else Etype (Ctrl_Arg) = RTE (RE_Interface_Tag)\n+        or else (RTE_Available (RE_Interface_Tag)\n+                  and then Etype (Ctrl_Arg) = RTE (RE_Interface_Tag))\n+      then\n+         Controlling_Tag := Duplicate_Subexpr (Ctrl_Arg);\n+\n+      --  Ada 2005 (AI-251): Abstract interface class-wide type\n+\n+      elsif Is_Interface (Etype (Ctrl_Arg))\n+         and then Is_Class_Wide_Type (Etype (Ctrl_Arg))\n       then\n          Controlling_Tag := Duplicate_Subexpr (Ctrl_Arg);\n \n@@ -928,19 +942,38 @@ package body Exp_Disp is\n       --  Generate:\n       --   Subp_Ptr_Typ!(Get_Prim_Op_Address (Ctrl._Tag, pos));\n \n-      New_Call_Name :=\n-        Unchecked_Convert_To (Subp_Ptr_Typ,\n-          Make_DT_Access_Action (Typ,\n-            Action => Get_Prim_Op_Address,\n-            Args => New_List (\n+      if Is_Predefined_Dispatching_Operation (Subp) then\n+         New_Call_Name :=\n+           Unchecked_Convert_To (Subp_Ptr_Typ,\n+             Make_DT_Access_Action (Typ,\n+               Action => Get_Predefined_Prim_Op_Address,\n+               Args => New_List (\n+\n+               --  Vptr\n \n-            --  Vptr\n+                 Unchecked_Convert_To (RTE (RE_Tag),\n+                   Controlling_Tag),\n \n-              Controlling_Tag,\n+               --  Position\n \n-            --  Position\n+                 Make_Integer_Literal (Loc, DT_Position (Subp)))));\n+\n+      else\n+         New_Call_Name :=\n+           Unchecked_Convert_To (Subp_Ptr_Typ,\n+             Make_DT_Access_Action (Typ,\n+               Action => Get_Prim_Op_Address,\n+               Args => New_List (\n \n-              Make_Integer_Literal (Loc, DT_Position (Subp)))));\n+               --  Vptr\n+\n+                 Unchecked_Convert_To (RTE (RE_Tag),\n+                   Controlling_Tag),\n+\n+               --  Position\n+\n+                 Make_Integer_Literal (Loc, DT_Position (Subp)))));\n+      end if;\n \n       if Nkind (Call_Node) = N_Function_Call then\n \n@@ -1060,6 +1093,14 @@ package body Exp_Disp is\n         and then Is_Interface (Iface_Typ));\n \n       if not Is_Static then\n+\n+         --  Give error if configurable run time and Displace not available\n+\n+         if not RTE_Available (RE_Displace) then\n+            Error_Msg_CRT (\"abstract interface types\", N);\n+            return;\n+         end if;\n+\n          Rewrite (N,\n            Make_Function_Call (Loc,\n              Name => New_Reference_To (RTE (RE_Displace), Loc),\n@@ -1086,8 +1127,10 @@ package body Exp_Disp is\n             Set_Directly_Designated_Type (New_Itype,\n               Class_Wide_Type (Iface_Typ));\n \n-            Rewrite (N, Unchecked_Convert_To (New_Itype,\n-                          Relocate_Node (N)));\n+            Rewrite (N, Make_Explicit_Dereference (Loc,\n+                          Unchecked_Convert_To (New_Itype,\n+                            Relocate_Node (N))));\n+            Analyze (N);\n          end;\n \n          return;\n@@ -1166,7 +1209,7 @@ package body Exp_Disp is\n                             Make_Attribute_Reference (Loc,\n                               Prefix =>\n                                 Make_Selected_Component (Loc,\n-                                  Prefix => Relocate_Node (Expression (N)),\n+                                  Prefix => Make_Identifier (Loc, Name_uO),\n                                   Selector_Name =>\n                                     New_Occurrence_Of (Iface_Tag, Loc)),\n                               Attribute_Name => Name_Address))))))));\n@@ -1455,6 +1498,13 @@ package body Exp_Disp is\n          Next_Formal (E);\n       end loop;\n \n+      --  Give message if configurable run-time and Offset_To_Top unavailable\n+\n+      if not RTE_Available (RE_Offset_To_Top) then\n+         Error_Msg_CRT (\"abstract interface types\", N);\n+         return Empty;\n+      end if;\n+\n       if Ekind (First_Formal (Target)) = E_In_Parameter\n         and then Ekind (Etype (First_Formal (Target)))\n                   = E_Anonymous_Access_Type\n@@ -1501,12 +1551,10 @@ package body Exp_Disp is\n                     Make_Function_Call (Loc,\n                       Name => New_Reference_To (RTE (RE_Offset_To_Top), Loc),\n                       Parameter_Associations => New_List (\n-                        Make_Selected_Component (Loc,\n-                          Prefix => New_Reference_To\n-                                      (Defining_Identifier (First (Formals)),\n-                                       Loc),\n-                          Selector_Name => Make_Identifier (Loc,\n-                                             Name_uTag))))));\n+                        Unchecked_Convert_To\n+                          (RTE (RE_Address),\n+                           New_Reference_To\n+                             (Defining_Identifier (First (Formals)), Loc))))));\n \n          Append_To (Decl, Decl_2);\n          Append_To (Decl, Decl_1);\n@@ -1546,12 +1594,11 @@ package body Exp_Disp is\n                     Make_Function_Call (Loc,\n                       Name => New_Reference_To (RTE (RE_Offset_To_Top), Loc),\n                       Parameter_Associations => New_List (\n-                        Make_Selected_Component (Loc,\n+                        Make_Attribute_Reference (Loc,\n                           Prefix => New_Reference_To\n                                       (Defining_Identifier (First (Formals)),\n                                        Loc),\n-                          Selector_Name => Make_Identifier (Loc,\n-                                             Name_uTag))))));\n+                          Attribute_Name => Name_Address)))));\n \n          Decl_2 :=\n            Make_Object_Declaration (Loc,\n@@ -1637,22 +1684,37 @@ package body Exp_Disp is\n       Tag     : constant Entity_Id := First_Tag_Component (Typ);\n \n    begin\n-      if Pos = Uint_0 or else Pos > DT_Entry_Count (Tag) then\n-         raise Program_Error;\n-      end if;\n+      pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n \n-      return\n-        Make_DT_Access_Action (Typ,\n-          Action => Set_Prim_Op_Address,\n-          Args   => New_List (\n-            Unchecked_Convert_To (RTE (RE_Tag),\n-              New_Reference_To (DT_Ptr, Loc)),                  -- DTptr\n+      if Is_Predefined_Dispatching_Operation (Prim) then\n+         return\n+           Make_DT_Access_Action (Typ,\n+             Action => Set_Predefined_Prim_Op_Address,\n+             Args   => New_List (\n+               Unchecked_Convert_To (RTE (RE_Tag),\n+                 New_Reference_To (DT_Ptr, Loc)),                  -- DTptr\n+\n+               Make_Integer_Literal (Loc, Pos),                    -- Position\n+\n+               Make_Attribute_Reference (Loc,                      -- Value\n+                 Prefix          => New_Reference_To (Prim, Loc),\n+                 Attribute_Name  => Name_Address)));\n+      else\n+         pragma Assert (Pos /= Uint_0 and then Pos <= DT_Entry_Count (Tag));\n+\n+         return\n+           Make_DT_Access_Action (Typ,\n+             Action => Set_Prim_Op_Address,\n+             Args   => New_List (\n+               Unchecked_Convert_To (RTE (RE_Tag),\n+                 New_Reference_To (DT_Ptr, Loc)),                  -- DTptr\n \n-            Make_Integer_Literal (Loc, Pos),                    -- Position\n+               Make_Integer_Literal (Loc, Pos),                    -- Position\n \n-            Make_Attribute_Reference (Loc,                      -- Value\n-              Prefix          => New_Reference_To (Prim, Loc),\n-              Attribute_Name  => Name_Address)));\n+               Make_Attribute_Reference (Loc,                      -- Value\n+                 Prefix          => New_Reference_To (Prim, Loc),\n+                 Attribute_Name  => Name_Address)));\n+      end if;\n    end Fill_DT_Entry;\n \n    -----------------------------\n@@ -1672,22 +1734,35 @@ package body Exp_Disp is\n                      First_Tag_Component (Scope (DTC_Entity (Iface_Prim)));\n \n    begin\n-      if Pos = Uint_0 or else Pos > DT_Entry_Count (Tag) then\n-         raise Program_Error;\n-      end if;\n+      if Is_Predefined_Dispatching_Operation (Prim) then\n+         return\n+           Make_DT_Access_Action (Typ,\n+             Action => Set_Predefined_Prim_Op_Address,\n+             Args   => New_List (\n+               Unchecked_Convert_To (RTE (RE_Tag),\n+                 New_Reference_To (Iface_DT_Ptr, Loc)),            -- DTptr\n \n-      return\n-        Make_DT_Access_Action (Typ,\n-          Action => Set_Prim_Op_Address,\n-          Args   => New_List (\n-            Unchecked_Convert_To (RTE (RE_Tag),\n-              New_Reference_To (Iface_DT_Ptr, Loc)),            -- DTptr\n+               Make_Integer_Literal (Loc, Pos),                    -- Position\n \n-            Make_Integer_Literal (Loc, Pos),                    -- Position\n+               Make_Attribute_Reference (Loc,                      -- Value\n+                 Prefix          => New_Reference_To (Thunk_Id, Loc),\n+                 Attribute_Name  => Name_Address)));\n+      else\n+         pragma Assert (Pos /= Uint_0 and then Pos <= DT_Entry_Count (Tag));\n \n-            Make_Attribute_Reference (Loc,                      -- Value\n-              Prefix          => New_Reference_To (Thunk_Id, Loc),\n-              Attribute_Name  => Name_Address)));\n+         return\n+           Make_DT_Access_Action (Typ,\n+             Action => Set_Prim_Op_Address,\n+             Args   => New_List (\n+               Unchecked_Convert_To (RTE (RE_Tag),\n+                 New_Reference_To (Iface_DT_Ptr, Loc)),            -- DTptr\n+\n+               Make_Integer_Literal (Loc, Pos),                    -- Position\n+\n+               Make_Attribute_Reference (Loc,                      -- Value\n+                 Prefix          => New_Reference_To (Thunk_Id, Loc),\n+                 Attribute_Name  => Name_Address)));\n+      end if;\n    end Fill_Secondary_DT_Entry;\n \n    ---------------------------\n@@ -1723,7 +1798,10 @@ package body Exp_Disp is\n       --  No need to inherit primitives if we have an abstract interface\n       --  type or a concurrent type.\n \n-      if Is_Interface (Typ) or else Is_Concurrent_Record_Type (Typ) then\n+      if Is_Interface (Typ)\n+        or else Is_Concurrent_Record_Type (Typ)\n+        or else Restriction_Active (No_Dispatching_Calls)\n+      then\n          return Result;\n       end if;\n \n@@ -1734,7 +1812,7 @@ package body Exp_Disp is\n          --  associated with predefined primitives.\n \n          --  Generate:\n-         --    Inherit_DT (T'Tag, Iface'Tag, Default_Prim_Op_Count);\n+         --    Inherit_DT (T'Tag, Iface'Tag, 0);\n \n          Append_To (Result,\n            Make_DT_Access_Action (Typ,\n@@ -1743,7 +1821,7 @@ package body Exp_Disp is\n                Node1 => New_Reference_To (DT_Ptr, Loc),\n                Node2 => Unchecked_Convert_To (RTE (RE_Tag),\n                           New_Reference_To (Node (AI), Loc)),\n-               Node3 => Make_Integer_Literal (Loc, Default_Prim_Op_Count))));\n+               Node3 => Make_Integer_Literal (Loc, Uint_0))));\n \n          Next_Elmt (AI);\n       end loop;\n@@ -1765,6 +1843,8 @@ package body Exp_Disp is\n       Stmts    : constant List_Id    := New_List;\n \n    begin\n+      pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n+\n       --  Null body is generated for interface types\n \n       if Is_Interface (Typ) then\n@@ -1911,6 +1991,8 @@ package body Exp_Disp is\n       Params : constant List_Id    := New_List;\n \n    begin\n+      pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n+\n       --  \"T\" - Object parameter\n       --  \"S\" - Primitive operation slot\n       --  \"P\" - Wrapped parameters\n@@ -1946,6 +2028,8 @@ package body Exp_Disp is\n       Stmts    : constant List_Id    := New_List;\n \n    begin\n+      pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n+\n       --  Null body is generated for interface types\n \n       if Is_Interface (Typ) then\n@@ -2152,6 +2236,8 @@ package body Exp_Disp is\n       Params : constant List_Id    := New_List;\n \n    begin\n+      pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n+\n       --  \"T\" - Object parameter\n       --  \"S\" - Primitive operation slot\n       --  \"P\" - Wrapped parameters\n@@ -2183,6 +2269,8 @@ package body Exp_Disp is\n       DT_Ptr : Entity_Id;\n \n    begin\n+      pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n+\n       if Is_Interface (Typ) then\n          return\n            Make_Subprogram_Body (Loc,\n@@ -2240,6 +2328,8 @@ package body Exp_Disp is\n       Params : constant List_Id    := New_List;\n \n    begin\n+      pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n+\n       --  \"T\" - Object parameter\n       --  \"S\" - Primitive operation slot\n       --  \"C\" - Call kind\n@@ -2267,6 +2357,8 @@ package body Exp_Disp is\n       Ret : Node_Id;\n \n    begin\n+      pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n+\n       if Is_Concurrent_Record_Type (Typ)\n         and then Ekind (Corresponding_Concurrent_Type (Typ)) = E_Task_Type\n       then\n@@ -2312,6 +2404,8 @@ package body Exp_Disp is\n                    Name_uDisp_Get_Task_Id);\n \n    begin\n+      pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n+\n       Set_Is_Internal (Def_Id);\n \n       return\n@@ -2341,6 +2435,8 @@ package body Exp_Disp is\n       Stmts    : constant List_Id    := New_List;\n \n    begin\n+      pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n+\n       --  Null body is generated for interface types\n \n       if Is_Interface (Typ) then\n@@ -2515,6 +2611,8 @@ package body Exp_Disp is\n       Params : constant List_Id    := New_List;\n \n    begin\n+      pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n+\n       --  \"T\" - Object parameter\n       --  \"S\" - Primitive operation slot\n       --  \"P\" - Wrapped parameters\n@@ -2590,6 +2688,7 @@ package body Exp_Disp is\n       TSD_Num_Entries   : Int;\n \n       Ancestor_Copy     : Entity_Id;\n+      Empty_DT          : Boolean := False;\n       Typ_Copy          : Entity_Id;\n \n    begin\n@@ -2601,11 +2700,13 @@ package body Exp_Disp is\n       --  Calculate the size of the DT and the TSD\n \n       if Is_Interface (Typ) then\n+\n          --  Abstract interfaces need neither the DT nor the ancestors table.\n          --  We reserve a single entry for its DT because at run-time the\n          --  pointer to this dummy DT will be used as the tag of this abstract\n          --  interface type.\n \n+         Empty_DT        := True;\n          Nb_Prim         := 1;\n          TSD_Num_Entries := 0;\n          Num_Ifaces      := 0;\n@@ -2669,12 +2770,14 @@ package body Exp_Disp is\n          TSD_Num_Entries := I_Depth + 1;\n          Nb_Prim := UI_To_Int (DT_Entry_Count (First_Tag_Component (Typ)));\n \n-         --  If the number of primitives of Typ is less that the number of\n-         --  predefined primitives, we must reserve at least enough space\n-         --  for the predefined primitives.\n+         --  If the number of primitives of Typ is 0 (or we are compiling with\n+         --  the No_Dispatching_Calls restriction) we reserve a dummy single\n+         --  entry for its DT because at run-time the pointer to this dummy DT\n+         --  will be used as the tag of this tagged type.\n \n-         if Nb_Prim < Default_Prim_Op_Count then\n-            Nb_Prim := Default_Prim_Op_Count;\n+         if Nb_Prim = 0 or else Restriction_Active (No_Dispatching_Calls) then\n+            Empty_DT := True;\n+            Nb_Prim  := 1;\n          end if;\n       end if;\n \n@@ -2746,52 +2849,6 @@ package body Exp_Disp is\n               Prefix => New_Reference_To (RTE (RE_Integer_Address), Loc),\n               Attribute_Name => Name_Alignment)));\n \n-      --  Initialize the signature of the interface tag. It is a sequence\n-      --  two bytes located in the header of the dispatch table.\n-\n-      Append_To (Result,\n-        Make_Assignment_Statement (Loc,\n-          Name =>\n-            Make_Indexed_Component (Loc,\n-              Prefix => New_Occurrence_Of (DT, Loc),\n-              Expressions => New_List (\n-                Make_Integer_Literal (Loc, Uint_1))),\n-          Expression =>\n-            Unchecked_Convert_To (RTE (RE_Storage_Element),\n-              New_Reference_To (RTE (RE_Valid_Signature), Loc))));\n-\n-      if not Is_Interface (Typ) then\n-\n-         --  The signature of a Primary Dispatch table is:\n-         --    (Valid_Signature, Primary_DT)\n-\n-         Append_To (Result,\n-           Make_Assignment_Statement (Loc,\n-             Name =>\n-               Make_Indexed_Component (Loc,\n-                 Prefix => New_Occurrence_Of (DT, Loc),\n-                 Expressions => New_List (\n-                   Make_Integer_Literal (Loc, Uint_2))),\n-             Expression =>\n-               Unchecked_Convert_To (RTE (RE_Storage_Element),\n-                 New_Reference_To (RTE (RE_Primary_DT), Loc))));\n-\n-      else\n-         --  The signature of an abstract interface is:\n-         --    (Valid_Signature, Abstract_Interface)\n-\n-         Append_To (Result,\n-           Make_Assignment_Statement (Loc,\n-             Name =>\n-               Make_Indexed_Component (Loc,\n-                 Prefix => New_Occurrence_Of (DT, Loc),\n-                 Expressions => New_List (\n-                   Make_Integer_Literal (Loc, Uint_2))),\n-             Expression =>\n-               Unchecked_Convert_To (RTE (RE_Storage_Element),\n-                 New_Reference_To (RTE (RE_Abstract_Interface), Loc))));\n-      end if;\n-\n       --  Generate code to create the pointer to the dispatch table\n \n       --    DT_Ptr : Tag := Tag!(DT'Address);\n@@ -2829,7 +2886,7 @@ package body Exp_Disp is\n \n       --  Set Access_Disp_Table field to be the dispatch table pointer\n \n-      if not Present (Access_Disp_Table (Typ)) then\n+      if No (Access_Disp_Table (Typ)) then\n          Set_Access_Disp_Table (Typ, New_Elmt_List);\n       end if;\n \n@@ -2876,6 +2933,26 @@ package body Exp_Disp is\n               Prefix => New_Reference_To (RTE (RE_Integer_Address), Loc),\n               Attribute_Name => Name_Alignment)));\n \n+      --  Generate:\n+      --    Set_Signature (DT_Ptr, Value);\n+\n+      if Is_Interface (Typ) then\n+         Append_To (Elab_Code,\n+           Make_DT_Access_Action (Typ,\n+             Action => Set_Signature,\n+             Args   => New_List (\n+               New_Reference_To (DT_Ptr, Loc),                  -- DTptr\n+               New_Reference_To (RTE (RE_Abstract_Interface), Loc))));\n+\n+      elsif RTE_Available (RE_Set_Signature) then\n+         Append_To (Elab_Code,\n+           Make_DT_Access_Action (Typ,\n+             Action => Set_Signature,\n+             Args   => New_List (\n+               New_Reference_To (DT_Ptr, Loc),                  -- DTptr\n+               New_Reference_To (RTE (RE_Primary_DT), Loc))));\n+      end if;\n+\n       --  Generate code to put the Address of the TSD in the dispatch table\n       --    Set_TSD (DT_Ptr, TSD);\n \n@@ -2895,17 +2972,19 @@ package body Exp_Disp is\n          null;\n \n       elsif Num_Ifaces = 0 then\n-         Append_To (Elab_Code,\n-           Make_DT_Access_Action (Typ,\n-             Action => Set_Interface_Table,\n-             Args   => New_List (\n-               New_Reference_To (DT_Ptr, Loc),                    -- DTptr\n-               New_Reference_To (RTE (RE_Null_Address), Loc))));  -- null\n+         if RTE_Available (RE_Set_Interface_Table) then\n+            Append_To (Elab_Code,\n+              Make_DT_Access_Action (Typ,\n+                Action => Set_Interface_Table,\n+                Args   => New_List (\n+                  New_Reference_To (DT_Ptr, Loc),                    -- DTptr\n+                  New_Reference_To (RTE (RE_Null_Address), Loc))));  -- null\n+         end if;\n \n       --  Generate the Interface_Table object and set the access\n       --  component if the TSD to it.\n \n-      else\n+      elsif RTE_Available (RE_Set_Interface_Table) then\n          Append_To (Result,\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => ITable,\n@@ -2932,65 +3011,77 @@ package body Exp_Disp is\n       --  Generate:\n       --    Set_Num_Prim_Ops (T'Tag, Nb_Prim)\n \n-      if not Is_Interface (Typ) then\n-         Append_To (Elab_Code,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name => New_Reference_To (RTE (RE_Set_Num_Prim_Ops), Loc),\n-             Parameter_Associations => New_List (\n-               New_Reference_To (DT_Ptr, Loc),\n-               Make_Integer_Literal (Loc, Nb_Prim))));\n-      end if;\n-\n-      if Ada_Version >= Ada_05\n-        and then not Is_Interface  (Typ)\n-        and then not Is_Abstract   (Typ)\n-        and then not Is_Controlled (Typ)\n-      then\n-         --  Generate:\n-         --    Set_Type_Kind (T'Tag, Type_Kind (Typ));\n-\n-         Append_To (Elab_Code,\n-           Make_DT_Access_Action (Typ,\n-             Action => Set_Tagged_Kind,\n-             Args   => New_List (\n-               New_Reference_To (DT_Ptr, Loc),               -- DTptr\n-               Tagged_Kind (Typ))));                         -- Value\n-\n-         --  Generate the Select Specific Data table for synchronized\n-         --  types that implement a synchronized interface. The size\n-         --  of the table is constrained by the number of non-predefined\n-         --  primitive operations.\n+      if RTE_Available (RE_Set_Num_Prim_Ops) then\n+         if not Is_Interface (Typ) then\n+            if Empty_DT then\n+               Append_To (Elab_Code,\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => New_Reference_To (RTE (RE_Set_Num_Prim_Ops), Loc),\n+                   Parameter_Associations => New_List (\n+                     New_Reference_To (DT_Ptr, Loc),\n+                     Make_Integer_Literal (Loc, Uint_0))));\n+            else\n+               Append_To (Elab_Code,\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => New_Reference_To (RTE (RE_Set_Num_Prim_Ops), Loc),\n+                   Parameter_Associations => New_List (\n+                     New_Reference_To (DT_Ptr, Loc),\n+                     Make_Integer_Literal (Loc, Nb_Prim))));\n+            end if;\n+         end if;\n \n-         if Is_Concurrent_Record_Type (Typ)\n-           and then Implements_Interface (\n-                      Typ          => Typ,\n-                      Kind         => Any_Limited_Interface,\n-                      Check_Parent => True)\n-           and then (Nb_Prim - Default_Prim_Op_Count) > 0\n+         if Ada_Version >= Ada_05\n+           and then not Is_Interface  (Typ)\n+           and then not Is_Abstract   (Typ)\n+           and then not Is_Controlled (Typ)\n+           and then not Restriction_Active (No_Dispatching_Calls)\n          then\n-            Append_To (Result,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => SSD,\n-                Aliased_Present     => True,\n-                Object_Definition   =>\n-                  Make_Subtype_Indication (Loc,\n-                    Subtype_Mark => New_Reference_To (\n-                      RTE (RE_Select_Specific_Data), Loc),\n-                    Constraint   => Make_Index_Or_Discriminant_Constraint (Loc,\n-                      Constraints => New_List (\n-                        Make_Integer_Literal (Loc,\n-                          Nb_Prim - Default_Prim_Op_Count))))));\n-\n-            --  Set the pointer to the Select Specific Data table in the TSD\n+            --  Generate:\n+            --    Set_Type_Kind (T'Tag, Type_Kind (Typ));\n \n             Append_To (Elab_Code,\n               Make_DT_Access_Action (Typ,\n-                Action => Set_SSD,\n+                Action => Set_Tagged_Kind,\n                 Args   => New_List (\n-                  New_Reference_To (DT_Ptr, Loc),            -- DTptr\n-                  Make_Attribute_Reference (Loc,             -- Value\n-                    Prefix         => New_Reference_To (SSD, Loc),\n-                    Attribute_Name => Name_Address))));\n+                  New_Reference_To (DT_Ptr, Loc),               -- DTptr\n+                  Tagged_Kind (Typ))));                         -- Value\n+\n+            --  Generate the Select Specific Data table for synchronized\n+            --  types that implement a synchronized interface. The size\n+            --  of the table is constrained by the number of non-predefined\n+            --  primitive operations.\n+\n+            if not Empty_DT\n+              and then Is_Concurrent_Record_Type (Typ)\n+              and then Implements_Interface (\n+                         Typ          => Typ,\n+                         Kind         => Any_Limited_Interface,\n+                         Check_Parent => True)\n+            then\n+               Append_To (Result,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => SSD,\n+                   Aliased_Present     => True,\n+                   Object_Definition   =>\n+                     Make_Subtype_Indication (Loc,\n+                       Subtype_Mark => New_Reference_To (\n+                         RTE (RE_Select_Specific_Data), Loc),\n+                       Constraint   =>\n+                         Make_Index_Or_Discriminant_Constraint (Loc,\n+                           Constraints => New_List (\n+                             Make_Integer_Literal (Loc, Nb_Prim))))));\n+\n+               --  Set the pointer to the Select Specific Data table in the TSD\n+\n+               Append_To (Elab_Code,\n+                 Make_DT_Access_Action (Typ,\n+                   Action => Set_SSD,\n+                   Args   => New_List (\n+                     New_Reference_To (DT_Ptr, Loc),            -- DTptr\n+                     Make_Attribute_Reference (Loc,             -- Value\n+                       Prefix         => New_Reference_To (SSD, Loc),\n+                       Attribute_Name => Name_Address))));\n+            end if;\n          end if;\n       end if;\n \n@@ -3052,24 +3143,37 @@ package body Exp_Disp is\n \n       if Typ /= Etype (Typ)\n         and then not Is_Interface (Typ)\n+        and then not Restriction_Active (No_Dispatching_Calls)\n       then\n          --  Generate: Inherit_DT (parent'tag, DT_Ptr, nb_prim of parent);\n \n          if not Is_Interface (Etype (Typ)) then\n-            Append_To (Elab_Code,\n-              Make_DT_Access_Action (Typ,\n-                Action => Inherit_DT,\n-                Args   => New_List (\n-                  Node1 => Old_Tag1,\n-                  Node2 => New_Reference_To (DT_Ptr, Loc),\n-                  Node3 =>\n-                    Make_Integer_Literal (Loc,\n-                      DT_Entry_Count (First_Tag_Component (Etype (Typ)))))));\n+            if Restriction_Active (No_Dispatching_Calls) then\n+               Append_To (Elab_Code,\n+                 Make_DT_Access_Action (Typ,\n+                   Action => Inherit_DT,\n+                   Args   => New_List (\n+                     Node1 => Old_Tag1,\n+                     Node2 => New_Reference_To (DT_Ptr, Loc),\n+                     Node3 => Make_Integer_Literal (Loc, Uint_0))));\n+            else\n+               Append_To (Elab_Code,\n+                 Make_DT_Access_Action (Typ,\n+                   Action => Inherit_DT,\n+                   Args   => New_List (\n+                     Node1 => Old_Tag1,\n+                     Node2 => New_Reference_To (DT_Ptr, Loc),\n+                     Node3 => Make_Integer_Literal (Loc,\n+                                DT_Entry_Count\n+                                  (First_Tag_Component (Etype (Typ)))))));\n+            end if;\n          end if;\n \n          --  Inherit the secondary dispatch tables of the ancestor\n \n-         if not Is_CPP_Class (Etype (Typ)) then\n+         if not Restriction_Active (No_Dispatching_Calls)\n+           and then not Is_CPP_Class (Etype (Typ))\n+         then\n             declare\n                Sec_DT_Ancestor : Elmt_Id :=\n                                    Next_Elmt\n@@ -3089,8 +3193,8 @@ package body Exp_Disp is\n                ------------------------\n \n                procedure Copy_Secondary_DTs (Typ : Entity_Id) is\n-                  E              : Entity_Id;\n-                  Iface          : Elmt_Id;\n+                  E     : Entity_Id;\n+                  Iface : Elmt_Id;\n \n                begin\n                   --  Climb to the ancestor (if any) handling private types\n@@ -3110,7 +3214,6 @@ package body Exp_Disp is\n                   then\n                      Iface := First_Elmt (Abstract_Interfaces (Typ));\n                      E     := First_Entity (Typ);\n-\n                      while Present (E)\n                        and then Present (Node (Sec_DT_Ancestor))\n                      loop\n@@ -3168,23 +3271,24 @@ package body Exp_Disp is\n             Node1 => Old_Tag2,\n             Node2 => New_Reference_To (DT_Ptr, Loc))));\n \n-      --  For types with no controlled components, generate:\n-      --    Set_RC_Offset (DT_Ptr, 0);\n+      if not Is_Interface (Typ) then\n \n-      --  For simple types with controlled components, generate:\n-      --    Set_RC_Offset (DT_Ptr, type._record_controller'position);\n+         --  For types with no controlled components, generate:\n+         --    Set_RC_Offset (DT_Ptr, 0);\n \n-      --  For complex types with controlled components where the position\n-      --  of the record controller is not statically computable, if there are\n-      --  controlled components at this level, generate:\n-      --    Set_RC_Offset (DT_Ptr, -1);\n-      --  to indicate that the _controller field is right after the _parent\n+         --  For simple types with controlled components, generate:\n+         --    Set_RC_Offset (DT_Ptr, type._record_controller'position);\n \n-      --  Or if there are no controlled components at this level, generate:\n-      --    Set_RC_Offset (DT_Ptr, -2);\n-      --  to indicate that we need to get the position from the parent.\n+         --  For complex types with controlled components where the position\n+         --  of the record controller is not statically computable, if there\n+         --  are controlled components at this level, generate:\n+         --    Set_RC_Offset (DT_Ptr, -1);\n+         --  to indicate that the _controller field is right after the _parent\n+\n+         --  Or if there are no controlled components at this level, generate:\n+         --    Set_RC_Offset (DT_Ptr, -2);\n+         --  to indicate that we need to get the position from the parent.\n \n-      if not Is_Interface (Typ) then\n          declare\n             Position : Node_Id;\n \n@@ -3258,16 +3362,20 @@ package body Exp_Disp is\n                   New_Occurrence_Of (Status, Loc))));\n          end;\n \n-         --  Generate:\n-         --    Set_Offset_To_Top (0, DT_Ptr, 0);\n+         if RTE_Available (RE_Set_Offset_To_Top) then\n+            --  Generate:\n+            --    Set_Offset_To_Top (0, DT_Ptr, True, 0, null);\n \n-         Append_To (Elab_Code,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name => New_Reference_To (RTE (RE_Set_Offset_To_Top), Loc),\n-             Parameter_Associations => New_List (\n-               New_Reference_To (RTE (RE_Null_Address), Loc),\n-               New_Reference_To (DT_Ptr, Loc),\n-               Make_Integer_Literal (Loc, Uint_0))));\n+            Append_To (Elab_Code,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name => New_Reference_To (RTE (RE_Set_Offset_To_Top), Loc),\n+                Parameter_Associations => New_List (\n+                  New_Reference_To (RTE (RE_Null_Address), Loc),\n+                  New_Reference_To (DT_Ptr, Loc),\n+                  New_Occurrence_Of (Standard_True, Loc),\n+                  Make_Integer_Literal (Loc, Uint_0),\n+                  New_Reference_To (RTE (RE_Null_Address), Loc))));\n+         end if;\n       end if;\n \n       --  Generate: Set_External_Tag (DT_Ptr, exname'Address);\n@@ -3284,15 +3392,15 @@ package body Exp_Disp is\n                    Prefix => New_Reference_To (Exname, Loc),\n                    Attribute_Name => Name_Address))));\n \n-      --  Generate code to register the Tag in the External_Tag hash\n-      --  table for the pure Ada type only.\n+         --  Generate code to register the Tag in the External_Tag hash\n+         --  table for the pure Ada type only.\n \n-      --        Register_Tag (Dt_Ptr);\n+         --        Register_Tag (Dt_Ptr);\n \n-      --  Skip this if routine not available, or in No_Run_Time mode\n-      --  or Typ is an abstract interface type (because the table to\n-      --  register it is not available in the abstract type but in\n-      --  types implementing this interface)\n+         --  Skip this if routine not available, or in No_Run_Time mode\n+         --  or Typ is an abstract interface type (because the table to\n+         --  register it is not available in the abstract type but in\n+         --  types implementing this interface)\n \n          if not No_Run_Time_Mode\n            and then RTE_Available (RE_Register_Tag)\n@@ -3459,6 +3567,7 @@ package body Exp_Disp is\n       Loc             : constant Source_Ptr := Sloc (AI_Tag);\n       Generalized_Tag : constant Entity_Id := RTE (RE_Interface_Tag);\n       Name_DT         : constant Name_Id := New_Internal_Name ('T');\n+      Empty_DT        : Boolean := False;\n       Iface_DT        : Node_Id;\n       Iface_DT_Ptr    : Node_Id;\n       Name_DT_Ptr     : Name_Id;\n@@ -3493,14 +3602,15 @@ package body Exp_Disp is\n       Set_Is_Statically_Allocated (Iface_DT_Ptr);\n \n       --  Generate code to create the storage for the Dispatch_Table object.\n-      --  If the number of primitives of Typ is less that the number of\n-      --  predefined primitives, we must reserve at least enough space\n-      --  for the predefined primitives.\n+      --  If the number of primitives of Typ is 0 we reserve a dummy single\n+      --  entry for its DT because at run-time the pointer to this dummy entry\n+      --  will be used as the tag.\n \n       Nb_Prim := UI_To_Int (DT_Entry_Count (AI_Tag));\n \n-      if Nb_Prim < Default_Prim_Op_Count then\n-         Nb_Prim := Default_Prim_Op_Count;\n+      if Nb_Prim = 0 then\n+         Empty_DT := True;\n+         Nb_Prim  := 1;\n       end if;\n \n       --    DT : Storage_Array (1..DT_Prologue_Size+nb_prim*DT_Entry_Size);\n@@ -3542,32 +3652,6 @@ package body Exp_Disp is\n               Prefix => New_Reference_To (RTE (RE_Integer_Address), Loc),\n               Attribute_Name => Name_Alignment)));\n \n-      --  Initialize the signature of the interface tag. It is a sequence of\n-      --  two bytes located in the header of the dispatch table. The signature\n-      --  of a Secondary Dispatch Table is (Valid_Signature, Secondary_DT).\n-\n-      Append_To (Result,\n-        Make_Assignment_Statement (Loc,\n-          Name =>\n-            Make_Indexed_Component (Loc,\n-              Prefix => New_Occurrence_Of (Iface_DT, Loc),\n-              Expressions => New_List (\n-                Make_Integer_Literal (Loc, Uint_1))),\n-          Expression =>\n-            Unchecked_Convert_To (RTE (RE_Storage_Element),\n-              New_Reference_To (RTE (RE_Valid_Signature), Loc))));\n-\n-      Append_To (Result,\n-        Make_Assignment_Statement (Loc,\n-          Name =>\n-            Make_Indexed_Component (Loc,\n-              Prefix => New_Occurrence_Of (Iface_DT, Loc),\n-              Expressions => New_List (\n-                Make_Integer_Literal (Loc, Uint_2))),\n-          Expression =>\n-            Unchecked_Convert_To (RTE (RE_Storage_Element),\n-              New_Reference_To (RTE (RE_Secondary_DT), Loc))));\n-\n       --  Generate code to create the pointer to the dispatch table\n \n       --    Iface_DT_Ptr : Tag := Tag!(DT'Address);\n@@ -3607,9 +3691,16 @@ package body Exp_Disp is\n \n       OSD := Make_Defining_Identifier (Loc, New_Internal_Name ('I'));\n \n+      --  Nothing to do if configurable run time does not support the\n+      --  Object_Specific_Data entity.\n+\n+      if not RTE_Available (RE_Object_Specific_Data) then\n+         Error_Msg_CRT (\"abstract interface types\", Typ);\n+         return;\n+      end if;\n+\n       --  Generate:\n-      --    OSD : Ada.Tags.Object_Specific_Data\n-      --            (Nb_Prims - Default_Prim_Op_Count);\n+      --    OSD : Ada.Tags.Object_Specific_Data (Nb_Prims);\n       --  where the constraint is used to allocate space for the\n       --  non-predefined primitive operations only.\n \n@@ -3623,8 +3714,15 @@ package body Exp_Disp is\n               Constraint =>\n                 Make_Index_Or_Discriminant_Constraint (Loc,\n                   Constraints => New_List (\n-                    Make_Integer_Literal (Loc,\n-                      Nb_Prim - Default_Prim_Op_Count + 1))))));\n+                    Make_Integer_Literal (Loc, Nb_Prim))))));\n+\n+      Append_To (Result,\n+        Make_DT_Access_Action (Typ,\n+          Action => Set_Signature,\n+          Args   => New_List (\n+            Unchecked_Convert_To (RTE (RE_Tag),\n+              New_Reference_To (Iface_DT_Ptr, Loc)),\n+            New_Reference_To (RTE (RE_Secondary_DT), Loc))));\n \n       --  Generate:\n       --    Ada.Tags.Set_OSD (Iface_DT_Ptr, OSD);\n@@ -3642,18 +3740,32 @@ package body Exp_Disp is\n       --  Generate:\n       --    Set_Num_Prim_Ops (T'Tag, Nb_Prim)\n \n-      Append_To (Result,\n-        Make_Procedure_Call_Statement (Loc,\n-          Name => New_Reference_To (RTE (RE_Set_Num_Prim_Ops), Loc),\n-          Parameter_Associations => New_List (\n-            Unchecked_Convert_To (RTE (RE_Tag),\n-              New_Reference_To (Iface_DT_Ptr, Loc)),\n-            Make_Integer_Literal (Loc, Nb_Prim))));\n+      if RTE_Available (RE_Set_Num_Prim_Ops) then\n+         if Empty_DT then\n+            Append_To (Result,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name => New_Reference_To (RTE (RE_Set_Num_Prim_Ops), Loc),\n+                Parameter_Associations => New_List (\n+                  Unchecked_Convert_To (RTE (RE_Tag),\n+                    New_Reference_To (Iface_DT_Ptr, Loc)),\n+                  Make_Integer_Literal (Loc, Uint_0))));\n+         else\n+            Append_To (Result,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name => New_Reference_To (RTE (RE_Set_Num_Prim_Ops), Loc),\n+                Parameter_Associations => New_List (\n+                  Unchecked_Convert_To (RTE (RE_Tag),\n+                    New_Reference_To (Iface_DT_Ptr, Loc)),\n+                  Make_Integer_Literal (Loc, Nb_Prim))));\n+         end if;\n+      end if;\n \n       if Ada_Version >= Ada_05\n         and then not Is_Interface  (Typ)\n         and then not Is_Abstract   (Typ)\n         and then not Is_Controlled (Typ)\n+        and then RTE_Available (RE_Set_Tagged_Kind)\n+        and then not Restriction_Active (No_Dispatching_Calls)\n       then\n          --  Generate:\n          --    Set_Tagged_Kind (Iface'Tag, Tagged_Kind (Iface));\n@@ -3666,12 +3778,12 @@ package body Exp_Disp is\n                  New_Reference_To (Iface_DT_Ptr, Loc)),\n                Tagged_Kind (Typ))));                            -- Value\n \n-         if Is_Concurrent_Record_Type (Typ)\n+         if not Empty_DT\n+           and then Is_Concurrent_Record_Type (Typ)\n            and then Implements_Interface (\n                       Typ          => Typ,\n                       Kind         => Any_Limited_Interface,\n                       Check_Parent => True)\n-           and then (Nb_Prim - Default_Prim_Op_Count) > 0\n          then\n             declare\n                Prim       : Entity_Id;\n@@ -3729,14 +3841,14 @@ package body Exp_Disp is\n       Assignments : constant List_Id    := New_List;\n       Loc         : constant Source_Ptr := Sloc (Typ);\n \n-      Conc_Typ    : Entity_Id;\n-      Decls       : List_Id;\n-      DT_Ptr      : Entity_Id;\n-      Prim        : Entity_Id;\n-      Prim_Als    : Entity_Id;\n-      Prim_Elmt   : Elmt_Id;\n-      Prim_Pos    : Uint;\n-      Nb_Prim     : Int := 0;\n+      Conc_Typ  : Entity_Id;\n+      Decls     : List_Id;\n+      DT_Ptr    : Entity_Id;\n+      Prim      : Entity_Id;\n+      Prim_Als  : Entity_Id;\n+      Prim_Elmt : Elmt_Id;\n+      Prim_Pos  : Uint;\n+      Nb_Prim   : Int := 0;\n \n       type Examined_Array is array (Int range <>) of Boolean;\n \n@@ -3776,6 +3888,8 @@ package body Exp_Disp is\n    --  Start of processing for Make_Select_Specific_Data_Table\n \n    begin\n+      pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n+\n       DT_Ptr := Node (First_Elmt (Access_Disp_Table (Typ)));\n \n       if Present (Corresponding_Concurrent_Type (Typ)) then\n@@ -3803,73 +3917,77 @@ package body Exp_Disp is\n       end loop;\n \n       declare\n-         Examined_Size : constant Int := Nb_Prim + Default_Prim_Op_Count;\n-         Examined : Examined_Array (1 .. Examined_Size) := (others => False);\n+         Examined : Examined_Array (1 .. Nb_Prim) := (others => False);\n \n       begin\n          Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n          while Present (Prim_Elmt) loop\n             Prim := Node (Prim_Elmt);\n             Prim_Pos := DT_Position (Prim);\n \n-            pragma Assert (UI_To_Int (Prim_Pos) <= Examined_Size);\n-\n-            if Examined (UI_To_Int (Prim_Pos)) then\n-               goto Continue;\n-            else\n-               Examined (UI_To_Int (Prim_Pos)) := True;\n-            end if;\n-\n-            --  The current primitive overrides an interface-level subprogram\n-\n-            if Present (Abstract_Interface_Alias (Prim)) then\n-\n-               --  Set the primitive operation kind regardless of subprogram\n-               --  type. Generate:\n-               --    Ada.Tags.Set_Prim_Op_Kind (DT_Ptr, <position>, <kind>);\n+            if not Is_Predefined_Dispatching_Operation (Prim) then\n+               pragma Assert (UI_To_Int (Prim_Pos) <= Nb_Prim);\n \n-               Append_To (Assignments,\n-                 Make_DT_Access_Action (Typ,\n-                   Action =>\n-                     Set_Prim_Op_Kind,\n-                   Args =>\n-                     New_List (\n-                       New_Reference_To (DT_Ptr, Loc),\n-                       Make_Integer_Literal (Loc, Prim_Pos),\n-                       Prim_Op_Kind (Prim, Typ))));\n-\n-               --  Retrieve the root of the alias chain if one is present\n-\n-               if Present (Alias (Prim)) then\n-                  Prim_Als := Prim;\n-                  while Present (Alias (Prim_Als)) loop\n-                     Prim_Als := Alias (Prim_Als);\n-                  end loop;\n+               if Examined (UI_To_Int (Prim_Pos)) then\n+                  goto Continue;\n                else\n-                  Prim_Als := Empty;\n+                  Examined (UI_To_Int (Prim_Pos)) := True;\n                end if;\n \n-               --  In the case of an entry wrapper, set the entry index\n+               --  The current primitive overrides an interface-level\n+               --  subprogram\n \n-               if Ekind (Prim) = E_Procedure\n-                 and then Present (Prim_Als)\n-                 and then Is_Primitive_Wrapper (Prim_Als)\n-                 and then Ekind (Wrapped_Entity (Prim_Als)) = E_Entry\n-               then\n+               if Present (Abstract_Interface_Alias (Prim)) then\n \n-                  --  Generate:\n-                  --    Ada.Tags.Set_Entry_Index (DT_Ptr, <position>, <index>);\n+                  --  Set the primitive operation kind regardless of subprogram\n+                  --  type. Generate:\n+                  --    Ada.Tags.Set_Prim_Op_Kind (DT_Ptr, <position>, <kind>);\n \n                   Append_To (Assignments,\n                     Make_DT_Access_Action (Typ,\n                       Action =>\n-                        Set_Entry_Index,\n+                        Set_Prim_Op_Kind,\n                       Args =>\n                         New_List (\n                           New_Reference_To (DT_Ptr, Loc),\n                           Make_Integer_Literal (Loc, Prim_Pos),\n-                          Make_Integer_Literal (Loc,\n-                            Find_Entry_Index (Wrapped_Entity (Prim_Als))))));\n+                          Prim_Op_Kind (Prim, Typ))));\n+\n+                  --  Retrieve the root of the alias chain if one is present\n+\n+                  if Present (Alias (Prim)) then\n+                     Prim_Als := Prim;\n+                     while Present (Alias (Prim_Als)) loop\n+                        Prim_Als := Alias (Prim_Als);\n+                     end loop;\n+                  else\n+                     Prim_Als := Empty;\n+                  end if;\n+\n+                  --  In the case of an entry wrapper, set the entry index\n+\n+                  if Ekind (Prim) = E_Procedure\n+                    and then Present (Prim_Als)\n+                    and then Is_Primitive_Wrapper (Prim_Als)\n+                    and then Ekind (Wrapped_Entity (Prim_Als)) = E_Entry\n+                  then\n+\n+                     --  Generate:\n+                     --    Ada.Tags.Set_Entry_Index\n+                     --      (DT_Ptr, <position>, <index>);\n+\n+                     Append_To (Assignments,\n+                       Make_DT_Access_Action (Typ,\n+                         Action =>\n+                           Set_Entry_Index,\n+                         Args =>\n+                           New_List (\n+                             New_Reference_To (DT_Ptr, Loc),\n+                             Make_Integer_Literal (Loc, Prim_Pos),\n+                             Make_Integer_Literal (Loc,\n+                               Find_Entry_Index\n+                                 (Wrapped_Entity (Prim_Als))))));\n+                  end if;\n                end if;\n             end if;\n \n@@ -3919,11 +4037,12 @@ package body Exp_Disp is\n    is\n       Full_Typ : Entity_Id := Typ;\n       Loc      : constant Source_Ptr := Sloc (Prim);\n-      Prim_Op  : Entity_Id := Prim;\n+      Prim_Op  : Entity_Id;\n \n    begin\n       --  Retrieve the original primitive operation\n \n+      Prim_Op := Prim;\n       while Present (Alias (Prim_Op)) loop\n          Prim_Op := Alias (Prim_Op);\n       end loop;\n@@ -4037,8 +4156,8 @@ package body Exp_Disp is\n             if Present (Abstract_Interface_Alias (Node (Prim_Elmt))) then\n                null;\n \n-            --  Predefined dispatching operations are completely safe.\n-            --  They are allocated at fixed positions.\n+            --  Predefined dispatching operations are completely safe. They\n+            --  are allocated at fixed positions in a separate table.\n \n             elsif Is_Predefined_Dispatching_Operation (Node (Prim_Elmt)) then\n                null;\n@@ -4266,26 +4385,24 @@ package body Exp_Disp is\n          end loop;\n \n          declare\n-            Fixed_Prim : array (Int range 0 .. Default_Prim_Op_Count +\n-                                  Parent_EC + Count_Prim)\n+            Fixed_Prim : array (Int range 0 .. Parent_EC + Count_Prim)\n                            of Boolean := (others => False);\n \n             E : Entity_Id;\n \n          begin\n             --  Second stage: Register fixed entries\n \n-            Nb_Prim   := Default_Prim_Op_Count;\n+            Nb_Prim   := 0;\n             Prim_Elmt := First_Prim;\n             while Present (Prim_Elmt) loop\n                Prim := Node (Prim_Elmt);\n \n-               --  Predefined primitives have a fixed position in all the\n-               --  dispatch tables\n+               --  Predefined primitives have a separate table and all its\n+               --  entries are at predefined fixed positions\n \n                if Is_Predefined_Dispatching_Operation (Prim) then\n                   Set_DT_Position (Prim, Default_Prim_Op_Position (Prim));\n-                  Fixed_Prim (UI_To_Int (DT_Position (Prim))) := True;\n \n                --  Overriding interface primitives of an ancestor\n \n@@ -4355,7 +4472,10 @@ package body Exp_Disp is\n \n                --  Skip primitives previously set entries\n \n-               if DT_Position (Prim) /= No_Uint then\n+               if Is_Predefined_Dispatching_Operation (Prim) then\n+                  null;\n+\n+               elsif DT_Position (Prim) /= No_Uint then\n                   null;\n \n                elsif Etype (DTC_Entity (Prim)) /= RTE (RE_Tag) then\n@@ -4442,14 +4562,18 @@ package body Exp_Disp is\n \n             --  Calculate real size of the dispatch table\n \n-            if UI_To_Int (DT_Position (Prim)) > DT_Length then\n+            if not Is_Predefined_Dispatching_Operation (Prim)\n+              and then UI_To_Int (DT_Position (Prim)) > DT_Length\n+            then\n                DT_Length := UI_To_Int (DT_Position (Prim));\n             end if;\n \n-            --  Ensure that the asignated position in the dispatch\n-            --  table is correct\n+            --  Ensure that the asignated position to non-predefined\n+            --  dispatching operations in the dispatch table is correct.\n \n-            Validate_Position (Prim);\n+            if not Is_Predefined_Dispatching_Operation (Prim) then\n+               Validate_Position (Prim);\n+            end if;\n \n             if Chars (Prim) = Name_Finalize then\n                Finalized := True;\n@@ -4591,7 +4715,8 @@ package body Exp_Disp is\n       Loc      : constant Source_Ptr := Sloc (T);\n \n    begin\n-      pragma Assert (Is_Tagged_Type (T));\n+      pragma Assert\n+        (Is_Tagged_Type (T) and then RTE_Available (RE_Tagged_Kind));\n \n       --  Abstract kinds\n \n@@ -4676,6 +4801,11 @@ package body Exp_Disp is\n \n          Write_Int  (Int (Prim));\n          Write_Str  (\": \");\n+\n+         if Is_Predefined_Dispatching_Operation (Prim) then\n+            Write_Str (\"(predefined) \");\n+         end if;\n+\n          Write_Name (Chars (Prim));\n \n          --  Indicate if this primitive has an aliased primitive"}, {"sha": "50f1a6b2f26b039ffa7eb03466c77263bca6b5ec", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0efe69eaeb85421c7a98d53934ffb4f64020d1e/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0efe69eaeb85421c7a98d53934ffb4f64020d1e/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=b0efe69eaeb85421c7a98d53934ffb4f64020d1e", "patch": "@@ -136,22 +136,15 @@ package Exp_Disp is\n \n    --  Guidelines for addition of new predefined primitive operations\n \n-   --      Update the value of constant Default_Prim_Op_Count in Exp_Disp.ads\n-   --      to reflect the new number of PPOs.\n-\n    --      Update the value of constant Default_Prim_Op_Count in A-Tags.ads\n-   --      to reflect the new number of PPOs. This value should be the same\n-   --      as the one in Exp_Disp.ads.\n+   --      to reflect the new number of PPOs.\n \n    --      Introduce a new predefined name for the new PPO in Snames.ads and\n    --      Snames.adb.\n \n    --      Categorize the new PPO name as predefined by adding an entry in\n    --      Is_Predefined_Dispatching_Operation in Exp_Util.adb.\n \n-   --      Reserve a dispatch table position for the new PPO by adding an entry\n-   --      in Default_Prim_Op_Position in Exp_Disp.adb.\n-\n    --      Generate the specification of the new PPO in Make_Predefined_\n    --      Primitive_Spec in Exp_Ch3.adb. The Is_Internal flag of the defining\n    --      identifier of the specification must be set to True.\n@@ -174,8 +167,6 @@ package Exp_Disp is\n    --    Exp_Disp.Default_Prim_Op_Position - indirect use\n    --    Exp_Disp.Set_All_DT_Position      - direct   use\n \n-   Default_Prim_Op_Count : constant Int := 15;\n-\n    type DT_Access_Action is\n       (CW_Membership,\n        IW_Membership,\n@@ -184,6 +175,7 @@ package Exp_Disp is\n        Get_Access_Level,\n        Get_Entry_Index,\n        Get_External_Tag,\n+       Get_Predefined_Prim_Op_Address,\n        Get_Prim_Op_Address,\n        Get_Prim_Op_Kind,\n        Get_RC_Offset,\n@@ -200,10 +192,12 @@ package Exp_Disp is\n        Set_Interface_Table,\n        Set_Offset_Index,\n        Set_OSD,\n+       Set_Predefined_Prim_Op_Address,\n        Set_Prim_Op_Address,\n        Set_Prim_Op_Kind,\n        Set_RC_Offset,\n        Set_Remotely_Callable,\n+       Set_Signature,\n        Set_SSD,\n        Set_TSD,\n        Set_Tagged_Kind,"}]}