{"sha": "45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "node_id": "C_kwDOANBUbNoAKDQ1Yzg1MjNkZDNlNTBkYWE1ZjBiYmEwNDAwOTlmZGZkMmFkMWFhYWE", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-05-22T18:17:40Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-06-01T09:11:15Z"}, "message": "Convert ranger and clients to vrange.\n\nFinally, the meat of the work.  Convert ranger and associated clients\nto vrange.\n\nEverything's relatively mechanical given the previous patches.  I did\ninclude a minor cleanup in the edge code.  There's no need to check\nthat the type of the switch is an integer as non-integer switches are\ninvalid.  I verified this with an appropriately coded assert.\n\nTested on x86-64 & ppc64le Linux.\n\ngcc/ChangeLog:\n\n\t* gimple-range-cache.cc (ssa_block_ranges::dump): Convert to vrange.\n\t(sbr_vector::sbr_vector): Same.\n\t(sbr_vector::grow): Same.\n\t(sbr_vector::set_bb_range): Same.\n\t(sbr_vector::get_bb_range): Same.\n\t(sbr_sparse_bitmap::sbr_sparse_bitmap): Same.\n\t(sbr_sparse_bitmap::set_bb_range): Same.\n\t(sbr_sparse_bitmap::get_bb_range): Same.\n\t(block_range_cache::set_bb_range): Same.\n\t(block_range_cache::get_bb_range): Same.\n\t(block_range_cache::dump): Same.\n\t(ssa_global_cache::get_global_range): Same.\n\t(ssa_global_cache::set_global_range): Same.\n\t(ssa_global_cache::clear): Same.\n\t(ssa_global_cache::dump): Same.\n\t(ranger_cache::get_global_range): Same.\n\t(ranger_cache::set_global_range): Same.\n\t(ranger_cache::range_of_def): Same.\n\t(ranger_cache::entry_range): Same.\n\t(ranger_cache::exit_range): Same.\n\t(ranger_cache::edge_range): Same.\n\t(ranger_cache::range_of_expr): Same.\n\t(ranger_cache::range_on_edge): Same.\n\t(ranger_cache::block_range): Same.\n\t(ranger_cache::propagate_cache): Same.\n\t(ranger_cache::fill_block_cache): Same.\n\t(ranger_cache::range_from_dom): Same.\n\t* gimple-range-cache.h: Same.\n\t* gimple-range-edge.cc (gimple_outgoing_range::get_edge_range):\n\tSame.\n\t(gimple_outgoing_range::switch_edge_range): Same.\n\t(gimple_outgoing_range::edge_range_p): Same.\n\t* gimple-range-edge.h: Same.\n\t* gimple-range-fold.cc (fur_source::get_operand): Same.\n\t(fur_source::get_phi_operand): Same.\n\t(fur_edge::get_operand): Same.\n\t(fur_edge::get_phi_operand): Same.\n\t(fur_stmt::get_operand): Same.\n\t(fur_stmt::get_phi_operand): Same.\n\t(fur_list::fur_list): Same.\n\t(fur_list::get_operand): Same.\n\t(fur_list::get_phi_operand): Same.\n\t(fold_range): Same.\n\t(adjust_imagpart_expr): Same.\n\t(adjust_realpart_expr): Same.\n\t(gimple_range_adjustment): Same.\n\t(fold_using_range::fold_stmt): Same.\n\t(fold_using_range::range_of_range_op): Same.\n\t(fold_using_range::range_of_address): Same.\n\t(fold_using_range::range_of_phi): Same.\n\t(fold_using_range::range_of_call): Same.\n\t(fold_using_range::range_of_builtin_call): Same.\n\t(fold_using_range::range_of_builtin_int_call): Same.\n\t(fold_using_range::range_of_cond_expr): Same.\n\t(fur_source::register_outgoing_edges): Same.\n\t* gimple-range-fold.h (fold_range): Same.\n\t(gimple_range_type): Same.\n\t(gimple_range_ssa_p): Same.\n\t* gimple-range-gori.cc (gimple_range_calc_op1): Same.\n\t(gimple_range_calc_op2): Same.\n\t(gori_compute::compute_operand_range_switch): Same.\n\t(gori_compute::compute_operand_range): Same.\n\t(gori_compute::logical_combine): Same.\n\t(gori_compute::compute_logical_operands): Same.\n\t(gori_compute::compute_operand1_range): Same.\n\t(gori_compute::compute_operand2_range): Same.\n\t(gori_compute::compute_operand1_and_operand2_range): Same.\n\t(gori_compute::outgoing_edge_range_p): Same.\n\t(gori_compute::condexpr_adjust): Same.\n\t* gimple-range-gori.h (gimple_range_calc_op1): Same.\n\t(gimple_range_calc_op2): Same.\n\t* gimple-range-path.cc (path_range_query::get_cache): Same.\n\t(path_range_query::set_cache): Same.\n\t(path_range_query::range_on_path_entry): Same.\n\t(path_range_query::internal_range_of_expr): Same.\n\t(path_range_query::range_of_expr): Same.\n\t(path_range_query::ssa_range_in_phi): Same.\n\t(path_range_query::range_defined_in_block): Same.\n\t(path_range_query::compute_ranges_in_phis): Same.\n\t(path_range_query::compute_ranges_in_block): Same.\n\t(path_range_query::add_to_imports): Same.\n\t(path_range_query::range_of_stmt): Same.\n\t* gimple-range-path.h: Same.\n\t* gimple-range-infer.cc (gimple_infer_range::add_range): Same.\n\t(gimple_infer_range::~side_effect_manager): Same.\n\t(gimple_infer_range::get_nonzero): Same.\n\t(gimple_infer_range::maybe_adjust_range): Same.\n\t(gimple_infer_range::add_range): Same.\n\t* gimple-range-infer.h: Same.\n\t* gimple-range-tests.cc: Same.\n\t* gimple-range-trace.cc (range_tracer::trailer): Same.\n\t(debug_seed_ranger): Same.\n\t* gimple-range-trace.h: Same.\n\t* gimple-range.cc (gimple_ranger::range_of_expr): Same.\n\t(gimple_ranger::range_on_entry): Same.\n\t(gimple_ranger::range_on_exit): Same.\n\t(gimple_ranger::range_on_edge): Same.\n\t(gimple_ranger::fold_range_internal): Same.\n\t(gimple_ranger::range_of_stmt): Same.\n\t(gimple_ranger::prefill_name): Same.\n\t(gimple_ranger::prefill_stmt_dependencies): Same.\n\t(gimple_ranger::export_global_ranges): Same.\n\t(gimple_ranger::dump_bb): Same.\n\t* gimple-range.h: Same.\n\t* gimple-ssa-warn-access.cc (check_nul_terminated_array): Same.\n\t(memmodel_to_uhwi): Same.\n\t* tree-ssa-loop-niter.cc (refine_value_range_using_guard): Same.\n\t(determine_value_range): Same.\n\t(record_nonwrapping_iv): Same.\n\t(infer_loop_bounds_from_signedness): Same.\n\t(scev_var_range_cant_overflow): Same.\n\t* tree-ssa-threadedge.cc (hybrid_jt_simplifier::simplify): Same.\n\t* value-query.cc (range_query::range_on_edge): Same.\n\t(range_query::range_of_stmt): Same.\n\t(range_query::value_of_expr): Same.\n\t(range_query::value_on_edge): Same.\n\t(range_query::value_of_stmt): Same.\n\t(range_query::get_tree_range): Same.\n\t(update_global_range): Same.\n\t(get_range_global): Same.\n\t(gimple_range_global): Same.\n\t(global_range_query::range_of_expr): Same.\n\t(range_query::query_relation): Same.\n\t* value-query.h (gimple_range_global): Same.\n\t(update_global_range): Same.\n\t* vr-values.cc (vr_values::range_of_expr): Same.\n\t(bounds_of_var_in_loop): Same.\n\t(simplify_using_ranges::vrp_visit_cond_stmt): Same.\n\t* vr-values.h (class vr_values): Same.\n\t* tree-ssa-loop-unswitch.cc (unswitch_predicate): Same.", "tree": {"sha": "9e8f023eab39b290d2c5194cea3692525a4a3d8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e8f023eab39b290d2c5194cea3692525a4a3d8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8474337a0b2bf1b3c84863957cef1da92811ffe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8474337a0b2bf1b3c84863957cef1da92811ffe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8474337a0b2bf1b3c84863957cef1da92811ffe"}], "stats": {"total": 898, "additions": 492, "deletions": 406}, "files": [{"sha": "85eed4421f4acff4ecf0122f1c53379b5040053f", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 75, "deletions": 65, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -44,11 +44,14 @@ along with GCC; see the file COPYING3.  If not see\n class ssa_block_ranges\n {\n public:\n-  virtual bool set_bb_range (const_basic_block bb, const irange &r) = 0;\n-  virtual bool get_bb_range (irange &r, const_basic_block bb) = 0;\n+  ssa_block_ranges (tree t) : m_type (t) { }\n+  virtual bool set_bb_range (const_basic_block bb, const vrange &r) = 0;\n+  virtual bool get_bb_range (vrange &r, const_basic_block bb) = 0;\n   virtual bool bb_range_p (const_basic_block bb) = 0;\n \n   void dump(FILE *f);\n+private:\n+  tree m_type;\n };\n \n // Print the list of known ranges for file F in a nice format.\n@@ -57,7 +60,7 @@ void\n ssa_block_ranges::dump (FILE *f)\n {\n   basic_block bb;\n-  int_range_max r;\n+  Value_Range r (m_type);\n \n   FOR_EACH_BB_FN (bb, cfun)\n     if (get_bb_range (r, bb))\n@@ -77,14 +80,14 @@ class sbr_vector : public ssa_block_ranges\n public:\n   sbr_vector (tree t, vrange_allocator *allocator);\n \n-  virtual bool set_bb_range (const_basic_block bb, const irange &r) override;\n-  virtual bool get_bb_range (irange &r, const_basic_block bb) override;\n+  virtual bool set_bb_range (const_basic_block bb, const vrange &r) override;\n+  virtual bool get_bb_range (vrange &r, const_basic_block bb) override;\n   virtual bool bb_range_p (const_basic_block bb) override;\n protected:\n-  irange **m_tab;\t// Non growing vector.\n+  vrange **m_tab;\t// Non growing vector.\n   int m_tab_size;\n-  int_range<2> m_varying;\n-  int_range<2> m_undefined;\n+  vrange *m_varying;\n+  vrange *m_undefined;\n   tree m_type;\n   vrange_allocator *m_range_allocator;\n   void grow ();\n@@ -94,18 +97,21 @@ class sbr_vector : public ssa_block_ranges\n // Initialize a block cache for an ssa_name of type T.\n \n sbr_vector::sbr_vector (tree t, vrange_allocator *allocator)\n+  : ssa_block_ranges (t)\n {\n   gcc_checking_assert (TYPE_P (t));\n   m_type = t;\n   m_range_allocator = allocator;\n   m_tab_size = last_basic_block_for_fn (cfun) + 1;\n-  m_tab = static_cast <irange **>\n-    (allocator->alloc (m_tab_size * sizeof (irange *)));\n-  memset (m_tab, 0, m_tab_size * sizeof (irange *));\n+  m_tab = static_cast <vrange **>\n+    (allocator->alloc (m_tab_size * sizeof (vrange *)));\n+  memset (m_tab, 0, m_tab_size * sizeof (vrange *));\n \n   // Create the cached type range.\n-  m_varying.set_varying (t);\n-  m_undefined.set_undefined ();\n+  m_varying = m_range_allocator->alloc_vrange (t);\n+  m_undefined = m_range_allocator->alloc_vrange (t);\n+  m_varying->set_varying (t);\n+  m_undefined->set_undefined ();\n }\n \n // Grow the vector when the CFG has increased in size.\n@@ -122,10 +128,10 @@ sbr_vector::grow ()\n   int new_size = inc + curr_bb_size;\n \n   // Allocate new memory, copy the old vector and clear the new space.\n-  irange **t = static_cast <irange **>\n-    (m_range_allocator->alloc (new_size * sizeof (irange *)));\n-  memcpy (t, m_tab, m_tab_size * sizeof (irange *));\n-  memset (t + m_tab_size, 0, (new_size - m_tab_size) * sizeof (irange *));\n+  vrange **t = static_cast <vrange **>\n+    (m_range_allocator->alloc (new_size * sizeof (vrange *)));\n+  memcpy (t, m_tab, m_tab_size * sizeof (vrange *));\n+  memset (t + m_tab_size, 0, (new_size - m_tab_size) * sizeof (vrange *));\n \n   m_tab = t;\n   m_tab_size = new_size;\n@@ -134,15 +140,15 @@ sbr_vector::grow ()\n // Set the range for block BB to be R.\n \n bool\n-sbr_vector::set_bb_range (const_basic_block bb, const irange &r)\n+sbr_vector::set_bb_range (const_basic_block bb, const vrange &r)\n {\n-  irange *m;\n+  vrange *m;\n   if (bb->index >= m_tab_size)\n     grow ();\n   if (r.varying_p ())\n-    m = &m_varying;\n+    m = m_varying;\n   else if (r.undefined_p ())\n-    m = &m_undefined;\n+    m = m_undefined;\n   else\n     m = m_range_allocator->clone (r);\n   m_tab[bb->index] = m;\n@@ -153,11 +159,11 @@ sbr_vector::set_bb_range (const_basic_block bb, const irange &r)\n // there is no range.\n \n bool\n-sbr_vector::get_bb_range (irange &r, const_basic_block bb)\n+sbr_vector::get_bb_range (vrange &r, const_basic_block bb)\n {\n   if (bb->index >= m_tab_size)\n     return false;\n-  irange *m = m_tab[bb->index];\n+  vrange *m = m_tab[bb->index];\n   if (m)\n     {\n       r = *m;\n@@ -193,14 +199,14 @@ class sbr_sparse_bitmap : public ssa_block_ranges\n {\n public:\n   sbr_sparse_bitmap (tree t, vrange_allocator *allocator, bitmap_obstack *bm);\n-  virtual bool set_bb_range (const_basic_block bb, const irange &r) override;\n-  virtual bool get_bb_range (irange &r, const_basic_block bb) override;\n+  virtual bool set_bb_range (const_basic_block bb, const vrange &r) override;\n+  virtual bool get_bb_range (vrange &r, const_basic_block bb) override;\n   virtual bool bb_range_p (const_basic_block bb) override;\n private:\n   void bitmap_set_quad (bitmap head, int quad, int quad_value);\n   int bitmap_get_quad (const_bitmap head, int quad);\n   vrange_allocator *m_range_allocator;\n-  irange *m_range[SBR_NUM];\n+  vrange *m_range[SBR_NUM];\n   bitmap_head bitvec;\n   tree m_type;\n };\n@@ -209,23 +215,22 @@ class sbr_sparse_bitmap : public ssa_block_ranges\n \n sbr_sparse_bitmap::sbr_sparse_bitmap (tree t, vrange_allocator *allocator,\n \t\t\t\t      bitmap_obstack *bm)\n+  : ssa_block_ranges (t)\n {\n   gcc_checking_assert (TYPE_P (t));\n   m_type = t;\n   bitmap_initialize (&bitvec, bm);\n   bitmap_tree_view (&bitvec);\n   m_range_allocator = allocator;\n   // Pre-cache varying.\n-  m_range[0] = static_cast <irange *> (m_range_allocator->alloc_vrange (t));\n+  m_range[0] = m_range_allocator->alloc_vrange (t);\n   m_range[0]->set_varying (t);\n   // Pre-cache zero and non-zero values for pointers.\n   if (POINTER_TYPE_P (t))\n     {\n-      m_range[1]\n-\t= static_cast <irange *> (m_range_allocator->alloc_vrange (t));\n+      m_range[1] = m_range_allocator->alloc_vrange (t);\n       m_range[1]->set_nonzero (t);\n-      m_range[2]\n-\t= static_cast <irange *> (m_range_allocator->alloc_vrange (t));\n+      m_range[2] = m_range_allocator->alloc_vrange (t);\n       m_range[2]->set_zero (t);\n     }\n   else\n@@ -257,7 +262,7 @@ sbr_sparse_bitmap::bitmap_get_quad (const_bitmap head, int quad)\n // Set the range on entry to basic block BB to R.\n \n bool\n-sbr_sparse_bitmap::set_bb_range (const_basic_block bb, const irange &r)\n+sbr_sparse_bitmap::set_bb_range (const_basic_block bb, const vrange &r)\n {\n   if (r.undefined_p ())\n     {\n@@ -283,7 +288,7 @@ sbr_sparse_bitmap::set_bb_range (const_basic_block bb, const irange &r)\n // there is no range.\n \n bool\n-sbr_sparse_bitmap::get_bb_range (irange &r, const_basic_block bb)\n+sbr_sparse_bitmap::get_bb_range (vrange &r, const_basic_block bb)\n {\n   int value = bitmap_get_quad (&bitvec, bb->index);\n \n@@ -333,7 +338,7 @@ block_range_cache::~block_range_cache ()\n \n bool\n block_range_cache::set_bb_range (tree name, const_basic_block bb,\n-\t\t\t\t const irange &r)\n+\t\t\t\t const vrange &r)\n {\n   unsigned v = SSA_NAME_VERSION (name);\n   if (v >= m_ssa_ranges.length ())\n@@ -379,7 +384,7 @@ block_range_cache::query_block_ranges (tree name)\n // is one.\n \n bool\n-block_range_cache::get_bb_range (irange &r, tree name, const_basic_block bb)\n+block_range_cache::get_bb_range (vrange &r, tree name, const_basic_block bb)\n {\n   ssa_block_ranges *ptr = query_block_ranges (name);\n   if (ptr)\n@@ -423,12 +428,13 @@ void\n block_range_cache::dump (FILE *f, basic_block bb, bool print_varying)\n {\n   unsigned x;\n-  int_range_max r;\n   bool summarize_varying = false;\n   for (x = 1; x < m_ssa_ranges.length (); ++x)\n     {\n       if (!gimple_range_ssa_p (ssa_name (x)))\n \tcontinue;\n+\n+      Value_Range r (TREE_TYPE (ssa_name (x)));\n       if (m_ssa_ranges[x] && m_ssa_ranges[x]->get_bb_range (r, bb))\n \t{\n \t  if (!print_varying && r.varying_p ())\n@@ -450,6 +456,8 @@ block_range_cache::dump (FILE *f, basic_block bb, bool print_varying)\n \t{\n \t  if (!gimple_range_ssa_p (ssa_name (x)))\n \t    continue;\n+\n+\t  Value_Range r (TREE_TYPE (ssa_name (x)));\n \t  if (m_ssa_ranges[x] && m_ssa_ranges[x]->get_bb_range (r, bb))\n \t    {\n \t      if (r.varying_p ())\n@@ -485,13 +493,13 @@ ssa_global_cache::~ssa_global_cache ()\n // Return the value in R.\n \n bool\n-ssa_global_cache::get_global_range (irange &r, tree name) const\n+ssa_global_cache::get_global_range (vrange &r, tree name) const\n {\n   unsigned v = SSA_NAME_VERSION (name);\n   if (v >= m_tab.length ())\n     return false;\n \n-  irange *stow = m_tab[v];\n+  vrange *stow = m_tab[v];\n   if (!stow)\n     return false;\n   r = *stow;\n@@ -502,13 +510,13 @@ ssa_global_cache::get_global_range (irange &r, tree name) const\n // Return TRUE if there was already a range set, otherwise false.\n \n bool\n-ssa_global_cache::set_global_range (tree name, const irange &r)\n+ssa_global_cache::set_global_range (tree name, const vrange &r)\n {\n   unsigned v = SSA_NAME_VERSION (name);\n   if (v >= m_tab.length ())\n     m_tab.safe_grow_cleared (num_ssa_names + 1);\n \n-  irange *m = m_tab[v];\n+  vrange *m = m_tab[v];\n   if (m && m->fits_p (r))\n     *m = r;\n   else\n@@ -533,7 +541,7 @@ void\n ssa_global_cache::clear ()\n {\n   if (m_tab.address ())\n-    memset (m_tab.address(), 0, m_tab.length () * sizeof (irange *));\n+    memset (m_tab.address(), 0, m_tab.length () * sizeof (vrange *));\n }\n \n // Dump the contents of the global cache to F.\n@@ -545,9 +553,10 @@ ssa_global_cache::dump (FILE *f)\n   bool print_header = true;\n   for (unsigned x = 1; x < num_ssa_names; x++)\n     {\n-      int_range_max r;\n-      if (gimple_range_ssa_p (ssa_name (x)) &&\n-\t  get_global_range (r, ssa_name (x))  && !r.varying_p ())\n+      if (!gimple_range_ssa_p (ssa_name (x)))\n+\tcontinue;\n+      Value_Range r (TREE_TYPE (ssa_name (x)));\n+      if (get_global_range (r, ssa_name (x)) && !r.varying_p ())\n \t{\n \t  if (print_header)\n \t    {\n@@ -809,11 +818,11 @@ ranger_cache::dump_bb (FILE *f, basic_block bb)\n // global range is not set, and return the legacy global value in R.\n \n bool\n-ranger_cache::get_global_range (irange &r, tree name) const\n+ranger_cache::get_global_range (vrange &r, tree name) const\n {\n   if (m_globals.get_global_range (r, name))\n     return true;\n-  r = gimple_range_global (name);\n+  gimple_range_global (r, name);\n   return false;\n }\n \n@@ -825,7 +834,7 @@ ranger_cache::get_global_range (irange &r, tree name) const\n // After this call, the global cache will have a value.\n \n bool\n-ranger_cache::get_global_range (irange &r, tree name, bool &current_p)\n+ranger_cache::get_global_range (vrange &r, tree name, bool &current_p)\n {\n   bool had_global = get_global_range (r, name);\n \n@@ -847,7 +856,7 @@ ranger_cache::get_global_range (irange &r, tree name, bool &current_p)\n //  Set the global range of NAME to R and give it a timestamp.\n \n void\n-ranger_cache::set_global_range (tree name, const irange &r)\n+ranger_cache::set_global_range (tree name, const vrange &r)\n {\n   if (m_globals.set_global_range (name, r))\n     {\n@@ -882,7 +891,7 @@ ranger_cache::set_global_range (tree name, const irange &r)\n // get the best global value available.\n \n void\n-ranger_cache::range_of_def (irange &r, tree name, basic_block bb)\n+ranger_cache::range_of_def (vrange &r, tree name, basic_block bb)\n {\n   gcc_checking_assert (gimple_range_ssa_p (name));\n   gcc_checking_assert (!bb || bb == gimple_bb (SSA_NAME_DEF_STMT (name)));\n@@ -895,20 +904,20 @@ ranger_cache::range_of_def (irange &r, tree name, basic_block bb)\n       if (gimple_get_lhs (s) == name)\n \tfold_range (r, s, get_global_range_query ());\n       else\n-\tr = gimple_range_global (name);\n+\tgimple_range_global (r, name);\n     }\n }\n \n // Get the range of NAME as it occurs on entry to block BB.  Use MODE for\n // lookups.\n \n void\n-ranger_cache::entry_range (irange &r, tree name, basic_block bb,\n+ranger_cache::entry_range (vrange &r, tree name, basic_block bb,\n \t\t\t   enum rfd_mode mode)\n {\n   if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n     {\n-      r = gimple_range_global (name);\n+      gimple_range_global (r, name);\n       return;\n     }\n \n@@ -923,12 +932,12 @@ ranger_cache::entry_range (irange &r, tree name, basic_block bb,\n // lookups.\n \n void\n-ranger_cache::exit_range (irange &r, tree name, basic_block bb,\n+ranger_cache::exit_range (vrange &r, tree name, basic_block bb,\n \t\t\t  enum rfd_mode mode)\n {\n   if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n     {\n-      r = gimple_range_global (name);\n+      gimple_range_global (r, name);\n       return;\n     }\n \n@@ -944,7 +953,7 @@ ranger_cache::exit_range (irange &r, tree name, basic_block bb,\n // Always returns a range and true.\n \n bool\n-ranger_cache::edge_range (irange &r, edge e, tree name, enum rfd_mode mode)\n+ranger_cache::edge_range (vrange &r, edge e, tree name, enum rfd_mode mode)\n {\n   exit_range (r, name, e->src, mode);\n   // If this is not an abnormal edge, check for inferred ranges on exit.\n@@ -961,7 +970,7 @@ ranger_cache::edge_range (irange &r, edge e, tree name, enum rfd_mode mode)\n // Implement range_of_expr.\n \n bool\n-ranger_cache::range_of_expr (irange &r, tree name, gimple *stmt)\n+ranger_cache::range_of_expr (vrange &r, tree name, gimple *stmt)\n {\n   if (!gimple_range_ssa_p (name))\n     {\n@@ -985,7 +994,7 @@ ranger_cache::range_of_expr (irange &r, tree name, gimple *stmt)\n // the current cache values.\n \n bool\n-ranger_cache::range_on_edge (irange &r, edge e, tree expr)\n+ranger_cache::range_on_edge (vrange &r, edge e, tree expr)\n {\n   if (gimple_range_ssa_p (expr))\n     return edge_range (r, e, expr, RFD_NONE);\n@@ -997,7 +1006,7 @@ ranger_cache::range_on_edge (irange &r, edge e, tree expr)\n // def block for NAME.  Otherwise, return false if the cache is empty.\n \n bool\n-ranger_cache::block_range (irange &r, basic_block bb, tree name, bool calc)\n+ranger_cache::block_range (vrange &r, basic_block bb, tree name, bool calc)\n {\n   gcc_checking_assert (gimple_range_ssa_p (name));\n \n@@ -1041,9 +1050,10 @@ ranger_cache::propagate_cache (tree name)\n   basic_block bb;\n   edge_iterator ei;\n   edge e;\n-  int_range_max new_range;\n-  int_range_max current_range;\n-  int_range_max e_range;\n+  tree type = TREE_TYPE (name);\n+  Value_Range new_range (type);\n+  Value_Range current_range (type);\n+  Value_Range e_range (type);\n \n   // Process each block by seeing if its calculated range on entry is\n   // the same as its cached value. If there is a difference, update\n@@ -1178,8 +1188,8 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n {\n   edge_iterator ei;\n   edge e;\n-  int_range_max block_result;\n-  int_range_max undefined;\n+  Value_Range block_result (TREE_TYPE (name));\n+  Value_Range undefined (TREE_TYPE (name));\n \n   // At this point we shouldn't be looking at the def, entry or exit block.\n   gcc_checking_assert (bb != def_bb && bb != ENTRY_BLOCK_PTR_FOR_FN (cfun) &&\n@@ -1232,7 +1242,7 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n       FOR_EACH_EDGE (e, ei, node->preds)\n \t{\n \t  basic_block pred = e->src;\n-\t  int_range_max r;\n+\t  Value_Range r (TREE_TYPE (name));\n \n \t  if (DEBUG_RANGE_CACHE)\n \t    fprintf (dump_file, \"  %d->%d \",e->src->index, e->dest->index);\n@@ -1306,7 +1316,7 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n // dominator tree based on MODE.\n \n bool\n-ranger_cache::range_from_dom (irange &r, tree name, basic_block start_bb,\n+ranger_cache::range_from_dom (vrange &r, tree name, basic_block start_bb,\n \t\t\t      enum rfd_mode mode)\n {\n   if (mode == RFD_NONE || !dom_info_available_p (CDI_DOMINATORS))"}, {"sha": "1e4b5b30565c3749fe6833d4b8d6f44777e393f7", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -34,8 +34,8 @@ class block_range_cache\n   block_range_cache ();\n   ~block_range_cache ();\n \n-  bool set_bb_range (tree name, const_basic_block bb, const irange &r);\n-  bool get_bb_range (irange &r, tree name, const_basic_block bb);\n+  bool set_bb_range (tree name, const_basic_block bb, const vrange &v);\n+  bool get_bb_range (vrange &v, tree name, const_basic_block bb);\n   bool bb_range_p (tree name, const_basic_block bb);\n \n   void dump (FILE *f);\n@@ -57,13 +57,13 @@ class ssa_global_cache\n public:\n   ssa_global_cache ();\n   ~ssa_global_cache ();\n-  bool get_global_range (irange &r, tree name) const;\n-  bool set_global_range (tree name, const irange &r);\n+  bool get_global_range (vrange &r, tree name) const;\n+  bool set_global_range (tree name, const vrange &r);\n   void clear_global_range (tree name);\n   void clear ();\n   void dump (FILE *f = stderr);\n private:\n-  vec<irange *> m_tab;\n+  vec<vrange *> m_tab;\n   vrange_allocator *m_range_allocator;\n };\n \n@@ -77,13 +77,13 @@ class ranger_cache : public range_query\n   ranger_cache (int not_executable_flag, bool use_imm_uses);\n   ~ranger_cache ();\n \n-  virtual bool range_of_expr (irange &r, tree name, gimple *stmt);\n-  virtual bool range_on_edge (irange &r, edge e, tree expr);\n-  bool block_range (irange &r, basic_block bb, tree name, bool calc = true);\n+  virtual bool range_of_expr (vrange &r, tree name, gimple *stmt);\n+  virtual bool range_on_edge (vrange &r, edge e, tree expr);\n+  bool block_range (vrange &r, basic_block bb, tree name, bool calc = true);\n \n-  bool get_global_range (irange &r, tree name) const;\n-  bool get_global_range (irange &r, tree name, bool &current_p);\n-  void set_global_range (tree name, const irange &r);\n+  bool get_global_range (vrange &r, tree name) const;\n+  bool get_global_range (vrange &r, tree name, bool &current_p);\n+  void set_global_range (tree name, const vrange &r);\n \n   void propagate_updated_value (tree name, basic_block bb);\n \n@@ -106,11 +106,11 @@ class ranger_cache : public range_query\n       RFD_READ_ONLY,\t// Scan DOM tree, do not write to cache.\n       RFD_FILL\t\t// Scan DOM tree, updating important nodes.\n     };\n-  bool range_from_dom (irange &r, tree name, basic_block bb, enum rfd_mode);\n-  void range_of_def (irange &r, tree name, basic_block bb = NULL);\n-  void entry_range (irange &r, tree expr, basic_block bb, enum rfd_mode);\n-  void exit_range (irange &r, tree expr, basic_block bb, enum rfd_mode);\n-  bool edge_range (irange &r, edge e, tree name, enum rfd_mode);\n+  bool range_from_dom (vrange &r, tree name, basic_block bb, enum rfd_mode);\n+  void range_of_def (vrange &r, tree name, basic_block bb = NULL);\n+  void entry_range (vrange &r, tree expr, basic_block bb, enum rfd_mode);\n+  void exit_range (vrange &r, tree expr, basic_block bb, enum rfd_mode);\n+  bool edge_range (vrange &r, edge e, tree name, enum rfd_mode);\n \n   vec<basic_block> m_workback;\n   class update_list *m_update;"}, {"sha": "6fe33408f7ecc7ed029bd34014c5bc13456fe146", "filename": "gcc/gimple-range-edge.cc", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-edge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-edge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-edge.cc?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -83,11 +83,8 @@ gimple_outgoing_range::~gimple_outgoing_range ()\n // Use a cached value if it exists, or calculate it if not.\n \n bool\n-gimple_outgoing_range::get_edge_range (irange &r, gimple *s, edge e)\n+gimple_outgoing_range::switch_edge_range (irange &r, gswitch *sw, edge e)\n {\n-  gcc_checking_assert (is_a<gswitch *> (s));\n-  gswitch *sw = as_a<gswitch *> (s);\n-\n   // ADA currently has cases where the index is 64 bits and the case\n   // arguments are 32 bit, causing a trap when we create a case_range.\n   // Until this is resolved (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=87798)\n@@ -204,12 +201,9 @@ gimple_outgoing_range::edge_range_p (irange &r, edge e)\n \n   gcc_checking_assert (is_a<gswitch *> (s));\n   gswitch *sw = as_a<gswitch *> (s);\n-  tree type = TREE_TYPE (gimple_switch_index (sw));\n-\n-  if (!irange::supports_type_p (type))\n-    return NULL;\n \n-  if (get_edge_range (r, sw, e))\n+  // Switches can only be integers.\n+  if (switch_edge_range (as_a <irange> (r), sw, e))\n     return s;\n \n   return NULL;"}, {"sha": "a9c4af8715bef72a3710f300299e3970ac21de92", "filename": "gcc/gimple-range-edge.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-edge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-edge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-edge.h?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -43,7 +43,7 @@ class gimple_outgoing_range\n   gimple *edge_range_p (irange &r, edge e);\n private:\n   void calc_switch_ranges (gswitch *sw);\n-  bool get_edge_range (irange &r, gimple *s, edge e);\n+  bool switch_edge_range (irange &r, gswitch *sw, edge e);\n \n   int m_max_edges;\n   hash_map<edge, irange *> *m_edge_table;"}, {"sha": "c1a801668c44e1aceb2c23d784bc49a419183ce3", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 82, "deletions": 59, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -60,7 +60,7 @@ fur_source::fur_source (range_query *q)\n // Invoke range_of_expr on EXPR.\n \n bool\n-fur_source::get_operand (irange &r, tree expr)\n+fur_source::get_operand (vrange &r, tree expr)\n {\n   return m_query->range_of_expr (r, expr);\n }\n@@ -69,7 +69,7 @@ fur_source::get_operand (irange &r, tree expr)\n // range_query to get the range on the edge.\n \n bool\n-fur_source::get_phi_operand (irange &r, tree expr, edge e)\n+fur_source::get_phi_operand (vrange &r, tree expr, edge e)\n {\n   return m_query->range_on_edge (r, e, expr);\n }\n@@ -109,8 +109,8 @@ class fur_edge : public fur_source\n {\n public:\n   fur_edge (edge e, range_query *q = NULL);\n-  virtual bool get_operand (irange &r, tree expr) override;\n-  virtual bool get_phi_operand (irange &r, tree expr, edge e) override;\n+  virtual bool get_operand (vrange &r, tree expr) override;\n+  virtual bool get_phi_operand (vrange &r, tree expr, edge e) override;\n private:\n   edge m_edge;\n };\n@@ -126,7 +126,7 @@ fur_edge::fur_edge (edge e, range_query *q) : fur_source (q)\n // Get the value of EXPR on edge m_edge.\n \n bool\n-fur_edge::get_operand (irange &r, tree expr)\n+fur_edge::get_operand (vrange &r, tree expr)\n {\n   return m_query->range_on_edge (r, m_edge, expr);\n }\n@@ -135,7 +135,7 @@ fur_edge::get_operand (irange &r, tree expr)\n // range_query to get the range on the edge.\n \n bool\n-fur_edge::get_phi_operand (irange &r, tree expr, edge e)\n+fur_edge::get_phi_operand (vrange &r, tree expr, edge e)\n {\n   // Edge to edge recalculations not supoprted yet, until we sort it out.\n   gcc_checking_assert (e == m_edge);\n@@ -152,7 +152,7 @@ fur_stmt::fur_stmt (gimple *s, range_query *q) : fur_source (q)\n // Retreive range of EXPR as it occurs as a use on stmt M_STMT.\n \n bool\n-fur_stmt::get_operand (irange &r, tree expr)\n+fur_stmt::get_operand (vrange &r, tree expr)\n {\n   return m_query->range_of_expr (r, expr, m_stmt);\n }\n@@ -161,7 +161,7 @@ fur_stmt::get_operand (irange &r, tree expr)\n // range_query to get the range on the edge.\n \n bool\n-fur_stmt::get_phi_operand (irange &r, tree expr, edge e)\n+fur_stmt::get_phi_operand (vrange &r, tree expr, edge e)\n {\n   // Pick up the range of expr from edge E.\n   fur_edge e_src (e, m_query);\n@@ -214,42 +214,42 @@ fur_depend::register_relation (edge e, relation_kind k, tree op1, tree op2)\n class fur_list : public fur_source\n {\n public:\n-  fur_list (irange &r1);\n-  fur_list (irange &r1, irange &r2);\n-  fur_list (unsigned num, irange *list);\n-  virtual bool get_operand (irange &r, tree expr) override;\n-  virtual bool get_phi_operand (irange &r, tree expr, edge e) override;\n+  fur_list (vrange &r1);\n+  fur_list (vrange &r1, vrange &r2);\n+  fur_list (unsigned num, vrange **list);\n+  virtual bool get_operand (vrange &r, tree expr) override;\n+  virtual bool get_phi_operand (vrange &r, tree expr, edge e) override;\n private:\n-  int_range_max m_local[2];\n-  irange *m_list;\n+  vrange *m_local[2];\n+  vrange **m_list;\n   unsigned m_index;\n   unsigned m_limit;\n };\n \n // One range supplied for unary operations.\n \n-fur_list::fur_list (irange &r1) : fur_source (NULL)\n+fur_list::fur_list (vrange &r1) : fur_source (NULL)\n {\n   m_list = m_local;\n   m_index = 0;\n   m_limit = 1;\n-  m_local[0] = r1;\n+  m_local[0] = &r1;\n }\n \n // Two ranges supplied for binary operations.\n \n-fur_list::fur_list (irange &r1, irange &r2) : fur_source (NULL)\n+fur_list::fur_list (vrange &r1, vrange &r2) : fur_source (NULL)\n {\n   m_list = m_local;\n   m_index = 0;\n   m_limit = 2;\n-  m_local[0] = r1;\n-  m_local[1] = r2;\n+  m_local[0] = &r1;\n+  m_local[1] = &r2;\n }\n \n // Arbitrary number of ranges in a vector.\n \n-fur_list::fur_list (unsigned num, irange *list) : fur_source (NULL)\n+fur_list::fur_list (unsigned num, vrange **list) : fur_source (NULL)\n {\n   m_list = list;\n   m_index = 0;\n@@ -259,26 +259,26 @@ fur_list::fur_list (unsigned num, irange *list) : fur_source (NULL)\n // Get the next operand from the vector, ensure types are compatible.\n \n bool\n-fur_list::get_operand (irange &r, tree expr)\n+fur_list::get_operand (vrange &r, tree expr)\n {\n   if (m_index >= m_limit)\n     return m_query->range_of_expr (r, expr);\n-  r = m_list[m_index++];\n+  r = *m_list[m_index++];\n   gcc_checking_assert (range_compatible_p (TREE_TYPE (expr), r.type ()));\n   return true;\n }\n \n // This will simply pick the next operand from the vector.\n bool\n-fur_list::get_phi_operand (irange &r, tree expr, edge e ATTRIBUTE_UNUSED)\n+fur_list::get_phi_operand (vrange &r, tree expr, edge e ATTRIBUTE_UNUSED)\n {\n   return get_operand (r, expr);\n }\n \n // Fold stmt S into range R using R1 as the first operand.\n \n bool\n-fold_range (irange &r, gimple *s, irange &r1)\n+fold_range (vrange &r, gimple *s, vrange &r1)\n {\n   fold_using_range f;\n   fur_list src (r1);\n@@ -288,7 +288,7 @@ fold_range (irange &r, gimple *s, irange &r1)\n // Fold stmt S into range R using R1  and R2 as the first two operands.\n \n bool\n-fold_range (irange &r, gimple *s, irange &r1, irange &r2)\n+fold_range (vrange &r, gimple *s, vrange &r1, vrange &r2)\n {\n   fold_using_range f;\n   fur_list src (r1, r2);\n@@ -299,7 +299,7 @@ fold_range (irange &r, gimple *s, irange &r1, irange &r2)\n // operands encountered.\n \n bool\n-fold_range (irange &r, gimple *s, unsigned num_elements, irange *vector)\n+fold_range (vrange &r, gimple *s, unsigned num_elements, vrange **vector)\n {\n   fold_using_range f;\n   fur_list src (num_elements, vector);\n@@ -309,7 +309,7 @@ fold_range (irange &r, gimple *s, unsigned num_elements, irange *vector)\n // Fold stmt S into range R using range query Q.\n \n bool\n-fold_range (irange &r, gimple *s, range_query *q)\n+fold_range (vrange &r, gimple *s, range_query *q)\n {\n   fold_using_range f;\n   fur_stmt src (s, q);\n@@ -319,7 +319,7 @@ fold_range (irange &r, gimple *s, range_query *q)\n // Recalculate stmt S into R using range query Q as if it were on edge ON_EDGE.\n \n bool\n-fold_range (irange &r, gimple *s, edge on_edge, range_query *q)\n+fold_range (vrange &r, gimple *s, edge on_edge, range_query *q)\n {\n   fold_using_range f;\n   fur_edge src (on_edge, q);\n@@ -370,7 +370,7 @@ adjust_pointer_diff_expr (irange &res, const gimple *diff_stmt)\n // Adjust the range for an IMAGPART_EXPR.\n \n static void\n-adjust_imagpart_expr (irange &res, const gimple *stmt)\n+adjust_imagpart_expr (vrange &res, const gimple *stmt)\n {\n   tree name = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);\n \n@@ -413,7 +413,7 @@ adjust_imagpart_expr (irange &res, const gimple *stmt)\n // Adjust the range for a REALPART_EXPR.\n \n static void\n-adjust_realpart_expr (irange &res, const gimple *stmt)\n+adjust_realpart_expr (vrange &res, const gimple *stmt)\n {\n   tree name = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);\n \n@@ -442,12 +442,12 @@ adjust_realpart_expr (irange &res, const gimple *stmt)\n // this statement.\n \n static void\n-gimple_range_adjustment (irange &res, const gimple *stmt)\n+gimple_range_adjustment (vrange &res, const gimple *stmt)\n {\n   switch (gimple_expr_code (stmt))\n     {\n     case POINTER_DIFF_EXPR:\n-      adjust_pointer_diff_expr (res, stmt);\n+      adjust_pointer_diff_expr (as_a <irange> (res), stmt);\n       return;\n \n     case IMAGPART_EXPR:\n@@ -536,7 +536,7 @@ gimple_range_operand2 (const gimple *stmt)\n // be calculated, return false.\n \n bool\n-fold_using_range::fold_stmt (irange &r, gimple *s, fur_source &src, tree name)\n+fold_using_range::fold_stmt (vrange &r, gimple *s, fur_source &src, tree name)\n {\n   bool res = false;\n   // If name and S are specified, make sure it is an LHS of S.\n@@ -549,7 +549,7 @@ fold_using_range::fold_stmt (irange &r, gimple *s, fur_source &src, tree name)\n   // Process addresses.\n   if (gimple_code (s) == GIMPLE_ASSIGN\n       && gimple_assign_rhs_code (s) == ADDR_EXPR)\n-    return range_of_address (r, s, src);\n+    return range_of_address (as_a <irange> (r), s, src);\n \n   if (range_op_handler (s))\n     res = range_of_range_op (r, s, src);\n@@ -566,7 +566,7 @@ fold_using_range::fold_stmt (irange &r, gimple *s, fur_source &src, tree name)\n       if (!name || !gimple_range_ssa_p (name))\n \treturn false;\n       // We don't understand the stmt, so return the global range.\n-      r = gimple_range_global (name);\n+      gimple_range_global (r, name);\n       return true;\n     }\n \n@@ -587,9 +587,8 @@ fold_using_range::fold_stmt (irange &r, gimple *s, fur_source &src, tree name)\n // If a range cannot be calculated, return false.\n \n bool\n-fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n+fold_using_range::range_of_range_op (vrange &r, gimple *s, fur_source &src)\n {\n-  int_range_max range1, range2;\n   tree type = gimple_range_type (s);\n   if (!type)\n     return false;\n@@ -599,13 +598,16 @@ fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n   tree lhs = gimple_get_lhs (s);\n   tree op1 = gimple_range_operand1 (s);\n   tree op2 = gimple_range_operand2 (s);\n+  Value_Range range1 (TREE_TYPE (op1));\n+  Value_Range range2 (op2 ? TREE_TYPE (op2) : TREE_TYPE (op1));\n \n   if (src.get_operand (range1, op1))\n     {\n       if (!op2)\n \t{\n \t  // Fold range, and register any dependency if available.\n-\t  int_range<2> r2 (type);\n+\t  Value_Range r2 (type);\n+\t  r2.set_varying (type);\n \t  handler.fold_range (r, type, range1, r2);\n \t  if (lhs && gimple_range_ssa_p (op1))\n \t    {\n@@ -630,7 +632,8 @@ fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n \t    }\n \t  // Fold range, and register any dependency if available.\n \t  handler.fold_range (r, type, range1, range2, rel);\n-\t  relation_fold_and_or (r, s, src);\n+\t  if (irange::supports_type_p (type))\n+\t    relation_fold_and_or (as_a <irange> (r), s, src);\n \t  if (lhs)\n \t    {\n \t      if (src.gori ())\n@@ -663,7 +666,8 @@ fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n \t\te0 = NULL;\n \t      if (!single_pred_p (e1->dest))\n \t\te1 = NULL;\n-\t      src.register_outgoing_edges (as_a<gcond *> (s), r, e0, e1);\n+\t      src.register_outgoing_edges (as_a<gcond *> (s),\n+\t\t\t\t\t   as_a <irange> (r), e0, e1);\n \t    }\n \t}\n       else\n@@ -729,12 +733,12 @@ fold_using_range::range_of_address (irange &r, gimple *stmt, fur_source &src)\n \t{\n \t  /* For -fdelete-null-pointer-checks -fno-wrapv-pointer we don't\n \t     allow going from non-NULL pointer to NULL.  */\n-\t  if (!range_includes_zero_p (&r))\n+\t  if (r.undefined_p () || !r.contains_p (build_zero_cst (r.type ())))\n \t    {\n \t      /* We could here instead adjust r by off >> LOG2_BITS_PER_UNIT\n \t\t using POINTER_PLUS_EXPR if off_cst and just fall back to\n \t\t this.  */\n-\t      r = range_nonzero (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n+\t      r.set_nonzero (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n \t      return true;\n \t    }\n \t}\n@@ -746,35 +750,35 @@ fold_using_range::range_of_address (irange &r, gimple *stmt, fur_source &src)\n \t  && known_ne (off, 0)\n \t  && (flag_delete_null_pointer_checks || known_gt (off, 0)))\n \t{\n-\t  r = range_nonzero (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n+\t  r.set_nonzero (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n \t  return true;\n \t}\n-      r = int_range<2> (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n+      r.set_varying (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n       return true;\n     }\n \n   // Handle \"= &a\".\n   if (tree_single_nonzero_warnv_p (expr, &strict_overflow_p))\n     {\n-      r = range_nonzero (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n+      r.set_nonzero (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n       return true;\n     }\n \n   // Otherwise return varying.\n-  r = int_range<2> (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n+  r.set_varying (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n   return true;\n }\n \n // Calculate a range for phi statement S and return it in R.\n // If a range cannot be calculated, return false.\n \n bool\n-fold_using_range::range_of_phi (irange &r, gphi *phi, fur_source &src)\n+fold_using_range::range_of_phi (vrange &r, gphi *phi, fur_source &src)\n {\n   tree phi_def = gimple_phi_result (phi);\n   tree type = gimple_range_type (phi);\n-  int_range_max arg_range;\n-  int_range_max equiv_range;\n+  Value_Range arg_range (type);\n+  Value_Range equiv_range (type);\n   unsigned x;\n \n   if (!type)\n@@ -881,7 +885,7 @@ fold_using_range::range_of_phi (irange &r, gphi *phi, fur_source &src)\n // If a range cannot be calculated, return false.\n \n bool\n-fold_using_range::range_of_call (irange &r, gcall *call, fur_source &src)\n+fold_using_range::range_of_call (vrange &r, gcall *call, fur_source &src)\n {\n   tree type = gimple_range_type (call);\n   if (!type)\n@@ -893,18 +897,18 @@ fold_using_range::range_of_call (irange &r, gcall *call, fur_source &src)\n   if (range_of_builtin_call (r, call, src))\n     ;\n   else if (gimple_stmt_nonnegative_warnv_p (call, &strict_overflow_p))\n-    r.set (build_int_cst (type, 0), TYPE_MAX_VALUE (type));\n+    r.set_nonnegative (type);\n   else if (gimple_call_nonnull_result_p (call)\n \t   || gimple_call_nonnull_arg (call))\n-    r = range_nonzero (type);\n+    r.set_nonzero (type);\n   else\n     r.set_varying (type);\n \n   // If there is an LHS, intersect that with what is known.\n   if (lhs)\n     {\n-      value_range def;\n-      def = gimple_range_global (lhs);\n+      Value_Range def (TREE_TYPE (lhs));\n+      gimple_range_global (def, lhs);\n       r.intersect (def);\n     }\n   return true;\n@@ -971,13 +975,30 @@ get_letter_range (tree type, irange &lowers, irange &uppers)\n // TRUE.  Otherwise return FALSE.\n \n bool\n-fold_using_range::range_of_builtin_call (irange &r, gcall *call,\n+fold_using_range::range_of_builtin_call (vrange &r, gcall *call,\n \t\t\t\t\t fur_source &src)\n {\n   combined_fn func = gimple_call_combined_fn (call);\n   if (func == CFN_LAST)\n     return false;\n \n+  tree type = gimple_range_type (call);\n+  gcc_checking_assert (type);\n+\n+  if (irange::supports_type_p (type))\n+    return range_of_builtin_int_call (as_a <irange> (r), call, src);\n+\n+  return false;\n+}\n+\n+bool\n+fold_using_range::range_of_builtin_int_call (irange &r, gcall *call,\n+\t\t\t\t\t     fur_source &src)\n+{\n+  combined_fn func = gimple_call_combined_fn (call);\n+  if (func == CFN_LAST)\n+    return false;\n+\n   tree type = gimple_range_type (call);\n   tree arg;\n   int mini, maxi, zerov = 0, prec;\n@@ -1256,9 +1277,8 @@ fold_using_range::range_of_builtin_call (irange &r, gcall *call,\n // If a range cannot be calculated, return false.\n \n bool\n-fold_using_range::range_of_cond_expr  (irange &r, gassign *s, fur_source &src)\n+fold_using_range::range_of_cond_expr  (vrange &r, gassign *s, fur_source &src)\n {\n-  int_range_max cond_range, range1, range2;\n   tree cond = gimple_assign_rhs1 (s);\n   tree op1 = gimple_assign_rhs2 (s);\n   tree op2 = gimple_assign_rhs3 (s);\n@@ -1267,6 +1287,9 @@ fold_using_range::range_of_cond_expr  (irange &r, gassign *s, fur_source &src)\n   if (!type)\n     return false;\n \n+  Value_Range range1 (TREE_TYPE (op1));\n+  Value_Range range2 (TREE_TYPE (op2));\n+  Value_Range cond_range (TREE_TYPE (cond));\n   gcc_checking_assert (gimple_assign_rhs_code (s) == COND_EXPR);\n   gcc_checking_assert (range_compatible_p (TREE_TYPE (op1), TREE_TYPE (op2)));\n   src.get_operand (cond_range, cond);\n@@ -1438,7 +1461,6 @@ fold_using_range::relation_fold_and_or (irange& lhs_range, gimple *s,\n void\n fur_source::register_outgoing_edges (gcond *s, irange &lhs_range, edge e0, edge e1)\n {\n-  int_range_max r;\n   int_range<2> e0_range, e1_range;\n   tree name;\n   basic_block bb = gimple_bb (s);\n@@ -1505,6 +1527,7 @@ fur_source::register_outgoing_edges (gcond *s, irange &lhs_range, edge e0, edge\n \tcontinue;\n       tree ssa1 = gimple_range_ssa_p (gimple_range_operand1 (stmt));\n       tree ssa2 = gimple_range_ssa_p (gimple_range_operand2 (stmt));\n+      Value_Range r (TREE_TYPE (name));\n       if (ssa1 && ssa2)\n \t{\n \t  if (e0 && gori ()->outgoing_edge_range_p (r, e0, name, *m_query)"}, {"sha": "df24280ee4076fbcf1a3ca6131123d4564a9c700", "filename": "gcc/gimple-range-fold.h", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.h?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -23,23 +23,23 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_GIMPLE_RANGE_FOLD_H\n \n // This file is the main include point for gimple range folding.\n-// These routines will fold stmt S into the result irange R.\n+// These routines will fold stmt S into the result range R.\n // Any ssa_names on the stmt will be calculated using the range_query\n // parameter via a call to range_of_expr.\n // If no range_query is provided, current global range info will be used.\n // The second variation specifies an edge, and stmt S is recalculated as if\n // it appeared on that edge.\n \n // Fold stmt S into range R using range query Q.\n-bool fold_range (irange &r, gimple *s, range_query *q = NULL);\n+bool fold_range (vrange &r, gimple *s, range_query *q = NULL);\n // Recalculate stmt S into R using range query Q as if it were on edge ON_EDGE.\n-bool fold_range (irange &r, gimple *s, edge on_edge, range_query *q = NULL);\n+bool fold_range (vrange &v, gimple *s, edge on_edge, range_query *q = NULL);\n \n // These routines the operands to be specified when manually folding.\n // Any excess queries will be drawn from the current range_query.\n-bool fold_range (irange &r, gimple *s, irange &r1);\n-bool fold_range (irange &r, gimple *s, irange &r1, irange &r2);\n-bool fold_range (irange &r, gimple *s, unsigned num_elements, irange *vector);\n+bool fold_range (vrange &r, gimple *s, vrange &r1);\n+bool fold_range (vrange &r, gimple *s, vrange &r1, vrange &r2);\n+bool fold_range (vrange &r, gimple *s, unsigned num_elements, vrange **vector);\n \n // Return the type of range which statement S calculates.  If the type is\n // unsupported or no type can be determined, return NULL_TREE.\n@@ -66,7 +66,7 @@ gimple_range_type (const gimple *s)\n \t    type = TREE_TYPE (type);\n \t}\n     }\n-  if (type && irange::supports_type_p (type))\n+  if (type && vrange::supports_type_p (type))\n     return type;\n   return NULL_TREE;\n }\n@@ -79,7 +79,7 @@ gimple_range_ssa_p (tree exp)\n   if (exp && TREE_CODE (exp) == SSA_NAME &&\n       !SSA_NAME_IS_VIRTUAL_OPERAND (exp) &&\n       !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (exp) &&\n-      irange::supports_type_p (TREE_TYPE (exp)))\n+      vrange::supports_type_p (TREE_TYPE (exp)))\n     return exp;\n   return NULL_TREE;\n }\n@@ -108,8 +108,8 @@ class fur_source\n   fur_source (range_query *q = NULL);\n   inline range_query *query () { return m_query; }\n   inline class gori_compute *gori () { return m_gori; };\n-  virtual bool get_operand (irange &r, tree expr);\n-  virtual bool get_phi_operand (irange &r, tree expr, edge e);\n+  virtual bool get_operand (vrange &r, tree expr);\n+  virtual bool get_phi_operand (vrange &r, tree expr, edge e);\n   virtual relation_kind query_relation (tree op1, tree op2);\n   virtual void register_relation (gimple *stmt, relation_kind k, tree op1,\n \t\t\t\t  tree op2);\n@@ -128,8 +128,8 @@ class fur_stmt : public fur_source\n {\n public:\n   fur_stmt (gimple *s, range_query *q = NULL);\n-  virtual bool get_operand (irange &r, tree expr) override;\n-  virtual bool get_phi_operand (irange &r, tree expr, edge e) override;\n+  virtual bool get_operand (vrange &r, tree expr) override;\n+  virtual bool get_phi_operand (vrange &r, tree expr, edge e) override;\n   virtual relation_kind query_relation (tree op1, tree op2) override;\n private:\n   gimple *m_stmt;\n@@ -161,17 +161,18 @@ extern tree gimple_range_operand2 (const gimple *s);\n class fold_using_range\n {\n public:\n-  bool fold_stmt (irange &r, gimple *s, class fur_source &src,\n+  bool fold_stmt (vrange &r, gimple *s, class fur_source &src,\n \t\t  tree name = NULL_TREE);\n protected:\n-  bool range_of_range_op (irange &r, gimple *s, fur_source &src);\n-  bool range_of_call (irange &r, gcall *call, fur_source &src);\n-  bool range_of_cond_expr (irange &r, gassign* cond, fur_source &src);\n+  bool range_of_range_op (vrange &r, gimple *s, fur_source &src);\n+  bool range_of_call (vrange &r, gcall *call, fur_source &src);\n+  bool range_of_cond_expr (vrange &r, gassign* cond, fur_source &src);\n   bool range_of_address (irange &r, gimple *s, fur_source &src);\n-  bool range_of_builtin_call (irange &r, gcall *call, fur_source &src);\n+  bool range_of_builtin_call (vrange &r, gcall *call, fur_source &src);\n+  bool range_of_builtin_int_call (irange &r, gcall *call, fur_source &src);\n   void range_of_builtin_ubsan_call (irange &r, gcall *call, tree_code code,\n \t\t\t\t    fur_source &src);\n-  bool range_of_phi (irange &r, gphi *phi, fur_source &src);\n+  bool range_of_phi (vrange &r, gphi *phi, fur_source &src);\n   void range_of_ssa_name_with_loop_info (irange &, tree, class loop *, gphi *,\n \t\t\t\t\t fur_source &src);\n   void relation_fold_and_or (irange& lhs_range, gimple *s, fur_source &src);"}, {"sha": "0a3e54eae4e8b63d29682da3f00f920a556d1df4", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 65, "deletions": 50, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -34,7 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n // LHS_RANGE.  Return false if nothing can be determined.\n \n bool\n-gimple_range_calc_op1 (irange &r, const gimple *stmt, const irange &lhs_range)\n+gimple_range_calc_op1 (vrange &r, const gimple *stmt, const vrange &lhs_range)\n {\n   gcc_checking_assert (gimple_num_ops (stmt) < 3);\n   // Give up on empty ranges.\n@@ -55,8 +55,8 @@ gimple_range_calc_op1 (irange &r, const gimple *stmt, const irange &lhs_range)\n // nothing can be determined.\n \n bool\n-gimple_range_calc_op1 (irange &r, const gimple *stmt,\n-\t\t       const irange &lhs_range, const irange &op2_range)\n+gimple_range_calc_op1 (vrange &r, const gimple *stmt,\n+\t\t       const vrange &lhs_range, const vrange &op2_range)\n {\n   // Give up on empty ranges.\n   if (lhs_range.undefined_p ())\n@@ -86,8 +86,8 @@ gimple_range_calc_op1 (irange &r, const gimple *stmt,\n // nothing can be determined.\n \n bool\n-gimple_range_calc_op2 (irange &r, const gimple *stmt,\n-\t\t       const irange &lhs_range, const irange &op1_range)\n+gimple_range_calc_op2 (vrange &r, const gimple *stmt,\n+\t\t       const vrange &lhs_range, const vrange &op1_range)\n {\n   // Give up on empty ranges.\n   if (lhs_range.undefined_p ())\n@@ -663,8 +663,8 @@ gori_compute::gori_compute (int not_executable_flag)\n // was not resolvable.\n \n bool\n-gori_compute::compute_operand_range_switch (irange &r, gswitch *s,\n-\t\t\t\t\t    const irange &lhs,\n+gori_compute::compute_operand_range_switch (vrange &r, gswitch *s,\n+\t\t\t\t\t    const vrange &lhs,\n \t\t\t\t\t    tree name, fur_source &src)\n {\n   tree op1 = gimple_switch_index (s);\n@@ -691,8 +691,8 @@ gori_compute::compute_operand_range_switch (irange &r, gswitch *s,\n // store the evaluation in R, otherwise return FALSE.\n \n bool\n-gori_compute::compute_operand_range (irange &r, gimple *stmt,\n-\t\t\t\t     const irange &lhs, tree name,\n+gori_compute::compute_operand_range (vrange &r, gimple *stmt,\n+\t\t\t\t     const vrange &lhs, tree name,\n \t\t\t\t     fur_source &src)\n {\n   // If the lhs doesn't tell us anything, neither will unwinding further.\n@@ -743,13 +743,18 @@ gori_compute::compute_operand_range (irange &r, gimple *stmt,\n \t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n \t}\n \n-      int_range_max op1_trange, op1_frange;\n-      int_range_max op2_trange, op2_frange;\n-      compute_logical_operands (op1_trange, op1_frange, stmt, lhs,\n+      tree type = TREE_TYPE (name);\n+      Value_Range op1_trange (type), op1_frange (type);\n+      Value_Range op2_trange (type), op2_frange (type);\n+      compute_logical_operands (op1_trange, op1_frange, stmt,\n+\t\t\t\tas_a <irange> (lhs),\n \t\t\t\tname, src, op1, op1_in_chain);\n-      compute_logical_operands (op2_trange, op2_frange, stmt, lhs,\n+      compute_logical_operands (op2_trange, op2_frange, stmt,\n+\t\t\t\tas_a <irange> (lhs),\n \t\t\t\tname, src, op2, op2_in_chain);\n-      res = logical_combine (r, gimple_expr_code (stmt), lhs,\n+      res = logical_combine (r,\n+\t\t\t     gimple_expr_code (stmt),\n+\t\t\t     as_a <irange> (lhs),\n \t\t\t     op1_trange, op1_frange, op2_trange, op2_frange);\n       if (idx)\n \ttracer.trailer (idx, \"compute_operand\", res, name, r);\n@@ -789,10 +794,10 @@ range_is_either_true_or_false (const irange &r)\n // the LHS.\n \n bool\n-gori_compute::logical_combine (irange &r, enum tree_code code,\n+gori_compute::logical_combine (vrange &r, enum tree_code code,\n \t\t\t       const irange &lhs,\n-\t\t\t       const irange &op1_true, const irange &op1_false,\n-\t\t\t       const irange &op2_true, const irange &op2_false)\n+\t\t\t       const vrange &op1_true, const vrange &op1_false,\n+\t\t\t       const vrange &op2_true, const vrange &op2_false)\n {\n   if (op1_true.varying_p () && op1_false.varying_p ()\n       && op2_true.varying_p () && op2_false.varying_p ())\n@@ -868,7 +873,7 @@ gori_compute::logical_combine (irange &r, enum tree_code code,\n   if (!range_is_either_true_or_false (lhs))\n     {\n       bool res;\n-      int_range_max r1;\n+      Value_Range r1 (r);\n       if (logical_combine (r1, code, m_bool_zero, op1_true, op1_false,\n \t\t\t   op2_true, op2_false)\n \t  && logical_combine (r, code, m_bool_one, op1_true, op1_false,\n@@ -898,11 +903,11 @@ gori_compute::logical_combine (irange &r, enum tree_code code,\n \telse\n \t  {\n \t    // The FALSE side is the union of the other 3 cases.\n-\t    int_range_max ff (op1_false);\n+\t    Value_Range ff (op1_false);\n \t    ff.intersect (op2_false);\n-\t    int_range_max tf (op1_true);\n+\t    Value_Range tf (op1_true);\n \t    tf.intersect (op2_false);\n-\t    int_range_max ft (op1_false);\n+\t    Value_Range ft (op1_false);\n \t    ft.intersect (op2_true);\n \t    r = ff;\n \t    r.union_ (tf);\n@@ -925,11 +930,11 @@ gori_compute::logical_combine (irange &r, enum tree_code code,\n \t  {\n \t    // The TRUE side of an OR operation will be the union of\n \t    // the other three combinations.\n-\t    int_range_max tt (op1_true);\n+\t    Value_Range tt (op1_true);\n \t    tt.intersect (op2_true);\n-\t    int_range_max tf (op1_true);\n+\t    Value_Range tf (op1_true);\n \t    tf.intersect (op2_false);\n-\t    int_range_max ft (op1_false);\n+\t    Value_Range ft (op1_false);\n \t    ft.intersect (op2_true);\n \t    r = tt;\n \t    r.union_ (tf);\n@@ -951,7 +956,7 @@ gori_compute::logical_combine (irange &r, enum tree_code code,\n // OP_IN_CHAIN is true.\n \n void\n-gori_compute::compute_logical_operands (irange &true_range, irange &false_range,\n+gori_compute::compute_logical_operands (vrange &true_range, vrange &false_range,\n \t\t\t\t\tgimple *stmt,\n \t\t\t\t\tconst irange &lhs,\n \t\t\t\t\ttree name, fur_source &src,\n@@ -1007,13 +1012,15 @@ gori_compute::compute_logical_operands (irange &true_range, irange &false_range,\n // R, or false if no range could be calculated.\n \n bool\n-gori_compute::compute_operand1_range (irange &r, gimple *stmt,\n-\t\t\t\t      const irange &lhs, tree name,\n+gori_compute::compute_operand1_range (vrange &r, gimple *stmt,\n+\t\t\t\t      const vrange &lhs, tree name,\n \t\t\t\t      fur_source &src)\n {\n-  int_range_max op1_range, op2_range;\n   tree op1 = gimple_range_operand1 (stmt);\n   tree op2 = gimple_range_operand2 (stmt);\n+  Value_Range op1_range (TREE_TYPE (op1));\n+  Value_Range tmp (TREE_TYPE (op1));\n+  Value_Range op2_range (op2 ? TREE_TYPE (op2) : TREE_TYPE (op1));\n \n   // Fetch the known range for op1 in this block.\n   src.get_operand (op1_range, op1);\n@@ -1022,15 +1029,15 @@ gori_compute::compute_operand1_range (irange &r, gimple *stmt,\n   if (op2)\n     {\n       src.get_operand (op2_range, op2);\n-      if (!gimple_range_calc_op1 (r, stmt, lhs, op2_range))\n+      if (!gimple_range_calc_op1 (tmp, stmt, lhs, op2_range))\n \treturn false;\n     }\n   else\n     {\n       // We pass op1_range to the unary operation.  Nomally it's a\n       // hidden range_for_type parameter, but sometimes having the\n       // actual range can result in better information.\n-      if (!gimple_range_calc_op1 (r, stmt, lhs, op1_range))\n+      if (!gimple_range_calc_op1 (tmp, stmt, lhs, op1_range))\n \treturn false;\n     }\n \n@@ -1053,21 +1060,22 @@ gori_compute::compute_operand1_range (irange &r, gimple *stmt,\n       tracer.print (idx, \"Computes \");\n       print_generic_expr (dump_file, op1, TDF_SLIM);\n       fprintf (dump_file, \" = \");\n-      r.dump (dump_file);\n+      tmp.dump (dump_file);\n       fprintf (dump_file, \" intersect Known range : \");\n       op1_range.dump (dump_file);\n       fputc ('\\n', dump_file);\n     }\n   // Intersect the calculated result with the known result and return if done.\n   if (op1 == name)\n     {\n-      r.intersect (op1_range);\n+      tmp.intersect (op1_range);\n+      r = tmp;\n       if (idx)\n \ttracer.trailer (idx, \"produces \", true, name, r);\n       return true;\n     }\n   // If the calculation continues, we're using op1_range as the new LHS.\n-  op1_range.intersect (r);\n+  op1_range.intersect (tmp);\n \n   if (idx)\n     tracer.trailer (idx, \"produces \", true, op1, op1_range);\n@@ -1084,19 +1092,21 @@ gori_compute::compute_operand1_range (irange &r, gimple *stmt,\n // R, or false if no range could be calculated.\n \n bool\n-gori_compute::compute_operand2_range (irange &r, gimple *stmt,\n-\t\t\t\t      const irange &lhs, tree name,\n+gori_compute::compute_operand2_range (vrange &r, gimple *stmt,\n+\t\t\t\t      const vrange &lhs, tree name,\n \t\t\t\t      fur_source &src)\n {\n-  int_range_max op1_range, op2_range;\n   tree op1 = gimple_range_operand1 (stmt);\n   tree op2 = gimple_range_operand2 (stmt);\n+  Value_Range op1_range (TREE_TYPE (op1));\n+  Value_Range op2_range (TREE_TYPE (op2));\n+  Value_Range tmp (TREE_TYPE (op2));\n \n   src.get_operand (op1_range, op1);\n   src.get_operand (op2_range, op2);\n \n   // Intersect with range for op2 based on lhs and op1.\n-  if (!gimple_range_calc_op2 (r, stmt, lhs, op1_range))\n+  if (!gimple_range_calc_op2 (tmp, stmt, lhs, op1_range))\n     return false;\n \n   unsigned idx;\n@@ -1118,21 +1128,22 @@ gori_compute::compute_operand2_range (irange &r, gimple *stmt,\n       tracer.print (idx, \"Computes \");\n       print_generic_expr (dump_file, op2, TDF_SLIM);\n       fprintf (dump_file, \" = \");\n-      r.dump (dump_file);\n+      tmp.dump (dump_file);\n       fprintf (dump_file, \" intersect Known range : \");\n       op2_range.dump (dump_file);\n       fputc ('\\n', dump_file);\n     }\n   // Intersect the calculated result with the known result and return if done.\n   if (op2 == name)\n     {\n-      r.intersect (op2_range);\n+      tmp.intersect (op2_range);\n+      r = tmp;\n       if (idx)\n \ttracer.trailer (idx, \" produces \", true, NULL_TREE, r);\n       return true;\n     }\n   // If the calculation continues, we're using op2_range as the new LHS.\n-  op2_range.intersect (r);\n+  op2_range.intersect (tmp);\n \n   if (idx)\n     tracer.trailer (idx, \" produces \", true, op2, op2_range);\n@@ -1149,13 +1160,13 @@ gori_compute::compute_operand2_range (irange &r, gimple *stmt,\n // R, or false if no range could be calculated.\n \n bool\n-gori_compute::compute_operand1_and_operand2_range (irange &r,\n+gori_compute::compute_operand1_and_operand2_range (vrange &r,\n \t\t\t\t\t\t   gimple *stmt,\n-\t\t\t\t\t\t   const irange &lhs,\n+\t\t\t\t\t\t   const vrange &lhs,\n \t\t\t\t\t\t   tree name,\n \t\t\t\t\t\t   fur_source &src)\n {\n-  int_range_max op_range;\n+  Value_Range op_range (TREE_TYPE (name));\n \n   // Calculate a good a range for op2.  Since op1 == op2, this will\n   // have already included whatever the actual range of name is.\n@@ -1236,10 +1247,9 @@ gori_compute::has_edge_range_p (tree name, edge e)\n // control edge or NAME is not defined by this edge.\n \n bool\n-gori_compute::outgoing_edge_range_p (irange &r, edge e, tree name,\n+gori_compute::outgoing_edge_range_p (vrange &r, edge e, tree name,\n \t\t\t\t     range_query &q)\n {\n-  int_range_max lhs;\n   unsigned idx;\n \n   if ((e->flags & m_not_executable_flag))\n@@ -1252,6 +1262,7 @@ gori_compute::outgoing_edge_range_p (irange &r, edge e, tree name,\n     }\n \n   gcc_checking_assert (gimple_range_ssa_p (name));\n+  int_range_max lhs;\n   // Determine if there is an outgoing edge.\n   gimple *stmt = outgoing.edge_range_p (lhs, e);\n   if (!stmt)\n@@ -1312,10 +1323,9 @@ gori_compute::outgoing_edge_range_p (irange &r, edge e, tree name,\n // edge and OP2 on the false edge.\n \n bool\n-gori_compute::condexpr_adjust (irange &r1, irange &r2, gimple *, tree cond,\n+gori_compute::condexpr_adjust (vrange &r1, vrange &r2, gimple *, tree cond,\n \t\t\t       tree op1, tree op2, fur_source &src)\n {\n-  int_range_max tmp, cond_true, cond_false;\n   tree ssa1 = gimple_range_ssa_p (op1);\n   tree ssa2 = gimple_range_ssa_p (op2);\n   if (!ssa1 && !ssa2)\n@@ -1341,15 +1351,19 @@ gori_compute::condexpr_adjust (irange &r1, irange &r2, gimple *, tree cond,\n     return false;\n \n   // Pick up the current values of each part of the condition.\n-  int_range_max cl, cr;\n-  src.get_operand (cl, gimple_assign_rhs1 (cond_def));\n-  src.get_operand (cr, gimple_assign_rhs2 (cond_def));\n+  tree rhs1 = gimple_assign_rhs1 (cond_def);\n+  tree rhs2 = gimple_assign_rhs2 (cond_def);\n+  Value_Range cl (TREE_TYPE (rhs1));\n+  Value_Range cr (TREE_TYPE (rhs2));\n+  src.get_operand (cl, rhs1);\n+  src.get_operand (cr, rhs2);\n \n   tree cond_name = c1 ? c1 : c2;\n   gimple *def_stmt = SSA_NAME_DEF_STMT (cond_name);\n \n   // Evaluate the value of COND_NAME on the true and false edges, using either\n   // the op1 or op2 routines based on its location.\n+  Value_Range cond_true (type), cond_false (type);\n   if (c1)\n     {\n       if (!hand.op1_range (cond_false, type, m_bool_zero, cr))\n@@ -1380,6 +1394,7 @@ gori_compute::condexpr_adjust (irange &r1, irange &r2, gimple *, tree cond,\n     }\n \n    // Now solve for SSA1 or SSA2 if they are in the dependency chain.\n+  Value_Range tmp (type);\n    if (ssa1 && in_chain_p (ssa1, cond_name))\n     {\n       if (compute_operand_range (tmp, def_stmt, cond_true, ssa1, src))"}, {"sha": "f5f691fe424bc8f544b827f7fbf2bbd3d89bf88e", "filename": "gcc/gimple-range-gori.h", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-gori.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-gori.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.h?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -121,7 +121,7 @@ class gori_map : public range_def_chain\n //   on *ANY* edge that has been seen.  FALSE indicates that the global value\n //   is applicable everywhere that has been processed.\n //\n-// outgoing_edge_range_p (irange &range, edge e, tree name)\n+// outgoing_edge_range_p (vrange &range, edge e, tree name)\n //   Actually does the calculation of RANGE for name on E\n //   This represents application of whatever static range effect edge E\n //   may have on NAME, not any cumulative effect.\n@@ -157,33 +157,33 @@ class gori_compute : public gori_map\n {\n public:\n   gori_compute (int not_executable_flag = 0);\n-  bool outgoing_edge_range_p (irange &r, edge e, tree name, range_query &q);\n-  bool condexpr_adjust (irange &r1, irange &r2, gimple *s, tree cond, tree op1,\n+  bool outgoing_edge_range_p (vrange &r, edge e, tree name, range_query &q);\n+  bool condexpr_adjust (vrange &r1, vrange &r2, gimple *s, tree cond, tree op1,\n \t\t\ttree op2, fur_source &src);\n   bool has_edge_range_p (tree name, basic_block bb = NULL);\n   bool has_edge_range_p (tree name, edge e);\n   void dump (FILE *f);\n private:\n   bool may_recompute_p (tree name, edge e);\n   bool may_recompute_p (tree name, basic_block bb = NULL);\n-  bool compute_operand_range (irange &r, gimple *stmt, const irange &lhs,\n+  bool compute_operand_range (vrange &r, gimple *stmt, const vrange &lhs,\n \t\t\t      tree name, class fur_source &src);\n-  bool compute_operand_range_switch (irange &r, gswitch *s, const irange &lhs,\n+  bool compute_operand_range_switch (vrange &r, gswitch *s, const vrange &lhs,\n \t\t\t\t     tree name, fur_source &src);\n-  bool compute_operand1_range (irange &r, gimple *stmt, const irange &lhs,\n+  bool compute_operand1_range (vrange &r, gimple *stmt, const vrange &lhs,\n \t\t\t       tree name, fur_source &src);\n-  bool compute_operand2_range (irange &r, gimple *stmt, const irange &lhs,\n+  bool compute_operand2_range (vrange &r, gimple *stmt, const vrange &lhs,\n \t\t\t       tree name, fur_source &src);\n-  bool compute_operand1_and_operand2_range (irange &r, gimple *stmt,\n-\t\t\t\t\t    const irange &lhs, tree name,\n+  bool compute_operand1_and_operand2_range (vrange &r, gimple *stmt,\n+\t\t\t\t\t    const vrange &lhs, tree name,\n \t\t\t\t\t    fur_source &src);\n-  void compute_logical_operands (irange &true_range, irange &false_range,\n+  void compute_logical_operands (vrange &true_range, vrange &false_range,\n \t\t\t\t gimple *stmt, const irange &lhs,\n \t\t\t\t tree name, fur_source &src, tree op,\n \t\t\t\t bool op_in_chain);\n-  bool logical_combine (irange &r, enum tree_code code, const irange &lhs,\n-\t\t\tconst irange &op1_true, const irange &op1_false,\n-\t\t\tconst irange &op2_true, const irange &op2_false);\n+  bool logical_combine (vrange &r, enum tree_code code, const irange &lhs,\n+\t\t\tconst vrange &op1_true, const vrange &op1_false,\n+\t\t\tconst vrange &op2_true, const vrange &op2_false);\n   int_range<2> m_bool_zero;\t// Boolean false cached.\n   int_range<2> m_bool_one;\t// Boolean true cached.\n \n@@ -193,14 +193,14 @@ class gori_compute : public gori_map\n };\n \n // These routines provide a GIMPLE interface to the range-ops code.\n-extern bool gimple_range_calc_op1 (irange &r, const gimple *s,\n-\t\t\t\t   const irange &lhs_range);\n-extern bool gimple_range_calc_op1 (irange &r, const gimple *s,\n-\t\t\t\t   const irange &lhs_range,\n-\t\t\t\t   const irange &op2_range);\n-extern bool gimple_range_calc_op2 (irange &r, const gimple *s,\n-\t\t\t\t   const irange &lhs_range,\n-\t\t\t\t   const irange &op1_range);\n+extern bool gimple_range_calc_op1 (vrange &r, const gimple *s,\n+\t\t\t\t   const vrange &lhs_range);\n+extern bool gimple_range_calc_op1 (vrange &r, const gimple *s,\n+\t\t\t\t   const vrange &lhs_range,\n+\t\t\t\t   const vrange &op2_range);\n+extern bool gimple_range_calc_op2 (vrange &r, const gimple *s,\n+\t\t\t\t   const vrange &lhs_range,\n+\t\t\t\t   const vrange &op1_range);\n \n // For each name that is an import into BB's exports..\n #define FOR_EACH_GORI_IMPORT_NAME(gori, bb, name)\t\t\t\\"}, {"sha": "eee149104b4e8dd8c59681388edbdaada05ee47b", "filename": "gcc/gimple-range-infer.cc", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-infer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-infer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-infer.cc?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -58,7 +58,7 @@ non_null_loadstore (gimple *, tree op, tree, void *data)\n // Add NAME and RANGE to the the range inference summary.\n \n void\n-gimple_infer_range::add_range (tree name, irange &range)\n+gimple_infer_range::add_range (tree name, vrange &range)\n {\n   m_names[num_args] = name;\n   m_ranges[num_args] = range;\n@@ -126,7 +126,7 @@ class exit_range\n {\n public:\n   tree name;\n-  irange *range;\n+  vrange *range;\n   exit_range *next;\n };\n \n@@ -181,18 +181,16 @@ infer_range_manager::~infer_range_manager ()\n // Return a non-zero range value of the appropriate type for NAME from\n // the cache, creating it if necessary.\n \n-const irange&\n+const vrange&\n infer_range_manager::get_nonzero (tree name)\n {\n   unsigned v = SSA_NAME_VERSION (name);\n   if (v >= m_nonzero.length ())\n     m_nonzero.safe_grow_cleared (num_ssa_names + 20);\n   if (!m_nonzero[v])\n     {\n-      tree type = TREE_TYPE (name);\n-      m_nonzero[v]\n-\t= static_cast <irange *> (m_range_allocator.alloc_vrange (type));\n-      m_nonzero[v]->set_nonzero (type);\n+      m_nonzero[v] = m_range_allocator.alloc_vrange (TREE_TYPE (name));\n+      m_nonzero[v]->set_nonzero (TREE_TYPE (name));\n     }\n   return *(m_nonzero[v]);\n }\n@@ -219,7 +217,7 @@ infer_range_manager::has_range_p (tree name, basic_block bb)\n // to include it.\n \n bool\n-infer_range_manager::maybe_adjust_range (irange &r, tree name, basic_block bb)\n+infer_range_manager::maybe_adjust_range (vrange &r, tree name, basic_block bb)\n {\n   if (!has_range_p (name, bb))\n     return false;\n@@ -232,7 +230,7 @@ infer_range_manager::maybe_adjust_range (irange &r, tree name, basic_block bb)\n // Add range R as an inferred range for NAME in block BB.\n \n void\n-infer_range_manager::add_range (tree name, basic_block bb, const irange &r)\n+infer_range_manager::add_range (tree name, basic_block bb, const vrange &r)\n {\n   if (bb->index >= (int)m_on_exit.length ())\n     m_on_exit.safe_grow_cleared (last_basic_block_for_fn (cfun) + 1);\n@@ -254,7 +252,7 @@ infer_range_manager::add_range (tree name, basic_block bb, const irange &r)\n   exit_range *ptr = m_on_exit[bb->index].find_ptr (name);\n   if (ptr)\n     {\n-      int_range_max cur = r;\n+      Value_Range cur (r);\n       // If no new info is added, just return.\n       if (!cur.intersect (*(ptr->range)))\n \treturn;\n@@ -263,7 +261,7 @@ infer_range_manager::add_range (tree name, basic_block bb, const irange &r)\n       else\n \t{\n \t  vrange &v = cur;\n-\t  ptr->range = static_cast <irange *> (m_range_allocator.clone (v));\n+\t  ptr->range = m_range_allocator.clone (v);\n \t}\n       return;\n     }"}, {"sha": "aafa8bb74f0c11b811ebd17af4f5574b8b04e4aa", "filename": "gcc/gimple-range-infer.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-infer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-infer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-infer.h?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -35,15 +35,15 @@ class gimple_infer_range\n   inline unsigned num () const { return num_args; }\n   inline tree name (unsigned index) const\n     { gcc_checking_assert (index < num_args); return m_names[index]; }\n-  inline const irange& range (unsigned index) const\n+  inline const vrange& range (unsigned index) const\n     { gcc_checking_assert (index < num_args); return m_ranges[index]; }\n-  void add_range (tree name, irange &range);\n+  void add_range (tree name, vrange &range);\n   void add_nonzero (tree name);\n private:\n   unsigned num_args;\n   static const int size_limit = 10;\n   tree m_names[size_limit];\n-  int_range<3> m_ranges[size_limit];\n+  Value_Range m_ranges[size_limit];\n   inline void bump_index () { if (num_args < size_limit - 1) num_args++; }\n };\n \n@@ -58,10 +58,10 @@ class infer_range_manager\n public:\n   infer_range_manager (bool do_search);\n   ~infer_range_manager ();\n-  void add_range (tree name, basic_block bb, const irange &r);\n+  void add_range (tree name, basic_block bb, const vrange &r);\n   void add_nonzero (tree name, basic_block bb);\n   bool has_range_p (tree name, basic_block bb);\n-  bool maybe_adjust_range (irange &r, tree name, basic_block bb);\n+  bool maybe_adjust_range (vrange &r, tree name, basic_block bb);\n private:\n   class exit_range_head\n   {\n@@ -73,8 +73,8 @@ class infer_range_manager\n   };\n   void register_all_uses (tree name);\n   vec <exit_range_head> m_on_exit;\n-  const irange &get_nonzero (tree name);\n-  vec <irange *> m_nonzero;\n+  const vrange &get_nonzero (tree name);\n+  vec <vrange *> m_nonzero;\n   bitmap m_seen;\n   bitmap_obstack m_bitmaps;\n   struct obstack m_list_obstack;"}, {"sha": "f8ae6fb9ffbb600c22ab6326b1bdf86504089116", "filename": "gcc/gimple-range-path.cc", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -83,7 +83,7 @@ path_range_query::clear_cache (tree name)\n // If NAME has a cache entry, return it in R, and return TRUE.\n \n inline bool\n-path_range_query::get_cache (irange &r, tree name)\n+path_range_query::get_cache (vrange &r, tree name)\n {\n   if (!gimple_range_ssa_p (name))\n     return get_global_range_query ()->range_of_expr (r, name);\n@@ -98,7 +98,7 @@ path_range_query::get_cache (irange &r, tree name)\n // Set the cache entry for NAME to R.\n \n void\n-path_range_query::set_cache (const irange &r, tree name)\n+path_range_query::set_cache (const vrange &r, tree name)\n {\n   unsigned v = SSA_NAME_VERSION (name);\n   bitmap_set_bit (m_has_cache_entry, v);\n@@ -149,7 +149,7 @@ path_range_query::defined_outside_path (tree name)\n // Return the range of NAME on entry to the path.\n \n void\n-path_range_query::range_on_path_entry (irange &r, tree name)\n+path_range_query::range_on_path_entry (vrange &r, tree name)\n {\n   gcc_checking_assert (defined_outside_path (name));\n   basic_block entry = entry_bb ();\n@@ -168,7 +168,7 @@ path_range_query::range_on_path_entry (irange &r, tree name)\n   // block.  This can happen when we're querying a block with only an\n   // outgoing edge (no statement but the fall through edge), but for\n   // which we can determine a range on entry to the block.\n-  int_range_max tmp;\n+  Value_Range tmp (TREE_TYPE (name));\n   bool changed = false;\n   r.set_undefined ();\n   for (unsigned i = 0; i < EDGE_COUNT (entry->preds); ++i)\n@@ -190,9 +190,9 @@ path_range_query::range_on_path_entry (irange &r, tree name)\n // Return the range of NAME at the end of the path being analyzed.\n \n bool\n-path_range_query::internal_range_of_expr (irange &r, tree name, gimple *stmt)\n+path_range_query::internal_range_of_expr (vrange &r, tree name, gimple *stmt)\n {\n-  if (!irange::supports_type_p (TREE_TYPE (name)))\n+  if (!vrange::supports_type_p (TREE_TYPE (name)))\n     return false;\n \n   if (get_cache (r, name))\n@@ -209,18 +209,22 @@ path_range_query::internal_range_of_expr (irange &r, tree name, gimple *stmt)\n       && range_defined_in_block (r, name, gimple_bb (stmt)))\n     {\n       if (TREE_CODE (name) == SSA_NAME)\n-\tr.intersect (gimple_range_global (name));\n+\t{\n+\t  Value_Range glob (TREE_TYPE (name));\n+\t  gimple_range_global (glob, name);\n+\t  r.intersect (glob);\n+\t}\n \n       set_cache (r, name);\n       return true;\n     }\n \n-  r = gimple_range_global (name);\n+  gimple_range_global (r, name);\n   return true;\n }\n \n bool\n-path_range_query::range_of_expr (irange &r, tree name, gimple *stmt)\n+path_range_query::range_of_expr (vrange &r, tree name, gimple *stmt)\n {\n   if (internal_range_of_expr (r, name, stmt))\n     {\n@@ -269,7 +273,7 @@ path_range_query::ssa_defined_in_bb (tree name, basic_block bb)\n // calculating the PHI's range must not trigger additional lookups.\n \n void\n-path_range_query::ssa_range_in_phi (irange &r, gphi *phi)\n+path_range_query::ssa_range_in_phi (vrange &r, gphi *phi)\n {\n   tree name = gimple_phi_result (phi);\n   basic_block bb = gimple_bb (phi);\n@@ -283,7 +287,7 @@ path_range_query::ssa_range_in_phi (irange &r, gphi *phi)\n       // Try to fold the phi exclusively with global or cached values.\n       // This will get things like PHI <5(99), 6(88)>.  We do this by\n       // calling range_of_expr with no context.\n-      int_range_max arg_range;\n+      Value_Range arg_range (TREE_TYPE (name));\n       r.set_undefined ();\n       for (size_t i = 0; i < nargs; ++i)\n \t{\n@@ -312,7 +316,7 @@ path_range_query::ssa_range_in_phi (irange &r, gphi *phi)\n \t  {\n \t    if (m_resolve)\n \t      {\n-\t\tint_range_max tmp;\n+\t\tValue_Range tmp (TREE_TYPE (name));\n \t\t// Using both the range on entry to the path, and the\n \t\t// range on this edge yields significantly better\n \t\t// results.\n@@ -335,7 +339,7 @@ path_range_query::ssa_range_in_phi (irange &r, gphi *phi)\n // TRUE.  Otherwise, return FALSE.\n \n bool\n-path_range_query::range_defined_in_block (irange &r, tree name, basic_block bb)\n+path_range_query::range_defined_in_block (vrange &r, tree name, basic_block bb)\n {\n   gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n   basic_block def_bb = gimple_bb (def_stmt);\n@@ -377,7 +381,6 @@ path_range_query::range_defined_in_block (irange &r, tree name, basic_block bb)\n void\n path_range_query::compute_ranges_in_phis (basic_block bb)\n {\n-  int_range_max r;\n   auto_bitmap phi_set;\n \n   // PHIs must be resolved simultaneously on entry to the block\n@@ -390,7 +393,11 @@ path_range_query::compute_ranges_in_phis (basic_block bb)\n       gphi *phi = iter.phi ();\n       tree name = gimple_phi_result (phi);\n \n-      if (import_p (name) && range_defined_in_block (r, name, bb))\n+      if (!import_p (name))\n+\tcontinue;\n+\n+      Value_Range r (TREE_TYPE (name));\n+      if (range_defined_in_block (r, name, bb))\n \t{\n \t  unsigned v = SSA_NAME_VERSION (name);\n \t  set_cache (r, name);\n@@ -423,7 +430,6 @@ void\n path_range_query::compute_ranges_in_block (basic_block bb)\n {\n   bitmap_iterator bi;\n-  int_range_max r, cached_range;\n   unsigned i;\n \n   if (m_resolve && !at_entry ())\n@@ -444,6 +450,7 @@ path_range_query::compute_ranges_in_block (basic_block bb)\n   EXECUTE_IF_SET_IN_BITMAP (m_imports, 0, i, bi)\n     {\n       tree name = ssa_name (i);\n+      Value_Range r (TREE_TYPE (name));\n \n       if (gimple_code (SSA_NAME_DEF_STMT (name)) != GIMPLE_PHI\n \t  && range_defined_in_block (r, name, bb))\n@@ -480,8 +487,10 @@ path_range_query::compute_ranges_in_block (basic_block bb)\n \n       if (bitmap_bit_p (exports, i))\n \t{\n+\t  Value_Range r (TREE_TYPE (name));\n \t  if (g.outgoing_edge_range_p (r, e, name, *this))\n \t    {\n+\t      Value_Range cached_range (TREE_TYPE (name));\n \t      if (get_cache (cached_range, name))\n \t\tr.intersect (cached_range);\n \n@@ -539,7 +548,7 @@ bool\n path_range_query::add_to_imports (tree name, bitmap imports)\n {\n   if (TREE_CODE (name) == SSA_NAME\n-      && irange::supports_type_p (TREE_TYPE (name)))\n+      && vrange::supports_type_p (TREE_TYPE (name)))\n     return bitmap_set_bit (imports, SSA_NAME_VERSION (name));\n   return false;\n }\n@@ -751,11 +760,11 @@ jt_fur_source::query_relation (tree op1, tree op2)\n // Return the range of STMT at the end of the path being analyzed.\n \n bool\n-path_range_query::range_of_stmt (irange &r, gimple *stmt, tree)\n+path_range_query::range_of_stmt (vrange &r, gimple *stmt, tree)\n {\n   tree type = gimple_range_type (stmt);\n \n-  if (!type || !irange::supports_type_p (type))\n+  if (!type || !vrange::supports_type_p (type))\n     return false;\n \n   // If resolving unknowns, fold the statement making use of any"}, {"sha": "2c4624e4cefbeb43199f662634e4be44138813c7", "filename": "gcc/gimple-range-path.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.h?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -38,29 +38,29 @@ class path_range_query : public range_query\n \t\t       const bitmap_head *imports = NULL);\n   void compute_ranges (edge e);\n   void compute_imports (bitmap imports, basic_block exit);\n-  bool range_of_expr (irange &r, tree name, gimple * = NULL) override;\n-  bool range_of_stmt (irange &r, gimple *, tree name = NULL) override;\n+  bool range_of_expr (vrange &r, tree name, gimple * = NULL) override;\n+  bool range_of_stmt (vrange &r, gimple *, tree name = NULL) override;\n   bool unreachable_path_p ();\n   void dump (FILE *) override;\n   void debug ();\n \n private:\n-  bool internal_range_of_expr (irange &r, tree name, gimple *);\n+  bool internal_range_of_expr (vrange &r, tree name, gimple *);\n   bool defined_outside_path (tree name);\n-  void range_on_path_entry (irange &r, tree name);\n+  void range_on_path_entry (vrange &r, tree name);\n   path_oracle *get_path_oracle () { return (path_oracle *)m_oracle; }\n \n   // Cache manipulation.\n-  void set_cache (const irange &r, tree name);\n-  bool get_cache (irange &r, tree name);\n+  void set_cache (const vrange &r, tree name);\n+  bool get_cache (vrange &r, tree name);\n   void clear_cache (tree name);\n \n   // Methods to compute ranges for the given path.\n-  bool range_defined_in_block (irange &, tree name, basic_block bb);\n+  bool range_defined_in_block (vrange &, tree name, basic_block bb);\n   void compute_ranges_in_block (basic_block bb);\n   void compute_ranges_in_phis (basic_block bb);\n   void adjust_for_non_null_uses (basic_block bb);\n-  void ssa_range_in_phi (irange &r, gphi *phi);\n+  void ssa_range_in_phi (vrange &r, gphi *phi);\n   void compute_outgoing_relations (basic_block bb, basic_block next);\n   void compute_phi_relations (basic_block bb, basic_block prev);\n   void maybe_register_phi_relation (gphi *, edge e);"}, {"sha": "84ecc486889dc2679bafa1fe33cdb7a2d1918095", "filename": "gcc/gimple-range-tests.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-tests.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-tests.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-tests.cc?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -42,8 +42,9 @@ class test_expr_eval : public gimple_ranger\n     ASSERT_TRUE (r == expect);\n   }\n \n-  virtual bool range_of_expr (irange &r, tree expr, gimple * = NULL) override\n+  virtual bool range_of_expr (vrange &v, tree expr, gimple * = NULL) override\n   {\n+    irange &r = as_a <irange> (v);\n     if (expr == op0)\n       {\n \tr.set (build_int_cst (type, 5), build_int_cst (type, 10));"}, {"sha": "46827f9c580949ca26ede532e2a483da26e5b095", "filename": "gcc/gimple-range-trace.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-trace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-trace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-trace.cc?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -102,7 +102,7 @@ range_tracer::print (unsigned counter, const char *str)\n \n void\n range_tracer::trailer (unsigned counter, const char *caller, bool result,\n-\t\t      tree name, const irange &r)\n+\t\t      tree name, const vrange &r)\n {\n   gcc_checking_assert (tracing && counter != 0);\n \n@@ -141,7 +141,6 @@ debug_seed_ranger (gimple_ranger &ranger)\n     }\n \n   basic_block bb;\n-  int_range_max r;\n   gimple_stmt_iterator gsi;\n   FOR_EACH_BB_FN (bb, cfun)\n     for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -151,7 +150,11 @@ debug_seed_ranger (gimple_ranger &ranger)\n \tif (is_gimple_debug (stmt))\n \t  continue;\n \n-\tranger.range_of_stmt (r, stmt);\n+\tif (tree type = gimple_range_type (stmt))\n+\t  {\n+\t    Value_Range r (type);\n+\t    ranger.range_of_stmt (r, stmt);\n+\t  }\n       }\n }\n "}, {"sha": "3f92e51803b8107b78c757347d1878079da8b24c", "filename": "gcc/gimple-range-trace.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range-trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-trace.h?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -32,7 +32,7 @@ class range_tracer\n   range_tracer (const char *name = \"\");\n   unsigned header (const char *str);\n   void trailer (unsigned counter, const char *caller, bool result, tree name,\n-\t\tconst irange &r);\n+\t\tconst vrange &r);\n   void print (unsigned counter, const char *str);\n   inline void enable_trace () { tracing = true; }\n   inline void disable_trace () { tracing = false; }"}, {"sha": "12da16841c2353af5d8498efb8e126191ac0553c", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -71,7 +71,7 @@ gimple_ranger::~gimple_ranger ()\n }\n \n bool\n-gimple_ranger::range_of_expr (irange &r, tree expr, gimple *stmt)\n+gimple_ranger::range_of_expr (vrange &r, tree expr, gimple *stmt)\n {\n   unsigned idx;\n   if (!gimple_range_ssa_p (expr))\n@@ -93,7 +93,7 @@ gimple_ranger::range_of_expr (irange &r, tree expr, gimple *stmt)\n   // If there is no statement, just get the global value.\n   if (!stmt)\n     {\n-      int_range_max tmp;\n+      Value_Range tmp (TREE_TYPE (expr));\n       m_cache.get_global_range (r, expr);\n       // Pick up implied context information from the on-entry cache\n       // if current_bb is set.  Do not attempt any new calculations.\n@@ -137,9 +137,9 @@ gimple_ranger::range_of_expr (irange &r, tree expr, gimple *stmt)\n // Return the range of NAME on entry to block BB in R.\n \n void\n-gimple_ranger::range_on_entry (irange &r, basic_block bb, tree name)\n+gimple_ranger::range_on_entry (vrange &r, basic_block bb, tree name)\n {\n-  int_range_max entry_range;\n+  Value_Range entry_range (TREE_TYPE (name));\n   gcc_checking_assert (gimple_range_ssa_p (name));\n \n   unsigned idx;\n@@ -164,7 +164,7 @@ gimple_ranger::range_on_entry (irange &r, basic_block bb, tree name)\n // Return false if no range can be calculated.\n \n void\n-gimple_ranger::range_on_exit (irange &r, basic_block bb, tree name)\n+gimple_ranger::range_on_exit (vrange &r, basic_block bb, tree name)\n {\n   // on-exit from the exit block?\n   gcc_checking_assert (bb != EXIT_BLOCK_PTR_FOR_FN (cfun));\n@@ -198,10 +198,10 @@ gimple_ranger::range_on_exit (irange &r, basic_block bb, tree name)\n // Calculate a range for NAME on edge E and return it in R.\n \n bool\n-gimple_ranger::range_on_edge (irange &r, edge e, tree name)\n+gimple_ranger::range_on_edge (vrange &r, edge e, tree name)\n {\n-  int_range_max edge_range;\n-  gcc_checking_assert (irange::supports_type_p (TREE_TYPE (name)));\n+  Value_Range edge_range (TREE_TYPE (name));\n+  gcc_checking_assert (vrange::supports_type_p (TREE_TYPE (name)));\n \n   // Do not process values along abnormal edges.\n   if (e->flags & EDGE_ABNORMAL)\n@@ -249,7 +249,7 @@ gimple_ranger::range_on_edge (irange &r, edge e, tree name)\n // fold_range wrapper for range_of_stmt to use as an internal client.\n \n bool\n-gimple_ranger::fold_range_internal (irange &r, gimple *s, tree name)\n+gimple_ranger::fold_range_internal (vrange &r, gimple *s, tree name)\n {\n   fold_using_range f;\n   fur_depend src (s, &(gori ()), this);\n@@ -263,7 +263,7 @@ gimple_ranger::fold_range_internal (irange &r, gimple *s, tree name)\n // avoided.  If a range cannot be calculated, return false and UNDEFINED.\n \n bool\n-gimple_ranger::range_of_stmt (irange &r, gimple *s, tree name)\n+gimple_ranger::range_of_stmt (vrange &r, gimple *s, tree name)\n {\n   bool res;\n   r.set_undefined ();\n@@ -313,7 +313,7 @@ gimple_ranger::range_of_stmt (irange &r, gimple *s, tree name)\n \tprefill_stmt_dependencies (name);\n \n       // Calculate a new value.\n-      int_range_max tmp;\n+      Value_Range tmp (TREE_TYPE (name));\n       fold_range_internal (tmp, s, name);\n \n       // Combine the new value with the old value.  This is required because\n@@ -334,7 +334,7 @@ gimple_ranger::range_of_stmt (irange &r, gimple *s, tree name)\n // stack if so.  R is a scratch range.\n \n inline void\n-gimple_ranger::prefill_name (irange &r, tree name)\n+gimple_ranger::prefill_name (vrange &r, tree name)\n {\n   if (!gimple_range_ssa_p (name))\n     return;\n@@ -357,7 +357,6 @@ gimple_ranger::prefill_stmt_dependencies (tree ssa)\n   if (SSA_NAME_IS_DEFAULT_DEF (ssa))\n     return;\n \n-  int_range_max r;\n   unsigned idx;\n   gimple *stmt = SSA_NAME_DEF_STMT (ssa);\n   gcc_checking_assert (stmt && gimple_bb (stmt));\n@@ -388,9 +387,10 @@ gimple_ranger::prefill_stmt_dependencies (tree ssa)\n \t    {\n \t      // Fold and save the value for NAME.\n \t      stmt = SSA_NAME_DEF_STMT (name);\n+\t      Value_Range r (TREE_TYPE (name));\n \t      fold_range_internal (r, stmt, name);\n \t      // Make sure we don't lose any current global info.\n-\t      int_range_max tmp;\n+\t      Value_Range tmp (TREE_TYPE (name));\n \t      m_cache.get_global_range (tmp, name);\n \t      r.intersect (tmp);\n \t      m_cache.set_global_range (name, r);\n@@ -414,13 +414,15 @@ gimple_ranger::prefill_stmt_dependencies (tree ssa)\n       gphi *phi = dyn_cast <gphi *> (stmt);\n       if (phi)\n \t{\n+\t  Value_Range r (TREE_TYPE (gimple_phi_result (phi)));\n \t  for (unsigned x = 0; x < gimple_phi_num_args (phi); x++)\n \t    prefill_name (r, gimple_phi_arg_def (phi, x));\n \t}\n       else\n \t{\n \t  gcc_checking_assert (range_op_handler (stmt));\n \t  tree op = gimple_range_operand2 (stmt);\n+\t  Value_Range r (TREE_TYPE (name));\n \t  if (op)\n \t    prefill_name (r, op);\n \t  op = gimple_range_operand1 (stmt);\n@@ -429,7 +431,10 @@ gimple_ranger::prefill_stmt_dependencies (tree ssa)\n \t}\n     }\n   if (idx)\n-    tracer.trailer (idx, \"ROS \", false, ssa, r);\n+    {\n+      unsupported_range r;\n+      tracer.trailer (idx, \"ROS \", false, ssa, r);\n+    }\n }\n \n \n@@ -487,8 +492,10 @@ gimple_ranger::export_global_ranges ()\n   bool print_header = true;\n   for (unsigned x = 1; x < num_ssa_names; x++)\n     {\n-      int_range_max r;\n       tree name = ssa_name (x);\n+      if (!name)\n+\tcontinue;\n+      Value_Range r (TREE_TYPE (name));\n       if (name && !SSA_NAME_IN_FREE_LIST (name)\n \t  && gimple_range_ssa_p (name)\n \t  && m_cache.get_global_range (r, name)\n@@ -507,13 +514,17 @@ gimple_ranger::export_global_ranges ()\n \t      print_header = false;\n \t    }\n \n-\t  value_range vr = r;\n+\t  if (!irange::supports_type_p (TREE_TYPE (name)))\n+\t    continue;\n+\n+\t  vrange &v = r;\n+\t  value_range vr = as_a <irange> (v);\n \t  print_generic_expr (dump_file, name , TDF_SLIM);\n \t  fprintf (dump_file, \"  : \");\n \t  vr.dump (dump_file);\n \t  fprintf (dump_file, \"\\n\");\n \t  int_range_max same = vr;\n-\t  if (same != r)\n+\t  if (same != as_a <irange> (v))\n \t    {\n \t      fprintf (dump_file, \"         irange : \");\n \t      r.dump (dump_file);\n@@ -531,7 +542,6 @@ gimple_ranger::dump_bb (FILE *f, basic_block bb)\n   unsigned x;\n   edge_iterator ei;\n   edge e;\n-  int_range_max range, tmp_range;\n   fprintf (f, \"\\n=========== BB %d ============\\n\", bb->index);\n   m_cache.dump_bb (f, bb);\n \n@@ -541,9 +551,11 @@ gimple_ranger::dump_bb (FILE *f, basic_block bb)\n   for (x = 1; x < num_ssa_names; x++)\n     {\n       tree name = ssa_name (x);\n-      if (gimple_range_ssa_p (name) && SSA_NAME_DEF_STMT (name) &&\n-\t  gimple_bb (SSA_NAME_DEF_STMT (name)) == bb &&\n-\t  m_cache.get_global_range (range, name))\n+      if (!gimple_range_ssa_p (name) || !SSA_NAME_DEF_STMT (name))\n+\tcontinue;\n+      Value_Range range (TREE_TYPE (name));\n+      if (gimple_bb (SSA_NAME_DEF_STMT (name)) == bb\n+\t  && m_cache.get_global_range (range, name))\n \t{\n \t  if (!range.varying_p ())\n \t    {\n@@ -562,10 +574,14 @@ gimple_ranger::dump_bb (FILE *f, basic_block bb)\n       for (x = 1; x < num_ssa_names; x++)\n \t{\n \t  tree name = gimple_range_ssa_p (ssa_name (x));\n-\t  if (name && gori ().has_edge_range_p (name, e)\n-\t      && m_cache.range_on_edge (range, e, name))\n+\t  if (!name || !gori ().has_edge_range_p (name, e))\n+\t    continue;\n+\n+\t  Value_Range range (TREE_TYPE (name));\n+\t  if (m_cache.range_on_edge (range, e, name))\n \t    {\n \t      gimple *s = SSA_NAME_DEF_STMT (name);\n+\t      Value_Range tmp_range (TREE_TYPE (name));\n \t      // Only print the range if this is the def block, or\n \t      // the on entry cache for either end of the edge is\n \t      // set."}, {"sha": "34f61025ac3457e4091da607a6dd940b87f0af5a", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -48,11 +48,11 @@ class gimple_ranger : public range_query\n public:\n   gimple_ranger (bool use_imm_uses = true);\n   ~gimple_ranger ();\n-  virtual bool range_of_stmt (irange &r, gimple *, tree name = NULL) override;\n-  virtual bool range_of_expr (irange &r, tree name, gimple * = NULL) override;\n-  virtual bool range_on_edge (irange &r, edge e, tree name) override;\n-  void range_on_entry (irange &r, basic_block bb, tree name);\n-  void range_on_exit (irange &r, basic_block bb, tree name);\n+  virtual bool range_of_stmt (vrange &r, gimple *, tree name = NULL) override;\n+  virtual bool range_of_expr (vrange &r, tree name, gimple * = NULL) override;\n+  virtual bool range_on_edge (vrange &r, edge e, tree name) override;\n+  void range_on_entry (vrange &r, basic_block bb, tree name);\n+  void range_on_exit (vrange &r, basic_block bb, tree name);\n   void export_global_ranges ();\n   inline gori_compute &gori ()  { return m_cache.m_gori; }\n   virtual void dump (FILE *f) override;\n@@ -62,8 +62,8 @@ class gimple_ranger : public range_query\n   bool fold_stmt (gimple_stmt_iterator *gsi, tree (*) (tree));\n   void register_inferred_ranges (gimple *s);\n protected:\n-  bool fold_range_internal (irange &r, gimple *s, tree name);\n-  void prefill_name (irange &r, tree name);\n+  bool fold_range_internal (vrange &r, gimple *s, tree name);\n+  void prefill_name (vrange &r, tree name);\n   void prefill_stmt_dependencies (tree ssa);\n   ranger_cache m_cache;\n   range_tracer tracer;"}, {"sha": "00f65858b0c321c12b849b7776a5dfa4696c7d5f", "filename": "gcc/gimple-ssa-warn-access.cc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-ssa-warn-access.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fgimple-ssa-warn-access.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.cc?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -328,11 +328,11 @@ check_nul_terminated_array (GimpleOrTree expr, tree src, tree bound)\n   wide_int bndrng[2];\n   if (bound)\n     {\n-      value_range r;\n+      Value_Range r (TREE_TYPE (bound));\n \n       get_global_range_query ()->range_of_expr (r, bound);\n \n-      if (r.kind () != VR_RANGE)\n+      if (r.undefined_p () || r.varying_p ())\n \treturn true;\n \n       bndrng[0] = r.lower_bound ();\n@@ -2790,9 +2790,8 @@ memmodel_to_uhwi (tree ord, gimple *stmt, unsigned HOST_WIDE_INT *cstval)\n     {\n       /* Use the range query to determine constant values in the absence\n \t of constant propagation (such as at -O0).  */\n-      value_range rng;\n+      Value_Range rng (TREE_TYPE (ord));\n       if (!get_range_query (cfun)->range_of_expr (rng, ord, stmt)\n-\t  || !rng.constant_p ()\n \t  || !rng.singleton_p (&ord))\n \treturn false;\n "}, {"sha": "1e0f609d8b61c5625a8e221a412605b9b54529c9", "filename": "gcc/tree-ssa-loop-niter.cc", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Ftree-ssa-loop-niter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Ftree-ssa-loop-niter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.cc?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -221,7 +221,7 @@ refine_value_range_using_guard (tree type, tree var,\n   get_type_static_bounds (type, mint, maxt);\n   mpz_init (minc1);\n   mpz_init (maxc1);\n-  value_range r;\n+  Value_Range r (TREE_TYPE (varc1));\n   /* Setup range information for varc1.  */\n   if (integer_zerop (varc1))\n     {\n@@ -374,7 +374,7 @@ determine_value_range (class loop *loop, tree type, tree var, mpz_t off,\n       gphi_iterator gsi;\n \n       /* Either for VAR itself...  */\n-      value_range var_range;\n+      Value_Range var_range (TREE_TYPE (var));\n       get_range_query (cfun)->range_of_expr (var_range, var);\n       rtype = var_range.kind ();\n       if (!var_range.undefined_p ())\n@@ -385,10 +385,10 @@ determine_value_range (class loop *loop, tree type, tree var, mpz_t off,\n \n       /* Or for PHI results in loop->header where VAR is used as\n \t PHI argument from the loop preheader edge.  */\n+      Value_Range phi_range (TREE_TYPE (var));\n       for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gphi *phi = gsi.phi ();\n-\t  value_range phi_range;\n \t  if (PHI_ARG_DEF_FROM_EDGE (phi, e) == var\n \t      && get_range_query (cfun)->range_of_expr (phi_range,\n \t\t\t\t\t\t    gimple_phi_result (phi))\n@@ -410,7 +410,7 @@ determine_value_range (class loop *loop, tree type, tree var, mpz_t off,\n \t\t     involved.  */\n \t\t  if (wi::gt_p (minv, maxv, sgn))\n \t\t    {\n-\t\t      value_range vr;\n+\t\t      Value_Range vr (TREE_TYPE (var));\n \t\t      get_range_query (cfun)->range_of_expr (vr, var);\n \t\t      rtype = vr.kind ();\n \t\t      if (!vr.undefined_p ())\n@@ -3650,7 +3650,7 @@ record_nonwrapping_iv (class loop *loop, tree base, tree step, gimple *stmt,\n   if (tree_int_cst_sign_bit (step))\n     {\n       wide_int max;\n-      value_range base_range;\n+      Value_Range base_range (TREE_TYPE (orig_base));\n       if (get_range_query (cfun)->range_of_expr (base_range, orig_base)\n \t  && !base_range.undefined_p ())\n \tmax = base_range.upper_bound ();\n@@ -3672,7 +3672,7 @@ record_nonwrapping_iv (class loop *loop, tree base, tree step, gimple *stmt,\n   else\n     {\n       wide_int min;\n-      value_range base_range;\n+      Value_Range base_range (TREE_TYPE (orig_base));\n       if (get_range_query (cfun)->range_of_expr (base_range, orig_base)\n \t  && !base_range.undefined_p ())\n \tmin = base_range.lower_bound ();\n@@ -3947,7 +3947,7 @@ infer_loop_bounds_from_signedness (class loop *loop, gimple *stmt)\n \n   low = lower_bound_in_type (type, type);\n   high = upper_bound_in_type (type, type);\n-  value_range r;\n+  Value_Range r (TREE_TYPE (def));\n   get_range_query (cfun)->range_of_expr (r, def);\n   if (r.kind () == VR_RANGE)\n     {\n@@ -4997,7 +4997,7 @@ scev_var_range_cant_overflow (tree var, tree step, class loop *loop)\n   if (!def_bb || !dominated_by_p (CDI_DOMINATORS, loop->latch, def_bb))\n     return false;\n \n-  value_range r;\n+  Value_Range r (TREE_TYPE (var));\n   get_range_query (cfun)->range_of_expr (r, var);\n   if (r.kind () != VR_RANGE)\n     return false;"}, {"sha": "ad1d05ccdffec5a05c4bcb6968ce3736c35b893a", "filename": "gcc/tree-ssa-loop-unswitch.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Ftree-ssa-loop-unswitch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Ftree-ssa-loop-unswitch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.cc?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -140,13 +140,13 @@ struct unswitch_predicate\n \tint_range<2> rhs_range (TREE_TYPE (rhs));\n \tif (CONSTANT_CLASS_P (rhs))\n \t  rhs_range.set (rhs);\n-\tif (!range_op->op1_range (true_range, TREE_TYPE (lhs),\n-\t\t\t\t  int_range<2> (boolean_true_node,\n-\t\t\t\t\t\tboolean_true_node), rhs_range)\n-\t    || !range_op->op1_range (false_range, TREE_TYPE (lhs),\n-\t\t\t\t     int_range<2> (boolean_false_node,\n-\t\t\t\t\t\t   boolean_false_node),\n-\t\t\t\t     rhs_range))\n+\tif (!range_op.op1_range (true_range, TREE_TYPE (lhs),\n+\t\t\t\t int_range<2> (boolean_true_node,\n+\t\t\t\t\t       boolean_true_node), rhs_range)\n+\t    || !range_op.op1_range (false_range, TREE_TYPE (lhs),\n+\t\t\t\t    int_range<2> (boolean_false_node,\n+\t\t\t\t\t\t  boolean_false_node),\n+\t\t\t\t    rhs_range))\n \t  {\n \t    true_range.set_varying (TREE_TYPE (lhs));\n \t    false_range.set_varying (TREE_TYPE (lhs));"}, {"sha": "931aa7479bbe14580c420520a8136f695e96522f", "filename": "gcc/tree-ssa-threadedge.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Ftree-ssa-threadedge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Ftree-ssa-threadedge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.cc?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -1409,19 +1409,19 @@ tree\n hybrid_jt_simplifier::simplify (gimple *stmt, gimple *, basic_block,\n \t\t\t\tjt_state *state)\n {\n-  int_range_max r;\n-\n   compute_ranges_from_state (stmt, state);\n \n   if (gimple_code (stmt) == GIMPLE_COND\n       || gimple_code (stmt) == GIMPLE_ASSIGN)\n     {\n+      Value_Range r (gimple_range_type (stmt));\n       tree ret;\n       if (m_query->range_of_stmt (r, stmt) && r.singleton_p (&ret))\n \treturn ret;\n     }\n   else if (gimple_code (stmt) == GIMPLE_SWITCH)\n     {\n+      int_range_max r;\n       gswitch *switch_stmt = dyn_cast <gswitch *> (stmt);\n       tree index = gimple_switch_index (switch_stmt);\n       if (m_query->range_of_expr (r, index, stmt))"}, {"sha": "e40e358ebd4a073f002a469839ee7bd8d3fa1a5b", "filename": "gcc/value-query.cc", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -57,13 +57,13 @@ value_query::value_of_stmt (gimple *stmt, tree name)\n // range_query default methods.\n \n bool\n-range_query::range_on_edge (irange &r, edge, tree expr)\n+range_query::range_on_edge (vrange &r, edge, tree expr)\n {\n   return range_of_expr (r, expr);\n }\n \n bool\n-range_query::range_of_stmt (irange &r, gimple *stmt, tree name)\n+range_query::range_of_stmt (vrange &r, gimple *stmt, tree name)\n {\n   if (!name)\n     name = gimple_get_lhs (stmt);\n@@ -79,11 +79,12 @@ tree\n range_query::value_of_expr (tree expr, gimple *stmt)\n {\n   tree t;\n-  int_range_max r;\n \n-  if (!irange::supports_type_p (TREE_TYPE (expr)))\n+  if (!vrange::supports_type_p (TREE_TYPE (expr)))\n     return NULL_TREE;\n \n+  Value_Range r (TREE_TYPE (expr));\n+\n   if (range_of_expr (r, expr, stmt))\n     {\n       // A constant used in an unreachable block oftens returns as UNDEFINED.\n@@ -100,10 +101,10 @@ tree\n range_query::value_on_edge (edge e, tree expr)\n {\n   tree t;\n-  int_range_max r;\n \n-  if (!irange::supports_type_p (TREE_TYPE (expr)))\n+  if (!vrange::supports_type_p (TREE_TYPE (expr)))\n     return NULL_TREE;\n+  Value_Range r (TREE_TYPE (expr));\n   if (range_on_edge (r, e, expr))\n     {\n       // A constant used in an unreachable block oftens returns as UNDEFINED.\n@@ -121,15 +122,15 @@ tree\n range_query::value_of_stmt (gimple *stmt, tree name)\n {\n   tree t;\n-  int_range_max r;\n \n   if (!name)\n     name = gimple_get_lhs (stmt);\n \n   gcc_checking_assert (!name || name == gimple_get_lhs (stmt));\n \n-  if (!name || !irange::supports_type_p (TREE_TYPE (name)))\n+  if (!name || !vrange::supports_type_p (TREE_TYPE (name)))\n     return NULL_TREE;\n+  Value_Range r (TREE_TYPE (name));\n   if (range_of_stmt (r, stmt, name) && r.singleton_p (&t))\n     return t;\n   return NULL_TREE;\n@@ -187,15 +188,15 @@ range_query::~range_query ()\n // representable, and UNDEFINED/false if not.\n \n bool\n-range_query::get_tree_range (irange &r, tree expr, gimple *stmt)\n+range_query::get_tree_range (vrange &r, tree expr, gimple *stmt)\n {\n   tree type;\n   if (TYPE_P (expr))\n     type = expr;\n   else\n     type = TREE_TYPE (expr);\n \n-  if (!irange::supports_type_p (type))\n+  if (!vrange::supports_type_p (type))\n     {\n       r.set_undefined ();\n       return false;\n@@ -214,7 +215,7 @@ range_query::get_tree_range (irange &r, tree expr, gimple *stmt)\n       return true;\n \n     case SSA_NAME:\n-      r = gimple_range_global (expr);\n+      gimple_range_global (r, expr);\n       return true;\n \n     case ADDR_EXPR:\n@@ -223,7 +224,7 @@ range_query::get_tree_range (irange &r, tree expr, gimple *stmt)\n \tbool ov;\n \tif (tree_single_nonzero_warnv_p (expr, &ov))\n \t  {\n-\t    r = range_nonzero (type);\n+\t    r.set_nonzero (type);\n \t    return true;\n \t  }\n \tbreak;\n@@ -237,7 +238,8 @@ range_query::get_tree_range (irange &r, tree expr, gimple *stmt)\n       range_op_handler op (TREE_CODE (expr), type);\n       if (op)\n \t{\n-\t  int_range_max r0, r1;\n+\t  Value_Range r0 (TREE_TYPE (TREE_OPERAND (expr, 0)));\n+\t  Value_Range r1 (TREE_TYPE (TREE_OPERAND (expr, 1)));\n \t  range_of_expr (r0, TREE_OPERAND (expr, 0), stmt);\n \t  range_of_expr (r1, TREE_OPERAND (expr, 1), stmt);\n \t  op.fold_range (r, type, r0, r1);\n@@ -250,11 +252,13 @@ range_query::get_tree_range (irange &r, tree expr, gimple *stmt)\n     {\n       range_op_handler op (TREE_CODE (expr), type);\n       tree op0_type = TREE_TYPE (TREE_OPERAND (expr, 0));\n-      if (op && irange::supports_type_p (op0_type))\n+      if (op && vrange::supports_type_p (op0_type))\n \t{\n-\t  int_range_max r0;\n+\t  Value_Range r0 (TREE_TYPE (TREE_OPERAND (expr, 0)));\n+\t  Value_Range r1 (type);\n+\t  r1.set_varying (type);\n \t  range_of_expr (r0, TREE_OPERAND (expr, 0), stmt);\n-\t  op.fold_range (r, type, r0, int_range<1> (type));\n+\t  op.fold_range (r, type, r0, r1);\n \t}\n       else\n \tr.set_varying (type);\n@@ -311,7 +315,7 @@ get_ssa_name_ptr_info_nonnull (const_tree name)\n // updated.\n \n bool\n-update_global_range (irange &r, tree name)\n+update_global_range (vrange &r, tree name)\n {\n   tree type = TREE_TYPE (name);\n \n@@ -330,8 +334,7 @@ update_global_range (irange &r, tree name)\n       if (r.undefined_p ())\n \treturn false;\n \n-      value_range vr = r;\n-      set_range_info (name, vr);\n+      set_range_info (name, as_a <irange> (r));\n       return true;\n     }\n   else if (POINTER_TYPE_P (type))\n@@ -349,7 +352,7 @@ update_global_range (irange &r, tree name)\n // return VARYING.\n \n static void\n-get_range_global (irange &r, tree name)\n+get_range_global (vrange &r, tree name)\n {\n   tree type = TREE_TYPE (name);\n \n@@ -369,7 +372,7 @@ get_range_global (irange &r, tree name)\n \t    r.set_nonzero (type);\n \t  else if (INTEGRAL_TYPE_P (type))\n \t    {\n-\t      get_ssa_name_range_info (r, name);\n+\t      get_ssa_name_range_info (as_a <irange> (r), name);\n \t      if (r.undefined_p ())\n \t\tr.set_varying (type);\n \t    }\n@@ -384,7 +387,8 @@ get_range_global (irange &r, tree name)\n    }\n   else if (!POINTER_TYPE_P (type) && SSA_NAME_RANGE_INFO (name))\n     {\n-      get_ssa_name_range_info (r, name);\n+      gcc_checking_assert (irange::supports_type_p (TREE_TYPE (name)));\n+      get_ssa_name_range_info (as_a <irange> (r), name);\n       if (r.undefined_p ())\n \tr.set_varying (type);\n     }\n@@ -414,21 +418,19 @@ get_range_global (irange &r, tree name)\n // See discussion here:\n // https://gcc.gnu.org/pipermail/gcc-patches/2021-June/571709.html\n \n-value_range\n-gimple_range_global (tree name)\n+void\n+gimple_range_global (vrange &r, tree name)\n {\n   tree type = TREE_TYPE (name);\n-  gcc_checking_assert (TREE_CODE (name) == SSA_NAME\n-\t\t       && irange::supports_type_p (type));\n+  gcc_checking_assert (TREE_CODE (name) == SSA_NAME);\n \n   if (SSA_NAME_IS_DEFAULT_DEF (name) || (cfun && cfun->after_inlining)\n       || is_a<gphi *> (SSA_NAME_DEF_STMT (name)))\n     {\n-      value_range vr;\n-      get_range_global (vr, name);\n-      return vr;\n+      get_range_global (r, name);\n+      return;\n     }\n-  return value_range (type);\n+  r.set_varying (type);\n }\n \n // ----------------------------------------------\n@@ -437,7 +439,7 @@ gimple_range_global (tree name)\n global_range_query global_ranges;\n \n bool\n-global_range_query::range_of_expr (irange &r, tree expr, gimple *stmt)\n+global_range_query::range_of_expr (vrange &r, tree expr, gimple *stmt)\n {\n   tree type = TREE_TYPE (expr);\n \n@@ -456,15 +458,16 @@ global_range_query::range_of_expr (irange &r, tree expr, gimple *stmt)\n relation_kind\n range_query::query_relation (gimple *s, tree ssa1, tree ssa2, bool get_range)\n {\n-  int_range_max tmp;\n   if (!m_oracle || TREE_CODE (ssa1) != SSA_NAME || TREE_CODE (ssa2) != SSA_NAME)\n     return VREL_VARYING;\n \n   // Ensure ssa1 and ssa2 have both been evaluated.\n   if (get_range)\n     {\n-      range_of_expr (tmp, ssa1, s);\n-      range_of_expr (tmp, ssa2, s);\n+      Value_Range tmp1 (TREE_TYPE (ssa1));\n+      Value_Range tmp2 (TREE_TYPE (ssa2));\n+      range_of_expr (tmp1, ssa1, s);\n+      range_of_expr (tmp2, ssa2, s);\n     }\n   return m_oracle->query_relation (gimple_bb (s), ssa1, ssa2);\n }\n@@ -477,7 +480,6 @@ relation_kind\n range_query::query_relation (edge e, tree ssa1, tree ssa2, bool get_range)\n {\n   basic_block bb;\n-  int_range_max tmp;\n   if (!m_oracle || TREE_CODE (ssa1) != SSA_NAME || TREE_CODE (ssa2) != SSA_NAME)\n     return VREL_VARYING;\n \n@@ -492,6 +494,7 @@ range_query::query_relation (edge e, tree ssa1, tree ssa2, bool get_range)\n   // Ensure ssa1 and ssa2 have both been evaluated.\n   if (get_range)\n     {\n+      Value_Range tmp (TREE_TYPE (ssa1));\n       range_on_edge (tmp, e, ssa1);\n       range_on_edge (tmp, e, ssa2);\n     }"}, {"sha": "280e47e3f6b1147379c1b4bdb2dfde9a6d02ff65", "filename": "gcc/value-query.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fvalue-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fvalue-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.h?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -89,9 +89,9 @@ class range_query : public value_query\n   //\n   // Note that range_of_expr must always return TRUE unless ranges are\n   // unsupported for EXPR's type (supports_type_p is false).\n-  virtual bool range_of_expr (irange &r, tree expr, gimple * = NULL) = 0;\n-  virtual bool range_on_edge (irange &r, edge, tree expr);\n-  virtual bool range_of_stmt (irange &r, gimple *, tree name = NULL);\n+  virtual bool range_of_expr (vrange &r, tree expr, gimple * = NULL) = 0;\n+  virtual bool range_on_edge (vrange &r, edge, tree expr);\n+  virtual bool range_of_stmt (vrange &r, gimple *, tree name = NULL);\n \n   // Query if there is any relation between SSA1 and SSA2.\n   relation_kind query_relation (gimple *s, tree ssa1, tree ssa2,\n@@ -110,8 +110,8 @@ class range_query : public value_query\n protected:\n   class value_range_equiv *allocate_value_range_equiv ();\n   void free_value_range_equiv (class value_range_equiv *);\n-  bool get_tree_range (irange &r, tree expr, gimple *stmt);\n-  bool get_arith_expr_range (irange &r, tree expr, gimple *stmt);\n+  bool get_tree_range (vrange &v, tree expr, gimple *stmt);\n+  bool get_arith_expr_range (vrange &r, tree expr, gimple *stmt);\n   relation_oracle *m_oracle;\n \n private:\n@@ -123,7 +123,7 @@ class range_query : public value_query\n class global_range_query : public range_query\n {\n public:\n-  bool range_of_expr (irange &r, tree expr, gimple * = NULL) override;\n+  bool range_of_expr (vrange &r, tree expr, gimple * = NULL) override;\n };\n \n extern global_range_query global_ranges;\n@@ -143,7 +143,7 @@ get_range_query (const struct function *fun)\n   return fun->x_range_query ? fun->x_range_query : &global_ranges;\n }\n \n-extern value_range gimple_range_global (tree name);\n-extern bool update_global_range (irange &r, tree name);\n+extern void gimple_range_global (vrange &v, tree name);\n+extern bool update_global_range (vrange &v, tree name);\n \n #endif // GCC_QUERY_H"}, {"sha": "38f204e2f5d6d729627ffc68a8ff353980eb8cf1", "filename": "gcc/vr-values.cc", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fvr-values.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fvr-values.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.cc?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -177,7 +177,7 @@ vr_values::get_value_range (const_tree var,\n }\n \n bool\n-vr_values::range_of_expr (irange &r, tree expr, gimple *stmt)\n+vr_values::range_of_expr (vrange &r, tree expr, gimple *stmt)\n {\n   if (!gimple_range_ssa_p (expr))\n     return get_tree_range (r, expr, stmt);\n@@ -1630,6 +1630,20 @@ compare_range_with_value (enum tree_code comp, const value_range *vr,\n   gcc_unreachable ();\n }\n \n+static inline void\n+fix_overflow (tree *min, tree *max)\n+{\n+  /* Even for valid range info, sometimes overflow flag will leak in.\n+     As GIMPLE IL should have no constants with TREE_OVERFLOW set, we\n+     drop them.  */\n+  if (TREE_OVERFLOW_P (*min))\n+    *min = drop_tree_overflow (*min);\n+  if (TREE_OVERFLOW_P (*max))\n+    *max = drop_tree_overflow (*max);\n+\n+  gcc_checking_assert (compare_values (*min, *max) != 1);\n+}\n+\n /* Given a VAR in STMT within LOOP, determine the bounds of the\n    variable and store it in MIN/MAX and return TRUE.  If no bounds\n    could be determined, return FALSE.  */\n@@ -1640,14 +1654,16 @@ bounds_of_var_in_loop (tree *min, tree *max, range_query *query,\n {\n   tree init, step, chrec, tmin, tmax, type = TREE_TYPE (var);\n   enum ev_direction dir;\n+  int_range<2> r;\n \n   chrec = instantiate_parameters (loop, analyze_scalar_evolution (loop, var));\n \n   /* Like in PR19590, scev can return a constant function.  */\n   if (is_gimple_min_invariant (chrec))\n     {\n       *min = *max = chrec;\n-      goto fix_overflow;\n+      fix_overflow (min, max);\n+      return true;\n     }\n \n   if (TREE_CODE (chrec) != POLYNOMIAL_CHREC)\n@@ -1659,13 +1675,17 @@ bounds_of_var_in_loop (tree *min, tree *max, range_query *query,\n   if (!init || !step)\n     return false;\n \n+  Value_Range rinit (TREE_TYPE (init));\n+  Value_Range rstep (TREE_TYPE (step));\n   /* If INIT is an SSA with a singleton range, set INIT to said\n      singleton, otherwise leave INIT alone.  */\n-  if (TREE_CODE (init) == SSA_NAME)\n-    query->get_value_range (init, stmt)->singleton_p (&init);\n+  if (TREE_CODE (init) == SSA_NAME\n+      && query->range_of_expr (rinit, init, stmt))\n+    rinit.singleton_p (&init);\n   /* Likewise for step.  */\n-  if (TREE_CODE (step) == SSA_NAME)\n-    query->get_value_range (step, stmt)->singleton_p (&step);\n+  if (TREE_CODE (step) == SSA_NAME\n+      && query->range_of_expr (rstep, step, stmt))\n+    rstep.singleton_p (&step);\n \n   /* If STEP is symbolic, we can't know whether INIT will be the\n      minimum or maximum value in the range.  Also, unless INIT is\n@@ -1699,7 +1719,8 @@ bounds_of_var_in_loop (tree *min, tree *max, range_query *query,\n   if (TREE_CODE (step) == INTEGER_CST\n       && is_gimple_val (init)\n       && (TREE_CODE (init) != SSA_NAME\n-\t  || query->get_value_range (init, stmt)->kind () == VR_RANGE))\n+\t  || (query->range_of_expr (r, init, stmt)\n+\t      && r.kind () == VR_RANGE)))\n     {\n       widest_int nit;\n \n@@ -1724,7 +1745,7 @@ bounds_of_var_in_loop (tree *min, tree *max, range_query *query,\n \t    {\n \t      value_range maxvr, vr0, vr1;\n \t      if (TREE_CODE (init) == SSA_NAME)\n-\t\tvr0 = *(query->get_value_range (init, stmt));\n+\t\tquery->range_of_expr (vr0, init, stmt);\n \t      else if (is_gimple_min_invariant (init))\n \t\tvr0.set (init);\n \t      else\n@@ -1737,10 +1758,10 @@ bounds_of_var_in_loop (tree *min, tree *max, range_query *query,\n \t      /* Likewise if the addition did.  */\n \t      if (maxvr.kind () == VR_RANGE)\n \t\t{\n-\t\t  value_range initvr;\n+\t\t  int_range<2> initvr;\n \n \t\t  if (TREE_CODE (init) == SSA_NAME)\n-\t\t    initvr = *(query->get_value_range (init, stmt));\n+\t\t    query->range_of_expr (initvr, init, stmt);\n \t\t  else if (is_gimple_min_invariant (init))\n \t\t    initvr.set (init);\n \t\t  else\n@@ -1770,16 +1791,7 @@ bounds_of_var_in_loop (tree *min, tree *max, range_query *query,\n   else\n     *min = init;\n \n- fix_overflow:\n-  /* Even for valid range info, sometimes overflow flag will leak in.\n-     As GIMPLE IL should have no constants with TREE_OVERFLOW set, we\n-     drop them.  */\n-  if (TREE_OVERFLOW_P (*min))\n-    *min = drop_tree_overflow (*min);\n-  if (TREE_OVERFLOW_P (*max))\n-    *max = drop_tree_overflow (*max);\n-\n-  gcc_checking_assert (compare_values (*min, *max) != 1);\n+  fix_overflow (min, max);\n   return true;\n }\n \n@@ -2446,7 +2458,9 @@ simplify_using_ranges::vrp_visit_cond_stmt (gcond *stmt, edge *taken_edge_p)\n \t  fprintf (dump_file, \"\\t\");\n \t  print_generic_expr (dump_file, use);\n \t  fprintf (dump_file, \": \");\n-\t  dump_value_range (dump_file, query->get_value_range (use, stmt));\n+\t  Value_Range r (TREE_TYPE (use));\n+\t  query->range_of_expr (r, use, stmt);\n+\t  r.dump (dump_file);\n \t}\n \n       fprintf (dump_file, \"\\n\");"}, {"sha": "f018d0dfc4bf8e35736fc6978af60c4df056d3cb", "filename": "gcc/vr-values.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=45c8523dd3e50daa5f0bba040099fdfd2ad1aaaa", "patch": "@@ -109,7 +109,7 @@ class vr_values : public range_query\n   vr_values (void);\n   ~vr_values (void);\n \n-  virtual bool range_of_expr (irange &r, tree expr, gimple *stmt) override;\n+  virtual bool range_of_expr (vrange &r, tree expr, gimple *stmt) override;\n   virtual tree value_of_expr (tree, gimple * = NULL) override;\n   virtual tree value_on_edge (edge, tree) override;\n   virtual tree value_of_stmt (gimple *, tree = NULL_TREE) override;"}]}