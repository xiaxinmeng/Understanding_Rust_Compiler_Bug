{"sha": "7f20a5b73d6dedc9b3e157e3a25392276a94b112", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2YyMGE1YjczZDZkZWRjOWIzZTE1N2UzYTI1MzkyMjc2YTk0YjExMg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-25T16:49:32Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-25T16:49:32Z"}, "message": "fold-const.c: Convert uses of fold (build (...)) to fold_buildN.\n\n\t* fold-const.c: Convert uses of fold (build (...)) to\n\tfold_buildN.\n\nFrom-SVN: r97046", "tree": {"sha": "0149ef86d31a2ca0bebd035664ef319c7add9010", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0149ef86d31a2ca0bebd035664ef319c7add9010"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f20a5b73d6dedc9b3e157e3a25392276a94b112", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f20a5b73d6dedc9b3e157e3a25392276a94b112", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f20a5b73d6dedc9b3e157e3a25392276a94b112", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f20a5b73d6dedc9b3e157e3a25392276a94b112/comments", "author": null, "committer": null, "parents": [{"sha": "aec6cb103c514a5f03990546a3f7481a84b9485c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aec6cb103c514a5f03990546a3f7481a84b9485c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aec6cb103c514a5f03990546a3f7481a84b9485c"}], "stats": {"total": 1047, "additions": 526, "deletions": 521}, "files": [{"sha": "96511134d4c2fc3100d81ab5e97ca7d158037271", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f20a5b73d6dedc9b3e157e3a25392276a94b112/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f20a5b73d6dedc9b3e157e3a25392276a94b112/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7f20a5b73d6dedc9b3e157e3a25392276a94b112", "patch": "@@ -1,3 +1,8 @@\n+2005-03-25  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* fold-const.c: Convert uses of fold (build (...)) to\n+\tfold_buildN.\n+\n 2005-03-25  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR rtl-optimization/20249"}, {"sha": "d32172f2453acb6e792b8a65cb05c7e8cc2eb9fc", "filename": "gcc/fold-const.c", "status": "modified", "additions": 521, "deletions": 521, "changes": 1042, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f20a5b73d6dedc9b3e157e3a25392276a94b112/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f20a5b73d6dedc9b3e157e3a25392276a94b112/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=7f20a5b73d6dedc9b3e157e3a25392276a94b112", "patch": "@@ -1044,17 +1044,17 @@ negate_expr (tree t)\n \t\t\t\t     TREE_OPERAND (t, 1)))\n \t    {\n \t      tem = negate_expr (TREE_OPERAND (t, 1));\n-\t      tem = fold (build2 (MINUS_EXPR, TREE_TYPE (t),\n-\t\t\t\t  tem, TREE_OPERAND (t, 0)));\n+\t      tem = fold_build2 (MINUS_EXPR, TREE_TYPE (t),\n+\t\t\t\t tem, TREE_OPERAND (t, 0));\n \t      return fold_convert (type, tem);\n \t    }\n \n \t  /* -(A + B) -> (-A) - B.  */\n \t  if (negate_expr_p (TREE_OPERAND (t, 0)))\n \t    {\n \t      tem = negate_expr (TREE_OPERAND (t, 0));\n-\t      tem = fold (build2 (MINUS_EXPR, TREE_TYPE (t),\n-\t\t\t\t  tem, TREE_OPERAND (t, 1)));\n+\t      tem = fold_build2 (MINUS_EXPR, TREE_TYPE (t),\n+\t\t\t\t tem, TREE_OPERAND (t, 1));\n \t      return fold_convert (type, tem);\n \t    }\n \t}\n@@ -1065,9 +1065,9 @@ negate_expr (tree t)\n       if ((! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations)\n \t  && reorder_operands_p (TREE_OPERAND (t, 0), TREE_OPERAND (t, 1)))\n \treturn fold_convert (type,\n-\t\t\t     fold (build2 (MINUS_EXPR, TREE_TYPE (t),\n-\t\t\t\t\t   TREE_OPERAND (t, 1),\n-\t\t\t\t\t   TREE_OPERAND (t, 0))));\n+\t\t\t     fold_build2 (MINUS_EXPR, TREE_TYPE (t),\n+\t\t\t\t\t  TREE_OPERAND (t, 1),\n+\t\t\t\t\t  TREE_OPERAND (t, 0)));\n       break;\n \n     case MULT_EXPR:\n@@ -1082,15 +1082,15 @@ negate_expr (tree t)\n \t  tem = TREE_OPERAND (t, 1);\n \t  if (negate_expr_p (tem))\n \t    return fold_convert (type,\n-\t\t\t\t fold (build2 (TREE_CODE (t), TREE_TYPE (t),\n-\t\t\t\t\t       TREE_OPERAND (t, 0),\n-\t\t\t\t\t       negate_expr (tem))));\n+\t\t\t\t fold_build2 (TREE_CODE (t), TREE_TYPE (t),\n+\t\t\t\t\t      TREE_OPERAND (t, 0),\n+\t\t\t\t\t      negate_expr (tem)));\n \t  tem = TREE_OPERAND (t, 0);\n \t  if (negate_expr_p (tem))\n \t    return fold_convert (type,\n-\t\t\t\t fold (build2 (TREE_CODE (t), TREE_TYPE (t),\n-\t\t\t\t\t       negate_expr (tem),\n-\t\t\t\t\t       TREE_OPERAND (t, 1))));\n+\t\t\t\t fold_build2 (TREE_CODE (t), TREE_TYPE (t),\n+\t\t\t\t\t      negate_expr (tem),\n+\t\t\t\t\t      TREE_OPERAND (t, 1)));\n \t}\n       break;\n \n@@ -1131,7 +1131,7 @@ negate_expr (tree t)\n \t\t\t   ? lang_hooks.types.signed_type (type)\n \t\t\t   : lang_hooks.types.unsigned_type (type);\n \t      tree temp = fold_convert (ntype, TREE_OPERAND (t, 0));\n-\t      temp = fold (build2 (RSHIFT_EXPR, ntype, temp, op1));\n+\t      temp = fold_build2 (RSHIFT_EXPR, ntype, temp, op1);\n \t      return fold_convert (type, temp);\n \t    }\n \t}\n@@ -1141,7 +1141,7 @@ negate_expr (tree t)\n       break;\n     }\n \n-  tem = fold (build1 (NEGATE_EXPR, TREE_TYPE (t), t));\n+  tem = fold_build1 (NEGATE_EXPR, TREE_TYPE (t), t);\n   return fold_convert (type, tem);\n }\n \f\n@@ -1279,8 +1279,8 @@ associate_trees (tree t1, tree t2, enum tree_code code, tree type)\n \t\t     fold_convert (type, t2));\n     }\n \n-  return fold (build2 (code, type, fold_convert (type, t1),\n-\t\t       fold_convert (type, t2)));\n+  return fold_build2 (code, type, fold_convert (type, t1),\n+\t\t      fold_convert (type, t2));\n }\n \f\n /* Combine two integer constants ARG1 and ARG2 under operation CODE\n@@ -1654,7 +1654,7 @@ size_binop (enum tree_code code, tree arg0, tree arg1)\n   if (arg0 == error_mark_node || arg1 == error_mark_node)\n     return error_mark_node;\n \n-  return fold (build2 (code, type, arg0, arg1));\n+  return fold_build2 (code, type, arg0, arg1);\n }\n \n /* Given two values, either both of sizetype or both of bitsizetype,\n@@ -1896,7 +1896,7 @@ fold_convert (tree type, tree arg)\n   if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (orig)\n       || lang_hooks.types_compatible_p (TYPE_MAIN_VARIANT (type),\n \t\t\t\t\tTYPE_MAIN_VARIANT (orig)))\n-    return fold (build1 (NOP_EXPR, type, arg));\n+    return fold_build1 (NOP_EXPR, type, arg);\n \n   switch (TREE_CODE (type))\n     {\n@@ -1911,15 +1911,15 @@ fold_convert (tree type, tree arg)\n \t}\n       if (INTEGRAL_TYPE_P (orig) || POINTER_TYPE_P (orig)\n \t  || TREE_CODE (orig) == OFFSET_TYPE)\n-        return fold (build1 (NOP_EXPR, type, arg));\n+        return fold_build1 (NOP_EXPR, type, arg);\n       if (TREE_CODE (orig) == COMPLEX_TYPE)\n \t{\n-\t  tem = fold (build1 (REALPART_EXPR, TREE_TYPE (orig), arg));\n+\t  tem = fold_build1 (REALPART_EXPR, TREE_TYPE (orig), arg);\n \t  return fold_convert (type, tem);\n \t}\n       gcc_assert (TREE_CODE (orig) == VECTOR_TYPE\n \t\t  && tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (orig)));\n-      return fold (build1 (NOP_EXPR, type, arg));\n+      return fold_build1 (NOP_EXPR, type, arg);\n \n     case REAL_TYPE:\n       if (TREE_CODE (arg) == INTEGER_CST)\n@@ -1940,14 +1940,14 @@ fold_convert (tree type, tree arg)\n \tcase INTEGER_TYPE: case CHAR_TYPE:\n \tcase BOOLEAN_TYPE: case ENUMERAL_TYPE:\n \tcase POINTER_TYPE: case REFERENCE_TYPE:\n-\t  return fold (build1 (FLOAT_EXPR, type, arg));\n+\t  return fold_build1 (FLOAT_EXPR, type, arg);\n \n \tcase REAL_TYPE:\n-\t  return fold (build1 (flag_float_store ? CONVERT_EXPR : NOP_EXPR,\n-\t\t\t       type, arg));\n+\t  return fold_build1 (flag_float_store ? CONVERT_EXPR : NOP_EXPR,\n+\t\t\t      type, arg);\n \n \tcase COMPLEX_TYPE:\n-\t  tem = fold (build1 (REALPART_EXPR, TREE_TYPE (orig), arg));\n+\t  tem = fold_build1 (REALPART_EXPR, TREE_TYPE (orig), arg);\n \t  return fold_convert (type, tem);\n \n \tdefault:\n@@ -1972,15 +1972,15 @@ fold_convert (tree type, tree arg)\n \t      {\n \t\trpart = fold_convert (TREE_TYPE (type), TREE_OPERAND (arg, 0));\n \t\tipart = fold_convert (TREE_TYPE (type), TREE_OPERAND (arg, 1));\n-\t\treturn fold (build2 (COMPLEX_EXPR, type, rpart, ipart));\n+\t\treturn fold_build2 (COMPLEX_EXPR, type, rpart, ipart);\n \t      }\n \n \t    arg = save_expr (arg);\n-\t    rpart = fold (build1 (REALPART_EXPR, TREE_TYPE (orig), arg));\n-\t    ipart = fold (build1 (IMAGPART_EXPR, TREE_TYPE (orig), arg));\n+\t    rpart = fold_build1 (REALPART_EXPR, TREE_TYPE (orig), arg);\n+\t    ipart = fold_build1 (IMAGPART_EXPR, TREE_TYPE (orig), arg);\n \t    rpart = fold_convert (TREE_TYPE (type), rpart);\n \t    ipart = fold_convert (TREE_TYPE (type), ipart);\n-\t    return fold (build2 (COMPLEX_EXPR, type, rpart, ipart));\n+\t    return fold_build2 (COMPLEX_EXPR, type, rpart, ipart);\n \t  }\n \n \tdefault:\n@@ -1993,10 +1993,10 @@ fold_convert (tree type, tree arg)\n       gcc_assert (tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (orig)));\n       gcc_assert (INTEGRAL_TYPE_P (orig) || POINTER_TYPE_P (orig)\n \t\t  || TREE_CODE (orig) == VECTOR_TYPE);\n-      return fold (build1 (NOP_EXPR, type, arg));\n+      return fold_build1 (NOP_EXPR, type, arg);\n \n     case VOID_TYPE:\n-      return fold (build1 (CONVERT_EXPR, type, fold_ignored_result (arg)));\n+      return fold_build1 (CONVERT_EXPR, type, fold_ignored_result (arg));\n \n     default:\n       gcc_unreachable ();\n@@ -2309,8 +2309,8 @@ combine_comparisons (enum tree_code code, enum tree_code lcode,\n   else if (compcode == COMPCODE_FALSE)\n     return constant_boolean_node (false, truth_type);\n   else\n-    return fold (build2 (compcode_to_comparison (compcode),\n-\t\t\t truth_type, ll_arg, lr_arg));\n+    return fold_build2 (compcode_to_comparison (compcode),\n+\t\t\ttruth_type, ll_arg, lr_arg);\n }\n \n /* Return nonzero if CODE is a tree code that represents a truth value.  */\n@@ -2779,16 +2779,16 @@ eval_subst (tree arg, tree old0, tree new0, tree old1, tree new1)\n   switch (class)\n     {\n     case tcc_unary:\n-      return fold (build1 (code, type,\n-\t\t\t   eval_subst (TREE_OPERAND (arg, 0),\n-\t\t\t\t       old0, new0, old1, new1)));\n+      return fold_build1 (code, type,\n+\t\t\t  eval_subst (TREE_OPERAND (arg, 0),\n+\t\t\t\t      old0, new0, old1, new1));\n \n     case tcc_binary:\n-      return fold (build2 (code, type,\n-\t\t\t   eval_subst (TREE_OPERAND (arg, 0),\n-\t\t\t\t       old0, new0, old1, new1),\n-\t\t\t   eval_subst (TREE_OPERAND (arg, 1),\n-\t\t\t\t       old0, new0, old1, new1)));\n+      return fold_build2 (code, type,\n+\t\t\t  eval_subst (TREE_OPERAND (arg, 0),\n+\t\t\t\t      old0, new0, old1, new1),\n+\t\t\t  eval_subst (TREE_OPERAND (arg, 1),\n+\t\t\t\t      old0, new0, old1, new1));\n \n     case tcc_expression:\n       switch (code)\n@@ -2800,13 +2800,13 @@ eval_subst (tree arg, tree old0, tree new0, tree old1, tree new1)\n \t  return eval_subst (TREE_OPERAND (arg, 1), old0, new0, old1, new1);\n \n \tcase COND_EXPR:\n-\t  return fold (build3 (code, type,\n-\t\t\t       eval_subst (TREE_OPERAND (arg, 0),\n-\t\t\t\t\t   old0, new0, old1, new1),\n-\t\t\t       eval_subst (TREE_OPERAND (arg, 1),\n-\t\t\t\t\t   old0, new0, old1, new1),\n-\t\t\t       eval_subst (TREE_OPERAND (arg, 2),\n-\t\t\t\t\t   old0, new0, old1, new1)));\n+\t  return fold_build3 (code, type,\n+\t\t\t      eval_subst (TREE_OPERAND (arg, 0),\n+\t\t\t\t\t  old0, new0, old1, new1),\n+\t\t\t      eval_subst (TREE_OPERAND (arg, 1),\n+\t\t\t\t\t  old0, new0, old1, new1),\n+\t\t\t      eval_subst (TREE_OPERAND (arg, 2),\n+\t\t\t\t\t  old0, new0, old1, new1));\n \tdefault:\n \t  break;\n \t}\n@@ -2831,7 +2831,7 @@ eval_subst (tree arg, tree old0, tree new0, tree old1, tree new1)\n \telse if (arg1 == old1 || operand_equal_p (arg1, old1, 0))\n \t  arg1 = new1;\n \n-\treturn fold (build2 (code, type, arg0, arg1));\n+\treturn fold_build2 (code, type, arg0, arg1);\n       }\n \n     default:\n@@ -3063,8 +3063,8 @@ distribute_bit_expr (enum tree_code code, tree type, tree arg0, tree arg1)\n   else\n     return 0;\n \n-  return fold (build2 (TREE_CODE (arg0), type, common,\n-\t\t       fold (build2 (code, type, left, right))));\n+  return fold_build2 (TREE_CODE (arg0), type, common,\n+\t\t      fold_build2 (code, type, left, right));\n }\n \f\n /* Return a BIT_FIELD_REF of type TYPE to refer to BITSIZE bits of INNER\n@@ -3345,8 +3345,8 @@ decode_field_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \n   /* Merge it with the mask we found in the BIT_AND_EXPR, if any.  */\n   if (and_mask != 0)\n-    mask = fold (build2 (BIT_AND_EXPR, unsigned_type,\n-\t\t\t fold_convert (unsigned_type, and_mask), mask));\n+    mask = fold_build2 (BIT_AND_EXPR, unsigned_type,\n+\t\t\tfold_convert (unsigned_type, and_mask), mask);\n \n   *pmask = mask;\n   *pand_mask = and_mask;\n@@ -3508,8 +3508,8 @@ range_binop (enum tree_code code, tree type, tree arg0, int upper0_p,\n \n   if (arg0 != 0 && arg1 != 0)\n     {\n-      tem = fold (build2 (code, type != 0 ? type : TREE_TYPE (arg0),\n-\t\t\t  arg0, fold_convert (TREE_TYPE (arg0), arg1)));\n+      tem = fold_build2 (code, type != 0 ? type : TREE_TYPE (arg0),\n+\t\t\t arg0, fold_convert (TREE_TYPE (arg0), arg1));\n       STRIP_NOPS (tem);\n       return TREE_CODE (tem) == INTEGER_CST ? tem : 0;\n     }\n@@ -3768,11 +3768,11 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t\t: TYPE_MAX_VALUE (arg0_type);\n \n \t      if (TYPE_PRECISION (exp_type) == TYPE_PRECISION (arg0_type))\n-\t\thigh_positive = fold (build2 (RSHIFT_EXPR, arg0_type,\n-\t\t\t\t\t      fold_convert (arg0_type,\n-\t\t\t\t\t\t\t    high_positive),\n-\t\t\t\t\t      fold_convert (arg0_type,\n-\t\t\t\t\t\t\t    integer_one_node)));\n+\t\thigh_positive = fold_build2 (RSHIFT_EXPR, arg0_type,\n+\t\t\t\t\t     fold_convert (arg0_type,\n+\t\t\t\t\t\t\t   high_positive),\n+\t\t\t\t\t     fold_convert (arg0_type,\n+\t\t\t\t\t\t\t   integer_one_node));\n \n \t      /* If the low bound is specified, \"and\" the range with the\n \t\t range for which the original unsigned value will be\n@@ -3852,13 +3852,13 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n     return fold_convert (type, integer_one_node);\n \n   if (low == 0)\n-    return fold (build2 (LE_EXPR, type, exp, high));\n+    return fold_build2 (LE_EXPR, type, exp, high);\n \n   if (high == 0)\n-    return fold (build2 (GE_EXPR, type, exp, low));\n+    return fold_build2 (GE_EXPR, type, exp, low);\n \n   if (operand_equal_p (low, high, 0))\n-    return fold (build2 (EQ_EXPR, type, exp, low));\n+    return fold_build2 (EQ_EXPR, type, exp, low);\n \n   if (integer_zerop (low))\n     {\n@@ -3897,8 +3897,8 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n \t      etype = lang_hooks.types.signed_type (etype);\n \t      exp = fold_convert (etype, exp);\n \t    }\n-\t  return fold (build2 (GT_EXPR, type, exp,\n-\t\t\t       fold_convert (etype, integer_zero_node)));\n+\t  return fold_build2 (GT_EXPR, type, exp,\n+\t\t\t      fold_convert (etype, integer_zero_node));\n \t}\n     }\n \n@@ -3936,7 +3936,7 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n \n   if (value != 0 && ! TREE_OVERFLOW (value))\n     return build_range_check (type,\n-\t\t\t      fold (build2 (MINUS_EXPR, etype, exp, low)),\n+\t\t\t      fold_build2 (MINUS_EXPR, etype, exp, low),\n \t\t\t      1, fold_convert (etype, integer_zero_node),\n \t\t\t      value);\n \n@@ -4208,7 +4208,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \tif (TYPE_UNSIGNED (TREE_TYPE (arg1)))\n \t  arg1 = fold_convert (lang_hooks.types.signed_type\n \t\t\t       (TREE_TYPE (arg1)), arg1);\n-\ttem = fold (build1 (ABS_EXPR, TREE_TYPE (arg1), arg1));\n+\ttem = fold_build1 (ABS_EXPR, TREE_TYPE (arg1), arg1);\n \treturn pedantic_non_lvalue (fold_convert (type, tem));\n       case UNLE_EXPR:\n       case UNLT_EXPR:\n@@ -4219,7 +4219,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \tif (TYPE_UNSIGNED (TREE_TYPE (arg1)))\n \t  arg1 = fold_convert (lang_hooks.types.signed_type\n \t\t\t       (TREE_TYPE (arg1)), arg1);\n-\ttem = fold (build1 (ABS_EXPR, TREE_TYPE (arg1), arg1));\n+\ttem = fold_build1 (ABS_EXPR, TREE_TYPE (arg1), arg1);\n \treturn negate_expr (fold_convert (type, tem));\n       default:\n \tgcc_assert (TREE_CODE_CLASS (comp_code) == tcc_comparison);\n@@ -4298,8 +4298,8 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \t      comp_op0 = fold_convert (comp_type, comp_op0);\n \t      comp_op1 = fold_convert (comp_type, comp_op1);\n \t      tem = (comp_code == LE_EXPR || comp_code == UNLE_EXPR)\n-\t\t    ? fold (build2 (MIN_EXPR, comp_type, comp_op0, comp_op1))\n-\t\t    : fold (build2 (MIN_EXPR, comp_type, comp_op1, comp_op0));\n+\t\t    ? fold_build2 (MIN_EXPR, comp_type, comp_op0, comp_op1)\n+\t\t    : fold_build2 (MIN_EXPR, comp_type, comp_op1, comp_op0);\n \t      return pedantic_non_lvalue (fold_convert (type, tem));\n \t    }\n \t  break;\n@@ -4312,8 +4312,8 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \t      comp_op0 = fold_convert (comp_type, comp_op0);\n \t      comp_op1 = fold_convert (comp_type, comp_op1);\n \t      tem = (comp_code == GE_EXPR || comp_code == UNGE_EXPR)\n-\t\t    ? fold (build2 (MAX_EXPR, comp_type, comp_op0, comp_op1))\n-\t\t    : fold (build2 (MAX_EXPR, comp_type, comp_op1, comp_op0));\n+\t\t    ? fold_build2 (MAX_EXPR, comp_type, comp_op0, comp_op1)\n+\t\t    : fold_build2 (MAX_EXPR, comp_type, comp_op1, comp_op0);\n \t      return pedantic_non_lvalue (fold_convert (type, tem));\n \t    }\n \t  break;\n@@ -4345,7 +4345,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n       case EQ_EXPR:\n \t/* We can replace A with C1 in this case.  */\n \targ1 = fold_convert (type, arg01);\n-\treturn fold (build3 (COND_EXPR, type, arg0, arg1, arg2));\n+\treturn fold_build3 (COND_EXPR, type, arg0, arg1, arg2);\n \n       case LT_EXPR:\n \t/* If C1 is C2 + 1, this is min(A, C2).  */\n@@ -4355,8 +4355,8 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \t\t\t\tconst_binop (PLUS_EXPR, arg2,\n \t\t\t\t\t     integer_one_node, 0),\n \t\t\t\tOEP_ONLY_CONST))\n-\t  return pedantic_non_lvalue (fold (build2 (MIN_EXPR,\n-\t\t\t\t\t\t    type, arg1, arg2)));\n+\t  return pedantic_non_lvalue (fold_build2 (MIN_EXPR,\n+\t\t\t\t\t\t   type, arg1, arg2));\n \tbreak;\n \n       case LE_EXPR:\n@@ -4367,8 +4367,8 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \t\t\t\tconst_binop (MINUS_EXPR, arg2,\n \t\t\t\t\t     integer_one_node, 0),\n \t\t\t\tOEP_ONLY_CONST))\n-\t  return pedantic_non_lvalue (fold (build2 (MIN_EXPR,\n-\t\t\t\t\t\t    type, arg1, arg2)));\n+\t  return pedantic_non_lvalue (fold_build2 (MIN_EXPR,\n+\t\t\t\t\t\t   type, arg1, arg2));\n \tbreak;\n \n       case GT_EXPR:\n@@ -4379,8 +4379,8 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \t\t\t\tconst_binop (MINUS_EXPR, arg2,\n \t\t\t\t\t     integer_one_node, 0),\n \t\t\t\tOEP_ONLY_CONST))\n-\t  return pedantic_non_lvalue (fold (build2 (MAX_EXPR,\n-\t\t\t\t\t\t    type, arg1, arg2)));\n+\t  return pedantic_non_lvalue (fold_build2 (MAX_EXPR,\n+\t\t\t\t\t\t   type, arg1, arg2));\n \tbreak;\n \n       case GE_EXPR:\n@@ -4391,8 +4391,8 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \t\t\t\tconst_binop (PLUS_EXPR, arg2,\n \t\t\t\t\t     integer_one_node, 0),\n \t\t\t\tOEP_ONLY_CONST))\n-\t  return pedantic_non_lvalue (fold (build2 (MAX_EXPR,\n-\t\t\t\t\t\t    type, arg1, arg2)));\n+\t  return pedantic_non_lvalue (fold_build2 (MAX_EXPR,\n+\t\t\t\t\t\t   type, arg1, arg2));\n \tbreak;\n       case NE_EXPR:\n \tbreak;\n@@ -4780,8 +4780,8 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n       l_const = unextend (l_const, ll_bitsize, ll_unsignedp, ll_and_mask);\n       l_const = const_binop (LSHIFT_EXPR, l_const, size_int (xll_bitpos), 0);\n       if (! integer_zerop (const_binop (BIT_AND_EXPR, l_const,\n-\t\t\t\t\tfold (build1 (BIT_NOT_EXPR,\n-\t\t\t\t\t\t      lntype, ll_mask)),\n+\t\t\t\t\tfold_build1 (BIT_NOT_EXPR,\n+\t\t\t\t\t\t     lntype, ll_mask),\n \t\t\t\t\t0)))\n \t{\n \t  warning (\"comparison is always %d\", wanted_code == NE_EXPR);\n@@ -4795,8 +4795,8 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n       r_const = unextend (r_const, rl_bitsize, rl_unsignedp, rl_and_mask);\n       r_const = const_binop (LSHIFT_EXPR, r_const, size_int (xrl_bitpos), 0);\n       if (! integer_zerop (const_binop (BIT_AND_EXPR, r_const,\n-\t\t\t\t\tfold (build1 (BIT_NOT_EXPR,\n-\t\t\t\t\t\t      lntype, rl_mask)),\n+\t\t\t\t\tfold_build1 (BIT_NOT_EXPR,\n+\t\t\t\t\t\t     lntype, rl_mask),\n \t\t\t\t\t0)))\n \t{\n \t  warning (\"comparison is always %d\", wanted_code == NE_EXPR);\n@@ -5002,42 +5002,42 @@ optimize_minmax_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \n     case GE_EXPR:\n       return\n-\tfold (build2 (TRUTH_ORIF_EXPR, type,\n-\t\t      optimize_minmax_comparison\n-\t\t      (EQ_EXPR, type, arg0, comp_const),\n-\t\t      optimize_minmax_comparison\n-\t\t      (GT_EXPR, type, arg0, comp_const)));\n+\tfold_build2 (TRUTH_ORIF_EXPR, type,\n+\t\t     optimize_minmax_comparison\n+\t\t     (EQ_EXPR, type, arg0, comp_const),\n+\t\t     optimize_minmax_comparison\n+\t\t     (GT_EXPR, type, arg0, comp_const));\n \n     case EQ_EXPR:\n       if (op_code == MAX_EXPR && consts_equal)\n \t/* MAX (X, 0) == 0  ->  X <= 0  */\n-\treturn fold (build2 (LE_EXPR, type, inner, comp_const));\n+\treturn fold_build2 (LE_EXPR, type, inner, comp_const);\n \n       else if (op_code == MAX_EXPR && consts_lt)\n \t/* MAX (X, 0) == 5  ->  X == 5   */\n-\treturn fold (build2 (EQ_EXPR, type, inner, comp_const));\n+\treturn fold_build2 (EQ_EXPR, type, inner, comp_const);\n \n       else if (op_code == MAX_EXPR)\n \t/* MAX (X, 0) == -1  ->  false  */\n \treturn omit_one_operand (type, integer_zero_node, inner);\n \n       else if (consts_equal)\n \t/* MIN (X, 0) == 0  ->  X >= 0  */\n-\treturn fold (build2 (GE_EXPR, type, inner, comp_const));\n+\treturn fold_build2 (GE_EXPR, type, inner, comp_const);\n \n       else if (consts_lt)\n \t/* MIN (X, 0) == 5  ->  false  */\n \treturn omit_one_operand (type, integer_zero_node, inner);\n \n       else\n \t/* MIN (X, 0) == -1  ->  X == -1  */\n-\treturn fold (build2 (EQ_EXPR, type, inner, comp_const));\n+\treturn fold_build2 (EQ_EXPR, type, inner, comp_const);\n \n     case GT_EXPR:\n       if (op_code == MAX_EXPR && (consts_equal || consts_lt))\n \t/* MAX (X, 0) > 0  ->  X > 0\n \t   MAX (X, 0) > 5  ->  X > 5  */\n-\treturn fold (build2 (GT_EXPR, type, inner, comp_const));\n+\treturn fold_build2 (GT_EXPR, type, inner, comp_const);\n \n       else if (op_code == MAX_EXPR)\n \t/* MAX (X, 0) > -1  ->  true  */\n@@ -5050,7 +5050,7 @@ optimize_minmax_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \n       else\n \t/* MIN (X, 0) > -1  ->  X > -1  */\n-\treturn fold (build2 (GT_EXPR, type, inner, comp_const));\n+\treturn fold_build2 (GT_EXPR, type, inner, comp_const);\n \n     default:\n       return NULL_TREE;\n@@ -5175,15 +5175,15 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n           tree cstype = (*lang_hooks.types.signed_type) (ctype);\n           if ((t1 = extract_muldiv (op0, c, code, cstype)) != 0)\n             {\n-              t1 = fold (build1 (tcode, cstype, fold_convert (cstype, t1)));\n+              t1 = fold_build1 (tcode, cstype, fold_convert (cstype, t1));\n               return fold_convert (ctype, t1);\n             }\n           break;\n         }\n       /* FALLTHROUGH */\n     case NEGATE_EXPR:\n       if ((t1 = extract_muldiv (op0, c, code, wide_type)) != 0)\n-\treturn fold (build1 (tcode, ctype, fold_convert (ctype, t1)));\n+\treturn fold_build1 (tcode, ctype, fold_convert (ctype, t1));\n       break;\n \n     case MIN_EXPR:  case MAX_EXPR:\n@@ -5199,8 +5199,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t  if (tree_int_cst_sgn (c) < 0)\n \t    tcode = (tcode == MIN_EXPR ? MAX_EXPR : MIN_EXPR);\n \n-\t  return fold (build2 (tcode, ctype, fold_convert (ctype, t1),\n-\t\t\t       fold_convert (ctype, t2)));\n+\t  return fold_build2 (tcode, ctype, fold_convert (ctype, t1),\n+\t\t\t      fold_convert (ctype, t2));\n \t}\n       break;\n \n@@ -5241,8 +5241,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t\t are divisible by c.  */\n \t      || (multiple_of_p (ctype, op0, c)\n \t          && multiple_of_p (ctype, op1, c))))\n-\treturn fold (build2 (tcode, ctype, fold_convert (ctype, t1),\n-\t\t\t     fold_convert (ctype, t2)));\n+\treturn fold_build2 (tcode, ctype, fold_convert (ctype, t1),\n+\t\t\t    fold_convert (ctype, t2));\n \n       /* If this was a subtraction, negate OP1 and set it to be an addition.\n \t This simplifies the logic below.  */\n@@ -5292,17 +5292,17 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n       /* If we were able to eliminate our operation from the first side,\n \t apply our operation to the second side and reform the PLUS.  */\n       if (t1 != 0 && (TREE_CODE (t1) != code || code == MULT_EXPR))\n-\treturn fold (build2 (tcode, ctype, fold_convert (ctype, t1), op1));\n+\treturn fold_build2 (tcode, ctype, fold_convert (ctype, t1), op1);\n \n       /* The last case is if we are a multiply.  In that case, we can\n \t apply the distributive law to commute the multiply and addition\n \t if the multiplication of the constants doesn't overflow.  */\n       if (code == MULT_EXPR)\n-\treturn fold (build2 (tcode, ctype,\n-\t\t\t     fold (build2 (code, ctype,\n-\t\t\t\t\t   fold_convert (ctype, op0),\n-\t\t\t\t\t   fold_convert (ctype, c))),\n-\t\t\t     op1));\n+\treturn fold_build2 (tcode, ctype,\n+\t\t\t    fold_build2 (code, ctype,\n+\t\t\t\t\t fold_convert (ctype, op0),\n+\t\t\t\t\t fold_convert (ctype, c)),\n+\t\t\t    op1);\n \n       break;\n \n@@ -5324,12 +5324,12 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t do something only if the second operand is a constant.  */\n       if (same_p\n \t  && (t1 = extract_muldiv (op0, c, code, wide_type)) != 0)\n-\treturn fold (build2 (tcode, ctype, fold_convert (ctype, t1),\n-\t\t\t     fold_convert (ctype, op1)));\n+\treturn fold_build2 (tcode, ctype, fold_convert (ctype, t1),\n+\t\t\t    fold_convert (ctype, op1));\n       else if (tcode == MULT_EXPR && code == MULT_EXPR\n \t       && (t1 = extract_muldiv (op1, c, code, wide_type)) != 0)\n-\treturn fold (build2 (tcode, ctype, fold_convert (ctype, op0),\n-\t\t\t     fold_convert (ctype, t1)));\n+\treturn fold_build2 (tcode, ctype, fold_convert (ctype, op0),\n+\t\t\t    fold_convert (ctype, t1));\n       else if (TREE_CODE (op1) != INTEGER_CST)\n \treturn 0;\n \n@@ -5339,7 +5339,7 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t  && 0 != (t1 = const_binop (MULT_EXPR, fold_convert (ctype, op1),\n \t\t\t\t     fold_convert (ctype, c), 0))\n \t  && ! TREE_OVERFLOW (t1))\n-\treturn fold (build2 (tcode, ctype, fold_convert (ctype, op0), t1));\n+\treturn fold_build2 (tcode, ctype, fold_convert (ctype, op0), t1);\n \n       /* If these operations \"cancel\" each other, we have the main\n \t optimizations of this pass, which occur when either constant is a\n@@ -5358,15 +5358,15 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t\t  && code != FLOOR_MOD_EXPR && code != ROUND_MOD_EXPR)))\n \t{\n \t  if (integer_zerop (const_binop (TRUNC_MOD_EXPR, op1, c, 0)))\n-\t    return fold (build2 (tcode, ctype, fold_convert (ctype, op0),\n-\t\t\t\t fold_convert (ctype,\n-\t\t\t\t\t       const_binop (TRUNC_DIV_EXPR,\n-\t\t\t\t\t\t\t    op1, c, 0))));\n+\t    return fold_build2 (tcode, ctype, fold_convert (ctype, op0),\n+\t\t\t\tfold_convert (ctype,\n+\t\t\t\t\t      const_binop (TRUNC_DIV_EXPR,\n+\t\t\t\t\t\t\t   op1, c, 0)));\n \t  else if (integer_zerop (const_binop (TRUNC_MOD_EXPR, c, op1, 0)))\n-\t    return fold (build2 (code, ctype, fold_convert (ctype, op0),\n-\t\t\t\t fold_convert (ctype,\n-\t\t\t\t\t       const_binop (TRUNC_DIV_EXPR,\n-\t\t\t\t\t\t\t    c, op1, 0))));\n+\t    return fold_build2 (code, ctype, fold_convert (ctype, op0),\n+\t\t\t\tfold_convert (ctype,\n+\t\t\t\t\t      const_binop (TRUNC_DIV_EXPR,\n+\t\t\t\t\t\t\t   c, op1, 0)));\n \t}\n       break;\n \n@@ -5503,7 +5503,7 @@ fold_binary_op_with_conditional_arg (enum tree_code code,\n \t\t\t     : build2 (code, type, arg, false_value));\n     }\n \n-  test = fold (build3 (COND_EXPR, type, test, lhs, rhs));\n+  test = fold_build3 (COND_EXPR, type, test, lhs, rhs);\n   return fold_convert (type, test);\n }\n \n@@ -5581,8 +5581,8 @@ fold_mathfn_compare (enum built_in_function fcode, enum tree_code code,\n \t    return omit_one_operand (type, integer_one_node, arg);\n \n \t  /* sqrt(x) > y is the same as x >= 0, if y is negative.  */\n-\t  return fold (build2 (GE_EXPR, type, arg,\n-\t\t\t       build_real (TREE_TYPE (arg), dconst0)));\n+\t  return fold_build2 (GE_EXPR, type, arg,\n+\t\t\t      build_real (TREE_TYPE (arg), dconst0));\n \t}\n       else if (code == GT_EXPR || code == GE_EXPR)\n \t{\n@@ -5595,17 +5595,17 @@ fold_mathfn_compare (enum built_in_function fcode, enum tree_code code,\n \t    {\n \t      /* sqrt(x) > y is x == +Inf, when y is very large.  */\n \t      if (HONOR_INFINITIES (mode))\n-\t\treturn fold (build2 (EQ_EXPR, type, arg,\n-\t\t\t\t     build_real (TREE_TYPE (arg), c2)));\n+\t\treturn fold_build2 (EQ_EXPR, type, arg,\n+\t\t\t\t    build_real (TREE_TYPE (arg), c2));\n \n \t      /* sqrt(x) > y is always false, when y is very large\n \t\t and we don't care about infinities.  */\n \t      return omit_one_operand (type, integer_zero_node, arg);\n \t    }\n \n \t  /* sqrt(x) > c is the same as x > c*c.  */\n-\t  return fold (build2 (code, type, arg,\n-\t\t\t       build_real (TREE_TYPE (arg), c2)));\n+\t  return fold_build2 (code, type, arg,\n+\t\t\t      build_real (TREE_TYPE (arg), c2));\n \t}\n       else if (code == LT_EXPR || code == LE_EXPR)\n \t{\n@@ -5624,47 +5624,47 @@ fold_mathfn_compare (enum built_in_function fcode, enum tree_code code,\n \t      /* sqrt(x) < y is x != +Inf when y is very large and we\n \t\t don't care about NaNs.  */\n \t      if (! HONOR_NANS (mode))\n-\t\treturn fold (build2 (NE_EXPR, type, arg,\n-\t\t\t\t     build_real (TREE_TYPE (arg), c2)));\n+\t\treturn fold_build2 (NE_EXPR, type, arg,\n+\t\t\t\t    build_real (TREE_TYPE (arg), c2));\n \n \t      /* sqrt(x) < y is x >= 0 when y is very large and we\n \t\t don't care about Infinities.  */\n \t      if (! HONOR_INFINITIES (mode))\n-\t\treturn fold (build2 (GE_EXPR, type, arg,\n-\t\t\t\t     build_real (TREE_TYPE (arg), dconst0)));\n+\t\treturn fold_build2 (GE_EXPR, type, arg,\n+\t\t\t\t    build_real (TREE_TYPE (arg), dconst0));\n \n \t      /* sqrt(x) < y is x >= 0 && x != +Inf, when y is large.  */\n \t      if (lang_hooks.decls.global_bindings_p () != 0\n \t\t  || CONTAINS_PLACEHOLDER_P (arg))\n \t\treturn NULL_TREE;\n \n \t      arg = save_expr (arg);\n-\t      return fold (build2 (TRUTH_ANDIF_EXPR, type,\n-\t\t\t\t   fold (build2 (GE_EXPR, type, arg,\n-\t\t\t\t\t\t build_real (TREE_TYPE (arg),\n-\t\t\t\t\t\t\t     dconst0))),\n-\t\t\t\t   fold (build2 (NE_EXPR, type, arg,\n-\t\t\t\t\t\t build_real (TREE_TYPE (arg),\n-\t\t\t\t\t\t\t     c2)))));\n+\t      return fold_build2 (TRUTH_ANDIF_EXPR, type,\n+\t\t\t\t  fold_build2 (GE_EXPR, type, arg,\n+\t\t\t\t\t       build_real (TREE_TYPE (arg),\n+\t\t\t\t\t\t\t   dconst0)),\n+\t\t\t\t  fold_build2 (NE_EXPR, type, arg,\n+\t\t\t\t\t       build_real (TREE_TYPE (arg),\n+\t\t\t\t\t\t\t   c2)));\n \t    }\n \n \t  /* sqrt(x) < c is the same as x < c*c, if we ignore NaNs.  */\n \t  if (! HONOR_NANS (mode))\n-\t    return fold (build2 (code, type, arg,\n-\t\t\t\t build_real (TREE_TYPE (arg), c2)));\n+\t    return fold_build2 (code, type, arg,\n+\t\t\t\tbuild_real (TREE_TYPE (arg), c2));\n \n \t  /* sqrt(x) < c is the same as x >= 0 && x < c*c.  */\n \t  if (lang_hooks.decls.global_bindings_p () == 0\n \t      && ! CONTAINS_PLACEHOLDER_P (arg))\n \t    {\n \t      arg = save_expr (arg);\n-\t      return fold (build2 (TRUTH_ANDIF_EXPR, type,\n-\t\t\t\t   fold (build2 (GE_EXPR, type, arg,\n-\t\t\t\t\t\t build_real (TREE_TYPE (arg),\n-\t\t\t\t\t\t\t     dconst0))),\n-\t\t\t\t   fold (build2 (code, type, arg,\n-\t\t\t\t\t\t build_real (TREE_TYPE (arg),\n-\t\t\t\t\t\t\t     c2)))));\n+\t      return fold_build2 (TRUTH_ANDIF_EXPR, type,\n+\t\t\t\t  fold_build2 (GE_EXPR, type, arg,\n+\t\t\t\t\t       build_real (TREE_TYPE (arg),\n+\t\t\t\t\t\t\t   dconst0)),\n+\t\t\t\t  fold_build2 (code, type, arg,\n+\t\t\t\t\t       build_real (TREE_TYPE (arg),\n+\t\t\t\t\t\t\t   c2)));\n \t    }\n \t}\n     }\n@@ -5715,38 +5715,38 @@ fold_inf_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \t  && ! CONTAINS_PLACEHOLDER_P (arg0))\n \t{\n \t  arg0 = save_expr (arg0);\n-\t  return fold (build2 (EQ_EXPR, type, arg0, arg0));\n+\t  return fold_build2 (EQ_EXPR, type, arg0, arg0);\n \t}\n       break;\n \n     case EQ_EXPR:\n     case GE_EXPR:\n       /* x == +Inf and x >= +Inf are always equal to x > DBL_MAX.  */\n       real_maxval (&max, neg, mode);\n-      return fold (build2 (neg ? LT_EXPR : GT_EXPR, type,\n-\t\t\t   arg0, build_real (TREE_TYPE (arg0), max)));\n+      return fold_build2 (neg ? LT_EXPR : GT_EXPR, type,\n+\t\t\t  arg0, build_real (TREE_TYPE (arg0), max));\n \n     case LT_EXPR:\n       /* x < +Inf is always equal to x <= DBL_MAX.  */\n       real_maxval (&max, neg, mode);\n-      return fold (build2 (neg ? GE_EXPR : LE_EXPR, type,\n-\t\t\t   arg0, build_real (TREE_TYPE (arg0), max)));\n+      return fold_build2 (neg ? GE_EXPR : LE_EXPR, type,\n+\t\t\t  arg0, build_real (TREE_TYPE (arg0), max));\n \n     case NE_EXPR:\n       /* x != +Inf is always equal to !(x > DBL_MAX).  */\n       real_maxval (&max, neg, mode);\n       if (! HONOR_NANS (mode))\n-\treturn fold (build2 (neg ? GE_EXPR : LE_EXPR, type,\n-\t\t\t     arg0, build_real (TREE_TYPE (arg0), max)));\n+\treturn fold_build2 (neg ? GE_EXPR : LE_EXPR, type,\n+\t\t\t    arg0, build_real (TREE_TYPE (arg0), max));\n \n       /* The transformation below creates non-gimple code and thus is\n \t not appropriate if we are in gimple form.  */\n       if (in_gimple_form)\n \treturn NULL_TREE;\n \n-      temp = fold (build2 (neg ? LT_EXPR : GT_EXPR, type,\n-\t\t\t   arg0, build_real (TREE_TYPE (arg0), max)));\n-      return fold (build1 (TRUTH_NOT_EXPR, type, temp));\n+      temp = fold_build2 (neg ? LT_EXPR : GT_EXPR, type,\n+\t\t\t  arg0, build_real (TREE_TYPE (arg0), max));\n+      return fold_build1 (TRUTH_NOT_EXPR, type, temp);\n \n     default:\n       break;\n@@ -5858,39 +5858,39 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n       if (TREE_OVERFLOW (lo) && TREE_OVERFLOW (hi))\n \treturn omit_one_operand (type, integer_zero_node, arg00);\n       if (TREE_OVERFLOW (hi))\n-\treturn fold (build2 (GE_EXPR, type, arg00, lo));\n+\treturn fold_build2 (GE_EXPR, type, arg00, lo);\n       if (TREE_OVERFLOW (lo))\n-\treturn fold (build2 (LE_EXPR, type, arg00, hi));\n+\treturn fold_build2 (LE_EXPR, type, arg00, hi);\n       return build_range_check (type, arg00, 1, lo, hi);\n \n     case NE_EXPR:\n       if (TREE_OVERFLOW (lo) && TREE_OVERFLOW (hi))\n \treturn omit_one_operand (type, integer_one_node, arg00);\n       if (TREE_OVERFLOW (hi))\n-\treturn fold (build2 (LT_EXPR, type, arg00, lo));\n+\treturn fold_build2 (LT_EXPR, type, arg00, lo);\n       if (TREE_OVERFLOW (lo))\n-\treturn fold (build2 (GT_EXPR, type, arg00, hi));\n+\treturn fold_build2 (GT_EXPR, type, arg00, hi);\n       return build_range_check (type, arg00, 0, lo, hi);\n \n     case LT_EXPR:\n       if (TREE_OVERFLOW (lo))\n \treturn omit_one_operand (type, integer_zero_node, arg00);\n-      return fold (build2 (LT_EXPR, type, arg00, lo));\n+      return fold_build2 (LT_EXPR, type, arg00, lo);\n \n     case LE_EXPR:\n       if (TREE_OVERFLOW (hi))\n \treturn omit_one_operand (type, integer_one_node, arg00);\n-      return fold (build2 (LE_EXPR, type, arg00, hi));\n+      return fold_build2 (LE_EXPR, type, arg00, hi);\n \n     case GT_EXPR:\n       if (TREE_OVERFLOW (hi))\n \treturn omit_one_operand (type, integer_zero_node, arg00);\n-      return fold (build2 (GT_EXPR, type, arg00, hi));\n+      return fold_build2 (GT_EXPR, type, arg00, hi);\n \n     case GE_EXPR:\n       if (TREE_OVERFLOW (lo))\n \treturn omit_one_operand (type, integer_one_node, arg00);\n-      return fold (build2 (GE_EXPR, type, arg00, lo));\n+      return fold_build2 (GE_EXPR, type, arg00, lo);\n \n     default:\n       break;\n@@ -5932,9 +5932,9 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n \t     == GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (arg00))))\n \t{\n \t  tree stype = lang_hooks.types.signed_type (TREE_TYPE (arg00));\n-\t  return fold (build2 (code == EQ_EXPR ? GE_EXPR : LT_EXPR,\n-\t\t\t       result_type, fold_convert (stype, arg00),\n-\t\t\t       fold_convert (stype, integer_zero_node)));\n+\t  return fold_build2 (code == EQ_EXPR ? GE_EXPR : LT_EXPR,\n+\t\t\t      result_type, fold_convert (stype, arg00),\n+\t\t\t      fold_convert (stype, integer_zero_node));\n \t}\n \n       /* Otherwise we have (A & C) != 0 where C is a single bit,\n@@ -5974,8 +5974,8 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n \t\t\tinner, size_int (bitnum));\n \n       if (code == EQ_EXPR)\n-\tinner = fold (build2 (BIT_XOR_EXPR, intermediate_type,\n-\t\t\t      inner, integer_one_node));\n+\tinner = fold_build2 (BIT_XOR_EXPR, intermediate_type,\n+\t\t\t     inner, integer_one_node);\n \n       /* Put the AND last so it can combine with more things.  */\n       inner = build2 (BIT_AND_EXPR, intermediate_type,\n@@ -6097,8 +6097,8 @@ fold_widened_comparison (enum tree_code code, tree type, tree arg0, tree arg1)\n \t  || (TREE_CODE (arg1_unw) == INTEGER_CST\n \t      && TREE_CODE (shorter_type) == INTEGER_TYPE\n \t      && int_fits_type_p (arg1_unw, shorter_type))))\n-    return fold (build (code, type, arg0_unw,\n-\t\t\tfold_convert (shorter_type, arg1_unw)));\n+    return fold_build2 (code, type, arg0_unw,\n+\t\t       fold_convert (shorter_type, arg1_unw));\n \n   if (TREE_CODE (arg1_unw) != INTEGER_CST)\n     return NULL_TREE;\n@@ -6200,7 +6200,7 @@ fold_sign_changed_comparison (enum tree_code code, tree type,\n   else\n     arg1 = fold_convert (inner_type, arg1);\n \n-  return fold (build2 (code, type, arg0_inner, arg1));\n+  return fold_build2 (code, type, arg0_inner, arg1);\n }\n \n /* Tries to replace &a[idx] CODE s * delta with &a[idx CODE delta], if s is\n@@ -6274,9 +6274,9 @@ try_move_mult_to_index (enum tree_code code, tree addr, tree mult)\n       pos = TREE_OPERAND (pos, 0);\n     }\n \n-  TREE_OPERAND (pos, 1) = fold (build2 (code, itype,\n-\t\t\t\t\tTREE_OPERAND (pos, 1),\n-\t\t\t\t\tdelta));\n+  TREE_OPERAND (pos, 1) = fold_build2 (code, itype,\n+\t\t\t\t       TREE_OPERAND (pos, 1),\n+\t\t\t\t       delta);\n \n   return build1 (ADDR_EXPR, TREE_TYPE (addr), ret);\n }\n@@ -6319,11 +6319,11 @@ fold_to_nonsharp_ineq_using_bound (tree ineq, tree bound)\n   if (TREE_TYPE (a1) != typea)\n     return NULL_TREE;\n \n-  diff = fold (build2 (MINUS_EXPR, typea, a1, a));\n+  diff = fold_build2 (MINUS_EXPR, typea, a1, a);\n   if (!integer_onep (diff))\n     return NULL_TREE;\n \n-  return fold (build2 (GE_EXPR, type, a, y));\n+  return fold_build2 (GE_EXPR, type, a, y);\n }\n \n /* Fold complex addition when both components are accessible by parts.\n@@ -6351,10 +6351,10 @@ fold_complex_add (tree type, tree ac, tree bc, enum tree_code code)\n \n   inner_type = TREE_TYPE (type);\n \n-  rr = fold (build2 (code, inner_type, ar, br));  \n-  ri = fold (build2 (code, inner_type, ai, bi));  \n+  rr = fold_build2 (code, inner_type, ar, br); \n+  ri = fold_build2 (code, inner_type, ai, bi); \n \n-  return fold (build2 (COMPLEX_EXPR, type, rr, ri));\n+  return fold_build2 (COMPLEX_EXPR, type, rr, ri);\n }\n \n /* Perform some simplifications of complex multiplication when one or more\n@@ -6427,51 +6427,51 @@ fold_complex_mult_parts (tree type, tree ar, tree ai, tree br, tree bi)\n     }\n   else if (ai0 && bi0)\n     {\n-      rr = fold (build2 (MULT_EXPR, inner_type, ar, br));\n+      rr = fold_build2 (MULT_EXPR, inner_type, ar, br);\n       ri = zero;\n     }\n   else if (ai0 && br0)\n     {\n       rr = zero;\n-      ri = fold (build2 (MULT_EXPR, inner_type, ar, bi));\n+      ri = fold_build2 (MULT_EXPR, inner_type, ar, bi);\n     }\n   else if (ar0 && bi0)\n     {\n       rr = zero;\n-      ri = fold (build2 (MULT_EXPR, inner_type, ai, br));\n+      ri = fold_build2 (MULT_EXPR, inner_type, ai, br);\n     }\n   else if (ar0 && br0)\n     {\n-      rr = fold (build2 (MULT_EXPR, inner_type, ai, bi));\n-      rr = fold (build1 (NEGATE_EXPR, inner_type, rr));\n+      rr = fold_build2 (MULT_EXPR, inner_type, ai, bi);\n+      rr = fold_build1 (NEGATE_EXPR, inner_type, rr);\n       ri = zero;\n     }\n   else if (bi0)\n     {\n-      rr = fold (build2 (MULT_EXPR, inner_type, ar, br));\n-      ri = fold (build2 (MULT_EXPR, inner_type, ai, br));\n+      rr = fold_build2 (MULT_EXPR, inner_type, ar, br);\n+      ri = fold_build2 (MULT_EXPR, inner_type, ai, br);\n     }\n   else if (ai0)\n     {\n-      rr = fold (build2 (MULT_EXPR, inner_type, ar, br));\n-      ri = fold (build2 (MULT_EXPR, inner_type, ar, bi));\n+      rr = fold_build2 (MULT_EXPR, inner_type, ar, br);\n+      ri = fold_build2 (MULT_EXPR, inner_type, ar, bi);\n     }\n   else if (br0)\n     {\n-      rr = fold (build2 (MULT_EXPR, inner_type, ai, bi));\n-      rr = fold (build1 (NEGATE_EXPR, inner_type, rr));\n-      ri = fold (build2 (MULT_EXPR, inner_type, ar, bi));\n+      rr = fold_build2 (MULT_EXPR, inner_type, ai, bi);\n+      rr = fold_build1 (NEGATE_EXPR, inner_type, rr);\n+      ri = fold_build2 (MULT_EXPR, inner_type, ar, bi);\n     }\n   else if (ar0)\n     {\n-      rr = fold (build2 (MULT_EXPR, inner_type, ai, bi));\n-      rr = fold (build1 (NEGATE_EXPR, inner_type, rr));\n-      ri = fold (build2 (MULT_EXPR, inner_type, ai, br));\n+      rr = fold_build2 (MULT_EXPR, inner_type, ai, bi);\n+      rr = fold_build1 (NEGATE_EXPR, inner_type, rr);\n+      ri = fold_build2 (MULT_EXPR, inner_type, ai, br);\n     }\n   else\n     return NULL;\n \n-  return fold (build2 (COMPLEX_EXPR, type, rr, ri));\n+  return fold_build2 (COMPLEX_EXPR, type, rr, ri);\n }\n \n static tree\n@@ -6562,40 +6562,40 @@ fold_complex_div_parts (tree type, tree ar, tree ai, tree br, tree bi,\n \n   if (ai0 && bi0)\n     {\n-      rr = fold (build2 (code, inner_type, ar, br));\n+      rr = fold_build2 (code, inner_type, ar, br);\n       ri = zero;\n     }\n   else if (ai0 && br0)\n     {\n       rr = zero;\n-      ri = fold (build2 (code, inner_type, ar, bi));\n-      ri = fold (build1 (NEGATE_EXPR, inner_type, ri));\n+      ri = fold_build2 (code, inner_type, ar, bi);\n+      ri = fold_build1 (NEGATE_EXPR, inner_type, ri);\n     }\n   else if (ar0 && bi0)\n     {\n       rr = zero;\n-      ri = fold (build2 (code, inner_type, ai, br));\n+      ri = fold_build2 (code, inner_type, ai, br);\n     }\n   else if (ar0 && br0)\n     {\n-      rr = fold (build2 (code, inner_type, ai, bi));\n+      rr = fold_build2 (code, inner_type, ai, bi);\n       ri = zero;\n     }\n   else if (bi0)\n     {\n-      rr = fold (build2 (code, inner_type, ar, br));\n-      ri = fold (build2 (code, inner_type, ai, br));\n+      rr = fold_build2 (code, inner_type, ar, br);\n+      ri = fold_build2 (code, inner_type, ai, br);\n     }\n   else if (br0)\n     {\n-      rr = fold (build2 (code, inner_type, ai, bi));\n-      ri = fold (build2 (code, inner_type, ar, bi));\n-      ri = fold (build1 (NEGATE_EXPR, inner_type, ri));\n+      rr = fold_build2 (code, inner_type, ai, bi);\n+      ri = fold_build2 (code, inner_type, ar, bi);\n+      ri = fold_build1 (NEGATE_EXPR, inner_type, ri);\n     }\n   else\n     return NULL;\n \n-  return fold (build2 (COMPLEX_EXPR, type, rr, ri));\n+  return fold_build2 (COMPLEX_EXPR, type, rr, ri);\n }\n \n static tree\n@@ -6663,17 +6663,17 @@ fold_unary (enum tree_code code, tree type, tree op0)\n     {\n       if (TREE_CODE (arg0) == COMPOUND_EXPR)\n \treturn build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t       fold (build1 (code, type, TREE_OPERAND (arg0, 1))));\n+\t\t       fold_build1 (code, type, TREE_OPERAND (arg0, 1)));\n       else if (TREE_CODE (arg0) == COND_EXPR)\n \t{\n \t  tree arg01 = TREE_OPERAND (arg0, 1);\n \t  tree arg02 = TREE_OPERAND (arg0, 2);\n \t  if (! VOID_TYPE_P (TREE_TYPE (arg01)))\n-\t    arg01 = fold (build1 (code, type, arg01));\n+\t    arg01 = fold_build1 (code, type, arg01);\n \t  if (! VOID_TYPE_P (TREE_TYPE (arg02)))\n-\t    arg02 = fold (build1 (code, type, arg02));\n-\t  tem = fold (build3 (COND_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t\t      arg01, arg02));\n+\t    arg02 = fold_build1 (code, type, arg02);\n+\t  tem = fold_build3 (COND_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t\t     arg01, arg02);\n \n \t  /* If this was a conversion, and all we did was to move into\n \t     inside the COND_EXPR, bring it back out.  But leave it if\n@@ -6716,11 +6716,11 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t      return arg0;\n \t    }\n \t  else if (TREE_CODE (type) != INTEGER_TYPE)\n-\t    return fold (build3 (COND_EXPR, type, arg0,\n-\t\t\t\t fold (build1 (code, type,\n-\t\t\t\t\t       integer_one_node)),\n-\t\t\t\t fold (build1 (code, type,\n-\t\t\t\t\t       integer_zero_node))));\n+\t    return fold_build3 (COND_EXPR, type, arg0,\n+\t\t\t\tfold_build1 (code, type,\n+\t\t\t\t\t     integer_one_node),\n+\t\t\t\tfold_build1 (code, type,\n+\t\t\t\t\t     integer_zero_node));\n \t}\n    }\n \n@@ -6765,7 +6765,7 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t  if (TYPE_MAIN_VARIANT (inside_type) == TYPE_MAIN_VARIANT (type)\n \t      && ((inter_int && final_int) || (inter_float && final_float))\n \t      && inter_prec >= final_prec)\n-\t    return fold (build1 (code, type, TREE_OPERAND (op0, 0)));\n+\t    return fold_build1 (code, type, TREE_OPERAND (op0, 0));\n \n \t  /* Likewise, if the intermediate and final types are either both\n \t     float or both integer, we don't need the middle conversion if\n@@ -6780,14 +6780,14 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t      && ! (final_prec != GET_MODE_BITSIZE (TYPE_MODE (type))\n \t\t    && TYPE_MODE (type) == TYPE_MODE (inter_type))\n \t      && ! final_ptr)\n-\t    return fold (build1 (code, type, TREE_OPERAND (op0, 0)));\n+\t    return fold_build1 (code, type, TREE_OPERAND (op0, 0));\n \n \t  /* If we have a sign-extension of a zero-extended value, we can\n \t     replace that by a single zero-extension.  */\n \t  if (inside_int && inter_int && final_int\n \t      && inside_prec < inter_prec && inter_prec < final_prec\n \t      && inside_unsignedp && !inter_unsignedp)\n-\t    return fold (build1 (code, type, TREE_OPERAND (op0, 0)));\n+\t    return fold_build1 (code, type, TREE_OPERAND (op0, 0));\n \n \t  /* Two conversions in a row are not needed unless:\n \t     - some conversion is floating-point (overstrict for now), or\n@@ -6811,7 +6811,7 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t      && ! (final_prec != GET_MODE_BITSIZE (TYPE_MODE (type))\n \t\t    && TYPE_MODE (type) == TYPE_MODE (inter_type))\n \t      && ! final_ptr)\n-\t    return fold (build1 (code, type, TREE_OPERAND (op0, 0)));\n+\t    return fold_build1 (code, type, TREE_OPERAND (op0, 0));\n \t}\n \n       if (TREE_CODE (op0) == MODIFY_EXPR\n@@ -6874,8 +6874,8 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t\t\t\t\tTREE_INT_CST_HIGH (and1));\n \t      tem = force_fit_type (tem, 0, TREE_OVERFLOW (and1),\n \t\t\t\t    TREE_CONSTANT_OVERFLOW (and1));\n-\t      return fold (build2 (BIT_AND_EXPR, type,\n-\t\t\t\t   fold_convert (type, and0), tem));\n+\t      return fold_build2 (BIT_AND_EXPR, type,\n+\t\t\t\t  fold_convert (type, and0), tem);\n \t    }\n \t}\n \n@@ -6912,24 +6912,24 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \treturn fold_convert (type, negate_expr (arg0));\n       /* Convert - (~A) to A + 1.  */\n       if (INTEGRAL_TYPE_P (type) && TREE_CODE (arg0) == BIT_NOT_EXPR)\n-\treturn fold (build2 (PLUS_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t\t     build_int_cst (type, 1)));\n+\treturn fold_build2 (PLUS_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t\t    build_int_cst (type, 1));\n       return NULL_TREE;\n \n     case ABS_EXPR:\n       if (TREE_CODE (arg0) == INTEGER_CST || TREE_CODE (arg0) == REAL_CST)\n \treturn fold_abs_const (arg0, type);\n       else if (TREE_CODE (arg0) == NEGATE_EXPR)\n-\treturn fold (build1 (ABS_EXPR, type, TREE_OPERAND (arg0, 0)));\n+\treturn fold_build1 (ABS_EXPR, type, TREE_OPERAND (arg0, 0));\n       /* Convert fabs((double)float) into (double)fabsf(float).  */\n       else if (TREE_CODE (arg0) == NOP_EXPR\n \t       && TREE_CODE (type) == REAL_TYPE)\n \t{\n \t  tree targ0 = strip_float_extensions (arg0);\n \t  if (targ0 != arg0)\n-\t    return fold_convert (type, fold (build1 (ABS_EXPR,\n-\t\t\t\t\t\t     TREE_TYPE (targ0),\n-\t\t\t\t\t\t     targ0)));\n+\t    return fold_convert (type, fold_build1 (ABS_EXPR,\n+\t\t\t\t\t\t    TREE_TYPE (targ0),\n+\t\t\t\t\t\t    targ0));\n \t}\n       else if (tree_expr_nonnegative_p (arg0))\n \treturn arg0;\n@@ -6939,7 +6939,7 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t{\n \t  tem = fold_strip_sign_ops (arg0);\n \t  if (tem)\n-\t    return fold (build1 (ABS_EXPR, type, fold_convert (type, tem)));\n+\t    return fold_build1 (ABS_EXPR, type, fold_convert (type, tem));\n \t}\n       return NULL_TREE;\n \n@@ -6954,11 +6954,11 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \treturn build_complex (type, TREE_REALPART (arg0),\n \t\t\t      negate_expr (TREE_IMAGPART (arg0)));\n       else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n-\treturn fold (build2 (TREE_CODE (arg0), type,\n-\t\t\t     fold (build1 (CONJ_EXPR, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 0))),\n-\t\t\t     fold (build1 (CONJ_EXPR, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 1)))));\n+\treturn fold_build2 (TREE_CODE (arg0), type,\n+\t\t\t    fold_build1 (CONJ_EXPR, type,\n+\t\t\t\t\t TREE_OPERAND (arg0, 0)),\n+\t\t\t    fold_build1 (CONJ_EXPR, type,\n+\t\t\t\t\t TREE_OPERAND (arg0, 1)));\n       else if (TREE_CODE (arg0) == CONJ_EXPR)\n \treturn TREE_OPERAND (arg0, 0);\n       return NULL_TREE;\n@@ -6970,15 +6970,15 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \treturn TREE_OPERAND (arg0, 0);\n       /* Convert ~ (-A) to A - 1.  */\n       else if (INTEGRAL_TYPE_P (type) && TREE_CODE (arg0) == NEGATE_EXPR)\n-\treturn fold (build2 (MINUS_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t\t     build_int_cst (type, 1)));\n+\treturn fold_build2 (MINUS_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t\t    build_int_cst (type, 1));\n       /* Convert ~ (A - 1) or ~ (A + -1) to -A.  */\n       else if (INTEGRAL_TYPE_P (type)\n \t       && ((TREE_CODE (arg0) == MINUS_EXPR\n \t\t    && integer_onep (TREE_OPERAND (arg0, 1)))\n \t\t   || (TREE_CODE (arg0) == PLUS_EXPR\n \t\t       && integer_all_onesp (TREE_OPERAND (arg0, 1)))))\n-\treturn fold (build1 (NEGATE_EXPR, type, TREE_OPERAND (arg0, 0)));\n+\treturn fold_build1 (NEGATE_EXPR, type, TREE_OPERAND (arg0, 0));\n       return NULL_TREE;\n \n     case TRUTH_NOT_EXPR:\n@@ -7005,11 +7005,11 @@ fold_unary (enum tree_code code, tree type, tree op0)\n       else if (TREE_CODE (arg0) == COMPLEX_CST)\n \treturn TREE_REALPART (arg0);\n       else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n-\treturn fold (build2 (TREE_CODE (arg0), type,\n-\t\t\t     fold (build1 (REALPART_EXPR, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 0))),\n-\t\t\t     fold (build1 (REALPART_EXPR, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 1)))));\n+\treturn fold_build2 (TREE_CODE (arg0), type,\n+\t\t\t    fold_build1 (REALPART_EXPR, type,\n+\t\t\t\t\t TREE_OPERAND (arg0, 0)),\n+\t\t\t    fold_build1 (REALPART_EXPR, type,\n+\t\t\t\t\t TREE_OPERAND (arg0, 1)));\n       return NULL_TREE;\n \n     case IMAGPART_EXPR:\n@@ -7021,11 +7021,11 @@ fold_unary (enum tree_code code, tree type, tree op0)\n       else if (TREE_CODE (arg0) == COMPLEX_CST)\n \treturn TREE_IMAGPART (arg0);\n       else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n-\treturn fold (build2 (TREE_CODE (arg0), type,\n-\t\t\t     fold (build1 (IMAGPART_EXPR, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 0))),\n-\t\t\t     fold (build1 (IMAGPART_EXPR, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 1)))));\n+\treturn fold_build2 (TREE_CODE (arg0), type,\n+\t\t\t    fold_build1 (IMAGPART_EXPR, type,\n+\t\t\t\t\t TREE_OPERAND (arg0, 0)),\n+\t\t\t    fold_build1 (IMAGPART_EXPR, type,\n+\t\t\t\t\t TREE_OPERAND (arg0, 1)));\n       return NULL_TREE;\n \n     default:\n@@ -7125,7 +7125,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n      to ARG1 to reduce the number of tests below.  */\n   if (commutative_tree_code (code)\n       && tree_swap_operands_p (arg0, arg1, true))\n-    return fold (build2 (code, type, op1, op0));\n+    return fold_build2 (code, type, op1, op0);\n \n   /* Now WINS is set as described above,\n      ARG0 is the first operand of EXPR,\n@@ -7156,12 +7156,12 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t  || (TREE_CODE (arg0) == BIT_AND_EXPR\n \t\t      && integer_onep (TREE_OPERAND (arg0, 1)))))))\n     {\n-      tem = fold (build2 (code == BIT_AND_EXPR ? TRUTH_AND_EXPR\n-\t\t\t  : code == BIT_IOR_EXPR ? TRUTH_OR_EXPR\n-\t\t\t  : TRUTH_XOR_EXPR,\n-\t\t\t  boolean_type_node,\n-\t\t\t  fold_convert (boolean_type_node, arg0),\n-\t\t\t  fold_convert (boolean_type_node, arg1)));\n+      tem = fold_build2 (code == BIT_AND_EXPR ? TRUTH_AND_EXPR\n+\t\t\t : code == BIT_IOR_EXPR ? TRUTH_OR_EXPR\n+\t\t\t : TRUTH_XOR_EXPR,\n+\t\t\t boolean_type_node,\n+\t\t\t fold_convert (boolean_type_node, arg0),\n+\t\t\t fold_convert (boolean_type_node, arg1));\n \n       if (code == EQ_EXPR)\n \ttem = invert_truthvalue (tem);\n@@ -7172,23 +7172,23 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n   if (TREE_CODE_CLASS (code) == tcc_comparison\n \t   && TREE_CODE (arg0) == COMPOUND_EXPR)\n     return build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t   fold (build2 (code, type, TREE_OPERAND (arg0, 1), arg1)));\n+\t\t   fold_build2 (code, type, TREE_OPERAND (arg0, 1), arg1));\n   else if (TREE_CODE_CLASS (code) == tcc_comparison\n \t   && TREE_CODE (arg1) == COMPOUND_EXPR)\n     return build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg1, 0),\n-\t\t   fold (build2 (code, type, arg0, TREE_OPERAND (arg1, 1))));\n+\t\t   fold_build2 (code, type, arg0, TREE_OPERAND (arg1, 1)));\n   else if (TREE_CODE_CLASS (code) == tcc_binary\n \t   || TREE_CODE_CLASS (code) == tcc_comparison)\n     {\n       if (TREE_CODE (arg0) == COMPOUND_EXPR)\n \treturn build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t       fold (build2 (code, type, TREE_OPERAND (arg0, 1),\n-\t\t\t\t     arg1)));\n+\t\t       fold_build2 (code, type, TREE_OPERAND (arg0, 1),\n+\t\t\t\t    arg1));\n       if (TREE_CODE (arg1) == COMPOUND_EXPR\n \t  && reorder_operands_p (arg0, TREE_OPERAND (arg1, 0)))\n \treturn build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg1, 0),\n-\t\t       fold (build2 (code, type,\n-\t\t\t\t     arg0, TREE_OPERAND (arg1, 1))));\n+\t\t       fold_build2 (code, type,\n+\t\t\t\t    arg0, TREE_OPERAND (arg1, 1)));\n \n       if (TREE_CODE (arg0) == COND_EXPR || COMPARISON_CLASS_P (arg0))\n \t{\n@@ -7214,16 +7214,16 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n     case PLUS_EXPR:\n       /* A + (-B) -> A - B */\n       if (TREE_CODE (arg1) == NEGATE_EXPR)\n-\treturn fold (build2 (MINUS_EXPR, type, arg0, TREE_OPERAND (arg1, 0)));\n+\treturn fold_build2 (MINUS_EXPR, type, arg0, TREE_OPERAND (arg1, 0));\n       /* (-A) + B -> B - A */\n       if (TREE_CODE (arg0) == NEGATE_EXPR\n \t  && reorder_operands_p (TREE_OPERAND (arg0, 0), arg1))\n-\treturn fold (build2 (MINUS_EXPR, type, arg1, TREE_OPERAND (arg0, 0)));\n+\treturn fold_build2 (MINUS_EXPR, type, arg1, TREE_OPERAND (arg0, 0));\n       /* Convert ~A + 1 to -A.  */\n       if (INTEGRAL_TYPE_P (type)\n \t  && TREE_CODE (arg0) == BIT_NOT_EXPR\n \t  && integer_onep (arg1))\n-\treturn fold (build1 (NEGATE_EXPR, type, TREE_OPERAND (arg0, 0)));\n+\treturn fold_build1 (NEGATE_EXPR, type, TREE_OPERAND (arg0, 0));\n \n       if (TREE_CODE (type) == COMPLEX_TYPE)\n \t{\n@@ -7278,19 +7278,19 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n \t      if (TREE_CODE (parg0) == MULT_EXPR\n \t\t  && TREE_CODE (parg1) != MULT_EXPR)\n-\t\treturn fold (build2 (pcode, type,\n-\t\t\t\t     fold (build2 (PLUS_EXPR, type,\n-\t\t\t\t\t\t   fold_convert (type, parg0),\n-\t\t\t\t\t\t   fold_convert (type, marg))),\n-\t\t\t\t     fold_convert (type, parg1)));\n+\t\treturn fold_build2 (pcode, type,\n+\t\t\t\t    fold_build2 (PLUS_EXPR, type,\n+\t\t\t\t\t\t fold_convert (type, parg0),\n+\t\t\t\t\t\t fold_convert (type, marg)),\n+\t\t\t\t    fold_convert (type, parg1));\n \t      if (TREE_CODE (parg0) != MULT_EXPR\n \t\t  && TREE_CODE (parg1) == MULT_EXPR)\n-\t\treturn fold (build2 (PLUS_EXPR, type,\n-\t\t\t\t     fold_convert (type, parg0),\n-\t\t\t\t     fold (build2 (pcode, type,\n-\t\t\t\t\t\t   fold_convert (type, marg),\n-\t\t\t\t\t\t   fold_convert (type,\n-\t\t\t\t\t\t\t\t parg1)))));\n+\t\treturn fold_build2 (PLUS_EXPR, type,\n+\t\t\t\t    fold_convert (type, parg0),\n+\t\t\t\t    fold_build2 (pcode, type,\n+\t\t\t\t\t\t fold_convert (type, marg),\n+\t\t\t\t\t\t fold_convert (type,\n+\t\t\t\t\t\t\t       parg1)));\n \t    }\n \n \t  if (TREE_CODE (arg0) == MULT_EXPR && TREE_CODE (arg1) == MULT_EXPR)\n@@ -7341,20 +7341,20 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n \t\t  if (exact_log2 (int11) > 0 && int01 % int11 == 0)\n \t\t    {\n-\t\t      alt0 = fold (build2 (MULT_EXPR, type, arg00,\n-\t\t\t\t\t   build_int_cst (NULL_TREE,\n-\t\t\t\t\t\t\t  int01 / int11)));\n+\t\t      alt0 = fold_build2 (MULT_EXPR, type, arg00,\n+\t\t\t\t\t  build_int_cst (NULL_TREE,\n+\t\t\t\t\t\t\t int01 / int11));\n \t\t      alt1 = arg10;\n \t\t      same = arg11;\n \t\t    }\n \t\t}\n \n \t      if (same)\n-\t\treturn fold (build2 (MULT_EXPR, type,\n-\t\t\t\t     fold (build2 (PLUS_EXPR, type,\n-\t\t\t\t\t\t   fold_convert (type, alt0),\n-\t\t\t\t\t\t   fold_convert (type, alt1))),\n-\t\t\t\t     same));\n+\t\treturn fold_build2 (MULT_EXPR, type,\n+\t\t\t\t    fold_build2 (PLUS_EXPR, type,\n+\t\t\t\t\t\t fold_convert (type, alt0),\n+\t\t\t\t\t\t fold_convert (type, alt1)),\n+\t\t\t\t    same);\n \t    }\n \n \t  /* Try replacing &a[i1] + c * i2 with &a[i1 + i2], if c is step\n@@ -7391,16 +7391,16 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t    {\n \t      tem = fold_negate_const (arg1, type);\n \t      if (!TREE_OVERFLOW (arg1) || !flag_trapping_math)\n-\t\treturn fold (build2 (MINUS_EXPR, type,\n-\t\t\t\t     fold_convert (type, arg0),\n-\t\t\t\t     fold_convert (type, tem)));\n+\t\treturn fold_build2 (MINUS_EXPR, type,\n+\t\t\t\t    fold_convert (type, arg0),\n+\t\t\t\t    fold_convert (type, tem));\n \t    }\n \n \t  /* Convert x+x into x*2.0.  */\n \t  if (operand_equal_p (arg0, arg1, 0)\n \t      && SCALAR_FLOAT_TYPE_P (type))\n-\t    return fold (build2 (MULT_EXPR, type, arg0,\n-\t\t\t\t build_real (type, dconst2)));\n+\t    return fold_build2 (MULT_EXPR, type, arg0,\n+\t\t\t\tbuild_real (type, dconst2));\n \n \t  /* Convert x*c+x into x*(c+1).  */\n \t  if (flag_unsafe_math_optimizations\n@@ -7413,8 +7413,8 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n \t      c = TREE_REAL_CST (TREE_OPERAND (arg0, 1));\n \t      real_arithmetic (&c, PLUS_EXPR, &c, &dconst1);\n-\t      return fold (build2 (MULT_EXPR, type, arg1,\n-\t\t\t\t   build_real (type, c)));\n+\t      return fold_build2 (MULT_EXPR, type, arg1,\n+\t\t\t\t  build_real (type, c));\n \t    }\n \n \t  /* Convert x+x*c into x*(c+1).  */\n@@ -7428,8 +7428,8 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n \t      c = TREE_REAL_CST (TREE_OPERAND (arg1, 1));\n \t      real_arithmetic (&c, PLUS_EXPR, &c, &dconst1);\n-\t      return fold (build2 (MULT_EXPR, type, arg0,\n-\t\t\t\t   build_real (type, c)));\n+\t      return fold_build2 (MULT_EXPR, type, arg0,\n+\t\t\t\t  build_real (type, c));\n \t    }\n \n \t  /* Convert x*c1+x*c2 into x*(c1+c2).  */\n@@ -7448,9 +7448,9 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      c1 = TREE_REAL_CST (TREE_OPERAND (arg0, 1));\n \t      c2 = TREE_REAL_CST (TREE_OPERAND (arg1, 1));\n \t      real_arithmetic (&c1, PLUS_EXPR, &c1, &c2);\n-\t      return fold (build2 (MULT_EXPR, type,\n-\t\t\t\t   TREE_OPERAND (arg0, 0),\n-\t\t\t\t   build_real (type, c1)));\n+\t      return fold_build2 (MULT_EXPR, type,\n+\t\t\t\t  TREE_OPERAND (arg0, 0),\n+\t\t\t\t  build_real (type, c1));\n \t    }\n           /* Convert a + (b*c + d*e) into (a + b*c) + d*e.  */\n           if (flag_unsafe_math_optimizations\n@@ -7463,8 +7463,8 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t  && TREE_CODE (tree10) == MULT_EXPR)\n                 {\n                   tree tree0;\n-                  tree0 = fold (build2 (PLUS_EXPR, type, arg0, tree10));\n-                  return fold (build2 (PLUS_EXPR, type, tree0, tree11));\n+                  tree0 = fold_build2 (PLUS_EXPR, type, arg0, tree10);\n+                  return fold_build2 (PLUS_EXPR, type, tree0, tree11);\n                 }\n             }\n           /* Convert (b*c + d*e) + a into b*c + (d*e +a).  */\n@@ -7478,8 +7478,8 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t  && TREE_CODE (tree00) == MULT_EXPR)\n                 {\n                   tree tree0;\n-                  tree0 = fold (build2 (PLUS_EXPR, type, tree01, arg1));\n-                  return fold (build2 (PLUS_EXPR, type, tree00, tree0));\n+                  tree0 = fold_build2 (PLUS_EXPR, type, tree01, arg1);\n+                  return fold_build2 (PLUS_EXPR, type, tree00, tree0);\n                 }\n             }\n \t}\n@@ -7653,25 +7653,25 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n     case MINUS_EXPR:\n       /* A - (-B) -> A + B */\n       if (TREE_CODE (arg1) == NEGATE_EXPR)\n-\treturn fold (build2 (PLUS_EXPR, type, arg0, TREE_OPERAND (arg1, 0)));\n+\treturn fold_build2 (PLUS_EXPR, type, arg0, TREE_OPERAND (arg1, 0));\n       /* (-A) - B -> (-B) - A  where B is easily negated and we can swap.  */\n       if (TREE_CODE (arg0) == NEGATE_EXPR\n \t  && (FLOAT_TYPE_P (type)\n \t      || (INTEGRAL_TYPE_P (type) && flag_wrapv && !flag_trapv))\n \t  && negate_expr_p (arg1)\n \t  && reorder_operands_p (arg0, arg1))\n-\treturn fold (build2 (MINUS_EXPR, type, negate_expr (arg1),\n-\t\t\t     TREE_OPERAND (arg0, 0)));\n+\treturn fold_build2 (MINUS_EXPR, type, negate_expr (arg1),\n+\t\t\t    TREE_OPERAND (arg0, 0));\n       /* Convert -A - 1 to ~A.  */\n       if (INTEGRAL_TYPE_P (type)\n \t  && TREE_CODE (arg0) == NEGATE_EXPR\n \t  && integer_onep (arg1))\n-\treturn fold (build1 (BIT_NOT_EXPR, type, TREE_OPERAND (arg0, 0)));\n+\treturn fold_build1 (BIT_NOT_EXPR, type, TREE_OPERAND (arg0, 0));\n \n       /* Convert -1 - A to ~A.  */\n       if (INTEGRAL_TYPE_P (type)\n \t  && integer_all_onesp (arg0))\n-\treturn fold (build1 (BIT_NOT_EXPR, type, arg1));\n+\treturn fold_build1 (BIT_NOT_EXPR, type, arg1);\n \n       if (TREE_CODE (type) == COMPLEX_TYPE)\n \t{\n@@ -7692,15 +7692,15 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      && TREE_CODE (arg1) == BIT_AND_EXPR)\n \t    {\n \t      if (operand_equal_p (arg0, TREE_OPERAND (arg1, 1), 0))\n-\t\treturn fold (build2 (BIT_AND_EXPR, type,\n-\t\t\t\t     fold (build1 (BIT_NOT_EXPR, type,\n-\t\t\t\t\t\t   TREE_OPERAND (arg1, 0))),\n-\t\t\t\t     arg0));\n+\t\treturn fold_build2 (BIT_AND_EXPR, type,\n+\t\t\t\t    fold_build1 (BIT_NOT_EXPR, type,\n+\t\t\t\t\t\t TREE_OPERAND (arg1, 0)),\n+\t\t\t\t    arg0);\n \t      if (operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n-\t\treturn fold (build2 (BIT_AND_EXPR, type,\n-\t\t\t\t     fold (build1 (BIT_NOT_EXPR, type,\n-\t\t\t\t\t\t   TREE_OPERAND (arg1, 1))),\n-\t\t\t\t     arg0));\n+\t\treturn fold_build2 (BIT_AND_EXPR, type,\n+\t\t\t\t    fold_build1 (BIT_NOT_EXPR, type,\n+\t\t\t\t\t\t TREE_OPERAND (arg1, 1)),\n+\t\t\t\t    arg0);\n \t    }\n \n \t  /* Fold (A & ~B) - (A & B) into (A ^ B) - B, where B is\n@@ -7712,13 +7712,13 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t    {\n \t      tree mask0 = TREE_OPERAND (arg0, 1);\n \t      tree mask1 = TREE_OPERAND (arg1, 1);\n-\t      tree tem = fold (build1 (BIT_NOT_EXPR, type, mask0));\n+\t      tree tem = fold_build1 (BIT_NOT_EXPR, type, mask0);\n \n \t      if (operand_equal_p (tem, mask1, 0))\n \t\t{\n-\t\t  tem = fold (build2 (BIT_XOR_EXPR, type,\n-\t\t\t\t      TREE_OPERAND (arg0, 0), mask1));\n-\t\t  return fold (build2 (MINUS_EXPR, type, tem, mask1));\n+\t\t  tem = fold_build2 (BIT_XOR_EXPR, type,\n+\t\t\t\t     TREE_OPERAND (arg0, 0), mask1);\n+\t\t  return fold_build2 (MINUS_EXPR, type, tem, mask1);\n \t\t}\n \t    }\n \t}\n@@ -7750,7 +7750,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t       && (TREE_CODE (arg1) != REAL_CST\n \t\t   ||  REAL_VALUE_NEGATIVE (TREE_REAL_CST (arg1))))\n \t      || (INTEGRAL_TYPE_P (type) && flag_wrapv && !flag_trapv)))\n-\treturn fold (build2 (PLUS_EXPR, type, arg0, negate_expr (arg1)));\n+\treturn fold_build2 (PLUS_EXPR, type, arg0, negate_expr (arg1));\n \n       /* Try folding difference of addresses.  */\n       {\n@@ -7780,33 +7780,33 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n           /* (A * C) - (B * C) -> (A-B) * C.  */\n \t  if (operand_equal_p (TREE_OPERAND (arg0, 1),\n \t\t\t       TREE_OPERAND (arg1, 1), 0))\n-\t    return fold (build2 (MULT_EXPR, type,\n-\t\t\t\t fold (build2 (MINUS_EXPR, type,\n-\t\t\t\t\t       TREE_OPERAND (arg0, 0),\n-\t\t\t\t\t       TREE_OPERAND (arg1, 0))),\n-\t\t\t\t TREE_OPERAND (arg0, 1)));\n+\t    return fold_build2 (MULT_EXPR, type,\n+\t\t\t\tfold_build2 (MINUS_EXPR, type,\n+\t\t\t\t\t     TREE_OPERAND (arg0, 0),\n+\t\t\t\t\t     TREE_OPERAND (arg1, 0)),\n+\t\t\t\tTREE_OPERAND (arg0, 1));\n           /* (A * C1) - (A * C2) -> A * (C1-C2).  */\n \t  if (operand_equal_p (TREE_OPERAND (arg0, 0),\n \t\t\t       TREE_OPERAND (arg1, 0), 0))\n-\t    return fold (build2 (MULT_EXPR, type,\n-\t\t\t\t TREE_OPERAND (arg0, 0),\n-\t\t\t\t fold (build2 (MINUS_EXPR, type,\n-\t\t\t\t\t       TREE_OPERAND (arg0, 1),\n-\t\t\t\t\t       TREE_OPERAND (arg1, 1)))));\n+\t    return fold_build2 (MULT_EXPR, type,\n+\t\t\t\tTREE_OPERAND (arg0, 0),\n+\t\t\t\tfold_build2 (MINUS_EXPR, type,\n+\t\t\t\t\t     TREE_OPERAND (arg0, 1),\n+\t\t\t\t\t     TREE_OPERAND (arg1, 1)));\n \t}\n \n       goto associate;\n \n     case MULT_EXPR:\n       /* (-A) * (-B) -> A * B  */\n       if (TREE_CODE (arg0) == NEGATE_EXPR && negate_expr_p (arg1))\n-\treturn fold (build2 (MULT_EXPR, type,\n-\t\t\t     TREE_OPERAND (arg0, 0),\n-\t\t\t     negate_expr (arg1)));\n+\treturn fold_build2 (MULT_EXPR, type,\n+\t\t\t    TREE_OPERAND (arg0, 0),\n+\t\t\t    negate_expr (arg1));\n       if (TREE_CODE (arg1) == NEGATE_EXPR && negate_expr_p (arg0))\n-\treturn fold (build2 (MULT_EXPR, type,\n-\t\t\t     negate_expr (arg0),\n-\t\t\t     TREE_OPERAND (arg1, 0)));\n+\treturn fold_build2 (MULT_EXPR, type,\n+\t\t\t    negate_expr (arg0),\n+\t\t\t    TREE_OPERAND (arg1, 0));\n \n       if (TREE_CODE (type) == COMPLEX_TYPE)\n \t{\n@@ -7828,12 +7828,12 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  /* (a * (1 << b)) is (a << b)  */\n \t  if (TREE_CODE (arg1) == LSHIFT_EXPR\n \t      && integer_onep (TREE_OPERAND (arg1, 0)))\n-\t    return fold (build2 (LSHIFT_EXPR, type, arg0,\n-\t\t\t\t TREE_OPERAND (arg1, 1)));\n+\t    return fold_build2 (LSHIFT_EXPR, type, arg0,\n+\t\t\t\tTREE_OPERAND (arg1, 1));\n \t  if (TREE_CODE (arg0) == LSHIFT_EXPR\n \t      && integer_onep (TREE_OPERAND (arg0, 0)))\n-\t    return fold (build2 (LSHIFT_EXPR, type, arg1,\n-\t\t\t\t TREE_OPERAND (arg0, 1)));\n+\t    return fold_build2 (LSHIFT_EXPR, type, arg1,\n+\t\t\t\tTREE_OPERAND (arg0, 1));\n \n \t  if (TREE_CODE (arg1) == INTEGER_CST\n \t      && 0 != (tem = extract_muldiv (op0,\n@@ -7871,8 +7871,8 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      tree tem = const_binop (MULT_EXPR, TREE_OPERAND (arg0, 0),\n \t\t\t\t      arg1, 0);\n \t      if (tem)\n-\t\treturn fold (build2 (RDIV_EXPR, type, tem,\n-\t\t\t\t     TREE_OPERAND (arg0, 1)));\n+\t\treturn fold_build2 (RDIV_EXPR, type, tem,\n+\t\t\t\t    TREE_OPERAND (arg0, 1));\n \t    }\n \n           /* Strip sign operations from X in X*X, i.e. -Y*-Y -> Y*Y.  */\n@@ -7882,7 +7882,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      if (tem != NULL_TREE)\n \t\t{\n \t\t  tem = fold_convert (type, tem);\n-\t\t  return fold (build2 (MULT_EXPR, type, tem, tem));\n+\t\t  return fold_build2 (MULT_EXPR, type, tem, tem);\n \t\t}\n \t    }\n \n@@ -7906,7 +7906,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n \t          /* Optimize root(x)*root(y) as root(x*y).  */\n \t\t  rootfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n-\t\t  arg = fold (build2 (MULT_EXPR, type, arg00, arg10));\n+\t\t  arg = fold_build2 (MULT_EXPR, type, arg00, arg10);\n \t\t  arglist = build_tree_list (NULL_TREE, arg);\n \t\t  return build_function_call_expr (rootfn, arglist);\n \t\t}\n@@ -7949,7 +7949,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t  if (operand_equal_p (arg00, arg10, 0))\n \t\t    {\n \t\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n-\t\t      tree arg = fold (build2 (PLUS_EXPR, type, arg01, arg11));\n+\t\t      tree arg = fold_build2 (PLUS_EXPR, type, arg01, arg11);\n \t\t      tree arglist = tree_cons (NULL_TREE, arg00,\n \t\t\t\t\t\tbuild_tree_list (NULL_TREE,\n \t\t\t\t\t\t\t\t arg));\n@@ -8082,10 +8082,10 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       if (TREE_CODE (arg0) == BIT_NOT_EXPR\n \t  && TREE_CODE (arg1) == BIT_NOT_EXPR)\n \t{\n-\t  return fold (build1 (BIT_NOT_EXPR, type,\n-\t\t\t       build2 (BIT_AND_EXPR, type,\n-\t\t\t\t       TREE_OPERAND (arg0, 0),\n-\t\t\t\t       TREE_OPERAND (arg1, 0))));\n+\t  return fold_build1 (BIT_NOT_EXPR, type,\n+\t\t\t      build2 (BIT_AND_EXPR, type,\n+\t\t\t\t      TREE_OPERAND (arg0, 0),\n+\t\t\t\t      TREE_OPERAND (arg1, 0)));\n \t}\n \n       /* See if this can be simplified into a rotate first.  If that\n@@ -8096,7 +8096,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       if (integer_zerop (arg1))\n \treturn non_lvalue (fold_convert (type, arg0));\n       if (integer_all_onesp (arg1))\n-\treturn fold (build1 (BIT_NOT_EXPR, type, arg0));\n+\treturn fold_build1 (BIT_NOT_EXPR, type, arg0);\n       if (operand_equal_p (arg0, arg1, 0))\n \treturn omit_one_operand (type, integer_zero_node, arg0);\n \n@@ -8181,10 +8181,10 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       if (TREE_CODE (arg0) == BIT_NOT_EXPR\n \t  && TREE_CODE (arg1) == BIT_NOT_EXPR)\n \t{\n-\t  return fold (build1 (BIT_NOT_EXPR, type,\n-\t\t\t       build2 (BIT_IOR_EXPR, type,\n-\t\t\t\t       TREE_OPERAND (arg0, 0),\n-\t\t\t\t       TREE_OPERAND (arg1, 0))));\n+\t  return fold_build1 (BIT_NOT_EXPR, type,\n+\t\t\t      build2 (BIT_IOR_EXPR, type,\n+\t\t\t\t      TREE_OPERAND (arg0, 0),\n+\t\t\t\t      TREE_OPERAND (arg1, 0)));\n \t}\n \n       goto associate;\n@@ -8199,13 +8199,13 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n       /* (-A) / (-B) -> A / B  */\n       if (TREE_CODE (arg0) == NEGATE_EXPR && negate_expr_p (arg1))\n-\treturn fold (build2 (RDIV_EXPR, type,\n-\t\t\t     TREE_OPERAND (arg0, 0),\n-\t\t\t     negate_expr (arg1)));\n+\treturn fold_build2 (RDIV_EXPR, type,\n+\t\t\t    TREE_OPERAND (arg0, 0),\n+\t\t\t    negate_expr (arg1));\n       if (TREE_CODE (arg1) == NEGATE_EXPR && negate_expr_p (arg0))\n-\treturn fold (build2 (RDIV_EXPR, type,\n-\t\t\t     negate_expr (arg0),\n-\t\t\t     TREE_OPERAND (arg1, 0)));\n+\treturn fold_build2 (RDIV_EXPR, type,\n+\t\t\t    negate_expr (arg0),\n+\t\t\t    TREE_OPERAND (arg1, 0));\n \n       /* In IEEE floating point, x/1 is not equivalent to x for snans.  */\n       if (!HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n@@ -8227,7 +8227,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  if (flag_unsafe_math_optimizations\n \t      && 0 != (tem = const_binop (code, build_real (type, dconst1),\n \t\t\t\t\t  arg1, 0)))\n-\t    return fold (build2 (MULT_EXPR, type, arg0, tem));\n+\t    return fold_build2 (MULT_EXPR, type, arg0, tem);\n \t  /* Find the reciprocal if optimizing and the result is exact.  */\n \t  if (optimize)\n \t    {\n@@ -8236,24 +8236,24 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      if (exact_real_inverse (TYPE_MODE(TREE_TYPE(arg0)), &r))\n \t\t{\n \t\t  tem = build_real (type, r);\n-\t\t  return fold (build2 (MULT_EXPR, type, arg0, tem));\n+\t\t  return fold_build2 (MULT_EXPR, type, arg0, tem);\n \t\t}\n \t    }\n \t}\n       /* Convert A/B/C to A/(B*C).  */\n       if (flag_unsafe_math_optimizations\n \t  && TREE_CODE (arg0) == RDIV_EXPR)\n-\treturn fold (build2 (RDIV_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t\t     fold (build2 (MULT_EXPR, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 1), arg1))));\n+\treturn fold_build2 (RDIV_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t\t    fold_build2 (MULT_EXPR, type,\n+\t\t\t\t\t TREE_OPERAND (arg0, 1), arg1));\n \n       /* Convert A/(B/C) to (A/B)*C.  */\n       if (flag_unsafe_math_optimizations\n \t  && TREE_CODE (arg1) == RDIV_EXPR)\n-\treturn fold (build2 (MULT_EXPR, type,\n-\t\t\t     fold (build2 (RDIV_EXPR, type, arg0,\n-\t\t\t\t\t   TREE_OPERAND (arg1, 0))),\n-\t\t\t     TREE_OPERAND (arg1, 1)));\n+\treturn fold_build2 (MULT_EXPR, type,\n+\t\t\t    fold_build2 (RDIV_EXPR, type, arg0,\n+\t\t\t\t\t TREE_OPERAND (arg1, 0)),\n+\t\t\t    TREE_OPERAND (arg1, 1));\n \n       /* Convert C1/(X*C2) into (C1/C2)/X.  */\n       if (flag_unsafe_math_optimizations\n@@ -8264,8 +8264,8 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  tree tem = const_binop (RDIV_EXPR, arg0,\n \t\t\t\t  TREE_OPERAND (arg1, 1), 0);\n \t  if (tem)\n-\t    return fold (build2 (RDIV_EXPR, type, tem,\n-\t\t\t\t TREE_OPERAND (arg1, 0)));\n+\t    return fold_build2 (RDIV_EXPR, type, tem,\n+\t\t\t\tTREE_OPERAND (arg1, 0));\n \t}\n \n       if (TREE_CODE (type) == COMPLEX_TYPE)\n@@ -8286,7 +8286,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      tree arglist = build_tree_list (NULL_TREE,\n \t\t\t\t\t      fold_convert (type, arg));\n \t      arg1 = build_function_call_expr (expfn, arglist);\n-\t      return fold (build2 (MULT_EXPR, type, arg0, arg1));\n+\t      return fold_build2 (MULT_EXPR, type, arg0, arg1);\n \t    }\n \n \t  /* Optimize x/pow(y,z) into x*pow(y,-z).  */\n@@ -8301,7 +8301,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      tree arglist = tree_cons(NULL_TREE, arg10,\n \t\t\t\t       build_tree_list (NULL_TREE, neg11));\n \t      arg1 = build_function_call_expr (powfn, arglist);\n-\t      return fold (build2 (MULT_EXPR, type, arg0, arg1));\n+\t      return fold_build2 (MULT_EXPR, type, arg0, arg1);\n \t    }\n \t}\n \n@@ -8337,8 +8337,8 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t{\n \t\t  tree tmp = TREE_OPERAND (arg0, 1);\n \t\t  tmp = build_function_call_expr (tanfn, tmp);\n-\t\t  return fold (build2 (RDIV_EXPR, type,\n-\t\t\t\t       build_real (type, dconst1), tmp));\n+\t\t  return fold_build2 (RDIV_EXPR, type,\n+\t\t\t\t      build_real (type, dconst1), tmp);\n \t\t}\n \t    }\n \n@@ -8392,7 +8392,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t after the last round to changes to the DIV code in expmed.c.  */\n       if ((code == CEIL_DIV_EXPR || code == FLOOR_DIV_EXPR)\n \t  && multiple_of_p (type, arg0, arg1))\n-\treturn fold (build2 (EXACT_DIV_EXPR, type, arg0, arg1));\n+\treturn fold_build2 (EXACT_DIV_EXPR, type, arg0, arg1);\n \n       if (TREE_CODE (arg1) == INTEGER_CST\n \t  && 0 != (tem = extract_muldiv (op0, arg1, code, NULL_TREE)))\n@@ -8456,8 +8456,8 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t    }\n \n \t  mask = build_int_cst_wide (type, low, high);\n-\t  return fold (build2 (BIT_AND_EXPR, type,\n-\t\t\t       fold_convert (type, arg0), mask));\n+\t  return fold_build2 (BIT_AND_EXPR, type,\n+\t\t\t      fold_convert (type, arg0), mask);\n \t}\n \n       /* X % -C is the same as X % C.  */\n@@ -8468,16 +8468,16 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && !flag_trapv\n \t  /* Avoid this transformation if C is INT_MIN, i.e. C == -C.  */\n \t  && !sign_bit_p (arg1, arg1))\n-\treturn fold (build2 (code, type, fold_convert (type, arg0),\n-\t\t\t     fold_convert (type, negate_expr (arg1))));\n+\treturn fold_build2 (code, type, fold_convert (type, arg0),\n+\t\t\t    fold_convert (type, negate_expr (arg1)));\n \n       /* X % -Y is the same as X % Y.  */\n       if (code == TRUNC_MOD_EXPR\n \t  && !TYPE_UNSIGNED (type)\n \t  && TREE_CODE (arg1) == NEGATE_EXPR\n \t  && !flag_trapv)\n-\treturn fold (build2 (code, type, fold_convert (type, arg0),\n-\t\t\t     fold_convert (type, TREE_OPERAND (arg1, 0))));\n+\treturn fold_build2 (code, type, fold_convert (type, arg0),\n+\t\t\t    fold_convert (type, TREE_OPERAND (arg1, 0)));\n \n       if (TREE_CODE (arg1) == INTEGER_CST\n \t  && 0 != (tem = extract_muldiv (op0, arg1, code, NULL_TREE)))\n@@ -8516,7 +8516,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\t    GET_MODE_BITSIZE (TYPE_MODE (type)));\n \t  tem = fold_convert (TREE_TYPE (arg1), tem);\n \t  tem = const_binop (MINUS_EXPR, tem, arg1, 0);\n-\t  return fold (build2 (RROTATE_EXPR, type, arg0, tem));\n+\t  return fold_build2 (RROTATE_EXPR, type, arg0, tem);\n \t}\n \n       /* If we have a rotate of a bit operation with the rotate count and\n@@ -8527,11 +8527,11 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      || TREE_CODE (arg0) == BIT_IOR_EXPR\n \t      || TREE_CODE (arg0) == BIT_XOR_EXPR)\n \t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n-\treturn fold (build2 (TREE_CODE (arg0), type,\n-\t\t\t     fold (build2 (code, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 0), arg1)),\n-\t\t\t     fold (build2 (code, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 1), arg1))));\n+\treturn fold_build2 (TREE_CODE (arg0), type,\n+\t\t\t    fold_build2 (code, type,\n+\t\t\t\t\t TREE_OPERAND (arg0, 0), arg1),\n+\t\t\t    fold_build2 (code, type,\n+\t\t\t\t\t TREE_OPERAND (arg0, 1), arg1));\n \n       /* Two consecutive rotates adding up to the width of the mode can\n \t be ignored.  */\n@@ -8606,11 +8606,11 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t{\n \t  tem = fold_to_nonsharp_ineq_using_bound (arg0, arg1);\n \t  if (tem)\n-\t    return fold (build2 (code, type, tem, arg1));\n+\t    return fold_build2 (code, type, tem, arg1);\n \n \t  tem = fold_to_nonsharp_ineq_using_bound (arg1, arg0);\n \t  if (tem)\n-\t    return fold (build2 (code, type, arg0, tem));\n+\t    return fold_build2 (code, type, arg0, tem);\n \t}\n \n     truth_andor:\n@@ -8641,23 +8641,23 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\t || code == TRUTH_OR_EXPR));\n \n \t  if (operand_equal_p (a00, a10, 0))\n-\t    return fold (build2 (TREE_CODE (arg0), type, a00,\n-\t\t\t\t fold (build2 (code, type, a01, a11))));\n+\t    return fold_build2 (TREE_CODE (arg0), type, a00,\n+\t\t\t\tfold_build2 (code, type, a01, a11));\n \t  else if (commutative && operand_equal_p (a00, a11, 0))\n-\t    return fold (build2 (TREE_CODE (arg0), type, a00,\n-\t\t\t\t fold (build2 (code, type, a01, a10))));\n+\t    return fold_build2 (TREE_CODE (arg0), type, a00,\n+\t\t\t\tfold_build2 (code, type, a01, a10));\n \t  else if (commutative && operand_equal_p (a01, a10, 0))\n-\t    return fold (build2 (TREE_CODE (arg0), type, a01,\n-\t\t\t\t fold (build2 (code, type, a00, a11))));\n+\t    return fold_build2 (TREE_CODE (arg0), type, a01,\n+\t\t\t\tfold_build2 (code, type, a00, a11));\n \n \t  /* This case if tricky because we must either have commutative\n \t     operators or else A10 must not have side-effects.  */\n \n \t  else if ((commutative || ! TREE_SIDE_EFFECTS (a10))\n \t\t   && operand_equal_p (a01, a11, 0))\n-\t    return fold (build2 (TREE_CODE (arg0), type,\n-\t\t\t\t fold (build2 (code, type, a00, a10)),\n-\t\t\t\t a01));\n+\t    return fold_build2 (TREE_CODE (arg0), type,\n+\t\t\t\tfold_build2 (code, type, a00, a10),\n+\t\t\t\ta01);\n \t}\n \n       /* See if we can build a range comparison.  */\n@@ -8670,7 +8670,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       if (TREE_CODE (arg0) == code\n \t  && 0 != (tem = fold_truthop (code, type,\n \t\t\t\t       TREE_OPERAND (arg0, 1), arg1)))\n-\treturn fold (build2 (code, type, TREE_OPERAND (arg0, 0), tem));\n+\treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0), tem);\n \n       if ((tem = fold_truthop (code, type, arg0, arg1)) != 0)\n \treturn tem;\n@@ -8721,7 +8721,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t{\n \t  /* Only call invert_truthvalue if operand is a truth value.  */\n \t  if (TREE_CODE (TREE_TYPE (arg0)) != BOOLEAN_TYPE)\n-\t    tem = fold (build1 (TRUTH_NOT_EXPR, TREE_TYPE (arg0), arg0));\n+\t    tem = fold_build1 (TRUTH_NOT_EXPR, TREE_TYPE (arg0), arg0);\n \t  else\n \t    tem = invert_truthvalue (arg0);\n \t  return non_lvalue (fold_convert (type, tem));\n@@ -8750,7 +8750,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n     case GE_EXPR:\n       /* If one arg is a real or integer constant, put it last.  */\n       if (tree_swap_operands_p (arg0, arg1, true))\n-\treturn fold (build2 (swap_tree_comparison (code), type, arg1, arg0));\n+\treturn fold_build2 (swap_tree_comparison (code), type, arg1, arg0);\n \n       /* If this is an equality comparison of the address of a non-weak\n \t object against zero, then we know the result.  */\n@@ -8804,7 +8804,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\toffset1 = build_int_cst (TREE_TYPE (offset0), 0);\n \n \t      if (TREE_TYPE (offset0) == TREE_TYPE (offset1))\n-\t\treturn fold (build2 (code, type, offset0, offset1));\n+\t\treturn fold_build2 (code, type, offset0, offset1);\n \t    }\n \t}\n \n@@ -8819,14 +8819,14 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n \t  /* Fold (double)float1 CMP (double)float2 into float1 CMP float2.  */\n \t  if (TYPE_PRECISION (newtype) < TYPE_PRECISION (TREE_TYPE (arg0)))\n-\t    return fold (build2 (code, type, fold_convert (newtype, targ0),\n-\t\t\t\t fold_convert (newtype, targ1)));\n+\t    return fold_build2 (code, type, fold_convert (newtype, targ0),\n+\t\t\t\tfold_convert (newtype, targ1));\n \n \t  /* (-a) CMP (-b) -> b CMP a  */\n \t  if (TREE_CODE (arg0) == NEGATE_EXPR\n \t      && TREE_CODE (arg1) == NEGATE_EXPR)\n-\t    return fold (build2 (code, type, TREE_OPERAND (arg1, 0),\n-\t\t\t\t TREE_OPERAND (arg0, 0)));\n+\t    return fold_build2 (code, type, TREE_OPERAND (arg1, 0),\n+\t\t\t\tTREE_OPERAND (arg0, 0));\n \n \t  if (TREE_CODE (arg1) == REAL_CST)\n \t  {\n@@ -8836,16 +8836,16 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t    /* (-a) CMP CST -> a swap(CMP) (-CST)  */\n \t    if (TREE_CODE (arg0) == NEGATE_EXPR)\n \t      return\n-\t\tfold (build2 (swap_tree_comparison (code), type,\n-\t\t\t      TREE_OPERAND (arg0, 0),\n-\t\t\t      build_real (TREE_TYPE (arg1),\n-\t\t\t\t\t  REAL_VALUE_NEGATE (cst))));\n+\t\tfold_build2 (swap_tree_comparison (code), type,\n+\t\t\t     TREE_OPERAND (arg0, 0),\n+\t\t\t     build_real (TREE_TYPE (arg1),\n+\t\t\t\t\t REAL_VALUE_NEGATE (cst)));\n \n \t    /* IEEE doesn't distinguish +0 and -0 in comparisons.  */\n \t    /* a CMP (-0) -> a CMP 0  */\n \t    if (REAL_VALUE_MINUS_ZERO (cst))\n-\t      return fold (build2 (code, type, arg0,\n-\t\t\t\t   build_real (TREE_TYPE (arg1), dconst0)));\n+\t      return fold_build2 (code, type, arg0,\n+\t\t\t\t  build_real (TREE_TYPE (arg1), dconst0));\n \n \t    /* x != NaN is always true, other ops are always false.  */\n \t    if (REAL_VALUE_ISNAN (cst)\n@@ -8877,7 +8877,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\t\t  ? MINUS_EXPR : PLUS_EXPR,\n \t\t\t\t\t  arg1, TREE_OPERAND (arg0, 1), 0))\n \t      && ! TREE_CONSTANT_OVERFLOW (tem))\n-\t    return fold (build2 (code, type, TREE_OPERAND (arg0, 0), tem));\n+\t    return fold_build2 (code, type, TREE_OPERAND (arg0, 0), tem);\n \n \t  /* Likewise, we can simplify a comparison of a real constant with\n \t     a MINUS_EXPR whose first operand is also a real constant, i.e.\n@@ -8889,8 +8889,8 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      && 0 != (tem = const_binop (MINUS_EXPR, TREE_OPERAND (arg0, 0),\n \t\t\t\t\t  arg1, 0))\n \t      && ! TREE_CONSTANT_OVERFLOW (tem))\n-\t    return fold (build2 (swap_tree_comparison (code), type,\n-\t\t\t\t TREE_OPERAND (arg0, 1), tem));\n+\t    return fold_build2 (swap_tree_comparison (code), type,\n+\t\t\t\tTREE_OPERAND (arg0, 1), tem);\n \n \t  /* Fold comparisons against built-in math functions.  */\n \t  if (TREE_CODE (arg1) == REAL_CST\n@@ -8924,16 +8924,16 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n \t  if (TREE_CODE (arg0) == POSTINCREMENT_EXPR)\n \t    {\n-\t      newconst = fold (build2 (PLUS_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t       arg1, TREE_OPERAND (arg0, 1)));\n+\t      newconst = fold_build2 (PLUS_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t      arg1, TREE_OPERAND (arg0, 1));\n \t      varop = build2 (PREINCREMENT_EXPR, TREE_TYPE (arg0),\n \t\t\t      TREE_OPERAND (arg0, 0),\n \t\t\t      TREE_OPERAND (arg0, 1));\n \t    }\n \t  else\n \t    {\n-\t      newconst = fold (build2 (MINUS_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t       arg1, TREE_OPERAND (arg0, 1)));\n+\t      newconst = fold_build2 (MINUS_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t      arg1, TREE_OPERAND (arg0, 1));\n \t      varop = build2 (PREDECREMENT_EXPR, TREE_TYPE (arg0),\n \t\t\t      TREE_OPERAND (arg0, 0),\n \t\t\t      TREE_OPERAND (arg0, 1));\n@@ -8954,22 +8954,22 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      /* First check whether the comparison would come out\n \t\t always the same.  If we don't do that we would\n \t\t change the meaning with the masking.  */\n-\t      folded_compare = fold (build2 (code, type,\n-\t\t\t\t\t     TREE_OPERAND (varop, 0), arg1));\n+\t      folded_compare = fold_build2 (code, type,\n+\t\t\t\t\t    TREE_OPERAND (varop, 0), arg1);\n \t      if (integer_zerop (folded_compare)\n \t\t  || integer_onep (folded_compare))\n \t\treturn omit_one_operand (type, folded_compare, varop);\n \n \t      shift = build_int_cst (NULL_TREE,\n \t\t\t\t     TYPE_PRECISION (TREE_TYPE (varop)) - size);\n \t      shift = fold_convert (TREE_TYPE (varop), shift);\n-\t      newconst = fold (build2 (LSHIFT_EXPR, TREE_TYPE (varop),\n-\t\t\t\t       newconst, shift));\n-\t      newconst = fold (build2 (RSHIFT_EXPR, TREE_TYPE (varop),\n-\t\t\t\t       newconst, shift));\n+\t      newconst = fold_build2 (LSHIFT_EXPR, TREE_TYPE (varop),\n+\t\t\t\t      newconst, shift);\n+\t      newconst = fold_build2 (RSHIFT_EXPR, TREE_TYPE (varop),\n+\t\t\t\t      newconst, shift);\n \t    }\n \n-\t  return fold (build2 (code, type, varop, newconst));\n+\t  return fold_build2 (code, type, varop, newconst);\n \t}\n \n       /* Change X >= C to X > (C - 1) and X < C to X <= (C - 1) if C > 0.\n@@ -8983,11 +8983,11 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t    {\n \t    case GE_EXPR:\n \t      arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t      return fold (build2 (GT_EXPR, type, arg0, arg1));\n+\t      return fold_build2 (GT_EXPR, type, arg0, arg1);\n \n \t    case LT_EXPR:\n \t      arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t      return fold (build2 (LE_EXPR, type, arg0, arg1));\n+\t      return fold_build2 (LE_EXPR, type, arg0, arg1);\n \n \t    default:\n \t      break;\n@@ -9061,13 +9061,13 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t  return omit_one_operand (type, integer_zero_node, arg0);\n \n \t\tcase GE_EXPR:\n-\t\t  return fold (build2 (EQ_EXPR, type, arg0, arg1));\n+\t\t  return fold_build2 (EQ_EXPR, type, arg0, arg1);\n \n \t\tcase LE_EXPR:\n \t\t  return omit_one_operand (type, integer_one_node, arg0);\n \n \t\tcase LT_EXPR:\n-\t\t  return fold (build2 (NE_EXPR, type, arg0, arg1));\n+\t\t  return fold_build2 (NE_EXPR, type, arg0, arg1);\n \n \t\t/* The GE_EXPR and LT_EXPR cases above are not normally\n \t\t   reached because of previous transformations.  */\n@@ -9082,10 +9082,10 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t{\n \t\tcase GT_EXPR:\n \t\t  arg1 = const_binop (PLUS_EXPR, arg1, integer_one_node, 0);\n-\t\t  return fold (build2 (EQ_EXPR, type, arg0, arg1));\n+\t\t  return fold_build2 (EQ_EXPR, type, arg0, arg1);\n \t\tcase LE_EXPR:\n \t\t  arg1 = const_binop (PLUS_EXPR, arg1, integer_one_node, 0);\n-\t\t  return fold (build2 (NE_EXPR, type, arg0, arg1));\n+\t\t  return fold_build2 (NE_EXPR, type, arg0, arg1);\n \t\tdefault:\n \t\t  break;\n \t\t}\n@@ -9098,13 +9098,13 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t  return omit_one_operand (type, integer_zero_node, arg0);\n \n \t\tcase LE_EXPR:\n-\t\t  return fold (build2 (EQ_EXPR, type, arg0, arg1));\n+\t\t  return fold_build2 (EQ_EXPR, type, arg0, arg1);\n \n \t\tcase GE_EXPR:\n \t\t  return omit_one_operand (type, integer_one_node, arg0);\n \n \t\tcase GT_EXPR:\n-\t\t  return fold (build2 (NE_EXPR, type, arg0, arg1));\n+\t\t  return fold_build2 (NE_EXPR, type, arg0, arg1);\n \n \t\tdefault:\n \t\t  break;\n@@ -9116,10 +9116,10 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t{\n \t\tcase GE_EXPR:\n \t\t  arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t\t  return fold (build2 (NE_EXPR, type, arg0, arg1));\n+\t\t  return fold_build2 (NE_EXPR, type, arg0, arg1);\n \t\tcase LT_EXPR:\n \t\t  arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t\t  return fold (build2 (EQ_EXPR, type, arg0, arg1));\n+\t\t  return fold_build2 (EQ_EXPR, type, arg0, arg1);\n \t\tdefault:\n \t\t  break;\n \t\t}\n@@ -9159,7 +9159,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\t      ? MINUS_EXPR : PLUS_EXPR,\n \t\t\t\t      arg1, TREE_OPERAND (arg0, 1), 0))\n \t  && ! TREE_CONSTANT_OVERFLOW (tem))\n-\treturn fold (build2 (code, type, TREE_OPERAND (arg0, 0), tem));\n+\treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0), tem);\n \n       /* Similarly for a NEGATE_EXPR.  */\n       else if ((code == EQ_EXPR || code == NE_EXPR)\n@@ -9168,14 +9168,14 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t       && 0 != (tem = negate_expr (arg1))\n \t       && TREE_CODE (tem) == INTEGER_CST\n \t       && ! TREE_CONSTANT_OVERFLOW (tem))\n-\treturn fold (build2 (code, type, TREE_OPERAND (arg0, 0), tem));\n+\treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0), tem);\n \n       /* If we have X - Y == 0, we can convert that to X == Y and similarly\n \t for !=.  Don't do this for ordered comparisons due to overflow.  */\n       else if ((code == NE_EXPR || code == EQ_EXPR)\n \t       && integer_zerop (arg1) && TREE_CODE (arg0) == MINUS_EXPR)\n-\treturn fold (build2 (code, type,\n-\t\t\t     TREE_OPERAND (arg0, 0), TREE_OPERAND (arg0, 1)));\n+\treturn fold_build2 (code, type,\n+\t\t\t    TREE_OPERAND (arg0, 0), TREE_OPERAND (arg0, 1));\n \n       else if (TREE_CODE (TREE_TYPE (arg0)) == INTEGER_TYPE\n \t       && (TREE_CODE (arg0) == NOP_EXPR\n@@ -9219,11 +9219,11 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t       && (0 != (tem = negate_expr (arg1)))\n \t       && TREE_CODE (tem) == INTEGER_CST\n \t       && ! TREE_CONSTANT_OVERFLOW (tem))\n-\treturn fold (build2 (TRUTH_ANDIF_EXPR, type,\n-\t\t\t     build2 (GE_EXPR, type,\n-\t\t\t\t     TREE_OPERAND (arg0, 0), tem),\n-\t\t\t     build2 (LE_EXPR, type,\n-\t\t\t\t     TREE_OPERAND (arg0, 0), arg1)));\n+\treturn fold_build2 (TRUTH_ANDIF_EXPR, type,\n+\t\t\t    build2 (GE_EXPR, type,\n+\t\t\t\t    TREE_OPERAND (arg0, 0), tem),\n+\t\t\t    build2 (LE_EXPR, type,\n+\t\t\t\t    TREE_OPERAND (arg0, 0), arg1));\n \n       /* Convert ABS_EXPR<x> >= 0 to true.  */\n       else if (code == GE_EXPR\n@@ -9243,7 +9243,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       else if ((code == EQ_EXPR || code == NE_EXPR)\n \t       && TREE_CODE (arg0) == ABS_EXPR\n \t       && (integer_zerop (arg1) || real_zerop (arg1)))\n-\treturn fold (build2 (code, type, TREE_OPERAND (arg0, 0), arg1));\n+\treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0), arg1);\n \n       /* If this is an EQ or NE comparison with zero and ARG0 is\n \t (1 << foo) & bar, convert it to (bar >> foo) & 1.  Both require\n@@ -9258,23 +9258,23 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  if (TREE_CODE (arg00) == LSHIFT_EXPR\n \t      && integer_onep (TREE_OPERAND (arg00, 0)))\n \t    return\n-\t      fold (build2 (code, type,\n-\t\t\t    build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t    build2 (RSHIFT_EXPR, TREE_TYPE (arg00),\n-\t\t\t\t\t    arg01, TREE_OPERAND (arg00, 1)),\n-\t\t\t\t    fold_convert (TREE_TYPE (arg0),\n-\t\t\t\t\t\t  integer_one_node)),\n-\t\t\t    arg1));\n+\t      fold_build2 (code, type,\n+\t\t\t   build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t   build2 (RSHIFT_EXPR, TREE_TYPE (arg00),\n+\t\t\t\t\t   arg01, TREE_OPERAND (arg00, 1)),\n+\t\t\t\t   fold_convert (TREE_TYPE (arg0),\n+\t\t\t\t\t\t integer_one_node)),\n+\t\t\t   arg1);\n \t  else if (TREE_CODE (TREE_OPERAND (arg0, 1)) == LSHIFT_EXPR\n \t\t   && integer_onep (TREE_OPERAND (TREE_OPERAND (arg0, 1), 0)))\n \t    return\n-\t      fold (build2 (code, type,\n-\t\t\t    build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t    build2 (RSHIFT_EXPR, TREE_TYPE (arg01),\n-\t\t\t\t\t    arg00, TREE_OPERAND (arg01, 1)),\n-\t\t\t\t    fold_convert (TREE_TYPE (arg0),\n-\t\t\t\t\t\t  integer_one_node)),\n-\t\t\t    arg1));\n+\t      fold_build2 (code, type,\n+\t\t\t   build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t   build2 (RSHIFT_EXPR, TREE_TYPE (arg01),\n+\t\t\t\t\t   arg00, TREE_OPERAND (arg01, 1)),\n+\t\t\t\t   fold_convert (TREE_TYPE (arg0),\n+\t\t\t\t\t\t integer_one_node)),\n+\t\t\t   arg1);\n \t}\n \n       /* If this is an NE or EQ comparison of zero against the result of a\n@@ -9290,14 +9290,14 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && integer_pow2p (TREE_OPERAND (arg0, 1)))\n \t{\n \t  tree newtype = lang_hooks.types.unsigned_type (TREE_TYPE (arg0));\n-\t  tree newmod = fold (build2 (TREE_CODE (arg0), newtype,\n-\t\t\t\t      fold_convert (newtype,\n-\t\t\t\t\t\t    TREE_OPERAND (arg0, 0)),\n-\t\t\t\t      fold_convert (newtype,\n-\t\t\t\t\t\t    TREE_OPERAND (arg0, 1))));\n+\t  tree newmod = fold_build2 (TREE_CODE (arg0), newtype,\n+\t\t\t\t     fold_convert (newtype,\n+\t\t\t\t\t\t   TREE_OPERAND (arg0, 0)),\n+\t\t\t\t     fold_convert (newtype,\n+\t\t\t\t\t\t   TREE_OPERAND (arg0, 1)));\n \n-\t  return fold (build2 (code, type, newmod,\n-\t\t\t       fold_convert (newtype, arg1)));\n+\t  return fold_build2 (code, type, newmod,\n+\t\t\t      fold_convert (newtype, arg1));\n \t}\n \n       /* If this is an NE comparison of zero with an AND of one, remove the\n@@ -9313,9 +9313,9 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && TREE_CODE (arg0) == BIT_AND_EXPR\n \t  && integer_pow2p (TREE_OPERAND (arg0, 1))\n \t  && operand_equal_p (TREE_OPERAND (arg0, 1), arg1, 0))\n-\treturn fold (build2 (code == EQ_EXPR ? NE_EXPR : EQ_EXPR, type,\n-\t\t\t     arg0, fold_convert (TREE_TYPE (arg0),\n-\t\t\t\t\t\t integer_zero_node)));\n+\treturn fold_build2 (code == EQ_EXPR ? NE_EXPR : EQ_EXPR, type,\n+\t\t\t    arg0, fold_convert (TREE_TYPE (arg0),\n+\t\t\t\t\t\tinteger_zero_node));\n \n       /* If we have (A & C) != 0 or (A & C) == 0 and C is a power of\n \t 2, then fold the expression into shifts and logical operations.  */\n@@ -9330,11 +9330,11 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && TREE_CODE (arg1) == INTEGER_CST\n \t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n \t{\n-\t  tree notc = fold (build1 (BIT_NOT_EXPR,\n-\t\t\t\t    TREE_TYPE (TREE_OPERAND (arg0, 1)),\n-\t\t\t\t    TREE_OPERAND (arg0, 1)));\n-\t  tree dandnotc = fold (build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t\targ1, notc));\n+\t  tree notc = fold_build1 (BIT_NOT_EXPR,\n+\t\t\t\t   TREE_TYPE (TREE_OPERAND (arg0, 1)),\n+\t\t\t\t   TREE_OPERAND (arg0, 1));\n+\t  tree dandnotc = fold_build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t       arg1, notc);\n \t  tree rslt = code == EQ_EXPR ? integer_zero_node : integer_one_node;\n \t  if (integer_nonzerop (dandnotc))\n \t    return omit_one_operand (type, rslt, arg0);\n@@ -9347,9 +9347,9 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && TREE_CODE (arg1) == INTEGER_CST\n \t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n \t{\n-\t  tree notd = fold (build1 (BIT_NOT_EXPR, TREE_TYPE (arg1), arg1));\n-\t  tree candnotd = fold (build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t\tTREE_OPERAND (arg0, 1), notd));\n+\t  tree notd = fold_build1 (BIT_NOT_EXPR, TREE_TYPE (arg1), arg1);\n+\t  tree candnotd = fold_build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t       TREE_OPERAND (arg0, 1), notd);\n \t  tree rslt = code == EQ_EXPR ? integer_zero_node : integer_one_node;\n \t  if (integer_nonzerop (candnotd))\n \t    return omit_one_operand (type, rslt, arg0);\n@@ -9397,7 +9397,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      if (! FLOAT_TYPE_P (TREE_TYPE (arg0))\n \t\t  || ! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n \t\treturn constant_boolean_node (1, type);\n-\t      return fold (build2 (EQ_EXPR, type, arg0, arg1));\n+\t      return fold_build2 (EQ_EXPR, type, arg0, arg1);\n \n \t    case NE_EXPR:\n \t      /* For NE, we can only do this simplification if integer\n@@ -9451,20 +9451,20 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t was the same as ARG1.  */\n \n \t      tree high_result\n-\t\t= fold (build2 (code, type,\n-\t\t\t\teval_subst (arg0, cval1, maxval,\n-\t\t\t\t\t    cval2, minval),\n-\t\t\t\targ1));\n+\t\t= fold_build2 (code, type,\n+\t\t\t       eval_subst (arg0, cval1, maxval,\n+\t\t\t\t\t   cval2, minval),\n+\t\t\t       arg1);\n \t      tree equal_result\n-\t\t= fold (build2 (code, type,\n-\t\t\t\teval_subst (arg0, cval1, maxval,\n-\t\t\t\t\t    cval2, maxval),\n-\t\t\t\targ1));\n+\t\t= fold_build2 (code, type,\n+\t\t\t       eval_subst (arg0, cval1, maxval,\n+\t\t\t\t\t   cval2, maxval),\n+\t\t\t       arg1);\n \t      tree low_result\n-\t\t= fold (build2 (code, type,\n-\t\t\t\teval_subst (arg0, cval1, minval,\n-\t\t\t\t\t    cval2, maxval),\n-\t\t\t\targ1));\n+\t\t= fold_build2 (code, type,\n+\t\t\t       eval_subst (arg0, cval1, minval,\n+\t\t\t\t\t   cval2, maxval),\n+\t\t\t       arg1);\n \n \t      /* All three of these results should be 0 or 1.  Confirm they\n \t\t are.  Then use those values to select the proper code\n@@ -9548,16 +9548,16 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n \t  arg0 = save_expr (arg0);\n \t  arg1 = save_expr (arg1);\n-\t  real0 = fold (build1 (REALPART_EXPR, subtype, arg0));\n-\t  imag0 = fold (build1 (IMAGPART_EXPR, subtype, arg0));\n-\t  real1 = fold (build1 (REALPART_EXPR, subtype, arg1));\n-\t  imag1 = fold (build1 (IMAGPART_EXPR, subtype, arg1));\n+\t  real0 = fold_build1 (REALPART_EXPR, subtype, arg0);\n+\t  imag0 = fold_build1 (IMAGPART_EXPR, subtype, arg0);\n+\t  real1 = fold_build1 (REALPART_EXPR, subtype, arg1);\n+\t  imag1 = fold_build1 (IMAGPART_EXPR, subtype, arg1);\n \n-\t  return fold (build2 ((code == EQ_EXPR ? TRUTH_ANDIF_EXPR\n-\t\t\t\t: TRUTH_ORIF_EXPR),\n-\t\t\t       type,\n-\t\t\t       fold (build2 (code, type, real0, real1)),\n-\t\t\t       fold (build2 (code, type, imag0, imag1))));\n+\t  return fold_build2 ((code == EQ_EXPR ? TRUTH_ANDIF_EXPR\n+\t\t\t       : TRUTH_ORIF_EXPR),\n+\t\t\t      type,\n+\t\t\t      fold_build2 (code, type, real0, real1),\n+\t\t\t      fold_build2 (code, type, imag0, imag1));\n \t}\n \n       /* Optimize comparisons of strlen vs zero to a compare of the\n@@ -9579,11 +9579,11 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      && (arglist = TREE_OPERAND (arg0, 1))\n \t      && TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) == POINTER_TYPE\n \t      && ! TREE_CHAIN (arglist))\n-\t    return fold (build2 (code, type,\n-\t\t\t\t build1 (INDIRECT_REF, char_type_node,\n-\t\t\t\t\t TREE_VALUE (arglist)),\n-\t\t\t\t fold_convert (char_type_node,\n-\t\t\t\t\t       integer_zero_node)));\n+\t    return fold_build2 (code, type,\n+\t\t\t\tbuild1 (INDIRECT_REF, char_type_node,\n+\t\t\t\t\tTREE_VALUE (arglist)),\n+\t\t\t\tfold_convert (char_type_node,\n+\t\t\t\t\t      integer_zero_node));\n \t}\n \n       /* We can fold X/C1 op C2 where C1 and C2 are integer constants\n@@ -9667,8 +9667,8 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  newtype = TREE_TYPE (targ1);\n \n \tif (TYPE_PRECISION (newtype) < TYPE_PRECISION (TREE_TYPE (arg0)))\n-\t  return fold (build2 (code, type, fold_convert (newtype, targ0),\n-\t\t\t       fold_convert (newtype, targ1)));\n+\t  return fold_build2 (code, type, fold_convert (newtype, targ0),\n+\t\t\t      fold_convert (newtype, targ1));\n       }\n \n       return NULL_TREE;\n@@ -9799,7 +9799,7 @@ fold_ternary (enum tree_code code, tree type, tree op0, tree op1, tree op2)\n \t  tem = invert_truthvalue (arg0);\n \n \t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n-\t    return fold (build3 (code, type, tem, op2, op1));\n+\t    return fold_build3 (code, type, tem, op2, op1);\n \t}\n \n       /* Convert A ? 1 : 0 to simply A.  */\n@@ -9825,8 +9825,8 @@ fold_ternary (enum tree_code code, tree type, tree op0, tree op1, tree op2)\n           && integer_zerop (TREE_OPERAND (arg0, 1))\n           && integer_zerop (op2)\n           && (tem = sign_bit_p (TREE_OPERAND (arg0, 0), arg1)))\n-        return fold_convert (type, fold (build2 (BIT_AND_EXPR,\n-\t\t\t\t\t\t TREE_TYPE (tem), tem, arg1)));\n+        return fold_convert (type, fold_build2 (BIT_AND_EXPR,\n+\t\t\t\t\t\tTREE_TYPE (tem), tem, arg1));\n \n       /* (A >> N) & 1 ? (1 << N) : 0 is simply A & (1 << N).  A & 1 was\n \t already handled above.  */\n@@ -9841,8 +9841,8 @@ fold_ternary (enum tree_code code, tree type, tree op0, tree op1, tree op2)\n               && TREE_CODE (TREE_OPERAND (tem, 1)) == INTEGER_CST\n               && (unsigned HOST_WIDE_INT) tree_log2 (arg1) ==\n \t         TREE_INT_CST_LOW (TREE_OPERAND (tem, 1)))\n-\t    return fold (build2 (BIT_AND_EXPR, type,\n-\t\t\t\t TREE_OPERAND (tem, 0), arg1));\n+\t    return fold_build2 (BIT_AND_EXPR, type,\n+\t\t\t\tTREE_OPERAND (tem, 0), arg1);\n \t}\n \n       /* A & N ? N : 0 is simply A & N if N is a power of two.  This\n@@ -9863,7 +9863,7 @@ fold_ternary (enum tree_code code, tree type, tree op0, tree op1, tree op2)\n       if (integer_zerop (op2)\n \t  && truth_value_p (TREE_CODE (arg0))\n \t  && truth_value_p (TREE_CODE (arg1)))\n-\treturn fold (build2 (TRUTH_ANDIF_EXPR, type, arg0, arg1));\n+\treturn fold_build2 (TRUTH_ANDIF_EXPR, type, arg0, arg1);\n \n       /* Convert A ? B : 1 into !A || B if A and B are truth values.  */\n       if (integer_onep (op2)\n@@ -9873,7 +9873,7 @@ fold_ternary (enum tree_code code, tree type, tree op0, tree op1, tree op2)\n \t  /* Only perform transformation if ARG0 is easily inverted.  */\n \t  tem = invert_truthvalue (arg0);\n \t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n-\t    return fold (build2 (TRUTH_ORIF_EXPR, type, tem, arg1));\n+\t    return fold_build2 (TRUTH_ORIF_EXPR, type, tem, arg1);\n \t}\n \n       /* Convert A ? 0 : B into !A && B if A and B are truth values.  */\n@@ -9884,14 +9884,14 @@ fold_ternary (enum tree_code code, tree type, tree op0, tree op1, tree op2)\n \t  /* Only perform transformation if ARG0 is easily inverted.  */\n \t  tem = invert_truthvalue (arg0);\n \t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n-\t    return fold (build2 (TRUTH_ANDIF_EXPR, type, tem, op2));\n+\t    return fold_build2 (TRUTH_ANDIF_EXPR, type, tem, op2);\n \t}\n \n       /* Convert A ? 1 : B into A || B if A and B are truth values.  */\n       if (integer_onep (arg1)\n \t  && truth_value_p (TREE_CODE (arg0))\n \t  && truth_value_p (TREE_CODE (op2)))\n-\treturn fold (build2 (TRUTH_ORIF_EXPR, type, arg0, op2));\n+\treturn fold_build2 (TRUTH_ORIF_EXPR, type, arg0, op2);\n \n       return NULL_TREE;\n \n@@ -11864,7 +11864,7 @@ ptr_difference_const (tree e1, tree e2, HOST_WIDE_INT *diff)\n       if (type != TREE_TYPE (toffset2))\n \ttoffset2 = fold_convert (type, toffset2);\n \n-      tdiff = fold (build2 (MINUS_EXPR, type, toffset1, toffset2));\n+      tdiff = fold_build2 (MINUS_EXPR, type, toffset1, toffset2);\n       if (!host_integerp (tdiff, 0))\n \treturn false;\n \n@@ -11906,9 +11906,9 @@ fold_strip_sign_ops (tree exp)\n       arg0 = fold_strip_sign_ops (TREE_OPERAND (exp, 0));\n       arg1 = fold_strip_sign_ops (TREE_OPERAND (exp, 1));\n       if (arg0 != NULL_TREE || arg1 != NULL_TREE)\n-\treturn fold (build2 (TREE_CODE (exp), TREE_TYPE (exp),\n-\t\t\t     arg0 ? arg0 : TREE_OPERAND (exp, 0),\n-\t\t\t     arg1 ? arg1 : TREE_OPERAND (exp, 1)));\n+\treturn fold_build2 (TREE_CODE (exp), TREE_TYPE (exp),\n+\t\t\t    arg0 ? arg0 : TREE_OPERAND (exp, 0),\n+\t\t\t    arg1 ? arg1 : TREE_OPERAND (exp, 1));\n       break;\n \n     default:"}]}