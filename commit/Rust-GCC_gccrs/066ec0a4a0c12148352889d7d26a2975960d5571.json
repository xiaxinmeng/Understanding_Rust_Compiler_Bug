{"sha": "066ec0a4a0c12148352889d7d26a2975960d5571", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY2ZWMwYTRhMGMxMjE0ODM1Mjg4OWQ3ZDI2YTI5NzU5NjBkNTU3MQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-06-30T00:50:34Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-06-30T00:50:34Z"}, "message": "cp-tree.h (TYPE_HAS_ASSIGN_REF): Rename to TYPE_HAS_COPY_ASSIGN.\n\n\t* cp-tree.h (TYPE_HAS_ASSIGN_REF): Rename to TYPE_HAS_COPY_ASSIGN.\n\t(TYPE_HAS_CONST_ASSIGN_REF): Rename to TYPE_HAS_CONST_COPY_ASSIGN.\n\t(TYPE_HAS_INIT_REF): Rename to TYPE_HAS_COPY_CTOR.\n\t(TYPE_HAS_CONST_INIT_REF): Rename to TYPE_HAS_CONST_COPY_CTOR.\n\t(TYPE_HAS_COMPLEX_ASSIGN_REF): Rename to TYPE_HAS_COMPLEX_COPY_ASSIGN.\n\t(TYPE_HAS_COMPLEX_INIT_REF): Rename to TYPE_HAS_COMPLEX_COPY_CTOR.\n\t(TYPE_HAS_TRIVIAL_ASSIGN_REF): Rename to TYPE_HAS_TRIVIAL_COPY_ASSIGN.\n\t(TYPE_HAS_TRIVIAL_INIT_REF): Rename to TYPE_HAS_TRIVIAL_COPY_CTOR.\n\t(CLASSTYPE_LAZY_ASSIGNMENT_OP): Rename to CLASSTYPE_LAZY_COPY_ASSIGN.\n\t(sfk_assignment_operator): Rename to sfk_copy_assignment.\n\t* decl.c, call.c, class.c, init.c, method.c, pt.c, ptree.c: Adjust.\n\t* search.c, semantics.c, tree.c: Adjust.\n\nFrom-SVN: r161577", "tree": {"sha": "1dc72ac1b9d7b731b6d2781f3b6a4919857d0c4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1dc72ac1b9d7b731b6d2781f3b6a4919857d0c4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/066ec0a4a0c12148352889d7d26a2975960d5571", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/066ec0a4a0c12148352889d7d26a2975960d5571", "html_url": "https://github.com/Rust-GCC/gccrs/commit/066ec0a4a0c12148352889d7d26a2975960d5571", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/066ec0a4a0c12148352889d7d26a2975960d5571/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "99453ddd870da9e9466dfdf14ebccb1cd31d52e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99453ddd870da9e9466dfdf14ebccb1cd31d52e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99453ddd870da9e9466dfdf14ebccb1cd31d52e9"}], "stats": {"total": 246, "additions": 130, "deletions": 116}, "files": [{"sha": "7eaca7fc688fc22e1b704d22a12d7d75ce4f45a5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=066ec0a4a0c12148352889d7d26a2975960d5571", "patch": "@@ -1,5 +1,18 @@\n 2010-06-29  Jason Merrill  <jason@redhat.com>\n \n+\t* cp-tree.h (TYPE_HAS_ASSIGN_REF): Rename to TYPE_HAS_COPY_ASSIGN.\n+\t(TYPE_HAS_CONST_ASSIGN_REF): Rename to TYPE_HAS_CONST_COPY_ASSIGN.\n+\t(TYPE_HAS_INIT_REF): Rename to TYPE_HAS_COPY_CTOR.\n+\t(TYPE_HAS_CONST_INIT_REF): Rename to TYPE_HAS_CONST_COPY_CTOR.\n+\t(TYPE_HAS_COMPLEX_ASSIGN_REF): Rename to TYPE_HAS_COMPLEX_COPY_ASSIGN.\n+\t(TYPE_HAS_COMPLEX_INIT_REF): Rename to TYPE_HAS_COMPLEX_COPY_CTOR.\n+\t(TYPE_HAS_TRIVIAL_ASSIGN_REF): Rename to TYPE_HAS_TRIVIAL_COPY_ASSIGN.\n+\t(TYPE_HAS_TRIVIAL_INIT_REF): Rename to TYPE_HAS_TRIVIAL_COPY_CTOR.\n+\t(CLASSTYPE_LAZY_ASSIGNMENT_OP): Rename to CLASSTYPE_LAZY_COPY_ASSIGN.\n+\t(sfk_assignment_operator): Rename to sfk_copy_assignment.\n+\t* decl.c, call.c, class.c, init.c, method.c, pt.c, ptree.c: Adjust.\n+\t* search.c, semantics.c, tree.c: Adjust.\n+\n \t* pt.c (dependent_scope_ref_p): Remove.\n \t(value_dependent_expression_p): Don't call it.\n \t(type_dependent_expression_p): Here either."}, {"sha": "c05e5a1ec2f6bdc974f02dba6534bb7f3da9ba87", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=066ec0a4a0c12148352889d7d26a2975960d5571", "patch": "@@ -5197,7 +5197,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t       OK.  */\n \t    if ((lvalue & clk_packed)\n \t\t&& CLASS_TYPE_P (type)\n-\t\t&& !TYPE_HAS_TRIVIAL_INIT_REF (type))\n+\t\t&& !TYPE_HAS_TRIVIAL_COPY_CTOR (type))\n \t      {\n \t\tif (complain & tf_error)\n \t\t  error (\"cannot bind packed field %qE to %qT\",\n@@ -5853,7 +5853,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t}\n       /* [class.copy]: the copy constructor is implicitly defined even if\n \t the implementation elided its use.  */\n-      else if (TYPE_HAS_COMPLEX_INIT_REF (DECL_CONTEXT (fn))\n+      else if (TYPE_HAS_COMPLEX_COPY_CTOR (DECL_CONTEXT (fn))\n \t       || move_fn_p (fn))\n \t{\n \t  mark_used (fn);\n@@ -5872,12 +5872,12 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t{\n \t  if (TREE_CODE (arg) == TARGET_EXPR)\n \t    return arg;\n-\t  else if (TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn))\n+\t  else if (TYPE_HAS_TRIVIAL_COPY_CTOR (DECL_CONTEXT (fn))\n \t\t   && !move_fn_p (fn))\n \t    return build_target_expr_with_type (arg, DECL_CONTEXT (fn));\n \t}\n       else if (TREE_CODE (arg) == TARGET_EXPR\n-\t       || (TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn))\n+\t       || (TYPE_HAS_TRIVIAL_COPY_CTOR (DECL_CONTEXT (fn))\n \t\t   && !move_fn_p (fn)))\n \t{\n \t  tree to = stabilize_reference (cp_build_indirect_ref (fa, RO_NULL,\n@@ -5889,7 +5889,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n     }\n   else if (DECL_OVERLOADED_OPERATOR_P (fn) == NOP_EXPR\n \t   && copy_fn_p (fn)\n-\t   && TYPE_HAS_TRIVIAL_ASSIGN_REF (DECL_CONTEXT (fn)))\n+\t   && TYPE_HAS_TRIVIAL_COPY_ASSIGN (DECL_CONTEXT (fn)))\n     {\n       tree to = stabilize_reference\n \t(cp_build_indirect_ref (argarray[0], RO_NULL, complain));"}, {"sha": "3a87555876cda20c848d671f3881b2e543caafb7", "filename": "gcc/cp/class.c", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=066ec0a4a0c12148352889d7d26a2975960d5571", "patch": "@@ -1282,10 +1282,10 @@ check_bases (tree t,\n \t assignment operators that take const references, then the\n \t derived class cannot have such a member automatically\n \t generated.  */\n-      if (! TYPE_HAS_CONST_INIT_REF (basetype))\n+      if (! TYPE_HAS_CONST_COPY_CTOR (basetype))\n \t*cant_have_const_ctor_p = 1;\n-      if (TYPE_HAS_ASSIGN_REF (basetype)\n-\t  && !TYPE_HAS_CONST_ASSIGN_REF (basetype))\n+      if (TYPE_HAS_COPY_ASSIGN (basetype)\n+\t  && !TYPE_HAS_CONST_COPY_ASSIGN (basetype))\n \t*no_const_asn_ref_p = 1;\n \n       if (BINFO_VIRTUAL_P (base_binfo))\n@@ -1311,9 +1311,9 @@ check_bases (tree t,\n       TYPE_NEEDS_CONSTRUCTING (t) |= TYPE_NEEDS_CONSTRUCTING (basetype);\n       TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n \t|= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (basetype);\n-      TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n-\t|= TYPE_HAS_COMPLEX_ASSIGN_REF (basetype);\n-      TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_HAS_COMPLEX_INIT_REF (basetype);\n+      TYPE_HAS_COMPLEX_COPY_ASSIGN (t)\n+\t|= TYPE_HAS_COMPLEX_COPY_ASSIGN (basetype);\n+      TYPE_HAS_COMPLEX_COPY_CTOR (t) |= TYPE_HAS_COMPLEX_COPY_CTOR (basetype);\n       TYPE_POLYMORPHIC_P (t) |= TYPE_POLYMORPHIC_P (basetype);\n       CLASSTYPE_CONTAINS_EMPTY_CLASS_P (t)\n \t|= CLASSTYPE_CONTAINS_EMPTY_CLASS_P (basetype);\n@@ -1541,7 +1541,7 @@ finish_struct_bits (tree t)\n      mode to be BLKmode, and force its TREE_ADDRESSABLE bit to be\n      nonzero.  This will cause it to be passed by invisible reference\n      and prevent it from being returned in a register.  */\n-  if (! TYPE_HAS_TRIVIAL_INIT_REF (t) || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t))\n+  if (! TYPE_HAS_TRIVIAL_COPY_CTOR (t) || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t))\n     {\n       tree variants;\n       DECL_MODE (TYPE_MAIN_DECL (t)) = BLKmode;\n@@ -1668,10 +1668,10 @@ maybe_warn_about_overly_private_class (tree t)\n \n \t   template <class T> class C { private: C(); };\n \n-\t To avoid this asymmetry, we check TYPE_HAS_INIT_REF.  All\n+\t To avoid this asymmetry, we check TYPE_HAS_COPY_CTOR.  All\n \t complete non-template or fully instantiated classes have this\n \t flag set.  */\n-      if (!TYPE_HAS_INIT_REF (t))\n+      if (!TYPE_HAS_COPY_CTOR (t))\n \tnonprivate_ctor = 1;\n       else\n \tfor (fn = CLASSTYPE_CONSTRUCTORS (t); fn; fn = OVL_NEXT (fn))\n@@ -2643,14 +2643,14 @@ add_implicitly_declared_members (tree t,\n \n      If a class definition does not explicitly declare a copy\n      constructor, one is declared implicitly.  */\n-  if (! TYPE_HAS_INIT_REF (t) && ! TYPE_FOR_JAVA (t))\n+  if (! TYPE_HAS_COPY_CTOR (t) && ! TYPE_FOR_JAVA (t))\n     {\n-      TYPE_HAS_INIT_REF (t) = 1;\n-      TYPE_HAS_CONST_INIT_REF (t) = !cant_have_const_cctor;\n+      TYPE_HAS_COPY_CTOR (t) = 1;\n+      TYPE_HAS_CONST_COPY_CTOR (t) = !cant_have_const_cctor;\n       CLASSTYPE_LAZY_COPY_CTOR (t) = 1;\n     }\n \n-  /* Currently only lambdas get a lazy move ctor, but N2987 adds them for\n+  /* Currently only lambdas get a lazy move ctor, but N3053 adds them for\n      other classes.  */\n   if (LAMBDA_TYPE_P (t))\n     CLASSTYPE_LAZY_MOVE_CTOR (t) = 1;\n@@ -2659,17 +2659,17 @@ add_implicitly_declared_members (tree t,\n      when it is needed.  For now, just record whether or not the type\n      of the parameter to the assignment operator will be a const or\n      non-const reference.  */\n-  if (!TYPE_HAS_ASSIGN_REF (t) && !TYPE_FOR_JAVA (t))\n+  if (!TYPE_HAS_COPY_ASSIGN (t) && !TYPE_FOR_JAVA (t))\n     {\n-      TYPE_HAS_ASSIGN_REF (t) = 1;\n-      TYPE_HAS_CONST_ASSIGN_REF (t) = !cant_have_const_assignment;\n-      CLASSTYPE_LAZY_ASSIGNMENT_OP (t) = 1;\n+      TYPE_HAS_COPY_ASSIGN (t) = 1;\n+      TYPE_HAS_CONST_COPY_ASSIGN (t) = !cant_have_const_assignment;\n+      CLASSTYPE_LAZY_COPY_ASSIGN (t) = 1;\n     }\n \n   /* We can't be lazy about declaring functions that might override\n      a virtual function from a base class.  */\n   if (TYPE_POLYMORPHIC_P (t)\n-      && (CLASSTYPE_LAZY_ASSIGNMENT_OP (t)\n+      && (CLASSTYPE_LAZY_COPY_ASSIGN (t)\n \t  || CLASSTYPE_LAZY_DESTRUCTOR (t)))\n     {\n       tree binfo = TYPE_BINFO (t);\n@@ -2684,8 +2684,8 @@ add_implicitly_declared_members (tree t,\n \t      tree fn = BV_FN (bv);\n \t      if (DECL_NAME (fn) == opname)\n \t\t{\n-\t\t  if (CLASSTYPE_LAZY_ASSIGNMENT_OP (t))\n-\t\t    lazily_declare_fn (sfk_assignment_operator, t);\n+\t\t  if (CLASSTYPE_LAZY_COPY_ASSIGN (t))\n+\t\t    lazily_declare_fn (sfk_copy_assignment, t);\n \t\t}\n \t      else if (DECL_DESTRUCTOR_P (fn)\n \t\t       && CLASSTYPE_LAZY_DESTRUCTOR (t))\n@@ -2819,7 +2819,7 @@ check_field_decl (tree field,\n      the settings of CANT_HAVE_CONST_CTOR and friends.  */\n   if (ANON_UNION_TYPE_P (type))\n     ;\n-  /* And, we don't set TYPE_HAS_CONST_INIT_REF, etc., for anonymous\n+  /* And, we don't set TYPE_HAS_CONST_COPY_CTOR, etc., for anonymous\n      structs.  So, we recurse through their fields here.  */\n   else if (ANON_AGGR_TYPE_P (type))\n     {\n@@ -2845,7 +2845,7 @@ check_field_decl (tree field,\n \t\t   field);\n \t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n \t    error (\"member %q+#D with destructor not allowed in union\", field);\n-\t  if (TYPE_HAS_COMPLEX_ASSIGN_REF (type))\n+\t  if (TYPE_HAS_COMPLEX_COPY_ASSIGN (type))\n \t    error (\"member %q+#D with copy assignment operator not allowed in union\",\n \t\t   field);\n \t}\n@@ -2854,15 +2854,15 @@ check_field_decl (tree field,\n \t  TYPE_NEEDS_CONSTRUCTING (t) |= TYPE_NEEDS_CONSTRUCTING (type);\n \t  TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n \t    |= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type);\n-\t  TYPE_HAS_COMPLEX_ASSIGN_REF (t) |= TYPE_HAS_COMPLEX_ASSIGN_REF (type);\n-\t  TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_HAS_COMPLEX_INIT_REF (type);\n+\t  TYPE_HAS_COMPLEX_COPY_ASSIGN (t) |= TYPE_HAS_COMPLEX_COPY_ASSIGN (type);\n+\t  TYPE_HAS_COMPLEX_COPY_CTOR (t) |= TYPE_HAS_COMPLEX_COPY_CTOR (type);\n \t  TYPE_HAS_COMPLEX_DFLT (t) |= TYPE_HAS_COMPLEX_DFLT (type);\n \t}\n \n-      if (!TYPE_HAS_CONST_INIT_REF (type))\n+      if (!TYPE_HAS_CONST_COPY_CTOR (type))\n \t*cant_have_const_ctor = 1;\n \n-      if (!TYPE_HAS_CONST_ASSIGN_REF (type))\n+      if (!TYPE_HAS_CONST_COPY_ASSIGN (type))\n \t*no_const_asn_ref = 1;\n     }\n   if (DECL_INITIAL (field) != NULL_TREE)\n@@ -3021,7 +3021,7 @@ check_field_decls (tree t, tree *access_decls,\n \t     aggregate, initialization by a brace-enclosed list) is the\n \t     only way to initialize nonstatic const and reference\n \t     members.  */\n-\t  TYPE_HAS_COMPLEX_ASSIGN_REF (t) = 1;\n+\t  TYPE_HAS_COMPLEX_COPY_ASSIGN (t) = 1;\n \t}\n \n       type = strip_array_types (type);\n@@ -3107,7 +3107,7 @@ check_field_decls (tree t, tree *access_decls,\n \t     aggregate, initialization by a brace-enclosed list) is the\n \t     only way to initialize nonstatic const and reference\n \t     members.  */\n-\t  TYPE_HAS_COMPLEX_ASSIGN_REF (t) = 1;\n+\t  TYPE_HAS_COMPLEX_COPY_ASSIGN (t) = 1;\n \t}\n       /* A field that is pseudo-const makes the structure likewise.  */\n       else if (CLASS_TYPE_P (type))\n@@ -3144,18 +3144,18 @@ check_field_decls (tree t, tree *access_decls,\n       && has_pointers\n       && TYPE_HAS_USER_CONSTRUCTOR (t)\n       && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n-      && !(TYPE_HAS_INIT_REF (t) && TYPE_HAS_ASSIGN_REF (t)))\n+      && !(TYPE_HAS_COPY_CTOR (t) && TYPE_HAS_COPY_ASSIGN (t)))\n     {\n       warning (OPT_Weffc__, \"%q#T has pointer data members\", t);\n \n-      if (! TYPE_HAS_INIT_REF (t))\n+      if (! TYPE_HAS_COPY_CTOR (t))\n \t{\n \t  warning (OPT_Weffc__,\n \t\t   \"  but does not override %<%T(const %T&)%>\", t, t);\n-\t  if (!TYPE_HAS_ASSIGN_REF (t))\n+\t  if (!TYPE_HAS_COPY_ASSIGN (t))\n \t    warning (OPT_Weffc__, \"  or %<operator=(const %T&)%>\", t);\n \t}\n-      else if (! TYPE_HAS_ASSIGN_REF (t))\n+      else if (! TYPE_HAS_COPY_ASSIGN (t))\n \twarning (OPT_Weffc__,\n \t\t \"  but does not override %<operator=(const %T&)%>\", t);\n     }\n@@ -4375,7 +4375,7 @@ check_bases_and_members (tree t)\n   /* Save the initial values of these flags which only indicate whether\n      or not the class has user-provided functions.  As we analyze the\n      bases and members we can set these flags for other reasons.  */\n-  saved_complex_asn_ref = TYPE_HAS_COMPLEX_ASSIGN_REF (t);\n+  saved_complex_asn_ref = TYPE_HAS_COMPLEX_COPY_ASSIGN (t);\n   saved_nontrivial_dtor = TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t);\n \n   /* Check all the data member declarations.  We cannot call\n@@ -4393,7 +4393,7 @@ check_bases_and_members (tree t)\n \n   /* Do some bookkeeping that will guide the generation of implicitly\n      declared member functions.  */\n-  TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_CONTAINS_VPTR_P (t);\n+  TYPE_HAS_COMPLEX_COPY_CTOR (t) |= TYPE_CONTAINS_VPTR_P (t);\n   /* We need to call a constructor for this class if it has a\n      user-provided constructor, or if the default constructor is going\n      to initialize the vptr.  (This is not an if-and-only-if;\n@@ -4416,7 +4416,7 @@ check_bases_and_members (tree t)\n     |= (CLASSTYPE_NON_AGGREGATE (t)\n \t|| saved_nontrivial_dtor || saved_complex_asn_ref);\n   CLASSTYPE_NON_STD_LAYOUT (t) |= TYPE_CONTAINS_VPTR_P (t);\n-  TYPE_HAS_COMPLEX_ASSIGN_REF (t) |= TYPE_CONTAINS_VPTR_P (t);\n+  TYPE_HAS_COMPLEX_COPY_ASSIGN (t) |= TYPE_CONTAINS_VPTR_P (t);\n   TYPE_HAS_COMPLEX_DFLT (t) |= TYPE_CONTAINS_VPTR_P (t);\n \n   /* If the class has no user-declared constructor, but does have\n@@ -4488,8 +4488,8 @@ check_bases_and_members (tree t)\n       TYPE_NEEDS_CONSTRUCTING (t) = 1;\n       TYPE_HAS_DEFAULT_CONSTRUCTOR (t) = 0;\n       CLASSTYPE_LAZY_DEFAULT_CTOR (t) = 0;\n-      TYPE_HAS_ASSIGN_REF (t) = 0;\n-      CLASSTYPE_LAZY_ASSIGNMENT_OP (t) = 0;\n+      TYPE_HAS_COPY_ASSIGN (t) = 0;\n+      CLASSTYPE_LAZY_COPY_ASSIGN (t) = 0;\n \n       /* \"This class type is not an aggregate.\"  */\n       CLASSTYPE_NON_AGGREGATE (t) = 1;"}, {"sha": "1b3c2f0a0f99d3d74f2139ad613b304e9eaa8d9a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=066ec0a4a0c12148352889d7d26a2975960d5571", "patch": "@@ -1239,11 +1239,11 @@ struct GTY(()) lang_type_header {\n   BOOL_BITFIELD is_lang_type_class : 1;\n \n   BOOL_BITFIELD has_type_conversion : 1;\n-  BOOL_BITFIELD has_init_ref : 1;\n+  BOOL_BITFIELD has_copy_ctor : 1;\n   BOOL_BITFIELD has_default_ctor : 1;\n   BOOL_BITFIELD const_needs_init : 1;\n   BOOL_BITFIELD ref_needs_init : 1;\n-  BOOL_BITFIELD has_const_assign_ref : 1;\n+  BOOL_BITFIELD has_const_copy_assign : 1;\n \n   BOOL_BITFIELD spare : 1;\n };\n@@ -1271,7 +1271,7 @@ struct GTY(()) lang_type_class {\n   unsigned non_pod_class : 1;\n   unsigned nearly_empty_p : 1;\n   unsigned user_align : 1;\n-  unsigned has_assign_ref : 1;\n+  unsigned has_copy_assign : 1;\n   unsigned has_new : 1;\n   unsigned has_array_new : 1;\n \n@@ -1297,17 +1297,18 @@ struct GTY(()) lang_type_class {\n   unsigned was_anonymous : 1;\n   unsigned lazy_default_ctor : 1;\n   unsigned lazy_copy_ctor : 1;\n-  unsigned lazy_assignment_op : 1;\n+  unsigned lazy_copy_assign : 1;\n   unsigned lazy_destructor : 1;\n \n-  unsigned has_const_init_ref : 1;\n-  unsigned has_complex_init_ref : 1;\n-  unsigned has_complex_assign_ref : 1;\n+  unsigned has_const_copy_ctor : 1;\n+  unsigned has_complex_copy_ctor : 1;\n+  unsigned has_complex_copy_assign : 1;\n   unsigned non_aggregate : 1;\n   unsigned has_complex_dflt : 1;\n   unsigned has_list_ctor : 1;\n   unsigned non_std_layout : 1;\n   unsigned lazy_move_ctor : 1;\n+\n   unsigned is_literal : 1;\n \n   /* When adding a flag here, consider whether or not it ought to\n@@ -1412,26 +1413,26 @@ struct GTY((variable_size)) lang_type {\n \n /* Nonzero means that NODE (a class type) has an assignment operator\n    -- but that it has not yet been declared.  */\n-#define CLASSTYPE_LAZY_ASSIGNMENT_OP(NODE) \\\n-  (LANG_TYPE_CLASS_CHECK (NODE)->lazy_assignment_op)\n+#define CLASSTYPE_LAZY_COPY_ASSIGN(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->lazy_copy_assign)\n \n /* Nonzero means that NODE (a class type) has a destructor -- but that\n    it has not yet been declared.  */\n #define CLASSTYPE_LAZY_DESTRUCTOR(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->lazy_destructor)\n \n /* Nonzero means that this _CLASSTYPE node overloads operator=(X&).  */\n-#define TYPE_HAS_ASSIGN_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_assign_ref)\n+#define TYPE_HAS_COPY_ASSIGN(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_copy_assign)\n \n /* True iff the class type NODE has an \"operator =\" whose parameter\n    has a parameter of type \"const X&\".  */\n-#define TYPE_HAS_CONST_ASSIGN_REF(NODE) \\\n-  (LANG_TYPE_CLASS_CHECK (NODE)->h.has_const_assign_ref)\n+#define TYPE_HAS_CONST_COPY_ASSIGN(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->h.has_const_copy_assign)\n \n /* Nonzero means that this _CLASSTYPE node has an X(X&) constructor.  */\n-#define TYPE_HAS_INIT_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->h.has_init_ref)\n-#define TYPE_HAS_CONST_INIT_REF(NODE) \\\n-  (LANG_TYPE_CLASS_CHECK (NODE)->has_const_init_ref)\n+#define TYPE_HAS_COPY_CTOR(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->h.has_copy_ctor)\n+#define TYPE_HAS_CONST_COPY_CTOR(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->has_const_copy_ctor)\n \n /* Nonzero if this class has an X(initializer_list<T>) constructor.  */\n #define TYPE_HAS_LIST_CTOR(NODE) \\\n@@ -3159,13 +3160,13 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define TYPE_NON_AGGREGATE_CLASS(NODE) \\\n   (CLASS_TYPE_P (NODE) && CLASSTYPE_NON_AGGREGATE (NODE))\n \n-/* Nonzero if there is a user-defined X::op=(x&) for this class.  */\n-#define TYPE_HAS_COMPLEX_ASSIGN_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_assign_ref)\n+/* Nonzero if there is a non-trivial X::op=(cv X&) for this class.  */\n+#define TYPE_HAS_COMPLEX_COPY_ASSIGN(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_copy_assign)\n \n-/* Nonzero if there is a user-defined X::X(x&) for this class.  */\n-#define TYPE_HAS_COMPLEX_INIT_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_init_ref)\n+/* Nonzero if there is a non-trivial X::X(cv X&) for this class.  */\n+#define TYPE_HAS_COMPLEX_COPY_CTOR(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_copy_ctor)\n \n-/* Nonzero if there is a user-defined default constructor for this class.  */\n+/* Nonzero if there is a non-trivial default constructor for this class.  */\n #define TYPE_HAS_COMPLEX_DFLT(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_dflt)\n \n /* Nonzero if TYPE has a trivial destructor.  From [class.dtor]:\n@@ -3195,13 +3196,13 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n \n /* Nonzero for class type means that copy initialization of this type can use\n    a bitwise copy.  */\n-#define TYPE_HAS_TRIVIAL_INIT_REF(NODE) \\\n-  (TYPE_HAS_INIT_REF (NODE) && ! TYPE_HAS_COMPLEX_INIT_REF (NODE))\n+#define TYPE_HAS_TRIVIAL_COPY_CTOR(NODE) \\\n+  (TYPE_HAS_COPY_CTOR (NODE) && ! TYPE_HAS_COMPLEX_COPY_CTOR (NODE))\n \n /* Nonzero for class type means that assignment of this type can use\n    a bitwise copy.  */\n-#define TYPE_HAS_TRIVIAL_ASSIGN_REF(NODE) \\\n-  (TYPE_HAS_ASSIGN_REF (NODE) && ! TYPE_HAS_COMPLEX_ASSIGN_REF (NODE))\n+#define TYPE_HAS_TRIVIAL_COPY_ASSIGN(NODE) \\\n+  (TYPE_HAS_COPY_ASSIGN (NODE) && ! TYPE_HAS_COMPLEX_COPY_ASSIGN (NODE))\n \n /* Returns true if NODE is a pointer-to-data-member.  */\n #define TYPE_PTRMEM_P(NODE)\t\t\t\\\n@@ -3867,7 +3868,7 @@ typedef enum special_function_kind {\n   sfk_constructor,\t   /* A constructor.  */\n   sfk_copy_constructor,    /* A copy constructor.  */\n   sfk_move_constructor,    /* A move constructor.  */\n-  sfk_assignment_operator, /* An assignment operator.  */\n+  sfk_copy_assignment,     /* A copy assignment operator.  */\n   sfk_destructor,\t   /* A destructor.  */\n   sfk_complete_destructor, /* A destructor for complete objects.  */\n   sfk_base_destructor,     /* A destructor for base subobjects.  */"}, {"sha": "10112437fe98b34c9b6140065ccd7218fa5e5685", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=066ec0a4a0c12148352889d7d26a2975960d5571", "patch": "@@ -3866,10 +3866,10 @@ fixup_anonymous_aggr (tree t)\n   /* Wipe out memory of synthesized methods.  */\n   TYPE_HAS_USER_CONSTRUCTOR (t) = 0;\n   TYPE_HAS_DEFAULT_CONSTRUCTOR (t) = 0;\n-  TYPE_HAS_INIT_REF (t) = 0;\n-  TYPE_HAS_CONST_INIT_REF (t) = 0;\n-  TYPE_HAS_ASSIGN_REF (t) = 0;\n-  TYPE_HAS_CONST_ASSIGN_REF (t) = 0;\n+  TYPE_HAS_COPY_CTOR (t) = 0;\n+  TYPE_HAS_CONST_COPY_CTOR (t) = 0;\n+  TYPE_HAS_COPY_ASSIGN (t) = 0;\n+  TYPE_HAS_CONST_COPY_ASSIGN (t) = 0;\n \n   /* Splice the implicitly generated functions out of the TYPE_METHODS\n      list.  */\n@@ -3915,7 +3915,7 @@ fixup_anonymous_aggr (tree t)\n \t\tif (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n \t\t  error (\"member %q+#D with destructor not allowed \"\n \t\t\t \"in anonymous aggregate\", field);\n-\t\tif (TYPE_HAS_COMPLEX_ASSIGN_REF (type))\n+\t\tif (TYPE_HAS_COMPLEX_COPY_ASSIGN (type))\n \t\t  error (\"member %q+#D with copy assignment operator \"\n \t\t\t \"not allowed in anonymous aggregate\", field);\n \t      }\n@@ -10261,11 +10261,11 @@ grok_special_member_properties (tree decl)\n \t     X&, volatile X& or const volatile X&, and either there\n \t     are no other parameters or else all other parameters have\n \t     default arguments.  */\n-\t  TYPE_HAS_INIT_REF (class_type) = 1;\n+\t  TYPE_HAS_COPY_CTOR (class_type) = 1;\n \t  if (user_provided_p (decl))\n-\t    TYPE_HAS_COMPLEX_INIT_REF (class_type) = 1;\n+\t    TYPE_HAS_COMPLEX_COPY_CTOR (class_type) = 1;\n \t  if (ctor > 1)\n-\t    TYPE_HAS_CONST_INIT_REF (class_type) = 1;\n+\t    TYPE_HAS_CONST_COPY_CTOR (class_type) = 1;\n \t}\n       else if (sufficient_parms_p (FUNCTION_FIRST_USER_PARMTYPE (decl)))\n \t{\n@@ -10288,11 +10288,11 @@ grok_special_member_properties (tree decl)\n \n       if (assop)\n \t{\n-\t  TYPE_HAS_ASSIGN_REF (class_type) = 1;\n+\t  TYPE_HAS_COPY_ASSIGN (class_type) = 1;\n \t  if (user_provided_p (decl))\n-\t    TYPE_HAS_COMPLEX_ASSIGN_REF (class_type) = 1;\n+\t    TYPE_HAS_COMPLEX_COPY_ASSIGN (class_type) = 1;\n \t  if (assop != 1)\n-\t    TYPE_HAS_CONST_ASSIGN_REF (class_type) = 1;\n+\t    TYPE_HAS_CONST_COPY_ASSIGN (class_type) = 1;\n \t}\n     }\n }"}, {"sha": "85ad582f2d1ed97e0c6f07bb91470a5feadfd7f1", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=066ec0a4a0c12148352889d7d26a2975960d5571", "patch": "@@ -2834,7 +2834,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n       && TREE_CODE (atype) == ARRAY_TYPE\n       && (from_array == 2\n \t  ? (!CLASS_TYPE_P (inner_elt_type)\n-\t     || !TYPE_HAS_COMPLEX_ASSIGN_REF (inner_elt_type))\n+\t     || !TYPE_HAS_COMPLEX_COPY_ASSIGN (inner_elt_type))\n \t  : !TYPE_NEEDS_CONSTRUCTING (type))\n       && ((TREE_CODE (init) == CONSTRUCTOR\n \t   /* Don't do this if the CONSTRUCTOR might contain something"}, {"sha": "96a1d54974003458d6cdd1dd0e9b99ed45aaf28a", "filename": "gcc/cp/method.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=066ec0a4a0c12148352889d7d26a2975960d5571", "patch": "@@ -57,7 +57,7 @@ enum mangling_flags\n \n typedef enum mangling_flags mangling_flags;\n \n-static void do_build_assign_ref (tree);\n+static void do_build_copy_assign (tree);\n static void do_build_copy_constructor (tree);\n static tree synthesize_exception_spec (tree, tree (*) (tree, void *), void *);\n static tree make_alias_for_thunk (tree);\n@@ -410,11 +410,11 @@ do_build_copy_constructor (tree fndecl)\n \n   parm = convert_from_reference (parm);\n \n-  if (TYPE_HAS_TRIVIAL_INIT_REF (current_class_type)\n+  if (TYPE_HAS_TRIVIAL_COPY_CTOR (current_class_type)\n       && is_empty_class (current_class_type))\n     /* Don't copy the padding byte; it might not have been allocated\n        if *this is a base subobject.  */;\n-  else if (TYPE_HAS_TRIVIAL_INIT_REF (current_class_type))\n+  else if (TYPE_HAS_TRIVIAL_COPY_CTOR (current_class_type))\n     {\n       tree t = build2 (INIT_EXPR, void_type_node, current_class_ref, parm);\n       finish_expr_stmt (t);\n@@ -508,19 +508,19 @@ do_build_copy_constructor (tree fndecl)\n }\n \n static void\n-do_build_assign_ref (tree fndecl)\n+do_build_copy_assign (tree fndecl)\n {\n   tree parm = TREE_CHAIN (DECL_ARGUMENTS (fndecl));\n   tree compound_stmt;\n \n   compound_stmt = begin_compound_stmt (0);\n   parm = convert_from_reference (parm);\n \n-  if (TYPE_HAS_TRIVIAL_ASSIGN_REF (current_class_type)\n+  if (TYPE_HAS_TRIVIAL_COPY_ASSIGN (current_class_type)\n       && is_empty_class (current_class_type))\n     /* Don't copy the padding byte; it might not have been allocated\n        if *this is a base subobject.  */;\n-  else if (TYPE_HAS_TRIVIAL_ASSIGN_REF (current_class_type))\n+  else if (TYPE_HAS_TRIVIAL_COPY_ASSIGN (current_class_type))\n     {\n       tree t = build2 (MODIFY_EXPR, void_type_node, current_class_ref, parm);\n       finish_expr_stmt (t);\n@@ -657,7 +657,7 @@ synthesize_method (tree fndecl)\n \n   if (DECL_OVERLOADED_OPERATOR_P (fndecl) == NOP_EXPR)\n     {\n-      do_build_assign_ref (fndecl);\n+      do_build_copy_assign (fndecl);\n       need_body = false;\n     }\n   else if (DECL_CONSTRUCTOR_P (fndecl))\n@@ -806,7 +806,7 @@ locate_copy (tree type, void *client_)\n \treturn NULL_TREE;\n       fns = VEC_index (tree, CLASSTYPE_METHOD_VEC (type), ix);\n     }\n-  else if (TYPE_HAS_INIT_REF (type))\n+  else if (TYPE_HAS_COPY_CTOR (type))\n     {\n       /* If construction of the copy constructor was postponed, create\n \t it now.  */\n@@ -913,14 +913,14 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n       break;\n \n     case sfk_copy_constructor:\n-    case sfk_assignment_operator:\n+    case sfk_copy_assignment:\n     case sfk_move_constructor:\n     {\n       struct copy_data data;\n \n       data.name = NULL;\n       data.quals = 0;\n-      if (kind == sfk_assignment_operator)\n+      if (kind == sfk_copy_assignment)\n \t{\n \t  return_type = build_reference_type (type);\n \t  name = ansi_assopname (NOP_EXPR);\n@@ -1057,7 +1057,7 @@ defaultable_fn_check (tree fn)\n   else if (DECL_ASSIGNMENT_OPERATOR_P (fn)\n \t   && DECL_OVERLOADED_OPERATOR_P (fn) == NOP_EXPR\n \t   && copy_fn_p (fn))\n-    kind = sfk_assignment_operator;\n+    kind = sfk_copy_assignment;\n \n   if (kind == sfk_none)\n     {\n@@ -1108,17 +1108,17 @@ lazily_declare_fn (special_function_kind sfk, tree type)\n   /* Figure out whether or not the argument has a const reference\n      type.  */\n   if (sfk == sfk_copy_constructor)\n-    const_p = TYPE_HAS_CONST_INIT_REF (type);\n-  else if (sfk == sfk_assignment_operator)\n-    const_p = TYPE_HAS_CONST_ASSIGN_REF (type);\n+    const_p = TYPE_HAS_CONST_COPY_CTOR (type);\n+  else if (sfk == sfk_copy_assignment)\n+    const_p = TYPE_HAS_CONST_COPY_ASSIGN (type);\n   else\n     /* In this case, CONST_P will be ignored.  */\n     const_p = false;\n   /* Declare the function.  */\n   fn = implicitly_declare_fn (sfk, type, const_p);\n   /* A destructor may be virtual.  */\n   if (sfk == sfk_destructor\n-      || sfk == sfk_assignment_operator)\n+      || sfk == sfk_copy_assignment)\n     check_for_override (fn, type);\n   /* Add it to CLASSTYPE_METHOD_VEC.  */\n   add_method (type, fn, NULL_TREE);\n@@ -1143,8 +1143,8 @@ lazily_declare_fn (special_function_kind sfk, tree type)\n       TYPE_METHODS (type) = fn;\n     }\n   maybe_add_class_template_decl_list (type, fn, /*friend_p=*/0);\n-  if (sfk == sfk_assignment_operator)\n-    CLASSTYPE_LAZY_ASSIGNMENT_OP (type) = 0;\n+  if (sfk == sfk_copy_assignment)\n+    CLASSTYPE_LAZY_COPY_ASSIGN (type) = 0;\n   else\n     {\n       /* Remember that the function has been created.  */"}, {"sha": "09d077ade06f91ec354f323fa14639c846bd73c9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=066ec0a4a0c12148352889d7d26a2975960d5571", "patch": "@@ -7809,10 +7809,10 @@ instantiate_class_template (tree type)\n   TYPE_HAS_NEW_OPERATOR (type) = TYPE_HAS_NEW_OPERATOR (pattern);\n   TYPE_HAS_ARRAY_NEW_OPERATOR (type) = TYPE_HAS_ARRAY_NEW_OPERATOR (pattern);\n   TYPE_GETS_DELETE (type) = TYPE_GETS_DELETE (pattern);\n-  TYPE_HAS_ASSIGN_REF (type) = TYPE_HAS_ASSIGN_REF (pattern);\n-  TYPE_HAS_CONST_ASSIGN_REF (type) = TYPE_HAS_CONST_ASSIGN_REF (pattern);\n-  TYPE_HAS_INIT_REF (type) = TYPE_HAS_INIT_REF (pattern);\n-  TYPE_HAS_CONST_INIT_REF (type) = TYPE_HAS_CONST_INIT_REF (pattern);\n+  TYPE_HAS_COPY_ASSIGN (type) = TYPE_HAS_COPY_ASSIGN (pattern);\n+  TYPE_HAS_CONST_COPY_ASSIGN (type) = TYPE_HAS_CONST_COPY_ASSIGN (pattern);\n+  TYPE_HAS_COPY_CTOR (type) = TYPE_HAS_COPY_CTOR (pattern);\n+  TYPE_HAS_CONST_COPY_CTOR (type) = TYPE_HAS_CONST_COPY_CTOR (pattern);\n   TYPE_HAS_DEFAULT_CONSTRUCTOR (type) = TYPE_HAS_DEFAULT_CONSTRUCTOR (pattern);\n   TYPE_HAS_CONVERSION (type) = TYPE_HAS_CONVERSION (pattern);\n   TYPE_PACKED (type) = TYPE_PACKED (pattern);"}, {"sha": "c2493c7fcadf42cec752a90636c18c8e31bbe1df", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=066ec0a4a0c12148352889d7d26a2975960d5571", "patch": "@@ -124,9 +124,9 @@ cxx_print_type (FILE *file, tree node, int indent)\n     fputs (\" X()\", file);\n   if (TYPE_HAS_CONVERSION (node))\n     fputs (\" has-type-conversion\", file);\n-  if (TYPE_HAS_INIT_REF (node))\n+  if (TYPE_HAS_COPY_CTOR (node))\n     {\n-      if (TYPE_HAS_CONST_INIT_REF (node))\n+      if (TYPE_HAS_CONST_COPY_CTOR (node))\n \tfputs (\" X(constX&)\", file);\n       else\n \tfputs (\" X(X&)\", file);\n@@ -139,7 +139,7 @@ cxx_print_type (FILE *file, tree node, int indent)\n     fputs (\" delete\", file);\n   if (TYPE_GETS_DELETE (node) & 2)\n     fputs (\" delete[]\", file);\n-  if (TYPE_HAS_ASSIGN_REF (node))\n+  if (TYPE_HAS_COPY_ASSIGN (node))\n     fputs (\" this=(X&)\", file);\n   if (CLASSTYPE_SORTED_FIELDS (node))\n     fprintf (file, \" sorted-fields %p\","}, {"sha": "d291c0834217f8479567d98e777e88873007ca38", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=066ec0a4a0c12148352889d7d26a2975960d5571", "patch": "@@ -1362,8 +1362,8 @@ lookup_fnfields_1 (tree type, tree name)\n \t    lazily_declare_fn (sfk_move_constructor, type);\n \t}\n       else if (name == ansi_assopname(NOP_EXPR)\n-\t       && CLASSTYPE_LAZY_ASSIGNMENT_OP (type))\n-\tlazily_declare_fn (sfk_assignment_operator, type);\n+\t       && CLASSTYPE_LAZY_COPY_ASSIGN (type))\n+\tlazily_declare_fn (sfk_copy_assignment, type);\n       else if ((name == dtor_identifier\n \t\t|| name == base_dtor_identifier\n \t\t|| name == complete_dtor_identifier"}, {"sha": "9dae90b4c8f077c487dd10fd3a329070dc4c61f1", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=066ec0a4a0c12148352889d7d26a2975960d5571", "patch": "@@ -3570,7 +3570,7 @@ cxx_omp_create_clause_info (tree c, tree type, bool need_default_ctor,\n   CP_OMP_CLAUSE_INFO (c) = info;\n \n   if (need_default_ctor\n-      || (need_copy_ctor && !TYPE_HAS_TRIVIAL_INIT_REF (type)))\n+      || (need_copy_ctor && !TYPE_HAS_TRIVIAL_COPY_CTOR (type)))\n     {\n       VEC(tree,gc) *vec;\n \n@@ -3624,7 +3624,7 @@ cxx_omp_create_clause_info (tree c, tree type, bool need_default_ctor,\n       TREE_VEC_ELT (info, 1) = omp_clause_info_fndecl (t, type);\n     }\n \n-  if (need_copy_assignment && !TYPE_HAS_TRIVIAL_ASSIGN_REF (type))\n+  if (need_copy_assignment && !TYPE_HAS_TRIVIAL_COPY_ASSIGN (type))\n     {\n       VEC(tree,gc) *vec;\n \n@@ -5011,7 +5011,7 @@ classtype_has_nothrow_assign_or_copy_p (tree type, bool assign_p)\n \treturn false;\n       fns = VEC_index (tree, CLASSTYPE_METHOD_VEC (type), ix);\n     } \n-  else if (TYPE_HAS_INIT_REF (type))\n+  else if (TYPE_HAS_COPY_CTOR (type))\n     {\n       /* If construction of the copy constructor was postponed, create\n \t it now.  */\n@@ -5070,7 +5070,7 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n       return (!CP_TYPE_CONST_P (type1) && type_code1 != REFERENCE_TYPE\n \t      && (trivial_type_p (type1)\n \t\t    || (CLASS_TYPE_P (type1)\n-\t\t\t&& TYPE_HAS_TRIVIAL_ASSIGN_REF (type1))));\n+\t\t\t&& TYPE_HAS_TRIVIAL_COPY_ASSIGN (type1))));\n \n     case CPTK_HAS_NOTHROW_CONSTRUCTOR:\n       type1 = strip_array_types (type1);\n@@ -5095,7 +5095,7 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n \t type\" wording for this trait.  */\n       type1 = strip_array_types (type1);\n       return (trivial_type_p (type1) || type_code1 == REFERENCE_TYPE\n-\t      || (CLASS_TYPE_P (type1) && TYPE_HAS_TRIVIAL_INIT_REF (type1)));\n+\t      || (CLASS_TYPE_P (type1) && TYPE_HAS_TRIVIAL_COPY_CTOR (type1)));\n \n     case CPTK_HAS_TRIVIAL_DESTRUCTOR:\n       type1 = strip_array_types (type1);"}, {"sha": "f7ce655eb192c9e22efeb99a3881fd296c230d94", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=066ec0a4a0c12148352889d7d26a2975960d5571", "patch": "@@ -479,7 +479,7 @@ build_target_expr_with_type (tree init, tree type)\n \n   if (TREE_CODE (init) == TARGET_EXPR)\n     return init;\n-  else if (CLASS_TYPE_P (type) && !TYPE_HAS_TRIVIAL_INIT_REF (type)\n+  else if (CLASS_TYPE_P (type) && !TYPE_HAS_TRIVIAL_COPY_CTOR (type)\n \t   && !VOID_TYPE_P (TREE_TYPE (init))\n \t   && TREE_CODE (init) != COND_EXPR\n \t   && TREE_CODE (init) != CONSTRUCTOR\n@@ -2376,7 +2376,7 @@ type_has_nontrivial_copy_init (const_tree t)\n   t = strip_array_types (CONST_CAST_TREE (t));\n \n   if (CLASS_TYPE_P (t))\n-    return TYPE_HAS_COMPLEX_INIT_REF (t);\n+    return TYPE_HAS_COMPLEX_COPY_CTOR (t);\n   else\n     return 0;\n }\n@@ -2390,8 +2390,8 @@ trivial_type_p (const_tree t)\n \n   if (CLASS_TYPE_P (t))\n     return (TYPE_HAS_TRIVIAL_DFLT (t)\n-\t    && TYPE_HAS_TRIVIAL_INIT_REF (t)\n-\t    && TYPE_HAS_TRIVIAL_ASSIGN_REF (t)\n+\t    && TYPE_HAS_TRIVIAL_COPY_CTOR (t)\n+\t    && TYPE_HAS_TRIVIAL_COPY_ASSIGN (t)\n \t    && TYPE_HAS_TRIVIAL_DESTRUCTOR (t));\n   else\n     return scalarish_type_p (t);\n@@ -2832,7 +2832,7 @@ special_function_p (const_tree decl)\n   if (DECL_CONSTRUCTOR_P (decl))\n     return sfk_constructor;\n   if (DECL_OVERLOADED_OPERATOR_P (decl) == NOP_EXPR)\n-    return sfk_assignment_operator;\n+    return sfk_copy_assignment;\n   if (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (decl))\n     return sfk_destructor;\n   if (DECL_COMPLETE_DESTRUCTOR_P (decl))"}, {"sha": "c8dae545c9e60965091bb434a21721f7d8cd9f84", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/066ec0a4a0c12148352889d7d26a2975960d5571/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=066ec0a4a0c12148352889d7d26a2975960d5571", "patch": "@@ -714,7 +714,7 @@ store_init_value (tree decl, tree init, int flags)\n \n   if (MAYBE_CLASS_TYPE_P (type))\n     {\n-      gcc_assert (TYPE_HAS_TRIVIAL_INIT_REF (type)\n+      gcc_assert (TYPE_HAS_TRIVIAL_COPY_CTOR (type)\n \t\t  || TREE_CODE (init) == CONSTRUCTOR);\n \n       if (TREE_CODE (init) == TREE_LIST)"}]}