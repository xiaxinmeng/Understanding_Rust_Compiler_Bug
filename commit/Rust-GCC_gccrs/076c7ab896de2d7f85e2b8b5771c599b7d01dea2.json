{"sha": "076c7ab896de2d7f85e2b8b5771c599b7d01dea2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc2YzdhYjg5NmRlMmQ3Zjg1ZTJiOGI1NzcxYzU5OWI3ZDAxZGVhMg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-08-24T16:46:32Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-08-24T16:46:32Z"}, "message": "basic-block.h (struct basic_block_def): Reorder fields to eliminate interior padding.\n\n\t* basic-block.h (struct basic_block_def): Reorder fields to\n\teliminate interior padding.  Remove 'partition' field.\n\t(BB_DISABLE_SCHEDULE, BB_HOT_PARTITION, BB_COLD_PARTITION)\n\t(BB_UNPARTITIONED, BB_PARTITION, BB_SET_PARTITION)\n\t(BB_COPY_PARTITION): New macros.\n\t* bb-reorder.c, cfgcleanup.c, cfglayout.c, cfgrtl.c, ifcvt.c\n\tReplace all references to the 'partition' field of a basic\n\tblock with new macros.\n\n\t* insn-notes.def: Delete NOTE_INSN_DISABLE_SCHED_OF_BLOCK.\n\t* final.c (final_scan_insn): Don't handle it.\n\t* modulo-sched.c: Set BB_DISABLE_SCHEDULE flag on g->bb\n\tinstead of emitting a NOTE_INSN_DISABLE_SCHED_OF_BLOCK note.\n\t* sched-rgn.c (sched_is_disabled_for_current_region_p):\n\tLook for a BB_DISABLE_SCHEDULE flag on the block instead of a note.\n\nFrom-SVN: r86495", "tree": {"sha": "a8c706cf283c42d5d4e89608fbc473e943519e99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8c706cf283c42d5d4e89608fbc473e943519e99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/076c7ab896de2d7f85e2b8b5771c599b7d01dea2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/076c7ab896de2d7f85e2b8b5771c599b7d01dea2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/076c7ab896de2d7f85e2b8b5771c599b7d01dea2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/comments", "author": null, "committer": null, "parents": [{"sha": "ae51017be07799ddc5570cb7b8697539743b6763", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae51017be07799ddc5570cb7b8697539743b6763", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae51017be07799ddc5570cb7b8697539743b6763"}], "stats": {"total": 196, "additions": 98, "deletions": 98}, "files": [{"sha": "a292bf7251df4c7071d327faab29b9f6d0995dae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=076c7ab896de2d7f85e2b8b5771c599b7d01dea2", "patch": "@@ -1,3 +1,21 @@\n+2004-08-24  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* basic-block.h (struct basic_block_def): Reorder fields to\n+\teliminate interior padding.  Remove 'partition' field.\n+\t(BB_DISABLE_SCHEDULE, BB_HOT_PARTITION, BB_COLD_PARTITION)\n+\t(BB_UNPARTITIONED, BB_PARTITION, BB_SET_PARTITION)\n+\t(BB_COPY_PARTITION): New macros.\n+\t* bb-reorder.c, cfgcleanup.c, cfglayout.c, cfgrtl.c, ifcvt.c\n+\tReplace all references to the 'partition' field of a basic\n+\tblock with new macros.\n+\n+\t* insn-notes.def: Delete NOTE_INSN_DISABLE_SCHED_OF_BLOCK.\n+\t* final.c (final_scan_insn): Don't handle it.\n+\t* modulo-sched.c: Set BB_DISABLE_SCHEDULE flag on g->bb\n+\tinstead of emitting a NOTE_INSN_DISABLE_SCHED_OF_BLOCK note.\n+\t* sched-rgn.c (sched_is_disabled_for_current_region_p):\n+\tLook for a BB_DISABLE_SCHEDULE flag on the block instead of a note.\n+\n 2004-08-24  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* c-decl.c (c_init_decl_processing): Adjust\n@@ -20,7 +38,7 @@\n \t* objc/objc-act.h (TREE_STATIC_TEMPLATE): Use TREE_PRIVATE.\n \n 2004-08-24  Richard Henderson  <rth@redhat.com>\n-            Andrew Pinski  <apinski@apple.com>\n+\t    Andrew Pinski  <apinski@apple.com>\n \n \t* gimplify.c (gimplify_array_ref_to_plus): Delete.\n \t(gimplify_addr_expr): Do not call gimplify_array_ref_to_plus"}, {"sha": "64dda0404434dce26957217c59792ec0900ca224", "filename": "gcc/basic-block.h", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=076c7ab896de2d7f85e2b8b5771c599b7d01dea2", "patch": "@@ -249,39 +249,36 @@ struct basic_block_def GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\")\n   /* Auxiliary info specific to a pass.  */\n   PTR GTY ((skip (\"\"))) aux;\n \n-  /* The index of this block.  */\n-  int index;\n+  /* Innermost loop containing the block.  */\n+  struct loop * GTY ((skip (\"\"))) loop_father;\n+\n+  /* The dominance and postdominance information node.  */\n+  struct et_node * GTY ((skip (\"\"))) dom[2];\n \n   /* Previous and next blocks in the chain.  */\n   struct basic_block_def *prev_bb;\n   struct basic_block_def *next_bb;\n \n-  /* The loop depth of this block.  */\n-  int loop_depth;\n-\n-  /* Innermost loop containing the block.  */\n-  struct loop * GTY ((skip (\"\"))) loop_father;\n+  /* The data used by basic block copying and reordering functions.  */\n+  struct reorder_block_def * GTY ((skip (\"\"))) rbi;\n \n-  /* The dominance and postdominance information node.  */\n-  struct et_node * GTY ((skip (\"\"))) dom[2];\n+  /* Annotations used at the tree level.  */\n+  struct bb_ann_d *tree_annotations;\n \n   /* Expected number of executions: calculated in profile.c.  */\n   gcov_type count;\n \n+  /* The index of this block.  */\n+  int index;\n+\n+  /* The loop depth of this block.  */\n+  int loop_depth;\n+\n   /* Expected frequency.  Normalized to be in range 0 to BB_FREQ_MAX.  */\n   int frequency;\n \n   /* Various flags.  See BB_* below.  */\n   int flags;\n-\n-  /* Which section block belongs in, when partitioning basic blocks.  */\n-  int partition;\n-\n-  /* The data used by basic block copying and reordering functions.  */\n-  struct reorder_block_def * GTY ((skip (\"\"))) rbi;\n-\n-  /* Annotations used at the tree level.  */\n-  struct bb_ann_d *tree_annotations;\n };\n \n typedef struct basic_block_def *basic_block;\n@@ -312,12 +309,18 @@ typedef struct reorder_block_def\n #define BB_VISITED\t\t8\n #define BB_IRREDUCIBLE_LOOP\t16\n #define BB_SUPERBLOCK\t\t32\n+#define BB_DISABLE_SCHEDULE     64\n+\n+#define BB_HOT_PARTITION\t128\n+#define BB_COLD_PARTITION\t256\n+#define BB_UNPARTITIONED\t0\n \n /* Partitions, to be used when partitioning hot and cold basic blocks into\n    separate sections.  */\n-#define UNPARTITIONED   0\n-#define HOT_PARTITION   1\n-#define COLD_PARTITION  2\n+#define BB_PARTITION(bb) ((bb)->flags & (BB_HOT_PARTITION|BB_COLD_PARTITION))\n+#define BB_SET_PARTITION(bb, part) ((bb)->flags |= (part))\n+#define BB_COPY_PARTITION(dstbb, srcbb) \\\n+  BB_SET_PARTITION (dstbb, BB_PARTITION (srcbb))\n \n /* Number of basic blocks in the current function.  */\n "}, {"sha": "ddf586c15d9be02edc796c26cea69cef7c86fb3e", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=076c7ab896de2d7f85e2b8b5771c599b7d01dea2", "patch": "@@ -203,15 +203,15 @@ push_to_next_round_p (basic_block bb, int round, int number_of_rounds,\n   next_round_is_last = round + 1 == number_of_rounds - 1;\n \n   cold_block = (flag_reorder_blocks_and_partition \n-\t\t&& bb->partition == COLD_PARTITION);\n+\t\t&& BB_PARTITION (bb) == BB_COLD_PARTITION);\n \n   block_not_hot_enough = (bb->frequency < exec_th \n \t\t\t  || bb->count < count_th\n \t\t\t  || probably_never_executed_bb_p (bb));\n \n   if (flag_reorder_blocks_and_partition\n       && next_round_is_last\n-      && bb->partition != COLD_PARTITION)\n+      && BB_PARTITION (bb) != BB_COLD_PARTITION)\n     return false;\n   else if (there_exists_another_round\n       && (cold_block || block_not_hot_enough))\n@@ -513,7 +513,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t  && e->dest->rbi->visited != *n_traces)\n \t\tcontinue;\n \n-\t      if (e->dest->partition == COLD_PARTITION\n+\t      if (BB_PARTITION (e->dest) == BB_COLD_PARTITION\n \t\t  && round < last_round)\n \t\tcontinue;\n \n@@ -758,7 +758,7 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n   basic_block new_bb;\n \n   new_bb = duplicate_block (old_bb, e);\n-  new_bb->partition = old_bb->partition;\n+  BB_COPY_PARTITION (new_bb, old_bb);\n \n   if (e->dest != new_bb)\n     abort ();\n@@ -811,7 +811,8 @@ bb_to_key (basic_block bb)\n \n   /* Do not start in probably never executed blocks.  */\n \n-  if (bb->partition == COLD_PARTITION || probably_never_executed_bb_p (bb))\n+  if (BB_PARTITION (bb) == BB_COLD_PARTITION\n+      || probably_never_executed_bb_p (bb))\n     return BB_FREQ_MAX;\n \n   /* Prefer blocks whose predecessor is an end of some trace\n@@ -921,7 +922,7 @@ connect_traces (int n_traces, struct trace *traces)\n   if (flag_reorder_blocks_and_partition)\n     for (i = 0; i < n_traces; i++)\n       {\n-\tif (traces[i].first->partition == COLD_PARTITION)\n+\tif (BB_PARTITION (traces[i].first) == BB_COLD_PARTITION)\n \t  {\n \t    connected[i] = true;\n \t    cold_traces[i] = true;\n@@ -1249,7 +1250,7 @@ add_unlikely_executed_notes (void)\n   /* Add the UNLIKELY_EXECUTED_NOTES to each cold basic block.  */\n \n   FOR_EACH_BB (bb)\n-    if (bb->partition == COLD_PARTITION)\n+    if (BB_PARTITION (bb) == BB_COLD_PARTITION)\n       mark_bb_for_unlikely_executed_section (bb);\n }\n \n@@ -1272,10 +1273,10 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges,\n   FOR_EACH_BB (bb)\n     {\n       if (probably_never_executed_bb_p (bb))\n-\tbb->partition = COLD_PARTITION;\n+\tBB_SET_PARTITION (bb, BB_COLD_PARTITION);\n       else\n \t{\n-\t  bb->partition = HOT_PARTITION;\n+\t  BB_SET_PARTITION (bb, BB_HOT_PARTITION);\n \t  has_hot_blocks = true;\n \t}\n     }\n@@ -1288,7 +1289,7 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges,\n     for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n       if (e->dest->index >= 0)\n \t{\n-\t  e->dest->partition = HOT_PARTITION;\n+\t  BB_SET_PARTITION (e->dest, BB_HOT_PARTITION);\n \t  break;\n \t}\n \n@@ -1302,7 +1303,7 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges,\n \t  {\n \t    if (e->src != ENTRY_BLOCK_PTR\n \t\t&& e->dest != EXIT_BLOCK_PTR\n-\t\t&& e->src->partition != e->dest->partition)\n+\t\t&& BB_PARTITION (e->src) != BB_PARTITION (e->dest))\n \t      {\n \t\te->flags |= EDGE_CROSSING;\n \t\tif (i == *max_idx)\n@@ -1535,8 +1536,8 @@ fix_up_fall_thru_edges (void)\n \t\t      \n  \t\t      /* Make sure new fall-through bb is in same \n \t\t\t partition as bb it's falling through from.  */\n- \t\t      \n-\t\t      new_bb->partition = cur_bb->partition;\n+\n+\t\t      BB_COPY_PARTITION (new_bb, cur_bb);\n \t\t      new_bb->succ->flags |= EDGE_CROSSING;\n  \t\t    }\n \t\t  \n@@ -1735,8 +1736,7 @@ fix_crossing_conditional_branches (void)\n \t\t  \n \t\t  /* Make sure new bb is in same partition as source\n \t\t     of conditional branch.  */\n-\t\t  \n-\t\t  new_bb->partition = cur_bb->partition;\n+\t\t  BB_COPY_PARTITION (new_bb, cur_bb);\n \t\t}\n \t      \n \t      /* Make old jump branch to new bb.  */"}, {"sha": "22821f3a4e60a36acac1d4d986f62f2c6419aecb", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=076c7ab896de2d7f85e2b8b5771c599b7d01dea2", "patch": "@@ -153,7 +153,7 @@ try_simplify_condjump (basic_block cbranch_block)\n      and cold sections.  */\n \n   if (flag_reorder_blocks_and_partition\n-      && (jump_block->partition != jump_dest_block->partition\n+      && (BB_PARTITION (jump_block) != BB_PARTITION (jump_dest_block)\n \t  || (cbranch_jump_edge->flags & EDGE_CROSSING)))\n     return false;\n \n@@ -673,7 +673,7 @@ merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n      and cold sections.  */\n   \n   if (flag_reorder_blocks_and_partition\n-      && (a->partition != b->partition\n+      && (BB_PARTITION (a) != BB_PARTITION (b)\n \t  || find_reg_note (BB_END (a), REG_CROSSING_JUMP, NULL_RTX)))\n     return;\n \n@@ -726,7 +726,7 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n   \n   if (flag_reorder_blocks_and_partition\n       && (find_reg_note (BB_END (a), REG_CROSSING_JUMP, NULL_RTX)\n-\t  || a->partition != b->partition))\n+\t  || BB_PARTITION (a) != BB_PARTITION (b)))\n     return;\n \n   real_b_end = BB_END (b);\n@@ -792,7 +792,7 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n   if (flag_reorder_blocks_and_partition\n       && (find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX)\n \t  || find_reg_note (BB_END (c), REG_CROSSING_JUMP, NULL_RTX)\n-\t  || b->partition != c->partition))\n+\t  || BB_PARTITION (b) != BB_PARTITION (c)))\n     return NULL;\n       \n     \n@@ -1673,7 +1673,7 @@ try_crossjump_bb (int mode, basic_block bb)\n      and cold sections.  */\n   \n   if (flag_reorder_blocks_and_partition\n-      && (bb->pred->src->partition != bb->pred->pred_next->src->partition\n+      && (BB_PARTITION (bb->pred->src) != BB_PARTITION (bb->pred->pred_next->src)\n \t  || (bb->pred->flags & EDGE_CROSSING)))\n     return false;\n "}, {"sha": "42acec35870571563dfbdeb354156e4aa5a30f6e", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=076c7ab896de2d7f85e2b8b5771c599b7d01dea2", "patch": "@@ -795,11 +795,11 @@ fixup_reorder_chain (void)\n \t  \n \t  /* Make sure new bb is tagged for correct section (same as\n \t     fall-thru source).  */\n-\t  e_fall->src->partition = bb->pred->src->partition;\n+\t  BB_COPY_PARTITION (e_fall->src, bb->pred->src);\n \t  if (flag_reorder_blocks_and_partition\n \t      && targetm.have_named_sections)\n \t    {\n-\t      if (bb->pred->src->partition == COLD_PARTITION)\n+\t      if (BB_PARTITION (bb->pred->src) == BB_COLD_PARTITION)\n \t\t{\n \t\t  rtx new_note;\n \t\t  rtx note = BB_HEAD (e_fall->src);\n@@ -1109,7 +1109,7 @@ cfg_layout_duplicate_bb (basic_block bb)\n \t\t\t       insn ? get_last_insn () : NULL,\n \t\t\t       EXIT_BLOCK_PTR->prev_bb);\n \n-  new_bb->partition = bb->partition;\n+  BB_COPY_PARTITION (new_bb, bb);\n   if (bb->rbi->header)\n     {\n       insn = bb->rbi->header;"}, {"sha": "d4136d246b0ec17da9a11c82b8df5d6a00741109", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=076c7ab896de2d7f85e2b8b5771c599b7d01dea2", "patch": "@@ -313,7 +313,7 @@ create_basic_block_structure (rtx head, rtx end, rtx bb_note, basic_block after)\n   link_block (bb, after);\n   BASIC_BLOCK (bb->index) = bb;\n   update_bb_for_insn (bb);\n-  bb->partition = UNPARTITIONED;\n+  BB_SET_PARTITION (bb, BB_UNPARTITIONED);\n \n   /* Tag the block so that we know it has been used when considering\n      other basic block notes.  */\n@@ -489,7 +489,7 @@ rtl_split_block (basic_block bb, void *insnp)\n \n   /* Create the new basic block.  */\n   new_bb = create_basic_block (NEXT_INSN (insn), BB_END (bb), bb);\n-  new_bb->partition = bb->partition;\n+  BB_COPY_PARTITION (new_bb, bb);\n   BB_END (bb) = insn;\n \n   /* Redirect the outgoing edges.  */\n@@ -619,24 +619,26 @@ rtl_merge_blocks (basic_block a, basic_block b)\n static bool\n rtl_can_merge_blocks (basic_block a,basic_block b)\n {\n-  bool partitions_ok = true;\n-\n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n-     and cold sections.  */\n-  \n+     and cold sections.\n+\n+     ??? If two basic blocks could otherwise be merged (which implies\n+     that the jump between the two is unconditional), and one is in a\n+     hot section and the other is in a cold section, surely that means\n+     that one of the section choices is wrong.  */\n+\n   if (flag_reorder_blocks_and_partition\n       && (find_reg_note (BB_END (a), REG_CROSSING_JUMP, NULL_RTX)\n \t  || find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX)\n-\t  || a->partition != b->partition))\n-    partitions_ok = false;\n+\t  || BB_PARTITION (a) != BB_PARTITION (b)))\n+    return false;\n \n   /* There must be exactly one edge in between the blocks.  */\n   return (a->succ && !a->succ->succ_next && a->succ->dest == b\n \t  && !b->pred->pred_next && a != b\n \t  /* Must be simple edge.  */\n \t  && !(a->succ->flags & EDGE_COMPLEX)\n-\t  && partitions_ok\n \t  && a->next_bb == b\n \t  && a != ENTRY_BLOCK_PTR && b != EXIT_BLOCK_PTR\n \t  /* If the jump insn has side effects,\n@@ -684,7 +686,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n   \n   if (flag_reorder_blocks_and_partition\n       && (find_reg_note (insn, REG_CROSSING_JUMP, NULL_RTX)\n-\t  || (src->partition != target->partition)))\n+\t  || BB_PARTITION (src) != BB_PARTITION (target)))\n     return NULL;\n \n   /* Verify that all targets will be TARGET.  */\n@@ -1094,11 +1096,11 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n \n       /* Make sure new block ends up in correct hot/cold section.  */\n \n-      jump_block->partition = e->src->partition;\n+      BB_COPY_PARTITION (jump_block, e->src);\n       if (flag_reorder_blocks_and_partition\n \t  && targetm.have_named_sections)\n \t{\n-\t  if (e->src->partition == COLD_PARTITION)\n+\t  if (BB_PARTITION (jump_block) == BB_COLD_PARTITION)\n \t    {\n \t      rtx bb_note, new_note;\n \t      for (bb_note = BB_HEAD (jump_block); \n@@ -1110,7 +1112,6 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n \t      new_note = emit_note_after (NOTE_INSN_UNLIKELY_EXECUTED_CODE,\n \t\t\t\t\t  bb_note);\n \t      NOTE_BASIC_BLOCK (new_note) = jump_block; \n-\t      jump_block->partition = COLD_PARTITION;\n \t    }\n \t  if (JUMP_P (BB_END (jump_block))\n \t      && !any_condjump_p (BB_END (jump_block))\n@@ -1354,12 +1355,13 @@ rtl_split_edge (edge edge_in)\n \t  && NOTE_LINE_NUMBER (before) == NOTE_INSN_LOOP_END)\n \tbefore = NEXT_INSN (before);\n       bb = create_basic_block (before, NULL, edge_in->src);\n-      bb->partition = edge_in->src->partition;\n+      BB_COPY_PARTITION (bb, edge_in->src);\n     }\n   else\n     {\n       bb = create_basic_block (before, NULL, edge_in->dest->prev_bb);\n-      bb->partition = edge_in->dest->partition;\n+      /* ??? Why not edge_in->dest->prev_bb here?  */\n+      BB_COPY_PARTITION (bb, edge_in->dest);\n     }\n \n   /* ??? This info is likely going to be out of date very soon.  */\n@@ -1601,7 +1603,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t  if (flag_reorder_blocks_and_partition\n \t      && targetm.have_named_sections\n \t      && e->src != ENTRY_BLOCK_PTR\n-\t      && e->src->partition == COLD_PARTITION\n+\t      && BB_PARTITION (e->src) == BB_COLD_PARTITION\n \t      && !(e->flags & EDGE_CROSSING))\n \t    {\n \t      rtx bb_note, new_note, cur_insn;\n@@ -1987,7 +1989,7 @@ rtl_verify_flow_info_1 (void)\n \t    {\n \t      n_fallthru++, fallthru = e;\n \t      if ((e->flags & EDGE_CROSSING)\n-\t\t  || (e->src->partition != e->dest->partition\n+\t\t  || (BB_PARTITION (e->src) != BB_PARTITION (e->dest)\n \t\t      && e->src != ENTRY_BLOCK_PTR\n \t\t      && e->dest != EXIT_BLOCK_PTR))\n \t    { \n@@ -2667,24 +2669,26 @@ cfg_layout_delete_block (basic_block bb)\n static bool\n cfg_layout_can_merge_blocks_p (basic_block a, basic_block b)\n {\n-  bool partitions_ok = true;\n-\n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n-     and cold sections.  */\n+     and cold sections.\n+\n+     ??? If two basic blocks could otherwise be merged (which implies\n+     that the jump between the two is unconditional), and one is in a\n+     hot section and the other is in a cold section, surely that means\n+     that one of the section choices is wrong.  */\n   \n   if (flag_reorder_blocks_and_partition\n       && (find_reg_note (BB_END (a), REG_CROSSING_JUMP, NULL_RTX)\n \t  || find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX)\n-\t  || a->partition != b->partition))\n-    partitions_ok = false;\n+\t  || BB_PARTITION (a) != BB_PARTITION (b)))\n+    return false;\n \n   /* There must be exactly one edge in between the blocks.  */\n   return (a->succ && !a->succ->succ_next && a->succ->dest == b\n \t  && !b->pred->pred_next && a != b\n \t  /* Must be simple edge.  */\n \t  && !(a->succ->flags & EDGE_COMPLEX)\n-\t  && partitions_ok\n \t  && a != ENTRY_BLOCK_PTR && b != EXIT_BLOCK_PTR\n \t  /* If the jump insn has side effects,\n \t     we can't kill the edge.  */"}, {"sha": "a59f3a2074c8b26446163eaeb4cf31fb81ff1222", "filename": "gcc/final.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=076c7ab896de2d7f85e2b8b5771c599b7d01dea2", "patch": "@@ -1704,7 +1704,6 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \tcase NOTE_INSN_FUNCTION_END:\n \tcase NOTE_INSN_REPEATED_LINE_NUMBER:\n \tcase NOTE_INSN_EXPECTED_VALUE:\n-\tcase NOTE_INSN_DISABLE_SCHED_OF_BLOCK:\n \t  break;\n \n \tcase NOTE_INSN_UNLIKELY_EXECUTED_CODE:"}, {"sha": "1af042708e2531a75d570868b2d19c3a106a09ba", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=076c7ab896de2d7f85e2b8b5771c599b7d01dea2", "patch": "@@ -2909,7 +2909,8 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n     {\n       new_bb->index = then_bb_index;\n       BASIC_BLOCK (then_bb_index) = new_bb;\n-      new_bb->partition = test_bb->partition;\n+      /* ??? Should be then_bb? */\n+      BB_COPY_PARTITION (new_bb, test_bb);\n     }\n   /* We've possibly created jump to next insn, cleanup_cfg will solve that\n      later.  */"}, {"sha": "44dbb20d525c29efce397bfbce7f9673b20ee30f", "filename": "gcc/insn-notes.def", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Finsn-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Finsn-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finsn-notes.def?ref=076c7ab896de2d7f85e2b8b5771c599b7d01dea2", "patch": "@@ -98,11 +98,4 @@ INSN_NOTE (BASIC_BLOCK)\n    this a bit on the basic block structure. */\n INSN_NOTE (UNLIKELY_EXECUTED_CODE)\n \n-/* Mark that a block shouldn't be scheduled.  This is currently used\n-   in modulo scheduling. Modulo scheduling adds this note to the\n-   blocks of the modulo-scheduled loops to disable scheduling them in\n-   the later traditional scheduling passes.  FIXME: Make this a bit on\n-   the basic block structure.  */\n-INSN_NOTE (DISABLE_SCHED_OF_BLOCK)\n-\n #undef INSN_NOTE"}, {"sha": "c7606d84a571782f3b81940a3c259b23432cab9b", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=076c7ab896de2d7f85e2b8b5771c599b7d01dea2", "patch": "@@ -1112,8 +1112,7 @@ sms_schedule (FILE *dump_file)\n           /* Mark this loop as software pipelined so the later\n \t     scheduling passes doesn't touch it.  */\n \t  if (! flag_resched_modulo_sched)\n-\t    emit_note_before (NOTE_INSN_DISABLE_SCHED_OF_BLOCK,\n-\t     \t\t      g->closing_branch->insn);\n+\t    g->bb->flags |= BB_DISABLE_SCHEDULE;\n \n \t  generate_reg_moves (ps);\n \t  if (dump_file)"}, {"sha": "f2e5773e797ba61ee461d7708cc3e44c5b32e592", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076c7ab896de2d7f85e2b8b5771c599b7d01dea2/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=076c7ab896de2d7f85e2b8b5771c599b7d01dea2", "patch": "@@ -2338,28 +2338,11 @@ debug_dependencies (void)\n static bool\n sched_is_disabled_for_current_region_p (void)\n {\n-  rtx first_bb_insn, last_bb_insn, insn;\n   int bb;\n \n   for (bb = 0; bb < current_nr_blocks; bb++)\n-    {\n-      bool disable_sched = false;\n-      /* Searching for NOTE_DISABLE_SCHED_OF_BLOCK note between the\n-         start and end of the basic block. */\n-      get_block_head_tail (BB_TO_BLOCK (bb), &first_bb_insn,\n-\t\t\t   &last_bb_insn);\n-      for (insn = last_bb_insn; insn != NULL && insn != first_bb_insn;\n-           insn = PREV_INSN (insn))\n-      \tif (GET_CODE (insn) == NOTE\n-\t    && (NOTE_LINE_NUMBER (insn)\n-\t        == NOTE_INSN_DISABLE_SCHED_OF_BLOCK))\n-          {\n-              disable_sched = true;\n-\t      break;\n-          }\n-      if (! disable_sched)\n-\treturn false;\n-    }\n+    if (!(BASIC_BLOCK (BB_TO_BLOCK (bb))->flags & BB_DISABLE_SCHEDULE))\n+      return false;\n \n   return true;\n }"}]}