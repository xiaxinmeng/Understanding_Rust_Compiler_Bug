{"sha": "7bf8ca763de168f22d2b65662a83e47b56d187e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JmOGNhNzYzZGUxNjhmMjJkMmI2NTY2MmE4M2U0N2I1NmQxODdlOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-11-02T01:20:42Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-11-02T01:20:42Z"}, "message": "fold-const.c (fold_indirect_ref_1): Handle folding POINTER_PLUS_EXPR to ARRAY_REF.\n\n\t* fold-const.c (fold_indirect_ref_1): Handle folding\n\tPOINTER_PLUS_EXPR to ARRAY_REF.\n\nFrom-SVN: r166163", "tree": {"sha": "56a4b5dc694a3d3f2da85636c53092dae364d937", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56a4b5dc694a3d3f2da85636c53092dae364d937"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bf8ca763de168f22d2b65662a83e47b56d187e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bf8ca763de168f22d2b65662a83e47b56d187e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bf8ca763de168f22d2b65662a83e47b56d187e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bf8ca763de168f22d2b65662a83e47b56d187e8/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "878415841a34cf750c5ca0573161cc528e4a51a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/878415841a34cf750c5ca0573161cc528e4a51a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/878415841a34cf750c5ca0573161cc528e4a51a9"}], "stats": {"total": 83, "additions": 47, "deletions": 36}, "files": [{"sha": "eedc19b38314c19514c98c39928f6a8a113c4496", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf8ca763de168f22d2b65662a83e47b56d187e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf8ca763de168f22d2b65662a83e47b56d187e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7bf8ca763de168f22d2b65662a83e47b56d187e8", "patch": "@@ -1,3 +1,8 @@\n+2010-11-01  Jason Merrill  <jason@redhat.com>\n+\n+\t* fold-const.c (fold_indirect_ref_1): Handle folding\n+\tPOINTER_PLUS_EXPR to ARRAY_REF.\n+\n 2010-11-01  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.c (TARGET_DELEGITIMIZE_ADDRESS): Redefine."}, {"sha": "67268ade5ccca5f04e28ac23cc41706477d12c54", "filename": "gcc/fold-const.c", "status": "modified", "additions": 42, "deletions": 36, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf8ca763de168f22d2b65662a83e47b56d187e8/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf8ca763de168f22d2b65662a83e47b56d187e8/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=7bf8ca763de168f22d2b65662a83e47b56d187e8", "patch": "@@ -15643,53 +15643,59 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)\n \t}\n     }\n \n-  /* ((foo*)&vectorfoo)[1] => BIT_FIELD_REF<vectorfoo,...> */\n   if (TREE_CODE (sub) == POINTER_PLUS_EXPR\n       && TREE_CODE (TREE_OPERAND (sub, 1)) == INTEGER_CST)\n     {\n       tree op00 = TREE_OPERAND (sub, 0);\n       tree op01 = TREE_OPERAND (sub, 1);\n-      tree op00type;\n \n       STRIP_NOPS (op00);\n-      op00type = TREE_TYPE (op00);\n-      if (TREE_CODE (op00) == ADDR_EXPR\n-          && TREE_CODE (TREE_TYPE (op00type)) == VECTOR_TYPE\n-          && type == TREE_TYPE (TREE_TYPE (op00type)))\n+      if (TREE_CODE (op00) == ADDR_EXPR)\n \t{\n-\t  HOST_WIDE_INT offset = tree_low_cst (op01, 0);\n-\t  tree part_width = TYPE_SIZE (type);\n-\t  unsigned HOST_WIDE_INT part_widthi = tree_low_cst (part_width, 0)/BITS_PER_UNIT;\n-\t  unsigned HOST_WIDE_INT indexi = offset * BITS_PER_UNIT;\n-\t  tree index = bitsize_int (indexi);\n-\n-\t  if (offset/part_widthi <= TYPE_VECTOR_SUBPARTS (TREE_TYPE (op00type)))\n-\t    return fold_build3_loc (loc,\n-\t\t\t\tBIT_FIELD_REF, type, TREE_OPERAND (op00, 0),\n-\t\t\t\tpart_width, index);\n+\t  tree op00type;\n+\t  op00 = TREE_OPERAND (op00, 0);\n+\t  op00type = TREE_TYPE (op00);\n \n-\t}\n-    }\n+\t  /* ((foo*)&vectorfoo)[1] => BIT_FIELD_REF<vectorfoo,...> */\n+\t  if (TREE_CODE (op00type) == VECTOR_TYPE\n+\t      && type == TREE_TYPE (op00type))\n+\t    {\n+\t      HOST_WIDE_INT offset = tree_low_cst (op01, 0);\n+\t      tree part_width = TYPE_SIZE (type);\n+\t      unsigned HOST_WIDE_INT part_widthi = tree_low_cst (part_width, 0)/BITS_PER_UNIT;\n+\t      unsigned HOST_WIDE_INT indexi = offset * BITS_PER_UNIT;\n+\t      tree index = bitsize_int (indexi);\n \n+\t      if (offset/part_widthi <= TYPE_VECTOR_SUBPARTS (op00type))\n+\t\treturn fold_build3_loc (loc,\n+\t\t\t\t\tBIT_FIELD_REF, type, op00,\n+\t\t\t\t\tpart_width, index);\n \n-  /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */\n-  if (TREE_CODE (sub) == POINTER_PLUS_EXPR\n-      && TREE_CODE (TREE_OPERAND (sub, 1)) == INTEGER_CST)\n-    {\n-      tree op00 = TREE_OPERAND (sub, 0);\n-      tree op01 = TREE_OPERAND (sub, 1);\n-      tree op00type;\n-\n-      STRIP_NOPS (op00);\n-      op00type = TREE_TYPE (op00);\n-      if (TREE_CODE (op00) == ADDR_EXPR\n- \t  && TREE_CODE (TREE_TYPE (op00type)) == COMPLEX_TYPE\n-\t  && type == TREE_TYPE (TREE_TYPE (op00type)))\n-\t{\n-\t  tree size = TYPE_SIZE_UNIT (type);\n-\t  if (tree_int_cst_equal (size, op01))\n-\t    return fold_build1_loc (loc, IMAGPART_EXPR, type,\n-\t\t\t\tTREE_OPERAND (op00, 0));\n+\t    }\n+\t  /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */\n+\t  else if (TREE_CODE (op00type) == COMPLEX_TYPE\n+\t\t   && type == TREE_TYPE (op00type))\n+\t    {\n+\t      tree size = TYPE_SIZE_UNIT (type);\n+\t      if (tree_int_cst_equal (size, op01))\n+\t\treturn fold_build1_loc (loc, IMAGPART_EXPR, type, op00);\n+\t    }\n+\t  /* ((foo *)&fooarray)[1] => fooarray[1] */\n+\t  else if (TREE_CODE (op00type) == ARRAY_TYPE\n+\t\t   && type == TREE_TYPE (op00type))\n+\t    {\n+\t      tree type_domain = TYPE_DOMAIN (op00type);\n+\t      tree min_val = size_zero_node;\n+\t      if (type_domain && TYPE_MIN_VALUE (type_domain))\n+\t\tmin_val = TYPE_MIN_VALUE (type_domain);\n+\t      op01 = size_binop_loc (loc, EXACT_DIV_EXPR, op01,\n+\t\t\t\t     TYPE_SIZE_UNIT (type));\n+\t      op01 = size_binop_loc (loc, PLUS_EXPR, op01, min_val);\n+\t      op0 = build4 (ARRAY_REF, type, op00, op01,\n+\t\t\t    NULL_TREE, NULL_TREE);\n+\t      SET_EXPR_LOCATION (op0, loc);\n+\t      return op0;\n+\t    }\n \t}\n     }\n "}]}