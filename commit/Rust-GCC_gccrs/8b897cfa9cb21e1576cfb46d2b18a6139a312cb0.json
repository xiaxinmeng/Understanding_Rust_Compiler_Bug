{"sha": "8b897cfa9cb21e1576cfb46d2b18a6139a312cb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI4OTdjZmE5Y2IyMWUxNTc2Y2ZiNDZkMmIxOGE2MTM5YTMxMmNiMA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-07-02T18:00:46Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-07-02T18:00:46Z"}, "message": "rs6000.c (struct processor_costs): New structure used to hold instruction latencies/sizes for processor types.\n\n\n\t* config/rs6000/rs6000.c (struct processor_costs): New structure\n\tused to hold instruction latencies/sizes for processor types.\n\t(rs6000_cost): New global variable pointing to current CPU's costs.\n\t(rs6000_override_options): Initialize rs6000_cost to point to the\n\tappropriate cost table based upon rs6000_cpu and optimize_size.\n\t(rs6000_rtx_costs): Use rs6000_cost to avoid hardcoding processor\n\ttimings inline.\n\nFrom-SVN: r84024", "tree": {"sha": "99c34429892c8fa9d4c24bd74d246105980786a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99c34429892c8fa9d4c24bd74d246105980786a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b897cfa9cb21e1576cfb46d2b18a6139a312cb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b897cfa9cb21e1576cfb46d2b18a6139a312cb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b897cfa9cb21e1576cfb46d2b18a6139a312cb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b897cfa9cb21e1576cfb46d2b18a6139a312cb0/comments", "author": null, "committer": null, "parents": [{"sha": "8a0aa06e00c3f8ecbabf27a810951b9a07e2a495", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a0aa06e00c3f8ecbabf27a810951b9a07e2a495", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a0aa06e00c3f8ecbabf27a810951b9a07e2a495"}], "stats": {"total": 471, "additions": 317, "deletions": 154}, "files": [{"sha": "65fe7a313d474fbac3c3d3e8061e34e06ae63c93", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b897cfa9cb21e1576cfb46d2b18a6139a312cb0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b897cfa9cb21e1576cfb46d2b18a6139a312cb0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b897cfa9cb21e1576cfb46d2b18a6139a312cb0", "patch": "@@ -1,3 +1,13 @@\n+2004-07-02  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* config/rs6000/rs6000.c (struct processor_costs): New structure\n+\tused to hold instruction latencies/sizes for processor types.\n+\t(rs6000_cost): New global variable pointing to current CPU's costs.\n+\t(rs6000_override_options): Initialize rs6000_cost to point to the\n+\tappropriate cost table based upon rs6000_cpu and optimize_size.\n+\t(rs6000_rtx_costs): Use rs6000_cost to avoid hardcoding processor\n+\ttimings inline.\n+\n 2004-07-02  Richard Henderson  <rth@redhat.com>\n \n \t* expmed.c (make_tree): Don't use SET_DECL_RTL."}, {"sha": "ca765579d68808fa311d82c4858706ac70634b73", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 307, "deletions": 154, "changes": 461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b897cfa9cb21e1576cfb46d2b18a6139a312cb0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b897cfa9cb21e1576cfb46d2b18a6139a312cb0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8b897cfa9cb21e1576cfb46d2b18a6139a312cb0", "patch": "@@ -282,7 +282,221 @@ struct builtin_description\n   const char *const name;\n   const enum rs6000_builtins code;\n };\n+\f\n+/* Target cpu costs.  */\n+\n+struct processor_costs {\n+  const int mulsi;        /* cost of SImode multiplication.  */\n+  const int mulsi_const;  /* cost of SImode multiplication by constant.  */\n+  const int mulsi_const9; /* cost of SImode mult by short constant.  */\n+  const int muldi;        /* cost of DImode multiplication.  */\n+  const int divsi;        /* cost of SImode division.  */\n+  const int divdi;        /* cost of DImode division.  */\n+};\n+\n+const struct processor_costs *rs6000_cost;\n+\n+/* Processor costs (relative to an add) */\n+\n+/* Instruction size costs on 32bit processors.  */\n+static const\n+struct processor_costs size32_cost = {\n+  1,    /* mulsi */\n+  1,    /* mulsi_const */\n+  1,    /* mulsi_const9 */\n+  1,    /* muldi */\n+  1,    /* divsi */\n+  1,    /* divdi */\n+};\n+\n+/* Instruction size costs on 64bit processors.  */\n+static const\n+struct processor_costs size64_cost = {\n+  1,    /* mulsi */\n+  1,    /* mulsi_const */\n+  1,    /* mulsi_const9 */\n+  1,    /* muldi */\n+  1,    /* divsi */\n+  1,    /* divdi */\n+};\n+\n+/* Instruction costs on RIOS1 processors.  */\n+static const\n+struct processor_costs rios1_cost = {\n+  5,    /* mulsi */\n+  4,    /* mulsi_const */\n+  3,    /* mulsi_const9 */\n+  5,    /* muldi */\n+  19,   /* divsi */\n+  19,   /* divdi */\n+};\n+\n+/* Instruction costs on RIOS2 processors.  */\n+static const\n+struct processor_costs rios2_cost = {\n+  2,    /* mulsi */\n+  2,    /* mulsi_const */\n+  2,    /* mulsi_const9 */\n+  2,    /* muldi */\n+  13,   /* divsi */\n+  13,   /* divdi */\n+};\n+\n+/* Instruction costs on RS64A processors.  */\n+static const\n+struct processor_costs rs64a_cost = {\n+  20,   /* mulsi */\n+  12,   /* mulsi_const */\n+  8,    /* mulsi_const9 */\n+  34,   /* muldi */\n+  65,   /* divsi */\n+  67,   /* divdi */\n+};\n+\n+/* Instruction costs on MPCCORE processors.  */\n+static const\n+struct processor_costs mpccore_cost = {\n+  2,    /* mulsi */\n+  2,    /* mulsi_const */\n+  2,    /* mulsi_const9 */\n+  2,    /* muldi */\n+  6,    /* divsi */\n+  6,    /* divdi */\n+};\n+\n+/* Instruction costs on PPC403 processors.  */\n+static const\n+struct processor_costs ppc403_cost = {\n+  4,    /* mulsi */\n+  4,    /* mulsi_const */\n+  4,    /* mulsi_const9 */\n+  4,    /* muldi */\n+  33,   /* divsi */\n+  33,   /* divdi */\n+};\n+\n+/* Instruction costs on PPC405 processors.  */\n+static const\n+struct processor_costs ppc405_cost = {\n+  5,    /* mulsi */\n+  4,    /* mulsi_const */\n+  3,    /* mulsi_const9 */\n+  5,    /* muldi */\n+  35,   /* divsi */\n+  35,   /* divdi */\n+};\n+\n+/* Instruction costs on PPC440 processors.  */\n+static const\n+struct processor_costs ppc440_cost = {\n+  3,    /* mulsi */\n+  2,    /* mulsi_const */\n+  2,    /* mulsi_const9 */\n+  3,    /* muldi */\n+  34,   /* divsi */\n+  34,   /* divdi */\n+};\n+\n+/* Instruction costs on PPC601 processors.  */\n+static const\n+struct processor_costs ppc601_cost = {\n+  5,    /* mulsi */\n+  5,    /* mulsi_const */\n+  5,    /* mulsi_const9 */\n+  5,    /* muldi */\n+  36,   /* divsi */\n+  36,   /* divdi */\n+};\n+\n+/* Instruction costs on PPC603 processors.  */\n+static const\n+struct processor_costs ppc603_cost = {\n+  5,    /* mulsi */\n+  3,    /* mulsi_const */\n+  2,    /* mulsi_const9 */\n+  5,    /* muldi */\n+  37,   /* divsi */\n+  37,   /* divdi */\n+};\n+\n+/* Instruction costs on PPC604 processors.  */\n+static const\n+struct processor_costs ppc604_cost = {\n+  4,    /* mulsi */\n+  4,    /* mulsi_const */\n+  4,    /* mulsi_const9 */\n+  4,    /* muldi */\n+  20,   /* divsi */\n+  20,   /* divdi */\n+};\n+\n+/* Instruction costs on PPC604e processors.  */\n+static const\n+struct processor_costs ppc604e_cost = {\n+  2,    /* mulsi */\n+  2,    /* mulsi_const */\n+  2,    /* mulsi_const9 */\n+  2,    /* muldi */\n+  20,   /* divsi */\n+  20,   /* divdi */\n+};\n+\n+/* Instruction costs on PPC620 and PPC630 processors.  */\n+static const\n+struct processor_costs ppc620_cost = {\n+  5,    /* mulsi */\n+  4,    /* mulsi_const */\n+  3,    /* mulsi_const9 */\n+  7,    /* muldi */\n+  21,   /* divsi */\n+  37,   /* divdi */\n+};\n+\n+/* Instruction costs on PPC750 and PPC7400 processors.  */\n+static const\n+struct processor_costs ppc750_cost = {\n+  5,    /* mulsi */\n+  3,    /* mulsi_const */\n+  2,    /* mulsi_const9 */\n+  5,    /* muldi */\n+  17,   /* divsi */\n+  17,   /* divdi */\n+};\n+\n+/* Instruction costs on PPC7450 processors.  */\n+static const\n+struct processor_costs ppc7450_cost = {\n+  4,    /* mulsi */\n+  3,    /* mulsi_const */\n+  3,    /* mulsi_const9 */\n+  4,    /* muldi */\n+  23,   /* divsi */\n+  23,   /* divdi */\n+};\n \n+/* Instruction costs on PPC8540 processors.  */\n+static const\n+struct processor_costs ppc8540_cost = {\n+  4,    /* mulsi */\n+  4,    /* mulsi_const */\n+  4,    /* mulsi_const9 */\n+  4,    /* muldi */\n+  19,   /* divsi */\n+  19,   /* divdi */\n+};\n+\n+/* Instruction costs on POWER4 and POWER5 processors.  */\n+static const\n+struct processor_costs power4_cost = {\n+  3,    /* mulsi */\n+  2,    /* mulsi_const */\n+  2,    /* mulsi_const9 */\n+  4,    /* muldi */\n+  18,   /* divsi */\n+  34,   /* divdi */\n+};\n+\n+\f\n static bool rs6000_function_ok_for_sibcall (tree, tree);\n static int num_insns_constant_wide (HOST_WIDE_INT);\n static void validate_condition_mode (enum rtx_code, enum machine_mode);\n@@ -1104,6 +1318,83 @@ rs6000_override_options (const char *default_cpu)\n      Linux and Darwin ABIs at the moment.  For now, only AIX is fixed.  */\n   if (DEFAULT_ABI != ABI_AIX)\n     targetm.calls.split_complex_arg = NULL;\n+\n+  /* Initialize rs6000_cost with the appropriate target costs.  */\n+  if (optimize_size)\n+    rs6000_cost = TARGET_POWERPC64 ? &size64_cost : &size32_cost;\n+  else\n+    switch (rs6000_cpu)\n+      {\n+      case PROCESSOR_RIOS1:\n+\trs6000_cost = &rios1_cost;\n+\tbreak;\n+\n+      case PROCESSOR_RIOS2:\n+\trs6000_cost = &rios2_cost;\n+\tbreak;\n+\n+      case PROCESSOR_RS64A:\n+\trs6000_cost = &rs64a_cost;\n+\tbreak;\n+\n+      case PROCESSOR_MPCCORE:\n+\trs6000_cost = &mpccore_cost;\n+\tbreak;\n+\n+      case PROCESSOR_PPC403:\n+\trs6000_cost = &ppc403_cost;\n+\tbreak;\n+\n+      case PROCESSOR_PPC405:\n+\trs6000_cost = &ppc405_cost;\n+\tbreak;\n+\n+      case PROCESSOR_PPC440:\n+\trs6000_cost = &ppc440_cost;\n+\tbreak;\n+\n+      case PROCESSOR_PPC601:\n+\trs6000_cost = &ppc601_cost;\n+\tbreak;\n+\n+      case PROCESSOR_PPC603:\n+\trs6000_cost = &ppc603_cost;\n+\tbreak;\n+\n+      case PROCESSOR_PPC604:\n+\trs6000_cost = &ppc604_cost;\n+\tbreak;\n+\n+      case PROCESSOR_PPC604e:\n+\trs6000_cost = &ppc604e_cost;\n+\tbreak;\n+\n+      case PROCESSOR_PPC620:\n+      case PROCESSOR_PPC630:\n+\trs6000_cost = &ppc620_cost;\n+\tbreak;\n+\n+      case PROCESSOR_PPC750:\n+      case PROCESSOR_PPC7400:\n+\trs6000_cost = &ppc750_cost;\n+\tbreak;\n+\n+      case PROCESSOR_PPC7450:\n+\trs6000_cost = &ppc7450_cost;\n+\tbreak;\n+\n+      case PROCESSOR_PPC8540:\n+\trs6000_cost = &ppc8540_cost;\n+\tbreak;\n+\n+      case PROCESSOR_POWER4:\n+      case PROCESSOR_POWER5:\n+\trs6000_cost = &power4_cost;\n+\tbreak;\n+\n+      default:\n+\tabort ();\n+      }\n }\n \n /* Handle generic options of the form -mfoo=yes/no.\n@@ -16165,90 +16456,19 @@ rs6000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n       return true;\n \n     case MULT:\n-      if (optimize_size)\n-\t{\n-\t  *total = COSTS_N_INSNS (2);\n-\t  return true;\n-\t}\n-      switch (rs6000_cpu)\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n \t{\n-\tcase PROCESSOR_RIOS1:\n-\tcase PROCESSOR_PPC405:\n-\t  *total = (GET_CODE (XEXP (x, 1)) != CONST_INT\n-\t\t    ? COSTS_N_INSNS (5)\n-\t\t    : (INTVAL (XEXP (x, 1)) >= -256\n-\t\t       && INTVAL (XEXP (x, 1)) <= 255)\n-\t\t    ? COSTS_N_INSNS (3) : COSTS_N_INSNS (4));\n-\t  return true;\n-\n-\tcase PROCESSOR_PPC440:\n-\t  *total = (GET_CODE (XEXP (x, 1)) != CONST_INT\n-\t\t    ? COSTS_N_INSNS (3)\n-\t\t    : COSTS_N_INSNS (2));\n-\t  return true;\n-\n-\tcase PROCESSOR_RS64A:\n-\t  *total = (GET_CODE (XEXP (x, 1)) != CONST_INT\n-\t\t    ? GET_MODE (XEXP (x, 1)) != DImode\n-\t\t    ? COSTS_N_INSNS (20) : COSTS_N_INSNS (34)\n-\t\t    : (INTVAL (XEXP (x, 1)) >= -256\n-\t\t       && INTVAL (XEXP (x, 1)) <= 255)\n-\t\t    ? COSTS_N_INSNS (8) : COSTS_N_INSNS (12));\n-\t  return true;\n-\n-\tcase PROCESSOR_RIOS2:\n-\tcase PROCESSOR_MPCCORE:\n-\tcase PROCESSOR_PPC604e:\n-\t  *total = COSTS_N_INSNS (2);\n-\t  return true;\n-\n-\tcase PROCESSOR_PPC601:\n-\t  *total = COSTS_N_INSNS (5);\n-\t  return true;\n-\n-\tcase PROCESSOR_PPC603:\n-\tcase PROCESSOR_PPC7400:\n-\tcase PROCESSOR_PPC750:\n-\t  *total = (GET_CODE (XEXP (x, 1)) != CONST_INT\n-\t\t    ? COSTS_N_INSNS (5)\n-\t\t    : (INTVAL (XEXP (x, 1)) >= -256\n-\t\t       && INTVAL (XEXP (x, 1)) <= 255)\n-\t\t    ? COSTS_N_INSNS (2) : COSTS_N_INSNS (3));\n-\t  return true;\n-\n-\tcase PROCESSOR_PPC7450:\n-\t  *total = (GET_CODE (XEXP (x, 1)) != CONST_INT\n-\t\t    ? COSTS_N_INSNS (4)\n-\t\t    : COSTS_N_INSNS (3));\n-\t  return true;\n-\n-\tcase PROCESSOR_PPC403:\n-\tcase PROCESSOR_PPC604:\n-\tcase PROCESSOR_PPC8540:\n-\t  *total = COSTS_N_INSNS (4);\n-\t  return true;\n-\n-\tcase PROCESSOR_PPC620:\n-\tcase PROCESSOR_PPC630:\n-\t  *total = (GET_CODE (XEXP (x, 1)) != CONST_INT\n-\t\t    ? GET_MODE (XEXP (x, 1)) != DImode\n-\t\t    ? COSTS_N_INSNS (5) : COSTS_N_INSNS (7)\n-\t\t    : (INTVAL (XEXP (x, 1)) >= -256\n-\t\t       && INTVAL (XEXP (x, 1)) <= 255)\n-\t\t    ? COSTS_N_INSNS (3) : COSTS_N_INSNS (4));\n-\t  return true;\n-\n-\tcase PROCESSOR_POWER4:\n-\tcase PROCESSOR_POWER5:\n-\t  *total = (GET_CODE (XEXP (x, 1)) != CONST_INT\n-\t\t    ? GET_MODE (XEXP (x, 1)) != DImode\n-\t\t    ? COSTS_N_INSNS (3) : COSTS_N_INSNS (4)\n-\t\t    : COSTS_N_INSNS (2));\n-\t  return true;\n-\n-\tdefault:\n-\t  abort ();\n+\t  if (INTVAL (XEXP (x, 1)) >= -256\n+\t      && INTVAL (XEXP (x, 1)) <= 255)\n+\t    *total = COSTS_N_INSNS (rs6000_cost->mulsi_const9);\n+\t  else\n+\t    *total = COSTS_N_INSNS (rs6000_cost->mulsi_const);\n \t}\n+      else if (GET_MODE (XEXP (x, 1)) == DImode)\n+\t*total = COSTS_N_INSNS (rs6000_cost->muldi);\n+      else\n+\t*total = COSTS_N_INSNS (rs6000_cost->mulsi);\n+      return true;\n \n     case DIV:\n     case MOD:\n@@ -16262,78 +16482,11 @@ rs6000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n \n     case UDIV:\n     case UMOD:\n-      switch (rs6000_cpu)\n-\t{\n-\tcase PROCESSOR_RIOS1:\n-\t  *total = COSTS_N_INSNS (19);\n-\t  return true;\n-\n-\tcase PROCESSOR_RIOS2:\n-\t  *total = COSTS_N_INSNS (13);\n-\t  return true;\n-\n-\tcase PROCESSOR_RS64A:\n-\t  *total = (GET_MODE (XEXP (x, 1)) != DImode\n-\t\t    ? COSTS_N_INSNS (65)\n-\t\t    : COSTS_N_INSNS (67));\n-\t  return true;\n-\n-\tcase PROCESSOR_MPCCORE:\n-\t  *total = COSTS_N_INSNS (6);\n-\t  return true;\n-\n-\tcase PROCESSOR_PPC403:\n-\t  *total = COSTS_N_INSNS (33);\n-\t  return true;\n-\n-\tcase PROCESSOR_PPC405:\n-\t  *total = COSTS_N_INSNS (35);\n-\t  return true;\n-\n-\tcase PROCESSOR_PPC440:\n-\t  *total = COSTS_N_INSNS (34);\n-\t  return true;\n-\n-\tcase PROCESSOR_PPC601:\n-\t  *total = COSTS_N_INSNS (36);\n-\t  return true;\n-\n-\tcase PROCESSOR_PPC603:\n-\t  *total = COSTS_N_INSNS (37);\n-\t  return true;\n-\n-\tcase PROCESSOR_PPC604:\n-\tcase PROCESSOR_PPC604e:\n-\t  *total = COSTS_N_INSNS (20);\n-\t  return true;\n-\n-\tcase PROCESSOR_PPC620:\n-\tcase PROCESSOR_PPC630:\n-\t  *total = (GET_MODE (XEXP (x, 1)) != DImode\n-\t\t    ? COSTS_N_INSNS (21)\n-\t\t    : COSTS_N_INSNS (37));\n-\t  return true;\n-\n-\tcase PROCESSOR_PPC750:\n-\tcase PROCESSOR_PPC8540:\n-\tcase PROCESSOR_PPC7400:\n-\t  *total = COSTS_N_INSNS (19);\n-\t  return true;\n-\n-\tcase PROCESSOR_PPC7450:\n-\t  *total = COSTS_N_INSNS (23);\n-\t  return true;\n-\n-\tcase PROCESSOR_POWER4:\n-\tcase PROCESSOR_POWER5:\n-\t  *total = (GET_MODE (XEXP (x, 1)) != DImode\n-\t\t    ? COSTS_N_INSNS (18)\n-\t\t    : COSTS_N_INSNS (34));\n-\t  return true;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n+      if (GET_MODE (XEXP (x, 1)) == DImode)\n+\t*total = COSTS_N_INSNS (rs6000_cost->divdi);\n+      else\n+\t*total = COSTS_N_INSNS (rs6000_cost->divsi);\n+      return true;\n \n     case FFS:\n       *total = COSTS_N_INSNS (4);"}]}