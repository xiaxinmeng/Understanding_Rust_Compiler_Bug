{"sha": "b98e296954eded73ab660265878b17a293678d97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk4ZTI5Njk1NGVkZWQ3M2FiNjYwMjY1ODc4YjE3YTI5MzY3OGQ5Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-06-12T13:01:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-06-12T13:01:22Z"}, "message": "[multiple changes]\n\n2012-06-12  Robert Dewar  <dewar@adacore.com>\n\n\t* switch-c.adb, a-exexpr-gcc.adb: Minor reformatting.\n\n2012-06-12  Vincent Pucci  <pucci@adacore.com>\n\n\t* checks.adb (Tag_Checks_Suppressed): Remove Kill_Tag_Checks check.\n\t* einfo.adb (Universal_Aliasing): Apply to the implementation\n\tbase type instead of the base type.\n\t(Get_Rep_Item_For_Entity):\n\tReturn a pragma if the pragma node is not present in the Rep\n\tItem chain of the parent.\n\t(Kill_Tag_Checks): Removed (unused flag).\n\t(Set_Kill_Tag_Checks): Removed.\n\t(Get_First_Rep_Item): New routine.\n\t(Get_Rep_Pragma_For_Entity): New routine.\n\t(Has_Rep_Item): New routine.\n\t(Has_Rep_Pragma_For_Entity): New routine.\n\t(Present_In_Rep_Item): New routine.\n\t* einfo.ads (Kill_Tag_Checks): Removed.\n\t(Set_Kill_Tag_Checks): Removed.\n\t(Get_First_Rep_Item): New routine.\n\t(Get_Rep_Pragma_For_Entity): New routine.\n\t(Has_Rep_Item): New routine.\n\t(Has_Rep_Pragma_For_Entity): New routine.\n\t(Present_In_Rep_Item): New routine.\n\t* exp_attr.adb, sem_attr.adb: Attribute_CPU,\n\tAttribute_Dispatching_Domain and Attribute_Interrupt_Priority\n\tcase added.\n\t* exp_ch13.adb (Expand_N_Attribute_Definition_Clause): For\n\tattribute Storage_Size, insert the new assignement statement\n\tafter the Size variable declaration.\n\t* exp_ch3.adb (Build_Init_Statements): Fill the CPU,\n\tDispatching_Domain, Priority and Size components with the Rep\n\tItem expression (if any).\n\t* exp_ch9.adb (Expand_N_Task_Type_Declaration): _CPU,\n\t_Priority, _Domain fields are always present in the\n\tcorresponding record type.\n\t(Find_Task_Or_Protected_Pragma): Removed.\n\t(Get_Relative_Deadline_Pragma): New routine.\n\t(Make_Initialize_Protection): Find_Task_Or_Protected_Pragma removed.\n\t(Make_Task_Create_Call): Check CPU, Size or\n\tDispatching_Domain Rep Item is present using new routine Has_Rep_Item.\n\t* freeze.adb (Freeze_All): Push_Scope_And_Install_Discriminants\n\tand Uninstall_Discriminants_And_Pop_Scope calls added.\n\t(Freeze_Entity): Evaluate_Aspects_At_Freeze_Point call added.\n\t* sem_aux.adb (Nearest_Ancestor): Retrieve the nearest ancestor\n\tfor private derived types.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Clean-up\n\tand reordering. Delay analysis for all aspects (except some\n\tpeculiar cases).\n\t(Analyze_Attribute_Definition_Clause):\n\tAttribute_CPU, Attribute_Dispatching_Domain,\n\tInterrupt_Priority and Attribute_Priority cases added.\n\t(Analyze_Freeze_Entity): Push_Scope_And_Install_Discriminants\n\tand Uninstall_Discriminants_And_Pop_Scope calls added.\n\t(Check_Aspect_At_Freeze_Point): Reordering and clean-up.\n\t(Duplicate_Clause): Issue an explicit error msg when the current\n\tclause duplicates an aspect specification, an attribute definition\n\tclause or a pragma.\n\t(Evaluate_Aspects_At_Freeze_Point): New routine.\n\t* sem_ch13.ads (Evaluate_Aspects_At_Freeze_Point): New routine.\n\t* sem_ch9.adb, sem_ch9.ads (Install_Discriminants): New routine.\n\t(Push_Scope_And_Install_Discriminants): New routine.\n\t(Uninstall_Discriminants): New routine.\n\t(Uninstall_Discriminants_And_Pop_Scope): New routine.\n\t* sem_prag.adb (Check_Duplicate_Pragma): Issue an explicit error\n\tmsg when the current pragma duplicates an aspect specification,\n\tan attribute definition clause or a pragma.\n\t(Analyze_Pragma): Remove use of flags Has_Pragma_CPU,\n\tHas_Pragma_Priority and Has_Pragma_Dispatching_Domain.\n\t* sem_util.adb (Compile_Time_Constraint_Error): Don't complain\n\tabout the type if the corresponding concurrent type doesn't come\n\tfrom source.\n\t* sinfo.adb, sinfo.ads (Has_Pragma_CPU): Removed.\n\t(Has_Pragma_Dispatching_Domain): Removed.\n\t(Has_Pragma_Priority): Removed.\n\t(Has_Task_Info_Pragma): Removed.\n\t(Has_Task_Name_Pragma): Removed.\n\t(Set_Has_Pragma_CPU): Removed.\n\t(Set_Has_Pragma_Dispatching_Domain): Removed.\n\t(Set_Has_Pragma_Priority): Removed.\n\t(Set_Has_Task_Info_Pragma): Removed.\n\t(Set_Has_Task_Name_Pragma): Removed.\n\t* snames.adb-tmpl (Get_Pragma_Id): Pragma_CPU,\n\tPragma_Dispatching_Domain and Pragma_Interrupt_Priority added.\n\t(Is_Pragma_Name): Name_CPU, Name_Dispatching_Domain and\n\tName_Interrupt_Priority added.\n\t* snames.ads-tmpl: Name_Dispatching_Domain, Name_CPU\n\tand Name_Interrupt_Priority moved to the list of\n\tAttribute_Name. Attribute_CPU, Attribute_Dispatching_Domain and\n\tAttribute_Interrupt_Priority added.  Pragma_Dispatching_Domain,\n\tPragma_CPU and Pragma_Interrupt_Priority moved to the end of\n\tthe Pragma_Name list.\n\nFrom-SVN: r188455", "tree": {"sha": "22d91ebb6c39908a565632e272740326a52d5cff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22d91ebb6c39908a565632e272740326a52d5cff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b98e296954eded73ab660265878b17a293678d97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b98e296954eded73ab660265878b17a293678d97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b98e296954eded73ab660265878b17a293678d97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b98e296954eded73ab660265878b17a293678d97/comments", "author": null, "committer": null, "parents": [{"sha": "fc7d1319f57091f72752692c3477438a37e6d1e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc7d1319f57091f72752692c3477438a37e6d1e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc7d1319f57091f72752692c3477438a37e6d1e9"}], "stats": {"total": 2986, "additions": 1717, "deletions": 1269}, "files": [{"sha": "7f654d0158ba357ac93653d4ab04ddf5a6665905", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -1,3 +1,98 @@\n+2012-06-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* switch-c.adb, a-exexpr-gcc.adb: Minor reformatting.\n+\n+2012-06-12  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* checks.adb (Tag_Checks_Suppressed): Remove Kill_Tag_Checks check.\n+\t* einfo.adb (Universal_Aliasing): Apply to the implementation\n+\tbase type instead of the base type.\n+\t(Get_Rep_Item_For_Entity):\n+\tReturn a pragma if the pragma node is not present in the Rep\n+\tItem chain of the parent.\n+\t(Kill_Tag_Checks): Removed (unused flag).\n+\t(Set_Kill_Tag_Checks): Removed.\n+\t(Get_First_Rep_Item): New routine.\n+\t(Get_Rep_Pragma_For_Entity): New routine.\n+\t(Has_Rep_Item): New routine.\n+\t(Has_Rep_Pragma_For_Entity): New routine.\n+\t(Present_In_Rep_Item): New routine.\n+\t* einfo.ads (Kill_Tag_Checks): Removed.\n+\t(Set_Kill_Tag_Checks): Removed.\n+\t(Get_First_Rep_Item): New routine.\n+\t(Get_Rep_Pragma_For_Entity): New routine.\n+\t(Has_Rep_Item): New routine.\n+\t(Has_Rep_Pragma_For_Entity): New routine.\n+\t(Present_In_Rep_Item): New routine.\n+\t* exp_attr.adb, sem_attr.adb: Attribute_CPU,\n+\tAttribute_Dispatching_Domain and Attribute_Interrupt_Priority\n+\tcase added.\n+\t* exp_ch13.adb (Expand_N_Attribute_Definition_Clause): For\n+\tattribute Storage_Size, insert the new assignement statement\n+\tafter the Size variable declaration.\n+\t* exp_ch3.adb (Build_Init_Statements): Fill the CPU,\n+\tDispatching_Domain, Priority and Size components with the Rep\n+\tItem expression (if any).\n+\t* exp_ch9.adb (Expand_N_Task_Type_Declaration): _CPU,\n+\t_Priority, _Domain fields are always present in the\n+\tcorresponding record type.\n+\t(Find_Task_Or_Protected_Pragma): Removed.\n+\t(Get_Relative_Deadline_Pragma): New routine.\n+\t(Make_Initialize_Protection): Find_Task_Or_Protected_Pragma removed.\n+\t(Make_Task_Create_Call): Check CPU, Size or\n+\tDispatching_Domain Rep Item is present using new routine Has_Rep_Item.\n+\t* freeze.adb (Freeze_All): Push_Scope_And_Install_Discriminants\n+\tand Uninstall_Discriminants_And_Pop_Scope calls added.\n+\t(Freeze_Entity): Evaluate_Aspects_At_Freeze_Point call added.\n+\t* sem_aux.adb (Nearest_Ancestor): Retrieve the nearest ancestor\n+\tfor private derived types.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Clean-up\n+\tand reordering. Delay analysis for all aspects (except some\n+\tpeculiar cases).\n+\t(Analyze_Attribute_Definition_Clause):\n+\tAttribute_CPU, Attribute_Dispatching_Domain,\n+\tInterrupt_Priority and Attribute_Priority cases added.\n+\t(Analyze_Freeze_Entity): Push_Scope_And_Install_Discriminants\n+\tand Uninstall_Discriminants_And_Pop_Scope calls added.\n+\t(Check_Aspect_At_Freeze_Point): Reordering and clean-up.\n+\t(Duplicate_Clause): Issue an explicit error msg when the current\n+\tclause duplicates an aspect specification, an attribute definition\n+\tclause or a pragma.\n+\t(Evaluate_Aspects_At_Freeze_Point): New routine.\n+\t* sem_ch13.ads (Evaluate_Aspects_At_Freeze_Point): New routine.\n+\t* sem_ch9.adb, sem_ch9.ads (Install_Discriminants): New routine.\n+\t(Push_Scope_And_Install_Discriminants): New routine.\n+\t(Uninstall_Discriminants): New routine.\n+\t(Uninstall_Discriminants_And_Pop_Scope): New routine.\n+\t* sem_prag.adb (Check_Duplicate_Pragma): Issue an explicit error\n+\tmsg when the current pragma duplicates an aspect specification,\n+\tan attribute definition clause or a pragma.\n+\t(Analyze_Pragma): Remove use of flags Has_Pragma_CPU,\n+\tHas_Pragma_Priority and Has_Pragma_Dispatching_Domain.\n+\t* sem_util.adb (Compile_Time_Constraint_Error): Don't complain\n+\tabout the type if the corresponding concurrent type doesn't come\n+\tfrom source.\n+\t* sinfo.adb, sinfo.ads (Has_Pragma_CPU): Removed.\n+\t(Has_Pragma_Dispatching_Domain): Removed.\n+\t(Has_Pragma_Priority): Removed.\n+\t(Has_Task_Info_Pragma): Removed.\n+\t(Has_Task_Name_Pragma): Removed.\n+\t(Set_Has_Pragma_CPU): Removed.\n+\t(Set_Has_Pragma_Dispatching_Domain): Removed.\n+\t(Set_Has_Pragma_Priority): Removed.\n+\t(Set_Has_Task_Info_Pragma): Removed.\n+\t(Set_Has_Task_Name_Pragma): Removed.\n+\t* snames.adb-tmpl (Get_Pragma_Id): Pragma_CPU,\n+\tPragma_Dispatching_Domain and Pragma_Interrupt_Priority added.\n+\t(Is_Pragma_Name): Name_CPU, Name_Dispatching_Domain and\n+\tName_Interrupt_Priority added.\n+\t* snames.ads-tmpl: Name_Dispatching_Domain, Name_CPU\n+\tand Name_Interrupt_Priority moved to the list of\n+\tAttribute_Name. Attribute_CPU, Attribute_Dispatching_Domain and\n+\tAttribute_Interrupt_Priority added.  Pragma_Dispatching_Domain,\n+\tPragma_CPU and Pragma_Interrupt_Priority moved to the end of\n+\tthe Pragma_Name list.\n+\n 2012-06-12  Arnaud Charlet  <charlet@adacore.com>\n \n \t* xref_lib.adb (Get_Full_Type): Add support for 'G'."}, {"sha": "2f2e7a76cbadc2312c9c10f386f9a17cebe9a4ee", "filename": "gcc/ada/a-exexpr-gcc.adb", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fa-exexpr-gcc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fa-exexpr-gcc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr-gcc.adb?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -109,9 +109,10 @@ package body Exception_Propagation is\n       Private1 : Unwind_Word;\n       Private2 : Unwind_Word;\n \n-      --  Usual exception structure has only 2 private fields, but the SEH\n-      --  one has 6.  To avoid makeing this file more complex, we use 6 fields\n-      --  on all platforms, wasting a few bytes on some.\n+      --  Usual exception structure has only two private fields, but the SEH\n+      --  one has six. To avoid makeing this file more complex, we use six\n+      --  fields on all platforms, wasting a few bytes on some.\n+\n       Private3 : Unwind_Word;\n       Private4 : Unwind_Word;\n       Private5 : Unwind_Word;\n@@ -481,9 +482,9 @@ package body Exception_Propagation is\n \n       GCC_Exception :=\n         new GNAT_GCC_Exception'\n-          (Header     => (Class => GNAT_Exception_Class,\n+          (Header     => (Class   => GNAT_Exception_Class,\n                           Cleanup => GNAT_GCC_Exception_Cleanup'Address,\n-                          others => 0),\n+                          others  => 0),\n            Occurrence => Excep.all);\n \n       --  Propagate it"}, {"sha": "195b69e1be8615911e5085da63a98083b4c7f62f", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -7378,12 +7378,10 @@ package body Checks is\n \n    function Tag_Checks_Suppressed (E : Entity_Id) return Boolean is\n    begin\n-      if Present (E) then\n-         if Kill_Tag_Checks (E) then\n-            return True;\n-         elsif Checks_May_Be_Suppressed (E) then\n-            return Is_Check_Suppressed (E, Tag_Check);\n-         end if;\n+      if Present (E)\n+        and then Checks_May_Be_Suppressed (E)\n+      then\n+         return Is_Check_Suppressed (E, Tag_Check);\n       end if;\n \n       return Scope_Suppress (Tag_Check);"}, {"sha": "9c4d22bd72d9902d0eb4bc79370deede1c4ce740", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 137, "deletions": 32, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -35,6 +35,7 @@ pragma Style_Checks (All_Checks);\n with Atree;    use Atree;\n with Nlists;   use Nlists;\n with Output;   use Output;\n+with Sem_Aux;  use Sem_Aux;\n with Sinfo;    use Sinfo;\n with Stand;    use Stand;\n \n@@ -283,7 +284,6 @@ package body Einfo is\n    --    Checks_May_Be_Suppressed        Flag31\n    --    Kill_Elaboration_Checks         Flag32\n    --    Kill_Range_Checks               Flag33\n-   --    Kill_Tag_Checks                 Flag34\n    --    Is_Class_Wide_Equivalent_Type   Flag35\n    --    Referenced_As_LHS               Flag36\n    --    Is_Known_Non_Null               Flag37\n@@ -526,6 +526,7 @@ package body Einfo is\n    --    Has_Anonymous_Master            Flag253\n    --    Is_Implementation_Defined       Flag254\n \n+   --    (unused)                        Flag34\n    --    (unused)                        Flag201\n \n    -----------------------\n@@ -2210,11 +2211,6 @@ package body Einfo is\n       return Flag33 (Id);\n    end Kill_Range_Checks;\n \n-   function Kill_Tag_Checks (Id : E) return B is\n-   begin\n-      return Flag34 (Id);\n-   end Kill_Tag_Checks;\n-\n    function Known_To_Have_Preelab_Init (Id : E) return B is\n    begin\n       pragma Assert (Is_Type (Id));\n@@ -2781,7 +2777,7 @@ package body Einfo is\n    function Universal_Aliasing (Id : E) return B is\n    begin\n       pragma Assert (Is_Type (Id));\n-      return Flag216 (Base_Type (Id));\n+      return Flag216 (Implementation_Base_Type (Id));\n    end Universal_Aliasing;\n \n    function Unset_Reference (Id : E) return N is\n@@ -4760,11 +4756,6 @@ package body Einfo is\n       Set_Flag33 (Id, V);\n    end Set_Kill_Range_Checks;\n \n-   procedure Set_Kill_Tag_Checks (Id : E; V : B := True) is\n-   begin\n-      Set_Flag34 (Id, V);\n-   end Set_Kill_Tag_Checks;\n-\n    procedure Set_Known_To_Have_Preelab_Init (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Type (Id));\n@@ -5988,6 +5979,44 @@ package body Einfo is\n       return Empty;\n    end Get_Attribute_Definition_Clause;\n \n+   ------------------\n+   -- Get_Rep_Item --\n+   ------------------\n+\n+   function Get_Rep_Item\n+     (E   : Entity_Id;\n+      Nam : Name_Id) return Node_Id\n+   is\n+      N     : Node_Id;\n+      N_Nam : Name_Id := No_Name;\n+\n+   begin\n+      N := First_Rep_Item (E);\n+\n+      while Present (N) loop\n+         if Nkind (N) = N_Pragma then\n+            N_Nam := Pragma_Name (N);\n+\n+         elsif Nkind (N) = N_Attribute_Definition_Clause then\n+            N_Nam := Chars (N);\n+\n+         elsif Nkind (N) = N_Aspect_Specification then\n+            N_Nam := Chars (Identifier (N));\n+         end if;\n+\n+         if N_Nam = Nam\n+           or else (Nam = Name_Priority\n+                     and then N_Nam = Name_Interrupt_Priority)\n+         then\n+            return N;\n+         end if;\n+\n+         Next_Rep_Item (N);\n+      end loop;\n+\n+      return Empty;\n+   end Get_Rep_Item;\n+\n    -------------------\n    -- Get_Full_View --\n    -------------------\n@@ -6036,28 +6065,47 @@ package body Einfo is\n      (E   : Entity_Id;\n       Nam : Name_Id) return Node_Id\n    is\n+      Par : constant Entity_Id := Nearest_Ancestor (E);\n+      --  In case of a derived type or subtype, this node represents the parent\n+      --  type of type E.\n+\n       N   : Node_Id;\n-      Arg : Node_Id;\n \n    begin\n       N := First_Rep_Item (E);\n       while Present (N) loop\n-         if Nkind (N) = N_Pragma and then Pragma_Name (N) = Nam then\n-            Arg := Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n+         if Nkind (N) = N_Pragma\n+           and then\n+             (Pragma_Name (N) = Nam\n+               or else (Nam = Name_Priority\n+                         and then Pragma_Name (N) = Name_Interrupt_Priority))\n+         then\n+            --  Return N if the pragma doesn't appear in the Rep_Item chain of\n+            --  the parent.\n \n-            if Is_Entity_Name (Arg) and then Entity (Arg) = E then\n+            if No (Par) then\n+               return N;\n+\n+            elsif not Present_In_Rep_Item (Par, N) then\n                return N;\n             end if;\n \n          elsif Nkind (N) = N_Attribute_Definition_Clause\n-           and then Chars (N) = Nam\n            and then Entity (N) = E\n+           and then\n+             (Chars (N) = Nam\n+                or else (Nam = Name_Priority\n+                          and then Chars (N) = Name_Interrupt_Priority))\n          then\n             return N;\n \n          elsif Nkind (N) = N_Aspect_Specification\n-           and then Chars (Identifier (N)) = Nam\n            and then Entity (N) = E\n+           and then\n+             (Chars (Identifier (N)) = Nam\n+                or else (Nam = Name_Priority\n+                          and then Chars (Identifier (N)) =\n+                                     Name_Interrupt_Priority))\n          then\n             return N;\n          end if;\n@@ -6078,7 +6126,12 @@ package body Einfo is\n    begin\n       N := First_Rep_Item (E);\n       while Present (N) loop\n-         if Nkind (N) = N_Pragma and then Pragma_Name (N) = Nam then\n+         if Nkind (N) = N_Pragma\n+           and then\n+             (Pragma_Name (N) = Nam\n+               or else (Nam = Name_Interrupt_Priority\n+                         and then Pragma_Name (N) = Name_Priority))\n+         then\n             return N;\n          end if;\n \n@@ -6088,6 +6141,30 @@ package body Einfo is\n       return Empty;\n    end Get_Rep_Pragma;\n \n+   -------------------------------\n+   -- Get_Rep_Pragma_For_Entity --\n+   -------------------------------\n+\n+   function Get_Rep_Pragma_For_Entity\n+     (E : Entity_Id; Nam : Name_Id) return Node_Id\n+   is\n+      Par : constant Entity_Id := Nearest_Ancestor (E);\n+      --  In case of a derived type or subtype, this node represents the parent\n+      --  type of type E.\n+\n+      Prag : constant Node_Id := Get_Rep_Pragma (E, Nam);\n+\n+   begin\n+      if No (Par) then\n+         return Prag;\n+\n+      elsif not Present_In_Rep_Item (Par, Prag) then\n+         return Prag;\n+      end if;\n+\n+      return Empty;\n+   end Get_Rep_Pragma_For_Entity;\n+\n    ------------------------\n    -- Has_Attach_Handler --\n    ------------------------\n@@ -6112,18 +6189,6 @@ package body Einfo is\n       return False;\n    end Has_Attach_Handler;\n \n-   -------------------------------------\n-   -- Has_Attribute_Definition_Clause --\n-   -------------------------------------\n-\n-   function Has_Attribute_Definition_Clause\n-     (E  : Entity_Id;\n-      Id : Attribute_Id) return Boolean\n-   is\n-   begin\n-      return Present (Get_Attribute_Definition_Clause (E, Id));\n-   end Has_Attribute_Definition_Clause;\n-\n    -----------------\n    -- Has_Entries --\n    -----------------\n@@ -6185,6 +6250,15 @@ package body Einfo is\n       return False;\n    end Has_Interrupt_Handler;\n \n+   ------------------\n+   -- Has_Rep_Item --\n+   ------------------\n+\n+   function Has_Rep_Item (E : Entity_Id; Nam : Name_Id) return Boolean is\n+   begin\n+      return Present (Get_Rep_Item (E, Nam));\n+   end Has_Rep_Item;\n+\n    --------------------\n    -- Has_Rep_Pragma --\n    --------------------\n@@ -6194,6 +6268,17 @@ package body Einfo is\n       return Present (Get_Rep_Pragma (E, Nam));\n    end Has_Rep_Pragma;\n \n+   -------------------------------\n+   -- Has_Rep_Pragma_For_Entity --\n+   -------------------------------\n+\n+   function Has_Rep_Pragma_For_Entity\n+     (E : Entity_Id; Nam : Name_Id) return Boolean\n+   is\n+   begin\n+      return Present (Get_Rep_Pragma_For_Entity (E, Nam));\n+   end Has_Rep_Pragma_For_Entity;\n+\n    --------------------\n    -- Has_Unmodified --\n    --------------------\n@@ -6972,6 +7057,27 @@ package body Einfo is\n       return Ekind (Id);\n    end Parameter_Mode;\n \n+   -------------------------\n+   -- Present_In_Rep_Item --\n+   -------------------------\n+\n+   function Present_In_Rep_Item (E : Entity_Id; N : Node_Id) return Boolean is\n+      Ritem : Node_Id;\n+\n+   begin\n+      Ritem := First_Rep_Item (E);\n+\n+      while Present (Ritem) loop\n+         if Ritem = N then\n+            return True;\n+         end if;\n+\n+         Next_Rep_Item (Ritem);\n+      end loop;\n+\n+      return False;\n+   end Present_In_Rep_Item;\n+\n    --------------------------\n    -- Primitive_Operations --\n    --------------------------\n@@ -7654,7 +7760,6 @@ package body Einfo is\n       W (\"Itype_Printed\",                   Flag202 (Id));\n       W (\"Kill_Elaboration_Checks\",         Flag32  (Id));\n       W (\"Kill_Range_Checks\",               Flag33  (Id));\n-      W (\"Kill_Tag_Checks\",                 Flag34  (Id));\n       W (\"Known_To_Have_Preelab_Init\",      Flag207 (Id));\n       W (\"Low_Bound_Tested\",                Flag205 (Id));\n       W (\"Machine_Radix_10\",                Flag84  (Id));"}, {"sha": "49a1cf61cb91499343590887642ec2078ebaaa65", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 39, "deletions": 27, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -729,11 +729,11 @@ package Einfo is\n --       declared the entity. Normally this is just the Parent of the entity.\n --       One exception arises with child units, where the parent of the entity\n --       is a selected component/defining program unit name. Another exception\n---       is that if the entity is an incomplete type that has been completed,\n---       then we obtain the declaration node denoted by the full type, i.e. the\n---       full type declaration node. Also note that for subprograms, this\n---       returns the {function,procedure}_specification, not the subprogram_\n---       declaration.\n+--       is that if the entity is an incomplete type that has been completed or\n+--       a private type, then we obtain the declaration node denoted by the\n+--       full type, i.e. the full type declaration node. Also note that for\n+--       subprograms, this returns the {function,procedure}_specification, not\n+--       the subprogram_declaration.\n \n --    Default_Aspect_Component_Value (Node19)\n --       Present in array types. Holds the static value specified in a\n@@ -2907,13 +2907,6 @@ package Einfo is\n --       This is currently only used in one odd situation in Sem_Ch3 for\n --       record types, and it would be good to get rid of it???\n \n---    Kill_Tag_Checks (Flag34)\n---       Present in all entities. Set by the expander to kill elaboration\n---       checks which are known not to be needed. Equivalent in effect to\n---       the use of pragma Suppress (Tag_Checks) for that entity except\n---       that the result is permanent and cannot be undone by a subsequent\n---       pragma Unsuppress.\n-\n --    Known_To_Have_Preelab_Init (Flag207)\n --       Present in all type and subtype entities. If set, then the type is\n --       known to have preelaborable initialization. In the case of a partial\n@@ -4852,7 +4845,6 @@ package Einfo is\n    --    Is_VMS_Exception                    (Flag133)\n    --    Kill_Elaboration_Checks             (Flag32)\n    --    Kill_Range_Checks                   (Flag33)\n-   --    Kill_Tag_Checks                     (Flag34)\n    --    Low_Bound_Tested                    (Flag205)\n    --    Materialize_Entity                  (Flag168)\n    --    Needs_Debug_Info                    (Flag147)\n@@ -6310,7 +6302,6 @@ package Einfo is\n    function Itype_Printed                       (Id : E) return B;\n    function Kill_Elaboration_Checks             (Id : E) return B;\n    function Kill_Range_Checks                   (Id : E) return B;\n-   function Kill_Tag_Checks                     (Id : E) return B;\n    function Known_To_Have_Preelab_Init          (Id : E) return B;\n    function Last_Assignment                     (Id : E) return N;\n    function Last_Entity                         (Id : E) return E;\n@@ -6907,7 +6898,6 @@ package Einfo is\n    procedure Set_Itype_Printed                   (Id : E; V : B := True);\n    procedure Set_Kill_Elaboration_Checks         (Id : E; V : B := True);\n    procedure Set_Kill_Range_Checks               (Id : E; V : B := True);\n-   procedure Set_Kill_Tag_Checks                 (Id : E; V : B := True);\n    procedure Set_Known_To_Have_Preelab_Init      (Id : E; V : B := True);\n    procedure Set_Last_Assignment                 (Id : E; V : N);\n    procedure Set_Last_Entity                     (Id : E; V : E);\n@@ -7200,15 +7190,25 @@ package Einfo is\n    --  value returned is the N_Attribute_Definition_Clause node, otherwise\n    --  Empty is returned.\n \n+   function Get_Rep_Item\n+     (E   : Entity_Id;\n+      Nam : Name_Id) return Node_Id;\n+   --  Searches the Rep_Item chain for a given entity E, for the first\n+   --  occurrence of a rep item (pragma, attribute definition clause, or aspect\n+   --  specification) whose name matches the given name. If one is found, it is\n+   --  returned, otherwise Empty is returned. A special case is that when Nam\n+   --  is Name_Priority, the call will also find Interrupt_Priority.\n+\n    function Get_Rep_Item_For_Entity\n      (E   : Entity_Id;\n       Nam : Name_Id) return Node_Id;\n    --  Searches the Rep_Item chain for a given entity E, for an instance of a\n    --  rep item (pragma, attribute definition clause, or aspect specification)\n    --  whose name matches the given name. If one is found, it is returned,\n-   --  otherwise Empty is returned. Unlike the other Get routines for the\n-   --  Rep_Item chain, this only returns items whose entity matches E (it\n-   --  does not return items from the parent chain).\n+   --  otherwise Empty is returned. This routine only returns items whose\n+   --  entity matches E (it does not return items from the parent chain). A\n+   --  special case is that when Nam is Name_Priority, the call will also find\n+   --  Interrupt_Priority.\n \n    function Get_Record_Representation_Clause (E : Entity_Id) return Node_Id;\n    --  Searches the Rep_Item chain for a given entity E, for a record\n@@ -7218,19 +7218,33 @@ package Einfo is\n    function Get_Rep_Pragma (E : Entity_Id; Nam : Name_Id) return Node_Id;\n    --  Searches the Rep_Item chain for the given entity E, for an instance\n    --  a representation pragma with the given name Nam. If found then the\n-   --  value returned is the N_Pragma node, otherwise Empty is returned.\n+   --  value returned is the N_Pragma node, otherwise Empty is returned. A\n+   --  special case is that when Nam is Name_Priority, the call will also find\n+   --  Interrupt_Priority.\n+\n+   function Get_Rep_Pragma_For_Entity\n+     (E : Entity_Id; Nam : Name_Id) return Node_Id;\n+   --  Same as Get_Rep_Pragma except that this routine returns a pragma that\n+   --  doesn't appear in the Rep Item chain of the parent of E (if any).\n+\n+   function Has_Rep_Item (E : Entity_Id; Nam : Name_Id) return Boolean;\n+   --  Searches the Rep_Item chain for the given entity E, for an instance\n+   --  of rep item with the given name Nam. If found then True is returned,\n+   --  otherwise False indicates that no matching entry was found.\n \n    function Has_Rep_Pragma (E : Entity_Id; Nam : Name_Id) return Boolean;\n    --  Searches the Rep_Item chain for the given entity E, for an instance\n    --  of representation pragma with the given name Nam. If found then True\n    --  is returned, otherwise False indicates that no matching entry was found.\n \n-   function Has_Attribute_Definition_Clause\n-     (E  : Entity_Id;\n-      Id : Attribute_Id) return Boolean;\n-   --  Searches the Rep_Item chain for a given entity E, for an instance of an\n-   --  attribute definition clause with the given attribute Id. If found, True\n-   --  is returned, otherwise False indicates that no matching entry was found.\n+   function Has_Rep_Pragma_For_Entity\n+     (E : Entity_Id; Nam : Name_Id) return Boolean;\n+   --  Same as Has_Rep_Pragma except that this routine doesn't return True if\n+   --  the representation pragma is also present in the Rep Item chain of the\n+   --  parent of E (if any).\n+\n+   function Present_In_Rep_Item (E : Entity_Id; N : Node_Id) return Boolean;\n+   --  Return True if N is present in the Rep_Item chain for a given entity E\n \n    procedure Record_Rep_Item (E : Entity_Id; N : Node_Id);\n    --  N is the node for a representation pragma, representation clause, an\n@@ -7650,7 +7664,6 @@ package Einfo is\n    pragma Inline (Itype_Printed);\n    pragma Inline (Kill_Elaboration_Checks);\n    pragma Inline (Kill_Range_Checks);\n-   pragma Inline (Kill_Tag_Checks);\n    pragma Inline (Known_To_Have_Preelab_Init);\n    pragma Inline (Last_Assignment);\n    pragma Inline (Last_Entity);\n@@ -8056,7 +8069,6 @@ package Einfo is\n    pragma Inline (Set_Itype_Printed);\n    pragma Inline (Set_Kill_Elaboration_Checks);\n    pragma Inline (Set_Kill_Range_Checks);\n-   pragma Inline (Set_Kill_Tag_Checks);\n    pragma Inline (Set_Known_To_Have_Preelab_Init);\n    pragma Inline (Set_Last_Assignment);\n    pragma Inline (Set_Last_Entity);"}, {"sha": "d63d4dee1ea25813a7118a641438284de0e9f9f0", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -831,11 +831,17 @@ package body Exp_Attr is\n \n       --  Attributes related to Ada 2012 iterators (placeholder ???)\n \n-      when Attribute_Constant_Indexing    => null;\n-      when Attribute_Default_Iterator     => null;\n-      when Attribute_Implicit_Dereference => null;\n-      when Attribute_Iterator_Element     => null;\n-      when Attribute_Variable_Indexing    => null;\n+      when Attribute_Constant_Indexing    |\n+           Attribute_Default_Iterator     |\n+           Attribute_Implicit_Dereference |\n+           Attribute_Iterator_Element     |\n+           Attribute_Variable_Indexing    => null;\n+\n+      --  Attributes related to Ada 2012 aspects\n+\n+      when Attribute_CPU                |\n+           Attribute_Dispatching_Domain |\n+           Attribute_Interrupt_Priority => null;\n \n       ------------\n       -- Access --"}, {"sha": "26eaec28b4e6ea3b5038ff5746ddb360c5a4ae2b", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -165,14 +165,30 @@ package body Exp_Ch13 is\n \n             --  If the type is a task type, then assign the value of the\n             --  storage size to the Size variable associated with the task.\n-            --    task_typeZ := expression\n+            --  Insert the assignment right after the declaration of the Size\n+            --  variable.\n+\n+            --  Generate:\n+\n+            --  task_typeZ := expression\n \n             if Ekind (Ent) = E_Task_Type then\n-               Insert_Action (N,\n-                 Make_Assignment_Statement (Loc,\n-                   Name => New_Reference_To (Storage_Size_Variable (Ent), Loc),\n-                   Expression =>\n-                     Convert_To (RTE (RE_Size_Type), Expression (N))));\n+               declare\n+                  Assign : Node_Id;\n+\n+               begin\n+                  Assign :=\n+                    Make_Assignment_Statement (Loc,\n+                      Name =>\n+                        New_Reference_To (Storage_Size_Variable (Ent), Loc),\n+                      Expression =>\n+                        Convert_To (RTE (RE_Size_Type), Expression (N)));\n+\n+                  Insert_After\n+                    (Parent (Storage_Size_Variable (Entity (N))), Assign);\n+\n+                  Analyze (Assign);\n+               end;\n \n             --  For Storage_Size for an access type, create a variable to hold\n             --  the value of the specified size with name typeV and expand an"}, {"sha": "fa64f9a0b0beef70f34ff06c1eb38a4e36b91c6d", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -2636,6 +2636,99 @@ package body Exp_Ch3 is\n                      Actions := Build_Assignment (Id, Expression (Decl));\n                   end if;\n \n+               --  CPU, Dispatching_Domain, Priority and Size components are\n+               --  filled with the corresponding rep item expression of the\n+               --  concurrent type (if any).\n+\n+               elsif Ekind (Scope (Id)) = E_Record_Type\n+                 and then Present (Corresponding_Concurrent_Type (Scope (Id)))\n+                 and then (Chars (Id) = Name_uCPU\n+                            or else Chars (Id) = Name_uDispatching_Domain\n+                            or else Chars (Id) = Name_uPriority)\n+               then\n+                  declare\n+                     Exp   : Node_Id;\n+                     Nam   : Name_Id;\n+                     Ritem : Node_Id;\n+\n+                  begin\n+                     if Chars (Id) = Name_uCPU then\n+                        Nam := Name_CPU;\n+\n+                     elsif Chars (Id) = Name_uDispatching_Domain then\n+                        Nam := Name_Dispatching_Domain;\n+\n+                     elsif Chars (Id) = Name_uPriority then\n+                        Nam := Name_Priority;\n+                     end if;\n+\n+                     --  Get the Rep Item (aspect specification, attribute\n+                     --  definition clause or pragma) of the corresponding\n+                     --  concurrent type.\n+\n+                     Ritem :=\n+                       Get_Rep_Item\n+                         (Corresponding_Concurrent_Type (Scope (Id)), Nam);\n+\n+                     if Present (Ritem) then\n+                        --  Pragma case\n+\n+                        if Nkind (Ritem) = N_Pragma then\n+                           Exp := First (Pragma_Argument_Associations (Ritem));\n+\n+                           if Nkind (Exp) = N_Pragma_Argument_Association then\n+                              Exp := Expression (Exp);\n+                           end if;\n+\n+                           --  Conversion for Priority expression\n+\n+                           if Nam = Name_Priority then\n+                              if Pragma_Name (Ritem) = Name_Priority\n+                                and then not GNAT_Mode\n+                              then\n+                                 Exp := Convert_To (RTE (RE_Priority), Exp);\n+                              else\n+                                 Exp :=\n+                                   Convert_To (RTE (RE_Any_Priority), Exp);\n+                              end if;\n+                           end if;\n+\n+                        --  Aspect/Attribute definition clause case\n+\n+                        else\n+                           Exp := Expression (Ritem);\n+\n+                           --  Conversion for Priority expression\n+\n+                           if Nam = Name_Priority then\n+                              if Chars (Ritem) = Name_Priority\n+                                and then not GNAT_Mode\n+                              then\n+                                 Exp := Convert_To (RTE (RE_Priority), Exp);\n+                              else\n+                                 Exp :=\n+                                   Convert_To (RTE (RE_Any_Priority), Exp);\n+                              end if;\n+                           end if;\n+                        end if;\n+\n+                        --  Conversion for Dispatching_Domain value\n+\n+                        if Nam = Name_Dispatching_Domain then\n+                           Exp :=\n+                             Unchecked_Convert_To\n+                               (RTE (RE_Dispatching_Domain_Access), Exp);\n+                        end if;\n+\n+                        Actions := Build_Assignment (Id, Exp);\n+\n+                     --  Nothing needed if no Rep Item\n+\n+                     else\n+                        Actions := No_List;\n+                     end if;\n+                  end;\n+\n                --  Composite component with its own Init_Proc\n \n                elsif not Is_Interface (Typ)"}, {"sha": "2a533c93c3ef8d009a58dbf53bf8abd753f2a5f1", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 145, "deletions": 220, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -395,15 +395,6 @@ package body Exp_Ch9 is\n    --  the scope of Context_Id and Context_Decls is the declarative list of\n    --  Context.\n \n-   function Find_Task_Or_Protected_Pragma\n-     (T : Node_Id;\n-      P : Name_Id) return Node_Id;\n-   --  Searches the task or protected definition T for the first occurrence\n-   --  of the pragma whose name is given by P. The caller has ensured that\n-   --  the pragma is present in the task definition. A special case is that\n-   --  when P is Name_uPriority, the call will also find Interrupt_Priority.\n-   --  ??? Should be implemented with the rep item chain mechanism.\n-\n    function Index_Object (Spec_Id : Entity_Id) return Entity_Id;\n    --  Given a subprogram identifier, return the entity which is associated\n    --  with the protection entry index in the Protected_Body_Subprogram or the\n@@ -11279,30 +11270,30 @@ package body Exp_Ch9 is\n    --  in the pragma, and is used to override the task stack size otherwise\n    --  associated with the task type.\n \n-   --  The _Priority field is present only if a Priority or Interrupt_Priority\n-   --  pragma appears in the task definition. The expression captures the\n-   --  argument that was present in the pragma, and is used to provide the Size\n-   --  parameter to the call to Create_Task.\n+   --  The _Priority field is always present. It will be filled at the freeze\n+   --  point, when the record init proc is built, to capture the expression of\n+   --  a Priority pragma, attribute definition clause or aspect specification\n+   --  (see Build_Record_Init_Proc in Exp_Ch3).\n \n    --  The _Task_Info field is present only if a Task_Info pragma appears in\n    --  the task definition. The expression captures the argument that was\n    --  present in the pragma, and is used to provide the Task_Image parameter\n    --  to the call to Create_Task.\n \n-   --  The _CPU field is present only if a CPU pragma appears in the task\n-   --  definition. The expression captures the argument that was present in\n-   --  the pragma, and is used to provide the CPU parameter to the call to\n-   --  Create_Task.\n+   --  The _CPU field is always present. It will be filled at the freeze point,\n+   --  when the record init proc is built, to capture the expression of a CPU\n+   --  pragma, attribute definition clause or aspect specification (see\n+   --  Build_Record_Init_Proc in Exp_Ch3).\n \n    --  The _Relative_Deadline field is present only if a Relative_Deadline\n    --  pragma appears in the task definition. The expression captures the\n    --  argument that was present in the pragma, and is used to provide the\n    --  Relative_Deadline parameter to the call to Create_Task.\n \n-   --  The _Domain field is present only if a Dispatching_Domain pragma or\n-   --  aspect appears in the task definition. The expression captures the\n-   --  argument that was present in the pragma or aspect, and is used to\n-   --  provide the Dispatching_Domain parameter to the call to Create_Task.\n+   --  The _Domain field is always present. It will be filled at the freeze\n+   --  point, when the record init proc is built, to capture the expression of\n+   --  a Dispatching_Domain pragma, attribute definition clause or aspect\n+   --  specification (see Build_Record_Init_Proc in Exp_Ch3).\n \n    --  When a task is declared, an instance of the task value record is\n    --  created. The elaboration of this declaration creates the correct bounds\n@@ -11336,20 +11327,64 @@ package body Exp_Ch9 is\n \n    procedure Expand_N_Task_Type_Declaration (N : Node_Id) is\n       Loc     : constant Source_Ptr := Sloc (N);\n+      TaskId  : constant Entity_Id  := Defining_Identifier (N);\n       Tasktyp : constant Entity_Id  := Etype (Defining_Identifier (N));\n       Tasknm  : constant Name_Id    := Chars (Tasktyp);\n       Taskdef : constant Node_Id    := Task_Definition (N);\n \n+      Body_Decl  : Node_Id;\n+      Cdecls     : List_Id;\n+      Decl_Stack : Node_Id;\n+      Elab_Decl  : Node_Id;\n+      Ent_Stack  : Entity_Id;\n       Proc_Spec  : Node_Id;\n       Rec_Decl   : Node_Id;\n       Rec_Ent    : Entity_Id;\n-      Cdecls     : List_Id;\n-      Elab_Decl  : Node_Id;\n-      Size_Decl  : Node_Id;\n-      Body_Decl  : Node_Id;\n+      Size_Decl  : Entity_Id;\n       Task_Size  : Node_Id;\n-      Ent_Stack  : Entity_Id;\n-      Decl_Stack : Node_Id;\n+\n+      function Get_Relative_Deadline_Pragma (T : Node_Id) return Node_Id;\n+      --  Searches the task definition T for the first occurrence of the pragma\n+      --  Relative Deadline. The caller has ensured that the pragma is present\n+      --  in the task definition. Note that this routine cannot be implemented\n+      --  with the Rep Item chain mechanism since Relative_Deadline pragmas are\n+      --  not chained because their expansion into a procedure call statement\n+      --  would cause a break in the chain.\n+\n+      ----------------------------------\n+      -- Get_Relative_Deadline_Pragma --\n+      ----------------------------------\n+\n+      function Get_Relative_Deadline_Pragma (T : Node_Id) return Node_Id is\n+         N : Node_Id;\n+\n+      begin\n+         N := First (Visible_Declarations (T));\n+         while Present (N) loop\n+            if Nkind (N) = N_Pragma\n+              and then Pragma_Name (N) = Name_Relative_Deadline\n+            then\n+               return N;\n+            end if;\n+\n+            Next (N);\n+         end loop;\n+\n+         N := First (Private_Declarations (T));\n+         while Present (N) loop\n+            if Nkind (N) = N_Pragma\n+              and then Pragma_Name (N) = Name_Relative_Deadline\n+            then\n+               return N;\n+            end if;\n+\n+            Next (N);\n+         end loop;\n+\n+         raise Program_Error;\n+      end Get_Relative_Deadline_Pragma;\n+\n+   --  Start of processing for Expand_N_Task_Type_Declaration\n \n    begin\n       --  If already expanded, nothing to do\n@@ -11378,6 +11413,7 @@ package body Exp_Ch9 is\n           Aliased_Present      => True,\n           Object_Definition    => New_Reference_To (Standard_Boolean, Loc),\n           Expression           => New_Reference_To (Standard_False, Loc));\n+\n       Insert_After (N, Elab_Decl);\n \n       --  Next create the declaration of the size variable (tasknmZ)\n@@ -11392,8 +11428,7 @@ package body Exp_Ch9 is\n           Is_Static_Expression\n             (Expression\n                (First (Pragma_Argument_Associations\n-                         (Find_Task_Or_Protected_Pragma\n-                            (Taskdef, Name_Storage_Size)))))\n+                         (Get_Rep_Pragma (TaskId, Name_Storage_Size)))))\n       then\n          Size_Decl :=\n            Make_Object_Declaration (Loc,\n@@ -11403,8 +11438,8 @@ package body Exp_Ch9 is\n                Convert_To (RTE (RE_Size_Type),\n                  Relocate_Node\n                    (Expression (First (Pragma_Argument_Associations\n-                                         (Find_Task_Or_Protected_Pragma\n-                                            (Taskdef, Name_Storage_Size)))))));\n+                                         (Get_Rep_Pragma\n+                                            (TaskId, Name_Storage_Size)))))));\n \n       else\n          Size_Decl :=\n@@ -11472,8 +11507,7 @@ package body Exp_Ch9 is\n                Expr_N : constant Node_Id :=\n                           Expression (First (\n                             Pragma_Argument_Associations (\n-                              Find_Task_Or_Protected_Pragma\n-                                (Taskdef, Name_Storage_Size))));\n+                              Get_Rep_Pragma (TaskId, Name_Storage_Size))));\n                Etyp   : constant Entity_Id := Etype (Expr_N);\n                P      : constant Node_Id   := Parent (Expr_N);\n \n@@ -11532,51 +11566,19 @@ package body Exp_Ch9 is\n \n       Collect_Entry_Families (Loc, Cdecls, Size_Decl, Tasktyp);\n \n-      --  Add the _Priority component if a Priority pragma is present\n+      --  Add the _Priority component with no expression\n \n-      if Present (Taskdef) and then Has_Pragma_Priority (Taskdef) then\n-         declare\n-            Prag : constant Node_Id :=\n-                     Find_Task_Or_Protected_Pragma (Taskdef, Name_Priority);\n-            Expr : Node_Id;\n-\n-         begin\n-            Expr := First (Pragma_Argument_Associations (Prag));\n-\n-            if Nkind (Expr) = N_Pragma_Argument_Association then\n-               Expr := Expression (Expr);\n-            end if;\n-\n-            Expr := New_Copy_Tree (Expr);\n-\n-            --  Add conversion to proper type to do range check if required\n-            --  Note that for runtime units, we allow out of range interrupt\n-            --  priority values to be used in a priority pragma. This is for\n-            --  the benefit of some versions of System.Interrupts which use\n-            --  a special server task with maximum interrupt priority.\n-\n-            if Pragma_Name (Prag) = Name_Priority\n-              and then not GNAT_Mode\n-            then\n-               Rewrite (Expr, Convert_To (RTE (RE_Priority), Expr));\n-            else\n-               Rewrite (Expr, Convert_To (RTE (RE_Any_Priority), Expr));\n-            end if;\n-\n-            Append_To (Cdecls,\n-              Make_Component_Declaration (Loc,\n-                Defining_Identifier =>\n-                  Make_Defining_Identifier (Loc, Name_uPriority),\n-                Component_Definition =>\n-                  Make_Component_Definition (Loc,\n-                    Aliased_Present    => False,\n-                    Subtype_Indication => New_Reference_To (Standard_Integer,\n-                                                            Loc)),\n-                Expression => Expr));\n-         end;\n-      end if;\n+      Append_To (Cdecls,\n+        Make_Component_Declaration (Loc,\n+          Defining_Identifier  =>\n+            Make_Defining_Identifier (Loc, Name_uPriority),\n+          Component_Definition =>\n+            Make_Component_Definition (Loc,\n+              Aliased_Present    => False,\n+              Subtype_Indication =>\n+                New_Reference_To (Standard_Integer, Loc))));\n \n-      --  Add the _Task_Size component if a Storage_Size pragma is present\n+      --  Add the _Size component if a Storage_Size pragma is present\n \n       if Present (Taskdef)\n         and then Has_Storage_Size_Pragma (Taskdef)\n@@ -11589,21 +11591,20 @@ package body Exp_Ch9 is\n              Component_Definition =>\n                Make_Component_Definition (Loc,\n                  Aliased_Present    => False,\n-                 Subtype_Indication => New_Reference_To (RTE (RE_Size_Type),\n-                                                         Loc)),\n+                 Subtype_Indication =>\n+                   New_Reference_To (RTE (RE_Size_Type), Loc)),\n \n              Expression =>\n                Convert_To (RTE (RE_Size_Type),\n                  Relocate_Node (\n                    Expression (First (\n                      Pragma_Argument_Associations (\n-                       Find_Task_Or_Protected_Pragma\n-                         (Taskdef, Name_Storage_Size))))))));\n+                       Get_Rep_Pragma (TaskId, Name_Storage_Size))))))));\n       end if;\n \n       --  Add the _Task_Info component if a Task_Info pragma is present\n \n-      if Present (Taskdef) and then Has_Task_Info_Pragma (Taskdef) then\n+      if Has_Rep_Pragma_For_Entity (TaskId, Name_Task_Info) then\n          Append_To (Cdecls,\n            Make_Component_Declaration (Loc,\n              Defining_Identifier =>\n@@ -11618,30 +11619,21 @@ package body Exp_Ch9 is\n              Expression => New_Copy (\n                Expression (First (\n                  Pragma_Argument_Associations (\n-                   Find_Task_Or_Protected_Pragma\n-                     (Taskdef, Name_Task_Info)))))));\n+                   Get_Rep_Pragma_For_Entity (TaskId, Name_Task_Info)))))));\n       end if;\n \n-      --  Add the _CPU component if a CPU pragma is present\n-\n-      if Present (Taskdef) and then Has_Pragma_CPU (Taskdef) then\n-         Append_To (Cdecls,\n-           Make_Component_Declaration (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier (Loc, Name_uCPU),\n+      --  Add the _CPU component with no expression\n \n-             Component_Definition =>\n-               Make_Component_Definition (Loc,\n-                 Aliased_Present    => False,\n-                 Subtype_Indication =>\n-                   New_Reference_To (RTE (RE_CPU_Range), Loc)),\n+      Append_To (Cdecls,\n+        Make_Component_Declaration (Loc,\n+          Defining_Identifier =>\n+            Make_Defining_Identifier (Loc, Name_uCPU),\n \n-             Expression => New_Copy (\n-               Expression (First (\n-                 Pragma_Argument_Associations (\n-                   Find_Task_Or_Protected_Pragma\n-                     (Taskdef, Name_CPU)))))));\n-      end if;\n+          Component_Definition =>\n+            Make_Component_Definition (Loc,\n+              Aliased_Present    => False,\n+              Subtype_Indication =>\n+                New_Reference_To (RTE (RE_CPU_Range), Loc))));\n \n       --  Add the _Relative_Deadline component if a Relative_Deadline pragma is\n       --  present. If we are using a restricted run time this component will\n@@ -11667,19 +11659,14 @@ package body Exp_Ch9 is\n                  Relocate_Node (\n                    Expression (First (\n                      Pragma_Argument_Associations (\n-                       Find_Task_Or_Protected_Pragma\n-                         (Taskdef, Name_Relative_Deadline))))))));\n+                       Get_Relative_Deadline_Pragma (Taskdef))))))));\n       end if;\n \n-      --  Add the _Dispatching_Domain component if a Dispatching_Domain pragma\n-      --  or aspect is present. If we are using a restricted run time this\n-      --  component will not be added (dispatching domains are not allowed by\n-      --  the Ravenscar profile).\n+      --  Add the _Dispatching_Domain component with no expression. If we are\n+      --  using a restricted run time this component will not be added\n+      --  (dispatching domains are not allowed by the Ravenscar profile).\n \n-      if not Restricted_Profile\n-        and then Present (Taskdef)\n-        and then Has_Pragma_Dispatching_Domain (Taskdef)\n-      then\n+      if not Restricted_Profile then\n          Append_To (Cdecls,\n            Make_Component_Declaration (Loc,\n              Defining_Identifier  =>\n@@ -11690,16 +11677,7 @@ package body Exp_Ch9 is\n                  Aliased_Present    => False,\n                  Subtype_Indication =>\n                    New_Reference_To\n-                     (RTE (RE_Dispatching_Domain_Access), Loc)),\n-\n-             Expression           =>\n-               Unchecked_Convert_To (RTE (RE_Dispatching_Domain_Access),\n-                 Relocate_Node\n-                   (Expression\n-                      (First\n-                         (Pragma_Argument_Associations\n-                            (Find_Task_Or_Protected_Pragma\n-                               (Taskdef, Name_Dispatching_Domain))))))));\n+                     (RTE (RE_Dispatching_Domain_Access), Loc))));\n       end if;\n \n       Insert_After (Size_Decl, Rec_Decl);\n@@ -12750,60 +12728,6 @@ package body Exp_Ch9 is\n       return S;\n    end Find_Master_Scope;\n \n-   -----------------------------------\n-   -- Find_Task_Or_Protected_Pragma --\n-   -----------------------------------\n-\n-   function Find_Task_Or_Protected_Pragma\n-     (T : Node_Id;\n-      P : Name_Id) return Node_Id\n-   is\n-      N : Node_Id;\n-\n-   begin\n-      N := First (Visible_Declarations (T));\n-      while Present (N) loop\n-         if Nkind (N) = N_Pragma then\n-            if Pragma_Name (N) = P then\n-               return N;\n-\n-            elsif P = Name_Priority\n-              and then Pragma_Name (N) = Name_Interrupt_Priority\n-            then\n-               return N;\n-\n-            else\n-               Next (N);\n-            end if;\n-\n-         else\n-            Next (N);\n-         end if;\n-      end loop;\n-\n-      N := First (Private_Declarations (T));\n-      while Present (N) loop\n-         if Nkind (N) = N_Pragma then\n-            if Pragma_Name (N) = P then\n-               return N;\n-\n-            elsif P = Name_Priority\n-              and then Pragma_Name (N) = Name_Interrupt_Priority\n-            then\n-               return N;\n-\n-            else\n-               Next (N);\n-            end if;\n-\n-         else\n-            Next (N);\n-         end if;\n-      end loop;\n-\n-      raise Program_Error;\n-   end Find_Task_Or_Protected_Pragma;\n-\n    -------------------------------\n    -- First_Protected_Operation --\n    -------------------------------\n@@ -13362,7 +13286,6 @@ package body Exp_Ch9 is\n    is\n       Loc         : constant Source_Ptr := Sloc (Protect_Rec);\n       P_Arr       : Entity_Id;\n-      Pdef        : Node_Id;\n       Pdec        : Node_Id;\n       Ptyp        : constant Node_Id :=\n                       Corresponding_Concurrent_Type (Protect_Rec);\n@@ -13392,10 +13315,6 @@ package body Exp_Ch9 is\n          Next (Pdec);\n       end loop;\n \n-      --  Now we can find the object definition from this declaration\n-\n-      Pdef := Protected_Definition (Pdec);\n-\n       --  Build the parameter list for the call. Note that _Init is the name\n       --  of the formal for the object to be initialized, which is the task\n       --  value record itself.\n@@ -13418,24 +13337,34 @@ package body Exp_Ch9 is\n              Attribute_Name => Name_Unchecked_Access));\n \n          --  Priority parameter. Set to Unspecified_Priority unless there is a\n-         --  priority pragma, in which case we take the value from the pragma,\n-         --  or there is an interrupt pragma and no priority pragma, and we\n-         --  set the ceiling to Interrupt_Priority'Last, an implementation-\n-         --  defined value, see D.3(10).\n+         --  priority clause, in which case we take the value from the\n+         --  pragma/attribute definition clause, or there is an interrupt\n+         --  clause and no priority clause, and we set the ceiling to\n+         --  Interrupt_Priority'Last, an implementation defined value,\n+         --  see D.3(10).\n \n-         if Present (Pdef)\n-           and then Has_Pragma_Priority (Pdef)\n-         then\n+         if Has_Rep_Item (Ptyp, Name_Priority) then\n             declare\n-               Prio : constant Node_Id :=\n-                        Expression\n-                          (First\n-                             (Pragma_Argument_Associations\n-                                (Find_Task_Or_Protected_Pragma\n-                                   (Pdef, Name_Priority))));\n+               Prio_Clause : constant Node_Id :=\n+                               Get_Rep_Item (Ptyp, Name_Priority);\n+\n+               Prio : Node_Id;\n                Temp : Entity_Id;\n \n             begin\n+               --  Pragma Priority\n+\n+               if Nkind (Prio_Clause) = N_Pragma then\n+                  Prio :=\n+                    Expression\n+                     (First (Pragma_Argument_Associations (Prio_Clause)));\n+\n+               --  Attribute definition clause Priority\n+\n+               else\n+                  Prio := Expression (Prio_Clause);\n+               end if;\n+\n                --  If priority is a static expression, then we can duplicate it\n                --  with no problem and simply append it to the argument list.\n \n@@ -13738,9 +13667,9 @@ package body Exp_Ch9 is\n       Args := New_List;\n \n       --  Priority parameter. Set to Unspecified_Priority unless there is a\n-      --  priority pragma, in which case we take the value from the pragma.\n+      --  priority rep item, in which case we take the value from the rep item.\n \n-      if Present (Tdef) and then Has_Pragma_Priority (Tdef) then\n+      if Has_Rep_Item (Ttyp, Name_Priority) then\n          Append_To (Args,\n            Make_Selected_Component (Loc,\n              Prefix        => Make_Identifier (Loc, Name_uInit),\n@@ -13795,9 +13724,7 @@ package body Exp_Ch9 is\n       --  Task_Info parameter. Set to Unspecified_Task_Info unless there is a\n       --  Task_Info pragma, in which case we take the value from the pragma.\n \n-      if Present (Tdef)\n-        and then Has_Task_Info_Pragma (Tdef)\n-      then\n+      if Has_Rep_Pragma_For_Entity (Ttyp, Name_Task_Info) then\n          Append_To (Args,\n            Make_Selected_Component (Loc,\n              Prefix        => Make_Identifier (Loc, Name_uInit),\n@@ -13808,18 +13735,17 @@ package body Exp_Ch9 is\n            New_Reference_To (RTE (RE_Unspecified_Task_Info), Loc));\n       end if;\n \n-      --  CPU parameter. Set to Unspecified_CPU unless there is a CPU pragma,\n-      --  in which case we take the value from the pragma. The parameter is\n+      --  CPU parameter. Set to Unspecified_CPU unless there is a CPU rep item,\n+      --  in which case we take the value from the rep item. The parameter is\n       --  passed as an Integer because in the case of unspecified CPU the\n       --  value is not in the range of CPU_Range.\n \n-      if Present (Tdef) and then Has_Pragma_CPU (Tdef) then\n+      if Has_Rep_Item (Ttyp, Name_CPU) then\n          Append_To (Args,\n            Convert_To (Standard_Integer,\n              Make_Selected_Component (Loc,\n                Prefix        => Make_Identifier (Loc, Name_uInit),\n                Selector_Name => Make_Identifier (Loc, Name_uCPU))));\n-\n       else\n          Append_To (Args,\n            New_Reference_To (RTE (RE_Unspecified_CPU), Loc));\n@@ -13836,7 +13762,9 @@ package body Exp_Ch9 is\n \n          --  Case where pragma Relative_Deadline applies: use given value\n \n-         if Present (Tdef) and then Has_Relative_Deadline_Pragma (Tdef) then\n+         if Present (Tdef)\n+           and then Has_Relative_Deadline_Pragma (Tdef)\n+         then\n             Append_To (Args,\n               Make_Selected_Component (Loc,\n                 Prefix        =>\n@@ -13851,18 +13779,17 @@ package body Exp_Ch9 is\n               New_Reference_To (RTE (RE_Time_Span_Zero), Loc));\n          end if;\n \n-         --  Dispatching_Domain parameter. If no Dispatching_Domain pragma or\n-         --  aspect is present, then the dispatching domain is null. If a\n-         --  pragma or aspect is present, then the dispatching domain is taken\n-         --  from the _Dispatching_Domain field of the task value record,\n-         --  which was set from the pragma value. Note that this parameter\n-         --  must not be generated for the restricted profiles since Ravenscar\n-         --  does not allow dispatching domains.\n+         --  Dispatching_Domain parameter. If no Dispatching_Domain rep item is\n+         --  present, then the dispatching domain is null. If a rep item is\n+         --  present, then the dispatching domain is taken from the\n+         --  _Dispatching_Domain field of the task value record, which was set\n+         --  from the rep item value. Note that this parameter must not be\n+         --  generated for the restricted profiles since Ravenscar does not\n+         --  allow dispatching domains.\n \n-         --  Case where pragma or aspect Dispatching_Domain applies: use given\n-         --  value.\n+         --  Case where Dispatching_Domain rep item applies: use given value\n \n-         if Present (Tdef) and then Has_Pragma_Dispatching_Domain (Tdef) then\n+         if Has_Rep_Item (Ttyp, Name_Dispatching_Domain) then\n             Append_To (Args,\n               Make_Selected_Component (Loc,\n                 Prefix        =>\n@@ -13980,18 +13907,16 @@ package body Exp_Ch9 is\n       --  init call unless there is a Task_Name pragma, in which case we take\n       --  the value from the pragma.\n \n-      if Present (Tdef)\n-        and then Has_Task_Name_Pragma (Tdef)\n-      then\n+      if Has_Rep_Pragma_For_Entity (Ttyp, Name_Task_Name) then\n          --  Copy expression in full, because it may be dynamic and have\n          --  side effects.\n \n          Append_To (Args,\n            New_Copy_Tree\n-             (Expression (First\n-                           (Pragma_Argument_Associations\n-                             (Find_Task_Or_Protected_Pragma\n-                               (Tdef, Name_Task_Name))))));\n+             (Expression\n+               (First\n+                 (Pragma_Argument_Associations\n+                   (Get_Rep_Pragma_For_Entity (Ttyp, Name_Task_Name))))));\n \n       else\n          Append_To (Args, Make_Identifier (Loc, Name_uTask_Name));"}, {"sha": "558022e75824050fc14508eae6f2e66f60fd91ef", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 19, "deletions": 36, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -49,6 +49,7 @@ with Sem_Cat;  use Sem_Cat;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch7;  use Sem_Ch7;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch9;  use Sem_Ch9;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Eval; use Sem_Eval;\n with Sem_Mech; use Sem_Mech;\n@@ -1323,6 +1324,11 @@ package body Freeze is\n             --  for a description of how we handle aspect visibility).\n \n             elsif Has_Delayed_Aspects (E) then\n+               --  Retrieve the visibility to the discriminants in order to\n+               --  analyze properly the aspects.\n+\n+               Push_Scope_And_Install_Discriminants (E);\n+\n                declare\n                   Ritem : Node_Id;\n \n@@ -1339,6 +1345,8 @@ package body Freeze is\n                      Ritem := Next_Rep_Item (Ritem);\n                   end loop;\n                end;\n+\n+               Uninstall_Discriminants_And_Pop_Scope (E);\n             end if;\n \n             --  If an incomplete type is still not frozen, this may be a\n@@ -1536,6 +1544,10 @@ package body Freeze is\n       procedure Add_To_Result (N : Node_Id);\n       --  N is a freezing action to be appended to the Result\n \n+      function After_Last_Declaration return Boolean;\n+      --  If Loc is a freeze_entity that appears after the last declaration\n+      --  in the scope, inhibit error messages on late completion.\n+\n       procedure Check_Current_Instance (Comp_Decl : Node_Id);\n       --  Check that an Access or Unchecked_Access attribute with a prefix\n       --  which is the current instance type can only be applied when the type\n@@ -1546,10 +1558,6 @@ package body Freeze is\n       --  integer literal without an explicit corresponding size clause. The\n       --  caller has checked that Utype is a modular integer type.\n \n-      function After_Last_Declaration return Boolean;\n-      --  If Loc is a freeze_entity that appears after the last declaration\n-      --  in the scope, inhibit error messages on late completion.\n-\n       procedure Freeze_Record_Type (Rec : Entity_Id);\n       --  Freeze each component, handle some representation clauses, and freeze\n       --  primitive operations if this is a tagged type.\n@@ -2513,39 +2521,15 @@ package body Freeze is\n          end;\n       end if;\n \n-      --  Deal with delayed aspect specifications. The analysis of the aspect\n-      --  is required to be delayed to the freeze point, so we evaluate the\n-      --  pragma or attribute definition clause in the tree at this point.\n+      --  Deal with delayed aspect specifications. The analysis of the\n+      --  aspect is required to be delayed to the freeze point, so we\n+      --  evaluate the pragma or attribute definition clause in the tree at\n+      --  this point. We also analyze the aspect specification node at the\n+      --  freeze point when the aspect doesn't correspond to\n+      --  pragma/attribute definition clause.\n \n       if Has_Delayed_Aspects (E) then\n-         declare\n-            Ritem : Node_Id;\n-            Aitem : Node_Id;\n-\n-         begin\n-            --  Look for aspect specification entries for this entity\n-\n-            Ritem := First_Rep_Item (E);\n-            while Present (Ritem) loop\n-               if Nkind (Ritem) = N_Aspect_Specification\n-                 and then Entity (Ritem) = E\n-                 and then Is_Delayed_Aspect (Ritem)\n-                 and then Scope (E) = Current_Scope\n-               then\n-                  Aitem := Aspect_Rep_Item (Ritem);\n-\n-                  --  Skip if this is an aspect with no corresponding pragma\n-                  --  or attribute definition node (such as Default_Value).\n-\n-                  if Present (Aitem) then\n-                     Set_Parent (Aitem, Ritem);\n-                     Analyze (Aitem);\n-                  end if;\n-               end if;\n-\n-               Next_Rep_Item (Ritem);\n-            end loop;\n-         end;\n+         Evaluate_Aspects_At_Freeze_Point (E);\n       end if;\n \n       --  Here to freeze the entity\n@@ -2555,7 +2539,6 @@ package body Freeze is\n       --  Case of entity being frozen is other than a type\n \n       if not Is_Type (E) then\n-\n          --  If entity is exported or imported and does not have an external\n          --  name, now is the time to provide the appropriate default name.\n          --  Skip this if the entity is stubbed, since we don't need a name"}, {"sha": "bf700803086f3b718a8ad0c2559c85cf9bc897f4", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -2215,6 +2215,14 @@ package body Sem_Attr is\n            Attribute_Variable_Indexing    =>\n          Error_Msg_N (\"illegal attribute\", N);\n \n+      --  Attributes related to Ada 2012 aspects. Attribute definition clause\n+      --  exists for these, but they cannot be queried.\n+\n+      when Attribute_CPU                |\n+           Attribute_Dispatching_Domain |\n+           Attribute_Interrupt_Priority =>\n+         Error_Msg_N (\"illegal attribute\", N);\n+\n       ------------------\n       -- Abort_Signal --\n       ------------------\n@@ -6286,11 +6294,17 @@ package body Sem_Attr is\n \n          --  Attributes related to Ada 2012 iterators (placeholder ???)\n \n-         when Attribute_Constant_Indexing    => null;\n-         when Attribute_Default_Iterator     => null;\n-         when Attribute_Implicit_Dereference => null;\n-         when Attribute_Iterator_Element     => null;\n-         when Attribute_Variable_Indexing    => null;\n+         when Attribute_Constant_Indexing    |\n+              Attribute_Default_Iterator     |\n+              Attribute_Implicit_Dereference |\n+              Attribute_Iterator_Element     |\n+              Attribute_Variable_Indexing    => null;\n+\n+         --  Atributes related to Ada 2012 aspects\n+\n+         when Attribute_CPU                |\n+              Attribute_Dispatching_Domain |\n+              Attribute_Interrupt_Priority => null;\n \n       --------------\n       -- Adjacent --"}, {"sha": "6499249d6d63eef4285c8aae45d31d5b8d492a6d", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -832,7 +832,7 @@ package body Sem_Aux is\n    ----------------------\n \n    function Nearest_Ancestor (Typ : Entity_Id) return Entity_Id is\n-         D : constant Node_Id := Declaration_Node (Typ);\n+      D : constant Node_Id := Original_Node (Declaration_Node (Typ));\n \n    begin\n       --  If we have a subtype declaration, get the ancestor subtype\n@@ -860,6 +860,15 @@ package body Sem_Aux is\n             end if;\n          end;\n \n+      --  If derived type and private type, get the full view to find who we\n+      --  are derived from.\n+\n+      elsif Is_Derived_Type (Typ)\n+        and then Is_Private_Type (Typ)\n+        and then Present (Full_View (Typ))\n+      then\n+         return Nearest_Ancestor (Full_View (Typ));\n+\n       --  Otherwise, nothing useful to return, return Empty\n \n       else"}, {"sha": "d1318fef1275729f0d3c5560dc4bc4cb2edbc3f9", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 828, "deletions": 679, "changes": 1507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -46,6 +46,7 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch9;  use Sem_Ch9;\n with Sem_Dim;  use Sem_Dim;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n@@ -693,26 +694,27 @@ package body Sem_Ch13 is\n       L : constant List_Id := Aspect_Specifications (N);\n \n       Ins_Node : Node_Id := N;\n-      --  Insert pragmas (except Pre/Post/Invariant/Predicate) after this node\n+      --  Insert pragmas/attribute definition clause after this node when no\n+      --  delayed analysis is required.\n \n       --  The general processing involves building an attribute definition\n-      --  clause or a pragma node that corresponds to the aspect. Then one\n-      --  of two things happens:\n-\n-      --  If we are required to delay the evaluation of this aspect to the\n-      --  freeze point, we attach the corresponding pragma/attribute definition\n-      --  clause to the aspect specification node, which is then placed in the\n-      --  Rep Item chain. In this case we mark the entity by setting the flag\n-      --  Has_Delayed_Aspects and we evaluate the rep item at the freeze point.\n-\n-      --  If no delay is required, we just insert the pragma or attribute\n-      --  after the declaration, and it will get processed by the normal\n-      --  circuit. The From_Aspect_Specification flag is set on the pragma\n-      --  or attribute definition node in either case to activate special\n-      --  processing (e.g. not traversing the list of homonyms for inline).\n-\n-      Delay_Required : Boolean := False;\n-      --  Set True if delay is required\n+      --  clause or a pragma node that corresponds to the aspect. Then in order\n+      --  to delay the evaluation of this aspect to the freeze point, we attach\n+      --  the corresponding pragma/attribute definition clause to the aspect\n+      --  specification node, which is then placed in the Rep Item chain. In\n+      --  this case we mark the entity by setting the flag Has_Delayed_Aspects\n+      --  and we evaluate the rep item at the freeze point. When the aspect\n+      --  doesn't have a corresponding pragma/attribute definition clause, then\n+      --  its analysis is simply delayed at the freeze point.\n+\n+      --  Some special cases don't require delay analysis, thus the aspect is\n+      --  analyzed right now.\n+\n+      --  Note that there is a special handling for\n+      --  Pre/Post/Test_Case/Contract_Case aspects. In this case, we do not\n+      --  have to worry about delay issues, since the pragmas themselves deal\n+      --  with delay of visibility for the expression analysis. Thus, we just\n+      --  insert the pragma after the node N.\n \n    begin\n       pragma Assert (Present (L));\n@@ -722,82 +724,98 @@ package body Sem_Ch13 is\n       Aspect := First (L);\n       Aspect_Loop : while Present (Aspect) loop\n          declare\n-            Loc  : constant Source_Ptr := Sloc (Aspect);\n-            Id   : constant Node_Id    := Identifier (Aspect);\n             Expr : constant Node_Id    := Expression (Aspect);\n+            Id   : constant Node_Id    := Identifier (Aspect);\n+            Loc  : constant Source_Ptr := Sloc (Aspect);\n             Nam  : constant Name_Id    := Chars (Id);\n             A_Id : constant Aspect_Id  := Get_Aspect_Id (Nam);\n             Anod : Node_Id;\n \n+            Delay_Required : Boolean := True;\n+            --  Set False if delay is not required\n+\n             Eloc : Source_Ptr := No_Location;\n             --  Source location of expression, modified when we split PPC's. It\n             --  is set below when Expr is present.\n \n-            procedure Check_False_Aspect_For_Derived_Type;\n-            --  This procedure checks for the case of a false aspect for a\n-            --  derived type, which improperly tries to cancel an aspect\n-            --  inherited from the parent;\n+            procedure Analyze_Aspect_External_Or_Link_Name;\n+            --  This routine performs the analysis of the External_Name or\n+            --  Link_Name aspects.\n \n-            -----------------------------------------\n-            -- Check_False_Aspect_For_Derived_Type --\n-            -----------------------------------------\n+            procedure Analyze_Aspect_Implicit_Dereference;\n+            --  This routine performs the analysis of the Implicit_Dereference\n+            --  aspects.\n \n-            procedure Check_False_Aspect_For_Derived_Type is\n+            ------------------------------------------\n+            -- Analyze_Aspect_External_Or_Link_Name --\n+            ------------------------------------------\n+\n+            procedure Analyze_Aspect_External_Or_Link_Name is\n             begin\n-               --  We are only checking derived types\n+               --  Verify that there is an Import/Export aspect defined for the\n+               --  entity. The processing of that aspect in turn checks that\n+               --  there is a Convention aspect declared. The pragma is\n+               --  constructed when processing the Convention aspect.\n \n-               if not Is_Derived_Type (E) then\n-                  return;\n-               end if;\n+               declare\n+                  A : Node_Id;\n \n-               case A_Id is\n-                  when Aspect_Atomic | Aspect_Shared =>\n-                     if not Is_Atomic (E) then\n-                        return;\n-                     end if;\n+               begin\n+                  A := First (L);\n \n-                  when Aspect_Atomic_Components =>\n-                     if not Has_Atomic_Components (E) then\n-                        return;\n-                     end if;\n+                  while Present (A) loop\n+                     exit when Chars (Identifier (A)) = Name_Export\n+                       or else Chars (Identifier (A)) = Name_Import;\n+                     Next (A);\n+                  end loop;\n \n-                  when Aspect_Discard_Names =>\n-                     if not Discard_Names (E) then\n-                        return;\n-                     end if;\n+                  if No (A) then\n+                     Error_Msg_N\n+                       (\"Missing Import/Export for Link/External name\",\n+                         Aspect);\n+                  end if;\n+               end;\n+            end Analyze_Aspect_External_Or_Link_Name;\n \n-                  when Aspect_Pack =>\n-                     if not Is_Packed (E) then\n-                        return;\n-                     end if;\n+            -----------------------------------------\n+            -- Analyze_Aspect_Implicit_Dereference --\n+            -----------------------------------------\n \n-                  when Aspect_Unchecked_Union =>\n-                     if not Is_Unchecked_Union (E) then\n-                        return;\n-                     end if;\n+            procedure Analyze_Aspect_Implicit_Dereference is\n+            begin\n+               if not Is_Type (E)\n+                 or else not Has_Discriminants (E)\n+               then\n+                  Error_Msg_N\n+                    (\"Aspect must apply to a type with discriminants\", N);\n \n-                  when Aspect_Volatile =>\n-                     if not Is_Volatile (E) then\n-                        return;\n-                     end if;\n+               else\n+                  declare\n+                     Disc : Entity_Id;\n \n-                  when Aspect_Volatile_Components =>\n-                     if not Has_Volatile_Components (E) then\n-                        return;\n-                     end if;\n+                  begin\n+                     Disc := First_Discriminant (E);\n \n-                  when others =>\n-                     return;\n-               end case;\n+                     while Present (Disc) loop\n+                        if Chars (Expr) = Chars (Disc)\n+                          and then Ekind (Etype (Disc)) =\n+                                     E_Anonymous_Access_Type\n+                        then\n+                           Set_Has_Implicit_Dereference (E);\n+                           Set_Has_Implicit_Dereference (Disc);\n+                           return;\n+                        end if;\n \n-               --  Fall through means we are canceling an inherited aspect\n+                        Next_Discriminant (Disc);\n+                     end loop;\n \n-               Error_Msg_Name_1 := Nam;\n-               Error_Msg_NE\n-                 (\"derived type& inherits aspect%, cannot cancel\", Expr, E);\n-            end Check_False_Aspect_For_Derived_Type;\n+                     --  Error if no proper access discriminant.\n \n-         --  Start of processing for Aspect_Loop\n+                     Error_Msg_NE\n+                      (\"not an access discriminant of&\", Expr, E);\n+                  end;\n+               end if;\n+            end Analyze_Aspect_Implicit_Dereference;\n \n          begin\n             --  Skip aspect if already analyzed (not clear if this is needed)\n@@ -926,199 +944,25 @@ package body Sem_Ch13 is\n                when No_Aspect =>\n                   raise Program_Error;\n \n-               --  Aspects taking an optional boolean argument\n-\n-               when Boolean_Aspects =>\n-                  Set_Is_Boolean_Aspect (Aspect);\n-\n-                  --  Special treatment for Aspect_Lock_Free since it is the\n-                  --  only Boolean_Aspect that doesn't correspond to a pragma.\n-\n-                  if A_Id = Aspect_Lock_Free then\n-                     if Ekind (E) /= E_Protected_Type then\n-                        Error_Msg_N\n-                          (\"aspect % only applies to protected objects\",\n-                           Aspect);\n-                     end if;\n-\n-                     --  Set the Uses_Lock_Free flag to True if there is no\n-                     --  expression or if the expression is True.\n-\n-                     if No (Expr) or else Is_True (Static_Boolean (Expr)) then\n-                        Set_Uses_Lock_Free (E);\n-                     end if;\n-\n-                     goto Continue;\n-\n-                  --  For Import/Export, Verify that there is an aspect\n-                  --  Convention that will incorporate the Import/Export\n-                  --  aspect, and eventual Link/External names.\n-\n-                  elsif A_Id = Aspect_Import or else A_Id = Aspect_Export then\n-                     declare\n-                        A : Node_Id;\n-\n-                     begin\n-                        A := First (L);\n-                        while Present (A) loop\n-                           exit when Chars (Identifier (A)) = Name_Convention;\n-                           Next (A);\n-                        end loop;\n-\n-                        if No (A) then\n-                           Error_Msg_N\n-                             (\"missing Convention aspect for Export/Import\",\n-                                 Aspect);\n-                        end if;\n-                     end;\n-\n-                     goto Continue;\n-                  end if;\n-\n-                  --  For all other aspects we just create a matching pragma\n-                  --  and insert it, if the expression is missing or set to\n-                  --  True. If the expression is False, we can ignore the\n-                  --  aspect with the exception that in the case of a derived\n-                  --  type, we must check for an illegal attempt to cancel an\n-                  --  inherited aspect.\n-\n-                  if Present (Expr)\n-                    and then Is_False (Static_Boolean (Expr))\n-                  then\n-                     Check_False_Aspect_For_Derived_Type;\n-                     goto Continue;\n-                  end if;\n-\n-                  --  If True, build corresponding pragma node\n-\n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Argument_Associations => New_List (Ent),\n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Chars (Id)));\n-\n-                  --  Never need to delay for boolean aspects\n-\n-                  pragma Assert (not Delay_Required);\n-\n-               --  Library unit aspects. These are boolean aspects, but we\n-               --  have to do special things with the insertion, since the\n-               --  pragma belongs inside the declarations of a package.\n-\n-               when Library_Unit_Aspects =>\n-                  if Present (Expr)\n-                    and then Is_False (Static_Boolean (Expr))\n-                  then\n-                     goto Continue;\n-                  end if;\n-\n-                  --  Build corresponding pragma node\n-\n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Argument_Associations => New_List (Ent),\n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Chars (Id)));\n-\n-                  --  This requires special handling in the case of a package\n-                  --  declaration, the pragma needs to be inserted in the list\n-                  --  of declarations for the associated package. There is no\n-                  --  issue of visibility delay for these aspects.\n-\n-                  if Nkind (N) = N_Package_Declaration then\n-                     if Nkind (Parent (N)) /= N_Compilation_Unit then\n-                        Error_Msg_N\n-                          (\"incorrect context for library unit aspect&\", Id);\n-                     else\n-                        Prepend\n-                          (Aitem, Visible_Declarations (Specification (N)));\n-                     end if;\n-\n-                     goto Continue;\n-                  end if;\n-\n-                  --  If not package declaration, no delay is required\n-\n-                  pragma Assert (not Delay_Required);\n-\n-               --  Aspects related to container iterators. These aspects denote\n-               --  subprograms, and thus must be delayed.\n-\n-               when Aspect_Constant_Indexing    |\n-                    Aspect_Variable_Indexing    =>\n-\n-                  if not Is_Type (E) or else not Is_Tagged_Type (E) then\n-                     Error_Msg_N (\"indexing applies to a tagged type\", N);\n-                  end if;\n-\n-                  Aitem :=\n-                    Make_Attribute_Definition_Clause (Loc,\n-                      Name       => Ent,\n-                      Chars      => Chars (Id),\n-                      Expression => Relocate_Node (Expr));\n-\n-                  Delay_Required := True;\n-                  Set_Is_Delayed_Aspect (Aspect);\n-\n-               when Aspect_Default_Iterator     |\n-                    Aspect_Iterator_Element     =>\n-\n-                  Aitem :=\n-                    Make_Attribute_Definition_Clause (Loc,\n-                      Name       => Ent,\n-                      Chars      => Chars (Id),\n-                      Expression => Relocate_Node (Expr));\n-\n-                  Delay_Required := True;\n-                  Set_Is_Delayed_Aspect (Aspect);\n-\n-               when Aspect_Implicit_Dereference =>\n-                  if not Is_Type (E)\n-                    or else not Has_Discriminants (E)\n-                  then\n-                     Error_Msg_N\n-                       (\"Aspect must apply to a type with discriminants\", N);\n-                     goto Continue;\n-\n-                  else\n-                     declare\n-                        Disc : Entity_Id;\n-\n-                     begin\n-                        Disc := First_Discriminant (E);\n-                        while Present (Disc) loop\n-                           if Chars (Expr) = Chars (Disc)\n-                             and then Ekind (Etype (Disc)) =\n-                               E_Anonymous_Access_Type\n-                           then\n-                              Set_Has_Implicit_Dereference (E);\n-                              Set_Has_Implicit_Dereference (Disc);\n-                              goto Continue;\n-                           end if;\n-\n-                           Next_Discriminant (Disc);\n-                        end loop;\n-\n-                        --  Error if no proper access discriminant.\n-\n-                        Error_Msg_NE\n-                         (\"not an access discriminant of&\", Expr, E);\n-                     end;\n-\n-                     goto Continue;\n-                  end if;\n-\n-               --  Aspects corresponding to attribute definition clauses\n+               --  Case 1: Aspects corresponding to attribute definition\n+               --  clauses.\n \n                when Aspect_Address              |\n                     Aspect_Alignment            |\n                     Aspect_Bit_Order            |\n                     Aspect_Component_Size       |\n+                    Aspect_Constant_Indexing    |\n+                    Aspect_CPU                  |\n+                    Aspect_Default_Iterator     |\n+                    Aspect_Dispatching_Domain   |\n                     Aspect_External_Tag         |\n                     Aspect_Input                |\n+                    Aspect_Interrupt_Priority   |\n+                    Aspect_Iterator_Element     |\n                     Aspect_Machine_Radix        |\n                     Aspect_Object_Size          |\n                     Aspect_Output               |\n+                    Aspect_Priority             |\n                     Aspect_Read                 |\n                     Aspect_Scalar_Storage_Order |\n                     Aspect_Size                 |\n@@ -1128,8 +972,20 @@ package body Sem_Ch13 is\n                     Aspect_Storage_Size         |\n                     Aspect_Stream_Size          |\n                     Aspect_Value_Size           |\n+                    Aspect_Variable_Indexing    |\n                     Aspect_Write                =>\n \n+                  --  Indexing aspects apply only to tagged type\n+\n+                  if (A_Id = Aspect_Constant_Indexing\n+                       or else A_Id = Aspect_Variable_Indexing)\n+                    and then not (Is_Type (E)\n+                                   and then Is_Tagged_Type (E))\n+                  then\n+                     Error_Msg_N (\"indexing applies to a tagged type\", N);\n+                     goto Continue;\n+                  end if;\n+\n                   --  Construct the attribute definition clause\n \n                   Aitem :=\n@@ -1138,22 +994,12 @@ package body Sem_Ch13 is\n                       Chars      => Chars (Id),\n                       Expression => Relocate_Node (Expr));\n \n-                  --  A delay is required except in the common case where\n-                  --  the expression is a literal, in which case it is fine\n-                  --  to take care of it right away.\n-\n-                  if Nkind_In (Expr, N_Integer_Literal, N_String_Literal) then\n-                     pragma Assert (not Delay_Required);\n-                     null;\n-                  else\n-                     Delay_Required := True;\n-                     Set_Is_Delayed_Aspect (Aspect);\n-                  end if;\n+               --  Case 2: Aspects cooresponding to pragmas\n \n-               --  Aspects corresponding to pragmas with two arguments, where\n-               --  the first argument is a local name referring to the entity,\n-               --  and the second argument is the aspect definition expression\n-               --  which is an expression that does not get analyzed.\n+               --  Case 2a: Aspects corresponding to pragmas with two\n+               --  arguments, where the first argument is a local name\n+               --  referring to the entity, and the second argument is the\n+               --  aspect definition expression.\n \n                when Aspect_Suppress   |\n                     Aspect_Unsuppress =>\n@@ -1168,11 +1014,6 @@ package body Sem_Ch13 is\n                       Pragma_Identifier            =>\n                         Make_Identifier (Sloc (Id), Chars (Id)));\n \n-                  --  We don't have to play the delay game here, since the only\n-                  --  values are check names which don't get analyzed anyway.\n-\n-                  pragma Assert (not Delay_Required);\n-\n                when Aspect_Synchronization =>\n \n                   --  The aspect corresponds to pragma Implemented.\n@@ -1186,11 +1027,53 @@ package body Sem_Ch13 is\n                       Pragma_Identifier            =>\n                         Make_Identifier (Sloc (Id), Name_Implemented));\n \n-                  pragma Assert (not Delay_Required);\n+                  --  No delay is required since the only values are: By_Entry\n+                  --  | By_Protected_Procedure | By_Any | Optional which don't\n+                  --  get analyzed anyway.\n \n-               --  Aspects corresponding to pragmas with two arguments, where\n-               --  the second argument is a local name referring to the entity,\n-               --  and the first argument is the aspect definition expression.\n+                  Delay_Required := False;\n+\n+               when Aspect_Attach_Handler =>\n+                  Aitem :=\n+                    Make_Pragma (Loc,\n+                      Pragma_Identifier            =>\n+                        Make_Identifier (Sloc (Id), Name_Attach_Handler),\n+                      Pragma_Argument_Associations =>\n+                        New_List (Ent, Relocate_Node (Expr)));\n+\n+               when Aspect_Dynamic_Predicate |\n+                    Aspect_Predicate         |\n+                    Aspect_Static_Predicate  =>\n+\n+                  --  Construct the pragma (always a pragma Predicate, with\n+                  --  flags recording whether it is static/dynamic).\n+\n+                  Aitem :=\n+                    Make_Pragma (Loc,\n+                      Pragma_Argument_Associations =>\n+                        New_List (Ent, Relocate_Node (Expr)),\n+                      Class_Present                => Class_Present (Aspect),\n+                      Pragma_Identifier            =>\n+                        Make_Identifier (Sloc (Id), Name_Predicate));\n+\n+                  --  If the type is private, indicate that its completion\n+                  --  has a freeze node, because that is the one that will be\n+                  --  visible at freeze time.\n+\n+                  Set_Has_Predicates (E);\n+\n+                  if Is_Private_Type (E)\n+                    and then Present (Full_View (E))\n+                  then\n+                     Set_Has_Predicates (Full_View (E));\n+                     Set_Has_Delayed_Aspects (Full_View (E));\n+                     Ensure_Freeze_Node (Full_View (E));\n+                  end if;\n+\n+               --  Case 2b: Aspects corresponding to pragmas with two\n+               --  arguments, where the second argument is a local name\n+               --  referring to the entity, and the first argument is the\n+               --  aspect definition expression.\n \n                when Aspect_Convention  =>\n \n@@ -1215,56 +1098,36 @@ package body Sem_Ch13 is\n                      L_Assoc  := Empty;\n                      E_Assoc  := Empty;\n \n-                     --  Loop to look for Import/Export/Link_Name/External_Name\n-\n                      A := First (L);\n                      while Present (A) loop\n                         A_Name := Chars (Identifier (A));\n \n-                        --  Import/Export\n-\n                         if A_Name = Name_Import\n-                             or else\n-                           A_Name = Name_Export\n+                          or else A_Name = Name_Export\n                         then\n-                           --  Forbid duplicates, at most one can appear\n-\n                            if Found then\n-                              Error_Msg_Name_1 := A_Name;\n-                              Error_Msg_Name_2 := P_Name;\n-                              Error_Msg_N\n-                                (\"% aspect conflicts with previous % aspect\",\n-                                 A);\n+                              Error_Msg_N (\"conflicting\", A);\n                            else\n                               Found := True;\n                            end if;\n \n-                           --  Record name of pragma to generate\n-\n                            P_Name := A_Name;\n \n-                        --  Capture Link_Name\n-\n                         elsif A_Name = Name_Link_Name then\n                            L_Assoc := Make_Pragma_Argument_Association (Loc,\n-                              Chars      => A_Name,\n+                              Chars => A_Name,\n                               Expression => Relocate_Node (Expression (A)));\n \n-                        --  Capture External_Name\n-\n                         elsif A_Name = Name_External_Name then\n                            E_Assoc := Make_Pragma_Argument_Association (Loc,\n-                              Chars      => A_Name,\n+                              Chars => A_Name,\n                               Expression => Relocate_Node (Expression (A)));\n                         end if;\n \n                         Next (A);\n                      end loop;\n \n-                     --  Construct pragma\n-\n                      Arg_List := New_List (Relocate_Node (Expr), Ent);\n-\n                      if Present (L_Assoc) then\n                         Append_To (Arg_List, L_Assoc);\n                      end if;\n@@ -1296,102 +1159,88 @@ package body Sem_Ch13 is\n                   --  We don't have to play the delay game here, since the only\n                   --  values are ON/OFF which don't get analyzed anyway.\n \n-                  pragma Assert (not Delay_Required);\n+                  Delay_Required := False;\n \n-               --  Default_Value and Default_Component_Value aspects. These\n-               --  are specially handled because they have no corresponding\n-               --  pragmas or attributes.\n+               --  Case 2c: Aspects corresponding to pragmas with three\n+               --  arguments.\n \n-               when Aspect_Default_Value | Aspect_Default_Component_Value =>\n-                  Error_Msg_Name_1 := Chars (Id);\n+               --  Invariant aspects have a first argument that references the\n+               --  entity, a second argument that is the expression and a third\n+               --  argument that is an appropriate message.\n \n-                  if not Is_Type (E) then\n-                     Error_Msg_N (\"aspect% can only apply to a type\", Id);\n-                     goto Continue;\n+               when Aspect_Invariant      |\n+                    Aspect_Type_Invariant =>\n \n-                  elsif not Is_First_Subtype (E) then\n-                     Error_Msg_N (\"aspect% cannot apply to subtype\", Id);\n-                     goto Continue;\n+                  --  Analysis of the pragma will verify placement legality:\n+                  --  an invariant must apply to a private type, or appear in\n+                  --  the private part of a spec and apply to a completion.\n \n-                  elsif A_Id = Aspect_Default_Value\n-                    and then not Is_Scalar_Type (E)\n-                  then\n-                     Error_Msg_N\n-                       (\"aspect% can only be applied to scalar type\", Id);\n-                     goto Continue;\n+                  --  Construct the pragma\n \n-                  elsif A_Id = Aspect_Default_Component_Value then\n-                     if not Is_Array_Type (E) then\n-                        Error_Msg_N\n-                          (\"aspect% can only be applied to array type\", Id);\n-                        goto Continue;\n-                     elsif not Is_Scalar_Type (Component_Type (E)) then\n-                        Error_Msg_N\n-                          (\"aspect% requires scalar components\", Id);\n-                        goto Continue;\n-                     end if;\n+                  Aitem :=\n+                    Make_Pragma (Loc,\n+                      Pragma_Argument_Associations =>\n+                        New_List (Ent, Relocate_Node (Expr)),\n+                      Class_Present                => Class_Present (Aspect),\n+                      Pragma_Identifier            =>\n+                        Make_Identifier (Sloc (Id), Name_Invariant));\n+\n+                  --  Add message unless exception messages are suppressed\n+\n+                  if not Opt.Exception_Locations_Suppressed then\n+                     Append_To (Pragma_Argument_Associations (Aitem),\n+                       Make_Pragma_Argument_Association (Eloc,\n+                         Chars      => Name_Message,\n+                         Expression =>\n+                           Make_String_Literal (Eloc,\n+                             Strval => \"failed invariant from \"\n+                                       & Build_Location_String (Eloc))));\n                   end if;\n \n-                  Aitem := Empty;\n-                  Delay_Required := True;\n+                  --  For Invariant case, insert immediately after the entity\n+                  --  declaration. We do not have to worry about delay issues\n+                  --  since the pragma processing takes care of this.\n+\n                   Set_Is_Delayed_Aspect (Aspect);\n-                  Set_Has_Default_Aspect (Base_Type (Entity (Ent)));\n+                  Delay_Required := False;\n \n-                  if Is_Scalar_Type (E) then\n-                     Set_Default_Aspect_Value (Entity (Ent), Expr);\n-                  else\n-                     Set_Default_Aspect_Component_Value (Entity (Ent), Expr);\n-                  end if;\n+               --  Case 3 : Aspects that don't correspond to pragma/attribute\n+               --  definition clause.\n \n-               when Aspect_Attach_Handler =>\n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Name_Attach_Handler),\n-                      Pragma_Argument_Associations =>\n-                        New_List (Ent, Relocate_Node (Expr)));\n+               --  Case 3a: The aspects listed below don't correspond to\n+               --  pragmas/attributes but do require delayed analysis.\n \n-                  Set_From_Aspect_Specification (Aitem, True);\n-                  Set_Corresponding_Aspect (Aitem, Aspect);\n+               when Aspect_Default_Value           |\n+                    Aspect_Default_Component_Value =>\n+                  Aitem := Empty;\n \n-                  pragma Assert (not Delay_Required);\n+               --  Case 3b: The aspects listed below don't correspond to\n+               --  pragmas/attributes and don't need delayed analysis.\n \n-               when Aspect_Priority           |\n-                    Aspect_Interrupt_Priority |\n-                    Aspect_Dispatching_Domain |\n-                    Aspect_CPU                =>\n-                  declare\n-                     Pname : Name_Id;\n+               --  For Implicit_Dereference, External_Name and Link_Name, only\n+               --  the legality checks are done during the analysis, thus no\n+               --  delay is required.\n \n-                  begin\n-                     if A_Id = Aspect_Priority then\n-                        Pname := Name_Priority;\n+               when Aspect_Implicit_Dereference =>\n+                  Analyze_Aspect_Implicit_Dereference;\n+                  goto Continue;\n \n-                     elsif A_Id = Aspect_Interrupt_Priority then\n-                        Pname := Name_Interrupt_Priority;\n+               when Aspect_External_Name |\n+                    Aspect_Link_Name     =>\n+                  Analyze_Aspect_External_Or_Link_Name;\n+                  goto Continue;\n \n-                     elsif A_Id = Aspect_CPU then\n-                        Pname := Name_CPU;\n+               when Aspect_Dimension =>\n+                  Analyze_Aspect_Dimension (N, Id, Expr);\n+                  goto Continue;\n \n-                     else\n-                        Pname := Name_Dispatching_Domain;\n-                     end if;\n+               when Aspect_Dimension_System =>\n+                  Analyze_Aspect_Dimension_System (N, Id, Expr);\n+                  goto Continue;\n \n-                     Aitem :=\n-                       Make_Pragma (Loc,\n-                           Pragma_Identifier            =>\n-                             Make_Identifier (Sloc (Id), Pname),\n-                           Pragma_Argument_Associations =>\n-                             New_List\n-                               (Make_Pragma_Argument_Association\n-                                  (Sloc       => Sloc (Id),\n-                                   Expression => Relocate_Node (Expr))));\n-\n-                     Set_From_Aspect_Specification (Aitem, True);\n-                     Set_Corresponding_Aspect (Aitem, Aspect);\n-\n-                     pragma Assert (not Delay_Required);\n-                  end;\n+               --  Case 4: Special handling for aspects\n+               --  Pre/Post/Test_Case/Contract_Case whose corresponding pragmas\n+               --  take care of the delay.\n \n                --  Aspects Pre/Post generate Precondition/Postcondition pragmas\n                --  with a first argument that is the expression, and a second\n@@ -1493,97 +1342,6 @@ package body Sem_Ch13 is\n                   goto Continue;\n                end;\n \n-               --  Invariant aspects generate a corresponding pragma with a\n-               --  first argument that is the entity, a second argument that is\n-               --  the expression and a third argument that is an appropriate\n-               --  message. This is inserted right after the declaration, to\n-               --  get the required pragma placement. The pragma processing\n-               --  takes care of the required delay.\n-\n-               when Aspect_Invariant      |\n-                    Aspect_Type_Invariant =>\n-\n-                  --  Analysis of the pragma will verify placement legality:\n-                  --  an invariant must apply to a private type, or appear in\n-                  --  the private part of a spec and apply to a completion.\n-\n-                  --  Construct the pragma\n-\n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Argument_Associations =>\n-                        New_List (Ent, Relocate_Node (Expr)),\n-                      Class_Present                => Class_Present (Aspect),\n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Name_Invariant));\n-\n-                  --  Add message unless exception messages are suppressed\n-\n-                  if not Opt.Exception_Locations_Suppressed then\n-                     Append_To (Pragma_Argument_Associations (Aitem),\n-                       Make_Pragma_Argument_Association (Eloc,\n-                         Chars      => Name_Message,\n-                         Expression =>\n-                           Make_String_Literal (Eloc,\n-                             Strval => \"failed invariant from \"\n-                                       & Build_Location_String (Eloc))));\n-                  end if;\n-\n-                  Set_From_Aspect_Specification (Aitem, True);\n-                  Set_Corresponding_Aspect (Aitem, Aspect);\n-                  Set_Is_Delayed_Aspect (Aspect);\n-\n-                  --  For Invariant case, insert immediately after the entity\n-                  --  declaration. We do not have to worry about delay issues\n-                  --  since the pragma processing takes care of this.\n-\n-                  Insert_After (N, Aitem);\n-                  goto Continue;\n-\n-               --  Predicate aspects generate a corresponding pragma with a\n-               --  first argument that is the entity, and the second argument\n-               --  is the expression.\n-\n-               when Aspect_Dynamic_Predicate |\n-                    Aspect_Predicate         |\n-                    Aspect_Static_Predicate  =>\n-\n-                  --  Construct the pragma (always a pragma Predicate, with\n-                  --  flags recording whether it is static/dynamic).\n-\n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Argument_Associations =>\n-                        New_List (Ent, Relocate_Node (Expr)),\n-                      Class_Present                => Class_Present (Aspect),\n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Name_Predicate));\n-\n-                  Set_From_Aspect_Specification (Aitem, True);\n-                  Set_Corresponding_Aspect (Aitem, Aspect);\n-\n-                  --  Make sure we have a freeze node (it might otherwise be\n-                  --  missing in cases like subtype X is Y, and we would not\n-                  --  have a place to build the predicate function).\n-\n-                  --  If the type is private, indicate that its completion\n-                  --  has a freeze node, because that is the one that will be\n-                  --  visible at freeze time.\n-\n-                  Set_Has_Predicates (E);\n-\n-                  if Is_Private_Type (E)\n-                    and then Present (Full_View (E))\n-                  then\n-                     Set_Has_Predicates (Full_View (E));\n-                     Set_Has_Delayed_Aspects (Full_View (E));\n-                     Ensure_Freeze_Node (Full_View (E));\n-                  end if;\n-\n-                  Ensure_Freeze_Node (E);\n-                  Set_Is_Delayed_Aspect (Aspect);\n-                  Delay_Required := True;\n-\n                when Aspect_Contract_Case |\n                     Aspect_Test_Case     =>\n                   declare\n@@ -1655,188 +1413,195 @@ package body Sem_Ch13 is\n                                     Pragma_Argument_Associations =>\n                                       Args);\n \n-                     Set_From_Aspect_Specification (Aitem, True);\n-                     Set_Corresponding_Aspect (Aitem, Aspect);\n-                     Set_Is_Delayed_Aspect (Aspect);\n-\n-                     --  Insert immediately after the entity declaration\n-\n-                     Insert_After (N, Aitem);\n-\n-                     goto Continue;\n+                     Delay_Required := False;\n                   end;\n \n-               when Aspect_Dimension =>\n-                  Analyze_Aspect_Dimension (N, Id, Expr);\n-                  goto Continue;\n+               --  Case 5: Special handling for aspects with an optional\n+               --  boolean argument.\n \n-               when Aspect_Dimension_System =>\n-                  Analyze_Aspect_Dimension_System (N, Id, Expr);\n-                  goto Continue;\n+               --  In the general case, the corresponding pragma cannot be\n+               --  generated yet because the evaluation of the boolean needs to\n+               --  be delayed til the freeze point.\n \n-               when Aspect_External_Name |\n-                    Aspect_Link_Name     =>\n+               when Boolean_Aspects      |\n+                    Library_Unit_Aspects =>\n \n-                  --  Verify that there is an Import/Export aspect defined for\n-                  --  the entity. The processing of that aspect in turn checks\n-                  --  that there is a Convention aspect declared. The pragma is\n-                  --  constructed when processing the Convention aspect.\n+                  Set_Is_Boolean_Aspect (Aspect);\n \n-                  declare\n-                     A : Node_Id;\n+                  --  Lock_Free aspect only apply to protected objects\n \n-                  begin\n-                     A := First (L);\n-                     while Present (A) loop\n-                        exit when Chars (Identifier (A)) = Name_Export\n-                          or else Chars (Identifier (A)) = Name_Import;\n-                        Next (A);\n-                     end loop;\n-\n-                     if No (A) then\n+                  if A_Id = Aspect_Lock_Free then\n+                     if Ekind (E) /= E_Protected_Type then\n                         Error_Msg_N\n-                          (\"Missing Import/Export for Link/External name\",\n-                               Aspect);\n+                          (\"aspect % only applies to a protected object\",\n+                           Aspect);\n+\n+                     else\n+                        --  Set the Uses_Lock_Free flag to True if there is no\n+                        --  expression or if the expression is True. ??? The\n+                        --  evaluation of this aspect should be delayed to the\n+                        --  freeze point.\n+\n+                        if No (Expr)\n+                          or else Is_True (Static_Boolean (Expr))\n+                        then\n+                           Set_Uses_Lock_Free (E);\n+                        end if;\n                      end if;\n-                  end;\n \n-                  goto Continue;\n-            end case;\n+                     goto Continue;\n \n-            --  If a delay is required, we delay the freeze (not much point in\n-            --  delaying the aspect if we don't delay the freeze!). The pragma\n-            --  or attribute clause if there is one is then attached to the\n-            --  aspect specification which is placed in the rep item list.\n+                  elsif A_Id = Aspect_Import\n+                    or else A_Id = Aspect_Export\n+                  then\n \n-            if Delay_Required then\n-               if Present (Aitem) then\n-                  Set_From_Aspect_Specification (Aitem, True);\n+                     --  Verify that there is an aspect Convention that will\n+                     --  incorporate the Import/Export aspect, and eventual\n+                     --  Link/External names.\n \n-                  if Nkind (Aitem) = N_Pragma then\n-                     Set_Corresponding_Aspect (Aitem, Aspect);\n-                  end if;\n+                     declare\n+                        A : Node_Id;\n \n-                  Set_Is_Delayed_Aspect (Aitem);\n-                  Set_Aspect_Rep_Item (Aspect, Aitem);\n-               end if;\n+                     begin\n+                        A := First (L);\n+                        while Present (A) loop\n+                           exit when Chars (Identifier (A)) = Name_Convention;\n+                           Next (A);\n+                        end loop;\n \n-               Ensure_Freeze_Node (E);\n-               Set_Has_Delayed_Aspects (E);\n-               Record_Rep_Item (E, Aspect);\n+                        if No (A) then\n+                           Error_Msg_N\n+                             (\"missing Convention aspect for Export/Import\",\n+                                 Aspect);\n+                        end if;\n+                     end;\n \n-            --  If no delay required, insert the pragma/clause in the tree\n+                     goto Continue;\n+                  end if;\n \n-            else\n-               Set_From_Aspect_Specification (Aitem, True);\n+                  --  This requires special handling in the case of a package\n+                  --  declaration, the pragma needs to be inserted in the list\n+                  --  of declarations for the associated package. There is no\n+                  --  issue of visibility delay for these aspects.\n \n-               if Nkind (Aitem) = N_Pragma then\n-                  Set_Corresponding_Aspect (Aitem, Aspect);\n-               end if;\n+                  if A_Id in Library_Unit_Aspects\n+                    and then Nkind (N) = N_Package_Declaration\n+                    and then Nkind (Parent (N)) /= N_Compilation_Unit\n+                  then\n+                     Error_Msg_N\n+                        (\"incorrect context for library unit aspect&\", Id);\n+                     goto Continue;\n+                  end if;\n \n-               --  If this is a compilation unit, we will put the pragma in\n-               --  the Pragmas_After list of the N_Compilation_Unit_Aux node.\n+                  --  Special handling when the aspect has no expression. In\n+                  --  this case the value is considered to be True. Thus, we\n+                  --  simply insert the pragma, no delay is required.\n \n-               if Nkind (Parent (Ins_Node)) = N_Compilation_Unit then\n-                  declare\n-                     Aux : constant Node_Id :=\n-                             Aux_Decls_Node (Parent (Ins_Node));\n+                  if No (Expr) then\n+                     Aitem :=\n+                       Make_Pragma (Loc,\n+                         Pragma_Argument_Associations => New_List (Ent),\n+                         Pragma_Identifier            =>\n+                           Make_Identifier (Sloc (Id), Chars (Id)));\n \n-                  begin\n-                     pragma Assert (Nkind (Aux) = N_Compilation_Unit_Aux);\n+                     Delay_Required := False;\n \n-                     if No (Pragmas_After (Aux)) then\n-                        Set_Pragmas_After (Aux, Empty_List);\n-                     end if;\n+                  --  In general cases, the corresponding pragma/attribute\n+                  --  definition clause will be inserted later at the freezing\n+                  --  point.\n \n-                     --  For Pre_Post put at start of list, otherwise at end\n+                  else\n+                     Aitem := Empty;\n+                  end if;\n+            end case;\n \n-                     if A_Id in Pre_Post_Aspects then\n-                        Prepend (Aitem, Pragmas_After (Aux));\n-                     else\n-                        Append (Aitem, Pragmas_After (Aux));\n-                     end if;\n-                  end;\n+            --  Attach the corresponding pragma/attribute definition clause to\n+            --  the aspect specification node.\n \n-               --  Here if not compilation unit case\n+            if Present (Aitem) then\n+               Set_From_Aspect_Specification (Aitem, True);\n \n-               else\n-                  case A_Id is\n+               if Nkind (Aitem) = N_Pragma then\n+                  Set_Corresponding_Aspect (Aitem, Aspect);\n+               end if;\n+            end if;\n \n-                     --  For Pre/Post cases, insert immediately after the\n-                     --  entity declaration, since that is the required pragma\n-                     --  placement.\n+            --  In the context of a compilation unit, we directly put the\n+            --  pragma in the Pragmas_After list of the\n+            --  N_Compilation_Unit_Aux node. No delay is required here.\n \n-                     when Pre_Post_Aspects =>\n-                        Insert_After (N, Aitem);\n+            if Nkind (Parent (N)) = N_Compilation_Unit\n+              and then (Present (Aitem) or else Is_Boolean_Aspect (Aspect))\n+            then\n+               declare\n+                  Aux : constant Node_Id := Aux_Decls_Node (Parent (N));\n \n-                     --  For Priority aspects, insert into the task or\n-                     --  protected definition, which we need to create if it's\n-                     --  not there. The same applies to CPU and\n-                     --  Dispatching_Domain but only to tasks.\n+               begin\n+                  pragma Assert (Nkind (Aux) = N_Compilation_Unit_Aux);\n \n-                     when Aspect_Priority           |\n-                          Aspect_Interrupt_Priority |\n-                          Aspect_Dispatching_Domain |\n-                          Aspect_CPU                =>\n-                        declare\n-                           T : Node_Id; -- the type declaration\n-                           L : List_Id; -- list of decls of task/protected\n+                  --  For a Boolean aspect, create the corresponding pragma if\n+                  --  no expression or if the value is True.\n \n-                        begin\n-                           if Nkind (N) = N_Object_Declaration then\n-                              T := Parent (Etype (Defining_Identifier (N)));\n-                           else\n-                              T := N;\n-                           end if;\n+                  if Is_Boolean_Aspect (Aspect)\n+                    and then No (Aitem)\n+                  then\n+                     if Is_True (Static_Boolean (Expr)) then\n+                        Aitem :=\n+                          Make_Pragma (Loc,\n+                            Pragma_Argument_Associations => New_List (Ent),\n+                            Pragma_Identifier            =>\n+                              Make_Identifier (Sloc (Id), Chars (Id)));\n \n-                           if Nkind (T) = N_Protected_Type_Declaration\n-                             and then A_Id /= Aspect_Dispatching_Domain\n-                             and then A_Id /= Aspect_CPU\n-                           then\n-                              pragma Assert\n-                                (Present (Protected_Definition (T)));\n-\n-                              L := Visible_Declarations\n-                                     (Protected_Definition (T));\n-\n-                           elsif Nkind (T) = N_Task_Type_Declaration then\n-                              if No (Task_Definition (T)) then\n-                                 Set_Task_Definition\n-                                   (T,\n-                                    Make_Task_Definition\n-                                      (Sloc (T),\n-                                       Visible_Declarations => New_List,\n-                                       End_Label => Empty));\n-                              end if;\n+                        Set_From_Aspect_Specification (Aitem, True);\n+                        Set_Corresponding_Aspect (Aitem, Aspect);\n+\n+                     else\n+                        goto Continue;\n+                     end if;\n+                  end if;\n \n-                              L := Visible_Declarations (Task_Definition (T));\n+                  if No (Pragmas_After (Aux)) then\n+                     Set_Pragmas_After (Aux, Empty_List);\n+                  end if;\n \n-                           else\n-                              raise Program_Error;\n-                           end if;\n+                  Append (Aitem, Pragmas_After (Aux));\n+                  goto Continue;\n+               end;\n+            end if;\n \n-                           Prepend (Aitem, To => L);\n+            --  The evaluation of the aspect is delayed to the freezing point.\n+            --  The pragma or attribute clause if there is one is then attached\n+            --  to the aspect specification which is placed in the rep item\n+            --  list.\n \n-                           --  Analyze rewritten pragma. Otherwise, its\n-                           --  analysis is done too late, after the task or\n-                           --  protected object has been created.\n+            if Delay_Required then\n+               if Present (Aitem) then\n+                  Set_Is_Delayed_Aspect (Aitem);\n+                  Set_Aspect_Rep_Item (Aspect, Aitem);\n+                  Set_Parent (Aitem, Aspect);\n+               end if;\n \n-                           Analyze (Aitem);\n-                        end;\n+               Set_Is_Delayed_Aspect (Aspect);\n+               Set_Has_Delayed_Aspects (E);\n+               Record_Rep_Item (E, Aspect);\n \n-                     --  For all other cases, insert in sequence\n+            --  When delay is not required and the context is not a compilation\n+            --  unit, we simply insert the pragma/attribute definition clause\n+            --  in sequence.\n \n-                     when others =>\n-                        Insert_After (Ins_Node, Aitem);\n-                        Ins_Node := Aitem;\n-                  end case;\n-               end if;\n+            else\n+               Insert_After (Ins_Node, Aitem);\n+               Ins_Node := Aitem;\n             end if;\n          end;\n \n       <<Continue>>\n          Next (Aspect);\n       end loop Aspect_Loop;\n+\n+      if Has_Delayed_Aspects (E) then\n+         Ensure_Freeze_Node (E);\n+      end if;\n    end Analyze_Aspect_Specifications;\n \n    -----------------------\n@@ -2293,18 +2058,29 @@ package body Sem_Ch13 is\n             return False;\n          end if;\n \n-         --  Otherwise current clause may duplicate previous clause or a\n-         --  previously given aspect specification for the same aspect.\n+         --  Otherwise current clause may duplicate previous clause, or a\n+         --  previously given pragma or aspect specification for the same\n+         --  aspect.\n \n          A := Get_Rep_Item_For_Entity (U_Ent, Chars (N));\n \n          if Present (A) then\n-            if Entity (A) = U_Ent then\n-               Error_Msg_Name_1 := Chars (N);\n-               Error_Msg_Sloc := Sloc (A);\n+            Error_Msg_Name_1 := Chars (N);\n+            Error_Msg_Sloc := Sloc (A);\n+\n+            if Nkind (A) = N_Aspect_Specification\n+              or else From_Aspect_Specification (A)\n+            then\n                Error_Msg_NE (\"aspect% for & previously given#\", N, U_Ent);\n-               return True;\n+\n+            elsif Nkind (A) = N_Pragma then\n+               Error_Msg_NE (\"clause% for & duplicates pragma#\", N, U_Ent);\n+\n+            else\n+               Error_Msg_NE (\"clause% for & duplicates clause#\", N, U_Ent);\n             end if;\n+\n+            return True;\n          end if;\n \n          return False;\n@@ -2436,9 +2212,13 @@ package body Sem_Ch13 is\n       if Etype (Nam) = Any_Type then\n          return;\n \n-      --  Must be declared in current scope\n+      --  Must be declared in current scope or in case of an aspect\n+      --  specification, must be the current scope.\n \n-      elsif Scope (Ent) /= Current_Scope then\n+      elsif Scope (Ent) /= Current_Scope\n+        and then (not From_Aspect_Specification (N)\n+                   or else Ent /= Current_Scope)\n+      then\n          Error_Msg_N (\"entity must be declared in this scope\", Nam);\n          return;\n \n@@ -2963,6 +2743,44 @@ package body Sem_Ch13 is\n          when Attribute_Constant_Indexing =>\n             Check_Indexing_Functions;\n \n+         ---------\n+         -- CPU --\n+         ---------\n+\n+         when Attribute_CPU => CPU :\n+         begin\n+            --  CPU attribute definition clause not allowed except from aspect\n+            --  specification.\n+\n+            if From_Aspect_Specification (N) then\n+               if not Is_Task_Type (U_Ent) then\n+                  Error_Msg_N (\"CPU can only be defined for task\", Nam);\n+\n+               elsif Duplicate_Clause then\n+                  null;\n+\n+               else\n+                  --  The expression must be analyzed in the special manner\n+                  --  described in \"Handling of Default and Per-Object\n+                  --  Expressions\" in sem.ads.\n+\n+                  --  The visibility to the discriminants must be restored\n+\n+                  Push_Scope_And_Install_Discriminants (U_Ent);\n+                  Preanalyze_Spec_Expression (Expr, RTE (RE_CPU_Range));\n+                  Uninstall_Discriminants_And_Pop_Scope (U_Ent);\n+\n+                  if not Is_Static_Expression (Expr) then\n+                     Check_Restriction (Static_Priorities, Expr);\n+                  end if;\n+               end if;\n+\n+            else\n+               Error_Msg_N\n+                 (\"attribute& cannot be set with definition clause\", N);\n+            end if;\n+         end CPU;\n+\n          ----------------------\n          -- Default_Iterator --\n          ----------------------\n@@ -2996,6 +2814,45 @@ package body Sem_Ch13 is\n             end if;\n          end Default_Iterator;\n \n+         ------------------------\n+         -- Dispatching_Domain --\n+         ------------------------\n+\n+         when Attribute_Dispatching_Domain => Dispatching_Domain :\n+         begin\n+            --  Dispatching_Domain attribute definition clause not allowed\n+            --  except from aspect specification.\n+\n+            if From_Aspect_Specification (N) then\n+               if not Is_Task_Type (U_Ent) then\n+                  Error_Msg_N (\"Dispatching_Domain can only be defined\" &\n+                               \"for task\",\n+                               Nam);\n+\n+               elsif Duplicate_Clause then\n+                  null;\n+\n+               else\n+                  --  The expression must be analyzed in the special manner\n+                  --  described in \"Handling of Default and Per-Object\n+                  --  Expressions\" in sem.ads.\n+\n+                  --  The visibility to the discriminants must be restored\n+\n+                  Push_Scope_And_Install_Discriminants (U_Ent);\n+\n+                  Preanalyze_Spec_Expression\n+                    (Expr, RTE (RE_Dispatching_Domain));\n+\n+                  Uninstall_Discriminants_And_Pop_Scope (U_Ent);\n+               end if;\n+\n+            else\n+               Error_Msg_N\n+                 (\"attribute& cannot be set with definition clause\", N);\n+            end if;\n+         end Dispatching_Domain;\n+\n          ------------------\n          -- External_Tag --\n          ------------------\n@@ -3055,6 +2912,48 @@ package body Sem_Ch13 is\n             Analyze_Stream_TSS_Definition (TSS_Stream_Input);\n             Set_Has_Specified_Stream_Input (Ent);\n \n+         ------------------------\n+         -- Interrupt_Priority --\n+         ------------------------\n+\n+         when Attribute_Interrupt_Priority => Interrupt_Priority :\n+         begin\n+            --  Interrupt_Priority attribute definition clause not allowed\n+            --  except from aspect specification.\n+\n+            if From_Aspect_Specification (N) then\n+               if not (Is_Protected_Type (U_Ent)\n+                        or else Is_Task_Type (U_Ent))\n+               then\n+                  Error_Msg_N\n+                    (\"Interrupt_Priority can only be defined for task\" &\n+                     \"and protected object\",\n+                     Nam);\n+\n+               elsif Duplicate_Clause then\n+                  null;\n+\n+               else\n+                  --  The expression must be analyzed in the special manner\n+                  --  described in \"Handling of Default and Per-Object\n+                  --  Expressions\" in sem.ads.\n+\n+                  --  The visibility to the discriminants must be restored\n+\n+                  Push_Scope_And_Install_Discriminants (U_Ent);\n+\n+                  Preanalyze_Spec_Expression\n+                    (Expr, RTE (RE_Interrupt_Priority));\n+\n+                  Uninstall_Discriminants_And_Pop_Scope (U_Ent);\n+               end if;\n+\n+            else\n+               Error_Msg_N\n+                 (\"attribute& cannot be set with definition clause\", N);\n+            end if;\n+         end Interrupt_Priority;\n+\n          ----------------------\n          -- Iterator_Element --\n          ----------------------\n@@ -3147,6 +3046,49 @@ package body Sem_Ch13 is\n             Analyze_Stream_TSS_Definition (TSS_Stream_Output);\n             Set_Has_Specified_Stream_Output (Ent);\n \n+         --------------\n+         -- Priority --\n+         --------------\n+\n+         when Attribute_Priority => Priority :\n+         begin\n+            --  Priority attribute definition clause not allowed except from\n+            --  aspect specification.\n+\n+            if From_Aspect_Specification (N) then\n+               if not (Is_Protected_Type (U_Ent)\n+                        or else Is_Task_Type (U_Ent))\n+               then\n+                  Error_Msg_N\n+                    (\"Priority can only be defined for task and protected\" &\n+                     \"object\",\n+                     Nam);\n+\n+               elsif Duplicate_Clause then\n+                  null;\n+\n+               else\n+                  --  The expression must be analyzed in the special manner\n+                  --  described in \"Handling of Default and Per-Object\n+                  --  Expressions\" in sem.ads.\n+\n+                  --  The visibility to the discriminants must be restored\n+\n+                  Push_Scope_And_Install_Discriminants (U_Ent);\n+                  Preanalyze_Spec_Expression (Expr, Standard_Integer);\n+                  Uninstall_Discriminants_And_Pop_Scope (U_Ent);\n+\n+                  if not Is_Static_Expression (Expr) then\n+                     Check_Restriction (Static_Priorities, Expr);\n+                  end if;\n+               end if;\n+\n+            else\n+               Error_Msg_N\n+                 (\"attribute& cannot be set with definition clause\", N);\n+            end if;\n+         end Priority;\n+\n          ----------\n          -- Read --\n          ----------\n@@ -3508,7 +3450,6 @@ package body Sem_Ch13 is\n \n          when Attribute_Storage_Size => Storage_Size : declare\n             Btype : constant Entity_Id := Base_Type (U_Ent);\n-            Sprag : Node_Id;\n \n          begin\n             if Is_Task_Type (U_Ent) then\n@@ -3551,16 +3492,6 @@ package body Sem_Ch13 is\n                   then\n                      Set_No_Pool_Assigned (Btype);\n                   end if;\n-\n-               else -- Is_Task_Type (U_Ent)\n-                  Sprag := Get_Rep_Pragma (Btype, Name_Storage_Size);\n-\n-                  if Present (Sprag) then\n-                     Error_Msg_Sloc := Sloc (Sprag);\n-                     Error_Msg_N\n-                       (\"Storage_Size already specified#\", Nam);\n-                     return;\n-                  end if;\n                end if;\n \n                Set_Has_Storage_Size_Clause (Btype);\n@@ -4221,7 +4152,14 @@ package body Sem_Ch13 is\n       --  the subtype name in the saved expression so that they will not cause\n       --  trouble in the preanalysis.\n \n-      if Has_Delayed_Aspects (E) then\n+      if Has_Delayed_Aspects (E)\n+        and then Scope (E) = Current_Scope\n+      then\n+         --  Retrieve the visibility to the discriminants in order to properly\n+         --  analyze the aspects.\n+\n+         Push_Scope_And_Install_Discriminants (E);\n+\n          declare\n             Ritem : Node_Id;\n \n@@ -4233,14 +4171,15 @@ package body Sem_Ch13 is\n                if Nkind (Ritem) = N_Aspect_Specification\n                  and then Entity (Ritem) = E\n                  and then Is_Delayed_Aspect (Ritem)\n-                 and then Scope (E) = Current_Scope\n                then\n                   Check_Aspect_At_Freeze_Point (Ritem);\n                end if;\n \n                Next_Rep_Item (Ritem);\n             end loop;\n          end;\n+\n+         Uninstall_Discriminants_And_Pop_Scope (E);\n       end if;\n    end Analyze_Freeze_Entity;\n \n@@ -6185,18 +6124,17 @@ package body Sem_Ch13 is\n    procedure Check_Aspect_At_End_Of_Declarations (ASN : Node_Id) is\n       Ent   : constant Entity_Id := Entity     (ASN);\n       Ident : constant Node_Id   := Identifier (ASN);\n-\n-      Freeze_Expr : constant Node_Id := Expression (ASN);\n-      --  Expression from call to Check_Aspect_At_Freeze_Point\n+      A_Id  : constant Aspect_Id := Get_Aspect_Id (Chars (Ident));\n \n       End_Decl_Expr : constant Node_Id := Entity (Ident);\n       --  Expression to be analyzed at end of declarations\n \n+      Freeze_Expr : constant Node_Id := Expression (ASN);\n+      --  Expression from call to Check_Aspect_At_Freeze_Point\n+\n       T : constant Entity_Id := Etype (Freeze_Expr);\n       --  Type required for preanalyze call\n \n-      A_Id : constant Aspect_Id := Get_Aspect_Id (Chars (Ident));\n-\n       Err : Boolean;\n       --  Set False if error\n \n@@ -6206,9 +6144,14 @@ package body Sem_Ch13 is\n       --  preanalyzed just after the freeze point.\n \n    begin\n+      --  Case of aspects Dimension, Dimension_System and Synchronization\n+\n+      if A_Id = Aspect_Synchronization then\n+         return;\n+\n       --  Case of stream attributes, just have to compare entities\n \n-      if A_Id = Aspect_Input  or else\n+      elsif A_Id = Aspect_Input  or else\n          A_Id = Aspect_Output or else\n          A_Id = Aspect_Read   or else\n          A_Id = Aspect_Write\n@@ -6286,11 +6229,11 @@ package body Sem_Ch13 is\n       Ident : constant Node_Id := Identifier (ASN);\n       --  Identifier (use Entity field to save expression)\n \n-      T : Entity_Id;\n-      --  Type required for preanalyze call\n-\n       A_Id : constant Aspect_Id := Get_Aspect_Id (Chars (Ident));\n \n+      T    : Entity_Id := Empty;\n+      --  Type required for preanalyze call\n+\n    begin\n       --  On entry to this procedure, Entity (Ident) contains a copy of the\n       --  original expression from the aspect, saved for this purpose.\n@@ -6312,34 +6255,17 @@ package body Sem_Ch13 is\n          when No_Aspect =>\n             raise Program_Error;\n \n-         --  Library unit aspects should be impossible (never delayed)\n-\n-         when Library_Unit_Aspects =>\n-            raise Program_Error;\n-\n-         --  Aspects taking an optional boolean argument. Should be impossible\n-         --  since these are never delayed.\n-\n-         when Boolean_Aspects =>\n-            raise Program_Error;\n-\n-         --  Contract_Case aspects apply to subprograms, hence should never be\n-         --  delayed.\n-\n-         when Aspect_Contract_Case =>\n-            raise Program_Error;\n-\n-         --  Test_Case aspects apply to entries and subprograms, hence should\n-         --  never be delayed.\n+         --  Aspects taking an optional boolean argument.\n \n-         when Aspect_Test_Case =>\n-            raise Program_Error;\n+         when Boolean_Aspects      |\n+              Library_Unit_Aspects =>\n+            T := Standard_Boolean;\n \n          when Aspect_Attach_Handler =>\n             T := RTE (RE_Interrupt_ID);\n \n          when Aspect_Convention =>\n-            null;\n+            return;\n \n          --  Default_Value is resolved with the type entity in question\n \n@@ -6400,13 +6326,19 @@ package body Sem_Ch13 is\n               Aspect_Value_Size     =>\n             T := Any_Integer;\n \n-         --  Stream attribute. Special case, the expression is just an entity\n+         when Aspect_Synchronization =>\n+            return;\n+\n+         --  Special case, the expression of these aspects is just an entity\n          --  that does not need any resolution, so just analyze.\n \n-         when Aspect_Input  |\n-              Aspect_Output |\n-              Aspect_Read   |\n-              Aspect_Write  =>\n+         when Aspect_Input           |\n+              Aspect_Output          |\n+              Aspect_Read            |\n+              Aspect_Suppress        |\n+              Aspect_Unsuppress      |\n+              Aspect_Warnings        |\n+              Aspect_Write           =>\n             Analyze (Expression (ASN));\n             return;\n \n@@ -6416,34 +6348,30 @@ package body Sem_Ch13 is\n          when Aspect_Constant_Indexing    |\n               Aspect_Default_Iterator     |\n               Aspect_Iterator_Element     |\n-              Aspect_Implicit_Dereference |\n               Aspect_Variable_Indexing    =>\n             Analyze (Expression (ASN));\n             return;\n \n-         --  Suppress/Unsuppress/Synchronization/Warnings should not be delayed\n-\n-         when Aspect_Suppress        |\n-              Aspect_Unsuppress      |\n-              Aspect_Synchronization |\n-              Aspect_Warnings        =>\n-            raise Program_Error;\n-\n-         --  Pre/Post/Invariant/Predicate take boolean expressions\n+         --  Invariant/Predicate take boolean expressions\n \n          when Aspect_Dynamic_Predicate |\n               Aspect_Invariant         |\n-              Aspect_Pre               |\n-              Aspect_Precondition      |\n-              Aspect_Post              |\n-              Aspect_Postcondition     |\n               Aspect_Predicate         |\n               Aspect_Static_Predicate  |\n               Aspect_Type_Invariant    =>\n             T := Standard_Boolean;\n \n-         when Aspect_Dimension        |\n-              Aspect_Dimension_System =>\n+         --  Here is the list of aspects that don't require delay analysis.\n+\n+         when Aspect_Contract_Case        |\n+              Aspect_Dimension            |\n+              Aspect_Dimension_System     |\n+              Aspect_Implicit_Dereference |\n+              Aspect_Post                 |\n+              Aspect_Postcondition        |\n+              Aspect_Pre                  |\n+              Aspect_Precondition         |\n+              Aspect_Test_Case     =>\n             raise Program_Error;\n \n       end case;\n@@ -7661,6 +7589,227 @@ package body Sem_Ch13 is\n       end if;\n    end Check_Size;\n \n+   --------------------------------------\n+   -- Evaluate_Aspects_At_Freeze_Point --\n+   --------------------------------------\n+\n+   procedure Evaluate_Aspects_At_Freeze_Point (E : Entity_Id) is\n+      ASN   : Node_Id;\n+      A_Id  : Aspect_Id;\n+      Ritem : Node_Id;\n+\n+      procedure Analyze_Aspect_Default_Value (ASN : Node_Id);\n+      --  This routine analyzes an Aspect_Default_Value or\n+      --  Aspect_Default_Component_Value denoted by the aspect specification\n+      --  node ASN.\n+\n+      procedure Make_Pragma_From_Boolean_Aspect (ASN : Node_Id);\n+      --  Given an aspect specification node ASN whose expression is an\n+      --  optional Boolean, this routines creates the corresponding pragma at\n+      --  the freezing point.\n+\n+      ----------------------------------\n+      -- Analyze_Aspect_Default_Value --\n+      ----------------------------------\n+\n+      procedure Analyze_Aspect_Default_Value (ASN : Node_Id) is\n+         Ent  : constant Entity_Id := Entity (ASN);\n+         Expr : constant Node_Id   := Expression (ASN);\n+         Id   : constant Node_Id   := Identifier (ASN);\n+\n+      begin\n+         Error_Msg_Name_1 := Chars (Id);\n+\n+         if not Is_Type (Ent) then\n+            Error_Msg_N (\"aspect% can only apply to a type\", Id);\n+            return;\n+\n+         elsif not Is_First_Subtype (Ent) then\n+            Error_Msg_N (\"aspect% cannot apply to subtype\", Id);\n+            return;\n+\n+         elsif A_Id = Aspect_Default_Value\n+           and then not Is_Scalar_Type (Ent)\n+         then\n+            Error_Msg_N (\"aspect% can only be applied to scalar type\", Id);\n+            return;\n+\n+         elsif A_Id = Aspect_Default_Component_Value then\n+            if not Is_Array_Type (Ent) then\n+               Error_Msg_N (\"aspect% can only be applied to array type\", Id);\n+               return;\n+\n+            elsif not Is_Scalar_Type (Component_Type (Ent)) then\n+               Error_Msg_N (\"aspect% requires scalar components\", Id);\n+               return;\n+            end if;\n+         end if;\n+\n+         Set_Has_Default_Aspect (Base_Type (Ent));\n+\n+         if Is_Scalar_Type (Ent) then\n+            Set_Default_Aspect_Value (Ent, Expr);\n+         else\n+            Set_Default_Aspect_Component_Value (Ent, Expr);\n+         end if;\n+      end Analyze_Aspect_Default_Value;\n+\n+      -------------------------------------\n+      -- Make_Pragma_From_Boolean_Aspect --\n+      -------------------------------------\n+\n+      procedure Make_Pragma_From_Boolean_Aspect (ASN : Node_Id) is\n+         Ident  : constant Node_Id    := Identifier (ASN);\n+         A_Name : constant Name_Id    := Chars (Ident);\n+         A_Id   : constant Aspect_Id  := Get_Aspect_Id (A_Name);\n+         Ent    : constant Entity_Id  := Entity (ASN);\n+         Expr   : constant Node_Id    := Expression (ASN);\n+         Loc    : constant Source_Ptr := Sloc (ASN);\n+\n+         Prag : Node_Id;\n+\n+         procedure Check_False_Aspect_For_Derived_Type;\n+         --  This procedure checks for the case of a false aspect for a derived\n+         --  type, which improperly tries to cancel an aspect inherited from\n+         --  the parent.\n+\n+         -----------------------------------------\n+         -- Check_False_Aspect_For_Derived_Type --\n+         -----------------------------------------\n+\n+         procedure Check_False_Aspect_For_Derived_Type is\n+            Par : Node_Id;\n+\n+         begin\n+            --  We are only checking derived types\n+\n+            if not Is_Derived_Type (E) then\n+               return;\n+            end if;\n+\n+            Par := Nearest_Ancestor (E);\n+\n+            case A_Id is\n+               when Aspect_Atomic | Aspect_Shared =>\n+                  if not Is_Atomic (Par) then\n+                     return;\n+                  end if;\n+\n+               when Aspect_Atomic_Components =>\n+                  if not Has_Atomic_Components (Par) then\n+                     return;\n+                  end if;\n+\n+               when Aspect_Discard_Names =>\n+                  if not Discard_Names (Par) then\n+                     return;\n+                  end if;\n+\n+               when Aspect_Pack =>\n+                  if not Is_Packed (Par) then\n+                     return;\n+                  end if;\n+\n+               when Aspect_Unchecked_Union =>\n+                  if not Is_Unchecked_Union (Par) then\n+                     return;\n+                  end if;\n+\n+               when Aspect_Volatile =>\n+                  if not Is_Volatile (Par) then\n+                     return;\n+                  end if;\n+\n+               when Aspect_Volatile_Components =>\n+                  if not Has_Volatile_Components (Par) then\n+                     return;\n+                  end if;\n+\n+               when others =>\n+                  return;\n+            end case;\n+\n+            --  Fall through means we are canceling an inherited aspect\n+\n+            Error_Msg_Name_1 := A_Name;\n+            Error_Msg_NE (\"derived type& inherits aspect%, cannot cancel\",\n+                          Expr,\n+                          E);\n+\n+         end Check_False_Aspect_For_Derived_Type;\n+\n+      --  Start of processing for Make_Pragma_From_Boolean_Aspect\n+\n+      begin\n+         if Is_False (Static_Boolean (Expr)) then\n+            Check_False_Aspect_For_Derived_Type;\n+\n+         else\n+            Prag :=\n+              Make_Pragma (Loc,\n+                Pragma_Argument_Associations => New_List (\n+                  New_Occurrence_Of (Ent, Sloc (Ident))),\n+                Pragma_Identifier            =>\n+                  Make_Identifier (Sloc (Ident), Chars (Ident)));\n+\n+            Set_From_Aspect_Specification (Prag, True);\n+            Set_Corresponding_Aspect (Prag, ASN);\n+            Set_Aspect_Rep_Item (ASN, Prag);\n+            Set_Is_Delayed_Aspect (Prag);\n+            Set_Parent (Prag, ASN);\n+         end if;\n+\n+      end Make_Pragma_From_Boolean_Aspect;\n+\n+   --  Start of processing for Evaluate_Aspects_At_Freeze_Point\n+\n+   begin\n+      --  Must be declared in current scope\n+\n+      if Scope (E) /= Current_Scope then\n+         return;\n+      end if;\n+\n+      --  Look for aspect specification entries for this entity\n+\n+      ASN := First_Rep_Item (E);\n+\n+      while Present (ASN) loop\n+         if Nkind (ASN) = N_Aspect_Specification\n+           and then Entity (ASN) = E\n+           and then Is_Delayed_Aspect (ASN)\n+         then\n+            A_Id := Get_Aspect_Id (Chars (Identifier (ASN)));\n+\n+            case A_Id is\n+               --  For aspects whose expression is an optional Boolean, make\n+               --  the corresponding pragma at the freezing point.\n+\n+               when Boolean_Aspects      |\n+                    Library_Unit_Aspects =>\n+                  Make_Pragma_From_Boolean_Aspect (ASN);\n+\n+               --  Special handling for aspects that don't correspond to\n+               --  pragmas/attributes.\n+\n+               when Aspect_Default_Value           |\n+                    Aspect_Default_Component_Value =>\n+                  Analyze_Aspect_Default_Value (ASN);\n+\n+               when others => null;\n+            end case;\n+\n+            Ritem := Aspect_Rep_Item (ASN);\n+\n+            if Present (Ritem) then\n+               Analyze (Ritem);\n+            end if;\n+         end if;\n+\n+         Next_Rep_Item (ASN);\n+      end loop;\n+   end Evaluate_Aspects_At_Freeze_Point;\n+\n    -------------------------\n    -- Get_Alignment_Value --\n    -------------------------"}, {"sha": "136e3755a86db672294fbf220d43d0533a5f7ae3", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -237,7 +237,7 @@ package Sem_Ch13 is\n    --  The visibility of aspects is tricky. First, the visibility is delayed\n    --  to the freeze point. This is not too complicated, what we do is simply\n    --  to leave the aspect \"laying in wait\" for the freeze point, and at that\n-   --  point materialize and analye the corresponding attribute definition\n+   --  point materialize and analyze the corresponding attribute definition\n    --  clause or pragma. There is some special processing for preconditions\n    --  and postonditions, where the pragmas themselves deal with the required\n    --  delay, but basically the approach is the same, delay analysis of the\n@@ -307,4 +307,8 @@ package Sem_Ch13 is\n    --  Performs the processing described above at the freeze all point, and\n    --  issues appropriate error messages if the visibility has indeed changed.\n    --  Again, ASN is the N_Aspect_Specification node for the aspect.\n+\n+   procedure Evaluate_Aspects_At_Freeze_Point (E : Entity_Id);\n+   --  This routines evaluates all the delayed aspects for entity E at freezing\n+   --  point.\n end Sem_Ch13;"}, {"sha": "ced4d51640d8ffb2816799375742407400658adb", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 87, "deletions": 4, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -111,10 +111,6 @@ package body Sem_Ch9 is\n    --  Find entity in corresponding task or protected declaration. Use full\n    --  view if first declaration was for an incomplete type.\n \n-   procedure Install_Declarations (Spec : Entity_Id);\n-   --  Utility to make visible in corresponding body the entities defined in\n-   --  task, protected type declaration, or entry declaration.\n-\n    -------------------------------------\n    -- Allows_Lock_Free_Implementation --\n    -------------------------------------\n@@ -2983,4 +2979,91 @@ package body Sem_Ch9 is\n       end loop;\n    end Install_Declarations;\n \n+   ---------------------------\n+   -- Install_Discriminants --\n+   ---------------------------\n+\n+   procedure Install_Discriminants (E : Entity_Id) is\n+      Disc : Entity_Id;\n+      Prev : Entity_Id;\n+   begin\n+      Disc := First_Discriminant (E);\n+      while Present (Disc) loop\n+         Prev := Current_Entity (Disc);\n+         Set_Current_Entity (Disc);\n+         Set_Is_Immediately_Visible (Disc);\n+         Set_Homonym (Disc, Prev);\n+         Next_Discriminant (Disc);\n+      end loop;\n+   end Install_Discriminants;\n+\n+   ------------------------------------------\n+   -- Push_Scope_And_Install_Discriminants --\n+   ------------------------------------------\n+\n+   procedure Push_Scope_And_Install_Discriminants (E : Entity_Id) is\n+   begin\n+      if Has_Discriminants (E) then\n+         Push_Scope (E);\n+         Install_Discriminants (E);\n+      end if;\n+   end Push_Scope_And_Install_Discriminants;\n+\n+   -----------------------------\n+   -- Uninstall_Discriminants --\n+   -----------------------------\n+\n+   procedure Uninstall_Discriminants (E : Entity_Id) is\n+      Disc  : Entity_Id;\n+      Prev  : Entity_Id;\n+      Outer : Entity_Id;\n+\n+   begin\n+      Disc := First_Discriminant (E);\n+      while Present (Disc) loop\n+         if Disc /= Current_Entity (Disc) then\n+            Prev := Current_Entity (Disc);\n+            while Present (Prev)\n+              and then Present (Homonym (Prev))\n+              and then Homonym (Prev) /= Disc\n+            loop\n+               Prev := Homonym (Prev);\n+            end loop;\n+         else\n+            Prev := Empty;\n+         end if;\n+\n+         Set_Is_Immediately_Visible (Disc, False);\n+\n+         Outer := Homonym (Disc);\n+         while Present (Outer) and then Scope (Outer) = E loop\n+            Outer := Homonym (Outer);\n+         end loop;\n+\n+         --  Reset homonym link of other entities, but do not modify link\n+         --  between entities in current scope, so that the back-end can have\n+         --  a proper count of local overloadings.\n+\n+         if No (Prev) then\n+            Set_Name_Entity_Id (Chars (Disc), Outer);\n+\n+         elsif Scope (Prev) /= Scope (Disc) then\n+            Set_Homonym (Prev,  Outer);\n+         end if;\n+\n+         Next_Discriminant (Disc);\n+      end loop;\n+   end Uninstall_Discriminants;\n+\n+   -------------------------------------------\n+   -- Uninstall_Discriminants_And_Pop_Scope --\n+   -------------------------------------------\n+\n+   procedure Uninstall_Discriminants_And_Pop_Scope (E : Entity_Id) is\n+   begin\n+      if Has_Discriminants (E) then\n+         Uninstall_Discriminants (E);\n+         Pop_Scope;\n+      end if;\n+   end Uninstall_Discriminants_And_Pop_Scope;\n end Sem_Ch9;"}, {"sha": "63f5bee2dea9f3fdcb8a8db3a630398fa00f0175", "filename": "gcc/ada/sem_ch9.ads", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsem_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsem_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.ads?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -54,6 +54,25 @@ package Sem_Ch9  is\n    procedure Analyze_Timed_Entry_Call                   (N : Node_Id);\n    procedure Analyze_Triggering_Alternative             (N : Node_Id);\n \n+   procedure Install_Declarations (Spec : Entity_Id);\n+   --  Utility to make visible in corresponding body the entities defined in\n+   --  task, protected type declaration, or entry declaration.\n+\n+   procedure Install_Discriminants (E : Entity_Id);\n+   --  Utility to make visible the discriminants of type entity E\n+\n+   procedure Push_Scope_And_Install_Discriminants (E : Entity_Id);\n+   --  Utility that pushes the scope E and makes visible the discriminants of\n+   --  type entity E if E has discriminants.\n+\n+   procedure Uninstall_Discriminants (E : Entity_Id);\n+   --  Utility that removes the visibility to the discriminants of type entity\n+   --  E.\n+\n+   procedure Uninstall_Discriminants_And_Pop_Scope (E : Entity_Id);\n+   --  Utility that removes the visibility to the discriminants of type entity\n+   --  E and pop the scope stack if E has discriminants.\n+\n    ------------------------------\n    -- Lock Free Data Structure --\n    ------------------------------"}, {"sha": "1193b09209efe60eff485b9d89049190b23fadd2", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 100, "deletions": 65, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -571,10 +571,9 @@ package body Sem_Prag is\n       --  error message for bad placement is given.\n \n       procedure Check_Duplicate_Pragma (E : Entity_Id);\n-      --  Check if a pragma of the same name as the current pragma is already\n+      --  Check if a rep item of the same name as the current pragma is already\n       --  chained as a rep pragma to the given entity. If so give a message\n       --  about the duplicate, and then raise Pragma_Exit so does not return.\n-      --  Also checks for delayed aspect specification node in the chain.\n \n       procedure Check_Duplicated_Export_Name (Nam : Node_Id);\n       --  Nam is an N_String_Literal node containing the external name set by\n@@ -1598,7 +1597,8 @@ package body Sem_Prag is\n       ----------------------------\n \n       procedure Check_Duplicate_Pragma (E : Entity_Id) is\n-         P : Node_Id;\n+         Id : Entity_Id := E;\n+         P  : Node_Id;\n \n       begin\n          --  Nothing to do if this pragma comes from an aspect specification,\n@@ -1610,20 +1610,34 @@ package body Sem_Prag is\n          end if;\n \n          --  Otherwise current pragma may duplicate previous pragma or a\n-         --  previously given aspect specification for the same pragma.\n+         --  previously given aspect specification or attribute definition\n+         --  clause for the same pragma.\n \n          P := Get_Rep_Item_For_Entity (E, Pragma_Name (N));\n \n          if Present (P) then\n             Error_Msg_Name_1 := Pragma_Name (N);\n             Error_Msg_Sloc := Sloc (P);\n \n+            --  For a single protected or a single task object, the error is\n+            --  issued on the original entity.\n+\n+            if Ekind (Id) = E_Task_Type\n+              or else Ekind (Id) = E_Protected_Type\n+            then\n+               Id := Defining_Identifier (Original_Node (Parent (Id)));\n+            end if;\n+\n             if Nkind (P) = N_Aspect_Specification\n               or else From_Aspect_Specification (P)\n             then\n-               Error_Msg_NE (\"aspect% for & previously given#\", N, E);\n+               Error_Msg_NE (\"aspect% for & previously given#\", N, Id);\n+\n+            elsif Nkind (P) = N_Pragma then\n+               Error_Msg_NE (\"pragma% for & duplicates pragma#\", N, Id);\n+\n             else\n-               Error_Msg_NE (\"pragma% for & duplicates pragma#\", N, E);\n+               Error_Msg_NE (\"pragma% for & duplicates clause#\", N, Id);\n             end if;\n \n             raise Pragma_Exit;\n@@ -2917,7 +2931,7 @@ package body Sem_Prag is\n       end Pragma_Misplaced;\n \n       ------------------------------------\n-      -- Process Atomic_Shared_Volatile --\n+      -- Process_Atomic_Shared_Volatile --\n       ------------------------------------\n \n       procedure Process_Atomic_Shared_Volatile is\n@@ -6597,6 +6611,7 @@ package body Sem_Prag is\n                end if;\n \n                Set_Is_Ada_2005_Only (Entity (E_Id));\n+               Record_Rep_Item (Entity (E_Id), N);\n \n             else\n                Check_Arg_Count (0);\n@@ -6644,6 +6659,7 @@ package body Sem_Prag is\n                end if;\n \n                Set_Is_Ada_2012_Only (Entity (E_Id));\n+               Record_Rep_Item (Entity (E_Id), N);\n \n             else\n                Check_Arg_Count (0);\n@@ -7149,6 +7165,7 @@ package body Sem_Prag is\n                Error_Pragma_Arg (\"inappropriate entity for pragma%\", Arg1);\n             end if;\n          end Atomic_Components;\n+\n          --------------------\n          -- Attach_Handler --\n          --------------------\n@@ -7931,6 +7948,7 @@ package body Sem_Prag is\n          when Pragma_CPU => CPU : declare\n             P   : constant Node_Id := Parent (N);\n             Arg : Node_Id;\n+            Ent : Entity_Id;\n \n          begin\n             Ada_2012_Pragma;\n@@ -7945,6 +7963,12 @@ package body Sem_Prag is\n                Arg := Get_Pragma_Arg (Arg1);\n                Analyze_And_Resolve (Arg, Any_Integer);\n \n+               Ent := Defining_Unit_Name (Specification (P));\n+\n+               if Nkind (Ent) = N_Defining_Program_Unit_Name then\n+                  Ent := Defining_Identifier (Ent);\n+               end if;\n+\n                --  Must be static\n \n                if not Is_Static_Expression (Arg) then\n@@ -7984,6 +8008,7 @@ package body Sem_Prag is\n \n             elsif Nkind (P) = N_Task_Definition then\n                Arg := Get_Pragma_Arg (Arg1);\n+               Ent := Defining_Identifier (Parent (P));\n \n                --  The expression must be analyzed in the special manner\n                --  described in \"Handling of Default and Per-Object\n@@ -7997,15 +8022,12 @@ package body Sem_Prag is\n                Pragma_Misplaced;\n             end if;\n \n-            if Has_Pragma_CPU (P) then\n-               Error_Pragma (\"duplicate pragma% not allowed\");\n-            else\n-               Set_Has_Pragma_CPU (P, True);\n+            --  Check duplicate pragma before we chain the pragma in the Rep\n+            --  Item chain of Ent.\n \n-               if Nkind (P) = N_Task_Definition then\n-                  Record_Rep_Item (Defining_Identifier (Parent (P)), N);\n-               end if;\n-            end if;\n+            Check_Duplicate_Pragma (Ent);\n+\n+            Record_Rep_Item (Ent, N);\n          end CPU;\n \n          -----------\n@@ -8249,6 +8271,8 @@ package body Sem_Prag is\n                     or else Ekind (E) = E_Exception\n                   then\n                      Set_Discard_Names (E);\n+                     Record_Rep_Item (E, N);\n+\n                   else\n                      Error_Pragma_Arg\n                        (\"inappropriate entity for pragma%\", Arg1);\n@@ -8267,6 +8291,7 @@ package body Sem_Prag is\n          when Pragma_Dispatching_Domain => Dispatching_Domain : declare\n             P   : constant Node_Id := Parent (N);\n             Arg : Node_Id;\n+            Ent : Entity_Id;\n \n          begin\n             Ada_2012_Pragma;\n@@ -8282,28 +8307,26 @@ package body Sem_Prag is\n \n             if Nkind (P) = N_Task_Definition then\n                Arg := Get_Pragma_Arg (Arg1);\n+               Ent := Defining_Identifier (Parent (P));\n \n                --  The expression must be analyzed in the special manner\n                --  described in \"Handling of Default and Per-Object\n                --  Expressions\" in sem.ads.\n \n                Preanalyze_Spec_Expression (Arg, RTE (RE_Dispatching_Domain));\n \n+               --  Check duplicate pragma before we chain the pragma in the Rep\n+               --  Item chain of Ent.\n+\n+               Check_Duplicate_Pragma (Ent);\n+\n+               Record_Rep_Item (Ent, N);\n+\n             --  Anything else is incorrect\n \n             else\n                Pragma_Misplaced;\n             end if;\n-\n-            if Has_Pragma_Dispatching_Domain (P) then\n-               Error_Pragma (\"duplicate pragma% not allowed\");\n-            else\n-               Set_Has_Pragma_Dispatching_Domain (P, True);\n-\n-               if Nkind (P) = N_Task_Definition then\n-                  Record_Rep_Item (Defining_Identifier (Parent (P)), N);\n-               end if;\n-            end if;\n          end Dispatching_Domain;\n \n          ---------------\n@@ -10235,6 +10258,7 @@ package body Sem_Prag is\n          when Pragma_Interrupt_Priority => Interrupt_Priority : declare\n             P   : constant Node_Id := Parent (N);\n             Arg : Node_Id;\n+            Ent : Entity_Id;\n \n          begin\n             Check_Ada_83_Warning;\n@@ -10255,12 +10279,15 @@ package body Sem_Prag is\n                Pragma_Misplaced;\n                return;\n \n-            elsif Has_Pragma_Priority (P) then\n-               Error_Pragma (\"duplicate pragma% not allowed\");\n-\n             else\n-               Set_Has_Pragma_Priority (P, True);\n-               Record_Rep_Item (Defining_Identifier (Parent (P)), N);\n+               Ent := Defining_Identifier (Parent (P));\n+\n+               --  Check duplicate pragma before we chain the pragma in the Rep\n+               --  Item chain of Ent.\n+\n+               Check_Duplicate_Pragma (Ent);\n+\n+               Record_Rep_Item (Ent, N);\n             end if;\n          end Interrupt_Priority;\n \n@@ -12295,6 +12322,7 @@ package body Sem_Prag is\n          when Pragma_Priority => Priority : declare\n             P   : constant Node_Id := Parent (N);\n             Arg : Node_Id;\n+            Ent : Entity_Id;\n \n          begin\n             Check_No_Identifiers;\n@@ -12305,6 +12333,12 @@ package body Sem_Prag is\n             if Nkind (P) = N_Subprogram_Body then\n                Check_In_Main_Program;\n \n+               Ent := Defining_Unit_Name (Specification (P));\n+\n+               if Nkind (Ent) = N_Defining_Program_Unit_Name then\n+                  Ent := Defining_Identifier (Ent);\n+               end if;\n+\n                Arg := Get_Pragma_Arg (Arg1);\n                Analyze_And_Resolve (Arg, Standard_Integer);\n \n@@ -12356,6 +12390,7 @@ package body Sem_Prag is\n \n             elsif Nkind_In (P, N_Protected_Definition, N_Task_Definition) then\n                Arg := Get_Pragma_Arg (Arg1);\n+               Ent := Defining_Identifier (Parent (P));\n \n                --  The expression must be analyzed in the special manner\n                --  described in \"Handling of Default and Per-Object\n@@ -12373,16 +12408,12 @@ package body Sem_Prag is\n                Pragma_Misplaced;\n             end if;\n \n-            if Has_Pragma_Priority (P) then\n-               Error_Pragma (\"duplicate pragma% not allowed\");\n-            else\n-               Set_Has_Pragma_Priority (P, True);\n+            --  Check duplicate pragma before we chain the pragma in the Rep\n+            --  Item chain of Ent.\n \n-               if Nkind_In (P, N_Protected_Definition, N_Task_Definition) then\n-                  Record_Rep_Item (Defining_Identifier (Parent (P)), N);\n-                  --  exp_ch9 should use this ???\n-               end if;\n-            end if;\n+            Check_Duplicate_Pragma (Ent);\n+\n+            Record_Rep_Item (Ent, N);\n          end Priority;\n \n          -----------------------------------\n@@ -12968,26 +12999,24 @@ package body Sem_Prag is\n             if Nkind (P) = N_Subprogram_Body then\n                Check_In_Main_Program;\n \n-            --  Tasks\n+            --  Only Task and subprogram cases allowed\n \n-            elsif Nkind (P) = N_Task_Definition then\n-               null;\n-\n-            --  Anything else is incorrect\n-\n-            else\n+            elsif Nkind (P) /= N_Task_Definition then\n                Pragma_Misplaced;\n             end if;\n \n+            --  Check duplicate pragma before we set the corresponding flag\n+\n             if Has_Relative_Deadline_Pragma (P) then\n                Error_Pragma (\"duplicate pragma% not allowed\");\n-            else\n-               Set_Has_Relative_Deadline_Pragma (P, True);\n-\n-               if Nkind (P) = N_Task_Definition then\n-                  Record_Rep_Item (Defining_Identifier (Parent (P)), N);\n-               end if;\n             end if;\n+\n+            --  Set Has_Relative_Deadline_Pragma only for tasks. Note that\n+            --  Relative_Deadline pragma node cannot be inserted in the Rep\n+            --  Item chain of Ent since it is rewritten by the expander as a\n+            --  procedure call statement that will break the chain.\n+\n+            Set_Has_Relative_Deadline_Pragma (P, True);\n          end Relative_Deadline;\n \n          ------------------------\n@@ -13458,7 +13487,6 @@ package body Sem_Prag is\n                end if;\n \n                Record_Rep_Item (Defining_Identifier (Parent (P)), N);\n-               --  ???  exp_ch9 should use this!\n             end if;\n          end Storage_Size;\n \n@@ -13877,7 +13905,8 @@ package body Sem_Prag is\n          --  pragma Task_Info (EXPRESSION);\n \n          when Pragma_Task_Info => Task_Info : declare\n-            P : constant Node_Id := Parent (N);\n+            P   : constant Node_Id := Parent (N);\n+            Ent : Entity_Id;\n \n          begin\n             GNAT_Pragma;\n@@ -13896,11 +13925,13 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            if Has_Task_Info_Pragma (P) then\n-               Error_Pragma (\"duplicate pragma% not allowed\");\n-            else\n-               Set_Has_Task_Info_Pragma (P, True);\n-            end if;\n+            Ent := Defining_Identifier (Parent (P));\n+\n+            --  Check duplicate pragma before we chain the pragma in the Rep\n+            --  Item chain of Ent.\n+\n+            Check_Duplicate_Pragma (Ent);\n+            Record_Rep_Item (Ent, N);\n          end Task_Info;\n \n          ---------------\n@@ -13912,6 +13943,7 @@ package body Sem_Prag is\n          when Pragma_Task_Name => Task_Name : declare\n             P   : constant Node_Id := Parent (N);\n             Arg : Node_Id;\n+            Ent : Entity_Id;\n \n          begin\n             Check_No_Identifiers;\n@@ -13930,12 +13962,13 @@ package body Sem_Prag is\n                Pragma_Misplaced;\n             end if;\n \n-            if Has_Task_Name_Pragma (P) then\n-               Error_Pragma (\"duplicate pragma% not allowed\");\n-            else\n-               Set_Has_Task_Name_Pragma (P, True);\n-               Record_Rep_Item (Defining_Identifier (Parent (P)), N);\n-            end if;\n+            Ent := Defining_Identifier (Parent (P));\n+\n+            --  Check duplicate pragma before we chain the pragma in the Rep\n+            --  Item chain of Ent.\n+\n+            Check_Duplicate_Pragma (Ent);\n+            Record_Rep_Item (Ent, N);\n          end Task_Name;\n \n          ------------------\n@@ -14143,6 +14176,7 @@ package body Sem_Prag is\n             Check_Arg_Is_Local_Name (Arg1);\n \n             Find_Type (Type_Id);\n+\n             Typ := Entity (Type_Id);\n \n             if Typ = Any_Type\n@@ -14287,6 +14321,7 @@ package body Sem_Prag is\n             end if;\n \n             Set_Universal_Aliasing (Implementation_Base_Type (E_Id));\n+            Record_Rep_Item (E_Id, N);\n          end Universal_Alias;\n \n          --------------------"}, {"sha": "34bd4524b5368ab99821e745b271ede1d09dacf6", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -2259,10 +2259,35 @@ package body Sem_Util is\n             end if;\n \n             if Wmsg then\n+               --  Check whether the context is an Init_Proc\n+\n                if Inside_Init_Proc then\n-                  Error_Msg_NEL\n-                    (\"\\?& will be raised for objects of this type\",\n-                     N, Standard_Constraint_Error, Eloc);\n+                  declare\n+                     Conc_Typ : constant Entity_Id :=\n+                                  Corresponding_Concurrent_Type\n+                                    (Entity (Parameter_Type (First\n+                                      (Parameter_Specifications\n+                                        (Parent (Current_Scope))))));\n+\n+                  begin\n+                     --  Don't complain if the corresponding concurrent type\n+                     --  doesn't come from source (i.e. a single task/protected\n+                     --  object).\n+\n+                     if Present (Conc_Typ)\n+                       and then not Comes_From_Source (Conc_Typ)\n+                     then\n+                        Error_Msg_NEL\n+                          (\"\\?& will be raised at run time\",\n+                           N, Standard_Constraint_Error, Eloc);\n+\n+                     else\n+                        Error_Msg_NEL\n+                          (\"\\?& will be raised for objects of this type\",\n+                           N, Standard_Constraint_Error, Eloc);\n+                     end if;\n+                  end;\n+\n                else\n                   Error_Msg_NEL\n                     (\"\\?& will be raised at run time\","}, {"sha": "d1c1480858a9caa3d8a2611bf2b8f236dac7e775", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -1476,33 +1476,6 @@ package body Sinfo is\n       return Flag17 (N);\n    end Has_No_Elaboration_Code;\n \n-   function Has_Pragma_CPU\n-      (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Subprogram_Body\n-        or else NT (N).Nkind = N_Task_Definition);\n-      return Flag14 (N);\n-   end Has_Pragma_CPU;\n-\n-   function Has_Pragma_Dispatching_Domain\n-     (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Task_Definition);\n-      return Flag15 (N);\n-   end Has_Pragma_Dispatching_Domain;\n-\n-   function Has_Pragma_Priority\n-      (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Protected_Definition\n-        or else NT (N).Nkind = N_Subprogram_Body\n-        or else NT (N).Nkind = N_Task_Definition);\n-      return Flag6 (N);\n-   end Has_Pragma_Priority;\n-\n    function Has_Pragma_Suppress_All\n       (N : Node_Id) return Boolean is\n    begin\n@@ -1549,22 +1522,6 @@ package body Sinfo is\n       return Flag5 (N);\n    end Has_Storage_Size_Pragma;\n \n-   function Has_Task_Info_Pragma\n-      (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Task_Definition);\n-      return Flag7 (N);\n-   end Has_Task_Info_Pragma;\n-\n-   function Has_Task_Name_Pragma\n-      (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Task_Definition);\n-      return Flag8 (N);\n-   end Has_Task_Name_Pragma;\n-\n    function Has_Wide_Character\n       (N : Node_Id) return Boolean is\n    begin\n@@ -4580,33 +4537,6 @@ package body Sinfo is\n       Set_Flag17 (N, Val);\n    end Set_Has_No_Elaboration_Code;\n \n-   procedure Set_Has_Pragma_CPU\n-      (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Subprogram_Body\n-        or else NT (N).Nkind = N_Task_Definition);\n-      Set_Flag14 (N, Val);\n-   end Set_Has_Pragma_CPU;\n-\n-   procedure Set_Has_Pragma_Dispatching_Domain\n-      (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Task_Definition);\n-      Set_Flag15 (N, Val);\n-   end Set_Has_Pragma_Dispatching_Domain;\n-\n-   procedure Set_Has_Pragma_Priority\n-      (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Protected_Definition\n-        or else NT (N).Nkind = N_Subprogram_Body\n-        or else NT (N).Nkind = N_Task_Definition);\n-      Set_Flag6 (N, Val);\n-   end Set_Has_Pragma_Priority;\n-\n    procedure Set_Has_Pragma_Suppress_All\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -4653,22 +4583,6 @@ package body Sinfo is\n       Set_Flag5 (N, Val);\n    end Set_Has_Storage_Size_Pragma;\n \n-   procedure Set_Has_Task_Info_Pragma\n-      (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Task_Definition);\n-      Set_Flag7 (N, Val);\n-   end Set_Has_Task_Info_Pragma;\n-\n-   procedure Set_Has_Task_Name_Pragma\n-      (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Task_Definition);\n-      Set_Flag8 (N, Val);\n-   end Set_Has_Task_Name_Pragma;\n-\n    procedure Set_Has_Wide_Character\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "cfaa82842c983281e28904f0cd7eb22d5f37c8ee", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -1149,16 +1149,6 @@ package Sinfo is\n    --    generate elaboration code, and non-preelaborated packages which do\n    --    not generate elaboration code.\n \n-   --  Has_Pragma_CPU (Flag14-Sem)\n-   --    A flag present in N_Subprogram_Body and N_Task_Definition nodes to\n-   --    flag the presence of a CPU pragma in the declaration sequence (public\n-   --    or private in the task case).\n-\n-   --  Has_Pragma_Dispatching_Domain (Flag15-Sem)\n-   --    A flag present in N_Task_Definition nodes to flag the presence of a\n-   --    Dispatching_Domain pragma in the declaration sequence (public or\n-   --    private in the task case).\n-\n    --  Has_Pragma_Suppress_All (Flag14-Sem)\n    --    This flag is set in an N_Compilation_Unit node if the Suppress_All\n    --    pragma appears anywhere in the unit. This accommodates the rather\n@@ -1168,12 +1158,6 @@ package Sinfo is\n    --    Suppress (All_Checks) appearing at the start of the configuration\n    --    pragmas for the unit.\n \n-   --  Has_Pragma_Priority (Flag6-Sem)\n-   --    A flag present in N_Subprogram_Body, N_Task_Definition and\n-   --    N_Protected_Definition nodes to flag the presence of either a Priority\n-   --    or Interrupt_Priority pragma in the declaration sequence (public or\n-   --    private in the task and protected cases)\n-\n    --  Has_Private_View (Flag11-Sem)\n    --    A flag present in generic nodes that have an entity, to indicate that\n    --    the node has a private type. Used to exchange private and full\n@@ -1194,14 +1178,6 @@ package Sinfo is\n    --    A flag present in an N_Task_Definition node to flag the presence of a\n    --    Storage_Size pragma.\n \n-   --  Has_Task_Info_Pragma (Flag7-Sem)\n-   --    A flag present in an N_Task_Definition node to flag the presence of a\n-   --    Task_Info pragma. Used to detect duplicate pragmas.\n-\n-   --  Has_Task_Name_Pragma (Flag8-Sem)\n-   --    A flag present in N_Task_Definition nodes to flag the presence of a\n-   --    Task_Name pragma in the declaration sequence for the task.\n-\n    --  Has_Wide_Character (Flag11-Sem)\n    --    Present in string literals, set if any wide character (i.e. character\n    --    code outside the Character range but within Wide_Character range)\n@@ -4619,13 +4595,11 @@ package Sinfo is\n       --  Acts_As_Spec (Flag4-Sem)\n       --  Bad_Is_Detected (Flag15) used only by parser\n       --  Do_Storage_Check (Flag17-Sem)\n-      --  Has_Pragma_Priority (Flag6-Sem)\n       --  Is_Protected_Subprogram_Body (Flag7-Sem)\n       --  Is_Entry_Barrier_Function (Flag8-Sem)\n       --  Is_Task_Master (Flag5-Sem)\n       --  Was_Originally_Stub (Flag13-Sem)\n       --  Has_Relative_Deadline_Pragma (Flag9-Sem)\n-      --  Has_Pragma_CPU (Flag14-Sem)\n \n       -------------------------\n       -- Expression Function --\n@@ -5109,13 +5083,8 @@ package Sinfo is\n       --  Visible_Declarations (List2)\n       --  Private_Declarations (List3) (set to No_List if no private part)\n       --  End_Label (Node4)\n-      --  Has_Pragma_Priority (Flag6-Sem)\n       --  Has_Storage_Size_Pragma (Flag5-Sem)\n-      --  Has_Task_Info_Pragma (Flag7-Sem)\n-      --  Has_Task_Name_Pragma (Flag8-Sem)\n       --  Has_Relative_Deadline_Pragma (Flag9-Sem)\n-      --  Has_Pragma_CPU (Flag14-Sem)\n-      --  Has_Pragma_Dispatching_Domain (Flag15-Sem)\n \n       --------------------\n       -- 9.1  Task Item --\n@@ -5200,7 +5169,6 @@ package Sinfo is\n       --  Visible_Declarations (List2)\n       --  Private_Declarations (List3) (set to No_List if no private part)\n       --  End_Label (Node4)\n-      --  Has_Pragma_Priority (Flag6-Sem)\n \n       ------------------------------------------\n       -- 9.4  Protected Operation Declaration --\n@@ -8566,15 +8534,6 @@ package Sinfo is\n    function Has_No_Elaboration_Code\n      (N : Node_Id) return Boolean;    -- Flag17\n \n-   function Has_Pragma_CPU\n-     (N : Node_Id) return Boolean;    -- Flag14\n-\n-   function Has_Pragma_Dispatching_Domain\n-     (N : Node_Id) return Boolean;    -- Flag15\n-\n-   function Has_Pragma_Priority\n-     (N : Node_Id) return Boolean;    -- Flag6\n-\n    function Has_Pragma_Suppress_All\n      (N : Node_Id) return Boolean;    -- Flag14\n \n@@ -8590,12 +8549,6 @@ package Sinfo is\n    function Has_Storage_Size_Pragma\n      (N : Node_Id) return Boolean;    -- Flag5\n \n-   function Has_Task_Info_Pragma\n-     (N : Node_Id) return Boolean;    -- Flag7\n-\n-   function Has_Task_Name_Pragma\n-     (N : Node_Id) return Boolean;    -- Flag8\n-\n    function Has_Wide_Character\n      (N : Node_Id) return Boolean;    -- Flag11\n \n@@ -9556,15 +9509,6 @@ package Sinfo is\n    procedure Set_Has_No_Elaboration_Code\n      (N : Node_Id; Val : Boolean := True);    -- Flag17\n \n-   procedure Set_Has_Pragma_CPU\n-     (N : Node_Id; Val : Boolean := True);    -- Flag14\n-\n-   procedure Set_Has_Pragma_Dispatching_Domain\n-     (N : Node_Id; Val : Boolean := True);    -- Flag15\n-\n-   procedure Set_Has_Pragma_Priority\n-     (N : Node_Id; Val : Boolean := True);    -- Flag6\n-\n    procedure Set_Has_Pragma_Suppress_All\n      (N : Node_Id; Val : Boolean := True);    -- Flag14\n \n@@ -9580,12 +9524,6 @@ package Sinfo is\n    procedure Set_Has_Storage_Size_Pragma\n      (N : Node_Id; Val : Boolean := True);    -- Flag5\n \n-   procedure Set_Has_Task_Info_Pragma\n-     (N : Node_Id; Val : Boolean := True);    -- Flag7\n-\n-   procedure Set_Has_Task_Name_Pragma\n-     (N : Node_Id; Val : Boolean := True);    -- Flag8\n-\n    procedure Set_Has_Wide_Character\n      (N : Node_Id; Val : Boolean := True);    -- Flag11\n \n@@ -11990,15 +11928,10 @@ package Sinfo is\n    pragma Inline (Has_Local_Raise);\n    pragma Inline (Has_Self_Reference);\n    pragma Inline (Has_No_Elaboration_Code);\n-   pragma Inline (Has_Pragma_CPU);\n-   pragma Inline (Has_Pragma_Dispatching_Domain);\n-   pragma Inline (Has_Pragma_Priority);\n    pragma Inline (Has_Pragma_Suppress_All);\n    pragma Inline (Has_Private_View);\n    pragma Inline (Has_Relative_Deadline_Pragma);\n    pragma Inline (Has_Storage_Size_Pragma);\n-   pragma Inline (Has_Task_Info_Pragma);\n-   pragma Inline (Has_Task_Name_Pragma);\n    pragma Inline (Has_Wide_Character);\n    pragma Inline (Has_Wide_Wide_Character);\n    pragma Inline (Header_Size_Added);\n@@ -12316,15 +12249,10 @@ package Sinfo is\n    pragma Inline (Set_Has_Local_Raise);\n    pragma Inline (Set_Has_Dynamic_Range_Check);\n    pragma Inline (Set_Has_No_Elaboration_Code);\n-   pragma Inline (Set_Has_Pragma_CPU);\n-   pragma Inline (Set_Has_Pragma_Dispatching_Domain);\n-   pragma Inline (Set_Has_Pragma_Priority);\n    pragma Inline (Set_Has_Pragma_Suppress_All);\n    pragma Inline (Set_Has_Private_View);\n    pragma Inline (Set_Has_Relative_Deadline_Pragma);\n    pragma Inline (Set_Has_Storage_Size_Pragma);\n-   pragma Inline (Set_Has_Task_Info_Pragma);\n-   pragma Inline (Set_Has_Task_Name_Pragma);\n    pragma Inline (Set_Has_Wide_Character);\n    pragma Inline (Set_Has_Wide_Wide_Character);\n    pragma Inline (Set_Header_Size_Added);"}, {"sha": "0beb51fd1e9d506ddcd81735e2a293df449f0442", "filename": "gcc/ada/snames.adb-tmpl", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsnames.adb-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsnames.adb-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb-tmpl?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -209,10 +209,16 @@ package body Snames is\n    begin\n       if N = Name_AST_Entry then\n          return Pragma_AST_Entry;\n+      elsif N = Name_CPU then\n+         return Pragma_CPU;\n+      elsif N = Name_Dispatching_Domain then\n+         return Pragma_Dispatching_Domain;\n       elsif N = Name_Fast_Math then\n          return Pragma_Fast_Math;\n       elsif N = Name_Interface then\n          return Pragma_Interface;\n+      elsif N = Name_Interrupt_Priority then\n+         return Pragma_Interrupt_Priority;\n       elsif N = Name_Priority then\n          return Pragma_Priority;\n       elsif N = Name_Relative_Deadline then\n@@ -410,8 +416,11 @@ package body Snames is\n    begin\n       return N in First_Pragma_Name .. Last_Pragma_Name\n         or else N = Name_AST_Entry\n+        or else N = Name_CPU\n+        or else N = Name_Dispatching_Domain\n         or else N = Name_Fast_Math\n         or else N = Name_Interface\n+        or else N = Name_Interrupt_Priority\n         or else N = Name_Relative_Deadline\n         or else N = Name_Priority\n         or else N = Name_Storage_Size"}, {"sha": "4b1b337d036a46117e692a1a0a77c1b2a3b9b43b", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -374,7 +374,13 @@ package Snames is\n    Name_Default_Storage_Pool           : constant Name_Id := N + $; -- Ada 12\n    Name_Disable_Atomic_Synchronization : constant Name_Id := N + $; -- GNAT\n    Name_Discard_Names                  : constant Name_Id := N + $;\n-   Name_Dispatching_Domain             : constant Name_Id := N + $; -- Ada 12\n+\n+   --  Note: Dispatching_Domain is not in this list because its name matches\n+   --  the name of the corresponding attribute. However, it is included in the\n+   --  definition of the type Pragma_Id, and the functions Get_Pragma_Id and\n+   --  Is_Pragma_Id correctly recognize and process Dispatching_Domain.\n+   --  Dispatching_Domain is a standard Ada 2012 pragma.\n+\n    Name_Elaboration_Checks             : constant Name_Id := N + $; -- GNAT\n    Name_Eliminate                      : constant Name_Id := N + $; -- GNAT\n    Name_Enable_Atomic_Synchronization  : constant Name_Id := N + $; -- GNAT\n@@ -456,7 +462,13 @@ package Snames is\n    Name_CPP_Constructor                : constant Name_Id := N + $; -- GNAT\n    Name_CPP_Virtual                    : constant Name_Id := N + $; -- GNAT\n    Name_CPP_Vtable                     : constant Name_Id := N + $; -- GNAT\n-   Name_CPU                            : constant Name_Id := N + $; -- Ada 12\n+\n+   --  Note: CPU is not in this list because its name matches the name of\n+   --  the corresponding attribute. However, it is included in the definition\n+   --  of the type Pragma_Id, and the functions Get_Pragma_Id and Is_Pragma_Id\n+   --  correctly recognize and process CPU. CPU is a standard Ada 2012\n+   --  pragma.\n+\n    Name_Debug                          : constant Name_Id := N + $; -- GNAT\n    Name_Elaborate                      : constant Name_Id := N + $; -- Ada 83\n    Name_Elaborate_All                  : constant Name_Id := N + $;\n@@ -489,11 +501,16 @@ package Snames is\n    --  Note: Interface is not in this list because its name matches an Ada 05\n    --  keyword. However it is included in the definition of the type\n    --  Attribute_Id, and the functions Get_Pragma_Id and Is_Pragma_Id correctly\n-   --  recognize and process Name_Storage_Size.\n+   --  recognize and process Name_Interface.\n \n    Name_Interface_Name                 : constant Name_Id := N + $; -- GNAT\n    Name_Interrupt_Handler              : constant Name_Id := N + $;\n-   Name_Interrupt_Priority             : constant Name_Id := N + $;\n+\n+   --  Note: Interrupt_Priority is not in this list because its name matches\n+   --  the name of the corresponding attribute. However, it is included in the\n+   --  definition of the type Pragma_Id, and the functions Get_Pragma_Id and\n+   --  Is_Pragma_Id correctly recognize and process Interrupt_Priority.\n+\n    Name_Invariant                      : constant Name_Id := N + $; -- GNAT\n    Name_Java_Constructor               : constant Name_Id := N + $; -- GNAT\n    Name_Java_Interface                 : constant Name_Id := N + $; -- GNAT\n@@ -754,13 +771,15 @@ package Snames is\n    Name_Constant_Indexing              : constant Name_Id := N + $; -- GNAT\n    Name_Constrained                    : constant Name_Id := N + $;\n    Name_Count                          : constant Name_Id := N + $;\n+   Name_CPU                            : constant Name_Id := N + $; -- Ada 12\n    Name_Default_Bit_Order              : constant Name_Id := N + $; -- GNAT\n    Name_Default_Iterator               : constant Name_Id := N + $; -- GNAT\n    Name_Definite                       : constant Name_Id := N + $;\n    Name_Delta                          : constant Name_Id := N + $;\n    Name_Denorm                         : constant Name_Id := N + $;\n    Name_Descriptor_Size                : constant Name_Id := N + $;\n    Name_Digits                         : constant Name_Id := N + $;\n+   Name_Dispatching_Domain             : constant Name_Id := N + $; -- Ada 12\n    Name_Elaborated                     : constant Name_Id := N + $; -- GNAT\n    Name_Emax                           : constant Name_Id := N + $; -- Ada 83\n    Name_Enabled                        : constant Name_Id := N + $; -- GNAT\n@@ -782,6 +801,7 @@ package Snames is\n    Name_Img                            : constant Name_Id := N + $; -- GNAT\n    Name_Implicit_Dereference           : constant Name_Id := N + $; -- GNAT\n    Name_Integer_Value                  : constant Name_Id := N + $; -- GNAT\n+   Name_Interrupt_Priority             : constant Name_Id := N + $; -- Ada 12\n    Name_Invalid_Value                  : constant Name_Id := N + $; -- GNAT\n    Name_Iterator_Element               : constant Name_Id := N + $; -- GNAT\n    Name_Large                          : constant Name_Id := N + $; -- Ada 83\n@@ -1329,13 +1349,15 @@ package Snames is\n       Attribute_Constant_Indexing,\n       Attribute_Constrained,\n       Attribute_Count,\n+      Attribute_CPU,\n       Attribute_Default_Bit_Order,\n       Attribute_Default_Iterator,\n       Attribute_Definite,\n       Attribute_Delta,\n       Attribute_Denorm,\n       Attribute_Descriptor_Size,\n       Attribute_Digits,\n+      Attribute_Dispatching_Domain,\n       Attribute_Elaborated,\n       Attribute_Emax,\n       Attribute_Enabled,\n@@ -1357,6 +1379,7 @@ package Snames is\n       Attribute_Img,\n       Attribute_Implicit_Dereference,\n       Attribute_Integer_Value,\n+      Attribute_Interrupt_Priority,\n       Attribute_Invalid_Value,\n       Attribute_Iterator_Element,\n       Attribute_Large,\n@@ -1576,7 +1599,6 @@ package Snames is\n       Pragma_Default_Storage_Pool,\n       Pragma_Disable_Atomic_Synchronization,\n       Pragma_Discard_Names,\n-      Pragma_Dispatching_Domain,\n       Pragma_Elaboration_Checks,\n       Pragma_Eliminate,\n       Pragma_Enable_Atomic_Synchronization,\n@@ -1644,7 +1666,6 @@ package Snames is\n       Pragma_CPP_Constructor,\n       Pragma_CPP_Virtual,\n       Pragma_CPP_Vtable,\n-      Pragma_CPU,\n       Pragma_Debug,\n       Pragma_Elaborate,\n       Pragma_Elaborate_All,\n@@ -1675,7 +1696,6 @@ package Snames is\n       Pragma_Inspection_Point,\n       Pragma_Interface_Name,\n       Pragma_Interrupt_Handler,\n-      Pragma_Interrupt_Priority,\n       Pragma_Invariant,\n       Pragma_Java_Constructor,\n       Pragma_Java_Interface,\n@@ -1749,8 +1769,11 @@ package Snames is\n       --  match existing attribute names.\n \n       Pragma_AST_Entry,\n+      Pragma_CPU,\n+      Pragma_Dispatching_Domain,\n       Pragma_Fast_Math,\n       Pragma_Interface,\n+      Pragma_Interrupt_Priority,\n       Pragma_Priority,\n       Pragma_Storage_Size,\n       Pragma_Storage_Unit,\n@@ -1829,8 +1852,9 @@ package Snames is\n \n    function Is_Pragma_Name (N : Name_Id) return Boolean;\n    --  Test to see if the name N is the name of a recognized pragma. Note that\n-   --  pragmas AST_Entry, Fast_Math, Priority, Storage_Size, and Storage_Unit\n-   --  are recognized as pragmas by this function even though their names are\n+   --  pragmas AST_Entry, CPU, Dispatching_Domain, Fast_Math,\n+   --  Interrupt_Priority, Priority, Storage_Size, and Storage_Unit are\n+   --  recognized as pragmas by this function even though their names are\n    --  separate from the other pragma names. For this reason, clients should\n    --  always use this function, rather than do range tests on Name_Id values.\n \n@@ -1870,9 +1894,9 @@ package Snames is\n    --  Returns Id of pragma corresponding to given name. Returns Unknown_Pragma\n    --  if N is not a name of a known (Ada defined or GNAT-specific) pragma.\n    --  Note that the function also works correctly for names of pragmas that\n-   --  are not included in the main list of pragma Names (AST_Entry, Priority,\n-   --  Storage_Size, and Storage_Unit (e.g. Name_Storage_Size returns\n-   --  Pragma_Storage_Size).\n+   --  are not included in the main list of pragma Names (AST_Entry, CPU,\n+   --  Dispatching_Domain, Interrupt_Priority, Priority, Storage_Size, and\n+   --  Storage_Unit (e.g. Name_Storage_Size returns Pragma_Storage_Size).\n \n    function Get_Queuing_Policy_Id (N : Name_Id) return Queuing_Policy_Id;\n    --  Returns Id of queuing policy corresponding to given name. It is an error"}, {"sha": "51cec6e02c46693d02fec315f885eaa96f73a1d0", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b98e296954eded73ab660265878b17a293678d97/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=b98e296954eded73ab660265878b17a293678d97", "patch": "@@ -736,7 +736,8 @@ package body Switch.C is\n \n                if Ptr <= Max then\n                   C := Switch_Chars (Ptr);\n-                  if C = '1' or C = '2' then\n+\n+                  if C in '1' .. '2' then\n                      Ptr := Ptr + 1;\n                      Inline_Level := Character'Pos (C) - Character'Pos ('0');\n                   end if;"}]}