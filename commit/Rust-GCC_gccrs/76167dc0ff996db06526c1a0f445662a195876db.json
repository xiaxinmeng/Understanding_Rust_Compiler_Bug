{"sha": "76167dc0ff996db06526c1a0f445662a195876db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYxNjdkYzBmZjk5NmRiMDY1MjZjMWEwZjQ0NTY2MmExOTU4NzZkYg==", "commit": {"author": {"name": "Guilhem Lavaux", "email": "guilhem@kaffe.org", "date": "2003-11-27T09:43:02Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-11-27T09:43:02Z"}, "message": "FormatCharacterIterator.java: Documented the class and\n\n2003-11-27  Guilhem Lavaux <guilhem@kaffe.org>\n\n\t* java/text/FormatCharacterIterator.java: Documented the class and\n\n2003-11-27  Guilhem Lavaux <guilhem@kaffe.org>\n\n\t* java/text/FormatCharacterIterator.java: Fixed some typos.\n\nFrom-SVN: r73986", "tree": {"sha": "27d216cd10d3927d908b5c251dab057aee21d76c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27d216cd10d3927d908b5c251dab057aee21d76c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76167dc0ff996db06526c1a0f445662a195876db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76167dc0ff996db06526c1a0f445662a195876db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76167dc0ff996db06526c1a0f445662a195876db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76167dc0ff996db06526c1a0f445662a195876db/comments", "author": null, "committer": null, "parents": [{"sha": "a01387ddb7a90329b4ef9d0fb23cc4fbc46cf6f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a01387ddb7a90329b4ef9d0fb23cc4fbc46cf6f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a01387ddb7a90329b4ef9d0fb23cc4fbc46cf6f6"}], "stats": {"total": 180, "additions": 126, "deletions": 54}, "files": [{"sha": "544f2c48ef414b2dd8cc7d9e6637372ba8fe75d7", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76167dc0ff996db06526c1a0f445662a195876db/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76167dc0ff996db06526c1a0f445662a195876db/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=76167dc0ff996db06526c1a0f445662a195876db", "patch": "@@ -1,3 +1,11 @@\n+2003-11-27  Guilhem Lavaux <guilhem@kaffe.org>\n+\n+\t* java/text/FormatCharacterIterator.java: Documented the class and\n+\n+2003-11-27  Guilhem Lavaux <guilhem@kaffe.org>\n+\n+\t* java/text/FormatCharacterIterator.java: Fixed some typos.\n+\n 2003-11-27  Guilhem Lavaux <guilhem@kaffe.org>\n \n \t* java/text/NumberFormat.java:"}, {"sha": "a31154c531a0520ebff42f4f9c5f5a475c47ba4d", "filename": "libjava/java/text/FormatCharacterIterator.java", "status": "modified", "additions": 118, "deletions": 54, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76167dc0ff996db06526c1a0f445662a195876db/libjava%2Fjava%2Ftext%2FFormatCharacterIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76167dc0ff996db06526c1a0f445662a195876db/libjava%2Fjava%2Ftext%2FFormatCharacterIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FFormatCharacterIterator.java?ref=76167dc0ff996db06526c1a0f445662a195876db", "patch": "@@ -43,6 +43,18 @@\n import java.util.HashMap;\n import java.util.Vector;\n \n+\n+/**\n+ * This class should not be put public and it is only intended to the\n+ * classes of the java.text package. Its aim is to build a segmented\n+ * character iterator by appending strings and adding attributes to\n+ * portions of strings. The code intends to do some optimization\n+ * concerning memory consumption and attribute access but at the\n+ * end it is only an AttributedCharacterIterator.\n+ *\n+ * @author Guilhem Lavaux <guilhem@kaffe.org>\n+ * @date November 22, 2003\n+ */\n class FormatCharacterIterator implements AttributedCharacterIterator\n {\n   private String formattedString;\n@@ -51,25 +63,45 @@ class FormatCharacterIterator implements AttributedCharacterIterator\n   private int[] ranges;\n   private HashMap[] attributes;\n   \n+  /**\n+   * This constructor builds an empty iterated strings. The attributes\n+   * are empty and so is the string. However you may append strings\n+   * and attributes to this iterator.\n+   */\n   FormatCharacterIterator()\n   {\n     formattedString = \"\";\n     ranges = new int[0];\n     attributes = new HashMap[0];\n   }\n \n-  FormatCharacterIterator(String s, int[] ranges, HashMap[] attributes)\n+  /**\n+   * This constructor take a string <code>s</code>, a set of ranges \n+   * and the corresponding attributes. This is used to build an iterator.\n+   * The array <code>ranges</code> should be formatted as follow:\n+   * each element of <code>ranges</code> specifies the index in the string\n+   * until which the corresponding map of attributes at the same position\n+   * is applied. For example, if you have:\n+   * <pre>\n+   *   s = \"hello\";\n+   *   ranges = new int[] { 2, 6 };\n+   *   attributes = new HashMap[2];\n+   * </pre>\n+   * <code>\"he\"</code> will have the attributes <code>attributes[0]</code>,\n+   * <code>\"llo\"</code> the <code>attributes[1]</code>.\n+   */\n+  FormatCharacterIterator (String s, int[] ranges, HashMap[] attributes)\n   {\n     formattedString = s;\n     this.ranges = ranges;\n     this.attributes = attributes;\n   }\n   \n-  /*\n-   * -----------------------------------\n-   * AttributedCharacterIterator methods\n-   * -----------------------------------\n+  /* \n+   * The following methods are inherited from AttributedCharacterIterator,\n+   * and thus are already documented. \n    */\n+\n   public Set getAllAttributeKeys()\n   {\n     if (attributes != null && attributes[attributeIndex] != null)\n@@ -86,10 +118,10 @@ public Map getAttributes()\n       return new HashMap();\n   }\n   \n-  public Object getAttribute(AttributedCharacterIterator.Attribute attrib)\n+  public Object getAttribute (AttributedCharacterIterator.Attribute attrib)\n   {\n     if (attributes != null && attributes[attributeIndex] != null)\n-      return attributes[attributeIndex].get(attrib);\n+      return attributes[attributeIndex].get (attrib);\n     else\n       return null;\n   }\n@@ -111,17 +143,17 @@ public int getRunLimit(Set reqAttrs)\n \t  break;\n \tnewKeys = attributes[currentAttrIndex].keySet();\n       }\n-    while (newKeys.containsAll(reqAttrs));\n+    while (newKeys.containsAll (reqAttrs));\n \n     return ranges[currentAttrIndex-1];\n   }\n   \n-  public int getRunLimit(AttributedCharacterIterator.Attribute attribute) \n+  public int getRunLimit (AttributedCharacterIterator.Attribute attribute) \n   {\n     Set s = new HashSet();\n \n-    s.add(attribute);\n-    return getRunLimit(s);\n+    s.add (attribute);\n+    return getRunLimit (s);\n   }\n \n   public int getRunLimit()\n@@ -139,7 +171,7 @@ public int getRunLimit()\n     return getRunLimit (attributes[attributeIndex].keySet());\n   }\n   \n-  public int getRunStart(Set reqAttrs)\n+  public int getRunStart (Set reqAttrs)\n   {\n     if (attributes == null)\n       return formattedString.length();\n@@ -157,7 +189,7 @@ public int getRunStart(Set reqAttrs)\n \t  break;\n \tnewKeys = attributes[currentAttrIndex].keySet();\n       }\n-    while (newKeys.containsAll(reqAttrs));\n+    while (newKeys.containsAll (reqAttrs));\n    \n     return (currentAttrIndex > 0) ? ranges[currentAttrIndex-1] : 0;\n   } \n@@ -175,37 +207,37 @@ public int getRunStart()\n \treturn 0;\n       }\n \n-    return getRunStart(attributes[attributeIndex].keySet());\n+    return getRunStart (attributes[attributeIndex].keySet());\n   }\n   \n-  public int getRunStart(AttributedCharacterIterator.Attribute attribute) \n+  public int getRunStart (AttributedCharacterIterator.Attribute attribute) \n   {\n     Set s = new HashSet();\n     \n-    s.add(attribute);\n-    return getRunStart(s);\n+    s.add (attribute);\n+    return getRunStart (s);\n   }\n \n   public Object clone()\n   {\n-    return new FormatCharacterIterator(formattedString, ranges, attributes);\n+    return new FormatCharacterIterator (formattedString, ranges, attributes);\n   }\n   \n   /*\n-   * ---------------------------------\n-   * CharacterIterator methods\n-   * ---------------------------------\n+   * The following methods are inherited from CharacterIterator and thus\n+   * are already documented.\n    */\n+\n   public char current()\n   {\n-    return formattedString.charAt(charIndex);\n+    return formattedString.charAt (charIndex);\n   }\n   \n   public char first()\n   {\n     charIndex = 0;\n     attributeIndex = 0;\n-    return formattedString.charAt(0);\n+    return formattedString.charAt (0);\n   }\n   \n   public int getBeginIndex()\n@@ -228,7 +260,7 @@ public char last()\n     charIndex = formattedString.length()-1;\n     if (attributes != null)\n       attributeIndex = attributes.length-1;\n-    return formattedString.charAt(charIndex);\n+    return formattedString.charAt (charIndex);\n   }\n   \n   public char next()\n@@ -244,7 +276,7 @@ public char next()\n \tif (charIndex >= ranges[attributeIndex])\n \t  attributeIndex++;\n       }\n-    return formattedString.charAt(charIndex);\n+    return formattedString.charAt (charIndex);\n   }\n   \n   public char previous()\n@@ -261,13 +293,13 @@ public char previous()\n \tif (charIndex < ranges[attributeIndex])\n \t  attributeIndex--;\n       }\n-    return formattedString.charAt(charIndex);\n+    return formattedString.charAt (charIndex);\n   }\n   \n-  public char setIndex(int position)\n+  public char setIndex (int position)\n   {\n     if (position < 0 || position > formattedString.length())\n-      throw new IllegalArgumentException(\"position is out of range\");\n+      throw new IllegalArgumentException (\"position is out of range\");\n     \n     charIndex = position;\n     if (attributes != null)\n@@ -281,10 +313,19 @@ public char setIndex(int position)\n     if (charIndex == formattedString.length())\n       return DONE;\n     else\n-      return formattedString.charAt(charIndex);\n+      return formattedString.charAt (charIndex);\n   }\n \n-  protected void mergeAttributes(HashMap[] attributes, int[] ranges)\n+  /**\n+   * This method merge the specified attributes and ranges with the\n+   * internal tables. This method is in charge of the optimization\n+   * of tables. Two following sets of attributes are never the same.\n+   *\n+   * @see #FormatCharacterIterator()\n+   *\n+   * @param attributes the new array attributes to apply to the string.\n+   */\n+  protected void mergeAttributes (HashMap[] attributes, int[] ranges)\n   {\n     Vector new_ranges = new Vector();\n     Vector new_attributes = new Vector();\n@@ -294,28 +335,28 @@ protected void mergeAttributes(HashMap[] attributes, int[] ranges)\n       {\n \tif (this.attributes[i] != null)\n \t  {\n-\t    new_attributes.add(this.attributes[i]);\n+\t    new_attributes.add (this.attributes[i]);\n \t    if (attributes[j] != null)\n-\t      this.attributes[i].putAll(attributes[j]);\n+\t      this.attributes[i].putAll (attributes[j]);\n \t  }\n \telse\n \t  {\n-\t    new_attributes.add(attributes[j]);\n+\t    new_attributes.add (attributes[j]);\n \t  }\n \tif (this.ranges[i] == ranges[j])\n \t  {\n-\t    new_ranges.add(new Integer(ranges[j]));\n+\t    new_ranges.add (new Integer (ranges[j]));\n \t    i++;\n \t    j++;\n \t  }\n \telse if (this.ranges[i] < ranges[j])\n \t  {\n-\t    new_ranges.add(new Integer(this.ranges[i]));\n+\t    new_ranges.add (new Integer (this.ranges[i]));\n \t    i++;\n \t  }\n \telse\n \t  {\n-\t    new_ranges.add(new Integer(ranges[j]));\n+\t    new_ranges.add (new Integer (ranges[j]));\n \t    j++;\n \t  }\n      }\n@@ -324,32 +365,39 @@ else if (this.ranges[i] < ranges[j])\n       {\n \tfor (;i<this.ranges.length;i++)\n \t  {\n-\t    new_attributes.add(this.attributes[i]);\n-\t    new_ranges.add(new Integer(this.ranges[i]));\n+\t    new_attributes.add (this.attributes[i]);\n+\t    new_ranges.add (new Integer (this.ranges[i]));\n \t  }\n       }\n     if (j != ranges.length)\n       {\n \tfor (;j<ranges.length;j++)\n \t  {\n-\t    new_attributes.add(attributes[j]);\n-\t    new_ranges.add(new Integer(ranges[j]));\n+\t    new_attributes.add (attributes[j]);\n+\t    new_ranges.add (new Integer (ranges[j]));\n \t  }\n       }\n \n     this.attributes = new HashMap[new_attributes.size()];\n     this.ranges = new int[new_ranges.size()];\n-    System.arraycopy(new_attributes.toArray(), 0, this.attributes,\n-\t\t     0, this.attributes.length);\n+    System.arraycopy (new_attributes.toArray(), 0, this.attributes,\n+\t\t      0, this.attributes.length);\n \n     for (i=0;i<new_ranges.size();i++)\n       {\n-\tthis.ranges[i] = ((Integer)new_ranges.elementAt(i)).intValue();\n+\tthis.ranges[i] = ((Integer)new_ranges.elementAt (i)).intValue();\n       }\n     \n   }\n \n-  protected void append(AttributedCharacterIterator iterator)\n+  /**\n+   * This method appends to the internal attributed string the attributed\n+   * string contained in the specified iterator.\n+   *\n+   * @param iterator the iterator which contains the attributed string to\n+   * append to this iterator.\n+   */\n+  protected void append (AttributedCharacterIterator iterator)\n   {\n     char c = iterator.first();\n     Vector more_ranges = new Vector();\n@@ -360,7 +408,7 @@ protected void append(AttributedCharacterIterator iterator)\n \tformattedString = formattedString + String.valueOf(c);\n \t// TODO: Reduce the size of the output array.\n \tmore_attributes.add (iterator.getAttributes());\n-\tmore_ranges.add(new Integer(formattedString.length()));\n+\tmore_ranges.add (new Integer (formattedString.length()));\n \t// END TOOD\n \tc = iterator.next();\n       } \n@@ -370,11 +418,11 @@ protected void append(AttributedCharacterIterator iterator)\n \t\t\t\t\t   + more_attributes.size()];\n     int[] new_ranges = new int[ranges.length + more_ranges.size()];\n     \n-    System.arraycopy(attributes, 0, new_attributes, 0, attributes.length);\n-    System.arraycopy(more_attributes.toArray(), 0, new_attributes,\n-\t\t     attributes.length, more_attributes.size());\n+    System.arraycopy (attributes, 0, new_attributes, 0, attributes.length);\n+    System.arraycopy (more_attributes.toArray(), 0, new_attributes,\n+\t\t      attributes.length, more_attributes.size());\n \n-    System.arraycopy(ranges, 0, new_ranges, 0, ranges.length);\n+    System.arraycopy (ranges, 0, new_ranges, 0, ranges.length);\n     Object[] new_ranges_array = more_ranges.toArray();\n     for (int i=0;i<more_ranges.size();i++)\n       new_ranges[i+ranges.length] = ((Integer)new_ranges_array[i]).intValue();\n@@ -383,23 +431,39 @@ protected void append(AttributedCharacterIterator iterator)\n     ranges = new_ranges;\n   }\n \n-  protected void append(String text, HashMap local_attributes)\n+  /**\n+   * This method appends an attributed string which attributes are specified\n+   * directly in the calling parameters.\n+   *\n+   * @param text The string to append.\n+   * @param local_attributes The attributes to put on this string in the\n+   * iterator. If it is <code>null</code> the string will simply have no\n+   * attributes.\n+   */\n+  protected void append (String text, HashMap local_attributes)\n   {\n     int[] new_ranges = new int[ranges.length+1];\n     HashMap[] new_attributes = new HashMap[attributes.length+1];\n \n     formattedString += text;\n-    System.arraycopy(attributes, 0, new_attributes, 0, attributes.length);\n-    System.arraycopy(ranges, 0, new_ranges, 0, ranges.length);\n+    System.arraycopy (attributes, 0, new_attributes, 0, attributes.length);\n+    System.arraycopy (ranges, 0, new_ranges, 0, ranges.length);\n     new_ranges[ranges.length] = formattedString.length();\n     new_attributes[attributes.length] = local_attributes;\n \n     ranges = new_ranges;\n     attributes = new_attributes;\n   }  \n \n-  protected void append(String text)\n+  /**\n+   * This method appends a string without attributes. It is completely\n+   * equivalent to call {@link #append(String,HashMap)} with local_attributes\n+   * equal to <code>null</code>.\n+   *\n+   * @param text The string to append to the iterator.\n+   */\n+  protected void append (String text)\n   {\n-    append(text, null);\n+    append (text, null);\n   }  \n }"}]}