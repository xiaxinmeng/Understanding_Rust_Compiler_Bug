{"sha": "266a27326fc77e9d7ff52ff913a67ec981a38d55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY2YTI3MzI2ZmM3N2U5ZDdmZjUyZmY5MTNhNjdlYzk4MWEzOGQ1NQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2003-06-16T14:56:38Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2003-06-16T14:56:38Z"}, "message": "sh.c (prepare_move_operand): Check if operand 0 is an invalid memory reference.\n\n\t* sh.c (prepare_move_operand): Check if operand 0 is an invalid\n\tmemory reference.  Fix test that checks if operand 1 is using r0.\n\t* sh.md (movhi_i): Don't allow st.w r0,@(rX,rY) .\n\nFrom-SVN: r68017", "tree": {"sha": "d751ccbd131f746cedcf2fe86a10b4e93e4e234a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d751ccbd131f746cedcf2fe86a10b4e93e4e234a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/266a27326fc77e9d7ff52ff913a67ec981a38d55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266a27326fc77e9d7ff52ff913a67ec981a38d55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/266a27326fc77e9d7ff52ff913a67ec981a38d55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266a27326fc77e9d7ff52ff913a67ec981a38d55/comments", "author": null, "committer": null, "parents": [{"sha": "0eff02cdae2e3ede11ffca73536037869cbc8ff1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eff02cdae2e3ede11ffca73536037869cbc8ff1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eff02cdae2e3ede11ffca73536037869cbc8ff1"}], "stats": {"total": 25, "additions": 22, "deletions": 3}, "files": [{"sha": "3612beab6cb641c6b659b48431e6d8cdd4256efd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266a27326fc77e9d7ff52ff913a67ec981a38d55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266a27326fc77e9d7ff52ff913a67ec981a38d55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=266a27326fc77e9d7ff52ff913a67ec981a38d55", "patch": "@@ -77,7 +77,12 @@\n \n 2003-06-16  J\"orn Rennecke <joern.rennecke@superh.com>\n \n-\t* (REG_CLASS_FROM_CONSTRAINT): Only define if not already defined.\n+\t* sh.c (prepare_move_operand): Check if operand 0 is an invalid\n+\tmemory reference.  Fix test that checks if operand 1 is using r0.\n+\t* sh.md (movhi_i): Don't allow st.w r0,@(rX,rY) .\n+\n+\t* defaults.h (REG_CLASS_FROM_CONSTRAINT): Only define if not already\n+\tdefined.\n \n 2003-06-15  Nathan Sidwell  <nathan@codesourcery.com>\n "}, {"sha": "94ca7a0baf637e02bc93827ba161d32245a1c491", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266a27326fc77e9d7ff52ff913a67ec981a38d55/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266a27326fc77e9d7ff52ff913a67ec981a38d55/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=266a27326fc77e9d7ff52ff913a67ec981a38d55", "patch": "@@ -763,11 +763,20 @@ prepare_move_operands (operands, mode)\n \t  && ! sh_register_operand (operands[1], mode))\n \toperands[1] = copy_to_mode_reg (mode, operands[1]);\n \n+      if (GET_CODE (operands[0]) == MEM && ! memory_operand (operands[0], mode))\n+\t{\n+\t  /* This is like change_address_1 (operands[0], mode, 0, 1) ,\n+\t     except that we can't use that function because it is static.  */\n+\t  rtx new = change_address (operands[0], mode, 0);\n+\t  MEM_COPY_ATTRIBUTES (new, operands[0]);\n+\t  operands[0] = new;\n+\t}\n+\n       /* This case can happen while generating code to move the result\n \t of a library call to the target.  Reject `st r0,@(rX,rY)' because\n \t reload will fail to find a spill register for rX, since r0 is already\n \t being used for the source.  */\n-      else if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == 0\n+      else if (refers_to_regno_p (R0_REG, R0_REG + 1, operands[1], (rtx *)0)\n \t       && GET_CODE (operands[0]) == MEM\n \t       && GET_CODE (XEXP (operands[0], 0)) == PLUS\n \t       && GET_CODE (XEXP (XEXP (operands[0], 0), 1)) == REG)"}, {"sha": "e70150ab0639c96c4a4b983e6564b58b76d1713e", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266a27326fc77e9d7ff52ff913a67ec981a38d55/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266a27326fc77e9d7ff52ff913a67ec981a38d55/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=266a27326fc77e9d7ff52ff913a67ec981a38d55", "patch": "@@ -3674,12 +3674,17 @@\n   operands[3] = gen_rtx_REG (DImode, REGNO (operands[2]));\n }\")\n \n+/* When storing r0, we have to avoid reg+reg addressing.  */\n (define_insn \"movhi_i\"\n   [(set (match_operand:HI 0 \"general_movdst_operand\" \"=r,r,r,r,m,r,l,r\")\n \t(match_operand:HI 1 \"general_movsrc_operand\" \"Q,rI,m,t,r,l,r,i\"))]\n   \"TARGET_SH1\n    && (arith_reg_operand (operands[0], HImode)\n-       || arith_reg_operand (operands[1], HImode))\"\n+       || arith_reg_operand (operands[1], HImode))\n+   && (GET_CODE (operands[0]) != MEM\n+       || GET_CODE (XEXP (operands[0], 0)) != PLUS\n+       || GET_CODE (XEXP (XEXP (operands[0], 0), 1)) != REG\n+       || ! refers_to_regno_p (R0_REG, R0_REG + 1, operands[1], (rtx *)0))\"\n   \"@\n \tmov.w\t%1,%0\n \tmov\t%1,%0"}]}