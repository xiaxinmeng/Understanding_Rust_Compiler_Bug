{"sha": "ebc4cd54b2378147d7041fd05ff03bd0e1a61e48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJjNGNkNTRiMjM3ODE0N2Q3MDQxZmQwNWZmMDNiZDBlMWE2MWU0OA==", "commit": {"author": {"name": "Stefan Kanthak", "email": "stefan.kanthak@nexgo.de", "date": "2020-11-10T15:22:28Z"}, "committer": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2020-11-10T15:29:46Z"}, "message": "Improve generated code for various libgcc2.c routines\n\nlibgcc/\n\n\t* libgcc2.c (__addvSI3): Use overflow builtins.\n\t(__addvsi3, __addvDI3 ,__subvSI3, __subvsi3): Likewise.\n\t(__subvDI3 __mulvSI3, __mulvsi3, __negvSI2): Likewise.\n\t(__negvsi2, __negvDI2): Likewise.\n\t(__cmpdi2, __ucmpdi2): Adjust implementation to improve\n\tgenerated code.\n\t* libgcc2.h (__ucmpdi2): Adjust prototype.", "tree": {"sha": "4b2e2cf268b9af0c664bb895ce4d461ede62f282", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b2e2cf268b9af0c664bb895ce4d461ede62f282"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebc4cd54b2378147d7041fd05ff03bd0e1a61e48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebc4cd54b2378147d7041fd05ff03bd0e1a61e48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebc4cd54b2378147d7041fd05ff03bd0e1a61e48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebc4cd54b2378147d7041fd05ff03bd0e1a61e48/comments", "author": null, "committer": null, "parents": [{"sha": "cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56"}], "stats": {"total": 84, "additions": 30, "deletions": 54}, "files": [{"sha": "4e4defb9bce1df77ee4f09e4808934d5c75532bb", "filename": "libgcc/libgcc2.c", "status": "modified", "additions": 29, "deletions": 53, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebc4cd54b2378147d7041fd05ff03bd0e1a61e48/libgcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebc4cd54b2378147d7041fd05ff03bd0e1a61e48/libgcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcc2.c?ref=ebc4cd54b2378147d7041fd05ff03bd0e1a61e48", "patch": "@@ -75,9 +75,9 @@ __negdi2 (DWtype u)\n Wtype\n __addvSI3 (Wtype a, Wtype b)\n {\n-  const Wtype w = (UWtype) a + (UWtype) b;\n+  Wtype w;\n \n-  if (b >= 0 ? w < a : w > a)\n+  if (__builtin_add_overflow(a, b, &w))\n     abort ();\n \n   return w;\n@@ -86,9 +86,9 @@ __addvSI3 (Wtype a, Wtype b)\n SItype\n __addvsi3 (SItype a, SItype b)\n {\n-  const SItype w = (USItype) a + (USItype) b;\n+  SItype w;\n \n-  if (b >= 0 ? w < a : w > a)\n+  if (__builtin_add_overflow(a, b, &w))\n     abort ();\n \n   return w;\n@@ -100,9 +100,9 @@ __addvsi3 (SItype a, SItype b)\n DWtype\n __addvDI3 (DWtype a, DWtype b)\n {\n-  const DWtype w = (UDWtype) a + (UDWtype) b;\n+  DWtype w;\n \n-  if (b >= 0 ? w < a : w > a)\n+  if (__builtin_add_overflow(a, b, &w))\n     abort ();\n \n   return w;\n@@ -113,9 +113,9 @@ __addvDI3 (DWtype a, DWtype b)\n Wtype\n __subvSI3 (Wtype a, Wtype b)\n {\n-  const Wtype w = (UWtype) a - (UWtype) b;\n+  Wtype w;\n \n-  if (b >= 0 ? w > a : w < a)\n+  if (__builtin_sub_overflow(a, b, &w))\n     abort ();\n \n   return w;\n@@ -124,9 +124,9 @@ __subvSI3 (Wtype a, Wtype b)\n SItype\n __subvsi3 (SItype a, SItype b)\n {\n-  const SItype w = (USItype) a - (USItype) b;\n+  SItype w;\n \n-  if (b >= 0 ? w > a : w < a)\n+  if (__builtin_sub_overflow(a, b, &w))\n     abort ();\n \n   return w;\n@@ -138,9 +138,9 @@ __subvsi3 (SItype a, SItype b)\n DWtype\n __subvDI3 (DWtype a, DWtype b)\n {\n-  const DWtype w = (UDWtype) a - (UDWtype) b;\n+  DWtype w;\n \n-  if (b >= 0 ? w > a : w < a)\n+  if (__builtin_sub_overflow(a, b, &w))\n     abort ();\n \n   return w;\n@@ -151,22 +151,20 @@ __subvDI3 (DWtype a, DWtype b)\n Wtype\n __mulvSI3 (Wtype a, Wtype b)\n {\n-  const DWtype w = (DWtype) a * (DWtype) b;\n+  Wtype w;\n \n-  if ((Wtype) (w >> W_TYPE_SIZE) != (Wtype) w >> (W_TYPE_SIZE - 1))\n+  if (__builtin_mul_overflow(a, b, &w))\n     abort ();\n \n   return w;\n }\n #ifdef COMPAT_SIMODE_TRAPPING_ARITHMETIC\n-#undef WORD_SIZE\n-#define WORD_SIZE (sizeof (SItype) * __CHAR_BIT__)\n SItype\n __mulvsi3 (SItype a, SItype b)\n {\n-  const DItype w = (DItype) a * (DItype) b;\n+  SItype w;\n \n-  if ((SItype) (w >> WORD_SIZE) != (SItype) w >> (WORD_SIZE-1))\n+  if (__builtin_mul_overflow(a, b, &w))\n     abort ();\n \n   return w;\n@@ -178,23 +176,23 @@ __mulvsi3 (SItype a, SItype b)\n Wtype\n __negvSI2 (Wtype a)\n {\n-  const Wtype w = -(UWtype) a;\n+  Wtype w;\n \n-  if (a >= 0 ? w > 0 : w < 0)\n+  if (__builtin_sub_overflow(0, a, &w))\n     abort ();\n \n-   return w;\n+  return w;\n }\n #ifdef COMPAT_SIMODE_TRAPPING_ARITHMETIC\n SItype\n __negvsi2 (SItype a)\n {\n-  const SItype w = -(USItype) a;\n+  SItype w;\n \n-  if (a >= 0 ? w > 0 : w < 0)\n+  if (__builtin_sub_overflow(0, a, &w))\n     abort ();\n \n-   return w;\n+  return w;\n }\n #endif /* COMPAT_SIMODE_TRAPPING_ARITHMETIC */\n #endif\n@@ -203,9 +201,9 @@ __negvsi2 (SItype a)\n DWtype\n __negvDI2 (DWtype a)\n {\n-  const DWtype w = -(UDWtype) a;\n+  DWtype w;\n \n-  if (a >= 0 ? w > 0 : w < 0)\n+  if (__builtin_sub_overflow(0, a, &w))\n     abort ();\n \n   return w;\n@@ -953,7 +951,7 @@ __udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp)\n      aligns the divisor under the dividend and then perform number of\n      test-subtract iterations which shift the dividend left. Number of\n      iterations is k + 1 where k is the number of bit positions the\n-     divisor must be shifted left  to align it under the dividend.\n+     divisor must be shifted left to align it under the dividend.\n      quotient bits can be saved in the rightmost positions of the dividend\n      as it shifts left on each test-subtract iteration. */\n \n@@ -965,7 +963,7 @@ __udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp)\n       k = lz1 - lz2;\n       y = (y << k);\n \n-      /* Dividend can exceed 2 ^ (width \u2212 1) \u2212 1 but still be less than the\n+      /* Dividend can exceed 2 ^ (width - 1) - 1 but still be less than the\n \t aligned divisor. Normal iteration can drops the high order bit\n \t of the dividend. Therefore, first test-subtract iteration is a\n \t special case, saving its quotient bit in a separate location and\n@@ -1325,37 +1323,15 @@ __udivdi3 (UDWtype n, UDWtype d)\n cmp_return_type\n __cmpdi2 (DWtype a, DWtype b)\n {\n-  const DWunion au = {.ll = a};\n-  const DWunion bu = {.ll = b};\n-\n-  if (au.s.high < bu.s.high)\n-    return 0;\n-  else if (au.s.high > bu.s.high)\n-    return 2;\n-  if ((UWtype) au.s.low < (UWtype) bu.s.low)\n-    return 0;\n-  else if ((UWtype) au.s.low > (UWtype) bu.s.low)\n-    return 2;\n-  return 1;\n+  return (a > b) - (a < b) + 1;\n }\n #endif\n \n #ifdef L_ucmpdi2\n cmp_return_type\n-__ucmpdi2 (DWtype a, DWtype b)\n+__ucmpdi2 (UDWtype a, UDWtype b)\n {\n-  const DWunion au = {.ll = a};\n-  const DWunion bu = {.ll = b};\n-\n-  if ((UWtype) au.s.high < (UWtype) bu.s.high)\n-    return 0;\n-  else if ((UWtype) au.s.high > (UWtype) bu.s.high)\n-    return 2;\n-  if ((UWtype) au.s.low < (UWtype) bu.s.low)\n-    return 0;\n-  else if ((UWtype) au.s.low > (UWtype) bu.s.low)\n-    return 2;\n-  return 1;\n+  return (a > b) - (a < b) + 1;\n }\n #endif\n \f"}, {"sha": "22a27062f82bddf049d87fe5b50df006bef5a0c0", "filename": "libgcc/libgcc2.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebc4cd54b2378147d7041fd05ff03bd0e1a61e48/libgcc%2Flibgcc2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebc4cd54b2378147d7041fd05ff03bd0e1a61e48/libgcc%2Flibgcc2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcc2.h?ref=ebc4cd54b2378147d7041fd05ff03bd0e1a61e48", "patch": "@@ -402,7 +402,7 @@ extern UWtype __udiv_w_sdiv (UWtype *, UWtype, UWtype, UWtype);\n #endif\n \n extern cmp_return_type __cmpdi2 (DWtype, DWtype);\n-extern cmp_return_type __ucmpdi2 (DWtype, DWtype);\n+extern cmp_return_type __ucmpdi2 (UDWtype, UDWtype);\n \n #if MIN_UNITS_PER_WORD > 1\n extern SItype __bswapsi2 (SItype);"}]}