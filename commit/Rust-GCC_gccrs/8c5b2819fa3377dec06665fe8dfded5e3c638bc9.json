{"sha": "8c5b2819fa3377dec06665fe8dfded5e3c638bc9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM1YjI4MTlmYTMzNzdkZWMwNjY2NWZlOGRmZGVkNWUzYzYzOGJjOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-05-15T11:02:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-05-15T11:02:25Z"}, "message": "[multiple changes]\n\n2012-05-15  Yannick Moy  <moy@adacore.com>\n\n\t* aspects.ads: Minor addition of comments to provide info on\n\thow to add new aspects.\n\n2012-05-15  Thomas Quinot  <quinot@adacore.com>\n\n\t* osint.ads: Minor reformatting.\n\n2012-05-15  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch5.adb, exp_pakd.adb, sem_util.adb, sem_util.ads\n\t(Expand_Assign_Array): Handle the case of a packed bit array within a\n\trecord with reverse storage order (assign element by element in that\n\tcase).\n\t(In_Reverse_Storage_Order_Record): New subprogram,\n\tcode extracted from Exp_Pakd.\n\n2012-05-15  Yannick Moy  <moy@adacore.com>\n\n\t* a-ngelfu.ads: Add postconditions using Ada 2012\n\taspect syntax, reflecting some of the RM requirements for these\n\tfunctions, from Annex A.5.1 or G.2.4.\n\n2012-05-15  Thomas Quinot  <quinot@adacore.com>\n\n\t* adaint.c: Minor fix: move misplaced comment.\n\n2012-05-15  Doug Rupp  <rupp@adacore.com>\n\n\t* vms_data.ads: Enhance help for /IMMEDIATE_ERRORS to discourage\n\tuse by customers.\n\nFrom-SVN: r187525", "tree": {"sha": "03a8cd81be1c8ea5788d3f7a31ca35040a709cdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03a8cd81be1c8ea5788d3f7a31ca35040a709cdc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c5b2819fa3377dec06665fe8dfded5e3c638bc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c5b2819fa3377dec06665fe8dfded5e3c638bc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c5b2819fa3377dec06665fe8dfded5e3c638bc9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/comments", "author": null, "committer": null, "parents": [{"sha": "3ee8dde59cd9a08b9ad51aabed67dea280720fdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ee8dde59cd9a08b9ad51aabed67dea280720fdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ee8dde59cd9a08b9ad51aabed67dea280720fdf"}], "stats": {"total": 336, "additions": 265, "deletions": 71}, "files": [{"sha": "34ab93d74ba550653aa843586a9b217b6fd781e5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8c5b2819fa3377dec06665fe8dfded5e3c638bc9", "patch": "@@ -1,3 +1,36 @@\n+2012-05-15  Yannick Moy  <moy@adacore.com>\n+\n+\t* aspects.ads: Minor addition of comments to provide info on\n+\thow to add new aspects.\n+\n+2012-05-15  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* osint.ads: Minor reformatting.\n+\n+2012-05-15  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch5.adb, exp_pakd.adb, sem_util.adb, sem_util.ads\n+\t(Expand_Assign_Array): Handle the case of a packed bit array within a\n+\trecord with reverse storage order (assign element by element in that\n+\tcase).\n+\t(In_Reverse_Storage_Order_Record): New subprogram,\n+\tcode extracted from Exp_Pakd.\n+\n+2012-05-15  Yannick Moy  <moy@adacore.com>\n+\n+\t* a-ngelfu.ads: Add postconditions using Ada 2012\n+\taspect syntax, reflecting some of the RM requirements for these\n+\tfunctions, from Annex A.5.1 or G.2.4.\n+\n+2012-05-15  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* adaint.c: Minor fix: move misplaced comment.\n+\n+2012-05-15  Doug Rupp  <rupp@adacore.com>\n+\n+\t* vms_data.ads: Enhance help for /IMMEDIATE_ERRORS to discourage\n+\tuse by customers.\n+\n 2012-05-15  Tristan Gingold  <gingold@adacore.com>\n \n \t* a-exextr.adb: Add comment."}, {"sha": "03aed54b9661428f2378354deb8fb3c35b3cced2", "filename": "gcc/ada/a-ngelfu.ads", "status": "modified", "additions": 144, "deletions": 34, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Fa-ngelfu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Fa-ngelfu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngelfu.ads?ref=8c5b2819fa3377dec06665fe8dfded5e3c638bc9", "patch": "@@ -6,10 +6,34 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n+--              Copyright (C) 2012, Free Software Foundation, Inc.         --\n+--                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT.  In accordance with the copyright of that document, you can freely --\n--- copy and modify this specification,  provided that if you redistribute a --\n--- modified version,  any changes that you have made are clearly indicated. --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the Post aspects that have been added to the spec.       --\n+-- Except for these parts of the document, in accordance with the copyright --\n+-- of that document,  you can  freely copy and  modify this  specification, --\n+-- provided that  if you redistribute a modified version,  any changes that --\n+-- you have made are clearly indicated.                                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -19,55 +43,141 @@ generic\n package Ada.Numerics.Generic_Elementary_Functions is\n    pragma Pure;\n \n-   function Sqrt    (X           : Float_Type'Base) return Float_Type'Base;\n-   function Log     (X           : Float_Type'Base) return Float_Type'Base;\n-   function Log     (X, Base     : Float_Type'Base) return Float_Type'Base;\n-   function Exp     (X           : Float_Type'Base) return Float_Type'Base;\n-   function \"**\"    (Left, Right : Float_Type'Base) return Float_Type'Base;\n-\n-   function Sin     (X           : Float_Type'Base) return Float_Type'Base;\n-   function Sin     (X, Cycle    : Float_Type'Base) return Float_Type'Base;\n-   function Cos     (X           : Float_Type'Base) return Float_Type'Base;\n-   function Cos     (X, Cycle    : Float_Type'Base) return Float_Type'Base;\n-   function Tan     (X           : Float_Type'Base) return Float_Type'Base;\n-   function Tan     (X, Cycle    : Float_Type'Base) return Float_Type'Base;\n-   function Cot     (X           : Float_Type'Base) return Float_Type'Base;\n-   function Cot     (X, Cycle    : Float_Type'Base) return Float_Type'Base;\n-\n-   function Arcsin  (X           : Float_Type'Base) return Float_Type'Base;\n-   function Arcsin  (X, Cycle    : Float_Type'Base) return Float_Type'Base;\n-   function Arccos  (X           : Float_Type'Base) return Float_Type'Base;\n-   function Arccos  (X, Cycle    : Float_Type'Base) return Float_Type'Base;\n+   function Sqrt (X : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => Sqrt'Result >= 0.0\n+       and then (if X = 0.0 then Sqrt'Result = 0.0)\n+       and then (if X = 1.0 then Sqrt'Result = 1.0);\n+\n+   function Log (X : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => (if X = 1.0 then Log'Result = 0.0);\n+\n+   function Log (X, Base : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => (if X = 1.0 then Log'Result = 0.0);\n+\n+   function Exp (X : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => (if X = 0.0 then Exp'Result = 1.0);\n+\n+   function \"**\" (Left, Right : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => \"**\"'Result >= 0.0\n+       and then (if Right = 0.0 then \"**\"'Result = 1.0)\n+       and then (if Right = 1.0 then \"**\"'Result = Left)\n+       and then (if Left = 1.0 then \"**\"'Result = 1.0)\n+       and then (if Left = 0.0 then \"**\"'Result = 0.0);\n+\n+   function Sin (X : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => Sin'Result in -1.0 .. 1.0\n+       and then (if X = 0.0 then Sin'Result = 0.0);\n+\n+   function Sin (X, Cycle : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => Sin'Result in -1.0 .. 1.0\n+       and then (if X = 0.0 then Sin'Result = 0.0);\n+\n+   function Cos (X : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => Cos'Result in -1.0 .. 1.0\n+       and then (if X = 0.0 then Cos'Result = 1.0);\n+\n+   function Cos (X, Cycle : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => Cos'Result in -1.0 .. 1.0\n+       and then  (if X = 0.0 then Cos'Result = 1.0);\n+\n+   function Tan (X : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => (if X = 0.0 then Tan'Result = 0.0);\n+\n+   function Tan (X, Cycle : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => (if X = 0.0 then Tan'Result = 0.0);\n+\n+   function Cot (X : Float_Type'Base) return Float_Type'Base;\n+\n+   function Cot (X, Cycle : Float_Type'Base) return Float_Type'Base;\n+\n+   function Arcsin (X : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => (if X = 0.0 then Arcsin'Result = 0.0);\n+\n+   function Arcsin (X, Cycle : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => (if X = 0.0 then Arcsin'Result = 0.0);\n+\n+   function Arccos (X : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => (if X = 1.0 then Arccos'Result = 0.0);\n+\n+   function Arccos (X, Cycle : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => (if X = 1.0 then Arccos'Result = 0.0);\n \n    function Arctan\n      (Y   : Float_Type'Base;\n       X   : Float_Type'Base := 1.0)\n-     return Float_Type'Base;\n+     return Float_Type'Base\n+   with\n+     Post => (if X > 0.0 and Y = 0.0 then Arctan'Result = 0.0);\n \n    function Arctan\n      (Y     : Float_Type'Base;\n       X     : Float_Type'Base := 1.0;\n       Cycle : Float_Type'Base)\n-      return  Float_Type'Base;\n+      return  Float_Type'Base\n+   with\n+     Post => (if X > 0.0 and Y = 0.0 then Arctan'Result = 0.0);\n \n    function Arccot\n      (X   : Float_Type'Base;\n       Y   : Float_Type'Base := 1.0)\n-     return Float_Type'Base;\n+     return Float_Type'Base\n+   with\n+     Post => (if X > 0.0 and Y = 0.0 then Arccot'Result = 0.0);\n \n    function Arccot\n      (X     : Float_Type'Base;\n       Y     : Float_Type'Base := 1.0;\n       Cycle : Float_Type'Base)\n-     return   Float_Type'Base;\n-\n-   function Sinh    (X : Float_Type'Base) return Float_Type'Base;\n-   function Cosh    (X : Float_Type'Base) return Float_Type'Base;\n-   function Tanh    (X : Float_Type'Base) return Float_Type'Base;\n-   function Coth    (X : Float_Type'Base) return Float_Type'Base;\n-   function Arcsinh (X : Float_Type'Base) return Float_Type'Base;\n-   function Arccosh (X : Float_Type'Base) return Float_Type'Base;\n-   function Arctanh (X : Float_Type'Base) return Float_Type'Base;\n+     return   Float_Type'Base\n+   with\n+     Post => (if X > 0.0 and Y = 0.0 then Arccot'Result = 0.0);\n+\n+   function Sinh (X : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => (if X = 0.0 then Sinh'Result = 0.0);\n+\n+   function Cosh (X : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => Cosh'Result >= 1.0\n+       and then (if X = 0.0 then Cosh'Result = 1.0);\n+\n+   function Tanh (X : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => Tanh'Result in -1.0 .. 1.0\n+       and then (if X = 0.0 then Tanh'Result = 0.0);\n+\n+   function Coth (X : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => abs Coth'Result >= 1.0;\n+\n+   function Arcsinh (X : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => (if X = 0.0 then Arcsinh'Result = 0.0);\n+\n+   function Arccosh (X : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => Arccosh'Result >= 0.0\n+       and then (if X = 1.0 then Arccosh'Result = 0.0);\n+\n+   function Arctanh (X : Float_Type'Base) return Float_Type'Base\n+   with\n+     Post => (if X = 0.0 then Arctanh'Result = 0.0);\n+\n    function Arccoth (X : Float_Type'Base) return Float_Type'Base;\n \n end Ada.Numerics.Generic_Elementary_Functions;"}, {"sha": "b76b3c6c4ceabb394c41023c940515ac067196f6", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=8c5b2819fa3377dec06665fe8dfded5e3c638bc9", "patch": "@@ -350,7 +350,6 @@ int __gnat_vmsp = 0;\n /* Used for Ada bindings */\n int __gnat_size_of_file_attributes = sizeof (struct file_attributes);\n \n-/* Reset the file attributes as if no system call had been performed */\n void __gnat_stat_to_attr (int fd, char* name, struct file_attributes* attr);\n \n /* The __gnat_max_path_len variable is used to export the maximum\n@@ -402,6 +401,8 @@ to_ptr32 (char **ptr64)\n \n static const char ATTR_UNSET = 127;\n \n+/* Reset the file attributes as if no system call had been performed */\n+\n void\n __gnat_reset_attributes\n   (struct file_attributes* attr)"}, {"sha": "bc5b9c6956c10b1019acb1b6f955126457c534b1", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=8c5b2819fa3377dec06665fe8dfded5e3c638bc9", "patch": "@@ -34,6 +34,31 @@\n --  aspect specifications from the tree. The semantic processing for aspect\n --  specifications is found in Sem_Ch13.Analyze_Aspect_Specifications.\n \n+--  In general, each aspect should have a corresponding pragma, so that the\n+--  newly developed functionality is available for Ada versions < Ada 2012.\n+--  When both are defined, it is convenient to first transform the aspect into\n+--  an equivalent pragma in Sem_Ch13.Analyze_Aspect_Specifications, and then\n+--  analyze the pragma in Sem_Prag.Analyze_Pragma.\n+\n+--  To add a new aspect:\n+--  * create a name in snames.ads-tmpl\n+--  * create a value in type Aspect_Id in this unit\n+--  * add a value for the aspect in the global arrays defined in this unit\n+--  * add code for analyzing the aspect in\n+--    Sem_Ch13.Analyze_Aspect_Specifications. This may involve adding some\n+--    nodes to the tree to perform additional treatments later.\n+--  * if the semantic analysis of expressions/names in the aspect should not\n+--    occur at the point the aspect is defined, add code in the adequate\n+--    semantic analysis procedure for the aspect. For example, this is the case\n+--    for aspects Pre and Post on subprograms, which are pre-analyzed at the\n+--    end of the list of declarations to which the subprogram belongs, and\n+--    fully analyzed (possibly with expansion) during the semantic analysis of\n+--    subprogram bodies.\n+\n+--  Additionally, to add a corresponding pragma for a new aspect:\n+--  * create a name for the pragma in snames.ads-tmpl\n+--  * add code for analyzing the pragma in Sem_Prag.Analyze_Pragma\n+\n with Namet;  use Namet;\n with Snames; use Snames;\n with Types;  use Types;"}, {"sha": "0acb74bced903e43d1eb266bfd62d9b00b0673eb", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=8c5b2819fa3377dec06665fe8dfded5e3c638bc9", "patch": "@@ -344,7 +344,18 @@ package body Exp_Ch5 is\n       elsif Has_Controlled_Component (L_Type) then\n          Loop_Required := True;\n \n-         --  If object is atomic, we cannot tolerate a loop\n+      --  If changing scalar storage order and assigning a bit packed arrau,\n+      --  force loop expansion.\n+\n+      elsif Is_Bit_Packed_Array (L_Type)\n+              and then\n+            (In_Reverse_Storage_Order_Record (Rhs)\n+               /=\n+             In_Reverse_Storage_Order_Record (Lhs))\n+      then\n+         Loop_Required := True;\n+\n+      --  If object is atomic, we cannot tolerate a loop\n \n       elsif Is_Atomic_Object (Act_Lhs)\n               or else"}, {"sha": "73befd16742250b26be4ba1be2618afd2fb93c1d", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=8c5b2819fa3377dec06665fe8dfded5e3c638bc9", "patch": "@@ -2622,14 +2622,9 @@ package body Exp_Pakd is\n       Loc  : constant Source_Ptr := Sloc (N);\n       PAT  : Entity_Id;\n       Otyp : Entity_Id;\n-      Pref : Node_Id;\n       Csiz : Uint;\n       Osiz : Uint;\n \n-      In_Reverse_Storage_Order_Record : Boolean;\n-      --  Set True if Obj is a [sub]component of a record that has reversed\n-      --  scalar storage order.\n-\n    begin\n       Csiz := Component_Size (Atyp);\n \n@@ -2732,28 +2727,7 @@ package body Exp_Pakd is\n \n       --  We also have to adjust if the storage order is reversed\n \n-      Pref := Obj;\n-      loop\n-         case Nkind (Pref) is\n-            when N_Selected_Component =>\n-               Pref := Prefix (Pref);\n-               exit;\n-\n-            when N_Indexed_Component =>\n-               Pref := Prefix (Pref);\n-\n-            when others =>\n-               Pref := Empty;\n-               exit;\n-         end case;\n-      end loop;\n-\n-      In_Reverse_Storage_Order_Record :=\n-        Present (Pref)\n-          and then Is_Record_Type (Etype (Pref))\n-          and then Reverse_Storage_Order (Etype (Pref));\n-\n-      if Bytes_Big_Endian xor In_Reverse_Storage_Order_Record then\n+      if Bytes_Big_Endian xor In_Reverse_Storage_Order_Record (Obj) then\n          Shift :=\n            Make_Op_Subtract (Loc,\n              Left_Opnd  => Make_Integer_Literal (Loc, Osiz - Csiz),"}, {"sha": "094fee3f52f0db0e755d7060d3a9396aa4bdf542", "filename": "gcc/ada/osint.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Fosint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Fosint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.ads?ref=8c5b2819fa3377dec06665fe8dfded5e3c638bc9", "patch": "@@ -763,7 +763,7 @@ private\n    --  the need for either mapping the struct exactly or importing the sizeof\n    --  from C, which would result in dynamic code). However, it does waste\n    --  space (e.g. when a component of this type appears in a record, if it is\n-   --  unnecessarily large.\n+   --  unnecessarily large).\n \n    type File_Attributes is\n      array (1 .. File_Attributes_Size)"}, {"sha": "522ea3c76fbf891abd212f6e2b10e5df1d14a56e", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8c5b2819fa3377dec06665fe8dfded5e3c638bc9", "patch": "@@ -3169,14 +3169,15 @@ package body Sem_Util is\n    -- Enclosing_Lib_Unit_Entity --\n    -------------------------------\n \n-   function Enclosing_Lib_Unit_Entity return Entity_Id is\n-      Unit_Entity : Entity_Id;\n+   function Enclosing_Lib_Unit_Entity\n+      (E : Entity_Id := Current_Scope) return Entity_Id\n+   is\n+      Unit_Entity : Entity_Id := E;\n \n    begin\n       --  Look for enclosing library unit entity by following scope links.\n       --  Equivalent to, but faster than indexing through the scope stack.\n \n-      Unit_Entity := Current_Scope;\n       while (Present (Scope (Unit_Entity))\n         and then Scope (Unit_Entity) /= Standard_Standard)\n         and not Is_Child_Unit (Unit_Entity)\n@@ -6267,6 +6268,37 @@ package body Sem_Util is\n       return False;\n    end In_Parameter_Specification;\n \n+   -------------------------------------\n+   -- In_Reverse_Storage_Order_Record --\n+   -------------------------------------\n+\n+   function In_Reverse_Storage_Order_Record (N : Node_Id) return Boolean is\n+      Pref : Node_Id;\n+   begin\n+      Pref := N;\n+\n+      --  Climb up indexed components\n+\n+      loop\n+         case Nkind (Pref) is\n+            when N_Selected_Component =>\n+               Pref := Prefix (Pref);\n+               exit;\n+\n+            when N_Indexed_Component =>\n+               Pref := Prefix (Pref);\n+\n+            when others =>\n+               Pref := Empty;\n+               exit;\n+         end case;\n+      end loop;\n+\n+      return Present (Pref)\n+               and then Is_Record_Type (Etype (Pref))\n+               and then Reverse_Storage_Order (Etype (Pref));\n+   end In_Reverse_Storage_Order_Record;\n+\n    --------------------------------------\n    -- In_Subprogram_Or_Concurrent_Unit --\n    --------------------------------------"}, {"sha": "d6e0770b364eb888f05c694a7998edff5ef96359", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=8c5b2819fa3377dec06665fe8dfded5e3c638bc9", "patch": "@@ -385,10 +385,12 @@ package Sem_Util is\n    --  Returns the Node_Id associated with the innermost enclosing generic\n    --  unit, if any. If none, then returns Empty.\n \n-   function Enclosing_Lib_Unit_Entity return Entity_Id;\n-   --  Returns the entity of enclosing N_Compilation_Unit Node which is the\n+   function Enclosing_Lib_Unit_Entity\n+     (E : Entity_Id := Current_Scope) return Entity_Id;\n+   --  Returns the entity of enclosing library unit node which is the\n    --  root of the current scope (which must not be Standard_Standard, and the\n-   --  caller is responsible for ensuring this condition).\n+   --  caller is responsible for ensuring this condition) or other specified\n+   --  entity.\n \n    function Enclosing_Package (E : Entity_Id) return Entity_Id;\n    --  Utility function to return the Ada entity of the package enclosing\n@@ -740,6 +742,10 @@ package Sem_Util is\n    function In_Parameter_Specification (N : Node_Id) return Boolean;\n    --  Returns True if node N belongs to a parameter specification\n \n+   function In_Reverse_Storage_Order_Record (N : Node_Id) return Boolean;\n+   --  Returns True if N denotes a component or subcomponent in a record object\n+   --  that has Reverse_Storage_Order.\n+\n    function In_Subprogram_Or_Concurrent_Unit return Boolean;\n    --  Determines if the current scope is within a subprogram compilation unit\n    --  (inside a subprogram declaration, subprogram body, or generic"}, {"sha": "1ebe8d34595636a6d77d4c360b1c332cabbe2a5e", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5b2819fa3377dec06665fe8dfded5e3c638bc9/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=8c5b2819fa3377dec06665fe8dfded5e3c638bc9", "patch": "@@ -1779,7 +1779,9 @@ package VMS_Data is\n    --   Causes errors to be displayed as soon as they are encountered, rather\n    --   than after compilation is terminated. If GNAT terminates prematurely\n    --   or goes into an infinite loop, the last error message displayed may\n-   --   help to pinpoint the culprit.\n+   --   help to pinpoint the culprit. Use with caution: This qualifier is\n+   --   intended for use in debugging the compiler proper, and may cause\n+   --   output of warnings suppressed by pragma.\n \n    S_GCC_Inline  : aliased constant S := \"/INLINE=\"                        &\n                                             \"PRAGMA \"                      &"}]}