{"sha": "3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NhYmQ2ZDE3YzhlYTFiOWEyYTdjZDY2NjMzOWViMDdlNzM2YWM2ZQ==", "commit": {"author": {"name": "Laurynas Biveinis", "email": "laurynas.biveinis@gmail.com", "date": "2009-04-22T04:48:34Z"}, "committer": {"name": "Laurynas Biveinis", "email": "lauras@gcc.gnu.org", "date": "2009-04-22T04:48:34Z"}, "message": "cfghooks.c (tidy_fallthru_edges): Remove find_basic_blocks references from comments.\n\n2009-04-22  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* cfghooks.c (tidy_fallthru_edges): Remove find_basic_blocks\n\treferences from comments.\n\t* cfgbuild.c: (count_basic_blocks): Delete.\n\t(find_basic_blocks_1): Delete.\n\t(find_basic_blocks): Delete.\n\t* except.c (finish_eh_generation): Make static.  Move comment \nfrom\n\texcept.h here.  Remove find_basic_blocks references from\n\tcomments.\n\t* except.h (finish_eh_generation): Delete.\n\t* basic-block.h (find_basic_blocks): Delete.\n\t* config/sh/sh.c (sh_output_mi_thunk): Delete a \"#if 0\" block.\n\nFrom-SVN: r146544", "tree": {"sha": "fd5b391992d702a834e6c7d9b01f77bb4d0f61fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd5b391992d702a834e6c7d9b01f77bb4d0f61fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e/comments", "author": {"login": "laurynas-biveinis", "id": 58894, "node_id": "MDQ6VXNlcjU4ODk0", "avatar_url": "https://avatars.githubusercontent.com/u/58894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/laurynas-biveinis", "html_url": "https://github.com/laurynas-biveinis", "followers_url": "https://api.github.com/users/laurynas-biveinis/followers", "following_url": "https://api.github.com/users/laurynas-biveinis/following{/other_user}", "gists_url": "https://api.github.com/users/laurynas-biveinis/gists{/gist_id}", "starred_url": "https://api.github.com/users/laurynas-biveinis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/laurynas-biveinis/subscriptions", "organizations_url": "https://api.github.com/users/laurynas-biveinis/orgs", "repos_url": "https://api.github.com/users/laurynas-biveinis/repos", "events_url": "https://api.github.com/users/laurynas-biveinis/events{/privacy}", "received_events_url": "https://api.github.com/users/laurynas-biveinis/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "270d1bcd872941a085c433b14499cb91fca6e66c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/270d1bcd872941a085c433b14499cb91fca6e66c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/270d1bcd872941a085c433b14499cb91fca6e66c"}], "stats": {"total": 280, "additions": 31, "deletions": 249}, "files": [{"sha": "26b721b5e855418b1d8cfa20ccdfbeea97defa91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e", "patch": "@@ -1,3 +1,17 @@\n+2009-04-22  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* cfghooks.c (tidy_fallthru_edges): Remove find_basic_blocks\n+\treferences from comments.\n+\t* cfgbuild.c: (count_basic_blocks): Delete.\n+\t(find_basic_blocks_1): Delete.\n+\t(find_basic_blocks): Delete.\n+\t* except.c (finish_eh_generation): Make static.  Move comment from\n+\texcept.h here.  Remove find_basic_blocks references from\n+\tcomments.\n+\t* except.h (finish_eh_generation): Delete.\n+\t* basic-block.h (find_basic_blocks): Delete.\n+\t* config/sh/sh.c (sh_output_mi_thunk): Delete a \"#if 0\" block.\n+\n 2009-04-22  Dave Korn  <dave.korn.cygwin@gmail.com>\n \n \t* sdbout.c (sdbout_symbol):  Pass VOIDmode to eliminate_regs."}, {"sha": "198fbefc0eb2904f6e555d64283a050fd9e6379c", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e", "patch": "@@ -896,7 +896,6 @@ extern bool purge_dead_edges (basic_block);\n /* In cfgbuild.c.  */\n extern void find_many_sub_basic_blocks (sbitmap);\n extern void rtl_make_eh_edge (sbitmap, basic_block, rtx);\n-extern void find_basic_blocks (rtx);\n \n /* In cfgcleanup.c.  */\n extern bool cleanup_cfg (int);"}, {"sha": "1c91ddbf32d528d65e4d40281520d70c80a58ff5", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e", "patch": "@@ -19,16 +19,6 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* find_basic_blocks divides the current function's rtl into basic\n-   blocks and constructs the CFG.  The blocks are recorded in the\n-   basic_block_info array; the CFG exists in the edge structures\n-   referenced by the blocks.\n-\n-   find_basic_blocks also finds any unreachable loops and deletes them.\n-\n-   Available functionality:\n-     - CFG construction\n-\t find_basic_blocks  */\n \f\n #include \"config.h\"\n #include \"system.h\"\n@@ -46,8 +36,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"timevar.h\"\n \n-static int count_basic_blocks (const_rtx);\n-static void find_basic_blocks_1 (rtx);\n static void make_edges (basic_block, basic_block, int);\n static void make_label_edge (sbitmap, basic_block, rtx, int);\n static void find_bb_boundaries (basic_block);\n@@ -138,45 +126,6 @@ control_flow_insn_p (const_rtx insn)\n     }\n }\n \n-/* Count the basic blocks of the function.  */\n-\n-static int\n-count_basic_blocks (const_rtx f)\n-{\n-  int count = NUM_FIXED_BLOCKS;\n-  bool saw_insn = false;\n-  const_rtx insn;\n-\n-  for (insn = f; insn; insn = NEXT_INSN (insn))\n-    {\n-      /* Code labels and barriers causes current basic block to be\n-\t terminated at previous real insn.  */\n-      if ((LABEL_P (insn) || BARRIER_P (insn))\n-\t  && saw_insn)\n-\tcount++, saw_insn = false;\n-\n-      /* Start basic block if needed.  */\n-      if (!saw_insn && inside_basic_block_p (insn))\n-\tsaw_insn = true;\n-\n-      /* Control flow insn causes current basic block to be terminated.  */\n-      if (saw_insn && control_flow_insn_p (insn))\n-\tcount++, saw_insn = false;\n-    }\n-\n-  if (saw_insn)\n-    count++;\n-\n-  /* The rest of the compiler works a bit smoother when we don't have to\n-     check for the edge case of do-nothing functions with no basic blocks.  */\n-  if (count == NUM_FIXED_BLOCKS)\n-    {\n-      emit_use (const0_rtx);\n-      count = NUM_FIXED_BLOCKS + 1;\n-    }\n-\n-  return count;\n-}\n \f\n /* Create an edge between two basic blocks.  FLAGS are auxiliary information\n    about the edge that is accumulated between calls.  */\n@@ -418,157 +367,6 @@ make_edges (basic_block min, basic_block max, int update_p)\n     sbitmap_vector_free (edge_cache);\n }\n \f\n-/* Find all basic blocks of the function whose first insn is F.\n-\n-   Collect and return a list of labels whose addresses are taken.  This\n-   will be used in make_edges for use with computed gotos.  */\n-\n-static void\n-find_basic_blocks_1 (rtx f)\n-{\n-  rtx insn, next;\n-  rtx bb_note = NULL_RTX;\n-  rtx head = NULL_RTX;\n-  rtx end = NULL_RTX;\n-  basic_block prev = ENTRY_BLOCK_PTR;\n-\n-  /* We process the instructions in a slightly different way than we did\n-     previously.  This is so that we see a NOTE_BASIC_BLOCK after we have\n-     closed out the previous block, so that it gets attached at the proper\n-     place.  Since this form should be equivalent to the previous,\n-     count_basic_blocks continues to use the old form as a check.  */\n-\n-  for (insn = f; insn; insn = next)\n-    {\n-      enum rtx_code code = GET_CODE (insn);\n-\n-      next = NEXT_INSN (insn);\n-\n-      if ((LABEL_P (insn) || BARRIER_P (insn))\n-\t  && head)\n-\t{\n-\t  prev = create_basic_block_structure (head, end, bb_note, prev);\n-\t  head = end = NULL_RTX;\n-\t  bb_note = NULL_RTX;\n-\t}\n-\n-      if (inside_basic_block_p (insn))\n-\t{\n-\t  if (head == NULL_RTX)\n-\t    head = insn;\n-\t  end = insn;\n-\t}\n-\n-      if (head && control_flow_insn_p (insn))\n-\t{\n-\t  prev = create_basic_block_structure (head, end, bb_note, prev);\n-\t  head = end = NULL_RTX;\n-\t  bb_note = NULL_RTX;\n-\t}\n-\n-      switch (code)\n-\t{\n-\tcase NOTE:\n-\t  /* Look for basic block notes with which to keep the\n-\t     basic_block_info pointers stable.  Unthread the note now;\n-\t     we'll put it back at the right place in create_basic_block.\n-\t     Or not at all if we've already found a note in this block.  */\n-\t  if (NOTE_INSN_BASIC_BLOCK_P (insn))\n-\t    {\n-\t      if (bb_note == NULL_RTX)\n-\t\tbb_note = insn;\n-\t      else\n-\t\tnext = delete_insn (insn);\n-\t    }\n-\t  break;\n-\n-\tcase CODE_LABEL:\n-\tcase JUMP_INSN:\n-\tcase CALL_INSN:\n-\tcase INSN:\n-\tcase BARRIER:\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-\n-  if (head != NULL_RTX)\n-    create_basic_block_structure (head, end, bb_note, prev);\n-  else if (bb_note)\n-    delete_insn (bb_note);\n-\n-  gcc_assert (last_basic_block == n_basic_blocks);\n-\n-  clear_aux_for_blocks ();\n-}\n-\n-\n-/* Find basic blocks of the current function.\n-   F is the first insn of the function.  */\n-\n-void\n-find_basic_blocks (rtx f)\n-{\n-  basic_block bb;\n-\n-  timevar_push (TV_CFG);\n-\n-  /* Flush out existing data.  */\n-  if (basic_block_info != NULL)\n-    {\n-      clear_edges ();\n-\n-      /* Clear bb->aux on all extant basic blocks.  We'll use this as a\n-\t tag for reuse during create_basic_block, just in case some pass\n-\t copies around basic block notes improperly.  */\n-      FOR_EACH_BB (bb)\n-\tbb->aux = NULL;\n-\n-      basic_block_info = NULL;\n-    }\n-\n-  n_basic_blocks = count_basic_blocks (f);\n-  last_basic_block = NUM_FIXED_BLOCKS;\n-  ENTRY_BLOCK_PTR->next_bb = EXIT_BLOCK_PTR;\n-  EXIT_BLOCK_PTR->prev_bb = ENTRY_BLOCK_PTR;\n-\n-\n-  /* Size the basic block table.  The actual structures will be allocated\n-     by find_basic_blocks_1, since we want to keep the structure pointers\n-     stable across calls to find_basic_blocks.  */\n-  /* ??? This whole issue would be much simpler if we called find_basic_blocks\n-     exactly once, and thereafter we don't have a single long chain of\n-     instructions at all until close to the end of compilation when we\n-     actually lay them out.  */\n-\n-  basic_block_info = VEC_alloc (basic_block, gc, n_basic_blocks);\n-  VEC_safe_grow_cleared (basic_block, gc, basic_block_info, n_basic_blocks);\n-  SET_BASIC_BLOCK (ENTRY_BLOCK, ENTRY_BLOCK_PTR);\n-  SET_BASIC_BLOCK (EXIT_BLOCK, EXIT_BLOCK_PTR);\n-\n-  find_basic_blocks_1 (f);\n-\n-  profile_status = PROFILE_ABSENT;\n-\n-  /* Tell make_edges to examine every block for out-going edges.  */\n-  FOR_EACH_BB (bb)\n-    SET_STATE (bb, BLOCK_NEW);\n-\n-  /* Discover the edges of our cfg.  */\n-  make_edges (ENTRY_BLOCK_PTR->next_bb, EXIT_BLOCK_PTR->prev_bb, 0);\n-\n-  /* Do very simple cleanup now, for the benefit of code that runs between\n-     here and cleanup_cfg, e.g. thread_prologue_and_epilogue_insns.  */\n-  tidy_fallthru_edges ();\n-\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n-  timevar_pop (TV_CFG);\n-}\n-\f\n static void\n mark_tablejump_edge (rtx label)\n {"}, {"sha": "2c65726fe1777e478faf595a5a8e3c472276cda5", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e", "patch": "@@ -829,7 +829,7 @@ tidy_fallthru_edge (edge e)\n /* Fix up edges that now fall through, or rather should now fall through\n    but previously required a jump around now deleted blocks.  Simplify\n    the search by only examining blocks numerically adjacent, since this\n-   is how find_basic_blocks created them.  */\n+   is how they were created.  */\n \n void\n tidy_fallthru_edges (void)\n@@ -852,9 +852,9 @@ tidy_fallthru_edges (void)\n \t a single successor.\n \n \t If we had a conditional branch to the next instruction when\n-\t find_basic_blocks was called, then there will only be one\n-\t out edge for the block which ended with the conditional\n-\t branch (since we do not create duplicate edges).\n+\t CFG was built, then there will only be one out edge for the\n+\t block which ended with the conditional branch (since we do\n+\t not create duplicate edges).\n \n \t Furthermore, the edge will be marked as a fallthru because we\n \t merge the flags for the duplicate edges.  So we do not want to"}, {"sha": "9d573e044cb3642a869968c3dca519d7bb371e97", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e", "patch": "@@ -10623,41 +10623,12 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   insn_locators_alloc ();\n   insns = get_insns ();\n \n-#if 0\n-  if (optimize > 0)\n-    {\n-      /* Initialize the bitmap obstacks.  */\n-      bitmap_obstack_initialize (NULL);\n-      bitmap_obstack_initialize (&reg_obstack);\n-      if (! cfun->cfg)\n-\tinit_flow ();\n-      rtl_register_cfg_hooks ();\n-      init_rtl_bb_info (ENTRY_BLOCK_PTR);\n-      init_rtl_bb_info (EXIT_BLOCK_PTR);\n-      ENTRY_BLOCK_PTR->flags |= BB_RTL;\n-      EXIT_BLOCK_PTR->flags |= BB_RTL;\n-      find_basic_blocks (insns);\n-\n-      if (flag_schedule_insns_after_reload)\n-\t{\n-\t  life_analysis (PROP_FINAL);\n-\n-\t  split_all_insns (1);\n-\n-\t  schedule_insns ();\n-\t}\n-      /* We must split jmp insn in PIC case.  */\n-      else if (flag_pic)\n-\tsplit_all_insns_noflow ();\n-    }\n-#else\n   if (optimize > 0)\n     {\n       if (! cfun->cfg)\n \tinit_flow (cfun);\n       split_all_insns_noflow ();\n     }\n-#endif\n \n   sh_reorg ();\n "}, {"sha": "5a04fa68a8e00abf4d30a150f7b2d7c402d9c464", "filename": "gcc/except.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e", "patch": "@@ -2117,7 +2117,10 @@ sjlj_build_landing_pads (void)\n   free (lp_info);\n }\n \n-void\n+/* After initial rtl generation, call back to finish generating\n+   exception support code.  */\n+\n+static void\n finish_eh_generation (void)\n {\n   basic_block bb;\n@@ -2126,14 +2129,15 @@ finish_eh_generation (void)\n   if (cfun->eh->region_tree == NULL)\n     return;\n \n-  /* The object here is to provide find_basic_blocks with detailed\n-     information (via reachable_handlers) on how exception control\n-     flows within the function.  In this first pass, we can include\n-     type information garnered from ERT_THROW and ERT_ALLOWED_EXCEPTIONS\n-     regions, and hope that it will be useful in deleting unreachable\n-     handlers.  Subsequently, we will generate landing pads which will\n-     connect many of the handlers, and then type information will not\n-     be effective.  Still, this is a win over previous implementations.  */\n+  /* The object here is to provide detailed information (via\n+     reachable_handlers) on how exception control flows within the\n+     function for the CFG construction.  In this first pass, we can\n+     include type information garnered from ERT_THROW and\n+     ERT_ALLOWED_EXCEPTIONS regions, and hope that it will be useful\n+     in deleting unreachable handlers.  Subsequently, we will generate\n+     landing pads which will connect many of the handlers, and then\n+     type information will not be effective.  Still, this is a win\n+     over previous implementations.  */\n \n   /* These registers are used by the landing pads.  Make sure they\n      have been generated.  */"}, {"sha": "cf83af944a6f9cd625092906b9c73ed455efb5f5", "filename": "gcc/except.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=3cabd6d17c8ea1b9a2a7cd666339eb07e736ac6e", "patch": "@@ -151,10 +151,6 @@ extern bool can_throw_external (const_rtx);\n /* Set TREE_NOTHROW and cfun->all_throwers_are_sibcalls.  */\n extern unsigned int set_nothrow_function_flags (void);\n \n-/* After initial rtl generation, call back to finish generating\n-   exception support code.  */\n-extern void finish_eh_generation (void);\n-\n extern void init_eh (void);\n extern void init_eh_for_function (void);\n "}]}