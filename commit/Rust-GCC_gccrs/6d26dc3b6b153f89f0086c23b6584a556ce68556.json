{"sha": "6d26dc3b6b153f89f0086c23b6584a556ce68556", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQyNmRjM2I2YjE1M2Y4OWYwMDg2YzIzYjY1ODRhNTU2Y2U2ODU1Ng==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-04-04T21:53:22Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-04-04T21:53:22Z"}, "message": "frv-protos.h: Add a prototype to frv_legitimate_memory_operand and frv_const_unspec_p.\n\n\t* config/frv/frv-protos.h: Add a prototype to\n\tfrv_legitimate_memory_operand and frv_const_unspec_p.\n\t(frv_unspec): Move from frv.c.\n\t* config/frv/frv.c (frv_unspec): Move to frv-protos.h.\n\t(frv_const_unspec_p, frv_legitimate_memory_operand_): Export.\n\t(ldd_address_operand, fdpic_fptr_operand, frv_load_operand,\n\tgpr_or_fpr_operand, gpr_or_int12_operand,\n\tgpr_fpr_or_int12_operand, fpr_or_int6_operand,\n\tgpr_or_int10_operand, gpr_or_int_operand, int12_operand,\n\tint6_operand, int5_operand, uint5_operand, uint4_operand,\n\tuint1_operand, int_2word_operand, uint16_operand,\n\tupper_int16_operand, integer_register_operand,\n\tgpr_no_subreg_operand, fpr_operand, even_reg_operand,\n\todd_reg_operand, even_gpr_operand, odd_gpr_operand,\n\tquad_fpr_operand, even_fpr_operand, odd_fpr_operand,\n\tdbl_memory_one_insn_operand, dbl_memory_two_insn_operand,\n\tmove_destination_operand, movcc_fp_destination_operand,\n\tfrv_function_symbol_referenced_p, move_source_operand,\n\tcondexec_dest_operand, condexec_source_operand,\n\treg_or_0_operand, lr_operand, fdpic_operand, got12_operand,\n\tconst_unspec_operand, gpr_or_memory_operand,\n\tgpr_or_memory_operand_with_scratch, fpr_or_memory_operand,\n\ticc_operand, fcc_operand, cc_operand, icr_operand,\n\tfcr_operand, cr_operand, call_operand, sibcall_operand,\n\tsymbolic_operand, relational_operator,\n\tinteger_relational_operator, float_relational_operator,\n\tccr_eqne_operator, minmax_operator,\n\tcondexec_si_binary_operator, condexec_si_media_operator,\n\tcondexec_si_divide_operator, condexec_si_unary_operator,\n\tcondexec_sf_conv_operator, condexec_sf_add_operator,\n\tcondexec_memory_operand, intop_compare_operator, acc_operand,\n\teven_acc_operand, quad_acc_operand, accg_operand: Move to\n\tpredicates.md.\n\t* config/frv/frv.h (PREDICATE_CODES): Remove.\n\t* config/frv/frv.md: Include predicates.md.\n\t* config/frv/predicates.md: New.\n\nFrom-SVN: r97577", "tree": {"sha": "7bdc51c7df3d930cfe6e023c853d414a3edd736e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bdc51c7df3d930cfe6e023c853d414a3edd736e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d26dc3b6b153f89f0086c23b6584a556ce68556", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d26dc3b6b153f89f0086c23b6584a556ce68556", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d26dc3b6b153f89f0086c23b6584a556ce68556", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d26dc3b6b153f89f0086c23b6584a556ce68556/comments", "author": null, "committer": null, "parents": [{"sha": "2f84c996da57d734c94dff8a8e913d210a580cc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f84c996da57d734c94dff8a8e913d210a580cc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f84c996da57d734c94dff8a8e913d210a580cc9"}], "stats": {"total": 3335, "additions": 1652, "deletions": 1683}, "files": [{"sha": "63fbd069d3645c0ba01e2abc6329a33e2d6dc9a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d26dc3b6b153f89f0086c23b6584a556ce68556/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d26dc3b6b153f89f0086c23b6584a556ce68556/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d26dc3b6b153f89f0086c23b6584a556ce68556", "patch": "@@ -3,6 +3,43 @@\n \t* config/frv/frv.h (PREDICATE_CODES): Add CONST to\n \tgpr_or_int12_operand.\n \n+\t* config/frv/frv-protos.h: Add a prototype to\n+\tfrv_legitimate_memory_operand and frv_const_unspec_p.\n+\t(frv_unspec): Move from frv.c.\n+\t* config/frv/frv.c (frv_unspec): Move to frv-protos.h.\n+\t(frv_const_unspec_p, frv_legitimate_memory_operand_): Export.\n+\t(ldd_address_operand, fdpic_fptr_operand, frv_load_operand,\n+\tgpr_or_fpr_operand, gpr_or_int12_operand,\n+\tgpr_fpr_or_int12_operand, fpr_or_int6_operand,\n+\tgpr_or_int10_operand, gpr_or_int_operand, int12_operand,\n+\tint6_operand, int5_operand, uint5_operand, uint4_operand,\n+\tuint1_operand, int_2word_operand, uint16_operand,\n+\tupper_int16_operand, integer_register_operand,\n+\tgpr_no_subreg_operand, fpr_operand, even_reg_operand,\n+\todd_reg_operand, even_gpr_operand, odd_gpr_operand,\n+\tquad_fpr_operand, even_fpr_operand, odd_fpr_operand,\n+\tdbl_memory_one_insn_operand, dbl_memory_two_insn_operand,\n+\tmove_destination_operand, movcc_fp_destination_operand,\n+\tfrv_function_symbol_referenced_p, move_source_operand,\n+\tcondexec_dest_operand, condexec_source_operand,\n+\treg_or_0_operand, lr_operand, fdpic_operand, got12_operand,\n+\tconst_unspec_operand, gpr_or_memory_operand,\n+\tgpr_or_memory_operand_with_scratch, fpr_or_memory_operand,\n+\ticc_operand, fcc_operand, cc_operand, icr_operand,\n+\tfcr_operand, cr_operand, call_operand, sibcall_operand,\n+\tsymbolic_operand, relational_operator,\n+\tinteger_relational_operator, float_relational_operator,\n+\tccr_eqne_operator, minmax_operator,\n+\tcondexec_si_binary_operator, condexec_si_media_operator,\n+\tcondexec_si_divide_operator, condexec_si_unary_operator,\n+\tcondexec_sf_conv_operator, condexec_sf_add_operator,\n+\tcondexec_memory_operand, intop_compare_operator, acc_operand,\n+\teven_acc_operand, quad_acc_operand, accg_operand: Move to\n+\tpredicates.md.\n+\t* config/frv/frv.h (PREDICATE_CODES): Remove.\n+\t* config/frv/frv.md: Include predicates.md.\n+\t* config/frv/predicates.md: New.\n+\n 2004-04-04  Richard Sandiford  <rsandifo@redhat.com>\n \n \tPR target/19537"}, {"sha": "89107a022edce8761728bd5c20d6536910a2b0cd", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d26dc3b6b153f89f0086c23b6584a556ce68556/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d26dc3b6b153f89f0086c23b6584a556ce68556/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=6d26dc3b6b153f89f0086c23b6584a556ce68556", "patch": "@@ -205,5 +205,18 @@ extern rtx frv_matching_accg_for_acc\t(rtx);\n extern void frv_expand_fdpic_call\t(rtx *, bool, bool);\n extern rtx frv_gen_GPsym2reg\t\t(rtx, rtx);\n extern void frv_output_dwarf_dtprel\t(FILE *, int, rtx);\n+extern int frv_legitimate_memory_operand (rtx, enum machine_mode, int);\n+\n+/* Information about a relocation unspec.  SYMBOL is the relocation symbol\n+   (a SYMBOL_REF or LABEL_REF), RELOC is the type of relocation and OFFSET\n+   is the constant addend.  */\n+struct frv_unspec {\n+  rtx symbol;\n+  int reloc;\n+  HOST_WIDE_INT offset;\n+};\n+\n+extern bool frv_const_unspec_p (rtx, struct frv_unspec *);\n+\n #endif\n "}, {"sha": "f867159c63914c3019cca9e84fdc81331b8e58be", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 51, "deletions": 1585, "changes": 1636, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d26dc3b6b153f89f0086c23b6584a556ce68556/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d26dc3b6b153f89f0086c23b6584a556ce68556/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=6d26dc3b6b153f89f0086c23b6584a556ce68556", "patch": "@@ -123,15 +123,6 @@ static unsigned int frv_num_nops;\n        REG < REGNO (X) + HARD_REGNO_NREGS (REGNO (X), GET_MODE (X));\t\\\n        REG++)\n \n-/* Information about a relocation unspec.  SYMBOL is the relocation symbol\n-   (a SYMBOL_REF or LABEL_REF), RELOC is the type of relocation and OFFSET\n-   is the constant addend.  */\n-struct frv_unspec {\n-  rtx symbol;\n-  int reloc;\n-  HOST_WIDE_INT offset;\n-};\n-\n /* Temporary register allocation support structure.  */\n typedef struct frv_tmp_reg_struct\n   {\n@@ -256,7 +247,6 @@ static bool frv_handle_option\t\t\t(size_t, const char *, int);\n static int frv_default_flags_for_cpu\t\t(void);\n static int frv_string_begins_with\t\t(tree, const char *);\n static FRV_INLINE bool frv_small_data_reloc_p\t(rtx, int);\n-static FRV_INLINE bool frv_const_unspec_p\t(rtx, struct frv_unspec *);\n static void frv_print_operand_memory_reference_reg\n \t\t\t\t\t\t(FILE *, rtx);\n static void frv_print_operand_memory_reference\t(FILE *, rtx, int);\n@@ -280,7 +270,6 @@ static void frv_frame_access_multi\t\t(frv_frame_accessor_t*,\n static void frv_frame_access_standard_regs\t(enum frv_stack_op,\n \t\t\t\t\t\t frv_stack_t *);\n static struct machine_function *frv_init_machine_status\t\t(void);\n-static int frv_legitimate_memory_operand\t(rtx, enum machine_mode, int);\n static rtx frv_int_to_acc\t\t\t(enum insn_code, int, rtx);\n static enum machine_mode frv_matching_accg_mode\t(enum machine_mode);\n static rtx frv_read_argument\t\t\t(tree *);\n@@ -468,7 +457,7 @@ frv_small_data_reloc_p (rtx symbol, int reloc)\n /* Return true if X is a valid relocation unspec.  If it is, fill in UNSPEC\n    appropriately.  */\n \n-static FRV_INLINE bool\n+bool\n frv_const_unspec_p (rtx x, struct frv_unspec *unspec)\n {\n   if (GET_CODE (x) == CONST)\n@@ -3715,7 +3704,7 @@ frv_find_base_term (rtx x)\n /* Return 1 if operand is a valid FRV address.  CONDEXEC_P is true if\n    the operand is used by a predicated instruction.  */\n \n-static int\n+int\n frv_legitimate_memory_operand (rtx op, enum machine_mode mode, int condexec_p)\n {\n   return ((GET_MODE (op) == mode || mode == VOIDmode)\n@@ -3805,1607 +3794,84 @@ frv_expand_fdpic_call (rtx *operands, bool ret_value, bool sibcall)\n     c = gen_call_fdpicdi (picreg, const0_rtx, lr);\n   emit_call_insn (c);\n }\n-\n-/* An address operand that may use a pair of registers, an addressing\n-   mode that we reject in general.  */\n-\n-int\n-ldd_address_operand (rtx x, enum machine_mode mode)\n-{\n-  if (GET_MODE (x) != mode && GET_MODE (x) != VOIDmode)\n-    return FALSE;\n-\n-  return frv_legitimate_address_p (DImode, x, reload_completed, FALSE, TRUE);\n-}\n-\n-int\n-fdpic_fptr_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-  if (REGNO (op) != FDPIC_FPTR_REGNO && REGNO (op) < FIRST_PSEUDO_REGISTER)\n-    return FALSE;\n-  return TRUE;\n-}\n \f\n-/* Return 1 is OP is a memory operand, or will be turned into one by\n-   reload.  */\n-\n-int\n-frv_load_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (reload_in_progress)\n-    {\n-      rtx tmp = op;\n-      if (GET_CODE (tmp) == SUBREG)\n-\ttmp = SUBREG_REG (tmp);\n-      if (GET_CODE (tmp) == REG\n-\t  && REGNO (tmp) >= FIRST_PSEUDO_REGISTER)\n-\top = reg_equiv_memory_loc[REGNO (tmp)];\n-    }\n-\n-  return op && memory_operand (op, mode);\n-}\n-\n-\n-/* Return 1 if operand is a GPR register or a FPR register.  */\n-\n-int\n-gpr_or_fpr_operand (rtx op, enum machine_mode mode)\n-{\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-\treturn register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  if (GPR_P (regno) || FPR_P (regno) || regno >= FIRST_PSEUDO_REGISTER)\n-    return TRUE;\n-\n-  return FALSE;\n-}\n-\n-/* Return 1 if operand is a GPR register or 12 bit signed immediate.  */\n+/* Look for a SYMBOL_REF of a function in an rtx.  We always want to\n+   process these separately from any offsets, such that we add any\n+   offsets to the function descriptor (the actual pointer), not to the\n+   function address.  */\n \n-int\n-gpr_or_int12_operand (rtx op, enum machine_mode mode)\n+static bool\n+frv_function_symbol_referenced_p (rtx x)\n {\n-  if (GET_CODE (op) == CONST_INT)\n-    return IN_RANGE_P (INTVAL (op), -2048, 2047);\n+  const char *format;\n+  int length;\n+  int j;\n \n-  if (got12_operand (op, mode))\n-    return true;\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    return SYMBOL_REF_FUNCTION_P (x);\n \n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n+  length = GET_RTX_LENGTH (GET_CODE (x));\n+  format = GET_RTX_FORMAT (GET_CODE (x));\n \n-  if (GET_CODE (op) == SUBREG)\n+  for (j = 0; j < length; ++j)\n     {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-\treturn register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  return GPR_OR_PSEUDO_P (REGNO (op));\n-}\n-\n-/* Return 1 if operand is a GPR register, or a FPR register, or a 12 bit\n-   signed immediate.  */\n-\n-int\n-gpr_fpr_or_int12_operand (rtx op, enum machine_mode mode)\n-{\n-  int regno;\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    return IN_RANGE_P (INTVAL (op), -2048, 2047);\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n+      switch (format[j])\n+\t{\n+\tcase 'e':\n+\t  if (frv_function_symbol_referenced_p (XEXP (x, j)))\n+\t    return TRUE;\n+\t  break;\n \n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-\treturn register_operand (op, mode);\n+\tcase 'V':\n+\tcase 'E':\n+\t  if (XVEC (x, j) != 0)\n+\t    {\n+\t      int k;\n+\t      for (k = 0; k < XVECLEN (x, j); ++k)\n+\t\tif (frv_function_symbol_referenced_p (XVECEXP (x, j, k)))\n+\t\t  return TRUE;\n+\t    }\n+\t  break;\n \n-      op = SUBREG_REG (op);\n+\tdefault:\n+\t  /* Nothing to do.  */\n+\t  break;\n+\t}\n     }\n \n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  if (GPR_P (regno) || FPR_P (regno) || regno >= FIRST_PSEUDO_REGISTER)\n-    return TRUE;\n-\n   return FALSE;\n }\n \n-/* Return 1 if operand is a register or 6 bit signed immediate.  */\n-\n-int\n-fpr_or_int6_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return IN_RANGE_P (INTVAL (op), -32, 31);\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-\treturn register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  return FPR_OR_PSEUDO_P (REGNO (op));\n-}\n-\n-/* Return 1 if operand is a register or 10 bit signed immediate.  */\n-\n-int\n-gpr_or_int10_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return IN_RANGE_P (INTVAL (op), -512, 511);\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-\treturn register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  return GPR_OR_PSEUDO_P (REGNO (op));\n-}\n-\n-/* Return 1 if operand is a register or an integer immediate.  */\n-\n-int\n-gpr_or_int_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return TRUE;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-\treturn register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  return GPR_OR_PSEUDO_P (REGNO (op));\n-}\n-\n-/* Return 1 if operand is a 12 bit signed immediate.  */\n+/* Return true if the memory operand is one that can be conditionally\n+   executed.  */\n \n int\n-int12_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+condexec_memory_operand (rtx op, enum machine_mode mode)\n {\n-  if (GET_CODE (op) != CONST_INT)\n-    return FALSE;\n-\n-  return IN_RANGE_P (INTVAL (op), -2048, 2047);\n-}\n-\n-/* Return 1 if operand is a 6 bit signed immediate.  */\n+  enum machine_mode op_mode = GET_MODE (op);\n+  rtx addr;\n \n-int\n-int6_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != CONST_INT)\n+  if (mode != VOIDmode && op_mode != mode)\n     return FALSE;\n \n-  return IN_RANGE_P (INTVAL (op), -32, 31);\n-}\n-\n-/* Return 1 if operand is a 5 bit signed immediate.  */\n-\n-int\n-int5_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return GET_CODE (op) == CONST_INT && IN_RANGE_P (INTVAL (op), -16, 15);\n-}\n-\n-/* Return 1 if operand is a 5 bit unsigned immediate.  */\n-\n-int\n-uint5_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return GET_CODE (op) == CONST_INT && IN_RANGE_P (INTVAL (op), 0, 31);\n-}\n-\n-/* Return 1 if operand is a 4 bit unsigned immediate.  */\n-\n-int\n-uint4_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return GET_CODE (op) == CONST_INT && IN_RANGE_P (INTVAL (op), 0, 15);\n-}\n-\n-/* Return 1 if operand is a 1 bit unsigned immediate (0 or 1).  */\n-\n-int\n-uint1_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return GET_CODE (op) == CONST_INT && IN_RANGE_P (INTVAL (op), 0, 1);\n-}\n-\n-/* Return 1 if operand is an integer constant that takes 2 instructions\n-   to load up and can be split into sethi/setlo instructions..  */\n-\n-int\n-int_2word_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  HOST_WIDE_INT value;\n-  REAL_VALUE_TYPE rv;\n-  long l;\n-\n-  switch (GET_CODE (op))\n+  switch (op_mode)\n     {\n     default:\n-      break;\n-\n-    case LABEL_REF:\n-      if (TARGET_FDPIC)\n-\treturn FALSE;\n-      \n-      return (flag_pic == 0);\n-\n-    case CONST:\n-      if (flag_pic || TARGET_FDPIC)\n-\treturn FALSE;\n-\n-      op = XEXP (op, 0);\n-      if (GET_CODE (op) == PLUS && GET_CODE (XEXP (op, 1)) == CONST_INT)\n-\top = XEXP (op, 0);\n-      return GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF;\n-\n-    case SYMBOL_REF:\n-      if (TARGET_FDPIC)\n-\treturn FALSE;\n-      \n-      /* small data references are already 1 word */\n-      return (flag_pic == 0) && (! SYMBOL_REF_SMALL_P (op));\n-\n-    case CONST_INT:\n-      return ! IN_RANGE_P (INTVAL (op), -32768, 32767);\n+      return FALSE;\n \n-    case CONST_DOUBLE:\n-      if (GET_MODE (op) == SFmode)\n-\t{\n-\t  REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n-\t  REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n-\t  value = l;\n-\t  return ! IN_RANGE_P (value, -32768, 32767);\n-\t}\n-      else if (GET_MODE (op) == VOIDmode)\n-\t{\n-\t  value = CONST_DOUBLE_LOW (op);\n-\t  return ! IN_RANGE_P (value, -32768, 32767);\n-\t}\n+    case QImode:\n+    case HImode:\n+    case SImode:\n+    case SFmode:\n       break;\n     }\n \n-  return FALSE;\n-}\n-\n-/* Return 1 if operand is a 16 bit unsigned immediate.  */\n-\n-int\n-uint16_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != CONST_INT)\n-    return FALSE;\n-\n-  return IN_RANGE_P (INTVAL (op), 0, 0xffff);\n-}\n-\n-/* Return 1 if operand is an integer constant with the bottom 16 bits\n-   clear.  */\n-\n-int\n-upper_int16_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != CONST_INT)\n-    return FALSE;\n-\n-  return ((INTVAL (op) & 0xffff) == 0);\n-}\n-\n-/* Return true if operand is a GPR register.  */\n-\n-int\n-integer_register_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-\treturn register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  return GPR_OR_PSEUDO_P (REGNO (op));\n-}\n-\n-/* Return true if operand is a GPR register.  Do not allow SUBREG's\n-   here, in order to prevent a combine bug.  */\n-\n-int\n-gpr_no_subreg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) != REG)\n+  if (GET_CODE (op) != MEM)\n     return FALSE;\n \n-  return GPR_OR_PSEUDO_P (REGNO (op));\n+  addr = XEXP (op, 0);\n+  return frv_legitimate_address_p (mode, addr, reload_completed, TRUE, FALSE);\n }\n-\n-/* Return true if operand is a FPR register.  */\n-\n-int\n-fpr_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-        return register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  return FPR_OR_PSEUDO_P (REGNO (op));\n-}\n-\n-/* Return true if operand is an even GPR or FPR register.  */\n-\n-int\n-even_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-        return register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    return TRUE;\n-\n-  if (GPR_P (regno))\n-    return (((regno - GPR_FIRST) & 1) == 0);\n-\n-  if (FPR_P (regno))\n-    return (((regno - FPR_FIRST) & 1) == 0);\n-\n-  return FALSE;\n-}\n-\n-/* Return true if operand is an odd GPR register.  */\n-\n-int\n-odd_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-        return register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  /* Assume that reload will give us an even register.  */\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    return FALSE;\n-\n-  if (GPR_P (regno))\n-    return (((regno - GPR_FIRST) & 1) != 0);\n-\n-  if (FPR_P (regno))\n-    return (((regno - FPR_FIRST) & 1) != 0);\n-\n-  return FALSE;\n-}\n-\n-/* Return true if operand is an even GPR register.  */\n-\n-int\n-even_gpr_operand (rtx op, enum machine_mode mode)\n-{\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-        return register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    return TRUE;\n-\n-  if (! GPR_P (regno))\n-    return FALSE;\n-\n-  return (((regno - GPR_FIRST) & 1) == 0);\n-}\n-\n-/* Return true if operand is an odd GPR register.  */\n-\n-int\n-odd_gpr_operand (rtx op, enum machine_mode mode)\n-{\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-        return register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  /* Assume that reload will give us an even register.  */\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    return FALSE;\n-\n-  if (! GPR_P (regno))\n-    return FALSE;\n-\n-  return (((regno - GPR_FIRST) & 1) != 0);\n-}\n-\n-/* Return true if operand is a quad aligned FPR register.  */\n-\n-int\n-quad_fpr_operand (rtx op, enum machine_mode mode)\n-{\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-        return register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    return TRUE;\n-\n-  if (! FPR_P (regno))\n-    return FALSE;\n-\n-  return (((regno - FPR_FIRST) & 3) == 0);\n-}\n-\n-/* Return true if operand is an even FPR register.  */\n-\n-int\n-even_fpr_operand (rtx op, enum machine_mode mode)\n-{\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-        return register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    return TRUE;\n-\n-  if (! FPR_P (regno))\n-    return FALSE;\n-\n-  return (((regno - FPR_FIRST) & 1) == 0);\n-}\n-\n-/* Return true if operand is an odd FPR register.  */\n-\n-int\n-odd_fpr_operand (rtx op, enum machine_mode mode)\n-{\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-        return register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  /* Assume that reload will give us an even register.  */\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    return FALSE;\n-\n-  if (! FPR_P (regno))\n-    return FALSE;\n-\n-  return (((regno - FPR_FIRST) & 1) != 0);\n-}\n-\n-/* Return true if operand is a 2 word memory address that can be loaded in one\n-   instruction to load or store.  We assume the stack and frame pointers are\n-   suitably aligned, and variables in the small data area.  FIXME -- at some we\n-   should recognize other globals and statics. We can't assume that any old\n-   pointer is aligned, given that arguments could be passed on an odd word on\n-   the stack and the address taken and passed through to another function.  */\n-\n-int\n-dbl_memory_one_insn_operand (rtx op, enum machine_mode mode)\n-{\n-  rtx addr;\n-  rtx addr_reg;\n-\n-  if (! TARGET_DWORD)\n-    return FALSE;\n-\n-  if (GET_CODE (op) != MEM)\n-    return FALSE;\n-\n-  if (mode != VOIDmode && GET_MODE_SIZE (mode) != 2*UNITS_PER_WORD)\n-    return FALSE;\n-\n-  addr = XEXP (op, 0);\n-  if (GET_CODE (addr) == REG)\n-    addr_reg = addr;\n-\n-  else if (GET_CODE (addr) == PLUS)\n-    {\n-      rtx addr0 = XEXP (addr, 0);\n-      rtx addr1 = XEXP (addr, 1);\n-\n-      if (GET_CODE (addr0) != REG)\n-\treturn FALSE;\n-\n-      if (got12_operand (addr1, VOIDmode))\n-\treturn TRUE;\n-\n-      if (GET_CODE (addr1) != CONST_INT)\n-\treturn FALSE;\n-\n-      if ((INTVAL (addr1) & 7) != 0)\n-\treturn FALSE;\n-\n-      addr_reg = addr0;\n-    }\n-\n-  else\n-    return FALSE;\n-\n-  if (addr_reg == frame_pointer_rtx || addr_reg == stack_pointer_rtx)\n-    return TRUE;\n-\n-  return FALSE;\n-}\n-\n-/* Return true if operand is a 2 word memory address that needs to\n-   use two instructions to load or store.  */\n-\n-int\n-dbl_memory_two_insn_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) != MEM)\n-    return FALSE;\n-\n-  if (mode != VOIDmode && GET_MODE_SIZE (mode) != 2*UNITS_PER_WORD)\n-    return FALSE;\n-\n-  if (! TARGET_DWORD)\n-    return TRUE;\n-\n-  return ! dbl_memory_one_insn_operand (op, mode);\n-}\n-\n-/* Return true if operand is something that can be an output for a move\n-   operation.  */\n-\n-int\n-move_destination_operand (rtx op, enum machine_mode mode)\n-{\n-  rtx subreg;\n-  enum rtx_code code;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      break;\n-\n-    case SUBREG:\n-      if (GET_MODE (op) != mode && mode != VOIDmode)\n-        return FALSE;\n-\n-      subreg = SUBREG_REG (op);\n-      code = GET_CODE (subreg);\n-      if (code == MEM)\n-\treturn frv_legitimate_address_p (mode, XEXP (subreg, 0),\n-\t\t\t\t\t reload_completed, FALSE, FALSE);\n-\n-      return (code == REG);\n-\n-    case REG:\n-      if (GET_MODE (op) != mode && mode != VOIDmode)\n-        return FALSE;\n-\n-      return TRUE;\n-\n-    case MEM:\n-      return frv_legitimate_memory_operand (op, mode, FALSE);\n-    }\n-\n-  return FALSE;\n-}\n-\n-/* Return true if we the operand is a valid destination for a movcc_fp\n-   instruction.  This means rejecting fcc_operands, since we need\n-   scratch registers to write to them.  */\n-\n-int\n-movcc_fp_destination_operand (rtx op, enum machine_mode mode)\n-{\n-  if (fcc_operand (op, mode))\n-    return FALSE;\n-\n-  return move_destination_operand (op, mode);\n-}\n-\n-/* Look for a SYMBOL_REF of a function in an rtx.  We always want to\n-   process these separately from any offsets, such that we add any\n-   offsets to the function descriptor (the actual pointer), not to the\n-   function address.  */\n-\n-static bool\n-frv_function_symbol_referenced_p (rtx x)\n-{\n-  const char *format;\n-  int length;\n-  int j;\n-\n-  if (GET_CODE (x) == SYMBOL_REF)\n-    return SYMBOL_REF_FUNCTION_P (x);\n-\n-  length = GET_RTX_LENGTH (GET_CODE (x));\n-  format = GET_RTX_FORMAT (GET_CODE (x));\n-\n-  for (j = 0; j < length; ++j)\n-    {\n-      switch (format[j])\n-\t{\n-\tcase 'e':\n-\t  if (frv_function_symbol_referenced_p (XEXP (x, j)))\n-\t    return TRUE;\n-\t  break;\n-\n-\tcase 'V':\n-\tcase 'E':\n-\t  if (XVEC (x, j) != 0)\n-\t    {\n-\t      int k;\n-\t      for (k = 0; k < XVECLEN (x, j); ++k)\n-\t\tif (frv_function_symbol_referenced_p (XVECEXP (x, j, k)))\n-\t\t  return TRUE;\n-\t    }\n-\t  break;\n-\n-\tdefault:\n-\t  /* Nothing to do.  */\n-\t  break;\n-\t}\n-    }\n-\n-  return FALSE;\n-}\n-\n-/* Return true if operand is something that can be an input for a move\n-   operation.  */\n-\n-int\n-move_source_operand (rtx op, enum machine_mode mode)\n-{\n-  rtx subreg;\n-  enum rtx_code code;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      break;\n-\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-      return immediate_operand (op, mode);\n-\n-    case SUBREG:\n-      if (GET_MODE (op) != mode && mode != VOIDmode)\n-        return FALSE;\n-\n-      subreg = SUBREG_REG (op);\n-      code = GET_CODE (subreg);\n-      if (code == MEM)\n-\treturn frv_legitimate_address_p (mode, XEXP (subreg, 0),\n-\t\t\t\t\t reload_completed, FALSE, FALSE);\n-\n-      return (code == REG);\n-\n-    case REG:\n-      if (GET_MODE (op) != mode && mode != VOIDmode)\n-        return FALSE;\n-\n-      return TRUE;\n-\n-    case MEM:\n-      return frv_legitimate_memory_operand (op, mode, FALSE);\n-    }\n-\n-  return FALSE;\n-}\n-\n-/* Return true if operand is something that can be an output for a conditional\n-   move operation.  */\n-\n-int\n-condexec_dest_operand (rtx op, enum machine_mode mode)\n-{\n-  rtx subreg;\n-  enum rtx_code code;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      break;\n-\n-    case SUBREG:\n-      if (GET_MODE (op) != mode && mode != VOIDmode)\n-        return FALSE;\n-\n-      subreg = SUBREG_REG (op);\n-      code = GET_CODE (subreg);\n-      if (code == MEM)\n-\treturn frv_legitimate_address_p (mode, XEXP (subreg, 0),\n-\t\t\t\t\t reload_completed, TRUE, FALSE);\n-\n-      return (code == REG);\n-\n-    case REG:\n-      if (GET_MODE (op) != mode && mode != VOIDmode)\n-        return FALSE;\n-\n-      return TRUE;\n-\n-    case MEM:\n-      return frv_legitimate_memory_operand (op, mode, TRUE);\n-    }\n-\n-  return FALSE;\n-}\n-\n-/* Return true if operand is something that can be an input for a conditional\n-   move operation.  */\n-\n-int\n-condexec_source_operand (rtx op, enum machine_mode mode)\n-{\n-  rtx subreg;\n-  enum rtx_code code;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      break;\n-\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-      return ZERO_P (op);\n-\n-    case SUBREG:\n-      if (GET_MODE (op) != mode && mode != VOIDmode)\n-        return FALSE;\n-\n-      subreg = SUBREG_REG (op);\n-      code = GET_CODE (subreg);\n-      if (code == MEM)\n-\treturn frv_legitimate_address_p (mode, XEXP (subreg, 0),\n-\t\t\t\t\t reload_completed, TRUE, FALSE);\n-\n-      return (code == REG);\n-\n-    case REG:\n-      if (GET_MODE (op) != mode && mode != VOIDmode)\n-        return FALSE;\n-\n-      return TRUE;\n-\n-    case MEM:\n-      return frv_legitimate_memory_operand (op, mode, TRUE);\n-    }\n-\n-  return FALSE;\n-}\n-\n-/* Return true if operand is a register of any flavor or a 0 of the\n-   appropriate type.  */\n-\n-int\n-reg_or_0_operand (rtx op, enum machine_mode mode)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      break;\n-\n-    case REG:\n-    case SUBREG:\n-      if (GET_MODE (op) != mode && mode != VOIDmode)\n-\treturn FALSE;\n-\n-      return register_operand (op, mode);\n-\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-      return ZERO_P (op);\n-    }\n-\n-  return FALSE;\n-}\n-\n-/* Return true if operand is the link register.  */\n-\n-int\n-lr_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (REGNO (op) != LR_REGNO && REGNO (op) < FIRST_PSEUDO_REGISTER)\n-    return FALSE;\n-\n-  return TRUE;\n-}\n-\n-/* Return true if operand is the uClinux PIC register.  */\n-\n-int\n-fdpic_operand (rtx op, enum machine_mode mode)\n-{\n-  if (!TARGET_FDPIC)\n-    return FALSE;\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (REGNO (op) != FDPIC_REGNO && REGNO (op) < FIRST_PSEUDO_REGISTER)\n-    return FALSE;\n-\n-  return TRUE;\n-}\n-\n-int\n-got12_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  struct frv_unspec unspec;\n-\n-  if (frv_const_unspec_p (op, &unspec))\n-    switch (unspec.reloc)\n-      {\n-      case R_FRV_GOT12:\n-      case R_FRV_GOTOFF12:\n-      case R_FRV_FUNCDESC_GOT12:\n-      case R_FRV_FUNCDESC_GOTOFF12:\n-      case R_FRV_GPREL12:\n-      case R_FRV_TLSMOFF12:\n-\treturn true;\n-      }\n-  return false;\n-}\n-\n-/* Return true if OP is a valid const-unspec expression.  */\n-\n-int\n-const_unspec_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  struct frv_unspec unspec;\n-\n-  return frv_const_unspec_p (op, &unspec);\n-}\n-\n-/* Return true if operand is a gpr register or a valid memory operand.  */\n-\n-int\n-gpr_or_memory_operand (rtx op, enum machine_mode mode)\n-{\n-  return (integer_register_operand (op, mode)\n-\t  || frv_legitimate_memory_operand (op, mode, FALSE));\n-}\n-\n-/* Return true if operand is a gpr register, a valid memory operand,\n-   or a memory operand that can be made valid using an additional gpr\n-   register.  */\n-\n-int\n-gpr_or_memory_operand_with_scratch (rtx op, enum machine_mode mode)\n-{\n-  rtx addr;\n-\n-  if (gpr_or_memory_operand (op, mode))\n-    return TRUE;\n-\n-  if (GET_CODE (op) != MEM)\n-    return FALSE;\n-\n-  if (GET_MODE (op) != mode)\n-    return FALSE;\n-\n-  addr = XEXP (op, 0);\n-\n-  if (GET_CODE (addr) != PLUS)\n-    return FALSE;\n-      \n-  if (!integer_register_operand (XEXP (addr, 0), Pmode))\n-    return FALSE;\n-\n-  if (GET_CODE (XEXP (addr, 1)) != CONST_INT)\n-    return FALSE;\n-\n-  return TRUE;\n-}\n-\n-/* Return true if operand is a fpr register or a valid memory operation.  */\n-\n-int\n-fpr_or_memory_operand (rtx op, enum machine_mode mode)\n-{\n-  return (fpr_operand (op, mode)\n-\t  || frv_legitimate_memory_operand (op, mode, FALSE));\n-}\n-\n-/* Return true if operand is an icc register.  */\n-\n-int\n-icc_operand (rtx op, enum machine_mode mode)\n-{\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  return ICC_OR_PSEUDO_P (regno);\n-}\n-\n-/* Return true if operand is an fcc register.  */\n-\n-int\n-fcc_operand (rtx op, enum machine_mode mode)\n-{\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  return FCC_OR_PSEUDO_P (regno);\n-}\n-\n-/* Return true if operand is either an fcc or icc register.  */\n-\n-int\n-cc_operand (rtx op, enum machine_mode mode)\n-{\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  if (CC_OR_PSEUDO_P (regno))\n-    return TRUE;\n-\n-  return FALSE;\n-}\n-\n-/* Return true if operand is an integer CCR register.  */\n-\n-int\n-icr_operand (rtx op, enum machine_mode mode)\n-{\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  return ICR_OR_PSEUDO_P (regno);\n-}\n-\n-/* Return true if operand is an fcc register.  */\n-\n-int\n-fcr_operand (rtx op, enum machine_mode mode)\n-{\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  return FCR_OR_PSEUDO_P (regno);\n-}\n-\n-/* Return true if operand is either an fcc or icc register.  */\n-\n-int\n-cr_operand (rtx op, enum machine_mode mode)\n-{\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  if (CR_OR_PSEUDO_P (regno))\n-    return TRUE;\n-\n-  return FALSE;\n-}\n-\n-/* Return true if operand is a memory reference suitable for a call.  */\n-\n-int\n-call_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode && GET_CODE (op) != CONST_INT)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SYMBOL_REF)\n-    return !TARGET_LONG_CALLS || SYMBOL_REF_LOCAL_P (op);\n-\n-  /* Note this doesn't allow reg+reg or reg+imm12 addressing (which should\n-     never occur anyway), but prevents reload from not handling the case\n-     properly of a call through a pointer on a function that calls\n-     vfork/setjmp, etc. due to the need to flush all of the registers to stack.  */\n-  return gpr_or_int12_operand (op, mode);\n-}\n-\n-/* Return true if operand is a memory reference suitable for a sibcall.  */\n-\n-int\n-sibcall_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode && GET_CODE (op) != CONST_INT)\n-    return FALSE;\n-\n-  /* Note this doesn't allow reg+reg or reg+imm12 addressing (which should\n-     never occur anyway), but prevents reload from not handling the case\n-     properly of a call through a pointer on a function that calls\n-     vfork/setjmp, etc. due to the need to flush all of the registers to stack.  */\n-  return gpr_or_int12_operand (op, mode);\n-}\n-\n-/* Returns 1 if OP is either a SYMBOL_REF or a constant.  */\n-int\n-symbolic_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code c = GET_CODE (op);\n-\n-  if (c == CONST)\n-    {\n-      /* Allow (const:SI (plus:SI (symbol_ref) (const_int))).  */\n-      return GET_MODE (op) == SImode\n-\t&& GET_CODE (XEXP (op, 0)) == PLUS\n-\t&& GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n-\t&& GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT;\n-    }\n-\n-  return c == SYMBOL_REF || c == CONST_INT;\n-}\n-\n-/* Return true if operator is a kind of relational operator.  */\n-\n-int\n-relational_operator (rtx op, enum machine_mode mode)\n-{\n-  return (integer_relational_operator (op, mode)\n-\t  || float_relational_operator (op, mode));\n-}\n-\n-/* Return true if OP is a relational operator suitable for CCmode,\n-   CC_UNSmode or CC_NZmode.  */\n-\n-int\n-integer_relational_operator (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return FALSE;\n-\n-  /* The allowable relations depend on the mode of the ICC register.  */\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      return FALSE;\n-\n-    case EQ:\n-    case NE:\n-    case LT:\n-    case GE:\n-      return (GET_MODE (XEXP (op, 0)) == CC_NZmode\n-\t      || GET_MODE (XEXP (op, 0)) == CCmode);\n-\n-    case LE:\n-    case GT:\n-      return GET_MODE (XEXP (op, 0)) == CCmode;\n-\n-    case GTU:\n-    case GEU:\n-    case LTU:\n-    case LEU:\n-      return (GET_MODE (XEXP (op, 0)) == CC_NZmode\n-\t      || GET_MODE (XEXP (op, 0)) == CC_UNSmode);\n-    }\n-}\n-\n-/* Return true if operator is a floating point relational operator.  */\n-\n-int\n-float_relational_operator (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return FALSE;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      return FALSE;\n-\n-    case EQ: case NE:\n-    case LE: case LT:\n-    case GE: case GT:\n-#if 0\n-    case UEQ: case UNE:\n-    case ULE: case ULT:\n-    case UGE: case UGT:\n-    case ORDERED:\n-    case UNORDERED:\n-#endif\n-      return GET_MODE (XEXP (op, 0)) == CC_FPmode;\n-    }\n-}\n-\n-/* Return true if operator is EQ/NE of a conditional execution register.  */\n-\n-int\n-ccr_eqne_operator (rtx op, enum machine_mode mode)\n-{\n-  enum machine_mode op_mode = GET_MODE (op);\n-  rtx op0;\n-  rtx op1;\n-  int regno;\n-\n-  if (mode != VOIDmode && op_mode != mode)\n-    return FALSE;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      return FALSE;\n-\n-    case EQ:\n-    case NE:\n-      break;\n-    }\n-\n-  op1 = XEXP (op, 1);\n-  if (op1 != const0_rtx)\n-    return FALSE;\n-\n-  op0 = XEXP (op, 0);\n-  if (GET_CODE (op0) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op0);\n-  if (op_mode == CC_CCRmode && CR_OR_PSEUDO_P (regno))\n-    return TRUE;\n-\n-  return FALSE;\n-}\n-\n-/* Return true if operator is a minimum or maximum operator (both signed and\n-   unsigned).  */\n-\n-int\n-minmax_operator (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return FALSE;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      return FALSE;\n-\n-    case SMIN:\n-    case SMAX:\n-    case UMIN:\n-    case UMAX:\n-      break;\n-    }\n-\n-  if (! integer_register_operand (XEXP (op, 0), mode))\n-    return FALSE;\n-\n-  if (! gpr_or_int10_operand (XEXP (op, 1), mode))\n-    return FALSE;\n-\n-  return TRUE;\n-}\n-\n-/* Return true if operator is an integer binary operator that can executed\n-   conditionally and takes 1 cycle.  */\n-\n-int\n-condexec_si_binary_operator (rtx op, enum machine_mode mode)\n-{\n-  enum machine_mode op_mode = GET_MODE (op);\n-\n-  if (mode != VOIDmode && op_mode != mode)\n-    return FALSE;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      return FALSE;\n-\n-    case PLUS:\n-    case MINUS:\n-    case AND:\n-    case IOR:\n-    case XOR:\n-    case ASHIFT:\n-    case ASHIFTRT:\n-    case LSHIFTRT:\n-      return TRUE;\n-    }\n-}\n-\n-/* Return true if operator is an integer binary operator that can be\n-   executed conditionally by a media instruction.  */\n-\n-int\n-condexec_si_media_operator (rtx op, enum machine_mode mode)\n-{\n-  enum machine_mode op_mode = GET_MODE (op);\n-\n-  if (mode != VOIDmode && op_mode != mode)\n-    return FALSE;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      return FALSE;\n-\n-    case AND:\n-    case IOR:\n-    case XOR:\n-      return TRUE;\n-    }\n-}\n-\n-/* Return true if operator is an integer division operator that can executed\n-   conditionally.  */\n-\n-int\n-condexec_si_divide_operator (rtx op, enum machine_mode mode)\n-{\n-  enum machine_mode op_mode = GET_MODE (op);\n-\n-  if (mode != VOIDmode && op_mode != mode)\n-    return FALSE;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      return FALSE;\n-\n-    case DIV:\n-    case UDIV:\n-      return TRUE;\n-    }\n-}\n-\n-/* Return true if operator is an integer unary operator that can executed\n-   conditionally.  */\n-\n-int\n-condexec_si_unary_operator (rtx op, enum machine_mode mode)\n-{\n-  enum machine_mode op_mode = GET_MODE (op);\n-\n-  if (mode != VOIDmode && op_mode != mode)\n-    return FALSE;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      return FALSE;\n-\n-    case NEG:\n-    case NOT:\n-      return TRUE;\n-    }\n-}\n-\n-/* Return true if operator is a conversion-type expression that can be\n-   evaluated conditionally by floating-point instructions.  */\n-\n-int\n-condexec_sf_conv_operator (rtx op, enum machine_mode mode)\n-{\n-  enum machine_mode op_mode = GET_MODE (op);\n-\n-  if (mode != VOIDmode && op_mode != mode)\n-    return FALSE;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      return FALSE;\n-\n-    case NEG:\n-    case ABS:\n-      return TRUE;\n-    }\n-}\n-\n-/* Return true if operator is an addition or subtraction expression.\n-   Such expressions can be evaluated conditionally by floating-point\n-   instructions.  */\n-\n-int\n-condexec_sf_add_operator (rtx op, enum machine_mode mode)\n-{\n-  enum machine_mode op_mode = GET_MODE (op);\n-\n-  if (mode != VOIDmode && op_mode != mode)\n-    return FALSE;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      return FALSE;\n-\n-    case PLUS:\n-    case MINUS:\n-      return TRUE;\n-    }\n-}\n-\n-/* Return true if the memory operand is one that can be conditionally\n-   executed.  */\n-\n-int\n-condexec_memory_operand (rtx op, enum machine_mode mode)\n-{\n-  enum machine_mode op_mode = GET_MODE (op);\n-  rtx addr;\n-\n-  if (mode != VOIDmode && op_mode != mode)\n-    return FALSE;\n-\n-  switch (op_mode)\n-    {\n-    default:\n-      return FALSE;\n-\n-    case QImode:\n-    case HImode:\n-    case SImode:\n-    case SFmode:\n-      break;\n-    }\n-\n-  if (GET_CODE (op) != MEM)\n-    return FALSE;\n-\n-  addr = XEXP (op, 0);\n-  return frv_legitimate_address_p (mode, addr, reload_completed, TRUE, FALSE);\n-}\n-\n-/* Return true if OP is an integer binary operator that can be combined\n-   with a (set ... (compare:CC_NZ ...)) pattern.  */\n-\n-int\n-intop_compare_operator (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && GET_MODE (op) != mode)\n-    return FALSE;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      return FALSE;\n-\n-    case PLUS:\n-    case MINUS:\n-    case AND:\n-    case IOR:\n-    case XOR:\n-    case ASHIFTRT:\n-    case LSHIFTRT:\n-      return GET_MODE (op) == SImode;\n-    }\n-}\n-\n-/* Return 1 if operand is a valid ACC register number.  */\n-\n-int\n-acc_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((mode == VOIDmode || mode == GET_MODE (op))\n-\t  && REG_P (op) && ACC_P (REGNO (op))\n-\t  && ((REGNO (op) - ACC_FIRST) & ~ACC_MASK) == 0);\n-}\n-\n-/* Return 1 if operand is a valid even ACC register number.  */\n-\n-int\n-even_acc_operand (rtx op, enum machine_mode mode)\n-{\n-  return acc_operand (op, mode) && ((REGNO (op) - ACC_FIRST) & 1) == 0;\n-}\n-\n-/* Return 1 if operand is zero or four.  */\n-\n-int\n-quad_acc_operand (rtx op, enum machine_mode mode)\n-{\n-  return acc_operand (op, mode) && ((REGNO (op) - ACC_FIRST) & 3) == 0;\n-}\n-\n-/* Return 1 if operand is a valid ACCG register number.  */\n-\n-int\n-accg_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((mode == VOIDmode || mode == GET_MODE (op))\n-\t  && REG_P (op) && ACCG_P (REGNO (op))\n-\t  && ((REGNO (op) - ACCG_FIRST) & ~ACC_MASK) == 0);\n-}\n-\n \f\n /* Return true if the bare return instruction can be used outside of the\n    epilog code.  For frv, we only do it if there was no stack allocation.  */"}, {"sha": "9961758f611a4c6fe75bbda09efdeae8ba12d22d", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d26dc3b6b153f89f0086c23b6584a556ce68556/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d26dc3b6b153f89f0086c23b6584a556ce68556/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=6d26dc3b6b153f89f0086c23b6584a556ce68556", "patch": "@@ -2758,104 +2758,6 @@ do {                                                                    \\\n \f\n /* Miscellaneous Parameters.  */\n \n-/* Define this if you have defined special-purpose predicates in the file\n-   `MACHINE.c'.  This macro is called within an initializer of an array of\n-   structures.  The first field in the structure is the name of a predicate and\n-   the second field is an array of rtl codes.  For each predicate, list all rtl\n-   codes that can be in expressions matched by the predicate.  The list should\n-   have a trailing comma.  Here is an example of two entries in the list for a\n-   typical RISC machine:\n-\n-        #define PREDICATE_CODES \\\n-          {\"gen_reg_rtx_operand\", {SUBREG, REG}},  \\\n-          {\"reg_or_short_cint_operand\", {SUBREG, REG, CONST_INT}},\n-\n-   Defining this macro does not affect the generated code (however, incorrect\n-   definitions that omit an rtl code that may be matched by the predicate can\n-   cause the compiler to malfunction).  Instead, it allows the table built by\n-   `genrecog' to be more compact and efficient, thus speeding up the compiler.\n-   The most important predicates to include in the list specified by this macro\n-   are thoses used in the most insn patterns.  */\n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-  { \"integer_register_operand\",\t\t{ REG, SUBREG }},\t\t\\\n-  { \"frv_load_operand\",\t\t\t{ REG, SUBREG, MEM }},\t\t\\\n-  { \"gpr_no_subreg_operand\",\t\t{ REG }},\t\t\t\\\n-  { \"gpr_or_fpr_operand\",\t\t{ REG, SUBREG }},\t\t\\\n-  { \"gpr_or_int12_operand\",\t\t{ REG, SUBREG, CONST_INT, CONST }},\t\\\n-  { \"gpr_fpr_or_int12_operand\",\t\t{ REG, SUBREG, CONST_INT }},\t\\\n-  { \"gpr_or_int10_operand\",\t\t{ REG, SUBREG, CONST_INT }},\t\\\n-  { \"gpr_or_int_operand\",\t\t{ REG, SUBREG, CONST_INT }},\t\\\n-  { \"move_source_operand\",\t\t{ REG, SUBREG, CONST_INT, MEM,\t\\\n-\t\t\t\t\t  CONST_DOUBLE, CONST,\t\t\\\n-\t\t\t\t\t  SYMBOL_REF, LABEL_REF }},\t\\\n-  { \"move_destination_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\\\n-  { \"movcc_fp_destination_operand\",\t{ REG, SUBREG, MEM }},\t\t\\\n-  { \"condexec_source_operand\",\t\t{ REG, SUBREG, CONST_INT, MEM,\t\\\n-\t\t\t\t\t  CONST_DOUBLE }},\t\t\\\n-  { \"condexec_dest_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\\\n-  { \"reg_or_0_operand\",\t\t\t{ REG, SUBREG, CONST_INT }},\t\\\n-  { \"lr_operand\",\t\t\t{ REG }},\t\t\t\\\n-  { \"gpr_or_memory_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\\\n-  { \"gpr_or_memory_operand_with_scratch\", { REG, SUBREG, MEM }},\t\\\n-  { \"fpr_or_memory_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\\\n-  { \"int12_operand\",\t\t\t{ CONST_INT }},\t\t\t\\\n-  { \"int_2word_operand\",\t\t{ CONST_INT, CONST_DOUBLE,\t\\\n-\t\t\t\t\t  SYMBOL_REF, LABEL_REF, CONST }}, \\\n-  { \"fdpic_operand\",\t\t\t{ REG }},\t\t\t\\\n-  { \"fdpic_fptr_operand\",\t\t{ REG }},\t\t\t\\\n-  { \"ldd_address_operand\",\t\t{ REG, SUBREG, PLUS }},\t\t\\\n-  { \"got12_operand\",\t\t\t{ CONST }},\t\t\t\\\n-  { \"const_unspec_operand\",\t\t{ CONST }},\t\t\t\\\n-  { \"icc_operand\",\t\t\t{ REG }},\t\t\t\\\n-  { \"fcc_operand\",\t\t\t{ REG }},\t\t\t\\\n-  { \"cc_operand\",\t\t\t{ REG }},\t\t\t\\\n-  { \"icr_operand\",\t\t\t{ REG }},\t\t\t\\\n-  { \"fcr_operand\",\t\t\t{ REG }},\t\t\t\\\n-  { \"cr_operand\",\t\t\t{ REG }},\t\t\t\\\n-  { \"fpr_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"even_reg_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"odd_reg_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"even_gpr_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"odd_gpr_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"quad_fpr_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"even_fpr_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"odd_fpr_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"dbl_memory_one_insn_operand\",\t{ MEM }},\t\t\t\\\n-  { \"dbl_memory_two_insn_operand\",\t{ MEM }},\t\t\t\\\n-  { \"call_operand\",\t\t\t{ REG, SUBREG, CONST_INT,\t\\\n-\t\t\t\t\t  CONST, SYMBOL_REF }}, \t\\\n-  { \"sibcall_operand\",\t\t\t{ REG, SUBREG, CONST_INT,\t\\\n-\t\t\t\t\t  CONST }}, \t\t\t\\\n-  { \"upper_int16_operand\",\t\t{ CONST_INT }},\t\t\t\\\n-  { \"uint16_operand\",\t\t\t{ CONST_INT }},\t\t\t\\\n-  { \"symbolic_operand\",                 { SYMBOL_REF, CONST_INT }},     \\\n-  { \"relational_operator\",\t\t{ EQ, NE, LE, LT, GE, GT,\t\\\n-\t\t\t\t\t  LEU, LTU, GEU, GTU }},\t\\\n-  { \"integer_relational_operator\",\t{ EQ, NE, LE, LT, GE, GT,\t\\\n-\t\t\t\t\t  LEU, LTU, GEU, GTU }},\t\\\n-  { \"float_relational_operator\",\t{ EQ, NE, LE, LT, GE, GT }},\t\\\n-  { \"ccr_eqne_operator\",\t\t{ EQ, NE }},\t\t\t\\\n-  { \"minmax_operator\",\t\t\t{ SMIN, SMAX, UMIN, UMAX }},\t\\\n-  { \"condexec_si_binary_operator\",\t{ PLUS, MINUS, AND, IOR, XOR,\t\\\n-\t\t\t\t\t  ASHIFT, ASHIFTRT, LSHIFTRT }}, \\\n-  { \"condexec_si_media_operator\",\t{ AND, IOR, XOR }},\t\t\\\n-  { \"condexec_si_divide_operator\",\t{ DIV, UDIV }},\t\t\t\\\n-  { \"condexec_si_unary_operator\",\t{ NOT, NEG }},\t\t\t\\\n-  { \"condexec_sf_add_operator\",\t\t{ PLUS, MINUS }},\t\t\\\n-  { \"condexec_sf_conv_operator\",\t{ ABS, NEG }},\t\t\t\\\n-  { \"intop_compare_operator\",\t\t{ PLUS, MINUS, AND, IOR, XOR,\t\\\n-\t\t\t\t\t  ASHIFT, ASHIFTRT, LSHIFTRT }}, \\\n-  { \"fpr_or_int6_operand\",\t\t{ REG, SUBREG, CONST_INT }},\t\\\n-  { \"int6_operand\",\t\t\t{ CONST_INT }},\t\t\t\\\n-  { \"int5_operand\",\t\t\t{ CONST_INT }},\t\t\t\\\n-  { \"uint5_operand\",\t\t\t{ CONST_INT }},\t\t\t\\\n-  { \"uint4_operand\",\t\t\t{ CONST_INT }},\t\t\t\\\n-  { \"uint1_operand\",\t\t\t{ CONST_INT }},\t\t\t\\\n-  { \"acc_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"even_acc_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"quad_acc_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"accg_operand\",\t\t\t{ REG, SUBREG }},\n-\n /* An alias for a machine mode name.  This is the machine mode that elements of\n    a jump-table should have.  */\n #define CASE_VECTOR_MODE SImode"}, {"sha": "3770b790afa69678f322f068f679f41c9a4f1266", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d26dc3b6b153f89f0086c23b6584a556ce68556/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d26dc3b6b153f89f0086c23b6584a556ce68556/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=6d26dc3b6b153f89f0086c23b6584a556ce68556", "patch": "@@ -1504,6 +1504,7 @@\n ;; )\n ;;\n \n+(include \"predicates.md\")\n \f\n ;; ::::::::::::::::::::\n ;; ::"}, {"sha": "656b6950170b84f658236fab56253679288cd433", "filename": "gcc/config/frv/predicates.md", "status": "added", "additions": 1550, "deletions": 0, "changes": 1550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d26dc3b6b153f89f0086c23b6584a556ce68556/gcc%2Fconfig%2Ffrv%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d26dc3b6b153f89f0086c23b6584a556ce68556/gcc%2Fconfig%2Ffrv%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Fpredicates.md?ref=6d26dc3b6b153f89f0086c23b6584a556ce68556", "patch": "@@ -0,0 +1,1550 @@\n+;; Predicate definitions for Frv.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; Return true if operand is a GPR register.\n+\n+(define_predicate \"integer_register_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (GET_CODE (SUBREG_REG (op)) != REG)\n+\treturn register_operand (op, mode);\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  return GPR_OR_PSEUDO_P (REGNO (op));\n+})\n+\n+;; Return 1 is OP is a memory operand, or will be turned into one by\n+;; reload.\n+\n+(define_predicate \"frv_load_operand\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (reload_in_progress)\n+    {\n+      rtx tmp = op;\n+      if (GET_CODE (tmp) == SUBREG)\n+\ttmp = SUBREG_REG (tmp);\n+      if (GET_CODE (tmp) == REG\n+\t  && REGNO (tmp) >= FIRST_PSEUDO_REGISTER)\n+\top = reg_equiv_memory_loc[REGNO (tmp)];\n+    }\n+\n+  return op && memory_operand (op, mode);\n+})\n+\n+;; Return true if operand is a GPR register.  Do not allow SUBREG's\n+;; here, in order to prevent a combine bug.\n+\n+(define_predicate \"gpr_no_subreg_operand\"\n+  (match_code \"reg\")\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  return GPR_OR_PSEUDO_P (REGNO (op));\n+})\n+\n+;; Return 1 if operand is a GPR register or a FPR register.\n+\n+(define_predicate \"gpr_or_fpr_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  int regno;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (GET_CODE (SUBREG_REG (op)) != REG)\n+\treturn register_operand (op, mode);\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  regno = REGNO (op);\n+  if (GPR_P (regno) || FPR_P (regno) || regno >= FIRST_PSEUDO_REGISTER)\n+    return TRUE;\n+\n+  return FALSE;\n+})\n+\n+;; Return 1 if operand is a GPR register or 12 bit signed immediate.\n+\n+(define_predicate \"gpr_or_int12_operand\"\n+  (match_code \"reg,subreg,const_int,const\")\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return IN_RANGE_P (INTVAL (op), -2048, 2047);\n+\n+  if (got12_operand (op, mode))\n+    return true;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (GET_CODE (SUBREG_REG (op)) != REG)\n+\treturn register_operand (op, mode);\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  return GPR_OR_PSEUDO_P (REGNO (op));\n+})\n+\n+;; Return 1 if operand is a GPR register, or a FPR register, or a 12\n+;; bit signed immediate.\n+\n+(define_predicate \"gpr_fpr_or_int12_operand\"\n+  (match_code \"reg,subreg,const_int\")\n+{\n+  int regno;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    return IN_RANGE_P (INTVAL (op), -2048, 2047);\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (GET_CODE (SUBREG_REG (op)) != REG)\n+\treturn register_operand (op, mode);\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  regno = REGNO (op);\n+  if (GPR_P (regno) || FPR_P (regno) || regno >= FIRST_PSEUDO_REGISTER)\n+    return TRUE;\n+\n+  return FALSE;\n+})\n+\n+;; Return 1 if operand is a register or 10 bit signed immediate.\n+\n+(define_predicate \"gpr_or_int10_operand\"\n+  (match_code \"reg,subreg,const_int\")\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return IN_RANGE_P (INTVAL (op), -512, 511);\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (GET_CODE (SUBREG_REG (op)) != REG)\n+\treturn register_operand (op, mode);\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  return GPR_OR_PSEUDO_P (REGNO (op));\n+})\n+\n+;; Return 1 if operand is a register or an integer immediate.\n+\n+(define_predicate \"gpr_or_int_operand\"\n+  (match_code \"reg,subreg,const_int\")\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return TRUE;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (GET_CODE (SUBREG_REG (op)) != REG)\n+\treturn register_operand (op, mode);\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  return GPR_OR_PSEUDO_P (REGNO (op));\n+})\n+\n+;; Return true if operand is something that can be an input for a move\n+;; operation.\n+\n+(define_predicate \"move_source_operand\"\n+  (match_code \"reg,subreg,const_int,mem,const_double,const,symbol_ref,label_ref\")\n+{\n+  rtx subreg;\n+  enum rtx_code code;\n+\n+  switch (GET_CODE (op))\n+    {\n+    default:\n+      break;\n+\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+      return immediate_operand (op, mode);\n+\n+    case SUBREG:\n+      if (GET_MODE (op) != mode && mode != VOIDmode)\n+        return FALSE;\n+\n+      subreg = SUBREG_REG (op);\n+      code = GET_CODE (subreg);\n+      if (code == MEM)\n+\treturn frv_legitimate_address_p (mode, XEXP (subreg, 0),\n+\t\t\t\t\t reload_completed, FALSE, FALSE);\n+\n+      return (code == REG);\n+\n+    case REG:\n+      if (GET_MODE (op) != mode && mode != VOIDmode)\n+        return FALSE;\n+\n+      return TRUE;\n+\n+    case MEM:\n+      return frv_legitimate_memory_operand (op, mode, FALSE);\n+    }\n+\n+  return FALSE;\n+})\n+\n+;; Return true if operand is something that can be an output for a\n+;; move operation.\n+\n+(define_predicate \"move_destination_operand\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+  rtx subreg;\n+  enum rtx_code code;\n+\n+  switch (GET_CODE (op))\n+    {\n+    default:\n+      break;\n+\n+    case SUBREG:\n+      if (GET_MODE (op) != mode && mode != VOIDmode)\n+        return FALSE;\n+\n+      subreg = SUBREG_REG (op);\n+      code = GET_CODE (subreg);\n+      if (code == MEM)\n+\treturn frv_legitimate_address_p (mode, XEXP (subreg, 0),\n+\t\t\t\t\t reload_completed, FALSE, FALSE);\n+\n+      return (code == REG);\n+\n+    case REG:\n+      if (GET_MODE (op) != mode && mode != VOIDmode)\n+        return FALSE;\n+\n+      return TRUE;\n+\n+    case MEM:\n+      return frv_legitimate_memory_operand (op, mode, FALSE);\n+    }\n+\n+  return FALSE;\n+})\n+\n+;; Return true if we the operand is a valid destination for a movcc_fp\n+;; instruction.  This means rejecting fcc_operands, since we need\n+;; scratch registers to write to them.\n+\n+(define_predicate \"movcc_fp_destination_operand\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+  if (fcc_operand (op, mode))\n+    return FALSE;\n+\n+  return move_destination_operand (op, mode);\n+})\n+\n+;; Return true if operand is something that can be an input for a\n+;; conditional move operation.\n+\n+(define_predicate \"condexec_source_operand\"\n+  (match_code \"reg,subreg,const_int,mem,const_double\")\n+{\n+  rtx subreg;\n+  enum rtx_code code;\n+\n+  switch (GET_CODE (op))\n+    {\n+    default:\n+      break;\n+\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+      return ZERO_P (op);\n+\n+    case SUBREG:\n+      if (GET_MODE (op) != mode && mode != VOIDmode)\n+        return FALSE;\n+\n+      subreg = SUBREG_REG (op);\n+      code = GET_CODE (subreg);\n+      if (code == MEM)\n+\treturn frv_legitimate_address_p (mode, XEXP (subreg, 0),\n+\t\t\t\t\t reload_completed, TRUE, FALSE);\n+\n+      return (code == REG);\n+\n+    case REG:\n+      if (GET_MODE (op) != mode && mode != VOIDmode)\n+        return FALSE;\n+\n+      return TRUE;\n+\n+    case MEM:\n+      return frv_legitimate_memory_operand (op, mode, TRUE);\n+    }\n+\n+  return FALSE;\n+})\n+\n+;; Return true if operand is something that can be an output for a\n+;; conditional move operation.\n+\n+(define_predicate \"condexec_dest_operand\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+  rtx subreg;\n+  enum rtx_code code;\n+\n+  switch (GET_CODE (op))\n+    {\n+    default:\n+      break;\n+\n+    case SUBREG:\n+      if (GET_MODE (op) != mode && mode != VOIDmode)\n+        return FALSE;\n+\n+      subreg = SUBREG_REG (op);\n+      code = GET_CODE (subreg);\n+      if (code == MEM)\n+\treturn frv_legitimate_address_p (mode, XEXP (subreg, 0),\n+\t\t\t\t\t reload_completed, TRUE, FALSE);\n+\n+      return (code == REG);\n+\n+    case REG:\n+      if (GET_MODE (op) != mode && mode != VOIDmode)\n+        return FALSE;\n+\n+      return TRUE;\n+\n+    case MEM:\n+      return frv_legitimate_memory_operand (op, mode, TRUE);\n+    }\n+\n+  return FALSE;\n+})\n+\n+;; Return true if operand is a register of any flavor or a 0 of the\n+;; appropriate type.\n+\n+(define_predicate \"reg_or_0_operand\"\n+  (match_code \"reg,subreg,const_int\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    default:\n+      break;\n+\n+    case REG:\n+    case SUBREG:\n+      if (GET_MODE (op) != mode && mode != VOIDmode)\n+\treturn FALSE;\n+\n+      return register_operand (op, mode);\n+\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+      return ZERO_P (op);\n+    }\n+\n+  return FALSE;\n+})\n+\n+;; Return true if operand is the link register.\n+\n+(define_predicate \"lr_operand\"\n+  (match_code \"reg\")\n+{\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (REGNO (op) != LR_REGNO && REGNO (op) < FIRST_PSEUDO_REGISTER)\n+    return FALSE;\n+\n+  return TRUE;\n+})\n+\n+;; Return true if operand is a gpr register or a valid memory operand.\n+\n+(define_predicate \"gpr_or_memory_operand\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+  return (integer_register_operand (op, mode)\n+\t  || frv_legitimate_memory_operand (op, mode, FALSE));\n+})\n+\n+;; Return true if operand is a gpr register, a valid memory operand,\n+;; or a memory operand that can be made valid using an additional gpr\n+;; register.\n+\n+(define_predicate \"gpr_or_memory_operand_with_scratch\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+  rtx addr;\n+\n+  if (gpr_or_memory_operand (op, mode))\n+    return TRUE;\n+\n+  if (GET_CODE (op) != MEM)\n+    return FALSE;\n+\n+  if (GET_MODE (op) != mode)\n+    return FALSE;\n+\n+  addr = XEXP (op, 0);\n+\n+  if (GET_CODE (addr) != PLUS)\n+    return FALSE;\n+      \n+  if (!integer_register_operand (XEXP (addr, 0), Pmode))\n+    return FALSE;\n+\n+  if (GET_CODE (XEXP (addr, 1)) != CONST_INT)\n+    return FALSE;\n+\n+  return TRUE;\n+})\n+\n+;; Return true if operand is a fpr register or a valid memory\n+;; operation.\n+\n+(define_predicate \"fpr_or_memory_operand\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+  return (fpr_operand (op, mode)\n+\t  || frv_legitimate_memory_operand (op, mode, FALSE));\n+})\n+\n+;; Return 1 if operand is a 12 bit signed immediate.\n+\n+(define_predicate \"int12_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return FALSE;\n+\n+  return IN_RANGE_P (INTVAL (op), -2048, 2047);\n+})\n+\n+;; Return 1 if operand is an integer constant that takes 2\n+;; instructions to load up and can be split into sethi/setlo\n+;; instructions..\n+\n+(define_predicate \"int_2word_operand\"\n+  (match_code \"const_int,const_double,symbol_ref,label_ref,const\")\n+{\n+  HOST_WIDE_INT value;\n+  REAL_VALUE_TYPE rv;\n+  long l;\n+\n+  switch (GET_CODE (op))\n+    {\n+    default:\n+      break;\n+\n+    case LABEL_REF:\n+      if (TARGET_FDPIC)\n+\treturn FALSE;\n+      \n+      return (flag_pic == 0);\n+\n+    case CONST:\n+      if (flag_pic || TARGET_FDPIC)\n+\treturn FALSE;\n+\n+      op = XEXP (op, 0);\n+      if (GET_CODE (op) == PLUS && GET_CODE (XEXP (op, 1)) == CONST_INT)\n+\top = XEXP (op, 0);\n+      return GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF;\n+\n+    case SYMBOL_REF:\n+      if (TARGET_FDPIC)\n+\treturn FALSE;\n+      \n+      /* small data references are already 1 word */\n+      return (flag_pic == 0) && (! SYMBOL_REF_SMALL_P (op));\n+\n+    case CONST_INT:\n+      return ! IN_RANGE_P (INTVAL (op), -32768, 32767);\n+\n+    case CONST_DOUBLE:\n+      if (GET_MODE (op) == SFmode)\n+\t{\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n+\t  REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n+\t  value = l;\n+\t  return ! IN_RANGE_P (value, -32768, 32767);\n+\t}\n+      else if (GET_MODE (op) == VOIDmode)\n+\t{\n+\t  value = CONST_DOUBLE_LOW (op);\n+\t  return ! IN_RANGE_P (value, -32768, 32767);\n+\t}\n+      break;\n+    }\n+\n+  return FALSE;\n+})\n+\n+;; Return true if operand is the uClinux PIC register.\n+\n+(define_predicate \"fdpic_operand\"\n+  (match_code \"reg\")\n+{\n+  if (!TARGET_FDPIC)\n+    return FALSE;\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (REGNO (op) != FDPIC_REGNO && REGNO (op) < FIRST_PSEUDO_REGISTER)\n+    return FALSE;\n+\n+  return TRUE;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"fdpic_fptr_operand\"\n+  (match_code \"reg\")\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+  if (REGNO (op) != FDPIC_FPTR_REGNO && REGNO (op) < FIRST_PSEUDO_REGISTER)\n+    return FALSE;\n+  return TRUE;\n+})\n+\n+;; An address operand that may use a pair of registers, an addressing\n+;; mode that we reject in general.\n+\n+(define_predicate \"ldd_address_operand\"\n+  (match_code \"reg,subreg,plus\")\n+{\n+  if (GET_MODE (op) != mode && GET_MODE (op) != VOIDmode)\n+    return FALSE;\n+\n+  return frv_legitimate_address_p (DImode, op, reload_completed, FALSE, TRUE);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"got12_operand\"\n+  (match_code \"const\")\n+{\n+  struct frv_unspec unspec;\n+\n+  if (frv_const_unspec_p (op, &unspec))\n+    switch (unspec.reloc)\n+      {\n+      case R_FRV_GOT12:\n+      case R_FRV_GOTOFF12:\n+      case R_FRV_FUNCDESC_GOT12:\n+      case R_FRV_FUNCDESC_GOTOFF12:\n+      case R_FRV_GPREL12:\n+      case R_FRV_TLSMOFF12:\n+\treturn true;\n+      }\n+  return false;\n+})\n+\n+;; Return true if OP is a valid const-unspec expression.\n+\n+(define_predicate \"const_unspec_operand\"\n+  (match_code \"const\")\n+{\n+  struct frv_unspec unspec;\n+\n+  return frv_const_unspec_p (op, &unspec);\n+})\n+\n+;; Return true if operand is an icc register.\n+\n+(define_predicate \"icc_operand\"\n+  (match_code \"reg\")\n+{\n+  int regno;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  regno = REGNO (op);\n+  return ICC_OR_PSEUDO_P (regno);\n+})\n+\n+;; Return true if operand is an fcc register.\n+\n+(define_predicate \"fcc_operand\"\n+  (match_code \"reg\")\n+{\n+  int regno;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  regno = REGNO (op);\n+  return FCC_OR_PSEUDO_P (regno);\n+})\n+\n+;; Return true if operand is either an fcc or icc register.\n+\n+(define_predicate \"cc_operand\"\n+  (match_code \"reg\")\n+{\n+  int regno;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  regno = REGNO (op);\n+  if (CC_OR_PSEUDO_P (regno))\n+    return TRUE;\n+\n+  return FALSE;\n+})\n+\n+;; Return true if operand is an integer CCR register.\n+\n+(define_predicate \"icr_operand\"\n+  (match_code \"reg\")\n+{\n+  int regno;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  regno = REGNO (op);\n+  return ICR_OR_PSEUDO_P (regno);\n+})\n+\n+;; Return true if operand is an fcc register.\n+\n+(define_predicate \"fcr_operand\"\n+  (match_code \"reg\")\n+{\n+  int regno;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  regno = REGNO (op);\n+  return FCR_OR_PSEUDO_P (regno);\n+})\n+\n+;; Return true if operand is either an fcc or icc register.\n+\n+(define_predicate \"cr_operand\"\n+  (match_code \"reg\")\n+{\n+  int regno;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  regno = REGNO (op);\n+  if (CR_OR_PSEUDO_P (regno))\n+    return TRUE;\n+\n+  return FALSE;\n+})\n+\n+;; Return true if operand is a FPR register.\n+\n+(define_predicate \"fpr_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (GET_CODE (SUBREG_REG (op)) != REG)\n+        return register_operand (op, mode);\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  return FPR_OR_PSEUDO_P (REGNO (op));\n+})\n+\n+;; Return true if operand is an even GPR or FPR register.\n+\n+(define_predicate \"even_reg_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  int regno;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (GET_CODE (SUBREG_REG (op)) != REG)\n+        return register_operand (op, mode);\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  regno = REGNO (op);\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    return TRUE;\n+\n+  if (GPR_P (regno))\n+    return (((regno - GPR_FIRST) & 1) == 0);\n+\n+  if (FPR_P (regno))\n+    return (((regno - FPR_FIRST) & 1) == 0);\n+\n+  return FALSE;\n+})\n+\n+;; Return true if operand is an odd GPR register.\n+\n+(define_predicate \"odd_reg_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  int regno;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (GET_CODE (SUBREG_REG (op)) != REG)\n+        return register_operand (op, mode);\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  regno = REGNO (op);\n+  /* Assume that reload will give us an even register.  */\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    return FALSE;\n+\n+  if (GPR_P (regno))\n+    return (((regno - GPR_FIRST) & 1) != 0);\n+\n+  if (FPR_P (regno))\n+    return (((regno - FPR_FIRST) & 1) != 0);\n+\n+  return FALSE;\n+})\n+\n+;; Return true if operand is an even GPR register.\n+\n+(define_predicate \"even_gpr_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  int regno;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (GET_CODE (SUBREG_REG (op)) != REG)\n+        return register_operand (op, mode);\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  regno = REGNO (op);\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    return TRUE;\n+\n+  if (! GPR_P (regno))\n+    return FALSE;\n+\n+  return (((regno - GPR_FIRST) & 1) == 0);\n+})\n+\n+;; Return true if operand is an odd GPR register.\n+\n+(define_predicate \"odd_gpr_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  int regno;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (GET_CODE (SUBREG_REG (op)) != REG)\n+        return register_operand (op, mode);\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  regno = REGNO (op);\n+  /* Assume that reload will give us an even register.  */\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    return FALSE;\n+\n+  if (! GPR_P (regno))\n+    return FALSE;\n+\n+  return (((regno - GPR_FIRST) & 1) != 0);\n+})\n+\n+;; Return true if operand is a quad aligned FPR register.\n+\n+(define_predicate \"quad_fpr_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  int regno;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (GET_CODE (SUBREG_REG (op)) != REG)\n+        return register_operand (op, mode);\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  regno = REGNO (op);\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    return TRUE;\n+\n+  if (! FPR_P (regno))\n+    return FALSE;\n+\n+  return (((regno - FPR_FIRST) & 3) == 0);\n+})\n+\n+;; Return true if operand is an even FPR register.\n+\n+(define_predicate \"even_fpr_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  int regno;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (GET_CODE (SUBREG_REG (op)) != REG)\n+        return register_operand (op, mode);\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  regno = REGNO (op);\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    return TRUE;\n+\n+  if (! FPR_P (regno))\n+    return FALSE;\n+\n+  return (((regno - FPR_FIRST) & 1) == 0);\n+})\n+\n+;; Return true if operand is an odd FPR register.\n+\n+(define_predicate \"odd_fpr_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  int regno;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (GET_CODE (SUBREG_REG (op)) != REG)\n+        return register_operand (op, mode);\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  regno = REGNO (op);\n+  /* Assume that reload will give us an even register.  */\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    return FALSE;\n+\n+  if (! FPR_P (regno))\n+    return FALSE;\n+\n+  return (((regno - FPR_FIRST) & 1) != 0);\n+})\n+\n+;; Return true if operand is a 2 word memory address that can be\n+;; loaded in one instruction to load or store.  We assume the stack\n+;; and frame pointers are suitably aligned, and variables in the small\n+;; data area.  FIXME -- at some we should recognize other globals and\n+;; statics. We can't assume that any old pointer is aligned, given\n+;; that arguments could be passed on an odd word on the stack and the\n+;; address taken and passed through to another function.\n+\n+(define_predicate \"dbl_memory_one_insn_operand\"\n+  (match_code \"mem\")\n+{\n+  rtx addr;\n+  rtx addr_reg;\n+\n+  if (! TARGET_DWORD)\n+    return FALSE;\n+\n+  if (GET_CODE (op) != MEM)\n+    return FALSE;\n+\n+  if (mode != VOIDmode && GET_MODE_SIZE (mode) != 2*UNITS_PER_WORD)\n+    return FALSE;\n+\n+  addr = XEXP (op, 0);\n+  if (GET_CODE (addr) == REG)\n+    addr_reg = addr;\n+\n+  else if (GET_CODE (addr) == PLUS)\n+    {\n+      rtx addr0 = XEXP (addr, 0);\n+      rtx addr1 = XEXP (addr, 1);\n+\n+      if (GET_CODE (addr0) != REG)\n+\treturn FALSE;\n+\n+      if (got12_operand (addr1, VOIDmode))\n+\treturn TRUE;\n+\n+      if (GET_CODE (addr1) != CONST_INT)\n+\treturn FALSE;\n+\n+      if ((INTVAL (addr1) & 7) != 0)\n+\treturn FALSE;\n+\n+      addr_reg = addr0;\n+    }\n+\n+  else\n+    return FALSE;\n+\n+  if (addr_reg == frame_pointer_rtx || addr_reg == stack_pointer_rtx)\n+    return TRUE;\n+\n+  return FALSE;\n+})\n+\n+;; Return true if operand is a 2 word memory address that needs to use\n+;; two instructions to load or store.\n+\n+(define_predicate \"dbl_memory_two_insn_operand\"\n+  (match_code \"mem\")\n+{\n+  if (GET_CODE (op) != MEM)\n+    return FALSE;\n+\n+  if (mode != VOIDmode && GET_MODE_SIZE (mode) != 2*UNITS_PER_WORD)\n+    return FALSE;\n+\n+  if (! TARGET_DWORD)\n+    return TRUE;\n+\n+  return ! dbl_memory_one_insn_operand (op, mode);\n+})\n+\n+;; Return true if operand is a memory reference suitable for a call.\n+\n+(define_predicate \"call_operand\"\n+  (match_code \"reg,subreg,const_int,const,symbol_ref\")\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode && GET_CODE (op) != CONST_INT)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return !TARGET_LONG_CALLS || SYMBOL_REF_LOCAL_P (op);\n+\n+  /* Note this doesn't allow reg+reg or reg+imm12 addressing (which should\n+     never occur anyway), but prevents reload from not handling the case\n+     properly of a call through a pointer on a function that calls\n+     vfork/setjmp, etc. due to the need to flush all of the registers to stack.  */\n+  return gpr_or_int12_operand (op, mode);\n+})\n+\n+;; Return true if operand is a memory reference suitable for a\n+;; sibcall.\n+\n+(define_predicate \"sibcall_operand\"\n+  (match_code \"reg,subreg,const_int,const\")\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode && GET_CODE (op) != CONST_INT)\n+    return FALSE;\n+\n+  /* Note this doesn't allow reg+reg or reg+imm12 addressing (which should\n+     never occur anyway), but prevents reload from not handling the case\n+     properly of a call through a pointer on a function that calls\n+     vfork/setjmp, etc. due to the need to flush all of the registers to stack.  */\n+  return gpr_or_int12_operand (op, mode);\n+})\n+\n+;; Return 1 if operand is an integer constant with the bottom 16 bits\n+;; clear.\n+\n+(define_predicate \"upper_int16_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return FALSE;\n+\n+  return ((INTVAL (op) & 0xffff) == 0);\n+})\n+\n+;; Return 1 if operand is a 16 bit unsigned immediate.\n+\n+(define_predicate \"uint16_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return FALSE;\n+\n+  return IN_RANGE_P (INTVAL (op), 0, 0xffff);\n+})\n+\n+;; Returns 1 if OP is either a SYMBOL_REF or a constant.\n+\n+(define_predicate \"symbolic_operand\"\n+  (match_code \"symbol_ref,const_int\")\n+{\n+  enum rtx_code c = GET_CODE (op);\n+\n+  if (c == CONST)\n+    {\n+      /* Allow (const:SI (plus:SI (symbol_ref) (const_int))).  */\n+      return GET_MODE (op) == SImode\n+\t&& GET_CODE (XEXP (op, 0)) == PLUS\n+\t&& GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n+\t&& GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT;\n+    }\n+\n+  return c == SYMBOL_REF || c == CONST_INT;\n+})\n+\n+;; Return true if operator is a kind of relational operator.\n+\n+(define_predicate \"relational_operator\"\n+  (match_code \"eq,ne,le,lt,ge,gt,leu,ltu,geu,gtu\")\n+{\n+  return (integer_relational_operator (op, mode)\n+\t  || float_relational_operator (op, mode));\n+})\n+\n+;; Return true if OP is a relational operator suitable for CCmode,\n+;; CC_UNSmode or CC_NZmode.\n+\n+(define_predicate \"integer_relational_operator\"\n+  (match_code \"eq,ne,le,lt,ge,gt,leu,ltu,geu,gtu\")\n+{\n+  if (mode != VOIDmode && mode != GET_MODE (op))\n+    return FALSE;\n+\n+  /* The allowable relations depend on the mode of the ICC register.  */\n+  switch (GET_CODE (op))\n+    {\n+    default:\n+      return FALSE;\n+\n+    case EQ:\n+    case NE:\n+    case LT:\n+    case GE:\n+      return (GET_MODE (XEXP (op, 0)) == CC_NZmode\n+\t      || GET_MODE (XEXP (op, 0)) == CCmode);\n+\n+    case LE:\n+    case GT:\n+      return GET_MODE (XEXP (op, 0)) == CCmode;\n+\n+    case GTU:\n+    case GEU:\n+    case LTU:\n+    case LEU:\n+      return (GET_MODE (XEXP (op, 0)) == CC_NZmode\n+\t      || GET_MODE (XEXP (op, 0)) == CC_UNSmode);\n+    }\n+})\n+\n+;; Return true if operator is a floating point relational operator.\n+\n+(define_predicate \"float_relational_operator\"\n+  (match_code \"eq,ne,le,lt,ge,gt\")\n+{\n+  if (mode != VOIDmode && mode != GET_MODE (op))\n+    return FALSE;\n+\n+  switch (GET_CODE (op))\n+    {\n+    default:\n+      return FALSE;\n+\n+    case EQ: case NE:\n+    case LE: case LT:\n+    case GE: case GT:\n+#if 0\n+    case UEQ: case UNE:\n+    case ULE: case ULT:\n+    case UGE: case UGT:\n+    case ORDERED:\n+    case UNORDERED:\n+#endif\n+      return GET_MODE (XEXP (op, 0)) == CC_FPmode;\n+    }\n+})\n+\n+;; Return true if operator is EQ/NE of a conditional execution\n+;; register.\n+\n+(define_predicate \"ccr_eqne_operator\"\n+  (match_code \"eq,ne\")\n+{\n+  enum machine_mode op_mode = GET_MODE (op);\n+  rtx op0;\n+  rtx op1;\n+  int regno;\n+\n+  if (mode != VOIDmode && op_mode != mode)\n+    return FALSE;\n+\n+  switch (GET_CODE (op))\n+    {\n+    default:\n+      return FALSE;\n+\n+    case EQ:\n+    case NE:\n+      break;\n+    }\n+\n+  op1 = XEXP (op, 1);\n+  if (op1 != const0_rtx)\n+    return FALSE;\n+\n+  op0 = XEXP (op, 0);\n+  if (GET_CODE (op0) != REG)\n+    return FALSE;\n+\n+  regno = REGNO (op0);\n+  if (op_mode == CC_CCRmode && CR_OR_PSEUDO_P (regno))\n+    return TRUE;\n+\n+  return FALSE;\n+})\n+\n+;; Return true if operator is a minimum or maximum operator (both\n+;; signed and unsigned).\n+\n+(define_predicate \"minmax_operator\"\n+  (match_code \"smin,smax,umin,umax\")\n+{\n+  if (mode != VOIDmode && mode != GET_MODE (op))\n+    return FALSE;\n+\n+  switch (GET_CODE (op))\n+    {\n+    default:\n+      return FALSE;\n+\n+    case SMIN:\n+    case SMAX:\n+    case UMIN:\n+    case UMAX:\n+      break;\n+    }\n+\n+  if (! integer_register_operand (XEXP (op, 0), mode))\n+    return FALSE;\n+\n+  if (! gpr_or_int10_operand (XEXP (op, 1), mode))\n+    return FALSE;\n+\n+  return TRUE;\n+})\n+\n+;; Return true if operator is an integer binary operator that can\n+;; executed conditionally and takes 1 cycle.\n+\n+(define_predicate \"condexec_si_binary_operator\"\n+  (match_code \"plus,minus,and,ior,xor,ashift,ashiftrt,lshiftrt\")\n+{\n+  enum machine_mode op_mode = GET_MODE (op);\n+\n+  if (mode != VOIDmode && op_mode != mode)\n+    return FALSE;\n+\n+  switch (GET_CODE (op))\n+    {\n+    default:\n+      return FALSE;\n+\n+    case PLUS:\n+    case MINUS:\n+    case AND:\n+    case IOR:\n+    case XOR:\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      return TRUE;\n+    }\n+})\n+\n+;; Return true if operator is an integer binary operator that can be\n+;; executed conditionally by a media instruction.\n+\n+(define_predicate \"condexec_si_media_operator\"\n+  (match_code \"and,ior,xor\")\n+{\n+  enum machine_mode op_mode = GET_MODE (op);\n+\n+  if (mode != VOIDmode && op_mode != mode)\n+    return FALSE;\n+\n+  switch (GET_CODE (op))\n+    {\n+    default:\n+      return FALSE;\n+\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      return TRUE;\n+    }\n+})\n+\n+;; Return true if operator is an integer division operator that can\n+;; executed conditionally.\n+\n+(define_predicate \"condexec_si_divide_operator\"\n+  (match_code \"div,udiv\")\n+{\n+  enum machine_mode op_mode = GET_MODE (op);\n+\n+  if (mode != VOIDmode && op_mode != mode)\n+    return FALSE;\n+\n+  switch (GET_CODE (op))\n+    {\n+    default:\n+      return FALSE;\n+\n+    case DIV:\n+    case UDIV:\n+      return TRUE;\n+    }\n+})\n+\n+;; Return true if operator is an integer unary operator that can\n+;; executed conditionally.\n+\n+(define_predicate \"condexec_si_unary_operator\"\n+  (match_code \"not,neg\")\n+{\n+  enum machine_mode op_mode = GET_MODE (op);\n+\n+  if (mode != VOIDmode && op_mode != mode)\n+    return FALSE;\n+\n+  switch (GET_CODE (op))\n+    {\n+    default:\n+      return FALSE;\n+\n+    case NEG:\n+    case NOT:\n+      return TRUE;\n+    }\n+})\n+\n+;; Return true if operator is an addition or subtraction\n+;; expression. Such expressions can be evaluated conditionally by\n+;; floating-point instructions.\n+\n+(define_predicate \"condexec_sf_add_operator\"\n+  (match_code \"plus,minus\")\n+{\n+  enum machine_mode op_mode = GET_MODE (op);\n+\n+  if (mode != VOIDmode && op_mode != mode)\n+    return FALSE;\n+\n+  switch (GET_CODE (op))\n+    {\n+    default:\n+      return FALSE;\n+\n+    case PLUS:\n+    case MINUS:\n+      return TRUE;\n+    }\n+})\n+\n+;; Return true if operator is a conversion-type expression that can be\n+;; evaluated conditionally by floating-point instructions.\n+\n+(define_predicate \"condexec_sf_conv_operator\"\n+  (match_code \"abs,neg\")\n+{\n+  enum machine_mode op_mode = GET_MODE (op);\n+\n+  if (mode != VOIDmode && op_mode != mode)\n+    return FALSE;\n+\n+  switch (GET_CODE (op))\n+    {\n+    default:\n+      return FALSE;\n+\n+    case NEG:\n+    case ABS:\n+      return TRUE;\n+    }\n+})\n+\n+;; Return true if OP is an integer binary operator that can be\n+;; combined with a (set ... (compare:CC_NZ ...)) pattern.\n+\n+(define_predicate \"intop_compare_operator\"\n+  (match_code \"plus,minus,and,ior,xor,ashift,ashiftrt,lshiftrt\")\n+{\n+  if (mode != VOIDmode && GET_MODE (op) != mode)\n+    return FALSE;\n+\n+  switch (GET_CODE (op))\n+    {\n+    default:\n+      return FALSE;\n+\n+    case PLUS:\n+    case MINUS:\n+    case AND:\n+    case IOR:\n+    case XOR:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      return GET_MODE (op) == SImode;\n+    }\n+})\n+\n+;; Return 1 if operand is a register or 6 bit signed immediate.\n+\n+(define_predicate \"fpr_or_int6_operand\"\n+  (match_code \"reg,subreg,const_int\")\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return IN_RANGE_P (INTVAL (op), -32, 31);\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (GET_CODE (SUBREG_REG (op)) != REG)\n+\treturn register_operand (op, mode);\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  return FPR_OR_PSEUDO_P (REGNO (op));\n+})\n+\n+;; Return 1 if operand is a 6 bit signed immediate.\n+\n+(define_predicate \"int6_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return FALSE;\n+\n+  return IN_RANGE_P (INTVAL (op), -32, 31);\n+})\n+\n+;; Return 1 if operand is a 5 bit signed immediate.\n+\n+(define_predicate \"int5_operand\"\n+  (match_code \"const_int\")\n+{\n+  return GET_CODE (op) == CONST_INT && IN_RANGE_P (INTVAL (op), -16, 15);\n+})\n+\n+;; Return 1 if operand is a 5 bit unsigned immediate.\n+\n+(define_predicate \"uint5_operand\"\n+  (match_code \"const_int\")\n+{\n+  return GET_CODE (op) == CONST_INT && IN_RANGE_P (INTVAL (op), 0, 31);\n+})\n+\n+;; Return 1 if operand is a 4 bit unsigned immediate.\n+\n+(define_predicate \"uint4_operand\"\n+  (match_code \"const_int\")\n+{\n+  return GET_CODE (op) == CONST_INT && IN_RANGE_P (INTVAL (op), 0, 15);\n+})\n+\n+;; Return 1 if operand is a 1 bit unsigned immediate (0 or 1).\n+\n+(define_predicate \"uint1_operand\"\n+  (match_code \"const_int\")\n+{\n+  return GET_CODE (op) == CONST_INT && IN_RANGE_P (INTVAL (op), 0, 1);\n+})\n+\n+;; Return 1 if operand is a valid ACC register number.\n+\n+(define_predicate \"acc_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  return ((mode == VOIDmode || mode == GET_MODE (op))\n+\t  && REG_P (op) && ACC_P (REGNO (op))\n+\t  && ((REGNO (op) - ACC_FIRST) & ~ACC_MASK) == 0);\n+})\n+\n+;; Return 1 if operand is a valid even ACC register number.\n+\n+(define_predicate \"even_acc_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  return acc_operand (op, mode) && ((REGNO (op) - ACC_FIRST) & 1) == 0;\n+})\n+\n+;; Return 1 if operand is zero or four.\n+\n+(define_predicate \"quad_acc_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  return acc_operand (op, mode) && ((REGNO (op) - ACC_FIRST) & 3) == 0;\n+})\n+\n+;; Return 1 if operand is a valid ACCG register number.\n+\n+(define_predicate \"accg_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  return ((mode == VOIDmode || mode == GET_MODE (op))\n+\t  && REG_P (op) && ACCG_P (REGNO (op))\n+\t  && ((REGNO (op) - ACCG_FIRST) & ~ACC_MASK) == 0);\n+})"}]}