{"sha": "e5c4f28a6c44485134c426d5ad4ba3f90cc26a41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVjNGYyOGE2YzQ0NDg1MTM0YzQyNmQ1YWQ0YmEzZjkwY2MyNmE0MQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenth@tat.physik.uni-tuebingen.de", "date": "2005-03-22T20:53:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-03-22T20:53:40Z"}, "message": "cgraphunit.c (cgraph_estimate_size_after_inlining): Compute call cost based on argument sizes.\n\n\n\t* cgraphunit.c (cgraph_estimate_size_after_inlining): Compute\n\tcall cost based on argument sizes.\n\t(cgraph_mark_inline_edge): Avoid inline unit from shringking by\n\tinlining.\n\t* params.def: (max-inline-inssn-single): Set to 450.\n\t(max-inline-insns-auto): Set to 90.\n\t(max-inline-insns-recursive): Set to 450\n\t(max-inline-insns-recursive-auto): Set to 450.\n\t(large-function-insns): Set to 2700.\n\t(inline-call-cost): New parameter.\n\t* tree-inline.c (estimate_move_cost): New function.\n\t(estimate_num_insns_1): Compute move sizes costs by estimate_move_cost\n\tfor non-gimple-regs, set cost to 0 for gimple-regs.  Compute call size\n\tbased on arguments.\n\t* tree-inline.h (estimate_move_cost): Declare.\n\t* invoke.texi: (max-inline-inssn-single): Change default to 450.\n\t(max-inline-insns-auto): Change default to 90.\n\t(max-inline-insns-recursive): Change default to 450\n\t(max-inline-insns-recursive-auto): Change default to 450.\n\t(large-function-insns): Change default to 2700.\n\t(inline-call-cost): Document new parameter.\n\n\t* gcc.dg/winline-6.c: Modify so inlined function have nonzero cost.\n\nCo-Authored-By: Jan Hubicka <jh@suse.cz>\n\nFrom-SVN: r96892", "tree": {"sha": "e6caff86555ce9f9639013c3cd82b4c469828776", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6caff86555ce9f9639013c3cd82b4c469828776"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41/comments", "author": null, "committer": null, "parents": [{"sha": "b360e193505ff0cd9ee72bdb8e232654e625731b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b360e193505ff0cd9ee72bdb8e232654e625731b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b360e193505ff0cd9ee72bdb8e232654e625731b"}], "stats": {"total": 164, "additions": 130, "deletions": 34}, "files": [{"sha": "a48a35e5a2e4e01ef9c4d96e4fc663e7579a8f86", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5c4f28a6c44485134c426d5ad4ba3f90cc26a41", "patch": "@@ -1,3 +1,29 @@\n+2005-03-22  Richard Guenther <rguenth@tat.physik.uni-tuebingen.de>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\t    Steven Bosscher <stevenb@suse.de\n+\n+\t* cgraphunit.c (cgraph_estimate_size_after_inlining): Compute\n+\tcall cost based on argument sizes.\n+\t(cgraph_mark_inline_edge): Avoid inline unit from shringking by\n+\tinlining.\n+\t* params.def: (max-inline-inssn-single): Set to 450.\n+\t(max-inline-insns-auto): Set to 90.\n+\t(max-inline-insns-recursive): Set to 450\n+\t(max-inline-insns-recursive-auto): Set to 450.\n+\t(large-function-insns): Set to 2700.\n+\t(inline-call-cost): New parameter.\n+\t* tree-inline.c (estimate_move_cost): New function.\n+\t(estimate_num_insns_1): Compute move sizes costs by estimate_move_cost\n+\tfor non-gimple-regs, set cost to 0 for gimple-regs.  Compute call size\n+\tbased on arguments.\n+\t* tree-inline.h (estimate_move_cost): Declare.\n+\t* invoke.texi: (max-inline-inssn-single): Change default to 450.\n+\t(max-inline-insns-auto): Change default to 90.\n+\t(max-inline-insns-recursive): Change default to 450\n+\t(max-inline-insns-recursive-auto): Change default to 450.\n+\t(large-function-insns): Change default to 2700.\n+\t(inline-call-cost): Document new parameter.\n+\n 2005-03-22  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/i860/i860.h (target_flags, TARGET_XP, TARGET_SWITCHES)"}, {"sha": "6e864d5e243fcbdfd0a051543926819aa83ee02e", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=e5c4f28a6c44485134c426d5ad4ba3f90cc26a41", "patch": "@@ -1030,7 +1030,12 @@ static int\n cgraph_estimate_size_after_inlining (int times, struct cgraph_node *to,\n \t\t\t\t     struct cgraph_node *what)\n {\n-  return (what->global.insns - INSNS_PER_CALL) * times + to->global.insns;\n+  tree fndecl = what->decl;\n+  tree arg;\n+  int call_insns = PARAM_VALUE (PARAM_INLINE_CALL_COST);\n+  for (arg = DECL_ARGUMENTS (fndecl); arg; arg = TREE_CHAIN (arg))\n+    call_insns += estimate_move_cost (TREE_TYPE (arg));\n+  return (what->global.insns - call_insns) * times + to->global.insns;\n }\n \n /* Estimate the growth caused by inlining NODE into all callees.  */\n@@ -1124,7 +1129,8 @@ cgraph_mark_inline_edge (struct cgraph_edge *e)\n       to->global.insns = new_insns;\n     }\n   gcc_assert (what->global.inlined_to == to);\n-  overall_insns += new_insns - old_insns;\n+  if (new_insns > old_insns)\n+    overall_insns += new_insns - old_insns;\n   ncalls_inlined++;\n }\n "}, {"sha": "bd9f4302de7c54e3d80af8bd897803d5df27baea", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e5c4f28a6c44485134c426d5ad4ba3f90cc26a41", "patch": "@@ -5518,15 +5518,15 @@ This number sets the maximum number of instructions (counted in GCC's\n internal representation) in a single function that the tree inliner\n will consider for inlining.  This only affects functions declared\n inline and methods implemented in a class declaration (C++).\n-The default value is 500.\n+The default value is 450.\n \n @item max-inline-insns-auto\n When you use @option{-finline-functions} (included in @option{-O3}),\n a lot of functions that would otherwise not be considered for inlining\n by the compiler will be investigated.  To those functions, a different\n (more restrictive) limit compared to functions declared inline can\n be applied.\n-The default value is 120.\n+The default value is 90.\n \n @item large-function-insns\n The limit specifying really large functions.  For functions larger than this\n@@ -5535,7 +5535,7 @@ limit after inlining inlining is constrained by\n to avoid extreme compilation time caused by non-linear algorithms used by the\n backend.\n This parameter is ignored when @option{-funit-at-a-time} is not used.\n-The default value is 3000.\n+The default value is 2700.\n \n @item large-function-growth\n Specifies maximal growth of large function caused by inlining in percents.\n@@ -5558,7 +5558,7 @@ For functions declared inline @option{--param max-inline-insns-recursive} is\n taken into acount.  For function not declared inline, recursive inlining\n happens only when @option{-finline-functions} (included in @option{-O3}) is\n enabled and @option{--param max-inline-insns-recursive-auto} is used.  The\n-default value is 500.\n+default value is 450.\n \n @item max-inline-recursive-depth\n @itemx max-inline-recursive-depth-auto\n@@ -5568,7 +5568,16 @@ For functions declared inline @option{--param max-inline-recursive-depth} is\n taken into acount.  For function not declared inline, recursive inlining\n happens only when @option{-finline-functions} (included in @option{-O3}) is\n enabled and @option{--param max-inline-recursive-depth-auto} is used.  The\n-default value is 500.\n+default value is 450.\n+\n+@item inline-call-cost\n+Specify cost of call instruction relative to simple arithmetics operations\n+(having cost of 1).  Increasing this cost disqualify inlinining of non-leaf\n+functions and at same time increase size of leaf function that is believed to\n+reduce function size by being inlined.  In effect it increase amount of\n+inlining for code having large abstraction penalty (many functions that just\n+pass the argumetns to other functions) and decrease inlining for code with low\n+abstraction penalty.  Default value is 16.\n \n @item max-unrolled-insns\n The maximum number of instructions that a loop should have if that loop"}, {"sha": "64cb88040e6fd7d0e2b0911f97e7e18c74ce1ca1", "filename": "gcc/params.def", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=e5c4f28a6c44485134c426d5ad4ba3f90cc26a41", "patch": "@@ -58,10 +58,9 @@ DEFPARAM (PARAM_SRA_FIELD_STRUCTURE_RATIO,\n    of a function counted in internal gcc instructions (not in\n    real machine instructions) that is eligible for inlining\n    by the tree inliner.\n-   The default value is 500.\n+   The default value is 450.\n    Only functions marked inline (or methods defined in the class\n-   definition for C++) are affected by this, unless you set the\n-   -finline-functions (included in -O3) compiler option.\n+   definition for C++) are affected by this.\n    There are more restrictions to inlining: If inlined functions\n    call other functions, the already inlined instructions are\n    counted and once the recursive inline limit (see \n@@ -70,29 +69,29 @@ DEFPARAM (PARAM_SRA_FIELD_STRUCTURE_RATIO,\n DEFPARAM (PARAM_MAX_INLINE_INSNS_SINGLE,\n \t  \"max-inline-insns-single\",\n \t  \"The maximum number of instructions in a single function eligible for inlining\",\n-\t  500, 0, 0)\n+\t  450, 0, 0)\n \n /* The single function inlining limit for functions that are\n    inlined by virtue of -finline-functions (-O3).\n    This limit should be chosen to be below or equal to the limit\n    that is applied to functions marked inlined (or defined in the\n    class declaration in C++) given by the \"max-inline-insns-single\"\n    parameter.\n-   The default value is 150.  */\n+   The default value is 90.  */\n DEFPARAM (PARAM_MAX_INLINE_INSNS_AUTO,\n \t  \"max-inline-insns-auto\",\n \t  \"The maximum number of instructions when automatically inlining\",\n-\t  120, 0, 0)\n+\t  90, 0, 0)\n \n DEFPARAM (PARAM_MAX_INLINE_INSNS_RECURSIVE,\n \t  \"max-inline-insns-recursive\",\n \t  \"The maximum number of instructions inline function can grow to via recursive inlining\",\n-\t  500, 0, 0)\n+\t  450, 0, 0)\n \n DEFPARAM (PARAM_MAX_INLINE_INSNS_RECURSIVE_AUTO,\n \t  \"max-inline-insns-recursive-auto\",\n \t  \"The maximum number of instructions non-inline function can grow to via recursive inlining\",\n-\t  500, 0, 0)\n+\t  450, 0, 0)\n \n DEFPARAM (PARAM_MAX_INLINE_RECURSIVE_DEPTH,\n \t  \"max-inline-recursive-depth\",\n@@ -148,7 +147,7 @@ DEFPARAM(PARAM_MAX_PENDING_LIST_LENGTH,\n DEFPARAM(PARAM_LARGE_FUNCTION_INSNS,\n \t \"large-function-insns\",\n \t \"The size of function body to be considered large\",\n-\t 3000, 0, 0)\n+\t 2700, 0, 0)\n DEFPARAM(PARAM_LARGE_FUNCTION_GROWTH,\n \t \"large-function-growth\",\n \t \"Maximal growth due to inlining of large function (in percent)\",\n@@ -157,6 +156,10 @@ DEFPARAM(PARAM_INLINE_UNIT_GROWTH,\n \t \"inline-unit-growth\",\n \t \"how much can given compilation unit grow because of the inlining (in percent)\",\n \t 50, 0, 0)\n+DEFPARAM(PARAM_INLINE_CALL_COST,\n+\t \"inline-call-cost\",\n+\t \"expense of call operation relative to ordinary aritmetic operations\",\n+\t 16, 0, 0)\n \n /* The GCSE optimization will be disabled if it would require\n    significantly more memory than this value.  */"}, {"sha": "6ea0ee910a549198743641bf4f6c9250bd23784a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e5c4f28a6c44485134c426d5ad4ba3f90cc26a41", "patch": "@@ -1,3 +1,9 @@\n+2005-03-22  Richard Guenther <rguenth@tat.physik.uni-tuebingen.de>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\t    Steven Bosscher <stevenb@suse.de\n+\n+\t* gcc.dg/winline-6.c: Modify so inlined function have nonzero cost.\n+\n 2005-03-22  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/19980"}, {"sha": "dd8d3a81b08e97453416ed0addae39e2eacf2707", "filename": "gcc/testsuite/gcc.dg/winline-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-6.c?ref=e5c4f28a6c44485134c426d5ad4ba3f90cc26a41", "patch": "@@ -17,5 +17,5 @@ inline int q(void)\n }\n inline int t (void)\n {\n-\treturn q ();\t\t /* { dg-warning \"called from here\" } */\n+\treturn q () + 1;\t /* { dg-warning \"called from here\" } */\n }"}, {"sha": "6f46eed8c369fb45ac2b29698ef8c50c64937f95", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 62, "deletions": 17, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=e5c4f28a6c44485134c426d5ad4ba3f90cc26a41", "patch": "@@ -1164,6 +1164,23 @@ inlinable_function_p (tree fn)\n   return inlinable;\n }\n \n+/* Estimate the cost of a memory move.  Use machine dependent\n+   word size and take possible memcpy call into account.  */\n+\n+int\n+estimate_move_cost (tree type)\n+{\n+  HOST_WIDE_INT size;\n+\n+  size = int_size_in_bytes (type);\n+\n+  if (size < 0 || size > MOVE_MAX_PIECES * MOVE_RATIO)\n+    /* Cost of a memcpy call, 3 arguments and the call.  */\n+    return 4;\n+  else\n+    return ((size + MOVE_MAX_PIECES - 1) / MOVE_MAX_PIECES);\n+}\n+\n /* Used by estimate_num_insns.  Estimate number of instructions seen\n    by given statement.  */\n \n@@ -1242,28 +1259,50 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n       *walk_subtrees = 0;\n       return NULL;\n \n-    /* Recognize assignments of large structures and constructors of\n-       big arrays.  */\n+    /* Try to estimate the cost of assignments.  We have three cases to\n+       deal with:\n+\t1) Simple assignments to registers;\n+\t2) Stores to things that must live in memory.  This includes\n+\t   \"normal\" stores to scalars, but also assignments of large\n+\t   structures, or constructors of big arrays;\n+\t3) TARGET_EXPRs.\n+\n+       Let us look at the first two cases, assuming we have \"a = b + C\":\n+       <modify_expr <var_decl \"a\"> <plus_expr <var_decl \"b\"> <constant C>>\n+       If \"a\" is a GIMPLE register, the assignment to it is free on almost\n+       any target, because \"a\" usually ends up in a real register.  Hence\n+       the only cost of this expression comes from the PLUS_EXPR, and we\n+       can ignore the MODIFY_EXPR.\n+       If \"a\" is not a GIMPLE register, the assignment to \"a\" will most\n+       likely be a real store, so the cost of the MODIFY_EXPR is the cost\n+       of moving something into \"a\", which we compute using the function\n+       estimate_move_cost.\n+\n+       The third case deals with TARGET_EXPRs, for which the semantics are\n+       that a temporary is assigned, unless the TARGET_EXPR itself is being\n+       assigned to something else.  In the latter case we do not need the\n+       temporary.  E.g. in <modify_expr <var_decl \"a\"> <target_expr>>, the\n+       MODIFY_EXPR is free.  */\n     case INIT_EXPR:\n     case MODIFY_EXPR:\n-      x = TREE_OPERAND (x, 0);\n-      /* FALLTHRU */\n+      /* Is the right and side a TARGET_EXPR?  */\n+      if (TREE_CODE (TREE_OPERAND (x, 1)) == TARGET_EXPR)\n+\tbreak;\n+      /* ... fall through ...  */\n+\n     case TARGET_EXPR:\n+      x = TREE_OPERAND (x, 0);\n+      /* Is this an assignments to a register?  */\n+      if (is_gimple_reg (x))\n+\tbreak;\n+      /* Otherwise it's a store, so fall through to compute the move cost.  */\n+      \n     case CONSTRUCTOR:\n-      {\n-\tHOST_WIDE_INT size;\n-\n-\tsize = int_size_in_bytes (TREE_TYPE (x));\n-\n-\tif (size < 0 || size > MOVE_MAX_PIECES * MOVE_RATIO)\n-\t  *count += 10;\n-\telse\n-\t  *count += ((size + MOVE_MAX_PIECES - 1) / MOVE_MAX_PIECES);\n-      }\n+      *count += estimate_move_cost (TREE_TYPE (x));\n       break;\n \n-      /* Assign cost of 1 to usual operations.\n-\t ??? We may consider mapping RTL costs to this.  */\n+    /* Assign cost of 1 to usual operations.\n+       ??? We may consider mapping RTL costs to this.  */\n     case COND_EXPR:\n \n     case PLUS_EXPR:\n@@ -1350,6 +1389,7 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case CALL_EXPR:\n       {\n \ttree decl = get_callee_fndecl (x);\n+\ttree arg;\n \n \tif (decl && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL)\n \t  switch (DECL_FUNCTION_CODE (decl))\n@@ -1362,7 +1402,12 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n \t    default:\n \t      break;\n \t    }\n-\t*count += 10;\n+\n+\targ = TREE_OPERAND (x, 1);\n+\tfor (arg = TREE_OPERAND (x, 1); arg; arg = TREE_CHAIN (arg))\n+\t  *count += estimate_move_cost (TREE_TYPE (TREE_VALUE (arg)));\n+\n+\t*count += PARAM_VALUE (PARAM_INLINE_CALL_COST);\n \tbreak;\n       }\n     default:"}, {"sha": "467f6bb929fc7194cdf72340e8b46dc30778df6d", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c4f28a6c44485134c426d5ad4ba3f90cc26a41/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=e5c4f28a6c44485134c426d5ad4ba3f90cc26a41", "patch": "@@ -29,6 +29,7 @@ bool tree_inlinable_function_p (tree);\n tree copy_tree_r (tree *, int *, void *);\n void clone_body (tree, tree, void *);\n tree save_body (tree, tree *, tree *);\n+int estimate_move_cost (tree type);\n int estimate_num_insns (tree expr);\n \n /* 0 if we should not perform inlining."}]}