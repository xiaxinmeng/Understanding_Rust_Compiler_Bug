{"sha": "60c48e4c8d74d72e45418c5c6348c91f5c6aeafa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBjNDhlNGM4ZDc0ZDcyZTQ1NDE4YzVjNjM0OGM5MWY1YzZhZWFmYQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2010-01-09T14:41:35Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2010-01-09T14:41:35Z"}, "message": "re PR debug/42630 (\"-fcompare-debug failure (length)\" with \"-O1 -fvariable-expansion-in-unroller -funroll-loops\")\n\ngcc/ChangeLog:\nPR debug/42630\n* loop-unroll.c (referenced_in_one_insn_in_loop_p): Count debug\nuses in new incoming argument.  Free body.\n(reset_debug_uses_in_loop): New.\n(analyze_insn_to_expand_var): Call the latter if the former found\nanything.  Fix whitespace.  Reject invalid dest overlaps before\ngoing through all insns in the loop.\ngcc/testsuite/ChangeLog:\nPR debug/42630\n* gcc.dg/pr42630.c: New.\n\nFrom-SVN: r155764", "tree": {"sha": "a7af950455aa369113ee72a90484b8e516e2fb82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7af950455aa369113ee72a90484b8e516e2fb82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60c48e4c8d74d72e45418c5c6348c91f5c6aeafa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60c48e4c8d74d72e45418c5c6348c91f5c6aeafa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60c48e4c8d74d72e45418c5c6348c91f5c6aeafa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60c48e4c8d74d72e45418c5c6348c91f5c6aeafa/comments", "author": null, "committer": null, "parents": [{"sha": "bb956f3ea05a1c9b59f21aa776da3f582c00d4e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb956f3ea05a1c9b59f21aa776da3f582c00d4e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb956f3ea05a1c9b59f21aa776da3f582c00d4e0"}], "stats": {"total": 94, "additions": 82, "deletions": 12}, "files": [{"sha": "b38662212dea43bc2c789d06ef2719729dada7c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c48e4c8d74d72e45418c5c6348c91f5c6aeafa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c48e4c8d74d72e45418c5c6348c91f5c6aeafa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60c48e4c8d74d72e45418c5c6348c91f5c6aeafa", "patch": "@@ -1,3 +1,13 @@\n+2010-01-09  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/42630\n+\t* loop-unroll.c (referenced_in_one_insn_in_loop_p): Count debug\n+\tuses in new incoming argument.  Free body.\n+\t(reset_debug_uses_in_loop): New.\n+\t(analyze_insn_to_expand_var): Call the latter if the former found\n+\tanything.  Fix whitespace.  Reject invalid dest overlaps before\n+\tgoing through all insns in the loop.\n+\n 2010-01-09  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR debug/42629"}, {"sha": "231d12db9eb57ae1d969c178cb2e956c5a75a5de", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 58, "deletions": 12, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c48e4c8d74d72e45418c5c6348c91f5c6aeafa/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c48e4c8d74d72e45418c5c6348c91f5c6aeafa/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=60c48e4c8d74d72e45418c5c6348c91f5c6aeafa", "patch": "@@ -1,5 +1,5 @@\n /* Loop unrolling and peeling.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008\n+   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -142,7 +142,7 @@ static void opt_info_start_duplication (struct opt_info *);\n static void apply_opt_in_copies (struct opt_info *, unsigned, bool, bool);\n static void free_opt_info (struct opt_info *);\n static struct var_to_expand *analyze_insn_to_expand_var (struct loop*, rtx);\n-static bool referenced_in_one_insn_in_loop_p (struct loop *, rtx);\n+static bool referenced_in_one_insn_in_loop_p (struct loop *, rtx, int *);\n static struct iv_to_split *analyze_iv_to_split_insn (rtx);\n static void expand_var_during_unrolling (struct var_to_expand *, rtx);\n static void insert_var_expansion_initialization (struct var_to_expand *,\n@@ -1525,10 +1525,13 @@ ve_info_eq (const void *ivts1, const void *ivts2)\n   return i1->insn == i2->insn;\n }\n \n-/* Returns true if REG is referenced in one insn in LOOP.  */\n+/* Returns true if REG is referenced in one nondebug insn in LOOP.\n+   Set *DEBUG_USES to the number of debug insns that reference the\n+   variable.  */\n \n bool\n-referenced_in_one_insn_in_loop_p (struct loop *loop, rtx reg)\n+referenced_in_one_insn_in_loop_p (struct loop *loop, rtx reg,\n+\t\t\t\t  int *debug_uses)\n {\n   basic_block *body, bb;\n   unsigned i;\n@@ -1541,14 +1544,45 @@ referenced_in_one_insn_in_loop_p (struct loop *loop, rtx reg)\n       bb = body[i];\n \n       FOR_BB_INSNS (bb, insn)\n-      {\n-        if (rtx_referenced_p (reg, insn))\n-          count_ref++;\n-      }\n+\tif (!rtx_referenced_p (reg, insn))\n+\t  continue;\n+\telse if (DEBUG_INSN_P (insn))\n+\t  ++*debug_uses;\n+\telse if (++count_ref > 1)\n+\t  break;\n     }\n+  free (body);\n   return (count_ref  == 1);\n }\n \n+/* Reset the DEBUG_USES debug insns in LOOP that reference REG.  */\n+\n+static void\n+reset_debug_uses_in_loop (struct loop *loop, rtx reg, int debug_uses)\n+{\n+  basic_block *body, bb;\n+  unsigned i;\n+  rtx insn;\n+\n+  body = get_loop_body (loop);\n+  for (i = 0; debug_uses && i < loop->num_nodes; i++)\n+    {\n+      bb = body[i];\n+\n+      FOR_BB_INSNS (bb, insn)\n+\tif (!DEBUG_INSN_P (insn) || !rtx_referenced_p (reg, insn))\n+\t  continue;\n+\telse\n+\t  {\n+\t    validate_change (insn, &INSN_VAR_LOCATION_LOC (insn),\n+\t\t\t     gen_rtx_UNKNOWN_VAR_LOC (), 0);\n+\t    if (!--debug_uses)\n+\t      break;\n+\t  }\n+    }\n+  free (body);\n+}\n+\n /* Determine whether INSN contains an accumulator\n    which can be expanded into separate copies,\n    one for each copy of the LOOP body.\n@@ -1579,6 +1613,7 @@ analyze_insn_to_expand_var (struct loop *loop, rtx insn)\n   struct var_to_expand *ves;\n   enum machine_mode mode1, mode2;\n   unsigned accum_pos;\n+  int debug_uses = 0;\n \n   set = single_set (insn);\n   if (!set)\n@@ -1624,15 +1659,15 @@ analyze_insn_to_expand_var (struct loop *loop, rtx insn)\n      the expansions at the end of the computation will yield wrong results\n      for (x = something - x) thus avoid using it in that case.  */\n   if (accum_pos == 1\n-    && GET_CODE (src) == MINUS)\n+      && GET_CODE (src) == MINUS)\n    return NULL;\n \n-  something = (accum_pos == 0)? op2 : op1;\n+  something = (accum_pos == 0) ? op2 : op1;\n \n-  if (!referenced_in_one_insn_in_loop_p (loop, dest))\n+  if (rtx_referenced_p (dest, something))\n     return NULL;\n \n-  if (rtx_referenced_p (dest, something))\n+  if (!referenced_in_one_insn_in_loop_p (loop, dest, &debug_uses))\n     return NULL;\n \n   mode1 = GET_MODE (dest);\n@@ -1650,6 +1685,17 @@ analyze_insn_to_expand_var (struct loop *loop, rtx insn)\n     fprintf (dump_file, \"\\n\");\n   }\n \n+  if (debug_uses)\n+    /* Instead of resetting the debug insns, we could replace each\n+       debug use in the loop with the sum or product of all expanded\n+       accummulators.  Since we'll only know of all expansions at the\n+       end, we'd have to keep track of which vars_to_expand a debug\n+       insn in the loop references, take note of each copy of the\n+       debug insn during unrolling, and when it's all done, compute\n+       the sum or product of each variable and adjust the original\n+       debug insn and each copy thereof.  What a pain!  */\n+    reset_debug_uses_in_loop (loop, dest, debug_uses);\n+\n   /* Record the accumulator to expand.  */\n   ves = XNEW (struct var_to_expand);\n   ves->insn = insn;"}, {"sha": "f9074e3ab60ab6cba92be606c8501a65665991aa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c48e4c8d74d72e45418c5c6348c91f5c6aeafa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c48e4c8d74d72e45418c5c6348c91f5c6aeafa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=60c48e4c8d74d72e45418c5c6348c91f5c6aeafa", "patch": "@@ -1,3 +1,8 @@\n+2010-01-09  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/42630\n+\t* gcc.dg/pr42630.c: New.\n+\n 2010-01-09  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR debug/42629"}, {"sha": "34543dab5e9971439dd66ca1b87a760435d8f216", "filename": "gcc/testsuite/gcc.dg/pr42630.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c48e4c8d74d72e45418c5c6348c91f5c6aeafa/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42630.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c48e4c8d74d72e45418c5c6348c91f5c6aeafa/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42630.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42630.c?ref=60c48e4c8d74d72e45418c5c6348c91f5c6aeafa", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fvariable-expansion-in-unroller -funroll-loops -fcompare-debug\" } */\n+\n+int sum(int *buf, int len)\n+{\n+  int s = 0;\n+  while (--len > 0) s += *buf++;\n+  return s;\n+}"}]}