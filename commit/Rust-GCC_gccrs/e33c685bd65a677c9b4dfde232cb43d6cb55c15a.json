{"sha": "e33c685bd65a677c9b4dfde232cb43d6cb55c15a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTMzYzY4NWJkNjVhNjc3YzliNGRmZGUyMzJjYjQzZDZjYjU1YzE1YQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-04-09T16:05:49Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-04-09T16:05:49Z"}, "message": "* g++.old-deja/g++.abi/cxa_vec.C: New test.\n\nFrom-SVN: r33043", "tree": {"sha": "4c357366e38f40c618b6911c5c8074ff3831c42c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c357366e38f40c618b6911c5c8074ff3831c42c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e33c685bd65a677c9b4dfde232cb43d6cb55c15a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e33c685bd65a677c9b4dfde232cb43d6cb55c15a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e33c685bd65a677c9b4dfde232cb43d6cb55c15a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e33c685bd65a677c9b4dfde232cb43d6cb55c15a/comments", "author": null, "committer": null, "parents": [{"sha": "b8c1233b5e3d2cdc5ab6db633195675b98ee515a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8c1233b5e3d2cdc5ab6db633195675b98ee515a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8c1233b5e3d2cdc5ab6db633195675b98ee515a"}], "stats": {"total": 274, "additions": 274, "deletions": 0}, "files": [{"sha": "6a3136e6c336829ce0c5457baec046454615155b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c685bd65a677c9b4dfde232cb43d6cb55c15a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c685bd65a677c9b4dfde232cb43d6cb55c15a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e33c685bd65a677c9b4dfde232cb43d6cb55c15a", "patch": "@@ -1,3 +1,7 @@\n+2000-04-09  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.old-deja/g++.abi/cxa_vec.C: New test.\n+\n 2000-04-08  Neil Booth  <NeilB@earthling.net>\n \t\n \t* gcc.dg/cpp-nullchar.c: Remove test as"}, {"sha": "e551db59e1b459d85f703476bd927324c88e7b66", "filename": "gcc/testsuite/g++.old-deja/g++.abi/cxa_vec.C", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c685bd65a677c9b4dfde232cb43d6cb55c15a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fcxa_vec.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c685bd65a677c9b4dfde232cb43d6cb55c15a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fcxa_vec.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fcxa_vec.C?ref=e33c685bd65a677c9b4dfde232cb43d6cb55c15a", "patch": "@@ -0,0 +1,270 @@\n+// Test __cxa_vec routines\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 7 Apr 2000 <nathan@nathan@codesourcery.com>\n+\n+#if defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n+#include <cxxabi.h>\n+#include <stdio.h>\n+#include <new>\n+#include <malloc.h>\n+#include <setjmp.h>\n+\n+static int ctor_count = 0;\n+static int dtor_count = 0;\n+static bool dtor_repeat = false;\n+\n+// our pseudo ctors and dtors\n+static void ctor (void *)\n+{\n+  if (!ctor_count)\n+    throw 1;\n+  ctor_count--;\n+}\n+\n+static void dtor (void *)\n+{\n+  if (!dtor_count)\n+    {\n+      if (!dtor_repeat)\n+        dtor_count--;\n+      throw 1;\n+    }\n+  dtor_count--;\n+}\n+\n+// track new and delete\n+static int blocks = 0;\n+void *operator new[] (std::size_t size) throw (std::bad_alloc)\n+{\n+  void *ptr = malloc (size);\n+  \n+  if (!ptr)\n+    throw std::bad_alloc ();\n+  blocks++;\n+  return ptr;\n+}\n+\n+void operator delete[] (void *ptr) throw ()\n+{\n+  if (ptr)\n+    {\n+      free (ptr);\n+      blocks--;\n+    }\n+}\n+static jmp_buf jump;\n+\n+// allocate and delete an array with no problems\n+void test0 ()\n+{\n+  static bool started = false;\n+  \n+  if (!started)\n+    {\n+      started = true;\n+      set_terminate (test0);\n+      \n+      ctor_count = dtor_count = 5;\n+      dtor_repeat = false;\n+      blocks = 0;\n+      \n+      try\n+        {\n+          void *ary = abi::__cxa_vec_new (5, 1, sizeof (std::size_t), ctor, dtor);\n+          abi::__cxa_vec_delete (ary, 1, sizeof (std::size_t), dtor);\n+          if (ctor_count || dtor_count || blocks)\n+            longjmp (jump, 1);\n+        }\n+      catch (...)\n+        {\n+          longjmp (jump, 2);\n+        }\n+    }\n+  else\n+    {\n+      longjmp (jump, 3);\n+    }\n+  return;\n+}\n+\n+// allocate and delete an array with exception on ctor\n+void test1 ()\n+{\n+  static bool started = false;\n+  \n+  if (!started)\n+    {\n+      started = true;\n+      set_terminate (test1);\n+      \n+      ctor_count = dtor_count = 5;\n+      dtor_repeat = false;\n+      blocks = 0;\n+      \n+      ctor_count = 4;\n+      try\n+        {\n+          void *ary = abi::__cxa_vec_new (5, 1, sizeof (std::size_t), ctor, dtor);\n+          longjmp (jump, 1);\n+        }\n+      catch (...)\n+        {\n+          // we expect to get here\n+          if (ctor_count || dtor_count != 1 || blocks)\n+            longjmp (jump, 2);\n+        }\n+    }\n+  else\n+    {\n+      longjmp (jump, 3);\n+    }\n+  return;\n+}\n+\n+// allocate and delete an array with exception on dtor\n+void test2 ()\n+{\n+  static bool started = false;\n+  \n+  if (!started)\n+    {\n+      started = true;\n+      set_terminate (test2);\n+      ctor_count = dtor_count = 5;\n+      dtor_repeat = false;\n+      blocks = 0;\n+      \n+      dtor_count = 3;\n+      try\n+        {\n+          void *ary = abi::__cxa_vec_new (5, 1, sizeof (std::size_t), ctor, dtor);\n+          abi::__cxa_vec_delete (ary, 1, sizeof (std::size_t), dtor);\n+          longjmp (jump, 1);\n+        }\n+      catch (...)\n+        {\n+          // we expect to get here\n+          if (ctor_count || dtor_count != -2u || blocks)\n+            longjmp (jump, 2);\n+        }\n+    }\n+  else\n+    {\n+      longjmp (jump, 3);\n+    }\n+  return;\n+}\n+\n+// allocate an array with double exception on dtor\n+void test3 ()\n+{\n+  static bool started = false;\n+  \n+  if (!started)\n+    {\n+      started = true;\n+      set_terminate (test3);\n+      \n+      ctor_count = dtor_count = 5;\n+      dtor_repeat = false;\n+      blocks = 0;\n+  \n+      dtor_count = 3;\n+      dtor_repeat = true;\n+      try\n+        {\n+          void *ary = abi::__cxa_vec_new (5, 1, sizeof (std::size_t), ctor, dtor);\n+          abi::__cxa_vec_delete (ary, 1, sizeof (std::size_t), dtor);\n+          longjmp (jump, 1);\n+        }\n+      catch (...)\n+        {\n+          // we do not expect to get here\n+          longjmp (jump, 2);\n+        }\n+    }\n+  else\n+    {\n+      // we expect to get here (via terminate)\n+      if (ctor_count || dtor_count || blocks != 1)\n+        longjmp (jump, 3);\n+      longjmp (jump, -1);\n+    }\n+  return;\n+}\n+\n+// allocate an array with exception on ctor and exception in cleanup\n+void test4 ()\n+{\n+  static bool started = false;\n+  \n+  if (!started)\n+    {\n+      started = true;\n+      set_terminate (test4);\n+      \n+      ctor_count = dtor_count = 5;\n+      dtor_repeat = false;\n+      blocks = 0;\n+  \n+      ctor_count = 3;\n+      dtor_count = 2;\n+      try\n+        {\n+          void *ary = abi::__cxa_vec_new (5, 1, sizeof (std::size_t), ctor, dtor);\n+          longjmp (jump, 1);\n+        }\n+      catch (...)\n+        {\n+          // we do not expect to get here\n+          longjmp (jump, 2);\n+        }\n+    }\n+  else\n+    {\n+      // we expect to get here (via terminate)\n+      if (ctor_count || dtor_count != -1u || blocks != 1)\n+        longjmp (jump, 3);\n+      longjmp (jump, -1);\n+    }\n+  return;\n+}\n+\n+static void (*tests[])() =\n+{\n+  test0,\n+  test1,\n+  test2,\n+  test3,\n+  test4,\n+  NULL\n+};\n+\n+int main ()\n+{\n+  int ix;\n+  int n;\n+  int errors = 0;\n+  \n+  for (ix = 0; tests[ix]; ix++)\n+    {\n+      if (n = setjmp (jump))\n+        {\n+          if (n > 0)\n+            {\n+              printf (\"test %d failed %d\\n\", ix, n);\n+              errors++;\n+            }\n+        }\n+      else\n+        tests[ix] ();\n+    }\n+  return errors;\n+}\n+\n+#else\n+int main ()\n+{\n+  return 0;\n+}\n+#endif"}]}