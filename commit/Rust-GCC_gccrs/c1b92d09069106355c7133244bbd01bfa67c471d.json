{"sha": "c1b92d09069106355c7133244bbd01bfa67c471d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFiOTJkMDkwNjkxMDYzNTVjNzEzMzI0NGJiZDAxYmZhNjdjNDcxZA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2002-07-01T19:41:54Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2002-07-01T19:41:54Z"}, "message": "sh.c (langhooks.h): Include.\n\n\t* sh.c (langhooks.h): Include.\n\t(sh_init_builtins, sh_media_init_builtins): New functions.\n\t(sh_expand_builtin, arith_reg_dest,and_operand): Likewise.\n\t(mextr_bit_offset, extend_reg_operand, zero_vec_operand): Likewise.\n\t(sh_rep_vec, sh_1el_vec, sh_const_vec): Likewise.\n\t(builtin_description): New struct tag.\n\t(signature_args, bdesc): New arrays.\n\t(TARGET_INIT_BUILTINS, TARGET_EXPAND_BUILTIN): Undef / define.\n\t(print_operand): Add 'N' modifier.\n\t* sh.h (VECTOR_MODE_SUPPORTED_P): Add SHmedia vector modes.\n\t(EXTRA_CONSTRAINT_U, EXTRA_CONSTRAINT_W): New macros.\n\t(EXTRA_CONSTRAINT): Add 'U' and 'W' cases.\n\t(CONST_COSTS): Add special case for SHmedia AND.\n\t(PREDICATE_CODES): Add and_operand, arith_reg_dest,\n\textend_reg_operand, extend_reg_or_0_operand, mextr_bit_offset,\n\tsh_const_vec, sh_1el_vec, sh_rep_vec, zero_vec_operand.\n\ttarget_operand can also be const or unspec.\n\t* sh.md (UNSPEC_INIT_TRAMP, UNSPEC_FCOSA UNSPEC_FSRRA): New constants.\n\t(UNSPEC_FSINA, UNSPEC_NSB, UNSPEC_ALLOCO): Likewise.\n\t(attribute type): Add new types.\n\t(anddi3): Add splitter.\n\t(movdi_const_16bit+1): Add code to handle vector constants and\n\tbitmasks efficiently.\n\t(shori_media): Have generator function made.\n\t(movv8qi, movv8qi_i, movv8qi_i+1, movv8qi_i+2): New patterns.\n\t(movv8qi_i+3, movv2hi, movv2hi_i, movv4hi, movv4hi_i): Likewise.\n\t(movv2si, movv2si_i, absv2si2, absv4hi2, addv2si3, addv4hi3): Likewise.\n\t(ssaddv2si3, usaddv8qi3, ssaddv4hi3, negcmpeqv8qi): Likewise.\n\t(negcmpeqv2si, negcmpeqv4hi, negcmpgtuv8qi, negcmpgtv2si): Likewise.\n\t(negcmpgtv4hi, mcmv, mcnvs_lw, mcnvs_wb, mcnvs_wub): Likewise.\n\t(mextr_rl, mextr_lr, mextr1, mextr2, mextr3, mextr4, mextr5): Likewise.\n\t(mextr6, mextr7, mmacfx_wl, mmacfx_wl_i, mmacnfx_wl): Likewise.\n\t(mmacnfx_wl_i, mulv2si3, mulv4hi3, mmulfx_l, mmulfx_w): Likewise.\n\t(mmulfxrp_w, mmulhi_wl, mmullo_wl, mmul23_wl, mmul01_wl): Likewise.\n\t(mmulsum_wq, mmulsum_wq_i, mperm_w, mperm_w_little): LIkewise.\n\t(mperm_w_big, mperm_w0, msad_ubq, msad_ubq_i, mshalds_l): Likewise.\n\t(mshalds_w, ashrv2si3, ashrv4hi3, mshards_q, mshfhi_b): Likewise.\n\t(mshflo_b,  mshf4_b, mshf0_b, mshfhi_l, mshflo_l, mshf4_l): Likewsie.\n\t(mshf0_l, mshfhi_w, mshflo_w, mshf4_w, mshf0_w, mshfhi_l_di): Likewise.\n\t(mshfhi_l_di_rev, mshflo_l_di, mshflo_l_di_rev): Likewise.\n\t(mshflo_l_di_x, mshflo_l_di_x_rev, ashlv2si3, ashlv4hi3): Likewise.\n\t(lshrv2si3, lshrv4hi3, subv2si3, subv4hi3, sssubv2si3): Likewise.\n\t(ussubv8qi3, sssubv4hi3, fcosa_s, fsina_s, fipr, fsrra_s): Likewise.\n\t(ftrv): Likewise.\n\n\t(fpu_switch+1, fpu_switch+2): Remove constraint.\n\nFrom-SVN: r55147", "tree": {"sha": "be1b71ef6e68d8c7d646d3f376a8933de3008580", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be1b71ef6e68d8c7d646d3f376a8933de3008580"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1b92d09069106355c7133244bbd01bfa67c471d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1b92d09069106355c7133244bbd01bfa67c471d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1b92d09069106355c7133244bbd01bfa67c471d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1b92d09069106355c7133244bbd01bfa67c471d/comments", "author": null, "committer": null, "parents": [{"sha": "7098b619a0ed14eb3255417bf33923564035329e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7098b619a0ed14eb3255417bf33923564035329e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7098b619a0ed14eb3255417bf33923564035329e"}], "stats": {"total": 1821, "additions": 1791, "deletions": 30}, "files": [{"sha": "a4d02b4b8aeb55eaec2622f92ef9d856e3a4d6cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1b92d09069106355c7133244bbd01bfa67c471d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1b92d09069106355c7133244bbd01bfa67c471d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1b92d09069106355c7133244bbd01bfa67c471d", "patch": "@@ -1,3 +1,52 @@\n+Mon Jul  1 19:55:17 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* sh.c (langhooks.h): Include.\n+\t(sh_init_builtins, sh_media_init_builtins): New functions.\n+\t(sh_expand_builtin, arith_reg_dest,and_operand): Likewise.\n+\t(mextr_bit_offset, extend_reg_operand, zero_vec_operand): Likewise.\n+\t(sh_rep_vec, sh_1el_vec, sh_const_vec): Likewise.\n+\t(builtin_description): New struct tag.\n+\t(signature_args, bdesc): New arrays.\n+\t(TARGET_INIT_BUILTINS, TARGET_EXPAND_BUILTIN): Undef / define.\n+\t(print_operand): Add 'N' modifier.\n+\t* sh.h (VECTOR_MODE_SUPPORTED_P): Add SHmedia vector modes.\n+\t(EXTRA_CONSTRAINT_U, EXTRA_CONSTRAINT_W): New macros.\n+\t(EXTRA_CONSTRAINT): Add 'U' and 'W' cases.\n+\t(CONST_COSTS): Add special case for SHmedia AND.\n+\t(PREDICATE_CODES): Add and_operand, arith_reg_dest,\n+\textend_reg_operand, extend_reg_or_0_operand, mextr_bit_offset,\n+\tsh_const_vec, sh_1el_vec, sh_rep_vec, zero_vec_operand.\n+\ttarget_operand can also be const or unspec.\n+\t* sh.md (UNSPEC_INIT_TRAMP, UNSPEC_FCOSA UNSPEC_FSRRA): New constants.\n+\t(UNSPEC_FSINA, UNSPEC_NSB, UNSPEC_ALLOCO): Likewise.\n+\t(attribute type): Add new types.\n+\t(anddi3): Add splitter.\n+\t(movdi_const_16bit+1): Add code to handle vector constants and\n+\tbitmasks efficiently.\n+\t(shori_media): Have generator function made.\n+\t(movv8qi, movv8qi_i, movv8qi_i+1, movv8qi_i+2): New patterns.\n+\t(movv8qi_i+3, movv2hi, movv2hi_i, movv4hi, movv4hi_i): Likewise.\n+\t(movv2si, movv2si_i, absv2si2, absv4hi2, addv2si3, addv4hi3): Likewise.\n+\t(ssaddv2si3, usaddv8qi3, ssaddv4hi3, negcmpeqv8qi): Likewise.\n+\t(negcmpeqv2si, negcmpeqv4hi, negcmpgtuv8qi, negcmpgtv2si): Likewise.\n+\t(negcmpgtv4hi, mcmv, mcnvs_lw, mcnvs_wb, mcnvs_wub): Likewise.\n+\t(mextr_rl, mextr_lr, mextr1, mextr2, mextr3, mextr4, mextr5): Likewise.\n+\t(mextr6, mextr7, mmacfx_wl, mmacfx_wl_i, mmacnfx_wl): Likewise.\n+\t(mmacnfx_wl_i, mulv2si3, mulv4hi3, mmulfx_l, mmulfx_w): Likewise.\n+\t(mmulfxrp_w, mmulhi_wl, mmullo_wl, mmul23_wl, mmul01_wl): Likewise.\n+\t(mmulsum_wq, mmulsum_wq_i, mperm_w, mperm_w_little): LIkewise.\n+\t(mperm_w_big, mperm_w0, msad_ubq, msad_ubq_i, mshalds_l): Likewise.\n+\t(mshalds_w, ashrv2si3, ashrv4hi3, mshards_q, mshfhi_b): Likewise.\n+\t(mshflo_b,  mshf4_b, mshf0_b, mshfhi_l, mshflo_l, mshf4_l): Likewsie.\n+\t(mshf0_l, mshfhi_w, mshflo_w, mshf4_w, mshf0_w, mshfhi_l_di): Likewise.\n+\t(mshfhi_l_di_rev, mshflo_l_di, mshflo_l_di_rev): Likewise.\n+\t(mshflo_l_di_x, mshflo_l_di_x_rev, ashlv2si3, ashlv4hi3): Likewise.\n+\t(lshrv2si3, lshrv4hi3, subv2si3, subv4hi3, sssubv2si3): Likewise.\n+\t(ussubv8qi3, sssubv4hi3, fcosa_s, fsina_s, fipr, fsrra_s): Likewise.\n+\t(ftrv): Likewise.\n+\n+\t(fpu_switch+1, fpu_switch+2): Remove constraint.\n+\n 2002-07-01  Aldy Hernandez  <aldyh@redhat.com>\n \n         * tree.c (build_function_type_list): Update function comment."}, {"sha": "429eda6d1e0d624573d8caf5b00c83199fef80c6", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 480, "deletions": 3, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1b92d09069106355c7133244bbd01bfa67c471d/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1b92d09069106355c7133244bbd01bfa67c471d/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=c1b92d09069106355c7133244bbd01bfa67c471d", "patch": "@@ -42,6 +42,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"target.h\"\n #include \"target-def.h\"\n #include \"real.h\"\n+#include \"langhooks.h\"\n \n int code_for_indirect_jump_scratch = CODE_FOR_indirect_jump_scratch;\n \n@@ -204,6 +205,10 @@ static bool sh_ms_bitfield_layout_p PARAMS ((tree));\n \n static void sh_encode_section_info PARAMS ((tree, int));\n static const char *sh_strip_name_encoding PARAMS ((const char *));\n+static void sh_init_builtins (void);\n+static void sh_media_init_builtins (void);\n+static rtx sh_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ATTRIBUTE_TABLE\n@@ -247,6 +252,11 @@ static const char *sh_strip_name_encoding PARAMS ((const char *));\n #undef TARGET_STRIP_NAME_ENCODING\n #define TARGET_STRIP_NAME_ENCODING sh_strip_name_encoding\n \n+#undef TARGET_INIT_BUILTINS\n+#define TARGET_INIT_BUILTINS sh_init_builtins\n+#undef TARGET_EXPAND_BUILTIN\n+#define TARGET_EXPAND_BUILTIN sh_expand_builtin\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Print the operand address in x to the stream.  */\n@@ -320,6 +330,7 @@ print_operand_address (stream, x)\n    'S'  print the MSW of a dp value - changes if in little endian\n    'T'  print the next word of a dp value - same as 'R' in big endian mode.\n    'M'  print an `x' if `m' will print `base,index'.\n+   'N'  print 'r63' if the operand is (const_int 0).\n    'm'  print a pair `base,offset' or `base,index', for LD and ST.\n    'u'  prints the lowest 16 bits of CONST_INT, as an unsigned value.\n    'o'  output an operator.  */\n@@ -422,6 +433,13 @@ print_operand (stream, x, code)\n \t}\n       break;\n \n+    case 'N':\n+      if (x == const0_rtx)\n+\t{\n+\t  fprintf ((stream), \"r63\");\n+\t  break;\n+\t}\n+      goto default_output;\n     case 'u':\n       if (GET_CODE (x) == CONST_INT)\n         {\n@@ -430,6 +448,7 @@ print_operand (stream, x, code)\n \t}\n       /* Fall through.  */\n \n+    default_output:\n     default:\n       switch (GET_CODE (x))\n \t{\n@@ -5846,6 +5865,20 @@ arith_reg_operand (op, mode)\n   return 0;\n }\n \n+/* Like above, but for DImode destinations: forbid paradoxical DImode subregs,\n+   because this would lead to missing sign extensions when truncating from\n+   DImode to SImode.  */\n+int\n+arith_reg_dest (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (mode == DImode && GET_CODE (op) == SUBREG\n+      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) < 8)\n+    return 0;\n+  return arith_reg_operand (op, mode);\n+}\n+\n int\n fp_arith_reg_operand (op, mode)\n      rtx op;\n@@ -5948,6 +5981,25 @@ logical_operand (op, mode)\n   return 0;\n }\n \n+int\n+and_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (logical_operand (op, mode))\n+    return 1;\n+\n+  /* Check mshflo.l / mshflhi.l opportunities.  */\n+  if (TARGET_SHMEDIA\n+      && mode == DImode\n+      && GET_CODE (op) == CONST_INT\n+      && (INTVAL (op) == (unsigned) 0xffffffff\n+\t  || INTVAL (op) == (HOST_WIDE_INT) -1 << 32))\n+\treturn 1;\n+\n+  return 0;\n+}\n+\n /* Nonzero if OP is a floating point value with value 0.0.  */\n \n int\n@@ -6129,6 +6181,135 @@ target_operand (op, mode)\n   return target_reg_operand (op, mode);\n }\n \n+int\n+mextr_bit_offset (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  HOST_WIDE_INT i;\n+\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  i = INTVAL (op);\n+  return i >= 1*8 && i <= 7*8 && (i & 7) == 0;\n+}\n+\n+int\n+extend_reg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == TRUNCATE\n+\t  ? arith_operand\n+\t  : arith_reg_operand) (op, mode);\n+}\n+\n+int\n+extend_reg_or_0_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == TRUNCATE\n+\t  ? arith_operand\n+\t  : arith_reg_or_0_operand) (op, mode);\n+}\n+\n+/* Return nonzero if V is a zero vector matching MODE.  */\n+int\n+zero_vec_operand (v, mode)\n+     rtx v;\n+     enum machine_mode mode;\n+{\n+  int i;\n+\n+  if (GET_CODE (v) != PARALLEL\n+      || (GET_MODE (v) != mode && mode != VOIDmode))\n+    return 0;\n+  for (i = XVECLEN (v, 0) - 1; i >= 0; i--)\n+    if (XVECEXP (v, 0, i) != const0_rtx)\n+      return 0;\n+  return 1;\n+}\n+\n+int\n+sh_rep_vec (v, mode)\n+     rtx v;\n+     enum machine_mode mode;\n+{\n+  int i;\n+  rtx x, y;\n+\n+  if ((GET_CODE (v) != CONST_VECTOR && GET_CODE (v) != PARALLEL)\n+      || (GET_MODE (v) != mode && mode != VOIDmode))\n+    return 0;\n+  i = XVECLEN (v, 0) - 2;\n+  x = XVECEXP (v, 0, i + 1);\n+  if (GET_MODE_UNIT_SIZE (mode) == 1)\n+    {\n+      y = XVECEXP (v, 0, i);\n+      for (i -= 2 ; i >= 0; i -= 2)\n+\tif (! rtx_equal_p (XVECEXP (v, 0, i + 1), x)\n+\t    || ! rtx_equal_p (XVECEXP (v, 0, i), y))\n+          return 0;\n+    }\n+  else\n+    for (; i >= 0; i--)\n+      if (XVECEXP (v, 0, i) != x)\n+        return 0;\n+  return 1;\n+}\n+\n+/* Determine if V is a constant vector matching MODE with only one element\n+   that is not a sign extension.  Two byte-sized elements count as one.  */\n+int\n+sh_1el_vec (v, mode)\n+     rtx v;\n+     enum machine_mode mode;\n+{\n+  int unit_size;\n+  int i, last, least, sign_ix;\n+  rtx sign;\n+\n+  if (GET_CODE (v) != CONST_VECTOR\n+      || (GET_MODE (v) != mode && mode != VOIDmode))\n+    return 0;\n+  /* Determine numbers of last and of least significat elements.  */\n+  last = XVECLEN (v, 0) - 1;\n+  least = TARGET_LITTLE_ENDIAN ? 0 : last;\n+  if (GET_CODE (XVECEXP (v, 0, least)) != CONST_INT)\n+    return 0;\n+  sign_ix = least;\n+  if (GET_MODE_UNIT_SIZE (mode) == 1)\n+    sign_ix = TARGET_LITTLE_ENDIAN ? 1 : last - 1;\n+  if (GET_CODE (XVECEXP (v, 0, sign_ix)) != CONST_INT)\n+    return 0;\n+  unit_size = GET_MODE_UNIT_SIZE (GET_MODE (v));\n+  sign = (INTVAL (XVECEXP (v, 0, sign_ix)) >> (unit_size * BITS_PER_UNIT - 1)\n+\t  ? constm1_rtx : const0_rtx);\n+  i = XVECLEN (v, 0) - 1;\n+  do\n+    if (i != least && i != sign_ix && XVECEXP (v, 0, i) != sign)\n+      return 0;\n+  while (--i);\n+  return 1;\n+}\n+\n+int\n+sh_const_vec (v, mode)\n+     rtx v;\n+     enum machine_mode mode;\n+{\n+  int i;\n+\n+  if (GET_CODE (v) != CONST_VECTOR\n+      || (GET_MODE (v) != mode && mode != VOIDmode))\n+    return 0;\n+  i = XVECLEN (v, 0) - 1;\n+  for (; i >= 0; i--)\n+    if (GET_CODE (XVECEXP (v, 0, i)) != CONST_INT)\n+      return 0;\n+  return 1;\n+}\n \f\n /* Return the destination address of a branch.  */\n    \n@@ -6446,8 +6627,8 @@ sh_insn_length_adjustment (insn)\n   /* Instructions with unfilled delay slots take up an extra two bytes for\n      the nop in the delay slot.  */\n   if (((GET_CODE (insn) == INSN\n-        && GET_CODE (PATTERN (insn)) != USE\n-        && GET_CODE (PATTERN (insn)) != CLOBBER)\n+\t&& GET_CODE (PATTERN (insn)) != USE\n+\t&& GET_CODE (PATTERN (insn)) != CLOBBER)\n        || GET_CODE (insn) == CALL_INSN\n        || (GET_CODE (insn) == JUMP_INSN\n \t   && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC\n@@ -6588,7 +6769,8 @@ legitimize_pic_address (orig, mode, reg)\n \n /* Mark the use of a constant in the literal table. If the constant\n    has multiple labels, make it unique.  */\n-static rtx mark_constant_pool_use (x)\n+static rtx\n+mark_constant_pool_use (x)\n      rtx x;\n {\n   rtx insn, lab, pattern;\n@@ -6848,4 +7030,299 @@ sh_strip_name_encoding (str)\n   return str;\n }\n \n+\f\n+/* Machine specific built-in functions.  */\n+\n+struct builtin_description\n+{\n+  const enum insn_code icode;\n+  const char *const name;\n+  int signature;\n+};\n+\n+/* describe number and signedness of arguments; arg[0] == result\n+   (1: unsigned, 2: signed, 4: don't care, 8: pointer 0: no argument */\n+static const char signature_args[][4] =\n+{\n+#define SH_BLTIN_V2SI2 0\n+  { 4, 4 },\n+#define SH_BLTIN_V4HI2 1\n+  { 4, 4 },\n+#define SH_BLTIN_V2SI3 2\n+  { 4, 4, 4 },\n+#define SH_BLTIN_V4HI3 3\n+  { 4, 4, 4 },\n+#define SH_BLTIN_V8QI3 4\n+  { 4, 4, 4 },\n+#define SH_BLTIN_MAC_HISI 5\n+  { 1, 4, 4, 1 },\n+#define SH_BLTIN_SH_HI 6\n+  { 4, 4, 1 },\n+#define SH_BLTIN_SH_SI 7\n+  { 4, 4, 1 },\n+#define SH_BLTIN_V4HI2V2SI 8\n+  { 4, 4, 4 },\n+#define SH_BLTIN_V4HI2V8QI 9\n+  { 4, 4, 4 },\n+#define SH_BLTIN_SISF 10\n+  { 4, 2 },\n+#define SH_BLTIN_LDUA_L 11\n+  { 2, 8 },\n+#define SH_BLTIN_LDUA_Q 12\n+  { 1, 8 },\n+#define SH_BLTIN_STUA_L 13\n+  { 0, 8, 2 },\n+#define SH_BLTIN_STUA_Q 14\n+  { 0, 8, 1 },\n+#define SH_BLTIN_NUM_SHARED_SIGNATURES 15\n+#define SH_BLTIN_2 15\n+#define SH_BLTIN_SU 15\n+  { 1, 2 },\n+#define SH_BLTIN_3 16\n+#define SH_BLTIN_SUS 16\n+  { 2, 2, 1 },\n+#define SH_BLTIN_PSSV 17\n+  { 0, 8, 2, 2 },\n+#define SH_BLTIN_XXUU 18\n+#define SH_BLTIN_UUUU 18\n+  { 1, 1, 1, 1 },\n+#define SH_BLTIN_PV 19\n+  { 0, 8 },\n+};\n+/* mcmv: operands considered unsigned. */\n+/* mmulsum_wq, msad_ubq: result considered unsigned long long.  */\n+/* mperm: control value considered unsigned int. */\n+/* mshalds, mshard, mshards, mshlld, mshlrd: shift count is unsigned int. */\n+/* mshards_q: returns signed short.  */\n+/* nsb: takes long long arg, returns unsigned char.  */\n+static const struct builtin_description bdesc[] =\n+{\n+  { CODE_FOR_absv2si2,\t\"__builtin_absv2si2\", SH_BLTIN_V2SI2 },\n+  { CODE_FOR_absv4hi2,\t\"__builtin_absv4hi2\", SH_BLTIN_V4HI2 },\n+  { CODE_FOR_addv2si3,\t\"__builtin_addv2si3\", SH_BLTIN_V2SI3 },\n+  { CODE_FOR_addv4hi3,\t\"__builtin_addv4hi3\", SH_BLTIN_V4HI3 },\n+  { CODE_FOR_ssaddv2si3,\"__builtin_ssaddv2si3\", SH_BLTIN_V2SI3 },\n+  { CODE_FOR_usaddv8qi3,\"__builtin_usaddv8qi3\", SH_BLTIN_V8QI3 },\n+  { CODE_FOR_ssaddv4hi3,\"__builtin_ssaddv4hi3\", SH_BLTIN_V4HI3 },\n+#if 0\n+  { CODE_FOR_alloco32,\t\"__builtin_sh_media_ALLOCO\", SH_BLTIN_PV },\n+  { CODE_FOR_alloco64,\t\"__builtin_sh_media_ALLOCO\", SH_BLTIN_PV },\n+#endif\n+  { CODE_FOR_negcmpeqv8qi,\"__builtin_sh_media_MCMPEQ_B\", SH_BLTIN_V8QI3 },\n+  { CODE_FOR_negcmpeqv2si,\"__builtin_sh_media_MCMPEQ_L\", SH_BLTIN_V2SI3 },\n+  { CODE_FOR_negcmpeqv4hi,\"__builtin_sh_media_MCMPEQ_W\", SH_BLTIN_V4HI3 },\n+  { CODE_FOR_negcmpgtuv8qi,\"__builtin_sh_media_MCMPGT_UB\", SH_BLTIN_V8QI3 },\n+  { CODE_FOR_negcmpgtv2si,\"__builtin_sh_media_MCMPGT_L\", SH_BLTIN_V2SI3 },\n+  { CODE_FOR_negcmpgtv4hi,\"__builtin_sh_media_MCMPGT_W\", SH_BLTIN_V4HI3 },\n+  { CODE_FOR_mcmv,\t\"__builtin_sh_media_MCMV\", SH_BLTIN_UUUU },\n+  { CODE_FOR_mcnvs_lw,\t\"__builtin_sh_media_MCNVS_LW\", SH_BLTIN_3 },\n+  { CODE_FOR_mcnvs_wb,\t\"__builtin_sh_media_MCNVS_WB\", SH_BLTIN_V4HI2V8QI },\n+  { CODE_FOR_mcnvs_wub,\t\"__builtin_sh_media_MCNVS_WUB\", SH_BLTIN_V4HI2V8QI },\n+  { CODE_FOR_mextr1,\t\"__builtin_sh_media_MEXTR1\", SH_BLTIN_V8QI3 },\n+  { CODE_FOR_mextr2,\t\"__builtin_sh_media_MEXTR2\", SH_BLTIN_V8QI3 },\n+  { CODE_FOR_mextr3,\t\"__builtin_sh_media_MEXTR3\", SH_BLTIN_V8QI3 },\n+  { CODE_FOR_mextr4,\t\"__builtin_sh_media_MEXTR4\", SH_BLTIN_V8QI3 },\n+  { CODE_FOR_mextr5,\t\"__builtin_sh_media_MEXTR5\", SH_BLTIN_V8QI3 },\n+  { CODE_FOR_mextr6,\t\"__builtin_sh_media_MEXTR6\", SH_BLTIN_V8QI3 },\n+  { CODE_FOR_mextr7,\t\"__builtin_sh_media_MEXTR7\", SH_BLTIN_V8QI3 },\n+  { CODE_FOR_mmacfx_wl,\t\"__builtin_sh_media_MMACFX_WL\", SH_BLTIN_MAC_HISI },\n+  { CODE_FOR_mmacnfx_wl,\"__builtin_sh_media_MMACNFX_WL\", SH_BLTIN_MAC_HISI },\n+  { CODE_FOR_mulv2si3,\t\"__builtin_mulv2si3\", SH_BLTIN_V2SI3, },\n+  { CODE_FOR_mulv4hi3,\t\"__builtin_mulv4hi3\", SH_BLTIN_V4HI3 },\n+  { CODE_FOR_mmulfx_l,\t\"__builtin_sh_media_MMULFX_L\", SH_BLTIN_V2SI3 },\n+  { CODE_FOR_mmulfx_w,\t\"__builtin_sh_media_MMULFX_W\", SH_BLTIN_V4HI3 },\n+  { CODE_FOR_mmulfxrp_w,\"__builtin_sh_media_MMULFXRP_W\", SH_BLTIN_V4HI3 },\n+  { CODE_FOR_mmulhi_wl,\t\"__builtin_sh_media_MMULHI_WL\", SH_BLTIN_V4HI2V2SI },\n+  { CODE_FOR_mmullo_wl,\t\"__builtin_sh_media_MMULLO_WL\", SH_BLTIN_V4HI2V2SI },\n+  { CODE_FOR_mmulsum_wq,\"__builtin_sh_media_MMULSUM_WQ\", SH_BLTIN_XXUU },\n+  { CODE_FOR_mperm_w,\t\"__builtin_sh_media_MPERM_W\", SH_BLTIN_SH_HI },\n+  { CODE_FOR_msad_ubq,\t\"__builtin_sh_media_MSAD_UBQ\", SH_BLTIN_XXUU },\n+  { CODE_FOR_mshalds_l,\t\"__builtin_sh_media_MSHALDS_L\", SH_BLTIN_SH_SI },\n+  { CODE_FOR_mshalds_w,\t\"__builtin_sh_media_MSHALDS_W\", SH_BLTIN_SH_HI },\n+  { CODE_FOR_ashrv2si3,\t\"__builtin_ashrv2si3\", SH_BLTIN_SH_SI },\n+  { CODE_FOR_ashrv4hi3,\t\"__builtin_ashrv4hi3\", SH_BLTIN_SH_HI },\n+  { CODE_FOR_mshards_q,\t\"__builtin_sh_media_MSHARDS_Q\", SH_BLTIN_SUS },\n+  { CODE_FOR_mshfhi_b,\t\"__builtin_sh_media_MSHFHI_B\", SH_BLTIN_V8QI3 },\n+  { CODE_FOR_mshfhi_l,\t\"__builtin_sh_media_MSHFHI_L\", SH_BLTIN_V2SI3 },\n+  { CODE_FOR_mshfhi_w,\t\"__builtin_sh_media_MSHFHI_W\", SH_BLTIN_V4HI3 },\n+  { CODE_FOR_mshflo_b,\t\"__builtin_sh_media_MSHFLO_B\", SH_BLTIN_V8QI3 },\n+  { CODE_FOR_mshflo_l,\t\"__builtin_sh_media_MSHFLO_L\", SH_BLTIN_V2SI3 },\n+  { CODE_FOR_mshflo_w,\t\"__builtin_sh_media_MSHFLO_W\", SH_BLTIN_V4HI3 },\n+  { CODE_FOR_ashlv2si3,\t\"__builtin_ashlv2si3\", SH_BLTIN_SH_SI },\n+  { CODE_FOR_ashlv4hi3,\t\"__builtin_ashlv4hi3\", SH_BLTIN_SH_HI },\n+  { CODE_FOR_lshrv2si3,\t\"__builtin_lshrv2si3\", SH_BLTIN_SH_SI },\n+  { CODE_FOR_lshrv4hi3,\t\"__builtin_lshrv4hi3\", SH_BLTIN_SH_HI },\n+  { CODE_FOR_subv2si3,\t\"__builtin_subv2si3\", SH_BLTIN_V2SI3 },\n+  { CODE_FOR_subv4hi3,\t\"__builtin_subv4hi3\", SH_BLTIN_V4HI3 },\n+  { CODE_FOR_sssubv2si3,\"__builtin_sssubv2si3\", SH_BLTIN_V2SI3 },\n+  { CODE_FOR_ussubv8qi3,\"__builtin_ussubv8qi3\", SH_BLTIN_V8QI3 },\n+  { CODE_FOR_sssubv4hi3,\"__builtin_sssubv4hi3\", SH_BLTIN_V4HI3 },\n+  { CODE_FOR_fcosa_s,\t\"__builtin_sh_media_FCOSA_S\", SH_BLTIN_SISF },\n+  { CODE_FOR_fsina_s,\t\"__builtin_sh_media_FSINA_S\", SH_BLTIN_SISF },\n+  { CODE_FOR_fipr,\t\"__builtin_sh_media_FIPR_S\", SH_BLTIN_3 },\n+  { CODE_FOR_ftrv,\t\"__builtin_sh_media_FTRV_S\", SH_BLTIN_3 },\n+  { CODE_FOR_fsrra_s,\t\"__builtin_sh_media_FSRRA_S\", SH_BLTIN_2 },\n+#if 0\n+  { CODE_FOR_ldhi_l,\t\"__builtin_sh_media_LDHI_L\", SH_BLTIN_LDUA_L },\n+  { CODE_FOR_ldhi_q,\t\"__builtin_sh_media_LDHI_Q\", SH_BLTIN_LDUA_Q },\n+  { CODE_FOR_ldlo_l,\t\"__builtin_sh_media_LDLO_L\", SH_BLTIN_LDUA_L },\n+  { CODE_FOR_ldlo_q,\t\"__builtin_sh_media_LDLO_Q\", SH_BLTIN_LDUA_Q },\n+  { CODE_FOR_sthi_l,\t\"__builtin_sh_media_STHI_L\", SH_BLTIN_STUA_L },\n+  { CODE_FOR_sthi_q,\t\"__builtin_sh_media_STHI_Q\", SH_BLTIN_STUA_Q },\n+  { CODE_FOR_stlo_l,\t\"__builtin_sh_media_STLO_L\", SH_BLTIN_STUA_L },\n+  { CODE_FOR_stlo_q,\t\"__builtin_sh_media_STLO_Q\", SH_BLTIN_STUA_Q },\n+  { CODE_FOR_ldhi_l64,\t\"__builtin_sh_media_LDHI_L\", SH_BLTIN_LDUA_L },\n+  { CODE_FOR_ldhi_q64,\t\"__builtin_sh_media_LDHI_Q\", SH_BLTIN_LDUA_Q },\n+  { CODE_FOR_ldlo_l64,\t\"__builtin_sh_media_LDLO_L\", SH_BLTIN_LDUA_L },\n+  { CODE_FOR_ldlo_q64,\t\"__builtin_sh_media_LDLO_Q\", SH_BLTIN_LDUA_Q },\n+  { CODE_FOR_sthi_l64,\t\"__builtin_sh_media_STHI_L\", SH_BLTIN_STUA_L },\n+  { CODE_FOR_sthi_q64,\t\"__builtin_sh_media_STHI_Q\", SH_BLTIN_STUA_Q },\n+  { CODE_FOR_stlo_l64,\t\"__builtin_sh_media_STLO_L\", SH_BLTIN_STUA_L },\n+  { CODE_FOR_stlo_q64,\t\"__builtin_sh_media_STLO_Q\", SH_BLTIN_STUA_Q },\n+  { CODE_FOR_nsb,\t\"__builtin_sh_media_NSB\", SH_BLTIN_SU },\n+  { CODE_FOR_byterev,\t\"__builtin_sh_media_BYTEREV\", SH_BLTIN_2 },\n+  { CODE_FOR_prefetch32,\"__builtin_sh_media_PREFO\", SH_BLTIN_PSSV },\n+  { CODE_FOR_prefetch64,\"__builtin_sh_media_PREFO\", SH_BLTIN_PSSV }\n+#endif\n+};\n+\n+static void\n+sh_media_init_builtins ()\n+{\n+  tree shared[SH_BLTIN_NUM_SHARED_SIGNATURES];\n+  const struct builtin_description *d;\n+\n+  bzero (shared, sizeof shared);\n+  for (d = bdesc; d - bdesc < sizeof bdesc / sizeof bdesc[0]; d++)\n+    {\n+      tree type, arg_type;\n+      int signature = d->signature;\n+      int i;\n+\n+      if (signature < SH_BLTIN_NUM_SHARED_SIGNATURES && shared[signature])\n+\ttype = shared[signature];\n+      else\n+\t{\n+\t  int has_result = signature_args[signature][0] != 0;\n+\n+\t  if (signature_args[signature][1] == 8\n+\t      && (insn_data[d->icode].operand[has_result].mode != Pmode))\n+\t    continue;\n+\t  if (! TARGET_FPU_ANY\n+\t      && FLOAT_MODE_P (insn_data[d->icode].operand[0].mode))\n+\t    continue;\n+\t  type = void_list_node;\n+\t  for (i = 3; ; i--)\n+\t    {\n+\t      int arg = signature_args[signature][i];\n+\t      int opno = i - 1 + has_result;\n+\n+\t      if (arg == 8)\n+\t\targ_type = ptr_type_node;\n+\t      else if (arg)\n+\t\targ_type = ((*lang_hooks.types.type_for_mode)\n+\t\t\t    (insn_data[d->icode].operand[opno].mode,\n+\t\t\t     (arg & 1)));\n+\t      else if (i)\n+\t\tcontinue;\n+\t      else\n+\t\targ_type = void_type_node;\n+\t      if (i == 0)\n+\t\tbreak;\n+\t      type = tree_cons (NULL_TREE, arg_type, type);\n+\t    }\n+\t  type = build_function_type (arg_type, type);\n+\t  if (signature < SH_BLTIN_NUM_SHARED_SIGNATURES)\n+\t    shared[signature] = type;\n+\t}\n+      builtin_function (d->name, type, d - bdesc, BUILT_IN_MD, NULL);\n+    }\n+}\n+\n+static void\n+sh_init_builtins ()\n+{\n+  if (TARGET_SHMEDIA)\n+    sh_media_init_builtins ();\n+}\n+\n+/* Expand an expression EXP that calls a built-in function,\n+   with result going to TARGET if that's convenient\n+   (and in mode MODE if that's convenient).\n+   SUBTARGET may be used as the target for computing one of EXP's operands.\n+   IGNORE is nonzero if the value is to be ignored.  */\n+\n+static rtx\n+sh_expand_builtin (exp, target, subtarget, mode, ignore)\n+     tree exp;\n+     rtx target;\n+     rtx subtarget ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     int ignore;\n+{\n+  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n+  const struct builtin_description *d = &bdesc[fcode];\n+  enum insn_code icode = d->icode;\n+  int signature = d->signature;\n+  enum machine_mode tmode = VOIDmode;\n+  int nop = 0, i;\n+  rtx op[4];\n+  rtx pat;\n+\n+  if (signature_args[signature][0])\n+    {\n+      if (ignore)\n+\treturn 0;\n+\n+      tmode = insn_data[icode].operand[0].mode;\n+      if (! target\n+\t  || GET_MODE (target) != tmode\n+\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+\ttarget = gen_reg_rtx (tmode);\n+      op[nop++] = target;\n+    }\n+  else\n+    target = 0;\n+\n+  for (i = 1; i <= 3; i++, nop++)\n+    {\n+      tree arg;\n+      enum machine_mode opmode, argmode;\n+\n+      if (! signature_args[signature][i])\n+\tbreak;\n+      arg = TREE_VALUE (arglist);\n+      arglist = TREE_CHAIN (arglist);\n+      opmode = insn_data[icode].operand[nop].mode;\n+      argmode = TYPE_MODE (TREE_TYPE (arg));\n+      if (argmode != opmode)\n+\targ = build1 (NOP_EXPR,\n+\t\t      (*lang_hooks.types.type_for_mode) (opmode, 0), arg);\n+      op[nop] = expand_expr (arg, NULL_RTX, opmode, 0);\n+      if (! (*insn_data[icode].operand[nop].predicate) (op[nop], opmode))\n+\top[nop] = copy_to_mode_reg (opmode, op[nop]);\n+    }\n+\n+  switch (nop)\n+    {\n+    case 1:\n+      pat = (*insn_data[d->icode].genfun) (op[0]);\n+      break;\n+    case 2:\n+      pat = (*insn_data[d->icode].genfun) (op[0], op[1]);\n+      break;\n+    case 3:\n+      pat = (*insn_data[d->icode].genfun) (op[0], op[1], op[2]);\n+      break;\n+    case 4:\n+      pat = (*insn_data[d->icode].genfun) (op[0], op[1], op[2], op[3]);\n+      break;\n+    }\n+  if (! pat)\n+    return 0;\n+  emit_insn (pat);\n+  return target;\n+}\n #include \"gt-sh.h\""}, {"sha": "abf9945a330e75d3b697d190a9046a0302e1ce59", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1b92d09069106355c7133244bbd01bfa67c471d/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1b92d09069106355c7133244bbd01bfa67c471d/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=c1b92d09069106355c7133244bbd01bfa67c471d", "patch": "@@ -924,8 +924,11 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n \n /* Value is 1 if MODE is a supported vector mode.  */\n #define VECTOR_MODE_SUPPORTED_P(MODE) \\\n-  (TARGET_FPU_ANY \\\n-   && ((MODE) == V2SFmode || (MODE) == V4SFmode || (MODE) == V16SFmode))\n+  ((TARGET_FPU_ANY \\\n+    && ((MODE) == V2SFmode || (MODE) == V4SFmode || (MODE) == V16SFmode)) \\\n+   || (TARGET_SHMEDIA \\\n+       && ((MODE) == V8QImode || (MODE) == V2HImode || (MODE) == V4HImode \\\n+\t   || (MODE) == V2SImode)))\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n@@ -2312,10 +2315,27 @@ while (0)\n #define EXTRA_CONSTRAINT_T(OP) \\\n   (NON_PIC_REFERENCE_P (OP))\n \n+/* A zero in any shape or form.  */\n+#define EXTRA_CONSTRAINT_U(OP) \\\n+  ((OP) == const0_rtx \\\n+   || (GET_CODE (OP) == SUBREG && VECTOR_MODE_SUPPORTED_P(GET_MODE (OP)) \\\n+       && SUBREG_REG (OP) == const0_rtx && SUBREG_BYTE (OP) == 0) \\\n+   || GET_CODE (OP) == CONST_VECTOR && zero_vec_operand ((OP), VOIDmode))\n+\n+/* Any vector constant we can handle.  */\n+#define EXTRA_CONSTRAINT_W(OP) \\\n+  (GET_CODE (OP) == CONST_VECTOR \\\n+   && (sh_rep_vec ((OP), VOIDmode) \\\n+       || (HOST_BITS_PER_WIDE_INT >= 64 \\\n+\t   ? sh_const_vec ((OP), VOIDmode) \\\n+\t   : sh_1el_vec ((OP), VOIDmode))))\n+\n #define EXTRA_CONSTRAINT(OP, C)\t\t\\\n   ((C) == 'Q' ? EXTRA_CONSTRAINT_Q (OP)\t\\\n    : (C) == 'S' ? EXTRA_CONSTRAINT_S (OP) \\\n    : (C) == 'T' ? EXTRA_CONSTRAINT_T (OP) \\\n+   : (C) == 'U' ? EXTRA_CONSTRAINT_U (OP) \\\n+   : (C) == 'W' ? EXTRA_CONSTRAINT_W (OP) \\\n    : 0)\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n@@ -2669,6 +2689,8 @@ while (0)\n   case CONST_INT:\t\t\t\t\\\n     if (TARGET_SHMEDIA)\t\t\t\t\\\n       {\t\t\t\t\t\t\\\n+\tif ((OUTER_CODE) == AND && and_operand ((RTX), DImode)) \\\n+\t  return 0;\t\t\t\t\\\n \tif (CONST_OK_FOR_J (INTVAL (RTX)))\t\\\n           return COSTS_N_INSNS (1);\t\t\\\n \telse if (CONST_OK_FOR_J (INTVAL (RTX) >> 16)) \\\n@@ -3188,7 +3210,6 @@ extern int current_function_interrupt;\n extern struct rtx_def *sp_switch;\n \n extern int rtx_equal_function_value_matters;\n-extern struct rtx_def *fpscr_rtx;\n \n \f\n /* Instructions with unfilled delay slots take up an\n@@ -3200,23 +3221,32 @@ extern struct rtx_def *fpscr_rtx;\n \f\n /* Define the codes that are matched by predicates in sh.c.  */\n #define PREDICATE_CODES \\\n+  {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n   {\"arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n+  {\"arith_reg_dest\", {SUBREG, REG}},\t\t\t\t\t\\\n   {\"arith_reg_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n   {\"arith_reg_or_0_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"binary_float_operator\", {PLUS, MULT}},\t\t\t\t\\\n   {\"commutative_float_operator\", {PLUS, MULT}},\t\t\t\t\\\n+  {\"extend_reg_operand\", {SUBREG, REG, TRUNCATE}},\t\t\t\\\n+  {\"extend_reg_or_0_operand\", {SUBREG, REG, TRUNCATE, CONST_INT}},\t\\\n   {\"fp_arith_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"fpscr_operand\", {REG}},\t\t\t\t\t\t\\\n   {\"fpul_operand\", {REG}},\t\t\t\t\t\t\\\n   {\"general_movsrc_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE, MEM}}, \\\n   {\"general_movdst_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n   {\"logical_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"mextr_bit_offset\", {CONST_INT}},\t\t\t\t\t\\\n   {\"noncommutative_float_operator\", {MINUS, DIV}},\t\t\t\\\n   {\"shmedia_6bit_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"target_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"target_operand\", {SUBREG, REG, LABEL_REF, SYMBOL_REF}},\t\t\\\n+  {\"target_operand\", {SUBREG, REG, LABEL_REF, SYMBOL_REF, CONST, UNSPEC}},\\\n   {\"register_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n-  {\"symbol_ref_operand\", {SYMBOL_REF}},\n+  {\"sh_const_vec\", {CONST_VECTOR}},\t\t\t\t\t\\\n+  {\"sh_1el_vec\", {CONST_VECTOR, PARALLEL}},\t\t\t\t\\\n+  {\"sh_rep_vec\", {CONST_VECTOR, PARALLEL}},\t\t\t\t\\\n+  {\"symbol_ref_operand\", {SYMBOL_REF}},\t\t\t\t\t\\\n+  {\"zero_vec_operand\", {CONST_VECTOR}},\n \n /* Define this macro if it is advisable to hold scalars in registers\n    in a wider mode than that declared by the program.  In such cases, "}, {"sha": "8303c96288647bd524a1298f43f13e79ccbf0595", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 1227, "deletions": 22, "changes": 1249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1b92d09069106355c7133244bbd01bfa67c471d/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1b92d09069106355c7133244bbd01bfa67c471d/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=c1b92d09069106355c7133244bbd01bfa67c471d", "patch": "@@ -129,6 +129,12 @@\n   (UNSPEC_CALLER\t10)\n   (UNSPEC_GOTPLT\t11)\n   (UNSPEC_ICACHE\t12)\n+  (UNSPEC_INIT_TRAMP\t13)\n+  (UNSPEC_FCOSA\t\t14)\n+  (UNSPEC_FSRRA\t\t15)\n+  (UNSPEC_FSINA\t\t16)\n+  (UNSPEC_NSB\t\t17)\n+  (UNSPEC_ALLOCO\t18)\n \n   ;; These are used with unspec_volatile.\n   (UNSPECV_BLOCKAGE\t0)\n@@ -197,7 +203,7 @@\n ;; nil\t\tno-op move, will be deleted.\n \n (define_attr \"type\"\n- \"cbranch,jump,jump_ind,arith,arith3,arith3b,dyn_shift,other,load,load_si,store,move,fmove,smpy,dmpy,return,pload,prset,pstore,prget,pcload,pcload_si,pt,ptabs,rte,sfunc,call,fp,fdiv,dfp_arith,dfp_cmp,dfp_conv,dfdiv,gp_fpul,nil\"\n+ \"cbranch,jump,jump_ind,arith,arith3,arith3b,dyn_shift,load,load_si,store,move,fmove,smpy,dmpy,return,pload,prset,pstore,prget,pcload,pcload_si,rte,sfunc,call,fp,fdiv,dfp_arith,dfp_cmp,dfp_conv,dfdiv,gp_fpul,arith_media,cbranch_media,cmp_media,dfdiv_media,dfmul_media,dfparith_media,dfpconv_media,dmpy_media,fcmp_media,fdiv_media,fload_media,fmove_media,fparith_media,fpconv_media,fstore_media,gettr_media,invalidate_line_media,jump_media,load_media,pt,ptabs,store_media,mcmp_media,mac_media,d2mpy_media,atrans_media,ustore_media,nil,other\"\n   (const_string \"other\"))\n \n ;; We define a new attribute namely \"insn_class\".We use\n@@ -1984,14 +1990,26 @@\n     }\n }\")\n \n-(define_insn \"anddi3\"\n-  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r,r\")\n-\t(and:DI (match_operand:DI 1 \"arith_reg_operand\" \"%r,r\")\n-\t\t(match_operand:DI 2 \"logical_operand\" \"r,P\")))]\n+(define_insn_and_split \"anddi3\"\n+  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r,r,r\")\n+\t(and:DI (match_operand:DI 1 \"arith_reg_operand\" \"%r,r,r\")\n+\t\t(match_operand:DI 2 \"and_operand\" \"r,P,n\")))]\n   \"TARGET_SHMEDIA\"\n   \"@\n \tand\t%1, %2, %0\n-\tandi\t%1, %2, %0\")\n+\tandi\t%1, %2, %0\n+\t#\"\n+  \"reload_completed\n+   && ! logical_operand (operands[2], DImode)\"\n+  [(const_int 0)]\n+  \"\n+{\n+  if (INTVAL (operands[2]) == (unsigned) 0xffffffff)\n+    emit_insn (gen_mshflo_l_di (operands[0], operands[1], CONST0_RTX (DImode)));\n+  else\n+    emit_insn (gen_mshfhi_l_di (operands[0], CONST0_RTX (DImode), operands[1]));\n+  DONE;\n+}\")\n \n (define_insn \"*andcdi3\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n@@ -3626,28 +3644,95 @@\n    && GET_CODE (operands[1]) == CONST_INT\n    && ! CONST_OK_FOR_J (INTVAL (operands[1]))\"\n   [(set (match_dup 0) (match_dup 2))\n-  (set (match_dup 0)\n-       (ior:DI (ashift:DI (match_dup 0) (const_int 16))\n-\t       (zero_extend:DI (truncate:HI (match_dup 1)))))]\n+   (match_dup 1)]\n   \"\n {\n-  unsigned HOST_WIDE_INT low = INTVAL (operands[1]);\n-  unsigned HOST_WIDE_INT val = low;\n+  unsigned HOST_WIDE_INT val = INTVAL (operands[1]);\n+  unsigned HOST_WIDE_INT low = val;\n+  unsigned HOST_WIDE_INT high = val;\n   unsigned HOST_WIDE_INT sign;\n+  unsigned HOST_WIDE_INT val2 = val ^ (val-1);\n \n   /* Sign-extend the 16 least-significant bits.  */\n-  val &= 0xffff;\n-  val ^= 0x8000;\n-  val -= 0x8000;\n-  operands[1] = GEN_INT (val);\n+  low &= 0xffff;\n+  low ^= 0x8000;\n+  low -= 0x8000;\n \n   /* Arithmetic shift right the word by 16 bits.  */\n-  low >>= 16;\n+  high >>= 16;\n   sign = 1;\n   sign <<= (HOST_BITS_PER_WIDE_INT - 16 - 1);\n-  low ^= sign;\n-  low -= sign;\n-  operands[2] = GEN_INT (low);\n+  high ^= sign;\n+  high -= sign;\n+  do\n+    {\n+      /* If we can't generate the constant with a two-insn movi / shori\n+\t sequence, try some other strategies.  */\n+      if (! CONST_OK_FOR_J (high))\n+\t{\n+\t  /* Try constant load / left shift.  We know VAL != 0.  */\n+\t  val2 = val ^ (val-1);\n+\t  if (val2 > 0x1ffff)\n+\t    {\n+\t      int trailing_zeroes = exact_log2 ((val2 >> 16) + 1) + 15;\n+\n+\t      if (CONST_OK_FOR_J (val >> trailing_zeroes)\n+\t\t  || (! CONST_OK_FOR_J (high >> 16)\n+\t\t      && CONST_OK_FOR_J (val >> (trailing_zeroes + 16))))\n+\t\t{\n+\t\t  val2 = (HOST_WIDE_INT) val >> trailing_zeroes;\n+\t\t  operands[1] = gen_ashldi3_media (operands[0], operands[0],\n+\t\t\t\t\t\t   GEN_INT (trailing_zeroes));\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  /* Try constant load / right shift.  */\n+\t  val2 = (val >> 15) + 1;\n+\t  if (val2 == (val2 & -val2))\n+\t    {\n+\t      int shift = 49 - exact_log2 (val2);\n+\n+\t      val2 = trunc_int_for_mode (val << shift, DImode);\n+\t      if (CONST_OK_FOR_J (val2))\n+\t\t{\n+\t\t  operands[1] = gen_lshrdi3_media (operands[0], operands[0],\n+\t\t\t\t\t\t   GEN_INT (shift));\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  /* Try mperm.w .  */\n+\t  val2 = val & 0xffff;\n+\t  if ((val >> 16 & 0xffff) == val2\n+\t      && (val >> 32 & 0xffff) == val2\n+\t      && (val >> 48 & 0xffff) == val2)\n+\t    {\n+\t      val2 = (HOST_WIDE_INT) val >> 48;\n+\t      operands[1] = gen_rtx_REG (V4HImode, true_regnum (operands[0]));\n+\t      operands[1] = gen_mperm_w0 (operands[1], operands[1]);\n+\t      break;\n+\t    }\n+\t  /* Try movi / mshflo.l  */\n+\t  val2 = (HOST_WIDE_INT) val >> 32;\n+\t  if (val2 == trunc_int_for_mode (val, SImode))\n+\t    {\n+\t      operands[1] = gen_mshflo_l_di (operands[0], operands[0],\n+\t\t\t\t\t     operands[0]);\n+\t      break;\n+\t    }\n+\t  /* Try movi / mshflo.l w/ r63.  */\n+\t  val2 = val + ((HOST_WIDE_INT) -1 << 32);\n+\t  if ((HOST_WIDE_INT) val2 < 0 && CONST_OK_FOR_J (val2))\n+\t    {\n+\t      operands[1] = gen_mshflo_l_di (operands[0], operands[0],\n+\t\t\t\t\t     GEN_INT (0));\n+\t      break;\n+\t    }\n+\t}\n+      val2 = high;\n+      operands[1] = gen_shori_media (operands[0], operands[0], GEN_INT (low));\n+    }\n+  while (0);\n+  operands[2] = GEN_INT (val2);\n }\")\n \n (define_split\n@@ -3690,7 +3775,7 @@\n     operands[2] = immed_double_const (low, high, DImode);\n }\")\n \n-(define_insn \"*shori_media\"\n+(define_insn \"shori_media\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r,r\")\n \t(ior:DI (ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"0,0\")\n \t\t\t   (const_int 16))\n@@ -7507,7 +7592,7 @@\n \n (define_split\n   [(set (reg:PSI FPSCR_REG)\n-\t(mem:PSI (match_operand:SI 0 \"register_operand\" \"r\")))]\n+\t(mem:PSI (match_operand:SI 0 \"register_operand\" \"\")))]\n   \"TARGET_SH4 && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))\"\n   [(set (match_dup 0) (match_dup 0))]\n   \"\n@@ -7521,7 +7606,7 @@\n \n (define_split\n   [(set (reg:PSI FPSCR_REG)\n-\t(mem:PSI (match_operand:SI 0 \"register_operand\" \"r\")))]\n+\t(mem:PSI (match_operand:SI 0 \"register_operand\" \"\")))]\n   \"TARGET_SH4\"\n   [(set (match_dup 0) (plus:SI (match_dup 0) (const_int -4)))]\n   \"\n@@ -8646,6 +8731,1126 @@\n   \"mov.l @r15+,r15\\;mov.l @r15+,r0\"\n   [(set_attr \"length\" \"4\")])\n \n+;; Integer vector moves\n+\n+(define_expand \"movv8qi\"\n+  [(set (match_operand:V8QI 0 \"general_movdst_operand\" \"\")\n+\t(match_operand:V8QI 1 \"general_movsrc_operand\" \"\"))]\n+  \"TARGET_SHMEDIA\"\n+  \"{ if (prepare_move_operands (operands, V8QImode)) DONE; }\")\n+\n+(define_insn \"movv8qi_i\"\n+  [(set (match_operand:V8QI 0 \"general_movdst_operand\" \"=r,r,r,rl,m\")\n+\t(match_operand:V8QI 1 \"general_movsrc_operand\" \"r,JSU,nW,m,rl\"))]\n+  \"TARGET_SHMEDIA\n+   && (register_operand (operands[0], V8QImode)\n+       || register_operand (operands[1], V8QImode))\"\n+  \"@\n+\tadd\t%1, r63, %0\n+\tmovi\t%1, %0\n+\t#\n+\tld%M1.q\t%m1, %0\n+\tst%M0.q\t%m0, %1\"\n+  [(set_attr \"type\"   \"arith_media,arith_media,*,load_media,store_media\")\n+   (set_attr \"length\" \"4,4,16,4,4\")])\n+\n+(define_split\n+  [(set (match_operand:V8QI 0 \"arith_reg_dest\" \"\")\n+\t(subreg:V8QI (const_int 0) 0))]\n+  \"TARGET_SHMEDIA\"\n+  [(set (match_dup 0)\n+\t(const_vector:V8QI [(const_int 0) (const_int 0) (const_int 0)\n+\t\t\t    (const_int 0) (const_int 0) (const_int 0)\n+\t\t\t    (const_int 0) (const_int 0)]))])\n+\n+(define_split\n+  [(set (match_operand 0 \"arith_reg_dest\" \"\")\n+\t(match_operand 1 \"sh_rep_vec\" \"\"))]\n+  \"TARGET_SHMEDIA && reload_completed\n+   && GET_MODE (operands[0]) == GET_MODE (operands[1])\n+   && VECTOR_MODE_SUPPORTED_P (GET_MODE (operands[0]))\n+   && GET_MODE_SIZE (GET_MODE (operands[0])) == 8\n+   && (XVECEXP (operands[1], 0, 0) != const0_rtx\n+       || XVECEXP (operands[1], 0, 1) != const0_rtx)\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (match_dup 2)]\n+  \"\n+{\n+  int unit_size = GET_MODE_UNIT_SIZE (GET_MODE (operands[1]));\n+  rtx elt1 = XVECEXP (operands[1], 0, 1);\n+\n+  if (unit_size > 2)\n+    operands[2] = gen_mshflo_l (operands[0], operands[0], operands[0]);\n+  else\n+    operands[2] = gen_mperm_w0 (operands[0], operands[0]);\n+  operands[0] = gen_rtx_REG (DImode, true_regnum (operands[0]));\n+  operands[1] = XVECEXP (operands[1], 0, 0);\n+  if (unit_size < 2)\n+    {\n+      if (GET_CODE (operands[1]) == CONST_INT && GET_CODE (elt1) == CONST_INT)\n+\toperands[1] = GEN_INT (TARGET_LITTLE_ENDIAN\n+\t\t\t       ? INTVAL (operands[1]) + (INTVAL (elt1) << 8)\n+\t\t\t       : (INTVAL (operands[1]) << 8) + INTVAL (elt1));\n+      else\n+\t{\n+\t  operands[0] = gen_rtx_REG (V2QImode, true_regnum (operands[0]));\n+\t  operands[1]\n+\t    = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, operands[1], elt1));\n+\t}\n+    }\n+}\")\n+\n+(define_split\n+  [(set (match_operand 0 \"arith_reg_dest\" \"\")\n+\t(match_operand 1 \"sh_const_vec\" \"\"))]\n+  \"TARGET_SHMEDIA && reload_completed\n+   && GET_MODE (operands[0]) == GET_MODE (operands[1])\n+   && VECTOR_MODE_SUPPORTED_P (GET_MODE (operands[0]))\n+   && XVECEXP (operands[1], 0, 0) != const0_rtx\n+   && (HOST_BITS_PER_WIDE_INT >= 64\n+       || HOST_BITS_PER_WIDE_INT >= GET_MODE_BITSIZE (GET_MODE (operands[0]))\n+       || sh_1el_vec (operands[1], VOIDmode))\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"\n+{\n+  rtx v = operands[1];\n+  enum machine_mode new_mode\n+    = mode_for_size (GET_MODE_BITSIZE (GET_MODE (v)), MODE_INT, 0);\n+\n+  operands[0] = gen_rtx_REG (new_mode, true_regnum (operands[0]));\n+  operands[1]\n+    = simplify_subreg (new_mode, operands[1], GET_MODE (operands[0]), 0);\n+}\")\n+\n+(define_expand \"movv2hi\"\n+  [(set (match_operand:V2HI 0 \"general_movdst_operand\" \"\")\n+\t(match_operand:V2HI 1 \"general_movsrc_operand\" \"\"))]\n+  \"TARGET_SHMEDIA\"\n+  \"{ if (prepare_move_operands (operands, V2HImode)) DONE; }\")\n+\n+(define_insn \"movv2hi_i\"\n+  [(set (match_operand:V2HI 0 \"general_movdst_operand\" \"=r,r,r,rl,m\")\n+\t(match_operand:V2HI 1 \"general_movsrc_operand\" \"r,JSU,nW,m,rl\"))]\n+  \"TARGET_SHMEDIA\n+   && (register_operand (operands[0], V2HImode)\n+       || register_operand (operands[1], V2HImode))\"\n+  \"@\n+\taddz.l\t%1, r63, %0\n+\tmovi\t%1, %0\n+\t#\n+\tld%M1.l\t%m1, %0\n+\tst%M0.l\t%m0, %1\"\n+  [(set_attr \"type\"   \"arith_media,arith_media,*,load_media,store_media\")\n+   (set_attr \"length\" \"4,4,16,4,4\")])\n+\n+(define_expand \"movv4hi\"\n+  [(set (match_operand:V4HI 0 \"general_movdst_operand\" \"\")\n+\t(match_operand:V4HI 1 \"general_movsrc_operand\" \"\"))]\n+  \"TARGET_SHMEDIA\"\n+  \"{ if (prepare_move_operands (operands, V4HImode)) DONE; }\")\n+\n+(define_insn \"movv4hi_i\"\n+  [(set (match_operand:V4HI 0 \"general_movdst_operand\" \"=r,r,r,rl,m\")\n+\t(match_operand:V4HI 1 \"general_movsrc_operand\" \"r,JSU,nW,m,rl\"))]\n+  \"TARGET_SHMEDIA\n+   && (register_operand (operands[0], V4HImode)\n+       || register_operand (operands[1], V4HImode))\"\n+  \"@\n+\tadd\t%1, r63, %0\n+\tmovi\t%1, %0\n+\t#\n+\tld%M1.q\t%m1, %0\n+\tst%M0.q\t%m0, %1\"\n+  [(set_attr \"type\"   \"arith_media,arith_media,*,load_media,store_media\")\n+   (set_attr \"length\" \"4,4,16,4,4\")])\n+\n+(define_expand \"movv2si\"\n+  [(set (match_operand:V2SI 0 \"general_movdst_operand\" \"\")\n+\t(match_operand:V2SI 1 \"general_movsrc_operand\" \"\"))]\n+  \"TARGET_SHMEDIA\"\n+  \"{ if (prepare_move_operands (operands, V2SImode)) DONE; }\")\n+\n+(define_insn \"movv2si_i\"\n+  [(set (match_operand:V2SI 0 \"general_movdst_operand\" \"=r,r,r,rl,m\")\n+\t(match_operand:V2SI 1 \"general_movsrc_operand\" \"r,JSU,nW,m,rl\"))]\n+  \"TARGET_SHMEDIA\n+   && (register_operand (operands[0], V2SImode)\n+       || register_operand (operands[1], V2SImode))\"\n+  \"@\n+\tadd\t%1, r63, %0\n+\tmovi\t%1, %0\n+\t#\n+\tld%M1.q\t%m1, %0\n+\tst%M0.q\t%m0, %1\"\n+  [(set_attr \"type\"   \"arith_media,arith_media,*,load_media,store_media\")\n+   (set_attr \"length\" \"4,4,16,4,4\")])\n+\n+;; Multimedia Intrinsics\n+\n+(define_insn \"absv2si2\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(abs:V2SI (match_operand:V2SI 1 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"mabs.l\t%1, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"absv4hi2\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(abs:V4HI (match_operand:V4HI 1 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"mabs.w\t%1, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"addv2si3\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(plus:V2SI (match_operand:V2SI 1 \"arith_reg_operand\" \"%r\")\n+\t\t   (match_operand:V2SI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"madd.l\t%1, %2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"addv4hi3\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(plus:V4HI (match_operand:V4HI 1 \"arith_reg_operand\" \"%r\")\n+\t\t   (match_operand:V4HI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"madd.w\t%1, %2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"ssaddv2si3\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(ss_plus:V2SI (match_operand:V2SI 1 \"arith_reg_operand\" \"%r\")\n+\t\t      (match_operand:V2SI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"madds.l\t%1, %2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"usaddv8qi3\"\n+  [(set (match_operand:V8QI 0 \"arith_reg_dest\" \"=r\")\n+\t(us_plus:V8QI (match_operand:V8QI 1 \"arith_reg_operand\" \"%r\")\n+\t\t      (match_operand:V8QI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"madds.ub\t%1, %2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"ssaddv4hi3\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(ss_plus:V4HI (match_operand:V4HI 1 \"arith_reg_operand\" \"%r\")\n+\t\t      (match_operand:V4HI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"madds.w\t%1, %2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"negcmpeqv8qi\"\n+  [(set (match_operand:V8QI 0 \"arith_reg_dest\" \"=r\")\n+\t(neg:V8QI (eq:V8QI (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"%rU\")\n+\t\t\t   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\"))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mcmpeq.b\t%N1, %N2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"negcmpeqv2si\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(neg:V2SI (eq:V2SI (match_operand:V2SI 1 \"arith_reg_or_0_operand\" \"%rU\")\n+\t\t\t   (match_operand:V2SI 2 \"arith_reg_or_0_operand\" \"rU\"))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mcmpeq.l\t%N1, %N2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"negcmpeqv4hi\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(neg:V4HI (eq:V4HI (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"%rU\")\n+\t\t\t   (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rU\"))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mcmpeq.w\t%N1, %N2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"negcmpgtuv8qi\"\n+  [(set (match_operand:V8QI 0 \"arith_reg_dest\" \"=r\")\n+\t(neg:V8QI (gtu:V8QI (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"%rU\")\n+\t\t\t    (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\"))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mcmpgt.ub\t%N1, %N2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"negcmpgtv2si\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(neg:V2SI (gt:V2SI (match_operand:V2SI 1 \"arith_reg_or_0_operand\" \"%rU\")\n+\t\t\t   (match_operand:V2SI 2 \"arith_reg_or_0_operand\" \"rU\"))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mcmpgt.l\t%N1, %N2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"negcmpgtv4hi\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(neg:V4HI (gt:V4HI (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"%rU\")\n+\t\t\t   (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rU\"))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mcmpgt.w\t%N1, %N2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"mcmv\"\n+  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n+\t(ior:DI (and:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t\t(match_operand:DI 2 \"arith_reg_operand\" \"r\"))\n+\t\t(and:DI (match_operand:DI 3 \"arith_reg_operand\" \"0\")\n+\t\t\t(not:DI (match_dup 2)))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mcmv\t%N1, %2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"mcnvs_lw\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(vec_concat:V4HI\n+\t (ss_truncate:V2HI (match_operand:V2SI 1 \"arith_reg_or_0_operand\" \"rU\"))\n+\t (ss_truncate:V2HI (match_operand:V2SI 2 \"arith_reg_or_0_operand\" \"rU\"))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mcnvs.lw\t%N1, %N2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"mcnvs_wb\"\n+  [(set (match_operand:V8QI 0 \"arith_reg_dest\" \"=r\")\n+\t(vec_concat:V8QI\n+\t (ss_truncate:V4QI (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"rU\"))\n+\t (ss_truncate:V4QI (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rU\"))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mcnvs.wb\t%N1, %N2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"mcnvs_wub\"\n+  [(set (match_operand:V8QI 0 \"arith_reg_dest\" \"=r\")\n+\t(vec_concat:V8QI\n+\t (us_truncate:V4QI (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"rU\"))\n+\t (us_truncate:V4QI (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rU\"))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mcnvs.wub\t%N1, %N2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"mextr_rl\"\n+  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n+\t(ior:DI (lshiftrt:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t\t     (match_operand:HI 3 \"mextr_bit_offset\" \"i\"))\n+\t       (ashift:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t\t  (match_operand:HI 4 \"mextr_bit_offset\" \"i\"))))]\n+  \"TARGET_SHMEDIA && INTVAL (operands[3]) + INTVAL (operands[4]) == 64\"\n+  \"*\n+{\n+  static char templ[16];\n+\n+  sprintf (templ, \\\"mextr%d\\\\t%%N1, %%N2, %%0\\\",\n+\t   (int) INTVAL (operands[3]) >> 3);\n+  return templ;\n+}\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"*mextr_lr\"\n+  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n+\t(ior:DI (ashift:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t\t   (match_operand:HI 3 \"mextr_bit_offset\" \"i\"))\n+\t       (lshiftrt:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t\t    (match_operand:HI 4 \"mextr_bit_offset\" \"i\"))))]\n+  \"TARGET_SHMEDIA && INTVAL (operands[3]) + INTVAL (operands[4]) == 64\"\n+  \"*\n+{\n+  static char templ[16];\n+\n+  sprintf (templ, \\\"mextr%d\\\\t%%N2, %%N1, %%0\\\",\n+\t   (int) INTVAL (operands[4]) >> 3);\n+  return templ;\n+}\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+; mextrN can be modelled with vec_select / vec_concat, but the selection\n+; vector then varies depending on endianness.\n+(define_expand \"mextr1\"\n+  [(match_operand:V8QI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[3],\n+\t\t\t   GEN_INT (1 * 8), GEN_INT (7 * 8)));\n+  DONE;\n+}\")\n+\n+(define_expand \"mextr2\"\n+  [(match_operand:V8QI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[3],\n+\t\t\t   GEN_INT (2 * 8), GEN_INT (6 * 8)));\n+  DONE;\n+}\")\n+\n+(define_expand \"mextr3\"\n+  [(match_operand:V8QI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[3],\n+\t\t\t   GEN_INT (3 * 8), GEN_INT (5 * 8)));\n+  DONE;\n+}\")\n+\n+(define_expand \"mextr4\"\n+  [(match_operand:V8QI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[3],\n+\t\t\t   GEN_INT (4 * 8), GEN_INT (4 * 8)));\n+  DONE;\n+}\")\n+\n+(define_expand \"mextr5\"\n+  [(match_operand:V8QI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[3],\n+\t\t\t   GEN_INT (5 * 8), GEN_INT (3 * 8)));\n+  DONE;\n+}\")\n+\n+(define_expand \"mextr6\"\n+  [(match_operand:V8QI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[3],\n+\t\t\t   GEN_INT (6 * 8), GEN_INT (2 * 8)));\n+  DONE;\n+}\")\n+\n+(define_expand \"mextr7\"\n+  [(match_operand:V8QI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[3],\n+\t\t\t   GEN_INT (7 * 8), GEN_INT (1 * 8)));\n+  DONE;\n+}\")\n+\n+(define_expand \"mmacfx_wl\"\n+  [(match_operand:V2SI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V2HI 1 \"extend_reg_operand\" \"\")\n+   (match_operand:V2HI 2 \"extend_reg_operand\" \"\")\n+   (match_operand:V2SI 3 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn (gen_mmacfx_wl_i (operands[0], operands[3],\n+\t\t\t      operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_insn \"mmacfx_wl_i\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(ss_plus:V2SI\n+\t (match_operand:V2SI 1 \"arith_reg_operand\" \"0\")\n+\t (ss_truncate:V2SI\n+\t  (ashift:V2DI\n+\t   (sign_extend:V2DI\n+\t    (mult:V2SI\n+\t     (sign_extend:V2SI (match_operand:V2HI 2 \"extend_reg_operand\" \"r\"))\n+\t     (sign_extend:V2SI (match_operand:V2HI 3 \"extend_reg_operand\" \"r\"))))\n+\t   (const_int 1)))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mmacfx.wl\t%2, %3, %0\"\n+  [(set_attr \"type\" \"mac_media\")])\n+\n+(define_expand \"mmacnfx_wl\"\n+  [(match_operand:V2SI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V2HI 1 \"extend_reg_operand\" \"\")\n+   (match_operand:V2HI 2 \"extend_reg_operand\" \"\")\n+   (match_operand:V2SI 3 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn (gen_mmacnfx_wl_i (operands[0], operands[3],\n+\t\t\t       operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_insn \"mmacnfx_wl_i\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(ss_minus:V2SI\n+\t (match_operand:V2SI 1 \"arith_reg_operand\" \"0\")\n+\t (ss_truncate:V2SI\n+\t  (ashift:V2DI\n+\t   (sign_extend:V2DI\n+\t    (mult:V2SI\n+\t     (sign_extend:V2SI (match_operand:V2HI 2 \"extend_reg_operand\" \"r\"))\n+\t     (sign_extend:V2SI (match_operand:V2HI 3 \"extend_reg_operand\" \"r\"))))\n+\t   (const_int 1)))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mmacnfx.wl\t%2, %3, %0\"\n+  [(set_attr \"type\" \"mac_media\")])\n+\n+(define_insn \"mulv2si3\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(mult:V2SI (match_operand:V2SI 1 \"arith_reg_operand\" \"r\")\n+\t\t   (match_operand:V2SI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"mmul.l\t%1, %2, %0\"\n+  [(set_attr \"type\" \"d2mpy_media\")])\n+\n+(define_insn \"mulv4hi3\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(mult:V4HI (match_operand:V4HI 1 \"arith_reg_operand\" \"r\")\n+\t\t   (match_operand:V4HI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"mmul.w\t%1, %2, %0\"\n+  [(set_attr \"type\" \"dmpy_media\")])\n+\n+(define_insn \"mmulfx_l\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(ss_truncate:V2SI\n+\t (ashiftrt:V2DI\n+\t  (mult:V2DI\n+\t   (sign_extend:V2DI (match_operand:V2SI 1 \"arith_reg_operand\" \"r\"))\n+\t   (sign_extend:V2DI (match_operand:V2SI 2 \"arith_reg_operand\" \"r\")))\n+\t  (const_int 31))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mmulfx.l\t%1, %2, %0\"\n+  [(set_attr \"type\" \"d2mpy_media\")])\n+\n+(define_insn \"mmulfx_w\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(ss_truncate:V4HI\n+\t (ashiftrt:V4SI\n+\t  (mult:V4SI\n+\t   (sign_extend:V4SI (match_operand:V4HI 1 \"arith_reg_operand\" \"r\"))\n+\t   (sign_extend:V4SI (match_operand:V4HI 2 \"arith_reg_operand\" \"r\")))\n+\t  (const_int 15))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mmulfx.w\t%1, %2, %0\"\n+  [(set_attr \"type\" \"dmpy_media\")])\n+\n+(define_insn \"mmulfxrp_w\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(ss_truncate:V4HI\n+\t (ashiftrt:V4SI\n+\t  (plus:V4SI\n+\t   (mult:V4SI\n+\t    (sign_extend:V4SI (match_operand:V4HI 1 \"arith_reg_operand\" \"r\"))\n+\t    (sign_extend:V4SI (match_operand:V4HI 2 \"arith_reg_operand\" \"r\")))\n+\t   (const_int 16384))\n+\t  (const_int 15))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mmulfxrp.w\t%1, %2, %0\"\n+  [(set_attr \"type\" \"dmpy_media\")])\n+\n+(define_expand \"mmulhi_wl\"\n+  [(match_operand:V2SI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V4HI 1 \"arith_reg_operand\" \"\")\n+   (match_operand:V4HI 2 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn ((TARGET_LITTLE_ENDIAN ? gen_mmul23_wl : gen_mmul01_wl)\n+\t     (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_expand \"mmullo_wl\"\n+  [(match_operand:V2SI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V4HI 1 \"arith_reg_operand\" \"\")\n+   (match_operand:V4HI 2 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn ((TARGET_LITTLE_ENDIAN ? gen_mmul01_wl : gen_mmul23_wl)\n+\t     (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_insn \"mmul23_wl\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(vec_select:V2SI\n+\t (mult:V4SI\n+\t  (sign_extend:V4SI (match_operand:V4HI 1 \"arith_reg_operand\" \"r\"))\n+\t  (sign_extend:V4SI (match_operand:V4HI 2 \"arith_reg_operand\" \"r\")))\n+\t (const_vector [(const_int 2) (const_int 3)])))]\n+  \"TARGET_SHMEDIA\"\n+  \"* return (TARGET_LITTLE_ENDIAN\n+\t     ? \\\"mmulhi.wl\t%1, %2, %0\\\"\n+\t     : \\\"mmullo.wl\t%1, %2, %0\\\");\"\n+  [(set_attr \"type\" \"dmpy_media\")])\n+\n+(define_insn \"mmul01_wl\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(vec_select:V2SI\n+\t (mult:V4SI\n+\t  (sign_extend:V4SI (match_operand:V4HI 1 \"arith_reg_operand\" \"r\"))\n+\t  (sign_extend:V4SI (match_operand:V4HI 2 \"arith_reg_operand\" \"r\")))\n+\t (const_vector [(const_int 0) (const_int 1)])))]\n+  \"TARGET_SHMEDIA\"\n+  \"* return (TARGET_LITTLE_ENDIAN\n+\t     ? \\\"mmullo.wl\t%1, %2, %0\\\"\n+\t     : \\\"mmulhi.wl\t%1, %2, %0\\\");\"\n+  [(set_attr \"type\" \"dmpy_media\")])\n+\n+(define_expand \"mmulsum_wq\"\n+  [(match_operand:DI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V4HI 1 \"arith_reg_operand\" \"\")\n+   (match_operand:V4HI 2 \"arith_reg_operand\" \"\")\n+   (match_operand:DI 3 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn (gen_mmulsum_wq_i (operands[0], operands[3],\n+\t\t\t       operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_insn \"mmulsum_wq_i\"\n+  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n+\t (plus:DI\n+\t  (plus:DI\n+\t   (vec_select:DI\n+\t    (mult:V4DI\n+\t     (sign_extend:V4DI (match_operand:V4HI 2 \"arith_reg_operand\" \"r\"))\n+\t     (sign_extend:V4DI (match_operand:V4HI 3 \"arith_reg_operand\" \"r\")))\n+\t    (const_vector [(const_int 0)]))\n+\t   (vec_select:DI (mult:V4DI (sign_extend:V4DI (match_dup 2))\n+\t\t\t\t     (sign_extend:V4DI (match_dup 3)))\n+\t\t\t  (const_vector [(const_int 1)])))\n+\t  (plus:DI\n+\t   (vec_select:DI (mult:V4DI (sign_extend:V4DI (match_dup 2))\n+\t\t\t\t     (sign_extend:V4DI (match_dup 3)))\n+\t\t\t  (const_vector [(const_int 2)]))\n+\t   (vec_select:DI (mult:V4DI (sign_extend:V4DI (match_dup 2))\n+\t\t\t\t     (sign_extend:V4DI (match_dup 3)))\n+\t\t\t  (const_vector [(const_int 3)]))))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mmulsum.wq\t%2, %3, %0\"\n+  [(set_attr \"type\" \"mac_media\")])\n+\n+(define_expand \"mperm_w\"\n+  [(match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+   (match_operand:V4HI 1 \"arith_reg_operand\" \"r\")\n+   (match_operand:QI 2 \"extend_reg_or_0_operand\" \"rU\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn ((TARGET_LITTLE_ENDIAN ? gen_mperm_w_little : gen_mperm_w_big)\n+\t     (operands[0], operands[1], operands[2]));\n+}\")\n+\n+; This use of vec_select isn't exactly correct according to rtl.texi\n+; (because not constant), but it seems a straightforward extension.\n+(define_insn \"mperm_w_little\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(vec_select:V4HI\n+\t (match_operand:V4HI 1 \"arith_reg_operand\" \"r\")\n+\t (parallel\n+\t  [(zero_extract (match_operand:QI 2 \"extend_reg_or_0_operand\" \"rU\")\n+\t\t\t (const_int 2) (const_int 0))\n+\t   (zero_extract (match_dup 2) (const_int 2) (const_int 2))\n+\t   (zero_extract (match_dup 2) (const_int 2) (const_int 4))\n+\t   (zero_extract (match_dup 2) (const_int 2) (const_int 6))])))]\n+  \"TARGET_SHMEDIA && TARGET_LITTLE_ENDIAN\"\n+  \"mperm.w\t%1, %N2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"mperm_w_big\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(vec_select:V4HI\n+\t (match_operand:V4HI 1 \"arith_reg_operand\" \"r\")\n+\t (parallel\n+\t  [(zero_extract (not:QI (match_operand:QI 2\n+\t\t\t\t  \"extend_reg_or_0_operand\" \"rU\"))\n+\t\t\t (const_int 2) (const_int 0))\n+\t   (zero_extract (not:QI (match_dup 2)) (const_int 2) (const_int 2))\n+\t   (zero_extract (not:QI (match_dup 2)) (const_int 2) (const_int 4))\n+\t   (zero_extract (not:QI (match_dup 2)) (const_int 2) (const_int 6))])))]\n+  \"TARGET_SHMEDIA && ! TARGET_LITTLE_ENDIAN\"\n+  \"mperm.w\t%1, %N2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"mperm_w0\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(vec_duplicate:V4HI (truncate:HI (match_operand 1\n+\t\t\t\t\t  \"extend_reg_operand\" \"r\"))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mperm.w\t%1, r63, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_expand \"msad_ubq\"\n+  [(match_operand:DI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"\")\n+   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"\")\n+   (match_operand:DI 3 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn (gen_msad_ubq_i (operands[0], operands[3],\n+\t\t\t     operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_insn \"msad_ubq_i\"\n+  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n+\t(plus:DI\n+\t (plus:DI\n+\t  (plus:DI\n+\t   (plus:DI\n+\t    (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n+\t    (abs:DI (vec_select:DI\n+\t\t     (minus:V8DI\n+\t\t      (zero_extend:V8DI\n+\t\t       (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"r\"))\n+\t\t      (zero_extend:V8DI\n+\t\t       (match_operand:V8QI 3 \"arith_reg_or_0_operand\" \"r\")))\n+\t\t     (const_vector [(const_int 0)]))))\n+\t   (abs:DI (vec_select:DI (minus:V8DI (zero_extend:V8DI (match_dup 2))\n+\t\t\t\t\t      (zero_extend:V8DI (match_dup 3)))\n+\t\t\t\t  (const_vector [(const_int 1)]))))\n+\t  (plus:DI\n+\t   (abs:DI (vec_select:DI (minus:V8DI (zero_extend:V8DI (match_dup 2))\n+\t\t\t\t\t      (zero_extend:V8DI (match_dup 3)))\n+\t\t\t\t  (const_vector [(const_int 2)])))\n+\t   (abs:DI (vec_select:DI (minus:V8DI (zero_extend:V8DI (match_dup 2))\n+\t\t\t\t\t      (zero_extend:V8DI (match_dup 3)))\n+\t\t\t\t  (const_vector [(const_int 3)])))))\n+\t (plus:DI\n+\t  (plus:DI\n+\t   (abs:DI (vec_select:DI (minus:V8DI (zero_extend:V8DI (match_dup 2))\n+\t\t\t\t\t      (zero_extend:V8DI (match_dup 3)))\n+\t\t\t\t  (const_vector [(const_int 4)])))\n+\t   (abs:DI (vec_select:DI (minus:V8DI (zero_extend:V8DI (match_dup 2))\n+\t\t\t\t\t      (zero_extend:V8DI (match_dup 3)))\n+\t\t\t\t  (const_vector [(const_int 5)]))))\n+\t  (plus:DI\n+\t   (abs:DI (vec_select:DI (minus:V8DI (zero_extend:V8DI (match_dup 2))\n+\t\t\t\t\t      (zero_extend:V8DI (match_dup 3)))\n+\t\t\t\t  (const_vector [(const_int 6)])))\n+\t   (abs:DI (vec_select:DI (minus:V8DI (zero_extend:V8DI (match_dup 2))\n+\t\t\t\t\t      (zero_extend:V8DI (match_dup 3)))\n+\t\t\t\t  (const_vector [(const_int 7)])))))))]\n+  \"TARGET_SHMEDIA\"\n+  \"msad.ubq\t%N2, %N3, %0\"\n+  [(set_attr \"type\" \"mac_media\")])\n+\n+(define_insn \"mshalds_l\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(ss_truncate:V2SI\n+\t (ashift:V2DI\n+\t  (sign_extend:V2DI (match_operand:V2SI 1 \"arith_reg_operand\" \"r\"))\n+\t  (and:DI (match_operand:DI 2 \"arith_reg_operand\" \"r\")\n+\t\t  (const_int 31)))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mshalds.l\t%1, %2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"mshalds_w\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(ss_truncate:V4HI\n+\t (ashift:V4SI\n+\t  (sign_extend:V4SI (match_operand:V4HI 1 \"arith_reg_operand\" \"r\"))\n+\t  (and:DI (match_operand:DI 2 \"arith_reg_operand\" \"r\")\n+\t\t  (const_int 15)))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mshalds.w\t%1, %2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"ashrv2si3\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(ashiftrt:V2SI (match_operand:V2SI 1 \"arith_reg_operand\" \"r\")\n+\t\t       (match_operand:DI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"mshard.l\t%1, %2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"ashrv4hi3\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(ashiftrt:V4HI (match_operand:V4HI 1 \"arith_reg_operand\" \"r\")\n+\t\t       (match_operand:DI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"mshard.w\t%1, %2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"mshards_q\"\n+  [(set (match_operand:HI 0 \"arith_reg_dest\" \"=r\")\n+\t(ss_truncate:HI\n+\t (ashiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"r\")\n+\t\t      (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\"))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mshards.q\t%1, %N2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_expand \"mshfhi_b\"\n+  [(match_operand:V8QI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn ((TARGET_LITTLE_ENDIAN ? gen_mshf4_b : gen_mshf0_b)\n+\t     (operands[0], operands[1], operands[2]));\n+}\")\n+\n+(define_expand \"mshflo_b\"\n+  [(match_operand:V8QI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn ((TARGET_LITTLE_ENDIAN ? gen_mshf0_b : gen_mshf4_b)\n+\t     (operands[0], operands[1], operands[2]));\n+}\")\n+\n+(define_insn \"mshf4_b\"\n+  [(set\n+    (match_operand:V8QI 0 \"arith_reg_dest\" \"=r\")\n+    (vec_select:V8QI\n+     (vec_concat:V16QI (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t       (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\"))\n+     (const_vector [(const_int 4) (const_int 12) (const_int 5) (const_int 13)\n+\t\t    (const_int 6) (const_int 14) (const_int 7) (const_int 15)])))]\n+  \"TARGET_SHMEDIA\"\n+  \"* return (TARGET_LITTLE_ENDIAN\n+\t     ? \\\"mshfhi.b\t%N1, %N2, %0\\\"\n+\t     : \\\"mshflo.b\t%N1, %N2, %0\\\");\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"mshf0_b\"\n+  [(set\n+    (match_operand:V8QI 0 \"arith_reg_dest\" \"=r\")\n+    (vec_select:V8QI\n+     (vec_concat:V16QI (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t       (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\"))\n+     (const_vector [(const_int 0) (const_int 8) (const_int 1) (const_int 9)\n+\t\t    (const_int 2) (const_int 10) (const_int 3) (const_int 11)])))]\n+  \"TARGET_SHMEDIA\"\n+  \"* return (TARGET_LITTLE_ENDIAN\n+\t     ? \\\"mshflo.b\t%N1, %N2, %0\\\"\n+\t     : \\\"mshfhi.b\t%N1, %N2, %0\\\");\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_expand \"mshfhi_l\"\n+  [(match_operand:V2SI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V2SI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:V2SI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn ((TARGET_LITTLE_ENDIAN ? gen_mshf4_l : gen_mshf0_l)\n+\t     (operands[0], operands[1], operands[2]));\n+}\")\n+\n+(define_expand \"mshflo_l\"\n+  [(match_operand:V2SI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V2SI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:V2SI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn ((TARGET_LITTLE_ENDIAN ? gen_mshf0_l : gen_mshf4_l)\n+\t     (operands[0], operands[1], operands[2]));\n+}\")\n+\n+(define_insn \"mshf4_l\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(vec_select:V2SI\n+\t (vec_concat:V4SI (match_operand:V2SI 1 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t\t  (match_operand:V2SI 2 \"arith_reg_or_0_operand\" \"rU\"))\n+\t (const_vector [(const_int 1) (const_int 3)])))]\n+  \"TARGET_SHMEDIA\"\n+  \"* return (TARGET_LITTLE_ENDIAN\n+\t     ? \\\"mshfhi.l\t%N1, %N2, %0\\\"\n+\t     : \\\"mshflo.l\t%N1, %N2, %0\\\");\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"mshf0_l\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(vec_select:V2SI\n+\t (vec_concat:V4SI (match_operand:V2SI 1 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t\t  (match_operand:V2SI 2 \"arith_reg_or_0_operand\" \"rU\"))\n+\t (const_vector [(const_int 0) (const_int 2)])))]\n+  \"TARGET_SHMEDIA\"\n+  \"* return (TARGET_LITTLE_ENDIAN\n+\t     ? \\\"mshflo.l\t%N1, %N2, %0\\\"\n+\t     : \\\"mshfhi.l\t%N1, %N2, %0\\\");\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_expand \"mshfhi_w\"\n+  [(match_operand:V4HI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn ((TARGET_LITTLE_ENDIAN ? gen_mshf4_w : gen_mshf0_w)\n+\t     (operands[0], operands[1], operands[2]));\n+}\")\n+\n+(define_expand \"mshflo_w\"\n+  [(match_operand:V4HI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  emit_insn ((TARGET_LITTLE_ENDIAN ? gen_mshf0_w : gen_mshf4_w)\n+\t     (operands[0], operands[1], operands[2]));\n+}\")\n+\n+(define_insn \"mshf4_w\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(vec_select:V4HI\n+\t (vec_concat:V8HI (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t\t  (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rU\"))\n+\t (const_vector [(const_int 2) (const_int 6) (const_int 3) (const_int 7)])))]\n+  \"TARGET_SHMEDIA\"\n+  \"* return (TARGET_LITTLE_ENDIAN\n+\t     ? \\\"mshfhi.w\t%N1, %N2, %0\\\"\n+\t     : \\\"mshflo.w\t%N1, %N2, %0\\\");\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"mshf0_w\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(vec_select:V4HI\n+\t (vec_concat:V8HI (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t\t  (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rU\"))\n+\t (const_vector [(const_int 0) (const_int 4) (const_int 1) (const_int 5)])))]\n+  \"TARGET_SHMEDIA\"\n+  \"* return (TARGET_LITTLE_ENDIAN\n+\t     ? \\\"mshflo.w\t%N1, %N2, %0\\\"\n+\t     : \\\"mshfhi.w\t%N1, %N2, %0\\\");\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+/* These are useful to expand ANDs and as combiner patterns.  */\n+(define_insn \"mshfhi_l_di\"\n+  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n+\t(ior:DI (lshiftrt:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\") \n+                             (const_int 32))\n+\t\t(and:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t\t(const_int -4294967296))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mshfhi.l\t%N1, %N2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"*mshfhi_l_di_rev\"\n+  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n+\t(ior:DI (and:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t\t(const_int -4294967296))\n+\t\t(lshiftrt:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\") \n+                             (const_int 32))))]\n+  \"TARGET_SHMEDIA\"\n+  \"mshfhi.l\t%N2, %N1, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"mshflo_l_di\"\n+  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n+\t(ior:DI (and:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t\t(const_int 4294967295))\n+\t\t(ashift:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")\n+                           (const_int 32))))]\n+\t\t\t\t\n+  \"TARGET_SHMEDIA\"\n+  \"mshflo.l\t%N1, %N2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"*mshflo_l_di_rev\"\n+  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n+\t(ior:DI (ashift:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n+                           (const_int 32))\n+\t\t(and:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t\t(const_int 4294967295))))]\n+\t\t\t\t\n+  \"TARGET_SHMEDIA\"\n+  \"mshflo.l\t%N2, %N1, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"*mshflo_l_di_x\"\n+  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n+\t(ior:DI (zero_extend:DI (match_operand:SI 1 \"extend_reg_or_0_operand\" \"rU\"))\n+\t\t(ashift:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")\n+                           (const_int 32))))]\n+\t\t\t\t\n+  \"TARGET_SHMEDIA\"\n+  \"mshflo.l\t%N1, %N2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"*mshflo_l_di_x_rev\"\n+  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n+\t(ior:DI (ashift:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n+                           (const_int 32))\n+\t\t(zero_extend:DI (match_operand:SI 2 \"extend_reg_or_0_operand\" \"rU\"))))]\n+\t\t\t\t\n+  \"TARGET_SHMEDIA\"\n+  \"mshflo.l\t%N2, %N1, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"ashlv2si3\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(ashift:V2SI (match_operand:V2SI 1 \"arith_reg_operand\" \"r\")\n+\t\t     (match_operand:DI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"mshlld.l\t%1, %2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"ashlv4hi3\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(ashift:V4HI (match_operand:V4HI 1 \"arith_reg_operand\" \"r\")\n+\t\t     (match_operand:DI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"mshlld.w\t%1, %2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"lshrv2si3\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(lshiftrt:V2SI (match_operand:V2SI 1 \"arith_reg_operand\" \"r\")\n+\t\t       (match_operand:DI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"mshlrd.l\t%1, %2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"lshrv4hi3\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(lshiftrt:V4HI (match_operand:V4HI 1 \"arith_reg_operand\" \"r\")\n+\t\t       (match_operand:DI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"mshlrd.w\t%1, %2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"subv2si3\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(minus:V2SI (match_operand:V2SI 1 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t    (match_operand:V2SI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"msub.l\t%N1, %2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"subv4hi3\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(minus:V4HI (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t    (match_operand:V4HI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"msub.w\t%N1, %2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"sssubv2si3\"\n+  [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n+\t(ss_minus:V2SI (match_operand:V2SI 1 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t       (match_operand:V2SI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"msubs.l\t%N1, %2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"ussubv8qi3\"\n+  [(set (match_operand:V8QI 0 \"arith_reg_dest\" \"=r\")\n+\t(us_minus:V8QI (match_operand:V8QI 1 \"arith_reg_operand\" \"r\")\n+\t\t       (match_operand:V8QI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"msubs.ub\t%1, %2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+(define_insn \"sssubv4hi3\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(ss_minus:V4HI (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t       (match_operand:V4HI 2 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"msubs.w\t%N1, %2, %0\"\n+  [(set_attr \"type\" \"mcmp_media\")])\n+\n+;; Floating Point Intrinsics\n+\n+(define_insn \"fcosa_s\"\n+  [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"=f\")\n+\t(unspec:SF [(match_operand:SI 1 \"fp_arith_reg_operand\" \"f\")]\n+\t\t   UNSPEC_FCOSA))]\n+  \"TARGET_SHMEDIA\"\n+  \"fcosa.s\t%1, %0\"\n+  [(set_attr \"type\" \"atrans_media\")])\n+\n+(define_insn \"fsina_s\"\n+  [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"=f\")\n+\t(unspec:SF [(match_operand:SI 1 \"fp_arith_reg_operand\" \"f\")]\n+\t\t   UNSPEC_FSINA))]\n+  \"TARGET_SHMEDIA\"\n+  \"fsina.s\t%1, %0\"\n+  [(set_attr \"type\" \"atrans_media\")])\n+\n+(define_insn \"fipr\"\n+  [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"=f\")\n+\t(plus:SF (plus:SF (vec_select:SF (mult:V4SF (match_operand:V4SF 1\n+\t\t\t\t\t\t    \"fp_arith_reg_operand\" \"f\")\n+\t\t\t\t\t\t   (match_operand:V4SF 2\n+\t\t\t\t\t\t    \"fp_arith_reg_operand\" \"f\"))\n+\t\t\t\t\t (const_vector [(const_int 0)]))\n+\t\t\t  (vec_select:SF (mult:V4SF (match_dup 1) (match_dup 2))\n+\t\t\t\t\t (const_vector [(const_int 1)])))\n+\t\t (plus:SF (vec_select:SF (mult:V4SF (match_dup 1) (match_dup 2))\n+\t\t\t\t\t (const_vector [(const_int 2)]))\n+\t\t\t  (vec_select:SF (mult:V4SF (match_dup 1) (match_dup 2))\n+\t\t\t\t\t (const_vector [(const_int 3)])))))]\n+  \"TARGET_SHMEDIA\"\n+  \"fipr\t%1, %2, %0\"\n+  [(set_attr \"type\" \"fparith_media\")])\n+\n+(define_insn \"fsrra_s\"\n+  [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"=f\")\n+\t(unspec:SF [(match_operand:SF 1 \"fp_arith_reg_operand\" \"f\")]\n+\t\t   UNSPEC_FSRRA))]\n+  \"TARGET_SHMEDIA\"\n+  \"fsrra.s\t%1, %0\"\n+  [(set_attr \"type\" \"atrans_media\")])\n+\n+(define_insn \"ftrv\"\n+  [(set (match_operand:V4SF 0 \"fp_arith_reg_operand\" \"=f\")\n+\t(plus:V4SF\n+\t (plus:V4SF\n+\t  (mult:V4SF\n+\t   (vec_select:V4SF (match_operand:V16SF 1 \"fp_arith_reg_operand\" \"f\")\n+\t\t\t    (const_vector [(const_int 0) (const_int 5)\n+\t\t\t\t\t   (const_int 10) (const_int 15)]))\n+\t   (match_operand:V4SF 2 \"fp_arith_reg_operand\" \"f\"))\n+\t  (mult:V4SF\n+\t   (vec_select:V4SF (match_dup 1)\n+\t\t\t    (const_vector [(const_int 4) (const_int 9)\n+\t\t\t\t\t   (const_int 14) (const_int 3)]))\n+\t   (vec_select:V4SF (match_dup 2)\n+\t\t\t    (const_vector [(const_int 1) (const_int 2)\n+\t\t\t\t\t   (const_int 3) (const_int 0)]))))\n+\t (plus:V4SF\n+\t  (mult:V4SF\n+\t   (vec_select:V4SF (match_dup 1)\n+\t\t\t    (const_vector [(const_int 8) (const_int 13)\n+\t\t\t\t\t   (const_int 2) (const_int 7)]))\n+\t   (vec_select:V4SF (match_dup 2)\n+\t\t\t    (const_vector [(const_int 2) (const_int 3)\n+\t\t\t\t\t   (const_int 0) (const_int 1)])))\n+\t  (mult:V4SF\n+\t   (vec_select:V4SF (match_dup 1)\n+\t\t\t    (const_vector [(const_int 12) (const_int 1)\n+\t\t\t\t\t   (const_int 6) (const_int 11)]))\n+\t   (vec_select:V4SF (match_dup 2)\n+\t\t\t    (const_vector [(const_int 3) (const_int 0)\n+\t\t\t\t\t   (const_int 1) (const_int 2)]))))))]\n+  \"TARGET_SHMEDIA\"\n+  \"ftrv %1, %2, %0\"\n+  [(set_attr \"type\" \"fparith_media\")])\n+\n ;; The following description  models the\n ;; SH4 pipeline using the DFA based scheduler. \n ;; The DFA based description is better way to model "}]}