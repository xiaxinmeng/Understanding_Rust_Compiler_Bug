{"sha": "df0e57c2c032cea0f77f2e68231c035f282b26d6", "node_id": "C_kwDOANBUbNoAKGRmMGU1N2MyYzAzMmNlYTBmNzdmMmU2ODIzMWMwMzVmMjgyYjI2ZDY", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@arm.com", "date": "2021-10-20T15:30:16Z"}, "committer": {"name": "Christophe Lyon", "email": "christophe.lyon@foss.st.com", "date": "2022-02-22T15:55:07Z"}, "message": "arm: Fix vcond_mask expander for MVE (PR target/100757)\n\nThe problem in this PR is that we call VPSEL with a mask of vector\ntype instead of HImode. This happens because operand 3 in vcond_mask\nis the pre-computed vector comparison and has vector type.\n\nThis patch fixes it by implementing TARGET_VECTORIZE_GET_MASK_MODE,\nreturning the appropriate VxBI mode when targeting MVE.  In turn, this\nimplies implementing vec_cmp<mode><MVE_vpred>,\nvec_cmpu<mode><MVE_vpred> and vcond_mask_<mode><MVE_vpred>, and we can\nmove vec_cmp<mode><v_cmp_result>, vec_cmpu<mode><mode> and\nvcond_mask_<mode><v_cmp_result> back to neon.md since they are not\nused by MVE anymore.  The new *<MVE_vpred> patterns listed above are\nimplemented in mve.md since they are only valid for MVE. However this\nmay make maintenance/comparison more painful than having all of them\nin vec-common.md.\n\nIn the process, we can get rid of the recently added vcond_mve\nparameter of arm_expand_vector_compare.\n\nCompared to neon.md's vcond_mask_<mode><v_cmp_result> before my \"arm:\nAuto-vectorization for MVE: vcmp\" patch (r12-834), it keeps the VDQWH\niterator added in r12-835 (to have V4HF/V8HF support), as well as the\n(!<Is_float_mode> || flag_unsafe_math_optimizations) condition which\nwas not present before r12-834 although SF modes were enabled by VDQW\n(I think this was a bug).\n\nUsing TARGET_VECTORIZE_GET_MASK_MODE has the advantage that we no\nlonger need to generate vpsel with vectors of 0 and 1: the masks are\nnow merged via scalar 'ands' instructions operating on 16-bit masks\nafter converting the boolean vectors.\n\nIn addition, this patch fixes a problem in arm_expand_vcond() where\nthe result would be a vector of 0 or 1 instead of operand 1 or 2.\n\nSince we want to skip gcc.dg/signbit-2.c for MVE, we also add a new\narm_mve effective target.\n\nReducing the number of iterations in pr100757-3.c from 32 to 8, we\ngenerate the code below:\n\nfloat a[32];\nfloat fn1(int d) {\n  float c = 4.0f;\n  for (int b = 0; b < 8; b++)\n    if (a[b] != 2.0f)\n      c = 5.0f;\n  return c;\n}\n\nfn1:\n\tldr     r3, .L3+48\n\tvldr.64 d4, .L3              // q2=(2.0,2.0,2.0,2.0)\n\tvldr.64 d5, .L3+8\n\tvldrw.32        q0, [r3]     // q0=a(0..3)\n\tadds    r3, r3, #16\n\tvcmp.f32        eq, q0, q2   // cmp a(0..3) == (2.0,2.0,2.0,2.0)\n\tvldrw.32        q1, [r3]     // q1=a(4..7)\n\tvmrs     r3, P0\n\tvcmp.f32        eq, q1, q2   // cmp a(4..7) == (2.0,2.0,2.0,2.0)\n\tvmrs    r2, P0  @ movhi\n\tands    r3, r3, r2           // r3=select(a(0..3]) & select(a(4..7))\n\tvldr.64 d4, .L3+16           // q2=(5.0,5.0,5.0,5.0)\n\tvldr.64 d5, .L3+24\n\tvmsr     P0, r3\n\tvldr.64 d6, .L3+32           // q3=(4.0,4.0,4.0,4.0)\n\tvldr.64 d7, .L3+40\n\tvpsel q3, q3, q2             // q3=vcond_mask(4.0,5.0)\n\tvmov.32 r2, q3[1]            // keep the scalar max\n\tvmov.32 r0, q3[3]\n\tvmov.32 r3, q3[2]\n\tvmov.f32        s11, s12\n\tvmov    s15, r2\n\tvmov    s14, r3\n\tvmaxnm.f32      s15, s11, s15\n\tvmaxnm.f32      s15, s15, s14\n\tvmov    s14, r0\n\tvmaxnm.f32      s15, s15, s14\n\tvmov    r0, s15\n\tbx      lr\n\t.L4:\n\t.align  3\n\t.L3:\n\t.word   1073741824\t// 2.0f\n\t.word   1073741824\n\t.word   1073741824\n\t.word   1073741824\n\t.word   1084227584\t// 5.0f\n\t.word   1084227584\n\t.word   1084227584\n\t.word   1084227584\n\t.word   1082130432\t// 4.0f\n\t.word   1082130432\n\t.word   1082130432\n\t.word   1082130432\n\nThis patch adds tests that trigger an ICE without this fix.\n\nThe pr100757*.c testcases are derived from\ngcc.c-torture/compile/20160205-1.c, forcing the use of MVE, and using\nvarious types and return values different from 0 and 1 to avoid\ncommonalization with boolean masks.  In addition, since we should not\nneed these masks, the tests make sure they are not present.\n\nMost of the work of this patch series was carried out while I was\nworking at STMicroelectronics as a Linaro assignee.\n\n2022-02-22  Christophe Lyon  <christophe.lyon@arm.com>\n\n\tPR target/100757\n\tgcc/\n\t* config/arm/arm-protos.h (arm_get_mask_mode): New prototype.\n\t(arm_expand_vector_compare): Update prototype.\n\t* config/arm/arm.cc (TARGET_VECTORIZE_GET_MASK_MODE): New.\n\t(arm_vector_mode_supported_p): Add support for VxBI modes.\n\t(arm_expand_vector_compare): Remove useless generation of vpsel.\n\t(arm_expand_vcond): Fix select operands.\n\t(arm_get_mask_mode): New.\n\t* config/arm/mve.md (vec_cmp<mode><MVE_vpred>): New.\n\t(vec_cmpu<mode><MVE_vpred>): New.\n\t(vcond_mask_<mode><MVE_vpred>): New.\n\t* config/arm/vec-common.md (vec_cmp<mode><v_cmp_result>)\n\t(vec_cmpu<mode><mode, vcond_mask_<mode><v_cmp_result>): Move to ...\n\t* config/arm/neon.md (vec_cmp<mode><v_cmp_result>)\n\t(vec_cmpu<mode><mode, vcond_mask_<mode><v_cmp_result>): ... here\n\tand disable for MVE.\n\t* doc/sourcebuild.texi (arm_mve): Document new effective-target.\n\n\tgcc/testsuite/\n\tPR target/100757\n\t* gcc.target/arm/simd/pr100757-2.c: New.\n\t* gcc.target/arm/simd/pr100757-3.c: New.\n\t* gcc.target/arm/simd/pr100757-4.c: New.\n\t* gcc.target/arm/simd/pr100757.c: New.\n\t* gcc.dg/signbit-2.c: Skip when targeting ARM/MVE.\n\t* lib/target-supports.exp (check_effective_target_arm_mve): New.", "tree": {"sha": "21d8c9a9003ba83035baaea4f058760da0e64036", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21d8c9a9003ba83035baaea4f058760da0e64036"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df0e57c2c032cea0f77f2e68231c035f282b26d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df0e57c2c032cea0f77f2e68231c035f282b26d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df0e57c2c032cea0f77f2e68231c035f282b26d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df0e57c2c032cea0f77f2e68231c035f282b26d6/comments", "author": null, "committer": null, "parents": [{"sha": "91224cf625dc90304bb515a0cc602beed48fe3da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91224cf625dc90304bb515a0cc602beed48fe3da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91224cf625dc90304bb515a0cc602beed48fe3da"}], "stats": {"total": 357, "additions": 227, "deletions": 130}, "files": [{"sha": "9d142096cb6383051e64138e3133a5262198b26a", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=df0e57c2c032cea0f77f2e68231c035f282b26d6", "patch": "@@ -204,6 +204,7 @@ extern void arm_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n extern bool arm_pad_reg_upward (machine_mode, tree, int);\n #endif\n extern int arm_apply_result_size (void);\n+extern opt_machine_mode arm_get_mask_mode (machine_mode mode);\n \n #endif /* RTX_CODE */\n \n@@ -380,7 +381,7 @@ extern void arm_emit_coreregs_64bit_shift (enum rtx_code, rtx, rtx, rtx, rtx,\n extern bool arm_fusion_enabled_p (tune_params::fuse_ops);\n extern bool arm_valid_symbolic_address_p (rtx);\n extern bool arm_validize_comparison (rtx *, rtx *, rtx *);\n-extern bool arm_expand_vector_compare (rtx, rtx_code, rtx, rtx, bool, bool);\n+extern bool arm_expand_vector_compare (rtx, rtx_code, rtx, rtx, bool);\n #endif /* RTX_CODE */\n \n extern bool arm_gen_setmem (rtx *);"}, {"sha": "c1103d9fad6b175e02b737e50fbc129c6c7d2a95", "filename": "gcc/config/arm/arm.cc", "status": "modified", "additions": 40, "deletions": 77, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Fconfig%2Farm%2Farm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Fconfig%2Farm%2Farm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.cc?ref=df0e57c2c032cea0f77f2e68231c035f282b26d6", "patch": "@@ -832,6 +832,9 @@ static const struct attribute_spec arm_attribute_table[] =\n \n #undef TARGET_STACK_PROTECT_GUARD\n #define TARGET_STACK_PROTECT_GUARD arm_stack_protect_guard\n+\n+#undef TARGET_VECTORIZE_GET_MASK_MODE\n+#define TARGET_VECTORIZE_GET_MASK_MODE arm_get_mask_mode\n \f\n /* Obstack for minipool constant handling.  */\n static struct obstack minipool_obstack;\n@@ -29286,7 +29289,8 @@ arm_vector_mode_supported_p (machine_mode mode)\n \n   if (TARGET_HAVE_MVE\n       && (mode == V2DImode || mode == V4SImode || mode == V8HImode\n-\t  || mode == V16QImode))\n+\t  || mode == V16QImode\n+\t  || mode == V16BImode || mode == V8BImode || mode == V4BImode))\n       return true;\n \n   if (TARGET_HAVE_MVE_FLOAT\n@@ -31085,7 +31089,7 @@ arm_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n }\n \f\n /* Return the mode for the MVE vector of predicates corresponding to MODE.  */\n-machine_mode\n+opt_machine_mode\n arm_mode_to_pred_mode (machine_mode mode)\n {\n   switch (GET_MODE_NUNITS (mode))\n@@ -31094,24 +31098,20 @@ arm_mode_to_pred_mode (machine_mode mode)\n     case 8: return V8BImode;\n     case 4: return V4BImode;\n     }\n-  gcc_unreachable ();\n+  return opt_machine_mode ();\n }\n \n /* Expand code to compare vectors OP0 and OP1 using condition CODE.\n    If CAN_INVERT, store either the result or its inverse in TARGET\n    and return true if TARGET contains the inverse.  If !CAN_INVERT,\n    always store the result in TARGET, never its inverse.\n \n-   If VCOND_MVE, do not emit the vpsel instruction here, let arm_expand_vcond do\n-   it with the right destination type to avoid emiting two vpsel, one here and\n-   one in arm_expand_vcond.\n-\n    Note that the handling of floating-point comparisons is not\n    IEEE compliant.  */\n \n bool\n arm_expand_vector_compare (rtx target, rtx_code code, rtx op0, rtx op1,\n-\t\t\t   bool can_invert, bool vcond_mve)\n+\t\t\t   bool can_invert)\n {\n   machine_mode cmp_result_mode = GET_MODE (target);\n   machine_mode cmp_mode = GET_MODE (op0);\n@@ -31140,7 +31140,7 @@ arm_expand_vector_compare (rtx target, rtx_code code, rtx op0, rtx op1,\n \t       and then store its inverse in TARGET.  This avoids reusing\n \t       TARGET (which for integer NE could be one of the inputs).  */\n \t    rtx tmp = gen_reg_rtx (cmp_result_mode);\n-\t    if (arm_expand_vector_compare (tmp, code, op0, op1, true, vcond_mve))\n+\t    if (arm_expand_vector_compare (tmp, code, op0, op1, true))\n \t      gcc_unreachable ();\n \t    emit_insn (gen_rtx_SET (target, gen_rtx_NOT (cmp_result_mode, tmp)));\n \t    return false;\n@@ -31176,36 +31176,22 @@ arm_expand_vector_compare (rtx target, rtx_code code, rtx op0, rtx op1,\n     case NE:\n       if (TARGET_HAVE_MVE)\n \t{\n-\t  rtx vpr_p0;\n-\t  if (vcond_mve)\n-\t    vpr_p0 = target;\n-\t  else\n-\t    vpr_p0 = gen_reg_rtx (arm_mode_to_pred_mode (cmp_mode));\n-\n \t  switch (GET_MODE_CLASS (cmp_mode))\n \t    {\n \t    case MODE_VECTOR_INT:\n-\t      emit_insn (gen_mve_vcmpq (code, cmp_mode, vpr_p0, op0, force_reg (cmp_mode, op1)));\n+\t      emit_insn (gen_mve_vcmpq (code, cmp_mode, target,\n+\t\t\t\t\top0, force_reg (cmp_mode, op1)));\n \t      break;\n \t    case MODE_VECTOR_FLOAT:\n \t      if (TARGET_HAVE_MVE_FLOAT)\n-\t\temit_insn (gen_mve_vcmpq_f (code, cmp_mode, vpr_p0, op0, force_reg (cmp_mode, op1)));\n+\t\temit_insn (gen_mve_vcmpq_f (code, cmp_mode, target,\n+\t\t\t\t\t    op0, force_reg (cmp_mode, op1)));\n \t      else\n \t\tgcc_unreachable ();\n \t      break;\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n-\n-\t  /* If we are not expanding a vcond, build the result here.  */\n-\t  if (!vcond_mve)\n-\t    {\n-\t      rtx zero = gen_reg_rtx (cmp_result_mode);\n-\t      rtx one = gen_reg_rtx (cmp_result_mode);\n-\t      emit_move_insn (zero, CONST0_RTX (cmp_result_mode));\n-\t      emit_move_insn (one, CONST1_RTX (cmp_result_mode));\n-\t      emit_insn (gen_mve_vpselq (VPSELQ_S, cmp_result_mode, target, one, zero, vpr_p0));\n-\t    }\n \t}\n       else\n \temit_insn (gen_neon_vc (code, cmp_mode, target, op0, op1));\n@@ -31217,23 +31203,8 @@ arm_expand_vector_compare (rtx target, rtx_code code, rtx op0, rtx op1,\n     case GEU:\n     case GTU:\n       if (TARGET_HAVE_MVE)\n-\t{\n-\t  rtx vpr_p0;\n-\t  if (vcond_mve)\n-\t    vpr_p0 = target;\n-\t  else\n-\t    vpr_p0 = gen_reg_rtx (arm_mode_to_pred_mode (cmp_mode));\n-\n-\t  emit_insn (gen_mve_vcmpq (code, cmp_mode, vpr_p0, op0, force_reg (cmp_mode, op1)));\n-\t  if (!vcond_mve)\n-\t    {\n-\t      rtx zero = gen_reg_rtx (cmp_result_mode);\n-\t      rtx one = gen_reg_rtx (cmp_result_mode);\n-\t      emit_move_insn (zero, CONST0_RTX (cmp_result_mode));\n-\t      emit_move_insn (one, CONST1_RTX (cmp_result_mode));\n-\t      emit_insn (gen_mve_vpselq (VPSELQ_S, cmp_result_mode, target, one, zero, vpr_p0));\n-\t    }\n-\t}\n+\temit_insn (gen_mve_vcmpq (code, cmp_mode, target,\n+\t\t\t\t  op0, force_reg (cmp_mode, op1)));\n       else\n \temit_insn (gen_neon_vc (code, cmp_mode, target,\n \t\t\t\top0, force_reg (cmp_mode, op1)));\n@@ -31244,23 +31215,8 @@ arm_expand_vector_compare (rtx target, rtx_code code, rtx op0, rtx op1,\n     case LEU:\n     case LTU:\n       if (TARGET_HAVE_MVE)\n-\t{\n-\t  rtx vpr_p0;\n-\t  if (vcond_mve)\n-\t    vpr_p0 = target;\n-\t  else\n-\t    vpr_p0 = gen_reg_rtx (arm_mode_to_pred_mode (cmp_mode));\n-\n-\t  emit_insn (gen_mve_vcmpq (swap_condition (code), cmp_mode, vpr_p0, force_reg (cmp_mode, op1), op0));\n-\t  if (!vcond_mve)\n-\t    {\n-\t      rtx zero = gen_reg_rtx (cmp_result_mode);\n-\t      rtx one = gen_reg_rtx (cmp_result_mode);\n-\t      emit_move_insn (zero, CONST0_RTX (cmp_result_mode));\n-\t      emit_move_insn (one, CONST1_RTX (cmp_result_mode));\n-\t      emit_insn (gen_mve_vpselq (VPSELQ_S, cmp_result_mode, target, one, zero, vpr_p0));\n-\t    }\n-\t}\n+\temit_insn (gen_mve_vcmpq (swap_condition (code), cmp_mode, target,\n+\t\t\t\t  force_reg (cmp_mode, op1), op0));\n       else\n \temit_insn (gen_neon_vc (swap_condition (code), cmp_mode,\n \t\t\t\ttarget, force_reg (cmp_mode, op1), op0));\n@@ -31275,8 +31231,8 @@ arm_expand_vector_compare (rtx target, rtx_code code, rtx op0, rtx op1,\n \trtx gt_res = gen_reg_rtx (cmp_result_mode);\n \trtx alt_res = gen_reg_rtx (cmp_result_mode);\n \trtx_code alt_code = (code == LTGT ? LT : LE);\n-\tif (arm_expand_vector_compare (gt_res, GT, op0, op1, true, vcond_mve)\n-\t    || arm_expand_vector_compare (alt_res, alt_code, op0, op1, true, vcond_mve))\n+\tif (arm_expand_vector_compare (gt_res, GT, op0, op1, true)\n+\t    || arm_expand_vector_compare (alt_res, alt_code, op0, op1, true))\n \t  gcc_unreachable ();\n \temit_insn (gen_rtx_SET (target, gen_rtx_IOR (cmp_result_mode,\n \t\t\t\t\t\t     gt_res, alt_res)));\n@@ -31296,40 +31252,36 @@ arm_expand_vcond (rtx *operands, machine_mode cmp_result_mode)\n {\n   /* When expanding for MVE, we do not want to emit a (useless) vpsel in\n      arm_expand_vector_compare, and another one here.  */\n-  bool vcond_mve=false;\n   rtx mask;\n \n   if (TARGET_HAVE_MVE)\n-    {\n-      vcond_mve=true;\n-      mask = gen_reg_rtx (arm_mode_to_pred_mode (cmp_result_mode));\n-    }\n+    mask = gen_reg_rtx (arm_mode_to_pred_mode (cmp_result_mode).require ());\n   else\n     mask = gen_reg_rtx (cmp_result_mode);\n \n   bool inverted = arm_expand_vector_compare (mask, GET_CODE (operands[3]),\n-\t\t\t\t\t     operands[4], operands[5], true, vcond_mve);\n+\t\t\t\t\t     operands[4], operands[5], true);\n   if (inverted)\n     std::swap (operands[1], operands[2]);\n   if (TARGET_NEON)\n   emit_insn (gen_neon_vbsl (GET_MODE (operands[0]), operands[0],\n \t\t\t    mask, operands[1], operands[2]));\n   else\n     {\n-      machine_mode cmp_mode = GET_MODE (operands[4]);\n-      rtx vpr_p0 = mask;\n-      rtx zero = gen_reg_rtx (cmp_mode);\n-      rtx one = gen_reg_rtx (cmp_mode);\n-      emit_move_insn (zero, CONST0_RTX (cmp_mode));\n-      emit_move_insn (one, CONST1_RTX (cmp_mode));\n+      machine_mode cmp_mode = GET_MODE (operands[0]);\n+\n       switch (GET_MODE_CLASS (cmp_mode))\n \t{\n \tcase MODE_VECTOR_INT:\n-\t  emit_insn (gen_mve_vpselq (VPSELQ_S, cmp_result_mode, operands[0], one, zero, vpr_p0));\n+\t  emit_insn (gen_mve_vpselq (VPSELQ_S, cmp_mode, operands[0],\n+\t\t\t\t     operands[1], operands[2], mask));\n \t  break;\n \tcase MODE_VECTOR_FLOAT:\n \t  if (TARGET_HAVE_MVE_FLOAT)\n-\t    emit_insn (gen_mve_vpselq_f (cmp_mode, operands[0], one, zero, vpr_p0));\n+\t    emit_insn (gen_mve_vpselq_f (cmp_mode, operands[0],\n+\t\t\t\t\t operands[1], operands[2], mask));\n+\t  else\n+\t    gcc_unreachable ();\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n@@ -34251,4 +34203,15 @@ arm_mode_base_reg_class (machine_mode mode)\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n+/* Implement TARGET_VECTORIZE_GET_MASK_MODE.  */\n+\n+opt_machine_mode\n+arm_get_mask_mode (machine_mode mode)\n+{\n+  if (TARGET_HAVE_MVE)\n+    return arm_mode_to_pred_mode (mode);\n+\n+  return default_get_mask_mode (mode);\n+}\n+\n #include \"gt-arm.h\""}, {"sha": "d0c3100a3ba28b51e50bcdf76b97b84406384923", "filename": "gcc/config/arm/mve.md", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Fconfig%2Farm%2Fmve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Fconfig%2Farm%2Fmve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fmve.md?ref=df0e57c2c032cea0f77f2e68231c035f282b26d6", "patch": "@@ -10527,3 +10527,54 @@\n       operands[1] = force_reg (<MODE>mode, operands[1]);\n   }\n )\n+\n+;; Expanders for vec_cmp and vcond\n+\n+(define_expand \"vec_cmp<mode><MVE_vpred>\"\n+  [(set (match_operand:<MVE_VPRED> 0 \"s_register_operand\")\n+\t(match_operator:<MVE_VPRED> 1 \"comparison_operator\"\n+\t  [(match_operand:MVE_VLD_ST 2 \"s_register_operand\")\n+\t   (match_operand:MVE_VLD_ST 3 \"reg_or_zero_operand\")]))]\n+  \"TARGET_HAVE_MVE\n+   && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n+{\n+  arm_expand_vector_compare (operands[0], GET_CODE (operands[1]),\n+\t\t\t     operands[2], operands[3], false);\n+  DONE;\n+})\n+\n+(define_expand \"vec_cmpu<mode><MVE_vpred>\"\n+  [(set (match_operand:<MVE_VPRED> 0 \"s_register_operand\")\n+\t(match_operator:<MVE_VPRED> 1 \"comparison_operator\"\n+\t  [(match_operand:MVE_2 2 \"s_register_operand\")\n+\t   (match_operand:MVE_2 3 \"reg_or_zero_operand\")]))]\n+  \"TARGET_HAVE_MVE\"\n+{\n+  arm_expand_vector_compare (operands[0], GET_CODE (operands[1]),\n+\t\t\t     operands[2], operands[3], false);\n+  DONE;\n+})\n+\n+(define_expand \"vcond_mask_<mode><MVE_vpred>\"\n+  [(set (match_operand:MVE_VLD_ST 0 \"s_register_operand\")\n+\t(if_then_else:MVE_VLD_ST\n+\t  (match_operand:<MVE_VPRED> 3 \"s_register_operand\")\n+\t  (match_operand:MVE_VLD_ST 1 \"s_register_operand\")\n+\t  (match_operand:MVE_VLD_ST 2 \"s_register_operand\")))]\n+  \"TARGET_HAVE_MVE\"\n+{\n+  switch (GET_MODE_CLASS (<MODE>mode))\n+    {\n+      case MODE_VECTOR_INT:\n+\temit_insn (gen_mve_vpselq (VPSELQ_S, <MODE>mode, operands[0],\n+\t\t\t\t   operands[1], operands[2], operands[3]));\n+\tbreak;\n+      case MODE_VECTOR_FLOAT:\n+\temit_insn (gen_mve_vpselq_f (<MODE>mode, operands[0],\n+\t\t\t\t     operands[1], operands[2], operands[3]));\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+    }\n+  DONE;\n+})"}, {"sha": "f270ded4978d3732c39c589054e524530ee84352", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=df0e57c2c032cea0f77f2e68231c035f282b26d6", "patch": "@@ -1394,6 +1394,45 @@\n   [(set_attr \"type\" \"neon_qsub<q>\")]\n )\n \n+(define_expand \"vec_cmp<mode><v_cmp_result>\"\n+  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\")\n+\t(match_operator:<V_cmp_result> 1 \"comparison_operator\"\n+\t  [(match_operand:VDQWH 2 \"s_register_operand\")\n+\t   (match_operand:VDQWH 3 \"reg_or_zero_operand\")]))]\n+  \"TARGET_NEON\n+   && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n+{\n+  arm_expand_vector_compare (operands[0], GET_CODE (operands[1]),\n+\t\t\t     operands[2], operands[3], false);\n+  DONE;\n+})\n+\n+(define_expand \"vec_cmpu<mode><mode>\"\n+  [(set (match_operand:VDQIW 0 \"s_register_operand\")\n+\t(match_operator:VDQIW 1 \"comparison_operator\"\n+\t  [(match_operand:VDQIW 2 \"s_register_operand\")\n+\t   (match_operand:VDQIW 3 \"reg_or_zero_operand\")]))]\n+  \"TARGET_NEON\"\n+{\n+  arm_expand_vector_compare (operands[0], GET_CODE (operands[1]),\n+\t\t\t     operands[2], operands[3], false);\n+  DONE;\n+})\n+\n+(define_expand \"vcond_mask_<mode><v_cmp_result>\"\n+  [(set (match_operand:VDQWH 0 \"s_register_operand\")\n+\t(if_then_else:VDQWH\n+\t  (match_operand:<V_cmp_result> 3 \"s_register_operand\")\n+\t  (match_operand:VDQWH 1 \"s_register_operand\")\n+\t  (match_operand:VDQWH 2 \"s_register_operand\")))]\n+  \"TARGET_NEON\n+   && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n+{\n+  emit_insn (gen_neon_vbsl<mode> (operands[0], operands[3], operands[1],\n+\t\t\t\t  operands[2]));\n+  DONE;\n+})\n+\n ;; Patterns for builtins.\n \n ; good for plain vadd, vaddq."}, {"sha": "f13009090af64d2ca1813a0bfd7c8d04259c6a4f", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=df0e57c2c032cea0f77f2e68231c035f282b26d6", "patch": "@@ -363,33 +363,6 @@\n     }\n })\n \n-(define_expand \"vec_cmp<mode><v_cmp_result>\"\n-  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\")\n-\t(match_operator:<V_cmp_result> 1 \"comparison_operator\"\n-\t  [(match_operand:VDQWH 2 \"s_register_operand\")\n-\t   (match_operand:VDQWH 3 \"reg_or_zero_operand\")]))]\n-  \"ARM_HAVE_<MODE>_ARITH\n-   && !TARGET_REALLY_IWMMXT\n-   && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n-{\n-  arm_expand_vector_compare (operands[0], GET_CODE (operands[1]),\n-\t\t\t     operands[2], operands[3], false, false);\n-  DONE;\n-})\n-\n-(define_expand \"vec_cmpu<mode><mode>\"\n-  [(set (match_operand:VDQIW 0 \"s_register_operand\")\n-\t(match_operator:VDQIW 1 \"comparison_operator\"\n-\t  [(match_operand:VDQIW 2 \"s_register_operand\")\n-\t   (match_operand:VDQIW 3 \"reg_or_zero_operand\")]))]\n-  \"ARM_HAVE_<MODE>_ARITH\n-   && !TARGET_REALLY_IWMMXT\"\n-{\n-  arm_expand_vector_compare (operands[0], GET_CODE (operands[1]),\n-\t\t\t     operands[2], operands[3], false, false);\n-  DONE;\n-})\n-\n ;; Conditional instructions.  These are comparisons with conditional moves for\n ;; vectors.  They perform the assignment:\n ;;\n@@ -461,31 +434,6 @@\n   DONE;\n })\n \n-(define_expand \"vcond_mask_<mode><v_cmp_result>\"\n-  [(set (match_operand:VDQWH 0 \"s_register_operand\")\n-        (if_then_else:VDQWH\n-          (match_operand:<V_cmp_result> 3 \"s_register_operand\")\n-          (match_operand:VDQWH 1 \"s_register_operand\")\n-          (match_operand:VDQWH 2 \"s_register_operand\")))]\n-  \"ARM_HAVE_<MODE>_ARITH\n-   && !TARGET_REALLY_IWMMXT\n-   && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n-{\n-  if (TARGET_NEON)\n-    {\n-      emit_insn (gen_neon_vbsl (<MODE>mode, operands[0], operands[3],\n-                                operands[1], operands[2]));\n-    }\n-  else if (TARGET_HAVE_MVE)\n-    {\n-      emit_insn (gen_mve_vpselq (VPSELQ_S, <MODE>mode, operands[0],\n-                                 operands[1], operands[2], operands[3]));\n-    }\n-  else\n-    gcc_unreachable ();\n-  DONE;\n-})\n-\n (define_expand \"vec_load_lanesoi<mode>\"\n   [(set (match_operand:OI 0 \"s_register_operand\")\n         (unspec:OI [(match_operand:OI 1 \"neon_struct_operand\")"}, {"sha": "613ac29967b30c545b2661d23ca997aca66e6e51", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=df0e57c2c032cea0f77f2e68231c035f282b26d6", "patch": "@@ -2236,6 +2236,10 @@ ARM target supports the @code{-mfloat-abi=softfp} option.\n @anchor{arm_hard_ok}\n ARM target supports the @code{-mfloat-abi=hard} option.\n \n+@item arm_mve\n+@anchor{arm_mve}\n+ARM target supports generating MVE instructions.\n+\n @item arm_v8_1_lob_ok\n @anchor{arm_v8_1_lob_ok}\n ARM Target supports executing the Armv8.1-M Mainline Low Overhead Loop"}, {"sha": "2f2dc448286e963b9a1bac9f4f84626baf4d0dde", "filename": "gcc/testsuite/gcc.dg/signbit-2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Ftestsuite%2Fgcc.dg%2Fsignbit-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Ftestsuite%2Fgcc.dg%2Fsignbit-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsignbit-2.c?ref=df0e57c2c032cea0f77f2e68231c035f282b26d6", "patch": "@@ -4,6 +4,7 @@\n /* This test does not work when the truth type does not match vector type.  */\n /* { dg-additional-options \"-mno-avx512f\" { target { i?86-*-* x86_64-*-* } } } */\n /* { dg-additional-options \"-march=armv8-a\" { target aarch64_sve } } */\n+/* { dg-skip-if \"no fallback for MVE\" { arm_mve } } */\n \n #include <stdint.h>\n "}, {"sha": "c2262b4d81e750141648d064e3863bbb8ef36933", "filename": "gcc/testsuite/gcc.target/arm/simd/pr100757-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fpr100757-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fpr100757-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fpr100757-2.c?ref=df0e57c2c032cea0f77f2e68231c035f282b26d6", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+/* { dg-additional-options \"-O3 -funsafe-math-optimizations\" } */\n+/* Derived from gcc.c-torture/compile/20160205-1.c.  */\n+\n+float a[32];\n+int fn1(int d) {\n+  int c = 4;\n+  for (int b = 0; b < 32; b++)\n+    if (a[b] != 2.0f)\n+      c = 5;\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\t.word\\t1073741824\\n} 4 } } */ /* Constant 2.0f.  */\n+/* { dg-final { scan-assembler-times {\\t.word\\t4\\n} 4 } } */ /* Initial value for c.  */\n+/* { dg-final { scan-assembler-times {\\t.word\\t5\\n} 4 } } */ /* Possible value for c.  */\n+/* { dg-final { scan-assembler-not {\\t.word\\t1\\n} } } */ /* 'true' mask.  */\n+/* { dg-final { scan-assembler-not {\\t.word\\t0\\n} } } */ /* 'false' mask.  */"}, {"sha": "e604555c04c9fa19f13d89b3747eb72f04fd2c9d", "filename": "gcc/testsuite/gcc.target/arm/simd/pr100757-3.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fpr100757-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fpr100757-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fpr100757-3.c?ref=df0e57c2c032cea0f77f2e68231c035f282b26d6", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+/* { dg-additional-options \"-O3 -funsafe-math-optimizations\" } */\n+/* Copied from gcc.c-torture/compile/20160205-1.c.  */\n+\n+float a[32];\n+float fn1(int d) {\n+  float c = 4.0f;\n+  for (int b = 0; b < 32; b++)\n+    if (a[b] != 2.0f)\n+      c = 5.0f;\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\t.word\\t1073741824\\n} 4 } } */ /* Constant 2.0f.  */\n+/* { dg-final { scan-assembler-times {\\t.word\\t1084227584\\n} 4 } } */ /* Initial value for c (4.0).  */\n+/* { dg-final { scan-assembler-times {\\t.word\\t1082130432\\n} 4 } } */ /* Possible value for c (5.0).  */\n+/* { dg-final { scan-assembler-not {\\t.word\\t1\\n} } } */ /* 'true' mask.  */\n+/* { dg-final { scan-assembler-not {\\t.word\\t0\\n} } } */ /* 'false' mask.  */"}, {"sha": "c12040c517f2c8de174a443f6b88df61ab1f9883", "filename": "gcc/testsuite/gcc.target/arm/simd/pr100757-4.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fpr100757-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fpr100757-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fpr100757-4.c?ref=df0e57c2c032cea0f77f2e68231c035f282b26d6", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+/* { dg-additional-options \"-O3\" } */\n+/* Derived from gcc.c-torture/compile/20160205-1.c.  */\n+\n+unsigned int a[32];\n+int fn1(int d) {\n+  int c = 2;\n+  for (int b = 0; b < 32; b++)\n+    if (a[b])\n+      c = 3;\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\t.word\\t0\\n} 4 } } */ /* 'false' mask.  */\n+/* { dg-final { scan-assembler-not {\\t.word\\t1\\n} } } */ /* 'true' mask.  */\n+/* { dg-final { scan-assembler-times {\\t.word\\t2\\n} 4 } } */ /* Initial value for c.  */\n+/* { dg-final { scan-assembler-times {\\t.word\\t3\\n} 4 } } */ /* Possible value for c.  */"}, {"sha": "41d6e4e2d7aa6715636c2abd908e5cb927d451a9", "filename": "gcc/testsuite/gcc.target/arm/simd/pr100757.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fpr100757.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fpr100757.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fpr100757.c?ref=df0e57c2c032cea0f77f2e68231c035f282b26d6", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+/* { dg-additional-options \"-O3\" } */\n+/* Derived from gcc.c-torture/compile/20160205-1.c.  */\n+\n+int a[32];\n+int fn1(int d) {\n+  int c = 2;\n+  for (int b = 0; b < 32; b++)\n+    if (a[b])\n+      c = 3;\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\t.word\\t0\\n} 4 } } */ /* 'false' mask.  */\n+/* { dg-final { scan-assembler-not {\\t.word\\t1\\n} } } */ /* 'true' mask.  */\n+/* { dg-final { scan-assembler-times {\\t.word\\t2\\n} 4 } } */ /* Initial value for c.  */\n+/* { dg-final { scan-assembler-times {\\t.word\\t3\\n} 4 } } */ /* Possible value for c.  */"}, {"sha": "737e1a8913b6dcfe201b9c0b48649d227bb8d3e6", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0e57c2c032cea0f77f2e68231c035f282b26d6/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=df0e57c2c032cea0f77f2e68231c035f282b26d6", "patch": "@@ -5235,6 +5235,18 @@ proc check_effective_target_arm_hard_ok { } {\n \t} \"-mfloat-abi=hard\"]\n }\n \n+# Return 1 if this is an ARM target supporting MVE.\n+proc check_effective_target_arm_mve { } {\n+    if { ![istarget arm*-*-*] } {\n+\treturn 0\n+    }\n+    return [check_no_compiler_messages arm_mve assembly {\n+\t#if !defined (__ARM_FEATURE_MVE)\n+\t#error FOO\n+\t#endif\n+    }]\n+}\n+\n # Return 1 if the target supports ARMv8.1-M MVE with floating point\n # instructions, 0 otherwise.  The test is valid for ARM.\n # Record the command line options needed."}]}