{"sha": "598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk4ZWFhYTJhMjM2OGJiN2Q1YWMzYmFmZTdhMGQxYmIyNmQ0M2Y2ZQ==", "commit": {"author": {"name": "Yuri Rumyantsev", "email": "ysrumyan@gmail.com", "date": "2016-11-16T16:22:39Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2016-11-16T16:22:39Z"}, "message": "Support non-masked epilogue vectoriziation\n\ngcc/\n\n2016-11-16  Yuri Rumyantsev  <ysrumyan@gmail.com>\n\n\t* params.def (PARAM_VECT_EPILOGUES_NOMASK): New.\n\t* tree-if-conv.c (tree_if_conversion): Make public.\n\t* * tree-if-conv.h: New file.\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependences) Avoid\n\tdynamic alias checks for epilogues.\n\t* tree-vect-loop-manip.c (vect_do_peeling): Return created epilog.\n\t* tree-vect-loop.c: include tree-if-conv.h.\n\t(new_loop_vec_info): Add zeroing orig_loop_info field.\n\t(vect_analyze_loop_2): Don't try to enhance alignment for epilogues.\n\t(vect_analyze_loop): Add argument ORIG_LOOP_INFO which is not NULL\n\tif epilogue is vectorized, set up orig_loop_info field of loop_vinfo\n\tusing passed argument.\n\t(vect_transform_loop): Check if created epilogue should be returned\n\tfor further vectorization with less vf.  If-convert epilogue if\n\trequired. Print vectorization success for epilogue.\n\t* tree-vectorizer.c (vectorize_loops): Add epilogue vectorization\n\tif it is required, pass loop_vinfo produced during vectorization of\n\tloop body to vect_analyze_loop.\n\t* tree-vectorizer.h (struct _loop_vec_info): Add new field\n\torig_loop_info.\n\t(LOOP_VINFO_ORIG_LOOP_INFO): New.\n\t(LOOP_VINFO_EPILOGUE_P): New.\n\t(LOOP_VINFO_ORIG_VECT_FACTOR): New.\n\t(vect_do_peeling): Change prototype to return epilogue.\n\t(vect_analyze_loop): Add argument of loop_vec_info type.\n\t(vect_transform_loop): Return created loop.\n\ngcc/testsuite/\n\n2016-11-16  Yuri Rumyantsev  <ysrumyan@gmail.com>\n\n\t* lib/target-supports.exp (check_avx2_hw_available): New.\n\t(check_effective_target_avx2_runtime): New.\n\t* gcc.dg/vect/vect-tail-nomask-1.c: New test.\n\nFrom-SVN: r242501", "tree": {"sha": "dc23b763501a2bee6d35f9e53240208b4bacc573", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc23b763501a2bee6d35f9e53240208b4bacc573"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/comments", "author": {"login": "ysrumyan", "id": 44425612, "node_id": "MDQ6VXNlcjQ0NDI1NjEy", "avatar_url": "https://avatars.githubusercontent.com/u/44425612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ysrumyan", "html_url": "https://github.com/ysrumyan", "followers_url": "https://api.github.com/users/ysrumyan/followers", "following_url": "https://api.github.com/users/ysrumyan/following{/other_user}", "gists_url": "https://api.github.com/users/ysrumyan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ysrumyan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ysrumyan/subscriptions", "organizations_url": "https://api.github.com/users/ysrumyan/orgs", "repos_url": "https://api.github.com/users/ysrumyan/repos", "events_url": "https://api.github.com/users/ysrumyan/events{/privacy}", "received_events_url": "https://api.github.com/users/ysrumyan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "03b85dcd4861611b49a7e7bf737246b6460b2295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b85dcd4861611b49a7e7bf737246b6460b2295", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03b85dcd4861611b49a7e7bf737246b6460b2295"}], "stats": {"total": 373, "additions": 340, "deletions": 33}, "files": [{"sha": "3a48f13122cea987b0ba96df1bae5088dd96a2d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e", "patch": "@@ -1,3 +1,32 @@\n+2016-11-16  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\t* params.def (PARAM_VECT_EPILOGUES_NOMASK): New.\n+\t* tree-if-conv.c (tree_if_conversion): Make public.\n+\t* * tree-if-conv.h: New file.\n+\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependences) Avoid\n+\tdynamic alias checks for epilogues.\n+\t* tree-vect-loop-manip.c (vect_do_peeling): Return created epilog.\n+\t* tree-vect-loop.c: include tree-if-conv.h.\n+\t(new_loop_vec_info): Add zeroing orig_loop_info field.\n+\t(vect_analyze_loop_2): Don't try to enhance alignment for epilogues.\n+\t(vect_analyze_loop): Add argument ORIG_LOOP_INFO which is not NULL\n+\tif epilogue is vectorized, set up orig_loop_info field of loop_vinfo\n+\tusing passed argument.\n+\t(vect_transform_loop): Check if created epilogue should be returned\n+\tfor further vectorization with less vf.  If-convert epilogue if\n+\trequired. Print vectorization success for epilogue.\n+\t* tree-vectorizer.c (vectorize_loops): Add epilogue vectorization\n+\tif it is required, pass loop_vinfo produced during vectorization of\n+\tloop body to vect_analyze_loop.\n+\t* tree-vectorizer.h (struct _loop_vec_info): Add new field\n+\torig_loop_info.\n+\t(LOOP_VINFO_ORIG_LOOP_INFO): New.\n+\t(LOOP_VINFO_EPILOGUE_P): New.\n+\t(LOOP_VINFO_ORIG_VECT_FACTOR): New.\n+\t(vect_do_peeling): Change prototype to return epilogue.\n+\t(vect_analyze_loop): Add argument of loop_vec_info type.\n+\t(vect_transform_loop): Return created loop.\n+\n 2016-11-16  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/rs6000.c (rs6000_components_for_bb): Mark the LR"}, {"sha": "50f75a728d2963e6d94451c73e3e3151efba48ef", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e", "patch": "@@ -1270,6 +1270,11 @@ DEFPARAM (PARAM_MAX_VRP_SWITCH_ASSERTIONS,\n \t  \"edge of a switch statement during VRP\",\n \t  10, 0, 0)\n \n+DEFPARAM (PARAM_VECT_EPILOGUES_NOMASK,\n+\t  \"vect-epilogues-nomask\",\n+\t  \"Enable loop epilogue vectorization using smaller vector size.\",\n+\t  0, 0, 1)\n+\n /*\n \n Local variables:"}, {"sha": "2d0367546959217b347f7e666a65ffd440ef6fef", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e", "patch": "@@ -1,3 +1,9 @@\n+2016-11-16  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\t* lib/target-supports.exp (check_avx2_hw_available): New.\n+\t(check_effective_target_avx2_runtime): New.\n+\t* gcc.dg/vect/vect-tail-nomask-1.c: New test.\n+\n 2016-11-16  Tamar Christina  <tamar.christina@arm.com>\n \n \tPR testsuite/78136"}, {"sha": "dc016bb47c2515b8e4fac6e5eaaeadb789adec3c", "filename": "gcc/testsuite/gcc.dg/vect/vect-tail-nomask-1.c", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-tail-nomask-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-tail-nomask-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-tail-nomask-1.c?ref=598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e", "patch": "@@ -0,0 +1,106 @@\n+/* { dg-do run } */\n+/* { dg-require-weak \"\" } */\n+/* { dg-additional-options \"--param vect-epilogues-nomask=1 -mavx2\" { target avx2_runtime } } */\n+\n+#define SIZE 1023\n+#define ALIGN 64\n+\n+extern int posix_memalign(void **memptr, __SIZE_TYPE__ alignment, __SIZE_TYPE__ size) __attribute__((weak));\n+extern void free (void *);\n+\n+void __attribute__((noinline))\n+test_citer (int * __restrict__ a,\n+\t    int * __restrict__ b,\n+\t    int * __restrict__ c)\n+{\n+  int i;\n+\n+  a = (int *)__builtin_assume_aligned (a, ALIGN);\n+  b = (int *)__builtin_assume_aligned (b, ALIGN);\n+  c = (int *)__builtin_assume_aligned (c, ALIGN);\n+\n+  for (i = 0; i < SIZE; i++)\n+    c[i] = a[i] + b[i];\n+}\n+\n+void __attribute__((noinline))\n+test_viter (int * __restrict__ a,\n+\t    int * __restrict__ b,\n+\t    int * __restrict__ c,\n+\t    int size)\n+{\n+  int i;\n+\n+  a = (int *)__builtin_assume_aligned (a, ALIGN);\n+  b = (int *)__builtin_assume_aligned (b, ALIGN);\n+  c = (int *)__builtin_assume_aligned (c, ALIGN);\n+\n+  for (i = 0; i < size; i++)\n+    c[i] = a[i] + b[i];\n+}\n+\n+void __attribute__((noinline))\n+init_data (int * __restrict__ a,\n+\t   int * __restrict__ b,\n+\t   int * __restrict__ c,\n+\t   int size)\n+{\n+  for (int i = 0; i < size; i++)\n+    {\n+      a[i] = i;\n+      b[i] = -i;\n+      c[i] = 0;\n+      asm volatile(\"\": : :\"memory\");\n+    }\n+  a[size] = b[size] = c[size] = size;\n+}\n+\n+\n+void __attribute__((noinline))\n+run_test ()\n+{\n+  int *a;\n+  int *b;\n+  int *c;\n+  int i;\n+\n+  if (posix_memalign ((void **)&a, ALIGN, (SIZE + 1) * sizeof (int)) != 0)\n+    return;\n+  if (posix_memalign ((void **)&b, ALIGN, (SIZE + 1) * sizeof (int)) != 0)\n+    return;\n+  if (posix_memalign ((void **)&c, ALIGN, (SIZE + 1) * sizeof (int)) != 0)\n+    return;\n+\n+  init_data (a, b, c, SIZE);\n+  test_citer (a, b, c);\n+  for (i = 0; i < SIZE; i++)\n+    if (c[i] != a[i] + b[i])\n+      __builtin_abort ();\n+  if (a[SIZE] != SIZE || b[SIZE] != SIZE || c[SIZE] != SIZE)\n+    __builtin_abort ();\n+\n+  init_data (a, b, c, SIZE);\n+  test_viter (a, b, c, SIZE);\n+  for (i = 0; i < SIZE; i++)\n+    if (c[i] != a[i] + b[i])\n+      __builtin_abort ();\n+  if (a[SIZE] != SIZE || b[SIZE] != SIZE || c[SIZE] != SIZE)\n+    __builtin_abort ();\n+\n+  free (a);\n+  free (b);\n+  free (c);\n+}\n+\n+int\n+main (int argc, const char **argv)\n+{\n+  if (!posix_memalign)\n+    return 0;\n+\n+  run_test ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" { target avx2_runtime } } } */\n+/* { dg-final { scan-tree-dump-times \"LOOP EPILOGUE VECTORIZED \\\\(VS=16\\\\)\" 2 \"vect\" { target avx2_runtime } } } */"}, {"sha": "e62b76887984687f62ddf9029bd13f52d786ea58", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e", "patch": "@@ -1730,6 +1730,36 @@ proc check_avx_hw_available { } {\n     }]\n }\n \n+# Return 1 if the target supports executing AVX2 instructions, 0\n+# otherwise.  Cache the result.\n+\n+proc check_avx2_hw_available { } {\n+    return [check_cached_effective_target avx2_hw_available {\n+\t# If this is not the right target then we can skip the test.\n+\tif { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {\n+\t    expr 0\n+\t} else {\n+\t    check_runtime_nocache avx2_hw_available {\n+\t\t#include \"cpuid.h\"\n+\t\tint main ()\n+\t\t{\n+\t\t  unsigned int eax, ebx, ecx, edx;\n+\t\t  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx)\n+\t\t      || ((ecx & bit_OSXSAVE) != bit_OSXSAVE))\n+\t\t    return 1;\n+\n+\t\t  if (__get_cpuid_max (0, NULL) < 7)\n+\t\t    return 1;\n+\n+\t\t  __cpuid_count (7, 0, eax, ebx, ecx, edx);\n+\n+\t\t  return (ebx & bit_AVX2) != bit_AVX2;\n+\t\t}\n+\t    } \"\"\n+\t}\n+    }]\n+}\n+\n # Return 1 if the target supports running SSE executables, 0 otherwise.\n \n proc check_effective_target_sse_runtime { } {\n@@ -1805,6 +1835,17 @@ proc check_effective_target_avx_runtime { } {\n     return 0\n }\n \n+# Return 1 if the target supports running AVX2 executables, 0 otherwise.\n+\n+proc check_effective_target_avx2_runtime { } {\n+    if { [check_effective_target_avx2]\n+\t && [check_avx2_hw_available]\n+\t && [check_avx_os_support_available] } {\n+\treturn 1\n+    }\n+    return 0\n+}\n+\n # Return 1 if we are compiling for 64-bit PowerPC but we do not use direct\n # move instructions for moves from GPR to FPR.\n "}, {"sha": "0b86ffebf7f27a461f12e2d6c91350734957b12b", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e", "patch": "@@ -2734,7 +2734,7 @@ ifcvt_local_dce (basic_block bb)\n    profitability analysis.  Returns non-zero todo flags when something\n    changed.  */\n \n-static unsigned int\n+unsigned int\n tree_if_conversion (struct loop *loop)\n {\n   unsigned int todo = 0;"}, {"sha": "3a732c25bc7f89d47d4b64bca316d6e0c58d6bde", "filename": "gcc/tree-if-conv.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftree-if-conv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftree-if-conv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.h?ref=598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e", "patch": "@@ -0,0 +1,24 @@\n+/* Copyright (C) 2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_IF_CONV_H\n+#define GCC_TREE_IF_CONV_H\n+\n+unsigned int tree_if_conversion (struct loop *);\n+\n+#endif  /* GCC_TREE_IF_CONV_H  */"}, {"sha": "5a303140833b711ee1c46564d85549f2ecdc9824", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e", "patch": "@@ -480,9 +480,15 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo, int *max_vf)\n \t\t\t\tLOOP_VINFO_LOOP_NEST (loop_vinfo), true))\n     return false;\n \n-  FOR_EACH_VEC_ELT (LOOP_VINFO_DDRS (loop_vinfo), i, ddr)\n-    if (vect_analyze_data_ref_dependence (ddr, loop_vinfo, max_vf))\n-      return false;\n+  /* For epilogues we either have no aliases or alias versioning\n+     was applied to original loop.  Therefore we may just get max_vf\n+     using VF of original loop.  */\n+  if (LOOP_VINFO_EPILOGUE_P (loop_vinfo))\n+    *max_vf = LOOP_VINFO_ORIG_VECT_FACTOR (loop_vinfo);\n+  else\n+    FOR_EACH_VEC_ELT (LOOP_VINFO_DDRS (loop_vinfo), i, ddr)\n+      if (vect_analyze_data_ref_dependence (ddr, loop_vinfo, max_vf))\n+\treturn false;\n \n   return true;\n }"}, {"sha": "e13d6a2758b9af86182a74a4d5c69f113fc20161", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e", "patch": "@@ -1614,11 +1614,13 @@ slpeel_update_phi_nodes_for_lcssa (struct loop *epilog)\n \n    Note this function peels prolog and epilog only if it's necessary,\n    as well as guards.\n+   Returns created epilogue or NULL.\n \n    TODO: Guard for prefer_scalar_loop should be emitted along with\n    versioning conditions if loop versioning is needed.  */\n \n-void\n+\n+struct loop *\n vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t\t tree *niters_vector, int th, bool check_profitability,\n \t\t bool niters_no_overflow)\n@@ -1634,15 +1636,15 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t\t\t || LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo));\n \n   if (!prolog_peeling && !epilog_peeling)\n-    return;\n+    return NULL;\n \n   prob_vector = 9 * REG_BR_PROB_BASE / 10;\n   if ((vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo)) == 2)\n     vf = 3;\n   prob_prolog = prob_epilog = (vf - 1) * REG_BR_PROB_BASE / vf;\n   vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n \n-  struct loop *prolog, *epilog, *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  struct loop *prolog, *epilog = NULL, *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   struct loop *first_loop = loop;\n   create_lcssa_for_virtual_phi (loop);\n   update_ssa (TODO_update_ssa_only_virtuals);\n@@ -1824,6 +1826,8 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n     }\n   adjust_vec.release ();\n   free_original_copy_tables ();\n+\n+  return epilog;\n }\n \n /* Function vect_create_cond_for_niters_checks."}, {"sha": "4150b0d9ee25cc04d674660c90d9d4c9d318f70a", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 83, "deletions": 19, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-fold.h\"\n #include \"cgraph.h\"\n #include \"tree-cfg.h\"\n+#include \"tree-if-conv.h\"\n \n /* Loop Vectorization Pass.\n \n@@ -1171,6 +1172,7 @@ new_loop_vec_info (struct loop *loop)\n   LOOP_VINFO_PEELING_FOR_GAPS (res) = false;\n   LOOP_VINFO_PEELING_FOR_NITER (res) = false;\n   LOOP_VINFO_OPERANDS_SWAPPED (res) = false;\n+  LOOP_VINFO_ORIG_LOOP_INFO (res) = NULL;\n \n   return res;\n }\n@@ -2046,15 +2048,20 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n   if (!ok)\n     return false;\n \n-  /* This pass will decide on using loop versioning and/or loop peeling in\n-     order to enhance the alignment of data references in the loop.  */\n-  ok = vect_enhance_data_refs_alignment (loop_vinfo);\n-  if (!ok)\n+  /* Do not invoke vect_enhance_data_refs_alignment for eplilogue\n+     vectorization.  */\n+  if (!LOOP_VINFO_EPILOGUE_P (loop_vinfo))\n     {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"bad data alignment.\\n\");\n-      return false;\n+    /* This pass will decide on using loop versioning and/or loop peeling in\n+       order to enhance the alignment of data references in the loop.  */\n+    ok = vect_enhance_data_refs_alignment (loop_vinfo);\n+    if (!ok)\n+      {\n+\tif (dump_enabled_p ())\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"bad data alignment.\\n\");\n+        return false;\n+      }\n     }\n \n   if (slp)\n@@ -2308,9 +2315,10 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \n    Apply a set of analyses on LOOP, and create a loop_vec_info struct\n    for it.  The different analyses will record information in the\n-   loop_vec_info struct.  */\n+   loop_vec_info struct.  If ORIG_LOOP_VINFO is not NULL epilogue must\n+   be vectorized.  */\n loop_vec_info\n-vect_analyze_loop (struct loop *loop)\n+vect_analyze_loop (struct loop *loop, loop_vec_info orig_loop_vinfo)\n {\n   loop_vec_info loop_vinfo;\n   unsigned int vector_sizes;\n@@ -2346,6 +2354,10 @@ vect_analyze_loop (struct loop *loop)\n \t}\n \n       bool fatal = false;\n+\n+      if (orig_loop_vinfo)\n+\tLOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = orig_loop_vinfo;\n+\n       if (vect_analyze_loop_2 (loop_vinfo, fatal))\n \t{\n \t  LOOP_VINFO_VECTORIZABLE_P (loop_vinfo) = 1;\n@@ -6696,12 +6708,14 @@ loop_niters_no_overflow (loop_vec_info loop_vinfo)\n \n    The analysis phase has determined that the loop is vectorizable.\n    Vectorize the loop - created vectorized stmts to replace the scalar\n-   stmts in the loop, and update the loop exit condition.  */\n+   stmts in the loop, and update the loop exit condition.\n+   Returns scalar epilogue loop if any.  */\n \n-void\n+struct loop *\n vect_transform_loop (loop_vec_info loop_vinfo)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  struct loop *epilogue = NULL;\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   int nbbs = loop->num_nodes;\n   int i;\n@@ -6780,8 +6794,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo) = niters;\n   tree nitersm1 = unshare_expr (LOOP_VINFO_NITERSM1 (loop_vinfo));\n   bool niters_no_overflow = loop_niters_no_overflow (loop_vinfo);\n-  vect_do_peeling (loop_vinfo, niters, nitersm1, &niters_vector, th,\n-\t\t   check_profitability, niters_no_overflow);\n+  epilogue = vect_do_peeling (loop_vinfo, niters, nitersm1, &niters_vector, th,\n+\t\t\t      check_profitability, niters_no_overflow);\n   if (niters_vector == NULL_TREE)\n     {\n       if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n@@ -7065,12 +7079,19 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n   if (dump_enabled_p ())\n     {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"LOOP VECTORIZED\\n\");\n-      if (loop->inner)\n+      if (!LOOP_VINFO_EPILOGUE_P (loop_vinfo))\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"LOOP VECTORIZED\\n\");\n+\t  if (loop->inner)\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"OUTER LOOP VECTORIZED\\n\");\n+\t  dump_printf (MSG_NOTE, \"\\n\");\n+\t}\n+      else\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"OUTER LOOP VECTORIZED\\n\");\n-      dump_printf (MSG_NOTE, \"\\n\");\n+\t\t\t \"LOOP EPILOGUE VECTORIZED (VS=%d)\\n\",\n+\t\t\t current_vector_size);\n     }\n \n   /* Free SLP instances here because otherwise stmt reference counting\n@@ -7082,6 +7103,49 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   /* Clear-up safelen field since its value is invalid after vectorization\n      since vectorized loop can have loop-carried dependencies.  */\n   loop->safelen = 0;\n+\n+  /* Don't vectorize epilogue for epilogue.  */\n+  if (LOOP_VINFO_EPILOGUE_P (loop_vinfo))\n+    epilogue = NULL;\n+\n+  if (epilogue)\n+    {\n+\tunsigned int vector_sizes\n+\t  = targetm.vectorize.autovectorize_vector_sizes ();\n+\tvector_sizes &= current_vector_size - 1;\n+\n+\tif (!PARAM_VALUE (PARAM_VECT_EPILOGUES_NOMASK))\n+\t  epilogue = NULL;\n+\telse if (!vector_sizes)\n+\t  epilogue = NULL;\n+\telse if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+\t\t && LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) >= 0)\n+\t  {\n+\t    int smallest_vec_size = 1 << ctz_hwi (vector_sizes);\n+\t    int ratio = current_vector_size / smallest_vec_size;\n+\t    int eiters = LOOP_VINFO_INT_NITERS (loop_vinfo)\n+\t      - LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n+\t    eiters = eiters % vf;\n+\n+\t    epilogue->nb_iterations_upper_bound = eiters - 1;\n+\n+\t    if (eiters < vf / ratio)\n+\t      epilogue = NULL;\n+\t    }\n+    }\n+\n+  if (epilogue)\n+    {\n+      epilogue->force_vectorize = loop->force_vectorize;\n+      epilogue->safelen = loop->safelen;\n+      epilogue->dont_vectorize = false;\n+\n+      /* We may need to if-convert epilogue to vectorize it.  */\n+      if (LOOP_VINFO_SCALAR_LOOP (loop_vinfo))\n+\ttree_if_conversion (epilogue);\n+    }\n+\n+  return epilogue;\n }\n \n /* The code below is trying to perform simple optimization - revert"}, {"sha": "35d7a3ee0c574170b38da65121164697e9991e05", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e", "patch": "@@ -514,6 +514,7 @@ vectorize_loops (void)\n   hash_table<simd_array_to_simduid> *simd_array_to_simduid_htab = NULL;\n   bool any_ifcvt_loops = false;\n   unsigned ret = 0;\n+  struct loop *new_loop;\n \n   vect_loops_num = number_of_loops (cfun);\n \n@@ -538,15 +539,16 @@ vectorize_loops (void)\n \t      && optimize_loop_nest_for_speed_p (loop))\n \t     || loop->force_vectorize)\n       {\n-\tloop_vec_info loop_vinfo;\n+\tloop_vec_info loop_vinfo, orig_loop_vinfo = NULL;\n+vectorize_epilogue:\n \tvect_location = find_loop_location (loop);\n         if (LOCATION_LOCUS (vect_location) != UNKNOWN_LOCATION\n \t    && dump_enabled_p ())\n \t  dump_printf (MSG_NOTE, \"\\nAnalyzing loop at %s:%d\\n\",\n                        LOCATION_FILE (vect_location),\n \t\t       LOCATION_LINE (vect_location));\n \n-\tloop_vinfo = vect_analyze_loop (loop);\n+\tloop_vinfo = vect_analyze_loop (loop, orig_loop_vinfo);\n \tloop->aux = loop_vinfo;\n \n \tif (!loop_vinfo || !LOOP_VINFO_VECTORIZABLE_P (loop_vinfo))\n@@ -580,7 +582,7 @@ vectorize_loops (void)\n \t    && dump_enabled_p ())\n           dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n                            \"loop vectorized\\n\");\n-\tvect_transform_loop (loop_vinfo);\n+\tnew_loop = vect_transform_loop (loop_vinfo);\n \tnum_vectorized_loops++;\n \t/* Now that the loop has been vectorized, allow it to be unrolled\n \t   etc.  */\n@@ -602,6 +604,15 @@ vectorize_loops (void)\n \t    fold_loop_vectorized_call (loop_vectorized_call, boolean_true_node);\n \t    ret |= TODO_cleanup_cfg;\n \t  }\n+\n+\tif (new_loop)\n+\t  {\n+\t    /* Epilogue of vectorized loop must be vectorized too.  */\n+\t    vect_loops_num = number_of_loops (cfun);\n+\t    loop = new_loop;\n+\t    orig_loop_vinfo = loop_vinfo;  /* To pass vect_analyze_loop.  */\n+\t    goto vectorize_epilogue;\n+\t  }\n       }\n \n   vect_location = UNKNOWN_LOCATION;"}, {"sha": "2a7fa0a33a28e675b5532ed0b723a42b14cbd308", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=598eaaa2a2368bb7d5ac3bafe7a0d1bb26d43f6e", "patch": "@@ -335,6 +335,10 @@ typedef struct _loop_vec_info : public vec_info {\n   /* Mark loops having masked stores.  */\n   bool has_mask_store;\n \n+  /* For loops being epilogues of already vectorized loops\n+     this points to the original vectorized loop.  Otherwise NULL.  */\n+  _loop_vec_info *orig_loop_info;\n+\n } *loop_vec_info;\n \n /* Access Functions.  */\n@@ -374,6 +378,7 @@ typedef struct _loop_vec_info : public vec_info {\n #define LOOP_VINFO_HAS_MASK_STORE(L)       (L)->has_mask_store\n #define LOOP_VINFO_SCALAR_ITERATION_COST(L) (L)->scalar_cost_vec\n #define LOOP_VINFO_SINGLE_SCALAR_ITERATION_COST(L) (L)->single_scalar_iteration_cost\n+#define LOOP_VINFO_ORIG_LOOP_INFO(L)       (L)->orig_loop_info\n \n #define LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT(L)\t\\\n   ((L)->may_misalign_stmts.length () > 0)\n@@ -389,6 +394,12 @@ typedef struct _loop_vec_info : public vec_info {\n #define LOOP_VINFO_NITERS_KNOWN_P(L)          \\\n   (tree_fits_shwi_p ((L)->num_iters) && tree_to_shwi ((L)->num_iters) > 0)\n \n+#define LOOP_VINFO_EPILOGUE_P(L) \\\n+  (LOOP_VINFO_ORIG_LOOP_INFO (L) != NULL)\n+\n+#define LOOP_VINFO_ORIG_VECT_FACTOR(L) \\\n+  (LOOP_VINFO_VECT_FACTOR (LOOP_VINFO_ORIG_LOOP_INFO (L)))\n+\n static inline loop_vec_info\n loop_vec_info_for_loop (struct loop *loop)\n {\n@@ -1032,8 +1043,8 @@ extern bool slpeel_can_duplicate_loop_p (const struct loop *, const_edge);\n struct loop *slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *,\n \t\t\t\t\t\t     struct loop *, edge);\n extern void vect_loop_versioning (loop_vec_info, unsigned int, bool);\n-extern void vect_do_peeling (loop_vec_info, tree, tree,\n-\t\t\t     tree *, int, bool, bool);\n+extern struct loop *vect_do_peeling (loop_vec_info, tree, tree,\n+\t\t\t\t     tree *, int, bool, bool);\n extern source_location find_loop_location (struct loop *);\n extern bool vect_can_advance_ivs_p (loop_vec_info);\n \n@@ -1144,11 +1155,11 @@ extern void destroy_loop_vec_info (loop_vec_info, bool);\n extern gimple *vect_force_simple_reduction (loop_vec_info, gimple *, bool,\n \t\t\t\t\t    bool *, bool);\n /* Drive for loop analysis stage.  */\n-extern loop_vec_info vect_analyze_loop (struct loop *);\n+extern loop_vec_info vect_analyze_loop (struct loop *, loop_vec_info);\n extern tree vect_build_loop_niters (loop_vec_info);\n extern void vect_gen_vector_loop_niters (loop_vec_info, tree, tree *, bool);\n /* Drive for loop transformation stage.  */\n-extern void vect_transform_loop (loop_vec_info);\n+extern struct loop *vect_transform_loop (loop_vec_info);\n extern loop_vec_info vect_analyze_loop_form (struct loop *);\n extern bool vectorizable_live_operation (gimple *, gimple_stmt_iterator *,\n \t\t\t\t\t slp_tree, int, gimple **);"}]}