{"sha": "79cf599406a6a51e2fdd47810fdba89e04cbf1cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzljZjU5OTQwNmE2YTUxZTJmZGQ0NzgxMGZkYmE4OWUwNGNiZjFjYw==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2006-01-18T20:02:42Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2006-01-18T20:02:42Z"}, "message": "c-pragma.c (handle_pragma_diagnostic): New.\n\n* c-pragma.c (handle_pragma_diagnostic): New.\n(init_pragma): Register it.\n* doc/extend.texi: Document it.\n\n* diagnostic.def: Add DK_UNSPECIFIED and DK_IGNORED.\n* diagnostic.h (diagnostic_classify_diagnostic): Declare.\n(diagnostic_context): Add classify_diagnostic[].\n* diagnostic.c (diagnostic_count_diagnostic): Don't count warnings\nas errors if they're overridden to DK_WARNING.\n(diagnostic_initialize): Initialize classify_diagnostic[].\n(diagnostic_set_kind_override): New.\n(diagnostic_report_diagnostic): Check for kind changes.\n* opts.c (common_handle_option): Take lang_mask.  Update callers.\nHandle OPT_Werror_.\n* common.opt (Werror=): New.\n* doc/invoke.texi: Document -Werror=*\n\nFrom-SVN: r109907", "tree": {"sha": "fc2b70d94a779eb0814d5f4a6c95145347b94e16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc2b70d94a779eb0814d5f4a6c95145347b94e16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79cf599406a6a51e2fdd47810fdba89e04cbf1cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79cf599406a6a51e2fdd47810fdba89e04cbf1cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79cf599406a6a51e2fdd47810fdba89e04cbf1cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/comments", "author": null, "committer": null, "parents": [{"sha": "f9fe7aed71e486669af301c0beb0c58bc303ee39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9fe7aed71e486669af301c0beb0c58bc303ee39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9fe7aed71e486669af301c0beb0c58bc303ee39"}], "stats": {"total": 265, "additions": 247, "deletions": 18}, "files": [{"sha": "cd3a907bda6253dedc867d9265519e6c45bb9e47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79cf599406a6a51e2fdd47810fdba89e04cbf1cc", "patch": "@@ -1,3 +1,22 @@\n+2006-01-18  DJ Delorie  <dj@redhat.com>\n+\n+\t* c-pragma.c (handle_pragma_diagnostic): New.\n+\t(init_pragma): Register it.\n+\t* doc/extend.texi: Document it.\n+\n+\t* diagnostic.def: Add DK_UNSPECIFIED and DK_IGNORED.\n+\t* diagnostic.h (diagnostic_classify_diagnostic): Declare.\n+\t(diagnostic_context): Add classify_diagnostic[].\n+\t* diagnostic.c (diagnostic_count_diagnostic): Don't count warnings\n+\tas errors if they're overridden to DK_WARNING.\n+\t(diagnostic_initialize): Initialize classify_diagnostic[].\n+\t(diagnostic_set_kind_override): New.\n+\t(diagnostic_report_diagnostic): Check for kind changes.\n+\t* opts.c (common_handle_option): Take lang_mask.  Update callers.\n+\tHandle OPT_Werror_.\n+\t* common.opt (Werror=): New.\n+\t* doc/invoke.texi: Document -Werror=*\n+\n 2006-01-18  Jeff Law  <law@redhat.com>\n \n \t* tree-vrp.c (test_for_singularity): Correct test for new\n@@ -640,7 +659,7 @@\n \t* basic-block.h: Remove the prototype for\n \tpartition_hot_cold_basic_blocks.\n \n-2006-01-16  Rafael \ufffd\u00c1vila de Esp\ufffd\u00c1\ufffdndola <rafael.espindola@gmail.com>\n+2006-01-16  Rafael \ufffd\ufffd\u00c1vila de Esp\ufffd\ufffd\u00c1\ufffd\ufffdndola <rafael.espindola@gmail.com>\n \n \t* cppspec.c (lang_specific_spec_functions): remove\n \t* gcc.c (lookup_spec_function): use static_spec_functions directelly"}, {"sha": "5256758d94b72c37eb244e4e0d27a14a90d9e782", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 53, "deletions": 3, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=79cf599406a6a51e2fdd47810fdba89e04cbf1cc", "patch": "@@ -1,6 +1,6 @@\n /* Handle #pragma, system V.4 style.  Supports #pragma weak and #pragma pack.\n-   Copyright (C) 1992, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n+   2006 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -36,7 +36,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tm_p.h\"\n #include \"vec.h\"\n #include \"target.h\"\n-\n+#include \"diagnostic.h\"\n+#include \"opts.h\"\n \n #define GCC_BAD(gmsgid) \\\n   do { warning (OPT_Wpragmas, gmsgid); return; } while (0)\n@@ -668,6 +669,53 @@ handle_pragma_visibility (cpp_reader *dummy ATTRIBUTE_UNUSED)\n \n #endif\n \n+static void\n+handle_pragma_diagnostic(cpp_reader *ARG_UNUSED(dummy))\n+{\n+  const char *kind_string, *option_string;\n+  unsigned int option_index;\n+  enum cpp_ttype token;\n+  diagnostic_t kind;\n+  tree x;\n+\n+  if (cfun)\n+    {\n+      error (\"#pragma GCC diagnostic not allowed inside functions\");\n+      return;\n+    }\n+\n+  token = pragma_lex (&x);\n+  if (token != CPP_NAME)\n+    GCC_BAD (\"missing [error|warning|ignored] after %<#pragma GCC diagnostic%>\");\n+  kind_string = IDENTIFIER_POINTER (x);\n+  if (strcmp (kind_string, \"error\") == 0)\n+    kind = DK_ERROR;\n+  else if (strcmp (kind_string, \"warning\") == 0)\n+    kind = DK_WARNING;\n+  else if (strcmp (kind_string, \"ignored\") == 0)\n+    kind = DK_IGNORED;\n+  else\n+    GCC_BAD (\"expected [error|warning|ignored] after %<#pragma GCC diagnostic%>\");\n+\n+  token = pragma_lex (&x);\n+  if (token != CPP_STRING)\n+    GCC_BAD (\"missing option after %<#pragma GCC diagnostic%> kind\");\n+  option_string = TREE_STRING_POINTER (x);\n+  for (option_index = 0; option_index < cl_options_count; option_index++)\n+    if (strcmp (cl_options[option_index].opt_text, option_string) == 0)\n+      {\n+\t/* This overrides -Werror, for example.  */\n+\tdiagnostic_classify_diagnostic (global_dc, option_index, kind);\n+\t/* This makes sure the option is enabled, like -Wfoo would do.  */\n+\tif (cl_options[option_index].var_type == CLVC_BOOLEAN\n+\t    && cl_options[option_index].flag_var\n+\t    && kind != DK_IGNORED)\n+\t    *(int *) cl_options[option_index].flag_var = 1;\n+\treturn;\n+      }\n+  GCC_BAD (\"unknown option after %<#pragma GCC diagnostic%> kind\");\n+}\n+\n /* A vector of registered pragma callbacks.  */\n \n DEF_VEC_O (pragma_handler);\n@@ -767,6 +815,8 @@ init_pragma (void)\n   c_register_pragma (\"GCC\", \"visibility\", handle_pragma_visibility);\n #endif\n \n+  c_register_pragma (\"GCC\", \"diagnostic\", handle_pragma_diagnostic);\n+\n   c_register_pragma (0, \"redefine_extname\", handle_pragma_redefine_extname);\n   c_register_pragma (0, \"extern_prefix\", handle_pragma_extern_prefix);\n "}, {"sha": "d16b9977c93a91a966bd9c66e4ccf0c55f5c352a", "filename": "gcc/common.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=79cf599406a6a51e2fdd47810fdba89e04cbf1cc", "patch": "@@ -1,6 +1,6 @@\n ; Options for the language- and target-independent parts of the compiler.\n \n-; Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n+; Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n ;\n ; This file is part of GCC.\n ;\n@@ -81,6 +81,10 @@ Werror\n Common Var(warnings_are_errors)\n Treat all warnings as errors\n \n+Werror=\n+Common Joined\n+Treat specified warning as error\n+\n Wextra\n Common\n Print extra (possibly unwanted) warnings"}, {"sha": "48ba2968f3b83a42d1d1746bd65961fb5d35ead6", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=79cf599406a6a51e2fdd47810fdba89e04cbf1cc", "patch": "@@ -1,5 +1,5 @@\n /* Language-independent diagnostic subroutines for the GNU Compiler Collection\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n    Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@codesourcery.com>\n \n@@ -61,6 +61,7 @@ static void real_abort (void) ATTRIBUTE_NORETURN;\n /* A diagnostic_context surrogate for stderr.  */\n static diagnostic_context global_diagnostic_context;\n diagnostic_context *global_dc = &global_diagnostic_context;\n+\n \f\n /* Return a malloc'd string containing MSG formatted a la printf.  The\n    caller is responsible for freeing the memory.  */\n@@ -102,6 +103,8 @@ diagnostic_initialize (diagnostic_context *context)\n   memset (context->diagnostic_count, 0, sizeof context->diagnostic_count);\n   context->issue_warnings_are_errors_message = true;\n   context->warning_as_error_requested = false;\n+  memset (context->classify_diagnostic, DK_UNSPECIFIED,\n+\t  sizeof context->classify_diagnostic);\n   context->show_option_requested = false;\n   context->abort_on_error = false;\n   context->internal_error = NULL;\n@@ -202,7 +205,12 @@ diagnostic_count_diagnostic (diagnostic_context *context,\n       if (!diagnostic_report_warnings_p ())\n         return false;\n \n-      if (!context->warning_as_error_requested)\n+      /* -Werror can reclassify warnings as errors, but\n+\t classify_diagnostic can reclassify it back to a warning.  The\n+\t second part of this test detects that case.  */\n+      if (!context->warning_as_error_requested\n+\t  || (context->classify_diagnostic[diagnostic->option_index]\n+\t      == DK_WARNING))\n         {\n           ++diagnostic_kind_count (context, DK_WARNING);\n           break;\n@@ -324,6 +332,26 @@ default_diagnostic_finalizer (diagnostic_context *context,\n   pp_destroy_prefix (context->printer);\n }\n \n+/* Interface to specify diagnostic kind overrides.  Returns the\n+   previous setting, or DK_UNSPECIFIED if the parameters are out of\n+   range.  */\n+diagnostic_t\n+diagnostic_classify_diagnostic (diagnostic_context *context,\n+\t\t\t\tint option_index,\n+\t\t\t\tdiagnostic_t new_kind)\n+{\n+  diagnostic_t old_kind;\n+\n+  if (option_index <= 0\n+      || option_index >= N_OPTS\n+      || new_kind >= DK_LAST_DIAGNOSTIC_KIND)\n+    return DK_UNSPECIFIED;\n+\n+  old_kind = context->classify_diagnostic[option_index];\n+  context->classify_diagnostic[option_index] = new_kind;\n+  return old_kind;\n+}\n+\n /* Report a diagnostic message (an error or a warning) as specified by\n    DC.  This function is *the* subroutine in terms of which front-ends\n    should implement their specific diagnostic handling modules.  The\n@@ -345,9 +373,21 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n \terror_recursion (context);\n     }\n \n-  if (diagnostic->option_index\n-      && ! option_enabled (diagnostic->option_index))\n-    return;\n+  if (diagnostic->option_index)\n+    {\n+      /* This tests if the user provided the appropriate -Wfoo or\n+\t -Wno-foo option.  */\n+      if (! option_enabled (diagnostic->option_index))\n+\treturn;\n+      /* This tests if the user provided the appropriate -Werror=foo\n+\t option.  */\n+      if (context->classify_diagnostic[diagnostic->option_index] != DK_UNSPECIFIED)\n+\tdiagnostic->kind = context->classify_diagnostic[diagnostic->option_index];\n+      /* This allows for future extenions, like temporarily disabling\n+\t warnings for ranges of source code.  */\n+      if (diagnostic->kind == DK_IGNORED)\n+\treturn;\n+    }\n \n   context->lock++;\n "}, {"sha": "bbdba2f1aa266518bdd1558793741e7bcebf994b", "filename": "gcc/diagnostic.def", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2Fdiagnostic.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2Fdiagnostic.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.def?ref=79cf599406a6a51e2fdd47810fdba89e04cbf1cc", "patch": "@@ -1,3 +1,17 @@\n+/* DK_UNSPECIFIED must be first so it has a value of zero.  We never\n+   assign this kind to an actual diagnostic, we only use this in\n+   variables that can hold a kind, to mean they have yet to have a\n+   kind specified.  I.e. they're uninitialized.  Within the diagnostic\n+   machinery, this kind also means \"don't change the existing kind\",\n+   meaning \"no change is specified\".  */\n+DEFINE_DIAGNOSTIC_KIND (DK_UNSPECIFIED, \"\")\n+\n+/* If a diagnostic is set to DK_IGNORED, it won't get reported at all.\n+   This is used by the diagnostic machinery when it wants to disable a\n+   diagnostic without disabling the option which causes it.  */\n+DEFINE_DIAGNOSTIC_KIND (DK_IGNORED, \"\")\n+\n+/* The remainder are real diagnostic types.  */\n DEFINE_DIAGNOSTIC_KIND (DK_FATAL, \"fatal error: \")\n DEFINE_DIAGNOSTIC_KIND (DK_ICE, \"internal compiler error: \")\n DEFINE_DIAGNOSTIC_KIND (DK_ERROR, \"error: \")"}, {"sha": "51493ea8bab5bcd2df739446edba81a70a966817", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=79cf599406a6a51e2fdd47810fdba89e04cbf1cc", "patch": "@@ -1,5 +1,5 @@\n /* Various declarations for language-independent diagnostics subroutines.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n    Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@codesourcery.com>\n \n@@ -73,6 +73,13 @@ struct diagnostic_context\n   /* True if it has been requested that warnings be treated as errors.  */\n   bool warning_as_error_requested;\n \n+  /* For each option index that can be passed to warning() et all\n+     (OPT_* from options.h), this array may contain a new kind that\n+     the diagnostic should be changed to before reporting, or\n+     DK_UNSPECIFIED to leave it as the reported kind, or DK_IGNORED to\n+     not report it at all.  N_OPTS is from <options.h>.  */\n+  char classify_diagnostic[N_OPTS];\n+\n   /* True if we should print the command line option which controls\n      each diagnostic, if known.  */\n   bool show_option_requested;\n@@ -179,6 +186,11 @@ extern diagnostic_context *global_dc;\n extern void diagnostic_initialize (diagnostic_context *);\n extern void diagnostic_report_current_module (diagnostic_context *);\n extern void diagnostic_report_current_function (diagnostic_context *);\n+\n+/* Force diagnostics controlled by OPTIDX to be kind KIND.  */\n+extern diagnostic_t diagnostic_classify_diagnostic (diagnostic_context *,\n+\t\t\t\t\t\t    int /* optidx */,\n+\t\t\t\t\t\t    diagnostic_t /* kind */);\n extern void diagnostic_report_diagnostic (diagnostic_context *,\n \t\t\t\t\t  diagnostic_info *);\n #ifdef ATTRIBUTE_GCC_DIAG"}, {"sha": "9d5a8f6076fc1db74c59ae77859a6d4dc0efbea3", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=79cf599406a6a51e2fdd47810fdba89e04cbf1cc", "patch": "@@ -1,5 +1,5 @@\n @c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1996, 1998, 1999, 2000,\n-@c 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+@c 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n \n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n@@ -9290,6 +9290,7 @@ for further explanation.\n * Symbol-Renaming Pragmas::\n * Structure-Packing Pragmas::\n * Weak Pragmas::\n+* Diagnostic Pragmas::\n @end menu\n \n @node ARM Pragmas\n@@ -9530,6 +9531,51 @@ It is an error if @var{symbol2} is not defined in the current\n translation unit.\n @end table\n \n+@node Diagnostic Pragmas\n+@subsection Diagnostic Pragmas\n+\n+GCC allows the user to selectively enable or disable certain types of\n+diagnostics, and change the kind of the diagnostic.  For example, a\n+project's policy might require that all sources compile with\n+@option{-Werror} but certain files might have exceptions allowing\n+specific types of warnings.  Or, a project might selectively enable\n+diagnostics and treat them as errors depending on which preprocessor\n+macros are defined.\n+\n+@table @code\n+@item #pragma GCC diagnostic @var{kind} @var{option}\n+@cindex pragma, diagnostic\n+\n+Modifies the disposition of a diagnostic.  Note that not all\n+diagnostics are modifyiable; at the moment only warnings (normally\n+controlled by @samp{-W...}) can be controlled, and not all of them.\n+Use @option{-fdiagnostics-show-option} to determine which diagnostics\n+are controllable and which option controls them.\n+\n+@var{kind} is @samp{error} to treat this diagnostic as an error,\n+@samp{warning} to treat it like a warning (even if @option{-Werror} is\n+in effect), or @samp{ignored} if the diagnostic is to be ignored.\n+@var{option} is a double quoted string which matches the command line\n+option.\n+\n+@example\n+#pragma GCC diagnostic warning \"-Wformat\"\n+#pragma GCC diagnostic error \"-Walways-true\"\n+#pragma GCC diagnostic ignored \"-Walways-true\"\n+@end example\n+\n+Note that these pragmas override any command line options.  Also,\n+while it is syntactically valid to put these pragmas anywhere in your\n+sources, the only supported location for them is before any data or\n+functions are defined.  Doing otherwise may result in unpredictable\n+results depending on how the optimizer manages your sources.  If the\n+same option is listed multiple times, the last one specified is the\n+one that is in effect.  This pragma is not intended to be a general\n+purpose replacement for command line options, but for implementing\n+strict control over project policies.\n+\n+@end table\n+\n @node Unnamed Fields\n @section Unnamed struct/union fields within structs/unions\n @cindex struct"}, {"sha": "924c121502e2d483ef708b393425a0af92fdd66e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=79cf599406a6a51e2fdd47810fdba89e04cbf1cc", "patch": "@@ -1,5 +1,5 @@\n @c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-@c 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+@c 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -226,7 +226,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wc++-compat -Wcast-align  -Wcast-qual  -Wchar-subscripts  -Wcomment @gol\n -Wconversion  -Wno-deprecated-declarations @gol\n -Wdisabled-optimization  -Wno-div-by-zero  -Wno-endif-labels @gol\n--Werror  -Werror-implicit-function-declaration @gol\n+-Werror  -Werror-* -Werror-implicit-function-declaration @gol\n -Wfatal-errors  -Wfloat-equal  -Wformat  -Wformat=2 @gol\n -Wno-format-extra-args -Wformat-nonliteral @gol\n -Wformat-security  -Wformat-y2k @gol\n@@ -3411,6 +3411,22 @@ This option is only supported for C and Objective-C@.\n @opindex Werror\n Make all warnings into errors.\n \n+@item -Werror=\n+@opindex Werror=\n+Make the specified warning into an errors.  The specifier for a\n+warning is appended, for example @option{-Werror=switch} turns the\n+warnings controlled by @option{-Wswitch} into errors.  This switch\n+takes a negative form, to be used to negate @option{-Werror} for\n+specific warnings, for example @option{-Wno-error=switch} makes\n+@option{-Wswitch} warnings not be errors, even when @option{-Werror}\n+is in effect.  You can use the @option{-fdiagnostics-show-option}\n+option to have each controllable warning amended with the option which\n+controls it, to determine what to use with this option.\n+\n+Note that specifying @option{-Werror=}@var{foo} automatically implies\n+@option{-W}@var{foo}.  However, @option{-Wno-error=}@var{foo} does not\n+imply anything.\n+\n @item -Wstack-protector\n @opindex Wstack-protector\n This option is only active when @option{-fstack-protector} is active.  It"}, {"sha": "36880862f67efcab9db4032156b2bfd59af2af69", "filename": "gcc/opts.c", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cf599406a6a51e2fdd47810fdba89e04cbf1cc/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=79cf599406a6a51e2fdd47810fdba89e04cbf1cc", "patch": "@@ -1,5 +1,5 @@\n /* Command line option handling.\n-   Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n    Contributed by Neil Booth.\n \n This file is part of GCC.\n@@ -102,7 +102,8 @@ const char **in_fnames;\n unsigned num_in_fnames;\n \n static size_t find_opt (const char *, int);\n-static int common_handle_option (size_t scode, const char *arg, int value);\n+static int common_handle_option (size_t scode, const char *arg, int value,\n+\t\t\t\t unsigned int lang_mask);\n static void handle_param (const char *);\n static void set_Wextra (int);\n static unsigned int handle_option (const char **argv, unsigned int lang_mask);\n@@ -405,7 +406,7 @@ handle_option (const char **argv, unsigned int lang_mask)\n       result = 0;\n \n   if (result && (option->flags & CL_COMMON))\n-    if (common_handle_option (opt_index, arg, value) == 0)\n+    if (common_handle_option (opt_index, arg, value, lang_mask) == 0)\n       result = 0;\n \n   if (result && (option->flags & CL_TARGET))\n@@ -719,7 +720,8 @@ decode_options (unsigned int argc, const char **argv)\n    VALUE assigned to a variable, it happens automatically.  */\n \n static int\n-common_handle_option (size_t scode, const char *arg, int value)\n+common_handle_option (size_t scode, const char *arg, int value,\n+\t\t      unsigned int lang_mask)\n {\n   enum opt_code code = (enum opt_code) scode;\n \n@@ -759,6 +761,32 @@ common_handle_option (size_t scode, const char *arg, int value)\n       set_Wextra (value);\n       break;\n \n+    case OPT_Werror_:\n+      {\n+\tchar *new_option;\n+\tint option_index;\n+\tnew_option = (char *) xmalloc (strlen (arg) + 2);\n+\tnew_option[0] = 'W';\n+\tstrcpy (new_option+1, arg);\n+\toption_index = find_opt (new_option, lang_mask);\n+\tif (option_index == N_OPTS)\n+\t  {\n+\t    error(\"-Werror-%s: No option -%s\", arg, new_option);\n+\t  }\n+\telse\n+\t  {\n+\t    int kind = value ? DK_ERROR : DK_WARNING;\n+\t    diagnostic_classify_diagnostic (global_dc, option_index, kind);\n+\n+\t    /* -Werror=foo implies -Wfoo.  */\n+\t    if (cl_options[option_index].var_type == CLVC_BOOLEAN\n+\t\t&& cl_options[option_index].flag_var\n+\t\t&& kind == DK_ERROR)\n+\t      *(int *) cl_options[option_index].flag_var = 1;\n+\t  }\n+      }\n+      break;\n+\n     case OPT_Wextra:\n       set_Wextra (value);\n       break;"}]}