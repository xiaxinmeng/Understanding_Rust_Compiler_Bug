{"sha": "dc65cd609e046633b7e665ace8072aa2d70788f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM2NWNkNjA5ZTA0NjYzM2I3ZTY2NWFjZTgwNzJhYTJkNzA3ODhmNw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-11-19T06:55:04Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-11-19T06:55:04Z"}, "message": "* cppfiles.c: Fix formatting.\n\nFrom-SVN: r59245", "tree": {"sha": "e95537e36c9bb3f14c63e3d7c67cd90deef672e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e95537e36c9bb3f14c63e3d7c67cd90deef672e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc65cd609e046633b7e665ace8072aa2d70788f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc65cd609e046633b7e665ace8072aa2d70788f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc65cd609e046633b7e665ace8072aa2d70788f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc65cd609e046633b7e665ace8072aa2d70788f7/comments", "author": null, "committer": null, "parents": [{"sha": "f3226a90019efdcdd3f1be3ef4fe19ff7f8d7f23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3226a90019efdcdd3f1be3ef4fe19ff7f8d7f23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3226a90019efdcdd3f1be3ef4fe19ff7f8d7f23"}], "stats": {"total": 31, "additions": 16, "deletions": 15}, "files": [{"sha": "64fb1cfe0a90f06a79030509f87f00e247822720", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc65cd609e046633b7e665ace8072aa2d70788f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc65cd609e046633b7e665ace8072aa2d70788f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc65cd609e046633b7e665ace8072aa2d70788f7", "patch": "@@ -1,3 +1,7 @@\n+2002-11-19  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* cppfiles.c: Fix formatting.\n+\n 2002-11-19  Jason Thorpe  <thorpej@wasabisystems.com>\n \n \t* gcc.c (The Specs Language): Document spec functions."}, {"sha": "e7281c5d7a6a7f631e0fc39cb7c18f1a88ff64a4", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc65cd609e046633b7e665ace8072aa2d70788f7/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc65cd609e046633b7e665ace8072aa2d70788f7/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=dc65cd609e046633b7e665ace8072aa2d70788f7", "patch": "@@ -77,8 +77,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #undef strcmp\n \n /* This structure is used for the table of all includes.  */\n-struct include_file\n-{\n+struct include_file {\n   const char *name;\t\t/* actual path name of file */\n   const cpp_hashnode *cmacro;\t/* macro, if any, preventing reinclusion.  */\n   const struct search_path *foundhere;\n@@ -106,7 +105,7 @@ struct include_file\n    included again.  If it's NEVER_REREAD, the file is never to be\n    included again.  Otherwise it is a macro hashnode, and the file is\n    to be included again if the macro is defined.  */\n-#define NEVER_REREAD ((const cpp_hashnode *)-1)\n+#define NEVER_REREAD ((const cpp_hashnode *) -1)\n #define DO_NOT_REREAD(inc) \\\n ((inc)->cmacro && ((inc)->cmacro == NEVER_REREAD \\\n \t\t   || (inc)->cmacro->type == NT_MACRO))\n@@ -168,7 +167,7 @@ static void\n destroy_node (v)\n      splay_tree_value v;\n {\n-  struct include_file *f = (struct include_file *)v;\n+  struct include_file *f = (struct include_file *) v;\n \n   if (f)\n     {\n@@ -416,7 +415,7 @@ read_include_file (pfile, inc)\n       if (SHOULD_MMAP (size, pagesize))\n \t{\n \t  buf = (uchar *) mmap (0, size, PROT_READ, MAP_PRIVATE, inc->fd, 0);\n-\t  if (buf == (uchar *)-1)\n+\t  if (buf == (uchar *) -1)\n \t    goto perror_fail;\n \t  inc->mapped = 1;\n \t}\n@@ -642,7 +641,7 @@ report_missing_guard (n, b)\n      void *b;\n {\n   struct include_file *f = (struct include_file *) n->value;\n-  int *bannerp = (int *)b;\n+  int *bannerp = (int *) b;\n \n   if (f && f->cmacro == 0 && f->include_count == 1)\n     {\n@@ -668,7 +667,7 @@ handle_missing_header (pfile, fname, angle_brackets)\n {\n   bool print_dep\n     = CPP_OPTION (pfile, deps.style) > (angle_brackets || pfile->map->sysp);\n- \n+\n   if (CPP_OPTION (pfile, deps.missing_files) && print_dep)\n     deps_add_dep (pfile->deps, fname);\n   /* If -M was specified, then don't count this as an error, because\n@@ -830,8 +829,7 @@ search_from (pfile, type)\n    such as DOS.  The format of the file name map file is just a series\n    of lines with two tokens on each line.  The first token is the name\n    to map, and the second token is the actual name to use.  */\n-struct file_name_map\n-{\n+struct file_name_map {\n   struct file_name_map *map_next;\n   char *map_from;\n   char *map_to;\n@@ -851,10 +849,10 @@ read_filename_string (ch, f)\n \n   len = 20;\n   set = alloc = xmalloc (len + 1);\n-  if (! is_space(ch))\n+  if (! is_space (ch))\n     {\n       *set++ = ch;\n-      while ((ch = getc (f)) != EOF && ! is_space(ch))\n+      while ((ch = getc (f)) != EOF && ! is_space (ch))\n \t{\n \t  if (set - alloc == len)\n \t    {\n@@ -871,8 +869,7 @@ read_filename_string (ch, f)\n }\n \n /* This structure holds a linked list of file name maps, one per directory.  */\n-struct file_name_map_list\n-{\n+struct file_name_map_list {\n   struct file_name_map_list *map_list_next;\n   char *map_list_name;\n   struct file_name_map *map_list_map;\n@@ -918,10 +915,10 @@ read_name_map (pfile, dirname)\n \t  char *from, *to;\n \t  struct file_name_map *ptr;\n \n-\t  if (is_space(ch))\n+\t  if (is_space (ch))\n \t    continue;\n \t  from = read_filename_string (ch, f);\n-\t  while ((ch = getc (f)) != EOF && is_hspace(ch))\n+\t  while ((ch = getc (f)) != EOF && is_hspace (ch))\n \t    ;\n \t  to = read_filename_string (ch, f);\n "}]}