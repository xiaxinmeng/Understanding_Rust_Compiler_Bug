{"sha": "244e5a2c23e5477e26f1970afb1fa0772b2cc808", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ0ZTVhMmMyM2U1NDc3ZTI2ZjE5NzBhZmIxZmEwNzcyYjJjYzgwOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-08-13T10:24:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-08-13T10:24:46Z"}, "message": "[multiple changes]\n\n2004-08-13  Olivier Hainque  <hainque@act-europe.fr>\n\n\t* decl.c (gnat_to_gnu_entity) <E_Variable>: When building an allocator\n\tfor a global aliased object with a variable size and an unconstrained\n\tnominal subtype, pretend there is no initializer if the one we have is\n\tincomplete, and avoid referencing an inexistant component in there. The\n\tpart we have will be rebuilt anyway and the reference may confuse\n\tfurther operations.\n\n2004-08-13  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* einfo.ads: Minor reformatting\n\n\t* lib-writ.adb (Output_Main_Program_Line): Do not set parameter\n\trestrictions in the ALI if we only want to warn about violations.\n\n2004-08-13  Vincent Celier  <celier@gnat.com>\n\n\t* ali.adb (Scan_ALI): Initialize component Body_Needed_For_SAL to False\n\twhen creating a new Unit_Record in table Units.\n\n\t* gnatls.adb (Output_Unit): In verbose mode, output the restrictions\n\tthat are violated, if any.\n\n\t* prj-nmsc.adb (Ada_Check.Get_Path_Names_And_Record_Sources): Do not\n\tadd directory separator if path already ends with a directory separator.\n\n2004-08-13  Ed Schonberg  <schonberg@gnat.com>\n\n\t* rtsfind.adb (Entity_Not_Defined): If the error ocurrs in a predefined\n\tunit, this is an attempt to inline a construct that is not available in\n\tthe current restricted mode, so abort rather than trying to continue.\n\n\t* sem_ch3.adb (Build_Underlying_Full_View): If the new type has\n\tdiscriminants that rename those of the parent, recover names of\n\toriginal discriminants for the constraint on the full view of the\n\tparent.\n\t(Complete_Private_Subtype): Do not create a subtype declaration if the\n\tsubtype is an itype.\n\n\t* gnat_rm.texi: Added section on implementation of discriminated\n\trecords with default values for discriminants.\n\n2004-08-13  Ed Schonberg  <schonberg@gnat.com>\n\n\tPR ada/15601\n\t* sem_res.adb (Make_Call_Into_Operator): Handle properly the case where\n\tthe second operand is overloaded.\n\nFrom-SVN: r85934", "tree": {"sha": "c7c2be77cbb0fac9968fa1b4ce500bd59db9d31d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7c2be77cbb0fac9968fa1b4ce500bd59db9d31d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/244e5a2c23e5477e26f1970afb1fa0772b2cc808", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/244e5a2c23e5477e26f1970afb1fa0772b2cc808", "html_url": "https://github.com/Rust-GCC/gccrs/commit/244e5a2c23e5477e26f1970afb1fa0772b2cc808", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/244e5a2c23e5477e26f1970afb1fa0772b2cc808/comments", "author": null, "committer": null, "parents": [{"sha": "47d2cee50d64825872e97186da5a683dcabb5943", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47d2cee50d64825872e97186da5a683dcabb5943", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47d2cee50d64825872e97186da5a683dcabb5943"}], "stats": {"total": 617, "additions": 412, "deletions": 205}, "files": [{"sha": "2819c7b00527fcc92bcac145006102963572f270", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=244e5a2c23e5477e26f1970afb1fa0772b2cc808", "patch": "@@ -1,3 +1,52 @@\n+2004-08-13  Olivier Hainque  <hainque@act-europe.fr>\n+\n+\t* decl.c (gnat_to_gnu_entity) <E_Variable>: When building an allocator\n+\tfor a global aliased object with a variable size and an unconstrained\n+\tnominal subtype, pretend there is no initializer if the one we have is\n+\tincomplete, and avoid referencing an inexistant component in there. The\n+\tpart we have will be rebuilt anyway and the reference may confuse\n+\tfurther operations.\n+\n+2004-08-13  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* einfo.ads: Minor reformatting\n+\n+\t* lib-writ.adb (Output_Main_Program_Line): Do not set parameter\n+\trestrictions in the ALI if we only want to warn about violations.\n+\n+2004-08-13  Vincent Celier  <celier@gnat.com>\n+\n+\t* ali.adb (Scan_ALI): Initialize component Body_Needed_For_SAL to False\n+\twhen creating a new Unit_Record in table Units.\n+\n+\t* gnatls.adb (Output_Unit): In verbose mode, output the restrictions\n+\tthat are violated, if any.\n+\n+\t* prj-nmsc.adb (Ada_Check.Get_Path_Names_And_Record_Sources): Do not\n+\tadd directory separator if path already ends with a directory separator.\n+\n+2004-08-13  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* rtsfind.adb (Entity_Not_Defined): If the error ocurrs in a predefined\n+\tunit, this is an attempt to inline a construct that is not available in\n+\tthe current restricted mode, so abort rather than trying to continue.\n+\n+\t* sem_ch3.adb (Build_Underlying_Full_View): If the new type has\n+\tdiscriminants that rename those of the parent, recover names of\n+\toriginal discriminants for the constraint on the full view of the\n+\tparent.\n+\t(Complete_Private_Subtype): Do not create a subtype declaration if the\n+\tsubtype is an itype.\n+\n+\t* gnat_rm.texi: Added section on implementation of discriminated\n+\trecords with default values for discriminants.\n+\n+2004-08-13  Ed Schonberg  <schonberg@gnat.com>\n+\n+\tPR ada/15601\n+\t* sem_res.adb (Make_Call_Into_Operator): Handle properly the case where\n+\tthe second operand is overloaded.\n+\n 2004-08-10  Richard Henderson  <rth@redhat.com>\n \n \t* utils.c (gnat_install_builtins): Remove __builtin_stack_alloc,"}, {"sha": "3326ecaafad8acc6e945c497d8981dfca503f3d9", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=244e5a2c23e5477e26f1970afb1fa0772b2cc808", "patch": "@@ -1173,6 +1173,7 @@ package body ALI is\n          Units.Table (Units.Last).First_Arg       := First_Arg;\n          Units.Table (Units.Last).Elab_Position   := 0;\n          Units.Table (Units.Last).Interface       := ALIs.Table (Id).Interface;\n+         Units.Table (Units.Last).Body_Needed_For_SAL := False;\n \n          if Debug_Flag_U then\n             Write_Str (\" ----> reading unit \");"}, {"sha": "a3a70002706f28c0565f5a6408d56eccbb99d0e4", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=244e5a2c23e5477e26f1970afb1fa0772b2cc808", "patch": "@@ -922,11 +922,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    used_by_ref = true;\n \t    const_flag = true;\n \n-\t    /* Get the data part of GNU_EXPR in case this was a\n-\t       aliased object whose nominal subtype is unconstrained.\n-\t       In that case the pointer above will be a thin pointer and\n-\t       build_allocator will automatically make the template and\n-\t       constructor already made above.  */\n+\t    /* In case this was a aliased object whose nominal subtype is\n+\t       unconstrained, the pointer above will be a thin pointer and\n+\t       build_allocator will automatically make the template.\n+\n+\t       If we have a template initializer only (that we made above),\n+\t       pretend there is none and rely on what build_allocator creates\n+\t       again anyway.  Otherwise (if we have a full initializer), get\n+\t       the data part and feed that to build_allocator.  */\n \n \t    if (definition)\n \t      {\n@@ -937,11 +940,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  {\n \t\t    gnu_alloc_type\n \t\t      = TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_alloc_type)));\n-\t\t    gnu_expr\n-\t\t      = build_component_ref\n-\t\t\t(gnu_expr, NULL_TREE,\n-\t\t\t TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (gnu_expr))),\n-\t\t\t false);\n+\n+                   if (TREE_CODE (gnu_expr) == CONSTRUCTOR\n+                       &&\n+                       TREE_CHAIN (CONSTRUCTOR_ELTS (gnu_expr)) == NULL_TREE)\n+                     gnu_expr = 0;\n+                   else\n+                     gnu_expr\n+                       = build_component_ref\n+                         (gnu_expr, NULL_TREE,\n+                          TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (gnu_expr))),\n+\t\t\t  false);\n \t\t  }\n \n \t\tif (TREE_CODE (TYPE_SIZE_UNIT (gnu_alloc_type)) == INTEGER_CST"}, {"sha": "2b467419e1e72d3a1c9cc195af02043e70c7cf81", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=244e5a2c23e5477e26f1970afb1fa0772b2cc808", "patch": "@@ -3088,7 +3088,7 @@ package Einfo is\n --       Present in private subtypes that are the completion of other private\n --       types, or in private types that are derived from private subtypes.\n --       If the full view of a private type T is derived from another\n---       private type  with discriminants Td, the full view of T is also\n+--       private type with discriminants Td, the full view of T is also\n --       private, and there is no way to attach to it a further full view that\n --       would convey the structure of T to the back end. The Underlying_Full_\n --       View is an attribute of the full view that is a subtype of Td with"}, {"sha": "82c390ab34fd1f5f2a395c9ac9f6a8bcb8671ffb", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=244e5a2c23e5477e26f1970afb1fa0772b2cc808", "patch": "@@ -380,6 +380,7 @@ Implementation of Specific Ada Features\n * GNAT Implementation of Tasking::\n * GNAT Implementation of Shared Passive Packages::\n * Code Generation for Array Aggregates::\n+* The Size of Discriminated Records with Default Discriminants::\n \n Project File Reference\n \n@@ -12798,6 +12799,7 @@ facilities.\n * GNAT Implementation of Tasking::\n * GNAT Implementation of Shared Passive Packages::\n * Code Generation for Array Aggregates::\n+* The Size of Discriminated Records with Default Discriminants::\n @end menu\n \n @node Machine Code Insertions\n@@ -13342,6 +13344,98 @@ If any of these conditions are violated, the aggregate will be built in\n a temporary (created either by the front-end or the code generator) and then\n that temporary will be copied onto the target.\n \n+\n+@node The Size of Discriminated Records with Default Discriminants\n+@section The Size of Discriminated Records with Default Discriminants\n+\n+@noindent\n+If a discriminated type @code{T} has discriminants with default values, it is\n+possible to declare an object of this type without providing an explicit\n+constraint:\n+\n+@smallexample @c ada\n+@group\n+type Size is range 1..100;\n+\n+type Rec (D : Size := 15) is record\n+   Name : String (1..D);\n+end T;\n+\n+Word : Rec;\n+@end group\n+@end smallexample\n+\n+@noindent \n+Such an object is said to be @emph{unconstrained}.\n+The discriminant of the object\n+can be modified by a full assignment to the object, as long as it preserves the\n+relation between the value of the discriminant, and the value of the components\n+that depend on it:\n+\n+@smallexample @c ada\n+@group\n+Word := (3, \"yes\");\n+\n+Word := (5, \"maybe\");\n+\n+Word := (5, \"no\"); -- raises Constraint_Error\n+@end group\n+@end smallexample\n+\n+@noindent\n+In order to support this behavior efficiently, an unconstrained object is\n+given the maximum size that any value of the type requires. In the case\n+above, @code{Word} has storage for the discriminant and for\n+a @code{String} of length 100.\n+It is important to note that unconstrained objects do not require dynamic\n+allocation. It would be an improper implementation to place on the heap those\n+components whose size depends on discriminants. (This improper implementation\n+was used by some Ada83 compilers, where the @code{Name} component above\n+would have\n+been stored as a pointer to a dynamic string). Following the principle that\n+dynamic storage management should never be introduced implicitly,\n+an Ada95 compiler should reserve the full size for an unconstrained declared\n+object, and place it on the stack.\n+\n+This maximum size approach\n+has been a source of surprise to some users, who expect the default\n+values of the discriminants to determine the size reserved for an\n+unconstrained object: ``If the default is 15, why should the object occupy\n+a larger size?''\n+The answer, of course, is that the discriminant may be later modified,\n+and its full range of values must be taken into account. This is why the\n+declaration:\n+\n+@smallexample\n+@group\n+type Rec (D : Positive := 15) is record\n+   Name : String (1..D);\n+end record;\n+\n+Too_Large : Rec;\n+@end group\n+@end smallexample\n+\n+@noindent\n+is flagged by the compiler with a warning:\n+an attempt to create @code{Too_Large} will raise @code{Storage_Error},\n+because the required size includes @code{Positive'Last}\n+bytes. As the first example indicates, the proper approach is to declare an\n+index type of ``reasonable'' range so that unconstrained objects are not too\n+large.\n+\n+One final wrinkle: if the object is declared to be @code{aliased}, or if it is\n+created in the heap by means of an allocator, then it is @emph{not}\n+unconstrained:\n+it is constrained by the default values of the discriminants, and those values\n+cannot be modified by full assignment. This is because in the presence of\n+aliasing all views of the object (which may be manipulated by different tasks,\n+say) must be consistent, so it is imperative that the object, once created,\n+remain invariant.\n+\n+\n+\n+\n @node Project File Reference\n @chapter Project File Reference\n "}, {"sha": "5c269916371c5d911dd5af8a3325593f502d91f9", "filename": "gcc/ada/gnatls.adb", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Fgnatls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Fgnatls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatls.adb?ref=244e5a2c23e5477e26f1970afb1fa0772b2cc808", "patch": "@@ -513,9 +513,11 @@ procedure Gnatls is\n \n          else\n             Write_Str (\"Unit => \");\n-            Write_Eol; Write_Str (\"     Name   => \");\n+            Write_Eol;\n+            Write_Str (\"     Name   => \");\n             Write_Str (Name_Buffer (1 .. Name_Len));\n-            Write_Eol; Write_Str (\"     Kind   => \");\n+            Write_Eol;\n+            Write_Str (\"     Kind   => \");\n \n             if Units.Table (U_Id).Unit_Kind = 'p' then\n                Write_Str (\"package \");\n@@ -547,7 +549,8 @@ procedure Gnatls is\n                U.Body_Needed_For_SAL or\n                U.Elaborate_Body\n             then\n-               Write_Eol; Write_Str (\"     Flags  =>\");\n+               Write_Eol;\n+               Write_Str (\"     Flags  =>\");\n \n                if U.Preelab then\n                   Write_Str (\" Preelaborable\");\n@@ -631,7 +634,8 @@ procedure Gnatls is\n                --  Display these restrictions.\n \n                if Restrictions.Set /= (All_Restrictions => False) then\n-                  Write_Eol; Write_Str (\"     Restrictions  =>\");\n+                  Write_Eol;\n+                  Write_Str (\"     pragma Restrictions  =>\");\n \n                   --  For boolean restrictions, just display the name of the\n                   --  restriction; for valued restrictions, also display the\n@@ -650,12 +654,45 @@ procedure Gnatls is\n                      end if;\n                   end loop;\n                end if;\n+\n+               --  If the unit violates some Restrictions, display the list of\n+               --  these restrictions.\n+\n+               if Restrictions.Violated /= (All_Restrictions => False) then\n+                  Write_Eol;\n+                  Write_Str (\"     Restrictions violated =>\");\n+\n+                  --  For boolean restrictions, just display the name of the\n+                  --  restriction; for valued restrictions, also display the\n+                  --  restriction value.\n+\n+                  for Restriction in All_Restrictions loop\n+                     if Restrictions.Violated (Restriction) then\n+                        Write_Eol;\n+                        Write_Str (\"       \");\n+                        Write_Str (Image (Restriction));\n+\n+                        if Restriction in All_Parameter_Restrictions then\n+                           if Restrictions.Count (Restriction) > 0 then\n+                              Write_Str (\" =>\");\n+\n+                              if Restrictions.Unknown (Restriction) then\n+                                 Write_Str (\" at least\");\n+                              end if;\n+\n+                              Write_Str (Restrictions.Count (Restriction)'Img);\n+                           end if;\n+                        end if;\n+                     end if;\n+                  end loop;\n+               end if;\n             end;\n          end if;\n \n          if Print_Source then\n             if Too_Long then\n-               Write_Eol; Write_Str (\"   \");\n+               Write_Eol;\n+               Write_Str (\"   \");\n             else\n                Write_Str (Spaces (Unit_Start + Name_Len + 1 .. Unit_End));\n             end if;"}, {"sha": "89b4e23b21030282e6198354577864d117c5b0df", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=244e5a2c23e5477e26f1970afb1fa0772b2cc808", "patch": "@@ -958,7 +958,9 @@ package body Lib.Writ is\n       --  And now the information for the parameter restrictions\n \n       for RP in All_Parameter_Restrictions loop\n-         if Main_Restrictions.Set (RP) then\n+         if Main_Restrictions.Set (RP)\n+           and then not Restriction_Warnings (RP)\n+         then\n             Write_Info_Char ('r');\n             Write_Info_Nat (Nat (Main_Restrictions.Value (RP)));\n          else"}, {"sha": "c3193b8098ee5dc7c4617e3d59c34e5f8a7f14f7", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 115, "deletions": 160, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=244e5a2c23e5477e26f1970afb1fa0772b2cc808", "patch": "@@ -29,7 +29,6 @@ with Fmap;     use Fmap;\n with Hostparm;\n with MLib.Tgt;\n with Namet;    use Namet;\n-with Opt;      use Opt;\n with Osint;    use Osint;\n with Output;   use Output;\n with MLib.Tgt; use MLib.Tgt;\n@@ -238,19 +237,15 @@ package body Prj.Nmsc is\n    --  a spec suffix, a body suffix or a separate suffix.\n \n    procedure Locate_Directory\n-     (Name     : Name_Id;\n-      Parent   : Name_Id;\n-      Dir      : out Name_Id;\n-      Display  : out Name_Id;\n-      Project  : Project_Id := No_Project;\n-      Kind     : String := \"\";\n-      Location : Source_Ptr := No_Location);\n-   --  Locate a directory. Dir is the canonical path name. Display is the\n-   --  path name for display purpose.\n-   --  When the directory does not exist, Setup_Projects is True and Kind is\n-   --  not the empty string, an attempt is made to create the directory.\n-   --  Returns No_Name in Dir and Display if directory does not exist or\n-   --  cannot be created.\n+     (Name    : Name_Id;\n+      Parent  : Name_Id;\n+      Dir     : out Name_Id;\n+      Display : out Name_Id);\n+   --  Locate a directory (returns No_Name for Dir and Display if directory\n+   --  does not exist). Name is the directory name. Parent is the root\n+   --  directory, if Name is a relative path name. Dir is the canonical case\n+   --  path name of the directory, Display is the directory path name for\n+   --  display purposes.\n \n    function Path_Name_Of\n      (File_Name : Name_Id;\n@@ -386,7 +381,11 @@ package body Prj.Nmsc is\n                      Source_Names.Set (Canonical_Name, NL);\n                      Name_Len := Dir_Path'Length;\n                      Name_Buffer (1 .. Name_Len) := Dir_Path;\n-                     Add_Char_To_Name_Buffer (Directory_Separator);\n+\n+                     if Name_Buffer (Name_Len) /= Directory_Separator then\n+                        Add_Char_To_Name_Buffer (Directory_Separator);\n+                     end if;\n+\n                      Add_Str_To_Name_Buffer (Name_Str (1 .. Last));\n                      Path := Name_Find;\n \n@@ -1113,8 +1112,7 @@ package body Prj.Nmsc is\n                --  the object directory or one of the source directories.\n                --  This is the directory where copies of the interface\n                --  sources will be copied. Note that this directory may be\n-               --  the library directory. If setting up projects (gnat setup)\n-               --  and the directory does not exist, attempt to create it.\n+               --  the library directory.\n \n                if Lib_Src_Dir.Value /= Empty_String then\n                   declare\n@@ -1124,18 +1122,11 @@ package body Prj.Nmsc is\n                      Locate_Directory\n                        (Dir_Id, Data.Display_Directory,\n                         Data.Library_Src_Dir,\n-                        Data.Display_Library_Src_Dir,\n-                        Project  => Project,\n-                        Kind     => \"library interface copy\",\n-                        Location => Lib_Src_Dir.Location);\n+                        Data.Display_Library_Src_Dir);\n \n-                     --  If directory does not exist, report an error. No need\n-                     --  to do that if Setup_Projects is True, as an error\n-                     --  has already been reported by Locate_Directory.\n+                     --  If directory does not exist, report an error\n \n-                     if not Setup_Projects\n-                       and then Data.Library_Src_Dir = No_Name\n-                     then\n+                     if Data.Library_Src_Dir = No_Name then\n \n                         --  Get the absolute name of the library directory\n                         --  that does not exist, to report an error.\n@@ -2526,17 +2517,15 @@ package body Prj.Nmsc is\n       end if;\n \n       if For_Language = Lang_Ada then\n-\n-         --  If we have looked for sources and found none, then it is an\n-         --  error, except if it is an extending project. If a non-extending\n-         --  project is not supposed to contain any source, then we never\n-         --  Find_Sources. No error is signalled when setting up projects\n-         --  using gnat setup.\n+         --  If we have looked for sources and found none, then\n+         --  it is an error, except if it is an extending project.\n+         --  If a non extending project is not supposed to contain\n+         --  any source, then we never call Find_Sources.\n \n          if Current_Source /= Nil_String then\n             Data.Ada_Sources_Present := True;\n \n-         elsif not Setup_Projects and then Data.Extends = No_Project then\n+         elsif Data.Extends = No_Project then\n             Error_Msg\n               (Project,\n                \"there are no Ada sources in this project\",\n@@ -3306,30 +3295,26 @@ package body Prj.Nmsc is\n                   Object_Dir.Location);\n \n             else\n-               --  Check that the specified object directory does exist, and\n-               --  attempt to create it if setting up projects (gnat setup).\n+               --  We check that the specified object directory\n+               --  does exist.\n \n                Locate_Directory\n                  (Object_Dir.Value, Data.Display_Directory,\n-                  Data.Object_Directory, Data.Display_Object_Dir,\n-                  Project  => Project, Kind => \"object\",\n-                  Location => Object_Dir.Location);\n+                  Data.Object_Directory, Data.Display_Object_Dir);\n \n-               if not Setup_Projects\n-                 and then Data.Object_Directory = No_Name\n-               then\n+               if Data.Object_Directory = No_Name then\n                   --  The object directory does not exist, report an error\n-\n                   Err_Vars.Error_Msg_Name_1 := Object_Dir.Value;\n                   Error_Msg\n                     (Project,\n                      \"the object directory { cannot be found\",\n                      Data.Location);\n \n                   --  Do not keep a nil Object_Directory. Set it to the\n-                  --  specified (relative or absolute) path. This is for the\n-                  --  benefit of tools that recover from errors. For example,\n-                  --  these tools could create the non-existent directory.\n+                  --  specified (relative or absolute) path.\n+                  --  This is for the benefit of tools that recover from\n+                  --  errors; for example, these tools could create the\n+                  --  non existent directory.\n \n                   Data.Display_Object_Dir := Object_Dir.Value;\n                   Get_Name_String (Object_Dir.Value);\n@@ -3376,18 +3361,14 @@ package body Prj.Nmsc is\n                   Exec_Dir.Location);\n \n             else\n-               --  We check that the specified exec directory does exist and\n-               --  attempt to create it if setting up projects (gnat setup).\n+               --  We check that the specified object directory\n+               --  does exist.\n \n                Locate_Directory\n                  (Exec_Dir.Value, Data.Directory,\n-                  Data.Exec_Directory, Data.Display_Exec_Dir,\n-                  Project  => Project, Kind => \"exec\",\n-                  Location => Exec_Dir.Location);\n+                  Data.Exec_Directory, Data.Display_Exec_Dir);\n \n-               if not Setup_Projects\n-                 and then Data.Exec_Directory = No_Name\n-               then\n+               if Data.Exec_Directory = No_Name then\n                   Err_Vars.Error_Msg_Name_1 := Exec_Dir.Value;\n                   Error_Msg\n                     (Project,\n@@ -3447,10 +3428,10 @@ package body Prj.Nmsc is\n \n          elsif Source_Dirs.Values = Nil_String then\n \n-            --  If Source_Dirs is an empty string list, this means that this\n-            --  contains no sources. For projects that do not extend other\n-            --  projects, this also means that there is no need for an object\n-            --  directory unless one is specified explicitly.\n+            --  If Source_Dirs is an empty string list, this means\n+            --  that this project contains no source. For projects that\n+            --  don't extend other projects, this also means that there is no\n+            --  need for an object directory, if not specified.\n \n             if Data.Extends = No_Project\n               and then  Data.Object_Directory = Data.Directory\n@@ -3531,8 +3512,8 @@ package body Prj.Nmsc is\n \n             begin\n                --  If the project extended is a library project, we inherit\n-               --  the library name, if it is not redefined, we check that\n-               --  the library directory is specified, and we reset the\n+               --  the library name, if it is not redefined; we check that\n+               --  the library directory is specified; and we reset the\n                --  library flag for the extended project.\n \n                if Extended_Data.Library then\n@@ -3579,16 +3560,13 @@ package body Prj.Nmsc is\n             end if;\n \n          else\n-            --  Find path name, check that it is a directory, and attempt\n-            --  to create it if setting up projects (gnat setup).\n+            --  Find path name, check that it is a directory\n \n             Locate_Directory\n               (Lib_Dir.Value, Data.Display_Directory,\n-               Data.Library_Dir, Data.Display_Library_Dir,\n-               Project => Project, Kind => \"library\",\n-               Location => Lib_Dir.Location);\n+               Data.Library_Dir, Data.Display_Library_Dir);\n \n-            if not Setup_Projects and then Data.Library_Dir = No_Name then\n+            if Data.Library_Dir = No_Name then\n \n                --  Get the absolute name of the library directory that\n                --  does not exist, to report an error.\n@@ -3773,35 +3751,36 @@ package body Prj.Nmsc is\n             --  Check Spec_Suffix\n \n             declare\n-               Spec_Suffixes : Array_Element_Id :=\n-                                 Util.Value_Of\n-                                   (Name_Spec_Suffix,\n-                                    Naming.Decl.Arrays);\n+               Spec_Suffixs : Array_Element_Id :=\n+                                Util.Value_Of\n+                                  (Name_Spec_Suffix,\n+                                   Naming.Decl.Arrays);\n                Suffix  : Array_Element_Id;\n                Element : Array_Element;\n                Suffix2 : Array_Element_Id;\n \n             begin\n-               --  If some suffixes have been specified, we make sure that\n+               --  If some suffixs have been specified, we make sure that\n                --  for each language for which a default suffix has been\n                --  specified, there is a suffix specified, either the one\n                --  in the project file or if there were none, the default.\n \n-               if Spec_Suffixes /= No_Array_Element then\n+               if Spec_Suffixs /= No_Array_Element then\n                   Suffix := Data.Naming.Spec_Suffix;\n \n                   while Suffix /= No_Array_Element loop\n                      Element := Array_Elements.Table (Suffix);\n-                     Suffix2 := Spec_Suffixes;\n+                     Suffix2 := Spec_Suffixs;\n \n                      while Suffix2 /= No_Array_Element loop\n                         exit when Array_Elements.Table (Suffix2).Index =\n                           Element.Index;\n                         Suffix2 := Array_Elements.Table (Suffix2).Next;\n                      end loop;\n \n-                     --  There is a registered default suffix, but no suffix is\n-                     --  specified in the project file. Add default to array.\n+                     --  There is a registered default suffix, but no\n+                     --  suffix specified in the project file.\n+                     --  Add the default to the array.\n \n                      if Suffix2 = No_Array_Element then\n                         Array_Elements.Increment_Last;\n@@ -3810,16 +3789,16 @@ package body Prj.Nmsc is\n                            Src_Index => Element.Src_Index,\n                            Index_Case_Sensitive => False,\n                            Value     => Element.Value,\n-                           Next      => Spec_Suffixes);\n-                        Spec_Suffixes := Array_Elements.Last;\n+                           Next      => Spec_Suffixs);\n+                        Spec_Suffixs := Array_Elements.Last;\n                      end if;\n \n                      Suffix := Element.Next;\n                   end loop;\n \n-                  --  Put the resulting array as the specification suffixes\n+                  --  Put the resulting array as the specification suffixs\n \n-                  Data.Naming.Spec_Suffix := Spec_Suffixes;\n+                  Data.Naming.Spec_Suffix := Spec_Suffixs;\n                end if;\n             end;\n \n@@ -3847,26 +3826,27 @@ package body Prj.Nmsc is\n             --  Check Body_Suffix\n \n             declare\n-               Impl_Suffixes : Array_Element_Id :=\n-                                 Util.Value_Of\n-                                   (Name_Body_Suffix, Naming.Decl.Arrays);\n+               Impl_Suffixs : Array_Element_Id :=\n+                                Util.Value_Of\n+                                  (Name_Body_Suffix,\n+                                   Naming.Decl.Arrays);\n \n                Suffix  : Array_Element_Id;\n                Element : Array_Element;\n                Suffix2 : Array_Element_Id;\n \n             begin\n-               --  If some suffixes have been specified, we make sure that\n+               --  If some suffixs have been specified, we make sure that\n                --  for each language for which a default suffix has been\n                --  specified, there is a suffix specified, either the one\n                --  in the project file or if there were noe, the default.\n \n-               if Impl_Suffixes /= No_Array_Element then\n+               if Impl_Suffixs /= No_Array_Element then\n                   Suffix := Data.Naming.Body_Suffix;\n \n                   while Suffix /= No_Array_Element loop\n                      Element := Array_Elements.Table (Suffix);\n-                     Suffix2 := Impl_Suffixes;\n+                     Suffix2 := Impl_Suffixs;\n \n                      while Suffix2 /= No_Array_Element loop\n                         exit when Array_Elements.Table (Suffix2).Index =\n@@ -3885,16 +3865,16 @@ package body Prj.Nmsc is\n                            Src_Index => Element.Src_Index,\n                            Index_Case_Sensitive => False,\n                            Value => Element.Value,\n-                           Next  => Impl_Suffixes);\n-                        Impl_Suffixes := Array_Elements.Last;\n+                           Next  => Impl_Suffixs);\n+                        Impl_Suffixs := Array_Elements.Last;\n                      end if;\n \n                      Suffix := Element.Next;\n                   end loop;\n \n-                  --  Put the resulting array as the implementation suffixes\n+                  --  Put the resulting array as the implementation suffixs\n \n-                  Data.Naming.Body_Suffix := Impl_Suffixes;\n+                  Data.Naming.Body_Suffix := Impl_Suffixs;\n                end if;\n             end;\n \n@@ -3941,78 +3921,17 @@ package body Prj.Nmsc is\n    ----------------------\n \n    procedure Locate_Directory\n-     (Name     : Name_Id;\n-      Parent   : Name_Id;\n-      Dir      : out Name_Id;\n-      Display  : out Name_Id;\n-      Project  : Project_Id := No_Project;\n-      Kind     : String := \"\";\n-      Location : Source_Ptr := No_Location)\n+     (Name    : Name_Id;\n+      Parent  : Name_Id;\n+      Dir     : out Name_Id;\n+      Display : out Name_Id)\n    is\n       The_Name   : constant String := Get_Name_String (Name);\n       The_Parent : constant String :=\n                      Get_Name_String (Parent) & Directory_Separator;\n       The_Parent_Last : constant Natural :=\n                      Compute_Directory_Last (The_Parent);\n \n-      procedure Create_Directory (Absolute_Path : String);\n-      --  Attempt to create a new directory\n-\n-      procedure Get_Names_For (Absolute_Path : String);\n-      --  Create name ids Dir and Display for directory Absolute_Path\n-\n-      ----------------------\n-      -- Create_Directory --\n-      ----------------------\n-\n-      procedure Create_Directory (Absolute_Path : String) is\n-      begin\n-         --  Attempt to create the directory\n-\n-         Make_Dir (Absolute_Path);\n-\n-         --  Setup Dir and Display if creation was successful\n-\n-         Get_Names_For (Absolute_Path);\n-\n-      exception\n-         when Directory_Error =>\n-            Error_Msg\n-              (Project,\n-               \"could not create \" & Kind & \" directory \"\"\" &\n-               Absolute_Path & \"\"\"\",\n-               Location);\n-      end Create_Directory;\n-\n-      -------------------\n-      -- Get_Names_For --\n-      -------------------\n-\n-      procedure Get_Names_For (Absolute_Path : String) is\n-         Normed         : constant String :=\n-                            Normalize_Pathname\n-                              (Absolute_Path,\n-                               Resolve_Links  => False,\n-                               Case_Sensitive => True);\n-\n-         Canonical_Path : constant String :=\n-                            Normalize_Pathname\n-                              (Normed,\n-                               Resolve_Links  => True,\n-                               Case_Sensitive => False);\n-\n-      begin\n-         Name_Len := Normed'Length;\n-         Name_Buffer (1 .. Name_Len) := Normed;\n-         Display := Name_Find;\n-\n-         Name_Len := Canonical_Path'Length;\n-         Name_Buffer (1 .. Name_Len) := Canonical_Path;\n-         Dir := Name_Find;\n-      end Get_Names_For;\n-\n-   --  Start of processing for Locate_Directory\n-\n    begin\n       if Current_Verbosity = High then\n          Write_Str (\"Locate_Directory (\"\"\");\n@@ -4027,10 +3946,28 @@ package body Prj.Nmsc is\n \n       if Is_Absolute_Path (The_Name) then\n          if Is_Directory (The_Name) then\n-            Get_Names_For (The_Name);\n+            declare\n+               Normed : constant String :=\n+                          Normalize_Pathname\n+                            (The_Name,\n+                             Resolve_Links  => False,\n+                             Case_Sensitive => True);\n+\n+               Canonical_Path : constant String :=\n+                                  Normalize_Pathname\n+                                    (Normed,\n+                                     Resolve_Links  => True,\n+                                     Case_Sensitive => False);\n \n-         elsif Kind /= \"\" and then Setup_Projects then\n-            Create_Directory (The_Name);\n+            begin\n+               Name_Len := Normed'Length;\n+               Name_Buffer (1 .. Name_Len) := Normed;\n+               Display := Name_Find;\n+\n+               Name_Len := Canonical_Path'Length;\n+               Name_Buffer (1 .. Name_Len) := Canonical_Path;\n+               Dir := Name_Find;\n+            end;\n          end if;\n \n       else\n@@ -4041,10 +3978,28 @@ package body Prj.Nmsc is\n \n          begin\n             if Is_Directory (Full_Path) then\n-               Get_Names_For (Full_Path);\n+               declare\n+                  Normed : constant String :=\n+                             Normalize_Pathname\n+                               (Full_Path,\n+                                Resolve_Links  => False,\n+                                Case_Sensitive => True);\n+\n+                  Canonical_Path : constant String :=\n+                                     Normalize_Pathname\n+                                       (Normed,\n+                                        Resolve_Links  => True,\n+                                        Case_Sensitive => False);\n \n-            elsif Kind /= \"\" and then Setup_Projects then\n-               Create_Directory (Full_Path);\n+               begin\n+                  Name_Len := Normed'Length;\n+                  Name_Buffer (1 .. Name_Len) := Normed;\n+                  Display := Name_Find;\n+\n+                  Name_Len := Canonical_Path'Length;\n+                  Name_Buffer (1 .. Name_Len) := Canonical_Path;\n+                  Dir := Name_Find;\n+               end;\n             end if;\n          end;\n       end if;"}, {"sha": "e4d1d03594965bafaa840b0ef53807d5050229f7", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=244e5a2c23e5477e26f1970afb1fa0772b2cc808", "patch": "@@ -186,7 +186,23 @@ package body Rtsfind is\n    procedure Entity_Not_Defined (Id : RE_Id) is\n    begin\n       if No_Run_Time_Mode then\n-         RTE_Error_Msg (\"|construct not allowed in no run time mode\");\n+\n+         --  If the error occurs when compiling the body of a predefined\n+         --  unit for inlining purposes, the body must be illegal in this\n+         --  mode, and there is no point in continuing.\n+\n+         if Is_Predefined_File_Name\n+           (Unit_File_Name (Get_Source_Unit (Sloc (Current_Error_Node))))\n+         then\n+            Error_Msg_N\n+              (\"construct not allowed in no run time mode!\",\n+                 Current_Error_Node);\n+            raise Unrecoverable_Error;\n+\n+         else\n+            RTE_Error_Msg (\"|construct not allowed in no run time mode\");\n+         end if;\n+\n       elsif Configurable_Run_Time_Mode then\n          RTE_Error_Msg (\"|construct not allowed in this configuration>\");\n       else"}, {"sha": "dd2e183ef845b423fb4824bb74b322ce92212fdb", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 66, "deletions": 26, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=244e5a2c23e5477e26f1970afb1fa0772b2cc808", "patch": "@@ -6288,50 +6288,83 @@ package body Sem_Ch3 is\n       C      : Node_Id;\n       Id     : Node_Id;\n \n+      procedure Set_Discriminant_Name (Id : Node_Id);\n+      --  If the derived type has discriminants, they may rename discriminants\n+      --  of the parent. When building the full view of the parent, we need to\n+      --  recover the names of the original discriminants if the constraint is\n+      --  given by named associations.\n+\n+      ---------------------------\n+      -- Set_Discriminant_Name --\n+      ---------------------------\n+\n+      procedure Set_Discriminant_Name (Id : Node_Id) is\n+         Disc : Entity_Id;\n+\n+      begin\n+         Set_Original_Discriminant (Id, Empty);\n+\n+         if Has_Discriminants (Typ) then\n+            Disc := First_Discriminant (Typ);\n+\n+            while Present (Disc) loop\n+               if Chars (Disc) = Chars (Id)\n+                 and then Present (Corresponding_Discriminant (Disc))\n+               then\n+                  Set_Chars (Id, Chars (Corresponding_Discriminant (Disc)));\n+               end if;\n+               Next_Discriminant (Disc);\n+            end loop;\n+         end if;\n+      end Set_Discriminant_Name;\n+\n+   --  Start of processing for Build_Underlying_Full_View\n+\n    begin\n       if Nkind (N) = N_Full_Type_Declaration then\n          Constr := Constraint (Subtype_Indication (Type_Definition (N)));\n \n-      --  ??? ??? is this assert right, I assume so otherwise Constr\n-      --  would not be defined below (this used to be an elsif)\n-\n-      else pragma Assert (Nkind (N) = N_Subtype_Declaration);\n+      elsif Nkind (N) = N_Subtype_Declaration then\n          Constr := New_Copy_Tree (Constraint (Subtype_Indication (N)));\n-      end if;\n \n-      --  If the constraint has discriminant associations, the discriminant\n-      --  entity is already set, but it denotes a discriminant of the new\n-      --  type, not the original parent, so it must be found anew.\n+      elsif Nkind (N) = N_Component_Declaration then\n+         Constr :=\n+           New_Copy_Tree\n+             (Constraint (Subtype_Indication (Component_Definition (N))));\n \n-      C := First (Constraints (Constr));\n+      else\n+         raise Program_Error;\n+      end if;\n \n+      C := First (Constraints (Constr));\n       while Present (C) loop\n-\n          if Nkind (C) = N_Discriminant_Association then\n             Id := First (Selector_Names (C));\n-\n             while Present (Id) loop\n-               Set_Original_Discriminant (Id, Empty);\n+               Set_Discriminant_Name (Id);\n                Next (Id);\n             end loop;\n          end if;\n \n          Next (C);\n       end loop;\n \n-      Indic := Make_Subtype_Declaration (Loc,\n-         Defining_Identifier => Subt,\n-         Subtype_Indication  =>\n-           Make_Subtype_Indication (Loc,\n-             Subtype_Mark => New_Reference_To (Par, Loc),\n-             Constraint   => New_Copy_Tree (Constr)));\n+      Indic :=\n+        Make_Subtype_Declaration (Loc,\n+          Defining_Identifier => Subt,\n+          Subtype_Indication  =>\n+            Make_Subtype_Indication (Loc,\n+              Subtype_Mark => New_Reference_To (Par, Loc),\n+              Constraint   => New_Copy_Tree (Constr)));\n \n       --  If this is a component subtype for an outer itype, it is not\n       --  a list member, so simply set the parent link for analysis: if\n       --  the enclosing type does not need to be in a declarative list,\n       --  neither do the components.\n \n-      if Is_List_Member (N) then\n+      if Is_List_Member (N)\n+        and then Nkind (N) /= N_Component_Declaration\n+      then\n          Insert_Before (N, Indic);\n       else\n          Set_Parent (Indic, Parent (N));\n@@ -6972,19 +7005,26 @@ package body Sem_Ch3 is\n            (Full, Related_Nod, Full_Base, Discriminant_Constraint (Priv));\n \n       --  If the full base is itself derived from private, build a congruent\n-      --  subtype of its underlying type, for use by the back end. Do not\n-      --  do this for a constrained record component, where the back-end has\n-      --  the proper information and there is no place for the declaration.\n+      --  subtype of its underlying type, for use by the back end. For a\n+      --  constrained record component, the declaration cannot be placed on\n+      --  the component list, but it must neverthess be built an analyzed, to\n+      --  supply enough information for gigi to compute the size of component.\n \n       elsif Ekind (Full_Base) in Private_Kind\n         and then Is_Derived_Type (Full_Base)\n         and then Has_Discriminants (Full_Base)\n-        and then Nkind (Related_Nod) /= N_Component_Declaration\n         and then (Ekind (Current_Scope) /= E_Record_Subtype)\n-        and then\n-          Nkind (Subtype_Indication (Parent (Priv))) = N_Subtype_Indication\n       then\n-         Build_Underlying_Full_View (Parent (Priv), Full, Etype (Full_Base));\n+         if not Is_Itype (Priv)\n+           and then\n+             Nkind (Subtype_Indication (Parent (Priv))) = N_Subtype_Indication\n+         then\n+            Build_Underlying_Full_View\n+              (Parent (Priv), Full, Etype (Full_Base));\n+\n+         elsif Nkind (Related_Nod) = N_Component_Declaration then\n+            Build_Underlying_Full_View (Related_Nod, Full, Etype (Full_Base));\n+         end if;\n \n       elsif Is_Record_Type (Full_Base) then\n "}, {"sha": "9e384e98023cfa7115dfce7d6c861a55a06bb976", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244e5a2c23e5477e26f1970afb1fa0772b2cc808/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=244e5a2c23e5477e26f1970afb1fa0772b2cc808", "patch": "@@ -1173,7 +1173,11 @@ package body Sem_Res is\n                          or else Scope (Opnd_Type) /= System_Aux_Id\n                          or else Pack /= Scope (System_Aux_Id))\n             then\n-               Error := True;\n+               if not Is_Overloaded (Right_Opnd (Op_Node)) then\n+                  Error := True;\n+               else\n+                  Error := not Operand_Type_In_Scope (Pack);\n+               end if;\n \n             elsif Pack = Standard_Standard\n               and then not Operand_Type_In_Scope (Standard_Standard)"}]}