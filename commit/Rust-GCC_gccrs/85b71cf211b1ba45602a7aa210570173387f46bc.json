{"sha": "85b71cf211b1ba45602a7aa210570173387f46bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODViNzFjZjIxMWIxYmE0NTYwMmE3YWEyMTA1NzAxNzMzODdmNDZiYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-12T01:53:33Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-12T01:53:33Z"}, "message": "[multiple changes]\n\nThu Sep 11 17:14:55 1997  Jason Merrill  <jason@yorick.cygnus.com>\n\n\t* decl.c (lookup_name_real): Add implicit 'typename' to types from\n\tbase classes.\n\n\t* pt.c (most_specialized_class): Fix typo.\n\t(tsubst): Move constant folding to TREE_VEC case.\n\nThu Sep 11 10:08:45 1997  Mark Mitchell  <mmitchell@usa.net>\n\n\t* pt.c (do_poplevel): Don't warn about unused local variables\n\twhile processing_template_decl since we don't always know whether\n\tor not they will need constructing/destructing.\n\n\t* pt.c (uses_template_parms): Check the values of an enumeration\n\ttype to make sure they don't depend on template parms.\n\n\t* decl.c (make_typename_type): Don't lookup the field if the\n\tcontext uses template parms, even if we're not\n\tprocessing_template_decl at the moment.\n\n\t* pt.c (coerce_template_parms): Avoid looking at the\n\tTYPE_LANG_DECL portion of a typename type, since there won't be\n\tone.\n\t(tsubst): Do constant folding as necessary to make sure that\n\targuments passed to lookup_template_class really are constants.\n\nFrom-SVN: r15422", "tree": {"sha": "ac107b3a0273de309e87b0f293a74e11ff384877", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac107b3a0273de309e87b0f293a74e11ff384877"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85b71cf211b1ba45602a7aa210570173387f46bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b71cf211b1ba45602a7aa210570173387f46bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85b71cf211b1ba45602a7aa210570173387f46bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b71cf211b1ba45602a7aa210570173387f46bc/comments", "author": null, "committer": null, "parents": [{"sha": "5188d2b2fad2225755fd678f24c77ef7a290e0d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5188d2b2fad2225755fd678f24c77ef7a290e0d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5188d2b2fad2225755fd678f24c77ef7a290e0d8"}], "stats": {"total": 92, "additions": 85, "deletions": 7}, "files": [{"sha": "66766ed4cb97c107c96966e6f50c4a8d754c1000", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b71cf211b1ba45602a7aa210570173387f46bc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b71cf211b1ba45602a7aa210570173387f46bc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=85b71cf211b1ba45602a7aa210570173387f46bc", "patch": "@@ -1,3 +1,30 @@\n+Thu Sep 11 17:14:55 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (lookup_name_real): Add implicit 'typename' to types from\n+\tbase classes.\n+\n+\t* pt.c (most_specialized_class): Fix typo.\n+\t(tsubst): Move constant folding to TREE_VEC case.\n+\n+Thu Sep 11 10:08:45 1997  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* pt.c (do_poplevel): Don't warn about unused local variables\n+\twhile processing_template_decl since we don't always know whether\n+\tor not they will need constructing/destructing.\n+\n+\t* pt.c (uses_template_parms): Check the values of an enumeration\n+\ttype to make sure they don't depend on template parms.\n+\n+\t* decl.c (make_typename_type): Don't lookup the field if the\n+\tcontext uses template parms, even if we're not\n+\tprocessing_template_decl at the moment.\n+\n+\t* pt.c (coerce_template_parms): Avoid looking at the\n+\tTYPE_LANG_DECL portion of a typename type, since there won't be\n+\tone. \n+\t(tsubst): Do constant folding as necessary to make sure that\n+\targuments passed to lookup_template_class really are constants. \n+\n Tue Sep  9 19:49:38 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* pt.c (unify): Just return 0 for a TYPENAME_TYPE."}, {"sha": "852708033be3345c8710b54579b5a125d8363803", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b71cf211b1ba45602a7aa210570173387f46bc/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b71cf211b1ba45602a7aa210570173387f46bc/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=85b71cf211b1ba45602a7aa210570173387f46bc", "patch": "@@ -4322,8 +4322,7 @@ make_typename_type (context, name)\n   else if (TREE_CODE (name) != IDENTIFIER_NODE)\n     my_friendly_abort (2000);\n \n-  if (! processing_template_decl\n-      || ! uses_template_parms (context)\n+  if (! uses_template_parms (context)\n       || context == current_class_type)\n     {\n       t = lookup_field (context, name, 0, 1);\n@@ -4432,7 +4431,7 @@ lookup_name_real (name, prefer_type, nonclass)\n       else\n \tval = NULL_TREE;\n \n-#if 1\n+      /* Add implicit 'typename' to scoped types from other classes.  */\n       if (got_scope && processing_template_decl\n \t  && got_scope != current_class_type\n \t  && uses_template_parms (got_scope)\n@@ -4443,7 +4442,6 @@ lookup_name_real (name, prefer_type, nonclass)\n \t  TREE_TYPE (t) = TREE_TYPE (val);\n \t  val = TYPE_MAIN_DECL (t);\n \t}\n-#endif\n \n       if (got_scope)\n \tgoto done;\n@@ -4473,6 +4471,19 @@ lookup_name_real (name, prefer_type, nonclass)\n \t created the COMPONENT_REF or anything like that.  */\n       if (classval == NULL_TREE)\n \tclassval = lookup_nested_field (name, ! yylex);\n+\n+      /* Add implicit 'typename' to types from base classes.  */\n+      if (processing_template_decl\n+\t  && classval && TREE_CODE (classval) == TYPE_DECL\n+\t  && DECL_CONTEXT (classval) != current_class_type\n+\t  && uses_template_parms (DECL_CONTEXT (classval))\n+\t  && ! DECL_ARTIFICIAL (classval))\n+\t{\n+\t  tree t = make_typename_type (DECL_CONTEXT (classval),\n+\t\t\t\t       DECL_NAME (classval));\n+\t  TREE_TYPE (t) = TREE_TYPE (classval);\n+\t  classval = TYPE_MAIN_DECL (t);\n+\t}\n     }\n \n   if (locval && classval)"}, {"sha": "8df5038b9ab5d20a0bc510d1cfc90d78de806ea3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b71cf211b1ba45602a7aa210570173387f46bc/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b71cf211b1ba45602a7aa210570173387f46bc/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=85b71cf211b1ba45602a7aa210570173387f46bc", "patch": "@@ -658,7 +658,8 @@ coerce_template_parms (parms, arglist, in_decl)\n \t  if (! processing_template_decl)\n \t    {\n \t      tree t = target_type (val);\n-\t      if (IS_AGGR_TYPE (t)\n+\t      if (TREE_CODE (t) != TYPENAME_TYPE \n+\t\t  && IS_AGGR_TYPE (t)\n \t\t  && decl_function_context (TYPE_MAIN_DECL (t)))\n \t\t{\n \t\t  cp_error (\"type `%T' composed from a local class is not a valid template-argument\", val);\n@@ -1146,10 +1147,19 @@ uses_template_parms (t)\n     case REAL_TYPE:\n     case COMPLEX_TYPE:\n     case VOID_TYPE:\n-    case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n       return 0;\n \n+    case ENUMERAL_TYPE:\n+      {\n+\ttree v;\n+\n+\tfor (v = TYPE_VALUES (t); v != NULL_TREE; v = TREE_CHAIN (v))\n+\t  if (uses_template_parms (TREE_VALUE (v)))\n+\t    return 1;\n+      }\n+      return 0;\n+\n       /* constants */\n     case INTEGER_CST:\n     case REAL_CST:\n@@ -2084,6 +2094,8 @@ tsubst (t, args, nargs, in_decl)\n     case TREE_VEC:\n       if (type != NULL_TREE)\n \t{\n+\t  /* A binfo node.  */\n+\n \t  t = copy_node (t);\n \n \t  if (type == TREE_TYPE (t))\n@@ -2099,6 +2111,8 @@ tsubst (t, args, nargs, in_decl)\n \t    }\n \t  return t;\n \t}\n+\n+      /* Otherwise, a vector of template arguments.  */\n       {\n \tint len = TREE_VEC_LENGTH (t), need_new = 0, i;\n \ttree *elts = (tree *) alloca (len * sizeof (tree));\n@@ -2108,6 +2122,24 @@ tsubst (t, args, nargs, in_decl)\n \tfor (i = 0; i < len; i++)\n \t  {\n \t    elts[i] = tsubst_expr (TREE_VEC_ELT (t, i), args, nargs, in_decl);\n+\n+\t    if (TREE_CODE_CLASS (TREE_CODE (elts[i])) != 't'\n+\t\t&& !uses_template_parms (elts[i]))\n+\t      {\n+\t\t/* Sometimes, one of the args was an expression involving a\n+\t\t   template constant parameter, like N - 1.  Now that we've\n+\t\t   tsubst'd, we might have something like 2 - 1.  This will\n+\t\t   confuse lookup_template_class, so we do constant folding\n+\t\t   here.  We have to unset processing_template_decl, to\n+\t\t   fool build_expr_from_tree() into building an actual\n+\t\t   tree.  */\n+\n+\t\tint saved_processing_template_decl = processing_template_decl; \n+\t\tprocessing_template_decl = 0;\n+\t\telts[i] = fold (build_expr_from_tree (elts[i]));\n+\t\tprocessing_template_decl = saved_processing_template_decl; \n+\t      }\n+\n \t    if (elts[i] != TREE_VEC_ELT (t, i))\n \t      need_new = 1;\n \t  }\n@@ -2305,8 +2337,16 @@ tree\n do_poplevel ()\n {\n   tree t;\n+  int saved_warn_unused;\n \n+  if (processing_template_decl)\n+    {\n+      saved_warn_unused = warn_unused;\n+      warn_unused = 0;\n+    }\n   expand_end_bindings (getdecls (), kept_level_p (), 1);\n+  if (processing_template_decl)\n+    warn_unused = saved_warn_unused;\n   t = poplevel (kept_level_p (), 1, 0);\n   pop_momentary ();\n   return t;\n@@ -3566,7 +3606,7 @@ most_specialized_class (specs, mainargs)\n \n   for (t = list; t && t != champ; t = TREE_CHAIN (t))\n     {\n-      fate = more_specialized (champ, t);\n+      fate = more_specialized_class (champ, t);\n       if (fate != 1)\n \treturn error_mark_node;\n     }"}]}