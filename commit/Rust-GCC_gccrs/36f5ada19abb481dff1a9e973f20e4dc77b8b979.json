{"sha": "36f5ada19abb481dff1a9e973f20e4dc77b8b979", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZmNWFkYTE5YWJiNDgxZGZmMWE5ZTk3M2YyMGU0ZGM3N2I4Yjk3OQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2004-12-18T20:22:52Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-12-18T20:22:52Z"}, "message": "re PR tree-optimization/18800 (ivopt missed)\n\n        PR tree-optimization/18800\n        * params.def (PARAM_IV_ALWAYS_PRUNE_CAND_SET_BOUND): New parameter.\n        * tree-ssa-loop-ivopts.c (struct iv_ca): Add n_cands field.\n        (ALWAYS_PRUNE_CAND_SET_BOUND): New macro.\n        (iv_ca_set_no_cp, iv_ca_set_cp, iv_ca_new): Update n_cands field.\n        (iv_ca_delta_join, iv_ca_delta_reverse, iv_ca_n_cands, iv_ca_prune):\n        New functions.\n        (iv_ca_extend): Return number of candidates in the set.\n        (try_add_cand_for): Add argument to iv_ca_extend calls.\n        (try_improve_iv_set): Use iv_ca_prune.\n        * doc/invoke.texi (iv-always-prune-cand-set-bound): Document.\n\nFrom-SVN: r92363", "tree": {"sha": "be8c1c0278641ae18ae9aa16fd05df79f9533593", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be8c1c0278641ae18ae9aa16fd05df79f9533593"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36f5ada19abb481dff1a9e973f20e4dc77b8b979", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36f5ada19abb481dff1a9e973f20e4dc77b8b979", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36f5ada19abb481dff1a9e973f20e4dc77b8b979", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36f5ada19abb481dff1a9e973f20e4dc77b8b979/comments", "author": null, "committer": null, "parents": [{"sha": "f54ff900373c7406b665588b2af845868b4a1872", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f54ff900373c7406b665588b2af845868b4a1872", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f54ff900373c7406b665588b2af845868b4a1872"}], "stats": {"total": 214, "additions": 187, "deletions": 27}, "files": [{"sha": "e6851c99ce54c5f1698adfa6e166163c7f13b048", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f5ada19abb481dff1a9e973f20e4dc77b8b979/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f5ada19abb481dff1a9e973f20e4dc77b8b979/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36f5ada19abb481dff1a9e973f20e4dc77b8b979", "patch": "@@ -2,6 +2,20 @@\n \n \t* stor-layout.c (layout_decl): Use unshare_expr, not unsave_expr.\n \n+2004-12-18  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+        PR tree-optimization/18800\n+        * params.def (PARAM_IV_ALWAYS_PRUNE_CAND_SET_BOUND): New parameter.\n+        * tree-ssa-loop-ivopts.c (struct iv_ca): Add n_cands field.\n+        (ALWAYS_PRUNE_CAND_SET_BOUND): New macro.\n+        (iv_ca_set_no_cp, iv_ca_set_cp, iv_ca_new): Update n_cands field.\n+        (iv_ca_delta_join, iv_ca_delta_reverse, iv_ca_n_cands, iv_ca_prune):\n+        New functions.\n+        (iv_ca_extend): Return number of candidates in the set.\n+        (try_add_cand_for): Add argument to iv_ca_extend calls.\n+        (try_improve_iv_set): Use iv_ca_prune.\n+        * doc/invoke.texi (iv-always-prune-cand-set-bound): Document.\n+\n 2004-12-18  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR rtl-optimization/19001"}, {"sha": "5ba632e7561b9f70c356160dd330981a71270add", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f5ada19abb481dff1a9e973f20e4dc77b8b979/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f5ada19abb481dff1a9e973f20e4dc77b8b979/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=36f5ada19abb481dff1a9e973f20e4dc77b8b979", "patch": "@@ -5478,6 +5478,11 @@ if there are more candidates, to avoid quadratic time complexity.\n The induction variable optimizations give up on loops that contain more\n induction variable uses.\n \n+@item iv-always-prune-cand-set-bound\n+If number of candidates in the set is smaller than this value,\n+we always try to remove unnecessary ivs from the set during its\n+optimization when a new iv is added to the set.\n+\n @item max-iterations-to-track\n \n The maximum number of iterations of a loop the brute force algorithm"}, {"sha": "7ac263cdc2467f987675d2da53dfbaf45589954d", "filename": "gcc/params.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f5ada19abb481dff1a9e973f20e4dc77b8b979/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f5ada19abb481dff1a9e973f20e4dc77b8b979/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=36f5ada19abb481dff1a9e973f20e4dc77b8b979", "patch": "@@ -347,6 +347,14 @@ DEFPARAM(PARAM_IV_MAX_CONSIDERED_USES,\n \t \"Bound on number of iv uses in loop optimized in iv optimizations\",\n \t 250, 0, 0)\n \n+/* If there are at most this number of ivs in the set, try removing unnecessary\n+   ivs from the set always.  */\n+\n+DEFPARAM(PARAM_IV_ALWAYS_PRUNE_CAND_SET_BOUND,\n+\t \"iv-always-prune-cand-set-bound\",\n+\t \"If number of candidates in the set is smaller, we always try to remove unused ivs during its optimization\",\n+\t 10, 0, 0)\n+\n /* The product of the next two is used to decide whether or not to\n    use .GLOBAL_VAR.  See tree-dfa.c.  */\n DEFPARAM(PARAM_GLOBAL_VAR_THRESHOLD,"}, {"sha": "9c5aad3920fab2f56dc48346f26d6ef0fdd55f57", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 160, "deletions": 27, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f5ada19abb481dff1a9e973f20e4dc77b8b979/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f5ada19abb481dff1a9e973f20e4dc77b8b979/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=36f5ada19abb481dff1a9e973f20e4dc77b8b979", "patch": "@@ -244,6 +244,9 @@ struct iv_ca\n   /* The candidates used.  */\n   bitmap cands;\n \n+  /* The number of candidates in the set.  */\n+  unsigned n_cands;\n+\n   /* Total number of registers needed.  */\n   unsigned n_regs;\n \n@@ -288,6 +291,12 @@ struct iv_ca_delta\n #define MAX_CONSIDERED_USES \\\n   ((unsigned) PARAM_VALUE (PARAM_IV_MAX_CONSIDERED_USES))\n \n+/* If there are at most this number of ivs in the set, try removing unnecessary\n+   ivs from the set always.  */\n+\n+#define ALWAYS_PRUNE_CAND_SET_BOUND \\\n+  ((unsigned) PARAM_VALUE (PARAM_IV_ALWAYS_PRUNE_CAND_SET_BOUND))\n+\n /* The list of trees for that the decl_rtl field must be reset is stored\n    here.  */\n \n@@ -3661,6 +3670,7 @@ iv_ca_set_no_cp (struct ivopts_data *data, struct iv_ca *ivs,\n       /* Do not count the pseudocandidates.  */\n       if (cp->cand->iv)\n \tivs->n_regs--;\n+      ivs->n_cands--;\n       ivs->cand_cost -= cp->cand->cost;\n     }\n \n@@ -3710,6 +3720,7 @@ iv_ca_set_cp (struct ivopts_data *data, struct iv_ca *ivs,\n \t  /* Do not count the pseudocandidates.  */\n \t  if (cp->cand->iv)\n \t    ivs->n_regs++;\n+\t  ivs->n_cands++;\n \t  ivs->cand_cost += cp->cand->cost;\n \t}\n \n@@ -3806,6 +3817,27 @@ iv_ca_delta_add (struct iv_use *use, struct cost_pair *old_cp,\n   return change;\n }\n \n+/* Joins two lists of changes L1 and L2.  Destructive -- old lists\n+   are rewritten.   */\n+\n+static struct iv_ca_delta *\n+iv_ca_delta_join (struct iv_ca_delta *l1, struct iv_ca_delta *l2)\n+{\n+  struct iv_ca_delta *last;\n+\n+  if (!l2)\n+    return l1;\n+\n+  if (!l1)\n+    return l2;\n+\n+  for (last = l1; last->next_change; last = last->next_change)\n+    continue;\n+  last->next_change = l2;\n+\n+  return l1;\n+}\n+\n /* Returns candidate by that USE is expressed in IVS.  */\n \n static struct cost_pair *\n@@ -3814,6 +3846,28 @@ iv_ca_cand_for_use (struct iv_ca *ivs, struct iv_use *use)\n   return ivs->cand_for_use[use->id];\n }\n \n+/* Reverse the list of changes DELTA, forming the inverse to it.  */\n+\n+static struct iv_ca_delta *\n+iv_ca_delta_reverse (struct iv_ca_delta *delta)\n+{\n+  struct iv_ca_delta *act, *next, *prev = NULL;\n+  struct cost_pair *tmp;\n+\n+  for (act = delta; act; act = next)\n+    {\n+      next = act->next_change;\n+      act->next_change = prev;\n+      prev = act;\n+\n+      tmp = act->old_cp;\n+      act->old_cp = act->new_cp;\n+      act->new_cp = tmp;\n+    }\n+\n+  return prev;\n+}\n+\n /* Commit changes in DELTA to IVS.  If FORWARD is false, the changes are\n    reverted instead.  */\n \n@@ -3822,23 +3876,21 @@ iv_ca_delta_commit (struct ivopts_data *data, struct iv_ca *ivs,\n \t\t    struct iv_ca_delta *delta, bool forward)\n {\n   struct cost_pair *from, *to;\n+  struct iv_ca_delta *act;\n \n-  for (; delta; delta = delta->next_change)\n-    {\n-      if (forward)\n-\t{\n-\t  from = delta->old_cp;\n-\t  to = delta->new_cp;\n-\t}\n-      else\n-\t{\n-\t  from = delta->new_cp;\n-\t  to = delta->old_cp;\n-\t}\n+  if (!forward)\n+    delta = iv_ca_delta_reverse (delta);\n \n-      gcc_assert (iv_ca_cand_for_use (ivs, delta->use) == from);\n-      iv_ca_set_cp (data, ivs, delta->use, to);\n+  for (act = delta; act; act = act->next_change)\n+    {\n+      from = act->old_cp;\n+      to = act->new_cp;\n+      gcc_assert (iv_ca_cand_for_use (ivs, act->use) == from);\n+      iv_ca_set_cp (data, ivs, act->use, to);\n     }\n+\n+  if (!forward)\n+    iv_ca_delta_reverse (delta);\n }\n \n /* Returns true if CAND is used in IVS.  */\n@@ -3849,6 +3901,14 @@ iv_ca_cand_used_p (struct iv_ca *ivs, struct iv_cand *cand)\n   return ivs->n_cand_uses[cand->id] > 0;\n }\n \n+/* Returns number of induction variable candidates in the set IVS.  */\n+\n+static unsigned\n+iv_ca_n_cands (struct iv_ca *ivs)\n+{\n+  return ivs->n_cands;\n+}\n+\n /* Free the list of changes DELTA.  */\n \n static void\n@@ -3877,6 +3937,7 @@ iv_ca_new (struct ivopts_data *data)\n   nw->cand_for_use = xcalloc (n_iv_uses (data), sizeof (struct cost_pair *));\n   nw->n_cand_uses = xcalloc (n_iv_cands (data), sizeof (unsigned));\n   nw->cands = BITMAP_XMALLOC ();\n+  nw->n_cands = 0;\n   nw->n_regs = 0;\n   nw->cand_use_cost = 0;\n   nw->cand_cost = 0;\n@@ -3920,11 +3981,13 @@ iv_ca_dump (struct ivopts_data *data, FILE *file, struct iv_ca *ivs)\n }\n \n /* Try changing candidate in IVS to CAND for each use.  Return cost of the\n-   new set, and store differences in DELTA.  */\n+   new set, and store differences in DELTA.  Number of induction variables\n+   in the new set is stored to N_IVS.  */\n \n static unsigned\n iv_ca_extend (struct ivopts_data *data, struct iv_ca *ivs,\n-\t      struct iv_cand *cand, struct iv_ca_delta **delta)\n+\t      struct iv_cand *cand, struct iv_ca_delta **delta,\n+\t      unsigned *n_ivs)\n {\n   unsigned i, cost;\n   struct iv_use *use;\n@@ -3955,6 +4018,8 @@ iv_ca_extend (struct ivopts_data *data, struct iv_ca *ivs,\n \n   iv_ca_delta_commit (data, ivs, *delta, true);\n   cost = iv_ca_cost (ivs);\n+  if (n_ivs)\n+    *n_ivs = iv_ca_n_cands (ivs);\n   iv_ca_delta_commit (data, ivs, *delta, false);\n \n   return cost;\n@@ -4044,6 +4109,55 @@ iv_ca_narrow (struct ivopts_data *data, struct iv_ca *ivs,\n   return cost;\n }\n \n+/* Try optimizing the set of candidates IVS by removing candidates different\n+   from to EXCEPT_CAND from it.  Return cost of the new set, and store\n+   differences in DELTA.  */\n+\n+static unsigned\n+iv_ca_prune (struct ivopts_data *data, struct iv_ca *ivs,\n+\t     struct iv_cand *except_cand, struct iv_ca_delta **delta)\n+{\n+  bitmap_iterator bi;\n+  struct iv_ca_delta *act_delta, *best_delta;\n+  unsigned i, best_cost, acost;\n+  struct iv_cand *cand;\n+\n+  best_delta = NULL;\n+  best_cost = iv_ca_cost (ivs);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (ivs->cands, 0, i, bi)\n+    {\n+      cand = iv_cand (data, i);\n+\n+      if (cand == except_cand)\n+\tcontinue;\n+\n+      acost = iv_ca_narrow (data, ivs, cand, &act_delta);\n+\n+      if (acost < best_cost)\n+\t{\n+\t  best_cost = acost;\n+\t  iv_ca_delta_free (&best_delta);\n+\t  best_delta = act_delta;\n+\t}\n+      else\n+\tiv_ca_delta_free (&act_delta);\n+    }\n+\n+  if (!best_delta)\n+    {\n+      *delta = NULL;\n+      return best_cost;\n+    }\n+\n+  /* Recurse to possibly remove other unnecessary ivs.  */\n+  iv_ca_delta_commit (data, ivs, best_delta, true);\n+  best_cost = iv_ca_prune (data, ivs, except_cand, delta);\n+  iv_ca_delta_commit (data, ivs, best_delta, false);\n+  *delta = iv_ca_delta_join (best_delta, *delta);\n+  return best_cost;\n+}\n+\n /* Tries to extend the sets IVS in the best possible way in order\n    to express the USE.  */\n \n@@ -4088,7 +4202,7 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n \tcontinue;\n \n       iv_ca_set_cp (data, ivs, use, cp);\n-      act_cost = iv_ca_extend (data, ivs, cand, &act_delta);\n+      act_cost = iv_ca_extend (data, ivs, cand, &act_delta, NULL);\n       iv_ca_set_no_cp (data, ivs, use);\n       act_delta = iv_ca_delta_add (use, NULL, cp, act_delta);\n \n@@ -4121,7 +4235,7 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n \n \t  act_delta = NULL;\n \t  iv_ca_set_cp (data, ivs, use, cp);\n-\t  act_cost = iv_ca_extend (data, ivs, cand, &act_delta);\n+\t  act_cost = iv_ca_extend (data, ivs, cand, &act_delta, NULL);\n \t  iv_ca_set_no_cp (data, ivs, use);\n \t  act_delta = iv_ca_delta_add (use, iv_ca_cand_for_use (ivs, use),\n \t\t\t\t       cp, act_delta);\n@@ -4168,35 +4282,54 @@ get_initial_solution (struct ivopts_data *data)\n static bool\n try_improve_iv_set (struct ivopts_data *data, struct iv_ca *ivs)\n {\n-  unsigned i, acost, best_cost = iv_ca_cost (ivs);\n-  struct iv_ca_delta *best_delta = NULL, *act_delta;\n+  unsigned i, acost, best_cost = iv_ca_cost (ivs), n_ivs;\n+  struct iv_ca_delta *best_delta = NULL, *act_delta, *tmp_delta;\n   struct iv_cand *cand;\n \n-  /* Try altering the set of induction variables by one.  */\n+  /* Try extending the set of induction variables by one.  */\n   for (i = 0; i < n_iv_cands (data); i++)\n     {\n       cand = iv_cand (data, i);\n       \n       if (iv_ca_cand_used_p (ivs, cand))\n-\tacost = iv_ca_narrow (data, ivs, cand, &act_delta);\n-      else\n-\tacost = iv_ca_extend (data, ivs, cand, &act_delta);\n+\tcontinue;\n+\n+      acost = iv_ca_extend (data, ivs, cand, &act_delta, &n_ivs);\n+      if (!act_delta)\n+\tcontinue;\n+\n+      /* If we successfully added the candidate and the set is small enough,\n+\t try optimizing it by removing other candidates.  */\n+      if (n_ivs <= ALWAYS_PRUNE_CAND_SET_BOUND)\n+      \t{\n+\t  iv_ca_delta_commit (data, ivs, act_delta, true);\n+\t  acost = iv_ca_prune (data, ivs, cand, &tmp_delta);\n+\t  iv_ca_delta_commit (data, ivs, act_delta, false);\n+\t  act_delta = iv_ca_delta_join (act_delta, tmp_delta);\n+\t}\n \n       if (acost < best_cost)\n \t{\n \t  best_cost = acost;\n-\t  if (best_delta)\n-\t    iv_ca_delta_free (&best_delta);\n+\t  iv_ca_delta_free (&best_delta);\n \t  best_delta = act_delta;\n \t}\n       else\n \tiv_ca_delta_free (&act_delta);\n     }\n \n   if (!best_delta)\n-    return false;\n+    {\n+      /* Try removing the candidates from the set instead.  */\n+      best_cost = iv_ca_prune (data, ivs, NULL, &best_delta);\n+\n+      /* Nothing more we can do.  */\n+      if (!best_delta)\n+\treturn false;\n+    }\n \n   iv_ca_delta_commit (data, ivs, best_delta, true);\n+  gcc_assert (best_cost == iv_ca_cost (ivs));\n   iv_ca_delta_free (&best_delta);\n   return true;\n }"}]}