{"sha": "1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "node_id": "C_kwDOANBUbNoAKDE4NzllNDhmM2Q4NTk1YmM5ZTdmNTgzYmJkMTJkZjNjNmY1YzQyZGM", "commit": {"author": {"name": "Qing Zhao", "email": "qing.zhao@oracle.com", "date": "2022-10-07T14:58:20Z"}, "committer": {"name": "Qing Zhao", "email": "qing.zhao@oracle.com", "date": "2022-10-07T17:44:08Z"}, "message": "Add a new option -fstrict-flex-arrays[=n] and new attribute strict_flex_array\n\nAdd the following new option -fstrict-flex-arrays[=n] and a corresponding\nattribute strict_flex_array to GCC:\n\n'-fstrict-flex-arrays'\n     Control when to treat the trailing array of a structure as a flexible array\n     member for the purpose of accessing the elements of such an array.\n     The positive form is equivalent to '-fstrict-flex-arrays=3', which is the\n     strictest.  A trailing array is treated as a flexible array member only when\n     it declared as a flexible array member per C99 standard onwards.\n     The negative form is equivalent to '-fstrict-flex-arrays=0', which is the\n     least strict.  All trailing arrays of structures are treated as flexible\n     array members.\n\n'-fstrict-flex-arrays=LEVEL'\n     Control when to treat the trailing array of a structure as a flexible array\n     member for the purpose of accessing the elements of such an array.  The value\n     of LEVEL controls the level of strictness\n\n     The possible values of LEVEL are the same as for the\n     'strict_flex_array' attribute (*note Variable Attributes::).\n\n     You can control this behavior for a specific trailing array field\n     of a structure by using the variable attribute 'strict_flex_array'\n     attribute (*note Variable Attributes::).\n\n'strict_flex_array (LEVEL)'\n     The 'strict_flex_array' attribute should be attached to the trailing\n     array field of a structure. It controls when to treat the trailing array\n     field of a structure as a flexible array member for the purposes of accessing\n     the elements of such an array. LEVEL must be an integer betwen 0 to 3.\n\n     LEVEL=0 is the least strict level, all trailing arrays of\n     structures are treated as flexible array members.  LEVEL=3 is the\n     strictest level, only when the trailing array is declared as a\n     flexible array member per C99 standard onwards ('[]'), it is\n     treated as a flexible array member.\n\n     There are two more levels in between 0 and 3, which are provided to\n     support older codes that use GCC zero-length array extension\n     ('[0]') or one-element array as flexible array members('[1]'): When\n     LEVEL is 1, the trailing array is treated as a flexible array member\n     when it is declared as either '[]', '[0]', or '[1]'; When\n     LEVEL is 2, the trailing array is treated as a flexible array member\n     when it is declared as either '[]', or '[0]'.\n\n     This attribute can be used with or without the\n     '-fstrict-flex-arrays'.  When both the attribute and the option\n     present at the same time, the level of the strictness for the\n     specific trailing array field is determined by the attribute.\n\ngcc/c-family/ChangeLog:\n\n\t* c-attribs.cc (handle_strict_flex_array_attribute): New function.\n\t(c_common_attribute_table): New item for strict_flex_array.\n\t* c.opt: (fstrict-flex-arrays): New option.\n\t(fstrict-flex-arrays=): New option.\n\ngcc/c/ChangeLog:\n\n\t* c-decl.cc (flexible_array_member_type_p): New function.\n\t(one_element_array_type_p): Likewise.\n\t(zero_length_array_type_p): Likewise.\n\t(add_flexible_array_elts_to_size): Call new utility\n\troutine flexible_array_member_type_p.\n\t(is_flexible_array_member_p): New function.\n\t(finish_struct): Set the new DECL_NOT_FLEXARRAY flag.\n\ngcc/cp/ChangeLog:\n\n\t* module.cc (trees_out::core_bools): Stream out new bit\n\tdecl_not_flexarray.\n\t(trees_in::core_bools): Stream in new bit decl_not_flexarray.\n\ngcc/ChangeLog:\n\n\t* doc/extend.texi: Document strict_flex_array attribute.\n\t* doc/invoke.texi: Document -fstrict-flex-arrays[=n] option.\n\t* print-tree.cc (print_node): Print new bit decl_not_flexarray.\n\t* tree-core.h (struct tree_decl_common): New bit field\n\tdecl_not_flexarray.\n\t* tree-streamer-in.cc (unpack_ts_decl_common_value_fields): Stream\n\tin new bit decl_not_flexarray.\n\t* tree-streamer-out.cc (pack_ts_decl_common_value_fields): Stream\n\tout new bit decl_not_flexarray.\n\t* tree.cc (array_at_struct_end_p): Update it with the new bit field\n\tdecl_not_flexarray.\n\t* tree.h (DECL_NOT_FLEXARRAY): New flag.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/strict-flex-array-1.C: New test.\n\t* gcc.dg/strict-flex-array-1.c: New test.", "tree": {"sha": "981a0bf7f72cf12425310915f8def6350def1a77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/981a0bf7f72cf12425310915f8def6350def1a77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/comments", "author": {"login": "qingzhao69", "id": 89154636, "node_id": "MDQ6VXNlcjg5MTU0NjM2", "avatar_url": "https://avatars.githubusercontent.com/u/89154636?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qingzhao69", "html_url": "https://github.com/qingzhao69", "followers_url": "https://api.github.com/users/qingzhao69/followers", "following_url": "https://api.github.com/users/qingzhao69/following{/other_user}", "gists_url": "https://api.github.com/users/qingzhao69/gists{/gist_id}", "starred_url": "https://api.github.com/users/qingzhao69/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qingzhao69/subscriptions", "organizations_url": "https://api.github.com/users/qingzhao69/orgs", "repos_url": "https://api.github.com/users/qingzhao69/repos", "events_url": "https://api.github.com/users/qingzhao69/events{/privacy}", "received_events_url": "https://api.github.com/users/qingzhao69/received_events", "type": "User", "site_admin": false}, "committer": {"login": "qingzhao69", "id": 89154636, "node_id": "MDQ6VXNlcjg5MTU0NjM2", "avatar_url": "https://avatars.githubusercontent.com/u/89154636?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qingzhao69", "html_url": "https://github.com/qingzhao69", "followers_url": "https://api.github.com/users/qingzhao69/followers", "following_url": "https://api.github.com/users/qingzhao69/following{/other_user}", "gists_url": "https://api.github.com/users/qingzhao69/gists{/gist_id}", "starred_url": "https://api.github.com/users/qingzhao69/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qingzhao69/subscriptions", "organizations_url": "https://api.github.com/users/qingzhao69/orgs", "repos_url": "https://api.github.com/users/qingzhao69/repos", "events_url": "https://api.github.com/users/qingzhao69/events{/privacy}", "received_events_url": "https://api.github.com/users/qingzhao69/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21e51a55e9714d14a6df0e8e83ae005eb19f0f02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21e51a55e9714d14a6df0e8e83ae005eb19f0f02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21e51a55e9714d14a6df0e8e83ae005eb19f0f02"}], "stats": {"total": 378, "additions": 350, "deletions": 28}, "files": [{"sha": "92ac93ba2cedd3ba5ef1be6c883b48eba95d15eb", "filename": "gcc/c-family/c-attribs.cc", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Fc-family%2Fc-attribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Fc-family%2Fc-attribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.cc?ref=1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "patch": "@@ -101,6 +101,8 @@ static tree handle_special_var_sec_attribute (tree *, tree, tree, int, bool *);\n static tree handle_aligned_attribute (tree *, tree, tree, int, bool *);\n static tree handle_warn_if_not_aligned_attribute (tree *, tree, tree,\n \t\t\t\t\t\t  int, bool *);\n+static tree handle_strict_flex_array_attribute (tree *, tree, tree,\n+\t\t\t\t\t\t int, bool *);\n static tree handle_weak_attribute (tree *, tree, tree, int, bool *) ;\n static tree handle_noplt_attribute (tree *, tree, tree, int, bool *) ;\n static tree handle_alias_ifunc_attribute (bool, tree *, tree, tree, bool *);\n@@ -369,6 +371,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t                      attr_aligned_exclusions },\n   { \"warn_if_not_aligned\",    0, 1, false, false, false, false,\n \t\t\t      handle_warn_if_not_aligned_attribute, NULL },\n+  { \"strict_flex_array\",      1, 1, true, false, false, false,\n+\t\t\t      handle_strict_flex_array_attribute, NULL },\n   { \"weak\",                   0, 0, true,  false, false, false,\n \t\t\t      handle_weak_attribute, NULL },\n   { \"noplt\",                   0, 0, true,  false, false, false,\n@@ -2508,6 +2512,49 @@ handle_warn_if_not_aligned_attribute (tree *node, tree name,\n \t\t\t\t\t  no_add_attrs, true);\n }\n \n+/* Handle a \"strict_flex_array\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_strict_flex_array_attribute (tree *node, tree name,\n+\t\t\t\t    tree args, int ARG_UNUSED (flags),\n+\t\t\t\t    bool *no_add_attrs)\n+{\n+  tree decl = *node;\n+  tree argval = TREE_VALUE (args);\n+\n+  /* This attribute only applies to field decls of a structure.  */\n+  if (TREE_CODE (decl) != FIELD_DECL)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"%qE attribute may not be specified for %q+D\", name, decl);\n+      *no_add_attrs = true;\n+    }\n+  /* This attribute only applies to field with array type.  */\n+  else if (TREE_CODE (TREE_TYPE (decl)) != ARRAY_TYPE)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"%qE attribute may not be specified for a non-array field\",\n+\t\tname);\n+      *no_add_attrs = true;\n+    }\n+  else if (TREE_CODE (argval) != INTEGER_CST)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"%qE attribute argument not an integer\", name);\n+      *no_add_attrs = true;\n+    }\n+  else if (!tree_fits_uhwi_p (argval) || tree_to_uhwi (argval) > 3)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"%qE attribute argument %qE is not an integer constant\"\n+\t\t\" between 0 and 3\", name, argval);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"weak\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "01d480759ae2d6e74a02999cd09b98c8f8d19a05", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "patch": "@@ -2076,6 +2076,13 @@ fsized-deallocation\n C++ ObjC++ Var(flag_sized_deallocation) Init(-1)\n Enable C++14 sized deallocation support.\n \n+fstrict-flex-arrays\n+C C++ Common Alias(fstrict-flex-arrays=,3,0)\n+\n+fstrict-flex-arrays=\n+C C++ Common Joined RejectNegative UInteger Var(flag_strict_flex_arrays) Init(0) IntegerRange(0,3)\n+-fstrict-flex-arrays=<level>    Control when to treat the trailing array of a structure as a flexible array member for the purposes of accessing the elements of such an array. The default is treating all trailing arrays of structures as flexible array members.\n+\n fsquangle\n C++ ObjC++ WarnRemoved\n "}, {"sha": "193e268f04e319a4a08077a21d11956d8ced79d7", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 121, "deletions": 9, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "patch": "@@ -5034,6 +5034,41 @@ set_array_declarator_inner (struct c_declarator *decl,\n   return decl;\n }\n \n+/* Determine whether TYPE is a ISO C99 flexible array memeber type \"[]\".  */\n+static bool\n+flexible_array_member_type_p (const_tree type)\n+{\n+  if (TREE_CODE (type) == ARRAY_TYPE\n+      && TYPE_SIZE (type) == NULL_TREE\n+      && TYPE_DOMAIN (type) != NULL_TREE\n+      && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) == NULL_TREE)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Determine whether TYPE is a one-element array type \"[1]\".  */\n+static bool\n+one_element_array_type_p (const_tree type)\n+{\n+  if (TREE_CODE (type) != ARRAY_TYPE)\n+    return false;\n+  return integer_zerop (array_type_nelts (type));\n+}\n+\n+/* Determine whether TYPE is a zero-length array type \"[0]\".  */\n+static bool\n+zero_length_array_type_p (const_tree type)\n+{\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    if (tree type_size = TYPE_SIZE_UNIT (type))\n+      if ((integer_zerop (type_size))\n+\t   && TYPE_DOMAIN (type) != NULL_TREE\n+\t   && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) == NULL_TREE)\n+\treturn true;\n+  return false;\n+}\n+\n /* INIT is a constructor that forms DECL's initializer.  If the final\n    element initializes a flexible array field, add the size of that\n    initializer to DECL's size.  */\n@@ -5048,10 +5083,7 @@ add_flexible_array_elts_to_size (tree decl, tree init)\n \n   elt = CONSTRUCTOR_ELTS (init)->last ().value;\n   type = TREE_TYPE (elt);\n-  if (TREE_CODE (type) == ARRAY_TYPE\n-      && TYPE_SIZE (type) == NULL_TREE\n-      && TYPE_DOMAIN (type) != NULL_TREE\n-      && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) == NULL_TREE)\n+  if (flexible_array_member_type_p (type))\n     {\n       complete_array_type (&type, elt, false);\n       DECL_SIZE (decl)\n@@ -8755,6 +8787,81 @@ finish_incomplete_vars (tree incomplete_vars, bool toplevel)\n     }\n }\n \n+\n+/* Determine whether the FIELD_DECL X is a flexible array member according to\n+   the following info:\n+  A. whether the FIELD_DECL X is the last field of the DECL_CONTEXT;\n+  B. whether the FIELD_DECL is an array that is declared as \"[]\", \"[0]\",\n+     or \"[1]\";\n+  C. flag_strict_flex_arrays;\n+  D. the attribute strict_flex_array that is attached to the field\n+     if presenting.\n+  Return TRUE when it's a flexible array member, FALSE otherwise.  */\n+\n+static bool\n+is_flexible_array_member_p (bool is_last_field,\n+\t\t\t    tree x)\n+{\n+  /* If not the last field, return false.  */\n+  if (!is_last_field)\n+    return false;\n+\n+  /* If not an array field, return false.  */\n+  if (TREE_CODE (TREE_TYPE (x)) != ARRAY_TYPE)\n+    return false;\n+\n+  bool is_zero_length_array = zero_length_array_type_p (TREE_TYPE (x));\n+  bool is_one_element_array = one_element_array_type_p (TREE_TYPE (x));\n+  bool is_flexible_array = flexible_array_member_type_p (TREE_TYPE (x));\n+\n+  unsigned int strict_flex_array_level = flag_strict_flex_arrays;\n+\n+  tree attr_strict_flex_array = lookup_attribute (\"strict_flex_array\",\n+\t\t\t\t\t\t  DECL_ATTRIBUTES (x));\n+  /* If there is a strict_flex_array attribute attached to the field,\n+     override the flag_strict_flex_arrays.  */\n+  if (attr_strict_flex_array)\n+    {\n+      /* Get the value of the level first from the attribute.  */\n+      unsigned HOST_WIDE_INT attr_strict_flex_array_level = 0;\n+      gcc_assert (TREE_VALUE (attr_strict_flex_array) != NULL_TREE);\n+      attr_strict_flex_array = TREE_VALUE (attr_strict_flex_array);\n+      gcc_assert (TREE_VALUE (attr_strict_flex_array) != NULL_TREE);\n+      attr_strict_flex_array = TREE_VALUE (attr_strict_flex_array);\n+      gcc_assert (tree_fits_uhwi_p (attr_strict_flex_array));\n+      attr_strict_flex_array_level = tree_to_uhwi (attr_strict_flex_array);\n+\n+      /* The attribute has higher priority than flag_struct_flex_array.  */\n+      strict_flex_array_level = attr_strict_flex_array_level;\n+    }\n+\n+  switch (strict_flex_array_level)\n+    {\n+      case 0:\n+\t/* Default, all trailing arrays are flexible array members.  */\n+\treturn true;\n+      case 1:\n+\t/* Level 1: all \"[1]\", \"[0]\", and \"[]\" are flexible array members.  */\n+\tif (is_one_element_array)\n+\t  return true;\n+\t/* FALLTHROUGH.  */\n+      case 2:\n+\t/* Level 2: all \"[0]\", and \"[]\" are flexible array members.  */\n+\tif (is_zero_length_array)\n+\t  return true;\n+\t/* FALLTHROUGH.  */\n+      case 3:\n+\t/* Level 3: Only \"[]\" are flexible array members.  */\n+\tif (is_flexible_array)\n+\t  return true;\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+    }\n+  return false;\n+}\n+\n+\n /* Fill in the fields of a RECORD_TYPE or UNION_TYPE node, T.\n    LOC is the location of the RECORD_TYPE or UNION_TYPE's definition.\n    FIELDLIST is a chain of FIELD_DECL nodes for the fields.\n@@ -8816,6 +8923,11 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n   bool saw_named_field = false;\n   for (x = fieldlist; x; x = DECL_CHAIN (x))\n     {\n+      /* Whether this field is the last field of the structure or union.\n+\t for UNION, any field is the last field of it.  */\n+      bool is_last_field = (DECL_CHAIN (x) == NULL_TREE)\n+\t\t\t    || (TREE_CODE (t) == UNION_TYPE);\n+\n       if (TREE_TYPE (x) == error_mark_node)\n \tcontinue;\n \n@@ -8854,18 +8966,15 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \tDECL_PACKED (x) = 1;\n \n       /* Detect flexible array member in an invalid context.  */\n-      if (TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE\n-\t  && TYPE_SIZE (TREE_TYPE (x)) == NULL_TREE\n-\t  && TYPE_DOMAIN (TREE_TYPE (x)) != NULL_TREE\n-\t  && TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (x))) == NULL_TREE)\n+      if (flexible_array_member_type_p (TREE_TYPE (x)))\n \t{\n \t  if (TREE_CODE (t) == UNION_TYPE)\n \t    {\n \t      error_at (DECL_SOURCE_LOCATION (x),\n \t\t\t\"flexible array member in union\");\n \t      TREE_TYPE (x) = error_mark_node;\n \t    }\n-\t  else if (DECL_CHAIN (x) != NULL_TREE)\n+\t  else if (!is_last_field)\n \t    {\n \t      error_at (DECL_SOURCE_LOCATION (x),\n \t\t\t\"flexible array member not at end of struct\");\n@@ -8885,6 +8994,9 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \tpedwarn (DECL_SOURCE_LOCATION (x), OPT_Wpedantic,\n \t\t \"invalid use of structure with flexible array member\");\n \n+      /* Set DECL_NOT_FLEXARRAY flag for FIELD_DECL x.  */\n+      DECL_NOT_FLEXARRAY (x) = !is_flexible_array_member_p (is_last_field, x);\n+\n       if (DECL_NAME (x)\n \t  || RECORD_OR_UNION_TYPE_P (TREE_TYPE (x)))\n \tsaw_named_field = true;"}, {"sha": "4d27cebd22ce0a10dc83ccb7e569d81165cc1a82", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "patch": "@@ -5433,6 +5433,7 @@ trees_out::core_bools (tree t)\n       WB (t->decl_common.decl_by_reference_flag);\n       WB (t->decl_common.decl_read_flag);\n       WB (t->decl_common.decl_nonshareable_flag);\n+      WB (t->decl_common.decl_not_flexarray);\n     }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n@@ -5577,6 +5578,7 @@ trees_in::core_bools (tree t)\n       RB (t->decl_common.decl_by_reference_flag);\n       RB (t->decl_common.decl_read_flag);\n       RB (t->decl_common.decl_nonshareable_flag);\n+      RB (t->decl_common.decl_not_flexarray);\n     }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))"}, {"sha": "cfbe32afce9b7647099b4f2d00c25fbffe60e722", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "patch": "@@ -7459,6 +7459,32 @@ This warning can be disabled by @option{-Wno-if-not-aligned}.\n The @code{warn_if_not_aligned} attribute can also be used for types\n (@pxref{Common Type Attributes}.)\n \n+@cindex @code{strict_flex_array} variable attribute\n+@item strict_flex_array (@var{level})\n+The @code{strict_flex_array} attribute should be attached to the trailing\n+array field of a structure.  It controls when to treat the trailing array\n+field of a structure as a flexible array member for the purposes of accessing\n+the elements of such an array.\n+@var{level} must be an integer betwen 0 to 3.\n+\n+@var{level}=0 is the least strict level, all trailing arrays of structures\n+are treated as flexible array members. @var{level}=3 is the strictest level,\n+only when the trailing array is declared as a flexible array member per C99\n+standard onwards (@samp{[]}), it is treated as a flexible array member.\n+\n+There are two more levels in between 0 and 3, which are provided to support\n+older codes that use GCC zero-length array extension (@samp{[0]}) or one-element\n+array as flexible array members (@samp{[1]}):\n+When @var{level} is 1, the trailing array is treated as a flexible array member\n+when it is declared as either @samp{[]}, @samp{[0]}, or @samp{[1]};\n+When @var{level} is 2, the trailing array is treated as a flexible array member\n+when it is declared as either @samp{[]}, or @samp{[0]}.\n+\n+This attribute can be used with or without the @option{-fstrict-flex-arrays}.\n+When both the attribute and the option present at the same time, the level of\n+the strictness for the specific trailing array field is determined by the\n+attribute.\n+\n @item alloc_size (@var{position})\n @itemx alloc_size (@var{position-1}, @var{position-2})\n @cindex @code{alloc_size} variable attribute"}, {"sha": "1eeaec1881073d8578fd5f0e398642c96e47e458", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "patch": "@@ -207,7 +207,8 @@ in the following sections.\n -fopenmp  -fopenmp-simd @gol\n -fpermitted-flt-eval-methods=@var{standard} @gol\n -fplan9-extensions  -fsigned-bitfields  -funsigned-bitfields @gol\n--fsigned-char  -funsigned-char  -fsso-struct=@var{endianness}}\n+-fsigned-char  -funsigned-char -fstrict-flex-arrays[=@var{n}] @gol\n+-fsso-struct=@var{endianness}}\n \n @item C++ Language Options\n @xref{C++ Dialect Options,,Options Controlling C++ Dialect}.\n@@ -2835,6 +2836,31 @@ The type @code{char} is always a distinct type from each of\n @code{signed char} or @code{unsigned char}, even though its behavior\n is always just like one of those two.\n \n+@item -fstrict-flex-arrays\n+@opindex fstrict-flex-arrays\n+@opindex fno-strict-flex-arrays\n+Control when to treat the trailing array of a structure as a flexible array\n+member for the purpose of accessing the elements of such an array.\n+The positive form is equivalent to @option{-fstrict-flex-arrays=3}, which is the\n+strictest.  A trailing array is treated as a flexible array member only when it\n+is declared as a flexible array member per C99 standard onwards.\n+The negative form is equivalent to @option{-fstrict-flex-arrays=0}, which is the\n+least strict.  All trailing arrays of structures are treated as flexible array\n+members.\n+\n+@item -fstrict-flex-arrays=@var{level}\n+@opindex fstrict-flex-arrays=@var{level}\n+Control when to treat the trailing array of a structure as a flexible array\n+member for the purpose of accessing the elements of such an array.  The value\n+of @var{level} controls the level of strictness.\n+\n+The possible values of @var{level} are the same as for the\n+@code{strict_flex_array} attribute (@pxref{Variable Attributes}).\n+\n+You can control this behavior for a specific trailing array field of a\n+structure by using the variable attribute @code{strict_flex_array} attribute\n+(@pxref{Variable Attributes}).\n+\n @item -fsso-struct=@var{endianness}\n @opindex fsso-struct\n Set the default scalar storage order of structures and unions to the"}, {"sha": "58a98250cc4f74d1aaa0541ba4d5c0269c8c3192", "filename": "gcc/print-tree.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Fprint-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Fprint-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.cc?ref=1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "patch": "@@ -517,8 +517,12 @@ print_node (FILE *file, const char *prefix, tree node, int indent,\n \t  fprintf (file, \" align:%d warn_if_not_align:%d\",\n \t\t   DECL_ALIGN (node), DECL_WARN_IF_NOT_ALIGN (node));\n \t  if (code == FIELD_DECL)\n-\t    fprintf (file, \" offset_align \" HOST_WIDE_INT_PRINT_UNSIGNED,\n-\t\t     DECL_OFFSET_ALIGN (node));\n+\t    {\n+\t      fprintf (file, \" offset_align \" HOST_WIDE_INT_PRINT_UNSIGNED,\n+\t\t       DECL_OFFSET_ALIGN (node));\n+\t      fprintf (file, \" decl_not_flexarray: %d\",\n+\t\t       DECL_NOT_FLEXARRAY (node));\n+\t    }\n \n \t  if (code == FUNCTION_DECL && fndecl_built_in_p (node))\n \t    {"}, {"sha": "92fcffe081ff32d5e403fc2ee5a9160c4e47e21e", "filename": "gcc/testsuite/g++.dg/strict-flex-array-1.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fstrict-flex-array-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fstrict-flex-array-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fstrict-flex-array-1.C?ref=1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "patch": "@@ -0,0 +1,31 @@\n+/* testing the correct usage of attribute strict_flex_array.  */   \n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+\n+int x __attribute__ ((strict_flex_array (1))); /* { dg-error \"'strict_flex_array' attribute may not be specified for 'x'\" } */\n+\n+struct trailing {\n+    int a;\n+    int c __attribute ((strict_flex_array)); /* { dg-error \"wrong number of arguments specified for 'strict_flex_array' attribute\" } */\n+};\n+\n+struct trailing_1 {\n+    int a;\n+    int b;\n+    int c __attribute ((strict_flex_array (2))); /* { dg-error \"'strict_flex_array' attribute may not be specified for a non-array field\" } */\n+};\n+\n+extern int d;\n+\n+struct trailing_array_2 {\n+    int a;\n+    int b;\n+    int c[1] __attribute ((strict_flex_array (d))); /* { dg-error \"'strict_flex_array' attribute argument not an integer\" } */\n+};\n+\n+struct trailing_array_3 {\n+    int a;\n+    int b;\n+    int c[0] __attribute ((strict_flex_array (5))); /* { dg-error \"'strict_flex_array' attribute argument '5' is not an integer constant between 0 and 3\" } */\n+};"}, {"sha": "5b8a79363b0a5a9ee1b456de9fa551ea9c11556d", "filename": "gcc/testsuite/gcc.dg/strict-flex-array-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-flex-array-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-flex-array-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-flex-array-1.c?ref=1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "patch": "@@ -0,0 +1,33 @@\n+/* testing the correct usage of attribute strict_flex_array.  */   \n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+\n+int x __attribute__ ((strict_flex_array (1))); /* { dg-error \"'strict_flex_array' attribute may not be specified for 'x'\" } */\n+\n+int [[gnu::strict_flex_array(1)]] x; /* { dg-warning \"'strict_flex_array' attribute does not apply to types\" } */\n+\n+struct trailing {\n+    int a;\n+    int c __attribute ((strict_flex_array)); /* { dg-error \"wrong number of arguments specified for 'strict_flex_array' attribute\" } */\n+};\n+\n+struct trailing_1 {\n+    int a;\n+    int b;\n+    int c __attribute ((strict_flex_array (2))); /* { dg-error \"'strict_flex_array' attribute may not be specified for a non-array field\" } */\n+};\n+\n+extern int d;\n+\n+struct trailing_array_2 {\n+    int a;\n+    int b;\n+    int c[1] __attribute ((strict_flex_array (d))); /* { dg-error \"'strict_flex_array' attribute argument not an integer\" } */\n+};\n+\n+struct trailing_array_3 {\n+    int a;\n+    int b;\n+    int c[0] __attribute ((strict_flex_array (5))); /* { dg-error \"'strict_flex_array' attribute argument '5' is not an integer constant between 0 and 3\" } */\n+};"}, {"sha": "c4f2cea2352327ae7727d8462df0da69ed1c7b09", "filename": "gcc/tree-core.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "patch": "@@ -1827,7 +1827,10 @@ struct GTY(()) tree_decl_common {\n      TYPE_WARN_IF_NOT_ALIGN.  */\n   unsigned int warn_if_not_align : 6;\n \n-  /* 14 bits unused.  */\n+  /* In FIELD_DECL, this is DECL_NOT_FLEXARRAY.  */\n+  unsigned int decl_not_flexarray : 1;\n+\n+  /* 13 bits unused.  */\n \n   /* UID for points-to sets, stable over copying from inlining.  */\n   unsigned int pt_uid;"}, {"sha": "57923da3741e70de132cb6f774a32b39ac9273b2", "filename": "gcc/tree-streamer-in.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Ftree-streamer-in.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Ftree-streamer-in.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.cc?ref=1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "patch": "@@ -261,6 +261,7 @@ unpack_ts_decl_common_value_fields (struct bitpack_d *bp, tree expr)\n       else\n \tSET_DECL_FIELD_ABI_IGNORED (expr, val);\n       expr->decl_common.off_align = bp_unpack_value (bp, 8);\n+      DECL_NOT_FLEXARRAY (expr) = (unsigned) bp_unpack_value (bp, 1);\n     }\n \n   else if (VAR_P (expr))"}, {"sha": "68a2818a9f936e8b1a3d872fd4918801a74da693", "filename": "gcc/tree-streamer-out.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Ftree-streamer-out.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Ftree-streamer-out.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.cc?ref=1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "patch": "@@ -229,6 +229,7 @@ pack_ts_decl_common_value_fields (struct bitpack_d *bp, tree expr)\n       else\n \tbp_pack_value (bp, DECL_FIELD_ABI_IGNORED (expr), 1);\n       bp_pack_value (bp, expr->decl_common.off_align, 8);\n+      bp_pack_value (bp, DECL_NOT_FLEXARRAY (expr), 1);\n     }\n \n   else if (VAR_P (expr))"}, {"sha": "c4ead94aa65ed7206d728058e29aced8744d8c79", "filename": "gcc/tree.cc", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.cc?ref=1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "patch": "@@ -12691,14 +12691,30 @@ array_ref_up_bound (tree exp)\n }\n \n /* Returns true if REF is an array reference, component reference,\n-   or memory reference to an array at the end of a structure.\n-   If this is the case, the array may be allocated larger\n-   than its upper bound implies.  */\n+   or memory reference to an array whose actual size might be larger\n+   than its upper bound implies, there are multiple cases:\n+   A. a ref to a flexible array member at the end of a structure;\n+   B. a ref to an array with a different type against the original decl;\n+      for example:\n \n+   short a[16] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };\n+   (*((char(*)[16])&a[0]))[i+8]\n+\n+   C. a ref to an array that was passed as a parameter;\n+      for example:\n+\n+   int test (uint8_t *p, uint32_t t[1][1], int n) {\n+   for (int i = 0; i < 4; i++, p++)\n+     t[i][0] = ...;\n+\n+   FIXME, the name of this routine need to be changed to be more accurate.  */\n bool\n array_at_struct_end_p (tree ref)\n {\n-  tree atype;\n+  /* the TYPE for this array referece.  */\n+  tree atype = NULL_TREE;\n+  /* the FIELD_DECL for the array field in the containing structure.  */\n+  tree afield_decl = NULL_TREE;\n \n   if (TREE_CODE (ref) == ARRAY_REF\n       || TREE_CODE (ref) == ARRAY_RANGE_REF)\n@@ -12708,7 +12724,10 @@ array_at_struct_end_p (tree ref)\n     }\n   else if (TREE_CODE (ref) == COMPONENT_REF\n \t   && TREE_CODE (TREE_TYPE (TREE_OPERAND (ref, 1))) == ARRAY_TYPE)\n-    atype = TREE_TYPE (TREE_OPERAND (ref, 1));\n+    {\n+      atype = TREE_TYPE (TREE_OPERAND (ref, 1));\n+      afield_decl = TREE_OPERAND (ref, 1);\n+    }\n   else if (TREE_CODE (ref) == MEM_REF)\n     {\n       tree arg = TREE_OPERAND (ref, 0);\n@@ -12720,6 +12739,7 @@ array_at_struct_end_p (tree ref)\n \t  if (tree fld = last_field (argtype))\n \t    {\n \t      atype = TREE_TYPE (fld);\n+\t      afield_decl = fld;\n \t      if (TREE_CODE (atype) != ARRAY_TYPE)\n \t\treturn false;\n \t      if (VAR_P (arg) && DECL_SIZE (fld))\n@@ -12773,13 +12793,16 @@ array_at_struct_end_p (tree ref)\n       ref = TREE_OPERAND (ref, 0);\n     }\n \n-  /* The array now is at struct end.  Treat flexible arrays as\n+  gcc_assert (!afield_decl\n+\t      || (afield_decl && TREE_CODE (afield_decl) == FIELD_DECL));\n+\n+  /* The array now is at struct end.  Treat flexible array member as\n      always subject to extend, even into just padding constrained by\n      an underlying decl.  */\n   if (! TYPE_SIZE (atype)\n       || ! TYPE_DOMAIN (atype)\n       || ! TYPE_MAX_VALUE (TYPE_DOMAIN (atype)))\n-    return true;\n+    return afield_decl ? !DECL_NOT_FLEXARRAY (afield_decl) : true;\n \n   /* If the reference is based on a declared entity, the size of the array\n      is constrained by its given domain.  (Do not trust commons PR/69368).  */\n@@ -12801,22 +12824,22 @@ array_at_struct_end_p (tree ref)\n       if (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (atype))) != INTEGER_CST\n \t  || TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (atype))) != INTEGER_CST\n           || TREE_CODE (TYPE_MIN_VALUE (TYPE_DOMAIN (atype))) != INTEGER_CST)\n-\treturn true;\n+\treturn afield_decl ? !DECL_NOT_FLEXARRAY (afield_decl) : true;\n       if (! get_addr_base_and_unit_offset (ref_to_array, &offset))\n-\treturn true;\n+\treturn afield_decl ? !DECL_NOT_FLEXARRAY (afield_decl) : true;\n \n       /* If at least one extra element fits it is a flexarray.  */\n       if (known_le ((wi::to_offset (TYPE_MAX_VALUE (TYPE_DOMAIN (atype)))\n \t\t     - wi::to_offset (TYPE_MIN_VALUE (TYPE_DOMAIN (atype)))\n \t\t     + 2)\n \t\t    * wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (atype))),\n \t\t    wi::to_offset (DECL_SIZE_UNIT (ref)) - offset))\n-\treturn true;\n+\treturn afield_decl ? !DECL_NOT_FLEXARRAY (afield_decl) : true;\n \n       return false;\n     }\n \n-  return true;\n+  return afield_decl ? !DECL_NOT_FLEXARRAY (afield_decl) : true;\n }\n \n /* Return a tree representing the offset, in bytes, of the field referenced"}, {"sha": "142e9c9d335b72a4fb8bf5f242a5c31807f4b977", "filename": "gcc/tree.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1879e48f3d8595bc9e7f583bbd12df3c6f5c42dc", "patch": "@@ -3005,6 +3005,12 @@ extern void decl_value_expr_insert (tree, tree);\n #define DECL_PADDING_P(NODE) \\\n   (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_3)\n \n+/* Used in a FIELD_DECL to indicate whether this field is not a flexible\n+   array member. This is only valid for the last array type field of a\n+   structure.  */\n+#define DECL_NOT_FLEXARRAY(NODE) \\\n+  (FIELD_DECL_CHECK (NODE)->decl_common.decl_not_flexarray)\n+\n /* A numeric unique identifier for a LABEL_DECL.  The UID allocation is\n    dense, unique within any one function, and may be used to index arrays.\n    If the value is -1, then no UID has been assigned.  */\n@@ -5547,10 +5553,10 @@ extern tree component_ref_field_offset (tree);\n    returns null.  */\n enum struct special_array_member\n   {\n-   none,      /* Not a special array member.  */\n-   int_0,     /* Interior array member with size zero.  */\n-   trail_0,   /* Trailing array member with size zero.  */\n-   trail_1    /* Trailing array member with one element.  */\n+    none,\t/* Not a special array member.  */\n+    int_0,\t/* Interior array member with size zero.  */\n+    trail_0,\t/* Trailing array member with size zero.  */\n+    trail_1\t/* Trailing array member with one element.  */\n   };\n \n /* Return the size of the member referenced by the COMPONENT_REF, using"}]}