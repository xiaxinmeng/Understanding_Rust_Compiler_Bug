{"sha": "56b5041c02bd8ecfddd5e5a373c8a3586a2354ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZiNTA0MWMwMmJkOGVjZmRkZDVlNWEzNzNjOGEzNTg2YTIzNTRhYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-08-07T18:34:29Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-08-07T18:34:29Z"}, "message": "re PR c/69389 (bit field incompatible with OpenMP atomic update)\n\n\tPR c/69389\n\t* gimplify.c (goa_stabilize_expr): Handle BIT_INSERT_EXPR and\n\tBIT_FIELD_REF.\n\n\t* c-omp.c (c_finish_omp_atomic): Handle atomics on bitfields.\n\n\t* testsuite/libgomp.c/pr69389.c: New test.\n\t* testsuite/libgomp.c++/pr69389.C: New test.\n\nFrom-SVN: r250929", "tree": {"sha": "c89ce11c83972621f5a37972d6d1ac9a7b80144e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c89ce11c83972621f5a37972d6d1ac9a7b80144e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2643d17f5a0c6b2c760e9dc9bc23399dbc6aae37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2643d17f5a0c6b2c760e9dc9bc23399dbc6aae37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2643d17f5a0c6b2c760e9dc9bc23399dbc6aae37"}], "stats": {"total": 240, "additions": 231, "deletions": 9}, "files": [{"sha": "e9b90b0ffdf57b509e098aa176c7a1e3af29715e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56b5041c02bd8ecfddd5e5a373c8a3586a2354ab", "patch": "@@ -1,3 +1,9 @@\n+2017-08-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/69389\n+\t* gimplify.c (goa_stabilize_expr): Handle BIT_INSERT_EXPR and\n+\tBIT_FIELD_REF.\n+\n 2017-08-07  Martin Liska  <mliska@suse.cz>\n \n \t* config/m32c/m32c.c: Add include of stringpool.h and attribs.h."}, {"sha": "c27da8a3ed20e8621ca32155320804ed1e1d99fc", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=56b5041c02bd8ecfddd5e5a373c8a3586a2354ab", "patch": "@@ -1,3 +1,8 @@\n+2017-08-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/69389\n+\t* c-omp.c (c_finish_omp_atomic): Handle atomics on bitfields.\n+\n 2017-08-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* c-ada-spec.c (has_nontrivial_methods): Test for FUNCTION_DECL."}, {"sha": "900f5a33943b4ad8abe3c9b3ab7bde8a9b6a2afd", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 81, "deletions": 9, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=56b5041c02bd8ecfddd5e5a373c8a3586a2354ab", "patch": "@@ -181,6 +181,7 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n \t\t     bool test)\n {\n   tree x, type, addr, pre = NULL_TREE;\n+  HOST_WIDE_INT bitpos = 0, bitsize = 0;\n \n   if (lhs == error_mark_node || rhs == error_mark_node\n       || v == error_mark_node || lhs1 == error_mark_node\n@@ -209,6 +210,29 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n     opcode = TRUNC_DIV_EXPR;\n \n   /* ??? Validate that rhs does not overlap lhs.  */\n+  tree blhs = NULL;\n+  if (TREE_CODE (lhs) == COMPONENT_REF\n+      && TREE_CODE (TREE_OPERAND (lhs, 1)) == FIELD_DECL\n+      && DECL_C_BIT_FIELD (TREE_OPERAND (lhs, 1))\n+      && DECL_BIT_FIELD_REPRESENTATIVE (TREE_OPERAND (lhs, 1)))\n+    {\n+      tree field = TREE_OPERAND (lhs, 1);\n+      tree repr = DECL_BIT_FIELD_REPRESENTATIVE (field);\n+      if (tree_fits_uhwi_p (DECL_FIELD_OFFSET (field))\n+\t  && tree_fits_uhwi_p (DECL_FIELD_OFFSET (repr)))\n+\tbitpos = (tree_to_uhwi (DECL_FIELD_OFFSET (field))\n+\t\t  - tree_to_uhwi (DECL_FIELD_OFFSET (repr))) * BITS_PER_UNIT;\n+      else\n+\tbitpos = 0;\n+      bitpos += (tree_to_uhwi (DECL_FIELD_BIT_OFFSET (field))\n+\t\t - tree_to_uhwi (DECL_FIELD_BIT_OFFSET (repr)));\n+      gcc_assert (tree_fits_shwi_p (DECL_SIZE (field)));\n+      bitsize = tree_to_shwi (DECL_SIZE (field));\n+      blhs = lhs;\n+      type = TREE_TYPE (repr);\n+      lhs = build3 (COMPONENT_REF, TREE_TYPE (repr), TREE_OPERAND (lhs, 0),\n+\t\t    repr, TREE_OPERAND (lhs, 2));\n+    }\n \n   /* Take and save the address of the lhs.  From then on we'll reference it\n      via indirection.  */\n@@ -228,28 +252,44 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n       DECL_CONTEXT (var) = current_function_decl;\n       addr = build4 (TARGET_EXPR, TREE_TYPE (addr), var, addr, NULL, NULL);\n     }\n+  tree orig_lhs = lhs;\n   lhs = build_indirect_ref (loc, addr, RO_NULL);\n+  tree new_lhs = lhs;\n \n   if (code == OMP_ATOMIC_READ)\n     {\n       x = build1 (OMP_ATOMIC_READ, type, addr);\n       SET_EXPR_LOCATION (x, loc);\n       OMP_ATOMIC_SEQ_CST (x) = seq_cst;\n+      if (blhs)\n+\tx = build3_loc (loc, BIT_FIELD_REF, TREE_TYPE (blhs), x,\n+\t\t\tbitsize_int (bitsize), bitsize_int (bitpos));\n       return build_modify_expr (loc, v, NULL_TREE, NOP_EXPR,\n \t\t\t\tloc, x, NULL_TREE);\n     }\n \n   /* There are lots of warnings, errors, and conversions that need to happen\n      in the course of interpreting a statement.  Use the normal mechanisms\n      to do this, and then take it apart again.  */\n-  if (swapped)\n+  if (blhs)\n+    {\n+      lhs = build3_loc (loc, BIT_FIELD_REF, TREE_TYPE (blhs), lhs,\n+\t\t\tbitsize_int (bitsize), bitsize_int (bitpos));\n+      if (swapped)\n+\trhs = build_binary_op (loc, opcode, rhs, lhs, 1);\n+      else if (opcode != NOP_EXPR)\n+\trhs = build_binary_op (loc, opcode, lhs, rhs, 1);\n+      opcode = NOP_EXPR;\n+    }\n+  else if (swapped)\n     {\n       rhs = build_binary_op (loc, opcode, rhs, lhs, 1);\n       opcode = NOP_EXPR;\n     }\n   bool save = in_late_binary_op;\n   in_late_binary_op = true;\n-  x = build_modify_expr (loc, lhs, NULL_TREE, opcode, loc, rhs, NULL_TREE);\n+  x = build_modify_expr (loc, blhs ? blhs : lhs, NULL_TREE, opcode,\n+\t\t\t loc, rhs, NULL_TREE);\n   in_late_binary_op = save;\n   if (x == error_mark_node)\n     return error_mark_node;\n@@ -262,6 +302,10 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n   gcc_assert (TREE_CODE (x) == MODIFY_EXPR);\n   rhs = TREE_OPERAND (x, 1);\n \n+  if (blhs)\n+    rhs = build3_loc (loc, BIT_INSERT_EXPR, type, new_lhs,\n+\t\t      rhs, bitsize_int (bitpos));\n+\n   /* Punt the actual generation of atomic operations to common code.  */\n   if (code == OMP_ATOMIC)\n     type = void_type_node;\n@@ -273,8 +317,8 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n      location, just diagnose different variables.  */\n   if (rhs1\n       && VAR_P (rhs1)\n-      && VAR_P (lhs)\n-      && rhs1 != lhs\n+      && VAR_P (orig_lhs)\n+      && rhs1 != orig_lhs\n       && !test)\n     {\n       if (code == OMP_ATOMIC)\n@@ -286,29 +330,57 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n       return error_mark_node;\n     }\n \n+  if (lhs1\n+      && lhs1 != orig_lhs\n+      && TREE_CODE (lhs1) == COMPONENT_REF\n+      && TREE_CODE (TREE_OPERAND (lhs1, 1)) == FIELD_DECL\n+      && DECL_C_BIT_FIELD (TREE_OPERAND (lhs1, 1))\n+      && DECL_BIT_FIELD_REPRESENTATIVE (TREE_OPERAND (lhs1, 1)))\n+    {\n+      tree field = TREE_OPERAND (lhs1, 1);\n+      tree repr = DECL_BIT_FIELD_REPRESENTATIVE (field);\n+      lhs1 = build3 (COMPONENT_REF, TREE_TYPE (repr), TREE_OPERAND (lhs1, 0),\n+\t\t     repr, TREE_OPERAND (lhs1, 2));\n+    }\n+  if (rhs1\n+      && rhs1 != orig_lhs\n+      && TREE_CODE (rhs1) == COMPONENT_REF\n+      && TREE_CODE (TREE_OPERAND (rhs1, 1)) == FIELD_DECL\n+      && DECL_C_BIT_FIELD (TREE_OPERAND (rhs1, 1))\n+      && DECL_BIT_FIELD_REPRESENTATIVE (TREE_OPERAND (rhs1, 1)))\n+    {\n+      tree field = TREE_OPERAND (rhs1, 1);\n+      tree repr = DECL_BIT_FIELD_REPRESENTATIVE (field);\n+      rhs1 = build3 (COMPONENT_REF, TREE_TYPE (repr), TREE_OPERAND (rhs1, 0),\n+\t\t     repr, TREE_OPERAND (rhs1, 2));\n+    }\n+\n   if (code != OMP_ATOMIC)\n     {\n       /* Generally it is hard to prove lhs1 and lhs are the same memory\n \t location, just diagnose different variables.  */\n-      if (lhs1 && VAR_P (lhs1) && VAR_P (lhs))\n+      if (lhs1 && VAR_P (lhs1) && VAR_P (orig_lhs))\n \t{\n-\t  if (lhs1 != lhs && !test)\n+\t  if (lhs1 != orig_lhs && !test)\n \t    {\n \t      error_at (loc, \"%<#pragma omp atomic capture%> uses two \"\n \t\t\t     \"different variables for memory\");\n \t      return error_mark_node;\n \t    }\n \t}\n+      if (blhs)\n+\tx = build3_loc (loc, BIT_FIELD_REF, TREE_TYPE (blhs), x,\n+\t\t\tbitsize_int (bitsize), bitsize_int (bitpos));\n       x = build_modify_expr (loc, v, NULL_TREE, NOP_EXPR,\n \t\t\t     loc, x, NULL_TREE);\n-      if (rhs1 && rhs1 != lhs)\n+      if (rhs1 && rhs1 != orig_lhs)\n \t{\n \t  tree rhs1addr = build_unary_op (loc, ADDR_EXPR, rhs1, false);\n \t  if (rhs1addr == error_mark_node)\n \t    return error_mark_node;\n \t  x = omit_one_operand_loc (loc, type, x, rhs1addr);\n \t}\n-      if (lhs1 && lhs1 != lhs)\n+      if (lhs1 && lhs1 != orig_lhs)\n \t{\n \t  tree lhs1addr = build_unary_op (loc, ADDR_EXPR, lhs1, false);\n \t  if (lhs1addr == error_mark_node)\n@@ -323,7 +395,7 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n \t    }\n \t}\n     }\n-  else if (rhs1 && rhs1 != lhs)\n+  else if (rhs1 && rhs1 != orig_lhs)\n     {\n       tree rhs1addr = build_unary_op (loc, ADDR_EXPR, rhs1, false);\n       if (rhs1addr == error_mark_node)"}, {"sha": "ed2ec646da2ec451f5879d62c5b7fab01fa6cb44", "filename": "gcc/gimplify.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=56b5041c02bd8ecfddd5e5a373c8a3586a2354ab", "patch": "@@ -10825,6 +10825,7 @@ goa_stabilize_expr (tree *expr_p, gimple_seq *pre_p, tree lhs_addr,\n \tcase TRUTH_AND_EXPR:\n \tcase TRUTH_OR_EXPR:\n \tcase TRUTH_XOR_EXPR:\n+\tcase BIT_INSERT_EXPR:\n \t  saw_lhs |= goa_stabilize_expr (&TREE_OPERAND (expr, 1), pre_p,\n \t\t\t\t\t lhs_addr, lhs_var);\n \t  /* FALLTHRU */\n@@ -10843,6 +10844,11 @@ goa_stabilize_expr (tree *expr_p, gimple_seq *pre_p, tree lhs_addr,\n \t  break;\n \t}\n       break;\n+    case tcc_reference:\n+      if (TREE_CODE (expr) == BIT_FIELD_REF)\n+\tsaw_lhs |= goa_stabilize_expr (&TREE_OPERAND (expr, 0), pre_p,\n+\t\t\t\t       lhs_addr, lhs_var);\n+      break;\n     default:\n       break;\n     }"}, {"sha": "f17a17b138d8b29a336665b589d8bf9c05a598fb", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=56b5041c02bd8ecfddd5e5a373c8a3586a2354ab", "patch": "@@ -1,3 +1,9 @@\n+2017-08-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/69389\n+\t* testsuite/libgomp.c/pr69389.c: New test.\n+\t* testsuite/libgomp.c++/pr69389.C: New test.\n+\n 2017-08-07  Tom de Vries  <tom@codesourcery.com>\n \n \tPR middle-end/78266"}, {"sha": "9fcb0ffc6d0cbd296e66448828256cc175a7aeca", "filename": "libgomp/testsuite/libgomp.c++/pr69389.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr69389.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr69389.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr69389.C?ref=56b5041c02bd8ecfddd5e5a373c8a3586a2354ab", "patch": "@@ -0,0 +1,3 @@\n+// PR c/69389\n+\n+#include \"../libgomp.c/pr69389.c\""}, {"sha": "07faff46f403c32039e995c1d299bfdacb1134e5", "filename": "libgomp/testsuite/libgomp.c/pr69389.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr69389.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b5041c02bd8ecfddd5e5a373c8a3586a2354ab/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr69389.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr69389.c?ref=56b5041c02bd8ecfddd5e5a373c8a3586a2354ab", "patch": "@@ -0,0 +1,124 @@\n+/* PR c/69389 */\n+\n+struct S { unsigned int a : 10; unsigned int b : 4; unsigned int c : 18; } s = { 210, 11, 1235 };\n+\n+unsigned int\n+f1 (void)\n+{\n+  unsigned int v;\n+  #pragma omp atomic read\n+  v = s.b;\n+  return v;\n+}\n+\n+void\n+f2 (unsigned int v)\n+{\n+  #pragma omp atomic write\n+  s.b = v;\n+}\n+\n+void\n+f3 (void)\n+{\n+  #pragma omp atomic\n+  s.b |= 1;\n+}\n+\n+int\n+f4 (void)\n+{\n+  int v;\n+  #pragma omp atomic capture\n+  v = s.b += 8;\n+  return v;\n+}\n+\n+int\n+f5 (void)\n+{\n+  int v;\n+  #pragma omp atomic capture\n+  {\n+    v = s.b;\n+    s.b -= 4;\n+  }\n+  return v;\n+}\n+\n+void\n+f6 (void)\n+{\n+  #pragma omp atomic\n+  s.b = s.b & 7;\n+}\n+\n+void\n+f7 (void)\n+{\n+  #pragma omp atomic\n+  s.b = ~7 & s.b;\n+}\n+\n+int\n+f8 (void)\n+{\n+  int v;\n+  #pragma omp atomic capture\n+  v = s.b = 8 + s.b;\n+  return v;\n+}\n+\n+int\n+f9 (void)\n+{\n+  int v;\n+  #pragma omp atomic capture\n+  {\n+    v = s.b;\n+    s.b = s.b - 4;\n+  }\n+  return v;\n+}\n+\n+int\n+main ()\n+{\n+  if (f1 () != 11)\n+    __builtin_abort ();\n+  f2 (4);\n+  if (s.a != 210 || s.b != 4 || s.c != 1235)\n+    __builtin_abort ();\n+  s.a = 813;\n+  s.c = 31532;\n+  if (f1 () != 4)\n+    __builtin_abort ();\n+  f3 ();\n+  if (f1 () != 5)\n+    __builtin_abort ();\n+  if (s.a != 813 || s.b != 5 || s.c != 31532)\n+    __builtin_abort ();\n+  if (f4 () != 13)\n+    __builtin_abort ();\n+  if (f1 () != 13)\n+    __builtin_abort ();\n+  f2 (14);\n+  if (s.a != 813 || s.b != 14 || s.c != 31532)\n+    __builtin_abort ();\n+  if (f5 () != 14)\n+    __builtin_abort ();\n+  if (f1 () != 10 || s.a != 813 || s.b != 10 || s.c != 31532)\n+    __builtin_abort ();\n+  f6 ();\n+  if (f1 () != 2)\n+    __builtin_abort ();\n+  f2 (15);\n+  f7 ();\n+  if (f1 () != 8)\n+    __builtin_abort ();\n+  if (f8 () != 0 || s.a != 813 || s.b != 0 || s.c != 31532)\n+    __builtin_abort ();\n+  if (f9 () != 0 || s.a != 813 || s.b != 12 || s.c != 31532)\n+    __builtin_abort ();\n+  return 0;\n+}"}]}