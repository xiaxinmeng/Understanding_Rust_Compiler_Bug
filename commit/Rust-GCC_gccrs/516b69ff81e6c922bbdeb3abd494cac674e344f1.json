{"sha": "516b69ff81e6c922bbdeb3abd494cac674e344f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE2YjY5ZmY4MWU2YzkyMmJiZGViM2FiZDQ5NGNhYzY3NGUzNDRmMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-10-17T22:34:54Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-10-17T22:34:54Z"}, "message": "com.h: Remove FFECOM_targetCURRENT...\n\n        * com.h: Remove FFECOM_targetCURRENT, FFECOM_ONEPASS, BUILT_FOR_270,\n        BUILT_FOR_280, FFECOM_GCC_INCLUDE, all derivitive defines, and all\n        related conditional compilation directives.\n        * bad.c, bld.c, bld.h, com.c, equiv.c, equiv.h, global.h, intdoc.c,\n        intrin.c, intrin.h, lex.c, parse.c, sta.c, std.c, ste.c, ste.h, stt.c,\n        stt.h, stw.h, symbol.c, symbol.h, target.h, top.c: Likewise.\n\nFrom-SVN: r46324", "tree": {"sha": "536405ac348d20d3d1f620d763c973351c594cf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/536405ac348d20d3d1f620d763c973351c594cf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/516b69ff81e6c922bbdeb3abd494cac674e344f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/516b69ff81e6c922bbdeb3abd494cac674e344f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/516b69ff81e6c922bbdeb3abd494cac674e344f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/516b69ff81e6c922bbdeb3abd494cac674e344f1/comments", "author": null, "committer": null, "parents": [{"sha": "5bed56d982200550d5e8c45b217b071bfae9be14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bed56d982200550d5e8c45b217b071bfae9be14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bed56d982200550d5e8c45b217b071bfae9be14"}], "stats": {"total": 8144, "additions": 1575, "deletions": 6569}, "files": [{"sha": "b064088ac204f33d90f3c7823f8331dcd8d9609a", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -1,3 +1,12 @@\n+2001-10-17  Richard Henderson  <rth@redhat.com>\n+\n+\t* com.h: Remove FFECOM_targetCURRENT, FFECOM_ONEPASS, BUILT_FOR_270,\n+\tBUILT_FOR_280, FFECOM_GCC_INCLUDE, all derivitive defines, and all\n+\trelated conditional compilation directives.\n+\t* bad.c, bld.c, bld.h, com.c, equiv.c, equiv.h, global.h, intdoc.c,\n+\tintrin.c, intrin.h, lex.c, parse.c, sta.c, std.c, ste.c, ste.h, stt.c,\n+\tstt.h, stw.h, symbol.c, symbol.h, target.h, top.c: Likewise.\n+\n 2001-10-17  Richard Henderson  <rth@redhat.com>\n \n \t* Make-lang.in (f/com.o): Depend on langhooks.h."}, {"sha": "67eade03cbdcfdc12858e8dd4b26be57e04dd923", "filename": "gcc/f/bad.c", "status": "modified", "additions": 33, "deletions": 44, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fbad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fbad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbad.c?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -182,44 +182,40 @@ ffebad_start_ (bool lex_override, ffebad errnum, ffebadSeverity sev,\n       ffebad_message_ = message;\n     }\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n-  {\n-    switch (ffebad_severity_)\n-      {\t\t\t\t/* Tell toplev.c about this message. */\n-      case FFEBAD_severityINFORMATIONAL:\n-      case FFEBAD_severityTRIVIAL:\n-\tif (inhibit_warnings)\n-\t  {\t\t\t/* User wants no warnings. */\n-\t    ffebad_is_temp_inhibited_ = TRUE;\n-\t    return FALSE;\n-\t  }\n-\t/* Fall through.  */\n-      case FFEBAD_severityWARNING:\n-      case FFEBAD_severityPECULIAR:\n-      case FFEBAD_severityPEDANTIC:\n-\tif ((ffebad_severity_ != FFEBAD_severityPEDANTIC)\n-\t    || !flag_pedantic_errors)\n-\t  {\n-\t    if (count_error (1) == 0)\n-\t      {\t\t\t/* User wants no warnings. */\n-\t\tffebad_is_temp_inhibited_ = TRUE;\n-\t\treturn FALSE;\n-\t      }\n-\t    break;\n-\t  }\n-\t/* Fall through (PEDANTIC && flag_pedantic_errors).  */\n-      case FFEBAD_severityFATAL:\n-      case FFEBAD_severityWEIRD:\n-      case FFEBAD_severitySEVERE:\n-      case FFEBAD_severityDISASTER:\n-\tcount_error (0);\n-\tbreak;\n+  switch (ffebad_severity_)\n+    {\t\t\t\t/* Tell toplev.c about this message. */\n+    case FFEBAD_severityINFORMATIONAL:\n+    case FFEBAD_severityTRIVIAL:\n+      if (inhibit_warnings)\n+\t{\t\t\t/* User wants no warnings. */\n+\t  ffebad_is_temp_inhibited_ = TRUE;\n+\t  return FALSE;\n+\t}\n+      /* Fall through.  */\n+    case FFEBAD_severityWARNING:\n+    case FFEBAD_severityPECULIAR:\n+    case FFEBAD_severityPEDANTIC:\n+      if ((ffebad_severity_ != FFEBAD_severityPEDANTIC)\n+\t  || !flag_pedantic_errors)\n+\t{\n+\t  if (count_error (1) == 0)\n+\t    {\t\t\t/* User wants no warnings. */\n+\t      ffebad_is_temp_inhibited_ = TRUE;\n+\t      return FALSE;\n+\t    }\n+\t  break;\n+\t}\n+      /* Fall through (PEDANTIC && flag_pedantic_errors).  */\n+    case FFEBAD_severityFATAL:\n+    case FFEBAD_severityWEIRD:\n+    case FFEBAD_severitySEVERE:\n+    case FFEBAD_severityDISASTER:\n+      count_error (0);\n+      break;\n \n-      default:\n-\tbreak;\n-      }\n-  }\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n+    default:\n+      break;\n+    }\n \n   ffebad_is_temp_inhibited_ = FALSE;\n   ffebad_errnum_ = errnum;\n@@ -420,20 +416,13 @@ ffebad_finish ()\n \t{\n \t  if (bi != 0)\n \t    fputc ('\\n', stderr);\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n \t  report_error_function (fn);\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \t  fprintf (stderr,\n-#if 0\n-\t\t   \"Line %\" ffewhereLineNumber_f \"u of %s:\\n   %s\\n   %s%c\",\n-\t\t   rn, fn,\n-#else\n \t\t   /* the trailing space on the <file>:<line>: line\n \t\t      fools emacs19 compilation mode into finding the\n \t\t      report */\n \t\t   \"%s:%\" ffewhereLineNumber_f \"u: %s\\n   %s\\n   %s%c\",\n \t\t   fn, rn,\n-#endif\n \t\t   s,\n \t\t   ffewhere_line_content (l),\n \t\t   &spaces[cn > MAX_SPACES ? 0 : MAX_SPACES - cn + 4],"}, {"sha": "41a79d6488c1f6037ae65195132ecedb6e063730", "filename": "gcc/f/bld.c", "status": "modified", "additions": 7, "deletions": 1278, "changes": 1285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fbld.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fbld.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbld.c?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -438,433 +438,6 @@ ffebld_constant_cmp (ffebldConstant c1, ffebldConstant c2)\n     }\n }\n \n-/* ffebld_constant_dump -- Display summary of constant's contents\n-\n-   ffebldConstant c;\n-   ffebld_constant_dump(c);\n-\n-   Displays the constant in summary form.  */\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void\n-ffebld_constant_dump (ffebldConstant c)\n-{\n-  switch (ffebld_constant_type (c))\n-    {\n-#if FFETARGET_okINTEGER1\n-    case FFEBLD_constINTEGER1:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeINTEGER,\n-\t\t\t  FFEINFO_kindtypeINTEGER1);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\tFFEINFO_basictypeINTEGER, FFEINFO_kindtypeINTEGER1);\n-      break;\n-#endif\n-\n-#if FFETARGET_okINTEGER2\n-    case FFEBLD_constINTEGER2:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeINTEGER,\n-\t\t\t  FFEINFO_kindtypeINTEGER2);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\tFFEINFO_basictypeINTEGER, FFEINFO_kindtypeINTEGER2);\n-      break;\n-#endif\n-\n-#if FFETARGET_okINTEGER3\n-    case FFEBLD_constINTEGER3:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeINTEGER,\n-\t\t\t  FFEINFO_kindtypeINTEGER3);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\tFFEINFO_basictypeINTEGER, FFEINFO_kindtypeINTEGER3);\n-      break;\n-#endif\n-\n-#if FFETARGET_okINTEGER4\n-    case FFEBLD_constINTEGER4:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeINTEGER,\n-\t\t\t  FFEINFO_kindtypeINTEGER4);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\tFFEINFO_basictypeINTEGER, FFEINFO_kindtypeINTEGER4);\n-      break;\n-#endif\n-\n-#if FFETARGET_okINTEGER5\n-    case FFEBLD_constINTEGER5:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeINTEGER,\n-\t\t\t  FFEINFO_kindtypeINTEGER5);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\tFFEINFO_basictypeINTEGER, FFEINFO_kindtypeINTEGER5);\n-      break;\n-#endif\n-\n-#if FFETARGET_okINTEGER6\n-    case FFEBLD_constINTEGER6:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeINTEGER,\n-\t\t\t  FFEINFO_kindtypeINTEGER6);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\tFFEINFO_basictypeINTEGER, FFEINFO_kindtypeINTEGER6);\n-      break;\n-#endif\n-\n-#if FFETARGET_okINTEGER7\n-    case FFEBLD_constINTEGER7:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeINTEGER,\n-\t\t\t  FFEINFO_kindtypeINTEGER7);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\tFFEINFO_basictypeINTEGER, FFEINFO_kindtypeINTEGER7);\n-      break;\n-#endif\n-\n-#if FFETARGET_okINTEGER8\n-    case FFEBLD_constINTEGER8:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeINTEGER,\n-\t\t\t  FFEINFO_kindtypeINTEGER8);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\tFFEINFO_basictypeINTEGER, FFEINFO_kindtypeINTEGER8);\n-      break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL1\n-    case FFEBLD_constLOGICAL1:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeLOGICAL,\n-\t\t\t  FFEINFO_kindtypeLOGICAL1);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\tFFEINFO_basictypeLOGICAL, FFEINFO_kindtypeLOGICAL1);\n-      break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL2\n-    case FFEBLD_constLOGICAL2:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeLOGICAL,\n-\t\t\t  FFEINFO_kindtypeLOGICAL2);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\tFFEINFO_basictypeLOGICAL, FFEINFO_kindtypeLOGICAL2);\n-      break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL3\n-    case FFEBLD_constLOGICAL3:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeLOGICAL,\n-\t\t\t  FFEINFO_kindtypeLOGICAL3);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\tFFEINFO_basictypeLOGICAL, FFEINFO_kindtypeLOGICAL3);\n-      break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL4\n-    case FFEBLD_constLOGICAL4:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeLOGICAL,\n-\t\t\t  FFEINFO_kindtypeLOGICAL4);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\tFFEINFO_basictypeLOGICAL, FFEINFO_kindtypeLOGICAL4);\n-      break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL5\n-    case FFEBLD_constLOGICAL5:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeLOGICAL,\n-\t\t\t  FFEINFO_kindtypeLOGICAL5);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\tFFEINFO_basictypeLOGICAL, FFEINFO_kindtypeLOGICAL5);\n-      break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL6\n-    case FFEBLD_constLOGICAL6:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeLOGICAL,\n-\t\t\t  FFEINFO_kindtypeLOGICAL6);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\tFFEINFO_basictypeLOGICAL, FFEINFO_kindtypeLOGICAL6);\n-      break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL7\n-    case FFEBLD_constLOGICAL7:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeLOGICAL,\n-\t\t\t  FFEINFO_kindtypeLOGICAL7);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\tFFEINFO_basictypeLOGICAL, FFEINFO_kindtypeLOGICAL7);\n-      break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL8\n-    case FFEBLD_constLOGICAL8:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeLOGICAL,\n-\t\t\t  FFEINFO_kindtypeLOGICAL8);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\tFFEINFO_basictypeLOGICAL, FFEINFO_kindtypeLOGICAL8);\n-      break;\n-#endif\n-\n-#if FFETARGET_okREAL1\n-    case FFEBLD_constREAL1:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeREAL,\n-\t\t\t  FFEINFO_kindtypeREAL1);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\t      FFEINFO_basictypeREAL, FFEINFO_kindtypeREAL1);\n-      break;\n-#endif\n-\n-#if FFETARGET_okREAL2\n-    case FFEBLD_constREAL2:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeREAL,\n-\t\t\t  FFEINFO_kindtypeREAL2);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\t      FFEINFO_basictypeREAL, FFEINFO_kindtypeREAL2);\n-      break;\n-#endif\n-\n-#if FFETARGET_okREAL3\n-    case FFEBLD_constREAL3:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeREAL,\n-\t\t\t  FFEINFO_kindtypeREAL3);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\t      FFEINFO_basictypeREAL, FFEINFO_kindtypeREAL3);\n-      break;\n-#endif\n-\n-#if FFETARGET_okREAL4\n-    case FFEBLD_constREAL4:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeREAL,\n-\t\t\t  FFEINFO_kindtypeREAL4);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\t      FFEINFO_basictypeREAL, FFEINFO_kindtypeREAL4);\n-      break;\n-#endif\n-\n-#if FFETARGET_okREAL5\n-    case FFEBLD_constREAL5:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeREAL,\n-\t\t\t  FFEINFO_kindtypeREAL5);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\t      FFEINFO_basictypeREAL, FFEINFO_kindtypeREAL5);\n-      break;\n-#endif\n-\n-#if FFETARGET_okREAL6\n-    case FFEBLD_constREAL6:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeREAL,\n-\t\t\t  FFEINFO_kindtypeREAL6);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\t      FFEINFO_basictypeREAL, FFEINFO_kindtypeREAL6);\n-      break;\n-#endif\n-\n-#if FFETARGET_okREAL7\n-    case FFEBLD_constREAL7:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeREAL,\n-\t\t\t  FFEINFO_kindtypeREAL7);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\t      FFEINFO_basictypeREAL, FFEINFO_kindtypeREAL7);\n-      break;\n-#endif\n-\n-#if FFETARGET_okREAL8\n-    case FFEBLD_constREAL8:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeREAL,\n-\t\t\t  FFEINFO_kindtypeREAL8);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\t      FFEINFO_basictypeREAL, FFEINFO_kindtypeREAL8);\n-      break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX1\n-    case FFEBLD_constCOMPLEX1:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeCOMPLEX,\n-\t\t\t  FFEINFO_kindtypeREAL1);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\t   FFEINFO_basictypeCOMPLEX, FFEINFO_kindtypeREAL1);\n-      break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX2\n-    case FFEBLD_constCOMPLEX2:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeCOMPLEX,\n-\t\t\t  FFEINFO_kindtypeREAL2);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\t   FFEINFO_basictypeCOMPLEX, FFEINFO_kindtypeREAL2);\n-      break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX3\n-    case FFEBLD_constCOMPLEX3:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeCOMPLEX,\n-\t\t\t  FFEINFO_kindtypeREAL3);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\t   FFEINFO_basictypeCOMPLEX, FFEINFO_kindtypeREAL3);\n-      break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX4\n-    case FFEBLD_constCOMPLEX4:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeCOMPLEX,\n-\t\t\t  FFEINFO_kindtypeREAL4);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\t   FFEINFO_basictypeCOMPLEX, FFEINFO_kindtypeREAL4);\n-      break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX5\n-    case FFEBLD_constCOMPLEX5:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeCOMPLEX,\n-\t\t\t  FFEINFO_kindtypeREAL5);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\t   FFEINFO_basictypeCOMPLEX, FFEINFO_kindtypeREAL5);\n-      break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX6\n-    case FFEBLD_constCOMPLEX6:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeCOMPLEX,\n-\t\t\t  FFEINFO_kindtypeREAL6);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\t   FFEINFO_basictypeCOMPLEX, FFEINFO_kindtypeREAL6);\n-      break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX7\n-    case FFEBLD_constCOMPLEX7:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeCOMPLEX,\n-\t\t\t  FFEINFO_kindtypeREAL7);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\t   FFEINFO_basictypeCOMPLEX, FFEINFO_kindtypeREAL7);\n-      break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX8\n-    case FFEBLD_constCOMPLEX8:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeCOMPLEX,\n-\t\t\t  FFEINFO_kindtypeREAL8);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t\t   FFEINFO_basictypeCOMPLEX, FFEINFO_kindtypeREAL8);\n-      break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER1\n-    case FFEBLD_constCHARACTER1:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeCHARACTER,\n-\t\t\t  FFEINFO_kindtypeCHARACTER1);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t    FFEINFO_basictypeCHARACTER, FFEINFO_kindtypeCHARACTER1);\n-      break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER2\n-    case FFEBLD_constCHARACTER2:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeCHARACTER,\n-\t\t\t  FFEINFO_kindtypeCHARACTER2);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t    FFEINFO_basictypeCHARACTER, FFEINFO_kindtypeCHARACTER2);\n-      break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER3\n-    case FFEBLD_constCHARACTER3:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeCHARACTER,\n-\t\t\t  FFEINFO_kindtypeCHARACTER3);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t    FFEINFO_basictypeCHARACTER, FFEINFO_kindtypeCHARACTER3);\n-      break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER4\n-    case FFEBLD_constCHARACTER4:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeCHARACTER,\n-\t\t\t  FFEINFO_kindtypeCHARACTER4);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t    FFEINFO_basictypeCHARACTER, FFEINFO_kindtypeCHARACTER4);\n-      break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER5\n-    case FFEBLD_constCHARACTER5:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeCHARACTER,\n-\t\t\t  FFEINFO_kindtypeCHARACTER5);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t    FFEINFO_basictypeCHARACTER, FFEINFO_kindtypeCHARACTER5);\n-      break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER6\n-    case FFEBLD_constCHARACTER6:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeCHARACTER,\n-\t\t\t  FFEINFO_kindtypeCHARACTER6);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t    FFEINFO_basictypeCHARACTER, FFEINFO_kindtypeCHARACTER6);\n-      break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER7\n-    case FFEBLD_constCHARACTER7:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeCHARACTER,\n-\t\t\t  FFEINFO_kindtypeCHARACTER7);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t    FFEINFO_basictypeCHARACTER, FFEINFO_kindtypeCHARACTER7);\n-      break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER8\n-    case FFEBLD_constCHARACTER8:\n-      ffebld_dump_prefix (dmpout, FFEINFO_basictypeCHARACTER,\n-\t\t\t  FFEINFO_kindtypeCHARACTER8);\n-      ffebld_constantunion_dump (ffebld_constant_union (c),\n-\t\t    FFEINFO_basictypeCHARACTER, FFEINFO_kindtypeCHARACTER8);\n-      break;\n-#endif\n-\n-    case FFEBLD_constHOLLERITH:\n-      fprintf (dmpout, \"H%\" ffetargetHollerithSize_f \"u/\",\n-\t       ffebld_constant_hollerith (c).length);\n-      ffetarget_print_hollerith (dmpout, ffebld_constant_hollerith (c));\n-      break;\n-\n-    case FFEBLD_constBINARY_MIL:\n-      fprintf (dmpout, \"BM/\");\n-      ffetarget_print_binarymil (dmpout, ffebld_constant_typeless (c));\n-      break;\n-\n-    case FFEBLD_constBINARY_VXT:\n-      fprintf (dmpout, \"BV/\");\n-      ffetarget_print_binaryvxt (dmpout, ffebld_constant_typeless (c));\n-      break;\n-\n-    case FFEBLD_constOCTAL_MIL:\n-      fprintf (dmpout, \"OM/\");\n-      ffetarget_print_octalmil (dmpout, ffebld_constant_typeless (c));\n-      break;\n-\n-    case FFEBLD_constOCTAL_VXT:\n-      fprintf (dmpout, \"OV/\");\n-      ffetarget_print_octalvxt (dmpout, ffebld_constant_typeless (c));\n-      break;\n-\n-    case FFEBLD_constHEX_X_MIL:\n-      fprintf (dmpout, \"XM/\");\n-      ffetarget_print_hexxmil (dmpout, ffebld_constant_typeless (c));\n-      break;\n-\n-    case FFEBLD_constHEX_X_VXT:\n-      fprintf (dmpout, \"XV/\");\n-      ffetarget_print_hexxvxt (dmpout, ffebld_constant_typeless (c));\n-      break;\n-\n-    case FFEBLD_constHEX_Z_MIL:\n-      fprintf (dmpout, \"ZM/\");\n-      ffetarget_print_hexzmil (dmpout, ffebld_constant_typeless (c));\n-      break;\n-\n-    case FFEBLD_constHEX_Z_VXT:\n-      fprintf (dmpout, \"ZV/\");\n-      ffetarget_print_hexzvxt (dmpout, ffebld_constant_typeless (c));\n-      break;\n-\n-    default:\n-      assert (\"bad constant type\" == NULL);\n-      fprintf (dmpout, \"?/?\");\n-      break;\n-    }\n-}\n-#endif\n-\n /* ffebld_constant_is_magical -- Determine if integer is \"magical\"\n \n    ffebldConstant c;\n@@ -1991,87 +1564,17 @@ ffebld_constant_new_typeless_val (ffebldConst type, ffetargetTypeless val)\n   return nc;\n }\n \n-/* ffebld_constantarray_dump -- Display summary of array's contents\n-\n-   ffebldConstantArray a;\n-   ffeinfoBasictype bt;\n-   ffeinfoKindtype kt;\n-   ffetargetOffset size;\n-   ffebld_constant_dump(a,bt,kt,size,NULL);\n+/* ffebld_constantarray_get -- Get a value from an array of constants\n \n-   Displays the constant array in summary form.\t The fifth argument, if\n-   supplied, is an ffebit object that is consulted as to whether the\n-   constant at a particular offset is valid.  */\n+   See prototype.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void\n-ffebld_constantarray_dump (ffebldConstantArray array, ffeinfoBasictype bt,\n-\t\t      ffeinfoKindtype kt, ffetargetOffset size, ffebit bits)\n+ffebldConstantUnion\n+ffebld_constantarray_get (ffebldConstantArray array, ffeinfoBasictype bt,\n+\t\t\t  ffeinfoKindtype kt, ffetargetOffset offset)\n {\n-  ffetargetOffset i;\n-  ffebitCount j;\n-\n-  ffebld_dump_prefix (dmpout, bt, kt);\n-\n-  fprintf (dmpout, \"\\\\(\");\n+  ffebldConstantUnion u;\n \n-  if (bits == NULL)\n-    {\n-      for (i = 0; i < size; ++i)\n-\t{\n-\t  ffebld_constantunion_dump (ffebld_constantarray_get (array, bt, kt, i), bt,\n-\t\t\t\t     kt);\n-\t  if (i != size - 1)\n-\t    fputc (',', dmpout);\n-\t}\n-    }\n-  else\n-    {\n-      bool value;\n-      ffebitCount length;\n-      ffetargetOffset offset = 0;\n-\n-      do\n-\t{\n-\t  ffebit_test (bits, offset, &value, &length);\n-\t  if (value && (length != 0))\n-\t    {\n-\t      if (length == 1)\n-\t\tfprintf (dmpout, \"[%\" ffetargetOffset_f \"d]:\", offset);\n-\t      else\n-\t\tfprintf (dmpout,\n-\t\t      \"[%\" ffetargetOffset_f \"u..%\" ffetargetOffset_f \"d]:\",\n-\t\t\t offset, offset + (ffetargetOffset) length - 1);\n-\t      for (j = 0; j < length; ++j, ++offset)\n-\t\t{\n-\t\t  ffebld_constantunion_dump (ffebld_constantarray_get (array, bt, kt,\n-\t\t\t\t\t\t\t   offset), bt, kt);\n-\t\t  if (j != length - 1)\n-\t\t    fputc (',', dmpout);\n-\t\t}\n-\t      fprintf (dmpout, \";\");\n-\t    }\n-\t  else\n-\t    offset += length;\n-\t}\n-      while (length != 0);\n-    }\n-  fprintf (dmpout, \"\\\\)\");\n-\n-}\n-#endif\n-\n-/* ffebld_constantarray_get -- Get a value from an array of constants\n-\n-   See prototype.  */\n-\n-ffebldConstantUnion\n-ffebld_constantarray_get (ffebldConstantArray array, ffeinfoBasictype bt,\n-\t\t\t  ffeinfoKindtype kt, ffetargetOffset offset)\n-{\n-  ffebldConstantUnion u;\n-\n-  switch (bt)\n+  switch (bt)\n     {\n     case FFEINFO_basictypeINTEGER:\n       switch (kt)\n@@ -4408,780 +3911,6 @@ ffebld_constantarray_put (ffebldConstantArray array, ffeinfoBasictype bt,\n     }\n }\n \n-/* ffebld_constantunion_dump -- Dump a constant\n-\n-   See prototype.  */\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void\n-ffebld_constantunion_dump (ffebldConstantUnion u, ffeinfoBasictype bt,\n-\t\t\t   ffeinfoKindtype kt)\n-{\n-  switch (bt)\n-    {\n-    case FFEINFO_basictypeINTEGER:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okINTEGER1\n-\tcase FFEINFO_kindtypeINTEGER1:\n-\t  ffetarget_print_integer1 (dmpout, u.integer1);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER2\n-\tcase FFEINFO_kindtypeINTEGER2:\n-\t  ffetarget_print_integer2 (dmpout, u.integer2);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER3\n-\tcase FFEINFO_kindtypeINTEGER3:\n-\t  ffetarget_print_integer3 (dmpout, u.integer3);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER4\n-\tcase FFEINFO_kindtypeINTEGER4:\n-\t  ffetarget_print_integer4 (dmpout, u.integer4);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER5\n-\tcase FFEINFO_kindtypeINTEGER5:\n-\t  ffetarget_print_integer5 (dmpout, u.integer5);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER6\n-\tcase FFEINFO_kindtypeINTEGER6:\n-\t  ffetarget_print_integer6 (dmpout, u.integer6);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER7\n-\tcase FFEINFO_kindtypeINTEGER7:\n-\t  ffetarget_print_integer7 (dmpout, u.integer7);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER8\n-\tcase FFEINFO_kindtypeINTEGER8:\n-\t  ffetarget_print_integer8 (dmpout, u.integer8);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad INTEGER kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeLOGICAL:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okLOGICAL1\n-\tcase FFEINFO_kindtypeLOGICAL1:\n-\t  ffetarget_print_logical1 (dmpout, u.logical1);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL2\n-\tcase FFEINFO_kindtypeLOGICAL2:\n-\t  ffetarget_print_logical2 (dmpout, u.logical2);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL3\n-\tcase FFEINFO_kindtypeLOGICAL3:\n-\t  ffetarget_print_logical3 (dmpout, u.logical3);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL4\n-\tcase FFEINFO_kindtypeLOGICAL4:\n-\t  ffetarget_print_logical4 (dmpout, u.logical4);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL5\n-\tcase FFEINFO_kindtypeLOGICAL5:\n-\t  ffetarget_print_logical5 (dmpout, u.logical5);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL6\n-\tcase FFEINFO_kindtypeLOGICAL6:\n-\t  ffetarget_print_logical6 (dmpout, u.logical6);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL7\n-\tcase FFEINFO_kindtypeLOGICAL7:\n-\t  ffetarget_print_logical7 (dmpout, u.logical7);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL8\n-\tcase FFEINFO_kindtypeLOGICAL8:\n-\t  ffetarget_print_logical8 (dmpout, u.logical8);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad LOGICAL kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeREAL:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okREAL1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  ffetarget_print_real1 (dmpout, u.real1);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  ffetarget_print_real2 (dmpout, u.real2);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  ffetarget_print_real3 (dmpout, u.real3);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL4\n-\tcase FFEINFO_kindtypeREAL4:\n-\t  ffetarget_print_real4 (dmpout, u.real4);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL5\n-\tcase FFEINFO_kindtypeREAL5:\n-\t  ffetarget_print_real5 (dmpout, u.real5);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL6\n-\tcase FFEINFO_kindtypeREAL6:\n-\t  ffetarget_print_real6 (dmpout, u.real6);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL7\n-\tcase FFEINFO_kindtypeREAL7:\n-\t  ffetarget_print_real7 (dmpout, u.real7);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL8\n-\tcase FFEINFO_kindtypeREAL8:\n-\t  ffetarget_print_real8 (dmpout, u.real8);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad REAL kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCOMPLEX:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okCOMPLEX1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  fprintf (dmpout, \"(\");\n-\t  ffetarget_print_real1 (dmpout, u.complex1.real);\n-\t  fprintf (dmpout, \",\");\n-\t  ffetarget_print_real1 (dmpout, u.complex1.imaginary);\n-\t  fprintf (dmpout, \")\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  fprintf (dmpout, \"(\");\n-\t  ffetarget_print_real2 (dmpout, u.complex2.real);\n-\t  fprintf (dmpout, \",\");\n-\t  ffetarget_print_real2 (dmpout, u.complex2.imaginary);\n-\t  fprintf (dmpout, \")\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  fprintf (dmpout, \"(\");\n-\t  ffetarget_print_real3 (dmpout, u.complex3.real);\n-\t  fprintf (dmpout, \",\");\n-\t  ffetarget_print_real3 (dmpout, u.complex3.imaginary);\n-\t  fprintf (dmpout, \")\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX4\n-\tcase FFEINFO_kindtypeREAL4:\n-\t  fprintf (dmpout, \"(\");\n-\t  ffetarget_print_real4 (dmpout, u.complex4.real);\n-\t  fprintf (dmpout, \",\");\n-\t  ffetarget_print_real4 (dmpout, u.complex4.imaginary);\n-\t  fprintf (dmpout, \")\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX5\n-\tcase FFEINFO_kindtypeREAL5:\n-\t  fprintf (dmpout, \"(\");\n-\t  ffetarget_print_real5 (dmpout, u.complex5.real);\n-\t  fprintf (dmpout, \",\");\n-\t  ffetarget_print_real5 (dmpout, u.complex5.imaginary);\n-\t  fprintf (dmpout, \")\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX6\n-\tcase FFEINFO_kindtypeREAL6:\n-\t  fprintf (dmpout, \"(\");\n-\t  ffetarget_print_real6 (dmpout, u.complex6.real);\n-\t  fprintf (dmpout, \",\");\n-\t  ffetarget_print_real6 (dmpout, u.complex6.imaginary);\n-\t  fprintf (dmpout, \")\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX7\n-\tcase FFEINFO_kindtypeREAL7:\n-\t  fprintf (dmpout, \"(\");\n-\t  ffetarget_print_real7 (dmpout, u.complex7.real);\n-\t  fprintf (dmpout, \",\");\n-\t  ffetarget_print_real7 (dmpout, u.complex7.imaginary);\n-\t  fprintf (dmpout, \")\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX8\n-\tcase FFEINFO_kindtypeREAL8:\n-\t  fprintf (dmpout, \"(\");\n-\t  ffetarget_print_real8 (dmpout, u.complex8.real);\n-\t  fprintf (dmpout, \",\");\n-\t  ffetarget_print_real8 (dmpout, u.complex8.imaginary);\n-\t  fprintf (dmpout, \")\");\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad COMPLEX kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCHARACTER:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okCHARACTER1\n-\tcase FFEINFO_kindtypeCHARACTER1:\n-\t  ffetarget_print_character1 (dmpout, u.character1);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER2\n-\tcase FFEINFO_kindtypeCHARACTER2:\n-\t  ffetarget_print_character2 (dmpout, u.character2);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER3\n-\tcase FFEINFO_kindtypeCHARACTER3:\n-\t  ffetarget_print_character3 (dmpout, u.character3);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER4\n-\tcase FFEINFO_kindtypeCHARACTER4:\n-\t  ffetarget_print_character4 (dmpout, u.character4);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER5\n-\tcase FFEINFO_kindtypeCHARACTER5:\n-\t  ffetarget_print_character5 (dmpout, u.character5);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER6\n-\tcase FFEINFO_kindtypeCHARACTER6:\n-\t  ffetarget_print_character6 (dmpout, u.character6);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER7\n-\tcase FFEINFO_kindtypeCHARACTER7:\n-\t  ffetarget_print_character7 (dmpout, u.character7);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER8\n-\tcase FFEINFO_kindtypeCHARACTER8:\n-\t  ffetarget_print_character8 (dmpout, u.character8);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad CHARACTER kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    default:\n-      assert (\"bad basictype\" == NULL);\n-      break;\n-    }\n-}\n-#endif\n-\n-/* ffebld_dump -- Dump expression tree in concise form\n-\n-   ffebld b;\n-   ffebld_dump(b);  */\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void\n-ffebld_dump (ffebld b)\n-{\n-  ffeinfoKind k;\n-  ffeinfoWhere w;\n-\n-  if (b == NULL)\n-    {\n-      fprintf (dmpout, \"(null)\");\n-      return;\n-    }\n-\n-  switch (ffebld_op (b))\n-    {\n-    case FFEBLD_opITEM:\n-      fputs (\"[\", dmpout);\n-      while (b != NULL)\n-\t{\n-\t  ffebld_dump (ffebld_head (b));\n-\t  if ((b = ffebld_trail (b)) != NULL)\n-\t    fputs (\",\", dmpout);\n-\t}\n-      fputs (\"]\", dmpout);\n-      return;\n-\n-    case FFEBLD_opSTAR:\n-    case FFEBLD_opBOUNDS:\n-    case FFEBLD_opREPEAT:\n-    case FFEBLD_opLABTER:\n-    case FFEBLD_opLABTOK:\n-    case FFEBLD_opIMPDO:\n-      fputs (ffebld_op_string (ffebld_op (b)), dmpout);\n-      break;\n-\n-    default:\n-      if (ffeinfo_size (ffebld_info (b)) != FFETARGET_charactersizeNONE)\n-\tfprintf (dmpout, \"%s%d%s%s*%\" ffetargetCharacterSize_f \"u\",\n-\t\t ffebld_op_string (ffebld_op (b)),\n-\t\t (int) ffeinfo_rank (ffebld_info (b)),\n-\t     ffeinfo_basictype_string (ffeinfo_basictype (ffebld_info (b))),\n-\t       ffeinfo_kindtype_string (ffeinfo_kindtype (ffebld_info (b))),\n-\t\t ffeinfo_size (ffebld_info (b)));\n-      else\n-\tfprintf (dmpout, \"%s%d%s%s\", ffebld_op_string (ffebld_op (b)),\n-\t\t (int) ffeinfo_rank (ffebld_info (b)),\n-\t     ffeinfo_basictype_string (ffeinfo_basictype (ffebld_info (b))),\n-\t      ffeinfo_kindtype_string (ffeinfo_kindtype (ffebld_info (b))));\n-      if ((k = ffeinfo_kind (ffebld_info (b))) != FFEINFO_kindNONE)\n-\tfprintf (dmpout, \"/%s\", ffeinfo_kind_string (k));\n-      if ((w = ffeinfo_where (ffebld_info (b))) != FFEINFO_whereNONE)\n-\tfprintf (dmpout, \"@%s\", ffeinfo_where_string (w));\n-      break;\n-    }\n-\n-  switch (ffebld_arity (b))\n-    {\n-    case 2:\n-      fputs (\"(\", dmpout);\n-      ffebld_dump (ffebld_left (b));\n-      fputs (\",\", dmpout);\n-      ffebld_dump (ffebld_right (b));\n-      fputs (\")\", dmpout);\n-      break;\n-\n-    case 1:\n-      fputs (\"(\", dmpout);\n-      ffebld_dump (ffebld_left (b));\n-      fputs (\")\", dmpout);\n-      break;\n-\n-    default:\n-      switch (ffebld_op (b))\n-\t{\n-\tcase FFEBLD_opCONTER:\n-\t  fprintf (dmpout, \"<\");\n-\t  ffebld_constant_dump (b->u.conter.expr);\n-\t  fprintf (dmpout, \">\");\n-\t  break;\n-\n-\tcase FFEBLD_opACCTER:\n-\t  fprintf (dmpout, \"<\");\n-\t  ffebld_constantarray_dump (b->u.accter.array,\n-\t\t\t\t     ffeinfo_basictype (ffebld_info (b)),\n-\t\t\t\t     ffeinfo_kindtype (ffebld_info (b)),\n-\t\t\t  ffebit_size (b->u.accter.bits), b->u.accter.bits);\n-\t  fprintf (dmpout, \">\");\n-\t  break;\n-\n-\tcase FFEBLD_opARRTER:\n-\t  fprintf (dmpout, \"<\");\n-\t  ffebld_constantarray_dump (b->u.arrter.array,\n-\t\t\t\t     ffeinfo_basictype (ffebld_info (b)),\n-\t\t\t\t     ffeinfo_kindtype (ffebld_info (b)),\n-\t\t\t\t     b->u.arrter.size, NULL);\n-\t  fprintf (dmpout, \">\");\n-\t  break;\n-\n-\tcase FFEBLD_opLABTER:\n-\t  if (b->u.labter == NULL)\n-\t    fprintf (dmpout, \"<>\");\n-\t  else\n-\t    fprintf (dmpout, \"<%\" ffelabValue_f \"u>\", ffelab_value (b->u.labter));\n-\t  break;\n-\n-\tcase FFEBLD_opLABTOK:\n-\t  fprintf (dmpout, \"<%s>\", ffelex_token_text (b->u.labtok));\n-\t  break;\n-\n-\tcase FFEBLD_opSYMTER:\n-\t  fprintf (dmpout, \"<\");\n-\t  ffesymbol_dump (b->u.symter.symbol);\n-\t  if ((b->u.symter.generic != FFEINTRIN_genNONE)\n-\t      || (b->u.symter.specific != FFEINTRIN_specNONE))\n-\t    fprintf (dmpout, \"{%s:%s:%s}\",\n-\t\t     ffeintrin_name_generic (b->u.symter.generic),\n-\t\t     ffeintrin_name_specific (b->u.symter.specific),\n-\t\tffeintrin_name_implementation (b->u.symter.implementation));\n-\t  if (b->u.symter.do_iter)\n-\t    fprintf (dmpout, \"{/do-iter}\");\n-\t  fprintf (dmpout, \">\");\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-}\n-#endif\n-\n-/* ffebld_dump_prefix -- Dump the prefix for a constant of a given type\n-\n-   ffebld_dump_prefix(dmpout,FFEINFO_basictypeINTEGER,\n-\t FFEINFO_kindtypeINTEGER1);  */\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void\n-ffebld_dump_prefix (FILE *out, ffeinfoBasictype bt, ffeinfoKindtype kt)\n-{\n-  switch (bt)\n-    {\n-    case FFEINFO_basictypeINTEGER:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okINTEGER1\n-\tcase FFEINFO_kindtypeINTEGER1:\n-\t  fprintf (out, \"I\" STRX (FFETARGET_kindINTEGER1) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER2\n-\tcase FFEINFO_kindtypeINTEGER2:\n-\t  fprintf (out, \"I\" STRX (FFETARGET_kindINTEGER2) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER3\n-\tcase FFEINFO_kindtypeINTEGER3:\n-\t  fprintf (out, \"I\" STRX (FFETARGET_kindINTEGER3) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER4\n-\tcase FFEINFO_kindtypeINTEGER4:\n-\t  fprintf (out, \"I\" STRX (FFETARGET_kindINTEGER4) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER5\n-\tcase FFEINFO_kindtypeINTEGER5:\n-\t  fprintf (out, \"I\" STRX (FFETARGET_kindINTEGER5) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER6\n-\tcase FFEINFO_kindtypeINTEGER6:\n-\t  fprintf (out, \"I\" STRX (FFETARGET_kindINTEGER6) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER7\n-\tcase FFEINFO_kindtypeINTEGER7:\n-\t  fprintf (out, \"I\" STRX (FFETARGET_kindINTEGER7) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER8\n-\tcase FFEINFO_kindtypeINTEGER8:\n-\t  fprintf (out, \"I\" STRX (FFETARGET_kindINTEGER8) \"/\");\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad INTEGER kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeLOGICAL:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okLOGICAL1\n-\tcase FFEINFO_kindtypeLOGICAL1:\n-\t  fprintf (out, \"L\" STRX (FFETARGET_kindLOGICAL1) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL2\n-\tcase FFEINFO_kindtypeLOGICAL2:\n-\t  fprintf (out, \"L\" STRX (FFETARGET_kindLOGICAL2) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL3\n-\tcase FFEINFO_kindtypeLOGICAL3:\n-\t  fprintf (out, \"L\" STRX (FFETARGET_kindLOGICAL3) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL4\n-\tcase FFEINFO_kindtypeLOGICAL4:\n-\t  fprintf (out, \"L\" STRX (FFETARGET_kindLOGICAL4) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL5\n-\tcase FFEINFO_kindtypeLOGICAL5:\n-\t  fprintf (out, \"L\" STRX (FFETARGET_kindLOGICAL5) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL6\n-\tcase FFEINFO_kindtypeLOGICAL6:\n-\t  fprintf (out, \"L\" STRX (FFETARGET_kindLOGICAL6) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL7\n-\tcase FFEINFO_kindtypeLOGICAL7:\n-\t  fprintf (out, \"L\" STRX (FFETARGET_kindLOGICAL7) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL8\n-\tcase FFEINFO_kindtypeLOGICAL8:\n-\t  fprintf (out, \"L\" STRX (FFETARGET_kindLOGICAL8) \"/\");\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad LOGICAL kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeREAL:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okREAL1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  fprintf (out, \"R\" STRX (FFETARGET_kindREAL1) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  fprintf (out, \"R\" STRX (FFETARGET_kindREAL2) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  fprintf (out, \"R\" STRX (FFETARGET_kindREAL3) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL4\n-\tcase FFEINFO_kindtypeREAL4:\n-\t  fprintf (out, \"R\" STRX (FFETARGET_kindREAL4) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL5\n-\tcase FFEINFO_kindtypeREAL5:\n-\t  fprintf (out, \"R\" STRX (FFETARGET_kindREAL5) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL6\n-\tcase FFEINFO_kindtypeREAL6:\n-\t  fprintf (out, \"R\" STRX (FFETARGET_kindREAL6) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL7\n-\tcase FFEINFO_kindtypeREAL7:\n-\t  fprintf (out, \"R\" STRX (FFETARGET_kindREAL7) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL8\n-\tcase FFEINFO_kindtypeREAL8:\n-\t  fprintf (out, \"R\" STRX (FFETARGET_kindREAL8) \"/\");\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad REAL kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCOMPLEX:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okCOMPLEX1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  fprintf (out, \"C\" STRX (FFETARGET_kindCOMPLEX1) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  fprintf (out, \"C\" STRX (FFETARGET_kindCOMPLEX2) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  fprintf (out, \"C\" STRX (FFETARGET_kindCOMPLEX3) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX4\n-\tcase FFEINFO_kindtypeREAL4:\n-\t  fprintf (out, \"C\" STRX (FFETARGET_kindCOMPLEX4) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX5\n-\tcase FFEINFO_kindtypeREAL5:\n-\t  fprintf (out, \"C\" STRX (FFETARGET_kindCOMPLEX5) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX6\n-\tcase FFEINFO_kindtypeREAL6:\n-\t  fprintf (out, \"C\" STRX (FFETARGET_kindCOMPLEX6) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX7\n-\tcase FFEINFO_kindtypeREAL7:\n-\t  fprintf (out, \"C\" STRX (FFETARGET_kindCOMPLEX7) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX8\n-\tcase FFEINFO_kindtypeREAL8:\n-\t  fprintf (out, \"C\" STRX (FFETARGET_kindCOMPLEX8) \"/\");\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad COMPLEX kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCHARACTER:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okCHARACTER1\n-\tcase FFEINFO_kindtypeCHARACTER1:\n-\t  fprintf (out, \"A\" STRX (FFETARGET_kindCHARACTER1) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER2\n-\tcase FFEINFO_kindtypeCHARACTER2:\n-\t  fprintf (out, \"A\" STRX (FFETARGET_kindCHARACTER2) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER3\n-\tcase FFEINFO_kindtypeCHARACTER3:\n-\t  fprintf (out, \"A\" STRX (FFETARGET_kindCHARACTER3) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER4\n-\tcase FFEINFO_kindtypeCHARACTER4:\n-\t  fprintf (out, \"A\" STRX (FFETARGET_kindCHARACTER4) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER5\n-\tcase FFEINFO_kindtypeCHARACTER5:\n-\t  fprintf (out, \"A\" STRX (FFETARGET_kindCHARACTER5) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER6\n-\tcase FFEINFO_kindtypeCHARACTER6:\n-\t  fprintf (out, \"A\" STRX (FFETARGET_kindCHARACTER6) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER7\n-\tcase FFEINFO_kindtypeCHARACTER7:\n-\t  fprintf (out, \"A\" STRX (FFETARGET_kindCHARACTER7) \"/\");\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCHARACTER8\n-\tcase FFEINFO_kindtypeCHARACTER8:\n-\t  fprintf (out, \"A\" STRX (FFETARGET_kindCHARACTER8) \"/\");\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad CHARACTER kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    default:\n-      assert (\"bad basictype\" == NULL);\n-      fprintf (out, \"?/?\");\n-      break;\n-    }\n-}\n-#endif\n-\n /* ffebld_init_0 -- Initialize the module\n \n    ffebld_init_0();  */"}, {"sha": "5f8bedebaad1e8b6ae58788f1977e44438ad43f3", "filename": "gcc/f/bld.h", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fbld.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fbld.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbld.h?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -124,13 +124,7 @@ typedef struct _ffebld_pool_stack_ *ffebldPoolstack_;\n #define FFEBLD_whereconstPROGUNIT_ 1\n #define FFEBLD_whereconstFILE_ 2\n \n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-#define FFEBLD_whereconstCURRENT_ FFEBLD_whereconstPROGUNIT_\n-#elif FFECOM_targetCURRENT == FFECOM_targetGCC\n #define FFEBLD_whereconstCURRENT_ FFEBLD_whereconstFILE_\n-#else\n-#error\n-#endif\n \n /* Structure definitions. */\n \n@@ -486,9 +480,6 @@ extern struct _ffebld_pool_stack_ ffebld_pool_stack_;\n /* Declare functions with prototypes. */\n \n int ffebld_constant_cmp (ffebldConstant c1, ffebldConstant c2);\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void ffebld_constant_dump (ffebldConstant c);\n-#endif\n bool ffebld_constant_is_magical (ffebldConstant c);\n bool ffebld_constant_is_zero (ffebldConstant c);\n #if FFETARGET_okCHARACTER1\n@@ -691,10 +682,6 @@ ffebldConstant ffebld_constant_new_typeless_ov (ffelexToken t);\n ffebldConstant ffebld_constant_new_typeless_val (ffebldConst type,\n \t\t\t\t\t\t ffetargetTypeless val);\n ffebldConstant ffebld_constant_negated (ffebldConstant c);\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void ffebld_constantarray_dump (ffebldConstantArray array, ffeinfoBasictype bt,\n-\t\t     ffeinfoKindtype kt, ffetargetOffset size, ffebit bits);\n-#endif\n ffebldConstantUnion ffebld_constantarray_get (ffebldConstantArray array,\n \t   ffeinfoBasictype bt, ffeinfoKindtype kt, ffetargetOffset offset);\n void ffebld_constantarray_kill (ffebldConstantArray array, ffeinfoBasictype bt,\n@@ -711,12 +698,6 @@ void ffebld_constantarray_preparray (void **aptr, void **cptr, size_t *size,\n \t\t\t\t ffeinfoBasictype cbt, ffeinfoKindtype ckt);\n void ffebld_constantarray_put (ffebldConstantArray array, ffeinfoBasictype bt,\n   ffeinfoKindtype kt, ffetargetOffset offset, ffebldConstantUnion constant);\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void ffebld_constantunion_dump (ffebldConstantUnion u, ffeinfoBasictype bt,\n-\t\t\t\tffeinfoKindtype kt);\n-void ffebld_dump (ffebld b);\n-void ffebld_dump_prefix (FILE *out, ffeinfoBasictype bt, ffeinfoKindtype kt);\n-#endif\n void ffebld_init_0 (void);\n void ffebld_init_1 (void);\n void ffebld_init_2 (void);"}, {"sha": "821a637fd5ab0d1140357d8633d8ee4f162f9690", "filename": "gcc/f/com.c", "status": "modified", "additions": 22, "deletions": 397, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -81,7 +81,6 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Include files. */\n \n #include \"proj.h\"\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n #include \"flags.h\"\n #include \"rtl.h\"\n #include \"toplev.h\"\n@@ -91,9 +90,6 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"diagnostic.h\"\n #include \"langhooks.h\"\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n-\n-#define FFECOM_GCC_INCLUDE 1\t/* Enable -I. */\n \n /* VMS-specific definitions */\n #ifdef VMS\n@@ -139,8 +135,6 @@ typedef struct { unsigned :16, :16, :16; } vms_ino_t;\n \n /* Externals defined here.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n-\n /* ~~gcc/tree.h *should* declare this, because toplev.c and dwarfout.c\n    reference it.  */\n \n@@ -213,7 +207,6 @@ tree ffecom_f2c_ftnlen_two_node;\n tree ffecom_f2c_ptr_to_ftnlen_type_node;\n tree ffecom_f2c_ftnint_type_node;\n tree ffecom_f2c_ptr_to_ftnint_type_node;\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \n /* Simple definitions and enumerations. */\n \n@@ -253,16 +246,13 @@ typedef enum\n \n /* Internal typedefs. */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n typedef struct _ffecom_concat_list_ ffecomConcatList_;\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \n /* Private include files. */\n \n \n /* Internal structure definitions. */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n struct _ffecom_concat_list_\n   {\n     ffebld *exprs;\n@@ -271,11 +261,9 @@ struct _ffecom_concat_list_\n     ffetargetCharacterSize minlen;\n     ffetargetCharacterSize maxlen;\n   };\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \n /* Static functions (internal). */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree ffecom_arglist_expr_ (const char *argstring, ffebld args);\n static tree ffecom_widest_expr_type_ (ffebld list);\n static bool ffecom_overlap_ (tree dest_decl, tree dest_offset,\n@@ -368,12 +356,10 @@ static tree ffecom_vardesc_array_ (ffesymbol s);\n static tree ffecom_vardesc_dims_ (ffesymbol s);\n static tree ffecom_convert_narrow_ (tree type, tree expr);\n static tree ffecom_convert_widen_ (tree type, tree expr);\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \n /* These are static functions that parallel those found in the C front\n    end and thus have the same names.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree bison_rule_compstmt_ (void);\n static void bison_rule_pushlevel_ (void);\n static void delete_block (tree block);\n@@ -392,23 +378,19 @@ static tree storedecls (tree decls);\n static void store_parm_decls (int is_main_program);\n static tree start_decl (tree decl, bool is_top_level);\n static void start_function (tree name, tree type, int nested, int public);\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n-#if FFECOM_GCC_INCLUDE\n static void ffecom_file_ (const char *name);\n static void ffecom_initialize_char_syntax_ (void);\n static void ffecom_close_include_ (FILE *f);\n static int ffecom_decode_include_option_ (char *spec);\n static FILE *ffecom_open_include_ (char *name, ffewhereLine l,\n \t\t\t\t   ffewhereColumn c);\n-#endif\t/* FFECOM_GCC_INCLUDE */\n \n /* Static objects accessed by functions in this module. */\n \n static ffesymbol ffecom_primary_entry_ = NULL;\n static ffesymbol ffecom_nested_entry_ = NULL;\n static ffeinfoKind ffecom_primary_entry_kind_;\n static bool ffecom_primary_entry_is_proc_;\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree ffecom_outer_function_decl_;\n static tree ffecom_previous_function_decl_;\n static tree ffecom_which_entrypoint_decl_;\n@@ -507,12 +489,9 @@ static const char *const ffecom_gfrt_argstring_[FFECOM_gfrt]\n #include \"com-rt.def\"\n #undef DEFGFRT\n };\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \n /* Internal macros. */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n-\n /* We let tm.h override the types used here, to handle trivial differences\n    such as the choice of unsigned int or long unsigned int for size_t.\n    When machines start needing nontrivial differences in the size type,\n@@ -634,8 +613,6 @@ static tree named_labels;\n /* A list of LABEL_DECLs from outer contexts that are currently shadowed.  */\n \n static tree shadowed_labels;\n-\n-#endif /* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \f\n /* Return the subscript expression, modified to do range-checking.\n \n@@ -700,7 +677,7 @@ ffecom_subscript_check_ (tree array, tree element, int dim, int total_dims,\n   else\n     {\n       /* Array reference substring range checking.  */\n-        \n+\n       cond = ffecom_2 (LE_EXPR, integer_type_node,\n                      low,\n                      element);\n@@ -980,7 +957,6 @@ ffecom_arrayref_ (tree item, ffebld expr, int want_ptr)\n    and such might well be stable too, but for things like calculations,\n    we do need to calculate a snapshot of a value before picking at it.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_stabilize_aggregate_ (tree ref)\n {\n@@ -1053,13 +1029,11 @@ ffecom_stabilize_aggregate_ (tree ref)\n \n   return result;\n }\n-#endif\n \n /* A rip-off of gcc's convert.c convert_to_complex function,\n    reworked to handle complex implemented as C structures\n    (RECORD_TYPE with two fields, real and imaginary `r' and `i').  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_convert_to_complex_ (tree type, tree expr)\n {\n@@ -1069,7 +1043,7 @@ ffecom_convert_to_complex_ (tree type, tree expr)\n   assert (TREE_CODE (type) == RECORD_TYPE);\n \n   subtype = TREE_TYPE (TYPE_FIELDS (type));\n-  \n+\n   if (form == REAL_TYPE || form == INTEGER_TYPE || form == ENUMERAL_TYPE)\n     {\n       expr = convert (subtype, expr);\n@@ -1102,16 +1076,14 @@ ffecom_convert_to_complex_ (tree type, tree expr)\n     error (\"pointer value used where a complex was expected\");\n   else\n     error (\"aggregate value used where a complex was expected\");\n-  \n+\n   return ffecom_2 (COMPLEX_EXPR, type,\n \t\t   convert (subtype, integer_zero_node),\n \t\t   convert (subtype, integer_zero_node));\n }\n-#endif\n \n /* Like gcc's convert(), but crashes if widening might happen.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_convert_narrow_ (type, expr)\n      tree type, expr;\n@@ -1180,11 +1152,9 @@ ffecom_convert_narrow_ (type, expr)\n   assert (\"conversion to non-scalar type requested\" == NULL);\n   return error_mark_node;\n }\n-#endif\n \n /* Like gcc's convert(), but crashes if narrowing might happen.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_convert_widen_ (type, expr)\n      tree type, expr;\n@@ -1253,13 +1223,11 @@ ffecom_convert_widen_ (type, expr)\n   assert (\"conversion to non-scalar type requested\" == NULL);\n   return error_mark_node;\n }\n-#endif\n \n /* Handles making a COMPLEX type, either the standard\n    (but buggy?) gbe way, or the safer (but less elegant?)\n    f2c way.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_make_complex_type_ (tree subtype)\n {\n@@ -1284,12 +1252,10 @@ ffecom_make_complex_type_ (tree subtype)\n \n   return type;\n }\n-#endif\n \n /* Chooses either the gbe or the f2c way to build a\n    complex constant.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_build_complex_constant_ (tree type, tree realpart, tree imagpart)\n {\n@@ -1308,9 +1274,7 @@ ffecom_build_complex_constant_ (tree type, tree realpart, tree imagpart)\n \n   return bothparts;\n }\n-#endif\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_arglist_expr_ (const char *c, ffebld expr)\n {\n@@ -1456,9 +1420,7 @@ ffecom_arglist_expr_ (const char *c, ffebld expr)\n \n   return list;\n }\n-#endif\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_widest_expr_type_ (ffebld list)\n {\n@@ -1494,7 +1456,6 @@ ffecom_widest_expr_type_ (ffebld list)\n   assert (t != NULL_TREE);\n   return t;\n }\n-#endif\n \n /* Check whether a partial overlap between two expressions is possible.\n \n@@ -1546,7 +1507,6 @@ ffecom_possible_partial_overlap_ (ffebld expr1, ffebld expr2 ATTRIBUTE_UNUSED)\n    change before it is finally modified.  dest_* are the canonized\n    destination itself.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static bool\n ffecom_overlap_ (tree dest_decl, tree dest_offset, tree dest_size,\n \t\t tree source_tree, ffebld source UNUSED,\n@@ -1726,12 +1686,10 @@ ffecom_overlap_ (tree dest_decl, tree dest_offset, tree dest_size,\n \n   return TRUE;\t\t/* Destination and source overlap. */\n }\n-#endif\n \n /* Check whether dest might overlap any of a list of arguments or is\n    in a COMMON area the callee might know about (and thus modify).  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static bool\n ffecom_args_overlapping_ (tree dest_tree, ffebld dest UNUSED,\n \t\t\t  tree args, tree callee_commons,\n@@ -1767,13 +1725,11 @@ ffecom_args_overlapping_ (tree dest_tree, ffebld dest UNUSED,\n \n   return FALSE;\n }\n-#endif\n \n /* Build a string for a variable name as used by NAMELIST.  This means that\n    if we're using the f2c library, we build an uppercase string, since\n    f2c does this.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_build_f2c_string_ (int i, const char *s)\n {\n@@ -1805,13 +1761,11 @@ ffecom_build_f2c_string_ (int i, const char *s)\n   }\n }\n \n-#endif\n /* Returns CALL_EXPR or equivalent with given type (pass NULL_TREE for\n    type to just get whatever the function returns), handling the\n    f2c value-returning convention, if required, by prepending\n    to the arglist a pointer to a temporary to receive the return value.\t */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_call_ (tree fn, ffeinfoKindtype kt, bool is_f2c_complex,\n \t      tree type, tree args, tree dest_tree,\n@@ -1875,12 +1829,10 @@ ffecom_call_ (tree fn, ffeinfoKindtype kt, bool is_f2c_complex,\n \n   return item;\n }\n-#endif\n \n /* Given two arguments, transform them and make a call to the given\n    function via ffecom_call_.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_call_binop_ (tree fn, ffeinfoKindtype kt, bool is_f2c_complex,\n \t\t    tree type, ffebld left, ffebld right,\n@@ -1929,7 +1881,6 @@ ffecom_call_binop_ (tree fn, ffeinfoKindtype kt, bool is_f2c_complex,\n \t\t       dest_tree, dest, dest_used, callee_commons,\n \t\t       scalar_args, hook);\n }\n-#endif\n \n /* Return ptr/length args for char subexpression\n \n@@ -1941,7 +1892,6 @@ ffecom_call_binop_ (tree fn, ffeinfoKindtype kt, bool is_f2c_complex,\n    Note that if with_null is TRUE, and the expression is an opCONTER,\n    a null byte is appended to the string.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffecom_char_args_x_ (tree *xitem, tree *length, ffebld expr, bool with_null)\n {\n@@ -2295,7 +2245,6 @@ ffecom_char_args_x_ (tree *xitem, tree *length, ffebld expr, bool with_null)\n \n   *xitem = item;\n }\n-#endif\n \n /* Check the size of the type to be sure it doesn't overflow the\n    \"portable\" capacities of the compiler back end.  `dummy' types\n@@ -2304,7 +2253,6 @@ ffecom_char_args_x_ (tree *xitem, tree *length, ffebld expr, bool with_null)\n    must still enforce its size requirements, though, and the back\n    end takes care of this in stor-layout.c.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_check_size_overflow_ (ffesymbol s, tree type, bool dummy)\n {\n@@ -2331,13 +2279,11 @@ ffecom_check_size_overflow_ (ffesymbol s, tree type, bool dummy)\n \n   return type;\n }\n-#endif\n \n /* Builds a length argument (PARM_DECL).  Also wraps type in an array type\n    where the dimension info is (1:size) where <size> is ffesymbol_size(s) if\n    known, length_arg if not known (FFETARGET_charactersizeNONE).  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_char_enhance_arg_ (tree *xtype, ffesymbol s)\n {\n@@ -2356,9 +2302,7 @@ ffecom_char_enhance_arg_ (tree *xtype, ffesymbol s)\n       else\n \ttlen = ffecom_get_invented_identifier (\"__g77_%s\", \"length\");\n       tlen = build_decl (PARM_DECL, tlen, ffecom_f2c_ftnlen_type_node);\n-#if BUILT_FOR_270\n       DECL_ARTIFICIAL (tlen) = 1;\n-#endif\n     }\n \n   if (sz == FFETARGET_charactersizeNONE)\n@@ -2381,7 +2325,6 @@ ffecom_char_enhance_arg_ (tree *xtype, ffesymbol s)\n   return tlen;\n }\n \n-#endif\n /* ffecom_concat_list_gather_ -- Gather list of concatenated string exprs\n \n    ffecomConcatList_ catlist;\n@@ -2392,14 +2335,13 @@ ffecom_char_enhance_arg_ (tree *xtype, ffesymbol s)\n    Scans expr for character subexpressions, updates and returns catlist\n    accordingly.\t */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static ffecomConcatList_\n ffecom_concat_list_gather_ (ffecomConcatList_ catlist, ffebld expr,\n \t\t\t    ffetargetCharacterSize max)\n {\n   ffetargetCharacterSize sz;\n \n-recurse:\t\t\t/* :::::::::::::::::::: */\n+ recurse:\n \n   if (expr == NULL)\n     return catlist;\n@@ -2495,15 +2437,13 @@ ffecom_concat_list_gather_ (ffecomConcatList_ catlist, ffebld expr,\n     }\n }\n \n-#endif\n /* ffecom_concat_list_kill_ -- Kill list of concatenated string exprs\n \n    ffecomConcatList_ catlist;\n    ffecom_concat_list_kill_(catlist);\n \n    Anything allocated within the list info is deallocated.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffecom_concat_list_kill_ (ffecomConcatList_ catlist)\n {\n@@ -2512,13 +2452,11 @@ ffecom_concat_list_kill_ (ffecomConcatList_ catlist)\n \t\t    catlist.max * sizeof (catlist.exprs[0]));\n }\n \n-#endif\n /* Make list of concatenated string exprs.\n \n    Returns a flattened list of concatenated subexpressions given a\n    tree of such expressions.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static ffecomConcatList_\n ffecom_concat_list_new_ (ffebld expr, ffetargetCharacterSize max)\n {\n@@ -2528,13 +2466,10 @@ ffecom_concat_list_new_ (ffebld expr, ffetargetCharacterSize max)\n   return ffecom_concat_list_gather_ (catlist, expr, max);\n }\n \n-#endif\n-\n /* Provide some kind of useful info on member of aggregate area,\n    since current g77/gcc technology does not provide debug info\n    on these members.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffecom_debug_kludge_ (tree aggr, const char *aggr_type, ffesymbol member,\n \t\t      tree member_type UNUSED, ffetargetOffset offset)\n@@ -2613,7 +2548,6 @@ ffecom_debug_kludge_ (tree aggr, const char *aggr_type, ffesymbol member,\n   if (buff != &space[0])\n     malloc_kill_ks (malloc_pool_image (), buff, len + 1);\n }\n-#endif\n \n /* ffecom_do_entry_ -- Do compilation of a particular entrypoint\n \n@@ -2624,7 +2558,6 @@ ffecom_debug_kludge_ (tree aggr, const char *aggr_type, ffesymbol member,\n    Makes a public entry point that calls our private master fn (already\n    compiled).  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffecom_do_entry_ (ffesymbol fn, int entrynum)\n {\n@@ -2981,15 +2914,13 @@ ffecom_do_entry_ (ffesymbol fn, int entrynum)\n   ffecom_doing_entry_ = FALSE;\n }\n \n-#endif\n /* Transform expr into gcc tree with possible destination\n \n    Recursive descent on expr while making corresponding tree nodes and\n    attaching type info and such.  If destination supplied and compatible\n    with temporary that would be made in certain cases, temporary isn't\n    made, destination used instead, and dest_used flag set TRUE.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_expr_ (ffebld expr, tree dest_tree, ffebld dest,\n \t      bool *dest_used, bool assignp, bool widenp)\n@@ -3240,7 +3171,7 @@ ffecom_expr_ (ffebld expr, tree dest_tree, ffebld dest,\n \n     case FFEBLD_opUMINUS:\n       left = ffecom_expr_ (ffebld_left (expr), NULL, NULL, NULL, FALSE, widenp);\n-      if (tree_type_x) \n+      if (tree_type_x)\n \t{\n \t  tree_type = tree_type_x;\n \t  left = convert (tree_type, left);\n@@ -3250,7 +3181,7 @@ ffecom_expr_ (ffebld expr, tree dest_tree, ffebld dest,\n     case FFEBLD_opADD:\n       left = ffecom_expr_ (ffebld_left (expr), NULL, NULL, NULL, FALSE, widenp);\n       right = ffecom_expr_ (ffebld_right (expr), NULL, NULL, NULL, FALSE, widenp);\n-      if (tree_type_x) \n+      if (tree_type_x)\n \t{\n \t  tree_type = tree_type_x;\n \t  left = convert (tree_type, left);\n@@ -3261,7 +3192,7 @@ ffecom_expr_ (ffebld expr, tree dest_tree, ffebld dest,\n     case FFEBLD_opSUBTRACT:\n       left = ffecom_expr_ (ffebld_left (expr), NULL, NULL, NULL, FALSE, widenp);\n       right = ffecom_expr_ (ffebld_right (expr), NULL, NULL, NULL, FALSE, widenp);\n-      if (tree_type_x) \n+      if (tree_type_x)\n \t{\n \t  tree_type = tree_type_x;\n \t  left = convert (tree_type, left);\n@@ -3272,7 +3203,7 @@ ffecom_expr_ (ffebld expr, tree dest_tree, ffebld dest,\n     case FFEBLD_opMULTIPLY:\n       left = ffecom_expr_ (ffebld_left (expr), NULL, NULL, NULL, FALSE, widenp);\n       right = ffecom_expr_ (ffebld_right (expr), NULL, NULL, NULL, FALSE, widenp);\n-      if (tree_type_x) \n+      if (tree_type_x)\n \t{\n \t  tree_type = tree_type_x;\n \t  left = convert (tree_type, left);\n@@ -3283,7 +3214,7 @@ ffecom_expr_ (ffebld expr, tree dest_tree, ffebld dest,\n     case FFEBLD_opDIVIDE:\n       left = ffecom_expr_ (ffebld_left (expr), NULL, NULL, NULL, FALSE, widenp);\n       right = ffecom_expr_ (ffebld_right (expr), NULL, NULL, NULL, FALSE, widenp);\n-      if (tree_type_x) \n+      if (tree_type_x)\n \t{\n \t  tree_type = tree_type_x;\n \t  left = convert (tree_type, left);\n@@ -3845,14 +3776,12 @@ ffecom_expr_ (ffebld expr, tree dest_tree, ffebld dest,\n #endif\n }\n \n-#endif\n /* Returns the tree that does the intrinsic invocation.\n \n    Note: this function applies only to intrinsics returning\n    CHARACTER*1 or non-CHARACTER results, and to intrinsic\n    subroutines.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_expr_intrinsic_ (ffebld expr, tree dest_tree,\n \t\t\tffebld dest, bool *dest_used)\n@@ -5478,12 +5407,10 @@ ffecom_expr_intrinsic_ (ffebld expr, tree dest_tree,\n      the bottom of this source file.  */\n }\n \n-#endif\n /* For power (exponentiation) where right-hand operand is type INTEGER,\n    generate in-line code to do it the fast way (which, if the operand\n    is a constant, might just mean a series of multiplies).  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_expr_power_integer_ (ffebld expr)\n {\n@@ -5851,22 +5778,20 @@ ffecom_expr_power_integer_ (ffebld expr)\n   return result;\n }\n \n-#endif\n /* ffecom_expr_transform_ -- Transform symbols in expr\n \n    ffebld expr;\t // FFE expression.\n    ffecom_expr_transform_ (expr);\n \n    Recursive descent on expr while transforming any untransformed SYMTERs.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffecom_expr_transform_ (ffebld expr)\n {\n   tree t;\n   ffesymbol s;\n \n-tail_recurse:\t\t\t/* :::::::::::::::::::: */\n+ tail_recurse:\n \n   if (expr == NULL)\n     return;\n@@ -5914,10 +5839,8 @@ ffecom_expr_transform_ (ffebld expr)\n   return;\n }\n \n-#endif\n /* Make a type based on info in live f2c.h file.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffecom_f2c_make_type_ (tree *type, int tcode, const char *name)\n {\n@@ -5986,8 +5909,6 @@ ffecom_f2c_make_type_ (tree *type, int tcode, const char *name)\n \t\t\t*type));\n }\n \n-#endif\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n /* Set the f2c list-directed-I/O code for whatever (integral) type has the\n    given size.  */\n \n@@ -6008,12 +5929,10 @@ ffecom_f2c_set_lio_code_ (ffeinfoBasictype bt, int size,\n       }\n }\n \n-#endif\n /* Finish up globals after doing all program units in file\n \n    Need to handle only uninitialized COMMON areas.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static ffeglobal\n ffecom_finish_global_ (ffeglobal global)\n {\n@@ -6056,10 +5975,8 @@ ffecom_finish_global_ (ffeglobal global)\n   return global;\n }\n \n-#endif\n /* Finish up any untransformed symbols.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static ffesymbol\n ffecom_finish_symbol_transform_ (ffesymbol s)\n {\n@@ -6103,12 +6020,10 @@ ffecom_finish_symbol_transform_ (ffesymbol s)\n   return s;\n }\n \n-#endif\n /* Append underscore(s) to name before calling get_identifier.  \"us\"\n    is nonzero if the name already contains an underscore and thus\n    needs two underscores appended.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_get_appended_identifier_ (char us, const char *name)\n {\n@@ -6130,11 +6045,9 @@ ffecom_get_appended_identifier_ (char us, const char *name)\n   return id;\n }\n \n-#endif\n /* Decide whether to append underscore to name before calling\n    get_identifier.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_get_external_identifier_ (ffesymbol s)\n {\n@@ -6160,7 +6073,6 @@ ffecom_get_external_identifier_ (ffesymbol s)\n   return ffecom_get_appended_identifier_ (us, name);\n }\n \n-#endif\n /* Decide whether to append underscore to internal name before calling\n    get_identifier.\n \n@@ -6176,7 +6088,6 @@ ffecom_get_external_identifier_ (ffesymbol s)\n    If the name does contain an underscore, then transform it just\n    like we transform an external identifier.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_get_identifier_ (const char *name)\n {\n@@ -6190,7 +6101,6 @@ ffecom_get_identifier_ (const char *name)\n \t\t\t\t\t  name);\n }\n \n-#endif\n /* ffecom_gen_sfuncdef_ -- Generate definition of statement function\n \n    tree t;\n@@ -6201,7 +6111,6 @@ ffecom_get_identifier_ (const char *name)\n    Call after setting up containing function and getting trees for all\n    other symbols.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_gen_sfuncdef_ (ffesymbol s, ffeinfoBasictype bt, ffeinfoKindtype kt)\n {\n@@ -6330,17 +6239,12 @@ ffecom_gen_sfuncdef_ (ffesymbol s, ffeinfoBasictype bt, ffeinfoKindtype kt)\n   return func;\n }\n \n-#endif\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static const char *\n ffecom_gfrt_args_ (ffecomGfrt ix)\n {\n   return ffecom_gfrt_argstring_[ix];\n }\n \n-#endif\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_gfrt_tree_ (ffecomGfrt ix)\n {\n@@ -6352,25 +6256,23 @@ ffecom_gfrt_tree_ (ffecomGfrt ix)\n \t\t   ffecom_gfrt_[ix]);\n }\n \n-#endif\n /* Return initialize-to-zero expression for this VAR_DECL.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n /* A somewhat evil way to prevent the garbage collector\n    from collecting 'tree' structures.  */\n #define NUM_TRACKED_CHUNK 63\n-static struct tree_ggc_tracker \n+static struct tree_ggc_tracker\n {\n   struct tree_ggc_tracker *next;\n   tree trees[NUM_TRACKED_CHUNK];\n } *tracker_head = NULL;\n \n-static void \n+static void\n mark_tracker_head (void *arg)\n {\n   struct tree_ggc_tracker *head;\n   int i;\n-  \n+\n   for (head = * (struct tree_ggc_tracker **) arg;\n        head != NULL;\n        head = head->next)\n@@ -6396,7 +6298,7 @@ ffecom_save_tree_forever (tree t)\n   {\n     /* Need to allocate a new block.  */\n     struct tree_ggc_tracker *old_head = tracker_head;\n-    \n+\n     tracker_head = ggc_alloc (sizeof (*tracker_head));\n     tracker_head->next = old_head;\n     tracker_head->trees[0] = t;\n@@ -6438,8 +6340,6 @@ ffecom_init_zero_ (tree decl)\n   return init;\n }\n \n-#endif\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_intrinsic_ichar_ (tree tree_type, ffebld arg,\n \t\t\t tree *maybe_tree)\n@@ -6543,7 +6443,6 @@ ffecom_intrinsic_ichar_ (tree tree_type, ffebld arg,\n     }\n }\n \n-#endif\n /* ffecom_intrinsic_len_ -- Return length info for char arg (LEN())\n \n    tree length_arg;\n@@ -6554,7 +6453,6 @@ ffecom_intrinsic_ichar_ (tree tree_type, ffebld arg,\n    subexpressions by constructing the appropriate tree for the\n    length-of-character-text argument in a calling sequence.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_intrinsic_len_ (ffebld expr)\n {\n@@ -6695,14 +6593,12 @@ ffecom_intrinsic_len_ (ffebld expr)\n   return length;\n }\n \n-#endif\n /* Handle CHARACTER assignments.\n \n    Generates code to do the assignment.\t Used by ordinary assignment\n    statement handler ffecom_let_stmt and by statement-function\n    handler to generate code for a statement function.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffecom_let_char_ (tree dest_tree, tree dest_length,\n \t\t  ffetargetCharacterSize dest_size, ffebld source)\n@@ -6904,7 +6800,6 @@ ffecom_let_char_ (tree dest_tree, tree dest_length,\n   ffecom_concat_list_kill_ (catlist);\n }\n \n-#endif\n /* ffecom_make_gfrt_ -- Make initial info for run-time routine\n \n    ffecomGfrt ix;\n@@ -6913,7 +6808,6 @@ ffecom_let_char_ (tree dest_tree, tree dest_length,\n    Assumes gfrt_[ix] is NULL_TREE, and replaces it with the FUNCTION_DECL\n    for the indicated run-time routine (ix).  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffecom_make_gfrt_ (ffecomGfrt ix)\n {\n@@ -7012,10 +6906,8 @@ ffecom_make_gfrt_ (ffecomGfrt ix)\n   ffecom_gfrt_[ix] = t;\n }\n \n-#endif\n /* Phase 1 pass over each member of a COMMON/EQUIVALENCE group.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffecom_member_phase1_ (ffestorag mst UNUSED, ffestorag st)\n {\n@@ -7025,12 +6917,10 @@ ffecom_member_phase1_ (ffestorag mst UNUSED, ffestorag st)\n     ffecom_member_namelisted_ = TRUE;\n }\n \n-#endif\n /* Phase 2 pass over each member of a COMMON/EQUIVALENCE group.  Declare\n    the member so debugger will see it.  Otherwise nobody should be\n    referencing the member.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffecom_member_phase2_ (ffestorag mst, ffestorag st)\n {\n@@ -7075,7 +6965,6 @@ ffecom_member_phase2_ (ffestorag mst, ffestorag st)\n   finish_decl (t, NULL_TREE, FALSE);\n }\n \n-#endif\n /* Prepare source expression for assignment into a destination perhaps known\n    to be of a specific size.  */\n \n@@ -7131,7 +7020,6 @@ ffecom_prepare_let_char_ (ffetargetCharacterSize dest_size, ffebld source)\n    always known by both the caller and the callee, though the code allows\n    for someday permitting CHAR*(*) stmtfunc dummies).  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffecom_push_dummy_decls_ (ffebld dummy_list, bool stmtfunc)\n {\n@@ -7201,13 +7089,11 @@ ffecom_push_dummy_decls_ (ffebld dummy_list, bool stmtfunc)\n   ffecom_transform_only_dummies_ = FALSE;\n }\n \n-#endif\n /* ffecom_start_progunit_ -- Beginning of program unit\n \n    Does GNU back end stuff necessary to teach it about the start of its\n    equivalent of a Fortran program unit.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffecom_start_progunit_ ()\n {\n@@ -7430,7 +7316,6 @@ ffecom_start_progunit_ ()\n     ffesymbol_drive (ffecom_finish_symbol_transform_);\n }\n \n-#endif\n /* ffecom_sym_transform_ -- Transform FFE sym into backend sym\n \n    ffesymbol s;\n@@ -7439,7 +7324,6 @@ ffecom_start_progunit_ ()\n    The ffesymbol_hook info for s is updated with appropriate backend info\n    on the symbol.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static ffesymbol\n ffecom_sym_transform_ (ffesymbol s)\n {\n@@ -7503,9 +7387,7 @@ ffecom_sym_transform_ (ffesymbol s)\n \t  t = build_decl (PARM_DECL,\n \t\t\t  ffecom_get_identifier_ (ffesymbol_text (s)),\n \t\t\t  ffecom_tree_ptr_to_subr_type);\n-#if BUILT_FOR_270\n \t  DECL_ARTIFICIAL (t) = 1;\n-#endif\n \t  addr = TRUE;\n \t  break;\n \n@@ -7972,9 +7854,7 @@ ffecom_sym_transform_ (ffesymbol s)\n \t      }\n \n \t    t = build_decl (PARM_DECL, t, type);\n-#if BUILT_FOR_270\n \t    DECL_ARTIFICIAL (t) = 1;\n-#endif\n \n \t    /* If this arg is present in every entry point's list of\n \t       dummy args, then we're done.  */\n@@ -8194,9 +8074,7 @@ ffecom_sym_transform_ (ffesymbol s)\n \t  t = build_decl (PARM_DECL,\n \t\t\t  ffecom_get_identifier_ (ffesymbol_text (s)),\n \t\t\t  t);\n-#if BUILT_FOR_270\n \t  DECL_ARTIFICIAL (t) = 1;\n-#endif\n \t  addr = TRUE;\n \t  break;\n \n@@ -8264,9 +8142,7 @@ ffecom_sym_transform_ (ffesymbol s)\n \t  t = build_decl (PARM_DECL,\n \t\t\t  ffecom_get_identifier_ (ffesymbol_text (s)),\n \t\t\t  ffecom_tree_ptr_to_subr_type);\n-#if BUILT_FOR_270\n \t  DECL_ARTIFICIAL (t) = 1;\n-#endif\n \t  addr = TRUE;\n \t  break;\n \n@@ -8459,7 +8335,6 @@ ffecom_sym_transform_ (ffesymbol s)\n   return s;\n }\n \n-#endif\n /* Transform into ASSIGNable symbol.\n \n    Symbol has already been transformed, but for whatever reason, the\n@@ -8468,7 +8343,6 @@ ffecom_sym_transform_ (ffesymbol s)\n    another local symbol of type void * and stuff that in the assign_tree\n    argument.  The F77/F90 standards allow this implementation.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static ffesymbol\n ffecom_sym_transform_assign_ (ffesymbol s)\n {\n@@ -8542,7 +8416,6 @@ ffecom_sym_transform_assign_ (ffesymbol s)\n   return s;\n }\n \n-#endif\n /* Implement COMMON area in back end.\n \n    Because COMMON-based variables can be referenced in the dimension\n@@ -8571,7 +8444,6 @@ ffecom_sym_transform_assign_ (ffesymbol s)\n    though we might do that as well just for debugging purposes (and\n    stuff the rtl with the appropriate offset expression).  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffecom_transform_common_ (ffesymbol s)\n {\n@@ -8723,10 +8595,8 @@ ffecom_transform_common_ (ffesymbol s)\n   ffecom_save_tree_forever (cbt);\n }\n \n-#endif\n /* Make master area for local EQUIVALENCE.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffecom_transform_equiv_ (ffestorag eqst)\n {\n@@ -8856,10 +8726,8 @@ ffecom_transform_equiv_ (ffestorag eqst)\n \t\t   eqst);\n }\n \n-#endif\n /* Implement NAMELIST in back end.  See f2c/format.c for more info.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_transform_namelist_ (ffesymbol s)\n {\n@@ -8939,14 +8807,11 @@ ffecom_transform_namelist_ (ffesymbol s)\n   return nmlt;\n }\n \n-#endif\n-\n /* A subroutine of ffecom_tree_canonize_ref_.  The incoming tree is\n    analyzed on the assumption it is calculating a pointer to be\n    indirected through.  It must return the proper decl and offset,\n    taking into account different units of measurements for offsets.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffecom_tree_canonize_ptr_ (tree *decl, tree *offset,\n \t\t\t   tree t)\n@@ -9001,7 +8866,6 @@ ffecom_tree_canonize_ptr_ (tree *decl, tree *offset,\n       break;\n     }\n }\n-#endif\n \n /* Given a tree that is possibly intended for use as an lvalue, return\n    information representing a canonical view of that tree as a decl, an\n@@ -9034,7 +8898,6 @@ ffecom_tree_canonize_ptr_ (tree *decl, tree *offset,\n    whereas converting the array offsets to consistant offsets will\n    reveal the overlap.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffecom_tree_canonize_ref_ (tree *decl, tree *offset,\n \t\t\t   tree *size, tree t)\n@@ -9186,11 +9049,9 @@ ffecom_tree_canonize_ref_ (tree *decl, tree *offset,\n       return;\n     }\n }\n-#endif\n \n /* Do divide operation appropriate to type of operands.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_tree_divide_ (tree tree_type, tree left, tree right,\n \t\t     tree dest_tree, ffebld dest, bool *dest_used,\n@@ -9278,10 +9139,8 @@ ffecom_tree_divide_ (tree tree_type, tree left, tree right,\n     }\n }\n \n-#endif\n /* Build type info for non-dummy variable.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_type_localvar_ (ffesymbol s, ffeinfoBasictype bt,\n \t\t       ffeinfoKindtype kt)\n@@ -9338,10 +9197,8 @@ ffecom_type_localvar_ (ffesymbol s, ffeinfoBasictype bt,\n   return type;\n }\n \n-#endif\n /* Build Namelist type.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_type_namelist_ ()\n {\n@@ -9373,11 +9230,8 @@ ffecom_type_namelist_ ()\n   return type;\n }\n \n-#endif\n-\n /* Build Vardesc type.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_type_vardesc_ ()\n {\n@@ -9406,9 +9260,6 @@ ffecom_type_vardesc_ ()\n   return type;\n }\n \n-#endif\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_vardesc_ (ffebld expr)\n {\n@@ -9497,8 +9348,6 @@ ffecom_vardesc_ (ffebld expr)\n   return ffesymbol_hook (s).vardesc_tree;\n }\n \n-#endif\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_vardesc_array_ (ffesymbol s)\n {\n@@ -9544,8 +9393,6 @@ ffecom_vardesc_array_ (ffesymbol s)\n   return var;\n }\n \n-#endif\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static tree\n ffecom_vardesc_dims_ (ffesymbol s)\n {\n@@ -9655,14 +9502,12 @@ ffecom_vardesc_dims_ (ffesymbol s)\n   }\n }\n \n-#endif\n /* Essentially does a \"fold (build1 (code, type, node))\" while checking\n    for certain housekeeping things.\n \n    NOTE: for building an ADDR_EXPR around a FUNCTION_DECL, use\n    ffecom_1_fn instead.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_1 (enum tree_code code, tree type, tree node)\n {\n@@ -9720,15 +9565,13 @@ ffecom_1 (enum tree_code code, tree type, tree node)\n     TREE_CONSTANT (item) = 1;\n   return fold (item);\n }\n-#endif\n \n /* Like ffecom_1 (ADDR_EXPR, TREE_TYPE (node), node), except\n    handles TREE_CODE (node) == FUNCTION_DECL.  In particular,\n    does not set TREE_ADDRESSABLE (because calling an inline\n    function does not mean the function needs to be separately\n    compiled).  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_1_fn (tree node)\n {\n@@ -9749,12 +9592,10 @@ ffecom_1_fn (tree node)\n     TREE_CONSTANT (item) = 1;\n   return fold (item);\n }\n-#endif\n \n /* Essentially does a \"fold (build (code, type, node1, node2))\" while\n    checking for certain housekeeping things.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_2 (enum tree_code code, tree type, tree node1,\n \t  tree node2)\n@@ -9923,7 +9764,6 @@ ffecom_2 (enum tree_code code, tree type, tree node1,\n   return fold (item);\n }\n \n-#endif\n /* ffecom_2pass_advise_entrypoint -- Advise that there's this entrypoint\n \n    ffesymbol s;\t // the ENTRY point itself\n@@ -9942,7 +9782,6 @@ ffecom_2 (enum tree_code code, tree type, tree node1,\n    03-Jan-92  JCB  2.0\n       Return FALSE if the return type conflicts with previous entrypoints.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n bool\n ffecom_2pass_advise_entrypoint (ffesymbol entry)\n {\n@@ -10080,7 +9919,6 @@ ffecom_2pass_advise_entrypoint (ffesymbol entry)\n   return TRUE;\n }\n \n-#endif\n /* ffecom_2pass_do_entrypoint -- Do compilation of entrypoint\n \n    ffesymbol s;\t // the ENTRY point itself\n@@ -10090,7 +9928,6 @@ ffecom_2pass_advise_entrypoint (ffesymbol entry)\n    happen.  Must be called for each entrypoint after\n    ffecom_finish_progunit is called.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n void\n ffecom_2pass_do_entrypoint (ffesymbol entry)\n {\n@@ -10111,13 +9948,10 @@ ffecom_2pass_do_entrypoint (ffesymbol entry)\n   ffecom_do_entry_ (entry, ent_num);\n }\n \n-#endif\n-\n /* Essentially does a \"fold (build (code, type, node1, node2))\" while\n    checking for certain housekeeping things.  Always sets\n    TREE_SIDE_EFFECTS.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_2s (enum tree_code code, tree type, tree node1,\n \t   tree node2)\n@@ -10134,11 +9968,9 @@ ffecom_2s (enum tree_code code, tree type, tree node1,\n   return fold (item);\n }\n \n-#endif\n /* Essentially does a \"fold (build (code, type, node1, node2, node3))\" while\n    checking for certain housekeeping things.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_3 (enum tree_code code, tree type, tree node1,\n \t  tree node2, tree node3)\n@@ -10158,12 +9990,10 @@ ffecom_3 (enum tree_code code, tree type, tree node1,\n   return fold (item);\n }\n \n-#endif\n /* Essentially does a \"fold (build (code, type, node1, node2, node3))\" while\n    checking for certain housekeeping things.  Always sets\n    TREE_SIDE_EFFECTS.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_3s (enum tree_code code, tree type, tree node1,\n \t   tree node2, tree node3)\n@@ -10181,8 +10011,6 @@ ffecom_3s (enum tree_code code, tree type, tree node1,\n   return fold (item);\n }\n \n-#endif\n-\n /* ffecom_arg_expr -- Transform argument expr into gcc tree\n \n    See use by ffecom_list_expr.\n@@ -10200,7 +10028,6 @@ ffecom_3s (enum tree_code code, tree type, tree node1,\n       we allow CHARACTER*(*) dummies to statement functions, we'll need\n       it).  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_arg_expr (ffebld expr, tree *length)\n {\n@@ -10217,7 +10044,6 @@ ffecom_arg_expr (ffebld expr, tree *length)\n   return ffecom_arg_ptr_to_expr (expr, &ign);\n }\n \n-#endif\n /* Transform expression into constant argument-pointer-to-expression tree.\n \n    If the expression can be transformed into a argument-pointer-to-expression\n@@ -10286,7 +10112,6 @@ ffecom_arg_ptr_to_const_expr (ffebld expr, tree *length)\n    length argument.  This might even be seen as a feature, if a null\n    byte can always be appended.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_arg_ptr_to_expr (ffebld expr, tree *length)\n {\n@@ -10529,15 +10354,13 @@ ffecom_arg_ptr_to_expr (ffebld expr, tree *length)\n   return item;\n }\n \n-#endif\n /* Generate call to run-time function.\n \n    The first arg is the GNU Fortran Run-Time function index, the second\n    arg is the list of arguments to pass to it.\tReturned is the expression\n    (WITHOUT TREE_SIDE_EFFECTS set!) that makes the call and returns the\n    result (which may be void).\t*/\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_call_gfrt (ffecomGfrt ix, tree args, tree hook)\n {\n@@ -10547,11 +10370,9 @@ ffecom_call_gfrt (ffecomGfrt ix, tree args, tree hook)\n \t\t       NULL_TREE, args, NULL_TREE, NULL,\n \t\t       NULL, NULL_TREE, TRUE, hook);\n }\n-#endif\n \n /* Transform constant-union to tree.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_constantunion (ffebldConstantUnion *cu, ffeinfoBasictype bt,\n \t\t      ffeinfoKindtype kt, tree tree_type)\n@@ -10819,8 +10640,6 @@ ffecom_constantunion (ffebldConstantUnion *cu, ffeinfoBasictype bt,\n   return item;\n }\n \n-#endif\n-\n /* Transform expression into constant tree.\n \n    If the expression can be transformed into a tree that is constant,\n@@ -10860,7 +10679,6 @@ ffecom_const_expr (ffebld expr)\n \n /* Handy way to make a field in a struct/union.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_decl_field (tree context, tree prevfield,\n \t\t   const char *name, tree type)\n@@ -10877,35 +10695,25 @@ ffecom_decl_field (tree context, tree prevfield,\n   return field;\n }\n \n-#endif\n-\n void\n ffecom_close_include (FILE *f)\n {\n-#if FFECOM_GCC_INCLUDE\n   ffecom_close_include_ (f);\n-#endif\n }\n \n int\n ffecom_decode_include_option (char *spec)\n {\n-#if FFECOM_GCC_INCLUDE\n   return ffecom_decode_include_option_ (spec);\n-#else\n-  return 1;\n-#endif\n }\n \n /* End a compound statement (block).  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_end_compstmt (void)\n {\n   return bison_rule_compstmt_ ();\n }\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \n /* ffecom_end_transition -- Perform end transition on all symbols\n \n@@ -10916,28 +10724,20 @@ ffecom_end_compstmt (void)\n void\n ffecom_end_transition ()\n {\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n   ffebld item;\n-#endif\n \n   if (ffe_is_ffedebug ())\n     fprintf (dmpout, \"; end_stmt_transition\\n\");\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n   ffecom_list_blockdata_ = NULL;\n   ffecom_list_common_ = NULL;\n-#endif\n \n   ffesymbol_drive (ffecom_sym_end_transition);\n   if (ffe_is_ffedebug ())\n     {\n       ffestorag_report ();\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-      ffesymbol_report_all ();\n-#endif\n     }\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n   ffecom_start_progunit_ ();\n \n   for (item = ffecom_list_blockdata_;\n@@ -10988,7 +10788,6 @@ ffecom_end_transition ()\n     ffecom_transform_common_ (ffebld_symter (ffebld_head (item)));\n \n   ffecom_list_common_ = NULL;\n-#endif\n }\n \n /* ffecom_exec_transition -- Perform exec transition on all symbols\n@@ -11014,9 +10813,6 @@ ffecom_exec_transition ()\n   if (ffe_is_ffedebug ())\n     {\n       ffestorag_report ();\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-      ffesymbol_report_all ();\n-#endif\n     }\n \n   if (inhibited)\n@@ -11028,7 +10824,6 @@ ffecom_exec_transition ()\n    Convert dest and source using ffecom_expr, then join them\n    with an ASSIGN op and pass the whole thing to expand_expr_stmt.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n void\n ffecom_expand_let_stmt (ffebld dest, ffebld source)\n {\n@@ -11138,7 +10933,6 @@ ffecom_expand_let_stmt (ffebld dest, ffebld source)\n \t\t    source);\n }\n \n-#endif\n /* ffecom_expr -- Transform expr into gcc tree\n \n    tree t;\n@@ -11148,41 +10942,34 @@ ffecom_expand_let_stmt (ffebld dest, ffebld source)\n    Recursive descent on expr while making corresponding tree nodes and\n    attaching type info and such.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_expr (ffebld expr)\n {\n   return ffecom_expr_ (expr, NULL_TREE, NULL, NULL, FALSE, FALSE);\n }\n \n-#endif\n /* Like ffecom_expr, but return tree usable for assigned GOTO or FORMAT.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_expr_assign (ffebld expr)\n {\n   return ffecom_expr_ (expr, NULL_TREE, NULL, NULL, TRUE, FALSE);\n }\n \n-#endif\n /* Like ffecom_expr_rw, but return tree usable for ASSIGN.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_expr_assign_w (ffebld expr)\n {\n   return ffecom_expr_ (expr, NULL_TREE, NULL, NULL, TRUE, FALSE);\n }\n \n-#endif\n /* Transform expr for use as into read/write tree and stabilize the\n    reference.  Not for use on CHARACTER expressions.\n \n    Recursive descent on expr while making corresponding tree nodes and\n    attaching type info and such.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_expr_rw (tree type, ffebld expr)\n {\n@@ -11193,14 +10980,12 @@ ffecom_expr_rw (tree type, ffebld expr)\n   return stabilize_reference (ffecom_expr (expr));\n }\n \n-#endif\n /* Transform expr for use as into write tree and stabilize the\n    reference.  Not for use on CHARACTER expressions.\n \n    Recursive descent on expr while making corresponding tree nodes and\n    attaching type info and such.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_expr_w (tree type, ffebld expr)\n {\n@@ -11211,10 +10996,8 @@ ffecom_expr_w (tree type, ffebld expr)\n   return stabilize_reference (ffecom_expr (expr));\n }\n \n-#endif\n /* Do global stuff.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n void\n ffecom_finish_compile ()\n {\n@@ -11224,21 +11007,17 @@ ffecom_finish_compile ()\n   ffeglobal_drive (ffecom_finish_global_);\n }\n \n-#endif\n /* Public entry point for front end to access finish_decl.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n void\n ffecom_finish_decl (tree decl, tree init, bool is_top_level)\n {\n   assert (!is_top_level);\n   finish_decl (decl, init, FALSE);\n }\n \n-#endif\n /* Finish a program unit.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n void\n ffecom_finish_progunit ()\n {\n@@ -11250,11 +11029,8 @@ ffecom_finish_progunit ()\n   finish_function (0);\n }\n \n-#endif\n-\n /* Wrapper for get_identifier.  pattern is sprintf-like.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_get_invented_identifier (const char *pattern, ...)\n {\n@@ -11420,9 +11196,7 @@ ffecom_init_0 ()\n \t}\n     }\n \n-#if FFECOM_GCC_INCLUDE\n   ffecom_initialize_char_syntax_ ();\n-#endif\n \n   ffecom_outer_function_decl_ = NULL_TREE;\n   current_function_decl = NULL_TREE;\n@@ -11962,9 +11736,7 @@ ffecom_init_0 ()\n   builtin_function (\"__builtin_cosl\", ldouble_ftype_ldouble,\n \t\t    BUILT_IN_COS, BUILT_IN_NORMAL, \"cosl\");\n \n-#if BUILT_FOR_270\n   pedantic_lvalues = FALSE;\n-#endif\n \n   ffecom_f2c_make_type_ (&ffecom_f2c_integer_type_node,\n \t\t\t FFECOM_f2cINTEGER,\n@@ -12080,12 +11852,10 @@ ffecom_init_0 ()\n #endif\n }\n \n-#endif\n /* ffecom_init_2 -- Initialize\n \n    ffecom_init_2();  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n void\n ffecom_init_2 ()\n {\n@@ -12101,7 +11871,6 @@ ffecom_init_2 ()\n   ffecom_multi_retval_ = NULL_TREE;\n }\n \n-#endif\n /* ffecom_list_expr -- Transform list of exprs into gcc tree\n \n    tree t;\n@@ -12110,7 +11879,6 @@ ffecom_init_2 ()\n \n    List of actual args is transformed into corresponding gcc backend list.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_list_expr (ffebld expr)\n {\n@@ -12142,7 +11910,6 @@ ffecom_list_expr (ffebld expr)\n   return list;\n }\n \n-#endif\n /* ffecom_list_ptr_to_expr -- Transform list of exprs into gcc tree\n \n    tree t;\n@@ -12152,7 +11919,6 @@ ffecom_list_expr (ffebld expr)\n    List of actual args is transformed into corresponding gcc backend list for\n    use in calling an external procedure (vs. a statement function).  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_list_ptr_to_expr (ffebld expr)\n {\n@@ -12184,10 +11950,8 @@ ffecom_list_ptr_to_expr (ffebld expr)\n   return list;\n }\n \n-#endif\n /* Obtain gcc's LABEL_DECL tree for label.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_lookup_label (ffelab label)\n {\n@@ -12247,13 +12011,11 @@ ffecom_lookup_label (ffelab label)\n   return glabel;\n }\n \n-#endif\n /* Stabilizes the arguments.  Don't use this if the lhs and rhs come from\n    a single source specification (as in the fourth argument of MVBITS).\n    If the type is NULL_TREE, the type of lhs is used to make the type of\n    the MODIFY_EXPR.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_modify (tree newtype, tree lhs,\n \t       tree rhs)\n@@ -12270,16 +12032,12 @@ ffecom_modify (tree newtype, tree lhs,\n   return ffecom_2s (MODIFY_EXPR, newtype, lhs, rhs);\n }\n \n-#endif\n-\n /* Register source file name.  */\n \n void\n ffecom_file (const char *name)\n {\n-#if FFECOM_GCC_INCLUDE\n   ffecom_file_ (name);\n-#endif\n }\n \n /* ffecom_notify_init_storage -- An aggregate storage is now fully init'ed\n@@ -12314,61 +12072,15 @@ void\n ffecom_notify_init_storage (ffestorag st)\n {\n   ffebld init;\t\t\t/* The initialization expression. */\n-#if 0 && FFECOM_targetCURRENT == FFECOM_targetGCC\n-  ffetargetOffset size;\t\t/* The size of the entity. */\n-  ffetargetAlign pad;\t\t/* Its initial padding. */\n-#endif\n \n   if (ffestorag_init (st) == NULL)\n     {\n       init = ffestorag_accretion (st);\n       assert (init != NULL);\n       ffestorag_set_accretion (st, NULL);\n       ffestorag_set_accretes (st, 0);\n-\n-#if 0 && FFECOM_targetCURRENT == FFECOM_targetGCC\n-      /* For GNU backend, just turn ACCTER into ARRTER and proceed. */\n-      size = ffebld_accter_size (init);\n-      pad = ffebld_accter_pad (init);\n-      ffebit_kill (ffebld_accter_bits (init));\n-      ffebld_set_op (init, FFEBLD_opARRTER);\n-      ffebld_set_arrter (init, ffebld_accter (init));\n-      ffebld_arrter_set_size (init, size);\n-      ffebld_arrter_set_pad (init, size);\n-#endif\n-\n-#if FFECOM_TWOPASS\n       ffestorag_set_init (st, init);\n-#endif\n     }\n-#if FFECOM_ONEPASS\n-  else\n-    init = ffestorag_init (st);\n-#endif\n-\n-#if FFECOM_ONEPASS\t\t/* Process the inits, wipe 'em out. */\n-  ffestorag_set_init (st, ffebld_new_any ());\n-\n-  if (ffebld_op (init) == FFEBLD_opANY)\n-    return;\t\t\t/* Oh, we already did this! */\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-  {\n-    ffesymbol s;\n-\n-    if (ffestorag_symbol (st) != NULL)\n-      s = ffestorag_symbol (st);\n-    else\n-      s = ffestorag_typesymbol (st);\n-\n-    fprintf (dmpout, \"= initialize_storage \\\"%s\\\" \",\n-\t     (s != NULL) ? ffesymbol_text (s) : \"(unnamed)\");\n-    ffebld_dump (init);\n-    fputc ('\\n', dmpout);\n-  }\n-#endif\n-\n-#endif /* if FFECOM_ONEPASS */\n }\n \n /* ffecom_notify_init_symbol -- A symbol is now fully init'ed\n@@ -12403,10 +12115,6 @@ void\n ffecom_notify_init_symbol (ffesymbol s)\n {\n   ffebld init;\t\t\t/* The initialization expression. */\n-#if 0 && FFECOM_targetCURRENT == FFECOM_targetGCC\n-  ffetargetOffset size;\t\t/* The size of the entity. */\n-  ffetargetAlign pad;\t\t/* Its initial padding. */\n-#endif\n \n   if (ffesymbol_storage (s) == NULL)\n     return;\t\t\t/* Do nothing until COMMON/EQUIVALENCE\n@@ -12417,40 +12125,8 @@ ffecom_notify_init_symbol (ffesymbol s)\n     {\n       ffesymbol_set_accretion (s, NULL);\n       ffesymbol_set_accretes (s, 0);\n-\n-#if 0 && FFECOM_targetCURRENT == FFECOM_targetGCC\n-      /* For GNU backend, just turn ACCTER into ARRTER and proceed. */\n-      size = ffebld_accter_size (init);\n-      pad = ffebld_accter_pad (init);\n-      ffebit_kill (ffebld_accter_bits (init));\n-      ffebld_set_op (init, FFEBLD_opARRTER);\n-      ffebld_set_arrter (init, ffebld_accter (init));\n-      ffebld_arrter_set_size (init, size);\n-      ffebld_arrter_set_pad (init, size);\n-#endif\n-\n-#if FFECOM_TWOPASS\n       ffesymbol_set_init (s, init);\n-#endif\n     }\n-#if FFECOM_ONEPASS\n-  else\n-    init = ffesymbol_init (s);\n-#endif\n-\n-#if FFECOM_ONEPASS\n-  ffesymbol_set_init (s, ffebld_new_any ());\n-\n-  if (ffebld_op (init) == FFEBLD_opANY)\n-    return;\t\t\t/* Oh, we already did this! */\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-  fprintf (dmpout, \"= initialize_symbol \\\"%s\\\" \", ffesymbol_text (s));\n-  ffebld_dump (init);\n-  fputc ('\\n', dmpout);\n-#endif\n-\n-#endif /* if FFECOM_ONEPASS */\n }\n \n /* ffecom_notify_primary_entry -- Learn which is the primary entry point\n@@ -12482,7 +12158,6 @@ ffecom_notify_primary_entry (ffesymbol s)\n \tfprintf (stderr, \"  %s:\\n\", ffesymbol_text (s));\n     }\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n   if (ffecom_primary_entry_kind_ == FFEINFO_kindSUBROUTINE)\n     {\n       ffebld list;\n@@ -12500,17 +12175,12 @@ ffecom_notify_primary_entry (ffesymbol s)\n \t    }\n \t}\n     }\n-#endif\n }\n \n FILE *\n ffecom_open_include (char *name, ffewhereLine l, ffewhereColumn c)\n {\n-#if FFECOM_GCC_INCLUDE\n   return ffecom_open_include_ (name, l, c);\n-#else\n-  return fopen (name, \"r\");\n-#endif\n }\n \n /* ffecom_ptr_to_expr -- Transform expr into gcc tree with & in front\n@@ -12521,7 +12191,6 @@ ffecom_open_include (char *name, ffewhereLine l, ffewhereColumn c)\n \n    Like ffecom_expr, but sticks address-of in front of most things.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_ptr_to_expr (ffebld expr)\n {\n@@ -12624,15 +12293,13 @@ ffecom_ptr_to_expr (ffebld expr)\n   return error_mark_node;\n }\n \n-#endif\n /* Obtain a temp var with given data type.\n \n    size is FFETARGET_charactersizeNONE for a non-CHARACTER type\n    or >= 0 for a CHARACTER type.\n \n    elements is -1 for a scalar or > 0 for an array of type.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_make_tempvar (const char *commentary, tree type,\n \t\t     ffetargetCharacterSize size, int elements)\n@@ -12667,7 +12334,6 @@ ffecom_make_tempvar (const char *commentary, tree type,\n \n   return t;\n }\n-#endif\n \n /* Prepare argument pointer to expression.\n \n@@ -13040,7 +12706,6 @@ ffecom_ptr_to_const_expr (ffebld expr)\n    meaning no return value or the caller expects it to be returned somewhere\n    else (which is handled by other parts of this module).  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_return_expr (ffebld expr)\n {\n@@ -13111,38 +12776,31 @@ ffecom_return_expr (ffebld expr)\n   return rtn;\n }\n \n-#endif\n /* Do save_expr only if tree is not error_mark_node.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_save_tree (tree t)\n {\n   return save_expr (t);\n }\n-#endif\n \n /* Start a compound statement (block).  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n void\n ffecom_start_compstmt (void)\n {\n   bison_rule_pushlevel_ ();\n }\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \n /* Public entry point for front end to access start_decl.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_start_decl (tree decl, bool is_initialized)\n {\n   DECL_INITIAL (decl) = is_initialized ? error_mark_node : NULL_TREE;\n   return start_decl (decl, FALSE);\n }\n \n-#endif\n /* ffecom_sym_commit -- Symbol's state being committed to reality\n \n    ffesymbol s;\n@@ -13151,14 +12809,12 @@ ffecom_start_decl (tree decl, bool is_initialized)\n    Does whatever the backend needs when a symbol is committed after having\n    been backtrackable for a period of time.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n void\n ffecom_sym_commit (ffesymbol s UNUSED)\n {\n   assert (!ffesymbol_retractable ());\n }\n \n-#endif\n /* ffecom_sym_end_transition -- Perform end transition on all symbols\n \n    ffecom_sym_end_transition();\n@@ -13178,7 +12834,6 @@ ffecom_sym_end_transition (ffesymbol s)\n \n   s = ffest_sym_end_transition (s);\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n   if ((ffesymbol_kind (s) == FFEINFO_kindBLOCKDATA)\n       && (ffesymbol_where (s) == FFEINFO_whereGLOBAL))\n     {\n@@ -13188,7 +12843,6 @@ ffecom_sym_end_transition (ffesymbol s)\n \t\t\t\t\t      FFEINTRIN_impNONE),\n \t\t\t   ffecom_list_blockdata_);\n     }\n-#endif\n \n   /* This is where we finally notice that a symbol has partial initialization\n      and finalize it. */\n@@ -13206,7 +12860,6 @@ ffecom_sym_end_transition (ffesymbol s)\n       ffecom_notify_init_storage (st);\n     }\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n   if ((ffesymbol_kind (s) == FFEINFO_kindCOMMON)\n       && (ffesymbol_where (s) == FFEINFO_whereLOCAL)\n       && (ffesymbol_storage (s) != NULL))\n@@ -13217,7 +12870,6 @@ ffecom_sym_end_transition (ffesymbol s)\n \t\t\t\t\t      FFEINTRIN_impNONE),\n \t\t\t   ffecom_list_common_);\n     }\n-#endif\n \n   return s;\n }\n@@ -13295,7 +12947,6 @@ ffecom_sym_learned (ffesymbol s)\n    Does whatever the backend needs when a symbol is retracted after having\n    been backtrackable for a period of time.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n void\n ffecom_sym_retract (ffesymbol s UNUSED)\n {\n@@ -13327,10 +12978,8 @@ ffecom_sym_retract (ffesymbol s UNUSED)\n #endif\n }\n \n-#endif\n /* Create temporary gcc label.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_temp_label ()\n {\n@@ -13347,35 +12996,29 @@ ffecom_temp_label ()\n   return glabel;\n }\n \n-#endif\n /* Return an expression that is usable as an arg in a conditional context\n    (IF, DO WHILE, .NOT., and so on).\n \n    Use the one provided for the back end as of >2.6.0.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_truth_value (tree expr)\n {\n   return truthvalue_conversion (expr);\n }\n \n-#endif\n /* Return the inversion of a truth value (the inversion of what\n    ffecom_truth_value builds).\n \n    Apparently invert_truthvalue, which is properly in the back end, is\n    enough for now, so just use it.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_truth_value_invert (tree expr)\n {\n   return invert_truthvalue (ffecom_truth_value (expr));\n }\n \n-#endif\n-\n /* Return the tree that is the type of the expression, as would be\n    returned in TREE_TYPE(ffecom_expr(expr)), without otherwise\n    transforming the expression, generating temporaries, etc.  */\n@@ -13451,16 +13094,13 @@ ffecom_type_expr (ffebld expr)\n    run time with the entrypoint number (0 for SUBROUTINE/FUNCTION, 1 for\n    first ENTRY statement, and so on).  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n ffecom_which_entrypoint_decl ()\n {\n   assert (ffecom_which_entrypoint_decl_ != NULL_TREE);\n \n   return ffecom_which_entrypoint_decl_;\n }\n-\n-#endif\n \f\n /* The following sections consists of private and public functions\n    that have the same names and perform roughly the same functions\n@@ -13477,8 +13117,6 @@ ffecom_which_entrypoint_decl ()\n    Functions named after rule \"foo:\" in c-parse.y are named\n    \"bison_rule_foo_\" so they are easy to find.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n-\n static void\n bison_rule_pushlevel_ ()\n {\n@@ -13699,13 +13337,11 @@ duplicate_decls (tree newdecl, tree olddecl)\n       if (DECL_SECTION_NAME (newdecl) == NULL_TREE)\n \tDECL_SECTION_NAME (newdecl) = DECL_SECTION_NAME (olddecl);\n \n-#if BUILT_FOR_270\n       if (TREE_CODE (newdecl) == FUNCTION_DECL)\n \t{\n \t  DECL_STATIC_CONSTRUCTOR(newdecl) |= DECL_STATIC_CONSTRUCTOR(olddecl);\n \t  DECL_STATIC_DESTRUCTOR (newdecl) |= DECL_STATIC_DESTRUCTOR (olddecl);\n \t}\n-#endif\n     }\n   /* If cannot merge, then use the new type and qualifiers,\n      and don't preserve the old rtl.  */\n@@ -14015,7 +13651,6 @@ lang_printable_name (tree decl, int v)\n /* g77's function to print out name of current function that caused\n    an error.  */\n \n-#if BUILT_FOR_270\n static void\n lang_print_error_function (diagnostic_context *context __attribute__((unused)),\n                            const char *file)\n@@ -14087,7 +13722,6 @@ lang_print_error_function (diagnostic_context *context __attribute__((unused)),\n       last_s = s;\n     }\n }\n-#endif\n \n /* Similar to `lookup_name' but look only at current binding level.  */\n \n@@ -14480,7 +14114,7 @@ incomplete_type_error (value, type)\n }\n \n /* Mark ARG for GC.  */\n-static void \n+static void\n mark_binding_level (void *arg)\n {\n   struct binding_level *level = *(struct binding_level **) arg;\n@@ -14546,11 +14180,11 @@ init_decl_processing ()\n   /* Record our roots.  */\n   for (i = 0; i < ARRAY_SIZE (tree_roots); i++)\n     ggc_add_tree_root (tree_roots[i], 1);\n-  ggc_add_tree_root (&ffecom_tree_type[0][0], \n+  ggc_add_tree_root (&ffecom_tree_type[0][0],\n \t\t     FFEINFO_basictype*FFEINFO_kindtype);\n-  ggc_add_tree_root (&ffecom_tree_fun_type[0][0], \n+  ggc_add_tree_root (&ffecom_tree_fun_type[0][0],\n \t\t     FFEINFO_basictype*FFEINFO_kindtype);\n-  ggc_add_tree_root (&ffecom_tree_ptr_to_fun_type[0][0], \n+  ggc_add_tree_root (&ffecom_tree_ptr_to_fun_type[0][0],\n \t\t     FFEINFO_basictype*FFEINFO_kindtype);\n   ggc_add_tree_root (ffecom_gfrt_, FFECOM_gfrt);\n   ggc_add_root (&current_binding_level, 1, sizeof current_binding_level,\n@@ -14584,9 +14218,7 @@ init_parse (filename)\n   /* Make identifier nodes long enough for the language-specific slots.  */\n   set_identifier_size (sizeof (struct lang_identifier));\n   decl_printable_name = lang_printable_name;\n-#if BUILT_FOR_270\n   print_error_function = lang_print_error_function;\n-#endif\n \n   return filename;\n }\n@@ -14989,9 +14621,7 @@ pushdecl (x)\n     {\n       if (IDENTIFIER_INVENTED (name))\n \t{\n-#if BUILT_FOR_270\n \t  DECL_ARTIFICIAL (x) = 1;\n-#endif\n \t  DECL_IN_SYSTEM_HEADER (x) = 1;\n \t}\n \n@@ -15557,7 +15187,7 @@ unsigned_type (type)\n   return type;\n }\n \n-void \n+void\n lang_mark_tree (t)\n      union tree_node *t ATTRIBUTE_UNUSED;\n {\n@@ -15571,11 +15201,7 @@ lang_mark_tree (t)\n   else if (TYPE_P (t) && TYPE_LANG_SPECIFIC (t))\n     ggc_mark (TYPE_LANG_SPECIFIC (t));\n }\n-\n-#endif /* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \f\n-#if FFECOM_GCC_INCLUDE\n-\n /* From gcc/cccp.c, the code to handle -I.  */\n \n /* Skip leading \"./\" from a directory name.\n@@ -16254,7 +15880,6 @@ ffecom_open_include_ (char *name, ffewhereLine l, ffewhereColumn c)\n \n   return f;\n }\n-#endif\t/* FFECOM_GCC_INCLUDE */\n \n /**INDENT* (Do not reformat this comment even with -fca option.)\n    Data-gathering files: Given the source file listed below, compiled with\n@@ -16740,20 +16365,20 @@ typedef doublereal E_f; // real function with -R not specified //\n     void pow_ci();\n     double pow_dd();\n     void pow_zz();\n-    double acos(), r_imag(), r_int(), log(), r_lg10(), r_mod(), r_nint(), \n+    double acos(), r_imag(), r_int(), log(), r_lg10(), r_mod(), r_nint(),\n             asin(), atan(), atan2(), c_abs();\n     void c_cos(), c_exp(), c_log(), r_cnjg();\n     double cos(), cosh();\n     void c_sin(), c_sqrt();\n-    double d_dim(), exp(), r_dim(), d_int(), d_lg10(), d_mod(), d_nint(), \n+    double d_dim(), exp(), r_dim(), d_int(), d_lg10(), d_mod(), d_nint(),\n             d_sign(), sin(), sinh(), sqrt(), tan(), tanh();\n     integer i_dim(), i_dnnt(), i_indx(), i_sign(), i_len();\n     logical l_ge(), l_gt(), l_le(), l_lt();\n     integer i_nint();\n     double r_sign();\n \n     // Local variables //\n-    extern // Subroutine // int fooa_(), fooc_(), food_(), fooi_(), foor_(), \n+    extern // Subroutine // int fooa_(), fooc_(), food_(), fooi_(), foor_(),\n             fool_(), fooz_(), getem_();\n     static char a1[10], a2[10];\n     static complex c1, c2;"}, {"sha": "5e20e2b10fb659ba756b4c69ea56b38f2b892a82", "filename": "gcc/f/com.h", "status": "modified", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fcom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fcom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.h?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -34,27 +34,9 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #define FFECOM_dimensionsMAX 7\t/* Max # dimensions (quick hack). */\n \n-#define FFECOM_targetFFE 1\n-#define FFECOM_targetGCC 2\n-\n-#ifndef FFE_STANDALONE\n-#define FFECOM_targetCURRENT FFECOM_targetGCC\t/* Backend! */\n-#define FFECOM_ONEPASS 0\n-#else\n-#define FFECOM_targetCURRENT FFECOM_targetFFE\n-#define FFECOM_ONEPASS 0\n-#endif\n-\n-#if FFECOM_ONEPASS\n-#define FFECOM_TWOPASS 0\n-#else\n-#define FFECOM_TWOPASS 1\n-#endif\n-\n #define FFECOM_SIZE_UNIT \"byte\"\t/* Singular form. */\n #define FFECOM_SIZE_UNITS \"bytes\"\t/* Plural form. */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n #define FFECOM_constantNULL NULL_TREE\n #define FFECOM_nonterNULL NULL_TREE\n #define FFECOM_globalNULL NULL_TREE\n@@ -139,31 +121,12 @@ typedef enum\n     FFECOM_gfrt\n   } ffecomGfrt;\n \n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n-\n /* Typedefs. */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n #ifndef TREE_CODE\n #include \"tree.h\"\n #endif\n \n-#ifndef BUILT_FOR_270\n-#ifdef DECL_STATIC_CONSTRUCTOR\t/* In gcc/tree.h. */\n-#define BUILT_FOR_270 1\n-#else\n-#define BUILT_FOR_270 0\n-#endif\n-#endif\t/* !defined (BUILT_FOR_270) */\n-\n-#ifndef BUILT_FOR_280\n-#ifdef DECL_ONE_ONLY\t/* In gcc/tree.h. */\n-#define BUILT_FOR_280 1\n-#else\n-#define BUILT_FOR_280 0\n-#endif\n-#endif\t/* !defined (BUILT_FOR_280) */\n-\n typedef tree ffecomConstant;\n #define FFECOM_constantHOOK\n typedef tree ffecomNonter;\n@@ -185,7 +148,6 @@ struct _ffecom_symbol_\n     tree assign_tree;\t\t/* For ASSIGN'ed vars. */\n     bool addr;\t\t\t/* Is address of item instead of item. */\n   };\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \n /* Include files needed by this one. */\n \n@@ -200,7 +162,6 @@ struct _ffecom_symbol_\n \n /* Global objects accessed by users of this module. */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n extern tree string_type_node;\n extern tree ffecom_integer_type_node;\n extern tree ffecom_integer_zero_node;\n@@ -227,11 +188,9 @@ extern tree ffecom_f2c_ftnlen_two_node;\n extern tree ffecom_f2c_ptr_to_ftnlen_type_node;\n extern tree ffecom_f2c_ftnint_type_node;\n extern tree ffecom_f2c_ptr_to_ftnint_type_node;\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \n /* Declare functions with prototypes. */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree ffecom_1 (enum tree_code code, tree type, tree node);\n tree ffecom_1_fn (tree node);\n tree ffecom_2 (enum tree_code code, tree type, tree node1, tree node2);\n@@ -251,16 +210,12 @@ tree ffecom_constantunion (ffebldConstantUnion *cu, ffeinfoBasictype bt,\n tree ffecom_const_expr (ffebld expr);\n tree ffecom_decl_field (tree context, tree prevfield, const char *name,\n \t\t\ttree type);\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n void ffecom_close_include (FILE *f);\n int ffecom_decode_include_option (char *spec);\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree ffecom_end_compstmt (void);\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n void ffecom_end_transition (void);\n void ffecom_exec_transition (void);\n void ffecom_expand_let_stmt (ffebld dest, ffebld source);\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree ffecom_expr (ffebld expr);\n tree ffecom_expr_assign (ffebld expr);\n tree ffecom_expr_assign_w (ffebld expr);\n@@ -282,13 +237,11 @@ tree ffecom_make_tempvar (const char *commentary, tree type,\n \t\t\t  ffetargetCharacterSize size, int elements);\n tree ffecom_modify (tree newtype, tree lhs, tree rhs);\n void ffecom_save_tree_forever (tree t);\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n void ffecom_file (const char *name);\n void ffecom_notify_init_storage (ffestorag st);\n void ffecom_notify_init_symbol (ffesymbol s);\n void ffecom_notify_primary_entry (ffesymbol fn);\n FILE *ffecom_open_include (char *name, ffewhereLine l, ffewhereColumn c);\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n void ffecom_prepare_arg_ptr_to_expr (ffebld expr);\n bool ffecom_prepare_end (void);\n void ffecom_prepare_expr_ (ffebld expr, ffebld dest);\n@@ -303,38 +256,22 @@ tree ffecom_save_tree (tree t);\n void ffecom_start_compstmt (void);\n tree ffecom_start_decl (tree decl, bool is_init);\n void ffecom_sym_commit (ffesymbol s);\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n ffesymbol ffecom_sym_end_transition (ffesymbol s);\n ffesymbol ffecom_sym_exec_transition (ffesymbol s);\n ffesymbol ffecom_sym_learned (ffesymbol s);\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n void ffecom_sym_retract (ffesymbol s);\n tree ffecom_temp_label (void);\n tree ffecom_truth_value (tree expr);\n tree ffecom_truth_value_invert (tree expr);\n tree ffecom_type_expr (ffebld expr);\n tree ffecom_which_entrypoint_decl (void);\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \n /* Define macros. */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-#define ffecom_expr(e) (e)\n-#define ffecom_init_0()\n-#define ffecom_init_2()\n-#define ffecom_label_kind() FFEINFO_kindtypeINTEGERDEFAULT\n-#define ffecom_pointer_kind() FFEINFO_kindtypeINTEGERDEFAULT\n-#define ffecom_ptr_to_expr(e) (e)\n-#define ffecom_sym_commit(s)\n-#define ffecom_sym_retract(s)\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetFFE */\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n #define ffecom_f2c_typecode(bt,kt) ffecom_f2c_typecode_[(bt)][(kt)]\n #define ffecom_label_kind() ffecom_label_kind_\n #define ffecom_pointer_kind() ffecom_pointer_kind_\n #define ffecom_prepare_expr(e) ffecom_prepare_expr_ ((e), NULL)\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \n #define ffecom_init_1()\n #define ffecom_init_3()"}, {"sha": "f58de9c4379d69be9634285dc9bc6d4887998419", "filename": "gcc/f/equiv.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fequiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fequiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fequiv.c?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -913,21 +913,6 @@ ffeequiv_add (ffeequiv eq, ffebld list, ffelexToken t)\n   ffeequiv_set_list (eq, ffebld_new_item (list, ffeequiv_list (eq)));\n }\n \n-/* ffeequiv_dump -- Dump info on equivalence object\n-\n-   ffeequiv eq;\n-   ffeequiv_dump(eq);  */\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void\n-ffeequiv_dump (ffeequiv eq)\n-{\n-  if (ffeequiv_common (eq) != NULL)\n-    fprintf (dmpout, \"(common %s) \", ffesymbol_text (ffeequiv_common (eq)));\n-  ffebld_dump (ffeequiv_list (eq));\n-}\n-#endif\n-\n /* ffeequiv_exec_transition -- Do the hard work on all the equivalence objects\n \n    ffeequiv_exec_transition();\t*/"}, {"sha": "59abfc875ca248c19a31fa8c315858ad35c2148c", "filename": "gcc/f/equiv.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fequiv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fequiv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fequiv.h?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -62,9 +62,6 @@ struct _ffeequiv_\n /* Declare functions with prototypes. */\n \n void ffeequiv_add (ffeequiv eq, ffebld list, ffelexToken t);\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void ffeequiv_dump (ffeequiv eq);\n-#endif\n void ffeequiv_exec_transition (void);\n void ffeequiv_init_2 (void);\n void ffeequiv_kill (ffeequiv victim);"}, {"sha": "15d984f7f4ed12188faee5c5e82993067593862f", "filename": "gcc/f/global.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fglobal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fglobal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fglobal.h?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -153,13 +153,7 @@ void ffeglobal_terminate_1 (void);\n \n /* Define macros. */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-#define FFEGLOBAL_ENABLED 0\n-#elif FFECOM_targetCURRENT == FFECOM_targetGCC\n #define FFEGLOBAL_ENABLED 1\n-#else\n-#error\n-#endif\n \n #define ffeglobal_common_init(g) ((g)->tick != 0)\n #define ffeglobal_common_have_pad(g) ((g)->u.common.have_pad)\n@@ -198,4 +192,4 @@ void ffeglobal_terminate_1 (void);\n /* End of #include file. */\n \n #endif /* ! GCC_F_GLOBAL_H */\n- \n+"}, {"sha": "44ab7a8ff8561d685ac420a9345fbc97cb7fc80b", "filename": "gcc/f/intdoc.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fintdoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fintdoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintdoc.c?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -96,9 +96,6 @@ struct _ffeintrin_spec_\n struct _ffeintrin_imp_\n   {\n     const char *const name;\t\t/* Name of implementation. */\n-#if 0\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n-    const ffecomGfrt gfrt;\t\t/* gfrt index in library. */\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n     const char *const control;\n   };\n \n@@ -136,19 +133,10 @@ static const struct _ffeintrin_imp_ imps[] = {\n #define DEFNAME(UPPER,LOWER,MIXED,GEN,SPEC)\n #define DEFGEN(CODE,NAME,SPEC1,SPEC2)\n #define DEFSPEC(CODE,NAME,CALLABLE,FAMILY,IMP)\n-#if 0\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n-#define DEFIMP(CODE,NAME,GFRTDIRECT,GFRTF2C,GFRTGNU,CONTROL) \\\n-  { NAME, FFECOM_gfrt ## GFRT, CONTROL },\n-#define DEFIMPY(CODE,NAME,GFRTDIRECT,GFRTF2C,GFRTGNU,CONTROL,Y2KBAD) \\\n-  { NAME, FFECOM_gfrt ## GFRT, CONTROL },\n-#elif 1\t/* FFECOM_targetCURRENT == FFECOM_targetFFE */\n #define DEFIMP(CODE,NAME,GFRTDIRECT,GFRTF2C,GFRTGNU,CONTROL) \\\n   { NAME, CONTROL },\n #define DEFIMPY(CODE,NAME,GFRTDIRECT,GFRTF2C,GFRTGNU,CONTROL,Y2KBAD) \\\n   { NAME, CONTROL },\n-#else\n-#error\n-#endif\n #include \"intrin.def\"\n #undef DEFNAME\n #undef DEFGEN"}, {"sha": "6b89bfadfce7b2276d23b1743d6fe0661a6e0b7b", "filename": "gcc/f/intrin.c", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fintrin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fintrin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintrin.c?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -58,11 +58,9 @@ struct _ffeintrin_spec_\n struct _ffeintrin_imp_\n   {\n     const char *const name;\t/* Name of implementation. */\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n     const ffecomGfrt gfrt_direct;/* library routine, direct-callable form. */\n     const ffecomGfrt gfrt_f2c;\t/* library routine, f2c-callable form. */\n     const ffecomGfrt gfrt_gnu;\t/* library routine, gnu-callable form. */\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n     const char *const control;\n     const char y2kbad;\n   };\n@@ -117,21 +115,12 @@ static const struct _ffeintrin_imp_ ffeintrin_imps_[]\n #define DEFNAME(UPPER,LOWER,MIXED,GEN,SPEC)\n #define DEFGEN(CODE,NAME,SPEC1,SPEC2)\n #define DEFSPEC(CODE,NAME,CALLABLE,FAMILY,IMP)\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n #define DEFIMP(CODE,NAME,GFRTDIRECT,GFRTF2C,GFRTGNU,CONTROL) \\\n       { NAME, FFECOM_gfrt ## GFRTDIRECT, FFECOM_gfrt ## GFRTF2C, \\\n \tFFECOM_gfrt ## GFRTGNU, CONTROL, FALSE },\n #define DEFIMPY(CODE,NAME,GFRTDIRECT,GFRTF2C,GFRTGNU,CONTROL,Y2KBAD) \\\n       { NAME, FFECOM_gfrt ## GFRTDIRECT, FFECOM_gfrt ## GFRTF2C, \\\n \tFFECOM_gfrt ## GFRTGNU, CONTROL, Y2KBAD },\n-#elif FFECOM_targetCURRENT == FFECOM_targetFFE\n-#define DEFIMP(CODE,NAME,GFRTDIRECT,GFRTF2C,GFRTGNU,CONTROL) \\\n-      { NAME, CONTROL, FALSE },\n-#define DEFIMPY(CODE,NAME,GFRTDIRECT,GFRTF2C,GFRTGNU,CONTROL,Y2KBAD) \\\n-      { NAME, CONTROL, Y2KBAD },\n-#else\n-#error\n-#endif\n #include \"intrin.def\"\n #undef DEFNAME\n #undef DEFGEN\n@@ -1195,7 +1184,7 @@ ffeintrin_basictype (ffeintrinSpec spec)\n \n   if (ffe_is_f2c ())\n     gfrt = ffeintrin_imps_[imp].gfrt_f2c;\n-  else \n+  else\n     gfrt = ffeintrin_imps_[imp].gfrt_gnu;\n \n   assert (gfrt != FFECOM_gfrt);\n@@ -1523,19 +1512,16 @@ ffeintrin_fulfill_specific (ffebld *expr, ffeinfo *info,\n \n /* Return run-time index of intrinsic implementation as direct call.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n ffecomGfrt\n ffeintrin_gfrt_direct (ffeintrinImp imp)\n {\n   assert (imp < FFEINTRIN_imp);\n \n   return ffeintrin_imps_[imp].gfrt_direct;\n }\n-#endif\n \n /* Return run-time index of intrinsic implementation as actual argument.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n ffecomGfrt\n ffeintrin_gfrt_indirect (ffeintrinImp imp)\n {\n@@ -1545,7 +1531,6 @@ ffeintrin_gfrt_indirect (ffeintrinImp imp)\n     return ffeintrin_imps_[imp].gfrt_gnu;\n   return ffeintrin_imps_[imp].gfrt_f2c;\n }\n-#endif\n \n void\n ffeintrin_init_0 ()\n@@ -1758,13 +1743,11 @@ ffeintrin_is_actualarg (ffeintrinSpec spec)\n   state = ffeintrin_state_family (ffeintrin_specs_[spec].family);\n \n   return (!ffe_is_pedantic () || ffeintrin_specs_[spec].is_actualarg)\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n     && (ffe_is_f2c ()\n \t? (ffeintrin_imps_[ffeintrin_specs_[spec].implementation].gfrt_f2c\n \t   != FFECOM_gfrt)\n \t: (ffeintrin_imps_[ffeintrin_specs_[spec].implementation].gfrt_gnu\n \t   != FFECOM_gfrt))\n-#endif\n     && ((state == FFE_intrinsicstateENABLED)\n \t|| (state == FFE_intrinsicstateHIDDEN));\n }"}, {"sha": "e741e69b4ecefa6e6861143a4aaa253a83dd330a", "filename": "gcc/f/intrin.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintrin.h?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -105,10 +105,8 @@ ffeintrinFamily ffeintrin_family (ffeintrinSpec spec);\n void ffeintrin_fulfill_generic (ffebld *expr, ffeinfo *info, ffelexToken t);\n void ffeintrin_fulfill_specific (ffebld *expr, ffeinfo *info,\n \t\t\t\t bool *check_intrin, ffelexToken t);\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n ffecomGfrt ffeintrin_gfrt_direct (ffeintrinImp imp);\n ffecomGfrt ffeintrin_gfrt_indirect (ffeintrinImp imp);\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n void ffeintrin_init_0 (void);\n #define ffeintrin_init_1()\n #define ffeintrin_init_2()"}, {"sha": "9fef050a0e9ca61776eb675b67e758fc68926002", "filename": "gcc/f/lex.c", "status": "modified", "additions": 3, "deletions": 47, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flex.c?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -27,13 +27,11 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"malloc.h\"\n #include \"src.h\"\n #include \"debug.h\"\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n #include \"flags.h\"\n #include \"input.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n #include \"ggc.h\"\n-#endif\n \n static void ffelex_append_to_token_ (char c);\n static int ffelex_backslash_ (int c, ffewhereColumnNumber col);\n@@ -45,10 +43,8 @@ static void ffelex_bad_2_ (ffebad errnum, ffewhereLineNumber ln0,\n static void ffelex_bad_here_ (int num, ffewhereLineNumber ln0,\n \t\t\t      ffewhereColumnNumber cn0);\n static void ffelex_finish_statement_ (void);\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static int ffelex_get_directive_line_ (char **text, FILE *finput);\n static int ffelex_hash_ (FILE *f);\n-#endif\n static ffewhereColumnNumber ffelex_image_char_ (int c,\n \t\t\t\t\t\tffewhereColumnNumber col);\n static void ffelex_include_ (void);\n@@ -561,7 +557,6 @@ ffelex_bad_here_ (int n, ffewhereLineNumber ln0,\n   ffewhere_column_kill (wc0);\n }\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static int\n ffelex_getc_ (FILE *finput)\n {\n@@ -578,8 +573,6 @@ ffelex_getc_ (FILE *finput)\n   return getc (finput);\n }\n \n-#endif\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static int\n ffelex_cfebackslash_ (int *use_d, int *d, FILE *finput)\n {\n@@ -725,10 +718,8 @@ ffelex_cfebackslash_ (int *use_d, int *d, FILE *finput)\n   return c;\n }\n \n-#endif\n /* A miniature version of the C front-end lexer.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static int\n ffelex_cfelex_ (ffelexToken *xtoken, FILE *finput, int c)\n {\n@@ -845,9 +836,7 @@ ffelex_cfelex_ (ffelexToken *xtoken, FILE *finput, int c)\n   *xtoken = token;\n   return c;\n }\n-#endif\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffelex_file_pop_ (const char *input_filename)\n {\n@@ -868,8 +857,6 @@ ffelex_file_pop_ (const char *input_filename)\n     input_file_stack->name = input_filename;\n }\n \n-#endif\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n ffelex_file_push_ (int old_lineno, const char *input_filename)\n {\n@@ -889,7 +876,6 @@ ffelex_file_push_ (int old_lineno, const char *input_filename)\n   if (input_file_stack)\n     input_file_stack->name = input_filename;\n }\n-#endif\n \n /* Prepare to finish a statement-in-progress by sending the current\n    token, if any, then setting up EOS as the current token with the\n@@ -980,7 +966,6 @@ ffelex_finish_statement_ ()\n \n /* Copied from gcc/c-common.c get_directive_line.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n static int\n ffelex_get_directive_line_ (char **text, FILE *finput)\n {\n@@ -1052,7 +1037,6 @@ ffelex_get_directive_line_ (char **text, FILE *finput)\n       char_escaped = (c == '\\\\' && ! char_escaped);\n     }\n }\n-#endif\n \n /* Handle # directives that make it through (or are generated by) the\n    preprocessor.  As much as reasonably possible, emulate the behavior\n@@ -1063,8 +1047,6 @@ ffelex_get_directive_line_ (char **text, FILE *finput)\n \n    Returns the next character unhandled, which is always newline or EOF.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n-\n #if defined HANDLE_PRAGMA\n /* Local versions of these macros, that can be passed as function pointers.  */\n static int\n@@ -1117,7 +1099,7 @@ ffelex_hash_ (FILE *finput)\n \t\t ISSPACE() may evaluate its argument more than once!  */\n \t      while (((c = getc (finput)), ISSPACE(c)))\n \t\tcontinue;\n-\t      \n+\n \t      do\n \t\t{\n \t\t  * buff ++ = c;\n@@ -1127,7 +1109,7 @@ ffelex_hash_ (FILE *finput)\n \t\t     && buff < buffer + 128);\n \n \t      pragma_ungetc (c);\n-\t\t\n+\n \t      * -- buff = 0;\n #ifdef HANDLE_PRAGMA\n \t      if (HANDLE_PRAGMA (pragma_getc, pragma_ungetc, buffer))\n@@ -1414,7 +1396,6 @@ ffelex_hash_ (FILE *finput)\n     ;\n   return c;\n }\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \n /* \"Image\" a character onto the card image, return incremented column number.\n \n@@ -1538,10 +1519,8 @@ ffelex_include_ ()\n   ffewhereLineNumber linecount_current = ffelex_linecount_current_;\n   ffewhereLineNumber linecount_offset\n     = ffewhere_line_filelinenum (current_wl);\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n   int old_lineno = lineno;\n   const char *old_input_filename = input_filename;\n-#endif\n \n   if (card_length != 0)\n     {\n@@ -1559,18 +1538,14 @@ ffelex_include_ ()\n \n   ffewhere_file_set (include_wherefile, TRUE, 0);\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n   ffelex_file_push_ (old_lineno, ffewhere_file_name (include_wherefile));\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \n   if (ffelex_include_free_form_)\n     ffelex_file_free (include_wherefile, include_file);\n   else\n     ffelex_file_fixed (include_wherefile, include_file);\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n   ffelex_file_pop_ (ffewhere_file_name (current_wf));\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \n   ffewhere_file_set (current_wf, TRUE, linecount_offset);\n \n@@ -1586,10 +1561,8 @@ ffelex_include_ ()\n     }\n   ffelex_card_image_[card_length] = '\\0';\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n   input_filename = old_input_filename;\n   lineno = old_lineno;\n-#endif\n   ffelex_linecount_current_ = linecount_current;\n   ffelex_current_wf_ = current_wf;\n   ffelex_final_nontab_column_ = final_nontab_column;\n@@ -1647,9 +1620,7 @@ ffelex_next_line_ ()\n {\n   ffelex_linecount_current_ = ffelex_linecount_next_;\n   ++ffelex_linecount_next_;\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n   ++lineno;\n-#endif\n }\n \n static void\n@@ -1865,10 +1836,8 @@ ffelex_file_fixed (ffewhereFile wf, FILE *f)\n \n   assert (ffelex_handler_ != NULL);\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n   lineno = 0;\n   input_filename = ffewhere_file_name (wf);\n-#endif\n   ffelex_current_wf_ = wf;\n   disallow_continuation_line = TRUE;\n   ignore_disallowed_continuation = FALSE;\n@@ -1957,10 +1926,8 @@ ffelex_file_fixed (ffewhereFile wf, FILE *f)\n \t  while ((c != '\\n') && (c != EOF))\n \t    c = getc (f);\n \t}\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n       else if (lextype == FFELEX_typeHASH)\n \tc = ffelex_hash_ (f);\n-#endif\n       else if (lextype == FFELEX_typeSLASH)\n \t{\n \t  /* SIDE-EFFECT ABOVE HAS HAPPENED. */\n@@ -3077,10 +3044,8 @@ ffelex_file_free (ffewhereFile wf, FILE *f)\n \n   assert (ffelex_handler_ != NULL);\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n   lineno = 0;\n   input_filename = ffewhere_file_name (wf);\n-#endif\n   ffelex_current_wf_ = wf;\n   continuation_line = FALSE;\n   ffelex_token_->type = FFELEX_typeNONE;\n@@ -3118,14 +3083,7 @@ ffelex_file_free (ffewhereFile wf, FILE *f)\n \t || (c == '#'))\n     {\n       if (c == '#')\n-\t{\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n-\t  c = ffelex_hash_ (f);\n-#else\n-\t  /* Don't skip over # line after all.  */\n-\t  break;\n-#endif\n-\t}\n+\tc = ffelex_hash_ (f);\n \n      comment_line:\t\t/* :::::::::::::::::::: */\n \n@@ -3968,7 +3926,6 @@ ffelex_file_free (ffewhereFile wf, FILE *f)\n \n /* See the code in com.c that calls this to understand why.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n void\n ffelex_hash_kludge (FILE *finput)\n {\n@@ -4005,7 +3962,6 @@ ffelex_hash_kludge (FILE *finput)\n     }\n }\n \n-#endif\n void\n ffelex_init_1 ()\n {"}, {"sha": "29c6133c38b4a4414d683448256a32f3aade4e4c", "filename": "gcc/f/parse.c", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fparse.c?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -24,72 +24,28 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"com.h\"\n #include \"where.h\"\n #include \"version.h\"\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n #include \"flags.h\"\n-#endif\n \n #define NAME_OF_STDIN \"<stdin>\"\n \n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void\n-main (int argc, char *argv[])\n-#elif FFECOM_targetCURRENT == FFECOM_targetGCC\n extern FILE *finput;\n \n int\n yyparse ()\n-#else\n-#error\n-#endif\n {\n   ffewhereFile wf;\n \n   if (ffe_is_version ())\n     fprintf (stderr, \"GNU Fortran Front End version %s\\n\", ffe_version_string);\n \n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-  ffe_init_0 ();\n-\n-  {\n-    int strings_processed;\n-    for (--argc, ++argv; argc > 0; argc -= strings_processed, argv += strings_processed)\n-      {\n-\tstrings_processed = ffe_decode_option (argc, argv);\n-\tif (strings_processed == 0)\n-\t  {\n-\t    fprintf (stderr, \"Unrecognized option: %s\\n\", argv[0]);\n-\t    strings_processed = 1;\n-\t  }\n-      }\n-  }\n-#elif FFECOM_targetCURRENT == FFECOM_targetGCC\n   if (!ffe_is_pedantic ())\n     ffe_set_is_pedantic (pedantic);\n-#else\n-#error\n-#endif\n \n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-  wf = ffewhere_file_new (NAME_OF_STDIN, strlen (NAME_OF_STDIN));\n-  ffecom_file (NAME_OF_STDIN);\n-  ffe_file (wf, stdin);\n-#elif FFECOM_targetCURRENT == FFECOM_targetGCC\n   wf = ffewhere_file_new (main_input_filename, strlen (main_input_filename));\n   ffecom_file (main_input_filename);\n   ffe_file (wf, finput);\n-#else\n-#error\n-#endif\n \n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n   ffecom_finish_compile ();\n \n   return 0;\n-#elif FFECOM_targetCURRENT == FFECOM_targetFFE\n-  ffe_terminate_0 ();\n-\n-  exit (0);\n-#else\n-#error\n-#endif\n }"}, {"sha": "0b4c11aa9efd4384692023807ca437ca76b713bf", "filename": "gcc/f/sta.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fsta.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fsta.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fsta.c?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -1452,9 +1452,6 @@ ffesta_eof ()\n   if (ffe_is_ffedebug ())\n     {\n       ffestorag_report ();\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-      ffesymbol_report_all ();\n-#endif\n     }\n }\n \n@@ -1990,9 +1987,6 @@ ffesta_zero (ffelexToken t)\n   if (ffe_is_ffedebug ())\n     {\n       ffestorag_report ();\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-      ffesymbol_report_all ();\n-#endif\n     }\n \n   ffelex_set_names (TRUE);"}, {"sha": "b8e3b39f6b430f03083c94b949be8842a42a4429", "filename": "gcc/f/std.c", "status": "modified", "additions": 406, "deletions": 2037, "changes": 2443, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fstd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fstd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstd.c?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1"}, {"sha": "6d1d0dc46dc8226569cc400597f0f7e1da79fe9f", "filename": "gcc/f/ste.c", "status": "modified", "additions": 1090, "deletions": 2168, "changes": 3258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fste.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fste.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fste.c?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1"}, {"sha": "fb32c792f9801cee7908324522d7f792c297a651", "filename": "gcc/f/ste.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fste.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fste.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fste.h?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -147,16 +147,10 @@ void ffeste_V026 (ffestpFindStmt *info);\n #define ffeste_init_2()\n #define ffeste_init_3()\n #define ffeste_init_4()\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n #define ffeste_filename() input_filename\n #define ffeste_filelinenum() lineno\n #define ffeste_set_line(name,num) \\\n   (input_filename = (name), lineno = (num))\n-#elif FFECOM_targetCURRENT == FFECOM_targetFFE\n-#define ffeste_set_line(name,num)\n-#else\n-#error\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetFFE */\n #define ffeste_terminate_0()\n #define ffeste_terminate_1()\n #ifdef ENABLE_CHECKING"}, {"sha": "c48a505b48b230fa2b6a63cfac2c405f367abdc1", "filename": "gcc/f/stt.c", "status": "modified", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fstt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fstt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstt.c?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -114,35 +114,6 @@ ffestt_caselist_create ()\n   return new;\n }\n \n-/* ffestt_caselist_dump -- Dump list of cases\n-\n-   ffesttCaseList list;\n-   ffestt_caselist_dump(list);\n-\n-   The cases in the list are dumped with commas separating them.  */\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void\n-ffestt_caselist_dump (ffesttCaseList list)\n-{\n-  ffesttCaseList next;\n-\n-  for (next = list->next; next != list; next = next->next)\n-    {\n-      if (next != list->next)\n-\tfputc (',', dmpout);\n-      if (next->expr1 != NULL)\n-\tffebld_dump (next->expr1);\n-      if (next->range)\n-\t{\n-\t  fputc (':', dmpout);\n-\t  if (next->expr2 != NULL)\n-\t    ffebld_dump (next->expr2);\n-\t}\n-    }\n-}\n-#endif\n-\n /* ffestt_caselist_kill -- Kill list of cases\n \n    ffesttCaseList list;\n@@ -438,32 +409,6 @@ ffestt_dimlist_create ()\n   return new;\n }\n \n-/* ffestt_dimlist_dump -- Dump list of dims\n-\n-   ffesttDimList list;\n-   ffestt_dimlist_dump(list);\n-\n-   The dims in the list are dumped with commas separating them.\t */\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void\n-ffestt_dimlist_dump (ffesttDimList list)\n-{\n-  ffesttDimList next;\n-\n-  for (next = list->next; next != list; next = next->next)\n-    {\n-      if (next != list->next)\n-\tfputc (',', dmpout);\n-      if (next->lower != NULL)\n-\tffebld_dump (next->lower);\n-      fputc (':', dmpout);\n-      if (next->upper != NULL)\n-\tffebld_dump (next->upper);\n-    }\n-}\n-#endif\n-\n /* ffestt_dimlist_kill -- Kill list of dims\n \n    ffesttDimList list;\n@@ -611,28 +556,6 @@ ffestt_exprlist_drive (ffesttExprList list, void (*fn) (ffebld, ffelexToken))\n     }\n }\n \n-/* ffestt_exprlist_dump -- Dump list of exprs\n-\n-   ffesttExprList list;\n-   ffestt_exprlist_dump(list);\n-\n-   The exprs in the list are dumped with commas separating them.  */\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void\n-ffestt_exprlist_dump (ffesttExprList list)\n-{\n-  ffesttExprList next;\n-\n-  for (next = list->next; next != list; next = next->next)\n-    {\n-      if (next != list->next)\n-\tfputc (',', dmpout);\n-      ffebld_dump (next->expr);\n-    }\n-}\n-#endif\n-\n /* ffestt_exprlist_kill -- Kill list of exprs\n \n    ffesttExprList list;\n@@ -850,35 +773,6 @@ ffestt_implist_drive (ffesttImpList list, void (*fn) (ffelexToken, ffelexToken))\n     }\n }\n \n-/* ffestt_implist_dump -- Dump list of token pairs\n-\n-   ffesttImpList list;\n-   ffestt_implist_dump(list);\n-\n-   The token pairs in the list are dumped with commas separating them.\t*/\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void\n-ffestt_implist_dump (ffesttImpList list)\n-{\n-  ffesttImpList next;\n-\n-  for (next = list->next; next != list; next = next->next)\n-    {\n-      if (next != list->next)\n-\tfputc (',', dmpout);\n-      assert (ffelex_token_type (next->first) == FFELEX_typeNAME);\n-      fputs (ffelex_token_text (next->first), dmpout);\n-      if (next->last != NULL)\n-\t{\n-\t  fputc ('-', dmpout);\n-\t  assert (ffelex_token_type (next->last) == FFELEX_typeNAME);\n-\t  fputs (ffelex_token_text (next->last), dmpout);\n-\t}\n-    }\n-}\n-#endif\n-\n /* ffestt_implist_kill -- Kill list of token pairs\n \n    ffesttImpList list;\n@@ -964,44 +858,6 @@ ffestt_tokenlist_drive (ffesttTokenList tl, void (*fn) (ffelexToken))\n     }\n }\n \n-/* ffestt_tokenlist_dump -- Dump list of tokens\n-\n-   ffesttTokenList tl;\n-   ffestt_tokenlist_dump(tl);\n-\n-   The tokens in the list are dumped with commas separating them.  */\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void\n-ffestt_tokenlist_dump (ffesttTokenList tl)\n-{\n-  ffesttTokenItem ti;\n-\n-  for (ti = tl->first; ti != (ffesttTokenItem) &tl->first; ti = ti->next)\n-    {\n-      if (ti != tl->first)\n-\tfputc (',', dmpout);\n-      switch (ffelex_token_type (ti->t))\n-\t{\n-\tcase FFELEX_typeNUMBER:\n-\tcase FFELEX_typeNAME:\n-\tcase FFELEX_typeNAMES:\n-\t  fputs (ffelex_token_text (ti->t), dmpout);\n-\t  break;\n-\n-\tcase FFELEX_typeASTERISK:\n-\t  fputc ('*', dmpout);\n-\t  break;\n-\n-\tdefault:\n-\t  assert (FALSE);\n-\t  fputc ('?', dmpout);\n-\t  break;\n-\t}\n-    }\n-}\n-#endif\n-\n /* ffestt_tokenlist_handle -- Handle list of tokens\n \n    ffesttTokenList tl;"}, {"sha": "56543d033956e7908ebeb42339179aaa2343d70c", "filename": "gcc/f/stt.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fstt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fstt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstt.h?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -164,49 +164,31 @@ struct _ffest_format_list_\n void ffestt_caselist_append (ffesttCaseList list, bool range, ffebld case1,\n \t\t\t     ffebld case2, ffelexToken t);\n ffesttCaseList ffestt_caselist_create (void);\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void ffestt_caselist_dump (ffesttCaseList list);\n-#endif\n void ffestt_caselist_kill (ffesttCaseList list);\n void ffestt_dimlist_append (ffesttDimList list, ffebld lower, ffebld upper,\n \t\t\t    ffelexToken t);\n ffebld ffestt_dimlist_as_expr (ffesttDimList list, ffeinfoRank *rank,\n \t\t\t       ffebld *array_size, ffebld *extents,\n \t\t\t       bool is_ugly_assumed);\n ffesttDimList ffestt_dimlist_create (void);\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void ffestt_dimlist_dump (ffesttDimList list);\n-#endif\n void ffestt_dimlist_kill (ffesttDimList list);\n ffestpDimtype ffestt_dimlist_type (ffesttDimList dims, bool is_ugly_assumed);\n void ffestt_exprlist_append (ffesttExprList list, ffebld expr, ffelexToken t);\n ffesttExprList ffestt_exprlist_create (void);\n void ffestt_exprlist_drive (ffesttExprList list, void (*fn) (ffebld, ffelexToken));\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void ffestt_exprlist_dump (ffesttExprList list);\n-#endif\n void ffestt_exprlist_kill (ffesttExprList list);\n ffesttFormatList ffestt_formatlist_append (ffesttFormatList list);\n ffesttFormatList ffestt_formatlist_create (ffesttFormatList parent,\n \t\t\t\t\t   ffelexToken t);\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void ffestt_formatlist_dump (ffesttFormatList list);\n-#endif\n void ffestt_formatlist_kill (ffesttFormatList list);\n void ffestt_implist_append (ffesttImpList list, ffelexToken first,\n \t\t\t    ffelexToken last);\n ffesttImpList ffestt_implist_create (void);\n void ffestt_implist_drive (ffesttImpList list, void (*fn) (ffelexToken, ffelexToken));\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void ffestt_implist_dump (ffesttImpList list);\n-#endif\n void ffestt_implist_kill (ffesttImpList list);\n void ffestt_tokenlist_append (ffesttTokenList list, ffelexToken t);\n ffesttTokenList ffestt_tokenlist_create (void);\n void ffestt_tokenlist_drive (ffesttTokenList list, void (*fn) (ffelexToken));\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void ffestt_tokenlist_dump (ffesttTokenList list);\n-#endif\n ffelexHandler ffestt_tokenlist_handle (ffesttTokenList list,\n \t\t\t\t       ffelexHandler handler);\n void ffestt_tokenlist_kill (ffesttTokenList list);"}, {"sha": "080bd73885d32c1cf28822ba0ea3698ace054a86", "filename": "gcc/f/stw.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fstw.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fstw.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstw.h?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -73,7 +73,6 @@ struct _ffestw_\n     int uses_;\t\t\t/* # uses (new+use-kill calls). */\n     ffestvState state_;\n     int substate_;\t\t/* Used on a per-block-state basis. */\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n     struct nesting *do_hook_;\t/* backend id for given loop (EXIT/CYCLE). */\n     tree do_tvar_;\t\t/* tree form of do_iter_var. */\n     tree do_incr_saved_;\t/* tree SAVED_EXPR of incr expr. */\n@@ -82,7 +81,6 @@ struct _ffestw_\n     bool select_break_;\t\t/* TRUE when CASE should start with gen\n \t\t\t\t   \"break;\". */\n     int ifthen_fake_else_;\t/* Number of fake `else' introductions.  */\n-#endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC*/\n   };\n \n struct _ffestw_case_"}, {"sha": "816ad1964bbcf1c13681e6eb0b8c7f9a379cf830", "filename": "gcc/f/symbol.c", "status": "modified", "additions": 0, "deletions": 223, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fsymbol.c?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -47,15 +47,9 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Choose how to handle global symbols here.  */\n \n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-#define FFESYMBOL_globalCURRENT_ FFESYMBOL_globalPROGUNIT_\n-#elif FFECOM_targetCURRENT == FFECOM_targetGCC\n /* Would be good to understand why PROGUNIT in this case too.\n    (1995-08-22).  */\n #define FFESYMBOL_globalCURRENT_ FFESYMBOL_globalPROGUNIT_\n-#else\n-#error\n-#endif\n \n /* Choose how to handle memory pools based on global symbol stuff.  */\n \n@@ -793,45 +787,6 @@ ffesymbol_drive_sfnames (ffesymbol (*fn) (ffesymbol))\n   ffename_space_drive_symbol (ffesymbol_sfunc_, fn);\n }\n \n-/* Dump info on the symbol for debugging purposes.  */\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void\n-ffesymbol_dump (ffesymbol s)\n-{\n-  ffeinfoKind k;\n-  ffeinfoWhere w;\n-\n-  assert (s != NULL);\n-\n-  if (ffeinfo_size (s->info) != FFETARGET_charactersizeNONE)\n-    fprintf (dmpout, \"%s:%d%s%s*%\" ffetargetCharacterSize_f \"u\",\n-\t     ffesymbol_text (s),\n-\t     (int) ffeinfo_rank (s->info),\n-\t     ffeinfo_basictype_string (ffeinfo_basictype (s->info)),\n-\t     ffeinfo_kindtype_string (ffeinfo_kindtype (s->info)),\n-\t     ffeinfo_size (s->info));\n-  else\n-    fprintf (dmpout, \"%s:%d%s%s\",\n-\t     ffesymbol_text (s),\n-\t     (int) ffeinfo_rank (s->info),\n-\t     ffeinfo_basictype_string (ffeinfo_basictype (s->info)),\n-\t     ffeinfo_kindtype_string (ffeinfo_kindtype (s->info)));\n-  if ((k = ffeinfo_kind (s->info)) != FFEINFO_kindNONE)\n-    fprintf (dmpout, \"/%s\", ffeinfo_kind_string (k));\n-  if ((w = ffeinfo_where (s->info)) != FFEINFO_whereNONE)\n-    fprintf (dmpout, \"@%s\", ffeinfo_where_string (w));\n-\n-  if ((s->generic != FFEINTRIN_genNONE)\n-      || (s->specific != FFEINTRIN_specNONE)\n-      || (s->implementation != FFEINTRIN_impNONE))\n-    fprintf (dmpout, \"{%s:%s:%s}\",\n-\t     ffeintrin_name_generic (s->generic),\n-\t     ffeintrin_name_specific (s->specific),\n-\t     ffeintrin_name_implementation (s->implementation));\n-}\n-#endif\n-\n /* Produce generic error message about a symbol.\n \n    For now, just output error message using symbol's name and pointing to\n@@ -1012,184 +967,6 @@ ffesymbol_reference (ffesymbol s, ffelexToken t, bool explicit)\n     ffesymbol_error (s, NULL);\n }\n \n-/* Report info on the symbol for debugging purposes.  */\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-ffesymbol\n-ffesymbol_report (ffesymbol s)\n-{\n-  ffeinfoKind k;\n-  ffeinfoWhere w;\n-\n-  assert (s != NULL);\n-\n-  if (s->reported)\n-    return s;\n-\n-  s->reported = TRUE;\n-\n-  if (ffeinfo_size (s->info) != FFETARGET_charactersizeNONE)\n-    fprintf (dmpout, \"\\\"%s\\\": %s %s %d%s%s*%\" ffetargetCharacterSize_f \"u\",\n-\t     ffesymbol_text (s),\n-\t     ffesymbol_state_string (s->state),\n-\t     ffesymbol_attrs_string (s->attrs),\n-\t     (int) ffeinfo_rank (s->info),\n-\t     ffeinfo_basictype_string (ffeinfo_basictype (s->info)),\n-\t     ffeinfo_kindtype_string (ffeinfo_kindtype (s->info)),\n-\t     ffeinfo_size (s->info));\n-  else\n-    fprintf (dmpout, \"\\\"%s\\\": %s %s %d%s%s\",\n-\t     ffesymbol_text (s),\n-\t     ffesymbol_state_string (s->state),\n-\t     ffesymbol_attrs_string (s->attrs),\n-\t     (int) ffeinfo_rank (s->info),\n-\t     ffeinfo_basictype_string (ffeinfo_basictype (s->info)),\n-\t     ffeinfo_kindtype_string (ffeinfo_kindtype (s->info)));\n-  if ((k = ffeinfo_kind (s->info)) != FFEINFO_kindNONE)\n-    fprintf (dmpout, \"/%s\", ffeinfo_kind_string (k));\n-  if ((w = ffeinfo_where (s->info)) != FFEINFO_whereNONE)\n-    fprintf (dmpout, \"@%s\", ffeinfo_where_string (w));\n-  fputc ('\\n', dmpout);\n-\n-  if (s->dims != NULL)\n-    {\n-      fprintf (dmpout, \"  dims: \");\n-      ffebld_dump (s->dims);\n-      fputs (\"\\n\", dmpout);\n-    }\n-\n-  if (s->extents != NULL)\n-    {\n-      fprintf (dmpout, \"  extents: \");\n-      ffebld_dump (s->extents);\n-      fputs (\"\\n\", dmpout);\n-    }\n-\n-  if (s->dim_syms != NULL)\n-    {\n-      fprintf (dmpout, \"  dim syms: \");\n-      ffebld_dump (s->dim_syms);\n-      fputs (\"\\n\", dmpout);\n-    }\n-\n-  if (s->array_size != NULL)\n-    {\n-      fprintf (dmpout, \"  array size: \");\n-      ffebld_dump (s->array_size);\n-      fputs (\"\\n\", dmpout);\n-    }\n-\n-  if (s->init != NULL)\n-    {\n-      fprintf (dmpout, \"  init-value: \");\n-      if (ffebld_op (s->init) == FFEBLD_opANY)\n-\tfputs (\"<any>\\n\", dmpout);\n-      else\n-\t{\n-\t  ffebld_dump (s->init);\n-\t  fputs (\"\\n\", dmpout);\n-\t}\n-    }\n-\n-  if (s->accretion != NULL)\n-    {\n-      fprintf (dmpout, \"  accretion (%\" ffetargetOffset_f \"d left): \",\n-\t       s->accretes);\n-      ffebld_dump (s->accretion);\n-      fputs (\"\\n\", dmpout);\n-    }\n-  else if (s->accretes != 0)\n-    fprintf (dmpout, \"  accretes!! = %\" ffetargetOffset_f \"d left\\n\",\n-\t     s->accretes);\n-\n-  if (s->dummy_args != NULL)\n-    {\n-      fprintf (dmpout, \"  dummies: \");\n-      ffebld_dump (s->dummy_args);\n-      fputs (\"\\n\", dmpout);\n-    }\n-\n-  if (s->namelist != NULL)\n-    {\n-      fprintf (dmpout, \"  namelist: \");\n-      ffebld_dump (s->namelist);\n-      fputs (\"\\n\", dmpout);\n-    }\n-\n-  if (s->common_list != NULL)\n-    {\n-      fprintf (dmpout, \"  common-list: \");\n-      ffebld_dump (s->common_list);\n-      fputs (\"\\n\", dmpout);\n-    }\n-\n-  if (s->sfunc_expr != NULL)\n-    {\n-      fprintf (dmpout, \"  sfunc expression: \");\n-      ffebld_dump (s->sfunc_expr);\n-      fputs (\"\\n\", dmpout);\n-    }\n-\n-  if (s->is_save)\n-    {\n-      fprintf (dmpout, \"  SAVEd\\n\");\n-    }\n-\n-  if (s->is_init)\n-    {\n-      fprintf (dmpout, \"  initialized\\n\");\n-    }\n-\n-  if (s->do_iter)\n-    {\n-      fprintf (dmpout, \"  DO-loop iteration variable (currently)\\n\");\n-    }\n-\n-  if (s->explicit_where)\n-    {\n-      fprintf (dmpout, \"  Explicit INTRINSIC/EXTERNAL\\n\");\n-    }\n-\n-  if (s->namelisted)\n-    {\n-      fprintf (dmpout, \"  Namelisted\\n\");\n-    }\n-\n-  if (s->common != NULL)\n-    {\n-      fprintf (dmpout, \"  COMMON area: %s\\n\", ffesymbol_text (s->common));\n-    }\n-\n-  if (s->equiv != NULL)\n-    {\n-      fprintf (dmpout, \"  EQUIVALENCE information: \");\n-      ffeequiv_dump (s->equiv);\n-      fputs (\"\\n\", dmpout);\n-    }\n-\n-  if (s->storage != NULL)\n-    {\n-      fprintf (dmpout, \"  Storage: \");\n-      ffestorag_dump (s->storage);\n-      fputs (\"\\n\", dmpout);\n-    }\n-\n-  return s;\n-}\n-#endif\n-\n-/* Report info on the symbols.\t*/\n-\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void\n-ffesymbol_report_all ()\n-{\n-  ffename_space_drive_symbol (ffesymbol_sfunc_, ffesymbol_report);\n-  ffename_space_drive_symbol (ffesymbol_local_, ffesymbol_report);\n-  ffename_space_drive_symbol (ffesymbol_global_, ffesymbol_report);\n-}\n-#endif\n-\n /* Resolve symbol that has become known intrinsic or non-intrinsic.  */\n \n void"}, {"sha": "c9e582a4f264f18c064ac4af5493119bf31b5cf6", "filename": "gcc/f/symbol.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fsymbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Fsymbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fsymbol.h?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -182,9 +182,6 @@ ffesymbol ffesymbol_declare_subrunit (ffelexToken t);\n void ffesymbol_drive (ffesymbol (*fn) (ffesymbol));\n void ffesymbol_drive_sfnames (ffesymbol (*fn) (ffesymbol));\n #define ffesymbol_dummyargs(s) ((s)->dummy_args)\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-void ffesymbol_dump (ffesymbol s);\n-#endif\n void ffesymbol_error (ffesymbol s, ffelexToken t);\n #define ffesymbol_equiv(s) ((s)->equiv)\n #define ffesymbol_explicitwhere(s) ((s)->explicit_where)\n@@ -223,10 +220,6 @@ ffesymbol ffesymbol_lookup_local (ffelexToken t);\n #define ffesymbol_ptr_to_namelist(s) (&(s)->namelist)\n #define ffesymbol_rank(s) ffeinfo_rank((s)->info)\n void ffesymbol_reference (ffesymbol s, ffelexToken t, bool explicit);\n-#if FFECOM_targetCURRENT == FFECOM_targetFFE\n-ffesymbol ffesymbol_report (ffesymbol s);\n-void ffesymbol_report_all (void);\n-#endif\n void ffesymbol_resolve_intrin (ffesymbol s);\n void ffesymbol_retract (bool retract);\n bool ffesymbol_retractable (void);"}, {"sha": "b21f2694fff629d32218120e058e525675006522", "filename": "gcc/f/target.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ftarget.h?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -860,13 +860,9 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n \n /* Define macros. */\n \n-#if BUILT_FOR_280\n-#define FFETARGET_REAL_VALUE_FROM_INT_(resr, lf, kt) \\\n-  REAL_VALUE_FROM_INT (resr, (long) lf, (long) ((lf < 0) ? -1 : 0), ((kt == 1) ? SFmode : DFmode))\n-#else\n-#define FFETARGET_REAL_VALUE_FROM_INT_(resr, lf, kt) \\\n-  REAL_VALUE_FROM_INT (resr, (long) lf, (long) ((lf < 0) ? -1 : 0))\n-#endif\n+#define FFETARGET_REAL_VALUE_FROM_INT_(resr, lf, kt)\t\t\t\\\n+  REAL_VALUE_FROM_INT (resr, (long) lf, (long) ((lf < 0) ? -1 : 0),\t\\\n+\t\t       ((kt == 1) ? SFmode : DFmode))\n \n #ifdef REAL_ARITHMETIC\n #define ffetarget_add_complex1(res,l,r) \\"}, {"sha": "560bcb48c3d24c6c00ba3957cddf5d8fdbab28f2", "filename": "gcc/f/top.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Ftop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516b69ff81e6c922bbdeb3abd494cac674e344f1/gcc%2Ff%2Ftop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ftop.c?ref=516b69ff81e6c922bbdeb3abd494cac674e344f1", "patch": "@@ -53,10 +53,8 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"symbol.h\"\n #include \"target.h\"\n #include \"where.h\"\n-#if FFECOM_targetCURRENT == FFECOM_targetGCC\n #include \"flags.h\"\n #include \"toplev.h\"\n-#endif\n \n /* Externals defined here. */\n "}]}