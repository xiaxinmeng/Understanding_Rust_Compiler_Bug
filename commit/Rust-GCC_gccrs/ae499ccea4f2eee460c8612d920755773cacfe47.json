{"sha": "ae499ccea4f2eee460c8612d920755773cacfe47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU0OTljY2VhNGYyZWVlNDYwYzg2MTJkOTIwNzU1NzczY2FjZmU0Nw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-09-07T01:36:11Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-09-07T01:36:11Z"}, "message": "Move statement-tree facilities from C++ to C front-end.\n\n\t* c-common.h (c_tree_index): Add CTI_VOID_ZERO.\n\t(void_zero_node): New macro.\n\t(struct stmt_tree_s): New type.\n\t(stmt_tree): New typedef.\n\t(struct language_function): New type.\n\t(last_tree): New macro.\n\t(last_expr_type): Likewise.\n\t(walk_tree_fn): New typedef.\n\t(current_stmt_tree): New function.\n\t(begin_stmt_tree): Likewise.\n\t(add_stmt): Likewise.\n\t(finish_stmt_tree): Likewise.\n\t(statement_code_p): Likewise.\n\t(lang_statement_code_p): New variable.\n\t(walk_stmt_tree): New function.\n\t(STMT_IS_FULL_EXPR_P): New macro.\n\t* c-common.c (lang_statement_code_p): New variable.\n\t(c_common_nodes_and_builtins): Initialize void_zero_node.\n\t(statement_code_p): New function.\n\t(walk_stmt_tree): Likewise.\n\t* c-decl.c (language_function): Rename to ...\n\t(c_language_function): ... this.  Include language_function.\n\t(push_c_function_context): Adjust accordingly.\n\t(pop_c_function_context): Likewise.\n\t(mark_c_function_context): Likewise.\n\t(current_stmt_tree): Define.\n\t* c-semantics.c (begin_stmt_tree): New function.\n\t(add_stmt): Likewise.\n\t(prune_unused_decls): Likewise.\n\t(finish_stmt_tree): Likewise.\n\n\tMove statement-tree facilities from C++ to C front-end.\n\t* cp-tree.h (cp_tree_index): Remove CPTI_VOID_ZERO.\n\t(void_zero_node): Remove.\n\t(stmt_tree): Likewise.\n\t(scope_chain): Adjust.\n\t(language_function): Rename to cp_language_function.\n\t(cp_function_chain): Adjust.\n\t(current_stmt_tree): Remove.\n\t(last_tree): Likewise.\n\t(last_expr_type): Likewise.\n\t(struct lang_decl): Adjust.\n\t(STMT_IS_FULL_EXPR_P): Remove.\n\t(add_tree): Remove.\n\t(begin_stmt_tree): Likewise.\n\t(finish_stmt_tree): Likewise.\n\t(walk_tree_fn): Likewise.\n\t(walk_stmt_tree): Likewise.\n\t* class.c (finish_struct): Replace use of add_tree with add_stmt.\n\t* decl.c (mark_stmt_tree): Adjust type.\n\t(init_decl_processing): Don't build void_zero_node.\n\t(initialize_local_var): Adjust usage of current_stmt_tree.\n\t(finish_enum): Use add_stmt, not add_tree.\n\t(save_function_data): Adjust use of language_function.\n\t(finish_constructor_body): Use add_stmt, not add_tree.\n\t(finish_destructor_body): Likewise.\n\t(push_cp_function_context): Adjust use of language_function.\n\t(pop_cp_function_context): Likewise.\n\t(mark_lang_function): Likewise.\n\t(mark_cp_function_context): Likewise.\n\t* init.c (build_aggr_init): Adjust use of current_stmt_tree.\n\t(build_vec_init): Likewise.\n\t* semantics.c (SET_LAST_STMT): Remove.\n\t(RECHAIN_STMTS): Don't use it.\n\t(stmts_are_full_exprs_p): Adjust use of current_stmt_tree.\n\t(current_stmt_tree): Define.\n\t(add_tree): Remove.\n\t(finish_goto_stmt): Use add_stmt, not add_tree.\n\t(finish_expr_stmt): Likewise.\n\t(begin_if_stmt): Likewise.\n\t(finish_then_clause): Likewise.\n\t(begin_while_stmt): Likewise.\n\t(begin_do_stmt): Likewise.\n\t(finish_return_stmt): Likewise.\n\t(begin_for_stmt): Likewise.\n\t(finish_break_stmt): Likewise.\n\t(finish_continue_stmt): Likewise.\n\t(begin_switch_stmt): Likewise.\n\t(finish_case_label): Likewise.\n\t(begin_try_block): Likewise.\n\t(begin_function_try_block): Likewise.\n\t(begin_handler): Likewise.\n\t(begin_catch_block): Likewise.\n\t(begin_compound_stmt): Likewise.\n\t(begin_asm_stmt): Likewise.\n\t(finish_asm_stmt): Likewise.\n\t(finish_label_stmt): Likewise.\n\t(add_decl_stmt): Likewise.\n\t(finish_subobject): Likewise.\n\t(finish_decl_cleanup): Likewise.\n\t(finish_named_return_value): Likewise.\n\t(setup_vtbl_ptr): Likewise.\n\t(add_scope_stmt): Likewise.\n\t(finish_stmt_expr): Likewise.\n\t(prune_unused_decls): Remove.\n\t(begin_stmt_tree): Likewise.\n\t(finish_stmt_tree): Likewise.\n\t(prep_stmt): Adjust use of current_stmt_tree.\n\t(lang_expand_stmt): Likewise.\n\t* tree.c (statement_code_p): Remove.\n\t(cp_statement_code_p): New function.\n\t(walk_stmt_tree): Remove.\n\t(init_tree): Set lang_statement_code_p.\n\nFrom-SVN: r36221", "tree": {"sha": "1ae8ce0d3f4f58cfa7b33b9fac7c1209e34d27a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ae8ce0d3f4f58cfa7b33b9fac7c1209e34d27a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae499ccea4f2eee460c8612d920755773cacfe47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae499ccea4f2eee460c8612d920755773cacfe47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae499ccea4f2eee460c8612d920755773cacfe47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae499ccea4f2eee460c8612d920755773cacfe47/comments", "author": null, "committer": null, "parents": [{"sha": "4f4b88d0832c7279722b5dee73d9ce9f1704452f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f4b88d0832c7279722b5dee73d9ce9f1704452f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f4b88d0832c7279722b5dee73d9ce9f1704452f"}], "stats": {"total": 864, "additions": 524, "deletions": 340}, "files": [{"sha": "7cc7fda58ac12a32f0d43c5b38f1123c5a682f24", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae499ccea4f2eee460c8612d920755773cacfe47", "patch": "@@ -1,3 +1,37 @@\n+2000-09-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tMove statement-tree facilities from C++ to C front-end.\n+\t* c-common.h (c_tree_index): Add CTI_VOID_ZERO.\n+\t(void_zero_node): New macro.\n+\t(struct stmt_tree_s): New type.\n+\t(stmt_tree): New typedef.\n+\t(struct language_function): New type.\n+\t(last_tree): New macro.\n+\t(last_expr_type): Likewise.\n+\t(walk_tree_fn): New typedef.\n+\t(current_stmt_tree): New function.\n+\t(begin_stmt_tree): Likewise.\n+\t(add_stmt): Likewise.\n+\t(finish_stmt_tree): Likewise.\n+\t(statement_code_p): Likewise.\n+\t(lang_statement_code_p): New variable.\n+\t(walk_stmt_tree): New function.\n+\t(STMT_IS_FULL_EXPR_P): New macro.\n+\t* c-common.c (lang_statement_code_p): New variable.\n+\t(c_common_nodes_and_builtins): Initialize void_zero_node.\n+\t(statement_code_p): New function.\n+\t(walk_stmt_tree): Likewise.\n+\t* c-decl.c (language_function): Rename to ...\n+\t(c_language_function): ... this.  Include language_function.\n+\t(push_c_function_context): Adjust accordingly.\n+\t(pop_c_function_context): Likewise.\n+\t(mark_c_function_context): Likewise.\n+\t(current_stmt_tree): Define.\n+\t* c-semantics.c (begin_stmt_tree): New function.\n+\t(add_stmt): Likewise.\n+\t(prune_unused_decls): Likewise.\n+\t(finish_stmt_tree): Likewise.\n+\n 2000-09-06 Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n \n         * flow.c (insn_dead_p): Detect dead memory stores with auto increments."}, {"sha": "fc8476a222d65ed12288afce7f93d8e35e736cd1", "filename": "gcc/c-common.c", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=ae499ccea4f2eee460c8612d920755773cacfe47", "patch": "@@ -144,6 +144,10 @@ tree *ridpointers;\n \n tree (*make_fname_decl)                PARAMS ((tree, const char *, int));\n \n+/* If non-NULL, the address of a language-specific function that\n+   returns 1 for language-specific statement codes.  */\n+int (*lang_statement_code_p)           PARAMS ((enum tree_code));\n+\n /* Nonzero means the expression being parsed will never be evaluated.\n    This is a count, since unevaluated expressions can nest.  */\n int skip_evaluation;\n@@ -3870,6 +3874,9 @@ c_common_nodes_and_builtins (cplus_mode, no_builtins, no_nonansi_builtins)\n \t\t\t\t\t\t\t    sizetype,\n \t\t\t\t\t\t\t    endlink))));\n \n+  void_zero_node = build_int_2 (0, 0);\n+  TREE_TYPE (void_zero_node) = void_type_node;\n+\n   /* Prototype for strcpy.  */\n   string_ftype_ptr_ptr\n     = build_function_type (string_type_node,\n@@ -4378,6 +4385,111 @@ expand_tree_builtin (function, params, coerced_params)\n   return NULL_TREE;\n }\n \n+/* Returns non-zero if CODE is the code for a statement.  */\n+\n+int\n+statement_code_p (code)\n+     enum tree_code code;\n+{\n+  switch (code)\n+    {\n+    case EXPR_STMT:\n+    case COMPOUND_STMT:\n+    case DECL_STMT:\n+    case IF_STMT:\n+    case FOR_STMT:\n+    case WHILE_STMT:\n+    case DO_STMT:\n+    case RETURN_STMT:\n+    case BREAK_STMT:\n+    case CONTINUE_STMT:\n+    case SWITCH_STMT:\n+    case GOTO_STMT:\n+    case LABEL_STMT:\n+    case ASM_STMT:\n+    case CASE_LABEL:\n+      return 1;\n+\n+    default:\n+      if (lang_statement_code_p)\n+\treturn (*lang_statement_code_p) (code);\n+      return 0;\n+    }\n+}\n+\n+/* Walk the statemen tree, rooted at *tp.  Apply FUNC to all the\n+   sub-trees of *TP in a pre-order traversal.  FUNC is called with the\n+   DATA and the address of each sub-tree.  If FUNC returns a non-NULL\n+   value, the traversal is aborted, and the value returned by FUNC is\n+   returned.  If FUNC sets WALK_SUBTREES to zero, then the subtrees of\n+   the node being visited are not walked.\n+\n+   We don't need a without_duplicates variant of this one because the\n+   statement tree is a tree, not a graph.  */\n+\n+tree \n+walk_stmt_tree (tp, func, data)\n+     tree *tp;\n+     walk_tree_fn func;\n+     void *data;\n+{\n+  enum tree_code code;\n+  int walk_subtrees;\n+  tree result;\n+  int i, len;\n+\n+#define WALK_SUBTREE(NODE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      result = walk_stmt_tree (&(NODE), func, data);\t\\\n+      if (result)\t\t\t\t\t\\\n+\treturn result;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+  /* Skip empty subtrees.  */\n+  if (!*tp)\n+    return NULL_TREE;\n+\n+  /* Skip subtrees below non-statement nodes.  */\n+  if (!statement_code_p (TREE_CODE (*tp)))\n+    return NULL_TREE;\n+\n+  /* Call the function.  */\n+  walk_subtrees = 1;\n+  result = (*func) (tp, &walk_subtrees, data);\n+\n+  /* If we found something, return it.  */\n+  if (result)\n+    return result;\n+\n+  /* Even if we didn't, FUNC may have decided that there was nothing\n+     interesting below this point in the tree.  */\n+  if (!walk_subtrees)\n+    return NULL_TREE;\n+\n+  /* FUNC may have modified the tree, recheck that we're looking at a\n+     statement node.  */\n+  code = TREE_CODE (*tp);\n+  if (!statement_code_p (code))\n+    return NULL_TREE;\n+\n+  /* Walk over all the sub-trees of this operand.  Statement nodes never\n+     contain RTL, and we needn't worry about TARGET_EXPRs.  */\n+  len = TREE_CODE_LENGTH (code);\n+\n+  /* Go through the subtrees.  We need to do this in forward order so\n+     that the scope of a FOR_EXPR is handled properly.  */\n+  for (i = 0; i < len; ++i)\n+    WALK_SUBTREE (TREE_OPERAND (*tp, i));\n+\n+  /* Finally visit the chain.  This can be tail-recursion optimized if\n+     we write it this way.  */\n+  return walk_stmt_tree (&TREE_CHAIN (*tp), func, data);\n+\n+#undef WALK_SUBTREE\n+}\n+\n /* Tree code classes. */\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,"}, {"sha": "6f442c466c68833509beae05ec83ec64fdcdcbce", "filename": "gcc/c-common.h", "status": "modified", "additions": 74, "deletions": 2, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=ae499ccea4f2eee460c8612d920755773cacfe47", "patch": "@@ -147,6 +147,8 @@ enum c_tree_index\n     CTI_PRETTY_FUNCTION_ID,\n     CTI_FUNC_ID,\n \n+    CTI_VOID_ZERO,\n+\n     CTI_MAX\n };\n \n@@ -187,6 +189,9 @@ enum c_tree_index\n #define pretty_function_id_node\t\tc_global_trees[CTI_PRETTY_FUNCTION_ID]\n #define func_id_node\t\t\tc_global_trees[CTI_FUNC_ID]\n \n+/* A node for `((void) 0)'.  */\n+#define void_zero_node                  c_global_trees[CTI_VOID_ZERO]\n+\n extern tree c_global_trees[CTI_MAX];\n \n typedef enum c_language_kind\n@@ -198,6 +203,68 @@ typedef enum c_language_kind\n } \n c_language_kind;\n \n+/* Information about a statement tree.  */\n+\n+struct stmt_tree_s {\n+  /* The last statement added to the tree.  */\n+  tree x_last_stmt;\n+  /* The type of the last expression statement.  (This information is\n+     needed to implement the statement-expression extension.)  */\n+  tree x_last_expr_type;\n+  /* In C++, Non-zero if we should treat statements as full\n+     expressions.  In particular, this variable is no-zero if at the\n+     end of a statement we should destroy any temporaries created\n+     during that statement.  Similarly, if, at the end of a block, we\n+     should destroy any local variables in this block.  Normally, this\n+     variable is non-zero, since those are the normal semantics of\n+     C++.\n+\n+     However, in order to represent aggregate initialization code as\n+     tree structure, we use statement-expressions.  The statements\n+     within the statement expression should not result in cleanups\n+     being run until the entire enclosing statement is complete.  \n+\n+     This flag has no effect in C.  */\n+  int stmts_are_full_exprs_p; \n+};\n+\n+typedef struct stmt_tree_s *stmt_tree;\n+\n+/* Global state pertinent to the current function.  Some C dialects\n+   extend this structure with additional fields.  */\n+\n+struct language_function {\n+  /* While we are parsing the function, this contains information\n+     about the statement-tree that we are building.  */\n+  struct stmt_tree_s x_stmt_tree;\n+};\n+\n+/* When building a statement-tree, this is the last statement added to\n+   the tree.  */\n+\n+#define last_tree (current_stmt_tree ()->x_last_stmt)\n+\n+/* The type of the last expression-statement we have seen.  */\n+\n+#define last_expr_type (current_stmt_tree ()->x_last_expr_type)\n+\n+/* The type of a function that walks over tree structure.  */\n+\n+typedef tree (*walk_tree_fn)                    PARAMS ((tree *, \n+\t\t\t\t\t\t\t int *, \n+\t\t\t\t\t\t\t void *));\n+\n+extern stmt_tree current_stmt_tree              PARAMS ((void));\n+extern void begin_stmt_tree                     PARAMS ((tree *));\n+extern void add_stmt\t\t\t\tPARAMS ((tree));\n+extern void finish_stmt_tree                    PARAMS ((tree *));\n+\n+extern int statement_code_p                     PARAMS ((enum tree_code));\n+extern int (*lang_statement_code_p)             PARAMS ((enum tree_code));\n+extern tree walk_stmt_tree\t\t\tPARAMS ((tree *,\n+\t\t\t\t\t\t\t walk_tree_fn,\n+\t\t\t\t\t\t\t void *));\n+\n /* The variant of the C language being processed.  Each C language\n    front-end defines this variable.  */\n \n@@ -337,8 +404,13 @@ extern tree build_va_arg\t\t\tPARAMS ((tree, tree));\n extern int self_promoting_args_p\t\tPARAMS ((tree));\n extern tree simple_type_promotes_to\t\tPARAMS ((tree));\n \n-/* These macros provide convenient access to the various _STMT nodes\n-   created when parsing template declarations.  */\n+/* These macros provide convenient access to the various _STMT nodes.  */\n+\n+/* Nonzero if this statement should be considered a full-expression,\n+   i.e., if temporaries created during this statement should have\n+   their destructors run at the end of this statement.  (In C, this\n+   will always be false, since there are no destructors.)  */\n+#define STMT_IS_FULL_EXPR_P(NODE) TREE_LANG_FLAG_1 ((NODE))\n \n /* IF_STMT accessors. These give access to the condtion of the if\n    statement, the then block of the if statement, and the else block"}, {"sha": "a5dc3d64e989e4fb27d07555cf8ea7ca9add4256", "filename": "gcc/c-decl.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=ae499ccea4f2eee460c8612d920755773cacfe47", "patch": "@@ -6761,8 +6761,9 @@ finish_function (nested)\n    that keep track of the progress of compilation of the current function.\n    Used for nested functions.  */\n \n-struct language_function\n+struct c_language_function\n {\n+  struct language_function base;\n   tree named_labels;\n   tree shadowed_labels;\n   int returns_value;\n@@ -6779,9 +6780,10 @@ void\n push_c_function_context (f)\n      struct function *f;\n {\n-  struct language_function *p;\n-  p = (struct language_function *) xmalloc (sizeof (struct language_function));\n-  f->language = p;\n+  struct c_language_function *p;\n+  p = ((struct c_language_function *) \n+       xmalloc (sizeof (struct c_language_function)));\n+  f->language = (struct language_function *) p;\n \n   p->named_labels = named_labels;\n   p->shadowed_labels = shadowed_labels;\n@@ -6798,7 +6800,8 @@ void\n pop_c_function_context (f)\n      struct function *f;\n {\n-  struct language_function *p = f->language;\n+  struct c_language_function *p \n+    = (struct c_language_function *) f->language;\n   tree link;\n \n   /* Bring back all the labels that were shadowed.  */\n@@ -6834,7 +6837,8 @@ void\n mark_c_function_context (f)\n      struct function *f;\n {\n-  struct language_function *p = f->language;\n+  struct c_language_function *p \n+    = (struct c_language_function *) f->language;\n \n   if (p == 0)\n     return;\n@@ -6899,6 +6903,16 @@ stmts_are_full_exprs_p ()\n   return 0;\n }\n \n+/* Returns the stmt_tree (if any) to which statements are currently\n+   being added.  If there is no active statement-tree, NULL is\n+   returned.  */\n+\n+stmt_tree\n+current_stmt_tree ()\n+{\n+  return cfun ? &cfun->language->x_stmt_tree : NULL;\n+}\n+\n /* Nonzero if TYPE is an anonymous union or struct type.  Always 0 in\n    C.  */\n "}, {"sha": "eea9f9209e50dbd6af61d9a6a8712077d69418f5", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=ae499ccea4f2eee460c8612d920755773cacfe47", "patch": "@@ -36,6 +36,119 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"timevar.h\"\n \n+static tree prune_unused_decls PARAMS ((tree *, int *, void *));\n+\n+/* Create an empty statement tree rooted at T.  */\n+\n+void\n+begin_stmt_tree (t)\n+     tree *t;\n+{\n+  /* We create a trivial EXPR_STMT so that last_tree is never NULL in\n+     what follows.  We remove the extraneous statement in\n+     finish_stmt_tree.  */\n+  *t = build_nt (EXPR_STMT, void_zero_node);\n+  last_tree = *t;\n+  last_expr_type = NULL_TREE;\n+}\n+\n+/* T is a statement.  Add it to the statement-tree.  */\n+\n+void\n+add_stmt (t)\n+     tree t;\n+{\n+  /* Add T to the statement-tree.  */\n+  TREE_CHAIN (last_tree) = t;\n+  last_tree = t;\n+  /* When we expand a statement-tree, we must know whether or not the\n+     statements are full-expresions.  We record that fact here.  */\n+  STMT_IS_FULL_EXPR_P (last_tree) = stmts_are_full_exprs_p ();\n+}\n+\n+/* Remove declarations of internal variables that are not used from a\n+   stmt tree.  To qualify, the variable must have a name and must have\n+   a zero DECL_SOURCE_LINE.  We tried to remove all variables for\n+   which TREE_USED was false, but it turns out that there's tons of\n+   variables for which TREE_USED is false but that are still in fact\n+   used.  */\n+\n+static tree\n+prune_unused_decls (tp, walk_subtrees, data)\n+     tree *tp;\n+     int *walk_subtrees ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  tree t = *tp;\n+\n+  if (t == NULL_TREE)\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (t) == DECL_STMT)\n+    {\n+      tree d = DECL_STMT_DECL (t);\n+      if (!TREE_USED (d) && DECL_NAME (d) && DECL_SOURCE_LINE (d) == 0)\n+\t{\n+\t  *tp = TREE_CHAIN (t);\n+\t  /* Recurse on the new value of tp, otherwise we will skip\n+\t     the next statement.  */\n+\t  return prune_unused_decls (tp, walk_subtrees, data);\n+\t}\n+    }\n+  else if (TREE_CODE (t) == SCOPE_STMT)\n+    {\n+      /* Remove all unused decls from the BLOCK of this SCOPE_STMT.  */\n+      tree block = SCOPE_STMT_BLOCK (t);\n+\n+      if (block)\n+\t{\n+\t  tree *vp;\n+\n+\t  for (vp = &BLOCK_VARS (block); *vp; )\n+\t    {\n+\t      tree v = *vp;\n+\t      if (! TREE_USED (v) && DECL_NAME (v) && DECL_SOURCE_LINE (v) == 0)\n+\t\t*vp = TREE_CHAIN (v);  /* drop */\n+\t      else\n+\t\tvp = &TREE_CHAIN (v);  /* advance */\n+\t    }\n+\t  /* If there are now no variables, the entire BLOCK can be dropped.\n+\t     (This causes SCOPE_NULLIFIED_P (t) to be true.)  */\n+\t  if (BLOCK_VARS (block) == NULL_TREE)\n+\t    SCOPE_STMT_BLOCK (t) = NULL_TREE;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Finish the statement tree rooted at T.  */\n+\n+void\n+finish_stmt_tree (t)\n+     tree *t;\n+{\n+  tree stmt;\n+  \n+  /* Remove the fake extra statement added in begin_stmt_tree.  */\n+  stmt = TREE_CHAIN (*t);\n+  *t = stmt;\n+  last_tree = NULL_TREE;\n+\n+  /* Remove unused decls from the stmt tree.  */\n+  walk_stmt_tree (t, prune_unused_decls, NULL);\n+\n+  if (cfun)\n+    {\n+      /* The line-number recorded in the outermost statement in a function\n+\t is the line number of the end of the function.  */\n+      STMT_LINENO (stmt) = lineno;\n+      STMT_LINENO_FOR_FN_P (stmt) = 1;\n+    }\n+}\n+\n /* Build a generic statement based on the given type of node and\n    arguments. Similar to `build_nt', except that we set\n    TREE_COMPLEXITY to be the current line number.  */"}, {"sha": "5f6ea876428b385a7fcd626525b71ef333a2eb67", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ae499ccea4f2eee460c8612d920755773cacfe47", "patch": "@@ -1,3 +1,78 @@\n+2000-09-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tMove statement-tree facilities from C++ to C front-end.\n+\t* cp-tree.h (cp_tree_index): Remove CPTI_VOID_ZERO.\n+\t(void_zero_node): Remove.\n+\t(stmt_tree): Likewise.\n+\t(scope_chain): Adjust.\n+\t(language_function): Rename to cp_language_function.\n+\t(cp_function_chain): Adjust.\n+\t(current_stmt_tree): Remove.\n+\t(last_tree): Likewise.\n+\t(last_expr_type): Likewise.\n+\t(struct lang_decl): Adjust.\n+\t(STMT_IS_FULL_EXPR_P): Remove.\n+\t(add_tree): Remove.\n+\t(begin_stmt_tree): Likewise.\n+\t(finish_stmt_tree): Likewise.\n+\t(walk_tree_fn): Likewise.\n+\t(walk_stmt_tree): Likewise.\n+\t* class.c (finish_struct): Replace use of add_tree with add_stmt.\n+\t* decl.c (mark_stmt_tree): Adjust type.\n+\t(init_decl_processing): Don't build void_zero_node.\n+\t(initialize_local_var): Adjust usage of current_stmt_tree.\n+\t(finish_enum): Use add_stmt, not add_tree.\n+\t(save_function_data): Adjust use of language_function.\n+\t(finish_constructor_body): Use add_stmt, not add_tree.\n+\t(finish_destructor_body): Likewise.\n+\t(push_cp_function_context): Adjust use of language_function.\n+\t(pop_cp_function_context): Likewise.\n+\t(mark_lang_function): Likewise.\n+\t(mark_cp_function_context): Likewise.\n+\t* init.c (build_aggr_init): Adjust use of current_stmt_tree.\n+\t(build_vec_init): Likewise.\n+\t* semantics.c (SET_LAST_STMT): Remove.\n+\t(RECHAIN_STMTS): Don't use it.\n+\t(stmts_are_full_exprs_p): Adjust use of current_stmt_tree.\n+\t(current_stmt_tree): Define.\n+\t(add_tree): Remove.\n+\t(finish_goto_stmt): Use add_stmt, not add_tree.\n+\t(finish_expr_stmt): Likewise.\n+\t(begin_if_stmt): Likewise.\n+\t(finish_then_clause): Likewise.\n+\t(begin_while_stmt): Likewise.\n+\t(begin_do_stmt): Likewise.\n+\t(finish_return_stmt): Likewise.\n+\t(begin_for_stmt): Likewise.\n+\t(finish_break_stmt): Likewise.\n+\t(finish_continue_stmt): Likewise.\n+\t(begin_switch_stmt): Likewise.\n+\t(finish_case_label): Likewise.\n+\t(begin_try_block): Likewise.\n+\t(begin_function_try_block): Likewise.\n+\t(begin_handler): Likewise.\n+\t(begin_catch_block): Likewise.\n+\t(begin_compound_stmt): Likewise.\n+\t(begin_asm_stmt): Likewise.\n+\t(finish_asm_stmt): Likewise.\n+\t(finish_label_stmt): Likewise.\n+\t(add_decl_stmt): Likewise.\n+\t(finish_subobject): Likewise.\n+\t(finish_decl_cleanup): Likewise.\n+\t(finish_named_return_value): Likewise.\n+\t(setup_vtbl_ptr): Likewise.\n+\t(add_scope_stmt): Likewise.\n+\t(finish_stmt_expr): Likewise.\n+\t(prune_unused_decls): Remove.\n+\t(begin_stmt_tree): Likewise.\n+\t(finish_stmt_tree): Likewise.\n+\t(prep_stmt): Adjust use of current_stmt_tree.\n+\t(lang_expand_stmt): Likewise.\n+\t* tree.c (statement_code_p): Remove.\n+\t(cp_statement_code_p): New function.\n+\t(walk_stmt_tree): Remove.\n+\t(init_tree): Set lang_statement_code_p.\n+\t\n 2000-09-06  Zack Weinberg  <zack@wolery.cumb.org>\n \n \tIntegrated preprocessor."}, {"sha": "6477261b9a0b0f5e1c4dbed950db4a22b6532380", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=ae499ccea4f2eee460c8612d920755773cacfe47", "patch": "@@ -5265,7 +5265,7 @@ finish_struct (t, attributes)\n     {\n       tree scope = current_scope ();\n       if (scope && TREE_CODE (scope) == FUNCTION_DECL)\n-\tadd_tree (build_min (TAG_DEFN, t));\n+\tadd_stmt (build_min (TAG_DEFN, t));\n     }\n \n   return t;"}, {"sha": "9fb04e52a37890980b122c6429e8a30a5cf23c6d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 53, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ae499ccea4f2eee460c8612d920755773cacfe47", "patch": "@@ -559,7 +559,6 @@ enum cp_tree_index\n     CPTI_JAVA_CHAR_TYPE,\n     CPTI_JAVA_BOOLEAN_TYPE,\n \n-    CPTI_VOID_ZERO,\n     CPTI_WCHAR_DECL,\n     CPTI_VTABLE_ENTRY_TYPE,\n     CPTI_DELTA_TYPE,\n@@ -652,7 +651,6 @@ extern tree cp_global_trees[CPTI_MAX];\n #define java_char_type_node\t\tcp_global_trees[CPTI_JAVA_CHAR_TYPE]\n #define java_boolean_type_node\t\tcp_global_trees[CPTI_JAVA_BOOLEAN_TYPE]\n \n-#define void_zero_node\t\t\tcp_global_trees[CPTI_VOID_ZERO]\n #define wchar_decl_node\t\t\tcp_global_trees[CPTI_WCHAR_DECL]\n #define vtable_entry_type\t\tcp_global_trees[CPTI_VTABLE_ENTRY_TYPE]\n /* The type used to represent an offset by which to adjust the `this'\n@@ -784,23 +782,6 @@ extern tree cp_global_trees[CPTI_MAX];\n \n /* Global state.  */\n \n-struct stmt_tree {\n-  tree x_last_stmt;\n-  tree x_last_expr_type;\n-/* Non-zero if we should treat statements as full expressions.  In\n-   particular, this variable is no-zero if at the end of a statement\n-   we should destroy any temporaries created during that statement.\n-   Similarly, if, at the end of a block, we should destroy any local\n-   variables in this block.  Normally, this variable is non-zero,\n-   since those are the normal semantics of C++.\n-\n-   However, in order to represent aggregate initialization code as\n-   tree structure, we use statement-expressions.  The statements\n-   within the statement expression should not result in cleanups being\n-   run until the entire enclosing statement is complete.  */\n-  int stmts_are_full_exprs_p; \n-};\n-\n struct saved_scope {\n   tree old_bindings;\n   tree old_namespace;\n@@ -824,7 +805,7 @@ struct saved_scope {\n   int x_processing_explicit_instantiation;\n   int need_pop_function_context;\n \n-  struct stmt_tree x_stmt_tree;\n+  struct stmt_tree_s x_stmt_tree;\n \n   struct binding_level *class_bindings;\n   struct binding_level *bindings;\n@@ -890,8 +871,10 @@ extern struct saved_scope *scope_chain;\n \n /* Global state pertinent to the current function.  */\n \n-struct language_function\n+struct cp_language_function\n {\n+  struct language_function base;\n+\n   tree x_ctor_label;\n   tree x_dtor_label;\n   tree x_current_class_ptr;\n@@ -912,8 +895,6 @@ struct language_function\n   int name_declared;\n   int vtbls_set_up_p;\n \n-  struct stmt_tree x_stmt_tree;\n-\n   struct named_label_use_list *x_named_label_uses;\n   struct named_label_list *x_named_labels;\n   struct binding_level *bindings;\n@@ -923,7 +904,8 @@ struct language_function\n \n /* The current C++-specific per-function global variables.  */\n \n-#define cp_function_chain (cfun->language)\n+#define cp_function_chain \\\n+  ((struct cp_language_function *) (cfun->language))\n \n /* In a destructor, the point at which all derived class destroying\n    has been done, just before any base class destroying will be done.  */\n@@ -944,24 +926,6 @@ struct language_function\n #define current_class_ref \\\n   (cfun ? cp_function_chain->x_current_class_ref : NULL_TREE)\n \n-/* Information about the current statement tree.  */\n-\n-#define current_stmt_tree\t\t\t\\\n-  (cfun\t\t\t\t\t\t\\\n-   ? &cp_function_chain->x_stmt_tree\t\t\\\n-   : &scope_chain->x_stmt_tree)\n-\n-/* When building a statement-tree, this is the last statement added to\n-   the tree.  */\n-\n-#define last_tree current_stmt_tree->x_last_stmt\n-\n-/* The type of the last expression-statement we have seen.  This is\n-   required because the type of a statement-expression is the type of\n-   the last expression statement.  */\n-\n-#define last_expr_type current_stmt_tree->x_last_expr_type\n-\n /* The TRY_BLOCK for the exception-specifiers for the current\n    function, if any.  */\n \n@@ -1927,7 +1891,7 @@ struct lang_decl\n   {\n     tree sorted_fields;\n     struct unparsed_text *pending_inline_info;\n-    struct language_function *saved_language_function;\n+    struct cp_language_function *saved_language_function;\n   } u;\n \n   union {\n@@ -2474,9 +2438,6 @@ struct lang_decl\n #define AGGR_INIT_VIA_CTOR_P(NODE) \\\n   TREE_LANG_FLAG_0 (AGGR_INIT_EXPR_CHECK (NODE))\n \n-/* Nonzero if this statement should be considered a full-expression.  */\n-#define STMT_IS_FULL_EXPR_P(NODE) TREE_LANG_FLAG_1 ((NODE))\n-\n /* The TYPE_MAIN_DECL for a class template type is a TYPE_DECL, not a\n    TEMPLATE_DECL.  This macro determines whether or not a given class\n    type is really a template type, as opposed to an instantiation or\n@@ -4231,7 +4192,6 @@ extern void do_decl_instantiation\t\tPARAMS ((tree, tree, tree));\n extern void do_type_instantiation\t\tPARAMS ((tree, tree, int));\n extern tree instantiate_decl\t\t\tPARAMS ((tree, int));\n extern tree get_bindings\t\t\tPARAMS ((tree, tree, tree));\n-extern void add_tree\t\t\t\tPARAMS ((tree));\n extern void add_maybe_template\t\t\tPARAMS ((tree, tree));\n extern void pop_tinst_level\t\t\tPARAMS ((void));\n extern int more_specialized_class\t\tPARAMS ((tree, tree));\n@@ -4409,8 +4369,6 @@ extern void add_decl_stmt                       PARAMS ((tree));\n extern void finish_decl_cleanup                 PARAMS ((tree, tree));\n extern void finish_named_return_value           PARAMS ((tree, tree));\n extern void expand_body                         PARAMS ((tree));\n-extern void begin_stmt_tree                     PARAMS ((tree *));\n-extern void finish_stmt_tree                    PARAMS ((tree *));\n extern void prep_stmt                           PARAMS ((tree));\n extern tree add_scope_stmt                      PARAMS ((int, int));\n extern void do_pushlevel                        PARAMS ((void));\n@@ -4494,17 +4452,13 @@ extern void debug_binfo\t\t\t\tPARAMS ((tree));\n extern tree build_dummy_object\t\t\tPARAMS ((tree));\n extern tree maybe_dummy_object\t\t\tPARAMS ((tree, tree *));\n extern int is_dummy_object\t\t\tPARAMS ((tree));\n-typedef tree (*walk_tree_fn)                    PARAMS ((tree *, int *, void *));\n extern tree walk_tree                           PARAMS ((tree *,\n \t\t\t\t\t\t\t walk_tree_fn,\n \t\t\t\t\t\t\t void *, \n \t\t\t\t\t\t\t htab_t));\n extern tree walk_tree_without_duplicates        PARAMS ((tree *,\n \t\t\t\t\t\t\t walk_tree_fn,\n \t\t\t\t\t\t\t void *));\n-extern tree walk_stmt_tree\t\t\tPARAMS ((tree *,\n-\t\t\t\t\t\t\t walk_tree_fn,\n-\t\t\t\t\t\t\t void *));\n extern tree copy_tree_r                         PARAMS ((tree *, int *, void *));\n extern int cp_valid_lang_attribute\t\tPARAMS ((tree, tree, tree, tree));\n extern tree make_ptrmem_cst                     PARAMS ((tree, tree));"}, {"sha": "5ca1e5597d5ea307ffd02ef65c86a25c4d424d25", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ae499ccea4f2eee460c8612d920755773cacfe47", "patch": "@@ -169,8 +169,8 @@ static void mark_binding_level PARAMS ((void *));\n static void mark_named_label_lists PARAMS ((void *, void *));\n static void mark_cp_function_context PARAMS ((struct function *));\n static void mark_saved_scope PARAMS ((void *));\n-static void mark_lang_function PARAMS ((struct language_function *));\n-static void mark_stmt_tree PARAMS ((struct stmt_tree *));\n+static void mark_lang_function PARAMS ((struct cp_language_function *));\n+static void mark_stmt_tree PARAMS ((stmt_tree));\n static void save_function_data PARAMS ((tree));\n static void check_function_type PARAMS ((tree));\n static void destroy_local_var PARAMS ((tree));\n@@ -200,7 +200,6 @@ tree error_mark_list;\n \n    C++ extensions\n \ttree wchar_decl_node;\n-\ttree void_zero_node;\n \n \ttree vtable_entry_type;\n \ttree delta_type_node;\n@@ -2453,7 +2452,7 @@ struct saved_scope *scope_chain;\n \n static void\n mark_stmt_tree (st)\n-     struct stmt_tree *st;\n+     stmt_tree st;\n {\n   ggc_mark_tree (st->x_last_stmt);\n   ggc_mark_tree (st->x_last_expr_type);\n@@ -6471,10 +6470,6 @@ init_decl_processing ()\n   void_list_node = build_tree_list (NULL_TREE, void_type_node);\n   TREE_PARMLIST (void_list_node) = 1;\n \n-  /* Used for expressions that do nothing, but are not errors.  */\n-  void_zero_node = build_int_2 (0, 0);\n-  TREE_TYPE (void_zero_node) = void_type_node;\n-\n   string_type_node = build_pointer_type (char_type_node);\n   const_string_type_node\n     = build_pointer_type (build_qualified_type (char_type_node,\n@@ -7965,12 +7960,13 @@ initialize_local_var (decl, init, flags)\n \t  emit_line_note (DECL_SOURCE_FILE (decl),\n \t\t\t  DECL_SOURCE_LINE (decl));\n \t  saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();\n-\t  current_stmt_tree->stmts_are_full_exprs_p = 1;\n+\t  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n \t  if (building_stmt_tree ())\n \t    finish_expr_stmt (build_aggr_init (decl, init, flags));\n \t  else\n \t    genrtl_expr_stmt (build_aggr_init (decl, init, flags));\n-\t  current_stmt_tree->stmts_are_full_exprs_p = saved_stmts_are_full_exprs_p;\n+\t  current_stmt_tree ()->stmts_are_full_exprs_p = \n+\t    saved_stmts_are_full_exprs_p;\n \t}\n \n       /* Set this to 0 so we can tell whether an aggregate which was\n@@ -13244,7 +13240,7 @@ finish_enum (enumtype)\n     {\n       tree scope = current_scope ();\n       if (scope && TREE_CODE (scope) == FUNCTION_DECL)\n-\tadd_tree (build_min (TAG_DEFN, enumtype));\n+\tadd_stmt (build_min (TAG_DEFN, enumtype));\n     }\n   else\n     {\n@@ -14037,23 +14033,23 @@ static void\n save_function_data (decl)\n      tree decl;\n {\n-  struct language_function *f;\n+  struct cp_language_function *f;\n \n   /* Save the language-specific per-function data so that we can\n      get it back when we really expand this function.  */\n   my_friendly_assert (!DECL_PENDING_INLINE_P (decl),\n \t\t      19990908);\n \n   /* Make a copy.  */\n-  f = ((struct language_function *)\n-       xmalloc (sizeof (struct language_function)));\n+  f = ((struct cp_language_function *)\n+       xmalloc (sizeof (struct cp_language_function)));\n   bcopy ((char *) cp_function_chain, (char *) f,\n-\t sizeof (struct language_function));\n+\t sizeof (struct cp_language_function));\n   DECL_SAVED_FUNCTION_DATA (decl) = f;\n \n   /* Clear out the bits we don't need.  */\n-  f->x_stmt_tree.x_last_stmt = NULL_TREE;\n-  f->x_stmt_tree.x_last_expr_type = NULL_TREE;\n+  f->base.x_stmt_tree.x_last_stmt = NULL_TREE;\n+  f->base.x_stmt_tree.x_last_expr_type = NULL_TREE;\n   f->x_result_rtx = NULL_RTX;\n   f->x_named_label_uses = NULL;\n   f->bindings = NULL;\n@@ -14075,7 +14071,7 @@ finish_constructor_body ()\n {\n   /* Any return from a constructor will end up here.  */\n   if (ctor_label)\n-    add_tree (build_stmt (LABEL_STMT, ctor_label));\n+    add_stmt (build_stmt (LABEL_STMT, ctor_label));\n \n   /* Clear CTOR_LABEL so that finish_return_stmt knows to really\n      generate the return, rather than a goto to CTOR_LABEL.  */\n@@ -14084,7 +14080,7 @@ finish_constructor_body ()\n      constructor to a return of `this'.  */\n   finish_return_stmt (NULL_TREE);\n   /* Mark the end of the constructor.  */\n-  add_tree (build_stmt (CTOR_STMT));\n+  add_stmt (build_stmt (CTOR_STMT));\n }\n \n /* At the end of every destructor we generate code to restore virtual\n@@ -14103,7 +14099,7 @@ finish_destructor_body ()\n   compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n \n   /* Any return from a destructor will end up here.  */\n-  add_tree (build_stmt (LABEL_STMT, dtor_label));\n+  add_stmt (build_stmt (LABEL_STMT, dtor_label));\n \n   /* Generate the code to call destructor on base class.  If this\n      destructor belongs to a class with virtual functions, then set\n@@ -14896,18 +14892,18 @@ static void\n push_cp_function_context (f)\n      struct function *f;\n {\n-  struct language_function *p\n-    = ((struct language_function *)\n-       xcalloc (1, sizeof (struct language_function)));\n-  f->language = p;\n+  struct cp_language_function *p\n+    = ((struct cp_language_function *)\n+       xcalloc (1, sizeof (struct cp_language_function)));\n+  f->language = (struct language_function *) p;\n \n   /* It takes an explicit call to expand_body to generate RTL for a\n      function.  */\n   expanding_p = 0;\n \n   /* Whenever we start a new function, we destroy temporaries in the\n      usual way.  */\n-  current_stmt_tree->stmts_are_full_exprs_p = 1;\n+  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n }\n \n /* Free the language-specific parts of F, now that we've finished\n@@ -14926,7 +14922,7 @@ pop_cp_function_context (f)\n \n static void\n mark_lang_function (p)\n-     struct language_function *p;\n+     struct cp_language_function *p;\n {\n   if (!p)\n     return;\n@@ -14941,7 +14937,7 @@ mark_lang_function (p)\n   ggc_mark_rtx (p->x_result_rtx);\n \n   mark_named_label_lists (&p->x_named_labels, &p->x_named_label_uses);\n-  mark_stmt_tree (&p->x_stmt_tree);\n+  mark_stmt_tree (&p->base.x_stmt_tree);\n   mark_binding_level (&p->bindings);\n }\n \n@@ -14951,7 +14947,7 @@ static void\n mark_cp_function_context (f)\n      struct function *f;\n {\n-  mark_lang_function (f->language);\n+  mark_lang_function ((struct cp_language_function *) f->language);\n }\n \n void"}, {"sha": "f39f37f4e9b29fda714cac359e95fb4abb92b5aa", "filename": "gcc/cp/init.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=ae499ccea4f2eee460c8612d920755773cacfe47", "patch": "@@ -1228,11 +1228,11 @@ build_aggr_init (exp, init, flags)\n   TREE_TYPE (exp) = TYPE_MAIN_VARIANT (type);\n   begin_init_stmts (&stmt_expr, &compound_stmt);\n   destroy_temps = stmts_are_full_exprs_p ();\n-  current_stmt_tree->stmts_are_full_exprs_p = 0;\n+  current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n   expand_aggr_init_1 (TYPE_BINFO (type), exp, exp,\n \t\t      init, LOOKUP_NORMAL|flags);\n   stmt_expr = finish_init_stmts (stmt_expr, compound_stmt);\n-  current_stmt_tree->stmts_are_full_exprs_p = destroy_temps;\n+  current_stmt_tree ()->stmts_are_full_exprs_p = destroy_temps;\n   TREE_TYPE (exp) = type;\n   TREE_READONLY (exp) = was_const;\n   TREE_THIS_VOLATILE (exp) = was_volatile;\n@@ -2873,7 +2873,7 @@ build_vec_init (decl, base, maxindex, init, from_array)\n \n   begin_init_stmts (&stmt_expr, &compound_stmt);\n   destroy_temps = stmts_are_full_exprs_p ();\n-  current_stmt_tree->stmts_are_full_exprs_p = 0;\n+  current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n   rval = get_temp_regvar (ptype, \n \t\t\t  cp_convert (ptype, default_conversion (base)));\n   base = get_temp_regvar (ptype, rval);\n@@ -3035,9 +3035,9 @@ build_vec_init (decl, base, maxindex, init, from_array)\n \t}\n       else\n \t{\n-\t  current_stmt_tree->stmts_are_full_exprs_p = 1;\n+\t  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n \t  finish_expr_stmt (elt_init);\n-\t  current_stmt_tree->stmts_are_full_exprs_p = 0;\n+\t  current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n \t}\n \n       finish_expr_stmt (build_modify_expr\n@@ -3087,7 +3087,7 @@ build_vec_init (decl, base, maxindex, init, from_array)\n   finish_expr_stmt (rval);\n \n   stmt_expr = finish_init_stmts (stmt_expr, compound_stmt);\n-  current_stmt_tree->stmts_are_full_exprs_p = destroy_temps;\n+  current_stmt_tree ()->stmts_are_full_exprs_p = destroy_temps;\n   return stmt_expr;\n }\n "}, {"sha": "0435e2f3e50c225d8eb5d5c594f041bd1134bafd", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 49, "deletions": 154, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=ae499ccea4f2eee460c8612d920755773cacfe47", "patch": "@@ -48,27 +48,20 @@\n \n static tree maybe_convert_cond PARAMS ((tree));\n static tree simplify_aggr_init_exprs_r PARAMS ((tree *, int *, void *));\n-static tree prune_unused_decls PARAMS ((tree *, int *, void *));\n static void deferred_type_access_control PARAMS ((void));\n static void emit_associated_thunks PARAMS ((tree));\n \n-/* Record the fact that STMT was the last statement added to the\n-   statement tree.  */\n-\n-#define SET_LAST_STMT(stmt) \\\n-  (current_stmt_tree->x_last_stmt = (stmt))\n-\n /* When parsing a template, LAST_TREE contains the last statement\n    parsed.  These are chained together through the TREE_CHAIN field,\n    but often need to be re-organized since the parse is performed\n    bottom-up.  This macro makes LAST_TREE the indicated SUBSTMT of\n    STMT.  */\n \n-#define RECHAIN_STMTS(stmt, substmt)\t\\\n-  do {\t\t\t\t\t\\\n-    substmt = TREE_CHAIN (stmt);\t\\\n-    TREE_CHAIN (stmt) = NULL_TREE;\t\\\n-    SET_LAST_STMT (stmt);\t\t\\\n+#define RECHAIN_STMTS(stmt, substmt)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    substmt = TREE_CHAIN (stmt);\t\t\\\n+    TREE_CHAIN (stmt) = NULL_TREE;\t\t\\\n+    last_tree = stmt;\t\t\t\t\\\n   } while (0)\n \n /* Finish processing the COND, the SUBSTMT condition for STMT.  */\n@@ -108,7 +101,19 @@ set_current_function_name_declared (i)\n int\n stmts_are_full_exprs_p ()\n {\n-  return current_stmt_tree->stmts_are_full_exprs_p;\n+  return current_stmt_tree ()->stmts_are_full_exprs_p;\n+}\n+\n+/* Returns the stmt_tree (if any) to which statements are currently\n+   being added.  If there is no active statement-tree, NULL is\n+   returned.  */\n+\n+stmt_tree\n+current_stmt_tree ()\n+{\n+  return (cfun \n+\t  ? &cfun->language->x_stmt_tree \n+\t  : &scope_chain->x_stmt_tree);\n }\n \n /* One if we have already declared __FUNCTION__ (and related\n@@ -170,20 +175,6 @@ do_pushlevel ()\n     }\n }\n \n-/* T is a statement.  Add it to the statement-tree.  */\n-\n-void\n-add_tree (t)\n-     tree t;\n-{\n-  /* Add T to the statement-tree.  */\n-  TREE_CHAIN (last_tree) = t;\n-  SET_LAST_STMT (t);\n-  /* When we expand a statement-tree, we must know whether or not the\n-     statements are full-expresions.  We record that fact here.  */\n-  STMT_IS_FULL_EXPR_P (last_tree) = stmts_are_full_exprs_p ();\n-}\n-\n /* Finish a goto-statement.  */\n \n void\n@@ -207,7 +198,7 @@ finish_goto_stmt (destination)\n   \n   check_goto (destination);\n \n-  add_tree (build_stmt (GOTO_STMT, destination));\n+  add_stmt (build_stmt (GOTO_STMT, destination));\n }\n \n /* COND is the condition-expression for an if, while, etc.,\n@@ -251,7 +242,7 @@ finish_expr_stmt (expr)\n       if (!processing_template_decl)\n \texpr = break_out_cleanups (expr);\n       \n-      add_tree (build_stmt (EXPR_STMT, expr));\n+      add_stmt (build_stmt (EXPR_STMT, expr));\n     }\n \n   finish_stmt ();\n@@ -271,7 +262,7 @@ begin_if_stmt ()\n   tree r;\n   do_pushlevel ();\n   r = build_stmt (IF_STMT, NULL_TREE, NULL_TREE, NULL_TREE);\n-  add_tree (r);\n+  add_stmt (r);\n   return r;\n }\n \n@@ -295,7 +286,7 @@ finish_then_clause (if_stmt)\n      tree if_stmt;\n {\n   RECHAIN_STMTS (if_stmt, THEN_CLAUSE (if_stmt));\n-  SET_LAST_STMT (if_stmt);\n+  last_tree = if_stmt;\n   return if_stmt;\n }\n \n@@ -346,7 +337,7 @@ begin_while_stmt ()\n {\n   tree r;\n   r = build_stmt (WHILE_STMT, NULL_TREE, NULL_TREE);\n-  add_tree (r);\n+  add_stmt (r);\n   do_pushlevel ();\n   return r;\n }\n@@ -382,7 +373,7 @@ tree\n begin_do_stmt ()\n {\n   tree r = build_stmt (DO_STMT, NULL_TREE, NULL_TREE);\n-  add_tree (r);\n+  add_stmt (r);\n   return r;\n }\n \n@@ -440,7 +431,7 @@ finish_return_stmt (expr)\n \t  return;\n \t}\n     }\n-  add_tree (build_stmt (RETURN_STMT, expr));\n+  add_stmt (build_stmt (RETURN_STMT, expr));\n   finish_stmt ();\n }\n \n@@ -454,7 +445,7 @@ begin_for_stmt ()\n   r = build_stmt (FOR_STMT, NULL_TREE, NULL_TREE, \n \t\t  NULL_TREE, NULL_TREE);\n   NEW_FOR_SCOPE_P (r) = flag_new_for_scope > 0;\n-  add_tree (r);\n+  add_stmt (r);\n   if (NEW_FOR_SCOPE_P (r))\n     {\n       do_pushlevel ();\n@@ -521,15 +512,15 @@ finish_for_stmt (for_stmt)\n void\n finish_break_stmt ()\n {\n-  add_tree (build_stmt (BREAK_STMT));\n+  add_stmt (build_stmt (BREAK_STMT));\n }\n \n /* Finish a continue-statement.  */\n \n void\n finish_continue_stmt ()\n {\n-  add_tree (build_stmt (CONTINUE_STMT));\n+  add_stmt (build_stmt (CONTINUE_STMT));\n }\n \n /* Begin a switch-statement.  Returns a new SWITCH_STMT if\n@@ -540,7 +531,7 @@ begin_switch_stmt ()\n {\n   tree r;\n   r = build_stmt (SWITCH_STMT, NULL_TREE, NULL_TREE);\n-  add_tree (r);\n+  add_stmt (r);\n   do_pushlevel ();\n   return r;\n }\n@@ -593,7 +584,7 @@ finish_case_label (low_value, high_value)\n {\n   /* Add a representation for the case label to the statement\n      tree.  */\n-  add_tree (build_stmt (CASE_LABEL, low_value, high_value));\n+  add_stmt (build_stmt (CASE_LABEL, low_value, high_value));\n   /* And warn about crossing initializations, etc.  */\n   if (!processing_template_decl)\n     define_case_label ();\n@@ -649,7 +640,7 @@ tree\n begin_try_block ()\n {\n   tree r = build_stmt (TRY_BLOCK, NULL_TREE, NULL_TREE);\n-  add_tree (r);\n+  add_stmt (r);\n   return r;\n }\n \n@@ -660,7 +651,7 @@ begin_function_try_block ()\n {\n   tree r = build_stmt (TRY_BLOCK, NULL_TREE, NULL_TREE);\n   FN_TRY_BLOCK_P (r) = 1;\n-  add_tree (r);\n+  add_stmt (r);\n   return r;\n }\n \n@@ -761,7 +752,7 @@ begin_handler ()\n {\n   tree r;\n   r = build_stmt (HANDLER, NULL_TREE, NULL_TREE);\n-  add_tree (r);\n+  add_stmt (r);\n   do_pushlevel ();\n   return r;\n }\n@@ -813,7 +804,7 @@ void\n begin_catch_block (type)\n      tree type;\n {\n-  add_tree (build (START_CATCH_STMT, type));\n+  add_stmt (build (START_CATCH_STMT, type));\n }\n \n /* Finish a handler, which may be given by HANDLER.  The BLOCKs are\n@@ -861,7 +852,7 @@ begin_compound_stmt (has_no_scope)\n   if (last_tree && TREE_CODE (last_tree) == TRY_BLOCK)\n     is_try = 1;\n \n-  add_tree (r);\n+  add_stmt (r);\n   if (has_no_scope)\n     COMPOUND_STMT_NO_SCOPE (r) = 1;\n \n@@ -957,7 +948,7 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n   r = build_stmt (ASM_STMT, cv_qualifier, string,\n \t\t  output_operands, input_operands,\n \t\t  clobbers);\n-  add_tree (r);\n+  add_stmt (r);\n }\n \n /* Finish a label with the indicated NAME.  */\n@@ -967,7 +958,7 @@ finish_label_stmt (name)\n      tree name;\n {\n   tree decl = define_label (input_filename, lineno, name);\n-  add_tree (build_stmt (LABEL_STMT, decl));\n+  add_stmt (build_stmt (LABEL_STMT, decl));\n }\n \n /* Finish a series of declarations for local labels.  G++ allows users\n@@ -993,7 +984,7 @@ add_decl_stmt (decl)\n \n   /* We need the type to last until instantiation time.  */\n   decl_stmt = build_stmt (DECL_STMT, decl);\n-  add_tree (decl_stmt); \n+  add_stmt (decl_stmt); \n }\n \n /* Generate the RTL for a SUBOBJECT. */\n@@ -1014,7 +1005,7 @@ finish_subobject (cleanup)\n      tree cleanup;\n {\n   tree r = build_stmt (SUBOBJECT, cleanup);\n-  add_tree (r);\n+  add_stmt (r);\n }\n \n /* When DECL goes out of scope, make sure that CLEANUP is executed.  */\n@@ -1024,7 +1015,7 @@ finish_decl_cleanup (decl, cleanup)\n      tree decl;\n      tree cleanup;\n {\n-  add_tree (build_stmt (CLEANUP_STMT, decl, cleanup));\n+  add_stmt (build_stmt (CLEANUP_STMT, decl, cleanup));\n }\n \n /* Generate the RTL for a RETURN_INIT. */\n@@ -1103,10 +1094,10 @@ finish_named_return_value (return_id, init)\n       if (!processing_template_decl) \n \t{\n \t  cp_finish_decl (decl, init, NULL_TREE, 0);\n-\t  add_tree (build_stmt (RETURN_INIT, NULL_TREE, NULL_TREE));\n+\t  add_stmt (build_stmt (RETURN_INIT, NULL_TREE, NULL_TREE));\n \t}\n       else\n-\tadd_tree (build_stmt (RETURN_INIT, return_id, init));\n+\tadd_stmt (build_stmt (RETURN_INIT, return_id, init));\n     }\n \n   /* Don't use tree-inlining for functions with named return values.\n@@ -1192,7 +1183,7 @@ setup_vtbl_ptr (member_init_list, base_init_list)\n   if (DECL_CONSTRUCTOR_P (current_function_decl))\n     {\n       if (processing_template_decl)\n-\tadd_tree (build_min_nt\n+\tadd_stmt (build_min_nt\n \t\t  (CTOR_INITIALIZER,\n \t\t   member_init_list, base_init_list));\n       else\n@@ -1202,7 +1193,7 @@ setup_vtbl_ptr (member_init_list, base_init_list)\n \t  /* Mark the beginning of the constructor.  */\n \t  ctor_stmt = build_stmt (CTOR_STMT);\n \t  CTOR_BEGIN_P (ctor_stmt) = 1;\n-\t  add_tree (ctor_stmt);\n+\t  add_stmt (ctor_stmt);\n \t  \n \t  /* And actually initialize the base-classes and members.  */\n \t  emit_base_init (member_init_list, base_init_list);\n@@ -1299,7 +1290,7 @@ add_scope_stmt (begin_p, partial_p)\n     }\n \n   /* Add the new statement to the statement-tree.  */\n-  add_tree (ss);\n+  add_stmt (ss);\n \n   return top;\n }\n@@ -1391,7 +1382,7 @@ finish_stmt_expr (rtl_expr)\n   \n   /* Remove the compound statement from the tree structure; it is\n      now saved in the STMT_EXPR.  */\n-  SET_LAST_STMT (rtl_expr);\n+  last_tree = rtl_expr;\n   TREE_CHAIN (last_tree) = NULL_TREE;\n \n   /* If we created a statement-tree for this statement-expression,\n@@ -2223,103 +2214,6 @@ finish_typeof (expr)\n   return TREE_TYPE (expr);\n }\n \n-/* Remove declarations of internal variables that are not used from a\n-   stmt tree.  To qualify, the variable must have a name and must have\n-   a zero DECL_SOURCE_LINE.  We tried to remove all variables for\n-   which TREE_USED was false, but it turns out that there's tons of\n-   variables for which TREE_USED is false but that are still in fact\n-   used.  */\n-\n-static tree\n-prune_unused_decls (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  tree t = *tp;\n-\n-  if (t == NULL_TREE)\n-    {\n-      *walk_subtrees = 0;\n-      return NULL_TREE;\n-    }\n-\n-  if (TREE_CODE (t) == DECL_STMT)\n-    {\n-      tree d = DECL_STMT_DECL (t);\n-      if (!TREE_USED (d) && DECL_NAME (d) && DECL_SOURCE_LINE (d) == 0)\n-\t{\n-\t  *tp = TREE_CHAIN (t);\n-\t  /* Recurse on the new value of tp, otherwise we will skip\n-\t     the next statement.  */\n-\t  return prune_unused_decls (tp, walk_subtrees, data);\n-\t}\n-    }\n-  else if (TREE_CODE (t) == SCOPE_STMT)\n-    {\n-      /* Remove all unused decls from the BLOCK of this SCOPE_STMT.  */\n-      tree block = SCOPE_STMT_BLOCK (t);\n-\n-      if (block)\n-\t{\n-\t  tree *vp;\n-\n-\t  for (vp = &BLOCK_VARS (block); *vp; )\n-\t    {\n-\t      tree v = *vp;\n-\t      if (! TREE_USED (v) && DECL_NAME (v) && DECL_SOURCE_LINE (v) == 0)\n-\t\t*vp = TREE_CHAIN (v);  /* drop */\n-\t      else\n-\t\tvp = &TREE_CHAIN (v);  /* advance */\n-\t    }\n-\t  /* If there are now no variables, the entire BLOCK can be dropped.\n-\t     (This causes SCOPE_NULLIFIED_P (t) to be true.)  */\n-\t  if (BLOCK_VARS (block) == NULL_TREE)\n-\t    SCOPE_STMT_BLOCK (t) = NULL_TREE;\n-\t}\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* Create an empty statement tree rooted at T.  */\n-\n-void\n-begin_stmt_tree (t)\n-     tree *t;\n-{\n-  /* We create a trivial EXPR_STMT so that last_tree is never NULL in\n-     what follows.  We remove the extraneous statement in\n-     finish_stmt_tree.  */\n-  *t = build_nt (EXPR_STMT, void_zero_node);\n-  SET_LAST_STMT (*t);\n-  last_expr_type = NULL_TREE;\n-}\n-\n-/* Finish the statement tree rooted at T.  */\n-\n-void\n-finish_stmt_tree (t)\n-     tree *t;\n-{\n-  tree stmt;\n-  \n-  /* Remove the fake extra statement added in begin_stmt_tree.  */\n-  stmt = TREE_CHAIN (*t);\n-  *t = stmt;\n-  SET_LAST_STMT (NULL_TREE);\n-\n-  /* Remove unused decls from the stmt tree.  */\n-  walk_stmt_tree (t, prune_unused_decls, NULL);\n-\n-  if (cfun)\n-    {\n-      /* The line-number recorded in the outermost statement in a function\n-\t is the line number of the end of the function.  */\n-      STMT_LINENO (stmt) = lineno;\n-      STMT_LINENO_FOR_FN_P (stmt) = 1;\n-    }\n-}\n-\n /* We're about to expand T, a statement.  Set up appropriate context\n    for the substitution.  */\n \n@@ -2329,7 +2223,7 @@ prep_stmt (t)\n {\n   if (!STMT_LINENO_FOR_FN_P (t))\n     lineno = STMT_LINENO (t);\n-  current_stmt_tree->stmts_are_full_exprs_p = STMT_IS_FULL_EXPR_P (t);\n+  current_stmt_tree ()->stmts_are_full_exprs_p = STMT_IS_FULL_EXPR_P (t);\n }\n \n /* Generate RTL for the statement T, and its substatements, and any\n@@ -2453,7 +2347,8 @@ lang_expand_stmt (t)\n \t}\n \n       /* Restore saved state.  */\n-      current_stmt_tree->stmts_are_full_exprs_p = saved_stmts_are_full_exprs_p;\n+      current_stmt_tree ()->stmts_are_full_exprs_p = \n+\tsaved_stmts_are_full_exprs_p;\n \n       /* Go on to the next statement in this scope.  */\n       t = TREE_CHAIN (t);"}, {"sha": "396b5c4f807d4608d66048d9488b84b47d53de82", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 7, "deletions": 88, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae499ccea4f2eee460c8612d920755773cacfe47/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=ae499ccea4f2eee460c8612d920755773cacfe47", "patch": "@@ -42,14 +42,14 @@ static cp_lvalue_kind lvalue_p_1 PARAMS ((tree, int));\n static tree no_linkage_helper PARAMS ((tree *, int *, void *));\n static tree build_srcloc PARAMS ((const char *, int));\n static void mark_list_hash PARAMS ((void *));\n-static int statement_code_p PARAMS ((enum tree_code));\n static tree mark_local_for_remap_r PARAMS ((tree *, int *, void *));\n static tree cp_unsave_r PARAMS ((tree *, int *, void *));\n static void cp_unsave PARAMS ((tree *));\n static tree build_target_expr PARAMS ((tree, tree));\n static tree count_trees_r PARAMS ((tree *, int *, void *));\n static tree verify_stmt_tree_r PARAMS ((tree *, int *, void *));\n static tree find_tree_r PARAMS ((tree *, int *, void *));\n+extern int cp_statement_code_p PARAMS ((enum tree_code));\n \n /* If REF is an lvalue, returns the kind of lvalue that REF is.\n    Otherwise, returns clk_none.  If TREAT_CLASS_RVALUES_AS_LVALUES is\n@@ -1071,33 +1071,18 @@ is_aggr_type_2 (t1, t2)\n \n /* Returns non-zero if CODE is the code for a statement.  */\n \n-static int\n-statement_code_p (code)\n+int\n+cp_statement_code_p (code)\n      enum tree_code code;\n {\n   switch (code)\n     {\n-    case EXPR_STMT:\n-    case COMPOUND_STMT:\n-    case DECL_STMT:\n-    case IF_STMT:\n-    case FOR_STMT:\n-    case WHILE_STMT:\n-    case DO_STMT:\n-    case RETURN_STMT:\n-    case BREAK_STMT:\n-    case CONTINUE_STMT:\n-    case SWITCH_STMT:\n-    case GOTO_STMT:\n-    case LABEL_STMT:\n-    case ASM_STMT:\n     case SUBOBJECT:\n     case CLEANUP_STMT:\n     case START_CATCH_STMT:\n     case CTOR_STMT:\n     case SCOPE_STMT:\n     case CTOR_INITIALIZER:\n-    case CASE_LABEL:\n     case RETURN_INIT:\n     case TRY_BLOCK:\n     case HANDLER:\n@@ -1223,9 +1208,9 @@ copy_template_template_parm (t, newargs)\n /* Apply FUNC to all the sub-trees of TP in a pre-order traversal.\n    FUNC is called with the DATA and the address of each sub-tree.  If\n    FUNC returns a non-NULL value, the traversal is aborted, and the\n-   value returned by FUNC is returned.  The FLAGS govern the way in\n-   which nodes are walked.  If HTAB is non-NULL it is used to record\n-   the nodes visited, and to avoid visiting a node more than once.  */\n+   value returned by FUNC is returned.  If HTAB is non-NULL it is used\n+   to record the nodes visited, and to avoid visiting a node more than\n+   once.  */\n \n tree \n walk_tree (tp, func, data, htab)\n@@ -1455,73 +1440,6 @@ walk_tree_without_duplicates (tp, func, data)\n   return result;\n }\n \n-/* Like walk_tree, but only examines statement nodes.  We don't need a\n-   without_duplicates variant of this one because the statement tree is\n-   a tree, not a graph.  */\n-\n-tree \n-walk_stmt_tree (tp, func, data)\n-     tree *tp;\n-     walk_tree_fn func;\n-     void *data;\n-{\n-  enum tree_code code;\n-  int walk_subtrees;\n-  tree result;\n-  int i, len;\n-\n-#define WALK_SUBTREE(NODE)\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      result = walk_stmt_tree (&(NODE), func, data);\t\\\n-      if (result)\t\t\t\t\t\\\n-\treturn result;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-  /* Skip empty subtrees.  */\n-  if (!*tp)\n-    return NULL_TREE;\n-\n-  /* Skip subtrees below non-statement nodes.  */\n-  if (!statement_code_p (TREE_CODE (*tp)))\n-    return NULL_TREE;\n-\n-  /* Call the function.  */\n-  walk_subtrees = 1;\n-  result = (*func) (tp, &walk_subtrees, data);\n-\n-  /* If we found something, return it.  */\n-  if (result)\n-    return result;\n-\n-  /* Even if we didn't, FUNC may have decided that there was nothing\n-     interesting below this point in the tree.  */\n-  if (!walk_subtrees)\n-    return NULL_TREE;\n-\n-  /* FUNC may have modified the tree, recheck that we're looking at a\n-     statement node.  */\n-  code = TREE_CODE (*tp);\n-  if (!statement_code_p (code))\n-    return NULL_TREE;\n-\n-  /* Walk over all the sub-trees of this operand.  Statement nodes never\n-     contain RTL, and we needn't worry about TARGET_EXPRs.  */\n-  len = TREE_CODE_LENGTH (code);\n-\n-  /* Go through the subtrees.  We need to do this in forward order so\n-     that the scope of a FOR_EXPR is handled properly.  */\n-  for (i = 0; i < len; ++i)\n-    WALK_SUBTREE (TREE_OPERAND (*tp, i));\n-\n-  /* Finally visit the chain.  This can be tail-recursion optimized if\n-     we write it this way.  */\n-  return walk_stmt_tree (&TREE_CHAIN (*tp), func, data);\n-\n-#undef WALK_SUBTREE\n-}\n-\n /* Called from count_trees via walk_tree.  */\n \n static tree\n@@ -2477,6 +2395,7 @@ init_tree ()\n {\n   make_lang_type_fn = cp_make_lang_type;\n   lang_unsave = cp_unsave;\n+  lang_statement_code_p = cp_statement_code_p;\n   ggc_add_root (list_hash_table, \n \t\tARRAY_SIZE (list_hash_table),\n \t\tsizeof (struct list_hash *),"}, {"sha": "21574a96285b9d599b459feb528ddd63ce235ec7", "filename": "libio/editbuf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae499ccea4f2eee460c8612d920755773cacfe47/libio%2Feditbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae499ccea4f2eee460c8612d920755773cacfe47/libio%2Feditbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Feditbuf.h?ref=ae499ccea4f2eee460c8612d920755773cacfe47", "patch": "@@ -1,5 +1,5 @@\n /* This is part of libio/iostream, providing -*- C++ -*- input/output.\n-Copyright (C) 1993 Free Software Foundation\n+Copyright (C) 1993, 2000 Free Software Foundation\n \n This file is part of the GNU IO Library.  This library is free\n software; you can redistribute it and/or modify it under the"}, {"sha": "ea60b7b3c5849dbcba293dd8ca8f4249da245e5f", "filename": "libobjc/encoding.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae499ccea4f2eee460c8612d920755773cacfe47/libobjc%2Fencoding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae499ccea4f2eee460c8612d920755773cacfe47/libobjc%2Fencoding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fencoding.c?ref=ae499ccea4f2eee460c8612d920755773cacfe47", "patch": "@@ -1,5 +1,5 @@\n /* Encoding of types for Objective C.\n-   Copyright (C) 1993, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1995, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.\n    Contributed by Kresten Krab Thorup\n    Bitfield support by Ovidiu Predescu\n "}]}