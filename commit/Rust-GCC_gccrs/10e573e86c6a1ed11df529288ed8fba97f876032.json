{"sha": "10e573e86c6a1ed11df529288ed8fba97f876032", "node_id": "C_kwDOANBUbNoAKDEwZTU3M2U4NmM2YTFlZDExZGY1MjkyODhlZDhmYmE5N2Y4NzYwMzI", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2023-03-31T12:17:00Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2023-03-31T13:20:51Z"}, "message": "libstdc++: Revert addition of boolean flag to net::ip::basic_endpoint\n\nAs pointed out in P2641R1, we can use GCC's __builtin_constant_p to\nemulate the proposed std::is_active_member. This allows us to detect\nwhich of the union members is active during constant evaluation, so we\ndon't need the extra bool data member. We still can't support constexpr\nuntil C++20 though, as we need to change the active member during\nconstant evaluation.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/experimental/internet (ip::basic_endpoint::_M_if_v6):\n\tRevert change from member function to data member. Fix for\n\tconstant evaluation by detecting which union member is active.\n\t(ip::basic_endpoint::resize): Revert changes to update _M_is_v6\n\tflag.", "tree": {"sha": "fe09dcde804ae9a21ea58ffe4a3a20dc3b456fcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe09dcde804ae9a21ea58ffe4a3a20dc3b456fcb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10e573e86c6a1ed11df529288ed8fba97f876032", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e573e86c6a1ed11df529288ed8fba97f876032", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10e573e86c6a1ed11df529288ed8fba97f876032", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e573e86c6a1ed11df529288ed8fba97f876032/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e02c9d9116f243643c0daba8dbcc5d1795c827c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e02c9d9116f243643c0daba8dbcc5d1795c827c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e02c9d9116f243643c0daba8dbcc5d1795c827c3"}], "stats": {"total": 32, "additions": 14, "deletions": 18}, "files": [{"sha": "eb23ae21cdc1d6daf5631ea78314d3bde937afe0", "filename": "libstdc++-v3/include/experimental/internet", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e573e86c6a1ed11df529288ed8fba97f876032/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Finternet", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e573e86c6a1ed11df529288ed8fba97f876032/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Finternet", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Finternet?ref=10e573e86c6a1ed11df529288ed8fba97f876032", "patch": "@@ -1531,7 +1531,6 @@ namespace ip\n \t    std::_Construct(&_M_data._M_v6);\n \t    _M_data._M_v6.sin6_family = __proto.family();\n \t    _M_data._M_v6.sin6_port = address_v4::_S_hton_16(__port_num);\n-\t    _M_is_v6 = true;\n \t  }\n \telse\n \t  {\n@@ -1560,21 +1559,20 @@ namespace ip\n \t    for (int __i = 0; __i < 16; ++__i)\n \t      __s6a[__i] = __addr._M_v6._M_bytes[__i];\n \t    _M_data._M_v6.sin6_scope_id = __addr._M_v6._M_scope_id;\n-\t    _M_is_v6 = true;\n \t  }\n       }\n \n       // members:\n \n       constexpr protocol_type protocol() const noexcept\n       {\n-\treturn _M_is_v6 ? protocol_type::v6() : protocol_type::v4();\n+\treturn _M_is_v6() ? protocol_type::v6() : protocol_type::v4();\n       }\n \n       constexpr ip::address\n       address() const noexcept\n       {\n-\tif (_M_is_v6)\n+\tif (_M_is_v6())\n \t  {\n \t    address_v6 __v6;\n \t    const uint8_t* __s6a = _M_data._M_v6.sin6_addr.s6_addr;\n@@ -1601,22 +1599,20 @@ namespace ip\n \t    __builtin_memcpy(_M_data._M_v6.sin6_addr.s6_addr,\n \t\t\t     __addr._M_v6._M_bytes.data(), 16);\n \t    _M_data._M_v6.sin6_scope_id = __addr._M_v6._M_scope_id;\n-\t    _M_is_v6 = true;\n \t  }\n \telse\n \t  {\n \t    std::_Construct(&_M_data._M_v4);\n \t    _M_data._M_v4.sin_family = protocol_type::v4().family();\n \t    _M_data._M_v4.sin_addr.s_addr = __addr._M_v4._M_addr;\n-\t    _M_is_v6 = false;\n \t  }\n       }\n \n       constexpr port_type\n       port() const noexcept\n       {\n \tport_type __p = 0;\n-\tif (_M_is_v6)\n+\tif (_M_is_v6())\n \t  __p = _M_data._M_v6.sin6_port;\n \telse\n \t  __p = _M_data._M_v4.sin_port;\n@@ -1627,7 +1623,7 @@ namespace ip\n       port(port_type __port_num) noexcept\n       {\n \t__port_num = address_v4::_S_hton_16(__port_num);\n-\tif (_M_is_v6)\n+\tif (_M_is_v6())\n \t  _M_data._M_v6.sin6_port = __port_num;\n \telse\n \t  _M_data._M_v4.sin_port = __port_num;\n@@ -1639,19 +1635,11 @@ namespace ip\n \n       constexpr size_t\n       size() const noexcept\n-      { return _M_is_v6 ? sizeof(sockaddr_in6) : sizeof(sockaddr_in); }\n+      { return _M_is_v6() ? sizeof(sockaddr_in6) : sizeof(sockaddr_in); }\n \n       void\n       resize(size_t __s)\n       {\n-\t__glibcxx_assert(__s >= 0);\n-\tstatic_assert(offsetof(sockaddr_in6, sin6_family)\n-\t\t\t== offsetof(sockaddr_in, sin_family),\n-\t\t      \"sockaddr_in::sin_family and sockaddr_in6::sin6_family \"\n-\t\t      \"must be at the same offset\");\n-\tconst sa_family_t __in6 = AF_INET6;\n-\tconst auto* __ptr = (char*)&_M_data + offsetof(sockaddr_in, sin_family);\n-\t_M_is_v6 = __builtin_memcmp(&__in6, __ptr, sizeof(__in6)) == 0;\n \tif (__s != size())\n \t  __throw_length_error(\"net::ip::basic_endpoint::resize\");\n       }\n@@ -1665,7 +1653,15 @@ namespace ip\n \tsockaddr_in6\t_M_v6;\n       } _M_data;\n \n-      bool _M_is_v6 = false;\n+      constexpr bool\n+      _M_is_v6() const noexcept\n+      {\n+\t// For constexpr eval we can just detect which union member is active.\n+\t// i.e. emulate P2641R1's std::is_active_member(&_M_data._M_v6)).\n+\tif (std::__is_constant_evaluated())\n+\t  return __builtin_constant_p(_M_data._M_v6.sin6_family);\n+\treturn _M_data._M_v6.sin6_family == AF_INET6;\n+      }\n     };\n \n   /** basic_endpoint comparisons"}]}