{"sha": "0609bdf2114919b570e7a3c4ab273fdf16262a4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYwOWJkZjIxMTQ5MTliNTcwZTdhM2M0YWIyNzNmZGYxNjI2MmE0Yg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2013-10-03T16:08:53Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2013-10-03T16:08:53Z"}, "message": "rs6000-builtin.def (XSRDPIM): Use floatdf2, ceildf2, btruncdf2, instead of vsx_* name.\n\n[gcc]\n2013-10-03  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000-builtin.def (XSRDPIM): Use floatdf2,\n\tceildf2, btruncdf2, instead of vsx_* name.\n\n\t* config/rs6000/vsx.md (vsx_add<mode>3): Change arithmetic\n\titerators to only do V2DF and V4SF here.  Move the DF code to\n\trs6000.md where it is combined with SF mode.  Replace <VSv> with\n\tjust 'v' since only vector operations are handled with these insns\n\tafter moving the DF support to rs6000.md.\n\t(vsx_sub<mode>3): Likewise.\n\t(vsx_mul<mode>3): Likewise.\n\t(vsx_div<mode>3): Likewise.\n\t(vsx_fre<mode>2): Likewise.\n\t(vsx_neg<mode>2): Likewise.\n\t(vsx_abs<mode>2): Likewise.\n\t(vsx_nabs<mode>2): Likewise.\n\t(vsx_smax<mode>3): Likewise.\n\t(vsx_smin<mode>3): Likewise.\n\t(vsx_sqrt<mode>2): Likewise.\n\t(vsx_rsqrte<mode>2): Likewise.\n\t(vsx_fms<mode>4): Likewise.\n\t(vsx_nfma<mode>4): Likewise.\n\t(vsx_copysign<mode>3): Likewise.\n\t(vsx_btrunc<mode>2): Likewise.\n\t(vsx_floor<mode>2): Likewise.\n\t(vsx_ceil<mode>2): Likewise.\n\t(vsx_smaxsf3): Delete scalar ops that were moved to rs6000.md.\n\t(vsx_sminsf3): Likewise.\n\t(vsx_fmadf4): Likewise.\n\t(vsx_fmsdf4): Likewise.\n\t(vsx_nfmadf4): Likewise.\n\t(vsx_nfmsdf4): Likewise.\n\t(vsx_cmpdf_internal1): Likewise.\n\n\t* config/rs6000/rs6000.h (TARGET_SF_SPE): Define macros to make it\n\tsimpler to select whether a target has SPE or traditional floating\n\tpoint support in iterators.\n\t(TARGET_DF_SPE): Likewise.\n\t(TARGET_SF_FPR): Likewise.\n\t(TARGET_DF_FPR): Likewise.\n\t(TARGET_SF_INSN): Macros to say whether floating point support\n\texists for a given operation for expanders.\n\t(TARGET_DF_INSN): Likewise.\n\n\t* config/rs6000/rs6000.c (Ftrad): New mode attributes to allow\n\tcombining of SF/DF mode operations, using both traditional and VSX\n\tregisters.\n\t(Fvsx): Likewise.\n\t(Ff): Likewise.\n\t(Fv): Likewise.\n\t(Fs): Likewise.\n\t(Ffre): Likewise.\n\t(FFRE): Likewise.\n\t(abs<mode>2): Combine SF/DF modes using traditional floating point\n\tinstructions.  Add support for using the upper DF registers with\n\tVSX support, and SF registers with power8-vector support.  Update\n\texpanders for operations supported by both the SPE and traditional\n\tfloating point units.\n\t(abs<mode>2_fpr): Likewise.\n\t(nabs<mode>2): Likewise.\n\t(nabs<mode>2_fpr): Likewise.\n\t(neg<mode>2): Likewise.\n\t(neg<mode>2_fpr): Likewise.\n\t(add<mode>3): Likewise.\n\t(add<mode>3_fpr): Likewise.\n\t(sub<mode>3): Likewise.\n\t(sub<mode>3_fpr): Likewise.\n\t(mul<mode>3): Likewise.\n\t(mul<mode>3_fpr): Likewise.\n\t(div<mode>3): Likewise.\n\t(div<mode>3_fpr): Likewise.\n\t(sqrt<mode>3): Likewise.\n\t(sqrt<mode>3_fpr): Likewise.\n\t(fre<Fs>): Likewise.\n\t(rsqrt<mode>2): Likewise.\n\t(cmp<mode>_fpr): Likewise.\n\t(smax<mode>3): Likewise.\n\t(smin<mode>3): Likewise.\n\t(smax<mode>3_vsx): Likewise.\n\t(smin<mode>3_vsx): Likewise.\n\t(negsf2): Delete SF operations that are merged with DF.\n\t(abssf2): Likewise.\n\t(addsf3): Likewise.\n\t(subsf3): Likewise.\n\t(mulsf3): Likewise.\n\t(divsf3): Likewise.\n\t(fres): Likewise.\n\t(fmasf4_fpr): Likewise.\n\t(fmssf4_fpr): Likewise.\n\t(nfmasf4_fpr): Likewise.\n\t(nfmssf4_fpr): Likewise.\n\t(sqrtsf2): Likewise.\n\t(rsqrtsf_internal1): Likewise.\n\t(smaxsf3): Likewise.\n\t(sminsf3): Likewise.\n\t(cmpsf_internal1): Likewise.\n\t(copysign<mode>3_fcpsgn): Add VSX/power8-vector support.\n\t(negdf2): Delete DF operations that are merged with SF.\n\t(absdf2): Likewise.\n\t(nabsdf2): Likewise.\n\t(adddf3): Likewise.\n\t(subdf3): Likewise.\n\t(muldf3): Likewise.\n\t(divdf3): Likewise.\n\t(fred): Likewise.\n\t(rsqrtdf_internal1): Likewise.\n\t(fmadf4_fpr): Likewise.\n\t(fmsdf4_fpr): Likewise.\n\t(nfmadf4_fpr): Likewise.\n\t(nfmsdf4_fpr): Likewise.\n\t(sqrtdf2): Likewise.\n\t(smaxdf3): Likewise.\n\t(smindf3): Likewise.\n\t(cmpdf_internal1): Likewise.\n\t(lrint<mode>di2): Use TARGET_<MODE>_FPR macro.\n\t(btrunc<mode>2): Delete separate expander, and combine with the\n\tinsn and add VSX instruction support.  Use TARGET_<MODE>_FPR.\n\t(btrunc<mode>2_fpr): Likewise.\n\t(ceil<mode>2): Likewise.\n\t(ceil<mode>2_fpr): Likewise.\n\t(floor<mode>2): Likewise.\n\t(floor<mode>2_fpr): Likewise.\n\t(fma<mode>4_fpr): Combine SF and DF fused multiply/add support.\n\tAdd support for using the upper registers with VSX and\n\tpower8-vector.  Move insns to be closer to the define_expands. On\n\tVSX systems, prefer the traditional form of FMA over the VSX\n\tversion, since the traditional form allows the target not to\n\toverlap with the inputs.\n\t(fms<mode>4_fpr): Likewise.\n\t(nfma<mode>4_fpr): Likewise.\n\t(nfms<mode>4_fpr): Likewise.\n\n[gcc/testsuite]\n2013-10-03  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/p8vector-fp.c: New test for floating point\n\tscalar operations when using -mupper-regs-sf and -mupper-regs-df.\n\t* gcc.target/powerpc/ppc-target-1.c: Update tests to allow either\n\tVSX scalar operations or the traditional floating point form of\n\tthe instruction.\n\t* gcc.target/powerpc/ppc-target-2.c: Likewise.\n\t* gcc.target/powerpc/recip-3.c: Likewise.\n\t* gcc.target/powerpc/recip-5.c: Likewise.\n\t* gcc.target/powerpc/pr72747.c: Likewise.\n\t* gcc.target/powerpc/vsx-builtin-3.c: Likewise.\n\nFrom-SVN: r203162", "tree": {"sha": "f2fb594bbcef47e806e79bd9aa1727c3528eaca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2fb594bbcef47e806e79bd9aa1727c3528eaca8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0609bdf2114919b570e7a3c4ab273fdf16262a4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0609bdf2114919b570e7a3c4ab273fdf16262a4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0609bdf2114919b570e7a3c4ab273fdf16262a4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0609bdf2114919b570e7a3c4ab273fdf16262a4b/comments", "author": null, "committer": null, "parents": [{"sha": "5bea0c6c8c3deb0b52aec49434484b35e75293f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bea0c6c8c3deb0b52aec49434484b35e75293f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bea0c6c8c3deb0b52aec49434484b35e75293f2"}], "stats": {"total": 1266, "additions": 603, "deletions": 663}, "files": [{"sha": "5d2b685a9b7dde5fddb77f812fd584ae8b19240e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0609bdf2114919b570e7a3c4ab273fdf16262a4b", "patch": "@@ -1,3 +1,136 @@\n+2013-10-03  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000-builtin.def (XSRDPIM): Use floatdf2,\n+\tceildf2, btruncdf2, instead of vsx_* name.\n+\n+\t* config/rs6000/vsx.md (vsx_add<mode>3): Change arithmetic\n+\titerators to only do V2DF and V4SF here.  Move the DF code to\n+\trs6000.md where it is combined with SF mode.  Replace <VSv> with\n+\tjust 'v' since only vector operations are handled with these insns\n+\tafter moving the DF support to rs6000.md.\n+\t(vsx_sub<mode>3): Likewise.\n+\t(vsx_mul<mode>3): Likewise.\n+\t(vsx_div<mode>3): Likewise.\n+\t(vsx_fre<mode>2): Likewise.\n+\t(vsx_neg<mode>2): Likewise.\n+\t(vsx_abs<mode>2): Likewise.\n+\t(vsx_nabs<mode>2): Likewise.\n+\t(vsx_smax<mode>3): Likewise.\n+\t(vsx_smin<mode>3): Likewise.\n+\t(vsx_sqrt<mode>2): Likewise.\n+\t(vsx_rsqrte<mode>2): Likewise.\n+\t(vsx_fms<mode>4): Likewise.\n+\t(vsx_nfma<mode>4): Likewise.\n+\t(vsx_copysign<mode>3): Likewise.\n+\t(vsx_btrunc<mode>2): Likewise.\n+\t(vsx_floor<mode>2): Likewise.\n+\t(vsx_ceil<mode>2): Likewise.\n+\t(vsx_smaxsf3): Delete scalar ops that were moved to rs6000.md.\n+\t(vsx_sminsf3): Likewise.\n+\t(vsx_fmadf4): Likewise.\n+\t(vsx_fmsdf4): Likewise.\n+\t(vsx_nfmadf4): Likewise.\n+\t(vsx_nfmsdf4): Likewise.\n+\t(vsx_cmpdf_internal1): Likewise.\n+\n+\t* config/rs6000/rs6000.h (TARGET_SF_SPE): Define macros to make it\n+\tsimpler to select whether a target has SPE or traditional floating\n+\tpoint support in iterators.\n+\t(TARGET_DF_SPE): Likewise.\n+\t(TARGET_SF_FPR): Likewise.\n+\t(TARGET_DF_FPR): Likewise.\n+\t(TARGET_SF_INSN): Macros to say whether floating point support\n+\texists for a given operation for expanders.\n+\t(TARGET_DF_INSN): Likewise.\n+\n+\t* config/rs6000/rs6000.c (Ftrad): New mode attributes to allow\n+\tcombining of SF/DF mode operations, using both traditional and VSX\n+\tregisters.\n+\t(Fvsx): Likewise.\n+\t(Ff): Likewise.\n+\t(Fv): Likewise.\n+\t(Fs): Likewise.\n+\t(Ffre): Likewise.\n+\t(FFRE): Likewise.\n+\t(abs<mode>2): Combine SF/DF modes using traditional floating point\n+\tinstructions.  Add support for using the upper DF registers with\n+\tVSX support, and SF registers with power8-vector support.  Update\n+\texpanders for operations supported by both the SPE and traditional\n+\tfloating point units.\n+\t(abs<mode>2_fpr): Likewise.\n+\t(nabs<mode>2): Likewise.\n+\t(nabs<mode>2_fpr): Likewise.\n+\t(neg<mode>2): Likewise.\n+\t(neg<mode>2_fpr): Likewise.\n+\t(add<mode>3): Likewise.\n+\t(add<mode>3_fpr): Likewise.\n+\t(sub<mode>3): Likewise.\n+\t(sub<mode>3_fpr): Likewise.\n+\t(mul<mode>3): Likewise.\n+\t(mul<mode>3_fpr): Likewise.\n+\t(div<mode>3): Likewise.\n+\t(div<mode>3_fpr): Likewise.\n+\t(sqrt<mode>3): Likewise.\n+\t(sqrt<mode>3_fpr): Likewise.\n+\t(fre<Fs>): Likewise.\n+\t(rsqrt<mode>2): Likewise.\n+\t(cmp<mode>_fpr): Likewise.\n+\t(smax<mode>3): Likewise.\n+\t(smin<mode>3): Likewise.\n+\t(smax<mode>3_vsx): Likewise.\n+\t(smin<mode>3_vsx): Likewise.\n+\t(negsf2): Delete SF operations that are merged with DF.\n+\t(abssf2): Likewise.\n+\t(addsf3): Likewise.\n+\t(subsf3): Likewise.\n+\t(mulsf3): Likewise.\n+\t(divsf3): Likewise.\n+\t(fres): Likewise.\n+\t(fmasf4_fpr): Likewise.\n+\t(fmssf4_fpr): Likewise.\n+\t(nfmasf4_fpr): Likewise.\n+\t(nfmssf4_fpr): Likewise.\n+\t(sqrtsf2): Likewise.\n+\t(rsqrtsf_internal1): Likewise.\n+\t(smaxsf3): Likewise.\n+\t(sminsf3): Likewise.\n+\t(cmpsf_internal1): Likewise.\n+\t(copysign<mode>3_fcpsgn): Add VSX/power8-vector support.\n+\t(negdf2): Delete DF operations that are merged with SF.\n+\t(absdf2): Likewise.\n+\t(nabsdf2): Likewise.\n+\t(adddf3): Likewise.\n+\t(subdf3): Likewise.\n+\t(muldf3): Likewise.\n+\t(divdf3): Likewise.\n+\t(fred): Likewise.\n+\t(rsqrtdf_internal1): Likewise.\n+\t(fmadf4_fpr): Likewise.\n+\t(fmsdf4_fpr): Likewise.\n+\t(nfmadf4_fpr): Likewise.\n+\t(nfmsdf4_fpr): Likewise.\n+\t(sqrtdf2): Likewise.\n+\t(smaxdf3): Likewise.\n+\t(smindf3): Likewise.\n+\t(cmpdf_internal1): Likewise.\n+\t(lrint<mode>di2): Use TARGET_<MODE>_FPR macro.\n+\t(btrunc<mode>2): Delete separate expander, and combine with the\n+\tinsn and add VSX instruction support.  Use TARGET_<MODE>_FPR.\n+\t(btrunc<mode>2_fpr): Likewise.\n+\t(ceil<mode>2): Likewise.\n+\t(ceil<mode>2_fpr): Likewise.\n+\t(floor<mode>2): Likewise.\n+\t(floor<mode>2_fpr): Likewise.\n+\t(fma<mode>4_fpr): Combine SF and DF fused multiply/add support.\n+\tAdd support for using the upper registers with VSX and\n+\tpower8-vector.  Move insns to be closer to the define_expands. On\n+\tVSX systems, prefer the traditional form of FMA over the VSX\n+\tversion, since the traditional form allows the target not to\n+\toverlap with the inputs.\n+\t(fms<mode>4_fpr): Likewise.\n+\t(nfma<mode>4_fpr): Likewise.\n+\t(nfms<mode>4_fpr): Likewise.\n+\n 2013-10-03  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n             Richard Earnshaw  <richard.earnshaw@arm.com>\n "}, {"sha": "3dab7321cac9f88b3556cd73a4cf90aaefb9665e", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=0609bdf2114919b570e7a3c4ab273fdf16262a4b", "patch": "@@ -1209,9 +1209,9 @@ BU_VSX_1 (XVRSPIZ,\t      \"xvrspiz\",\tCONST,\tvsx_btruncv4sf2)\n \n BU_VSX_1 (XSRDPI,\t      \"xsrdpi\",\t\tCONST,\tvsx_xsrdpi)\n BU_VSX_1 (XSRDPIC,\t      \"xsrdpic\",\tCONST,\tvsx_xsrdpic)\n-BU_VSX_1 (XSRDPIM,\t      \"xsrdpim\",\tCONST,\tvsx_floordf2)\n-BU_VSX_1 (XSRDPIP,\t      \"xsrdpip\",\tCONST,\tvsx_ceildf2)\n-BU_VSX_1 (XSRDPIZ,\t      \"xsrdpiz\",\tCONST,\tvsx_btruncdf2)\n+BU_VSX_1 (XSRDPIM,\t      \"xsrdpim\",\tCONST,\tfloordf2)\n+BU_VSX_1 (XSRDPIP,\t      \"xsrdpip\",\tCONST,\tceildf2)\n+BU_VSX_1 (XSRDPIZ,\t      \"xsrdpiz\",\tCONST,\tbtruncdf2)\n \n /* VSX predicate functions.  */\n BU_VSX_P (XVCMPEQSP_P,\t      \"xvcmpeqsp_p\",\tCONST,\tvector_eq_v4sf_p)"}, {"sha": "c4d57d863afe320c386bb89401a189bff92812e5", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=0609bdf2114919b570e7a3c4ab273fdf16262a4b", "patch": "@@ -617,6 +617,25 @@ extern int rs6000_vector_align[];\n \t\t\t  || rs6000_cpu == PROCESSOR_PPC8548)\n \n \n+/* Whether SF/DF operations are supported on the E500.  */\n+#define TARGET_SF_SPE\t(TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\t\\\n+\t\t\t && !TARGET_FPRS)\n+\n+#define TARGET_DF_SPE\t(TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\t\\\n+\t\t\t && !TARGET_FPRS && TARGET_E500_DOUBLE)\n+\n+/* Whether SF/DF operations are supported by by the normal floating point unit\n+   (or the vector/scalar unit).  */\n+#define TARGET_SF_FPR\t(TARGET_HARD_FLOAT && TARGET_FPRS\t\t\\\n+\t\t\t && TARGET_SINGLE_FLOAT)\n+\n+#define TARGET_DF_FPR\t(TARGET_HARD_FLOAT && TARGET_FPRS\t\t\\\n+\t\t\t && TARGET_DOUBLE_FLOAT)\n+\n+/* Whether SF/DF operations are supported by any hardware.  */\n+#define TARGET_SF_INSN\t(TARGET_SF_FPR || TARGET_SF_SPE)\n+#define TARGET_DF_INSN\t(TARGET_DF_FPR || TARGET_DF_SPE)\n+\n /* Which machine supports the various reciprocal estimate instructions.  */\n #define TARGET_FRES\t(TARGET_HARD_FLOAT && TARGET_PPC_GFXOPT \\\n \t\t\t && TARGET_FPRS && TARGET_SINGLE_FLOAT)"}, {"sha": "2160066f1198daeea49b1d90e07e954ce785381e", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 343, "deletions": 468, "changes": 811, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=0609bdf2114919b570e7a3c4ab273fdf16262a4b", "patch": "@@ -337,6 +337,25 @@\n ; Iterator for just SF/DF\n (define_mode_iterator SFDF [SF DF])\n \n+; SF/DF suffix for traditional floating instructions\n+(define_mode_attr Ftrad\t\t[(SF \"s\") (DF \"\")])\n+\n+; SF/DF suffix for VSX instructions\n+(define_mode_attr Fvsx\t\t[(SF \"sp\") (DF\t\"dp\")])\n+\n+; SF/DF constraint for arithmetic on traditional floating point registers\n+(define_mode_attr Ff\t\t[(SF \"f\") (DF \"d\")])\n+\n+; SF/DF constraint for arithmetic on VSX registers\n+(define_mode_attr Fv\t\t[(SF \"wy\") (DF \"ws\")])\n+\n+; s/d suffix for things like fp_addsub_s/fp_addsub_d\n+(define_mode_attr Fs\t\t[(SF \"s\")  (DF \"d\")])\n+\n+; FRE/FRES support\n+(define_mode_attr Ffre\t\t[(SF \"fres\") (DF \"fre\")])\n+(define_mode_attr FFRE\t\t[(SF \"FRES\") (DF \"FRE\")])\n+\n ; Conditional returns.\n (define_code_iterator any_return [return simple_return])\n (define_code_attr return_pred [(return \"direct_return ()\")\n@@ -5045,22 +5064,172 @@\n \t\t    (const_int 0)))]\n   \"\")\n \n-;; Floating-point insns, excluding normal data motion.\n-;;\n-;; PowerPC has a full set of single-precision floating point instructions.\n-;;\n-;; For the POWER architecture, we pretend that we have both SFmode and\n-;; DFmode insns, while, in fact, all fp insns are actually done in double.\n-;; The only conversions we will do will be when storing to memory.  In that\n-;; case, we will use the \"frsp\" instruction before storing.\n-;;\n-;; Note that when we store into a single-precision memory location, we need to\n-;; use the frsp insn first.  If the register being stored isn't dead, we\n-;; need a scratch register for the frsp.  But this is difficult when the store\n-;; is done by reload.  It is not incorrect to do the frsp on the register in\n-;; this case, we just lose precision that we would have otherwise gotten but\n-;; is not guaranteed.  Perhaps this should be tightened up at some point.\n+\f\n+;; Floating-point insns, excluding normal data motion.  We combine the SF/DF\n+;; modes here, and also add in conditional vsx/power8-vector support to access\n+;; values in the traditional Altivec registers if the appropriate\n+;; -mupper-regs-{df,sf} option is enabled.\n+\n+(define_expand \"abs<mode>2\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n+\t(abs:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_<MODE>_INSN\"\n+  \"\")\n+\n+(define_insn \"*abs<mode>2_fpr\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n+\t(abs:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n+  \"TARGET_<MODE>_FPR\"\n+  \"@\n+   fabs %0,%1\n+   xsabsdp %x0,%x1\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n+\n+(define_insn \"*nabs<mode>2_fpr\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n+\t(neg:SFDF\n+\t (abs:SFDF\n+\t  (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\"))))]\n+  \"TARGET_<MODE>_FPR\"\n+  \"@\n+   fnabs %0,%1\n+   xsnabsdp %x0,%x1\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n+\n+(define_expand \"neg<mode>2\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n+\t(neg:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_<MODE>_INSN\"\n+  \"\")\n+\n+(define_insn \"*neg<mode>2_fpr\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n+\t(neg:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n+  \"TARGET_<MODE>_FPR\"\n+  \"@\n+   fneg %0,%1\n+   xsnegdp %x0,%x1\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n+\n+(define_expand \"add<mode>3\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n+\t(plus:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")\n+\t\t   (match_operand:SFDF 2 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_<MODE>_INSN\"\n+  \"\")\n+\n+(define_insn \"*add<mode>3_fpr\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n+\t(plus:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"%<Ff>,<Fv>\")\n+\t\t   (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n+  \"TARGET_<MODE>_FPR\"\n+  \"@\n+   fadd<Ftrad> %0,%1,%2\n+   xsadd<Fvsx> %x0,%x1,%x2\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n+\n+(define_expand \"sub<mode>3\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n+\t(minus:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")\n+\t\t    (match_operand:SFDF 2 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_<MODE>_INSN\"\n+  \"\")\n \n+(define_insn \"*sub<mode>3_fpr\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n+\t(minus:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")\n+\t\t    (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n+  \"TARGET_<MODE>_FPR\"\n+  \"@\n+   fsub<Ftrad> %0,%1,%2\n+   xssub<Fvsx> %x0,%x1,%x2\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n+\n+(define_expand \"mul<mode>3\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n+\t(mult:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")\n+\t\t   (match_operand:SFDF 2 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_<MODE>_INSN\"\n+  \"\")\n+\n+(define_insn \"*mul<mode>3_fpr\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n+\t(mult:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"%<Ff>,<Fv>\")\n+\t\t   (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n+  \"TARGET_<MODE>_FPR\"\n+  \"@\n+   fmul<Ftrad> %0,%1,%2\n+   xsmul<Fvsx> %x0,%x1,%x2\"\n+  [(set_attr \"type\" \"dmul\")\n+   (set_attr \"fp_type\" \"fp_mul_<Fs>\")])\n+\n+(define_expand \"div<mode>3\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n+\t(div:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")\n+\t\t  (match_operand:SFDF 2 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_<MODE>_INSN && !TARGET_SIMPLE_FPU\"\n+  \"\")\n+\n+(define_insn \"*div<mode>3_fpr\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n+\t(div:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")\n+\t\t  (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n+  \"TARGET_<MODE>_FPR && !TARGET_SIMPLE_FPU\"\n+  \"@\n+   fdiv<Ftrad> %0,%1,%2\n+   xsdiv<Fvsx> %x0,%x1,%x2\"\n+  [(set_attr \"type\" \"<Fs>div\")\n+   (set_attr \"fp_type\" \"fp_div_<Fs>\")])\n+\n+(define_insn \"sqrt<mode>2\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n+\t(sqrt:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n+  \"TARGET_<MODE>_FPR && !TARGET_SIMPLE_FPU\n+   && (TARGET_PPC_GPOPT || (<MODE>mode == SFmode && TARGET_XILINX_FPU))\"\n+  \"@\n+   fsqrt<Ftrad> %0,%1\n+   xssqrt<Fvsx> %x0,%x1\"\n+  [(set_attr \"type\" \"<Fs>sqrt\")\n+   (set_attr \"fp_type\" \"fp_sqrt_<Fs>\")])\n+\n+;; Floating point reciprocal approximation\n+(define_insn \"fre<Fs>\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n+\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")]\n+\t\t     UNSPEC_FRES))]\n+  \"TARGET_<FFRE>\"\n+  \"@\n+   fre<Ftrad> %0,%1\n+   xsre<Fvsx> %x0,%x1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"*rsqrt<mode>2\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n+\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")]\n+\t\t     UNSPEC_RSQRT))]\n+  \"RS6000_RECIP_HAVE_RSQRTE_P (<MODE>mode)\"\n+  \"@\n+   frsqrte<Ftrad> %0,%1\n+   xsrsqrte<Fvsx> %x0,%x1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+;; Floating point comparisons\n+(define_insn \"*cmp<mode>_fpr\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y,y\")\n+\t(compare:CCFP (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")\n+\t\t      (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n+  \"TARGET_<MODE>_FPR\"\n+  \"@\n+   fcmpu %0,%1,%2\n+   xscmpudp %x0,%x1,%x2\"\n+  [(set_attr \"type\" \"fpcompare\")])\n+\n+;; Floating point conversions\n (define_expand \"extendsfdf2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(float_extend:DF (match_operand:SF 1 \"reg_or_none500mem_operand\" \"\")))]\n@@ -5117,175 +5286,6 @@\n   \"frsp %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_expand \"negsf2\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(neg:SF (match_operand:SF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\"\n-  \"\")\n-\n-(define_insn \"*negsf2\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(neg:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n-  \"fneg %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_expand \"abssf2\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(abs:SF (match_operand:SF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\"\n-  \"\")\n-\n-(define_insn \"*abssf2\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(abs:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n-  \"fabs %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(neg:SF (abs:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\"))))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n-  \"fnabs %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_expand \"addsf3\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(plus:SF (match_operand:SF 1 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(plus:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n-\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n-  \"fadds %0,%1,%2\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_addsub_s\")])\n-\n-(define_expand \"subsf3\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(minus:SF (match_operand:SF 1 \"gpc_reg_operand\" \"\")\n-\t\t  (match_operand:SF 2 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(minus:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t  (match_operand:SF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n-  \"fsubs %0,%1,%2\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_addsub_s\")])\n-\n-(define_expand \"mulsf3\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n-\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n-  \"fmuls %0,%1,%2\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_mul_s\")])\n-\n-(define_expand \"divsf3\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(div:SF (match_operand:SF 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT && !TARGET_SIMPLE_FPU\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(div:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS\n-   && TARGET_SINGLE_FLOAT && !TARGET_SIMPLE_FPU\"\n-  \"fdivs %0,%1,%2\"\n-  [(set_attr \"type\" \"sdiv\")])\n-\n-(define_insn \"fres\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(unspec:SF [(match_operand:SF 1 \"gpc_reg_operand\" \"f\")] UNSPEC_FRES))]\n-  \"TARGET_FRES\"\n-  \"fres %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-; builtin fmaf support\n-(define_insn \"*fmasf4_fpr\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(fma:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"f\")\n-\t\t(match_operand:SF 3 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n-  \"fmadds %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_maddsub_s\")])\n-\n-(define_insn \"*fmssf4_fpr\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(fma:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"f\")\n-\t\t(neg:SF (match_operand:SF 3 \"gpc_reg_operand\" \"f\"))))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n-  \"fmsubs %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_maddsub_s\")])\n-\n-(define_insn \"*nfmasf4_fpr\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(neg:SF (fma:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"f\")\n-\t\t\t(match_operand:SF 3 \"gpc_reg_operand\" \"f\"))))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n-  \"fnmadds %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_maddsub_s\")])\n-\n-(define_insn \"*nfmssf4_fpr\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(neg:SF (fma:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t\t(match_operand:SF 2 \"gpc_reg_operand\" \"f\")\n-\t\t\t(neg:SF (match_operand:SF 3 \"gpc_reg_operand\" \"f\")))))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n-  \"fnmsubs %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_maddsub_s\")])\n-\n-(define_expand \"sqrtsf2\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(sqrt:SF (match_operand:SF 1 \"gpc_reg_operand\" \"\")))]\n-  \"(TARGET_PPC_GPOPT || TARGET_XILINX_FPU)\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n-   && !TARGET_SIMPLE_FPU\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(sqrt:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\")))]\n-  \"(TARGET_PPC_GPOPT || TARGET_XILINX_FPU) && TARGET_HARD_FLOAT\n-   && TARGET_FPRS && TARGET_SINGLE_FLOAT && !TARGET_SIMPLE_FPU\"\n-  \"fsqrts %0,%1\"\n-  [(set_attr \"type\" \"ssqrt\")])\n-\n-(define_insn \"*rsqrtsf_internal1\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(unspec:SF [(match_operand:SF 1 \"gpc_reg_operand\" \"f\")]\n-\t\t   UNSPEC_RSQRT))]\n-  \"TARGET_FRSQRTES\"\n-  \"frsqrtes %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n ;; This expander is here to avoid FLOAT_WORDS_BIGENDIAN tests in\n ;; builtins.c and optabs.c that are not correct for IBM long double\n ;; when little-endian.\n@@ -5353,37 +5353,82 @@\n ;; Use an unspec rather providing an if-then-else in RTL, to prevent the\n ;; compiler from optimizing -0.0\n (define_insn \"copysign<mode>3_fcpsgn\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n-\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")\n-\t\t      (match_operand:SFDF 2 \"gpc_reg_operand\" \"<rreg2>\")]\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n+\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")\n+\t\t      (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv>\")]\n \t\t     UNSPEC_COPYSIGN))]\n-  \"TARGET_CMPB && !VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"fcpsgn %0,%2,%1\"\n+  \"TARGET_<MODE>_FPR && TARGET_CMPB\"\n+  \"@\n+   fcpsgn %0,%2,%1\n+   xscpsgn<VSs> %x0,%x2,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n ;; For MIN, MAX, and conditional move, we use DEFINE_EXPAND's that involve a\n ;; fsel instruction and some auxiliary computations.  Then we just have a\n ;; single DEFINE_INSN for fsel and the define_splits to make them if made by\n ;; combine.\n-(define_expand \"smaxsf3\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(if_then_else:SF (ge (match_operand:SF 1 \"gpc_reg_operand\" \"\")\n-\t\t\t     (match_operand:SF 2 \"gpc_reg_operand\" \"\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))]\n-  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS \n-   && TARGET_SINGLE_FLOAT && !flag_trapping_math\"\n-  \"{ rs6000_emit_minmax (operands[0], SMAX, operands[1], operands[2]); DONE;}\")\n+;; For MIN, MAX on non-VSX machines, and conditional move all of the time, we\n+;; use DEFINE_EXPAND's that involve a fsel instruction and some auxiliary\n+;; computations.  Then we just have a single DEFINE_INSN for fsel and the\n+;; define_splits to make them if made by combine.  On VSX machines we have the\n+;; min/max instructions.\n+;;\n+;; On VSX, we only check for TARGET_VSX instead of checking for a vsx/p8 vector\n+;; to allow either DF/SF to use only traditional registers.\n \n-(define_expand \"sminsf3\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(if_then_else:SF (ge (match_operand:SF 1 \"gpc_reg_operand\" \"\")\n-\t\t\t     (match_operand:SF 2 \"gpc_reg_operand\" \"\"))\n-\t\t\t (match_dup 2)\n-\t\t\t (match_dup 1)))]\n-  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS \n-   && TARGET_SINGLE_FLOAT && !flag_trapping_math\"\n-  \"{ rs6000_emit_minmax (operands[0], SMIN, operands[1], operands[2]); DONE;}\")\n+(define_expand \"smax<mode>3\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n+\t(if_then_else:SFDF (ge (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")\n+\t\t\t       (match_operand:SFDF 2 \"gpc_reg_operand\" \"\"))\n+\t\t\t   (match_dup 1)\n+\t\t\t   (match_dup 2)))]\n+  \"TARGET_<MODE>_FPR && TARGET_PPC_GFXOPT && !flag_trapping_math\"\n+{\n+  rs6000_emit_minmax (operands[0], SMAX, operands[1], operands[2]);\n+  DONE;\n+})\n+\n+(define_insn \"*smax<mode>3_vsx\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n+\t(smax:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"%<Ff>,<Fv>\")\n+\t\t   (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n+  \"TARGET_<MODE>_FPR && TARGET_VSX\"\n+  \"xsmaxdp %x0,%x1,%x2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_expand \"smin<mode>3\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n+\t(if_then_else:SFDF (ge (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")\n+\t\t\t       (match_operand:SFDF 2 \"gpc_reg_operand\" \"\"))\n+\t\t\t   (match_dup 2)\n+\t\t\t   (match_dup 1)))]\n+  \"TARGET_<MODE>_FPR && TARGET_PPC_GFXOPT && !flag_trapping_math\"\n+{\n+  rs6000_emit_minmax (operands[0], SMIN, operands[1], operands[2]);\n+  DONE;\n+})\n+\n+(define_insn \"*smin<mode>3_vsx\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n+\t(smin:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"%<Ff>,<Fv>\")\n+\t\t   (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n+  \"TARGET_<MODE>_FPR && TARGET_VSX\"\n+  \"xsmindp %x0,%x1,%x2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_split\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n+\t(match_operator:SFDF 3 \"min_max_operator\"\n+\t [(match_operand:SFDF 1 \"gpc_reg_operand\" \"\")\n+\t  (match_operand:SFDF 2 \"gpc_reg_operand\" \"\")]))]\n+  \"TARGET_<MODE>_FPR && TARGET_PPC_GFXOPT && !flag_trapping_math\n+   && !TARGET_VSX\"\n+  [(const_int 0)]\n+{\n+  rs6000_emit_minmax (operands[0], GET_CODE (operands[3]), operands[1],\n+\t\t      operands[2]);\n+  DONE;\n+})\n \n (define_split\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n@@ -5515,208 +5560,9 @@\n   \"fsel %0,%1,%2,%3\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_expand \"negdf2\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(neg:DF (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && ((TARGET_FPRS && TARGET_DOUBLE_FLOAT) || TARGET_E500_DOUBLE)\"\n-  \"\")\n-\n-(define_insn \"*negdf2_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(neg:DF (match_operand:DF 1 \"gpc_reg_operand\" \"d\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && !VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"fneg %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_expand \"absdf2\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(abs:DF (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && ((TARGET_FPRS && TARGET_DOUBLE_FLOAT) || TARGET_E500_DOUBLE)\"\n-  \"\")\n-\n-(define_insn \"*absdf2_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(abs:DF (match_operand:DF 1 \"gpc_reg_operand\" \"d\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && !VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"fabs %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"*nabsdf2_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(neg:DF (abs:DF (match_operand:DF 1 \"gpc_reg_operand\" \"d\"))))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && !VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"fnabs %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_expand \"adddf3\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(plus:DF (match_operand:DF 1 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:DF 2 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && ((TARGET_FPRS && TARGET_DOUBLE_FLOAT) || TARGET_E500_DOUBLE)\"\n-  \"\")\n-\n-(define_insn \"*adddf3_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(plus:DF (match_operand:DF 1 \"gpc_reg_operand\" \"%d\")\n-\t\t (match_operand:DF 2 \"gpc_reg_operand\" \"d\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && !VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"fadd %0,%1,%2\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_addsub_d\")])\n-\n-(define_expand \"subdf3\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(minus:DF (match_operand:DF 1 \"gpc_reg_operand\" \"\")\n-\t\t  (match_operand:DF 2 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && ((TARGET_FPRS && TARGET_DOUBLE_FLOAT) || TARGET_E500_DOUBLE)\"\n-  \"\")\n-\n-(define_insn \"*subdf3_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(minus:DF (match_operand:DF 1 \"gpc_reg_operand\" \"d\")\n-\t\t  (match_operand:DF 2 \"gpc_reg_operand\" \"d\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && !VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"fsub %0,%1,%2\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_addsub_d\")])\n-\n-(define_expand \"muldf3\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(mult:DF (match_operand:DF 1 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:DF 2 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && ((TARGET_FPRS && TARGET_DOUBLE_FLOAT) || TARGET_E500_DOUBLE)\"\n-  \"\")\n-\n-(define_insn \"*muldf3_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(mult:DF (match_operand:DF 1 \"gpc_reg_operand\" \"%d\")\n-\t\t (match_operand:DF 2 \"gpc_reg_operand\" \"d\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && !VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"fmul %0,%1,%2\"\n-  [(set_attr \"type\" \"dmul\")\n-   (set_attr \"fp_type\" \"fp_mul_d\")])\n-\n-(define_expand \"divdf3\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(div:DF (match_operand:DF 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT\n-   && ((TARGET_FPRS && TARGET_DOUBLE_FLOAT) || TARGET_E500_DOUBLE)\n-   && !TARGET_SIMPLE_FPU\"\n-  \"\")\n-\n-(define_insn \"*divdf3_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(div:DF (match_operand:DF 1 \"gpc_reg_operand\" \"d\")\n-\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"d\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && !TARGET_SIMPLE_FPU\n-   && !VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"fdiv %0,%1,%2\"\n-  [(set_attr \"type\" \"ddiv\")])\n-\n-(define_insn \"*fred_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n-\t(unspec:DF [(match_operand:DF 1 \"gpc_reg_operand\" \"f\")] UNSPEC_FRES))]\n-  \"TARGET_FRE && !VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"fre %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"*rsqrtdf_internal1\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(unspec:DF [(match_operand:DF 1 \"gpc_reg_operand\" \"d\")]\n-\t\t   UNSPEC_RSQRT))]\n-  \"TARGET_FRSQRTE && !VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"frsqrte %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-; builtin fma support\n-(define_insn \"*fmadf4_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n-\t(fma:DF (match_operand:DF 1 \"gpc_reg_operand\" \"f\")\n-\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"f\")\n-\t\t(match_operand:DF 3 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && VECTOR_UNIT_NONE_P (DFmode)\"\n-  \"fmadd %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_maddsub_d\")])\n-\n-(define_insn \"*fmsdf4_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n-\t(fma:DF (match_operand:DF 1 \"gpc_reg_operand\" \"f\")\n-\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"f\")\n-\t\t(neg:DF (match_operand:DF 3 \"gpc_reg_operand\" \"f\"))))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && VECTOR_UNIT_NONE_P (DFmode)\"\n-  \"fmsub %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_maddsub_d\")])\n-\n-(define_insn \"*nfmadf4_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n-\t(neg:DF (fma:DF (match_operand:DF 1 \"gpc_reg_operand\" \"f\")\n-\t\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"f\")\n-\t\t\t(match_operand:DF 3 \"gpc_reg_operand\" \"f\"))))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && VECTOR_UNIT_NONE_P (DFmode)\"\n-  \"fnmadd %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_maddsub_d\")])\n-\n-(define_insn \"*nfmsdf4_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n-\t(neg:DF (fma:DF (match_operand:DF 1 \"gpc_reg_operand\" \"f\")\n-\t\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"f\")\n-\t\t\t(neg:DF (match_operand:DF 3 \"gpc_reg_operand\" \"f\")))))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && VECTOR_UNIT_NONE_P (DFmode)\"\n-  \"fnmsub %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_maddsub_d\")])\n-\n-(define_expand \"sqrtdf2\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(sqrt:DF (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_PPC_GPOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n-  \"\")\n-\n-(define_insn \"*sqrtdf2_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(sqrt:DF (match_operand:DF 1 \"gpc_reg_operand\" \"d\")))]\n-  \"TARGET_PPC_GPOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && !VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"fsqrt %0,%1\"\n-  [(set_attr \"type\" \"dsqrt\")])\n-\n ;; The conditional move instructions allow us to perform max and min\n ;; operations even when\n \n-(define_expand \"smaxdf3\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(if_then_else:DF (ge (match_operand:DF 1 \"gpc_reg_operand\" \"\")\n-\t\t\t     (match_operand:DF 2 \"gpc_reg_operand\" \"\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))]\n-  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT \n-   && !flag_trapping_math\"\n-  \"{ rs6000_emit_minmax (operands[0], SMAX, operands[1], operands[2]); DONE;}\")\n-\n-(define_expand \"smindf3\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(if_then_else:DF (ge (match_operand:DF 1 \"gpc_reg_operand\" \"\")\n-\t\t\t     (match_operand:DF 2 \"gpc_reg_operand\" \"\"))\n-\t\t\t (match_dup 2)\n-\t\t\t (match_dup 1)))]\n-  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT \n-   && !flag_trapping_math\"\n-  \"{ rs6000_emit_minmax (operands[0], SMIN, operands[1], operands[2]); DONE;}\")\n-\n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(match_operator:DF 3 \"min_max_operator\"\n@@ -6400,66 +6246,52 @@\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d\")\n \t(unspec:DI [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")]\n \t\t   UNSPEC_FCTID))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\"\n+  \"TARGET_<MODE>_FPR && TARGET_FPRND\"\n   \"fctid %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_expand \"btrunc<mode>2\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n-\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"\")]\n-\t\t     UNSPEC_FRIZ))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\"\n-  \"\")\n-\n-(define_insn \"*btrunc<mode>2_fpr\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n-\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")]\n+(define_insn \"btrunc<mode>2\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n+\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")]\n \t\t     UNSPEC_FRIZ))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\n-   && !VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"friz %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n+  \"TARGET_<MODE>_FPR && TARGET_FPRND\"\n+  \"@\n+   friz %0,%1\n+   xsrdpiz %x0,%x1\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n \n-(define_expand \"ceil<mode>2\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n-\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"\")]\n+(define_insn \"ceil<mode>2\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n+\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")]\n \t\t     UNSPEC_FRIP))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\"\n-  \"\")\n-\n-(define_insn \"*ceil<mode>2_fpr\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n-\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")]\n-\t\t     UNSPEC_FRIP))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\n-   && !VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"frip %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_expand \"floor<mode>2\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n-\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"\")]\n-\t\t     UNSPEC_FRIM))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\"\n-  \"\")\n+  \"TARGET_<MODE>_FPR && TARGET_FPRND\"\n+  \"@\n+   frip %0,%1\n+   xsrdpip %x0,%x1\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n \n-(define_insn \"*floor<mode>2_fpr\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n-\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")]\n+(define_insn \"floor<mode>2\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n+\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")]\n \t\t     UNSPEC_FRIM))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\n-   && !VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"frim %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n+  \"TARGET_<MODE>_FPR && TARGET_FPRND\"\n+  \"@\n+   frim %0,%1\n+   xsrdpim %x0,%x1\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n \n ;; No VSX equivalent to frin\n (define_insn \"round<mode>2\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n \t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")]\n \t\t     UNSPEC_FRIN))]\n-  \"TARGET_FPRND && TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\"\n+  \"TARGET_<MODE>_FPR && TARGET_FPRND\"\n   \"frin %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n \n ; An UNSPEC is used so we don't have to support SImode in FP registers.\n (define_insn \"stfiwx\"\n@@ -13331,23 +13163,6 @@\n   [(set (match_dup 3) (compare:CCUNS (match_dup 1) (match_dup 2)))\n    (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 4)))])\n \n-(define_insn \"*cmpsf_internal1\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(compare:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t      (match_operand:SF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n-  \"fcmpu %0,%1,%2\"\n-  [(set_attr \"type\" \"fpcompare\")])\n-\n-(define_insn \"*cmpdf_internal1\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(compare:CCFP (match_operand:DF 1 \"gpc_reg_operand\" \"d\")\n-\t\t      (match_operand:DF 2 \"gpc_reg_operand\" \"d\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && !VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"fcmpu %0,%1,%2\"\n-  [(set_attr \"type\" \"fpcompare\")])\n-\n ;; Only need to compare second words if first words equal\n (define_insn \"*cmptf_internal1\"\n   [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n@@ -15642,6 +15457,20 @@\n   \"\"\n   \"\")\n \n+(define_insn \"*fma<mode>4_fpr\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>,<Fv>\")\n+\t(fma:SFDF\n+\t  (match_operand:SFDF 1 \"gpc_reg_operand\" \"%<Ff>,<Fv>,<Fv>\")\n+\t  (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv>,0\")\n+\t  (match_operand:SFDF 3 \"gpc_reg_operand\" \"<Ff>,0,<Fv>\")))]\n+  \"TARGET_<MODE>_FPR\"\n+  \"@\n+   fmadd<Ftrad> %0,%1,%2,%3\n+   xsmadda<Fvsx> %x0,%x1,%x2\n+   xsmaddm<Fvsx> %x0,%x1,%x3\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_maddsub_<Fs>\")])\n+\n ; Altivec only has fma and nfms.\n (define_expand \"fms<mode>4\"\n   [(set (match_operand:FMA_F 0 \"register_operand\" \"\")\n@@ -15652,6 +15481,20 @@\n   \"!VECTOR_UNIT_ALTIVEC_P (<MODE>mode)\"\n   \"\")\n \n+(define_insn \"*fms<mode>4_fpr\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>,<Fv>\")\n+\t(fma:SFDF\n+\t (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>,<Fv>\")\n+\t (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv>,0\")\n+\t (neg:SFDF (match_operand:SFDF 3 \"gpc_reg_operand\" \"<Ff>,0,<Fv>\"))))]\n+  \"TARGET_<MODE>_FPR\"\n+  \"@\n+   fmsub<Ftrad> %0,%1,%2,%3\n+   xsmsuba<Fvsx> %x0,%x1,%x2\n+   xsmsubm<Fvsx> %x0,%x1,%x3\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_maddsub_<Fs>\")])\n+\n ;; If signed zeros are ignored, -(a * b - c) = -a * b + c.\n (define_expand \"fnma<mode>4\"\n   [(set (match_operand:FMA_F 0 \"register_operand\" \"\")\n@@ -15685,6 +15528,21 @@\n   \"!VECTOR_UNIT_ALTIVEC_P (<MODE>mode)\"\n   \"\")\n \n+(define_insn \"*nfma<mode>4_fpr\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>,<Fv>\")\n+\t(neg:SFDF\n+\t (fma:SFDF\n+\t  (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>,<Fv>\")\n+\t  (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv>,0\")\n+\t  (match_operand:SFDF 3 \"gpc_reg_operand\" \"<Ff>,0,<Fv>\"))))]\n+  \"TARGET_<MODE>_FPR\"\n+  \"@\n+   fnmadd<Ftrad> %0,%1,%2,%3\n+   xsnmadda<Fvsx> %x0,%x1,%x2\n+   xsnmaddm<Fvsx> %x0,%x1,%x3\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_maddsub_<Fs>\")])\n+\n ; Not an official optab name, but used from builtins.\n (define_expand \"nfms<mode>4\"\n   [(set (match_operand:FMA_F 0 \"register_operand\" \"\")\n@@ -15696,6 +15554,23 @@\n   \"\"\n   \"\")\n \n+(define_insn \"*nfmssf4_fpr\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>,<Fv>\")\n+\t(neg:SFDF\n+\t (fma:SFDF\n+\t  (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>,<Fv>\")\n+\t  (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv>,0\")\n+\t  (neg:SFDF\n+\t   (match_operand:SFDF 3 \"gpc_reg_operand\" \"<Ff>,0,<Fv>\")))))]\n+  \"TARGET_<MODE>_FPR\"\n+  \"@\n+   fnmsub<Ftrad> %0,%1,%2,%3\n+   xsnmsuba<Fvsx> %x0,%x1,%x2\n+   xsnmsubm<Fvsx> %x0,%x1,%x3\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_maddsub_<Fs>\")])\n+\n+\f\n (define_expand \"rs6000_get_timebase\"\n   [(use (match_operand:DI 0 \"gpc_reg_operand\" \"\"))]\n   \"\""}, {"sha": "988842f9fe85166ec24f456222717ef8f9002364", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 74, "deletions": 172, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=0609bdf2114919b570e7a3c4ab273fdf16262a4b", "patch": "@@ -316,40 +316,42 @@\n   \"\")\n \n \f\n-;; VSX scalar and vector floating point arithmetic instructions\n+;; VSX vector floating point arithmetic instructions.  The VSX scalar\n+;; instructions are now combined with the insn for the traditional floating\n+;; point unit.\n (define_insn \"*vsx_add<mode>3\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (plus:VSX_B (match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t    (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+        (plus:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")\n+\t\t    (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>add<VSs> %x0,%x1,%x2\"\n+  \"xvadd<VSs> %x0,%x1,%x2\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"*vsx_sub<mode>3\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (minus:VSX_B (match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t     (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+        (minus:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")\n+\t\t     (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>sub<VSs> %x0,%x1,%x2\"\n+  \"xvsub<VSs> %x0,%x1,%x2\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"*vsx_mul<mode>3\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (mult:VSX_B (match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t    (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+        (mult:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")\n+\t\t    (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>mul<VSs> %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"<VStype_mul>\")\n+  \"xvmul<VSs> %x0,%x1,%x2\"\n+  [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_mul>\")])\n \n (define_insn \"*vsx_div<mode>3\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (div:VSX_B (match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t   (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+        (div:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")\n+\t\t   (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>div<VSs> %x0,%x1,%x2\"\n+  \"xvdiv<VSs> %x0,%x1,%x2\"\n   [(set_attr \"type\" \"<VStype_div>\")\n    (set_attr \"fp_type\" \"<VSfptype_div>\")])\n \n@@ -392,94 +394,72 @@\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_fre<mode>2\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(unspec:VSX_B [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+\t(unspec:VSX_F [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")]\n \t\t      UNSPEC_FRES))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>re<VSs> %x0,%x1\"\n+  \"xvre<VSs> %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"*vsx_neg<mode>2\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (neg:VSX_B (match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+        (neg:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>neg<VSs> %x0,%x1\"\n+  \"xvneg<VSs> %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"*vsx_abs<mode>2\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (abs:VSX_B (match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+        (abs:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>abs<VSs> %x0,%x1\"\n+  \"xvabs<VSs> %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_nabs<mode>2\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (neg:VSX_B\n-\t (abs:VSX_B\n-\t  (match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\"))))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+        (neg:VSX_F\n+\t (abs:VSX_F\n+\t  (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\"))))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>nabs<VSs> %x0,%x1\"\n+  \"xvnabs<VSs> %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_smax<mode>3\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (smax:VSX_B (match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t    (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+        (smax:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")\n+\t\t    (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>max<VSs> %x0,%x1,%x2\"\n+  \"xvmax<VSs> %x0,%x1,%x2\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"*vsx_smin<mode>3\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (smin:VSX_B (match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t    (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+        (smin:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")\n+\t\t    (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>min<VSs> %x0,%x1,%x2\"\n+  \"xvmin<VSs> %x0,%x1,%x2\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n-;; Special VSX version of smin/smax for single precision floating point.  Since\n-;; both numbers are rounded to single precision, we can just use the DP version\n-;; of the instruction.\n-\n-(define_insn \"*vsx_smaxsf3\"\n-  [(set (match_operand:SF 0 \"vsx_register_operand\" \"=f\")\n-        (smax:SF (match_operand:SF 1 \"vsx_register_operand\" \"f\")\n-\t\t (match_operand:SF 2 \"vsx_register_operand\" \"f\")))]\n-  \"VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"xsmaxdp %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_addsub_d\")])\n-\n-(define_insn \"*vsx_sminsf3\"\n-  [(set (match_operand:SF 0 \"vsx_register_operand\" \"=f\")\n-        (smin:SF (match_operand:SF 1 \"vsx_register_operand\" \"f\")\n-\t\t (match_operand:SF 2 \"vsx_register_operand\" \"f\")))]\n-  \"VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"xsmindp %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_addsub_d\")])\n-\n (define_insn \"*vsx_sqrt<mode>2\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (sqrt:VSX_B (match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+        (sqrt:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>sqrt<VSs> %x0,%x1\"\n+  \"xvsqrt<VSs> %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_sqrt>\")\n    (set_attr \"fp_type\" \"<VSfptype_sqrt>\")])\n \n (define_insn \"*vsx_rsqrte<mode>2\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(unspec:VSX_B [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+\t(unspec:VSX_F [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")]\n \t\t      UNSPEC_RSQRT))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>rsqrte<VSs> %x0,%x1\"\n+  \"xvrsqrte<VSs> %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n@@ -518,26 +498,10 @@\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n-;; Fused vector multiply/add instructions Support the classical DF versions of\n-;; fma, which allows the target to be a separate register from the 3 inputs.\n-;; Under VSX, the target must be either the addend or the first multiply.\n-;; Where we can, also do the same for the Altivec V4SF fmas.\n-\n-(define_insn \"*vsx_fmadf4\"\n-  [(set (match_operand:DF 0 \"vsx_register_operand\" \"=ws,ws,?wa,?wa,d\")\n-\t(fma:DF\n-\t  (match_operand:DF 1 \"vsx_register_operand\" \"%ws,ws,wa,wa,d\")\n-\t  (match_operand:DF 2 \"vsx_register_operand\" \"ws,0,wa,0,d\")\n-\t  (match_operand:DF 3 \"vsx_register_operand\" \"0,ws,0,wa,d\")))]\n-  \"VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"@\n-   xsmaddadp %x0,%x1,%x2\n-   xsmaddmdp %x0,%x1,%x3\n-   xsmaddadp %x0,%x1,%x2\n-   xsmaddmdp %x0,%x1,%x3\n-   fmadd %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_maddsub_d\")])\n+;; Fused vector multiply/add instructions. Support the classical Altivec\n+;; versions of fma, which allows the target to be a separate register from the\n+;; 3 inputs.  Under VSX, the target must be either the addend or the first\n+;; multiply.\n \n (define_insn \"*vsx_fmav4sf4\"\n   [(set (match_operand:V4SF 0 \"vsx_register_operand\" \"=ws,ws,?wa,?wa,v\")\n@@ -568,23 +532,6 @@\n    xvmaddmdp %x0,%x1,%x3\"\n   [(set_attr \"type\" \"vecdouble\")])\n \n-(define_insn \"*vsx_fmsdf4\"\n-  [(set (match_operand:DF 0 \"vsx_register_operand\" \"=ws,ws,?wa,?wa,d\")\n-\t(fma:DF\n-\t  (match_operand:DF 1 \"vsx_register_operand\" \"%ws,ws,wa,wa,d\")\n-\t  (match_operand:DF 2 \"vsx_register_operand\" \"ws,0,wa,0,d\")\n-\t  (neg:DF\n-\t    (match_operand:DF 3 \"vsx_register_operand\" \"0,ws,0,wa,d\"))))]\n-  \"VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"@\n-   xsmsubadp %x0,%x1,%x2\n-   xsmsubmdp %x0,%x1,%x3\n-   xsmsubadp %x0,%x1,%x2\n-   xsmsubmdp %x0,%x1,%x3\n-   fmsub %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_maddsub_d\")])\n-\n (define_insn \"*vsx_fms<mode>4\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,<VSr>,?wa,?wa\")\n \t(fma:VSX_F\n@@ -594,29 +541,12 @@\n \t    (match_operand:VSX_F 3 \"vsx_register_operand\" \"0,<VSr>,0,wa\"))))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"@\n-   x<VSv>msuba<VSs> %x0,%x1,%x2\n-   x<VSv>msubm<VSs> %x0,%x1,%x3\n-   x<VSv>msuba<VSs> %x0,%x1,%x2\n-   x<VSv>msubm<VSs> %x0,%x1,%x3\"\n+   xvmsuba<VSs> %x0,%x1,%x2\n+   xvmsubm<VSs> %x0,%x1,%x3\n+   xvmsuba<VSs> %x0,%x1,%x2\n+   xvmsubm<VSs> %x0,%x1,%x3\"\n   [(set_attr \"type\" \"<VStype_mul>\")])\n \n-(define_insn \"*vsx_nfmadf4\"\n-  [(set (match_operand:DF 0 \"vsx_register_operand\" \"=ws,ws,?wa,?wa,d\")\n-\t(neg:DF\n-\t (fma:DF\n-\t  (match_operand:DF 1 \"vsx_register_operand\" \"ws,ws,wa,wa,d\")\n-\t  (match_operand:DF 2 \"vsx_register_operand\" \"ws,0,wa,0,d\")\n-\t  (match_operand:DF 3 \"vsx_register_operand\" \"0,ws,0,wa,d\"))))]\n-  \"VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"@\n-   xsnmaddadp %x0,%x1,%x2\n-   xsnmaddmdp %x0,%x1,%x3\n-   xsnmaddadp %x0,%x1,%x2\n-   xsnmaddmdp %x0,%x1,%x3\n-   fnmadd %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_maddsub_d\")])\n-\n (define_insn \"*vsx_nfma<mode>4\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,<VSr>,?wa,?wa\")\n \t(neg:VSX_F\n@@ -626,31 +556,13 @@\n \t  (match_operand:VSX_F 3 \"vsx_register_operand\" \"0,<VSr>,0,wa\"))))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"@\n-   x<VSv>nmadda<VSs> %x0,%x1,%x2\n-   x<VSv>nmaddm<VSs> %x0,%x1,%x3\n-   x<VSv>nmadda<VSs> %x0,%x1,%x2\n-   x<VSv>nmaddm<VSs> %x0,%x1,%x3\"\n+   xvnmadda<VSs> %x0,%x1,%x2\n+   xvnmaddm<VSs> %x0,%x1,%x3\n+   xvnmadda<VSs> %x0,%x1,%x2\n+   xvnmaddm<VSs> %x0,%x1,%x3\"\n   [(set_attr \"type\" \"<VStype_mul>\")\n    (set_attr \"fp_type\" \"<VSfptype_mul>\")])\n \n-(define_insn \"*vsx_nfmsdf4\"\n-  [(set (match_operand:DF 0 \"vsx_register_operand\" \"=ws,ws,?wa,?wa,d\")\n-\t(neg:DF\n-\t (fma:DF\n-\t   (match_operand:DF 1 \"vsx_register_operand\" \"%ws,ws,wa,wa,d\")\n-\t   (match_operand:DF 2 \"vsx_register_operand\" \"ws,0,wa,0,d\")\n-\t   (neg:DF\n-\t     (match_operand:DF 3 \"vsx_register_operand\" \"0,ws,0,wa,d\")))))]\n-  \"VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"@\n-   xsnmsubadp %x0,%x1,%x2\n-   xsnmsubmdp %x0,%x1,%x3\n-   xsnmsubadp %x0,%x1,%x2\n-   xsnmsubmdp %x0,%x1,%x3\n-   fnmsub %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_maddsub_d\")])\n-\n (define_insn \"*vsx_nfmsv4sf4\"\n   [(set (match_operand:V4SF 0 \"vsx_register_operand\" \"=wf,wf,?wa,?wa,v\")\n \t(neg:V4SF\n@@ -712,16 +624,6 @@\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n-;; Floating point scalar compare\n-(define_insn \"*vsx_cmpdf_internal1\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y,?y\")\n-\t(compare:CCFP (match_operand:DF 1 \"gpc_reg_operand\" \"ws,wa\")\n-\t\t      (match_operand:DF 2 \"gpc_reg_operand\" \"ws,wa\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"xscmpudp %0,%x1,%x2\"\n-  [(set_attr \"type\" \"fpcompare\")])\n-\n ;; Compare vectors producing a vector result and a predicate, setting CR6 to\n ;; indicate a combined status\n (define_insn \"*vsx_eq_<mode>_p\"\n@@ -788,13 +690,13 @@\n \n ;; Copy sign\n (define_insn \"vsx_copysign<mode>3\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(unspec:VSX_B\n-\t [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t  (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,wa\")]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+\t(unspec:VSX_F\n+\t [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")\n+\t  (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,wa\")]\n \t UNSPEC_COPYSIGN))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>cpsgn<VSs> %x0,%x2,%x1\"\n+  \"xvcpsgn<VSs> %x0,%x2,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n@@ -855,10 +757,10 @@\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_btrunc<mode>2\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(fix:VSX_B (match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+\t(fix:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>r<VSs>iz %x0,%x1\"\n+  \"xvr<VSs>iz %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n@@ -872,20 +774,20 @@\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_floor<mode>2\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(unspec:VSX_B [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+\t(unspec:VSX_F [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")]\n \t\t      UNSPEC_FRIM))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>r<VSs>im %x0,%x1\"\n+  \"xvr<VSs>im %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_ceil<mode>2\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(unspec:VSX_B [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+\t(unspec:VSX_F [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")]\n \t\t      UNSPEC_FRIP))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>r<VSs>ip %x0,%x1\"\n+  \"xvr<VSs>ip %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n "}, {"sha": "6e84ea52cb27ec0a3b0f065ef7530cf37c0e9d4f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0609bdf2114919b570e7a3c4ab273fdf16262a4b", "patch": "@@ -1,3 +1,16 @@\n+2013-10-03  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/p8vector-fp.c: New test for floating point\n+\tscalar operations when using -mupper-regs-sf and -mupper-regs-df.\n+\t* gcc.target/powerpc/ppc-target-1.c: Update tests to allow either\n+\tVSX scalar operations or the traditional floating point form of\n+\tthe instruction.\n+\t* gcc.target/powerpc/ppc-target-2.c: Likewise.\n+\t* gcc.target/powerpc/recip-3.c: Likewise.\n+\t* gcc.target/powerpc/recip-5.c: Likewise.\n+\t* gcc.target/powerpc/pr72747.c: Likewise.\n+\t* gcc.target/powerpc/vsx-builtin-3.c: Likewise.\n+\n 2013-10-03  Marcus Shawcroft  <marcus.shawcroft@arm.com>\n \n \tPR target/58460"}, {"sha": "b39fe4115bcf3e4befdbdef453a4210d6a7d9f39", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-target-1.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-target-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-target-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-target-1.c?ref=0609bdf2114919b570e7a3c4ab273fdf16262a4b", "patch": "@@ -5,8 +5,7 @@\n /* { dg-final { scan-assembler-times \"fabs\" 3 } } */\n /* { dg-final { scan-assembler-times \"fnabs\" 3 } } */\n /* { dg-final { scan-assembler-times \"fsel\" 3 } } */\n-/* { dg-final { scan-assembler-times \"fcpsgn\" 3 } } */\n-/* { dg-final { scan-assembler-times \"xscpsgndp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fcpsgn\\|xscpsgndp\" 4 } } */\n \n double normal1 (double, double);\n double power5  (double, double) __attribute__((__target__(\"cpu=power5\")));"}, {"sha": "e8a2de3636a141c9d96a1730f34bb61a5775d4b2", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-target-2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-target-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-target-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-target-2.c?ref=0609bdf2114919b570e7a3c4ab273fdf16262a4b", "patch": "@@ -5,8 +5,7 @@\n /* { dg-final { scan-assembler-times \"fabs\" 3 } } */\n /* { dg-final { scan-assembler-times \"fnabs\" 3 } } */\n /* { dg-final { scan-assembler-times \"fsel\" 3 } } */\n-/* { dg-final { scan-assembler-times \"fcpsgn\" 3 } } */\n-/* { dg-final { scan-assembler-times \"xscpsgndp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fcpsgn\\|xscpsgndp\" 4 } } */\n \n /* fabs/fnabs/fsel */\n double normal1 (double a, double b) { return __builtin_copysign (a, b); }"}, {"sha": "41362db17746d2af3a5c1dd5e2dd6c895adf359a", "filename": "gcc/testsuite/gcc.target/powerpc/pr42747.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr42747.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr42747.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr42747.c?ref=0609bdf2114919b570e7a3c4ab273fdf16262a4b", "patch": "@@ -5,4 +5,4 @@\n \n double foo (double x) { return __builtin_sqrt (x); }\n \n-/* { dg-final { scan-assembler \"xssqrtdp\" } } */\n+/* { dg-final { scan-assembler \"xssqrtdp\\|fsqrt\" } } */"}, {"sha": "1f8e30572b248bdc784aa5d88494856af9734307", "filename": "gcc/testsuite/gcc.target/powerpc/recip-3.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-3.c?ref=0609bdf2114919b570e7a3c4ab273fdf16262a4b", "patch": "@@ -1,14 +1,14 @@\n /* { dg-do compile { target { { powerpc*-*-* } && { ! powerpc*-apple-darwin* } } } } */\n /* { dg-require-effective-target powerpc_fprs } */\n /* { dg-options \"-O2 -mrecip -ffast-math -mcpu=power7\" } */\n-/* { dg-final { scan-assembler-times \"xsrsqrtedp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xsrsqrtedp\\|frsqrte\\ \" 1 } } */\n /* { dg-final { scan-assembler-times \"xsmsub.dp\\|fmsub\\ \" 1 } } */\n-/* { dg-final { scan-assembler-times \"xsmuldp\" 4 } } */\n+/* { dg-final { scan-assembler-times \"xsmuldp\\|fmul\\ \" 4 } } */\n /* { dg-final { scan-assembler-times \"xsnmsub.dp\\|fnmsub\\ \" 2 } } */\n-/* { dg-final { scan-assembler-times \"frsqrtes\" 1 } } */\n-/* { dg-final { scan-assembler-times \"fmsubs\" 1 } } */\n-/* { dg-final { scan-assembler-times \"fmuls\" 2 } } */\n-/* { dg-final { scan-assembler-times \"fnmsubs\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xsrsqrtesp\\|frsqrtes\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xsmsub.sp\\|fmsubs\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xsmulsp\\|fmuls\" 2 } } */\n+/* { dg-final { scan-assembler-times \"xsnmsub.sp\\|fnmsubs\" 1 } } */\n \n double\n rsqrt_d (double a)"}, {"sha": "11d125c110e8d7f48e444b955eff88d9993fc64f", "filename": "gcc/testsuite/gcc.target/powerpc/recip-5.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-5.c?ref=0609bdf2114919b570e7a3c4ab273fdf16262a4b", "patch": "@@ -4,12 +4,12 @@\n /* { dg-options \"-O3 -ftree-vectorize -mrecip=all -ffast-math -mcpu=power7 -fno-unroll-loops\" } */\n /* { dg-final { scan-assembler-times \"xvredp\" 4 } } */\n /* { dg-final { scan-assembler-times \"xvresp\" 5 } } */\n-/* { dg-final { scan-assembler-times \"xsredp\" 2 } } */\n-/* { dg-final { scan-assembler-times \"fres\" 2 } } */\n-/* { dg-final { scan-assembler-times \"fmuls\" 2 } } */\n-/* { dg-final { scan-assembler-times \"fnmsubs\" 2 } } */\n-/* { dg-final { scan-assembler-times \"xsmuldp\" 2 } } */\n-/* { dg-final { scan-assembler-times \"xsnmsub.dp\" 4 } } */\n+/* { dg-final { scan-assembler-times \"xsredp\\|fre\\ \" 2 } } */\n+/* { dg-final { scan-assembler-times \"fres\\|xsresp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"fmuls\\|xsmulsp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"fnmsubs\\|xsnmsub.sp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"xsmuldp\\|fmul\\ \" 2 } } */\n+/* { dg-final { scan-assembler-times \"xsnmsub.dp\\|fnmsub\\ \" 4 } } */\n /* { dg-final { scan-assembler-times \"xvmulsp\" 7 } } */\n /* { dg-final { scan-assembler-times \"xvnmsub.sp\" 5 } } */\n /* { dg-final { scan-assembler-times \"xvmuldp\" 6 } } */"}, {"sha": "7aeba6cb563ad33174228129b6ff3ebe889ad487", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0609bdf2114919b570e7a3c4ab273fdf16262a4b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-3.c?ref=0609bdf2114919b570e7a3c4ab273fdf16262a4b", "patch": "@@ -16,9 +16,9 @@\n /* { dg-final { scan-assembler \"xvrspiz\" } } */\n /* { dg-final { scan-assembler \"xsrdpi\" } } */\n /* { dg-final { scan-assembler \"xsrdpic\" } } */\n-/* { dg-final { scan-assembler \"xsrdpim\" } } */\n-/* { dg-final { scan-assembler \"xsrdpip\" } } */\n-/* { dg-final { scan-assembler \"xsrdpiz\" } } */\n+/* { dg-final { scan-assembler \"xsrdpim\\|frim\" } } */\n+/* { dg-final { scan-assembler \"xsrdpip\\|frip\" } } */\n+/* { dg-final { scan-assembler \"xsrdpiz\\|friz\" } } */\n /* { dg-final { scan-assembler \"xsmaxdp\" } } */\n /* { dg-final { scan-assembler \"xsmindp\" } } */\n /* { dg-final { scan-assembler \"xxland\" } } */"}]}