{"sha": "b66a64f16c38d7b3bb8d55c289af5e68250a3768", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY2YTY0ZjE2YzM4ZDdiM2JiOGQ1NWMyODlhZjVlNjgyNTBhMzc2OA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-10-28T10:08:03Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-10-28T10:08:03Z"}, "message": "tree.c (int_cst_node, [...]): New variables.\n\n\t* tree.c (int_cst_node, int_cst_hash_table): New variables.\n\t(init_ttree): Initialize them.\n\t(int_cst_hash_hash, int_cst_hash_eq): New hashing functions.\n\t(build_int_cst_wide): Use hash table for oversized integers.\n\nFrom-SVN: r89745", "tree": {"sha": "d762afa78963cd3988f8de9137f90d64608f4937", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d762afa78963cd3988f8de9137f90d64608f4937"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b66a64f16c38d7b3bb8d55c289af5e68250a3768", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b66a64f16c38d7b3bb8d55c289af5e68250a3768", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b66a64f16c38d7b3bb8d55c289af5e68250a3768", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b66a64f16c38d7b3bb8d55c289af5e68250a3768/comments", "author": null, "committer": null, "parents": [{"sha": "0b4828effea3bcacf88af872da26c5632cbfef85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4828effea3bcacf88af872da26c5632cbfef85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b4828effea3bcacf88af872da26c5632cbfef85"}], "stats": {"total": 87, "additions": 78, "deletions": 9}, "files": [{"sha": "82eb2ca907855c07252b768e845e1f4454c78498", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66a64f16c38d7b3bb8d55c289af5e68250a3768/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66a64f16c38d7b3bb8d55c289af5e68250a3768/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b66a64f16c38d7b3bb8d55c289af5e68250a3768", "patch": "@@ -1,3 +1,10 @@\n+2004-10-28  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* tree.c (int_cst_node, int_cst_hash_table): New variables.\n+\t(init_ttree): Initialize them.\n+\t(int_cst_hash_hash, int_cst_hash_eq): New hashing functions.\n+\t(build_int_cst_wide): Use hash table for oversized integers.\n+\n 2004-10-28  Nick Clifton  <nickc@redhat.com>\n \n \t* config/m32r/m32r.h (DBX_OUTPUT_SOURCE_LINE): Define"}, {"sha": "2cfcde2ff4dac08df9fe7d2036ce476cd98cfd0d", "filename": "gcc/tree.c", "status": "modified", "additions": 71, "deletions": 9, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66a64f16c38d7b3bb8d55c289af5e68250a3768/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66a64f16c38d7b3bb8d55c289af5e68250a3768/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b66a64f16c38d7b3bb8d55c289af5e68250a3768", "patch": "@@ -125,9 +125,16 @@ struct type_hash GTY(())\n static GTY ((if_marked (\"type_hash_marked_p\"), param_is (struct type_hash)))\n      htab_t type_hash_table;\n \n+/* Hash table and temporary node for larger integer const values.  */\n+static GTY (()) tree int_cst_node;\n+static GTY ((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n+     htab_t int_cst_hash_table;\n+\n static void set_type_quals (tree, int);\n static int type_hash_eq (const void *, const void *);\n static hashval_t type_hash_hash (const void *);\n+static hashval_t int_cst_hash_hash (const void *);\n+static int int_cst_hash_eq (const void *, const void *);\n static void print_type_hash_statistics (void);\n static tree make_vector_type (tree, int, enum machine_mode);\n static int type_hash_marked_p (const void *);\n@@ -145,6 +152,9 @@ init_ttree (void)\n   /* Initialize the hash table of types.  */\n   type_hash_table = htab_create_ggc (TYPE_HASH_INITIAL_SIZE, type_hash_hash,\n \t\t\t\t     type_hash_eq, 0);\n+  int_cst_hash_table = htab_create_ggc (1024, int_cst_hash_hash,\n+\t\t\t\t\tint_cst_hash_eq, NULL);\n+  int_cst_node = make_node (INTEGER_CST);\n }\n \n \f\n@@ -522,8 +532,38 @@ build_int_cst_type (tree type, HOST_WIDE_INT low)\n   return ret;\n }\n \n+/* These are the hash table functions for the hash table of INTEGER_CST\n+   nodes of a sizetype.  */\n+\n+/* Return the hash code code X, an INTEGER_CST.  */\n+\n+static hashval_t\n+int_cst_hash_hash (const void *x)\n+{\n+  tree t = (tree) x;\n+\n+  return (TREE_INT_CST_HIGH (t) ^ TREE_INT_CST_LOW (t)\n+\t  ^ htab_hash_pointer (TREE_TYPE (t)));\n+}\n+\n+/* Return nonzero if the value represented by *X (an INTEGER_CST tree node)\n+   is the same as that given by *Y, which is the same.  */\n+\n+static int\n+int_cst_hash_eq (const void *x, const void *y)\n+{\n+  tree xt = (tree) x;\n+  tree yt = (tree) y;\n+\n+  return (TREE_TYPE (xt) == TREE_TYPE (yt)\n+\t  && TREE_INT_CST_HIGH (xt) == TREE_INT_CST_HIGH (yt)\n+\t  && TREE_INT_CST_LOW (xt) == TREE_INT_CST_LOW (yt));\n+}\n+\n /* Create an INT_CST node of TYPE and value HI:LOW.  If TYPE is NULL,\n-   integer_type_node is used.  */\n+   integer_type_node is used.  The returned node is always shared.\n+   For small integers we use a per-type vector cache, for larger ones\n+   we use a single hash table.  */\n \n tree\n build_int_cst_wide (tree type, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n@@ -580,6 +620,7 @@ build_int_cst_wide (tree type, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n \n   if (ix >= 0)\n     {\n+      /* Look for it in the type's vector of small shared ints.  */\n       if (!TYPE_CACHED_VALUES_P (type))\n \t{\n \t  TYPE_CACHED_VALUES_P (type) = 1;\n@@ -593,18 +634,39 @@ build_int_cst_wide (tree type, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n \t  gcc_assert (TREE_TYPE (t) == type);\n \t  gcc_assert (TREE_INT_CST_LOW (t) == low);\n \t  gcc_assert (TREE_INT_CST_HIGH (t) == hi);\n-\t  return t;\n \t}\n-    }\n+      else\n+\t{\n+\t  /* Create a new shared int.  */\n+\t  t = make_node (INTEGER_CST);\n \n-  t = make_node (INTEGER_CST);\n+\t  TREE_INT_CST_LOW (t) = low;\n+\t  TREE_INT_CST_HIGH (t) = hi;\n+\t  TREE_TYPE (t) = type;\n+\t  \n+\t  TREE_VEC_ELT (TYPE_CACHED_VALUES (type), ix) = t;\n+\t}\n+    }\n+  else\n+    {\n+      /* Use the cache of larger shared ints.  */\n+      void **slot;\n \n-  TREE_INT_CST_LOW (t) = low;\n-  TREE_INT_CST_HIGH (t) = hi;\n-  TREE_TYPE (t) = type;\n+      TREE_INT_CST_LOW (int_cst_node) = low;\n+      TREE_INT_CST_HIGH (int_cst_node) = hi;\n+      TREE_TYPE (int_cst_node) = type;\n \n-  if (ix >= 0)\n-    TREE_VEC_ELT (TYPE_CACHED_VALUES (type), ix) = t;\n+      slot = htab_find_slot (int_cst_hash_table, int_cst_node, INSERT);\n+      t = *slot;\n+      if (!t)\n+\t{\n+\t  /* Insert this one into the hash table.  */\n+\t  t = int_cst_node;\n+\t  *slot = t;\n+\t  /* Make a new node for next time round.  */\n+\t  int_cst_node = make_node (INTEGER_CST);\n+\t}\n+    }\n \n   return t;\n }"}]}