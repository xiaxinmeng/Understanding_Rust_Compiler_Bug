{"sha": "0645ba8f0b34dbbce7a57dcf712cd0cb261edcc2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY0NWJhOGYwYjM0ZGJiY2U3YTU3ZGNmNzEyY2QwY2IyNjFlZGNjMg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-10-01T18:44:49Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-10-01T18:44:49Z"}, "message": "stor-layout.c (update_alignment_for_field): New function.\n\n\t* stor-layout.c (update_alignment_for_field): New function.\n\t(place_union_field): Use it.\n\t(place_field): Likewise.\n\t* gcc.dg/empty1.C: New test.\n\nFrom-SVN: r57697", "tree": {"sha": "6a0a7a188939d5684b564c5c8f4ddde2761d9f00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a0a7a188939d5684b564c5c8f4ddde2761d9f00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0645ba8f0b34dbbce7a57dcf712cd0cb261edcc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0645ba8f0b34dbbce7a57dcf712cd0cb261edcc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0645ba8f0b34dbbce7a57dcf712cd0cb261edcc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0645ba8f0b34dbbce7a57dcf712cd0cb261edcc2/comments", "author": null, "committer": null, "parents": [{"sha": "b4c20e524ce008387c6efe06d10fbd4a488d8654", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4c20e524ce008387c6efe06d10fbd4a488d8654", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4c20e524ce008387c6efe06d10fbd4a488d8654"}], "stats": {"total": 246, "additions": 124, "deletions": 122}, "files": [{"sha": "a860318aa125191e18fcdda33dfad239d9633d5f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0645ba8f0b34dbbce7a57dcf712cd0cb261edcc2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0645ba8f0b34dbbce7a57dcf712cd0cb261edcc2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0645ba8f0b34dbbce7a57dcf712cd0cb261edcc2", "patch": "@@ -1,3 +1,9 @@\n+2002-10-01  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* stor-layout.c (update_alignment_for_field): New function.\n+\t(place_union_field): Use it.\n+\t(place_field): Likewise.\n+\t\n 2002-10-01  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* gcc.c (cc1_options): Add space on -auxbase-strip."}, {"sha": "dd37d955190384e29d3087050b4bf5a80ba18240", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 106, "deletions": 122, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0645ba8f0b34dbbce7a57dcf712cd0cb261edcc2/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0645ba8f0b34dbbce7a57dcf712cd0cb261edcc2/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=0645ba8f0b34dbbce7a57dcf712cd0cb261edcc2", "patch": "@@ -60,6 +60,9 @@ static int reference_types_internal = 0;\n static void finalize_record_size\tPARAMS ((record_layout_info));\n static void finalize_type_size\t\tPARAMS ((tree));\n static void place_union_field\t\tPARAMS ((record_layout_info, tree));\n+static unsigned int update_alignment_for_field\n+                                        PARAMS ((record_layout_info, tree, \n+\t\t\t\t\t\t unsigned int));\n extern void debug_rli\t\t\tPARAMS ((record_layout_info));\n \f\n /* SAVE_EXPRs for sizes of types and decls, waiting to be expanded.  */\n@@ -644,130 +647,23 @@ rli_size_so_far (rli)\n   return bit_from_pos (rli->offset, rli->bitpos);\n }\n \n-/* Called from place_field to handle unions.  */\n+/* FIELD is about to be added to RLI->T.  The alignment (in bits) of\n+   the next available location is given by KNOWN_ALIGN.  Update the\n+   variable alignment fields in RLI, and return the alignment to give\n+   the FIELD.  */\n \n-static void\n-place_union_field (rli, field)\n-     record_layout_info rli;\n-     tree field;\n-{\n-  unsigned int desired_align;\n-\n-  layout_decl (field, 0);\n-\n-  DECL_FIELD_OFFSET (field) = size_zero_node;\n-  DECL_FIELD_BIT_OFFSET (field) = bitsize_zero_node;\n-  SET_DECL_OFFSET_ALIGN (field, BIGGEST_ALIGNMENT);\n-\n-  desired_align = DECL_ALIGN (field);\n-\n-#ifdef BIGGEST_FIELD_ALIGNMENT\n-  /* Some targets (i.e. i386) limit union field alignment\n-     to a lower boundary than alignment of variables unless\n-     it was overridden by attribute aligned.  */\n-  if (! DECL_USER_ALIGN (field))\n-    desired_align =\n-      MIN (desired_align, (unsigned) BIGGEST_FIELD_ALIGNMENT);\n-#endif\n-\n-#ifdef ADJUST_FIELD_ALIGN\n-  if (! DECL_USER_ALIGN (field))\n-    desired_align = ADJUST_FIELD_ALIGN (field, desired_align);\n-#endif\n-\n-  TYPE_USER_ALIGN (rli->t) |= DECL_USER_ALIGN (field);\n-\n-  /* Union must be at least as aligned as any field requires.  */\n-  rli->record_align = MAX (rli->record_align, desired_align);\n-  rli->unpadded_align = MAX (rli->unpadded_align, desired_align);\n-\n-#ifdef PCC_BITFIELD_TYPE_MATTERS\n-  /* On the m88000, a bit field of declare type `int' forces the\n-     entire union to have `int' alignment.  */\n-  if (PCC_BITFIELD_TYPE_MATTERS && DECL_BIT_FIELD_TYPE (field))\n-    {\n-      unsigned int type_align = TYPE_ALIGN (TREE_TYPE (field));\n-\n-#ifdef ADJUST_FIELD_ALIGN\n-      if (! TYPE_USER_ALIGN (TREE_TYPE (field)))\n-\ttype_align = ADJUST_FIELD_ALIGN (field, type_align);\n-#endif\n-      rli->record_align = MAX (rli->record_align, type_align);\n-      rli->unpadded_align = MAX (rli->unpadded_align, type_align);\n-      TYPE_USER_ALIGN (rli->t) |= TYPE_USER_ALIGN (TREE_TYPE (field));\n-    }\n-#endif\n-\n-  /* We assume the union's size will be a multiple of a byte so we don't\n-     bother with BITPOS.  */\n-  if (TREE_CODE (rli->t) == UNION_TYPE)\n-    rli->offset = size_binop (MAX_EXPR, rli->offset, DECL_SIZE_UNIT (field));\n-  else if (TREE_CODE (rli->t) == QUAL_UNION_TYPE)\n-    rli->offset = fold (build (COND_EXPR, sizetype,\n-\t\t\t       DECL_QUALIFIER (field),\n-\t\t\t       DECL_SIZE_UNIT (field), rli->offset));\n-}\n-\n-/* RLI contains information about the layout of a RECORD_TYPE.  FIELD\n-   is a FIELD_DECL to be added after those fields already present in\n-   T.  (FIELD is not actually added to the TYPE_FIELDS list here;\n-   callers that desire that behavior must manually perform that step.)  */\n-\n-void\n-place_field (rli, field)\n+static unsigned int\n+update_alignment_for_field (rli, field, known_align)\n      record_layout_info rli;\n      tree field;\n+     unsigned int known_align;\n {\n   /* The alignment required for FIELD.  */\n   unsigned int desired_align;\n-  /* The alignment FIELD would have if we just dropped it into the\n-     record as it presently stands.  */\n-  unsigned int known_align;\n-  unsigned int actual_align;\n-  unsigned int user_align;\n   /* The type of this field.  */\n   tree type = TREE_TYPE (field);\n-\n-  if (TREE_CODE (field) == ERROR_MARK || TREE_CODE (type) == ERROR_MARK)\n-      return;\n-\n-  /* If FIELD is static, then treat it like a separate variable, not\n-     really like a structure field.  If it is a FUNCTION_DECL, it's a\n-     method.  In both cases, all we do is lay out the decl, and we do\n-     it *after* the record is laid out.  */\n-  if (TREE_CODE (field) == VAR_DECL)\n-    {\n-      rli->pending_statics = tree_cons (NULL_TREE, field,\n-\t\t\t\t\trli->pending_statics);\n-      return;\n-    }\n-\n-  /* Enumerators and enum types which are local to this class need not\n-     be laid out.  Likewise for initialized constant fields.  */\n-  else if (TREE_CODE (field) != FIELD_DECL)\n-    return;\n-\n-  /* Unions are laid out very differently than records, so split\n-     that code off to another function.  */\n-  else if (TREE_CODE (rli->t) != RECORD_TYPE)\n-    {\n-      place_union_field (rli, field);\n-      return;\n-    }\n-\n-  /* Work out the known alignment so far.  Note that A & (-A) is the\n-     value of the least-significant bit in A that is one.  */\n-  if (! integer_zerop (rli->bitpos))\n-    known_align = (tree_low_cst (rli->bitpos, 1)\n-\t\t   & - tree_low_cst (rli->bitpos, 1));\n-  else if (integer_zerop (rli->offset))\n-    known_align = BIGGEST_ALIGNMENT;\n-  else if (host_integerp (rli->offset, 1))\n-    known_align = (BITS_PER_UNIT\n-\t\t   * (tree_low_cst (rli->offset, 1)\n-\t\t      & - tree_low_cst (rli->offset, 1)));\n-  else\n-    known_align = rli->offset_align;\n+  /* True if the field was explicitly aligned by the user.  */\n+  bool user_align;\n \n   /* Lay out the field so we know what alignment it needs.  For a\n      packed field, use the alignment as specified, disregarding what\n@@ -785,13 +681,13 @@ place_field (rli, field)\n      to a lower boundary than alignment of variables unless\n      it was overridden by attribute aligned.  */\n #ifdef BIGGEST_FIELD_ALIGNMENT\n-  if (! user_align)\n+  if (!user_align)\n     desired_align\n       = MIN (desired_align, (unsigned) BIGGEST_FIELD_ALIGNMENT);\n #endif\n \n #ifdef ADJUST_FIELD_ALIGN\n-  if (! user_align)\n+  if (!user_align)\n     desired_align = ADJUST_FIELD_ALIGN (field, desired_align);\n #endif\n \n@@ -873,6 +769,96 @@ place_field (rli, field)\n       rli->unpadded_align = MAX (rli->unpadded_align, DECL_ALIGN (field));\n     }\n \n+  TYPE_USER_ALIGN (rli->t) |= user_align;\n+\n+  return desired_align;\n+}\n+\n+/* Called from place_field to handle unions.  */\n+\n+static void\n+place_union_field (rli, field)\n+     record_layout_info rli;\n+     tree field;\n+{\n+  update_alignment_for_field (rli, field, /*known_align=*/0);\n+\n+  DECL_FIELD_OFFSET (field) = size_zero_node;\n+  DECL_FIELD_BIT_OFFSET (field) = bitsize_zero_node;\n+  SET_DECL_OFFSET_ALIGN (field, BIGGEST_ALIGNMENT);\n+\n+  /* We assume the union's size will be a multiple of a byte so we don't\n+     bother with BITPOS.  */\n+  if (TREE_CODE (rli->t) == UNION_TYPE)\n+    rli->offset = size_binop (MAX_EXPR, rli->offset, DECL_SIZE_UNIT (field));\n+  else if (TREE_CODE (rli->t) == QUAL_UNION_TYPE)\n+    rli->offset = fold (build (COND_EXPR, sizetype,\n+\t\t\t       DECL_QUALIFIER (field),\n+\t\t\t       DECL_SIZE_UNIT (field), rli->offset));\n+}\n+\n+/* RLI contains information about the layout of a RECORD_TYPE.  FIELD\n+   is a FIELD_DECL to be added after those fields already present in\n+   T.  (FIELD is not actually added to the TYPE_FIELDS list here;\n+   callers that desire that behavior must manually perform that step.)  */\n+\n+void\n+place_field (rli, field)\n+     record_layout_info rli;\n+     tree field;\n+{\n+  /* The alignment required for FIELD.  */\n+  unsigned int desired_align;\n+  /* The alignment FIELD would have if we just dropped it into the\n+     record as it presently stands.  */\n+  unsigned int known_align;\n+  unsigned int actual_align;\n+  /* The type of this field.  */\n+  tree type = TREE_TYPE (field);\n+\n+  if (TREE_CODE (field) == ERROR_MARK || TREE_CODE (type) == ERROR_MARK)\n+      return;\n+\n+  /* If FIELD is static, then treat it like a separate variable, not\n+     really like a structure field.  If it is a FUNCTION_DECL, it's a\n+     method.  In both cases, all we do is lay out the decl, and we do\n+     it *after* the record is laid out.  */\n+  if (TREE_CODE (field) == VAR_DECL)\n+    {\n+      rli->pending_statics = tree_cons (NULL_TREE, field,\n+\t\t\t\t\trli->pending_statics);\n+      return;\n+    }\n+\n+  /* Enumerators and enum types which are local to this class need not\n+     be laid out.  Likewise for initialized constant fields.  */\n+  else if (TREE_CODE (field) != FIELD_DECL)\n+    return;\n+\n+  /* Unions are laid out very differently than records, so split\n+     that code off to another function.  */\n+  else if (TREE_CODE (rli->t) != RECORD_TYPE)\n+    {\n+      place_union_field (rli, field);\n+      return;\n+    }\n+\n+  /* Work out the known alignment so far.  Note that A & (-A) is the\n+     value of the least-significant bit in A that is one.  */\n+  if (! integer_zerop (rli->bitpos))\n+    known_align = (tree_low_cst (rli->bitpos, 1)\n+\t\t   & - tree_low_cst (rli->bitpos, 1));\n+  else if (integer_zerop (rli->offset))\n+    known_align = BIGGEST_ALIGNMENT;\n+  else if (host_integerp (rli->offset, 1))\n+    known_align = (BITS_PER_UNIT\n+\t\t   * (tree_low_cst (rli->offset, 1)\n+\t\t      & - tree_low_cst (rli->offset, 1)));\n+  else\n+    known_align = rli->offset_align;\n+  \n+  desired_align = update_alignment_for_field (rli, field, known_align);\n+\n   if (warn_packed && DECL_PACKED (field))\n     {\n       if (known_align > TYPE_ALIGN (type))\n@@ -956,7 +942,7 @@ place_field (rli, field)\n \t  > tree_low_cst (TYPE_SIZE (type), 1) / type_align)\n \trli->bitpos = round_up (rli->bitpos, type_align);\n \n-      user_align |= TYPE_USER_ALIGN (type);\n+      TYPE_USER_ALIGN (rli->t) |= TYPE_USER_ALIGN (type);\n     }\n #endif\n \n@@ -999,7 +985,7 @@ place_field (rli, field)\n \t      / type_align))\n \trli->bitpos = round_up (rli->bitpos, type_align);\n \n-      user_align |= TYPE_USER_ALIGN (type);\n+      TYPE_USER_ALIGN (rli->t) |= TYPE_USER_ALIGN (type);\n     }\n #endif\n \n@@ -1153,8 +1139,6 @@ place_field (rli, field)\n   DECL_FIELD_BIT_OFFSET (field) = rli->bitpos;\n   SET_DECL_OFFSET_ALIGN (field, rli->offset_align);\n \n-  TYPE_USER_ALIGN (rli->t) |= user_align;\n-\n   /* If this field ended up more aligned than we thought it would be (we\n      approximate this by seeing if its position changed), lay out the field\n      again; perhaps we can use an integral mode for it now.  */"}, {"sha": "57d265fe7f6e36f2430ba1d073e60b2b2c58c12a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0645ba8f0b34dbbce7a57dcf712cd0cb261edcc2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0645ba8f0b34dbbce7a57dcf712cd0cb261edcc2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0645ba8f0b34dbbce7a57dcf712cd0cb261edcc2", "patch": "@@ -1,5 +1,7 @@\n 2002-10-01  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* gcc.dg/empty1.C: New test.\n+\n \t* g++.dg/tls/init-2.C: Tweak error messages.\n \n 2002-10-01  Richard Sandiford  <rsandifo@redhat.com>"}, {"sha": "69f778c72b3c0203e526036022cf325e938ed228", "filename": "gcc/testsuite/gcc.dg/empty1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0645ba8f0b34dbbce7a57dcf712cd0cb261edcc2/gcc%2Ftestsuite%2Fgcc.dg%2Fempty1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0645ba8f0b34dbbce7a57dcf712cd0cb261edcc2/gcc%2Ftestsuite%2Fgcc.dg%2Fempty1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fempty1.c?ref=0645ba8f0b34dbbce7a57dcf712cd0cb261edcc2", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+\n+struct S { int : 0; };\n+union U { int : 0; };\n+\n+int main () {\n+  if (__alignof__ (struct S) != __alignof__ (union U))\n+    return 1;\n+}"}]}