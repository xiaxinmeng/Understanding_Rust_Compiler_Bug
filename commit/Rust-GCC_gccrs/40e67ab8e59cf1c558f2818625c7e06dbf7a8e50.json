{"sha": "40e67ab8e59cf1c558f2818625c7e06dbf7a8e50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBlNjdhYjhlNTljZjFjNTU4ZjI4MTg2MjVjN2UwNmRiZjdhOGU1MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-26T10:24:33Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-26T10:24:33Z"}, "message": "Make default duplicate and insert methods of summaries abort; fix fallout\n\nthe default duplicate and insert methods of sumaries produce empty\nsummary that is not useful for anything and makes it easy to introduce\nbugs.\n\nThis patch makes the default hooks to abort and summaries that do not\nneed dupicaito/insertion disable the corresponding hooks. I also\nimplemented missing insertion hook for ipa-sra which forced me to move\nanalysis out of anonymous namespace.\n\n2020-10-23  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* cgraph.h (struct cgraph_node): Make ipa_transforms_to_apply vl_ptr.\n\t* ipa-inline-analysis.c (initialize_growth_caches): Disable insertion\n\tand duplication hooks.\n\t* ipa-inline-transform.c (clone_inlined_nodes): Clear\n\tipa_transforms_to_apply.\n\t(save_inline_function_body): Disable insertion hoook for\n\tipa_saved_clone_sources.\n\t* ipa-prop.c (ipcp_transformation_initialize): Disable insertion hook.\n\t* ipa-prop.h (ipa_node_params_t): Disable insertion hook.\n\t* ipa-reference.c (propagate): Disable insertion hoook.\n\t* ipa-sra.c (ipa_sra_summarize_function): Move out of anonymous\n\tnamespace.\n\t(ipa_sra_function_summaries::insert): New virtual function.\n\t* passes.c (execute_one_pass): Do not add transforms to inline clones.\n\t* symbol-summary.h (function_summary_base): Make insert and duplicate\n\thooks fail instead of silently producing empty summaries; add way to\n\tdisable duplication hooks\n\t(call_summary_base): Likewise.\n\t* tree-nested.c (nested_function_info::get_create): Disable insertion\n\thooks\n\t(maybe_record_nested_function): Likewise.", "tree": {"sha": "a949d436af2b24b4dcf1d15dd96045e6ec8f7f9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a949d436af2b24b4dcf1d15dd96045e6ec8f7f9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/comments", "author": null, "committer": null, "parents": [{"sha": "dc7824734e6589bac2ba0f8363d24d50da8cfeae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc7824734e6589bac2ba0f8363d24d50da8cfeae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc7824734e6589bac2ba0f8363d24d50da8cfeae"}], "stats": {"total": 320, "additions": 210, "deletions": 110}, "files": [{"sha": "65e4646efcd8778aacda2dc56ccc4ce8b2ab4b86", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=40e67ab8e59cf1c558f2818625c7e06dbf7a8e50", "patch": "@@ -1402,7 +1402,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   /* Interprocedural passes scheduled to have their transform functions\n      applied next time we execute local pass on them.  We maintain it\n      per-function in order to allow IPA passes to introduce new functions.  */\n-  vec<ipa_opt_pass> GTY((skip)) ipa_transforms_to_apply;\n+  vec<ipa_opt_pass, va_heap, vl_ptr> GTY((skip)) ipa_transforms_to_apply;\n \n   /* For inline clones this points to the function they will be\n      inlined into.  */"}, {"sha": "bd0e322605fa50fefc0567da088541a099a1c522", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=40e67ab8e59cf1c558f2818625c7e06dbf7a8e50", "patch": "@@ -127,6 +127,9 @@ initialize_growth_caches ()\n     = new fast_call_summary<edge_growth_cache_entry *, va_heap> (symtab);\n   node_context_cache\n     = new fast_function_summary<node_context_summary *, va_heap> (symtab);\n+  edge_growth_cache->disable_duplication_hook ();\n+  node_context_cache->disable_insertion_hook ();\n+  node_context_cache->disable_duplication_hook ();\n }\n \n /* Free growth caches.  */"}, {"sha": "279ba2f7cb0abee6648181887fdc0c5b24bbc29c", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=40e67ab8e59cf1c558f2818625c7e06dbf7a8e50", "patch": "@@ -231,6 +231,11 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n     e->callee->remove_from_same_comdat_group ();\n \n   e->callee->inlined_to = inlining_into;\n+  if (e->callee->ipa_transforms_to_apply.length ())\n+    {\n+      e->callee->ipa_transforms_to_apply.release ();\n+      e->callee->ipa_transforms_to_apply = vNULL;\n+    }\n \n   /* Recursively clone all bodies.  */\n   for (e = e->callee->callees; e; e = next)\n@@ -606,7 +611,10 @@ save_inline_function_body (struct cgraph_node *node)\n \n   tree prev_body_holder = node->decl;\n   if (!ipa_saved_clone_sources)\n-    ipa_saved_clone_sources = new function_summary <tree *> (symtab);\n+    {\n+      ipa_saved_clone_sources = new function_summary <tree *> (symtab);\n+      ipa_saved_clone_sources->disable_insertion_hook ();\n+    }\n   else\n     {\n       tree *p = ipa_saved_clone_sources->get (node);"}, {"sha": "6014766b4183dbe1a842320b6c3494beff4d05ff", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=40e67ab8e59cf1c558f2818625c7e06dbf7a8e50", "patch": "@@ -4211,7 +4211,10 @@ ipcp_transformation_initialize (void)\n   if (!ipa_vr_hash_table)\n     ipa_vr_hash_table = hash_table<ipa_vr_ggc_hash_traits>::create_ggc (37);\n   if (ipcp_transformation_sum == NULL)\n-    ipcp_transformation_sum = ipcp_transformation_t::create_ggc (symtab);\n+    {\n+      ipcp_transformation_sum = ipcp_transformation_t::create_ggc (symtab);\n+      ipcp_transformation_sum->disable_insertion_hook ();\n+    }\n }\n \n /* Release the IPA CP transformation summary.  */"}, {"sha": "77e92b04bbaa9a95c32b3fa12a37c9fc3edaf6b8", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=40e67ab8e59cf1c558f2818625c7e06dbf7a8e50", "patch": "@@ -941,7 +941,10 @@ class GTY((user)) ipa_node_params_t: public function_summary <ipa_node_params *>\n {\n public:\n   ipa_node_params_t (symbol_table *table, bool ggc):\n-    function_summary<ipa_node_params *> (table, ggc) { }\n+    function_summary<ipa_node_params *> (table, ggc)\n+  {\n+    disable_insertion_hook ();\n+  }\n \n   /* Hook that is called by summary when a node is duplicated.  */\n   virtual void duplicate (cgraph_node *node,"}, {"sha": "871c9977841f3138ef500b561a98ec21f338cd80", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=40e67ab8e59cf1c558f2818625c7e06dbf7a8e50", "patch": "@@ -894,7 +894,10 @@ propagate (void)\n     }\n \n   if (ipa_ref_opt_sum_summaries == NULL)\n-    ipa_ref_opt_sum_summaries = new ipa_ref_opt_summary_t (symtab);\n+    {\n+      ipa_ref_opt_sum_summaries = new ipa_ref_opt_summary_t (symtab);\n+      ipa_ref_opt_sum_summaries->disable_insertion_hook ();\n+    }\n \n   /* Cleanup. */\n   FOR_EACH_DEFINED_FUNCTION (node)\n@@ -1130,6 +1133,7 @@ ipa_reference_read_optimization_summary (void)\n \n   gcc_checking_assert (ipa_ref_opt_sum_summaries == NULL);\n   ipa_ref_opt_sum_summaries = new ipa_ref_opt_summary_t (symtab);\n+  ipa_ref_opt_sum_summaries->disable_insertion_hook ();\n   ipa_reference_vars_map = new reference_vars_map_t(257);\n   varpool_node_hooks\n \t = symtab->add_varpool_removal_hook (varpool_removal_hook, NULL);"}, {"sha": "07227c0bfecfdf8c4b295053e0a90d08aadf58c8", "filename": "gcc/ipa-sra.c", "status": "modified", "additions": 91, "deletions": 73, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fipa-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fipa-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.c?ref=40e67ab8e59cf1c558f2818625c7e06dbf7a8e50", "patch": "@@ -85,6 +85,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-streamer.h\"\n #include \"internal-fn.h\"\n \n+static void ipa_sra_summarize_function (cgraph_node *);\n+\n /* Bits used to track size of an aggregate in bytes interprocedurally.  */\n #define ISRA_ARG_SIZE_LIMIT_BITS 16\n #define ISRA_ARG_SIZE_LIMIT (1 << ISRA_ARG_SIZE_LIMIT_BITS)\n@@ -373,6 +375,7 @@ class GTY((user)) ipa_sra_function_summaries\n   virtual void duplicate (cgraph_node *, cgraph_node *,\n \t\t\t  isra_func_summary *old_sum,\n \t\t\t  isra_func_summary *new_sum);\n+  virtual void insert (cgraph_node *, isra_func_summary *);\n };\n \n /* Hook that is called by summary when a node is duplicated.  */\n@@ -426,6 +429,21 @@ ipa_sra_function_summaries::duplicate (cgraph_node *, cgraph_node *,\n \n static GTY(()) ipa_sra_function_summaries *func_sums;\n \n+/* Hook that is called by summary when new node appears.  */\n+\n+void\n+ipa_sra_function_summaries::insert (cgraph_node *node, isra_func_summary *)\n+{\n+  if (opt_for_fn (node->decl, flag_ipa_sra))\n+    {\n+      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+      ipa_sra_summarize_function (node);\n+      pop_cfun ();\n+    }\n+  else\n+    func_sums->remove (node);\n+}\n+\n /* Class to manage call summaries.  */\n \n class ipa_sra_call_summaries: public call_summary <isra_call_summary *>\n@@ -2478,79 +2496,6 @@ verify_splitting_accesses (cgraph_node *node, bool certain_must_exist)\n     }\n }\n \n-/* Intraprocedural part of IPA-SRA analysis.  Scan function body of NODE and\n-   create a summary structure describing IPA-SRA opportunities and constraints\n-   in it.  */\n-\n-static void\n-ipa_sra_summarize_function (cgraph_node *node)\n-{\n-  if (dump_file)\n-    fprintf (dump_file, \"Creating summary for %s/%i:\\n\", node->name (),\n-\t     node->order);\n-  if (!ipa_sra_preliminary_function_checks (node))\n-    return;\n-  gcc_obstack_init (&gensum_obstack);\n-  isra_func_summary *ifs = func_sums->get_create (node);\n-  ifs->m_candidate = true;\n-  tree ret = TREE_TYPE (TREE_TYPE (node->decl));\n-  ifs->m_returns_value = (TREE_CODE (ret) != VOID_TYPE);\n-\n-  decl2desc = new hash_map<tree, gensum_param_desc *>;\n-  unsigned count = 0;\n-  for (tree parm = DECL_ARGUMENTS (node->decl); parm; parm = DECL_CHAIN (parm))\n-    count++;\n-\n-  if (count > 0)\n-    {\n-      auto_vec<gensum_param_desc, 16> param_descriptions (count);\n-      param_descriptions.reserve_exact (count);\n-      param_descriptions.quick_grow_cleared (count);\n-\n-      bool cfun_pushed = false;\n-      struct function *fun = DECL_STRUCT_FUNCTION (node->decl);\n-      if (create_parameter_descriptors (node, &param_descriptions))\n-\t{\n-\t  push_cfun (fun);\n-\t  cfun_pushed = true;\n-\t  final_bbs = BITMAP_ALLOC (NULL);\n-\t  bb_dereferences = XCNEWVEC (HOST_WIDE_INT,\n-\t\t\t\t      by_ref_count\n-\t\t\t\t      * last_basic_block_for_fn (fun));\n-\t  aa_walking_limit = opt_for_fn (node->decl, param_ipa_max_aa_steps);\n-\t  scan_function (node, fun);\n-\n-\t  if (dump_file)\n-\t    {\n-\t      dump_gensum_param_descriptors (dump_file, node->decl,\n-\t\t\t\t\t     &param_descriptions);\n-\t      fprintf (dump_file, \"----------------------------------------\\n\");\n-\t    }\n-\t}\n-      process_scan_results (node, fun, ifs, &param_descriptions);\n-\n-      if (cfun_pushed)\n-\tpop_cfun ();\n-      if (bb_dereferences)\n-\t{\n-\t  free (bb_dereferences);\n-\t  bb_dereferences = NULL;\n-\t  BITMAP_FREE (final_bbs);\n-\t  final_bbs = NULL;\n-\t}\n-    }\n-  isra_analyze_all_outgoing_calls (node);\n-\n-  delete decl2desc;\n-  decl2desc = NULL;\n-  obstack_free (&gensum_obstack, NULL);\n-  if (dump_file)\n-    fprintf (dump_file, \"\\n\\n\");\n-  if (flag_checking)\n-    verify_splitting_accesses (node, false);\n-  return;\n-}\n-\n /* Intraprocedural part of IPA-SRA analysis.  Scan bodies of all functions in\n    this compilation unit and create summary structures describing IPA-SRA\n    opportunities and constraints in them.  */\n@@ -4102,6 +4047,79 @@ class pass_ipa_sra : public ipa_opt_pass_d\n \n } // anon namespace\n \n+/* Intraprocedural part of IPA-SRA analysis.  Scan function body of NODE and\n+   create a summary structure describing IPA-SRA opportunities and constraints\n+   in it.  */\n+\n+static void\n+ipa_sra_summarize_function (cgraph_node *node)\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \"Creating summary for %s/%i:\\n\", node->name (),\n+\t     node->order);\n+  if (!ipa_sra_preliminary_function_checks (node))\n+    return;\n+  gcc_obstack_init (&gensum_obstack);\n+  isra_func_summary *ifs = func_sums->get_create (node);\n+  ifs->m_candidate = true;\n+  tree ret = TREE_TYPE (TREE_TYPE (node->decl));\n+  ifs->m_returns_value = (TREE_CODE (ret) != VOID_TYPE);\n+\n+  decl2desc = new hash_map<tree, gensum_param_desc *>;\n+  unsigned count = 0;\n+  for (tree parm = DECL_ARGUMENTS (node->decl); parm; parm = DECL_CHAIN (parm))\n+    count++;\n+\n+  if (count > 0)\n+    {\n+      auto_vec<gensum_param_desc, 16> param_descriptions (count);\n+      param_descriptions.reserve_exact (count);\n+      param_descriptions.quick_grow_cleared (count);\n+\n+      bool cfun_pushed = false;\n+      struct function *fun = DECL_STRUCT_FUNCTION (node->decl);\n+      if (create_parameter_descriptors (node, &param_descriptions))\n+\t{\n+\t  push_cfun (fun);\n+\t  cfun_pushed = true;\n+\t  final_bbs = BITMAP_ALLOC (NULL);\n+\t  bb_dereferences = XCNEWVEC (HOST_WIDE_INT,\n+\t\t\t\t      by_ref_count\n+\t\t\t\t      * last_basic_block_for_fn (fun));\n+\t  aa_walking_limit = opt_for_fn (node->decl, param_ipa_max_aa_steps);\n+\t  scan_function (node, fun);\n+\n+\t  if (dump_file)\n+\t    {\n+\t      dump_gensum_param_descriptors (dump_file, node->decl,\n+\t\t\t\t\t     &param_descriptions);\n+\t      fprintf (dump_file, \"----------------------------------------\\n\");\n+\t    }\n+\t}\n+      process_scan_results (node, fun, ifs, &param_descriptions);\n+\n+      if (cfun_pushed)\n+\tpop_cfun ();\n+      if (bb_dereferences)\n+\t{\n+\t  free (bb_dereferences);\n+\t  bb_dereferences = NULL;\n+\t  BITMAP_FREE (final_bbs);\n+\t  final_bbs = NULL;\n+\t}\n+    }\n+  isra_analyze_all_outgoing_calls (node);\n+\n+  delete decl2desc;\n+  decl2desc = NULL;\n+  obstack_free (&gensum_obstack, NULL);\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n\\n\");\n+  if (flag_checking)\n+    verify_splitting_accesses (node, false);\n+  return;\n+}\n+\n ipa_opt_pass_d *\n make_pass_ipa_sra (gcc::context *ctxt)\n {"}, {"sha": "02a47e2595cfcfd0745660df32f949e85d2053f2", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=40e67ab8e59cf1c558f2818625c7e06dbf7a8e50", "patch": "@@ -2566,7 +2566,8 @@ execute_one_pass (opt_pass *pass)\n     {\n       struct cgraph_node *node;\n       FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n-\tnode->ipa_transforms_to_apply.safe_push ((ipa_opt_pass_d *)pass);\n+\tif (!node->inlined_to)\n+\t  node->ipa_transforms_to_apply.safe_push ((ipa_opt_pass_d *)pass);\n     }\n   else if (dump_file)\n     do_per_function (execute_function_dump, pass);"}, {"sha": "af5f4e6da62cb7aba5a37836bbf3b0152416cc52", "filename": "gcc/symbol-summary.h", "status": "modified", "additions": 83, "deletions": 29, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fsymbol-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Fsymbol-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymbol-summary.h?ref=40e67ab8e59cf1c558f2818625c7e06dbf7a8e50", "patch": "@@ -31,17 +31,27 @@ class function_summary_base\n   function_summary_base (symbol_table *symtab CXX_MEM_STAT_INFO):\n   m_symtab (symtab),\n   m_insertion_enabled (true),\n+  m_duplication_enabled (true),\n   m_allocator (\"function summary\" PASS_MEM_STAT)\n   {}\n \n   /* Basic implementation of insert operation.  */\n-  virtual void insert (cgraph_node *, T *) {}\n+  virtual void insert (cgraph_node *, T *)\n+  {\n+    /* In most cases, it makes no sense to create summaries without\n+       initializing them.  */\n+    gcc_unreachable ();\n+  }\n \n   /* Basic implementation of removal operation.  */\n   virtual void remove (cgraph_node *, T *) {}\n \n   /* Basic implementation of duplication operation.  */\n-  virtual void duplicate (cgraph_node *, cgraph_node *, T *, T *) {}\n+  virtual void duplicate (cgraph_node *, cgraph_node *, T *, T *)\n+  {\n+    /* It makes no sense to not copy anything during duplication.  */\n+    gcc_unreachable ();\n+  }\n \n   /* Enable insertion hook invocation.  */\n   void enable_insertion_hook ()\n@@ -55,6 +65,18 @@ class function_summary_base\n     m_insertion_enabled = false;\n   }\n \n+  /* Enable duplication hook invocation.  */\n+  void enable_duplication_hook ()\n+  {\n+    m_duplication_enabled = true;\n+  }\n+\n+  /* Enable duplication hook invocation.  */\n+  void disable_duplication_hook ()\n+  {\n+    m_duplication_enabled = false;\n+  }\n+\n protected:\n   /* Allocates new data that are stored within map.  */\n   T* allocate_new ()\n@@ -88,6 +110,8 @@ class function_summary_base\n \n   /* Indicates if insertion hook is enabled.  */\n   bool m_insertion_enabled;\n+  /* Indicates if duplication hook is enabled.  */\n+  bool m_duplication_enabled;\n \n private:\n   /* Return true when the summary uses GGC memory for allocation.  */\n@@ -269,10 +293,13 @@ function_summary<T *>::symtab_duplication (cgraph_node *node,\n \t\t\t\t\t   cgraph_node *node2, void *data)\n {\n   function_summary *summary = (function_summary <T *> *) (data);\n-  T *v = summary->get (node);\n+  if (summary->m_duplication_enabled)\n+    {\n+      T *v = summary->get (node);\n \n-  if (v)\n-    summary->duplicate (node, node2, v, summary->get_create (node2));\n+      if (v)\n+\tsummary->duplicate (node, node2, v, summary->get_create (node2));\n+    }\n }\n \n template <typename T>\n@@ -468,12 +495,15 @@ fast_function_summary<T *, V>::symtab_duplication (cgraph_node *node,\n \t\t\t\t\t\t   void *data)\n {\n   fast_function_summary *summary = (fast_function_summary <T *, V> *) (data);\n-  T *v = summary->get (node);\n-\n-  if (v)\n+  if (summary->m_duplication_enabled)\n     {\n-      T *duplicate = summary->get_create (node2);\n-      summary->duplicate (node, node2, v, duplicate);\n+      T *v = summary->get (node);\n+\n+      if (v)\n+\t{\n+\t  T *duplicate = summary->get_create (node2);\n+\t  summary->duplicate (node, node2, v, duplicate);\n+\t}\n     }\n }\n \n@@ -536,14 +566,30 @@ class call_summary_base\n   call_summary_base (symbol_table *symtab CXX_MEM_STAT_INFO):\n   m_symtab (symtab),\n   m_initialize_when_cloning (false),\n+  m_duplication_enabled (true),\n   m_allocator (\"call summary\" PASS_MEM_STAT)\n   {}\n \n   /* Basic implementation of removal operation.  */\n   virtual void remove (cgraph_edge *, T *) {}\n \n   /* Basic implementation of duplication operation.  */\n-  virtual void duplicate (cgraph_edge *, cgraph_edge *, T *, T *) {}\n+  virtual void duplicate (cgraph_edge *, cgraph_edge *, T *, T *)\n+  {\n+    gcc_unreachable ();\n+  }\n+\n+  /* Enable duplication hook invocation.  */\n+  void enable_duplication_hook ()\n+  {\n+    m_duplication_enabled = true;\n+  }\n+\n+  /* Enable duplication hook invocation.  */\n+  void disable_duplication_hook ()\n+  {\n+    m_duplication_enabled = false;\n+  }\n \n protected:\n   /* Allocates new data that are stored within map.  */\n@@ -576,6 +622,8 @@ class call_summary_base\n   cgraph_2edge_hook_list *m_symtab_duplication_hook;\n   /* Initialize summary for an edge that is cloned.  */\n   bool m_initialize_when_cloning;\n+  /* Indicates if duplication hook is enabled.  */\n+  bool m_duplication_enabled;\n \n private:\n   /* Return true when the summary uses GGC memory for allocation.  */\n@@ -726,16 +774,19 @@ call_summary<T *>::symtab_duplication (cgraph_edge *edge1,\n \t\t\t\t       cgraph_edge *edge2, void *data)\n {\n   call_summary *summary = (call_summary <T *> *) (data);\n-  T *edge1_summary = NULL;\n+  if (summary->m_duplication_enabled)\n+    {\n+      T *edge1_summary = NULL;\n \n-  if (summary->m_initialize_when_cloning)\n-    edge1_summary = summary->get_create (edge1);\n-  else\n-    edge1_summary = summary->get (edge1);\n+      if (summary->m_initialize_when_cloning)\n+\tedge1_summary = summary->get_create (edge1);\n+      else\n+\tedge1_summary = summary->get (edge1);\n \n-  if (edge1_summary)\n-    summary->duplicate (edge1, edge2, edge1_summary,\n-\t\t\tsummary->get_create (edge2));\n+      if (edge1_summary)\n+\tsummary->duplicate (edge1, edge2, edge1_summary,\n+\t\t\t    summary->get_create (edge2));\n+    }\n }\n \n template <typename T>\n@@ -892,17 +943,20 @@ fast_call_summary<T *, V>::symtab_duplication (cgraph_edge *edge1,\n \t\t\t\t\t\t cgraph_edge *edge2, void *data)\n {\n   fast_call_summary *summary = (fast_call_summary <T *, V> *) (data);\n-  T *edge1_summary = NULL;\n-\n-  if (summary->m_initialize_when_cloning)\n-    edge1_summary = summary->get_create (edge1);\n-  else\n-    edge1_summary = summary->get (edge1);\n-\n-  if (edge1_summary)\n+  if (summary->m_duplication_enabled)\n     {\n-      T *duplicate = summary->get_create (edge2);\n-      summary->duplicate (edge1, edge2, edge1_summary, duplicate);\n+      T *edge1_summary = NULL;\n+\n+      if (summary->m_initialize_when_cloning)\n+\tedge1_summary = summary->get_create (edge1);\n+      else\n+\tedge1_summary = summary->get (edge1);\n+\n+      if (edge1_summary)\n+\t{\n+\t  T *duplicate = summary->get_create (edge2);\n+\t  summary->duplicate (edge1, edge2, edge1_summary, duplicate);\n+\t}\n     }\n }\n "}, {"sha": "9cb4a08e2d9e713bfd41a5171edda7c4d9b4fa0f", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e67ab8e59cf1c558f2818625c7e06dbf7a8e50/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=40e67ab8e59cf1c558f2818625c7e06dbf7a8e50", "patch": "@@ -65,8 +65,11 @@ nested_function_info *\n nested_function_info::get_create (cgraph_node *node)\n {\n   if (!nested_function_sum)\n-    nested_function_sum = new function_summary <nested_function_info *>\n-\t\t\t\t (symtab);\n+    {\n+      nested_function_sum = new function_summary <nested_function_info *>\n+\t\t\t\t   (symtab);\n+      nested_function_sum->disable_insertion_hook ();\n+    }\n   return nested_function_sum->get_create (node);\n }\n \n@@ -124,6 +127,9 @@ nested_function_info::release ()\n void\n maybe_record_nested_function (cgraph_node *node)\n {\n+  /* All nested functions gets lowered during the construction of symtab.  */\n+  if (symtab->state > CONSTRUCTION)\n+    return;\n   if (DECL_CONTEXT (node->decl)\n       && TREE_CODE (DECL_CONTEXT (node->decl)) == FUNCTION_DECL)\n     {"}]}