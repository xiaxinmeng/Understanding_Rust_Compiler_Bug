{"sha": "02c808938e798d28c6d57d4f44904e2d065b80d0", "node_id": "C_kwDOANBUbNoAKDAyYzgwODkzOGU3OThkMjhjNmQ1N2Q0ZjQ0OTA0ZTJkMDY1YjgwZDA", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-03-02T09:25:25Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-03-02T09:25:25Z"}, "message": "modref: Comment spelling fixes\n\nThis fixes some spelling mistakes in ipa-modref*.\n\n2022-03-02  Jakub Jelinek  <jakub@redhat.com>\n\n\t* ipa-modref-tree.cc (modref_access_node::contains,\n\tmodref_access_node::closer_pair_p, modref_access_node::insert,\n\tmodref_access_node::insert_kill): Comment spelling fixes.\n\t* ipa-modref.cc: Likewise.\n\t(modref_summary::finalize, ignore_nondeterminism_p,\n\tclass modref_access_analysis,\n\tmodref_access_analysis::set_side_effects,\n\tmodref_access_analysis::set_nondeterministic,\n\tmodref_access_analysis::record_global_memory_load,\n\tmodref_access_analysis::propagate, modref_access_analysis::analyze,\n\tstruct escape_point, class modref_lattice, modref_lattice::merge,\n\tmodref_lattice::merge_deref, class modref_eaf_analysis,\n\tmodref_eaf_analysis::merge_call_lhs_flags,\n\tmodref_eaf_analysis::analyze_ssa_name, modref_eaf_analysis::propagate,\n\tmodref_eaf_analysis::record_escape_points, remap_kills,\n\tupdate_escape_summary, remove_useless_summaries,\n\tipa_merge_modref_summary_after_inlining, pass_ipa_modref::execute):\n\tLikewise.\n\t* ipa-modref.h (struct modref_summary, interposable_eaf_flags):\n\tLikewise.\n\t* ipa-modref-tree.h (enum modref_special_parms,\n\tstruct modref_access_node): Likewise.", "tree": {"sha": "7d217bee2a81a81d32da19a8df1da385904c1ff1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d217bee2a81a81d32da19a8df1da385904c1ff1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02c808938e798d28c6d57d4f44904e2d065b80d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02c808938e798d28c6d57d4f44904e2d065b80d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02c808938e798d28c6d57d4f44904e2d065b80d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02c808938e798d28c6d57d4f44904e2d065b80d0/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f1fa70db51f5356e308e757210d0e521a32e1b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f1fa70db51f5356e308e757210d0e521a32e1b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f1fa70db51f5356e308e757210d0e521a32e1b7"}], "stats": {"total": 108, "additions": 54, "deletions": 54}, "files": [{"sha": "d0ec2fbf004cf16fb8bc05cdb274f825a62ec6ef", "filename": "gcc/ipa-modref-tree.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02c808938e798d28c6d57d4f44904e2d065b80d0/gcc%2Fipa-modref-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02c808938e798d28c6d57d4f44904e2d065b80d0/gcc%2Fipa-modref-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.cc?ref=02c808938e798d28c6d57d4f44904e2d065b80d0", "patch": "@@ -71,13 +71,13 @@ modref_access_node::contains (const modref_access_node &a) const\n \t   /* Accesses are never below parm_offset, so look\n \t      for smaller offset.\n \t      If access ranges are known still allow merging\n-\t      when bit offsets comparsion passes.  */\n+\t      when bit offsets comparison passes.  */\n \t   if (!known_le (parm_offset, a.parm_offset)\n \t       && !range_info_useful_p ())\n \t     return false;\n \t   /* We allow negative aoffset_adj here in case\n \t      there is an useful range.  This is because adding\n-\t      a.offset may result in non-ngative offset again.\n+\t      a.offset may result in non-negative offset again.\n \t      Ubsan fails on val << LOG_BITS_PER_UNIT where val\n \t      is negative.  */\n \t   aoffset_adj = (a.parm_offset - parm_offset)\n@@ -89,7 +89,7 @@ modref_access_node::contains (const modref_access_node &a) const\n       if (!a.range_info_useful_p ())\n \treturn false;\n       /* Sizes of stores are used to check that object is big enough\n-\t to fit the store, so smaller or unknown sotre is more general\n+\t to fit the store, so smaller or unknown store is more general\n \t than large store.  */\n       if (known_size_p (size)\n \t  && (!known_size_p (a.size)\n@@ -266,7 +266,7 @@ modref_access_node::closer_pair_p (const modref_access_node &a1,\n     gcc_unreachable ();\n \n \n-  /* Now compute distnace of the intervals.  */\n+  /* Now compute distance of the intervals.  */\n   poly_int64 dist1, dist2;\n   if (known_le (offseta1, offsetb1))\n     {\n@@ -509,7 +509,7 @@ modref_access_node::stream_in (struct lto_input_block *ib)\n    If RECORD_ADJUSTMENTs is true avoid too many interval extensions.\n    Return true if record was changed.\n \n-   Reutrn 0 if nothing changed, 1 if insert was successful and -1\n+   Return 0 if nothing changed, 1 if insert was successful and -1\n    if entries should be collapsed.  */\n int\n modref_access_node::insert (vec <modref_access_node, va_gc> *&accesses,\n@@ -800,7 +800,7 @@ modref_access_node::insert_kill (vec<modref_access_node> &kills,\n   gcc_checking_assert (a.useful_for_kill_p ());\n \n   /* See if we have corresponding entry already or we can merge with\n-     neighbouring entry.  */\n+     neighboring entry.  */\n   FOR_EACH_VEC_ELT (kills, index, a2)\n     {\n       if (a2->contains_for_kills (a))"}, {"sha": "b788beed4775037a444e0d315b63b08fd1adf11d", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02c808938e798d28c6d57d4f44904e2d065b80d0/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02c808938e798d28c6d57d4f44904e2d065b80d0/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=02c808938e798d28c6d57d4f44904e2d065b80d0", "patch": "@@ -50,8 +50,8 @@ enum modref_special_parms {\n   MODREF_RETSLOT_PARM = -3,\n   /* Used for bases that points to memory that escapes from function.  */\n   MODREF_GLOBAL_MEMORY_PARM = -4,\n-  /* Used in modref_parm_map to tak references which can be removed\n-     from the summary during summary update since they now points to loca\n+  /* Used in modref_parm_map to take references which can be removed\n+     from the summary during summary update since they now points to local\n      memory.  */\n   MODREF_LOCAL_MEMORY_PARM = -5\n };\n@@ -101,15 +101,15 @@ struct GTY(()) modref_access_node\n   bool range_info_useful_p () const;\n   /* Return tree corresponding to parameter of the range in STMT.  */\n   tree get_call_arg (const gcall *stmt) const;\n-  /* Build ao_ref corresponding to the access and return true if succesful.  */\n+  /* Build ao_ref corresponding to the access and return true if successful.  */\n   bool get_ao_ref (const gcall *stmt, class ao_ref *ref) const;\n   /* Stream access to OB.  */\n   void stream_out (struct output_block *ob) const;\n   /* Stream access in from IB.  */\n   static modref_access_node stream_in (struct lto_input_block *ib);\n   /* Insert A into vector ACCESSES.  Limit size of vector to MAX_ACCESSES and\n      if RECORD_ADJUSTMENT is true keep track of adjustment counts.\n-     Return 0 if nothing changed, 1 is insertion suceeded and -1 if failed.  */\n+     Return 0 if nothing changed, 1 is insertion succeeded and -1 if failed.  */\n   static int insert (vec <modref_access_node, va_gc> *&accesses,\n \t\t     modref_access_node a, size_t max_accesses,\n \t\t     bool record_adjustments);\n@@ -173,7 +173,7 @@ struct GTY((user)) modref_ref_node\n     if (every_access)\n       return false;\n \n-    /* Only the following kind of paramters needs to be tracked.\n+    /* Only the following kind of parameters needs to be tracked.\n        We do not track return slots because they are seen as a direct store\n        in the caller.  */\n     gcc_checking_assert (a.parm_index >= 0"}, {"sha": "acfd7d80ff88c4c059c472fe7d5f57c621e8494b", "filename": "gcc/ipa-modref.cc", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02c808938e798d28c6d57d4f44904e2d065b80d0/gcc%2Fipa-modref.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02c808938e798d28c6d57d4f44904e2d065b80d0/gcc%2Fipa-modref.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.cc?ref=02c808938e798d28c6d57d4f44904e2d065b80d0", "patch": "@@ -37,7 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n    The following information is computed\n      1) load/store access tree described in ipa-modref-tree.h\n \tThis is used by tree-ssa-alias to disambiguate load/stores\n-     2) EAF flags used by points-to analysis (in tree-ssa-structlias).\n+     2) EAF flags used by points-to analysis (in tree-ssa-structalias).\n \tand defined in tree-core.h.\n    and stored to optimization_summaries.\n \n@@ -50,7 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n        necessary because gimple_call_fnspec performs additional\n        analysis except for looking callee fndecl.\n      - escape_summary holds escape points for given call edge.\n-       That is a vector recording what function parmaeters\n+       That is a vector recording what function parameters\n        may escape to a function call (and with what parameter index).  */\n \n #include \"config.h\"\n@@ -680,7 +680,7 @@ modref_summary::finalize (tree fun)\n   global_memory_written = !stores || stores->global_access_p ();\n \n   /* We can do DSE if we know function has no side effects and\n-     we can analyse all stores.  Disable dse if there are too many\n+     we can analyze all stores.  Disable dse if there are too many\n      stores to try.  */\n   if (side_effects || global_memory_written || writes_errno)\n     try_dse = false;\n@@ -788,7 +788,7 @@ get_modref_function_summary (gcall *call, bool *interposed)\n \n namespace {\n \n-/* Return true if ECF flags says that nondeterminsm can be ignored.  */\n+/* Return true if ECF flags says that nondeterminism can be ignored.  */\n \n static bool\n ignore_nondeterminism_p (tree caller, int flags)\n@@ -966,23 +966,23 @@ class modref_access_analysis\n   void propagate ();\n \n   /* Summary being computed.\n-     We work eitehr with m_summary or m_summary_lto.  Never on both.  */\n+     We work either with m_summary or m_summary_lto.  Never on both.  */\n   modref_summary *m_summary;\n   modref_summary_lto *m_summary_lto;\n-  /* Recursive calls needs simplisitc dataflow after analysis finished.\n+  /* Recursive calls needs simplistic dataflow after analysis finished.\n      Collect all calls into this vector during analysis and later process\n      them in propagate.  */\n   auto_vec <gimple *, 32> m_recursive_calls;\n-  /* ECF flags of function being analysed.  */\n+  /* ECF flags of function being analyzed.  */\n   int m_ecf_flags;\n   /* True if IPA propagation will be done later.  */\n   bool m_ipa;\n-  /* Set true if statement currently analysed is known to be\n+  /* Set true if statement currently analyze is known to be\n      executed each time function is called.  */\n   bool m_always_executed;\n };\n \n-/* Set side_effects flag and return if someting changed.  */\n+/* Set side_effects flag and return if something changed.  */\n \n bool\n modref_access_analysis::set_side_effects ()\n@@ -1002,7 +1002,7 @@ modref_access_analysis::set_side_effects ()\n   return changed;\n }\n \n-/* Set nondeterministic flag and return if someting changed.  */\n+/* Set nondeterministic flag and return if something changed.  */\n \n bool\n modref_access_analysis::set_nondeterministic ()\n@@ -1211,7 +1211,7 @@ modref_access_analysis::record_unknown_store ()\n   return changed;\n }\n \n-/* Record unknown load from gloal memory.  */\n+/* Record unknown load from global memory.  */\n \n bool\n modref_access_analysis::record_global_memory_load ()\n@@ -1228,7 +1228,7 @@ modref_access_analysis::record_global_memory_load ()\n   return changed;\n }\n \n-/* Record unknown store from gloal memory.  */\n+/* Record unknown store from global memory.  */\n \n bool\n modref_access_analysis::record_global_memory_store ()\n@@ -1838,7 +1838,7 @@ modref_access_analysis::analyze_stmt (gimple *stmt, bool always_executed)\n    }\n }\n \n-/* Propagate load/stres acress recursive calls.  */\n+/* Propagate load/stores across recursive calls.  */\n \n void\n modref_access_analysis::propagate ()\n@@ -1885,7 +1885,7 @@ modref_access_analysis::analyze ()\n \t   !gsi_end_p (si); gsi_next_nondebug (&si))\n \t{\n \t  /* NULL memory accesses terminates BB.  These accesses are known\n-\t     to trip undefined behaviour.  gimple-ssa-isolate-paths turns them\n+\t     to trip undefined behavior.  gimple-ssa-isolate-paths turns them\n \t     to volatile accesses and adds builtin_trap call which would\n \t     confuse us otherwise.  */\n \t  if (infer_nonnull_range_by_dereference (gsi_stmt (si),\n@@ -1899,7 +1899,7 @@ modref_access_analysis::analyze ()\n \t    }\n \t  analyze_stmt (gsi_stmt (si), always_executed);\n \n-\t  /* Avoid doing useles work.  */\n+\t  /* Avoid doing useless work.  */\n \t  if ((!m_summary || !m_summary->useful_p (m_ecf_flags, false))\n \t      && (!m_summary_lto\n \t\t  || !m_summary_lto->useful_p (m_ecf_flags, false)))\n@@ -1914,7 +1914,7 @@ modref_access_analysis::analyze ()\n       if (!summary_useful)\n \tbreak;\n     }\n-  /* In non-IPA mode we need to perform iterative datafow on recursive calls.\n+  /* In non-IPA mode we need to perform iterative dataflow on recursive calls.\n      This needs to be done after all other side effects are computed.  */\n   if (summary_useful)\n     {\n@@ -1990,13 +1990,13 @@ struct escape_point\n   /* Argument it escapes to.  */\n   int arg;\n   /* Flags already known about the argument (this can save us from recording\n-     esape points if local analysis did good job already).  */\n+     escape points if local analysis did good job already).  */\n   eaf_flags_t min_flags;\n-  /* Does value escape directly or indiretly?  */\n+  /* Does value escape directly or indirectly?  */\n   bool direct;\n };\n \n-/* Lattice used during the eaf flags analsysis dataflow.  For a given SSA name\n+/* Lattice used during the eaf flags analysis dataflow.  For a given SSA name\n    we aim to compute its flags and escape points.  We also use the lattice\n    to dynamically build dataflow graph to propagate on.  */\n \n@@ -2019,7 +2019,7 @@ class modref_lattice\n      Only remember them and do the merging at IPA propagation time.  */\n   vec <escape_point, va_heap, vl_ptr> escape_points;\n \n-  /* Representation of a graph for dataaflow.  This graph is built on-demand\n+  /* Representation of a graph for dataflow.  This graph is built on-demand\n      using modref_eaf_analysis::analyze_ssa and later solved by\n      modref_eaf_analysis::propagate.\n      Each edge represents the fact that flags of current lattice should be\n@@ -2140,7 +2140,7 @@ modref_lattice::merge (int f)\n   if ((flags & f) != flags)\n     {\n       flags &= f;\n-      /* Prune obvoiusly useless flags;\n+      /* Prune obviously useless flags;\n \t We do not have ECF_FLAGS handy which is not big problem since\n \t we will do final flags cleanup before producing summary.\n \t Merging should be fast so it can work well with dataflow.  */\n@@ -2152,7 +2152,7 @@ modref_lattice::merge (int f)\n   return false;\n }\n \n-/* Merge in WITH.  Return true if anyting changed.  */\n+/* Merge in WITH.  Return true if anything changed.  */\n \n bool\n modref_lattice::merge (const modref_lattice &with)\n@@ -2173,7 +2173,7 @@ modref_lattice::merge (const modref_lattice &with)\n }\n \n /* Merge in deref of WITH.  If IGNORE_STORES is true do not consider\n-   stores.  Return true if anyting changed.  */\n+   stores.  Return true if anything changed.  */\n \n bool\n modref_lattice::merge_deref (const modref_lattice &with, bool ignore_stores)\n@@ -2218,12 +2218,12 @@ modref_lattice::merge_direct_store ()\n }\n \n /* Analyzer of EAF flags.\n-   This is genrally dataflow problem over the SSA graph, however we only\n+   This is generally dataflow problem over the SSA graph, however we only\n    care about flags of few selected ssa names (arguments, return slot and\n    static chain).  So we first call analyze_ssa_name on all relevant names\n    and perform a DFS walk to discover SSA names where flags needs to be\n    determined.  For acyclic graphs we try to determine final flags during\n-   this walk.  Once cycles or recursin depth is met we enlist SSA names\n+   this walk.  Once cycles or recursion depth is met we enlist SSA names\n    for dataflow which is done by propagate call.\n \n    After propagation the flags can be obtained using get_ssa_name_flags.  */\n@@ -2233,7 +2233,7 @@ class modref_eaf_analysis\n public:\n   /* Mark NAME as relevant for analysis.  */\n   void analyze_ssa_name (tree name, bool deferred = false);\n-  /* Dataflow slover.  */\n+  /* Dataflow solver.  */\n   void propagate ();\n   /* Return flags computed earlier for NAME.  */\n   int get_ssa_name_flags (tree name)\n@@ -2260,7 +2260,7 @@ class modref_eaf_analysis\n \tm_lattice[i].release ();\n   }\n private:\n-  /* If true, we produce analysis for IPA mode.  In this case escape points ar\n+  /* If true, we produce analysis for IPA mode.  In this case escape points are\n      collected.  */\n   bool m_ipa;\n   /* Depth of recursion of analyze_ssa_name.  */\n@@ -2276,7 +2276,7 @@ class modref_eaf_analysis\n };\n \n \n-/* Call statements may return tgeir parameters.  Consider argument number\n+/* Call statements may return their parameters.  Consider argument number\n    ARG of USE_STMT and determine flags that can needs to be cleared\n    in case pointer possibly indirectly references from ARG I is returned.\n    If DIRECT is true consider direct returns and if INDIRECT consider\n@@ -2425,7 +2425,7 @@ modref_eaf_analysis::analyze_ssa_name (tree name, bool deferred)\n \t  print_gimple_stmt (dump_file, use_stmt, 0);\n \t}\n       /* If we see a direct non-debug use, clear unused bit.\n-\t All dereferneces should be accounted below using deref_flags.  */\n+\t All dereferences should be accounted below using deref_flags.  */\n       m_lattice[index].merge (~EAF_UNUSED);\n \n       /* Gimple return may load the return value.\n@@ -2499,7 +2499,7 @@ modref_eaf_analysis::analyze_ssa_name (tree name, bool deferred)\n \t\t\t the callee's return slot is returned it means that\n \t\t\t arg is written to itself which is an escape.\n \t\t\t Since we do not track the memory it is written to we\n-\t\t\t need to give up on analysisng it.  */\n+\t\t\t need to give up on analyzing it.  */\n \t\t      if (!isretslot)\n \t\t\t{\n \t\t\t  if (!(call_flags & (EAF_NOT_RETURNED_DIRECTLY\n@@ -2768,7 +2768,7 @@ modref_eaf_analysis::propagate ()\n   rpo.safe_grow (m_names_to_propagate.length (), true);\n   stack.reserve_exact (m_names_to_propagate.length ());\n \n-  /* We reuse known flag for RPO DFS walk bookeeping.  */\n+  /* We reuse known flag for RPO DFS walk bookkeeping.  */\n   if (flag_checking)\n     FOR_EACH_VEC_ELT (m_names_to_propagate, i, index)\n       gcc_assert (!m_lattice[index].known && m_lattice[index].changed);\n@@ -2813,7 +2813,7 @@ modref_eaf_analysis::propagate ()\n \t}\n     }\n \n-  /* Perform itrative dataflow.  */\n+  /* Perform iterative dataflow.  */\n   while (changed)\n     {\n       changed = false;\n@@ -2890,9 +2890,9 @@ modref_eaf_analysis::record_escape_points (tree name, int parm_index, int flags)\n \n /* Determine EAF flags for function parameters\n    and fill in SUMMARY/SUMMARY_LTO.  If IPA is true work in IPA mode\n-   where we also collect scape points.\n+   where we also collect escape points.\n    PAST_FLAGS, PAST_RETSLOT_FLAGS, PAST_STATIC_CHAIN_FLAGS can be\n-   used to preserve flags from prevoius (IPA) run for cases where\n+   used to preserve flags from previous (IPA) run for cases where\n    late optimizations changed code in a way we can no longer analyze\n    it easily.  */\n \n@@ -4043,7 +4043,7 @@ remap_arg_flags (auto_vec <eaf_flags_t> &arg_flags, clone_info *info)\n     }\n }\n \n-/* Update kills accrdoing to the parm map MAP.  */\n+/* Update kills according to the parm map MAP.  */\n \n static void\n remap_kills (vec <modref_access_node> &kills, const vec <int> &map)\n@@ -4359,7 +4359,7 @@ update_escape_summary_1 (cgraph_edge *e,\n     escape_summaries->remove (e);\n }\n \n-/* Update escape map fo NODE.  */\n+/* Update escape map for NODE.  */\n \n static void\n update_escape_summary (cgraph_node *node,\n@@ -4632,7 +4632,7 @@ propagate_unknown_call (cgraph_node *node,\n   return changed;\n }\n \n-/* Maybe remove summaies of NODE pointed to by CUR_SUMMARY_PTR\n+/* Maybe remove summaries of NODE pointed to by CUR_SUMMARY_PTR\n    and CUR_SUMMARY_LTO_PTR if they are useless according to ECF_FLAGS.  */\n \n static void\n@@ -5311,8 +5311,8 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n     }\n \n   /* Now merge escape summaries.\n-     For every escape to the callee we need to merge calle flags\n-     and remap calees escapes.  */\n+     For every escape to the callee we need to merge callee flags\n+     and remap callee's escapes.  */\n   class escape_summary *sum = escape_summaries->get (edge);\n   int max_escape = -1;\n   escape_entry *ee;\n@@ -5482,7 +5482,7 @@ pass_ipa_modref::execute (function *)\n   delete escape_summaries;\n   escape_summaries = NULL;\n \n-  /* If we posibly made constructors const/pure we may need to remove\n+  /* If we possibly made constructors const/pure we may need to remove\n      them.  */\n   return pureconst ? TODO_remove_functions : 0;\n }"}, {"sha": "19114bcb4291395cad4609b4ab70f7a881b7c4fc", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02c808938e798d28c6d57d4f44904e2d065b80d0/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02c808938e798d28c6d57d4f44904e2d065b80d0/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=02c808938e798d28c6d57d4f44904e2d065b80d0", "patch": "@@ -51,7 +51,7 @@ struct GTY(()) modref_summary\n      it is still useful for CSE.  */\n   unsigned calls_interposable : 1;\n \n-  /* Flags coputed by finalize method.  */\n+  /* Flags computed by finalize method.  */\n \n   /* Total number of accesses in loads tree.  */\n   unsigned int load_accesses;\n@@ -101,7 +101,7 @@ static const int implicit_retslot_eaf_flags\n      | EAF_NOT_RETURNED_INDIRECTLY;\n \n /* If function does not bind to current def (i.e. it is inline in comdat\n-   section), the modref analysis may not match the behaviour of function\n+   section), the modref analysis may not match the behavior of function\n    which will be later symbol interposed to.  All side effects must match\n    however it is possible that the other function body contains more loads\n    which may trap.\n@@ -120,7 +120,7 @@ interposable_eaf_flags (int modref_flags, int flags)\n \t\t      | EAF_NOT_RETURNED_DIRECTLY | EAF_NOT_RETURNED_INDIRECTLY\n \t\t      | EAF_NO_DIRECT_CLOBBER | EAF_NO_INDIRECT_CLOBBER;\n     }\n-  /* We can not deterine that value is not read at all.  */\n+  /* We can not determine that value is not read at all.  */\n   if ((modref_flags & EAF_NO_DIRECT_READ) && !(flags & EAF_NO_DIRECT_READ))\n     modref_flags &= ~EAF_NO_DIRECT_READ;\n   if ((modref_flags & EAF_NO_INDIRECT_READ) && !(flags & EAF_NO_INDIRECT_READ))"}]}