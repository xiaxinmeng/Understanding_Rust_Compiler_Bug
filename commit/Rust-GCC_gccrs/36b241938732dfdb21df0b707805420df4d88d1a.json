{"sha": "36b241938732dfdb21df0b707805420df4d88d1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZiMjQxOTM4NzMyZGZkYjIxZGYwYjcwNzgwNTQyMGRmNGQ4OGQxYQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-09-22T10:02:47Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-09-22T10:02:47Z"}, "message": "re PR tree-optimization/28888 (ICE in tree check: expected cond_expr, have label_expr in simplify_using_initial_conditions, at tree-ssa-loop-niter.c)\n\n\tPR tree-optimization/28888\n\t* tree-if-conv.c (combine_blocks): Rewritten.\n\t* tree-cfg.c (tree_verify_flow_info): Check that edges with\n\tEDGE_TRUE/FALSE_VALUE follow COND_EXPR.\n\n\t* gcc.dg/pr28888.c: New test.\n\nFrom-SVN: r117135", "tree": {"sha": "a53cb50ab23e9f4afc3a543ca0bdbc9e862012bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a53cb50ab23e9f4afc3a543ca0bdbc9e862012bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36b241938732dfdb21df0b707805420df4d88d1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36b241938732dfdb21df0b707805420df4d88d1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36b241938732dfdb21df0b707805420df4d88d1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36b241938732dfdb21df0b707805420df4d88d1a/comments", "author": null, "committer": null, "parents": [{"sha": "3735874658495316376a6d215904c62535e2979c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3735874658495316376a6d215904c62535e2979c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3735874658495316376a6d215904c62535e2979c"}], "stats": {"total": 170, "additions": 106, "deletions": 64}, "files": [{"sha": "311f26bd42732f87eec689963edc3c265a72a59d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36b241938732dfdb21df0b707805420df4d88d1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36b241938732dfdb21df0b707805420df4d88d1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36b241938732dfdb21df0b707805420df4d88d1a", "patch": "@@ -1,3 +1,10 @@\n+2006-09-22  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/28888\n+\t* tree-if-conv.c (combine_blocks): Rewritten.\n+\t* tree-cfg.c (tree_verify_flow_info): Check that edges with\n+\tEDGE_TRUE/FALSE_VALUE follow COND_EXPR.\n+\n 2006-09-22  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-ssa-propagate.c (set_rhs): Copy EXPR_LOCATION if"}, {"sha": "a560131e2a63f8360dc38661ce7ece842cced050", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36b241938732dfdb21df0b707805420df4d88d1a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36b241938732dfdb21df0b707805420df4d88d1a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=36b241938732dfdb21df0b707805420df4d88d1a", "patch": "@@ -1,19 +1,24 @@\n+2006-09-22  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/28888\n+\t* gcc.dg/pr28888.c: New test.\n+\n 2006-09-21  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/29016\n \t* g++.dg/init/ptrfn1.C: New test.\n \n 2006-09-21  Lee Millward  <lee.millward@codesourcery.com>\n \n-        PR c++/28861\n-        * g++.dg/template/spec32.C: New test.\n-        * g++.dg/parse/crash9.C: Adjust error markers.\n+\tPR c++/28861\n+\t* g++.dg/template/spec32.C: New test.\n+\t* g++.dg/parse/crash9.C: Adjust error markers.\n \n \tPR c++/28303\n-        * g++.dg/template/typedef6.C: New test.\n-        * g++.dg/init/error1.C: Adjust error markers.\n-        * g++.dg/parse/crash9.C: Likewise.\n-        * g++.dg/template/crash55.C: Likewise.\n+\t* g++.dg/template/typedef6.C: New test.\n+\t* g++.dg/init/error1.C: Adjust error markers.\n+\t* g++.dg/parse/crash9.C: Likewise.\n+\t* g++.dg/template/crash55.C: Likewise.\n \t\n 2006-09-21  Janis Johnson  <janis187@us.ibm.com>\n "}, {"sha": "c65a26a08748aeac548716912699494f8f86f26a", "filename": "gcc/testsuite/gcc.dg/pr28888.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36b241938732dfdb21df0b707805420df4d88d1a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28888.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36b241938732dfdb21df0b707805420df4d88d1a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28888.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28888.c?ref=36b241938732dfdb21df0b707805420df4d88d1a", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+static const unsigned char _c30[] =\n+  \"statistic of allocated integer registers:\";\n+Allocate__WriteStats (void)\n+{\n+  register int i0, i1, i2, i3, i4, i5;\n+l0:i1 = (int) (i5 << 2);\n+  if (i0)\n+  i4 = i5;\n+l1:i2 += i1;\n+  if (i1)\n+  goto l0;\n+l3:i0 = i1 == 255;\n+  i1++;\n+  Out__LongInt ((int) i0, (int) 0);\n+  i0 = i4 >= i1;\n+  if (i0)\n+    goto l3;\n+}"}, {"sha": "67d049130e802f4cc91fe8db6ce782a880b8c078", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36b241938732dfdb21df0b707805420df4d88d1a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36b241938732dfdb21df0b707805420df4d88d1a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=36b241938732dfdb21df0b707805420df4d88d1a", "patch": "@@ -3757,6 +3757,19 @@ tree_verify_flow_info (void)\n \t      }\n \t}\n \n+      if (TREE_CODE (stmt) != COND_EXPR)\n+\t{\n+\t  /* Verify that there are no edges with EDGE_TRUE/FALSE_FLAG set\n+\t     after anything else but if statement.  */\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    if (e->flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE))\n+\t      {\n+\t\terror (\"true/false edge after a non-COND_EXPR in bb %d\",\n+\t\t       bb->index);\n+\t\terr = 1;\n+\t      }\n+\t}\n+\n       switch (TREE_CODE (stmt))\n \t{\n \tcase COND_EXPR:"}, {"sha": "3a50741aff528b88d123d93cff04dd83441d5c7b", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 53, "deletions": 57, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36b241938732dfdb21df0b707805420df4d88d1a/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36b241938732dfdb21df0b707805420df4d88d1a/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=36b241938732dfdb21df0b707805420df4d88d1a", "patch": "@@ -866,71 +866,73 @@ combine_blocks (struct loop *loop)\n   basic_block bb, exit_bb, merge_target_bb;\n   unsigned int orig_loop_num_nodes = loop->num_nodes;\n   unsigned int i;\n-  unsigned int n_exits;\n-  edge *exits;\n+  edge e;\n+  edge_iterator ei;\n \n-  exits = get_loop_exit_edges (loop, &n_exits);\n-  free (exits);\n   /* Process phi nodes to prepare blocks for merge.  */\n   process_phi_nodes (loop);\n \n+  /* Merge basic blocks.  First remove all the edges in the loop, except\n+     for those from the exit block.  */\n   exit_bb = NULL;\n+  for (i = 0; i < orig_loop_num_nodes; i++)\n+    {\n+      bb = ifc_bbs[i];\n+      if (bb_with_exit_edge_p (loop, bb))\n+\t{\n+\t  exit_bb = bb;\n+\t  break;\n+\t}\n+    }\n+  gcc_assert (exit_bb != loop->latch);\n \n-  /* Merge basic blocks */\n-  merge_target_bb = loop->header;\n   for (i = 1; i < orig_loop_num_nodes; i++)\n     {\n-      edge e;\n-      block_stmt_iterator bsi;\n-      tree_stmt_iterator last;\n-\n       bb = ifc_bbs[i];\n \n-      if (!exit_bb && bb_with_exit_edge_p (loop, bb))\n-\t  exit_bb = bb;\n-\n-      if (bb == exit_bb)\n+      for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei));)\n \t{\n-\t  edge_iterator ei;\n+\t  if (e->src == exit_bb)\n+\t    ei_next (&ei);\n+\t  else\n+\t    remove_edge (e);\n+\t}\n+    }\n \n+  if (exit_bb != NULL)\n+    {\n+      if (exit_bb != loop->header)\n+\t{\n \t  /* Connect this node with loop header.  */\n-\t  make_edge (ifc_bbs[0], bb, EDGE_FALLTHRU);\n-\t  set_immediate_dominator (CDI_DOMINATORS, bb, ifc_bbs[0]);\n-\n-\t  if (exit_bb != loop->latch)\n-\t    {\n-\t      /* Redirect non-exit edge to loop->latch.  */\n-\t      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t\t{\n-\t\t  if (!loop_exit_edge_p (loop, e))\n-\t\t    {\n-\t\t      redirect_edge_and_branch (e, loop->latch);\n-\t\t      set_immediate_dominator (CDI_DOMINATORS, loop->latch, bb);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  continue;\n+\t  make_edge (loop->header, exit_bb, EDGE_FALLTHRU);\n+\t  set_immediate_dominator (CDI_DOMINATORS, exit_bb, loop->header);\n \t}\n \n-      if (bb == loop->latch && empty_block_p (bb))\n-\tcontinue;\n+      /* Redirect non-exit edges to loop->latch.  */\n+      FOR_EACH_EDGE (e, ei, exit_bb->succs)\n+\t{\n+\t  if (!loop_exit_edge_p (loop, e))\n+\t    redirect_edge_and_branch (e, loop->latch);\n+\t}\n+      set_immediate_dominator (CDI_DOMINATORS, loop->latch, exit_bb);\n+    }\n+  else\n+    {\n+      /* If the loop does not have exit then reconnect header and latch.  */\n+      make_edge (loop->header, loop->latch, EDGE_FALLTHRU);\n+      set_immediate_dominator (CDI_DOMINATORS, loop->latch, loop->header);\n+    }\n \n-      /* It is time to remove this basic block.\t First remove edges.  */\n-      while (EDGE_COUNT (bb->preds) > 0)\n-\tremove_edge (EDGE_PRED (bb, 0));\n+  merge_target_bb = loop->header;\n+  for (i = 1; i < orig_loop_num_nodes; i++)\n+    {\n+      block_stmt_iterator bsi;\n+      tree_stmt_iterator last;\n \n-      /* This is loop latch and loop does not have exit then do not\n- \t delete this basic block. Just remove its PREDS and reconnect \n- \t loop->header and loop->latch blocks.  */\n-      if (bb == loop->latch && n_exits == 0)\n- \t{\n- \t  make_edge (loop->header, loop->latch, EDGE_FALLTHRU);\n- \t  set_immediate_dominator (CDI_DOMINATORS, loop->latch, loop->header);\n-\t  continue;\n- \t}\n+      bb = ifc_bbs[i];\n \n-      while (EDGE_COUNT (bb->succs) > 0)\n-\tremove_edge (EDGE_SUCC (bb, 0));\n+      if (bb == exit_bb || bb == loop->latch)\n+\tcontinue;\n \n       /* Remove labels and make stmts member of loop->header.  */\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); )\n@@ -956,8 +958,6 @@ combine_blocks (struct loop *loop)\n \tdelete_from_dominance_info (CDI_POST_DOMINATORS, bb);\n \n       /* Remove basic block.  */\n-      if (bb == loop->latch)\n-\tloop->latch = merge_target_bb;\n       remove_bb_from_loops (bb);\n       expunge_block (bb);\n     }\n@@ -966,15 +966,11 @@ combine_blocks (struct loop *loop)\n      This reduces number of basic blocks to 2. Auto vectorizer addresses\n      loops with two nodes only.  FIXME: Use cleanup_tree_cfg().  */\n   if (exit_bb\n-      && loop->header != loop->latch\n-      && exit_bb != loop->latch \n-      && empty_block_p (loop->latch))\n+      && exit_bb != loop->header\n+      && can_merge_blocks_p (loop->header, exit_bb))\n     {\n-      if (can_merge_blocks_p (loop->header, exit_bb))\n-\t{\n-\t  remove_bb_from_loops (exit_bb);\n-\t  merge_blocks (loop->header, exit_bb);\n-\t}\n+      remove_bb_from_loops (exit_bb);\n+      merge_blocks (loop->header, exit_bb);\n     }\n }\n "}]}