{"sha": "dc192bbdd0442f75e324cc82a98e611b7912e2f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMxOTJiYmRkMDQ0MmY3NWUzMjRjYzgyYTk4ZTYxMWI3OTEyZTJmOQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-02-26T13:28:07Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-02-26T20:42:42Z"}, "message": "coroutines: Amend parameter handling to match n4849.\n\nIn n4849 and preceding versions, [class.copy.elision] (1.3)\nappears to confer additional permissions on coroutines to elide\nparameter copies.\n\nAfter considerable discussion on this topic by email and during\nthe February 2020 WG21 meeting, it has been determined that there\nare no additional permissions applicable to coroutine parameter\ncopy elision.\n\nThe content of that clause in the standard is expected to be amended\neventually to clarify this.  Other than this, the handling of\nparameter lifetimes is expected to be as per n4849:\n\n * A copy is made before the promise is constructed\n * If the promise CTOR uses the parms, then it should use the copy\n   where appropriate.\n * The param copy lifetimes end after the promise is destroyed\n   (during the coroutine frame destruction).\n * Otherwise, C++20 copy elision rules apply.\n\n(as an aside) In practice, we expect that copy elision can only occur\nwhen the coroutine body is fully inlined, possibly in conjunction with\nheap allocation elision.\n\nThe patch:\n * Reorders the copying process to precede the promise CTOR and\n    ensures the correct use.\n * Copies all params into the frame regardless of whether the coro\n   body uses them (this is a bit unfortunate, and we should figure\n   out an amendment for C++23).\n\ngcc/cp/ChangeLog:\n\n2020-02-26  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* class.c (classtype_has_non_deleted_copy_ctor): New.\n\t* coroutines.cc (struct param_info): Keep track of params\n\tthat are references, and cache the original type and whether\n\tthe DTOR is trivial.\n\t(build_actor_fn): Handle param copies always, and adjust the\n\thandling for references.\n\t(register_param_uses): Only handle uses here.\n\t(classtype_has_non_deleted_copy_ctor): New.\n\t(morph_fn_to_coro): Adjust param copy handling to match n4849\n\tby reordering ahead of the promise CTOR and always making a\n\tframe copy, even if the param is unused in the coroutine body.\n\t* cp-tree.h (classtype_has_non_deleted_copy_ctor): New.\n\ngcc/testsuite/ChangeLog:\n\n2020-02-26  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* g++.dg/coroutines/coro1-refs-and-ctors.h: New.\n\t* g++.dg/coroutines/torture/func-params-07.C: New test.\n\t* g++.dg/coroutines/torture/func-params-08.C: New test.", "tree": {"sha": "83e8b11aec1912dbdf853b717a3409cb3c15fead", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83e8b11aec1912dbdf853b717a3409cb3c15fead"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc192bbdd0442f75e324cc82a98e611b7912e2f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc192bbdd0442f75e324cc82a98e611b7912e2f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc192bbdd0442f75e324cc82a98e611b7912e2f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc192bbdd0442f75e324cc82a98e611b7912e2f9/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5decc83e4eb06103c801fd4f8215301ce746109", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5decc83e4eb06103c801fd4f8215301ce746109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5decc83e4eb06103c801fd4f8215301ce746109"}], "stats": {"total": 683, "additions": 554, "deletions": 129}, "files": [{"sha": "051e415abeefd638b6c82d51b62f72f461c3161e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc192bbdd0442f75e324cc82a98e611b7912e2f9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc192bbdd0442f75e324cc82a98e611b7912e2f9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dc192bbdd0442f75e324cc82a98e611b7912e2f9", "patch": "@@ -1,3 +1,18 @@\n+2020-02-26  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* class.c (classtype_has_non_deleted_copy_ctor): New.\n+\t* coroutines.cc (struct param_info): Keep track of params\n+\tthat are references, and cache the original type and whether\n+\tthe DTOR is trivial.\n+\t(build_actor_fn): Handle param copies always, and adjust the\n+\thandling for references.\n+\t(register_param_uses): Only handle uses here.\n+\t(classtype_has_non_deleted_copy_ctor): New.\n+\t(morph_fn_to_coro): Adjust param copy handling to match n4849\n+\tby reordering ahead of the promise CTOR and always making a\n+\tframe copy, even if the param is unused in the coroutine body.\n+\t* cp-tree.h (classtype_has_non_deleted_copy_ctor): New.\n+\n 2020-02-26  Patrick Palka  <ppalka@redhat.com>\n \n \t* constraint.cc (finish_constraint_binary_op): Set expr's location range"}, {"sha": "6b779da0495381271c091dfc502b8fa2ba0655ed", "filename": "gcc/cp/class.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc192bbdd0442f75e324cc82a98e611b7912e2f9/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc192bbdd0442f75e324cc82a98e611b7912e2f9/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=dc192bbdd0442f75e324cc82a98e611b7912e2f9", "patch": "@@ -5447,6 +5447,19 @@ classtype_has_non_deleted_move_ctor (tree t)\n   return false;\n }\n \n+/* True iff T has a copy constructor that is not deleted.  */\n+\n+bool\n+classtype_has_non_deleted_copy_ctor (tree t)\n+{\n+  if (CLASSTYPE_LAZY_COPY_CTOR (t))\n+    lazily_declare_fn (sfk_copy_constructor, t);\n+  for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n+    if (copy_fn_p (*iter) && !DECL_DELETED_FN (*iter))\n+      return true;\n+  return false;\n+}\n+\n /* If T, a class, has a user-provided copy constructor, copy assignment\n    operator, or destructor, returns that function.  Otherwise, null.  */\n "}, {"sha": "ffc33aa1534ebadaf06e4109dc4ad6e24734f5b4", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 182, "deletions": 129, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc192bbdd0442f75e324cc82a98e611b7912e2f9/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc192bbdd0442f75e324cc82a98e611b7912e2f9/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=dc192bbdd0442f75e324cc82a98e611b7912e2f9", "patch": "@@ -1737,11 +1737,19 @@ transform_await_wrapper (tree *stmt, int *do_subtree, void *d)\n   return NULL_TREE;\n }\n \n+/* This caches information that we determine about function params,\n+   their uses and copies in the coroutine frame.  */\n+\n struct param_info\n {\n-  tree field_id;\n-  vec<tree *> *body_uses;\n-  tree frame_type;\n+  tree field_id;  /* The name of the copy in the coroutine frame.  */\n+  vec<tree *> *body_uses; /* Worklist of uses, void if there are none.  */\n+  tree frame_type; /* The type used to represent this parm in the frame.  */\n+  tree orig_type;  /* The original type of the parm (not as passed).  */\n+  bool by_ref;  /* Was passed by reference.  */\n+  bool rv_ref;  /* Was an rvalue reference.  */\n+  bool pt_ref;  /* Was a pointer to object.  */\n+  bool trivial_dtor; /* The frame type has a trivial DTOR.  */\n };\n \n struct local_var_info\n@@ -1941,26 +1949,37 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n \n   /* Re-write param references in the body, no code should be generated\n      here.  */\n-  if (DECL_ARGUMENTS (orig) && param_uses != NULL)\n+  if (DECL_ARGUMENTS (orig))\n     {\n       tree arg;\n       for (arg = DECL_ARGUMENTS (orig); arg != NULL; arg = DECL_CHAIN (arg))\n \t{\n \t  bool existed;\n \t  param_info &parm = param_uses->get_or_insert (arg, &existed);\n-\t  if (parm.field_id == NULL_TREE)\n-\t    continue; /* Wasn't used.  */\n+\t  if (!parm.body_uses)\n+\t    continue; /* Wasn't used in the orignal function body.  */\n+\n \t  tree fld_ref = lookup_member (coro_frame_type, parm.field_id,\n \t\t\t\t\t/*protect=*/1, /*want_type=*/0,\n \t\t\t\t\ttf_warning_or_error);\n-\t  tree fld_idx = build3_loc (loc, COMPONENT_REF, TREE_TYPE (arg),\n+\t  tree fld_idx = build3_loc (loc, COMPONENT_REF, parm.frame_type,\n \t\t\t\t     actor_frame, fld_ref, NULL_TREE);\n+\n+\t  /* We keep these in the frame as a regular pointer, so convert that\n+\t   back to the type expected.  */\n+\t  if (parm.pt_ref)\n+\t    fld_idx = build1_loc (loc, CONVERT_EXPR, TREE_TYPE (arg), fld_idx);\n+\n+\t  /* We expect an rvalue ref. here.  */\n+\t  if (parm.rv_ref)\n+\t    fld_idx = convert_to_reference (DECL_ARG_TYPE (arg), fld_idx,\n+\t\t\t\t\t    CONV_STATIC, LOOKUP_NORMAL,\n+\t\t\t\t\t    NULL_TREE, tf_warning_or_error);\n+\n \t  int i;\n \t  tree *puse;\n \t  FOR_EACH_VEC_ELT (*parm.body_uses, i, puse)\n-\t    {\n-\t      *puse = fld_idx;\n-\t    }\n+\t    *puse = fld_idx;\n \t}\n     }\n \n@@ -2837,27 +2856,8 @@ register_param_uses (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n   param_info &parm = data->param_uses->get_or_insert (*stmt, &existed);\n   gcc_checking_assert (existed);\n \n-  if (parm.field_id == NULL_TREE)\n+  if (!parm.body_uses)\n     {\n-      tree actual_type = TREE_TYPE (*stmt);\n-\n-      if (!COMPLETE_TYPE_P (actual_type))\n-\tactual_type = complete_type_or_else (actual_type, *stmt);\n-\n-      if (actual_type == NULL_TREE)\n-\t/* Diagnostic emitted by complete_type_or_else.  */\n-\tactual_type = error_mark_node;\n-\n-      if (TREE_CODE (actual_type) == REFERENCE_TYPE)\n-\tactual_type = build_pointer_type (TREE_TYPE (actual_type));\n-\n-      parm.frame_type = actual_type;\n-      tree pname = DECL_NAME (*stmt);\n-      size_t namsize = sizeof (\"__parm.\") + IDENTIFIER_LENGTH (pname) + 1;\n-      char *buf = (char *) alloca (namsize);\n-      snprintf (buf, namsize, \"__parm.%s\", IDENTIFIER_POINTER (pname));\n-      parm.field_id\n-\t= coro_make_frame_entry (data->field_list, buf, actual_type, data->loc);\n       vec_alloc (parm.body_uses, 4);\n       parm.body_uses->quick_push (stmt);\n       data->param_seen = true;\n@@ -2993,11 +2993,13 @@ act_des_fn (tree orig, tree fn_type, tree coro_frame_ptr, const char* name)\n   coro1::promise_type __p;\n   bool frame_needs_free; free the coro frame mem if set.\n   short __resume_at;\n+  handle_type self_handle;\n+  (maybe) parameter copies.\n+  (maybe) lambda capture copies.\n   coro1::suspend_never_prt __is;\n   (maybe) handle_type i_hand;\n   coro1::suspend_always_prt __fs;\n   (maybe) handle_type f_hand;\n-  (maybe) parameters used in the body.\n   (maybe) local variables saved\n   (maybe) trailing space.\n  };  */\n@@ -3120,6 +3122,77 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n      await_suspend().  There's no point in creating it over and over.  */\n   (void) coro_make_frame_entry (&field_list, \"__self_h\", handle_type, fn_start);\n \n+  /* Now add in fields for function params (if there are any).\n+     We do not attempt elision of copies at this stage, we do analyse the\n+     uses and build worklists to replace those when the state machine is\n+     lowered.  */\n+\n+  hash_map<tree, param_info> *param_uses = NULL;\n+  if (DECL_ARGUMENTS (orig))\n+    {\n+      /* Build a hash map with an entry for each param.\n+\t  The key is the param tree.\n+\t  Then we have an entry for the frame field name.\n+\t  Then a cache for the field ref when we come to use it.\n+\t  Then a tree list of the uses.\n+\t  The second two entries start out empty - and only get populated\n+\t  when we see uses.  */\n+      param_uses = new hash_map<tree, param_info>;\n+\n+      for (tree arg = DECL_ARGUMENTS (orig); arg != NULL;\n+\t   arg = DECL_CHAIN (arg))\n+\t{\n+\t  bool existed;\n+\t  param_info &parm = param_uses->get_or_insert (arg, &existed);\n+\t  gcc_checking_assert (!existed);\n+\t  parm.body_uses = NULL;\n+\t  tree actual_type = TREE_TYPE (arg);\n+\t  actual_type = complete_type_or_else (actual_type, orig);\n+\t  if (actual_type == NULL_TREE)\n+\t    actual_type = error_mark_node;\n+\t  parm.orig_type = actual_type;\n+\t  parm.by_ref = parm.rv_ref = parm.pt_ref = false;\n+\t  if (TREE_CODE (actual_type) == REFERENCE_TYPE\n+\t      && TYPE_REF_IS_RVALUE (DECL_ARG_TYPE (arg)))\n+\t    {\n+\t      parm.rv_ref = true;\n+\t      actual_type = TREE_TYPE (actual_type);\n+\t      parm.frame_type = actual_type;\n+\t    }\n+\t  else if (TREE_CODE (actual_type) == REFERENCE_TYPE)\n+\t    {\n+\t      /* If the user passes by reference, then we will save the\n+\t\t pointer to the original.  As noted in\n+\t\t [dcl.fct.def.coroutine] / 13, if the lifetime of the\n+\t\t referenced item ends and then the coroutine is resumed,\n+\t\t we have UB; well, the user asked for it.  */\n+\t      actual_type = build_pointer_type (TREE_TYPE (actual_type));\n+\t      parm.frame_type = actual_type;\n+\t      parm.pt_ref = true;\n+\t    }\n+\t  else if (TYPE_REF_P (DECL_ARG_TYPE (arg)))\n+\t    {\n+\t      parm.by_ref = true;\n+\t      parm.frame_type = actual_type;\n+\t    }\n+\t  else\n+\t    parm.frame_type = actual_type;\n+\n+\t  parm.trivial_dtor = TYPE_HAS_TRIVIAL_DESTRUCTOR (parm.frame_type);\n+\t  tree pname = DECL_NAME (arg);\n+\t  char *buf = xasprintf (\"__parm.%s\", IDENTIFIER_POINTER (pname));\n+\t  parm.field_id = coro_make_frame_entry\n+\t    (&field_list, buf, actual_type, DECL_SOURCE_LOCATION (arg));\n+\t  free (buf);\n+\t}\n+\n+      param_frame_data param_data\n+\t= {&field_list, param_uses, fn_start, false};\n+      /* We want to record every instance of param's use, so don't include\n+\t a 'visited' hash_set.  */\n+      cp_walk_tree (&fnbody, register_param_uses, &param_data, NULL);\n+    }\n+\n   /* Initial suspend is mandated.  */\n   tree init_susp_name = coro_make_frame_entry (&field_list, \"__aw_s.is\",\n \t\t\t\t\t       initial_suspend_type, fn_start);\n@@ -3164,50 +3237,6 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   register_await_info (final_await, final_suspend_type, fin_susp_name,\n \t\t       void_type_node, fin_hand_name);\n \n-  /* 3. Now add in fields for function params (if there are any) that are used\n-     within the function body.  This is conservative; we can't tell at this\n-     stage if such uses might be optimized away, or if they might turn out not\n-     to persist across any suspend points.  Of course, even if they don't\n-     persist across suspend points, when the actor is out of line the saved\n-     frame version is still needed.  */\n-  hash_map<tree, param_info> *param_uses = NULL;\n-  if (DECL_ARGUMENTS (orig))\n-    {\n-      /* Build a hash map with an entry for each param.\n-\t  The key is the param tree.\n-\t  Then we have an entry for the frame field name.\n-\t  Then a cache for the field ref when we come to use it.\n-\t  Then a tree list of the uses.\n-\t  The second two entries start out empty - and only get populated\n-\t  when we see uses.  */\n-      param_uses = new hash_map<tree, param_info>;\n-\n-      for (tree arg = DECL_ARGUMENTS (orig); arg != NULL;\n-\t   arg = DECL_CHAIN (arg))\n-\t{\n-\t  bool existed;\n-\t  param_info &parm = param_uses->get_or_insert (arg, &existed);\n-\t  gcc_checking_assert (!existed);\n-\t  parm.field_id = NULL_TREE;\n-\t  parm.body_uses = NULL;\n-\t}\n-\n-      param_frame_data param_data\n-\t= {&field_list, param_uses, fn_start, false};\n-      /* We want to record every instance of param's use, so don't include\n-\t a 'visited' hash_set.  */\n-      cp_walk_tree (&fnbody, register_param_uses, &param_data, NULL);\n-\n-      /* If no uses for any param were seen, act as if there were no\n-\t params (it could be that they are only used to construct the\n-\t promise).  */\n-      if (!param_data.param_seen)\n-\t{\n-\t  delete param_uses;\n-\t  param_uses = NULL;\n-\t}\n-    }\n-\n   /* 4. Now make space for local vars, this is conservative again, and we\n      would expect to delete unused entries later.  */\n   hash_map<tree, local_var_info> local_var_uses;\n@@ -3480,59 +3509,34 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   r = coro_build_cvt_void_expr_stmt (r, fn_start);\n   add_stmt (r);\n \n-  /* Set up the promise.  */\n-  tree promise_m\n-    = lookup_member (coro_frame_type, promise_name,\n-\t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n+  /* n4849 [dcl.fct.def.coroutine] /13\n+     When a coroutine is invoked, a copy is created for each coroutine\n+     parameter.  Each such copy is an object with automatic storage duration\n+     that is direct-initialized from an lvalue referring to the corresponding\n+     parameter if the parameter is an lvalue reference, and from an xvalue\n+     referring to it otherwise.  A reference to a parameter in the function-\n+     body of the coroutine and in the call to the coroutine promise\n+     constructor is replaced by a reference to its copy.  */\n \n-  tree p = build_class_member_access_expr (deref_fp, promise_m, NULL_TREE,\n-\t\t\t\t\t   false, tf_warning_or_error);\n+  vec<tree, va_gc> *promise_args = NULL; /* So that we can adjust refs.  */\n \n-  if (TYPE_NEEDS_CONSTRUCTING (promise_type))\n-    {\n-      /* Do a placement new constructor for the promise type (we never call\n-\t the new operator, just the constructor on the object in place in the\n-\t frame).\n+  /* The initialization and destruction of each parameter copy occurs in the\n+     context of the called coroutine.  Initializations of parameter copies are\n+     sequenced before the call to the coroutine promise constructor and\n+     indeterminately sequenced with respect to each other.  The lifetime of\n+     parameter copies ends immediately after the lifetime of the coroutine\n+     promise object ends.  */\n \n-\t First try to find a constructor with the same parameter list as the\n-\t original function (if it has params), failing that find a constructor\n-\t with no parameter list.  */\n-\n-      if (DECL_ARGUMENTS (orig))\n-\t{\n-\t  vec<tree, va_gc> *args = make_tree_vector ();\n-\t  tree arg;\n-\t  for (arg = DECL_ARGUMENTS (orig); arg != NULL; arg = DECL_CHAIN (arg))\n-\t    vec_safe_push (args, arg);\n-\t  r = build_special_member_call (p, complete_ctor_identifier, &args,\n-\t\t\t\t\t promise_type, LOOKUP_NORMAL, tf_none);\n-\t  release_tree_vector (args);\n-\t}\n-      else\n-\tr = NULL_TREE;\n-\n-      if (r == NULL_TREE || r == error_mark_node)\n-\tr = build_special_member_call (p, complete_ctor_identifier, NULL,\n-\t\t\t\t       promise_type, LOOKUP_NORMAL,\n-\t\t\t\t       tf_warning_or_error);\n-\n-      r = coro_build_cvt_void_expr_stmt (r, fn_start);\n-      add_stmt (r);\n-    }\n-\n-  /* Copy in any of the function params we found to be used.\n-     Param types with non-trivial dtors will have to be moved into position\n-     and the dtor run before the frame is freed.  */\n   vec<tree, va_gc> *param_dtor_list = NULL;\n-  if (DECL_ARGUMENTS (orig) && param_uses != NULL)\n+\n+  if (DECL_ARGUMENTS (orig))\n     {\n-      tree arg;\n-      for (arg = DECL_ARGUMENTS (orig); arg != NULL; arg = DECL_CHAIN (arg))\n+      promise_args = make_tree_vector ();\n+      for (tree arg = DECL_ARGUMENTS (orig); arg != NULL;\n+\t   arg = DECL_CHAIN (arg))\n \t{\n \t  bool existed;\n \t  param_info &parm = param_uses->get_or_insert (arg, &existed);\n-\t  if (parm.field_id == NULL_TREE)\n-\t    continue; /* Wasn't used.  */\n \n \t  tree fld_ref = lookup_member (coro_frame_type, parm.field_id,\n \t\t\t\t\t/*protect=*/1, /*want_type=*/0,\n@@ -3541,14 +3545,21 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t    = build_class_member_access_expr (deref_fp, fld_ref, NULL_TREE,\n \t\t\t\t\t      false, tf_warning_or_error);\n \n+\t  /* Add this to the promise CTOR arguments list, accounting for\n+\t     refs.  */\n+\t  if (parm.by_ref)\n+\t    vec_safe_push (promise_args, fld_idx);\n+\t  else if (parm.rv_ref)\n+\t    vec_safe_push (promise_args, rvalue (fld_idx));\n+\t  else\n+\t    vec_safe_push (promise_args, arg);\n+\n \t  if (TYPE_NEEDS_CONSTRUCTING (parm.frame_type))\n \t    {\n \t      vec<tree, va_gc> *p_in;\n-\t      if (TYPE_REF_P (DECL_ARG_TYPE (arg))\n-\t\t  && (CLASSTYPE_LAZY_MOVE_CTOR (parm.frame_type)\n-\t\t      || CLASSTYPE_LAZY_MOVE_ASSIGN (parm.frame_type)\n-\t\t      || classtype_has_move_assign_or_move_ctor_p\n-\t\t\t    (parm.frame_type, /*user_declared=*/true)))\n+\t      if (parm.by_ref\n+\t\t  && classtype_has_non_deleted_move_ctor (parm.frame_type)\n+\t\t  && !classtype_has_non_deleted_copy_ctor (parm.frame_type))\n \t\tp_in = make_tree_vector_single (rvalue (arg));\n \t      else\n \t\tp_in = make_tree_vector_single (arg);\n@@ -3558,13 +3569,12 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t\t\t\t\t     LOOKUP_NORMAL,\n \t\t\t\t\t     tf_warning_or_error);\n \t      release_tree_vector (p_in);\n-\t      if (param_dtor_list == NULL)\n-\t\tparam_dtor_list = make_tree_vector ();\n-\t      vec_safe_push (param_dtor_list, parm.field_id);\n \t    }\n \t  else\n \t    {\n-\t      if (!same_type_p (parm.frame_type, DECL_ARG_TYPE (arg)))\n+\t      if (parm.rv_ref)\n+\t\tr = convert_from_reference (arg);\n+\t      else if (!same_type_p (parm.frame_type, DECL_ARG_TYPE (arg)))\n \t\tr = build1_loc (DECL_SOURCE_LOCATION (arg), CONVERT_EXPR,\n \t\t\t\tparm.frame_type, arg);\n \t      else\n@@ -3575,9 +3585,52 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t    }\n \t  r = coro_build_cvt_void_expr_stmt (r, fn_start);\n \t  add_stmt (r);\n+\t  if (!parm.trivial_dtor)\n+\t    {\n+\t      if (param_dtor_list == NULL)\n+\t\tparam_dtor_list = make_tree_vector ();\n+\t      vec_safe_push (param_dtor_list, parm.field_id);\n+\t    }\n \t}\n     }\n \n+  /* Set up the promise.  */\n+  tree promise_m\n+    = lookup_member (coro_frame_type, promise_name,\n+\t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n+\n+  tree p = build_class_member_access_expr (deref_fp, promise_m, NULL_TREE,\n+\t\t\t\t\t   false, tf_warning_or_error);\n+\n+  if (TYPE_NEEDS_CONSTRUCTING (promise_type))\n+    {\n+      /* Do a placement new constructor for the promise type (we never call\n+\t the new operator, just the constructor on the object in place in the\n+\t frame).\n+\n+\t First try to find a constructor with the same parameter list as the\n+\t original function (if it has params), failing that find a constructor\n+\t with no parameter list.  */\n+\n+      if (DECL_ARGUMENTS (orig))\n+\t{\n+\t  r = build_special_member_call (p, complete_ctor_identifier,\n+\t\t\t\t\t &promise_args, promise_type,\n+\t\t\t\t\t LOOKUP_NORMAL, tf_none);\n+\t  release_tree_vector (promise_args);\n+\t}\n+      else\n+\tr = NULL_TREE;\n+\n+      if (r == NULL_TREE || r == error_mark_node)\n+\tr = build_special_member_call (p, complete_ctor_identifier, NULL,\n+\t\t\t\t       promise_type, LOOKUP_NORMAL,\n+\t\t\t\t       tf_warning_or_error);\n+\n+      r = coro_build_cvt_void_expr_stmt (r, fn_start);\n+      add_stmt (r);\n+    }\n+\n   vec<tree, va_gc> *captures_dtor_list = NULL;\n   while (!captures.is_empty())\n     {"}, {"sha": "0a7381cee3f8de1a8abedb90835332b098ed6c15", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc192bbdd0442f75e324cc82a98e611b7912e2f9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc192bbdd0442f75e324cc82a98e611b7912e2f9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=dc192bbdd0442f75e324cc82a98e611b7912e2f9", "patch": "@@ -6439,6 +6439,7 @@ extern bool type_has_constexpr_destructor\t(tree);\n extern bool type_has_virtual_destructor\t\t(tree);\n extern bool classtype_has_move_assign_or_move_ctor_p (tree, bool user_declared);\n extern bool classtype_has_non_deleted_move_ctor (tree);\n+extern bool classtype_has_non_deleted_copy_ctor (tree);\n extern tree classtype_has_depr_implicit_copy\t(tree);\n extern bool classtype_has_op (tree, tree_code);\n extern tree classtype_has_defaulted_op (tree, tree_code);"}, {"sha": "105fa854160cb02cf2f07cbe2785e1cd805fbb56", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc192bbdd0442f75e324cc82a98e611b7912e2f9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc192bbdd0442f75e324cc82a98e611b7912e2f9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dc192bbdd0442f75e324cc82a98e611b7912e2f9", "patch": "@@ -1,3 +1,9 @@\n+2020-02-26  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* g++.dg/coroutines/coro1-refs-and-ctors.h: New.\n+\t* g++.dg/coroutines/torture/func-params-07.C: New test.\n+\t* g++.dg/coroutines/torture/func-params-08.C: New test.\n+\n 2020-02-26  Peter Bergner  <bergner@linux.ibm.com>\n \n \tPR target/93913"}, {"sha": "5b89e7c412817f3cc79acff590eaa17174f69aa0", "filename": "gcc/testsuite/g++.dg/coroutines/coro1-refs-and-ctors.h", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc192bbdd0442f75e324cc82a98e611b7912e2f9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro1-refs-and-ctors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc192bbdd0442f75e324cc82a98e611b7912e2f9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro1-refs-and-ctors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro1-refs-and-ctors.h?ref=dc192bbdd0442f75e324cc82a98e611b7912e2f9", "patch": "@@ -0,0 +1,144 @@\n+struct coro1 {\n+\n+  struct promise_type {\n+\n+  promise_type () : vv(-1) {  PRINT (\"Promise def. CTOR\"); }\n+  promise_type (int __x) : vv(__x) {  PRINTF (\"Created Promise with %d\\n\",__x); }\n+  promise_type (int __x, int& __y, int&& __z)\n+    : vv(__x), v2(__y), v3(__z)\n+    {  PRINTF (\"Created Promise with %d, %d, %d\\n\", __x, __y, __z); }\n+\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  auto get_return_object () {\n+    PRINT (\"get_return_object: handle from promise\");\n+    return handle_type::from_promise (*this);\n+  }\n+\n+  auto initial_suspend () {\n+    PRINT (\"get initial_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  auto final_suspend () {\n+    PRINT (\"get final_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+\n+#ifdef USE_AWAIT_TRANSFORM\n+\n+  auto await_transform (int v) {\n+    PRINTF (\"await_transform an int () %d\\n\",v);\n+    return suspend_always_intprt (v);\n+  }\n+\n+  auto await_transform (long v) {\n+    PRINTF (\"await_transform a long () %ld\\n\",v);\n+    return suspend_always_longprtsq (v);\n+  }\n+\n+#endif\n+\n+  auto yield_value (int v) {\n+    PRINTF (\"yield_value (%d)\\n\", v);\n+    vv = v;\n+    return suspend_always_prt{};\n+  }\n+\n+  void return_value (int v) {\n+    PRINTF (\"return_value (%d)\\n\", v);\n+    vv = v;\n+    \n+  }\n+\n+  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n+\n+  int get_value () { return vv; }\n+  int get_v2 () { return v2; }\n+  int get_v3 () { return v3; }\n+\n+  private:\n+    int vv;\n+    int v2;\n+    int v3;\n+  };\n+\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+  coro1 () : handle(0) {}\n+  coro1 (handle_type _handle)\n+    : handle(_handle) {\n+        PRINT(\"Created coro1 object from handle\");\n+  }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) : handle(s.handle) {\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 mv ctor \");\n+  }\n+  coro1 &operator = (coro1 &&s) {\n+\thandle = s.handle;\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 op=  \");\n+\treturn *this;\n+  }\n+  ~coro1() {\n+        PRINT(\"Destroyed coro1\");\n+        if ( handle )\n+          handle.destroy();\n+  }\n+\n+  // Some awaitables to use in tests.\n+  // With progress printing for debug.\n+  struct suspend_never_prt {\n+  bool await_ready() const noexcept { return true; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-never-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n+  };\n+\n+  struct  suspend_always_prt {\n+  bool await_ready() const noexcept { return false; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-always-resume\");}\n+  ~suspend_always_prt() { PRINT (\"susp-always-dtor\"); }\n+  };\n+\n+  struct suspend_always_intprt {\n+    int x;\n+    suspend_always_intprt() : x(5) {}\n+    suspend_always_intprt(int __x) : x(__x) {}\n+    ~suspend_always_intprt() {}\n+    bool await_ready() const noexcept { return false; }\n+    void await_suspend(coro::coroutine_handle<>) const noexcept { PRINT (\"susp-always-susp-intprt\");}\n+    int await_resume() const noexcept { PRINT (\"susp-always-resume-intprt\"); return x;}\n+  };\n+  \n+  /* This returns the square of the int that it was constructed with.  */\n+  struct suspend_always_longprtsq {\n+    long x;\n+    suspend_always_longprtsq() : x(12L) { PRINT (\"suspend_always_longprtsq def ctor\"); }\n+    suspend_always_longprtsq(long _x) : x(_x) { PRINTF (\"suspend_always_longprtsq ctor with %ld\\n\", x); }\n+    ~suspend_always_longprtsq() {}\n+    bool await_ready() const noexcept { return false; }\n+    void await_suspend(coro::coroutine_handle<>) const noexcept { PRINT (\"susp-always-susp-longsq\");}\n+    long await_resume() const noexcept { PRINT (\"susp-always-resume-longsq\"); return x * x;}\n+  };\n+\n+  struct suspend_always_intrefprt {\n+    int& x;\n+    suspend_always_intrefprt(int& __x) : x(__x) {}\n+    ~suspend_always_intrefprt() {}\n+    bool await_ready() const noexcept { return false; }\n+    void await_suspend(coro::coroutine_handle<>) const noexcept { PRINT (\"susp-always-susp-intprt\");}\n+    int& await_resume() const noexcept { PRINT (\"susp-always-resume-intprt\"); return x;}\n+  };\n+\n+  template <typename _AwaitType>\n+  struct suspend_always_tmpl_awaiter {\n+    _AwaitType x;\n+    suspend_always_tmpl_awaiter(_AwaitType __x) : x(__x) {}\n+    ~suspend_always_tmpl_awaiter() {}\n+    bool await_ready() const noexcept { return false; }\n+    void await_suspend(coro::coroutine_handle<>) const noexcept { PRINT (\"suspend_always_tmpl_awaiter\");}\n+    _AwaitType await_resume() const noexcept { PRINT (\"suspend_always_tmpl_awaiter\"); return x;}\n+  };\n+\n+};"}, {"sha": "7f3bb3cc7825e5927d20fca66180160b3b193ac9", "filename": "gcc/testsuite/g++.dg/coroutines/torture/func-params-07.C", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc192bbdd0442f75e324cc82a98e611b7912e2f9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-07.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc192bbdd0442f75e324cc82a98e611b7912e2f9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-07.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-07.C?ref=dc192bbdd0442f75e324cc82a98e611b7912e2f9", "patch": "@@ -0,0 +1,81 @@\n+// { dg-do run }\n+\n+// Test that we copy simple parms correctly by value, reference or\n+// rvalue reference.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-refs-and-ctors.h\"\n+\n+coro1\n+my_coro (int v1, int& v2, int&& v3)\n+{\n+  co_yield v1 + v2 + v3;\n+  co_return v1 + v2 + v3;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  int lv = 1;\n+  int lvr = 2;\n+  coro1 x = my_coro (lv, lvr, lvr+2);\n+\n+  if (x.handle.done())\n+    abort();\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (initial suspend)\");\n+\n+  /* Now we should have the co_yielded value.  */\n+  int y = x.handle.promise().get_value();\n+  if ( y != 7 )\n+    {\n+      PRINTF (\"main: wrong result (%d).\", y);\n+      abort ();\n+    }\n+\n+  /* So we should be suspended at the yield, now change the\n+     values so that we can determine that the reference persists\n+     and the copy was made correctly.  */\n+  lv = 5; // should be ignored\n+  lvr = 3; // should be enacted\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (yield)\");\n+\n+  /* Now we should have the co_returned value.  */\n+  y = x.handle.promise().get_value();\n+  if ( y != 8 )\n+    {\n+      PRINTF (\"main: wrong result (%d).\", y);\n+      abort ();\n+    }\n+\n+  y = x.handle.promise().get_v2();\n+  if ( y != 2 )\n+    {\n+      PRINTF (\"main: wrong result 2 (%d).\", y);\n+      abort ();\n+    }\n+\n+  y = x.handle.promise().get_v3();\n+  if ( y != 4 )\n+    {\n+      PRINTF (\"main: wrong result 3 (%d).\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+\n+  x.handle.destroy();\n+  x.handle = NULL;\n+\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "c34d143fa6825e3e285ff13fa8ee3fee900e1e68", "filename": "gcc/testsuite/g++.dg/coroutines/torture/func-params-08.C", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc192bbdd0442f75e324cc82a98e611b7912e2f9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-08.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc192bbdd0442f75e324cc82a98e611b7912e2f9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-08.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-08.C?ref=dc192bbdd0442f75e324cc82a98e611b7912e2f9", "patch": "@@ -0,0 +1,112 @@\n+// { dg-do run }\n+\n+// Check that we correctly handle params with non-trivial DTORs and\n+// use the correct copy/move CTORs.\n+\n+#include \"../coro.h\"\n+#include <vector>\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int regular = 0;\n+int copy = 0;\n+int move = 0;\n+\n+struct Foo {\n+  Foo(int _v) : value(_v), x(1, _v)\n+    {\n+      regular++;\n+      PRINTF (\"FOO(%d)\\n\",_v);\n+    }\n+\n+  Foo(const Foo& t)\n+    {\n+      value = t.value;\n+      x = t.x;\n+      copy++;\n+      PRINTF (\"FOO(&), %d\\n\",value);\n+    }\n+\n+  Foo(Foo&& s)\n+    {\n+      value = s.value;\n+      s.value = -1;\n+      x = std::move(s.x);\n+      s.x = std::vector<int> ();\n+      move++;\n+      PRINTF (\"FOO(&&), %d\\n\", value);\n+    }\n+\n+  ~Foo() {PRINTF (\"~FOO(), %d\\n\", value);}\n+\n+  auto operator co_await()\n+    {\n+      struct awaitable\n+\t{\n+\t  int v;\n+\t  awaitable (int _v) : v(_v) {}\n+\t  bool await_ready() { return true; }\n+\t  void await_suspend(coro::coroutine_handle<>) {}\n+\t  int await_resume() { return v;}\n+\t};\n+      return awaitable{value + x[0]};\n+    };\n+\n+    void return_value(int _v) { value = _v;}\n+\n+    int value;\n+    std::vector<int> x;\n+};\n+\n+coro1\n+my_coro (Foo t_lv, Foo& t_ref, Foo&& t_rv_ref)\n+{\n+  PRINT (\"my_coro\");\n+  // We are created suspended, so correct operation depends on\n+  // the parms being copied.\n+  int sum = co_await t_lv;\n+  PRINT (\"my_coro 1\");\n+  sum += co_await t_ref;\n+  PRINT (\"my_coro 2\");\n+  sum += co_await t_rv_ref;\n+  PRINT (\"my_coro 3\");\n+  co_return sum;\n+}\n+\n+int main ()\n+{\n+\n+  PRINT (\"main: create coro1\");\n+  Foo thing (4);\n+  coro1 x = my_coro (Foo (1), thing, Foo (2));\n+  PRINT (\"main: done ramp\");\n+\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume (initial suspend)\");\n+\n+  // now do the three co_awaits.\n+  while(!x.handle.done())\n+    x.handle.resume();\n+  PRINT (\"main: after resuming 3 co_awaits\");\n+\n+  /* Now we should have the co_returned value.  */\n+  int y = x.handle.promise().get_value();\n+  if (y != 14)\n+    {\n+      PRINTF (\"main: wrong result (%d).\", y);\n+      abort ();\n+    }\n+\n+  if (regular != 3 || copy != 1 || move != 1)\n+    {\n+      PRINTF (\"main: unexpected ctor use (R:%d, C:%d, M:%d)\\n\",\n+\t      regular, copy, move);\n+      abort ();\n+    }\n+\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}]}