{"sha": "1dd3f21095858fbfd3e28a149578d5fb67e75f95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRkM2YyMTA5NTg1OGZiZmQzZTI4YTE0OTU3OGQ1ZmI2N2U3NWY5NQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-07-13T11:59:15Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-07-14T06:15:17Z"}, "message": "Support reduction def re-use for epilogue with different vector size\n\nThe following adds support for re-using the vector reduction def\nfrom the main loop in vectorized epilogue loops on architectures\nwhich use different vector sizes for the epilogue.  That's only\nx86 as far as I am aware.\n\n2021-07-13  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-loop.c (vect_find_reusable_accumulator): Handle\n\tvector types where the old vector type has a multiple of\n\tthe new vector type elements.\n\t(vect_create_partial_epilog): New function, split out from...\n\t(vect_create_epilog_for_reduction): ... here.\n\t(vect_transform_cycle_phi): Reduce the re-used accumulator\n\tto the new vector type.\n\n\t* gcc.target/i386/vect-reduc-1.c: New testcase.", "tree": {"sha": "c09052cd904389d80af79d67e1a586478b475ea4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c09052cd904389d80af79d67e1a586478b475ea4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1dd3f21095858fbfd3e28a149578d5fb67e75f95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dd3f21095858fbfd3e28a149578d5fb67e75f95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dd3f21095858fbfd3e28a149578d5fb67e75f95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dd3f21095858fbfd3e28a149578d5fb67e75f95/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7098d6ef4e4e799dab8ef925c62b199d707694b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7098d6ef4e4e799dab8ef925c62b199d707694b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7098d6ef4e4e799dab8ef925c62b199d707694b"}], "stats": {"total": 244, "additions": 156, "deletions": 88}, "files": [{"sha": "9ee9ba4e7361692779d705790de6b0b87fc8c98a", "filename": "gcc/testsuite/gcc.target/i386/vect-reduc-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dd3f21095858fbfd3e28a149578d5fb67e75f95/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-reduc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dd3f21095858fbfd3e28a149578d5fb67e75f95/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-reduc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-reduc-1.c?ref=1dd3f21095858fbfd3e28a149578d5fb67e75f95", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mavx2 -mno-avx512f -fdump-tree-vect-details\" } */\n+\n+#define N 32\n+int foo (int *a, int n)\n+{\n+  int sum = 1;\n+  for (int i = 0; i < 8*N + 4; ++i)\n+    sum += a[i];\n+  return sum;\n+}\n+\n+/* The reduction epilog should be vectorized and the accumulator\n+   re-used.  */\n+/* { dg-final { scan-tree-dump \"LOOP EPILOGUE VECTORIZED\" \"vect\" } } */\n+/* { dg-final { scan-assembler-times \"psrl\" 2 } } */\n+/* { dg-final { scan-assembler-times \"padd\" 5 } } */"}, {"sha": "e9780158a51d22c10aeb393abbb3f0246a9576b7", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 139, "deletions": 88, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dd3f21095858fbfd3e28a149578d5fb67e75f95/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dd3f21095858fbfd3e28a149578d5fb67e75f95/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=1dd3f21095858fbfd3e28a149578d5fb67e75f95", "patch": "@@ -4896,12 +4896,11 @@ vect_find_reusable_accumulator (loop_vec_info loop_vinfo,\n \t\t      accumulator->reduc_info->reduc_scalar_results.begin ()))\n     return false;\n \n-  /* For now, only handle the case in which both loops are operating on the\n-     same vector types.  In future we could reduce wider vectors to narrower\n-     ones as well.  */\n+  /* Handle the case where we can reduce wider vectors to narrower ones.  */\n   tree vectype = STMT_VINFO_VECTYPE (reduc_info);\n   tree old_vectype = TREE_TYPE (accumulator->reduc_input);\n-  if (!useless_type_conversion_p (old_vectype, vectype))\n+  if (!constant_multiple_p (TYPE_VECTOR_SUBPARTS (old_vectype),\n+\t\t\t    TYPE_VECTOR_SUBPARTS (vectype)))\n     return false;\n \n   /* Non-SLP reductions might apply an adjustment after the reduction\n@@ -4935,6 +4934,101 @@ vect_find_reusable_accumulator (loop_vec_info loop_vinfo,\n   return true;\n }\n \n+/* Reduce the vector VEC_DEF down to VECTYPE with reduction operation\n+   CODE emitting stmts before GSI.  Returns a vector def of VECTYPE.  */\n+\n+static tree\n+vect_create_partial_epilog (tree vec_def, tree vectype, enum tree_code code,\n+\t\t\t    gimple_seq *seq)\n+{\n+  unsigned nunits = TYPE_VECTOR_SUBPARTS (TREE_TYPE (vec_def)).to_constant ();\n+  unsigned nunits1 = TYPE_VECTOR_SUBPARTS (vectype).to_constant ();\n+  tree stype = TREE_TYPE (vectype);\n+  tree new_temp = vec_def;\n+  while (nunits > nunits1)\n+    {\n+      nunits /= 2;\n+      tree vectype1 = get_related_vectype_for_scalar_type (TYPE_MODE (vectype),\n+\t\t\t\t\t\t\t   stype, nunits);\n+      unsigned int bitsize = tree_to_uhwi (TYPE_SIZE (vectype1));\n+\n+      /* The target has to make sure we support lowpart/highpart\n+\t extraction, either via direct vector extract or through\n+\t an integer mode punning.  */\n+      tree dst1, dst2;\n+      gimple *epilog_stmt;\n+      if (convert_optab_handler (vec_extract_optab,\n+\t\t\t\t TYPE_MODE (TREE_TYPE (new_temp)),\n+\t\t\t\t TYPE_MODE (vectype1))\n+\t  != CODE_FOR_nothing)\n+\t{\n+\t  /* Extract sub-vectors directly once vec_extract becomes\n+\t     a conversion optab.  */\n+\t  dst1 = make_ssa_name (vectype1);\n+\t  epilog_stmt\n+\t      = gimple_build_assign (dst1, BIT_FIELD_REF,\n+\t\t\t\t     build3 (BIT_FIELD_REF, vectype1,\n+\t\t\t\t\t     new_temp, TYPE_SIZE (vectype1),\n+\t\t\t\t\t     bitsize_int (0)));\n+\t  gimple_seq_add_stmt_without_update (seq, epilog_stmt);\n+\t  dst2 =  make_ssa_name (vectype1);\n+\t  epilog_stmt\n+\t      = gimple_build_assign (dst2, BIT_FIELD_REF,\n+\t\t\t\t     build3 (BIT_FIELD_REF, vectype1,\n+\t\t\t\t\t     new_temp, TYPE_SIZE (vectype1),\n+\t\t\t\t\t     bitsize_int (bitsize)));\n+\t  gimple_seq_add_stmt_without_update (seq, epilog_stmt);\n+\t}\n+      else\n+\t{\n+\t  /* Extract via punning to appropriately sized integer mode\n+\t     vector.  */\n+\t  tree eltype = build_nonstandard_integer_type (bitsize, 1);\n+\t  tree etype = build_vector_type (eltype, 2);\n+\t  gcc_assert (convert_optab_handler (vec_extract_optab,\n+\t\t\t\t\t     TYPE_MODE (etype),\n+\t\t\t\t\t     TYPE_MODE (eltype))\n+\t\t      != CODE_FOR_nothing);\n+\t  tree tem = make_ssa_name (etype);\n+\t  epilog_stmt = gimple_build_assign (tem, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t     build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t     etype, new_temp));\n+\t  gimple_seq_add_stmt_without_update (seq, epilog_stmt);\n+\t  new_temp = tem;\n+\t  tem = make_ssa_name (eltype);\n+\t  epilog_stmt\n+\t      = gimple_build_assign (tem, BIT_FIELD_REF,\n+\t\t\t\t     build3 (BIT_FIELD_REF, eltype,\n+\t\t\t\t\t     new_temp, TYPE_SIZE (eltype),\n+\t\t\t\t\t     bitsize_int (0)));\n+\t  gimple_seq_add_stmt_without_update (seq, epilog_stmt);\n+\t  dst1 = make_ssa_name (vectype1);\n+\t  epilog_stmt = gimple_build_assign (dst1, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t     build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t     vectype1, tem));\n+\t  gimple_seq_add_stmt_without_update (seq, epilog_stmt);\n+\t  tem = make_ssa_name (eltype);\n+\t  epilog_stmt\n+\t      = gimple_build_assign (tem, BIT_FIELD_REF,\n+\t\t\t\t     build3 (BIT_FIELD_REF, eltype,\n+\t\t\t\t\t     new_temp, TYPE_SIZE (eltype),\n+\t\t\t\t\t     bitsize_int (bitsize)));\n+\t  gimple_seq_add_stmt_without_update (seq, epilog_stmt);\n+\t  dst2 =  make_ssa_name (vectype1);\n+\t  epilog_stmt = gimple_build_assign (dst2, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t     build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t     vectype1, tem));\n+\t  gimple_seq_add_stmt_without_update (seq, epilog_stmt);\n+\t}\n+\n+      new_temp = make_ssa_name (vectype1);\n+      epilog_stmt = gimple_build_assign (new_temp, code, dst1, dst2);\n+      gimple_seq_add_stmt_without_update (seq, epilog_stmt);\n+    }\n+\n+  return new_temp;\n+}\n+\n /* Function vect_create_epilog_for_reduction\n \n    Create code at the loop-epilog to finalize the result of a reduction\n@@ -5684,87 +5778,11 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \n       /* First reduce the vector to the desired vector size we should\n \t do shift reduction on by combining upper and lower halves.  */\n-      new_temp = reduc_inputs[0];\n-      while (nunits > nunits1)\n-\t{\n-\t  nunits /= 2;\n-\t  vectype1 = get_related_vectype_for_scalar_type (TYPE_MODE (vectype),\n-\t\t\t\t\t\t\t  stype, nunits);\n-\t  unsigned int bitsize = tree_to_uhwi (TYPE_SIZE (vectype1));\n-\n-\t  /* The target has to make sure we support lowpart/highpart\n-\t     extraction, either via direct vector extract or through\n-\t     an integer mode punning.  */\n-\t  tree dst1, dst2;\n-\t  if (convert_optab_handler (vec_extract_optab,\n-\t\t\t\t     TYPE_MODE (TREE_TYPE (new_temp)),\n-\t\t\t\t     TYPE_MODE (vectype1))\n-\t      != CODE_FOR_nothing)\n-\t    {\n-\t      /* Extract sub-vectors directly once vec_extract becomes\n-\t\t a conversion optab.  */\n-\t      dst1 = make_ssa_name (vectype1);\n-\t      epilog_stmt\n-\t\t  = gimple_build_assign (dst1, BIT_FIELD_REF,\n-\t\t\t\t\t build3 (BIT_FIELD_REF, vectype1,\n-\t\t\t\t\t\t new_temp, TYPE_SIZE (vectype1),\n-\t\t\t\t\t\t bitsize_int (0)));\n-\t      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n-\t      dst2 =  make_ssa_name (vectype1);\n-\t      epilog_stmt\n-\t\t  = gimple_build_assign (dst2, BIT_FIELD_REF,\n-\t\t\t\t\t build3 (BIT_FIELD_REF, vectype1,\n-\t\t\t\t\t\t new_temp, TYPE_SIZE (vectype1),\n-\t\t\t\t\t\t bitsize_int (bitsize)));\n-\t      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Extract via punning to appropriately sized integer mode\n-\t\t vector.  */\n-\t      tree eltype = build_nonstandard_integer_type (bitsize, 1);\n-\t      tree etype = build_vector_type (eltype, 2);\n-\t      gcc_assert (convert_optab_handler (vec_extract_optab,\n-\t\t\t\t\t\t TYPE_MODE (etype),\n-\t\t\t\t\t\t TYPE_MODE (eltype))\n-\t\t\t  != CODE_FOR_nothing);\n-\t      tree tem = make_ssa_name (etype);\n-\t      epilog_stmt = gimple_build_assign (tem, VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t build1 (VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t\t etype, new_temp));\n-\t      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n-\t      new_temp = tem;\n-\t      tem = make_ssa_name (eltype);\n-\t      epilog_stmt\n-\t\t  = gimple_build_assign (tem, BIT_FIELD_REF,\n-\t\t\t\t\t build3 (BIT_FIELD_REF, eltype,\n-\t\t\t\t\t\t new_temp, TYPE_SIZE (eltype),\n-\t\t\t\t\t\t bitsize_int (0)));\n-\t      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n-\t      dst1 = make_ssa_name (vectype1);\n-\t      epilog_stmt = gimple_build_assign (dst1, VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t build1 (VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t\t vectype1, tem));\n-\t      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n-\t      tem = make_ssa_name (eltype);\n-\t      epilog_stmt\n-\t\t  = gimple_build_assign (tem, BIT_FIELD_REF,\n-\t\t\t\t\t build3 (BIT_FIELD_REF, eltype,\n-\t\t\t\t\t\t new_temp, TYPE_SIZE (eltype),\n-\t\t\t\t\t\t bitsize_int (bitsize)));\n-\t      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n-\t      dst2 =  make_ssa_name (vectype1);\n-\t      epilog_stmt = gimple_build_assign (dst2, VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t build1 (VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t\t vectype1, tem));\n-\t      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n-\t    }\n-\n-\t  new_temp = make_ssa_name (vectype1);\n-\t  epilog_stmt = gimple_build_assign (new_temp, code, dst1, dst2);\n-\t  gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n-\t  reduc_inputs[0] = new_temp;\n-\t}\n+      gimple_seq stmts = NULL;\n+      new_temp = vect_create_partial_epilog (reduc_inputs[0], vectype1,\n+\t\t\t\t\t     code, &stmts);\n+      gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n+      reduc_inputs[0] = new_temp;\n \n       if (reduce_with_shift && !slp_reduc)\n \t{\n@@ -7681,13 +7699,46 @@ vect_transform_cycle_phi (loop_vec_info loop_vinfo,\n \n   if (auto *accumulator = reduc_info->reused_accumulator)\n     {\n+      tree def = accumulator->reduc_input;\n+      unsigned int nreduc;\n+      bool res = constant_multiple_p (TYPE_VECTOR_SUBPARTS (TREE_TYPE (def)),\n+\t\t\t\t      TYPE_VECTOR_SUBPARTS (vectype_out),\n+\t\t\t\t      &nreduc);\n+      gcc_assert (res);\n+      if (nreduc != 1)\n+\t{\n+\t  /* Reduce the single vector to a smaller one.  */\n+\t  gimple_seq stmts = NULL;\n+\t  def = vect_create_partial_epilog (def, vectype_out,\n+\t\t\t\t\t    STMT_VINFO_REDUC_CODE (reduc_info),\n+\t\t\t\t\t    &stmts);\n+\t  /* Adjust the input so we pick up the partially reduced value\n+\t     for the skip edge in vect_create_epilog_for_reduction.  */\n+\t  accumulator->reduc_input = def;\n+\t  if (loop_vinfo->main_loop_edge)\n+\t    {\n+\t      /* While we'd like to insert on the edge this will split\n+\t\t blocks and disturb bookkeeping, we also will eventually\n+\t\t need this on the skip edge.  Rely on sinking to\n+\t\t fixup optimal placement and insert in the pred.  */\n+\t      gimple_stmt_iterator gsi\n+\t\t= gsi_last_bb (loop_vinfo->main_loop_edge->src);\n+\t      /* Insert before a cond that eventually skips the\n+\t\t epilogue.  */\n+\t      if (!gsi_end_p (gsi) && stmt_ends_bb_p (gsi_stmt (gsi)))\n+\t\tgsi_prev (&gsi);\n+\t      gsi_insert_seq_after (&gsi, stmts, GSI_CONTINUE_LINKING);\n+\t    }\n+\t  else\n+\t    gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop),\n+\t\t\t\t\t      stmts);\n+\t}\n       if (loop_vinfo->main_loop_edge)\n \tvec_initial_defs[0]\n-\t  = vect_get_main_loop_result (loop_vinfo, accumulator->reduc_input,\n+\t  = vect_get_main_loop_result (loop_vinfo, def,\n \t\t\t\t       vec_initial_defs[0]);\n       else\n-\tvec_initial_defs.safe_push (accumulator->reduc_input);\n-      gcc_assert (vec_initial_defs.length () == 1);\n+\tvec_initial_defs.safe_push (def);\n     }\n \n   /* Generate the reduction PHIs upfront.  */"}]}