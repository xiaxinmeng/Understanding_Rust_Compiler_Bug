{"sha": "2c83faf86827bf5d49ededf3baf8c89a432028ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM4M2ZhZjg2ODI3YmY1ZDQ5ZWRlZGYzYmFmOGM4OWE0MzIwMjhlZQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2015-07-09T18:55:01Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2015-07-09T18:55:01Z"}, "message": "rs6000-protos.h (rs6000_secondary_reload_memory): Use machine mode, not enum machine_mode in the prototype.\n\n2015-07-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000-protos.h (rs6000_secondary_reload_memory):\n\tUse machine mode, not enum machine_mode in the prototype.\n\n\t* config/rs6000/rs6000.h (FLOAT128_IEEE_P): New helper macros to\n\tclassify 128-bit floating point support.\n\t(FLOAT128_IBM_P): Likewise.\n\t(FLOAT128_VECTOR_P): Likewise.\n\t(FLOAT128_2REG_P): Likewise.\n\t(SCALAR_FLOAT_MODE_NOT_VECTOR_P): Likewise.\n\t(SLOW_UNALIGNED_ACCESS): Add IEEE 128-bit floating point support.\n\t(HARD_REGNO_CALLER_SAVE_MODE): Likewise.\n\t(HARD_REGNO_CALL_PART_CLOBBERED): Likewise.\n\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_nregs_internal): Drop\n\ttests against TFmode/TDmode, since those modes do not use VSX\n\taddresses.\n\t(rs6000_hard_regno_mode_ok): Add IEEE 128-bit floating point\n\tsupport.\n\t(rs6000_init_hard_regno_mode_ok): Use new helper macros instead of\n\ttests against TFmode, etc.\n\t(invalid_e500_subreg): Add tests against IFmode/KFmode.\n\t(reg_offset_addressing_ok_p): Likewise.\n\t(rs6000_legitimate_offset_address_p): Likewise.\n\t(rs6000_legitimize_address): Likewise.\n\t(rs6000_legitimize_reload_address): Likewise.\n\t(rs6000_legitimate_address_p): Clean up tests against TFmode and\n\tTDmode to use the new helper macros, which will include IFmode and\n\tKFmode.\n\t(rs6000_emit_move): Likewise.\n\t(rs6000_darwin64_record_arg_recurse): Likewise.\n\t(print_operand): Likewise.\n\t(rs6000_member_type_forces_blk): Treat IEEE 128-bit floating point\n\tthat uses a single vector register as a vector and not as a\n\tfloating point register in terms of the calling sequence.\n\t(rs6000_discover_homogeneous_aggregate): Likewise.\n\t(rs6000_return_in_memory): Likewise.\n\t(init_cumulative_args): Likewise.\n\t(rs6000_function_arg_boundary): Likewise.\n\t(rs6000_function_arg_advance_1): Likewise.\n\t(rs6000_function_arg): Likewise.\n\t(rs6000_pass_by_reference): Likewise.\n\t(rs6000_gimplify_va_arg): Likewise.\n\t(rs6000_secondary_reload_memory): Use machine_mode not enum\n\tmachine mode.\n\t(rs6000_split_multireg_move): Use new helper macros.\n\t(spe_func_has_64bit_regs_p): Likewise.\n\t(rs6000_output_function_epilogue): Add IFmode/KFmode support.\n\t(output_toc): Use new helper macros.\n\t(rs6000_register_move_cost): Likewise.\n\t(rs6000_function_value): Add IEEE 128-bit floating point calling\n\tsequence support.\n\t(rs6000_libcall_value): Likewise.\n\t(rs6000_scalar_mode_supported_p): Add support for IEEE 128-bit\n\tfloating point support.\n\t(rs6000_vector_mode_supported_p): Likewise.\n\nFrom-SVN: r225631", "tree": {"sha": "99fce879e10483a69a5c8acdd84c65ab3faa7d2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99fce879e10483a69a5c8acdd84c65ab3faa7d2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c83faf86827bf5d49ededf3baf8c89a432028ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c83faf86827bf5d49ededf3baf8c89a432028ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c83faf86827bf5d49ededf3baf8c89a432028ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c83faf86827bf5d49ededf3baf8c89a432028ee/comments", "author": null, "committer": null, "parents": [{"sha": "1bf3fe3c6ac33ed15c7502b88d8ce5758ee2b139", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bf3fe3c6ac33ed15c7502b88d8ce5758ee2b139", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bf3fe3c6ac33ed15c7502b88d8ce5758ee2b139"}], "stats": {"total": 173, "additions": 113, "deletions": 60}, "files": [{"sha": "7a1f4c428333a8de80d19b08c49732d5530670e3", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c83faf86827bf5d49ededf3baf8c89a432028ee/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c83faf86827bf5d49ededf3baf8c89a432028ee/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=2c83faf86827bf5d49ededf3baf8c89a432028ee", "patch": "@@ -133,8 +133,7 @@ extern void rs6000_split_multireg_move (rtx, rtx);\n extern void rs6000_emit_le_vsx_move (rtx, rtx, machine_mode);\n extern void rs6000_emit_move (rtx, rtx, machine_mode);\n extern rtx rs6000_secondary_memory_needed_rtx (machine_mode);\n-extern machine_mode rs6000_secondary_memory_needed_mode (enum\n-\t\t\t\t\t\t\t      machine_mode);\n+extern machine_mode rs6000_secondary_memory_needed_mode (machine_mode);\n extern rtx (*rs6000_legitimize_reload_address_ptr) (rtx, machine_mode,\n \t\t\t\t\t\t    int, int, int, int *);\n extern bool rs6000_legitimate_offset_address_p (machine_mode, rtx,"}, {"sha": "cac1de5abb98d767daf7f76a2a6e993dac5c7cc7", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 80, "deletions": 51, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c83faf86827bf5d49ededf3baf8c89a432028ee/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c83faf86827bf5d49ededf3baf8c89a432028ee/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2c83faf86827bf5d49ededf3baf8c89a432028ee", "patch": "@@ -1740,9 +1740,11 @@ rs6000_hard_regno_nregs_internal (int regno, machine_mode mode)\n {\n   unsigned HOST_WIDE_INT reg_size;\n \n-  /* TF/TD modes are special in that they always take 2 registers.  */\n+  /* 128-bit floating point usually takes 2 registers, unless it is IEEE\n+     128-bit floating point that can go in vector registers, which has VSX\n+     memory addressing.  */\n   if (FP_REGNO_P (regno))\n-    reg_size = ((VECTOR_MEM_VSX_P (mode) && mode != TDmode && mode != TFmode)\n+    reg_size = (VECTOR_MEM_VSX_P (mode)\n \t\t? UNITS_PER_VSX_WORD\n \t\t: UNITS_PER_FP_WORD);\n \n@@ -1799,6 +1801,7 @@ rs6000_hard_regno_mode_ok (int regno, machine_mode mode)\n      asked for it.  */\n   if (TARGET_VSX && VSX_REGNO_P (regno)\n       && (VECTOR_MEM_VSX_P (mode)\n+\t  || FLOAT128_VECTOR_P (mode)\n \t  || reg_addr[mode].scalar_in_vmx_p\n \t  || (TARGET_VSX_TIMODE && mode == TImode)\n \t  || (TARGET_VADDUQM && mode == V1TImode)))\n@@ -1824,6 +1827,9 @@ rs6000_hard_regno_mode_ok (int regno, machine_mode mode)\n      modes and DImode.  */\n   if (FP_REGNO_P (regno))\n     {\n+      if (FLOAT128_VECTOR_P (mode))\n+\treturn false;\n+\n       if (SCALAR_FLOAT_MODE_P (mode)\n \t  && (mode != TDmode || (regno % 2) == 0)\n \t  && FP_REGNO_P (last_regno))\n@@ -2999,9 +3005,9 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t  machine_mode m2 = (machine_mode)m;\n \t  int reg_size2 = reg_size;\n \n-\t  /* TFmode/TDmode always takes 2 registers, even in VSX.  */\n-\t  if (TARGET_VSX && VSX_REG_CLASS_P (c)\n-\t      && (m == TDmode || m == TFmode))\n+\t  /* TDmode & IBM 128-bit floating point always takes 2 registers, even\n+\t     in VSX.  */\n+\t  if (TARGET_VSX && VSX_REG_CLASS_P (c) && FLOAT128_2REG_P (m))\n \t    reg_size2 = UNITS_PER_FP_WORD;\n \n \t  rs6000_class_max_nregs[m][c]\n@@ -6106,13 +6112,16 @@ invalid_e500_subreg (rtx op, machine_mode mode)\n \t      || mode == DDmode || mode == TDmode || mode == PTImode)\n \t  && REG_P (SUBREG_REG (op))\n \t  && (GET_MODE (SUBREG_REG (op)) == DFmode\n-\t      || GET_MODE (SUBREG_REG (op)) == TFmode))\n+\t      || GET_MODE (SUBREG_REG (op)) == TFmode\n+\t      || GET_MODE (SUBREG_REG (op)) == IFmode\n+\t      || GET_MODE (SUBREG_REG (op)) == KFmode))\n \treturn true;\n \n       /* Reject (subreg:DF (reg:DI)); likewise with subreg:TF and\n \t reg:TI.  */\n       if (GET_CODE (op) == SUBREG\n-\t  && (mode == DFmode || mode == TFmode)\n+\t  && (mode == DFmode || mode == TFmode || mode == IFmode\n+\t      || mode == KFmode)\n \t  && REG_P (SUBREG_REG (op))\n \t  && (GET_MODE (SUBREG_REG (op)) == DImode\n \t      || GET_MODE (SUBREG_REG (op)) == TImode\n@@ -6474,10 +6483,13 @@ reg_offset_addressing_ok_p (machine_mode mode)\n     case V2DImode:\n     case V1TImode:\n     case TImode:\n+    case TFmode:\n+    case KFmode:\n       /* AltiVec/VSX vector modes.  Only reg+reg addressing is valid.  While\n \t TImode is not a vector mode, if we want to use the VSX registers to\n-\t move it around, we need to restrict ourselves to reg+reg\n-\t addressing.  */\n+\t move it around, we need to restrict ourselves to reg+reg addressing.\n+\t Similarly for IEEE 128-bit floating point that is passed in a single\n+\t vector register.  */\n       if (VECTOR_MEM_ALTIVEC_OR_VSX_P (mode))\n \treturn false;\n       break;\n@@ -6743,6 +6755,8 @@ rs6000_legitimate_offset_address_p (machine_mode mode, rtx x,\n       break;\n \n     case TFmode:\n+    case IFmode:\n+    case KFmode:\n       if (TARGET_E500_DOUBLE)\n \treturn (SPE_CONST_OFFSET_OK (offset)\n \t\t&& SPE_CONST_OFFSET_OK (offset + 8));\n@@ -6936,6 +6950,8 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n     case TDmode:\n     case TImode:\n     case PTImode:\n+    case IFmode:\n+    case KFmode:\n       /* As in legitimate_offset_address_p we do not assume\n \t worst-case.  The mode here is just a hint as to the registers\n \t used.  A TImode is usually in gprs, but may actually be in\n@@ -7708,6 +7724,8 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n       && !reg_addr[mode].scalar_in_vmx_p\n       && mode != TFmode\n       && mode != TDmode\n+      && mode != IFmode\n+      && mode != KFmode\n       && (mode != TImode || !TARGET_VSX_TIMODE)\n       && mode != PTImode\n       && (mode != DImode || TARGET_POWERPC64)\n@@ -7861,8 +7879,7 @@ rs6000_legitimate_address_p (machine_mode mode, rtx x, bool reg_ok_strict)\n     return 1;\n   if (rs6000_legitimate_offset_address_p (mode, x, reg_ok_strict, false))\n     return 1;\n-  if (mode != TFmode\n-      && mode != TDmode\n+  if (!FLOAT128_2REG_P (mode)\n       && ((TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)\n \t  || TARGET_POWERPC64\n \t  || (mode != DFmode && mode != DDmode)\n@@ -8530,9 +8547,8 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n   /* 128-bit constant floating-point values on Darwin should really be loaded\n      as two parts.  However, this premature splitting is a problem when DFmode\n      values can go into Altivec registers.  */\n-  if (!TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\n-      && !reg_addr[DFmode].scalar_in_vmx_p\n-      && mode == TFmode && GET_CODE (operands[1]) == CONST_DOUBLE)\n+  if (FLOAT128_IBM_P (mode) && !reg_addr[DFmode].scalar_in_vmx_p\n+      && GET_CODE (operands[1]) == CONST_DOUBLE)\n     {\n       rs6000_emit_move (simplify_gen_subreg (DFmode, operands[0], mode, 0),\n \t\t\tsimplify_gen_subreg (DFmode, operands[1], mode, 0),\n@@ -8724,7 +8740,10 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n \n     case TFmode:\n     case TDmode:\n-      rs6000_eliminate_indexed_memrefs (operands);\n+    case IFmode:\n+    case KFmode:\n+      if (FLOAT128_2REG_P (mode))\n+\trs6000_eliminate_indexed_memrefs (operands);\n       /* fall through */\n \n     case DFmode:\n@@ -8948,7 +8967,7 @@ rs6000_member_type_forces_blk (const_tree field, machine_mode mode)\n \f\n /* Nonzero if we can use a floating-point register to pass this arg.  */\n #define USE_FP_FOR_ARG_P(CUM,MODE)\t\t\\\n-  (SCALAR_FLOAT_MODE_P (MODE)\t\t\t\\\n+  (SCALAR_FLOAT_MODE_NOT_VECTOR_P (MODE)\t\t\\\n    && (CUM)->fregno <= FP_ARG_MAX_REG\t\t\\\n    && TARGET_HARD_FLOAT && TARGET_FPRS)\n \n@@ -9149,7 +9168,7 @@ rs6000_discover_homogeneous_aggregate (machine_mode mode, const_tree type,\n \n       if (field_count > 0)\n \t{\n-\t  int n_regs = (SCALAR_FLOAT_MODE_P (field_mode)?\n+\t  int n_regs = (SCALAR_FLOAT_MODE_P (field_mode) ?\n \t\t\t(GET_MODE_SIZE (field_mode) + 7) >> 3 : 1);\n \n \t  /* The ELFv2 ABI allows homogeneous aggregates to occupy\n@@ -9259,7 +9278,8 @@ rs6000_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n       return true;\n     }\n \n-  if (DEFAULT_ABI == ABI_V4 && TARGET_IEEEQUAD && TYPE_MODE (type) == TFmode)\n+  if (DEFAULT_ABI == ABI_V4 && TARGET_IEEEQUAD\n+      && FLOAT128_IEEE_P (TYPE_MODE (type)))\n     return true;\n \n   return false;\n@@ -9389,7 +9409,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n \t\t      <= 8))\n \t\trs6000_returns_struct = true;\n \t    }\n-\t  if (SCALAR_FLOAT_MODE_P (return_mode))\n+\t  if (SCALAR_FLOAT_MODE_NOT_VECTOR_P (return_mode))\n \t    rs6000_passes_float = true;\n \t  else if (ALTIVEC_OR_VSX_VECTOR_MODE (return_mode)\n \t\t   || SPE_VECTOR_MODE (return_mode))\n@@ -9527,8 +9547,10 @@ rs6000_function_arg_boundary (machine_mode mode, const_tree type)\n       && (GET_MODE_SIZE (mode) == 8\n \t  || (TARGET_HARD_FLOAT\n \t      && TARGET_FPRS\n-\t      && (mode == TFmode || mode == TDmode))))\n+\t      && FLOAT128_2REG_P (mode))))\n     return 64;\n+  else if (FLOAT128_VECTOR_P (mode))\n+    return 128;\n   else if (SPE_VECTOR_MODE (mode)\n \t   || (type && TREE_CODE (type) == VECTOR_TYPE\n \t       && int_size_in_bytes (type) >= 8\n@@ -9800,7 +9822,7 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, machine_mode mode,\n   if (DEFAULT_ABI == ABI_V4\n       && cum->escapes)\n     {\n-      if (SCALAR_FLOAT_MODE_P (mode))\n+      if (SCALAR_FLOAT_MODE_NOT_VECTOR_P (mode))\n \trs6000_passes_float = true;\n       else if (named && ALTIVEC_OR_VSX_VECTOR_MODE (mode))\n \trs6000_passes_vector = true;\n@@ -9907,21 +9929,21 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, machine_mode mode,\n       if (TARGET_HARD_FLOAT && TARGET_FPRS\n \t  && ((TARGET_SINGLE_FLOAT && mode == SFmode)\n \t      || (TARGET_DOUBLE_FLOAT && mode == DFmode)\n-\t      || (mode == TFmode && !TARGET_IEEEQUAD)\n-\t      || mode == SDmode || mode == DDmode || mode == TDmode))\n+\t      || FLOAT128_2REG_P (mode)\n+\t      || DECIMAL_FLOAT_MODE_P (mode)))\n \t{\n \t  /* _Decimal128 must use an even/odd register pair.  This assumes\n \t     that the register number is odd when fregno is odd.  */\n \t  if (mode == TDmode && (cum->fregno % 2) == 1)\n \t    cum->fregno++;\n \n-\t  if (cum->fregno + (mode == TFmode || mode == TDmode ? 1 : 0)\n+\t  if (cum->fregno + (FLOAT128_2REG_P (mode) ? 1 : 0)\n \t      <= FP_ARG_V4_MAX_REG)\n \t    cum->fregno += (GET_MODE_SIZE (mode) + 7) >> 3;\n \t  else\n \t    {\n \t      cum->fregno = FP_ARG_V4_MAX_REG + 1;\n-\t      if (mode == DFmode || mode == TFmode\n+\t      if (mode == DFmode || FLOAT128_IBM_P (mode)\n \t\t  || mode == DDmode || mode == TDmode)\n \t\tcum->words += cum->words & 1;\n \t      cum->words += rs6000_arg_size (mode, type);\n@@ -9973,8 +9995,7 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, machine_mode mode,\n \n       cum->words = align_words + n_words;\n \n-      if (SCALAR_FLOAT_MODE_P (elt_mode)\n-\t  && TARGET_HARD_FLOAT && TARGET_FPRS)\n+      if (SCALAR_FLOAT_MODE_P (elt_mode) && TARGET_HARD_FLOAT && TARGET_FPRS)\n \t{\n \t  /* _Decimal128 must be passed in an even/odd float register pair.\n \t     This assumes that the register number is odd when fregno is\n@@ -10216,7 +10237,7 @@ rs6000_darwin64_record_arg_recurse (CUMULATIVE_ARGS *cum, const_tree type,\n \t      = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t   gen_rtx_REG (mode, cum->fregno++),\n \t\t\t\t   GEN_INT (bitpos / BITS_PER_UNIT));\n-\t    if (mode == TFmode || mode == TDmode)\n+\t    if (FLOAT128_2REG_P (mode))\n \t      cum->fregno++;\n \t  }\n \telse if (cum->named && USE_ALTIVEC_FOR_ARG_P (cum, mode, 1))\n@@ -10567,15 +10588,15 @@ rs6000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n       if (TARGET_HARD_FLOAT && TARGET_FPRS\n \t  && ((TARGET_SINGLE_FLOAT && mode == SFmode)\n \t      || (TARGET_DOUBLE_FLOAT && mode == DFmode)\n-\t      || (mode == TFmode && !TARGET_IEEEQUAD)\n-\t      || mode == SDmode || mode == DDmode || mode == TDmode))\n+\t      || FLOAT128_2REG_P (mode)\n+\t      || DECIMAL_FLOAT_MODE_P (mode)))\n \t{\n \t  /* _Decimal128 must use an even/odd register pair.  This assumes\n \t     that the register number is odd when fregno is odd.  */\n \t  if (mode == TDmode && (cum->fregno % 2) == 1)\n \t    cum->fregno++;\n \n-\t  if (cum->fregno + (mode == TFmode || mode == TDmode ? 1 : 0)\n+\t  if (cum->fregno + (FLOAT128_2REG_P (mode) ? 1 : 0)\n \t      <= FP_ARG_V4_MAX_REG)\n \t    return gen_rtx_REG (mode, cum->fregno);\n \t  else\n@@ -10637,7 +10658,7 @@ rs6000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t      machine_mode fmode = elt_mode;\n \t      if (cum->fregno + (i + 1) * n_fpreg > FP_ARG_MAX_REG + 1)\n \t\t{\n-\t\t  gcc_assert (fmode == TFmode || fmode == TDmode);\n+\t\t  gcc_assert (FLOAT128_2REG_P (fmode));\n \t\t  fmode = DECIMAL_FLOAT_MODE_P (fmode) ? DDmode : DFmode;\n \t\t}\n \n@@ -10811,10 +10832,11 @@ rs6000_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \t\t\t  machine_mode mode, const_tree type,\n \t\t\t  bool named ATTRIBUTE_UNUSED)\n {\n-  if (DEFAULT_ABI == ABI_V4 && TARGET_IEEEQUAD && mode == TFmode)\n+  if (DEFAULT_ABI == ABI_V4 && TARGET_IEEEQUAD\n+      && FLOAT128_IEEE_P (TYPE_MODE (type)))\n     {\n       if (TARGET_DEBUG_ARG)\n-\tfprintf (stderr, \"function_arg_pass_by_reference: V4 long double\\n\");\n+\tfprintf (stderr, \"function_arg_pass_by_reference: V4 IEEE 128-bit\\n\");\n       return 1;\n     }\n \n@@ -11489,10 +11511,8 @@ rs6000_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n       && ((TARGET_SINGLE_FLOAT && TYPE_MODE (type) == SFmode)\n           || (TARGET_DOUBLE_FLOAT \n               && (TYPE_MODE (type) == DFmode \n- \t          || TYPE_MODE (type) == TFmode\n-\t          || TYPE_MODE (type) == SDmode\n-\t          || TYPE_MODE (type) == DDmode\n-\t          || TYPE_MODE (type) == TDmode))))\n+\t\t  || FLOAT128_2REG_P (TYPE_MODE (type))\n+\t\t  || DECIMAL_FLOAT_MODE_P (TYPE_MODE (type))))))\n     {\n       /* FP args go in FP registers, if present.  */\n       reg = fpr;\n@@ -16755,7 +16775,7 @@ rs6000_secondary_reload_toc_costs (addr_mask_type addr_mask)\n static int\n rs6000_secondary_reload_memory (rtx addr,\n \t\t\t\tenum reg_class rclass,\n-\t\t\t\tenum machine_mode mode)\n+\t\t\t\tmachine_mode mode)\n {\n   int extra_cost = 0;\n   rtx reg, and_arg, plus_arg0, plus_arg1;\n@@ -19053,7 +19073,7 @@ print_operand (FILE *file, rtx x, int code)\n \t/* Ugly hack because %y is overloaded.  */\n \tif ((TARGET_SPE || TARGET_E500_DOUBLE)\n \t    && (GET_MODE_SIZE (GET_MODE (x)) == 8\n-\t\t|| GET_MODE (x) == TFmode\n+\t\t|| FLOAT128_2REG_P (GET_MODE (x))\n \t\t|| GET_MODE (x) == TImode\n \t\t|| GET_MODE (x) == PTImode))\n \t  {\n@@ -21003,7 +21023,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT) ? DFmode : SFmode);\n   else if (ALTIVEC_REGNO_P (reg))\n     reg_mode = V16QImode;\n-  else if (TARGET_E500_DOUBLE && mode == TFmode)\n+  else if (TARGET_E500_DOUBLE && FLOAT128_2REG_P (mode))\n     reg_mode = DFmode;\n   else\n     reg_mode = word_mode;\n@@ -22080,7 +22100,8 @@ spe_func_has_64bit_regs_p (void)\n \n \t      if (SPE_VECTOR_MODE (mode))\n \t\treturn true;\n-\t      if (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode))\n+\t      if (TARGET_E500_DOUBLE\n+\t\t  && (mode == DFmode || FLOAT128_2REG_P (mode)))\n \t\treturn true;\n \t    }\n \t}\n@@ -25843,6 +25864,8 @@ rs6000_output_function_epilogue (FILE *file,\n \t\t\tcase DDmode:\n \t\t\tcase TFmode:\n \t\t\tcase TDmode:\n+\t\t\tcase IFmode:\n+\t\t\tcase KFmode:\n \t\t\t  bits = 0x3;\n \t\t\t  break;\n \n@@ -26516,7 +26539,8 @@ output_toc (FILE *file, rtx x, int labelno, machine_mode mode)\n      TOC, things we put here aren't actually in the TOC, so we can allow\n      FP constants.  */\n   if (GET_CODE (x) == CONST_DOUBLE &&\n-      (GET_MODE (x) == TFmode || GET_MODE (x) == TDmode))\n+      (GET_MODE (x) == TFmode || GET_MODE (x) == TDmode\n+       || GET_MODE (x) == IFmode || GET_MODE (x) == KFmode))\n     {\n       REAL_VALUE_TYPE rv;\n       long k[4];\n@@ -31040,7 +31064,7 @@ rs6000_register_move_cost (machine_mode mode,\n \n   /* Moving between two similar registers is just one instruction.  */\n   else if (reg_classes_intersect_p (to, from))\n-    ret = (mode == TFmode || mode == TDmode) ? 4 : 2;\n+    ret = (FLOAT128_2REG_P (mode)) ? 4 : 2;\n \n   /* Everything else has to go through GENERAL_REGS.  */\n   else\n@@ -32107,7 +32131,7 @@ rs6000_function_value (const_tree valtype,\n     {\n       int first_reg, n_regs;\n \n-      if (SCALAR_FLOAT_MODE_P (elt_mode))\n+      if (SCALAR_FLOAT_MODE_NOT_VECTOR_P (elt_mode))\n \t{\n \t  /* _Decimal128 must use even/odd register pairs.  */\n \t  first_reg = (elt_mode == TDmode) ? FP_ARG_RETURN + 1 : FP_ARG_RETURN;\n@@ -32144,7 +32168,7 @@ rs6000_function_value (const_tree valtype,\n   if (DECIMAL_FLOAT_MODE_P (mode) && TARGET_HARD_FLOAT && TARGET_FPRS)\n     /* _Decimal128 must use an even/odd register pair.  */\n     regno = (mode == TDmode) ? FP_ARG_RETURN + 1 : FP_ARG_RETURN;\n-  else if (SCALAR_FLOAT_TYPE_P (valtype) && TARGET_HARD_FLOAT && TARGET_FPRS\n+  else if (SCALAR_FLOAT_MODE_NOT_VECTOR_P (mode) && TARGET_HARD_FLOAT && TARGET_FPRS\n \t   && ((TARGET_SINGLE_FLOAT && (mode == SFmode)) || TARGET_DOUBLE_FLOAT))\n     regno = FP_ARG_RETURN;\n   else if (TREE_CODE (valtype) == COMPLEX_TYPE\n@@ -32153,13 +32177,13 @@ rs6000_function_value (const_tree valtype,\n   /* VSX is a superset of Altivec and adds V2DImode/V2DFmode.  Since the same\n      return register is used in both cases, and we won't see V2DImode/V2DFmode\n      for pure altivec, combine the two cases.  */\n-  else if (TREE_CODE (valtype) == VECTOR_TYPE\n+  else if ((TREE_CODE (valtype) == VECTOR_TYPE || FLOAT128_VECTOR_P (mode))\n \t   && TARGET_ALTIVEC && TARGET_ALTIVEC_ABI\n \t   && ALTIVEC_OR_VSX_VECTOR_MODE (mode))\n     regno = ALTIVEC_ARG_RETURN;\n   else if (TARGET_E500_DOUBLE && TARGET_HARD_FLOAT\n \t   && (mode == DFmode || mode == DCmode\n-\t       || mode == TFmode || mode == TCmode))\n+\t       || FLOAT128_IBM_P (mode) || mode == TCmode))\n     return spe_build_register_parallel (mode, GP_ARG_RETURN);\n   else\n     regno = GP_ARG_RETURN;\n@@ -32181,7 +32205,7 @@ rs6000_libcall_value (machine_mode mode)\n   if (DECIMAL_FLOAT_MODE_P (mode) && TARGET_HARD_FLOAT && TARGET_FPRS)\n     /* _Decimal128 must use an even/odd register pair.  */\n     regno = (mode == TDmode) ? FP_ARG_RETURN + 1 : FP_ARG_RETURN;\n-  else if (SCALAR_FLOAT_MODE_P (mode)\n+  else if (SCALAR_FLOAT_MODE_NOT_VECTOR_P (mode)\n \t   && TARGET_HARD_FLOAT && TARGET_FPRS\n            && ((TARGET_SINGLE_FLOAT && mode == SFmode) || TARGET_DOUBLE_FLOAT))\n     regno = FP_ARG_RETURN;\n@@ -32195,7 +32219,7 @@ rs6000_libcall_value (machine_mode mode)\n     return rs6000_complex_function_value (mode);\n   else if (TARGET_E500_DOUBLE && TARGET_HARD_FLOAT\n \t   && (mode == DFmode || mode == DCmode\n-\t       || mode == TFmode || mode == TCmode))\n+\t       || FLOAT128_IBM_P (mode) || mode == TCmode))\n     return spe_build_register_parallel (mode, GP_ARG_RETURN);\n   else\n     regno = GP_ARG_RETURN;\n@@ -32421,6 +32445,8 @@ rs6000_scalar_mode_supported_p (machine_mode mode)\n \n   if (DECIMAL_FLOAT_MODE_P (mode))\n     return default_decimal_float_supported_p ();\n+  else if (mode == KFmode)\n+    return TARGET_FLOAT128;\n   else\n     return default_scalar_mode_supported_p (mode);\n }\n@@ -32436,7 +32462,10 @@ rs6000_vector_mode_supported_p (machine_mode mode)\n   if (TARGET_SPE && SPE_VECTOR_MODE (mode))\n     return true;\n \n-  else if (VECTOR_MEM_ALTIVEC_OR_VSX_P (mode))\n+  /* There is no vector form for IEEE 128-bit.  If we return true for IEEE\n+     128-bit, the compiler might try to widen IEEE 128-bit to IBM\n+     double-double.  */\n+  else if (VECTOR_MEM_ALTIVEC_OR_VSX_P (mode) && !FLOAT128_IEEE_P (mode))\n     return true;\n \n   else"}, {"sha": "f253689eb0c31c72cf7f17eb36c0b60514caf2f9", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c83faf86827bf5d49ededf3baf8c89a432028ee/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c83faf86827bf5d49ededf3baf8c89a432028ee/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=2c83faf86827bf5d49ededf3baf8c89a432028ee", "patch": "@@ -402,6 +402,33 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define TARGET_DEBUG_TARGET\t(rs6000_debug & MASK_DEBUG_TARGET)\n #define TARGET_DEBUG_BUILTIN\t(rs6000_debug & MASK_DEBUG_BUILTIN)\n \n+/* Helper macros for TFmode.  Quad floating point (TFmode) can be either IBM\n+   long double format that uses a pair of doubles, or IEEE 128-bit floating\n+   point.  KFmode was added as a way to represent IEEE 128-bit floating point,\n+   even if the default for long double is the IBM long double format.\n+   Similarly IFmode is the IBM long double format even if the default is IEEE\n+   128-bit.  */\n+#define FLOAT128_IEEE_P(MODE)\t\t\t\t\t\t\\\n+  (((MODE) == TFmode && TARGET_IEEEQUAD)\t\t\t\t\\\n+   || ((MODE) == KFmode))\n+\n+#define FLOAT128_IBM_P(MODE)\t\t\t\t\t\t\\\n+  (((MODE) == TFmode && !TARGET_IEEEQUAD)\t\t\t\t\\\n+   || ((MODE) == IFmode))\n+\n+/* Helper macros to say whether a 128-bit floating point type can go in a\n+   single vector register, or whether it needs paired scalar values.  */\n+#define FLOAT128_VECTOR_P(MODE) (TARGET_FLOAT128 && FLOAT128_IEEE_P (MODE))\n+\n+#define FLOAT128_2REG_P(MODE)\t\t\t\t\t\t\\\n+  (FLOAT128_IBM_P (MODE)\t\t\t\t\t\t\\\n+   || ((MODE) == TDmode)\t\t\t\t\t\t\\\n+   || (!TARGET_FLOAT128 && FLOAT128_IEEE_P (MODE)))\n+\n+/* Return true for floating point that does not use a vector register.  */\n+#define SCALAR_FLOAT_MODE_NOT_VECTOR_P(MODE)\t\t\t\t\\\n+  (SCALAR_FLOAT_MODE_P (MODE) && !FLOAT128_VECTOR_P (MODE))\n+\n /* Describe the vector unit used for arithmetic operations.  */\n extern enum rs6000_vector rs6000_vector_unit[];\n \n@@ -888,11 +915,10 @@ enum data_align { align_abi, align_opt, align_both };\n    aligned to 4 or 8 bytes.  */\n #define SLOW_UNALIGNED_ACCESS(MODE, ALIGN)\t\t\t\t\\\n   (STRICT_ALIGNMENT\t\t\t\t\t\t\t\\\n-   || (((MODE) == SFmode || (MODE) == DFmode || (MODE) == TFmode\t\\\n-\t|| (MODE) == SDmode || (MODE) == DDmode || (MODE) == TDmode)\t\\\n-       && (ALIGN) < 32)\t\t\t\t\t\t\t\\\n+   || (SCALAR_FLOAT_MODE_NOT_VECTOR_P (MODE) && (ALIGN) < 32)\t\t\\\n    || (!TARGET_EFFICIENT_UNALIGNED_VSX                                  \\\n-       && (VECTOR_MODE_P ((MODE)) && (((int)(ALIGN)) < VECTOR_ALIGN (MODE)))))\n+       && ((VECTOR_MODE_P (MODE) || FLOAT128_VECTOR_P (MODE))\t\t\\\n+\t   && (((int)(ALIGN)) < VECTOR_ALIGN (MODE)))))\n \n \f\n /* Standard register usage.  */\n@@ -1174,7 +1200,7 @@ enum data_align { align_abi, align_opt, align_both };\n    ? V2DFmode\t\t\t\t\t\t\t\t\\\n    : TARGET_E500_DOUBLE && ((MODE) == VOIDmode || (MODE) == DFmode)\t\\\n    ? DFmode\t\t\t\t\t\t\t\t\\\n-   : !TARGET_E500_DOUBLE && (MODE) == TFmode && FP_REGNO_P (REGNO)\t\\\n+   : !TARGET_E500_DOUBLE && FLOAT128_IBM_P (MODE) && FP_REGNO_P (REGNO)\t\\\n    ? DFmode\t\t\t\t\t\t\t\t\\\n    : !TARGET_E500_DOUBLE && (MODE) == TDmode && FP_REGNO_P (REGNO)\t\\\n    ? DImode\t\t\t\t\t\t\t\t\\\n@@ -1185,8 +1211,7 @@ enum data_align { align_abi, align_opt, align_both };\n      && (GET_MODE_SIZE (MODE) > 4)\t\t\t\t\t\\\n      && INT_REGNO_P (REGNO)) ? 1 : 0)\t\t\t\t\t\\\n    || (TARGET_VSX && FP_REGNO_P (REGNO)\t\t\t\t\t\\\n-       && GET_MODE_SIZE (MODE) > 8 && ((MODE) != TDmode) \t\t\\\n-       && ((MODE) != TFmode)))\n+       && GET_MODE_SIZE (MODE) > 8 && !FLOAT128_2REG_P (MODE)))\n \n #define VSX_VECTOR_MODE(MODE)\t\t\\\n \t ((MODE) == V4SFmode\t\t\\"}]}