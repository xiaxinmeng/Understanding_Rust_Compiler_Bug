{"sha": "e0e3ce634818b83965b87512938490df4d57f81d", "node_id": "C_kwDOANBUbNoAKGUwZTNjZTYzNDgxOGI4Mzk2NWI4NzUxMjkzODQ5MGRmNGQ1N2Y4MWQ", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2022-06-09T19:45:03Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2022-06-14T17:31:15Z"}, "message": "rs6000: Delete VS_scalar\n\nIt is just the same as VEC_base, which is a more generic name.\n\n2022-06-14  Segher Boessenkool  <segher@kernel.crashing.org>\n\n\t* config/rs6000/vsx.md (VS_scalar): Delete.\n\t(rest of file): Adjust.", "tree": {"sha": "a1deaa9bd2d4cfbc819231507235657003aa2ed0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1deaa9bd2d4cfbc819231507235657003aa2ed0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0e3ce634818b83965b87512938490df4d57f81d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0e3ce634818b83965b87512938490df4d57f81d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0e3ce634818b83965b87512938490df4d57f81d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0e3ce634818b83965b87512938490df4d57f81d/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8609768fbbc1ec650fe245cb45ee6d893ade3d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8609768fbbc1ec650fe245cb45ee6d893ade3d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8609768fbbc1ec650fe245cb45ee6d893ade3d7"}], "stats": {"total": 141, "additions": 66, "deletions": 75}, "files": [{"sha": "e226a93bbe551564d6872551b1b5cb4c6c7bc017", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 66, "deletions": 75, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e3ce634818b83965b87512938490df4d57f81d/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e3ce634818b83965b87512938490df4d57f81d/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=e0e3ce634818b83965b87512938490df4d57f81d", "patch": "@@ -186,15 +186,6 @@\n \t\t\t\t (V4SF \"vecfdiv\")\n \t\t\t\t (DF   \"ddiv\")])\n \n-;; Map the scalar mode for a vector type\n-(define_mode_attr VS_scalar [(V1TI\t\"TI\")\n-\t\t\t     (V2DF\t\"DF\")\n-\t\t\t     (V2DI\t\"DI\")\n-\t\t\t     (V4SF\t\"SF\")\n-\t\t\t     (V4SI\t\"SI\")\n-\t\t\t     (V8HI\t\"HI\")\n-\t\t\t     (V16QI\t\"QI\")])\n-\n ;; Map to a double-sized vector mode\n (define_mode_attr VS_double [(V4SI\t\"V8SI\")\n \t\t\t     (V4SF\t\"V8SF\")\n@@ -2996,8 +2987,8 @@\n (define_insn \"vsx_concat_<mode>\"\n   [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wa,we\")\n \t(vec_concat:VSX_D\n-\t (match_operand:<VS_scalar> 1 \"gpc_reg_operand\" \"wa,b\")\n-\t (match_operand:<VS_scalar> 2 \"gpc_reg_operand\" \"wa,b\")))]\n+\t (match_operand:<VEC_base> 1 \"gpc_reg_operand\" \"wa,b\")\n+\t (match_operand:<VEC_base> 2 \"gpc_reg_operand\" \"wa,b\")))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n {\n   if (which_alternative == 0)\n@@ -3020,10 +3011,10 @@\n (define_insn \"*vsx_concat_<mode>_1\"\n   [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wa\")\n \t(vec_concat:VSX_D\n-\t (vec_select:<VS_scalar>\n+\t (vec_select:<VEC_base>\n \t  (match_operand:VSX_D 1 \"gpc_reg_operand\" \"wa\")\n \t  (parallel [(match_operand:QI 2 \"const_0_to_1_operand\" \"n\")]))\n-\t (match_operand:<VS_scalar> 3 \"gpc_reg_operand\" \"wa\")))]\n+\t (match_operand:<VEC_base> 3 \"gpc_reg_operand\" \"wa\")))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n {\n   HOST_WIDE_INT dword = INTVAL (operands[2]);\n@@ -3043,8 +3034,8 @@\n (define_insn \"*vsx_concat_<mode>_2\"\n   [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wa\")\n \t(vec_concat:VSX_D\n-\t (match_operand:<VS_scalar> 1 \"gpc_reg_operand\" \"wa\")\n-\t (vec_select:<VS_scalar>\n+\t (match_operand:<VEC_base> 1 \"gpc_reg_operand\" \"wa\")\n+\t (vec_select:<VEC_base>\n \t  (match_operand:VSX_D 2 \"gpc_reg_operand\" \"wa\")\n \t  (parallel [(match_operand:QI 3 \"const_0_to_1_operand\" \"n\")]))))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n@@ -3066,10 +3057,10 @@\n (define_insn \"*vsx_concat_<mode>_3\"\n   [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wa\")\n \t(vec_concat:VSX_D\n-\t (vec_select:<VS_scalar>\n+\t (vec_select:<VEC_base>\n \t  (match_operand:VSX_D 1 \"gpc_reg_operand\" \"wa\")\n \t  (parallel [(match_operand:QI 2 \"const_0_to_1_operand\" \"n\")]))\n-\t (vec_select:<VS_scalar>\n+\t (vec_select:<VEC_base>\n \t  (match_operand:VSX_D 3 \"gpc_reg_operand\" \"wa\")\n \t  (parallel [(match_operand:QI 4 \"const_0_to_1_operand\" \"n\")]))))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n@@ -3367,15 +3358,15 @@\n (define_expand \"vsx_set_<mode>\"\n   [(use (match_operand:VSX_D 0 \"vsx_register_operand\"))\n    (use (match_operand:VSX_D 1 \"vsx_register_operand\"))\n-   (use (match_operand:<VS_scalar> 2 \"gpc_reg_operand\"))\n+   (use (match_operand:<VEC_base> 2 \"gpc_reg_operand\"))\n    (use (match_operand:QI 3 \"const_0_to_1_operand\"))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n {\n   rtx dest = operands[0];\n   rtx vec_reg = operands[1];\n   rtx value = operands[2];\n   rtx ele = operands[3];\n-  rtx tmp = gen_reg_rtx (<VS_scalar>mode);\n+  rtx tmp = gen_reg_rtx (<VEC_base>mode);\n \n   if (ele == const0_rtx)\n     {\n@@ -3398,8 +3389,8 @@\n ;; Or see if we can avoid doing the move at all\n \n (define_insn \"vsx_extract_<mode>\"\n-  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=wa, wa, wr, wr\")\n-\t(vec_select:<VS_scalar>\n+  [(set (match_operand:<VEC_base> 0 \"gpc_reg_operand\" \"=wa, wa, wr, wr\")\n+\t(vec_select:<VEC_base>\n \t (match_operand:VSX_D 1 \"gpc_reg_operand\"       \"wa, wa, wa, wa\")\n \t (parallel\n \t  [(match_operand:QI 2 \"const_0_to_1_operand\"   \"wD, n,  wD, n\")])))]\n@@ -3453,8 +3444,8 @@\n \n ;; Optimize extracting a single scalar element from memory.\n (define_insn_and_split \"*vsx_extract_<P:mode>_<VSX_D:mode>_load\"\n-  [(set (match_operand:<VS_scalar> 0 \"register_operand\" \"=wa,wr\")\n-\t(vec_select:<VSX_D:VS_scalar>\n+  [(set (match_operand:<VEC_base> 0 \"register_operand\" \"=wa,wr\")\n+\t(vec_select:<VSX_D:VEC_base>\n \t (match_operand:VSX_D 1 \"memory_operand\" \"m,m\")\n \t (parallel [(match_operand:QI 2 \"const_0_to_1_operand\" \"n,n\")])))\n    (clobber (match_scratch:P 3 \"=&b,&b\"))]\n@@ -3464,16 +3455,16 @@\n   [(set (match_dup 0) (match_dup 4))]\n {\n   operands[4] = rs6000_adjust_vec_address (operands[0], operands[1], operands[2],\n-\t\t\t\t\t   operands[3], <VSX_D:VS_scalar>mode);\n+\t\t\t\t\t   operands[3], <VSX_D:VEC_base>mode);\n }\n   [(set_attr \"type\" \"fpload,load\")\n    (set_attr \"length\" \"8\")])\n \n ;; Optimize storing a single scalar element that is the right location to\n ;; memory\n (define_insn \"*vsx_extract_<mode>_store\"\n-  [(set (match_operand:<VS_scalar> 0 \"memory_operand\" \"=m,Z,wY\")\n-\t(vec_select:<VS_scalar>\n+  [(set (match_operand:<VEC_base> 0 \"memory_operand\" \"=m,Z,wY\")\n+\t(vec_select:<VEC_base>\n \t (match_operand:VSX_D 1 \"register_operand\" \"d,v,v\")\n \t (parallel [(match_operand:QI 2 \"vsx_scalar_64bit\" \"wD,wD,wD\")])))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n@@ -3486,8 +3477,8 @@\n \n ;; Variable V2DI/V2DF extract shift\n (define_insn \"vsx_vslo_<mode>\"\n-  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=v\")\n-\t(unspec:<VS_scalar> [(match_operand:VSX_D 1 \"gpc_reg_operand\" \"v\")\n+  [(set (match_operand:<VEC_base> 0 \"gpc_reg_operand\" \"=v\")\n+\t(unspec:<VEC_base> [(match_operand:VSX_D 1 \"gpc_reg_operand\" \"v\")\n \t\t\t     (match_operand:V2DI 2 \"gpc_reg_operand\" \"v\")]\n \t\t\t    UNSPEC_VSX_VSLO))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT\"\n@@ -3496,8 +3487,8 @@\n \n ;; Variable V2DI/V2DF extract from a register\n (define_insn_and_split \"vsx_extract_<mode>_var\"\n-  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=v\")\n-\t(unspec:<VS_scalar> [(match_operand:VSX_D 1 \"gpc_reg_operand\" \"v\")\n+  [(set (match_operand:<VEC_base> 0 \"gpc_reg_operand\" \"=v\")\n+\t(unspec:<VEC_base> [(match_operand:VSX_D 1 \"gpc_reg_operand\" \"v\")\n \t\t\t     (match_operand:DI 2 \"gpc_reg_operand\" \"r\")]\n \t\t\t    UNSPEC_VSX_EXTRACT))\n    (clobber (match_scratch:DI 3 \"=r\"))\n@@ -3514,8 +3505,8 @@\n \n ;; Variable V2DI/V2DF extract from memory\n (define_insn_and_split \"*vsx_extract_<mode>_var_load\"\n-  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=wa,r\")\n-\t(unspec:<VS_scalar> [(match_operand:VSX_D 1 \"memory_operand\" \"Q,Q\")\n+  [(set (match_operand:<VEC_base> 0 \"gpc_reg_operand\" \"=wa,r\")\n+\t(unspec:<VEC_base> [(match_operand:VSX_D 1 \"memory_operand\" \"Q,Q\")\n \t\t\t     (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")]\n \t\t\t    UNSPEC_VSX_EXTRACT))\n    (clobber (match_scratch:DI 3 \"=&b,&b\"))]\n@@ -3525,7 +3516,7 @@\n   [(set (match_dup 0) (match_dup 4))]\n {\n   operands[4] = rs6000_adjust_vec_address (operands[0], operands[1], operands[2],\n-\t\t\t\t\t   operands[3], <VS_scalar>mode);\n+\t\t\t\t\t   operands[3], <VEC_base>mode);\n }\n   [(set_attr \"type\" \"fpload,load\")])\n \n@@ -3734,8 +3725,8 @@\n ;; none of the small types were allowed in a vector register, so we had to\n ;; extract to a DImode and either do a direct move or store.\n (define_expand  \"vsx_extract_<mode>\"\n-  [(parallel [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\")\n-\t\t   (vec_select:<VS_scalar>\n+  [(parallel [(set (match_operand:<VEC_base> 0 \"gpc_reg_operand\")\n+\t\t   (vec_select:<VEC_base>\n \t\t    (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\")\n \t\t    (parallel [(match_operand:QI 2 \"const_int_operand\")])))\n \t      (clobber (match_scratch:VSX_EXTRACT_I 3))])]\n@@ -3751,8 +3742,8 @@\n })\n \n (define_insn \"vsx_extract_<mode>_p9\"\n-  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=r,<VSX_EX>\")\n-\t(vec_select:<VS_scalar>\n+  [(set (match_operand:<VEC_base> 0 \"gpc_reg_operand\" \"=r,<VSX_EX>\")\n+\t(vec_select:<VEC_base>\n \t (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"v,<VSX_EX>\")\n \t (parallel [(match_operand:QI 2 \"<VSX_EXTRACT_PREDICATE>\" \"n,n\")])))\n    (clobber (match_scratch:SI 3 \"=r,X\"))]\n@@ -3782,8 +3773,8 @@\n    (set_attr \"isa\" \"p9v,*\")])\n \n (define_split\n-  [(set (match_operand:<VS_scalar> 0 \"int_reg_operand\")\n-\t(vec_select:<VS_scalar>\n+  [(set (match_operand:<VEC_base> 0 \"int_reg_operand\")\n+\t(vec_select:<VEC_base>\n \t (match_operand:VSX_EXTRACT_I 1 \"altivec_register_operand\")\n \t (parallel [(match_operand:QI 2 \"const_int_operand\")])))\n    (clobber (match_operand:SI 3 \"int_reg_operand\"))]\n@@ -3808,36 +3799,36 @@\n (define_insn_and_split \"*vsx_extract_<mode>_di_p9\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,<VSX_EX>\")\n \t(zero_extend:DI\n-\t (vec_select:<VS_scalar>\n+\t (vec_select:<VEC_base>\n \t  (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"v,<VSX_EX>\")\n \t  (parallel [(match_operand:QI 2 \"const_int_operand\" \"n,n\")]))))\n    (clobber (match_scratch:SI 3 \"=r,X\"))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_VEXTRACTUB\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 4)\n-\t\t   (vec_select:<VS_scalar>\n+\t\t   (vec_select:<VEC_base>\n \t\t    (match_dup 1)\n \t\t    (parallel [(match_dup 2)])))\n \t      (clobber (match_dup 3))])]\n {\n-  operands[4] = gen_rtx_REG (<VS_scalar>mode, REGNO (operands[0]));\n+  operands[4] = gen_rtx_REG (<VEC_base>mode, REGNO (operands[0]));\n }\n   [(set_attr \"isa\" \"p9v,*\")])\n \n ;; Optimize stores to use the ISA 3.0 scalar store instructions\n (define_insn_and_split \"*vsx_extract_<mode>_store_p9\"\n-  [(set (match_operand:<VS_scalar> 0 \"memory_operand\" \"=Z,m\")\n-\t(vec_select:<VS_scalar>\n+  [(set (match_operand:<VEC_base> 0 \"memory_operand\" \"=Z,m\")\n+\t(vec_select:<VEC_base>\n \t (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"<VSX_EX>,v\")\n \t (parallel [(match_operand:QI 2 \"const_int_operand\" \"n,n\")])))\n-   (clobber (match_scratch:<VS_scalar> 3 \"=<VSX_EX>,&*r\"))\n+   (clobber (match_scratch:<VEC_base> 3 \"=<VSX_EX>,&*r\"))\n    (clobber (match_scratch:SI 4 \"=X,&r\"))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_VEXTRACTUB\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 3)\n-\t\t   (vec_select:<VS_scalar>\n+\t\t   (vec_select:<VEC_base>\n \t\t    (match_dup 1)\n \t\t    (parallel [(match_dup 2)])))\n \t      (clobber (match_dup 4))])\n@@ -3898,8 +3889,8 @@\n    (set_attr \"isa\" \"*,p8v,*\")])\n \n (define_insn_and_split  \"*vsx_extract_<mode>_p8\"\n-  [(set (match_operand:<VS_scalar> 0 \"nonimmediate_operand\" \"=r\")\n-\t(vec_select:<VS_scalar>\n+  [(set (match_operand:<VEC_base> 0 \"nonimmediate_operand\" \"=r\")\n+\t(vec_select:<VEC_base>\n \t (match_operand:VSX_EXTRACT_I2 1 \"gpc_reg_operand\" \"v\")\n \t (parallel [(match_operand:QI 2 \"<VSX_EXTRACT_PREDICATE>\" \"n\")])))\n    (clobber (match_scratch:VSX_EXTRACT_I2 3 \"=v\"))]\n@@ -3946,8 +3937,8 @@\n \n ;; Optimize extracting a single scalar element from memory.\n (define_insn_and_split \"*vsx_extract_<mode>_load\"\n-  [(set (match_operand:<VS_scalar> 0 \"register_operand\" \"=r\")\n-\t(vec_select:<VS_scalar>\n+  [(set (match_operand:<VEC_base> 0 \"register_operand\" \"=r\")\n+\t(vec_select:<VEC_base>\n \t (match_operand:VSX_EXTRACT_I 1 \"memory_operand\" \"m\")\n \t (parallel [(match_operand:QI 2 \"<VSX_EXTRACT_PREDICATE>\" \"n\")])))\n    (clobber (match_scratch:DI 3 \"=&b\"))]\n@@ -3957,15 +3948,15 @@\n   [(set (match_dup 0) (match_dup 4))]\n {\n   operands[4] = rs6000_adjust_vec_address (operands[0], operands[1], operands[2],\n-\t\t\t\t\t   operands[3], <VS_scalar>mode);\n+\t\t\t\t\t   operands[3], <VEC_base>mode);\n }\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"8\")])\n \n ;; Variable V16QI/V8HI/V4SI extract from a register\n (define_insn_and_split \"vsx_extract_<mode>_var\"\n-  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(unspec:<VS_scalar>\n+  [(set (match_operand:<VEC_base> 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(unspec:<VEC_base>\n \t [(match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"v,v\")\n \t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")]\n \t UNSPEC_VSX_EXTRACT))\n@@ -3984,8 +3975,8 @@\n \n ;; Variable V16QI/V8HI/V4SI extract from memory\n (define_insn_and_split \"*vsx_extract_<mode>_var_load\"\n-  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=r\")\n-\t(unspec:<VS_scalar>\n+  [(set (match_operand:<VEC_base> 0 \"gpc_reg_operand\" \"=r\")\n+\t(unspec:<VEC_base>\n \t [(match_operand:VSX_EXTRACT_I 1 \"memory_operand\" \"Q\")\n \t  (match_operand:DI 2 \"gpc_reg_operand\" \"r\")]\n \t UNSPEC_VSX_EXTRACT))\n@@ -3996,7 +3987,7 @@\n   [(set (match_dup 0) (match_dup 4))]\n {\n   operands[4] = rs6000_adjust_vec_address (operands[0], operands[1], operands[2],\n-\t\t\t\t\t   operands[3], <VS_scalar>mode);\n+\t\t\t\t\t   operands[3], <VEC_base>mode);\n }\n   [(set_attr \"type\" \"load\")])\n \n@@ -4172,7 +4163,7 @@\n (define_expand \"vreplace_elt_<mode>\"\n   [(set (match_operand:REPLACE_ELT 0 \"register_operand\")\n   (unspec:REPLACE_ELT [(match_operand:REPLACE_ELT 1 \"register_operand\")\n-\t\t       (match_operand:<VS_scalar> 2 \"register_operand\")\n+\t\t       (match_operand:<VEC_base> 2 \"register_operand\")\n \t\t       (match_operand:QI 3 \"const_0_to_3_operand\")]\n \t\t      UNSPEC_REPLACE_ELT))]\n  \"TARGET_POWER10\"\n@@ -4196,7 +4187,7 @@\n (define_insn \"vreplace_elt_<mode>_inst\"\n  [(set (match_operand:REPLACE_ELT 0 \"register_operand\" \"=v\")\n   (unspec:REPLACE_ELT [(match_operand:REPLACE_ELT 1 \"register_operand\" \"0\")\n-\t\t       (match_operand:<VS_scalar> 2 \"register_operand\" \"r\")\n+\t\t       (match_operand:<VEC_base> 2 \"register_operand\" \"r\")\n \t\t       (match_operand:QI 3 \"const_0_to_12_operand\" \"n\")]\n \t\t      UNSPEC_REPLACE_ELT))]\n  \"TARGET_POWER10\"\n@@ -4206,7 +4197,7 @@\n (define_insn \"vreplace_un_<mode>\"\n  [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n   (unspec:V16QI [(match_operand:REPLACE_ELT 1 \"register_operand\" \"0\")\n-                 (match_operand:<VS_scalar> 2 \"register_operand\" \"r\")\n+                 (match_operand:<VEC_base> 2 \"register_operand\" \"r\")\n \t\t (match_operand:QI 3 \"const_0_to_12_operand\" \"n\")]\n \t\tUNSPEC_REPLACE_UN))]\n  \"TARGET_POWER10\"\n@@ -4322,19 +4313,19 @@\n ;; Where <ftype> is SFmode, DFmode (and KFmode/TFmode if those types are IEEE\n ;; 128-bit hardware types) and <vtype> is vector char, vector unsigned char,\n ;; vector short or vector unsigned short.\n-(define_insn_and_split \"*vsx_ext_<VSX_EXTRACT_I:VS_scalar>_fl_<FL_CONV:mode>\"\n+(define_insn_and_split \"*vsx_ext_<VSX_EXTRACT_I:VEC_base>_fl_<FL_CONV:mode>\"\n   [(set (match_operand:FL_CONV 0 \"gpc_reg_operand\" \"=wa\")\n \t(float:FL_CONV\n-\t (vec_select:<VSX_EXTRACT_I:VS_scalar>\n+\t (vec_select:<VSX_EXTRACT_I:VEC_base>\n \t  (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"v\")\n \t  (parallel [(match_operand:QI 2 \"const_int_operand\" \"n\")]))))\n-   (clobber (match_scratch:<VSX_EXTRACT_I:VS_scalar> 3 \"=v\"))]\n+   (clobber (match_scratch:<VSX_EXTRACT_I:VEC_base> 3 \"=v\"))]\n   \"VECTOR_MEM_VSX_P (<VSX_EXTRACT_I:MODE>mode) && TARGET_DIRECT_MOVE_64BIT\n    && TARGET_P9_VECTOR\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 3)\n-\t\t   (vec_select:<VSX_EXTRACT_I:VS_scalar>\n+\t\t   (vec_select:<VSX_EXTRACT_I:VEC_base>\n \t\t    (match_dup 1)\n \t\t    (parallel [(match_dup 2)])))\n \t      (clobber (scratch:SI))])\n@@ -4347,19 +4338,19 @@\n }\n   [(set_attr \"isa\" \"<FL_CONV:VSisa>\")])\n \n-(define_insn_and_split \"*vsx_ext_<VSX_EXTRACT_I:VS_scalar>_ufl_<FL_CONV:mode>\"\n+(define_insn_and_split \"*vsx_ext_<VSX_EXTRACT_I:VEC_base>_ufl_<FL_CONV:mode>\"\n   [(set (match_operand:FL_CONV 0 \"gpc_reg_operand\" \"=wa\")\n \t(unsigned_float:FL_CONV\n-\t (vec_select:<VSX_EXTRACT_I:VS_scalar>\n+\t (vec_select:<VSX_EXTRACT_I:VEC_base>\n \t  (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"v\")\n \t  (parallel [(match_operand:QI 2 \"const_int_operand\" \"n\")]))))\n-   (clobber (match_scratch:<VSX_EXTRACT_I:VS_scalar> 3 \"=v\"))]\n+   (clobber (match_scratch:<VSX_EXTRACT_I:VEC_base> 3 \"=v\"))]\n   \"VECTOR_MEM_VSX_P (<VSX_EXTRACT_I:MODE>mode) && TARGET_DIRECT_MOVE_64BIT\n    && TARGET_P9_VECTOR\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 3)\n-\t\t   (vec_select:<VSX_EXTRACT_I:VS_scalar>\n+\t\t   (vec_select:<VSX_EXTRACT_I:VEC_base>\n \t\t    (match_dup 1)\n \t\t    (parallel [(match_dup 2)])))\n \t      (clobber (scratch:SI))])\n@@ -4375,7 +4366,7 @@\n   [(set (match_operand:VSX_EXTRACT_I 0 \"gpc_reg_operand\" \"=<VSX_EX>\")\n \t(unspec:VSX_EXTRACT_I\n \t [(match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"0\")\n-\t  (match_operand:<VS_scalar> 2 \"gpc_reg_operand\" \"<VSX_EX>\")\n+\t  (match_operand:<VEC_base> 2 \"gpc_reg_operand\" \"<VSX_EX>\")\n \t  (match_operand:QI 3 \"<VSX_EXTRACT_PREDICATE>\" \"n\")]\n \t UNSPEC_VSX_SET))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_P9_VECTOR && TARGET_POWERPC64\"\n@@ -4386,7 +4377,7 @@\n   if (!BYTES_BIG_ENDIAN)\n     ele = nunits - 1 - ele;\n \n-  operands[3] = GEN_INT (GET_MODE_SIZE (<VS_scalar>mode) * ele);\n+  operands[3] = GEN_INT (GET_MODE_SIZE (<VEC_base>mode) * ele);\n   if (<MODE>mode == V4SImode)\n     return \"xxinsertw %x0,%x2,%3\";\n   else\n@@ -4559,20 +4550,20 @@\n (define_expand \"vsx_splat_<mode>\"\n   [(set (match_operand:VSX_D 0 \"vsx_register_operand\")\n \t(vec_duplicate:VSX_D\n-\t (match_operand:<VS_scalar> 1 \"input_operand\")))]\n+\t (match_operand:<VEC_base> 1 \"input_operand\")))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n {\n   rtx op1 = operands[1];\n   if (MEM_P (op1))\n     operands[1] = rs6000_force_indexed_or_indirect_mem (op1);\n   else if (!REG_P (op1))\n-    op1 = force_reg (<VSX_D:VS_scalar>mode, op1);\n+    op1 = force_reg (<VSX_D:VEC_base>mode, op1);\n })\n \n (define_insn \"vsx_splat_<mode>_reg\"\n   [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wa,we\")\n \t(vec_duplicate:VSX_D\n-\t (match_operand:<VS_scalar> 1 \"gpc_reg_operand\" \"wa,b\")))]\n+\t (match_operand:<VEC_base> 1 \"gpc_reg_operand\" \"wa,b\")))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"@\n    xxpermdi %x0,%x1,%x1,0\n@@ -4582,7 +4573,7 @@\n (define_insn \"vsx_splat_<mode>_mem\"\n   [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wa\")\n \t(vec_duplicate:VSX_D\n-\t (match_operand:<VSX_D:VS_scalar> 1 \"memory_operand\" \"Z\")))]\n+\t (match_operand:<VSX_D:VEC_base> 1 \"memory_operand\" \"Z\")))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"lxvdsx %x0,%y1\"\n   [(set_attr \"type\" \"vecload\")])\n@@ -4638,7 +4629,7 @@\n (define_insn \"vsx_xxspltw_<mode>\"\n   [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wa\")\n \t(vec_duplicate:VSX_W\n-\t (vec_select:<VS_scalar>\n+\t (vec_select:<VEC_base>\n \t  (match_operand:VSX_W 1 \"vsx_register_operand\" \"wa\")\n \t  (parallel\n \t   [(match_operand:QI 2 \"u5bit_cint_operand\" \"n\")]))))]\n@@ -4664,7 +4655,7 @@\n (define_insn \"vsx_vsplt<VSX_SPLAT_SUFFIX>_di\"\n   [(set (match_operand:VSX_SPLAT_I 0 \"altivec_register_operand\" \"=v\")\n \t(vec_duplicate:VSX_SPLAT_I\n-\t (truncate:<VS_scalar>\n+\t (truncate:<VEC_base>\n \t  (match_operand:DI 1 \"altivec_register_operand\" \"v\"))))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT\"\n   \"vsplt<VSX_SPLAT_SUFFIX> %0,%1,<VSX_SPLAT_COUNT>\""}]}