{"sha": "542e7230c0dd16977671486414207ef1a3bd52e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQyZTcyMzBjMGRkMTY5Nzc2NzE0ODY0MTQyMDdlZjFhM2JkNTJlNA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-07-05T11:49:02Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-07-05T11:49:02Z"}, "message": "cfgloop.h (struct loop): Add comment.\n\n\t* cfgloop.h (struct loop): Add comment.  New field orig_loop_num.\n\t* cfgloopmanip.c (lv_adjust_loop_entry_edge): Comment change.\n\t* internal-fn.c (expand_LOOP_DIST_ALIAS): New function.\n\t* internal-fn.def (LOOP_DIST_ALIAS): New.\n\t* tree-vectorizer.c (fold_loop_vectorized_call): Rename to ...\n\t(fold_loop_internal_call): ... this.\n\t(vect_loop_dist_alias_call): New function.\n\t(set_uid_loop_bbs): Call fold_loop_internal_call.\n\t(vectorize_loops): Fold IFN_LOOP_VECTORIZED and IFN_LOOP_DIST_ALIAS\n\tinternal calls.\n\nFrom-SVN: r249983", "tree": {"sha": "9a843c42d270fa10bf2d9124972c10bfcae93081", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a843c42d270fa10bf2d9124972c10bfcae93081"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/542e7230c0dd16977671486414207ef1a3bd52e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/542e7230c0dd16977671486414207ef1a3bd52e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/542e7230c0dd16977671486414207ef1a3bd52e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/542e7230c0dd16977671486414207ef1a3bd52e4/comments", "author": null, "committer": null, "parents": [{"sha": "3d07163dd2eece338feb79bf5e91ac8fd6ac48b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d07163dd2eece338feb79bf5e91ac8fd6ac48b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d07163dd2eece338feb79bf5e91ac8fd6ac48b7"}], "stats": {"total": 127, "additions": 116, "deletions": 11}, "files": [{"sha": "fa8c40cacddf65f43f2277eb4f1914cc0f517e0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/542e7230c0dd16977671486414207ef1a3bd52e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/542e7230c0dd16977671486414207ef1a3bd52e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=542e7230c0dd16977671486414207ef1a3bd52e4", "patch": "@@ -1,3 +1,16 @@\n+2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* cfgloop.h (struct loop): Add comment.  New field orig_loop_num.\n+\t* cfgloopmanip.c (lv_adjust_loop_entry_edge): Comment change.\n+\t* internal-fn.c (expand_LOOP_DIST_ALIAS): New function.\n+\t* internal-fn.def (LOOP_DIST_ALIAS): New.\n+\t* tree-vectorizer.c (fold_loop_vectorized_call): Rename to ...\n+\t(fold_loop_internal_call): ... this.\n+\t(vect_loop_dist_alias_call): New function.\n+\t(set_uid_loop_bbs): Call fold_loop_internal_call.\n+\t(vectorize_loops): Fold IFN_LOOP_VECTORIZED and IFN_LOOP_DIST_ALIAS\n+\tinternal calls.\n+\n 2017-07-04  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/81300"}, {"sha": "e7ffa2364376c256b9a73fd2433e52fc2cca7d83", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/542e7230c0dd16977671486414207ef1a3bd52e4/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/542e7230c0dd16977671486414207ef1a3bd52e4/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=542e7230c0dd16977671486414207ef1a3bd52e4", "patch": "@@ -114,7 +114,8 @@ struct GTY ((chain_next (\"%h.next\"))) control_iv {\n \n /* Structure to hold information for each natural loop.  */\n struct GTY ((chain_next (\"%h.next\"))) loop {\n-  /* Index into loops array.  */\n+  /* Index into loops array.  Note indices will never be reused after loop\n+     is destroyed.  */\n   int num;\n \n   /* Number of loop insns.  */\n@@ -225,6 +226,16 @@ struct GTY ((chain_next (\"%h.next\"))) loop {\n      builtins.  */\n   tree simduid;\n \n+  /* In loop optimization, it's common to generate loops from the original\n+     loop.  This field records the index of the original loop which can be\n+     used to track the original loop from newly generated loops.  This can\n+     be done by calling function get_loop (cfun, orig_loop_num).  Note the\n+     original loop could be destroyed for various reasons thus no longer\n+     exists, as a result, function call to get_loop returns NULL pointer.\n+     In this case, this field should not be used and needs to be cleared\n+     whenever possible.  */\n+  int orig_loop_num;\n+\n   /* Upper bound on number of iterations of a loop.  */\n   struct nb_iter_bound *bounds;\n "}, {"sha": "3f4ff988c7400decf9099a131d6c35c3a3bd73b5", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/542e7230c0dd16977671486414207ef1a3bd52e4/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/542e7230c0dd16977671486414207ef1a3bd52e4/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=542e7230c0dd16977671486414207ef1a3bd52e4", "patch": "@@ -1623,7 +1623,8 @@ force_single_succ_latches (void)\n \n   THEN_PROB is the probability of then branch of the condition.\n   ELSE_PROB is the probability of else branch. Note that they may be both\n-  REG_BR_PROB_BASE when condition is IFN_LOOP_VECTORIZED.  */\n+  REG_BR_PROB_BASE when condition is IFN_LOOP_VECTORIZED or\n+  IFN_LOOP_DIST_ALIAS.  */\n \n static basic_block\n lv_adjust_loop_entry_edge (basic_block first_head, basic_block second_head,"}, {"sha": "18466cd53b334515e01285559a2187ea2ac70f13", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/542e7230c0dd16977671486414207ef1a3bd52e4/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/542e7230c0dd16977671486414207ef1a3bd52e4/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=542e7230c0dd16977671486414207ef1a3bd52e4", "patch": "@@ -2250,6 +2250,14 @@ expand_LOOP_VECTORIZED (internal_fn, gcall *)\n   gcc_unreachable ();\n }\n \n+/* This should get folded in tree-vectorizer.c.  */\n+\n+static void\n+expand_LOOP_DIST_ALIAS (internal_fn, gcall *)\n+{\n+  gcc_unreachable ();\n+}\n+\n /* Expand MASK_LOAD call STMT using optab OPTAB.  */\n \n static void"}, {"sha": "79c19fb8e7a6948bd8cc6489e76f0e61e5f60d50", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/542e7230c0dd16977671486414207ef1a3bd52e4/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/542e7230c0dd16977671486414207ef1a3bd52e4/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=542e7230c0dd16977671486414207ef1a3bd52e4", "patch": "@@ -158,6 +158,7 @@ DEF_INTERNAL_FN (GOMP_SIMD_LAST_LANE, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_ORDERED_START, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_ORDERED_END, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (LOOP_VECTORIZED, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (LOOP_DIST_ALIAS, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (ANNOTATE,  ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (UBSAN_NULL, ECF_LEAF | ECF_NOTHROW, \".R.\")\n DEF_INTERNAL_FN (UBSAN_BOUNDS, ECF_LEAF | ECF_NOTHROW, NULL)"}, {"sha": "33a1f580474cb93ccc4f2f43631bf7a90623c2ad", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 80, "deletions": 9, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/542e7230c0dd16977671486414207ef1a3bd52e4/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/542e7230c0dd16977671486414207ef1a3bd52e4/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=542e7230c0dd16977671486414207ef1a3bd52e4", "patch": "@@ -448,11 +448,11 @@ vect_loop_vectorized_call (struct loop *loop)\n   return NULL;\n }\n \n-/* Fold LOOP_VECTORIZED internal call G to VALUE and\n-   update any immediate uses of it's LHS.  */\n+/* Fold loop internal call G like IFN_LOOP_VECTORIZED/IFN_LOOP_DIST_ALIAS\n+   to VALUE and update any immediate uses of it's LHS.  */\n \n static void\n-fold_loop_vectorized_call (gimple *g, tree value)\n+fold_loop_internal_call (gimple *g, tree value)\n {\n   tree lhs = gimple_call_lhs (g);\n   use_operand_p use_p;\n@@ -469,6 +469,60 @@ fold_loop_vectorized_call (gimple *g, tree value)\n     }\n }\n \n+/* If LOOP has been versioned during loop distribution, return the gurading\n+   internal call.  */\n+\n+static gimple *\n+vect_loop_dist_alias_call (struct loop *loop)\n+{\n+  basic_block bb;\n+  basic_block entry;\n+  struct loop *outer, *orig;\n+  gimple_stmt_iterator gsi;\n+  gimple *g;\n+\n+  if (loop->orig_loop_num == 0)\n+    return NULL;\n+\n+  orig = get_loop (cfun, loop->orig_loop_num);\n+  if (orig == NULL)\n+    {\n+      /* The original loop is somehow destroyed.  Clear the information.  */\n+      loop->orig_loop_num = 0;\n+      return NULL;\n+    }\n+\n+  if (loop != orig)\n+    bb = nearest_common_dominator (CDI_DOMINATORS, loop->header, orig->header);\n+  else\n+    bb = loop_preheader_edge (loop)->src;\n+\n+  outer = bb->loop_father;\n+  entry = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+\n+  /* Look upward in dominance tree.  */\n+  for (; bb != entry && flow_bb_inside_loop_p (outer, bb);\n+       bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n+    {\n+      g = last_stmt (bb);\n+      if (g == NULL || gimple_code (g) != GIMPLE_COND)\n+\tcontinue;\n+\n+      gsi = gsi_for_stmt (g);\n+      gsi_prev (&gsi);\n+      if (gsi_end_p (gsi))\n+\tcontinue;\n+\n+      g = gsi_stmt (gsi);\n+      /* The guarding internal function call must have the same distribution\n+\t alias id.  */\n+      if (gimple_call_internal_p (g, IFN_LOOP_DIST_ALIAS)\n+\t  && (tree_to_shwi (gimple_call_arg (g, 0)) == loop->orig_loop_num))\n+\treturn g;\n+    }\n+  return NULL;\n+}\n+\n /* Set the uids of all the statements in basic blocks inside loop\n    represented by LOOP_VINFO. LOOP_VECTORIZED_CALL is the internal\n    call guarding the loop which has been if converted.  */\n@@ -494,7 +548,7 @@ set_uid_loop_bbs (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n \t{\n \t  arg = gimple_call_arg (g, 0);\n \t  get_loop (cfun, tree_to_shwi (arg))->dont_vectorize = true;\n-\t  fold_loop_vectorized_call (g, boolean_false_node);\n+\t  fold_loop_internal_call (g, boolean_false_node);\n \t}\n     }\n   bbs = get_loop_body (scalar_loop);\n@@ -595,14 +649,15 @@ vectorize_loops (void)\n     else\n       {\n \tloop_vec_info loop_vinfo, orig_loop_vinfo;\n-\tgimple *loop_vectorized_call;\n+\tgimple *loop_vectorized_call, *loop_dist_alias_call;\n        try_vectorize:\n \tif (!((flag_tree_loop_vectorize\n \t       && optimize_loop_nest_for_speed_p (loop))\n \t      || loop->force_vectorize))\n \t  continue;\n \torig_loop_vinfo = NULL;\n \tloop_vectorized_call = vect_loop_vectorized_call (loop);\n+\tloop_dist_alias_call = vect_loop_dist_alias_call (loop);\n        vectorize_epilogue:\n \tvect_location = find_loop_location (loop);\n         if (LOCATION_LOCUS (vect_location) != UNKNOWN_LOCATION\n@@ -652,8 +707,8 @@ vectorize_loops (void)\n \t\t  {\n \t\t    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n \t\t\t\t     \"basic block vectorized\\n\");\n-\t\t    fold_loop_vectorized_call (loop_vectorized_call,\n-\t\t\t\t\t       boolean_true_node);\n+\t\t    fold_loop_internal_call (loop_vectorized_call,\n+\t\t\t\t\t     boolean_true_node);\n \t\t    loop_vectorized_call = NULL;\n \t\t    ret |= TODO_cleanup_cfg;\n \t\t  }\n@@ -706,10 +761,17 @@ vectorize_loops (void)\n \n \tif (loop_vectorized_call)\n \t  {\n-\t    fold_loop_vectorized_call (loop_vectorized_call, boolean_true_node);\n+\t    fold_loop_internal_call (loop_vectorized_call, boolean_true_node);\n \t    loop_vectorized_call = NULL;\n \t    ret |= TODO_cleanup_cfg;\n \t  }\n+\tif (loop_dist_alias_call)\n+\t  {\n+\t    tree value = gimple_call_arg (loop_dist_alias_call, 1);\n+\t    fold_loop_internal_call (loop_dist_alias_call, value);\n+\t    loop_dist_alias_call = NULL;\n+\t    ret |= TODO_cleanup_cfg;\n+\t  }\n \n \tif (new_loop)\n \t  {\n@@ -741,7 +803,16 @@ vectorize_loops (void)\n \t    gimple *g = vect_loop_vectorized_call (loop);\n \t    if (g)\n \t      {\n-\t\tfold_loop_vectorized_call (g, boolean_false_node);\n+\t\tfold_loop_internal_call (g, boolean_false_node);\n+\t\tret |= TODO_cleanup_cfg;\n+\t\tg = NULL;\n+\t      }\n+\t    else\n+\t      g = vect_loop_dist_alias_call (loop);\n+\n+\t    if (g)\n+\t      {\n+\t\tfold_loop_internal_call (g, boolean_false_node);\n \t\tret |= TODO_cleanup_cfg;\n \t      }\n \t  }"}]}