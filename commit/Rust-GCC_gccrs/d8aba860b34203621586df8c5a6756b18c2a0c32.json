{"sha": "d8aba860b34203621586df8c5a6756b18c2a0c32", "node_id": "C_kwDOANBUbNoAKGQ4YWJhODYwYjM0MjAzNjIxNTg2ZGY4YzVhNjc1NmIxOGMyYTBjMzI", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-15T18:53:42Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-15T18:53:42Z"}, "message": "c, analyzer: support named constants in analyzer [PR106302]\n\nThe analyzer's file-descriptor state machine tracks the access mode of\nopened files, so that it can emit -Wanalyzer-fd-access-mode-mismatch.\n\nTo do this, its symbolic execution needs to \"know\" the values of the\nconstants \"O_RDONLY\", \"O_WRONLY\", and \"O_ACCMODE\".  Currently\nanalyzer/sm-fd.cc simply uses these values directly from the build-time\nheader files, but these are the values on the host, not those from the\ntarget, which could be different (PR analyzer/106302).\n\nIn an earlier discussion of this issue:\n  https://gcc.gnu.org/pipermail/gcc/2022-June/238954.html\nwe talked about adding a target hook for this.\n\nHowever, I've also been experimenting with extending the fd state\nmachine to track sockets (PR analyzer/106140).  For this, it's useful to\n\"know\" the values of the constants \"SOCK_STREAM\" and \"SOCK_DGRAM\".\nUnfortunately, these seem to have many arbitrary differences from target\nto target.\n\nFor example: Linux/glibc general has SOCK_STREAM == 1, SOCK_DGRAM == 2,\nas does AIX, but annoyingly, e.g. Linux on MIPS has them the other way\naround.\n\nIt seems to me that as the analyzer grows more ambitious modeling of the\nbehavior of APIs (perhaps via plugins) it's more likely that the\nanalyzer will need to know the values of named constants, which might\nnot even exist on the host.\n\nFor example, at LPC it was suggested to me that -fanalyzer could check\nrules about memory management inside the Linux kernel (probably via a\nplugin), but doing so involves a bunch of GFP_* flags (see PR 107472).\n\nSo rather than trying to capture all this knowledge in a target hook,\nthis patch attempts to get at named constant values from the user's\nsource code.\n\nThe patch adds an interface for frontends to call into the analyzer as\nthe translation unit finishes.  The analyzer can then call back into the\nfrontend to ask about the values of the named constants it cares about\nwhilst the frontend's data structures are still around.\n\nThe patch implements this for the C frontend, which looks up the names\nby looking for named CONST_DECLs (which handles enum values).  Failing\nthat, it attempts to look up the values of macros but only the simplest\ncases are supported (a non-traditional macro with a single CPP_NUMBER\ntoken).  It does this by building a buffer containing the macro\ndefinition and rerunning a lexer on it.\n\nThe analyzer gracefully handles the cases where named values aren't\nfound (such as anything more complicated than described above).\n\nThe patch ports the analyzer to use this mechanism for \"O_RDONLY\",\n\"O_WRONLY\", and \"O_ACCMODE\".  I have successfully tested my socket patch\nto also use this for \"SOCK_STREAM\" and \"SOCK_DGRAM\", so the technique\nseems to work.\n\ngcc/ChangeLog:\n\tPR analyzer/106302\n\t* Makefile.in (ANALYZER_OBJS): Add analyzer/analyzer-language.o.\n\t(GTFILES): Add analyzer/analyzer-language.cc.\n\t* doc/analyzer.texi: Document __analyzer_dump_named_constant.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/106302\n\t* analyzer-language.cc: New file.\n\t* analyzer-language.h: New file.\n\t* analyzer.h (get_stashed_constant_by_name): New decl.\n\t(log_stashed_constants): New decl.\n\t* engine.cc (impl_run_checkers): Call log_stashed_constants.\n\t* region-model-impl-calls.cc\n\t(region_model::impl_call_analyzer_dump_named_constant): New.\n\t* region-model.cc (region_model::on_stmt_pre): Handle\n\t__analyzer_dump_named_constant.\n\t* region-model.h\n\t(region_model::impl_call_analyzer_dump_named_constant): New decl.\n\t* sm-fd.cc (fd_state_machine::m_O_ACCMODE): New.\n\t(fd_state_machine::m_O_RDONLY): New.\n\t(fd_state_machine::m_O_WRONLY): New.\n\t(fd_state_machine::fd_state_machine): Initialize the new fields.\n\t(fd_state_machine::get_access_mode_from_flag): Use the new fields,\n\trather than using the host values.\n\ngcc/c/ChangeLog:\n\tPR analyzer/106302\n\t* c-parser.cc: Include \"analyzer/analyzer-language.h\" and \"toplev.h\".\n\t(class ana::c_translation_unit): New.\n\t(c_parser_translation_unit): Call ana::on_finish_translation_unit.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/analyzer-decls.h\n\t(__analyzer_dump_named_constant): New decl.\n\t* gcc.dg/analyzer/fd-4.c (void): Likewise.\n\t(O_ACCMODE): Define.\n\t* gcc.dg/analyzer/fd-access-mode-enum.c: New test, based on .\n\t* gcc.dg/analyzer/fd-5.c: ...this.  Rename to...\n\t* gcc.dg/analyzer/fd-access-mode-macros.c: ...this.\n\t(O_ACCMODE): Define.\n\t* gcc.dg/analyzer/fd-access-mode-target-headers.c: New test, also\n\tbased on fd-5.c.\n\t(test_sm_fd_constants): New.\n\t* gcc.dg/analyzer/fd-dup-1.c (O_ACCMODE): Define.\n\t* gcc.dg/analyzer/named-constants-via-enum.c: New test.\n\t* gcc.dg/analyzer/named-constants-via-enum-and-macro.c: New test.\n\t* gcc.dg/analyzer/named-constants-via-macros-2.c: New test.\n\t* gcc.dg/analyzer/named-constants-via-macros.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "51d723dac265a7f94898c0589103fd83c4970a30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51d723dac265a7f94898c0589103fd83c4970a30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8aba860b34203621586df8c5a6756b18c2a0c32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8aba860b34203621586df8c5a6756b18c2a0c32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8aba860b34203621586df8c5a6756b18c2a0c32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8aba860b34203621586df8c5a6756b18c2a0c32/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46c3d9c8e8f6becdb73bac8bcc2f0ba12d6b1d9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c3d9c8e8f6becdb73bac8bcc2f0ba12d6b1d9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46c3d9c8e8f6becdb73bac8bcc2f0ba12d6b1d9c"}], "stats": {"total": 523, "additions": 513, "deletions": 10}, "files": [{"sha": "41b3fe7851f15494f2d3f3ac9b74d741b24d5a55", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -1249,6 +1249,7 @@ C_COMMON_OBJS = c-family/c-common.o c-family/c-cppbuiltin.o c-family/c-dump.o \\\n ANALYZER_OBJS = \\\n \tanalyzer/analysis-plan.o \\\n \tanalyzer/analyzer.o \\\n+\tanalyzer/analyzer-language.o \\\n \tanalyzer/analyzer-logging.o \\\n \tanalyzer/analyzer-pass.o \\\n \tanalyzer/analyzer-selftests.o \\\n@@ -2742,6 +2743,7 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/internal-fn.h \\\n   $(srcdir)/calls.cc \\\n   $(srcdir)/omp-general.h \\\n+  $(srcdir)/analyzer/analyzer-language.cc \\\n   @all_gtfiles@\n \n # Compute the list of GT header files from the corresponding C sources,"}, {"sha": "ba4352b729a51d7e51c826b4d934f73af6fb9105", "filename": "gcc/analyzer/analyzer-language.cc", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fanalyzer%2Fanalyzer-language.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fanalyzer%2Fanalyzer-language.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer-language.cc?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -0,0 +1,110 @@\n+/* Interface between analyzer and frontends.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#define INCLUDE_MEMORY\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-language.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+\n+/* Map from identifier to INTEGER_CST.  */\n+static GTY (()) hash_map <tree, tree> *analyzer_stashed_constants;\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* Call into TU to try to find a value for NAME.\n+   If found, stash its value within analyzer_stashed_constants.  */\n+\n+static void\n+maybe_stash_named_constant (const translation_unit &tu, const char *name)\n+{\n+  if (!analyzer_stashed_constants)\n+    analyzer_stashed_constants = hash_map<tree, tree>::create_ggc ();\n+\n+  tree id = get_identifier (name);\n+  if (tree t = tu.lookup_constant_by_id (id))\n+    {\n+      gcc_assert (TREE_CODE (t) == INTEGER_CST);\n+      analyzer_stashed_constants->put (id, t);\n+    }\n+}\n+\n+/* Hook for frontend to call into analyzer when TU finishes.\n+   This exists so that the analyzer can stash named constant values from\n+   header files (e.g. macros and enums) for later use when modeling the\n+   behaviors of APIs.\n+\n+   By doing it this way, the analyzer can use the precise values for those\n+   constants from the user's headers, rather than attempting to model them\n+   as properties of the target.  */\n+\n+void\n+on_finish_translation_unit (const translation_unit &tu)\n+{\n+  /* Bail if the analyzer isn't enabled.  */\n+  if (!flag_analyzer)\n+    return;\n+\n+  /* Stash named constants for use by sm-fd.cc  */\n+  maybe_stash_named_constant (tu, \"O_ACCMODE\");\n+  maybe_stash_named_constant (tu, \"O_RDONLY\");\n+  maybe_stash_named_constant (tu, \"O_WRONLY\");\n+}\n+\n+/* Lookup NAME in the named constants stashed when the frontend TU finished.\n+   Return either an INTEGER_CST, or NULL_TREE.  */\n+\n+tree\n+get_stashed_constant_by_name (const char *name)\n+{\n+  if (!analyzer_stashed_constants)\n+    return NULL_TREE;\n+  tree id = get_identifier (name);\n+  if (tree *slot = analyzer_stashed_constants->get (id))\n+    {\n+      gcc_assert (TREE_CODE (*slot) == INTEGER_CST);\n+      return *slot;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Log all stashed named constants to LOGGER.  */\n+\n+void\n+log_stashed_constants (logger *logger)\n+{\n+  gcc_assert (logger);\n+  LOG_SCOPE (logger);\n+  if (analyzer_stashed_constants)\n+    for (auto iter : *analyzer_stashed_constants)\n+      logger->log (\"%qE: %qE\", iter.first, iter.second);\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */\n+\n+#include \"gt-analyzer-language.h\""}, {"sha": "33c4dd60623e43965b6c0454ea1b62553fa37685", "filename": "gcc/analyzer/analyzer-language.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fanalyzer%2Fanalyzer-language.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fanalyzer%2Fanalyzer-language.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer-language.h?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -0,0 +1,48 @@\n+/* Interface between analyzer and frontends.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_LANGUAGE_H\n+#define GCC_ANALYZER_LANGUAGE_H\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* Abstract base class for representing a specific TU\n+   to the analyzer.  */\n+\n+class translation_unit\n+{\n+ public:\n+  /* Attempt to look up an  value for identifier ID (e.g. in the headers that\n+     have been seen).  If it is defined and an integer (e.g. either as a\n+     macro or enum), return the INTEGER_CST value, otherwise return NULL.  */\n+  virtual tree lookup_constant_by_id (tree id) const = 0;\n+};\n+\n+/* Analyzer hook for frontends to call at the end of the TU.  */\n+\n+void on_finish_translation_unit (const translation_unit &tu);\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */\n+\n+#endif /* GCC_ANALYZER_LANGUAGE_H */"}, {"sha": "9cf8d98fabef4be68fd534811b9fd386eed4fbd7", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -311,6 +311,9 @@ class path_context\n   virtual bool terminate_path_p () const = 0;\n };\n \n+extern tree get_stashed_constant_by_name (const char *name);\n+extern void log_stashed_constants (logger *logger);\n+\n } // namespace ana\n \n extern bool is_special_named_call_p (const gcall *call, const char *funcname,"}, {"sha": "891be7c5c900d7added97e81ddda05a583a918fe", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -6010,6 +6010,7 @@ impl_run_checkers (logger *logger)\n       logger->log (\"BITS_BIG_ENDIAN: %i\", BITS_BIG_ENDIAN ? 1 : 0);\n       logger->log (\"BYTES_BIG_ENDIAN: %i\", BYTES_BIG_ENDIAN ? 1 : 0);\n       logger->log (\"WORDS_BIG_ENDIAN: %i\", WORDS_BIG_ENDIAN ? 1 : 0);\n+      log_stashed_constants (logger);\n     }\n \n   /* If using LTO, ensure that the cgraph nodes have function bodies.  */"}, {"sha": "a7134ed90bb3465135cf579637a96b381f04ef10", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -352,6 +352,34 @@ region_model::impl_call_analyzer_dump_escaped (const gcall *call)\n \t      pp_formatted_text (&pp));\n }\n \n+/* Handle a call to \"__analyzer_dump_named_constant\".\n+\n+   Look up the given name, and emit a warning describing the\n+   state of the corresponding stashed value.\n+\n+   This is for use when debugging, and for DejaGnu tests.  */\n+\n+void\n+region_model::\n+impl_call_analyzer_dump_named_constant (const gcall *call,\n+\t\t\t\t\tregion_model_context *ctxt)\n+{\n+  call_details cd (call, this, ctxt);\n+  const char *name = cd.get_arg_string_literal (0);\n+  if (!name)\n+    {\n+      error_at (call->location, \"cannot determine name\");\n+      return;\n+    }\n+  tree value = get_stashed_constant_by_name (name);\n+  if (value)\n+    warning_at (call->location, 0, \"named constant %qs has value %qE\",\n+\t\tname, value);\n+  else\n+    warning_at (call->location, 0, \"named constant %qs has unknown value\",\n+\t\tname);\n+}\n+\n /* Handle a call to \"__analyzer_eval\" by evaluating the input\n    and dumping as a dummy warning, so that test cases can use\n    dg-warning to validate the result (and so unexpected warnings will"}, {"sha": "5bae3cf5cd41f8fbf9221c3695abeff6589a2e44", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -1229,6 +1229,10 @@ region_model::on_stmt_pre (const gimple *stmt,\n \t  impl_call_analyzer_dump_capacity (call, ctxt);\n \telse if (is_special_named_call_p (call, \"__analyzer_dump_escaped\", 0))\n \t  impl_call_analyzer_dump_escaped (call);\n+\telse if (is_special_named_call_p (call,\n+\t\t\t\t\t  \"__analyzer_dump_named_constant\",\n+\t\t\t\t\t  1))\n+\t  impl_call_analyzer_dump_named_constant (call, ctxt);\n \telse if (is_special_named_call_p (call, \"__analyzer_dump_path\", 0))\n \t  {\n \t    /* Handle the builtin \"__analyzer_dump_path\" by queuing a"}, {"sha": "bd81e6b6b9db4dceec80bfd475892d303dff9a2b", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -344,6 +344,8 @@ class region_model\n   void impl_call_analyzer_dump_capacity (const gcall *call,\n \t\t\t\t\t region_model_context *ctxt);\n   void impl_call_analyzer_dump_escaped (const gcall *call);\n+  void impl_call_analyzer_dump_named_constant (const gcall *call,\n+\t\t\t\t\t       region_model_context *ctxt);\n   void impl_call_analyzer_eval (const gcall *call,\n \t\t\t\tregion_model_context *ctxt);\n   void impl_call_analyzer_get_unknown_ptr (const call_details &cd);"}, {"sha": "370115d56bf10786afc28ffdf3a8d6cbe4cdd23d", "filename": "gcc/analyzer/sm-fd.cc", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fanalyzer%2Fsm-fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fanalyzer%2Fsm-fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.cc?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -159,6 +159,11 @@ class fd_state_machine : public state_machine\n   /* State for a file descriptor that we do not want to track anymore . */\n   state_t m_stop;\n \n+  /* Stashed constant values from the frontend.  These could be NULL.  */\n+  tree m_O_ACCMODE;\n+  tree m_O_RDONLY;\n+  tree m_O_WRONLY;\n+\n private:\n   void on_open (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\n \t\tconst gcall *call) const;\n@@ -686,7 +691,10 @@ fd_state_machine::fd_state_machine (logger *logger)\n       m_valid_write_only (add_state (\"fd-valid-write-only\")),\n       m_invalid (add_state (\"fd-invalid\")),\n       m_closed (add_state (\"fd-closed\")),\n-      m_stop (add_state (\"fd-stop\"))\n+      m_stop (add_state (\"fd-stop\")),\n+      m_O_ACCMODE (get_stashed_constant_by_name (\"O_ACCMODE\")),\n+      m_O_RDONLY (get_stashed_constant_by_name (\"O_RDONLY\")),\n+      m_O_WRONLY (get_stashed_constant_by_name (\"O_WRONLY\"))\n {\n }\n \n@@ -709,16 +717,18 @@ fd_state_machine::is_valid_fd_p (state_t s) const\n enum access_mode\n fd_state_machine::get_access_mode_from_flag (int flag) const\n {\n-  /* FIXME: this code assumes the access modes on the host and\n-     target are the same, which in practice might not be the case.  */\n-\n-  if ((flag & O_ACCMODE) == O_RDONLY)\n-    {\n-      return READ_ONLY;\n-    }\n-  else if ((flag & O_ACCMODE) == O_WRONLY)\n+  if (m_O_ACCMODE && TREE_CODE (m_O_ACCMODE) == INTEGER_CST)\n     {\n-      return WRITE_ONLY;\n+      const unsigned HOST_WIDE_INT mask_val = TREE_INT_CST_LOW (m_O_ACCMODE);\n+      const unsigned HOST_WIDE_INT masked_flag = flag & mask_val;\n+\n+      if (m_O_RDONLY && TREE_CODE (m_O_RDONLY) == INTEGER_CST)\n+\tif (masked_flag == TREE_INT_CST_LOW (m_O_RDONLY))\n+\t  return READ_ONLY;\n+\n+      if (m_O_WRONLY && TREE_CODE (m_O_WRONLY) == INTEGER_CST)\n+\tif (masked_flag == TREE_INT_CST_LOW (m_O_WRONLY))\n+\t  return WRITE_ONLY;\n     }\n   return READ_WRITE;\n }"}, {"sha": "f3c79996fb0f25af74d147e0035698eae45fc3c4", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -72,6 +72,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"memmodel.h\"\n #include \"c-family/known-headers.h\"\n #include \"bitmap.h\"\n+#include \"analyzer/analyzer-language.h\"\n+#include \"toplev.h\"\n \n /* We need to walk over decls with incomplete struct/union/enum types\n    after parsing the whole translation unit.\n@@ -1664,6 +1666,86 @@ static bool c_parser_objc_diagnose_bad_element_prefix\n   (c_parser *, struct c_declspecs *);\n static location_t c_parser_parse_rtl_body (c_parser *, char *);\n \n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* Concrete implementation of ana::translation_unit for the C frontend.  */\n+\n+class c_translation_unit : public translation_unit\n+{\n+public:\n+  /* Implementation of translation_unit::lookup_constant_by_id for use by the\n+     analyzer to look up named constants in the user's source code.  */\n+  tree lookup_constant_by_id (tree id) const final override\n+  {\n+    /* Consider decls.  */\n+    if (tree decl = lookup_name (id))\n+      if (TREE_CODE (decl) == CONST_DECL)\n+\tif (tree value = DECL_INITIAL (decl))\n+\t  if (TREE_CODE (value) == INTEGER_CST)\n+\t    return value;\n+\n+    /* Consider macros.  */\n+    cpp_hashnode *hashnode = C_CPP_HASHNODE (id);\n+    if (cpp_macro_p (hashnode))\n+      if (tree value = consider_macro (hashnode->value.macro))\n+\treturn value;\n+\n+    return NULL_TREE;\n+  }\n+\n+private:\n+  /* Attempt to get an INTEGER_CST from MACRO.\n+     Only handle the simplest cases: where MACRO's definition is a single\n+     token containing a number, by lexing the number again.\n+     This will handle e.g.\n+       #define NAME 42\n+     and other bases but not negative numbers, parentheses or e.g.\n+       #define NAME 1 << 7\n+     as doing so would require a parser.  */\n+  tree consider_macro (cpp_macro *macro) const\n+  {\n+    if (macro->paramc > 0)\n+      return NULL_TREE;\n+    if (macro->kind != cmk_macro)\n+      return NULL_TREE;\n+    if (macro->count != 1)\n+      return NULL_TREE;\n+    const cpp_token &tok = macro->exp.tokens[0];\n+    if (tok.type != CPP_NUMBER)\n+      return NULL_TREE;\n+\n+    cpp_reader *old_parse_in = parse_in;\n+    parse_in = cpp_create_reader (CLK_GNUC89, ident_hash, line_table);\n+\n+    pretty_printer pp;\n+    pp_string (&pp, (const char *) tok.val.str.text);\n+    pp_newline (&pp);\n+    cpp_push_buffer (parse_in,\n+\t\t     (const unsigned char *) pp_formatted_text (&pp),\n+\t\t     strlen (pp_formatted_text (&pp)),\n+\t\t     0);\n+\n+    tree value;\n+    location_t loc;\n+    unsigned char cpp_flags;\n+    c_lex_with_flags (&value, &loc, &cpp_flags, 0);\n+\n+    cpp_destroy (parse_in);\n+    parse_in = old_parse_in;\n+\n+    if (value && TREE_CODE (value) == INTEGER_CST)\n+      return value;\n+\n+    return NULL_TREE;\n+  }\n+};\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */\n+\n /* Parse a translation unit (C90 6.7, C99 6.9, C11 6.9).\n \n    translation-unit:\n@@ -1724,6 +1806,14 @@ c_parser_translation_unit (c_parser *parser)\n \t       \"#pragma omp begin assumes\", \"#pragma omp end assumes\");\n       current_omp_begin_assumes = 0;\n     }\n+\n+#if ENABLE_ANALYZER\n+  if (flag_analyzer)\n+    {\n+      ana::c_translation_unit tu;\n+      ana::on_finish_translation_unit (tu);\n+    }\n+#endif\n }\n \n /* Parse an external declaration (C90 6.7, C99 6.9, C11 6.9)."}, {"sha": "d61b55cec5aa027bf2a94bc750f3bd19dc3d0588", "filename": "gcc/doc/analyzer.texi", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fdoc%2Fanalyzer.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Fdoc%2Fanalyzer.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fanalyzer.texi?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -524,6 +524,23 @@ With a non-zero argument\n \n it will also dump all of the states within the ``processed'' nodes.\n \n+The builtin @code{__analyzer_dump_named_constant} will emit a warning\n+during analysis describing what is known about the value of a given\n+named constant, for parts of the analyzer that interact with target\n+headers.\n+\n+For example:\n+\n+@smallexample\n+__analyzer_dump_named_constant (\"O_RDONLY\");\n+@end smallexample\n+\n+might emit the warning:\n+\n+@smallexample\n+warning: named constant 'O_RDONLY' has value '1'\n+@end smallexample\n+\n @smallexample\n    __analyzer_dump_region_model ();\n @end smallexample"}, {"sha": "d9a32ed937069efe0401609a128bef944b30fbca", "filename": "gcc/testsuite/gcc.dg/analyzer/analyzer-decls.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-decls.h?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -31,6 +31,9 @@ extern void __analyzer_dump_escaped (void);\n    will also dump all of the states within those nodes.  */\n extern void __analyzer_dump_exploded_nodes (int);\n \n+/* Emit a warning describing what is known about the value of NAME.  */\n+extern void __analyzer_dump_named_constant (const char *name);\n+\n /* Emit a placeholder \"note\" diagnostic with a path to this call site,\n    if the analyzer finds a feasible path to it.  */\n extern void __analyzer_dump_path (void);"}, {"sha": "994bad84342661bc1d19d4e8d3ab75a3d1f50bbf", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-4.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-4.c?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -8,6 +8,7 @@ void close(int fd);\n int write (int fd, void *buf, int nbytes);\n int read (int fd, void *buf, int nbytes);\n \n+#define O_ACCMODE 0xf\n #define O_RDONLY 0\n #define O_WRONLY 1\n #define O_RDWR 2"}, {"sha": "5226569c437e1dd790fe66e7b4281cfb240ed110", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-access-mode-enum.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-access-mode-enum.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-access-mode-enum.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-access-mode-enum.c?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -0,0 +1,60 @@\n+int open(const char *, int mode);\n+void close(int fd);\n+int write (int fd, void *buf, int nbytes);\n+int read (int fd, void *buf, int nbytes);\n+\n+/* Example of these flags as an enum, and with\n+   non-standard values for them.  */\n+\n+enum {\n+      O_RDONLY  = 0x10,\n+      O_WRONLY  = 0x20,\n+      O_RDWR    = 0x40,\n+\n+      O_ACCMODE = 0xf0\n+};\n+\n+void f (int fd) __attribute__((fd_arg(1))); /* { dg-message \"argument 1 of 'f' must be an open file descriptor, due to '__attribute__\\\\(\\\\(fd_arg\\\\(1\\\\)\\\\)\\\\)'\" } */\n+\n+void\n+test_1 (const char *path)\n+{\n+    int fd = open (path, O_RDWR);\n+    close(fd);\n+    f(fd); /* { dg-warning \"'f' on closed file descriptor 'fd'\" } */\n+      /* { dg-message \"\\\\(3\\\\) 'f' on closed file descriptor 'fd'; 'close' was at \\\\(2\\\\)\" \"\" { target *-*-* } .-1 } */\n+}\n+\n+void g (int fd) __attribute__((fd_arg_read(1))); /* { dg-message \"argument 1 of 'g' must be a readable file descriptor, due to '__attribute__\\\\(\\\\(fd_arg_read\\\\(1\\\\)\\\\)\\\\)'\" } */\n+\n+void\n+test_2 (const char *path)\n+{\n+  int fd = open (path, O_WRONLY);\n+  if (fd != -1)\n+  {\n+    g (fd); /* { dg-warning \"'g' on write-only file descriptor 'fd'\" } */\n+  }\n+  close (fd);\n+}\n+\n+void h (int fd) __attribute__((fd_arg_write(1))); /* { dg-message \"argument 1 of 'h' must be a writable file descriptor, due to '__attribute__\\\\(\\\\(fd_arg_write\\\\(1\\\\)\\\\)\\\\)'\" } */\n+void\n+test_3 (const char *path)\n+{\n+  int fd = open (path, O_RDONLY);\n+  if (fd != -1)\n+  {\n+    h (fd); /* { dg-warning \"'h' on read-only file descriptor 'fd'\" } */\n+  }\n+  close(fd);\n+}\n+\n+void ff (int fd) __attribute__((fd_arg(1))); /* { dg-message \"argument 1 of 'ff' must be an open file descriptor, due to '__attribute__\\\\(\\\\(fd_arg\\\\(1\\\\)\\\\)\\\\)'\" } */\n+\n+void test_4 (const char *path)\n+{\n+  int fd = open (path, O_RDWR);\n+  ff (fd); /* { dg-warning \"'ff' on possibly invalid file descriptor 'fd'\" } */\n+  close(fd);\n+}"}, {"sha": "f9a6931a5dbc3a36c3cbed610ff8732a135d91d7", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-access-mode-macros.c", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-access-mode-macros.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-access-mode-macros.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-access-mode-macros.c?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -6,6 +6,7 @@ int read (int fd, void *buf, int nbytes);\n #define O_RDONLY 0\n #define O_WRONLY 1\n #define O_RDWR 2\n+#define O_ACCMODE 0x3\n \n void f (int fd) __attribute__((fd_arg(1))); /* { dg-message \"argument 1 of 'f' must be an open file descriptor, due to '__attribute__\\\\(\\\\(fd_arg\\\\(1\\\\)\\\\)\\\\)'\" } */\n ", "previous_filename": "gcc/testsuite/gcc.dg/analyzer/fd-5.c"}, {"sha": "b76eb667d5027b3075fa57ed234f74bd6cace063", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-access-mode-target-headers.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-access-mode-target-headers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-access-mode-target-headers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-access-mode-target-headers.c?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -0,0 +1,56 @@\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include \"analyzer-decls.h\"\n+\n+void f (int fd) __attribute__((fd_arg(1))); /* { dg-message \"argument 1 of 'f' must be an open file descriptor, due to '__attribute__\\\\(\\\\(fd_arg\\\\(1\\\\)\\\\)\\\\)'\" } */\n+\n+void\n+test_1 (const char *path)\n+{\n+    int fd = open (path, O_RDWR);\n+    close(fd);\n+    f(fd); /* { dg-warning \"'f' on closed file descriptor 'fd'\" } */\n+      /* { dg-message \"\\\\(3\\\\) 'f' on closed file descriptor 'fd'; 'close' was at \\\\(2\\\\)\" \"\" { target *-*-* } .-1 } */\n+}\n+\n+void g (int fd) __attribute__((fd_arg_read(1))); /* { dg-message \"argument 1 of 'g' must be a readable file descriptor, due to '__attribute__\\\\(\\\\(fd_arg_read\\\\(1\\\\)\\\\)\\\\)'\" } */\n+\n+void\n+test_2 (const char *path)\n+{\n+  int fd = open (path, O_WRONLY);\n+  if (fd != -1)\n+  {\n+    g (fd); /* { dg-warning \"'g' on write-only file descriptor 'fd'\" } */\n+  }\n+  close (fd);\n+}\n+\n+void h (int fd) __attribute__((fd_arg_write(1))); /* { dg-message \"argument 1 of 'h' must be a writable file descriptor, due to '__attribute__\\\\(\\\\(fd_arg_write\\\\(1\\\\)\\\\)\\\\)'\" } */\n+void\n+test_3 (const char *path)\n+{\n+  int fd = open (path, O_RDONLY);\n+  if (fd != -1)\n+  {\n+    h (fd); /* { dg-warning \"'h' on read-only file descriptor 'fd'\" } */\n+  }\n+  close(fd);\n+}\n+\n+void ff (int fd) __attribute__((fd_arg(1))); /* { dg-message \"argument 1 of 'ff' must be an open file descriptor, due to '__attribute__\\\\(\\\\(fd_arg\\\\(1\\\\)\\\\)\\\\)'\" } */\n+\n+void test_4 (const char *path)\n+{\n+  int fd = open (path, O_RDWR);\n+  ff (fd); /* { dg-warning \"'ff' on possibly invalid file descriptor 'fd'\" } */\n+  close(fd);\n+}\n+\n+void test_sm_fd_constants (void)\n+{\n+  __analyzer_dump_named_constant (\"O_ACCMODE\"); /* { dg-warning \"named constant 'O_ACCMODE' has value '\\[0-9\\]+'\" } */\n+  __analyzer_dump_named_constant (\"O_RDONLY\"); /* { dg-warning \"named constant 'O_RDONLY' has value '\\[0-9\\]+'\" } */\n+  __analyzer_dump_named_constant (\"O_WRONLY\"); /* { dg-warning \"named constant 'O_WRONLY' has value '\\[0-9\\]+'\" } */\n+}"}, {"sha": "bb58e9d9d5e20140256eca294e0a55c24e572709", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-dup-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-dup-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-dup-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-dup-1.c?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -8,6 +8,7 @@ int read (int fd, void *buf, int nbytes);\n #define O_RDONLY 0\n #define O_WRONLY 1\n #define O_RDWR 2\n+#define O_ACCMODE 3\n \n void test_1 (const char *path)\n {"}, {"sha": "9e6cbeeb0369078ac14b906afff9aa0d28937db9", "filename": "gcc/testsuite/gcc.dg/analyzer/named-constants-via-enum-and-macro.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fnamed-constants-via-enum-and-macro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fnamed-constants-via-enum-and-macro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fnamed-constants-via-enum-and-macro.c?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -0,0 +1,12 @@\n+#include \"analyzer-decls.h\"\n+\n+enum __foo {\n+     O_ACCMODE = 1,\n+ \n+#define O_ACCMODE O_ACCMODE\n+};\n+\n+void test_sm_fd_constants (void)\n+{\n+  __analyzer_dump_named_constant (\"O_ACCMODE\"); /* { dg-warning \"named constant 'O_ACCMODE' has value '1'\" } */\n+}"}, {"sha": "e6b77b8dd1828bc83b43bfb69e36f07ae1f3db62", "filename": "gcc/testsuite/gcc.dg/analyzer/named-constants-via-enum.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fnamed-constants-via-enum.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fnamed-constants-via-enum.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fnamed-constants-via-enum.c?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -0,0 +1,20 @@\n+#include \"analyzer-decls.h\"\n+\n+/* Various constants used by the fd state machine.  */\n+enum {\n+      O_ACCMODE = 42,\n+      O_RDONLY  = 0x1,\n+      O_WRONLY  = 010\n+};\n+\n+void test_sm_fd_constants (void)\n+{\n+  __analyzer_dump_named_constant (\"O_ACCMODE\"); /* { dg-warning \"named constant 'O_ACCMODE' has value '42'\" } */\n+  __analyzer_dump_named_constant (\"O_RDONLY\"); /* { dg-warning \"named constant 'O_RDONLY' has value '1'\" } */\n+  __analyzer_dump_named_constant (\"O_WRONLY\"); /* { dg-warning \"named constant 'O_WRONLY' has value '8'\" } */\n+}\n+\n+void test_unknown (void)\n+{\n+  __analyzer_dump_named_constant (\"UNKNOWN\"); /* { dg-warning \"named constant 'UNKNOWN' has unknown value\" } */\n+}"}, {"sha": "9c019e7c5ef2a060da4dd64f6c6262e2e7af4d64", "filename": "gcc/testsuite/gcc.dg/analyzer/named-constants-via-macros-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fnamed-constants-via-macros-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fnamed-constants-via-macros-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fnamed-constants-via-macros-2.c?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -0,0 +1,15 @@\n+#include \"analyzer-decls.h\"\n+\n+/* Various constants used by the fd state machine, as macros\n+   that can't be handled.  */\n+\n+#define O_ACCMODE (\n+#define O_RDONLY  \"foo\"\n+#define O_WRONLY  int\n+\n+void test_sm_fd_constants (void)\n+{\n+  __analyzer_dump_named_constant (\"O_ACCMODE\"); /* { dg-warning \"named constant 'O_ACCMODE' has unknown value\" } */\n+  __analyzer_dump_named_constant (\"O_RDONLY\"); /* { dg-warning \"named constant 'O_RDONLY' has unknown value\" } */\n+  __analyzer_dump_named_constant (\"O_WRONLY\"); /* { dg-warning \"named constant 'O_WRONLY' has unknown value\" } */\n+}"}, {"sha": "2022f98e5b64072d6c1d7d0ffae95d8c0e09b515", "filename": "gcc/testsuite/gcc.dg/analyzer/named-constants-via-macros.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fnamed-constants-via-macros.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aba860b34203621586df8c5a6756b18c2a0c32/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fnamed-constants-via-macros.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fnamed-constants-via-macros.c?ref=d8aba860b34203621586df8c5a6756b18c2a0c32", "patch": "@@ -0,0 +1,19 @@\n+#include \"analyzer-decls.h\"\n+\n+/* Various constants used by the fd state machine.  */\n+\n+#define O_ACCMODE 42\n+#define O_RDONLY  0x1\n+#define O_WRONLY  010\n+\n+void test_sm_fd_constants (void)\n+{\n+  __analyzer_dump_named_constant (\"O_ACCMODE\"); /* { dg-warning \"named constant 'O_ACCMODE' has value '42'\" } */\n+  __analyzer_dump_named_constant (\"O_RDONLY\"); /* { dg-warning \"named constant 'O_RDONLY' has value '1'\" } */\n+  __analyzer_dump_named_constant (\"O_WRONLY\"); /* { dg-warning \"named constant 'O_WRONLY' has value '8'\" } */\n+}\n+\n+void test_unknown (void)\n+{\n+  __analyzer_dump_named_constant (\"UNKNOWN\"); /* { dg-warning \"named constant 'UNKNOWN' has unknown value\" } */\n+}"}]}