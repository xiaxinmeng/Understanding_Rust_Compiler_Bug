{"sha": "dc2cb19139f944afba7993591ce2db3eaa54bb7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMyY2IxOTEzOWY5NDRhZmJhNzk5MzU5MWNlMmRiM2VhYTU0YmI3ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-02-19T23:02:58Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-02-19T23:02:58Z"}, "message": "regmove.c (discover_flags_reg): New function.\n\n        * regmove.c (discover_flags_reg): New function.\n        (flags_set_1, mark_flags_life_zones): New functions.\n        (regmove_optimize): Call them.\n        (fixup_match_1): Use insn modes rather than sets_cc0_p.\n\nFrom-SVN: r25332", "tree": {"sha": "af5eb96fcb1c70c25611e5c77953012d89efcef8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af5eb96fcb1c70c25611e5c77953012d89efcef8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc2cb19139f944afba7993591ce2db3eaa54bb7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc2cb19139f944afba7993591ce2db3eaa54bb7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc2cb19139f944afba7993591ce2db3eaa54bb7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc2cb19139f944afba7993591ce2db3eaa54bb7e/comments", "author": null, "committer": null, "parents": [{"sha": "419ff8e1c2254ca0dbc45ef61f1565e1ee761be9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/419ff8e1c2254ca0dbc45ef61f1565e1ee761be9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/419ff8e1c2254ca0dbc45ef61f1565e1ee761be9"}], "stats": {"total": 190, "additions": 183, "deletions": 7}, "files": [{"sha": "7cee31cd5de9fcb0023329bd28d02d3c7e73dc1b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc2cb19139f944afba7993591ce2db3eaa54bb7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc2cb19139f944afba7993591ce2db3eaa54bb7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc2cb19139f944afba7993591ce2db3eaa54bb7e", "patch": "@@ -1,3 +1,10 @@\n+Fri Feb 19 23:02:02 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* regmove.c (discover_flags_reg): New function.\n+\t(flags_set_1, mark_flags_life_zones): New functions.\n+\t(regmove_optimize): Call them.\n+\t(fixup_match_1): Use insn modes rather than sets_cc0_p.\n+\n Fri Feb 19 22:47:01 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* rtlanal.c (insn_first_p): Fix return value for insn == reference."}, {"sha": "04fcb5da5a4878abc48b75dff5894cfca84d7eea", "filename": "gcc/regmove.c", "status": "modified", "additions": 176, "deletions": 7, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc2cb19139f944afba7993591ce2db3eaa54bb7e/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc2cb19139f944afba7993591ce2db3eaa54bb7e/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=dc2cb19139f944afba7993591ce2db3eaa54bb7e", "patch": "@@ -53,6 +53,10 @@ struct match {\n   int early_clobber[MAX_RECOG_OPERANDS];\n };\n \n+static rtx discover_flags_reg PROTO((void));\n+static void mark_flags_life_zones PROTO((rtx));\n+static void flags_set_1 PROTO((rtx, rtx));\n+\n static int try_auto_increment PROTO((rtx, rtx, rtx, rtx, HOST_WIDE_INT, int));\n static int find_matches PROTO((rtx, struct match *));\n static int fixup_match_1 PROTO((rtx, rtx, rtx, rtx, rtx, int, int, int, FILE *))\n@@ -150,7 +154,172 @@ try_auto_increment (insn, inc_insn, inc_insn_set, reg, increment, pre)\n     }\n   return 0;\n }\n+\f\n+/* Determine if the pattern generated by add_optab has a clobber,\n+   such as might be issued for a flags hard register.  To make the\n+   code elsewhere simpler, we handle cc0 in this same framework.\n+\n+   Return the register if one was discovered.  Return NULL_RTX if\n+   if no flags were found.  Return pc_rtx if we got confused.  */\n+\n+static rtx\n+discover_flags_reg ()\n+{\n+  rtx tmp;\n+  tmp = gen_rtx_REG (SImode, 10000);\n+  tmp = gen_add3_insn (tmp, tmp, GEN_INT (2));\n+\n+  /* If we get something that isn't a simple set, or a \n+     [(set ..) (clobber ..)], this whole function will go wrong.  */\n+  if (GET_CODE (tmp) == SET)\n+    return NULL_RTX;\n+  else if (GET_CODE (tmp) == PARALLEL)\n+    {\n+      int found;\n+\n+      if (XVECLEN (tmp, 0) != 2)\n+\treturn pc_rtx;\n+      tmp = XVECEXP (tmp, 0, 1);\n+      if (GET_CODE (tmp) != CLOBBER)\n+\treturn pc_rtx;\n+      tmp = XEXP (tmp, 0);\n+\n+      /* Don't do anything foolish if the md wanted to clobber a\n+\t scratch or something.  We only care about hard regs.\n+\t Moreover we don't like the notion of subregs of hard regs.  */\n+      if (GET_CODE (tmp) == SUBREG\n+\t  && GET_CODE (SUBREG_REG (tmp)) == REG\n+\t  && REGNO (SUBREG_REG (tmp)) < FIRST_PSEUDO_REGISTER)\n+\treturn pc_rtx;\n+      found = (GET_CODE (tmp) == REG && REGNO (tmp) < FIRST_PSEUDO_REGISTER);\n+\n+#ifdef HAVE_cc0\n+      /* If we're cc0, and we found a potential flags reg, bail.  */\n+      return (found ? pc_rtx : cc0_rtx);\n+#else\n+      return (found ? tmp : NULL_RTX);\n+#endif\n+    }\n+\n+  return pc_rtx;\n+}\n+\n+/* It is a tedious task identifying when the flags register is live and\n+   when it is safe to optimize.  Since we process the instruction stream\n+   multiple times, locate and record these live zones by marking the\n+   mode of the instructions -- \n+\n+   QImode is used on the instruction at which the flags becomes live.\n+\n+   HImode is used within the range (exclusive) that the flags are\n+   live.  Thus the user of the flags is not marked.\n+\n+   All other instructions are cleared to VOIDmode.  */\n+\n+/* Used to communicate with flags_set_1.  */\n+static rtx flags_set_1_rtx;\n+static int flags_set_1_set;\n+\n+static void\n+mark_flags_life_zones (flags)\n+     rtx flags;\n+{\n+  int flags_regno;\n+  int flags_nregs;\n+  int block;\n+\n+  /* Simple cases first: if no flags, clear all modes.  If confusing,\n+     mark the entire function as being in a flags shadow.  */\n+  if (flags == NULL_RTX || flags == pc_rtx)\n+    {\n+      enum machine_mode mode = (flags ? HImode : VOIDmode);\n+      rtx insn;\n+      for (insn = get_insns(); insn; insn = NEXT_INSN (insn))\n+\tPUT_MODE (insn, mode);\n+      return;\n+    }\n+\n+#ifdef HAVE_cc0\n+  flags_regno = -1;\n+  flags_nregs = 1;\n+#else\n+  flags_regno = REGNO (flags);\n+  flags_nregs = HARD_REGNO_NREGS (flags_regno, GET_MODE (flags));\n+#endif\n+  flags_set_1_rtx = flags;\n+\n+  /* Process each basic block.  */\n+  for (block = n_basic_blocks - 1; block >= 0; block--)\n+    {\n+      rtx insn, end;\n+      int live;\n+\n+      insn = BLOCK_HEAD (block);\n+      end = BLOCK_END (block);\n+\n+      /* Look out for the (unlikely) case of flags being live across\n+\t basic block boundaries.  */\n+      live = 0;\n+#ifndef HAVE_cc0\n+      {\n+\tint i;\n+\tfor (i = 0; i < flags_nregs; ++i)\n+          live |= REGNO_REG_SET_P (basic_block_live_at_start[block],\n+\t\t\t\t   flags_regno + i);\n+      }\n+#endif\n+\n+      while (1)\n+\t{\n+\t  /* Process liveness in reverse order of importance --\n+\t     alive, death, birth.  This lets more important info\n+\t     overwrite the mode of lesser info.  */\n+\n+\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t    {\n+#ifdef HAVE_cc0\n+\t      /* In the cc0 case, death is not marked in reg notes,\n+\t\t but is instead the mere use of cc0 when it is alive.  */\n+\t      if (live && reg_mentioned_p (cc0_rtx, PATTERN (insn)))\n+\t\tlive = 0;\n+#else\n+\t      /* In the hard reg case, we watch death notes.  */\n+\t      if (live && find_regno_note (insn, REG_DEAD, flags_regno))\n+\t\tlive = 0;\n+#endif\n+\t      PUT_MODE (insn, (live ? HImode : VOIDmode));\n+\n+\t      /* In either case, birth is denoted simply by it's presence\n+\t\t as the destination of a set.  */\n+\t      flags_set_1_set = 0;\n+\t      note_stores (PATTERN (insn), flags_set_1);\n+\t      if (flags_set_1_set)\n+\t\t{\n+\t\t  live = 1;\n+\t\t  PUT_MODE (insn, QImode);\n+\t\t}\n+\t    }\n+\t  else\n+\t    PUT_MODE (insn, (live ? HImode : VOIDmode));\n+\n+\t  if (insn == end)\n+\t    break;\n+\t  insn = NEXT_INSN (insn);\n+\t}\n+    }\n+}\n \n+/* A subroutine of mark_flags_life_zones, called through note_stores.  */\n+\n+static void\n+flags_set_1 (x, pat)\n+     rtx x, pat;\n+{\n+  if (GET_CODE (pat) == SET\n+      && reg_overlap_mentioned_p (x, flags_set_1_rtx))\n+    flags_set_1_set = 1;\n+}\n+\f\n static int *regno_src_regno;\n \n /* Indicate how good a choice REG (which appears as a source) is to replace\n@@ -908,6 +1077,10 @@ regmove_optimize (f, nregs, regmove_dump_file)\n   int i;\n   rtx copy_src, copy_dst;\n \n+  /* Find out where a potential flags register is live, and so that we\n+     can supress some optimizations in those zones.  */\n+  mark_flags_life_zones (discover_flags_reg ());\n+\n   regno_src_regno = (int *)alloca (sizeof *regno_src_regno * nregs);\n   for (i = nregs; --i >= 0; ) regno_src_regno[i] = -1;\n \n@@ -1617,13 +1790,9 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n \t\t\t    && GET_CODE (SET_DEST (single_set (p))) == REG\n \t\t\t    && (REGNO (SET_DEST (single_set (p)))\n \t\t\t\t< FIRST_PSEUDO_REGISTER))\n-#ifdef HAVE_cc0\n-\t\t      /* We may not emit an insn directly\n-\t\t\t after P if the latter sets CC0.  */\n-\t\t      && ! sets_cc0_p (PATTERN (p))\n-#endif\n-\t\t      )\n-\n+\t\t      /* We may only emit an insn directly after P if we\n+\t\t\t are not in the shadow of a live flags register.  */\n+\t\t      && GET_MODE (p) == VOIDmode)\n \t\t    {\n \t\t      search_end = q;\n \t\t      q = insn;"}]}