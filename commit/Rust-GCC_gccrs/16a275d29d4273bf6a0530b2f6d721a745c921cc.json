{"sha": "16a275d29d4273bf6a0530b2f6d721a745c921cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZhMjc1ZDI5ZDQyNzNiZjZhMDUzMGIyZjZkNzIxYTc0NWM5MjFjYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2011-09-27T16:49:17Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2011-09-27T16:49:17Z"}, "message": "ifcvt.c (cheap_bb_rtx_cost_p): Add SCALE argument.\n\n\t* ifcvt.c (cheap_bb_rtx_cost_p): Add SCALE argument.  Scale\n\tnon-jumping insns by REG_BR_PROB_BASE and the maximum cost\n\tby SCALE.\n\t(find_if_case_1): Use the probability of the THEN clause when\n\tdetermining if speculation is profitable.\n\t(find_if_case_2): Similarly for the ELSE clause.\n\nFrom-SVN: r179284", "tree": {"sha": "6381eca87c4993fc200ec70c432192fd905c402e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6381eca87c4993fc200ec70c432192fd905c402e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16a275d29d4273bf6a0530b2f6d721a745c921cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16a275d29d4273bf6a0530b2f6d721a745c921cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16a275d29d4273bf6a0530b2f6d721a745c921cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16a275d29d4273bf6a0530b2f6d721a745c921cc/comments", "author": null, "committer": null, "parents": [{"sha": "9b7ab6d6e016c89bf22322a95772786a14739465", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b7ab6d6e016c89bf22322a95772786a14739465", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b7ab6d6e016c89bf22322a95772786a14739465"}], "stats": {"total": 61, "additions": 49, "deletions": 12}, "files": [{"sha": "dbe8a600b336a52e8fa440d6d78cc6b475bf5992", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a275d29d4273bf6a0530b2f6d721a745c921cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a275d29d4273bf6a0530b2f6d721a745c921cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16a275d29d4273bf6a0530b2f6d721a745c921cc", "patch": "@@ -1,3 +1,12 @@\n+2011-09-27  Jeff Law  <law@redhat.com>\n+\n+\t* ifcvt.c (cheap_bb_rtx_cost_p): Add SCALE argument.  Scale\n+\tnon-jumping insns by REG_BR_PROB_BASE and the maximum cost\n+\tby SCALE.\n+\t(find_if_case_1): Use the probability of the THEN clause when\n+\tdetermining if speculation is profitable.\n+\t(find_if_case_2): Similarly for the ELSE clause.\n+\n 2011-09-27  Jakub Jelinek  <jakub@redhat.com>\n \n \t* common.opt: Add -foptimize-strlen option."}, {"sha": "272cbb7175f29faa8de534bffcf931b850af88f8", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a275d29d4273bf6a0530b2f6d721a745c921cc/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a275d29d4273bf6a0530b2f6d721a745c921cc/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=16a275d29d4273bf6a0530b2f6d721a745c921cc", "patch": "@@ -85,7 +85,7 @@ static int cond_exec_changed_p;\n \n /* Forward references.  */\n static int count_bb_insns (const_basic_block);\n-static bool cheap_bb_rtx_cost_p (const_basic_block, int);\n+static bool cheap_bb_rtx_cost_p (const_basic_block, int, int);\n static rtx first_active_insn (basic_block);\n static rtx last_active_insn (basic_block, int);\n static rtx find_active_insn_before (basic_block, rtx);\n@@ -131,20 +131,31 @@ count_bb_insns (const_basic_block bb)\n \n /* Determine whether the total insn_rtx_cost on non-jump insns in\n    basic block BB is less than MAX_COST.  This function returns\n-   false if the cost of any instruction could not be estimated.  */\n+   false if the cost of any instruction could not be estimated. \n+\n+   The cost of the non-jump insns in BB is scaled by REG_BR_PROB_BASE\n+   as those insns are being speculated.  MAX_COST is scaled with SCALE\n+   plus a small fudge factor.  */\n \n static bool\n-cheap_bb_rtx_cost_p (const_basic_block bb, int max_cost)\n+cheap_bb_rtx_cost_p (const_basic_block bb, int scale, int max_cost)\n {\n   int count = 0;\n   rtx insn = BB_HEAD (bb);\n   bool speed = optimize_bb_for_speed_p (bb);\n \n+  /* Our branch probability/scaling factors are just estimates and don't\n+     account for cases where we can get speculation for free and other\n+     secondary benefits.  So we fudge the scale factor to make speculating\n+     appear a little more profitable.  */\n+  scale += REG_BR_PROB_BASE / 8;\n+  max_cost *= scale;\n+\n   while (1)\n     {\n       if (NONJUMP_INSN_P (insn))\n \t{\n-\t  int cost = insn_rtx_cost (PATTERN (insn), speed);\n+\t  int cost = insn_rtx_cost (PATTERN (insn), speed) * REG_BR_PROB_BASE;\n \t  if (cost == 0)\n \t    return false;\n \n@@ -3796,8 +3807,8 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n   basic_block then_bb = then_edge->dest;\n   basic_block else_bb = else_edge->dest;\n   basic_block new_bb;\n+  int then_bb_index, then_prob;\n   rtx else_target = NULL_RTX;\n-  int then_bb_index;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n@@ -3840,8 +3851,14 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n \t     \"\\nIF-CASE-1 found, start %d, then %d\\n\",\n \t     test_bb->index, then_bb->index);\n \n-  /* THEN is small.  */\n-  if (! cheap_bb_rtx_cost_p (then_bb,\n+  if (then_edge->probability)\n+    then_prob = REG_BR_PROB_BASE - then_edge->probability;\n+  else\n+    then_prob = REG_BR_PROB_BASE / 2;\n+\n+  /* We're speculating from the THEN path, we want to make sure the cost\n+     of speculation is within reason.  */\n+  if (! cheap_bb_rtx_cost_p (then_bb, then_prob,\n \tCOSTS_N_INSNS (BRANCH_COST (optimize_bb_for_speed_p (then_edge->src),\n \t\t\t\t    predictable_edge_p (then_edge)))))\n     return FALSE;\n@@ -3910,7 +3927,7 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n   basic_block then_bb = then_edge->dest;\n   basic_block else_bb = else_edge->dest;\n   edge else_succ;\n-  rtx note;\n+  int then_prob, else_prob;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n@@ -3949,9 +3966,19 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n   if (then_bb->index < NUM_FIXED_BLOCKS)\n     return FALSE;\n \n+  if (else_edge->probability)\n+    {\n+      else_prob = else_edge->probability;\n+      then_prob = REG_BR_PROB_BASE - else_prob;\n+    }\n+  else\n+    {\n+      else_prob = REG_BR_PROB_BASE / 2;\n+      then_prob = REG_BR_PROB_BASE / 2;\n+    }\n+\n   /* ELSE is predicted or SUCC(ELSE) postdominates THEN.  */\n-  note = find_reg_note (BB_END (test_bb), REG_BR_PROB, NULL_RTX);\n-  if (note && INTVAL (XEXP (note, 0)) >= REG_BR_PROB_BASE / 2)\n+  if (else_prob > then_prob)\n     ;\n   else if (else_succ->dest->index < NUM_FIXED_BLOCKS\n \t   || dominated_by_p (CDI_POST_DOMINATORS, then_bb,\n@@ -3966,8 +3993,9 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n \t     \"\\nIF-CASE-2 found, start %d, else %d\\n\",\n \t     test_bb->index, else_bb->index);\n \n-  /* ELSE is small.  */\n-  if (! cheap_bb_rtx_cost_p (else_bb,\n+  /* We're speculating from the ELSE path, we want to make sure the cost\n+     of speculation is within reason.  */\n+  if (! cheap_bb_rtx_cost_p (else_bb, else_prob,\n \tCOSTS_N_INSNS (BRANCH_COST (optimize_bb_for_speed_p (else_edge->src),\n \t\t\t\t    predictable_edge_p (else_edge)))))\n     return FALSE;"}]}