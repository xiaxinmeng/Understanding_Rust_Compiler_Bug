{"sha": "9a34a5cce6b50fc3527e7c7ab356808ed435883c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEzNGE1Y2NlNmI1MGZjMzUyN2U3YzdhYjM1NjgwOGVkNDM1ODgzYw==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-10-31T20:53:34Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-11-06T19:49:23Z"}, "message": "Objective-C/C++ (parsers) : Update @property attribute parsing.\n\nAt present, we are missing parsing and checking for around\nhalf of the property attributes in use.  The existing ad hoc scheme\nfor the parser's communication with the Objective C validation\nis not suitable for extending to cover all the missing cases.\n\nAdditionally:\n\n1/ We were declaring errors in two cases that the reference\n   implementation warns (or is silent).\n\n   I've elected to warn for both those cases, (Wattributes) it\n   could be that we should implement Wobjc-xxx-property warning\n   masks (TODO).\n\n2/ We were emitting spurious complaints about missing property\n   attributes when these were not being parsed because we gave\n   up on the first syntax error.\n\n3/ The quality of the diagnostic locations was poor (that's\n   true for much of Objective-C, we will have to improve it as\n   we modernise areas).\n\nWe continue to attempt to keep the code, warning and error output\nsimilar (preferably identical output) between the C and C++ front\nends.\n\nThe interface to the Objective-C-specific parts of the parsing is\nsimplified to a vector of parsed (but not fully-checked) property\nattributes, this will simplify the addition of new attributes.\n\ngcc/c-family/ChangeLog:\n\n\t* c-objc.h (enum objc_property_attribute_group): New\n\t(enum objc_property_attribute_kind): New.\n\t(OBJC_PROPATTR_GROUP_MASK): New.\n\t(struct property_attribute_info): Small class encapsulating\n\tparser output from property attributes.\n\t(objc_prop_attr_kind_for_rid): New\n\t(objc_add_property_declaration): Simplify interface.\n\t* stub-objc.c (enum rid): Dummy type.\n\t(objc_add_property_declaration): Simplify interface.\n\t(objc_prop_attr_kind_for_rid): New.\n\ngcc/c/ChangeLog:\n\n\t* c-parser.c (c_parser_objc_at_property_declaration):\n\tImprove parsing fidelity. Associate better location info\n\twith @property attributes.  Clean up the interface to\n\tobjc_add_property_declaration ().\n\ngcc/cp/ChangeLog:\n\n\t* parser.c (cp_parser_objc_at_property_declaration):\n\tImprove parsing fidelity. Associate better location info\n\twith @property attributes.  Clean up the interface to\n\tobjc_add_property_declaration ().\n\ngcc/objc/ChangeLog:\n\n\t* objc-act.c (objc_prop_attr_kind_for_rid): New.\n\t(objc_add_property_declaration): Adjust to consume the\n\tparser output using a vector of parsed attributes.\n\ngcc/testsuite/ChangeLog:\n\n\t* obj-c++.dg/property/at-property-1.mm: Adjust expected\n\tdiagnostics.\n\t* obj-c++.dg/property/at-property-29.mm: Likewise.\n\t* obj-c++.dg/property/at-property-4.mm: Likewise.\n\t* obj-c++.dg/property/property-neg-2.mm: Likewise.\n\t* objc.dg/property/at-property-1.m: Likewise.\n\t* objc.dg/property/at-property-29.m: Likewise.\n\t* objc.dg/property/at-property-4.m: Likewise.\n\t* objc.dg/property/at-property-5.m: Likewise.\n\t* objc.dg/property/property-neg-2.m: Likewise.", "tree": {"sha": "a1b114d1c1f375371c8eb1cf69025a15d99dfb80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1b114d1c1f375371c8eb1cf69025a15d99dfb80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a34a5cce6b50fc3527e7c7ab356808ed435883c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a34a5cce6b50fc3527e7c7ab356808ed435883c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a34a5cce6b50fc3527e7c7ab356808ed435883c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a34a5cce6b50fc3527e7c7ab356808ed435883c/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c282c14d1be0bba2bf5d49acd074b349f28ad17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c282c14d1be0bba2bf5d49acd074b349f28ad17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c282c14d1be0bba2bf5d49acd074b349f28ad17"}], "stats": {"total": 992, "additions": 598, "deletions": 394}, "files": [{"sha": "a2ca112dcc6cfb731cf61a74edd50f95d564f464", "filename": "gcc/c-family/c-objc.h", "status": "modified", "additions": 63, "deletions": 2, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Fc-family%2Fc-objc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Fc-family%2Fc-objc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-objc.h?ref=9a34a5cce6b50fc3527e7c7ab356808ed435883c", "patch": "@@ -28,6 +28,67 @@ enum GTY(()) objc_ivar_visibility_kind {\n   OBJC_IVAR_VIS_PACKAGE   = 3\n };\n \n+/* ObjC property attribute kinds.\n+   These have two fields; a unique value (that identifies which attribute)\n+   and a group key that indicates membership of an exclusion group.\n+   Only one member may be present from an exclusion group in a given attribute\n+   list.\n+   getters and setters have additional rules, since they are excluded from\n+   non-overlapping group sets.  */\n+\n+enum objc_property_attribute_group\n+{\n+  OBJC_PROPATTR_GROUP_UNKNOWN = 0,\n+  OBJC_PROPATTR_GROUP_GETTER,\n+  OBJC_PROPATTR_GROUP_SETTER,\n+  OBJC_PROPATTR_GROUP_READWRITE,\n+  OBJC_PROPATTR_GROUP_ASSIGN,\n+  OBJC_PROPATTR_GROUP_ATOMIC,\n+  OBJC_PROPATTR_GROUP_MAX\n+};\n+\n+enum objc_property_attribute_kind\n+{\n+  OBJC_PROPERTY_ATTR_UNKNOWN =\t\t0|OBJC_PROPATTR_GROUP_UNKNOWN,\n+  OBJC_PROPERTY_ATTR_GETTER =\t\t( 1 << 8)|OBJC_PROPATTR_GROUP_GETTER,\n+  OBJC_PROPERTY_ATTR_SETTER =\t\t( 2 << 8)|OBJC_PROPATTR_GROUP_SETTER,\n+  OBJC_PROPERTY_ATTR_READONLY =\t\t( 3 << 8)|OBJC_PROPATTR_GROUP_READWRITE,\n+  OBJC_PROPERTY_ATTR_READWRITE =\t( 4 << 8)|OBJC_PROPATTR_GROUP_READWRITE,\n+  OBJC_PROPERTY_ATTR_ASSIGN =\t\t( 5 << 8)|OBJC_PROPATTR_GROUP_ASSIGN,\n+  OBJC_PROPERTY_ATTR_RETAIN =\t\t( 6 << 8)|OBJC_PROPATTR_GROUP_ASSIGN,\n+  OBJC_PROPERTY_ATTR_COPY =\t\t( 7 << 8)|OBJC_PROPATTR_GROUP_ASSIGN,\n+  OBJC_PROPERTY_ATTR_ATOMIC =\t\t( 8 << 8)|OBJC_PROPATTR_GROUP_ATOMIC,\n+  OBJC_PROPERTY_ATTR_NONATOMIC =\t( 9 << 8)|OBJC_PROPATTR_GROUP_ATOMIC,\n+  OBJC_PROPERTY_ATTR_MAX =\t\t(255 << 8|OBJC_PROPATTR_GROUP_MAX)\n+};\n+\n+#define OBJC_PROPATTR_GROUP_MASK 0x0f\n+\n+/* To contain parsed, but unverified, information about a single property\n+   attribute.  */\n+struct property_attribute_info\n+{\n+  property_attribute_info () = default;\n+  property_attribute_info (tree name, location_t loc,\n+\t\t\t   enum objc_property_attribute_kind k)\n+   : name (name), ident (NULL_TREE), prop_loc (loc), prop_kind (k),\n+     parse_error (false) {}\n+\n+  enum objc_property_attribute_group group ()\n+    {\n+      return (enum objc_property_attribute_group)\n+\t((unsigned)prop_kind & OBJC_PROPATTR_GROUP_MASK);\n+    }\n+\n+  tree name; /* Name of the attribute.  */\n+  tree ident; /* For getter/setter cases, the method/selector name.  */\n+  location_t prop_loc; /* Extended location covering the parsed attr.  */\n+  enum objc_property_attribute_kind prop_kind : 16;\n+  unsigned parse_error : 1; /* The C/C++ parser saw an error in this attr.  */\n+};\n+\n+extern enum objc_property_attribute_kind objc_prop_attr_kind_for_rid (enum rid);\n+\n /* Objective-C / Objective-C++ entry points.  */\n \n /* The following ObjC/ObjC++ functions are called by the C and/or C++\n@@ -90,8 +151,8 @@ extern tree objc_generate_write_barrier (tree, enum tree_code, tree);\n extern void objc_set_method_opt (bool);\n extern void objc_finish_foreach_loop (location_t, tree, tree, tree, tree, tree);\n extern bool  objc_method_decl (enum tree_code);\n-extern void objc_add_property_declaration (location_t, tree, bool, bool, bool, \n-\t\t\t\t\t   bool, bool, bool, tree, tree);\n+extern void objc_add_property_declaration (location_t, tree,\n+\t\t\t\t\t   vec<property_attribute_info *>&);\n extern tree objc_maybe_build_component_ref (tree, tree);\n extern tree objc_build_class_component_ref (tree, tree);\n extern tree objc_maybe_build_modify_expr (tree, tree);"}, {"sha": "2f535578789712c987d457cbdb319f8c9d3d8aef", "filename": "gcc/c-family/stub-objc.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Fc-family%2Fstub-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Fc-family%2Fstub-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fstub-objc.c?ref=9a34a5cce6b50fc3527e7c7ab356808ed435883c", "patch": "@@ -23,6 +23,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n+#include \"vec.h\"\n+\n+/* Provide a dummy type for the RID enum used as an argument to\n+   objc_prop_attr_kind_for_rid () */\n+enum rid { DUMMY };\n+\n #include \"c-objc.h\"\n \n tree\n@@ -314,14 +320,8 @@ objc_get_class_ivars (tree ARG_UNUSED (name))\n void\n objc_add_property_declaration (location_t ARG_UNUSED (location), \n \t\t\t       tree ARG_UNUSED (decl),\n-\t\t\t       bool ARG_UNUSED (parsed_property_readonly),\n-\t\t\t       bool ARG_UNUSED (parsed_property_readwrite),\n-\t\t\t       bool ARG_UNUSED (parsed_property_assign),\n-\t\t\t       bool ARG_UNUSED (parsed_property_retain),\n-\t\t\t       bool ARG_UNUSED (parsed_property_copy),\n-\t\t\t       bool ARG_UNUSED (parsed_property_nonatomic),\n-\t\t\t       tree ARG_UNUSED (parsed_property_getter_ident),\n-\t\t\t       tree ARG_UNUSED (parsed_property_setter_ident))\n+\t\t\t       vec<property_attribute_info *>&\n+\t\t\t       /*prop_attr_list*/)\n {\n }\n \n@@ -465,3 +465,8 @@ void\n objc_maybe_warn_exceptions (location_t ARG_UNUSED (loc))\n {\n }\n+\n+enum objc_property_attribute_kind objc_prop_attr_kind_for_rid (enum rid)\n+{\n+  return OBJC_PROPERTY_ATTR_UNKNOWN;\n+}"}, {"sha": "da8278a8257c4ffc8be3d9d2ba300abc87d06f08", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 159, "deletions": 121, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=9a34a5cce6b50fc3527e7c7ab356808ed435883c", "patch": "@@ -11958,158 +11958,196 @@ c_parser_objc_diagnose_bad_element_prefix (c_parser *parser,\n static void\n c_parser_objc_at_property_declaration (c_parser *parser)\n {\n-  /* The following variables hold the attributes of the properties as\n-     parsed.  They are 'false' or 'NULL_TREE' if the attribute was not\n-     seen.  When we see an attribute, we set them to 'true' (if they\n-     are boolean properties) or to the identifier (if they have an\n-     argument, ie, for getter and setter).  Note that here we only\n-     parse the list of attributes, check the syntax and accumulate the\n-     attributes that we find.  objc_add_property_declaration() will\n-     then process the information.  */\n-  bool property_assign = false;\n-  bool property_copy = false;\n-  tree property_getter_ident = NULL_TREE;\n-  bool property_nonatomic = false;\n-  bool property_readonly = false;\n-  bool property_readwrite = false;\n-  bool property_retain = false;\n-  tree property_setter_ident = NULL_TREE;\n-\n-  /* 'properties' is the list of properties that we read.  Usually a\n-     single one, but maybe more (eg, in \"@property int a, b, c;\" there\n-     are three).  */\n-  tree properties;\n-  location_t loc;\n-\n-  loc = c_parser_peek_token (parser)->location;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_AT_PROPERTY));\n-\n+  location_t loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_token (parser);  /* Eat '@property'.  */\n \n-  /* Parse the optional attribute list...  */\n+  /* Parse the optional attribute list.\n+\n+     A list of parsed, but not verified, attributes.  */\n+  vec<property_attribute_info *> prop_attr_list = vNULL;\n+\n+  bool syntax_error = false;\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n     {\n       matching_parens parens;\n \n+      location_t attr_start = c_parser_peek_token (parser)->location;\n       /* Eat the '(' */\n       parens.consume_open (parser);\n \n       /* Property attribute keywords are valid now.  */\n       parser->objc_property_attr_context = true;\n \n-      while (true)\n+      /* Allow @property (), with a warning.  */\n+      location_t attr_end = c_parser_peek_token (parser)->location;\n+\n+      if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \t{\n-\t  bool syntax_error = false;\n-\t  c_token *token = c_parser_peek_token (parser);\n-\t  enum rid keyword;\n+\t  location_t attr_comb = make_location (attr_end, attr_start, attr_end);\n+\t  warning_at (attr_comb, OPT_Wattributes,\n+\t\t      \"empty property attribute list\");\n+\t}\n+      else\n+\twhile (true)\n+\t  {\n+\t    c_token *token = c_parser_peek_token (parser);\n+\t    attr_start = token->location;\n+\t    attr_end = get_finish (token->location);\n+\t    location_t attr_comb = make_location (attr_start, attr_start,\n+\t\t\t\t\t\t  attr_end);\n \n-\t  if (token->type != CPP_KEYWORD)\n-\t    {\n-\t      if (token->type == CPP_CLOSE_PAREN)\n-\t\tc_parser_error (parser, \"expected identifier\");\n-\t      else\n-\t\t{\n-\t\t  c_parser_consume_token (parser);\n-\t\t  c_parser_error (parser, \"unknown property attribute\");\n-\t\t}\n-\t      break;\n-\t    }\n-\t  keyword = token->keyword;\n-\t  c_parser_consume_token (parser);\n-\t  switch (keyword)\n-\t    {\n-\t    case RID_ASSIGN:    property_assign = true;    break;\n-\t    case RID_COPY:      property_copy = true;      break;\n-\t    case RID_NONATOMIC: property_nonatomic = true; break;\n-\t    case RID_READONLY:  property_readonly = true;  break;\n-\t    case RID_READWRITE: property_readwrite = true; break;\n-\t    case RID_RETAIN:    property_retain = true;    break;\n-\n-\t    case RID_GETTER:\n-\t    case RID_SETTER:\n-\t      if (c_parser_next_token_is_not (parser, CPP_EQ))\n-\t\t{\n-\t\t  if (keyword == RID_GETTER)\n-\t\t    c_parser_error (parser,\n-\t\t\t\t    \"missing %<=%> (after %<getter%> attribute)\");\n-\t\t  else\n-\t\t    c_parser_error (parser,\n-\t\t\t\t    \"missing %<=%> (after %<setter%> attribute)\");\n-\t\t  syntax_error = true;\n-\t\t  break;\n-\t\t}\n-\t      c_parser_consume_token (parser); /* eat the = */\n-\t      if (c_parser_next_token_is_not (parser, CPP_NAME))\n-\t\t{\n-\t\t  c_parser_error (parser, \"expected identifier\");\n-\t\t  syntax_error = true;\n+\t    if (token->type == CPP_CLOSE_PAREN || token->type == CPP_COMMA)\n+\t      {\n+\t\twarning_at (attr_comb, OPT_Wattributes,\n+\t\t\t    \"missing property attribute\");\n+\t\tif (token->type == CPP_CLOSE_PAREN)\n \t\t  break;\n-\t\t}\n-\t      if (keyword == RID_SETTER)\n-\t\t{\n-\t\t  if (property_setter_ident != NULL_TREE)\n-\t\t    c_parser_error (parser, \"the %<setter%> attribute may only be specified once\");\n-\t\t  else\n-\t\t    property_setter_ident = c_parser_peek_token (parser)->value;\n-\t\t  c_parser_consume_token (parser);\n-\t\t  if (c_parser_next_token_is_not (parser, CPP_COLON))\n-\t\t    c_parser_error (parser, \"setter name must terminate with %<:%>\");\n-\t\t  else\n-\t\t    c_parser_consume_token (parser);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (property_getter_ident != NULL_TREE)\n-\t\t    c_parser_error (parser, \"the %<getter%> attribute may only be specified once\");\n-\t\t  else\n-\t\t    property_getter_ident = c_parser_peek_token (parser)->value;\n-\t\t  c_parser_consume_token (parser);\n-\t\t}\n-\t      break;\n-\t    default:\n-\t      c_parser_error (parser, \"unknown property attribute\");\n-\t      syntax_error = true;\n-\t      break;\n+\t\tc_parser_consume_token (parser);\n+\t\tcontinue;\n+\t      }\n+\n+\t    tree attr_name = NULL_TREE;\n+\t    enum rid keyword = RID_MAX; /* Not a valid property attribute.  */\n+\t    bool add_at = false;\n+\t    if (token->type == CPP_KEYWORD)\n+\t      {\n+\t\tkeyword = token->keyword;\n+\t\tif (OBJC_IS_AT_KEYWORD (keyword))\n+\t\t  {\n+\t\t    /* For '@' keywords the token value has the keyword,\n+\t\t       prepend the '@' for diagnostics.  */\n+\t\t    attr_name = token->value;\n+\t\t    add_at = true;\n+\t\t  }\n+\t\telse\n+\t\t  attr_name = ridpointers[(int)keyword];\n+\t      }\n+\t    else if (token->type == CPP_NAME)\n+\t      attr_name = token->value;\n+\t    c_parser_consume_token (parser);\n+\n+\t    enum objc_property_attribute_kind prop_kind\n+\t      = objc_prop_attr_kind_for_rid (keyword);\n+\t    property_attribute_info *prop\n+\t      = new property_attribute_info (attr_name, attr_comb, prop_kind);\n+\t    prop_attr_list.safe_push (prop);\n+\n+\t    tree meth_name;\n+\t    switch (prop->prop_kind)\n+\t      {\n+\t      default: break;\n+\t      case OBJC_PROPERTY_ATTR_UNKNOWN:\n+\t\tif (attr_name)\n+\t\t  error_at (attr_comb, \"unknown property attribute %<%s%s%>\",\n+\t\t\t    add_at ? \"@\" : \"\", IDENTIFIER_POINTER (attr_name));\n+\t\telse\n+\t\t  error_at (attr_comb, \"unknown property attribute\");\n+\t\tprop->parse_error = syntax_error = true;\n+\t\tbreak;\n+\n+\t      case OBJC_PROPERTY_ATTR_GETTER:\n+\t      case OBJC_PROPERTY_ATTR_SETTER:\n+\t\tif (c_parser_next_token_is_not (parser, CPP_EQ))\n+\t\t  {\n+\t\t    attr_comb = make_location (attr_end, attr_start, attr_end);\n+\t\t    error_at (attr_comb, \"expected %<=%> after Objective-C %qE\",\n+\t\t\t      attr_name);\n+\t\t    prop->parse_error = syntax_error = true;\n+\t\t    break;\n+\t\t  }\n+\t\ttoken = c_parser_peek_token (parser);\n+\t\tattr_end = token->location;\n+\t\tc_parser_consume_token (parser); /* eat the = */\n+\t\tif (c_parser_next_token_is_not (parser, CPP_NAME))\n+\t\t  {\n+\t\t    attr_comb = make_location (attr_end, attr_start, attr_end);\n+\t\t    error_at (attr_comb, \"expected %qE selector name\",\n+\t\t\t      attr_name);\n+\t\t    prop->parse_error = syntax_error = true;\n+\t\t    break;\n+\t\t  }\n+\t\t/* Get the end of the method name, and consume the name.  */\n+\t\ttoken = c_parser_peek_token (parser);\n+\t\tattr_end = get_finish (token->location);\n+\t\tmeth_name = token->value;\n+\t\tc_parser_consume_token (parser);\n+\t\tif (prop->prop_kind == OBJC_PROPERTY_ATTR_SETTER)\n+\t\t  {\n+\t\t    if (c_parser_next_token_is_not (parser, CPP_COLON))\n+\t\t      {\n+\t\t\tattr_comb = make_location (attr_end, attr_start,\n+\t\t\t\t\t\t   attr_end);\n+\t\t\terror_at (attr_comb, \"setter method names must\"\n+\t\t\t\t  \" terminate with %<:%>\");\n+\t\t\tprop->parse_error = syntax_error = true;\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\tattr_end = get_finish (c_parser_peek_token\n+\t\t\t\t\t       (parser)->location);\n+\t\t\tc_parser_consume_token (parser);\n+\t\t      }\n+\t\t    attr_comb = make_location (attr_start, attr_start,\n+\t\t\t\t\t       attr_end);\n+\t\t  }\n+\t\telse\n+\t\t  attr_comb = make_location (attr_start, attr_start,\n+\t\t\t\t\t       attr_end);\n+\t\tprop->ident = meth_name;\n+\t\t/* Updated location including all that was successfully\n+\t\t   parsed.  */\n+\t\tprop->prop_loc = attr_comb;\n+\t\tbreak;\n \t    }\n \n-\t  if (syntax_error)\n-\t    break;\n-\t  \n+\t  /* If we see a comma here, then keep going - even if we already\n+\t     saw a syntax error.  For simple mistakes e.g. (asign, getter=x)\n+\t     this makes a more useful output and avoid spurious warnings about\n+\t     missing attributes that are, in fact, specified after the one with\n+\t     the syntax error.  */\n \t  if (c_parser_next_token_is (parser, CPP_COMMA))\n \t    c_parser_consume_token (parser);\n \t  else\n \t    break;\n \t}\n       parser->objc_property_attr_context = false;\n-      parens.skip_until_found_close (parser);\n-    }\n-  /* ... and the property declaration(s).  */\n-  properties = c_parser_struct_declaration (parser);\n \n-  if (properties == error_mark_node)\n-    {\n-      c_parser_skip_until_found (parser, CPP_SEMICOLON, NULL);\n-      parser->error = false;\n-      return;\n+      if (syntax_error && c_parser_next_token_is_not (parser, CPP_CLOSE_PAREN))\n+\t/* We don't really want to chew the whole of the file looking for a\n+\t   matching closing parenthesis, so we will try to read the decl and\n+\t   let the error handling for that close out the statement.  */\n+\t;\n+      else\n+\tsyntax_error = false, parens.skip_until_found_close (parser);\n     }\n \n-  if (properties == NULL_TREE)\n-    c_parser_error (parser, \"expected identifier\");\n+  /* 'properties' is the list of properties that we read.  Usually a\n+     single one, but maybe more (eg, in \"@property int a, b, c;\" there\n+     are three).  */\n+  tree properties = c_parser_struct_declaration (parser);\n+\n+  if (properties == error_mark_node)\n+    c_parser_skip_until_found (parser, CPP_SEMICOLON, NULL);\n   else\n     {\n-      /* Comma-separated properties are chained together in\n-\t reverse order; add them one by one.  */\n-      properties = nreverse (properties);\n-      \n-      for (; properties; properties = TREE_CHAIN (properties))\n-\tobjc_add_property_declaration (loc, copy_node (properties),\n-\t\t\t\t       property_readonly, property_readwrite,\n-\t\t\t\t       property_assign, property_retain,\n-\t\t\t\t       property_copy, property_nonatomic,\n-\t\t\t\t       property_getter_ident, property_setter_ident);\n+      if (properties == NULL_TREE)\n+\tc_parser_error (parser, \"expected identifier\");\n+      else\n+\t{\n+\t  /* Comma-separated properties are chained together in reverse order;\n+\t     add them one by one.  */\n+\t  properties = nreverse (properties);\n+\t  for (; properties; properties = TREE_CHAIN (properties))\n+\t    objc_add_property_declaration (loc, copy_node (properties),\n+\t\t\t\t\t    prop_attr_list);\n+\t}\n+      c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n     }\n \n-  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+  while (!prop_attr_list.is_empty())\n+    delete prop_attr_list.pop ();\n+  prop_attr_list.release ();\n   parser->error = false;\n }\n "}, {"sha": "c4c672efa09584395ee39415f8992f5e86b80d5c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 146, "deletions": 120, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9a34a5cce6b50fc3527e7c7ab356808ed435883c", "patch": "@@ -34001,30 +34001,11 @@ cp_parser_objc_struct_declaration (cp_parser *parser)\n static void\n cp_parser_objc_at_property_declaration (cp_parser *parser)\n {\n-  /* The following variables hold the attributes of the properties as\n-     parsed.  They are 'false' or 'NULL_TREE' if the attribute was not\n-     seen.  When we see an attribute, we set them to 'true' (if they\n-     are boolean properties) or to the identifier (if they have an\n-     argument, ie, for getter and setter).  Note that here we only\n-     parse the list of attributes, check the syntax and accumulate the\n-     attributes that we find.  objc_add_property_declaration() will\n-     then process the information.  */\n-  bool property_assign = false;\n-  bool property_copy = false;\n-  tree property_getter_ident = NULL_TREE;\n-  bool property_nonatomic = false;\n-  bool property_readonly = false;\n-  bool property_readwrite = false;\n-  bool property_retain = false;\n-  tree property_setter_ident = NULL_TREE;\n+  /* Parse the optional attribute list.\n \n-  /* 'properties' is the list of properties that we read.  Usually a\n-     single one, but maybe more (eg, in \"@property int a, b, c;\" there\n-     are three).  */\n-  tree properties;\n-  location_t loc;\n-\n-  loc = cp_lexer_peek_token (parser->lexer)->location;\n+     A list of parsed, but not verified, attributes.  */\n+  vec<property_attribute_info *> prop_attr_list = vNULL;\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@property'.  */\n \n@@ -34033,127 +34014,172 @@ cp_parser_objc_at_property_declaration (cp_parser *parser)\n     {\n       /* Eat the '('.  */\n       matching_parens parens;\n+      location_t attr_start = cp_lexer_peek_token (parser->lexer)->location;\n       parens.consume_open (parser);\n       bool syntax_error = false;\n \n-      while (true)\n+      /* Allow empty @property attribute lists, but with a warning.  */\n+      location_t attr_end = cp_lexer_peek_token (parser->lexer)->location;\n+      location_t attr_comb;\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n \t{\n-\t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-      \t  enum rid keyword;\n+\t  attr_comb = make_location (attr_end, attr_start, attr_end);\n+\t  warning_at (attr_comb, OPT_Wattributes,\n+\t\t      \"empty property attribute list\");\n+\t}\n+      else\n+\twhile (true)\n+\t  {\n+\t    cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\t    attr_start = token->location;\n+\t    attr_end = get_finish (token->location);\n+\t    attr_comb = make_location (attr_start, attr_start, attr_end);\n \n-\t  if (token->type != CPP_NAME)\n-\t    {\n-\t      cp_parser_error (parser, \"expected identifier\");\n-\t      syntax_error = true;\n-\t      break;\n-\t    }\n-\t  keyword = C_RID_CODE (token->u.value);\n-\t  cp_lexer_consume_token (parser->lexer);\n-\t  switch (keyword)\n-\t    {\n-\t    case RID_ASSIGN:    property_assign = true;    break;\n-\t    case RID_COPY:      property_copy = true;      break;\n-\t    case RID_NONATOMIC: property_nonatomic = true; break;\n-\t    case RID_READONLY:  property_readonly = true;  break;\n-\t    case RID_READWRITE: property_readwrite = true; break;\n-\t    case RID_RETAIN:    property_retain = true;    break;\n-\n-\t    case RID_GETTER:\n-\t    case RID_SETTER:\n-\t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_EQ))\n-\t\t{\n-\t\t  if (keyword == RID_GETTER)\n-\t\t    cp_parser_error (parser,\n-\t\t\t\t     \"missing %<=%> (after %<getter%> attribute)\");\n-\t\t  else\n-\t\t    cp_parser_error (parser,\n-\t\t\t\t     \"missing %<=%> (after %<setter%> attribute)\");\n-\t\t  syntax_error = true;\n-\t\t  break;\n-\t\t}\n-\t      cp_lexer_consume_token (parser->lexer); /* eat the = */\n-\t      if (!cp_parser_objc_selector_p (cp_lexer_peek_token (parser->lexer)->type))\n-\t\t{\n-\t\t  cp_parser_error (parser, \"expected identifier\");\n-\t\t  syntax_error = true;\n+\t    if (token->type == CPP_CLOSE_PAREN || token->type == CPP_COMMA)\n+\t      {\n+\t\twarning_at (attr_comb, OPT_Wattributes,\n+\t\t\t    \"missing property attribute\");\n+\t\tif (token->type == CPP_CLOSE_PAREN)\n \t\t  break;\n-\t\t}\n-\t      if (keyword == RID_SETTER)\n-\t\t{\n-\t\t  if (property_setter_ident != NULL_TREE)\n-\t\t    {\n-\t\t      cp_parser_error (parser, \"the %<setter%> attribute may only be specified once\");\n-\t\t      cp_lexer_consume_token (parser->lexer);\n-\t\t    }\n-\t\t  else\n-\t\t    property_setter_ident = cp_parser_objc_selector (parser);\n-\t\t  if (cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n-\t\t    cp_parser_error (parser, \"setter name must terminate with %<:%>\");\n-\t\t  else\n-\t\t    cp_lexer_consume_token (parser->lexer);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (property_getter_ident != NULL_TREE)\n-\t\t    {\n-\t\t      cp_parser_error (parser, \"the %<getter%> attribute may only be specified once\");\n-\t\t      cp_lexer_consume_token (parser->lexer);\n-\t\t    }\n-\t\t  else\n-\t\t    property_getter_ident = cp_parser_objc_selector (parser);\n-\t\t}\n-\t      break;\n-\t    default:\n-\t      cp_parser_error (parser, \"unknown property attribute\");\n-\t      syntax_error = true;\n-\t      break;\n-\t    }\n+\t\tcp_lexer_consume_token (parser->lexer);\n+\t\tcontinue;\n+\t      }\n \n-\t  if (syntax_error)\n-\t    break;\n+\t    tree attr_name = NULL_TREE;\n+\t    if (identifier_p (token->u.value))\n+\t      attr_name = token->u.value;\n \n-\t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\t    enum rid keyword;\n+\t    if (token->type == CPP_NAME)\n+\t      keyword = C_RID_CODE (token->u.value);\n+\t    else\n+\t      keyword = RID_MAX; /* By definition, an unknown property.  */\n \t    cp_lexer_consume_token (parser->lexer);\n-\t  else\n-\t    break;\n-\t}\n+\n+\t    enum objc_property_attribute_kind prop_kind\n+\t      = objc_prop_attr_kind_for_rid (keyword);\n+\t    property_attribute_info *prop\n+\t      = new property_attribute_info (attr_name, attr_comb, prop_kind);\n+\t    prop_attr_list.safe_push (prop);\n+\n+\t    tree meth_name;\n+\t    switch (prop->prop_kind)\n+\t      {\n+\t      default: break;\n+\t      case OBJC_PROPERTY_ATTR_UNKNOWN:\n+\t\tif (attr_name)\n+\t\t  error_at (attr_start, \"unknown property attribute %qE\",\n+\t\t\t    attr_name);\n+\t\telse\n+\t\t  error_at (attr_start, \"unknown property attribute\");\n+\t\tprop->parse_error = syntax_error = true;\n+\t\tbreak;\n+\n+\t      case OBJC_PROPERTY_ATTR_GETTER:\n+\t      case OBJC_PROPERTY_ATTR_SETTER:\n+\t\tif (cp_lexer_next_token_is_not (parser->lexer, CPP_EQ))\n+\t\t  {\n+\t\t    attr_comb = make_location (attr_end, attr_start, attr_end);\n+\t\t    error_at (attr_comb, \"expected %<=%> after Objective-C %qE\",\n+\t\t\t      attr_name);\n+\t\t    prop->parse_error = syntax_error = true;\n+\t\t    break;\n+\t\t  }\n+\n+\t\ttoken = cp_lexer_peek_token (parser->lexer);\n+\t\tattr_end = token->location;\n+\t\tcp_lexer_consume_token (parser->lexer); /* eat the = */\n+\n+\t\tif (!cp_parser_objc_selector_p\n+\t\t     (cp_lexer_peek_token (parser->lexer)->type))\n+\t\t  {\n+\t\t    attr_comb = make_location (attr_end, attr_start, attr_end);\n+\t\t    error_at (attr_comb, \"expected %qE selector name\",\n+\t\t\t      attr_name);\n+\t\t    prop->parse_error = syntax_error = true;\n+\t\t    break;\n+\t\t  }\n+\n+\t\t/* Get the end of the method name, and consume the name.  */\n+\t\ttoken = cp_lexer_peek_token (parser->lexer);\n+\t\tattr_end = get_finish (token->location);\n+\t\t/* Because method names may contain C++ keywords, we have a\n+\t\t   routine to fetch them (this also consumes the token).  */\n+\t\tmeth_name = cp_parser_objc_selector (parser);\n+\n+\t\tif (prop->prop_kind == OBJC_PROPERTY_ATTR_SETTER)\n+\t\t  {\n+\t\t    if (cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n+\t\t      {\n+\t\t\tattr_comb = make_location (attr_end, attr_start,\n+\t\t\t\t\t\t   attr_end);\n+\t\t\terror_at (attr_comb, \"setter method names must\"\n+\t\t\t\t  \" terminate with %<:%>\");\n+\t\t\tprop->parse_error = syntax_error = true;\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\tattr_end = get_finish (cp_lexer_peek_token\n+\t\t\t\t\t       (parser->lexer)->location);\n+\t\t\tcp_lexer_consume_token (parser->lexer);\n+\t\t      }\n+\t\t    attr_comb = make_location (attr_start, attr_start,\n+\t\t\t\t\t       attr_end);\n+\t\t  }\n+\t\telse\n+\t\t  attr_comb = make_location (attr_start, attr_start,\n+\t\t\t\t\t     attr_end);\n+\t\tprop->ident = meth_name;\n+\t\t/* Updated location including all that was successfully\n+\t\t   parsed.  */\n+\t\tprop->prop_loc = attr_comb;\n+\t\tbreak;\n+\t      }\n+\n+\t    /* If we see a comma here, then keep going - even if we already\n+\t       saw a syntax error.  For simple mistakes e.g. (asign, getter=x)\n+\t       this makes a more useful output and avoid spurious warnings\n+\t       about missing attributes that are, in fact, specified after the\n+\t       one with the syntax error.  */\n+\t    if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t    else\n+\t      break;\n+\t  }\n \n       if (syntax_error || !parens.require_close (parser))\n-\tcp_parser_skip_to_closing_parenthesis (parser,\n-\t\t\t\t\t\t /*recovering=*/true,\n-\t\t\t\t\t\t /*or_comma=*/false,\n-\t\t\t\t\t\t /*consume_paren=*/true);\n+\tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t       /*or_comma=*/false,\n+\t\t\t\t\t       /*consume_paren=*/true);\n     }\n \n-  /* ... and the property declaration(s).  */\n-  properties = cp_parser_objc_struct_declaration (parser);\n+  /* 'properties' is the list of properties that we read.  Usually a\n+     single one, but maybe more (eg, in \"@property int a, b, c;\" there\n+     are three).\n+     TODO: Update this parsing so that it accepts (erroneous) bitfields so\n+     that we can issue a meaningful and consistent (between C/C++) error\n+     message from objc_add_property_declaration ().  */\n+  tree properties = cp_parser_objc_struct_declaration (parser);\n \n   if (properties == error_mark_node)\n-    {\n-      cp_parser_skip_to_end_of_statement (parser);\n-      /* If the next token is now a `;', consume it.  */\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n-\tcp_lexer_consume_token (parser->lexer);\n-      return;\n-    }\n-\n-  if (properties == NULL_TREE)\n+    cp_parser_skip_to_end_of_statement (parser);\n+  else if (properties == NULL_TREE)\n     cp_parser_error (parser, \"expected identifier\");\n   else\n     {\n-      /* Comma-separated properties are chained together in\n-\t reverse order; add them one by one.  */\n+      /* Comma-separated properties are chained together in reverse order;\n+\t add them one by one.  */\n       properties = nreverse (properties);\n-\n       for (; properties; properties = TREE_CHAIN (properties))\n \tobjc_add_property_declaration (loc, copy_node (properties),\n-\t\t\t\t       property_readonly, property_readwrite,\n-\t\t\t\t       property_assign, property_retain,\n-\t\t\t\t       property_copy, property_nonatomic,\n-\t\t\t\t       property_getter_ident, property_setter_ident);\n+\t\t\t\t       prop_attr_list);\n     }\n \n   cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\n+  while (!prop_attr_list.is_empty())\n+    delete prop_attr_list.pop ();\n+  prop_attr_list.release ();\n }\n \n /* Parse an Objective-C++ @synthesize declaration.  The syntax is:"}, {"sha": "26cdeddfc5af63bf961618b6a5abcd0ae036c0a9", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 179, "deletions": 116, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=9a34a5cce6b50fc3527e7c7ab356808ed435883c", "patch": "@@ -804,119 +804,74 @@ lookup_property (tree interface_type, tree property)\n   return inter;\n }\n \n+/* This routine returns a PROPERTY_KIND for the front end RID code supplied.  */\n+\n+enum objc_property_attribute_kind\n+objc_prop_attr_kind_for_rid (enum rid prop_rid)\n+{\n+  switch (prop_rid)\n+    {\n+      default:\t\t\treturn OBJC_PROPERTY_ATTR_UNKNOWN;\n+      case RID_GETTER:\t\treturn OBJC_PROPERTY_ATTR_GETTER;\n+      case RID_SETTER:\t\treturn OBJC_PROPERTY_ATTR_SETTER;\n+\n+      case RID_READONLY:\treturn OBJC_PROPERTY_ATTR_READONLY;\n+      case RID_READWRITE:\treturn OBJC_PROPERTY_ATTR_READWRITE;\n+\n+      case RID_ASSIGN:\t\treturn OBJC_PROPERTY_ATTR_ASSIGN;\n+      case RID_RETAIN:\t\treturn OBJC_PROPERTY_ATTR_RETAIN;\n+      case RID_COPY:\t\treturn OBJC_PROPERTY_ATTR_COPY;\n+\n+      case RID_NONATOMIC:\treturn OBJC_PROPERTY_ATTR_NONATOMIC;\n+\n+    }\n+}\n+\n /* This routine is called by the parser when a\n    @property... declaration is found.  'decl' is the declaration of\n    the property (type/identifier), and the other arguments represent\n    property attributes that may have been specified in the Objective-C\n    declaration.  'parsed_property_readonly' is 'true' if the attribute\n    'readonly' was specified, and 'false' if not; similarly for the\n-   other bool parameters.  'parsed_property_getter_ident' is NULL_TREE\n+   other bool parameters.  'property_getter_ident' is NULL_TREE\n    if the attribute 'getter' was not specified, and is the identifier\n    corresponding to the specified getter if it was; similarly for\n-   'parsed_property_setter_ident'.  */\n+   'property_setter_ident'.  */\n void\n objc_add_property_declaration (location_t location, tree decl,\n-\t\t\t       bool parsed_property_readonly, bool parsed_property_readwrite,\n-\t\t\t       bool parsed_property_assign, bool parsed_property_retain,\n-\t\t\t       bool parsed_property_copy, bool parsed_property_nonatomic,\n-\t\t\t       tree parsed_property_getter_ident, tree parsed_property_setter_ident)\n+\t\t\t       vec<property_attribute_info *>& prop_attr_list)\n {\n-  tree property_decl;\n-  tree x;\n-  /* 'property_readonly' and 'property_assign_semantics' are the final\n-     attributes of the property after all parsed attributes have been\n-     considered (eg, if we parsed no 'readonly' and no 'readwrite', ie\n-     parsed_property_readonly = false and parsed_property_readwrite =\n-     false, then property_readonly will be false because the default\n-     is readwrite).  */\n-  bool property_readonly = false;\n-  objc_property_assign_semantics property_assign_semantics = OBJC_PROPERTY_ASSIGN;\n-  bool property_extension_in_class_extension = false;\n-\n   if (flag_objc1_only)\n-    error_at (input_location, \"%<@property%> is not available in Objective-C 1.0\");\n-\n-  if (parsed_property_readonly && parsed_property_readwrite)\n-    {\n-      error_at (location, \"%<readonly%> attribute conflicts with %<readwrite%> attribute\");\n-      /* In case of conflicting attributes (here and below), after\n-\t producing an error, we pick one of the attributes and keep\n-\t going.  */\n-      property_readonly = false;\n-    }\n-  else\n-    {\n-      if (parsed_property_readonly)\n-\tproperty_readonly = true;\n-\n-      if (parsed_property_readwrite)\n-\tproperty_readonly = false;\n-    }\n-\n-  if (parsed_property_readonly && parsed_property_setter_ident)\n-    {\n-      error_at (location, \"%<readonly%> attribute conflicts with %<setter%> attribute\");\n-      property_readonly = false;\n-    }\n-\n-  if (parsed_property_assign && parsed_property_retain)\n-    {\n-      error_at (location, \"%<assign%> attribute conflicts with %<retain%> attribute\");\n-      property_assign_semantics = OBJC_PROPERTY_RETAIN;\n-    }\n-  else if (parsed_property_assign && parsed_property_copy)\n-    {\n-      error_at (location, \"%<assign%> attribute conflicts with %<copy%> attribute\");\n-      property_assign_semantics = OBJC_PROPERTY_COPY;\n-    }\n-  else if (parsed_property_retain && parsed_property_copy)\n-    {\n-      error_at (location, \"%<retain%> attribute conflicts with %<copy%> attribute\");\n-      property_assign_semantics = OBJC_PROPERTY_COPY;\n-    }\n-  else\n-    {\n-      if (parsed_property_assign)\n-\tproperty_assign_semantics = OBJC_PROPERTY_ASSIGN;\n-\n-      if (parsed_property_retain)\n-\tproperty_assign_semantics = OBJC_PROPERTY_RETAIN;\n-\n-      if (parsed_property_copy)\n-\tproperty_assign_semantics = OBJC_PROPERTY_COPY;\n-    }\n+    /* FIXME: we probably ought to bail out at this point.  */\n+    error_at (location, \"%<@property%> is not available in Objective-C 1.0\");\n \n+  /* We must be in an interface, category, or protocol.  */\n   if (!objc_interface_context)\n     {\n-      error_at (location, \"property declaration not in @interface or @protocol context\");\n+      error_at (location, \"property declaration not in %<@interface%>,\"\n+\t\t\t  \" %<@protocol%> or %<category%> context\");\n       return;\n     }\n \n-  /* At this point we know that we are either in an interface, a\n-     category, or a protocol.  */\n+  /* Do some spot-checks for the most obvious invalid cases.  */\n+\n+  gcc_checking_assert (decl && TREE_CODE (decl) == FIELD_DECL);\n \n-  /* We expect a FIELD_DECL from the parser.  Make sure we didn't get\n-     something else, as that would confuse the checks below.  */\n-  if (TREE_CODE (decl) != FIELD_DECL)\n+  if (decl && !DECL_NAME (decl))\n     {\n-      error_at (location, \"invalid property declaration\");\n+      error_at (location, \"properties must be named\");\n       return;\n     }\n \n-  /* Do some spot-checks for the most obvious invalid types.  */\n-\n+  location_t decl_loc = DECL_SOURCE_LOCATION (decl);\n+  decl_loc = make_location (decl_loc, location, decl_loc);\n   if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n     {\n-      error_at (location, \"property cannot be an array\");\n+      error_at (decl_loc, \"property cannot be an array\");\n       return;\n     }\n \n-  /* The C++/ObjC++ parser seems to reject the ':' for a bitfield when\n-     parsing, while the C/ObjC parser accepts it and gives us a\n-     FIELD_DECL with a DECL_INITIAL set.  So we use the DECL_INITIAL\n-     to check for a bitfield when doing ObjC.  */\n-#ifndef OBJCPLUS\n-  if (DECL_INITIAL (decl))\n+  if (DECL_C_BIT_FIELD (decl))\n     {\n       /* A @property is not an actual variable, but it is a way to\n \t describe a pair of accessor methods, so its type (which is\n@@ -925,10 +880,110 @@ objc_add_property_declaration (location_t location, tree decl,\n \t and arguments of functions cannot be bitfields).  The\n \t underlying instance variable could be a bitfield, but that is\n \t a different matter.  */\n-      error_at (location, \"property cannot be a bit-field\");\n+      error_at (decl_loc, \"property cannot be a bit-field\");\n       return;\n     }\n-#endif\n+\n+  /* The final results of parsing the (growing number) of property\n+     attributes.  */\n+  property_attribute_info *attrs[OBJC_PROPATTR_GROUP_MAX] = { nullptr };\n+\n+  tree property_getter_ident = NULL_TREE;\n+  tree property_setter_ident = NULL_TREE;\n+  for (unsigned pn = 0; pn < prop_attr_list.length (); ++pn)\n+    {\n+      if (prop_attr_list[pn]->parse_error)\n+\tcontinue; /* Ignore attributes known to be wrongly parsed.  */\n+\n+      switch (int g = (int) prop_attr_list[pn]->group())\n+\t{\n+\tcase OBJC_PROPATTR_GROUP_UNKNOWN:\n+\t  continue;\n+\tcase OBJC_PROPATTR_GROUP_SETTER:\n+\tcase OBJC_PROPATTR_GROUP_GETTER:\n+\t  if (attrs[g])\n+\t    {\n+\t      warning_at (prop_attr_list[pn]->prop_loc, OPT_Wattributes,\n+\t\t\t  \"multiple property %qE methods specified, the latest\"\n+\t\t\t  \" one will be used\", attrs[g]->name);\n+\t      inform (attrs[g]->prop_loc, \"previous specification\");\n+\t    }\n+\t  attrs[g] = prop_attr_list[pn];\n+\t  if (g == OBJC_PROPATTR_GROUP_SETTER)\n+\t    property_setter_ident = attrs[g]->ident;\n+\t  else\n+\t    property_getter_ident = attrs[g]->ident;\n+\t  continue;\n+\tdefault:\n+\t  {\n+\t    if (!attrs[g])\n+\t      ;\n+\t    else if (attrs[g]->prop_kind != prop_attr_list[pn]->prop_kind)\n+\t      {\n+\t\terror_at (prop_attr_list[pn]->prop_loc,\n+\t\t\t  \"%qE attribute conflicts with %qE attribute\",\n+\t\t\t  prop_attr_list[pn]->name, attrs[g]->name);\n+\t\tinform (attrs[g]->prop_loc, \"%qE specified here\",\n+\t\t\tattrs[g]->name );\n+\t      }\n+\t    else\n+\t      {\n+\t\twarning_at (prop_attr_list[pn]->prop_loc, OPT_Wattributes,\n+\t\t\t    \"duplicate %qE attribute\", attrs[g]->name);\n+\t\tinform (attrs[g]->prop_loc, \"first specified here\");\n+\t      }\n+\t    attrs[g] = prop_attr_list[pn];\n+\t  }\n+\t  continue;\n+\t}\n+    }\n+\n+  /* The defaults for atomicity (atomic) and write-ability (readwrite) apply\n+     even if the user provides no specified attributes.  */\n+  bool property_nonatomic = false;\n+  bool property_readonly = false;\n+\n+  /* Set the values from any specified by the user; these are easy, only two\n+     states.  */\n+  if (attrs[OBJC_PROPATTR_GROUP_ATOMIC])\n+    property_nonatomic = attrs[OBJC_PROPATTR_GROUP_ATOMIC]->prop_kind\n+\t\t\t == OBJC_PROPERTY_ATTR_NONATOMIC;\n+\n+  if (attrs[OBJC_PROPATTR_GROUP_READWRITE])\n+    property_readonly = attrs[OBJC_PROPATTR_GROUP_READWRITE]->prop_kind\n+\t\t\t == OBJC_PROPERTY_ATTR_READONLY;\n+\n+  /* One can't set a readonly value; we issue an error, but force the property\n+     to readwrite as well.  */\n+  if (property_readonly && property_setter_ident)\n+    {\n+      error_at (attrs[OBJC_PROPATTR_GROUP_READWRITE]->prop_loc, \"%<readonly%>\"\n+\t\t\" attribute conflicts with %<setter%> attribute\");\n+      gcc_checking_assert (attrs[OBJC_PROPATTR_GROUP_SETTER]);\n+      inform (attrs[OBJC_PROPATTR_GROUP_SETTER]->prop_loc, \"%<setter%>\"\n+\t      \" specified here\");\n+      property_readonly = false;\n+    }\n+\n+  /* Assign semantics is a tri-state property, and also needs some further\n+     checking against the object type.  */\n+  objc_property_assign_semantics property_assign_semantics\n+    = OBJC_PROPERTY_ASSIGN;\n+\n+  if (attrs[OBJC_PROPATTR_GROUP_ASSIGN])\n+    {\n+      if (attrs[OBJC_PROPATTR_GROUP_ASSIGN]->prop_kind\n+\t  == OBJC_PROPERTY_ATTR_ASSIGN)\n+\tproperty_assign_semantics = OBJC_PROPERTY_ASSIGN;\n+      else if (attrs[OBJC_PROPATTR_GROUP_ASSIGN]->prop_kind\n+\t       == OBJC_PROPERTY_ATTR_RETAIN)\n+\tproperty_assign_semantics = OBJC_PROPERTY_RETAIN;\n+      else if (attrs[OBJC_PROPATTR_GROUP_ASSIGN]->prop_kind\n+\t       == OBJC_PROPERTY_ATTR_COPY)\n+\tproperty_assign_semantics = OBJC_PROPERTY_COPY;\n+      else\n+\tgcc_unreachable ();\n+    }\n \n   /* TODO: Check that the property type is an Objective-C object or a\n      \"POD\".  */\n@@ -950,69 +1005,77 @@ objc_add_property_declaration (location_t location, tree decl,\n \t for non-{Objective-C objects}, and to 'retain' for\n \t Objective-C objects.  But that would break compatibility with\n \t other compilers.  */\n-      if (!parsed_property_assign && !parsed_property_retain && !parsed_property_copy)\n+      if (!attrs[OBJC_PROPATTR_GROUP_ASSIGN])\n \t{\n \t  /* Use 'false' so we do not warn for Class objects.  */\n \t  if (objc_type_valid_for_messaging (TREE_TYPE (decl), false))\n \t    {\n-\t      warning_at (location,\n-\t\t\t  0,\n-\t\t\t  \"object property %qD has no %<assign%>, %<retain%> or %<copy%> attribute; assuming %<assign%>\",\n-\t\t\t  decl);\n-\t      inform (location,\n-\t\t      \"%<assign%> can be unsafe for Objective-C objects; please state explicitly if you need it\");\n+\t      warning_at (decl_loc, 0, \"object property %qD has no %<assign%>,\"\n+\t\t\t  \" %<retain%> or %<copy%> attribute; assuming\"\n+\t\t\t  \" %<assign%>\", decl);\n+\t      inform (decl_loc, \"%<assign%> can be unsafe for Objective-C\"\n+\t\t      \" objects; please state explicitly if you need it\");\n \t    }\n \t}\n     }\n \n-  if (property_assign_semantics == OBJC_PROPERTY_RETAIN\n-      && !objc_type_valid_for_messaging (TREE_TYPE (decl), true))\n-    error_at (location, \"%<retain%> attribute is only valid for Objective-C objects\");\n+  /* Some attributes make no sense unless applied to an Objective-C object.  */\n+  bool prop_objc_object_p\n+    = objc_type_valid_for_messaging (TREE_TYPE (decl), true);\n+  if (!prop_objc_object_p)\n+    {\n+      tree p_name = NULL_TREE;\n+      if (property_assign_semantics == OBJC_PROPERTY_RETAIN\n+\t  || property_assign_semantics == OBJC_PROPERTY_COPY)\n+\tp_name = attrs[OBJC_PROPATTR_GROUP_ASSIGN]->name;\n \n-  if (property_assign_semantics == OBJC_PROPERTY_COPY\n-      && !objc_type_valid_for_messaging (TREE_TYPE (decl), true))\n-    error_at (location, \"%<copy%> attribute is only valid for Objective-C objects\");\n+      if (p_name)\n+\terror_at (decl_loc, \"%qE attribute is only valid for Objective-C\"\n+\t\t  \" objects\", p_name);\n+    }\n \n   /* Now determine the final property getter and setter names.  They\n      will be stored in the PROPERTY_DECL, from which they'll always be\n      extracted and used.  */\n \n   /* Adjust, or fill in, setter and getter names.  We overwrite the\n-     parsed_property_setter_ident and parsed_property_getter_ident\n+     property_setter_ident and property_getter_ident\n      with the final setter and getter identifiers that will be\n      used.  */\n-  if (parsed_property_setter_ident)\n+  if (property_setter_ident)\n     {\n       /* The setter should be terminated by ':', but the parser only\n \t gives us an identifier without ':'.  So, we need to add ':'\n \t at the end.  */\n-      const char *parsed_setter = IDENTIFIER_POINTER (parsed_property_setter_ident);\n+      const char *parsed_setter = IDENTIFIER_POINTER (property_setter_ident);\n       size_t length = strlen (parsed_setter);\n       char *final_setter = (char *)alloca (length + 2);\n \n       sprintf (final_setter, \"%s:\", parsed_setter);\n-      parsed_property_setter_ident = get_identifier (final_setter);\n+      property_setter_ident = get_identifier (final_setter);\n     }\n   else\n     {\n       if (!property_readonly)\n-\tparsed_property_setter_ident = get_identifier (objc_build_property_setter_name\n+\tproperty_setter_ident = get_identifier (objc_build_property_setter_name\n \t\t\t\t\t\t       (DECL_NAME (decl)));\n     }\n \n-  if (!parsed_property_getter_ident)\n-    parsed_property_getter_ident = DECL_NAME (decl);\n+  if (!property_getter_ident)\n+    property_getter_ident = DECL_NAME (decl);\n \n   /* Check for duplicate property declarations.  We first check the\n      immediate context for a property with the same name.  Any such\n      declarations are an error, unless this is a class extension and\n      we are extending a property from readonly to readwrite.  */\n+  bool property_extension_in_class_extension = false;\n+  tree x = NULL_TREE;\n   for (x = CLASS_PROPERTY_DECL (objc_interface_context); x; x = TREE_CHAIN (x))\n     {\n       if (PROPERTY_NAME (x) == DECL_NAME (decl))\n \t{\n \t  if (objc_in_class_extension\n-\t      && property_readonly == 0\n+\t      && !property_readonly\n \t      && PROPERTY_READONLY (x) == 1)\n \t    {\n \t      /* This is a class extension, and we are extending an\n@@ -1087,7 +1150,7 @@ objc_add_property_declaration (location_t location, tree decl,\n \t types, or it is compatible.  */\n       location_t original_location = DECL_SOURCE_LOCATION (x);\n \n-      if (PROPERTY_NONATOMIC (x) != parsed_property_nonatomic)\n+      if (PROPERTY_NONATOMIC (x) != property_nonatomic)\n \t{\n \t  warning_at (location, 0,\n \t\t      \"%<nonatomic%> attribute of property %qD conflicts with \"\n@@ -1098,7 +1161,7 @@ objc_add_property_declaration (location_t location, tree decl,\n \t  return;\n \t}\n \n-      if (PROPERTY_GETTER_NAME (x) != parsed_property_getter_ident)\n+      if (PROPERTY_GETTER_NAME (x) != property_getter_ident)\n \t{\n \t  warning_at (location, 0,\n \t\t      \"%<getter%> attribute of property %qD conflicts with \"\n@@ -1112,7 +1175,7 @@ objc_add_property_declaration (location_t location, tree decl,\n       /* We can only compare the setter names if both the old and new property have a setter.  */\n       if (!property_readonly  &&  !PROPERTY_READONLY(x))\n \t{\n-\t  if (PROPERTY_SETTER_NAME (x) != parsed_property_setter_ident)\n+\t  if (PROPERTY_SETTER_NAME (x) != property_setter_ident)\n \t    {\n \t      warning_at (location, 0,\n \t\t\t  \"%<setter%> attribute of property %qD conflicts with \"\n@@ -1190,13 +1253,13 @@ objc_add_property_declaration (location_t location, tree decl,\n       if (property_extension_in_class_extension)\n \t{\n \t  PROPERTY_READONLY (x) = 0;\n-\t  PROPERTY_SETTER_NAME (x) = parsed_property_setter_ident;\n+\t  PROPERTY_SETTER_NAME (x) = property_setter_ident;\n \t  return;\n \t}\n     }\n \n   /* Create a PROPERTY_DECL node.  */\n-  property_decl = make_node (PROPERTY_DECL);\n+  tree property_decl = make_node (PROPERTY_DECL);\n \n   /* Copy the basic information from the original decl.  */\n   TREE_TYPE (property_decl) = TREE_TYPE (decl);\n@@ -1205,10 +1268,10 @@ objc_add_property_declaration (location_t location, tree decl,\n \n   /* Add property-specific information.  */\n   PROPERTY_NAME (property_decl) = DECL_NAME (decl);\n-  PROPERTY_GETTER_NAME (property_decl) = parsed_property_getter_ident;\n-  PROPERTY_SETTER_NAME (property_decl) = parsed_property_setter_ident;\n+  PROPERTY_GETTER_NAME (property_decl) = property_getter_ident;\n+  PROPERTY_SETTER_NAME (property_decl) = property_setter_ident;\n   PROPERTY_READONLY (property_decl) = property_readonly;\n-  PROPERTY_NONATOMIC (property_decl) = parsed_property_nonatomic;\n+  PROPERTY_NONATOMIC (property_decl) = property_nonatomic;\n   PROPERTY_ASSIGN_SEMANTICS (property_decl) = property_assign_semantics;\n   PROPERTY_IVAR_NAME (property_decl) = NULL_TREE;\n   PROPERTY_DYNAMIC (property_decl) = 0;"}, {"sha": "332582384a383b495ced7bf221df08105e04276f", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-1.mm", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-1.mm?ref=9a34a5cce6b50fc3527e7c7ab356808ed435883c", "patch": "@@ -6,14 +6,18 @@ @interface MyRootClass\n {\n   Class isa;\n }\n-@property;                      /* { dg-error \"expected identifier\" } */\n+@property;                      /* { dg-error \"expected\" } */\n @property int;                  /* { dg-error \"expected identifier\" } */\n+\n @property int a;\n @property int b, c;\n-@property () int d;             /* { dg-error \"expected identifier\" } */\n+@property () int d;             /* { dg-warning \"empty property attribute list\" } */\n @property (readonly) int e;\n-@property (readonly,) int f;    /* { dg-error \"expected identifier\" } */\n+@property (readonly,) int f;    /* { dg-warning \"missing property attribute\" } */\n @property (xxx) int g;          /* { dg-error \"unknown property attribute\" } */\n @property (readonly,xxx) int h; /* { dg-error \"unknown property attribute\" } */\n-@property ( int i;              /* { dg-error \"expected identifier\" } */\n+@property ( int i;              /* { dg-error \"unknown property attribute\" } */\n+\t\t\t\t/* { dg-error \"expected\" \"\" { target *-*-* } .-1 } */\n+@property (assign,,nonatomic) int j; /* { dg-warning \"missing property attribute\" } */\n+@property (assign nonatomic) int k; /* { dg-error {expected } } */\n @end"}, {"sha": "64dfe83cd5957097ca407ed5bddd48a229239fd8", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-29.mm", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-29.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-29.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-29.mm?ref=9a34a5cce6b50fc3527e7c7ab356808ed435883c", "patch": "@@ -8,7 +8,9 @@ @interface MyRootClass\n   Class isa;\n }\n /* Test missing '=' in setter/getter attributes.  */\n-@property (getter)  int property_a; /* { dg-error \"missing .=. .after .getter. attribute.\" } */\n-@property (setter) int property_b;  /* { dg-error \"missing .=. .after .setter. attribute.\" } */\n-@property (assign, getter) int property_c; /* { dg-error \"missing .=. .after .getter. attribute.\" } */\n+@property (getter)  int property_a; /* { dg-error {expected '=' after Objective-C 'getter'} } */\n+@property (setter) int property_b;  /* { dg-error {expected '=' after Objective-C 'setter'} } */\n+@property (assign, getter) int property_c; /* { dg-error {expected '=' after Objective-C 'getter'} } */\n+@property (retain, getter=) id x; /* { dg-error {expected 'getter' selector name} } */\n+@property (retain, setter=) id y; /* { dg-error {expected 'setter' selector name} } */\n @end"}, {"sha": "4083947de71d3cab5e7d43a3fd54e0aaf5b9e612", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-4.mm", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-4.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-4.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-4.mm?ref=9a34a5cce6b50fc3527e7c7ab356808ed435883c", "patch": "@@ -27,14 +27,14 @@ - (void) mySetter2: (int)property;\n \n /* Now test various problems.  */\n \n-@property (readonly, readwrite) int a;    /* { dg-error \".readonly. attribute conflicts with .readwrite. attribute\" } */\n+@property (readonly, readwrite) int a;    /* { dg-error \".readwrite. attribute conflicts with .readonly. attribute\" } */\n @property (readonly, setter=mySetterB:) int b; /* { dg-error \".readonly. attribute conflicts with .setter. attribute\" } */\n \n-@property (assign, retain) id c;          /* { dg-error \".assign. attribute conflicts with .retain. attribute\" } */\n-@property (assign, copy) id d;            /* { dg-error \".assign. attribute conflicts with .copy. attribute\" } */\n+@property (assign, retain) id c;          /* { dg-error \".retain. attribute conflicts with .assign. attribute\" } */\n+@property (assign, copy) id d;            /* { dg-error \".copy. attribute conflicts with .assign. attribute\" } */\n @property (copy, retain) id e;            /* { dg-error \".retain. attribute conflicts with .copy. attribute\" } */\n \n-@property (setter=mySetter:,setter=mySetter2:)  int f; /* { dg-error \".setter. attribute may only be specified once\" } */\n-@property (getter=myGetter, getter=myGetter2 )  int g; /* { dg-error \".getter. attribute may only be specified once\" } */\n+@property (setter=mySetter:,setter=mySetter2:)  int f; /* { dg-warning {multiple property 'setter' methods specified, the latest one will be used} } */\n+@property (getter=myGetter, getter=myGetter2 )  int g; /* { dg-warning {multiple property 'getter' methods specified, the latest one will be used} } */\n \n @end"}, {"sha": "794f2bd0e965f789092fecd958bebc1608c714d2", "filename": "gcc/testsuite/obj-c++.dg/property/property-neg-2.mm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-2.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-2.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-2.mm?ref=9a34a5cce6b50fc3527e7c7ab356808ed435883c", "patch": "@@ -4,5 +4,5 @@ @interface Bar\n @end\n \n @implementation Bar\n-@property int FooBar; /* { dg-error \"property declaration not in @interface or @protocol context\" } */\n+@property int FooBar; /* { dg-error {property declaration not in '@interface', '@protocol' or 'category' context} } */\n @end"}, {"sha": "6dba8f4b84a2f9d141f04a5678f53d5e7ecafa9d", "filename": "gcc/testsuite/objc.dg/property/at-property-1.m", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-1.m?ref=9a34a5cce6b50fc3527e7c7ab356808ed435883c", "patch": "@@ -11,11 +11,15 @@ @interface MyRootClass\n                                 /* { dg-warning \"declaration does not declare anything\" \"\" { target *-*-* } .-1 } */\n @property int a;\n @property int b, c;\n-@property () int d;             /* { dg-error \"expected identifier\" } */\n+@property () int d;             /* { dg-warning \"empty property attribute list\" } */\n @property (readonly) int e;\n-@property (readonly,) int f;    /* { dg-error \"expected identifier\" } */\n+@property (readonly,) int f;    /* { dg-warning \"missing property attribute\" } */\n @property (xxx) int g;          /* { dg-error \"unknown property attribute\" } */\n @property (readonly,xxx) int h; /* { dg-error \"unknown property attribute\" } */\n @property ( int i;              /* { dg-error \"unknown property attribute\" } */\n-/* Because the last syntax error opens a '(' and never closes it, we get to the end of input.  */\n-@end                            /* { dg-error \"expected ..end. at end of input\" } */\n+\t\t\t\t/* { dg-error \"expected\" \"\" { target *-*-* } .-1 } */\n+@property (assign,,nonatomic) int j; /* { dg-warning \"missing property attribute\" } */\n+@property (assign nonatomic) int k; /* { dg-error {expected } } */\n+@property (assign) int l[4]; /* { dg-error {property cannot be an array} } */\n+@property (assign) int : 5; /* { dg-error {properties must be named} } */\n+@end"}, {"sha": "0b34e1cf67199b516dfbf6a1cfa0dac9ca779b90", "filename": "gcc/testsuite/objc.dg/property/at-property-29.m", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-29.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-29.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-29.m?ref=9a34a5cce6b50fc3527e7c7ab356808ed435883c", "patch": "@@ -8,7 +8,8 @@ @interface MyRootClass\n   Class isa;\n }\n /* Test missing '=' in setter/getter attributes.  */\n-@property (getter)  int property_a; /* { dg-error \"missing .=. .after .getter. attribute.\" } */\n-@property (setter) int property_b;  /* { dg-error \"missing .=. .after .setter. attribute.\" } */\n-@property (assign, getter) int property_c; /* { dg-error \"missing .=. .after .getter. attribute.\" } */\n+@property (getter)  int property_a; /* { dg-error {expected '=' after Objective-C 'getter'} } */\n+@property (setter) int property_b;  /* { dg-error {expected '=' after Objective-C 'setter'} } */\n+@property (assign, getter) int property_c; /* { dg-error {expected '=' after Objective-C 'getter'} } */\n+@property (retain, getter=) id x; /* { dg-error {expected 'getter' selector name} } */\n @end"}, {"sha": "4083947de71d3cab5e7d43a3fd54e0aaf5b9e612", "filename": "gcc/testsuite/objc.dg/property/at-property-4.m", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-4.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-4.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-4.m?ref=9a34a5cce6b50fc3527e7c7ab356808ed435883c", "patch": "@@ -27,14 +27,14 @@ - (void) mySetter2: (int)property;\n \n /* Now test various problems.  */\n \n-@property (readonly, readwrite) int a;    /* { dg-error \".readonly. attribute conflicts with .readwrite. attribute\" } */\n+@property (readonly, readwrite) int a;    /* { dg-error \".readwrite. attribute conflicts with .readonly. attribute\" } */\n @property (readonly, setter=mySetterB:) int b; /* { dg-error \".readonly. attribute conflicts with .setter. attribute\" } */\n \n-@property (assign, retain) id c;          /* { dg-error \".assign. attribute conflicts with .retain. attribute\" } */\n-@property (assign, copy) id d;            /* { dg-error \".assign. attribute conflicts with .copy. attribute\" } */\n+@property (assign, retain) id c;          /* { dg-error \".retain. attribute conflicts with .assign. attribute\" } */\n+@property (assign, copy) id d;            /* { dg-error \".copy. attribute conflicts with .assign. attribute\" } */\n @property (copy, retain) id e;            /* { dg-error \".retain. attribute conflicts with .copy. attribute\" } */\n \n-@property (setter=mySetter:,setter=mySetter2:)  int f; /* { dg-error \".setter. attribute may only be specified once\" } */\n-@property (getter=myGetter, getter=myGetter2 )  int g; /* { dg-error \".getter. attribute may only be specified once\" } */\n+@property (setter=mySetter:,setter=mySetter2:)  int f; /* { dg-warning {multiple property 'setter' methods specified, the latest one will be used} } */\n+@property (getter=myGetter, getter=myGetter2 )  int g; /* { dg-warning {multiple property 'getter' methods specified, the latest one will be used} } */\n \n @end"}, {"sha": "820f5b3101cb9e881af8f2ecb3486a56ec22a83a", "filename": "gcc/testsuite/objc.dg/property/at-property-5.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-5.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-5.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-5.m?ref=9a34a5cce6b50fc3527e7c7ab356808ed435883c", "patch": "@@ -31,4 +31,4 @@ @interface MyRootClass\n    \t\t\t          /* { dg-message \"originally specified here\" \"\" { target *-*-* } property_e_first } */\n @end\n \n-@property id test; /* { dg-error \"property declaration not in .interface or .protocol context\" } */\n+@property id test; /* { dg-error {property declaration not in '@interface', '@protocol' or 'category' context} } */"}, {"sha": "794f2bd0e965f789092fecd958bebc1608c714d2", "filename": "gcc/testsuite/objc.dg/property/property-neg-2.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a34a5cce6b50fc3527e7c7ab356808ed435883c/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-2.m?ref=9a34a5cce6b50fc3527e7c7ab356808ed435883c", "patch": "@@ -4,5 +4,5 @@ @interface Bar\n @end\n \n @implementation Bar\n-@property int FooBar; /* { dg-error \"property declaration not in @interface or @protocol context\" } */\n+@property int FooBar; /* { dg-error {property declaration not in '@interface', '@protocol' or 'category' context} } */\n @end"}]}