{"sha": "ca0d06ac97251505aecc4a6c34938ace11faab7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EwZDA2YWM5NzI1MTUwNWFlY2M0YTZjMzQ5MzhhY2UxMWZhYWI3ZQ==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jblomqvi@cc.hut.fi", "date": "2005-09-10T16:31:28Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2005-09-10T16:31:28Z"}, "message": "unix.c: Remove mmap code.\n\n2005-09-10  Janne Blomqvist  <jblomqvi@cc.hut.fi>\n\n\t* io/unix.c: Remove mmap code.\n\nFrom-SVN: r104127", "tree": {"sha": "6acaeb62e4d84ee2cef0babb7ef834d8ed2f6386", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6acaeb62e4d84ee2cef0babb7ef834d8ed2f6386"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca0d06ac97251505aecc4a6c34938ace11faab7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca0d06ac97251505aecc4a6c34938ace11faab7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca0d06ac97251505aecc4a6c34938ace11faab7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca0d06ac97251505aecc4a6c34938ace11faab7e/comments", "author": null, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "225d3396bf31d99723e14e4e767ce0d6cb22ae1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/225d3396bf31d99723e14e4e767ce0d6cb22ae1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/225d3396bf31d99723e14e4e767ce0d6cb22ae1d"}], "stats": {"total": 219, "additions": 10, "deletions": 209}, "files": [{"sha": "5dd311ad589035c8cfac3a9711f1dce0fd417501", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0d06ac97251505aecc4a6c34938ace11faab7e/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0d06ac97251505aecc4a6c34938ace11faab7e/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=ca0d06ac97251505aecc4a6c34938ace11faab7e", "patch": "@@ -1,3 +1,7 @@\n+2005-09-10  Janne Blomqvist  <jblomqvi@cc.hut.fi>\n+\n+\t* io/unix.c: Remove mmap code.\n+\n 2005-09-09  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR libfortran/23784"}, {"sha": "1a4beddfc06734e81c8d2d86d0fa7dacf83731ff", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 6, "deletions": 209, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0d06ac97251505aecc4a6c34938ace11faab7e/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0d06ac97251505aecc4a6c34938ace11faab7e/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=ca0d06ac97251505aecc4a6c34938ace11faab7e", "patch": "@@ -140,7 +140,7 @@ typedef struct\n \n   int special_file;\t\t/* =1 if the fd refers to a special file */\n \n-  unsigned unbuffered:1, mmaped:1;\n+  unsigned unbuffered:1;\n \n   char small_buffer[BUFFER_SIZE];\n \n@@ -371,7 +371,6 @@ fd_alloc (unix_stream * s, gfc_offset where,\n \n   s->buffer = new_buffer;\n   s->len = read_len;\n-  s->mmaped = 0;\n }\n \n \n@@ -570,201 +569,6 @@ fd_open (unix_stream * s)\n }\n \n \n-/*********************************************************************\n-    mmap stream functions\n-\n- Because mmap() is not capable of extending a file, we have to keep\n- track of how long the file is.  We also have to be able to detect end\n- of file conditions.  If there are multiple writers to the file (which\n- can only happen outside the current program), things will get\n- confused.  Then again, things will get confused anyway.\n-\n-*********************************************************************/\n-\n-#if HAVE_MMAP\n-\n-static int page_size, page_mask;\n-\n-/* mmap_flush()-- Deletes a memory mapping if something is mapped. */\n-\n-static try\n-mmap_flush (unix_stream * s)\n-{\n-  if (!s->mmaped)\n-    return fd_flush (s);\n-\n-  if (s->buffer == NULL)\n-    return SUCCESS;\n-\n-  if (munmap (s->buffer, s->active))\n-    return FAILURE;\n-\n-  s->buffer = NULL;\n-  s->active = 0;\n-\n-  return SUCCESS;\n-}\n-\n-\n-/* mmap_alloc()-- mmap() a section of the file.  The whole section is\n- * guaranteed to be mappable. */\n-\n-static try\n-mmap_alloc (unix_stream * s, gfc_offset where,\n-\t    int *len __attribute__ ((unused)))\n-{\n-  gfc_offset offset;\n-  int length;\n-  char *p;\n-\n-  if (mmap_flush (s) == FAILURE)\n-    return FAILURE;\n-\n-  offset = where & page_mask;\t/* Round down to the next page */\n-\n-  length = ((where - offset) & page_mask) + 2 * page_size;\n-\n-  p = mmap (NULL, length, s->prot, MAP_SHARED, s->fd, offset);\n-  if (p == (char *) MAP_FAILED)\n-    return FAILURE;\n-\n-  s->mmaped = 1;\n-  s->buffer = p;\n-  s->buffer_offset = offset;\n-  s->active = length;\n-\n-  return SUCCESS;\n-}\n-\n-\n-static char *\n-mmap_alloc_r_at (unix_stream * s, int *len, gfc_offset where)\n-{\n-  gfc_offset m;\n-\n-  if (where == -1)\n-    where = s->logical_offset;\n-\n-  m = where + *len;\n-\n-  if ((s->buffer == NULL || s->buffer_offset > where ||\n-       m > s->buffer_offset + s->active) &&\n-      mmap_alloc (s, where, len) == FAILURE)\n-    return NULL;\n-\n-  if (m > s->file_length)\n-    {\n-      *len = s->file_length - s->logical_offset;\n-      s->logical_offset = s->file_length;\n-    }\n-  else\n-    s->logical_offset = m;\n-\n-  return s->buffer + (where - s->buffer_offset);\n-}\n-\n-\n-static char *\n-mmap_alloc_w_at (unix_stream * s, int *len, gfc_offset where)\n-{\n-  if (where == -1)\n-    where = s->logical_offset;\n-\n-  /* If we're extending the file, we have to use file descriptor\n-   * methods. */\n-\n-  if (where + *len > s->file_length)\n-    {\n-      if (s->mmaped)\n-\tmmap_flush (s);\n-      return fd_alloc_w_at (s, len, where);\n-    }\n-\n-  if ((s->buffer == NULL || s->buffer_offset > where ||\n-       where + *len > s->buffer_offset + s->active ||\n-       where < s->buffer_offset + s->active) &&\n-      mmap_alloc (s, where, len) == FAILURE)\n-    return NULL;\n-\n-  s->logical_offset = where + *len;\n-\n-  return s->buffer + where - s->buffer_offset;\n-}\n-\n-\n-static int\n-mmap_seek (unix_stream * s, gfc_offset offset)\n-{\n-  s->logical_offset = offset;\n-  return SUCCESS;\n-}\n-\n-\n-static try\n-mmap_close (unix_stream * s)\n-{\n-  try t;\n-\n-  t = mmap_flush (s);\n-\n-  if (close (s->fd) < 0)\n-    t = FAILURE;\n-  free_mem (s);\n-\n-  return t;\n-}\n-\n-\n-static try\n-mmap_sfree (unix_stream * s __attribute__ ((unused)))\n-{\n-  return SUCCESS;\n-}\n-\n-\n-/* mmap_open()-- mmap_specific open.  If the particular file cannot be\n- * mmap()-ed, we fall back to the file descriptor functions. */\n-\n-static try\n-mmap_open (unix_stream * s __attribute__ ((unused)))\n-{\n-  char *p;\n-  int i;\n-\n-  page_size = getpagesize ();\n-  page_mask = ~0;\n-\n-  p = mmap (0, page_size, s->prot, MAP_SHARED, s->fd, 0);\n-  if (p == (char *) MAP_FAILED)\n-    {\n-      fd_open (s);\n-      return SUCCESS;\n-    }\n-\n-  munmap (p, page_size);\n-\n-  i = page_size >> 1;\n-  while (i != 0)\n-    {\n-      page_mask <<= 1;\n-      i >>= 1;\n-    }\n-\n-  s->st.alloc_r_at = (void *) mmap_alloc_r_at;\n-  s->st.alloc_w_at = (void *) mmap_alloc_w_at;\n-  s->st.sfree = (void *) mmap_sfree;\n-  s->st.close = (void *) mmap_close;\n-  s->st.seek = (void *) mmap_seek;\n-  s->st.truncate = (void *) fd_truncate;\n-\n-  if (lseek (s->fd, s->file_length, SEEK_SET) < 0)\n-    return FAILURE;\n-\n-  return SUCCESS;\n-}\n-\n-#endif\n-\n \n /*********************************************************************\n   memory stream functions - These are used for internal files\n@@ -900,7 +704,7 @@ open_internal (char *base, int length)\n  * around it. */\n \n static stream *\n-fd_to_stream (int fd, int prot, int avoid_mmap)\n+fd_to_stream (int fd, int prot)\n {\n   struct stat statbuf;\n   unix_stream *s;\n@@ -920,14 +724,7 @@ fd_to_stream (int fd, int prot, int avoid_mmap)\n   s->file_length = S_ISREG (statbuf.st_mode) ? statbuf.st_size : -1;\n   s->special_file = !S_ISREG (statbuf.st_mode);\n \n-#if HAVE_MMAP\n-  if (avoid_mmap)\n-    fd_open (s);\n-  else\n-    mmap_open (s);\n-#else\n   fd_open (s);\n-#endif\n \n   return (stream *) s;\n }\n@@ -1180,7 +977,7 @@ open_external (unit_flags *flags)\n       internal_error (\"open_external(): Bad action\");\n     }\n \n-  return fd_to_stream (fd, prot, 0);\n+  return fd_to_stream (fd, prot);\n }\n \n \n@@ -1190,7 +987,7 @@ open_external (unit_flags *flags)\n stream *\n input_stream (void)\n {\n-  return fd_to_stream (STDIN_FILENO, PROT_READ, 1);\n+  return fd_to_stream (STDIN_FILENO, PROT_READ);\n }\n \n \n@@ -1200,7 +997,7 @@ input_stream (void)\n stream *\n output_stream (void)\n {\n-  return fd_to_stream (STDOUT_FILENO, PROT_WRITE, 1);\n+  return fd_to_stream (STDOUT_FILENO, PROT_WRITE);\n }\n \n \n@@ -1210,7 +1007,7 @@ output_stream (void)\n stream *\n error_stream (void)\n {\n-  return fd_to_stream (STDERR_FILENO, PROT_WRITE, 1);\n+  return fd_to_stream (STDERR_FILENO, PROT_WRITE);\n }\n \n /* init_error_stream()-- Return a pointer to the error stream.  This"}]}