{"sha": "23fca1f58766f4095fb3f889433de3f5552681f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNmY2ExZjU4NzY2ZjQwOTVmYjNmODg5NDMzZGUzZjU1NTI2ODFmMQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2006-02-07T23:25:02Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2006-02-07T23:25:02Z"}, "message": "cp-tree.h (tf_warning_or_error): Renamed from tf_warn_or_error.\n\n        * cp-tree.h (tf_warning_or_error): Renamed from\n          tf_warn_or_error.\n        (cp_build_qualified_type): Propogate renaming.\n        * call.c (convert_like_real): Likewise.\n        * cvt.c (cp_convert_to_pointer, convert_to_reference):\n          Likewise.\n        * decl.c (make_typename_type, grokdeclarator): Likewise.\n        * pt.c (tsubst_friend_function, instantiate_class_template,\n        tsubst_default_argument, instantiate_decl,\n        tsubst_initializer_list, tsubst_enum): Likewise.\n        * semantics.c (finish_template_type): Likewise.\n        * typeck.c (build_ptrmemfunc, convert_for_assignment):\n          Likewise.\n\nFrom-SVN: r110727", "tree": {"sha": "b0dfe1bf3ad18a5e2d4648542568ec2fadf9591a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0dfe1bf3ad18a5e2d4648542568ec2fadf9591a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23fca1f58766f4095fb3f889433de3f5552681f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23fca1f58766f4095fb3f889433de3f5552681f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23fca1f58766f4095fb3f889433de3f5552681f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23fca1f58766f4095fb3f889433de3f5552681f1/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6defecc2d32860e29a9de5033fc3810ed64857ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6defecc2d32860e29a9de5033fc3810ed64857ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6defecc2d32860e29a9de5033fc3810ed64857ae"}], "stats": {"total": 71, "additions": 42, "deletions": 29}, "files": [{"sha": "e9040ee75a94f964b7ef2a86e71b39a64ebe588c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23fca1f58766f4095fb3f889433de3f5552681f1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23fca1f58766f4095fb3f889433de3f5552681f1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=23fca1f58766f4095fb3f889433de3f5552681f1", "patch": "@@ -1,3 +1,16 @@\n+2006-02-07  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* cp-tree.h (tf_warning_or_error): Renamed from tf_warn_or_error.\n+\t(cp_build_qualified_type): Propogate renaming.\n+\t* call.c (convert_like_real): Likewise.\n+\t* cvt.c (cp_convert_to_pointer, convert_to_reference): Likewise.\n+\t* decl.c (make_typename_type, grokdeclarator): Likewise.\n+\t* pt.c (tsubst_friend_function, instantiate_class_template,\n+\ttsubst_default_argument, instantiate_decl,\n+\ttsubst_initializer_list, tsubst_enum): Likewise.\n+\t* semantics.c (finish_template_type): Likewise.\n+\t* typeck.c (build_ptrmemfunc, convert_for_assignment): Likewise.\n+\n 2006-02-07  Dirk Mueller  <dmueller@suse.com>\n \n \t* typeck.c (build_binary_op): Annotate div-by-zero"}, {"sha": "01c51f21f5ed48182fef29c4a8a3f462eff9845e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23fca1f58766f4095fb3f889433de3f5552681f1/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23fca1f58766f4095fb3f889433de3f5552681f1/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=23fca1f58766f4095fb3f889433de3f5552681f1", "patch": "@@ -4279,7 +4279,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n       }\n     case ck_identity:\n       if (type_unknown_p (expr))\n-\texpr = instantiate_type (totype, expr, tf_warn_or_error);\n+\texpr = instantiate_type (totype, expr, tf_warning_or_error);\n       /* Convert a constant to its underlying value, unless we are\n \t about to bind it to a reference, in which case we need to\n \t leave it as an lvalue.  */"}, {"sha": "dfeb4122db2ddf60e6cebb219b6a3cb0f1d378dc", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23fca1f58766f4095fb3f889433de3f5552681f1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23fca1f58766f4095fb3f889433de3f5552681f1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=23fca1f58766f4095fb3f889433de3f5552681f1", "patch": "@@ -3111,7 +3111,7 @@ typedef enum tsubst_flags_t {\n \t\t\t\t   not actually performing the\n \t\t\t\t   conversion.  */\n   /* Convenient substitution flags combinations.  */\n-  tf_warn_or_error = tf_warning | tf_error\n+  tf_warning_or_error = tf_warning | tf_error\n } tsubst_flags_t;\n \n /* The kind of checking we can do looking in a class hierarchy.  */\n@@ -4274,7 +4274,7 @@ extern tree make_ptrmem_cst\t\t\t(tree, tree);\n extern tree cp_build_type_attribute_variant     (tree, tree);\n extern tree cp_build_qualified_type_real\t(tree, int, tsubst_flags_t);\n #define cp_build_qualified_type(TYPE, QUALS) \\\n-  cp_build_qualified_type_real ((TYPE), (QUALS), tf_warn_or_error)\n+  cp_build_qualified_type_real ((TYPE), (QUALS), tf_warning_or_error)\n extern special_function_kind special_function_p (tree);\n extern int count_trees\t\t\t\t(tree);\n extern int char_type_p\t\t\t\t(tree);"}, {"sha": "4dd1e1047aec00ab2f2ed3052b89d65b83dc65d3", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23fca1f58766f4095fb3f889433de3f5552681f1/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23fca1f58766f4095fb3f889433de3f5552681f1/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=23fca1f58766f4095fb3f889433de3f5552681f1", "patch": "@@ -280,7 +280,7 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n     }\n \n   if (type_unknown_p (expr))\n-    return instantiate_type (type, expr, tf_warn_or_error);\n+    return instantiate_type (type, expr, tf_warning_or_error);\n \n   error (\"cannot convert %qE from type %qT to type %qT\",\n \t expr, intype, type);\n@@ -451,7 +451,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n       && TREE_TYPE (expr) == unknown_type_node)\n     expr = instantiate_type (type, expr,\n \t\t\t     (flags & LOOKUP_COMPLAIN)\n-\t\t\t     ? tf_warn_or_error : tf_none);\n+\t\t\t     ? tf_warning_or_error : tf_none);\n \n   if (expr == error_mark_node)\n     return error_mark_node;"}, {"sha": "2b8207353900b19d98506747be6a4410f1d1bfa4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23fca1f58766f4095fb3f889433de3f5552681f1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23fca1f58766f4095fb3f889433de3f5552681f1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=23fca1f58766f4095fb3f889433de3f5552681f1", "patch": "@@ -2672,7 +2672,7 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n \t\t\t\t\tTREE_OPERAND (fullname, 1),\n \t\t\t\t\tNULL_TREE, context,\n \t\t\t\t\t/*entering_scope=*/0,\n-\t\t\t\t\ttf_warn_or_error | tf_user);\n+\t\t\t\t\ttf_warning_or_error | tf_user);\n \t}\n       else\n \t{\n@@ -7112,7 +7112,7 @@ grokdeclarator (const cp_declarator *declarator,\n   type_quals |= cp_type_quals (type);\n   type = cp_build_qualified_type_real\n     (type, type_quals, ((typedef_decl && !DECL_ARTIFICIAL (typedef_decl)\n-\t\t\t ? tf_ignore_bad_quals : 0) | tf_warn_or_error));\n+\t\t\t ? tf_ignore_bad_quals : 0) | tf_warning_or_error));\n   /* We might have ignored or rejected some of the qualifiers.  */\n   type_quals = cp_type_quals (type);\n "}, {"sha": "bf6923f3ae1c0293b63e7bef121dd2944866aed3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23fca1f58766f4095fb3f889433de3f5552681f1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23fca1f58766f4095fb3f889433de3f5552681f1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=23fca1f58766f4095fb3f889433de3f5552681f1", "patch": "@@ -5152,21 +5152,21 @@ tsubst_friend_function (tree decl, tree args)\n \t current cless with same name.  */\n       push_nested_namespace (ns);\n       fns = tsubst_expr (DECL_TI_TEMPLATE (decl), args,\n-\t\t\t tf_warn_or_error, NULL_TREE);\n+\t\t\t tf_warning_or_error, NULL_TREE);\n       pop_nested_namespace (ns);\n       arglist = tsubst (DECL_TI_ARGS (decl), args,\n-\t\t\ttf_warn_or_error, NULL_TREE);\n+\t\t\ttf_warning_or_error, NULL_TREE);\n       template_id = lookup_template_function (fns, arglist);\n \n-      new_friend = tsubst (decl, args, tf_warn_or_error, NULL_TREE);\n+      new_friend = tsubst (decl, args, tf_warning_or_error, NULL_TREE);\n       tmpl = determine_specialization (template_id, new_friend,\n \t\t\t\t       &new_args,\n \t\t\t\t       /*need_member_template=*/0,\n \t\t\t\t       TREE_VEC_LENGTH (args));\n       return instantiate_template (tmpl, new_args, tf_error);\n     }\n \n-  new_friend = tsubst (decl, args, tf_warn_or_error, NULL_TREE);\n+  new_friend = tsubst (decl, args, tf_warning_or_error, NULL_TREE);\n \n   /* The NEW_FRIEND will look like an instantiation, to the\n      compiler, but is not an instantiation from the point of view of\n@@ -5419,7 +5419,7 @@ tsubst_friend_class (tree friend_tmpl, tree args)\n \t{\n \t  tree parms;\n \t  parms = tsubst_template_parms (DECL_TEMPLATE_PARMS (friend_tmpl),\n-\t\t\t\t\t args, tf_warn_or_error);\n+\t\t\t\t\t args, tf_warning_or_error);\n \t  redeclare_class_template (TREE_TYPE (tmpl), parms);\n \t}\n \n@@ -5430,7 +5430,7 @@ tsubst_friend_class (tree friend_tmpl, tree args)\n       /* The friend template has not already been declared.  In this\n \t case, the instantiation of the template class will cause the\n \t injection of this template into the global scope.  */\n-      tmpl = tsubst (friend_tmpl, args, tf_warn_or_error, NULL_TREE);\n+      tmpl = tsubst (friend_tmpl, args, tf_warning_or_error, NULL_TREE);\n \n       /* The new TMPL is not an instantiation of anything, so we\n \t forget its origins.  We don't reset CLASSTYPE_TI_TEMPLATE for\n@@ -5722,7 +5722,7 @@ instantiate_class_template (tree type)\n \n \t\t  if (TREE_CODE (t) == TEMPLATE_DECL)\n \t\t    ++processing_template_decl;\n-\t\t  r = tsubst (t, args, tf_warn_or_error, NULL_TREE);\n+\t\t  r = tsubst (t, args, tf_warning_or_error, NULL_TREE);\n \t\t  if (TREE_CODE (t) == TEMPLATE_DECL)\n \t\t    --processing_template_decl;\n \t\t  if (TREE_CODE (r) == VAR_DECL)\n@@ -5796,7 +5796,7 @@ instantiate_class_template (tree type)\n \t\t{\n \t\t  /* template <class T> friend class C::D;  */\n \t\t  friend_type = tsubst (friend_type, args,\n-\t\t\t\t\ttf_warn_or_error, NULL_TREE);\n+\t\t\t\t\ttf_warning_or_error, NULL_TREE);\n \t\t  if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n \t\t    friend_type = TREE_TYPE (friend_type);\n \t\t  adjust_processing_template_decl = true;\n@@ -5813,7 +5813,7 @@ instantiate_class_template (tree type)\n \n \t\t     otherwise.  */\n \t\t  friend_type = tsubst (friend_type, args,\n-\t\t\t\t\ttf_warn_or_error, NULL_TREE);\n+\t\t\t\t\ttf_warning_or_error, NULL_TREE);\n \t\t  /* Bump processing_template_decl for correct\n \t\t     dependent_type_p calculation.  */\n \t\t  ++processing_template_decl;\n@@ -5842,7 +5842,7 @@ instantiate_class_template (tree type)\n \t      else if (uses_template_parms (friend_type))\n \t\t/* friend class C<T>;  */\n \t\tfriend_type = tsubst (friend_type, args,\n-\t\t\t\t      tf_warn_or_error, NULL_TREE);\n+\t\t\t\t      tf_warning_or_error, NULL_TREE);\n \t      /* Otherwise it's\n \n \t\t   friend class C;\n@@ -6151,7 +6151,7 @@ tsubst_default_argument (tree fn, tree type, tree arg)\n \n   push_deferring_access_checks(dk_no_deferred);\n   arg = tsubst_expr (arg, DECL_TI_ARGS (fn),\n-\t\t     tf_warn_or_error, NULL_TREE);\n+\t\t     tf_warning_or_error, NULL_TREE);\n   pop_deferring_access_checks();\n \n   /* Restore the \"this\" pointer.  */\n@@ -11635,16 +11635,16 @@ instantiate_decl (tree d, int defer_ok,\n \n       if (TREE_CODE (gen) == FUNCTION_DECL)\n \t{\n-\t  tsubst (DECL_ARGUMENTS (gen), gen_args, tf_warn_or_error, d);\n+\t  tsubst (DECL_ARGUMENTS (gen), gen_args, tf_warning_or_error, d);\n \t  tsubst (TYPE_RAISES_EXCEPTIONS (type), gen_args,\n-\t\t  tf_warn_or_error, d);\n+\t\t  tf_warning_or_error, d);\n \t  /* Don't simply tsubst the function type, as that will give\n \t     duplicate warnings about poor parameter qualifications.\n \t     The function arguments are the same as the decl_arguments\n \t     without the top level cv qualifiers.  */\n \t  type = TREE_TYPE (type);\n \t}\n-      tsubst (type, gen_args, tf_warn_or_error, d);\n+      tsubst (type, gen_args, tf_warning_or_error, d);\n \n       pop_access_scope (d);\n     }\n@@ -11690,7 +11690,7 @@ instantiate_decl (tree d, int defer_ok,\n \t  push_nested_class (DECL_CONTEXT (d));\n \t  init = tsubst_expr (DECL_INITIAL (code_pattern), \n \t\t\t      args,\n-\t\t\t      tf_warn_or_error, NULL_TREE);\n+\t\t\t      tf_warning_or_error, NULL_TREE);\n \t  DECL_INITIAL (d) = init;\n \t  cp_finish_decl (d, init, /*asmspec_tree=*/NULL_TREE,\n \t\t\t  LOOKUP_ONLYCONVERTING);\n@@ -11812,7 +11812,7 @@ instantiate_decl (tree d, int defer_ok,\n \n       /* Substitute into the body of the function.  */\n       tsubst_expr (DECL_SAVED_TREE (code_pattern), args,\n-\t\t   tf_warn_or_error, tmpl);\n+\t\t   tf_warning_or_error, tmpl);\n \n       /* We don't need the local specializations any more.  */\n       htab_delete (local_specializations);\n@@ -11959,13 +11959,13 @@ tsubst_initializer_list (tree t, tree argvec)\n       tree decl;\n       tree init;\n \n-      decl = tsubst_copy (TREE_PURPOSE (t), argvec, tf_warn_or_error,\n+      decl = tsubst_copy (TREE_PURPOSE (t), argvec, tf_warning_or_error,\n \t\t\t  NULL_TREE);\n       decl = expand_member_init (decl);\n       if (decl && !DECL_P (decl))\n \tin_base_initializer = 1;\n \n-      init = tsubst_expr (TREE_VALUE (t), argvec, tf_warn_or_error,\n+      init = tsubst_expr (TREE_VALUE (t), argvec, tf_warning_or_error,\n \t\t\t  NULL_TREE);\n       in_base_initializer = 0;\n \n@@ -12010,7 +12010,7 @@ tsubst_enum (tree tag, tree newtag, tree args)\n       /* Note that in a template enum, the TREE_VALUE is the\n \t CONST_DECL, not the corresponding INTEGER_CST.  */\n       value = tsubst_expr (DECL_INITIAL (decl),\n-\t\t\t   args, tf_warn_or_error, NULL_TREE);\n+\t\t\t   args, tf_warning_or_error, NULL_TREE);\n \n       /* Give this enumeration constant the correct access.  */\n       set_current_access_from_decl (decl);"}, {"sha": "89d41d66dac8b01fc748fd72cb5b5e5a4e5e46ae", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23fca1f58766f4095fb3f889433de3f5552681f1/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23fca1f58766f4095fb3f889433de3f5552681f1/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=23fca1f58766f4095fb3f889433de3f5552681f1", "patch": "@@ -2324,7 +2324,7 @@ finish_template_type (tree name, tree args, int entering_scope)\n \n   decl = lookup_template_class (name, args,\n \t\t\t\tNULL_TREE, NULL_TREE, entering_scope,\n-\t\t\t\ttf_warn_or_error | tf_user);\n+\t\t\t\ttf_warning_or_error | tf_user);\n   if (decl != error_mark_node)\n     decl = TYPE_STUB_DECL (decl);\n "}, {"sha": "e8dac530a6fc5bb19c7b36d60e83aae2685bd204", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23fca1f58766f4095fb3f889433de3f5552681f1/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23fca1f58766f4095fb3f889433de3f5552681f1/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=23fca1f58766f4095fb3f889433de3f5552681f1", "patch": "@@ -5878,7 +5878,7 @@ build_ptrmemfunc (tree type, tree pfn, int force, bool c_cast_p)\n     }\n \n   if (type_unknown_p (pfn))\n-    return instantiate_type (type, pfn, tf_warn_or_error);\n+    return instantiate_type (type, pfn, tf_warning_or_error);\n \n   fn = TREE_OPERAND (pfn, 0);\n   gcc_assert (TREE_CODE (fn) == FUNCTION_DECL\n@@ -6069,7 +6069,7 @@ convert_for_assignment (tree type, tree rhs,\n \t     overloaded function.  Call instantiate_type to get error\n \t     messages.  */\n \t  if (rhstype == unknown_type_node)\n-\t    instantiate_type (type, rhs, tf_warn_or_error);\n+\t    instantiate_type (type, rhs, tf_warning_or_error);\n \t  else if (fndecl)\n \t    error (\"cannot convert %qT to %qT for argument %qP to %qD\",\n \t\t   rhstype, type, parmnum, fndecl);"}]}