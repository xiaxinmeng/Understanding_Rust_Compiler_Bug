{"sha": "1ceb5ff350b39174c1329415944bd1d9b3e25704", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNlYjVmZjM1MGIzOTE3NGMxMzI5NDE1OTQ0YmQxZDliM2UyNTcwNA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-07-24T00:45:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-07-24T00:45:51Z"}, "message": "lex.c: Sync with C frontend.\n\n\t* lex.c: Sync with C frontend.\n\t(whitespace_cr): New fn.\n\t(skip_white_space): Use it.\n\t(init_parse): Reorder.\n\t(yyprint): Support CONSTANT.\n\t(pragma_getc, pragma_ungetc): Bring back.\n\t(read_line_number): Change in_system_header directly.\n\t(handle_generic_pragma, handle_cp_pragma, yyerror): Move up in file.\n\t(parse_float): Update to C version.\n\t(yylex): Handle '$' under the letter case.\n\tRemove looking_for_typename handling.\n\tSupport hex floating point constants.\n\tFollow C's lead for choosing type of integer constants.\n\tRearrange stuff to match C frontend.\n\t(yyungetc, reinit_parse_for_block, yylex): Support indent_level.\n\t* spew.c (yylex): Clear looking_for_typename if we see a TYPESPEC.\n\nFrom-SVN: r28230", "tree": {"sha": "b5654b6d150bb960f9b0d4773426d5a71d71907b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5654b6d150bb960f9b0d4773426d5a71d71907b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ceb5ff350b39174c1329415944bd1d9b3e25704", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ceb5ff350b39174c1329415944bd1d9b3e25704", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ceb5ff350b39174c1329415944bd1d9b3e25704", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ceb5ff350b39174c1329415944bd1d9b3e25704/comments", "author": null, "committer": null, "parents": [{"sha": "b0385db881d09789d60be06a6bb78246fba4463a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0385db881d09789d60be06a6bb78246fba4463a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0385db881d09789d60be06a6bb78246fba4463a"}], "stats": {"total": 1141, "additions": 634, "deletions": 507}, "files": [{"sha": "fdbec6605ba0dbcd837c34dc990756b597903da9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ceb5ff350b39174c1329415944bd1d9b3e25704/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ceb5ff350b39174c1329415944bd1d9b3e25704/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1ceb5ff350b39174c1329415944bd1d9b3e25704", "patch": "@@ -1,3 +1,22 @@\n+1999-07-23  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* lex.c: Sync with C frontend.\n+\t(whitespace_cr): New fn.\n+\t(skip_white_space): Use it.\n+\t(init_parse): Reorder.\n+\t(yyprint): Support CONSTANT.\n+\t(pragma_getc, pragma_ungetc): Bring back.\n+\t(read_line_number): Change in_system_header directly.\n+\t(handle_generic_pragma, handle_cp_pragma, yyerror): Move up in file.\n+\t(parse_float): Update to C version.\n+\t(yylex): Handle '$' under the letter case.\n+\tRemove looking_for_typename handling.\n+\tSupport hex floating point constants.\n+\tFollow C's lead for choosing type of integer constants.\n+\tRearrange stuff to match C frontend.\n+\t(yyungetc, reinit_parse_for_block, yylex): Support indent_level.\n+\t* spew.c (yylex): Clear looking_for_typename if we see a TYPESPEC.\n+\n 1999-07-23  Mark Mitchell  <mark@codesourcery.com>\n \n \t* call.c (reference_binding): Tweak."}, {"sha": "a2f2be54b6b7ac8497cc0baadb703a3d82c1f8de", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 612, "deletions": 507, "changes": 1119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ceb5ff350b39174c1329415944bd1d9b3e25704/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ceb5ff350b39174c1329415944bd1d9b3e25704/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=1ceb5ff350b39174c1329415944bd1d9b3e25704", "patch": "@@ -57,6 +57,7 @@ extern void yyprint PROTO((FILE *, int, YYSTYPE));\n \n static tree get_time_identifier PROTO((const char *));\n static int check_newline PROTO((void));\n+static int whitespace_cr\t\tPROTO((int));\n static int skip_white_space PROTO((int));\n static void finish_defarg PROTO((void));\n static int my_get_run_time PROTO((void));\n@@ -303,13 +304,13 @@ static int maxtoken;\t\t/* Current nominal length of token buffer.  */\n char *token_buffer;\t\t/* Pointer to token buffer.\n \t\t\t\t   Actual allocated length is maxtoken + 2.  */\n \n-static int indent_level = 0;\t/* Number of { minus number of }. */\n+static int indent_level;\t/* Number of { minus number of }. */\n \n #include \"hash.h\"\n \f\n \n /* Nonzero tells yylex to ignore \\ in string constants.  */\n-static int ignore_escape_flag = 0;\n+static int ignore_escape_flag;\n \n static tree\n get_time_identifier (name)\n@@ -481,18 +482,7 @@ init_parse (filename)\n   literal_codeset = getenv (\"LANG\");\n #endif\n \n-#if USE_CPPLIB\n-  parse_in.show_column = 1;\n-  if (! cpp_start_read (&parse_in, filename))\n-    abort ();\n-\n-  /* cpp_start_read always puts at least one line directive into the\n-     token buffer.  We must arrange to read it out here. */\n-  yy_cur = parse_in.token_buffer;\n-  yy_lim = CPP_PWRITTEN (&parse_in);\n-  cpp_token = CPP_DIRECTIVE;\n-\n-#else\n+#if !USE_CPPLIB\n   /* Open input file.  */\n   if (filename == 0 || !strcmp (filename, \"-\"))\n     {\n@@ -507,6 +497,20 @@ init_parse (filename)\n #ifdef IO_BUFFER_SIZE\n   setvbuf (finput, (char *) xmalloc (IO_BUFFER_SIZE), _IOFBF, IO_BUFFER_SIZE);\n #endif\n+#else /* !USE_CPPLIB */\n+  parse_in.show_column = 1;\n+  if (! cpp_start_read (&parse_in, filename))\n+    abort ();\n+\n+  if (filename == 0 || !strcmp (filename, \"-\"))\n+    filename = \"stdin\";\n+\n+  /* cpp_start_read always puts at least one line directive into the\n+     token buffer.  We must arrange to read it out here. */\n+  yy_cur = parse_in.token_buffer;\n+  yy_lim = CPP_PWRITTEN (&parse_in);\n+  cpp_token = CPP_DIRECTIVE;\n+\n #endif /* !USE_CPPLIB */\n \n   /* Initialize the lookahead machinery.  */\n@@ -686,8 +690,8 @@ init_parse (filename)\n   ridpointers[(int) RID_SIGNED] = get_identifier (\"signed\");\n   ridpointers[(int) RID_INLINE] = get_identifier (\"inline\");\n   ridpointers[(int) RID_CONST] = get_identifier (\"const\");\n-  ridpointers[(int) RID_VOLATILE] = get_identifier (\"volatile\");\n   ridpointers[(int) RID_RESTRICT] = get_identifier (\"__restrict\");\n+  ridpointers[(int) RID_VOLATILE] = get_identifier (\"volatile\");\n   ridpointers[(int) RID_AUTO] = get_identifier (\"auto\");\n   ridpointers[(int) RID_STATIC] = get_identifier (\"static\");\n   ridpointers[(int) RID_EXTERN] = get_identifier (\"extern\");\n@@ -921,6 +925,7 @@ yyprint (file, yychar, yylval)\n       if (IDENTIFIER_POINTER (t))\n \t  fprintf (file, \" `%s'\", IDENTIFIER_POINTER (t));\n       break;\n+\n     case AGGR:\n       if (yylval.ttype == class_type_node)\n \tfprintf (file, \" `class'\");\n@@ -935,6 +940,30 @@ yyprint (file, yychar, yylval)\n       else\n \tmy_friendly_abort (80);\n       break;\n+\n+    case CONSTANT:\n+      t = yylval.ttype;\n+      if (TREE_CODE (t) == INTEGER_CST)\n+\tfprintf (file,\n+#if HOST_BITS_PER_WIDE_INT == 64\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+\t\t \" 0x%x%016x\",\n+#else\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n+\t\t \" 0x%lx%016lx\",\n+#else\n+\t\t \" 0x%llx%016llx\",\n+#endif\n+#endif\n+#else\n+#if HOST_BITS_PER_WIDE_INT != HOST_BITS_PER_INT\n+\t\t \" 0x%lx%08lx\",\n+#else\n+\t\t \" 0x%x%08x\",\n+#endif\n+#endif\n+\t\t TREE_INT_CST_HIGH (t), TREE_INT_CST_LOW (t));\n+      break;\n     }\n }\n \n@@ -1435,6 +1464,13 @@ yyungetc (ch, rescan)\n   /* Unget a character from the input stream.  */\n   if (yychar == YYEMPTY || rescan == 0)\n     {\n+      /* If we're putting back a brace, undo the change in indent_level\n+\t from the first time we saw it.  */\n+      if (ch == '{')\n+\tindent_level--;\n+      else if (ch == '}')\n+\tindent_level++;\n+\n       put_back (ch);\n     }\n   else\n@@ -1530,7 +1566,11 @@ reinit_parse_for_block (pyychar, obstackp)\n   int look_for_lbrac = 0;\n \n   if (pyychar == '{')\n-    obstack_1grow (obstackp, '{');\n+    {\n+      obstack_1grow (obstackp, '{');\n+      /* We incremented indent_level in yylex; undo that.  */\n+      indent_level--;\n+    }\n   else if (pyychar == '=')\n     look_for_semicolon = 1;\n   else if (pyychar == ':')\n@@ -2117,6 +2157,29 @@ note_list_got_semicolon (declspecs)\n   clear_anon_tags ();\n }\n \f\n+/* Iff C is a carriage return, warn about it - if appropriate -\n+   and return nonzero.  */\n+static int\n+whitespace_cr (c)\n+     int c;\n+{\n+  static int newline_warning = 0;\n+\n+  if (c == '\\r')\n+    {\n+      /* ANSI C says the effects of a carriage return in a source file\n+\t are undefined.  */\n+      if (pedantic && !newline_warning)\n+\t{\n+\t  warning (\"carriage return in source file\");\n+\t  warning (\"(we only warn about the first carriage return)\");\n+\t  newline_warning = 1;\n+\t}\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n /* If C is not whitespace, return C.\n    Otherwise skip whitespace and return first nonwhite char read.  */\n \n@@ -2128,6 +2191,10 @@ skip_white_space (c)\n     {\n       switch (c)\n \t{\n+\t  /* We don't recognize comments here, because\n+\t     cpp output can include / and * consecutively as operators.\n+\t     Also, there's no need, since cpp removes all comments.  */\n+\n \tcase '\\n':\n \t  if (linemode)\n \t    {\n@@ -2140,7 +2207,6 @@ skip_white_space (c)\n \tcase ' ':\n \tcase '\\t':\n \tcase '\\f':\n-\tcase '\\r':\n \tcase '\\v':\n \tcase '\\b':\n #if USE_CPPLIB\n@@ -2153,6 +2219,11 @@ skip_white_space (c)\n \t    c = getch ();\n \t  break;\n \n+\tcase '\\r':\n+\t  whitespace_cr (c);\n+\t  c = getch ();\n+\t  break;\n+\n \tcase '\\\\':\n \t  c = getch ();\n \t  if (c == '\\n')\n@@ -2192,6 +2263,22 @@ extend_token_buffer (p)\n   return token_buffer + offset;\n }\n \f\n+#if defined HANDLE_PRAGMA\n+/* Local versions of these macros, that can be passed as function pointers.  */\n+static int\n+pragma_getc ()\n+{\n+  return getch ();\n+}\n+\n+static void\n+pragma_ungetc (arg)\n+     int arg;\n+{\n+  put_back (arg);\n+}\n+#endif\n+\n static int\n read_line_number (num)\n      int *num;\n@@ -2228,7 +2315,6 @@ check_newline ()\n   int saw_line;\n   enum { act_none, act_push, act_pop } action;\n   int old_lineno, action_number, l;\n-  int entering_system_header;\n   int entering_c_header;\n \n  restart:\n@@ -2288,24 +2374,22 @@ check_newline ()\n       if (!strcmp (name, \"pragma\"))\n \t{\n \t  token = real_yylex ();\n-\t  if (token == IDENTIFIER\n-\t      && TREE_CODE (yylval.ttype) == IDENTIFIER_NODE)\n-\t    {\n-\t      /* If this is 1, we handled it; if it's -1, it was one we\n-\t\t wanted but had something wrong with it.  Only if it's\n-\t\t 0 was it not handled.  */\n-\t      if (handle_cp_pragma (IDENTIFIER_POINTER (yylval.ttype)))\n-\t\tgoto skipline;\n-\t    }\n-\t  else if (token == END_OF_LINE)\n+\t  if (token != IDENTIFIER\n+\t      || TREE_CODE (yylval.ttype) != IDENTIFIER_NODE)\n+\t    goto skipline;\n+\t  \n+\t  /* If this is 1, we handled it; if it's -1, it was one we\n+\t     wanted but had something wrong with it.  Only if it's\n+\t     0 was it not handled.  */\n+\t  if (handle_cp_pragma (IDENTIFIER_POINTER (yylval.ttype)))\n \t    goto skipline;\n \n #ifdef HANDLE_PRAGMA\n \t  /* We invoke HANDLE_PRAGMA before HANDLE_GENERIC_PRAGMAS\n \t     (if both are defined), in order to give the back\n \t     end a chance to override the interpretation of\n \t     SYSV style pragmas.  */\n-\t  if (HANDLE_PRAGMA (getch, put_back,\n+\t  if (HANDLE_PRAGMA (pragma_getc, pragma_ungetc,\n \t\t\t     IDENTIFIER_POINTER (yylval.ttype)))\n \t    goto skipline;\n #endif /* HANDLE_PRAGMA */\n@@ -2466,12 +2550,15 @@ check_newline ()\n   extract_interface_info ();\n \n   old_lineno = lineno;\n-  entering_system_header = 0;\n-  entering_c_header = 0;\n   action = act_none;\n   action_number = 0;\n   lineno = l;\n \n+  /* Each change of file name\n+     reinitializes whether we are now in a system header.  */\n+  in_system_header = 0;\n+  entering_c_header = 0;\n+\n   if (!read_line_number (&action_number))\n     {\n       /* Update the name in the top element of input_file_stack.  */\n@@ -2495,7 +2582,7 @@ check_newline ()\n   if (action_number == 3)\n     {\n       /* `3' after file name means this is a system header file.  */\n-      entering_system_header = 1;\n+      in_system_header = 1;\n       read_line_number (&action_number);\n     }\n   if (action_number == 4)\n@@ -2510,17 +2597,15 @@ check_newline ()\n   if (action == act_push)\n     {\n       /* Pushing to a new file.  */\n-      struct file_stack *p;\n-\n-      p = (struct file_stack *) xmalloc (sizeof (struct file_stack));\n+      struct file_stack *p\n+\t= (struct file_stack *) xmalloc (sizeof (struct file_stack));\n       input_file_stack->line = old_lineno;\n       p->next = input_file_stack;\n       p->name = input_filename;\n       p->indent_level = indent_level;\n       input_file_stack = p;\n       input_file_stack_tick++;\n       debug_start_source_file (input_filename);\n-      in_system_header = entering_system_header;\n       if (c_header_level)\n \t++c_header_level;\n       else if (entering_c_header)\n@@ -2534,17 +2619,15 @@ check_newline ()\n       /* Popping out of a file.  */\n       if (input_file_stack->next)\n \t{\n-\t  struct file_stack *p;\n+\t  struct file_stack *p = input_file_stack;\n \n \t  if (c_header_level && --c_header_level == 0)\n \t    {\n \t      if (entering_c_header)\n \t\twarning (\"badly nested C headers from preprocessor\");\n \t      --pending_lang_change;\n \t    }\n-\t  in_system_header = entering_system_header;\n \n-\t  p = input_file_stack;\n \t  if (indent_level != p->indent_level)\n \t    {\n \t      warning_with_file_and_line\n@@ -2561,18 +2644,163 @@ check_newline ()\n       else\n \terror (\"#-lines for entering and leaving files don't match\");\n     }\n-  else\n-    in_system_header = entering_system_header;\n+\n+  /* Now that we've pushed or popped the input stack,\n+     update the name in the top element.  */\n+  if (input_file_stack)\n+    input_file_stack->name = input_filename;\n \n   /* skip the rest of this line.  */\n  skipline:\n   linemode = 0;\n   end_of_file = 0;\n \n-  while ((c = getch ()) != EOF && c != '\\n');\n+  do\n+    c = getch ();\n+  while (c != '\\n' && c != EOF);\n   return c;\n }\n+\f\n+#ifdef HANDLE_GENERIC_PRAGMAS\n+\n+/* Handle a #pragma directive.\n+   TOKEN is the token we read after `#pragma'.  Processes the entire input\n+   line and return non-zero iff the pragma has been successfully parsed.  */\n+\n+/* This function has to be in this file, in order to get at\n+   the token types.  */\n+\n+static int\n+handle_generic_pragma (token)\n+     register int token;\n+{\n+  for (;;)\n+    {\n+      switch (token)\n+\t{\n+\tcase IDENTIFIER:\n+\tcase TYPENAME:\n+        case STRING:\n+        case CONSTANT:\n+\t  handle_pragma_token (token_buffer, yylval.ttype);\n+\t  break;\n+\n+\tcase LEFT_RIGHT:\n+\t  handle_pragma_token (\"(\", NULL_TREE);\n+\t  handle_pragma_token (\")\", NULL_TREE);\n+\t  break;\n+\n+\tcase END_OF_LINE:\n+\t  return handle_pragma_token (NULL_PTR, NULL_TREE);\n+\n+\tdefault:\n+\t  handle_pragma_token (token_buffer, NULL_TREE);\n+\t}\n+      \n+      token = real_yylex ();\n+    }\n+}\n+#endif /* HANDLE_GENERIC_PRAGMAS */\n+\n+static int\n+handle_cp_pragma (pname)\n+     const char *pname;\n+{\n+  register int token;\n+\n+  if (! strcmp (pname, \"vtable\"))\n+    {\n+      extern tree pending_vtables;\n+\n+      /* More follows: it must be a string constant (class name).  */\n+      token = real_yylex ();\n+      if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)\n+\t{\n+\t  error (\"invalid #pragma vtable\");\n+\t  return -1;\n+\t}\n+\n+      pending_vtables\n+\t= perm_tree_cons (NULL_TREE,\n+\t\t\t  get_identifier (TREE_STRING_POINTER (yylval.ttype)),\n+\t\t\t  pending_vtables);\n+      token = real_yylex ();\n+      if (token != END_OF_LINE)\n+\twarning (\"trailing characters ignored\");\n+      return 1;\n+    }\n+  else if (! strcmp (pname, \"unit\"))\n+    {\n+      /* More follows: it must be a string constant (unit name).  */\n+      token = real_yylex ();\n+      if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)\n+\t{\n+\t  error (\"invalid #pragma unit\");\n+\t  return -1;\n+\t}\n+      token = real_yylex ();\n+      if (token != END_OF_LINE)\n+\twarning (\"trailing characters ignored\");\n+      return 1;\n+    }\n+  else if (! strcmp (pname, \"interface\"))\n+    {\n+      char *main_filename = input_filename;\n+\n+      main_filename = file_name_nondirectory (main_filename);\n+\n+      token = real_yylex ();\n+      \n+      if (token != END_OF_LINE)\n+\t{\n+\t  if (token != STRING\n+\t      || TREE_CODE (yylval.ttype) != STRING_CST)\n+\t    {\n+\t      error (\"invalid `#pragma interface'\");\n+\t      return -1;\n+\t    }\n+\t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n+\t  token = real_yylex ();\n+\t}\n+\n+      if (token != END_OF_LINE)\n+\twarning (\"garbage after `#pragma interface' ignored\");\n+\n+      cp_pragma_interface (main_filename);\n+\n+      return 1;\n+    }\n+  else if (! strcmp (pname, \"implementation\"))\n+    {\n+      char *main_filename = main_input_filename ? main_input_filename : input_filename;\n+\n+      main_filename = file_name_nondirectory (main_filename);\n+\n+      token = real_yylex ();\n+\n+      if (token != END_OF_LINE)\n+\t{\n+\t  if (token != STRING\n+\t      || TREE_CODE (yylval.ttype) != STRING_CST)\n+\t    {\n+\t      error (\"invalid `#pragma implementation'\");\n+\t      return -1;\n+\t    }\n+\t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n+\t  token = real_yylex ();\n+\t}\n+\n+      if (token != END_OF_LINE)\n+\twarning (\"garbage after `#pragma implementation' ignored\");\n+\n+      cp_pragma_implementation (main_filename);\n \n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\f\n void\n do_pending_lang_change ()\n {\n@@ -2633,8 +2861,9 @@ readescape (ignore_ptr)\n \t;\n       else if ((count - 1) * 4 >= TYPE_PRECISION (integer_type_node)\n \t       || (count > 1\n-\t\t   && (((unsigned)1 <<\n-\t\t\t(TYPE_PRECISION (integer_type_node) - (count - 1) * 4))\n+\t\t   && (((unsigned)1\n+\t\t\t<< (TYPE_PRECISION (integer_type_node)\n+\t\t\t    - (count - 1) * 4))\n \t\t       <= firstdig)))\n \tpedwarn (\"hex escape out of range\");\n       return code;\n@@ -2705,7 +2934,37 @@ readescape (ignore_ptr)\n     pedwarn (\"unknown escape sequence: `\\\\' followed by char code 0x%x\", c);\n   return c;\n }\n+\f\n+void\n+yyerror (string)\n+     const char *string;\n+{\n+  extern int end_of_file;\n+  char buf[200];\n+\n+  strcpy (buf, string);\n+\n+  /* We can't print string and character constants well\n+     because the token_buffer contains the result of processing escapes.  */\n+  if (end_of_file)\n+    strcat (buf, input_redirected ()\n+\t    ? \" at end of saved text\"\n+\t    : \" at end of input\");\n+  else if (token_buffer[0] == 0)\n+    strcat (buf, \" at null character\");\n+  else if (token_buffer[0] == '\"')\n+    strcat (buf, \" before string constant\");\n+  else if (token_buffer[0] == '\\'')\n+    strcat (buf, \" before character constant\");\n+  else if (!ISGRAPH ((unsigned char)token_buffer[0]))\n+    sprintf (buf + strlen (buf), \" before character 0%o\",\n+\t     (unsigned char) token_buffer[0]);\n+  else\n+    strcat (buf, \" before `%s'\");\n \n+  error (buf, token_buffer);\n+}\n+\f\n /* Value is 1 (or 2) if we should try to make the next identifier look like\n    a typename (when it may be a local variable or a class variable).\n    Value is 0 if we treat this name in a default fashion.  */\n@@ -3097,15 +3356,17 @@ identifier_typedecl_value (node)\n   return NULL_TREE;\n }\n \n-struct pf_args \n+struct pf_args\n {\n   /* Input */\n+  int base;\n+  char * p;\n   /* I/O */\n-  char *p;\n   int c;\n+  /* Output */\n   int imag;\n   tree type;\n-  /* Output */\n+  int conversion_errno;\n   REAL_VALUE_TYPE value;\n };\n \n@@ -3120,11 +3381,14 @@ parse_float (data)\n      REAL_VALUE_ATOF may not work any more.  */\n   char *copy = (char *) alloca (args->p - token_buffer + 1);\n   bcopy (token_buffer, copy, args->p - token_buffer + 1);\n-  \n+  args->imag = 0;\n+  args->conversion_errno = 0;\n+  args->type = double_type_node;\n+\n   while (1)\n     {\n       int lose = 0;\n-      \n+\n       /* Read the suffixes to choose a data type.  */\n       switch (args->c)\n \t{\n@@ -3133,62 +3397,77 @@ parse_float (data)\n \t    error (\"more than one `f' in numeric constant\");\n \t  fflag = 1;\n \t  break;\n-\t  \n+\n \tcase 'l': case 'L':\n \t  if (lflag)\n \t    error (\"more than one `l' in numeric constant\");\n \t  lflag = 1;\n \t  break;\n-\t  \n+\n \tcase 'i': case 'I':\n \t  if (args->imag)\n \t    error (\"more than one `i' or `j' in numeric constant\");\n \t  else if (pedantic)\n \t    pedwarn (\"ANSI C++ forbids imaginary numeric constants\");\n \t  args->imag = 1;\n \t  break;\n-\t  \n+\n \tdefault:\n \t  lose = 1;\n \t}\n-      \n+\n       if (lose)\n \tbreak;\n-      \n+\n       if (args->p >= token_buffer + maxtoken - 3)\n \targs->p = extend_token_buffer (args->p);\n       *(args->p++) = args->c;\n       *(args->p) = 0;\n       args->c = getch ();\n     }\n-  \n+\n   /* The second argument, machine_mode, of REAL_VALUE_ATOF\n      tells the desired precision of the binary result\n      of decimal-to-binary conversion.  */\n-  \n+\n   if (fflag)\n     {\n       if (lflag)\n \terror (\"both `f' and `l' in floating constant\");\n-      \n+\n       args->type = float_type_node;\n-      args->value = REAL_VALUE_ATOF (copy, TYPE_MODE (args->type));\n+      errno = 0;\n+      if (args->base == 16)\n+\targs->value = REAL_VALUE_HTOF (copy, TYPE_MODE (args->type));\n+      else\n+\targs->value = REAL_VALUE_ATOF (copy, TYPE_MODE (args->type));\n+      args->conversion_errno = errno;\n       /* A diagnostic is required here by some ANSI C testsuites.\n-\t This is not pedwarn, become some people don't want\n+\t This is not pedwarn, because some people don't want\n \t an error for this.  */\n       if (REAL_VALUE_ISINF (args->value) && pedantic)\n \twarning (\"floating point number exceeds range of `float'\");\n     }\n   else if (lflag)\n     {\n       args->type = long_double_type_node;\n-      args->value = REAL_VALUE_ATOF (copy, TYPE_MODE (args->type));\n+      errno = 0;\n+      if (args->base == 16)\n+\targs->value = REAL_VALUE_HTOF (copy, TYPE_MODE (args->type));\n+      else\n+\targs->value = REAL_VALUE_ATOF (copy, TYPE_MODE (args->type));\n+      args->conversion_errno = errno;\n       if (REAL_VALUE_ISINF (args->value) && pedantic)\n \twarning (\"floating point number exceeds range of `long double'\");\n     }\n   else\n     {\n-      args->value = REAL_VALUE_ATOF (copy, TYPE_MODE (args->type));\n+      errno = 0;\n+      if (args->base == 16)\n+\targs->value = REAL_VALUE_HTOF (copy, TYPE_MODE (args->type));\n+      else\n+\targs->value = REAL_VALUE_ATOF (copy, TYPE_MODE (args->type));\n+      args->conversion_errno = errno;\n       if (REAL_VALUE_ISINF (args->value) && pedantic)\n \twarning (\"floating point number exceeds range of `double'\");\n     }\n@@ -3232,10 +3511,9 @@ int\n real_yylex ()\n {\n   register int c;\n+  register char *p;\n   register int value;\n   int wide_flag = 0;\n-  int dollar_seen = 0;\n-  int i;\n \n   c = getch ();\n \n@@ -3277,8 +3555,8 @@ real_yylex ()\n   switch (c)\n     {\n     case EOF:\n-      token_buffer[0] = '\\0';\n       end_of_file = 1;\n+      token_buffer[0] = 0;\n       if (input_redirected ())\n \tvalue = END_OF_SAVED_INPUT;\n       else if (linemode)\n@@ -3287,14 +3565,6 @@ real_yylex ()\n \tvalue = ENDFILE;\n       break;\n \n-    case '$':\n-      if (! dollars_in_ident)\n-\terror (\"`$' in identifier\");\n-      else if (pedantic)\n-\tpedwarn (\"`$' in identifier\");\n-      dollar_seen = 1;\n-      goto letter;\n-\n     case 'L':\n #if USE_CPPLIB\n       if (cpp_token == CPP_NAME)\n@@ -3315,7 +3585,7 @@ real_yylex ()\n \t  }\n \ttoken_put_back (c);\n       }\n-\n+      \n     case 'A':  case 'B':  case 'C':  case 'D':  case 'E':\n     case 'F':  case 'G':  case 'H':  case 'I':  case 'J':\n     case 'K':\t\t  case 'M':  case 'N':  case 'O':\n@@ -3329,181 +3599,164 @@ real_yylex ()\n     case 'u':  case 'v':  case 'w':  case 'x':  case 'y':\n     case 'z':\n     case '_':\n+    case '$':\n     letter:\n-      {\n-\tregister char *p;\n-\n #if USE_CPPLIB\n-\tif (cpp_token == CPP_NAME)\n-\t  {\n-\t    /* Note that one character has already been read from\n-\t       yy_cur into token_buffer.  */\n-\n-\t    int len = yy_lim - yy_cur + 1;\n-\t    if (len >= maxtoken)\n-\t      extend_token_buffer_to (len + 1);\n-\t    memcpy (token_buffer + 1, yy_cur, len);\n-\t    p = token_buffer + len;\n-\t    yy_cur = yy_lim;\n-\t  }\n-\telse\n+      if (cpp_token == CPP_NAME)\n+\t{\n+\t  /* Note that one character has already been read from\n+\t     yy_cur into token_buffer.  Also, cpplib complains about\n+\t     $ in identifiers, so we don't have to.  */\n+\n+\t  int len = yy_lim - yy_cur + 1;\n+\t  if (len >= maxtoken)\n+\t    extend_token_buffer_to (len + 1);\n+\t  memcpy (token_buffer + 1, yy_cur, len);\n+\t  p = token_buffer + len;\n+\t  yy_cur = yy_lim;\n+\t}\n+      else\n #endif\n-\t  {\n-\t    /* We already installed C as the first char in token_buffer.  */\n-\t    p = token_buffer+1;\n-\t    c = token_getch ();\n-\n-\t    while (ISALNUM (c) || (c == '_') || c == '$')\n-\t      {\n-\t\tif (c == '$')\n-\t\t  {\n-\t\t    if (! dollars_in_ident)\n-\t\t      error (\"`$' in identifier\");\n-\t\t    else if (pedantic)\n-\t\t      pedwarn (\"`$' in identifier\");\n-\t\t  }\n+\t{\n+\t  p = token_buffer;\n+\t  while (ISALNUM (c) || (c == '_') || c == '$')\n+\t    {\n+\t      /* Make sure this char really belongs in an identifier.  */\n+\t      if (c == '$')\n+\t\t{\n+\t\t  if (! dollars_in_ident)\n+\t\t    error (\"`$' in identifier\");\n+\t\t  else if (pedantic)\n+\t\t    pedwarn (\"`$' in identifier\");\n+\t\t}\n \n-\t\tif (p >= token_buffer + maxtoken)\n-\t\t  p = extend_token_buffer (p);\n+\t      if (p >= token_buffer + maxtoken)\n+\t\tp = extend_token_buffer (p);\n \n-\t\t*p++ = c;\n-\t\tc = token_getch ();\n-\t      }\n+\t      *p++ = c;\n+\t      c = token_getch ();\n+\t    }\n \n-\t    *p = 0;\n-\t    token_put_back (c);\n-\t  }\n+\t  *p = 0;\n+\t  token_put_back (c);\n+\t}\n \n-\tvalue = IDENTIFIER;\n-\tyylval.itype = 0;\n+      value = IDENTIFIER;\n+      yylval.itype = 0;\n \n-\t/* Try to recognize a keyword.  Uses minimum-perfect hash function */\n+      /* Try to recognize a keyword.  Uses minimum-perfect hash function */\n \n-\t{\n-\t  register struct resword *ptr;\n+      {\n+\tregister struct resword *ptr;\n \n-\t  if ((ptr = is_reserved_word (token_buffer, p - token_buffer)))\n-\t    {\n-\t      if (ptr->rid)\n-\t\t{\n-\t\t  tree old_ttype = ridpointers[(int) ptr->rid];\n-\n-\t\t  /* If this provides a type for us, then revert lexical\n-\t\t     state to standard state.  */\n-\t\t  if (TREE_CODE (old_ttype) == IDENTIFIER_NODE\n-\t\t      && IDENTIFIER_GLOBAL_VALUE (old_ttype) != 0\n-\t\t      && TREE_CODE (IDENTIFIER_GLOBAL_VALUE (old_ttype)) == TYPE_DECL)\n-\t\t    looking_for_typename = 0;\n-\t\t  else if (ptr->token == AGGR || ptr->token == ENUM)\n-\t\t    looking_for_typename = 2;\n-\n-\t\t  if (ptr->token == VISSPEC)\n-\t\t    {\n-\t\t      switch (ptr->rid)\n-\t\t\t{\n-\t\t\tcase RID_PUBLIC:\n-\t\t\t  yylval.ttype = access_public_node;\n-\t\t\t  break;\n-\t\t\tcase RID_PRIVATE:\n-\t\t\t  yylval.ttype = access_private_node;\n-\t\t\t  break;\n-\t\t\tcase RID_PROTECTED:\n-\t\t\t  yylval.ttype = access_protected_node;\n-\t\t\t  break;\n-\t\t\tdefault:\n-\t\t\t  my_friendly_abort (63);\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    yylval.ttype = old_ttype;\n-\t\t}\n-\t      else switch (ptr->token)\n-\t\t{\n-\t\tcase EQCOMPARE:\n-\t\t  yylval.code = NE_EXPR;\n-\t\t  token_buffer[0] = '!';\n-\t\t  token_buffer[1] = '=';\n-\t\t  token_buffer[2] = 0;\n-\t\t  break;\n+\tif ((ptr = is_reserved_word (token_buffer, p - token_buffer)))\n+\t  {\n+\t    if (ptr->rid)\n+\t      {\n+\t\tif (ptr->token == VISSPEC)\n+\t\t  {\n+\t\t    switch (ptr->rid)\n+\t\t      {\n+\t\t      case RID_PUBLIC:\n+\t\t\tyylval.ttype = access_public_node;\n+\t\t\tbreak;\n+\t\t      case RID_PRIVATE:\n+\t\t\tyylval.ttype = access_private_node;\n+\t\t\tbreak;\n+\t\t      case RID_PROTECTED:\n+\t\t\tyylval.ttype = access_protected_node;\n+\t\t\tbreak;\n+\t\t      default:\n+\t\t\tmy_friendly_abort (63);\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  yylval.ttype = ridpointers[(int) ptr->rid];\n+\t      }\n+\t    else switch (ptr->token)\n+\t      {\n+\t      case EQCOMPARE:\n+\t\tyylval.code = NE_EXPR;\n+\t\ttoken_buffer[0] = '!';\n+\t\ttoken_buffer[1] = '=';\n+\t\ttoken_buffer[2] = 0;\n+\t\tbreak;\n \n-\t\tcase ASSIGN:\n-\t\t  if (strcmp (\"and_eq\", token_buffer) == 0)\n-\t\t    {\n-\t\t      yylval.code = BIT_AND_EXPR;\n-\t\t      token_buffer[0] = '&';\n-\t\t    }\n-\t\t  else if (strcmp (\"or_eq\", token_buffer) == 0)\n-\t\t    {\n-\t\t      yylval.code = BIT_IOR_EXPR;\n-\t\t      token_buffer[0] = '|';\n-\t\t    }\n-\t\t  else if (strcmp (\"xor_eq\", token_buffer) == 0)\n-\t\t    {\n-\t\t      yylval.code = BIT_XOR_EXPR;\n-\t\t      token_buffer[0] = '^';\n-\t\t    }\n-\t\t  token_buffer[1] = '=';\n-\t\t  token_buffer[2] = 0;\n-\t\t  break;\n+\t      case ASSIGN:\n+\t\tif (strcmp (\"and_eq\", token_buffer) == 0)\n+\t\t  {\n+\t\t    yylval.code = BIT_AND_EXPR;\n+\t\t    token_buffer[0] = '&';\n+\t\t  }\n+\t\telse if (strcmp (\"or_eq\", token_buffer) == 0)\n+\t\t  {\n+\t\t    yylval.code = BIT_IOR_EXPR;\n+\t\t    token_buffer[0] = '|';\n+\t\t  }\n+\t\telse if (strcmp (\"xor_eq\", token_buffer) == 0)\n+\t\t  {\n+\t\t    yylval.code = BIT_XOR_EXPR;\n+\t\t    token_buffer[0] = '^';\n+\t\t  }\n+\t\ttoken_buffer[1] = '=';\n+\t\ttoken_buffer[2] = 0;\n+\t\tbreak;\n \n-\t\tcase '&':\n-\t\t  yylval.code = BIT_AND_EXPR;\n-\t\t  token_buffer[0] = '&';\n-\t\t  token_buffer[1] = 0;\n-\t\t  break;\n+\t      case '&':\n+\t\tyylval.code = BIT_AND_EXPR;\n+\t\ttoken_buffer[0] = '&';\n+\t\ttoken_buffer[1] = 0;\n+\t\tbreak;\n \n-\t\tcase '|':\n-\t\t  yylval.code = BIT_IOR_EXPR;\n-\t\t  token_buffer[0] = '|';\n-\t\t  token_buffer[1] = 0;\n-\t\t  break;\n+\t      case '|':\n+\t\tyylval.code = BIT_IOR_EXPR;\n+\t\ttoken_buffer[0] = '|';\n+\t\ttoken_buffer[1] = 0;\n+\t\tbreak;\n \n-\t\tcase '^':\n-\t\t  yylval.code = BIT_XOR_EXPR;\n-\t\t  token_buffer[0] = '^';\n-\t\t  token_buffer[1] = 0;\n-\t\t  break;\n-\t\t}\n+\t      case '^':\n+\t\tyylval.code = BIT_XOR_EXPR;\n+\t\ttoken_buffer[0] = '^';\n+\t\ttoken_buffer[1] = 0;\n+\t\tbreak;\n+\t      }\n \n-\t      value = (int) ptr->token;\n-\t    }\n-\t}\n+\t    value = (int) ptr->token;\n+\t  }\n+      }\n \n-\t/* If we did not find a keyword, look for an identifier\n-\t   (or a typename).  */\n+      /* If we did not find a keyword, look for an identifier\n+\t (or a typename).  */\n \n-\tif (value == IDENTIFIER || value == TYPESPEC)\n-\t  GNU_xref_ref (current_function_decl, token_buffer);\n+      if (value == IDENTIFIER || value == TYPESPEC)\n+\tGNU_xref_ref (current_function_decl, token_buffer);\n \n-\tif (value == IDENTIFIER)\n-\t  {\n-\t    register tree tmp = get_identifier (token_buffer);\n+      if (value == IDENTIFIER)\n+\t{\n+\t  register tree tmp = get_identifier (token_buffer);\n \n #if !defined(VMS) && defined(JOINER)\n-\t    /* Make sure that user does not collide with our internal\n-\t       naming scheme.  */\n-\t    if (JOINER == '$'\n-\t\t&& dollar_seen\n-\t\t&& (THIS_NAME_P (tmp)\n-\t\t    || VPTR_NAME_P (tmp)\n-\t\t    || DESTRUCTOR_NAME_P (tmp)\n-\t\t    || VTABLE_NAME_P (tmp)\n-\t\t    || TEMP_NAME_P (tmp)\n-\t\t    || ANON_AGGRNAME_P (tmp)\n-\t\t    || ANON_PARMNAME_P (tmp)))\n-\t      warning (\"identifier name `%s' conflicts with GNU C++ internal naming strategy\",\n-\t\t       token_buffer);\n+\t  /* Make sure that user does not collide with our internal\n+\t     naming scheme.  */\n+\t  if (JOINER == '$'\n+\t      && (THIS_NAME_P (tmp)\n+\t\t  || VPTR_NAME_P (tmp)\n+\t\t  || DESTRUCTOR_NAME_P (tmp)\n+\t\t  || VTABLE_NAME_P (tmp)\n+\t\t  || TEMP_NAME_P (tmp)\n+\t\t  || ANON_AGGRNAME_P (tmp)\n+\t\t  || ANON_PARMNAME_P (tmp)))\n+\t    warning (\"identifier name `%s' conflicts with GNU C++ internal naming strategy\",\n+\t\t     token_buffer);\n #endif\n \n-\t    yylval.ttype = tmp;\n-\t  }\n-\tif (value == NEW && ! global_bindings_p ())\n-\t  {\n-\t    value = NEW;\n-\t    goto done;\n-\t  }\n-      }\n-\n+\t  yylval.ttype = tmp;\n+\t}\n+      if (value == NEW && ! global_bindings_p ())\n+\t{\n+\t  value = NEW;\n+\t  goto done;\n+\t}\n       break;\n \n     case '.':\n@@ -3537,13 +3790,13 @@ real_yylex ()\n \t  if (ISDIGIT (c1))\n \t    {\n \t      token_put_back (c1);\n-\t      goto resume_numerical_scan;\n+\t      goto number;\n \t    }\n \t  token_put_back (c1);\n \t}\n       value = '.';\n       token_buffer[1] = 0;\n-      goto done;\n+      break;\n \n     case '0':  case '1':\n       /* Optimize for most frequent case.  */\n@@ -3559,21 +3812,16 @@ real_yylex ()\n #endif\n \tif (cond)\n \t  {\n-\t    /* Terminate string.  */\n-\t    if (c == '0')\n-\t      yylval.ttype = integer_zero_node;\n-\t    else\n-\t      yylval.ttype = integer_one_node;\n+\t    yylval.ttype = (c == '0') ? integer_zero_node : integer_one_node;\n \t    value = CONSTANT;\n-\t    goto done;\n+\t    break;\n \t  }\n+\t/*FALLTHRU*/\n       }\n-    /* fall through...  */\n-\t\t\t  case '2':  case '3':  case '4':\n+    case '2':  case '3':  case '4':\n     case '5':  case '6':  case '7':  case '8':  case '9':\n-    resume_numerical_scan:\n+    number:\n       {\n-\tregister char *p;\n \tint base = 10;\n \tint count = 0;\n \tint largest_digit = 0;\n@@ -3591,8 +3839,8 @@ real_yylex ()\n #define TOTAL_PARTS ((HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR) * 2)\n \tunsigned int parts[TOTAL_PARTS];\n \n-\tenum anon1 { NOT_FLOAT, AFTER_POINT, TOO_MANY_POINTS} floatflag\n-\t  = NOT_FLOAT;\n+\tenum anon1 { NOT_FLOAT, AFTER_POINT, TOO_MANY_POINTS, AFTER_EXPON }\n+\t  floatflag = NOT_FLOAT;\n \n \tfor (count = 0; count < TOTAL_PARTS; count++)\n \t  parts[count] = 0;\n@@ -3621,19 +3869,19 @@ real_yylex ()\n \t/* Read all the digits-and-decimal-points.  */\n \n \twhile (c == '.'\n-\t       || (ISALNUM (c) && (c != 'l') && (c != 'L')\n-\t\t   && (c != 'u') && (c != 'U')\n+\t       || (ISALNUM (c) && c != 'l' && c != 'L'\n+\t\t   && c != 'u' && c != 'U'\n \t\t   && c != 'i' && c != 'I' && c != 'j' && c != 'J'\n \t\t   && (floatflag == NOT_FLOAT || ((c != 'f') && (c != 'F')))))\n \t  {\n \t    if (c == '.')\n \t      {\n-\t\tif (base == 16)\n-\t\t  error (\"floating constant may not be in radix 16\");\n+\t\tif (base == 16 && pedantic)\n+\t\t  pedwarn (\"floating constant may not be in radix 16\");\n \t\tif (floatflag == TOO_MANY_POINTS)\n \t\t  /* We have already emitted an error.  Don't need another.  */\n \t\t  ;\n-\t\telse if (floatflag == AFTER_POINT)\n+\t\telse if (floatflag == AFTER_POINT || floatflag == AFTER_EXPON)\n \t\t  {\n \t\t    error (\"malformed floating constant\");\n \t\t    floatflag = TOO_MANY_POINTS;\n@@ -3644,7 +3892,8 @@ real_yylex ()\n \t\telse\n \t\t  floatflag = AFTER_POINT;\n \n-\t\tbase = 10;\n+\t\tif (base == 8)\n+\t\t  base = 10;\n \t\t*p++ = c = token_getch ();\n \t\t/* Accept '.' as the start of a floating-point number\n \t\t   only when it is followed by a digit.  */\n@@ -3665,12 +3914,17 @@ real_yylex ()\n \t\t    if (c == 'e' || c == 'E')\n \t\t      {\n \t\t\tbase = 10;\n-\t\t\tfloatflag = AFTER_POINT;\n+\t\t\tfloatflag = AFTER_EXPON;\n \t\t\tbreak;   /* start of exponent */\n \t\t      }\n \t\t    error (\"nondigits in number and not hexadecimal\");\n \t\t    c = 0;\n \t\t  }\n+\t\telse if (base == 16 && (c == 'p' || c == 'P'))\n+\t\t  {\n+\t\t    floatflag = AFTER_EXPON;\n+\t\t    break;   /* start of exponent */\n+\t\t  }\n \t\telse if (c >= 'a')\n \t\t  {\n \t\t    c = c - 'a' + 10;\n@@ -3725,15 +3979,15 @@ real_yylex ()\n \n \tif (floatflag != NOT_FLOAT)\n \t  {\n-\t    tree type = double_type_node;\n-\t    int exceeds_double = 0;\n-\t    int imag = 0;\n+\t    tree type;\n+\t    int imag, conversion_errno;\n \t    REAL_VALUE_TYPE value;\n \t    struct pf_args args;\n \n \t    /* Read explicit exponent if any, and put it in tokenbuf.  */\n \n-\t    if ((c == 'e') || (c == 'E'))\n+\t    if ((base == 10 && ((c == 'e') || (c == 'E')))\n+\t\t|| (base == 16 && (c == 'p' || c == 'P')))\n \t      {\n \t\tif (p >= token_buffer + maxtoken - 3)\n \t\t  p = extend_token_buffer (p);\n@@ -3744,26 +3998,27 @@ real_yylex ()\n \t\t    *p++ = c;\n \t\t    c = token_getch ();\n \t\t  }\n+\t\t/* Exponent is decimal, even if string is a hex float.  */\n \t\tif (! ISDIGIT (c))\n \t\t  error (\"floating constant exponent has no digits\");\n-\t        while (ISDIGIT (c))\n+\t\twhile (ISDIGIT (c))\n \t\t  {\n \t\t    if (p >= token_buffer + maxtoken - 3)\n \t\t      p = extend_token_buffer (p);\n \t\t    *p++ = c;\n \t\t    c = token_getch ();\n \t\t  }\n \t      }\n+\t    if (base == 16 && floatflag != AFTER_EXPON)\n+\t      error (\"hexadecimal floating constant has no exponent\");\n \n \t    *p = 0;\n-\t    errno = 0;\n \n \t    /* Setup input for parse_float() */\n+\t    args.base = base;\n \t    args.p = p;\n \t    args.c = c;\n-\t    args.imag = imag;\n-\t    args.type = type;\n-\t    \n+\n \t    /* Convert string to a double, checking for overflow.  */\n \t    if (do_float_handler (parse_float, (PTR) &args))\n \t      {\n@@ -3778,24 +4033,18 @@ real_yylex ()\n \t      }\n \n \t    /* Receive output from parse_float() */\n-\t    p = args.p;\n \t    c = args.c;\n \t    imag = args.imag;\n \t    type = args.type;\n+\t    conversion_errno = args.conversion_errno;\n \t    \n #ifdef ERANGE\n-\t    if (errno == ERANGE && pedantic)\n-\t      {\n-  \t\t/* ERANGE is also reported for underflow,\n-  \t\t   so test the value to distinguish overflow from that.  */\n-\t\tif (REAL_VALUES_LESS (dconst1, value)\n-\t\t    || REAL_VALUES_LESS (value, dconstm1))\n-\t\t  {\n-\t\t    pedwarn (\"floating point number exceeds range of `%s'\",\n-\t\t\t     IDENTIFIER_POINTER (TYPE_IDENTIFIER (type)));\n-\t\t    exceeds_double = 1;\n-\t\t  }\n-\t      }\n+\t    /* ERANGE is also reported for underflow,\n+\t       so test the value to distinguish overflow from that.  */\n+\t    if (conversion_errno == ERANGE && pedantic\n+\t\t&& (REAL_VALUES_LESS (dconst1, value)\n+\t\t    || REAL_VALUES_LESS (value, dconstm1)))\n+\t      warning (\"floating point number exceeds range of `double'\");\n #endif\n \n \t    /* If the result is not a number, assume it must have been\n@@ -3807,7 +4056,7 @@ real_yylex ()\n \t    /* Create a node with determined type and value.  */\n \t    if (imag)\n \t      yylval.ttype = build_complex (NULL_TREE,\n-\t\t\t\t\t    cp_convert (type, integer_zero_node),\n+\t\t\t\t\t    convert (type, integer_zero_node),\n \t\t\t\t\t    build_real (type, value));\n \t    else\n \t      yylval.ttype = build_real (type, value);\n@@ -3820,7 +4069,7 @@ real_yylex ()\n \t    int spec_long = 0;\n \t    int spec_long_long = 0;\n \t    int spec_imag = 0;\n-\t    int warn;\n+\t    int warn, i;\n \n \t    while (1)\n \t      {\n@@ -3867,6 +4116,7 @@ real_yylex ()\n \n \t    /* This is simplified by the fact that our constant\n \t       is always positive.  */\n+\n \t    high = low = 0;\n \n \t    for (i = 0; i < HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR; i++)\n@@ -3876,27 +4126,25 @@ real_yylex ()\n \t\t\t << (i * HOST_BITS_PER_CHAR));\n \t\tlow |= (HOST_WIDE_INT) parts[i] << (i * HOST_BITS_PER_CHAR);\n \t      }\n-\t    \n-\t    \n+\n \t    yylval.ttype = build_int_2 (low, high);\n \t    TREE_TYPE (yylval.ttype) = long_long_unsigned_type_node;\n \n \t    /* Calculate the ANSI type.  */\n-\t    if (!spec_long && !spec_unsigned\n+\t    if (! spec_long && ! spec_unsigned\n \t\t&& int_fits_type_p (yylval.ttype, integer_type_node))\n \t      type = integer_type_node;\n-\t    else if (!spec_long && (base != 10 || spec_unsigned)\n+\t    else if (! spec_long && (base != 10 || spec_unsigned)\n \t\t     && int_fits_type_p (yylval.ttype, unsigned_type_node))\n-\t      /* Nondecimal constants try unsigned even in traditional C.  */\n \t      type = unsigned_type_node;\n-\t    else if (!spec_unsigned && !spec_long_long\n+\t    else if (! spec_unsigned && !spec_long_long\n \t\t     && int_fits_type_p (yylval.ttype, long_integer_type_node))\n \t      type = long_integer_type_node;\n-\t    else if (! spec_long_long)\n+\t    else if (! spec_long_long\n+\t\t     && int_fits_type_p (yylval.ttype,\n+\t\t\t\t\t long_unsigned_type_node))\n \t      type = long_unsigned_type_node;\n \t    else if (! spec_unsigned\n-\t\t     /* Verify value does not overflow into sign bit.  */\n-\t\t     && TREE_INT_CST_HIGH (yylval.ttype) >= 0\n \t\t     && int_fits_type_p (yylval.ttype,\n \t\t\t\t\t long_long_integer_type_node))\n \t      type = long_long_integer_type_node;\n@@ -3910,30 +4158,49 @@ real_yylex ()\n \t    else\n \t      type = widest_unsigned_literal_type_node;\n \n-\t    if (!int_fits_type_p (yylval.ttype, type) && !warn)\n-\t      pedwarn (\"integer constant is larger than the maximum value for its type\");\n+\t    if (pedantic && !spec_long_long && !warn\n+\t\t&& (TYPE_PRECISION (long_integer_type_node)\n+\t\t    < TYPE_PRECISION (type)))\n+\t      {\n+\t\twarn = 1;\n+\t\tpedwarn (\"integer constant larger than the maximum value of an unsigned long int\");\n+\t      }\n \n \t    if (base == 10 && ! spec_unsigned && TREE_UNSIGNED (type))\n-\t      warning (\"decimal integer constant is so large that it is unsigned\");\n+\t      warning (\"decimal constant is so large that it is unsigned\");\n \n \t    if (spec_imag)\n \t      {\n \t\tif (TYPE_PRECISION (type)\n \t\t    <= TYPE_PRECISION (integer_type_node))\n \t\t  yylval.ttype\n \t\t    = build_complex (NULL_TREE, integer_zero_node,\n-\t\t\t\t     cp_convert (integer_type_node,\n-\t\t\t\t\t\t yylval.ttype));\n+\t\t\t\t     convert (integer_type_node,\n+\t\t\t\t\t      yylval.ttype));\n \t\telse\n \t\t  error (\"complex integer constant is too wide for `__complex int'\");\n \t      }\n \t    else\n \t      TREE_TYPE (yylval.ttype) = type;\n+\n+\n+\t    /* If it's still an integer (not a complex), and it doesn't\n+\t       fit in the type we choose for it, then pedwarn. */\n+\n+\t    if (! warn\n+\t\t&& TREE_CODE (TREE_TYPE (yylval.ttype)) == INTEGER_TYPE\n+\t\t&& ! int_fits_type_p (yylval.ttype, TREE_TYPE (yylval.ttype)))\n+\t      pedwarn (\"integer constant is larger than the maximum value for its type\");\n \t  }\n \n \ttoken_put_back (c);\n \t*p = 0;\n \n+\tif (ISALNUM (c) || c == '.' || c == '_' || c == '$'\n+\t    || ((c == '-' || c == '+')\n+\t\t&& (p[-1] == 'e' || p[-1] == 'E')))\n+\t  error (\"missing white space after number `%s'\", token_buffer);\n+\n \tvalue = CONSTANT; break;\n       }\n \n@@ -4057,7 +4324,7 @@ real_yylex ()\n \t      }\n \n \t    /* Merge character into result; ignore excess chars.  */\n-\t    num_chars++;\n+\t    num_chars += (width / TYPE_PRECISION (char_type_node));\n \t    if (num_chars < max_chars + 1)\n \t      {\n \t\tif (width < HOST_BITS_PER_INT)\n@@ -4097,6 +4364,7 @@ real_yylex ()\n \t\t= build_int_2 (result | ~(~(unsigned HOST_WIDE_INT) 0\n \t\t\t\t\t  >> (HOST_BITS_PER_WIDE_INT - num_bits)),\n \t\t\t       -1);\n+\t    /* In C, a character constant has type 'int'; in C++, 'char'.  */\n \t    if (chars_seen <= 1)\n \t      TREE_TYPE (yylval.ttype) = char_type_node;\n \t    else\n@@ -4115,7 +4383,6 @@ real_yylex ()\n     case '\"':\n     string_constant:\n       {\n-\tregister char *p;\n \tunsigned width = wide_flag ? WCHAR_TYPE_SIZE\n \t                           : TYPE_PRECISION (char_type_node);\n #ifdef MULTIBYTE_CHARS\n@@ -4137,7 +4404,7 @@ real_yylex ()\n \t\t  goto skipnewline;\n \t\tif (width < HOST_BITS_PER_INT\n \t\t    && (unsigned) c >= ((unsigned)1 << width))\n-\t\t  warning (\"escape sequence out of range for character\");\n+\t\t  pedwarn (\"escape sequence out of range for character\");\n \t      }\n \t    else if (c == '\\n')\n \t      {\n@@ -4198,7 +4465,7 @@ real_yylex ()\n \t\tfor (byte = 0; byte < WCHAR_BYTES; ++byte)\n \t\t  {\n \t\t    int value;\n-\t\t    if (byte >= (int) sizeof(c))\n+\t\t    if (byte >= (int) sizeof (c))\n \t\t      value = 0;\n \t\t    else\n \t\t      value = (c >> (byte * width)) & bytemask;\n@@ -4218,10 +4485,6 @@ real_yylex ()\n \n \t  skipnewline:\n \t    c = token_getch ();\n-\t    if (c == EOF) {\n-\t\terror (\"Unterminated string\");\n-\t\tbreak;\n-\t    }\n \t  }\n \n \t/* Terminate the string value, either with a single byte zero\n@@ -4240,6 +4503,9 @@ real_yylex ()\n \t    *p++ = 0;\n \t  }\n \n+\tif (c == EOF)\n+\t  error (\"Unterminated string constant\");\n+\n \t/* We have read the entire constant.\n \t   Construct a STRING_CST for the result.  */\n \n@@ -4261,6 +4527,7 @@ real_yylex ()\n     case '-':\n     case '&':\n     case '|':\n+    case ':':\n     case '<':\n     case '>':\n     case '*':\n@@ -4337,19 +4604,11 @@ real_yylex ()\n \t    case '>':\n \t      c = RSHIFT;\n \t      goto combine;\n+\t    case ':':\n+\t      value = SCOPE;\n+\t      yylval.itype = 1;\n+\t      goto done;\n \t    }\n-\telse if ((c == '-') && (c1 == '>'))\n-\t  {\n-\t    c1 = token_getch ();\n-\t    if (c1 == '*')\n-\t      value = POINTSAT_STAR;\n-\t    else\n-\t      {\n-\t\ttoken_put_back (c1);\n-\t\tvalue = POINTSAT;\n-\t      }\n-\t    goto done;\n-\t  }\n \telse if (c1 == '?' && (c == '<' || c == '>'))\n \t  {\n \t    token_buffer[3] = 0;\n@@ -4372,49 +4631,66 @@ real_yylex ()\n \t\t       token_buffer);\n \t    goto done;\n \t  }\n-\t/* digraphs */\n-\telse if (c == '<' && c1 == '%')\n-\t  { value = '{'; goto done; }\n-\telse if (c == '<' && c1 == ':')\n-\t  { value = '['; goto done; }\n-\telse if (c == '%' && c1 == '>')\n-\t  { value = '}'; goto done; }\n-\telse if (c == '%' && c1 == ':')\n-\t  { value = '#'; goto done; }\n+\telse\n+\t  switch (c)\n+\t    {\n+\t    case '-':\n+\t      if (c1 == '>')\n+\t\t{\n+\t\t  c1 = token_getch ();\n+\t\t  if (c1 == '*')\n+\t\t    value = POINTSAT_STAR;\n+\t\t  else\n+\t\t    {\n+\t\t      token_put_back (c1);\n+\t\t      value = POINTSAT;\n+\t\t    }\n+\t\t  goto done;\n+\t\t}\n+\t      break;\n+\n+\t      /* digraphs */\n+\t    case ':':\n+\t      if (c1 == '>')\n+\t\t{ value = ']'; goto done; }\n+\t      break;\n+\t    case '<':\n+\t      if (c1 == '%')\n+\t\t{ value = '{'; indent_level++; goto done; }\n+\t      if (c1 == ':')\n+\t\t{ value = '['; goto done; }\n+\t      break;\n+\t    case '%':\n+\t      if (c1 == '>')\n+\t\t{ value = '}'; indent_level--; goto done; }\n+\t      break;\n+\t    }\n \n \ttoken_put_back (c1);\n \ttoken_buffer[1] = 0;\n \n+\t/* Here the C frontend changes < and > to ARITHCOMPARE.  We don't\n+\t   do that because of templates.  */\n+\n \tvalue = c;\n-\tgoto done;\n+\tbreak;\n       }\n \n-    case ':':\n-      c = token_getch ();\n-      if (c == ':')\n-\t{\n-\t  token_buffer[1] = ':';\n-\t  token_buffer[2] = '\\0';\n-\t  value = SCOPE;\n-\t  yylval.itype = 1;\n-\t}\n-      else if (c == '>')\n-\t{\n-\t  value = ']';\n-\t  goto done;\n-\t}\n-      else\n-\t{\n-\t  token_put_back (c);\n-\t  value = ':';\n-\t}\n-      break;\n-\n     case 0:\n       /* Don't make yyparse think this is eof.  */\n       value = 1;\n       break;\n \n+    case '{':\n+      indent_level++;\n+      value = c;\n+      break;\n+\n+    case '}':\n+      indent_level--;\n+      value = c;\n+      break;\n+\n     default:\n       value = c;\n     }\n@@ -4690,135 +4966,6 @@ compiler_error VPROTO ((const char *msg, ...))\n   error_with_file_and_line (input_filename, lineno, \"%s (compiler error)\", buf);\n }\n \f\n-void\n-yyerror (string)\n-     const char *string;\n-{\n-  extern int end_of_file;\n-  char buf[200];\n-\n-  strcpy (buf, string);\n-\n-  /* We can't print string and character constants well\n-     because the token_buffer contains the result of processing escapes.  */\n-  if (end_of_file)\n-    strcat (buf, input_redirected ()\n-\t    ? \" at end of saved text\"\n-\t    : \" at end of input\");\n-  else if (token_buffer[0] == 0)\n-    strcat (buf, \" at null character\");\n-  else if (token_buffer[0] == '\"')\n-    strcat (buf, \" before string constant\");\n-  else if (token_buffer[0] == '\\'')\n-    strcat (buf, \" before character constant\");\n-  else if (!ISGRAPH ((unsigned char)token_buffer[0]))\n-    sprintf (buf + strlen (buf), \" before character 0%o\",\n-\t     (unsigned char) token_buffer[0]);\n-  else\n-    strcat (buf, \" before `%s'\");\n-\n-  error (buf, token_buffer);\n-}\n-\f\n-static int\n-handle_cp_pragma (pname)\n-     const char *pname;\n-{\n-  register int token;\n-\n-  if (! strcmp (pname, \"vtable\"))\n-    {\n-      extern tree pending_vtables;\n-\n-      /* More follows: it must be a string constant (class name).  */\n-      token = real_yylex ();\n-      if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)\n-\t{\n-\t  error (\"invalid #pragma vtable\");\n-\t  return -1;\n-\t}\n-\n-      pending_vtables\n-\t= perm_tree_cons (NULL_TREE,\n-\t\t\t  get_identifier (TREE_STRING_POINTER (yylval.ttype)),\n-\t\t\t  pending_vtables);\n-      token = real_yylex ();\n-      if (token != END_OF_LINE)\n-\twarning (\"trailing characters ignored\");\n-      return 1;\n-    }\n-  else if (! strcmp (pname, \"unit\"))\n-    {\n-      /* More follows: it must be a string constant (unit name).  */\n-      token = real_yylex ();\n-      if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)\n-\t{\n-\t  error (\"invalid #pragma unit\");\n-\t  return -1;\n-\t}\n-      token = real_yylex ();\n-      if (token != END_OF_LINE)\n-\twarning (\"trailing characters ignored\");\n-      return 1;\n-    }\n-  else if (! strcmp (pname, \"interface\"))\n-    {\n-      char *main_filename = input_filename;\n-\n-      main_filename = file_name_nondirectory (main_filename);\n-\n-      token = real_yylex ();\n-      \n-      if (token != END_OF_LINE)\n-\t{\n-\t  if (token != STRING\n-\t      || TREE_CODE (yylval.ttype) != STRING_CST)\n-\t    {\n-\t      error (\"invalid `#pragma interface'\");\n-\t      return -1;\n-\t    }\n-\t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n-\t  token = real_yylex ();\n-\t}\n-\n-      if (token != END_OF_LINE)\n-\twarning (\"garbage after `#pragma interface' ignored\");\n-\n-      cp_pragma_interface (main_filename);\n-\n-      return 1;\n-    }\n-  else if (! strcmp (pname, \"implementation\"))\n-    {\n-      char *main_filename = main_input_filename ? main_input_filename : input_filename;\n-\n-      main_filename = file_name_nondirectory (main_filename);\n-\n-      token = real_yylex ();\n-\n-      if (token != END_OF_LINE)\n-\t{\n-\t  if (token != STRING\n-\t      || TREE_CODE (yylval.ttype) != STRING_CST)\n-\t    {\n-\t      error (\"invalid `#pragma implementation'\");\n-\t      return -1;\n-\t    }\n-\t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n-\t  token = real_yylex ();\n-\t}\n-\n-      if (token != END_OF_LINE)\n-\twarning (\"garbage after `#pragma implementation' ignored\");\n-\n-      cp_pragma_implementation (main_filename);\n-\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n /* Return the type-qualifier corresponding to the identifier given by\n    RID.  */\n \n@@ -4836,45 +4983,3 @@ cp_type_qual_from_rid (rid)\n   my_friendly_abort (0);\n   return TYPE_UNQUALIFIED;\n }\n-\n-\f\n-#ifdef HANDLE_GENERIC_PRAGMAS\n-\n-/* Handle a #pragma directive.  TOKEN is the type of the word following\n-   the #pragma directive on the line.  Process the entire input line and\n-   return non-zero iff the directive successfully parsed.  */\n-\n-/* This function has to be in this file, in order to get at\n-   the token types.  */\n-\n-static int\n-handle_generic_pragma (token)\n-     register int token;\n-{\n-  for (;;)\n-    {\n-      switch (token)\n-\t{\n-\tcase IDENTIFIER:\n-\tcase TYPENAME:\n-        case STRING:\n-        case CONSTANT:\n-\t  handle_pragma_token (token_buffer, yylval.ttype);\n-\t  break;\n-\n-\tcase LEFT_RIGHT:\n-\t  handle_pragma_token (\"(\", NULL_TREE);\n-\t  handle_pragma_token (\")\", NULL_TREE);\n-\t  break;\n-\n-\tcase END_OF_LINE:\n-\t  return handle_pragma_token (NULL_PTR, NULL_TREE);\n-\n-\tdefault:\n-\t  handle_pragma_token (token_buffer, NULL_TREE);\n-\t}\n-      \n-      token = real_yylex ();\n-    }\n-}\n-#endif /* HANDLE_GENERIC_PRAGMAS */"}, {"sha": "8fe9c7e7b1d316bfb8376816cb5da9950935508d", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ceb5ff350b39174c1329415944bd1d9b3e25704/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ceb5ff350b39174c1329415944bd1d9b3e25704/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=1ceb5ff350b39174c1329415944bd1d9b3e25704", "patch": "@@ -401,6 +401,9 @@ yylex ()\n       break;\n \n     case TYPESPEC:\n+      /* If this provides a type for us, then revert lexical\n+\t state to standard state.  */\n+      looking_for_typename = 0;\n       consume_token ();\n       break;\n "}]}