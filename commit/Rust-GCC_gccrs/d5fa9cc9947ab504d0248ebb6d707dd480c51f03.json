{"sha": "d5fa9cc9947ab504d0248ebb6d707dd480c51f03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVmYTljYzk5NDdhYjUwNGQwMjQ4ZWJiNmQ3MDdkZDQ4MGM1MWYwMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-12-16T18:46:49Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-12-16T18:46:49Z"}, "message": "predict.h (PROB_LIKELY): Fix the value.\n\n\t* predict.h (PROB_LIKELY): Fix the value.\n\t* internal-fn.c (ubsan_expand_si_overflow_mul_check): Add support\n\tfor overflow checking for modes without 2xwider supported mode,\n\tif the mode has 2xnarrower mode.\n\n\t* c-c++-common/ubsan/overflow-mul-3.c: New test.\n\t* c-c++-common/ubsan/overflow-mul-4.c: New test.\n\nFrom-SVN: r206026", "tree": {"sha": "30e2cba74403c48113ac6fb7b1f8dc931d074c7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30e2cba74403c48113ac6fb7b1f8dc931d074c7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5fa9cc9947ab504d0248ebb6d707dd480c51f03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5fa9cc9947ab504d0248ebb6d707dd480c51f03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5fa9cc9947ab504d0248ebb6d707dd480c51f03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5fa9cc9947ab504d0248ebb6d707dd480c51f03/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "97286431624c245b32ae05c33e9af2876eda55ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97286431624c245b32ae05c33e9af2876eda55ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97286431624c245b32ae05c33e9af2876eda55ee"}], "stats": {"total": 426, "additions": 423, "deletions": 3}, "files": [{"sha": "1cf51b49db255368b9ee264137f32fad336d4d38", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa9cc9947ab504d0248ebb6d707dd480c51f03/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa9cc9947ab504d0248ebb6d707dd480c51f03/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d5fa9cc9947ab504d0248ebb6d707dd480c51f03", "patch": "@@ -1,5 +1,10 @@\n 2013-12-16  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* predict.h (PROB_LIKELY): Fix the value.\n+\t* internal-fn.c (ubsan_expand_si_overflow_mul_check): Add support\n+\tfor overflow checking for modes without 2xwider supported mode,\n+\tif the mode has 2xnarrower mode.\n+\n \t* internal-fn.c: Include stringpool.h and tree-ssanames.h.\n \t(ubsan_expand_si_overflow_addsub_check): In the generic expansion,\n \ttry to improve generated code if one of the arguments is constant"}, {"sha": "30d8c5357318038e542c9e8e786fcef23e273717", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 289, "deletions": 2, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa9cc9947ab504d0248ebb6d707dd480c51f03/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa9cc9947ab504d0248ebb6d707dd480c51f03/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=d5fa9cc9947ab504d0248ebb6d707dd480c51f03", "patch": "@@ -436,6 +436,8 @@ ubsan_expand_si_overflow_mul_check (gimple stmt)\n   if (icode == CODE_FOR_nothing)\n     {\n       struct separate_ops ops;\n+      enum machine_mode hmode\n+\t= mode_for_size (GET_MODE_PRECISION (mode) / 2, MODE_INT, 1);\n       ops.op0 = arg0;\n       ops.op1 = arg1;\n       ops.op2 = NULL_TREE;\n@@ -462,10 +464,295 @@ ubsan_expand_si_overflow_mul_check (gimple stmt)\n \t  emit_cmp_and_jump_insns (signbit, hipart, EQ, NULL_RTX, mode,\n \t\t\t\t   false, done_label, PROB_VERY_LIKELY);\n \t}\n+      else if (hmode != BLKmode\n+\t       && 2 * GET_MODE_PRECISION (hmode) == GET_MODE_PRECISION (mode))\n+\t{\n+\t  rtx large_op0 = gen_label_rtx ();\n+\t  rtx small_op0_large_op1 = gen_label_rtx ();\n+\t  rtx one_small_one_large = gen_label_rtx ();\n+\t  rtx both_ops_large = gen_label_rtx ();\n+\t  rtx after_hipart_neg = gen_label_rtx ();\n+\t  rtx after_lopart_neg = gen_label_rtx ();\n+\t  rtx do_overflow = gen_label_rtx ();\n+\t  rtx hipart_different = gen_label_rtx ();\n+\n+\t  int hprec = GET_MODE_PRECISION (hmode);\n+\t  rtx hipart0 = expand_shift (RSHIFT_EXPR, mode, op0, hprec,\n+\t\t\t\t      NULL_RTX, 0);\n+\t  hipart0 = gen_lowpart (hmode, hipart0);\n+\t  rtx lopart0 = gen_lowpart (hmode, op0);\n+\t  rtx signbit0 = expand_shift (RSHIFT_EXPR, hmode, lopart0, hprec - 1,\n+\t\t\t\t       NULL_RTX, 0);\n+\t  rtx hipart1 = expand_shift (RSHIFT_EXPR, mode, op1, hprec,\n+\t\t\t\t      NULL_RTX, 0);\n+\t  hipart1 = gen_lowpart (hmode, hipart1);\n+\t  rtx lopart1 = gen_lowpart (hmode, op1);\n+\t  rtx signbit1 = expand_shift (RSHIFT_EXPR, hmode, lopart1, hprec - 1,\n+\t\t\t\t       NULL_RTX, 0);\n+\n+\t  res = gen_reg_rtx (mode);\n+\n+\t  /* True if op0 resp. op1 are known to be in the range of\n+\t     halfstype.  */\n+\t  bool op0_small_p = false;\n+\t  bool op1_small_p = false;\n+\t  /* True if op0 resp. op1 are known to have all zeros or all ones\n+\t     in the upper half of bits, but are not known to be\n+\t     op{0,1}_small_p.  */\n+\t  bool op0_medium_p = false;\n+\t  bool op1_medium_p = false;\n+\t  /* -1 if op{0,1} is known to be negative, 0 if it is known to be\n+\t     nonnegative, 1 if unknown.  */\n+\t  int op0_sign = 1;\n+\t  int op1_sign = 1;\n+\n+\t  if (TREE_CODE (arg0) == SSA_NAME)\n+\t    {\n+\t      double_int arg0_min, arg0_max;\n+\t      if (get_range_info (arg0, &arg0_min, &arg0_max) == VR_RANGE)\n+\t\t{\n+\t\t  if (arg0_max.sle (double_int::max_value (hprec, false))\n+\t\t      && double_int::min_value (hprec, false).sle (arg0_min))\n+\t\t    op0_small_p = true;\n+\t\t  else if (arg0_max.sle (double_int::max_value (hprec, true))\n+\t\t\t   && (~double_int::max_value (hprec,\n+\t\t\t\t\t\t       true)).sle (arg0_min))\n+\t\t    op0_medium_p = true;\n+\t\t  if (!arg0_min.is_negative ())\n+\t\t    op0_sign = 0;\n+\t\t  else if (arg0_max.is_negative ())\n+\t\t    op0_sign = -1;\n+\t\t}\n+\t    }\n+\t  if (TREE_CODE (arg1) == SSA_NAME)\n+\t    {\n+\t      double_int arg1_min, arg1_max;\n+\t      if (get_range_info (arg1, &arg1_min, &arg1_max) == VR_RANGE)\n+\t\t{\n+\t\t  if (arg1_max.sle (double_int::max_value (hprec, false))\n+\t\t      && double_int::min_value (hprec, false).sle (arg1_min))\n+\t\t    op1_small_p = true;\n+\t\t  else if (arg1_max.sle (double_int::max_value (hprec, true))\n+\t\t\t   && (~double_int::max_value (hprec,\n+\t\t\t\t\t\t       true)).sle (arg1_min))\n+\t\t    op1_medium_p = true;\n+\t\t  if (!arg1_min.is_negative ())\n+\t\t    op1_sign = 0;\n+\t\t  else if (arg1_max.is_negative ())\n+\t\t    op1_sign = -1;\n+\t\t}\n+\t    }\n+\n+\t  int smaller_sign = 1;\n+\t  int larger_sign = 1;\n+\t  if (op0_small_p)\n+\t    {\n+\t      smaller_sign = op0_sign;\n+\t      larger_sign = op1_sign;\n+\t    }\n+\t  else if (op1_small_p)\n+\t    {\n+\t      smaller_sign = op1_sign;\n+\t      larger_sign = op0_sign;\n+\t    }\n+\t  else if (op0_sign == op1_sign)\n+\t    {\n+\t      smaller_sign = op0_sign;\n+\t      larger_sign = op0_sign;\n+\t    }\n+\n+\t  if (!op0_small_p)\n+\t    emit_cmp_and_jump_insns (signbit0, hipart0, NE, NULL_RTX, hmode,\n+\t\t\t\t     false, large_op0, PROB_UNLIKELY);\n+\n+\t  if (!op1_small_p)\n+\t    emit_cmp_and_jump_insns (signbit1, hipart1, NE, NULL_RTX, hmode,\n+\t\t\t\t     false, small_op0_large_op1,\n+\t\t\t\t     PROB_UNLIKELY);\n+\n+\t  /* If both op0 and op1 are sign extended from hmode to mode,\n+\t     the multiplication will never overflow.  We can do just one\n+\t     hmode x hmode => mode widening multiplication.  */\n+\t  if (GET_CODE (lopart0) == SUBREG)\n+\t    {\n+\t      SUBREG_PROMOTED_VAR_P (lopart0) = 1;\n+\t      SUBREG_PROMOTED_UNSIGNED_SET (lopart0, 0);\n+\t    }\n+\t  if (GET_CODE (lopart1) == SUBREG)\n+\t    {\n+\t      SUBREG_PROMOTED_VAR_P (lopart1) = 1;\n+\t      SUBREG_PROMOTED_UNSIGNED_SET (lopart1, 0);\n+\t    }\n+\t  tree halfstype = build_nonstandard_integer_type (hprec, 0);\n+\t  ops.op0 = make_tree (halfstype, lopart0);\n+\t  ops.op1 = make_tree (halfstype, lopart1);\n+\t  ops.code = WIDEN_MULT_EXPR;\n+\t  ops.type = TREE_TYPE (arg0);\n+\t  rtx thisres\n+\t    = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n+\t  emit_move_insn (res, thisres);\n+\t  emit_jump (done_label);\n+\n+\t  emit_label (small_op0_large_op1);\n+\n+\t  /* If op0 is sign extended from hmode to mode, but op1 is not,\n+\t     just swap the arguments and handle it as op1 sign extended,\n+\t     op0 not.  */\n+\t  rtx larger = gen_reg_rtx (mode);\n+\t  rtx hipart = gen_reg_rtx (hmode);\n+\t  rtx lopart = gen_reg_rtx (hmode);\n+\t  emit_move_insn (larger, op1);\n+\t  emit_move_insn (hipart, hipart1);\n+\t  emit_move_insn (lopart, lopart0);\n+\t  emit_jump (one_small_one_large);\n+\n+\t  emit_label (large_op0);\n+\n+\t  if (!op1_small_p)\n+\t    emit_cmp_and_jump_insns (signbit1, hipart1, NE, NULL_RTX, hmode,\n+\t\t\t\t     false, both_ops_large, PROB_UNLIKELY);\n+\n+\t  /* If op1 is sign extended from hmode to mode, but op0 is not,\n+\t     prepare larger, hipart and lopart pseudos and handle it together\n+\t     with small_op0_large_op1.  */\n+\t  emit_move_insn (larger, op0);\n+\t  emit_move_insn (hipart, hipart0);\n+\t  emit_move_insn (lopart, lopart1);\n+\n+\t  emit_label (one_small_one_large);\n+\n+\t  /* lopart is the low part of the operand that is sign extended\n+\t     to mode, larger is the the other operand, hipart is the\n+\t     high part of larger and lopart0 and lopart1 are the low parts\n+\t     of both operands.\n+\t     We perform lopart0 * lopart1 and lopart * hipart widening\n+\t     multiplications.  */\n+\t  tree halfutype = build_nonstandard_integer_type (hprec, 1);\n+\t  ops.op0 = make_tree (halfutype, lopart0);\n+\t  ops.op1 = make_tree (halfutype, lopart1);\n+\t  rtx lo0xlo1\n+\t    = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n+\n+\t  ops.op0 = make_tree (halfutype, lopart);\n+\t  ops.op1 = make_tree (halfutype, hipart);\n+\t  rtx loxhi = gen_reg_rtx (mode);\n+\t  rtx tem = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n+\t  emit_move_insn (loxhi, tem);\n+\n+\t  /* if (hipart < 0) loxhi -= lopart << (bitsize / 2);  */\n+\t  if (larger_sign == 0)\n+\t    emit_jump (after_hipart_neg);\n+\t  else if (larger_sign != -1)\n+\t    emit_cmp_and_jump_insns (hipart, const0_rtx, GE, NULL_RTX, hmode,\n+\t\t\t\t     false, after_hipart_neg, PROB_EVEN);\n+\n+\t  tem = expand_shift (LSHIFT_EXPR, mode, lopart, hprec, NULL_RTX, 1);\n+\t  tem = expand_simple_binop (mode, MINUS, loxhi, tem, NULL_RTX,\n+\t\t\t\t     1, OPTAB_DIRECT);\n+\t  emit_move_insn (loxhi, tem);\n+\n+\t  emit_label (after_hipart_neg);\n+\n+\t  /* if (lopart < 0) loxhi -= larger;  */\n+\t  if (smaller_sign == 0)\n+\t    emit_jump (after_lopart_neg);\n+\t  else if (smaller_sign != -1)\n+\t    emit_cmp_and_jump_insns (lopart, const0_rtx, GE, NULL_RTX, hmode,\n+\t\t\t\t     false, after_lopart_neg, PROB_EVEN);\n+\n+\t  tem = expand_simple_binop (mode, MINUS, loxhi, larger, NULL_RTX,\n+\t\t\t\t     1, OPTAB_DIRECT);\n+\t  emit_move_insn (loxhi, tem);\n+\n+\t  emit_label (after_lopart_neg);\n+\n+\t  /* loxhi += (uns) lo0xlo1 >> (bitsize / 2);  */\n+\t  tem = expand_shift (RSHIFT_EXPR, mode, lo0xlo1, hprec, NULL_RTX, 1);\n+\t  tem = expand_simple_binop (mode, PLUS, loxhi, tem, NULL_RTX,\n+\t\t\t\t     1, OPTAB_DIRECT);\n+\t  emit_move_insn (loxhi, tem);\n+\n+\t  /* if (loxhi >> (bitsize / 2)\n+\t\t == (hmode) loxhi >> (bitsize / 2 - 1))  */\n+\t  rtx hipartloxhi = expand_shift (RSHIFT_EXPR, mode, loxhi, hprec,\n+\t\t\t\t\t  NULL_RTX, 0);\n+\t  hipartloxhi = gen_lowpart (hmode, hipartloxhi);\n+\t  rtx lopartloxhi = gen_lowpart (hmode, loxhi);\n+\t  rtx signbitloxhi = expand_shift (RSHIFT_EXPR, hmode, lopartloxhi,\n+\t\t\t\t\t   hprec - 1, NULL_RTX, 0);\n+\n+\t  emit_cmp_and_jump_insns (signbitloxhi, hipartloxhi, NE, NULL_RTX,\n+\t\t\t\t   hmode, false, do_overflow,\n+\t\t\t\t   PROB_VERY_UNLIKELY);\n+\n+\t  /* res = (loxhi << (bitsize / 2)) | (hmode) lo0xlo1;  */\n+\t  rtx loxhishifted = expand_shift (LSHIFT_EXPR, mode, loxhi, hprec,\n+\t\t\t\t\t   NULL_RTX, 1);\n+\t  tem = convert_modes (mode, hmode, gen_lowpart (hmode, lo0xlo1), 1);\n+\n+\t  tem = expand_simple_binop (mode, IOR, loxhishifted, tem, res,\n+\t\t\t\t     1, OPTAB_DIRECT);\n+\t  if (tem != res)\n+\t    emit_move_insn (res, tem);\n+\t  emit_jump (done_label);\n+\n+\t  emit_label (both_ops_large);\n+\n+\t  /* If both operands are large (not sign extended from hmode),\n+\t     then perform the full multiplication which will be the result\n+\t     of the operation.  The only cases which don't overflow are\n+\t     some cases where both hipart0 and highpart1 are 0 or -1.  */\n+\t  ops.code = MULT_EXPR;\n+\t  ops.op0 = make_tree (TREE_TYPE (arg0), op0);\n+\t  ops.op1 = make_tree (TREE_TYPE (arg0), op1);\n+\t  tem = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n+\t  emit_move_insn (res, tem);\n+\n+\t  if (!op0_medium_p)\n+\t    {\n+\t      tem = expand_simple_binop (hmode, PLUS, hipart0, const1_rtx,\n+\t\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+\t      emit_cmp_and_jump_insns (tem, const1_rtx, GTU, NULL_RTX, hmode,\n+\t\t\t\t       true, do_error, PROB_VERY_UNLIKELY);\n+\t    }\n+\n+\t  if (!op1_medium_p)\n+\t    {\n+\t      tem = expand_simple_binop (hmode, PLUS, hipart1, const1_rtx,\n+\t\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+\t      emit_cmp_and_jump_insns (tem, const1_rtx, GTU, NULL_RTX, hmode,\n+\t\t\t\t       true, do_error, PROB_VERY_UNLIKELY);\n+\t    }\n+\n+\t  /* At this point hipart{0,1} are both in [-1, 0].  If they are the\n+\t     same, overflow happened if res is negative, if they are different,\n+\t     overflow happened if res is positive.  */\n+\t  if (op0_sign != 1 && op1_sign != 1 && op0_sign != op1_sign)\n+\t    emit_jump (hipart_different);\n+\t  else if (op0_sign == 1 || op1_sign == 1)\n+\t    emit_cmp_and_jump_insns (hipart0, hipart1, NE, NULL_RTX, hmode,\n+\t\t\t\t     true, hipart_different, PROB_EVEN);\n+\n+\t  emit_cmp_and_jump_insns (res, const0_rtx, LT, NULL_RTX, mode, false,\n+\t\t\t\t   do_error, PROB_VERY_UNLIKELY);\n+\t  emit_jump (done_label);\n+\n+\t  emit_label (hipart_different);\n+\n+\t  emit_cmp_and_jump_insns (res, const0_rtx, GE, NULL_RTX, mode, false,\n+\t\t\t\t   do_error, PROB_VERY_UNLIKELY);\n+\t  emit_jump (done_label);\n+\n+\t  emit_label (do_overflow);\n+\n+\t  /* Overflow, do full multiplication and fallthru into do_error.  */\n+\t  ops.op0 = make_tree (TREE_TYPE (arg0), op0);\n+\t  ops.op1 = make_tree (TREE_TYPE (arg0), op1);\n+\t  tem = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n+\t  emit_move_insn (res, tem);\n+\t}\n       else\n \t{\n-\t  /* For now we don't instrument this.  See __mulvDI3 in libgcc2.c\n-\t     for what could be done.  */\n \t  ops.code = MULT_EXPR;\n \t  ops.type = TREE_TYPE (arg0);\n \t  res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);"}, {"sha": "125245e73f4f5ca5b7cdfe184ea84adaa4766c7c", "filename": "gcc/predict.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa9cc9947ab504d0248ebb6d707dd480c51f03/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa9cc9947ab504d0248ebb6d707dd480c51f03/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=d5fa9cc9947ab504d0248ebb6d707dd480c51f03", "patch": "@@ -28,7 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #define PROB_VERY_LIKELY\t(REG_BR_PROB_BASE - PROB_VERY_UNLIKELY)\n #define PROB_ALWAYS\t\t(REG_BR_PROB_BASE)\n #define PROB_UNLIKELY           (REG_BR_PROB_BASE / 5 - 1)\n-#define PROB_LIKELY             (PROB_ALWAYS - PROB_VERY_LIKELY)\n+#define PROB_LIKELY             (REG_BR_PROB_BASE - PROB_UNLIKELY)\n \n #define DEF_PREDICTOR(ENUM, NAME, HITRATE, FLAGS) ENUM,\n enum br_predictor"}, {"sha": "79047575c5522550f44de3a528125be9e732628b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa9cc9947ab504d0248ebb6d707dd480c51f03/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa9cc9947ab504d0248ebb6d707dd480c51f03/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d5fa9cc9947ab504d0248ebb6d707dd480c51f03", "patch": "@@ -1,5 +1,8 @@\n 2013-12-16  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* c-c++-common/ubsan/overflow-mul-3.c: New test.\n+\t* c-c++-common/ubsan/overflow-mul-4.c: New test.\n+\n \tPR libgomp/59337\n \t* gfortran.dg/gomp/pr59337.f90: New test.\n "}, {"sha": "93596417d4ba799f190a4047c0ffd2165420274e", "filename": "gcc/testsuite/c-c++-common/ubsan/overflow-mul-3.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa9cc9947ab504d0248ebb6d707dd480c51f03/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-mul-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa9cc9947ab504d0248ebb6d707dd480c51f03/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-mul-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-mul-3.c?ref=d5fa9cc9947ab504d0248ebb6d707dd480c51f03", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=signed-integer-overflow\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */\n+\n+__attribute__((noinline, noclone)) long long\n+mul (long long x, long long y)\n+{\n+  return x * y;\n+}\n+\n+long long tab[] = {\n+  0x7fffffffLL, 0x7fffffffLL, 0x3fffffff00000001LL,\n+  -0x80000000LL, -0x80000000LL, 0x4000000000000000LL,\n+  0x7fffffffLL, -0x80000000LL, -0x3fffffff80000000LL,\n+  -0x80000000LL, 0x7fffffffLL, -0x3fffffff80000000LL,\n+  3LL, 5LL, 15LL,\n+  -3LL, -9LL, 27LL,\n+  6LL, -7LL, -42LL,\n+  -12LL, 13LL, -156LL,\n+  0x1555555555555555LL, 6LL, 0x7ffffffffffffffeLL,\n+  -0x1555555555555555LL, -6LL, 0x7ffffffffffffffeLL,\n+  0x1555555555555555LL, -6LL, -0x7ffffffffffffffeLL,\n+  -0x1555555555555555LL, 6LL, -0x7ffffffffffffffeLL,\n+  0x81234567LL, 0xfdbe971fLL, 0x7fffffffbea72879LL,\n+  -0x81234567LL, -0xfdbe971fLL, 0x7fffffffbea72879LL,\n+  0x81234567LL, -0xfdbe971fLL, -0x7fffffffbea72879LL,\n+  -0x81234567LL, 0xfdbe971fLL, -0x7fffffffbea72879LL\n+};\n+\n+int\n+main ()\n+{\n+  unsigned int i;\n+  for (i = 0; i < sizeof (tab) / sizeof (long long); i += 3)\n+    if (mul (tab[i], tab[i + 1]) != tab[i + 2]\n+        || mul (tab[i + 1], tab[i]) != tab[i + 2])\n+      __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "923c14585eb1ffe79fb0ff088a9d3c08224278e6", "filename": "gcc/testsuite/c-c++-common/ubsan/overflow-mul-4.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa9cc9947ab504d0248ebb6d707dd480c51f03/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-mul-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa9cc9947ab504d0248ebb6d707dd480c51f03/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-mul-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-mul-4.c?ref=d5fa9cc9947ab504d0248ebb6d707dd480c51f03", "patch": "@@ -0,0 +1,86 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=signed-integer-overflow\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */\n+\n+int\n+main ()\n+{\n+#define MUL_WITH_CHECK(xv, yv, zv) \\\n+  do {\t\t\t\t\t\t\\\n+    long long x = xv;\t\t\t\t\\\n+    long long y = yv;\t\t\t\t\\\n+    long long z;\t\t\t\t\\\n+    asm (\"\" : \"+g\" (x));\t\t\t\\\n+    asm (\"\" : \"+g\" (y));\t\t\t\\\n+    z = x * y;\t\t\t\t\t\\\n+    asm (\"\" : \"+g\" (z));\t\t\t\\\n+    if (z != zv)\t\t\t\t\\\n+      __builtin_abort ();\t\t\t\\\n+  } while (0)\n+  MUL_WITH_CHECK (0x1555555555555556LL, 6LL, -0x7ffffffffffffffcLL);\n+  MUL_WITH_CHECK (-0x1555555555555556LL, -6LL, -0x7ffffffffffffffcLL);\n+  MUL_WITH_CHECK (0x1555555555555556LL, -6LL, 0x7ffffffffffffffcLL);\n+  MUL_WITH_CHECK (-0x1555555555555556LL, 6LL, 0x7ffffffffffffffcLL);\n+  MUL_WITH_CHECK (0x81234568LL, 0xfdbe971fLL, -0x7fffffff439a4068LL);\n+  MUL_WITH_CHECK (-0x81234568LL, -0xfdbe971fLL, -0x7fffffff439a4068LL);\n+  MUL_WITH_CHECK (0x81234568LL, -0xfdbe971fLL, 0x7fffffff439a4068LL);\n+  MUL_WITH_CHECK (-0x81234568LL, 0xfdbe971fLL, 0x7fffffff439a4068LL);\n+  MUL_WITH_CHECK (0x1555555555555555LL, 7LL, -0x6aaaaaaaaaaaaaadLL);\n+  MUL_WITH_CHECK (-0x1555555555555555LL, -7LL, -0x6aaaaaaaaaaaaaadLL);\n+  MUL_WITH_CHECK (0x1555555555555555LL, -7LL, 0x6aaaaaaaaaaaaaadLL);\n+  MUL_WITH_CHECK (-0x1555555555555555LL, 7LL, 0x6aaaaaaaaaaaaaadLL);\n+  MUL_WITH_CHECK (0x81234567LL, 0xfdbe9720LL, -0x7fffffffc0359220LL);\n+  MUL_WITH_CHECK (-0x81234567LL, -0xfdbe9720LL, -0x7fffffffc0359220LL);\n+  MUL_WITH_CHECK (0x81234567LL, -0xfdbe9720LL, 0x7fffffffc0359220LL);\n+  MUL_WITH_CHECK (-0x81234567LL, 0xfdbe9720LL, 0x7fffffffc0359220LL);\n+  MUL_WITH_CHECK (6LL, 0x1555555555555556LL, -0x7ffffffffffffffcLL);\n+  MUL_WITH_CHECK (-6LL, -0x1555555555555556LL, -0x7ffffffffffffffcLL);\n+  MUL_WITH_CHECK (-6LL, 0x1555555555555556LL, 0x7ffffffffffffffcLL);\n+  MUL_WITH_CHECK (6LL, -0x1555555555555556LL, 0x7ffffffffffffffcLL);\n+  MUL_WITH_CHECK (0xfdbe971fLL, 0x81234568LL, -0x7fffffff439a4068LL);\n+  MUL_WITH_CHECK (-0xfdbe971fLL, -0x81234568LL, -0x7fffffff439a4068LL);\n+  MUL_WITH_CHECK (-0xfdbe971fLL, 0x81234568LL, 0x7fffffff439a4068LL);\n+  MUL_WITH_CHECK (0xfdbe971fLL, -0x81234568LL, 0x7fffffff439a4068LL);\n+  MUL_WITH_CHECK (7LL, 0x1555555555555555LL, -0x6aaaaaaaaaaaaaadLL);\n+  MUL_WITH_CHECK (-7LL, -0x1555555555555555LL, -0x6aaaaaaaaaaaaaadLL);\n+  MUL_WITH_CHECK (-7LL, 0x1555555555555555LL, 0x6aaaaaaaaaaaaaadLL);\n+  MUL_WITH_CHECK (7LL, -0x1555555555555555LL, 0x6aaaaaaaaaaaaaadLL);\n+  MUL_WITH_CHECK (0xfdbe9720LL, 0x81234567LL, -0x7fffffffc0359220LL);\n+  MUL_WITH_CHECK (-0xfdbe9720LL, -0x81234567LL, -0x7fffffffc0359220LL);\n+  MUL_WITH_CHECK (-0xfdbe9720LL, 0x81234567LL, 0x7fffffffc0359220LL);\n+  MUL_WITH_CHECK (0xfdbe9720LL, -0x81234567LL, 0x7fffffffc0359220LL);\n+  return 0;\n+}\n+\n+/* { dg-output \"overflow-mul-4.c:20:\\[^\\n\\r]*signed integer overflow: 1537228672809129302 \\\\* 6 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:21:\\[^\\n\\r]*signed integer overflow: -1537228672809129302 \\\\* -6 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:22:\\[^\\n\\r]*signed integer overflow: 1537228672809129302 \\\\* -6 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:23:\\[^\\n\\r]*signed integer overflow: -1537228672809129302 \\\\* 6 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:24:\\[^\\n\\r]*signed integer overflow: 2166572392 \\\\* 4257126175 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:25:\\[^\\n\\r]*signed integer overflow: -2166572392 \\\\* -4257126175 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:26:\\[^\\n\\r]*signed integer overflow: 2166572392 \\\\* -4257126175 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:27:\\[^\\n\\r]*signed integer overflow: -2166572392 \\\\* 4257126175 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:28:\\[^\\n\\r]*signed integer overflow: 1537228672809129301 \\\\* 7 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:29:\\[^\\n\\r]*signed integer overflow: -1537228672809129301 \\\\* -7 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:30:\\[^\\n\\r]*signed integer overflow: 1537228672809129301 \\\\* -7 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:31:\\[^\\n\\r]*signed integer overflow: -1537228672809129301 \\\\* 7 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:32:\\[^\\n\\r]*signed integer overflow: 2166572391 \\\\* 4257126176 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:33:\\[^\\n\\r]*signed integer overflow: -2166572391 \\\\* -4257126176 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:34:\\[^\\n\\r]*signed integer overflow: 2166572391 \\\\* -4257126176 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:35:\\[^\\n\\r]*signed integer overflow: -2166572391 \\\\* 4257126176 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:36:\\[^\\n\\r]*signed integer overflow: 6 \\\\* 1537228672809129302 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:37:\\[^\\n\\r]*signed integer overflow: -6 \\\\* -1537228672809129302 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:38:\\[^\\n\\r]*signed integer overflow: -6 \\\\* 1537228672809129302 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:39:\\[^\\n\\r]*signed integer overflow: 6 \\\\* -1537228672809129302 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:40:\\[^\\n\\r]*signed integer overflow: 4257126175 \\\\* 2166572392 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:41:\\[^\\n\\r]*signed integer overflow: -4257126175 \\\\* -2166572392 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:42:\\[^\\n\\r]*signed integer overflow: -4257126175 \\\\* 2166572392 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:43:\\[^\\n\\r]*signed integer overflow: 4257126175 \\\\* -2166572392 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:44:\\[^\\n\\r]*signed integer overflow: 7 \\\\* 1537228672809129301 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:45:\\[^\\n\\r]*signed integer overflow: -7 \\\\* -1537228672809129301 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:46:\\[^\\n\\r]*signed integer overflow: -7 \\\\* 1537228672809129301 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:47:\\[^\\n\\r]*signed integer overflow: 7 \\\\* -1537228672809129301 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:48:\\[^\\n\\r]*signed integer overflow: 4257126176 \\\\* 2166572391 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:49:\\[^\\n\\r]*signed integer overflow: -4257126176 \\\\* -2166572391 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:50:\\[^\\n\\r]*signed integer overflow: -4257126176 \\\\* 2166572391 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*overflow-mul-4.c:51:\\[^\\n\\r]*signed integer overflow: 4257126176 \\\\* -2166572391 cannot be represented in type 'long long int'(\\n|\\r\\n|\\r)\" } */"}]}