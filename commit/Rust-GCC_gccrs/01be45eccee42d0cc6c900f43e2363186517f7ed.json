{"sha": "01be45eccee42d0cc6c900f43e2363186517f7ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFiZTQ1ZWNjZWU0MmQwY2M2YzkwMGY0M2UyMzYzMTg2NTE3ZjdlZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-01-05T11:03:22Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-01-05T11:03:22Z"}, "message": "vect: Fix missing alias checks for 128-bit SVE [PR98371]\n\nOn AArch64, the vectoriser tries various ways of vectorising with both\nSVE and Advanced SIMD and picks the best one.  All other things being\nequal, it prefers earlier attempts over later attempts.\n\nThe way this works currently is that, once it has a successful\nvectorisation attempt A, it analyses all other attempts as epilogue\nloops of A:\n\n      /* When pick_lowest_cost_p is true, we should in principle iterate\n\t over all the loop_vec_infos that LOOP_VINFO could replace and\n\t try to vectorize LOOP_VINFO under the same conditions.\n\t E.g. when trying to replace an epilogue loop, we should vectorize\n\t LOOP_VINFO as an epilogue loop with the same VF limit.  When trying\n\t to replace the main loop, we should vectorize LOOP_VINFO as a main\n\t loop too.\n\n\t However, autovectorize_vector_modes is usually sorted as follows:\n\n\t - Modes that naturally produce lower VFs usually follow modes that\n\t   naturally produce higher VFs.\n\n\t - When modes naturally produce the same VF, maskable modes\n\t   usually follow unmaskable ones, so that the maskable mode\n\t   can be used to vectorize the epilogue of the unmaskable mode.\n\n\t This order is preferred because it leads to the maximum\n\t epilogue vectorization opportunities.  Targets should only use\n\t a different order if they want to make wide modes available while\n\t disparaging them relative to earlier, smaller modes.  The assumption\n\t in that case is that the wider modes are more expensive in some\n\t way that isn't reflected directly in the costs.\n\n\t There should therefore be few interesting cases in which\n\t LOOP_VINFO fails when treated as an epilogue loop, succeeds when\n\t treated as a standalone loop, and ends up being genuinely cheaper\n\t than FIRST_LOOP_VINFO.  */\n\nHowever, the vectoriser can normally elide alias checks for epilogue\nloops, on the basis that the main loop should do them instead.\nConverting an epilogue loop to a main loop can therefore cause the alias\nchecks to be skipped.  (It probably also unfairly penalises the original\nloop in the cost comparison, given that one loop will have alias checks\nand the other won't.)\n\nAs the comment says, we should in principle analyse each vector mode\ntwice: once as a main loop and once as an epilogue.  However, doing\nthat up-front would be quite expensive.  This patch instead goes for a\ncompromise: if an epilogue loop for mode M2 seems better than a main\nloop for mode M1, re-analyse with M2 as the main loop.\n\nThe patch fixes dg.torture.exp=pr69719.c when testing with\n-msve-vector-bits=128.\n\ngcc/\n\tPR tree-optimization/98371\n\t* tree-vect-loop.c (vect_reanalyze_as_main_loop): New function.\n\t(vect_analyze_loop): If an epilogue loop appears to be cheaper\n\tthan the main loop, re-analyze it as a main loop before adopting\n\tit as a main loop.", "tree": {"sha": "6f7c11daffb31f26b5ef8e5934e1ef80f06b2bf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f7c11daffb31f26b5ef8e5934e1ef80f06b2bf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01be45eccee42d0cc6c900f43e2363186517f7ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01be45eccee42d0cc6c900f43e2363186517f7ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01be45eccee42d0cc6c900f43e2363186517f7ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01be45eccee42d0cc6c900f43e2363186517f7ed/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a20893cf6b95f60f5319b2196621acc65180125c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a20893cf6b95f60f5319b2196621acc65180125c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a20893cf6b95f60f5319b2196621acc65180125c"}], "stats": {"total": 61, "additions": 58, "deletions": 3}, "files": [{"sha": "830531f48b879ac926bd981ecab8c5a112ee89a8", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01be45eccee42d0cc6c900f43e2363186517f7ed/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01be45eccee42d0cc6c900f43e2363186517f7ed/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=01be45eccee42d0cc6c900f43e2363186517f7ed", "patch": "@@ -2850,6 +2850,45 @@ vect_joust_loop_vinfos (loop_vec_info new_loop_vinfo,\n   return true;\n }\n \n+/* If LOOP_VINFO is already a main loop, return it unmodified.  Otherwise\n+   try to reanalyze it as a main loop.  Return the loop_vinfo on success\n+   and null on failure.  */\n+\n+static loop_vec_info\n+vect_reanalyze_as_main_loop (loop_vec_info loop_vinfo, unsigned int *n_stmts)\n+{\n+  if (!LOOP_VINFO_EPILOGUE_P (loop_vinfo))\n+    return loop_vinfo;\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"***** Reanalyzing as a main loop with vector mode %s\\n\",\n+\t\t     GET_MODE_NAME (loop_vinfo->vector_mode));\n+\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  vec_info_shared *shared = loop_vinfo->shared;\n+  opt_loop_vec_info main_loop_vinfo = vect_analyze_loop_form (loop, shared);\n+  gcc_assert (main_loop_vinfo);\n+\n+  main_loop_vinfo->vector_mode = loop_vinfo->vector_mode;\n+\n+  bool fatal = false;\n+  bool res = vect_analyze_loop_2 (main_loop_vinfo, fatal, n_stmts);\n+  loop->aux = NULL;\n+  if (!res)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"***** Failed to analyze main loop with vector\"\n+\t\t\t \" mode %s\\n\",\n+\t\t\t GET_MODE_NAME (loop_vinfo->vector_mode));\n+      delete main_loop_vinfo;\n+      return NULL;\n+    }\n+  LOOP_VINFO_VECTORIZABLE_P (main_loop_vinfo) = 1;\n+  return main_loop_vinfo;\n+}\n+\n /* Function vect_analyze_loop.\n \n    Apply a set of analyses on LOOP, and create a loop_vec_info struct\n@@ -2997,9 +3036,25 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \t      if (vinfos.is_empty ()\n \t\t  && vect_joust_loop_vinfos (loop_vinfo, first_loop_vinfo))\n \t\t{\n-\t\t  delete first_loop_vinfo;\n-\t\t  first_loop_vinfo = opt_loop_vec_info::success (NULL);\n-\t\t  LOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = NULL;\n+\t\t  loop_vec_info main_loop_vinfo\n+\t\t    = vect_reanalyze_as_main_loop (loop_vinfo, &n_stmts);\n+\t\t  if (main_loop_vinfo == loop_vinfo)\n+\t\t    {\n+\t\t      delete first_loop_vinfo;\n+\t\t      first_loop_vinfo = opt_loop_vec_info::success (NULL);\n+\t\t    }\n+\t\t  else if (main_loop_vinfo\n+\t\t\t   && vect_joust_loop_vinfos (main_loop_vinfo,\n+\t\t\t\t\t\t      first_loop_vinfo))\n+\t\t    {\n+\t\t      delete first_loop_vinfo;\n+\t\t      first_loop_vinfo = opt_loop_vec_info::success (NULL);\n+\t\t      delete loop_vinfo;\n+\t\t      loop_vinfo\n+\t\t\t= opt_loop_vec_info::success (main_loop_vinfo);\n+\t\t    }\n+\t\t  else\n+\t\t    delete main_loop_vinfo;\n \t\t}\n \t    }\n "}]}