{"sha": "72e42e26cb760d23353bca4fcee688979d06270a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJlNDJlMjZjYjc2MGQyMzM1M2JjYTRmY2VlNjg4OTc5ZDA2MjcwYQ==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@koffie.nl", "date": "2003-01-25T18:21:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-01-25T18:21:22Z"}, "message": "bitmap.h (BITMAP_WORD): New typedef: fundamental storage type for bitmaps.\n\n        * bitmap.h (BITMAP_WORD): New typedef: fundamental storage\n        type for bitmaps.  Use unsigned long.\n        (nBITMAP_WORD_BITS): New macro.\n        (BITMAP_WORD_BITS): New macro.\n        (rest of file): Use it.\n        * bitmap.c: Use it.\n\nFrom-SVN: r61793", "tree": {"sha": "d3d47f978b9d20aa676221e18721f06cd932e531", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3d47f978b9d20aa676221e18721f06cd932e531"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72e42e26cb760d23353bca4fcee688979d06270a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72e42e26cb760d23353bca4fcee688979d06270a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72e42e26cb760d23353bca4fcee688979d06270a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72e42e26cb760d23353bca4fcee688979d06270a/comments", "author": null, "committer": null, "parents": [{"sha": "bbaab9162a854dd2225f38cb42e0c3666a9462ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbaab9162a854dd2225f38cb42e0c3666a9462ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbaab9162a854dd2225f38cb42e0c3666a9462ec"}], "stats": {"total": 123, "additions": 66, "deletions": 57}, "files": [{"sha": "efffdb45d1ac1fd0917239cf7c67069cd063d3cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72e42e26cb760d23353bca4fcee688979d06270a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72e42e26cb760d23353bca4fcee688979d06270a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72e42e26cb760d23353bca4fcee688979d06270a", "patch": "@@ -1,3 +1,12 @@\n+2003-01-25  Segher Boessenkool  <segher@koffie.nl>\n+\n+\t* bitmap.h (BITMAP_WORD): New typedef: fundamental storage\n+\ttype for bitmaps.  Use unsigned long.\n+\t(nBITMAP_WORD_BITS): New macro.\n+\t(BITMAP_WORD_BITS): New macro.\n+\t(rest of file): Use it.\n+\t* bitmap.c: Use it.\n+\n 2003-01-25  Richard Henderson  <rth@redhat.com>\n \n \t2002-02-19  Robert Lipe  <robertlipe@usa.net>"}, {"sha": "4575f62a531614d58778422207c20b9a229e9599", "filename": "gcc/bitmap.c", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72e42e26cb760d23353bca4fcee688979d06270a/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72e42e26cb760d23353bca4fcee688979d06270a/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=72e42e26cb760d23353bca4fcee688979d06270a", "patch": "@@ -1,5 +1,6 @@\n /* Functions to support general ended bitmaps.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -332,7 +333,7 @@ bitmap_find_bit (head, bit)\n      unsigned int bit;\n {\n   bitmap_element *element;\n-  unsigned HOST_WIDE_INT indx = bit / BITMAP_ELEMENT_ALL_BITS;\n+  unsigned int indx = bit / BITMAP_ELEMENT_ALL_BITS;\n \n   if (head->current == 0\n       || head->indx == indx)\n@@ -371,10 +372,9 @@ bitmap_clear_bit (head, bit)\n \n   if (ptr != 0)\n     {\n-      unsigned bit_num  = bit % (unsigned) HOST_BITS_PER_WIDE_INT;\n-      unsigned word_num = ((bit / (unsigned) HOST_BITS_PER_WIDE_INT)\n-\t\t\t   % BITMAP_ELEMENT_WORDS);\n-      ptr->bits[word_num] &= ~ (((unsigned HOST_WIDE_INT) 1) << bit_num);\n+      unsigned bit_num  = bit % BITMAP_WORD_BITS;\n+      unsigned word_num = bit / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\n+      ptr->bits[word_num] &= ~ (((BITMAP_WORD) 1) << bit_num);\n \n       /* If we cleared the entire word, free up the element */\n       if (bitmap_element_zerop (ptr))\n@@ -390,10 +390,9 @@ bitmap_set_bit (head, bit)\n      int bit;\n {\n   bitmap_element *ptr = bitmap_find_bit (head, bit);\n-  unsigned word_num\n-    = ((bit / (unsigned) HOST_BITS_PER_WIDE_INT) % BITMAP_ELEMENT_WORDS);\n-  unsigned bit_num  = bit % (unsigned) HOST_BITS_PER_WIDE_INT;\n-  unsigned HOST_WIDE_INT bit_val = ((unsigned HOST_WIDE_INT) 1) << bit_num;\n+  unsigned word_num = bit / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\n+  unsigned bit_num  = bit % BITMAP_WORD_BITS;\n+  BITMAP_WORD bit_val = ((BITMAP_WORD) 1) << bit_num;\n \n   if (ptr == 0)\n     {\n@@ -421,9 +420,8 @@ bitmap_bit_p (head, bit)\n   if (ptr == 0)\n     return 0;\n \n-  bit_num = bit % (unsigned) HOST_BITS_PER_WIDE_INT;\n-  word_num\n-    = ((bit / (unsigned) HOST_BITS_PER_WIDE_INT) % BITMAP_ELEMENT_WORDS);\n+  bit_num = bit % BITMAP_WORD_BITS;\n+  word_num = bit / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\n \n   return (ptr->bits[word_num] >> bit_num) & 1;\n }\n@@ -436,7 +434,7 @@ bitmap_first_set_bit (a)\n      bitmap a;\n {\n   bitmap_element *ptr = a->first;\n-  unsigned HOST_WIDE_INT word;\n+  BITMAP_WORD word;\n   unsigned word_num, bit_num;\n \n   if (ptr == NULL)\n@@ -458,10 +456,10 @@ bitmap_first_set_bit (a)\n   bit_num = 0;\n   word = word & -word;\n \n-#if HOST_BITS_PER_WIDE_INT > 64\n+#if nBITMAP_WORD_BITS > 64\n  #error \"Fill out the table.\"\n #endif\n-#if HOST_BITS_PER_WIDE_INT > 32\n+#if nBITMAP_WORD_BITS > 32\n   if ((word & 0xffffffff) == 0)\n     word >>= 32, bit_num += 32;\n #endif\n@@ -477,7 +475,7 @@ bitmap_first_set_bit (a)\n     bit_num += 1;\n \n   return (ptr->indx * BITMAP_ELEMENT_ALL_BITS\n-\t  + word_num * HOST_BITS_PER_WIDE_INT\n+\t  + word_num * BITMAP_WORD_BITS\n \t  + bit_num);\n }\n \n@@ -489,7 +487,7 @@ bitmap_last_set_bit (a)\n      bitmap a;\n {\n   bitmap_element *ptr = a->first;\n-  unsigned HOST_WIDE_INT word;\n+  BITMAP_WORD word;\n   unsigned word_num, bit_num;\n \n   if (ptr == NULL)\n@@ -511,11 +509,11 @@ bitmap_last_set_bit (a)\n   /* Binary search for the last set bit.  */\n \n   bit_num = 0;\n-#if HOST_BITS_PER_WIDE_INT > 64\n+#if nBITMAP_WORD_BITS > 64\n  #error \"Fill out the table.\"\n #endif\n-#if HOST_BITS_PER_WIDE_INT > 32\n-  if (word & ~ (unsigned HOST_WIDE_INT) 0xffffffff)\n+#if nBITMAP_WORD_BITS > 32\n+  if (word & ~(BITMAP_WORD)0xffffffff)\n     word >>= 32, bit_num += 32;\n #endif\n   if (word & 0xffff0000)\n@@ -530,7 +528,7 @@ bitmap_last_set_bit (a)\n     bit_num += 1;\n \n   return (ptr->indx * BITMAP_ELEMENT_ALL_BITS\n-\t  + word_num * HOST_BITS_PER_WIDE_INT\n+\t  + word_num * BITMAP_WORD_BITS\n \t  + bit_num);\n }\n \f\n@@ -560,7 +558,7 @@ bitmap_operation (to, from1, from2, operation)\n #if BITMAP_ELEMENT_WORDS == 2\n #define DOIT(OP)\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\\\n-    unsigned HOST_WIDE_INT t0, t1, f10, f11, f20, f21;\t\\\n+    BITMAP_WORD t0, t1, f10, f11, f20, f21;\t\t\\\n     f10 = from1_tmp->bits[0];\t\t\t\t\\\n     f20 = from2_tmp->bits[0];\t\t\t\t\\\n     t0 = f10 OP f20;\t\t\t\t\t\\\n@@ -575,7 +573,7 @@ bitmap_operation (to, from1, from2, operation)\n #else\n #define DOIT(OP)\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\\\n-    unsigned HOST_WIDE_INT t, f1, f2;\t\t\t\\\n+    BITMAP_WORD t, f1, f2;\t\t\t\t\\\n     int i;\t\t\t\t\t\t\\\n     for (i = 0; i < BITMAP_ELEMENT_WORDS; ++i)\t\t\\\n       {\t\t\t\t\t\t\t\\\n@@ -787,7 +785,7 @@ debug_bitmap_file (file, head)\n \n   for (ptr = head->first; ptr; ptr = ptr->next)\n     {\n-      int i, j, col = 26;\n+      unsigned int i, j, col = 26;\n \n       fprintf (file, \"\\t\");\n       fprintf (file, HOST_PTR_PRINTF, (PTR) ptr);\n@@ -798,7 +796,7 @@ debug_bitmap_file (file, head)\n       fprintf (file, \" indx = %u\\n\\t\\tbits = {\", ptr->indx);\n \n       for (i = 0; i < BITMAP_ELEMENT_WORDS; i++)\n-\tfor (j = 0; j < HOST_BITS_PER_WIDE_INT; j++)\n+\tfor (j = 0; j < BITMAP_WORD_BITS; j++)\n \t  if ((ptr->bits[i] >> j) & 1)\n \t    {\n \t      if (col > 70)\n@@ -808,7 +806,7 @@ debug_bitmap_file (file, head)\n \t\t}\n \n \t      fprintf (file, \" %u\", (ptr->indx * BITMAP_ELEMENT_ALL_BITS\n-\t\t\t\t     + i * HOST_BITS_PER_WIDE_INT + j));\n+\t\t\t\t     + i * BITMAP_WORD_BITS + j));\n \t      col += 4;\n \t    }\n "}, {"sha": "85f8239cce758858ec14795aa806fe969986db72", "filename": "gcc/bitmap.h", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72e42e26cb760d23353bca4fcee688979d06270a/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72e42e26cb760d23353bca4fcee688979d06270a/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=72e42e26cb760d23353bca4fcee688979d06270a", "patch": "@@ -1,5 +1,5 @@\n /* Functions to support general ended bitmaps.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -22,18 +22,26 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef GCC_BITMAP_H\n #define GCC_BITMAP_H\n \n+/* Fundamental storage type for bitmap.  */\n+\n+/* typedef unsigned HOST_WIDE_INT BITMAP_WORD; */\n+/* #define nBITMAP_WORD_BITS HOST_BITS_PER_WIDE_INT */\n+typedef unsigned long BITMAP_WORD;\n+#define nBITMAP_WORD_BITS (CHAR_BIT * SIZEOF_LONG)\n+#define BITMAP_WORD_BITS (unsigned) nBITMAP_WORD_BITS\n+\n /* Number of words to use for each element in the linked list.  */\n \n #ifndef BITMAP_ELEMENT_WORDS\n-#define BITMAP_ELEMENT_WORDS 2\n+#define BITMAP_ELEMENT_WORDS ((128 + nBITMAP_WORD_BITS - 1) / nBITMAP_WORD_BITS)\n #endif\n \n /* Number of bits in each actual element of a bitmap.  We get slightly better\n    code for bit % BITMAP_ELEMENT_ALL_BITS and bit / BITMAP_ELEMENT_ALL_BITS if\n    bits is unsigned, assuming it is a power of 2.  */\n \n #define BITMAP_ELEMENT_ALL_BITS \\\n-  ((unsigned) (BITMAP_ELEMENT_WORDS * HOST_BITS_PER_WIDE_INT))\n+  ((unsigned) (BITMAP_ELEMENT_WORDS * BITMAP_WORD_BITS))\n \n /* Bitmap set element.  We use a linked list to hold only the bits that\n    are set.  This allows for use to grow the bitset dynamically without\n@@ -45,7 +53,7 @@ typedef struct bitmap_element_def GTY(())\n   struct bitmap_element_def *next;\t\t/* Next element.  */\n   struct bitmap_element_def *prev;\t\t/* Previous element.  */\n   unsigned int indx;\t\t\t/* regno/BITMAP_ELEMENT_ALL_BITS.  */\n-  unsigned HOST_WIDE_INT bits[BITMAP_ELEMENT_WORDS]; /* Bits that are set.  */\n+  BITMAP_WORD bits[BITMAP_ELEMENT_WORDS]; /* Bits that are set.  */\n } bitmap_element;\n \n /* Head of bitmap linked list.  */\n@@ -162,9 +170,8 @@ do {\t\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   bitmap_element *ptr_ = (BITMAP)->first;\t\t\t\t\\\n   unsigned int indx_ = (MIN) / BITMAP_ELEMENT_ALL_BITS;\t\t\t\\\n-  unsigned bit_num_ = (MIN) % ((unsigned) HOST_BITS_PER_WIDE_INT);\t\\\n-  unsigned word_num_ = (((MIN) / ((unsigned) HOST_BITS_PER_WIDE_INT))\t\\\n-\t\t\t% BITMAP_ELEMENT_WORDS);\t\t\t\\\n+  unsigned bit_num_ = (MIN) % BITMAP_WORD_BITS;\t\t\t\t\\\n+  unsigned word_num_ = (MIN) / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   /* Find the block the minimum bit is in.  */\t\t\t\t\\\n@@ -181,20 +188,19 @@ do {\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       for (; word_num_ < BITMAP_ELEMENT_WORDS; word_num_++)\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  unsigned HOST_WIDE_INT word_ = ptr_->bits[word_num_];\t\t\\\n+\t  BITMAP_WORD word_ = ptr_->bits[word_num_];\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t  if (word_ != 0)\t\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n-\t      for (; bit_num_ < HOST_BITS_PER_WIDE_INT; bit_num_++)\t\\\n+\t      for (; bit_num_ < BITMAP_WORD_BITS; bit_num_++)\t\t\\\n \t\t{\t\t\t\t\t\t\t\\\n-\t\t  unsigned HOST_WIDE_INT mask_\t\t\t\t\\\n-\t\t    = ((unsigned HOST_WIDE_INT) 1) << bit_num_;\t\t\\\n+\t\t  BITMAP_WORD mask_ = ((BITMAP_WORD) 1) << bit_num_;\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t\t  if ((word_ & mask_) != 0)\t\t\t\t\\\n \t\t    {\t\t\t\t\t\t\t\\\n \t\t      word_ &= ~ mask_;\t\t\t\t\t\\\n \t\t      (BITNUM) = (ptr_->indx * BITMAP_ELEMENT_ALL_BITS  \\\n-\t\t\t\t  + word_num_ * HOST_BITS_PER_WIDE_INT  \\\n+\t\t\t\t  + word_num_ * BITMAP_WORD_BITS\t\\\n \t\t\t\t  + bit_num_);\t\t\t\t\\\n \t\t      CODE;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -220,9 +226,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n   bitmap_element *ptr1_ = (BITMAP1)->first;\t\t\t\t\\\n   bitmap_element *ptr2_ = (BITMAP2)->first;\t\t\t\t\\\n   unsigned int indx_ = (MIN) / BITMAP_ELEMENT_ALL_BITS;\t\t\t\\\n-  unsigned bit_num_ = (MIN) % ((unsigned) HOST_BITS_PER_WIDE_INT);\t\\\n-  unsigned word_num_ = (((MIN) / ((unsigned) HOST_BITS_PER_WIDE_INT))\t\\\n-\t\t\t% BITMAP_ELEMENT_WORDS);\t\t\t\\\n+  unsigned bit_num_ = (MIN) % BITMAP_WORD_BITS;\t\t\t\t\\\n+  unsigned word_num_ = (MIN) / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\t\\\n \t\t\t\t\t\t\t\t\t\\\n   /* Find the block the minimum bit is in in the first bitmap.  */\t\\\n   while (ptr1_ != 0 && ptr1_->indx < indx_)\t\t\t\t\\\n@@ -248,20 +253,19 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       for (; word_num_ < BITMAP_ELEMENT_WORDS; word_num_++)\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  unsigned HOST_WIDE_INT word_ = (ptr1_->bits[word_num_]\t\\\n-\t\t\t\t\t  & ~ tmp2_->bits[word_num_]);\t\\\n+\t  BITMAP_WORD word_ = (ptr1_->bits[word_num_]\t\t\t\\\n+\t\t\t       & ~ tmp2_->bits[word_num_]);\t\t\\\n \t  if (word_ != 0)\t\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n-\t      for (; bit_num_ < HOST_BITS_PER_WIDE_INT; bit_num_++)\t\\\n+\t      for (; bit_num_ < BITMAP_WORD_BITS; bit_num_++)\t\t\\\n \t\t{\t\t\t\t\t\t\t\\\n-\t\t  unsigned HOST_WIDE_INT mask_\t\t\t\t\\\n-\t\t    = ((unsigned HOST_WIDE_INT)1) << bit_num_;\t\t\\\n+\t\t  BITMAP_WORD mask_ = ((BITMAP_WORD) 1) << bit_num_;\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t\t  if ((word_ & mask_) != 0)\t\t\t\t\\\n \t\t    {\t\t\t\t\t\t\t\\\n \t\t      word_ &= ~ mask_;\t\t\t\t\t\\\n \t\t      (BITNUM) = (ptr1_->indx * BITMAP_ELEMENT_ALL_BITS \\\n-\t\t\t\t  + word_num_ * HOST_BITS_PER_WIDE_INT  \\\n+\t\t\t\t  + word_num_ * BITMAP_WORD_BITS\t\\\n \t\t\t\t  + bit_num_);\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t\t      CODE;\t\t\t\t\t\t\\\n@@ -287,9 +291,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n   bitmap_element *ptr1_ = (BITMAP1)->first;\t\t\t\t\\\n   bitmap_element *ptr2_ = (BITMAP2)->first;\t\t\t\t\\\n   unsigned int indx_ = (MIN) / BITMAP_ELEMENT_ALL_BITS;\t\t\t\\\n-  unsigned bit_num_ = (MIN) % ((unsigned) HOST_BITS_PER_WIDE_INT);\t\\\n-  unsigned word_num_ = (((MIN) / ((unsigned) HOST_BITS_PER_WIDE_INT))\t\\\n-\t\t\t% BITMAP_ELEMENT_WORDS);\t\t\t\\\n+  unsigned bit_num_ = (MIN) % BITMAP_WORD_BITS;\t\t\t\t\\\n+  unsigned word_num_ = (MIN) / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\t\\\n \t\t\t\t\t\t\t\t\t\\\n   /* Find the block the minimum bit is in in the first bitmap.  */\t\\\n   while (ptr1_ != 0 && ptr1_->indx < indx_)\t\t\t\t\\\n@@ -321,20 +324,19 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       for (; word_num_ < BITMAP_ELEMENT_WORDS; word_num_++)\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  unsigned HOST_WIDE_INT word_ = (ptr1_->bits[word_num_]\t\\\n-\t\t\t\t\t  & ptr2_->bits[word_num_]);\t\\\n+\t  BITMAP_WORD word_ = (ptr1_->bits[word_num_]\t\t\t\\\n+\t\t\t       & ptr2_->bits[word_num_]);\t\t\\\n \t  if (word_ != 0)\t\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n-\t      for (; bit_num_ < HOST_BITS_PER_WIDE_INT; bit_num_++)\t\\\n+\t      for (; bit_num_ < BITMAP_WORD_BITS; bit_num_++)\t\t\\\n \t\t{\t\t\t\t\t\t\t\\\n-\t\t  unsigned HOST_WIDE_INT mask_\t\t\t\t\\\n-\t\t    = ((unsigned HOST_WIDE_INT)1) << bit_num_;\t\t\\\n+\t\t  BITMAP_WORD mask_ = ((BITMAP_WORD) 1) << bit_num_;\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t\t  if ((word_ & mask_) != 0)\t\t\t\t\\\n \t\t    {\t\t\t\t\t\t\t\\\n \t\t      word_ &= ~ mask_;\t\t\t\t\t\\\n \t\t      (BITNUM) = (ptr1_->indx * BITMAP_ELEMENT_ALL_BITS \\\n-\t\t\t\t  + word_num_ * HOST_BITS_PER_WIDE_INT  \\\n+\t\t\t\t  + word_num_ * BITMAP_WORD_BITS\t\\\n \t\t\t\t  + bit_num_);\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t\t      CODE;\t\t\t\t\t\t\\"}]}