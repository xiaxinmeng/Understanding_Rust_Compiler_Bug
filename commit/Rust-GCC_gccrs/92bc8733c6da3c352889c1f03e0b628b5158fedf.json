{"sha": "92bc8733c6da3c352889c1f03e0b628b5158fedf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJiYzg3MzNjNmRhM2MzNTI4ODljMWYwM2UwYjYyOGI1MTU4ZmVkZg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-01-24T06:31:02Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-01-24T06:31:02Z"}, "message": "Makefile.in: Rebuilt.\n\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (awt_java_source_files): Added new files.\n\t* java/awt/Toolkit.java: Merged with Classpath.\n\t* java/awt/PrintGraphics.java: New file from Classpath.\n\t* java/awt/PrintJob.java: New file from Classpath.\n\t* java/awt/datatransfer/Clipboard.java: New file from Classpath.\n\t* java/awt/datatransfer/ClipboardOwner.java: New file from\n\tClasspath.\n\t* java/awt/datatransfer/DataFlavor.java: New file from Classpath.\n\t* java/awt/datatransfer/FlavorMap.java: New file from Classpath.\n\t* java/awt/datatransfer/MimeTypeParseException.java: New file from\n\tClasspath.\n\t* java/awt/datatransfer/StringSelection.java: New file from\n\tClasspath.\n\t* java/awt/datatransfer/SystemFlavorMap.java: New file from\n\tClasspath.\n\t* java/awt/datatransfer/Transferable.java: New file from\n\tClasspath.\n\t* java/awt/datatransfer/UnsupportedFlavorException.java: New file\n\tfrom Classpath.\n\nFrom-SVN: r49171", "tree": {"sha": "dcbd4f350943e311340c00ef1ec2ad6d15fd51b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcbd4f350943e311340c00ef1ec2ad6d15fd51b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92bc8733c6da3c352889c1f03e0b628b5158fedf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92bc8733c6da3c352889c1f03e0b628b5158fedf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92bc8733c6da3c352889c1f03e0b628b5158fedf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92bc8733c6da3c352889c1f03e0b628b5158fedf/comments", "author": null, "committer": null, "parents": [{"sha": "e1d7127573026268f0a31ae68d62281771d26079", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1d7127573026268f0a31ae68d62281771d26079", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1d7127573026268f0a31ae68d62281771d26079"}], "stats": {"total": 3109, "additions": 2858, "deletions": 251}, "files": [{"sha": "e4aa69238392f3ddb1ec9dc1bb9ac287622fedf6", "filename": "libjava/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=92bc8733c6da3c352889c1f03e0b628b5158fedf", "patch": "@@ -1,5 +1,26 @@\n 2002-01-23  Tom Tromey  <tromey@redhat.com>\n \n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (awt_java_source_files): Added new files.\n+\t* java/awt/Toolkit.java: Merged with Classpath.\n+\t* java/awt/PrintGraphics.java: New file from Classpath.\n+\t* java/awt/PrintJob.java: New file from Classpath.\n+\t* java/awt/datatransfer/Clipboard.java: New file from Classpath.\n+\t* java/awt/datatransfer/ClipboardOwner.java: New file from\n+\tClasspath.\n+\t* java/awt/datatransfer/DataFlavor.java: New file from Classpath.\n+\t* java/awt/datatransfer/FlavorMap.java: New file from Classpath.\n+\t* java/awt/datatransfer/MimeTypeParseException.java: New file from\n+\tClasspath.\n+\t* java/awt/datatransfer/StringSelection.java: New file from\n+\tClasspath.\n+\t* java/awt/datatransfer/SystemFlavorMap.java: New file from\n+\tClasspath.\n+\t* java/awt/datatransfer/Transferable.java: New file from\n+\tClasspath.\n+\t* java/awt/datatransfer/UnsupportedFlavorException.java: New file\n+\tfrom Classpath.\n+\n \t* Makefile.in: Rebuilt.\n \t* Makefile.am (awt_java_source_files): Added new files.\n \t* java/awt/image/AreaAveragingScaleFilter.java: New file from"}, {"sha": "3d71f33307554800b1efea634c5dff1109c38c8f", "filename": "libjava/Makefile.am", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=92bc8733c6da3c352889c1f03e0b628b5158fedf", "patch": "@@ -661,6 +661,8 @@ java/awt/Panel.java \\\n java/awt/Point.java \\\n java/awt/Polygon.java \\\n java/awt/PopupMenu.java\t\\\n+java/awt/PrintGraphics.java \\\n+java/awt/PrintJob.java \\\n java/awt/Rectangle.java\t\\\n java/awt/RenderingHints.java \\\n java/awt/ScrollPane.java \\\n@@ -677,6 +679,14 @@ java/awt/color/ColorSpace.java \\\n java/awt/color/ICC_ColorSpace.java \\\n java/awt/color/ICC_Profile.java\t\\\n java/awt/datatransfer/Clipboard.java \\\n+java/awt/datatransfer/ClipboardOwner.java \\\n+java/awt/datatransfer/DataFlavor.java \\\n+java/awt/datatransfer/FlavorMap.java \\\n+java/awt/datatransfer/MimeTypeParseException.java \\\n+java/awt/datatransfer/StringSelection.java \\\n+java/awt/datatransfer/SystemFlavorMap.java \\\n+java/awt/datatransfer/Transferable.java\t\\\n+java/awt/datatransfer/UnsupportedFlavorException.java \\\n java/awt/event/AWTEventListener.java \\\n java/awt/event/ActionEvent.java\t\\\n java/awt/event/ActionListener.java \\"}, {"sha": "66494d9576e10d4230cc36547be93c6b20dd29b0", "filename": "libjava/Makefile.in", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=92bc8733c6da3c352889c1f03e0b628b5158fedf", "patch": "@@ -412,6 +412,8 @@ java/awt/Panel.java \\\n java/awt/Point.java \\\n java/awt/Polygon.java \\\n java/awt/PopupMenu.java\t\\\n+java/awt/PrintGraphics.java \\\n+java/awt/PrintJob.java \\\n java/awt/Rectangle.java\t\\\n java/awt/RenderingHints.java \\\n java/awt/ScrollPane.java \\\n@@ -428,6 +430,14 @@ java/awt/color/ColorSpace.java \\\n java/awt/color/ICC_ColorSpace.java \\\n java/awt/color/ICC_Profile.java\t\\\n java/awt/datatransfer/Clipboard.java \\\n+java/awt/datatransfer/ClipboardOwner.java \\\n+java/awt/datatransfer/DataFlavor.java \\\n+java/awt/datatransfer/FlavorMap.java \\\n+java/awt/datatransfer/MimeTypeParseException.java \\\n+java/awt/datatransfer/StringSelection.java \\\n+java/awt/datatransfer/SystemFlavorMap.java \\\n+java/awt/datatransfer/Transferable.java\t\\\n+java/awt/datatransfer/UnsupportedFlavorException.java \\\n java/awt/event/AWTEventListener.java \\\n java/awt/event/ActionEvent.java\t\\\n java/awt/event/ActionListener.java \\\n@@ -2028,7 +2038,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/awt/MenuItem.P .deps/java/awt/MenuShortcut.P \\\n .deps/java/awt/Paint.P .deps/java/awt/PaintContext.P \\\n .deps/java/awt/Panel.P .deps/java/awt/Point.P .deps/java/awt/Polygon.P \\\n-.deps/java/awt/PopupMenu.P .deps/java/awt/Rectangle.P \\\n+.deps/java/awt/PopupMenu.P .deps/java/awt/PrintGraphics.P \\\n+.deps/java/awt/PrintJob.P .deps/java/awt/Rectangle.P \\\n .deps/java/awt/RenderingHints.P .deps/java/awt/ScrollPane.P \\\n .deps/java/awt/Scrollbar.P .deps/java/awt/Shape.P \\\n .deps/java/awt/SystemColor.P .deps/java/awt/TextArea.P \\\n@@ -2038,6 +2049,14 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/awt/color/ICC_ColorSpace.P \\\n .deps/java/awt/color/ICC_Profile.P \\\n .deps/java/awt/datatransfer/Clipboard.P \\\n+.deps/java/awt/datatransfer/ClipboardOwner.P \\\n+.deps/java/awt/datatransfer/DataFlavor.P \\\n+.deps/java/awt/datatransfer/FlavorMap.P \\\n+.deps/java/awt/datatransfer/MimeTypeParseException.P \\\n+.deps/java/awt/datatransfer/StringSelection.P \\\n+.deps/java/awt/datatransfer/SystemFlavorMap.P \\\n+.deps/java/awt/datatransfer/Transferable.P \\\n+.deps/java/awt/datatransfer/UnsupportedFlavorException.P \\\n .deps/java/awt/event/AWTEventListener.P \\\n .deps/java/awt/event/ActionEvent.P \\\n .deps/java/awt/event/ActionListener.P \\"}, {"sha": "3d1ee6326828c72c59b60fb00715ad605851f959", "filename": "libjava/java/awt/PrintGraphics.java", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2FPrintGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2FPrintGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FPrintGraphics.java?ref=92bc8733c6da3c352889c1f03e0b628b5158fedf", "patch": "@@ -0,0 +1,59 @@\n+/* PrintGraphics.java -- A print graphics context.\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt;\n+\n+/**\n+  * This interface allows the originating print job to be obtained.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public interface PrintGraphics\n+{\n+\n+/**\n+  * Returns the <code>PrintJob</code> that this object is being\n+  * managed by.\n+  *\n+  * @return The print job for this object.\n+  */\n+public abstract PrintJob\n+getPrintJob();\n+\n+} // interface PrintGraphics\n+"}, {"sha": "4e6ae29ff7b7714536b5e8261c98299c084e4ed1", "filename": "libjava/java/awt/PrintJob.java", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2FPrintJob.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2FPrintJob.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FPrintJob.java?ref=92bc8733c6da3c352889c1f03e0b628b5158fedf", "patch": "@@ -0,0 +1,128 @@\n+/* PrintJob.java -- A print job class\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt;\n+\n+/**\n+  * This abstract class represents a print job.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public abstract class PrintJob\n+{\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * This method initializes a new instance of <code>PrintJob</code>.\n+  */\n+public\n+PrintJob()\n+{\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n+ */\n+\n+/**\n+  * Returns a graphics context suitable for rendering the next page.\n+  *\n+  * @return A graphics context for printing the next page.\n+  */\n+public abstract Graphics\n+getGraphics();\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the dimension of the page in pixels.  The resolution will be\n+  * chosen to be similar to the on screen image.\n+  *\n+  * @return The page dimensions.\n+  */\n+public abstract Dimension\n+getPageDimension();\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the resolution of the page in pixels per inch.\n+  *\n+  * @return The resolution of the page in pixels per inch.\n+  */\n+public abstract int\n+getPageResolution();\n+\n+/*************************************************************************/\n+\n+/**\n+  * Tests whether or not the last page will be printed first.\n+  *\n+  * @return <code>true</code> if the last page prints first, <code>false</code>\n+  * otherwise.\n+  */\n+public abstract boolean\n+lastPageFirst();\n+\n+/*************************************************************************/\n+\n+/**\n+  * Informs the print job that printing is complete.\n+  */\n+public abstract void\n+end();\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method explicitly ends the print job in the event the job\n+  * becomes un-referenced without the application having done so.\n+  */\n+public void\n+finalize()\n+{\n+  end();\n+}\n+\n+} // class PrintJob\n+"}, {"sha": "4c59138fc6be9e7ee36f8c4a1d4e4dc99c7c8aad", "filename": "libjava/java/awt/Toolkit.java", "status": "modified", "additions": 805, "deletions": 243, "changes": 1048, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2FToolkit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2FToolkit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FToolkit.java?ref=92bc8733c6da3c352889c1f03e0b628b5158fedf", "patch": "@@ -1,263 +1,825 @@\n-/* Copyright (C) 1999, 2000  Free Software Foundation\n+/* Toolkit.java -- AWT Toolkit superclass\n+   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n-   This file is part of libjava.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libjava License.  Please consult the file \"LIBJAVA_LICENSE\" for\n-details.  */\n \n package java.awt;\n-import java.awt.peer.*;\n+\n import java.awt.event.*;\n-import java.net.URL;\n-import java.beans.*;\n+import java.awt.peer.*;\n import java.awt.image.*;\n import java.awt.datatransfer.Clipboard;\n-import java.util.Hashtable;\n-import gnu.java.awt.GLightweightPeer;\n-\n-/* A very incomplete placeholder. */\n+import java.util.Properties;\n+import java.net.URL;\n+import java.beans.*;\n \n+/**\n+  * The AWT system uses a set of native peer objects to implement its\n+  * widgets.  These peers are provided by a peer toolkit, that is accessed\n+  * via a subclass of this superclass.  The system toolkit is retrieved\n+  * by the static methods <code>getDefaultToolkit</code>.  This method\n+  * determines the system toolkit by examining the system property\n+  * <code>awt.toolkit</code>.  That property is set to the name of the\n+  * <code>Toolkit</code> subclass for the specified peer set.  If the\n+  * <code>awt.toolkit</code> property is not set, then the default\n+  * toolkit <code>gnu.java.awt.peer.gtk.GtkToolkit</code> is used.  This\n+  * toolkit creates its peers using the GTK+ toolkit.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n public abstract class Toolkit\n {\n-  static Toolkit defaultToolkit;\n-  PropertyChangeSupport changeSupport = new PropertyChangeSupport(this);\n-  Hashtable desktopProperties = new Hashtable();\n-\n-  public static Toolkit getDefaultToolkit()\n-  {\n-    if (defaultToolkit != null)\n-      return defaultToolkit;\n-    \n-    Class toolkit_class;\n-    String tk_class_name = System.getProperty(\"awt.toolkit\");\n-    if (tk_class_name == null)\n-      tk_class_name = \"gnu.awt.gtk.GtkToolkit\";\n-\n-    try\n+\n+/*\n+ * Static Variables\n+ */\n+\n+// The default toolkit name.\n+private static String default_toolkit_name = \n+  \"gnu.java.awt.peer.gtk.GtkToolkit\";\n+\n+// The toolkit in use.  Once we load it, we don't ever change it\n+// if the awt.toolkit propert is set.\n+private static Toolkit toolkit;\n+\n+// The toolkit properties\n+private static Properties props = new Properties();\n+\n+private PropertyChangeSupport changeSupport = new PropertyChangeSupport(this);\n+\n+private Properties desktopProperties = new Properties();\n+\n+/*************************************************************************/\n+\n+/*\n+ * Static Methods\n+ */\n+\n+/**\n+  * Returns an instance of the default toolkit.  The default toolkit is\n+  * the subclass of <code>Toolkit</code> specified in the system property\n+  * <code>awt.toolkit</code>, or <code>gnu.java.awt.peer.gtk.GtkToolkit</code>\n+  * if the property is not set.\n+  *\n+  * @return An instance of the system default toolkit.\n+  *\n+  * @error AWTError If the toolkit cannot be loaded.\n+  */\n+public static Toolkit\n+getDefaultToolkit()\n+{\n+  if (toolkit != null)\n+    return(toolkit);\n+\n+  String toolkit_name = System.getProperty(\"awt.toolkit\",\n+\t\t\t\t\t   default_toolkit_name);\n+\n+  try\n     {\n-      toolkit_class = Class.forName(tk_class_name);\n-      defaultToolkit = (Toolkit) toolkit_class.newInstance();\n+      Class cls = Class.forName(toolkit_name);\n+      Object obj = cls.newInstance();\n+\n+      if (!(obj instanceof Toolkit))\n+        throw new AWTError(toolkit_name + \" is not a subclass of \" +\n+                           \"java.awt.Toolkit\");\n+\n+      toolkit = (Toolkit)obj;\n+      return(toolkit);\n     }\n-    catch (Exception x)\n+  catch(Exception e)\n     {\n-      throw new AWTError(\"Toolkit class \" + tk_class_name + \n-        \t\t \" could not be initialized:\\n  \" + x);\n+      throw new AWTError(\"Cannot load AWT toolkit: \" + e.getMessage());\n     }\n+}\n \n-    return defaultToolkit;\n-  }\n-\n-  protected abstract ButtonPeer createButton(Button target);\n-  protected abstract TextFieldPeer createTextField(TextField target);\n-  protected abstract LabelPeer createLabel(Label target);\n-  protected abstract ListPeer createList(List target);\n-  protected abstract CheckboxPeer createCheckbox(Checkbox target);\n-  protected abstract ScrollbarPeer createScrollbar(Scrollbar target);\n-  protected abstract ScrollPanePeer createScrollPane(ScrollPane target);\n-  protected abstract TextAreaPeer createTextArea(TextArea target);\n-  protected abstract ChoicePeer createChoice(Choice target);\n-  protected abstract FramePeer createFrame(Frame target);\n-  protected abstract CanvasPeer createCanvas(Canvas target);\n-  protected abstract PanelPeer createPanel(Panel target);\n-  protected abstract WindowPeer createWindow(Window target);\n-  protected abstract DialogPeer createDialog(Dialog target);\n-  protected abstract MenuBarPeer createMenuBar(MenuBar target);\n-  protected abstract MenuPeer createMenu(Menu target);\n-  protected abstract PopupMenuPeer createPopupMenu(PopupMenu target);\n-  protected abstract MenuItemPeer createMenuItem(MenuItem target);\n-  protected abstract FileDialogPeer createFileDialog(FileDialog target);\n-  protected abstract CheckboxMenuItemPeer \n-    createCheckboxMenuItem(CheckboxMenuItem target);\n-\n-  protected LightweightPeer createComponent(Component target)\n-  {\n-    return GLightweightPeer.INSTANCE;\n-  }\n-  \n-  /* @deprecated Use GraphicsEnvironment.getAllFonts() */\n-  protected abstract java.awt.peer.FontPeer getFontPeer(String name, int style);\n-  \n-  /*\n-  public abstract DragSourceContextPeer \n-    createDragSourceContextPeer(DragGestureEvent dge)\n-    throws InvalidDnDOperationException;\n+/*************************************************************************/\n+\n+/**\n+  * Returns the value of the property with the specified name, or the\n+  * default value if the property does not exist.\n+  *\n+  * @param key The name of the property to retrieve.\n+  * @param defThe default value of the property.\n   */\n-  \n-  protected void loadSystemColors(int[] systemColors)\n-  {\n-    // FIXME\n-  }\n-\n-  public abstract Dimension getScreenSize();\n-  public abstract int getScreenResolution();\n-  public abstract ColorModel getColorModel();\n-  /* @deprecated Use GraphicsEnvironment.getAvailableFontFamilyNames() */\n-  public abstract String[] getFontList();\n-  public abstract FontMetrics getFontMetrics(Font font);\n-  public abstract void sync();\n-  public abstract Image getImage(String filename);\n-  public abstract Image getImage(URL url);\n-  public abstract Image createImage(String filename);\n-  public abstract Image createImage(URL url);\n-  public abstract boolean prepareImage(Image image, int width, int height,\n-                                       ImageObserver observer);\n-  public abstract int checkImage(Image image, int width, int height,\n-                        \t ImageObserver observer);\n-  public abstract Image createImage(ImageProducer producer);\n-\n-  public Image createImage(byte[] imagedata)\n-  {\n-    return createImage (imagedata, 0, imagedata.length);\n-  }\n-  \n-  public abstract Image createImage(byte[] imagedata, int imageoffset,\n-                                    int imagelength);\n-  /*\n-  public abstract PrintJob getPrintJob(Frame frame, String jobtitle,\n-                                       Properties props);\n-  public PrintJob getPrintJob(Frame frame, String jobtitle,\n-                              JobAttributes jobAttributes,\n-\t\t\t      PageAttributes pageAttributes)\n-  {\n-    \n-  }\n+public static String\n+getProperty(String key, String def)\n+{\n+  return(props.getProperty(key, def));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the native container object of the specified component.  This\n+  * method is necessary because the parent component might be a lightweight\n+  * component.\n+  *\n+  * @param component The component to fetch the native container for.\n+  *\n+  * @return The native container object for this component.\n   */\n-  \n-  public abstract void beep();\n-  public abstract Clipboard getSystemClipboard();\n-\n-  public int getMenuShortcutKeyMask()\n-  {\n-    return InputEvent.CTRL_MASK;\n-  }\n-\n-  public boolean getLockingKeyState(int keyCode)\n-  {\n-    if (keyCode != KeyEvent.VK_CAPS_LOCK\n-\t&& keyCode != KeyEvent.VK_NUM_LOCK\n-\t&& keyCode != KeyEvent.VK_SCROLL_LOCK)\n-      throw new IllegalArgumentException();\n-\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  public void setLockingKeyState(int keyCode, boolean on)\n-  {\n-    if (keyCode != KeyEvent.VK_CAPS_LOCK\n-\t&& keyCode != KeyEvent.VK_NUM_LOCK\n-\t&& keyCode != KeyEvent.VK_SCROLL_LOCK)\n-      throw new IllegalArgumentException();\n-\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  protected static Container getNativeContainer(Component c)\n-  {\n-    while (c != null) \n-    {\n-      if (!c.isLightweight ())\n-\treturn (Container) c;\n+protected static Container\n+getNativeContainer(Component component)\n+{\n+  component = component.getParent();\n \n-      c = c.getParent();\n+  for(;;)\n+    {\n+      if (component == null)\n+        return(null);\n+\n+      if (!(component instanceof Container))\n+        {\n+          component = component.getParent();\n+          continue;\n+        }\n+\n+      if (component.getPeer() instanceof LightweightPeer)\n+        {\n+          component = component.getParent();\n+          continue;\n+        } \n+\n+      return((Container)component);\n     }\n-    return null;\n-  }\n-\n-  public Cursor createCustomCursor(Image cursor, Point hotSpot, String name)\n-    throws IndexOutOfBoundsException\n-  {\n-    // Presumably the only reason this isn't abstract is for backwards\n-    // compatibility? FIXME?\n-    return null;\n-  }\n-\n-  public Dimension getBestCursorSize(int preferredWidth, int preferredHeight)\n-  {\n-    return new Dimension (0,0);\n-  }\n-\n-  public int getMaximumCursorColors()\n-  {\n-    return 0;\n-  }\n-\n-  public static String getProperty(String key, String defaultValue)\n-  {\n-    // FIXME\n-    return defaultValue;\n-  }\n-\n-  public final EventQueue getSystemEventQueue()\n-  {\n-      return getSystemEventQueueImpl();\n-  }\n-\n-  protected abstract EventQueue getSystemEventQueueImpl();\n-\n-  /*\n-  public DragGestureRecognizer \n-    createDragGestureRecognizer(Class abstractRecognizerClass, DragSource ds,\n-                        \tComponent c, int srcActions,\n-\t\t\t\tDragGestureListener dgl)\n-  {\n-    // err... FIXME\n-    return null;\n-  }\n-  */\n-\n-  public final Object getDesktopProperty(String propertyName)\n-  {\n-    return desktopProperties.get(propertyName);\n-  }\n-\n-  protected final void setDesktopProperty(String name, Object newValue)\n-  {\n-    Object oldValue = getDesktopProperty(name);\n-    desktopProperties.put(name, newValue);\n-    changeSupport.firePropertyChange(name, oldValue, newValue);\n-  }\n-\n-  protected Object lazilyLoadDesktopProperty(String name)\n-  {\n-    // FIXME - what is this??\n-    return null;\n-  }\n-\n-  protected void initializeDesktopProperties()\n-  {\n-    // Overridden by toolkit implementation?\n-  }\n-\n-  public void addPropertyChangeListener(String name,\n-                                \tPropertyChangeListener pcl)\n-  {\n-    changeSupport.addPropertyChangeListener(name, pcl);\n-  }\n-  \n-  public void removePropertyChangeListener(String name,\n-                                           PropertyChangeListener pcl)\n-  {\n-    changeSupport.removePropertyChangeListener(name, pcl);\n-  }\n-\n-  public void addAWTEventListener(AWTEventListener listener, long eventMask)\n-  {\n-    // SecurityManager s = System.getSecurityManager();\n-    // if (s != null)\n-    //  s.checkPermission(AWTPermission(\"listenToAllAWTEvents\"));\n-\n-    // FIXME\n-  }\n-\n-  public void removeAWTEventListener(AWTEventListener listener)\n-  {\n-    // FIXME\n-  }\n-  \n-  /*\n-  public abstract Map mapInputMethodHighlight(InputMethodHighlight highlight)\n-  {\n-  }  \n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * Default constructor for subclasses.\n+  */\n+public\n+Toolkit()\n+{\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n+ */\n+\n+/**\n+  * Creates a peer object for the specified <code>Button</code>.\n+  *\n+  * @param target The <code>Button</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>Button</code> object.\n+  */\n+protected abstract ButtonPeer\n+createButton(Button target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>TextField</code>.\n+  *\n+  * @param target The <code>TextField</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>TextField</code> object.\n+  */\n+protected abstract TextFieldPeer\n+createTextField(TextField target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>Label</code>.\n+  *\n+  * @param target The <code>Label</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>Label</code> object.\n+  */\n+protected abstract LabelPeer\n+createLabel(Label target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>List</code>.\n+  *\n+  * @param target The <code>List</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>List</code> object.\n+  */\n+protected abstract ListPeer\n+createList(List target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>Checkbox</code>.\n+  *\n+  * @param target The <code>Checkbox</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>Checkbox</code> object.\n+  */\n+protected abstract CheckboxPeer\n+createCheckbox(Checkbox target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>Scrollbar</code>.\n+  *\n+  * @param target The <code>Scrollbar</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>Scrollbar</code> object.\n+  */\n+protected abstract ScrollbarPeer\n+createScrollbar(Scrollbar target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>ScrollPane</code>.\n+  *\n+  * @param target The <code>ScrollPane</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>ScrollPane</code> object.\n+  */\n+protected abstract ScrollPanePeer\n+createScrollPane(ScrollPane target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>TextArea</code>.\n+  *\n+  * @param target The <code>TextArea</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>TextArea</code> object.\n+  */\n+protected abstract TextAreaPeer\n+createTextArea(TextArea target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>Choice</code>.\n+  *\n+  * @param target The <code>Choice</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>Choice</code> object.\n+  */\n+protected abstract ChoicePeer\n+createChoice(Choice target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>Frame</code>.\n+  *\n+  * @param target The <code>Frame</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>Frame</code> object.\n+  */\n+protected abstract FramePeer\n+createFrame(Frame target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>Canvas</code>.\n+  *\n+  * @param target The <code>Canvas</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>Canvas</code> object.\n+  */\n+protected abstract CanvasPeer\n+createCanvas(Canvas target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>Panel</code>.\n+  *\n+  * @param target The <code>Panel</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>Panel</code> object.\n+  */\n+protected abstract PanelPeer\n+createPanel(Panel target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>Window</code>.\n+  *\n+  * @param target The <code>Window</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>Window</code> object.\n+  */\n+protected abstract WindowPeer\n+createWindow(Window target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>Dialog</code>.\n+  *\n+  * @param target The dialog to create the peer for\n+  *\n+  * @return The peer for the specified font name.\n+  */\n+protected abstract DialogPeer\n+createDialog(Dialog target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>MenuBar</code>.\n+  *\n+  * @param target The <code>MenuBar</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>MenuBar</code> object.\n+  */\n+protected abstract MenuBarPeer\n+createMenuBar(MenuBar target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>Menu</code>.\n+  *\n+  * @param target The <code>Menu</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>Menu</code> object.\n+  */\n+protected abstract MenuPeer\n+createMenu(Menu target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>PopupMenu</code>.\n+  *\n+  * @param target The <code>PopupMenu</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>PopupMenu</code> object.\n+  */\n+protected abstract PopupMenuPeer\n+createPopupMenu(PopupMenu target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>MenuItem</code>.\n+  *\n+  * @param target The <code>MenuItem</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>MenuItem</code> object.\n+  */\n+protected abstract MenuItemPeer\n+createMenuItem(MenuItem target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>FileDialog</code>.\n+  *\n+  * @param target The <code>FileDialog</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>FileDialog</code> object.\n+  */\n+protected abstract FileDialogPeer\n+createFileDialog(FileDialog target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>CheckboxMenuItem</code>.\n+  *\n+  * @param target The <code>CheckboxMenuItem</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>CheckboxMenuItem</code> object.\n+  */\n+protected abstract CheckboxMenuItemPeer\n+createCheckboxMenuItem(CheckboxMenuItem target);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified <code>Component</code>.  The\n+  * peer returned by this method is not a native windowing system peer\n+  * with its own native window.  Instead, this method allows the component\n+  * to draw on its parent window as a \"lightweight\" widget.\n+  *\n+  * XXX: FIXME\n+  *\n+  * @param target The <code>Component</code> to create the peer for.\n+  *\n+  * @return The peer for the specified <code>Component</code> object.\n   */\n+protected LightweightPeer\n+createComponent(Component target)\n+{\n+  return null;\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a peer object for the specified font name.\n+  *\n+  * @param name The font to create the peer for.\n+  * @param style The font style to create the peer for.\n+  *\n+  * @return The peer for the specified font name.\n+  */\n+protected abstract FontPeer\n+getFontPeer(String name, int style);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Copies the current system colors into the specified array.  This is\n+  * the interface used by the <code>SystemColors</code> class.\n+  *\n+  * @param colors The array to copy the system colors into.\n+  */\n+protected void\n+loadSystemColors(int systemColors[])\n+{\n }\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the dimensions of the screen in pixels.\n+  *\n+  * @return The dimensions of the screen in pixels.\n+  */\n+public abstract Dimension\n+getScreenSize();\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the screen resolution in dots per square inch.\n+  *\n+  * @return The screen resolution in dots per square inch.\n+  */\n+public abstract int\n+getScreenResolution();\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the color model of the screen.\n+  *\n+  * @return The color model of the screen.\n+  */\n+public abstract ColorModel\n+getColorModel();\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the names of the available fonts.\n+  *\n+  * @return The names of the available fonts.\n+  */\n+public abstract String[]\n+getFontList();\n+\n+/*************************************************************************/\n+\n+/**\n+  * Return the font metrics for the specified font\n+  *\n+  * @param name The name of the font to return metrics for.\n+  *\n+  * @return The requested font metrics.\n+  */\n+public abstract FontMetrics\n+getFontMetrics(Font name);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Flushes any buffered data to the screen so that it is in sync with \n+  * what the AWT system has drawn to it.\n+  */\n+public abstract void\n+sync();\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns an image from the specified file, which must be in a \n+  * recognized format.  Supported formats vary from toolkit to toolkit.\n+  *\n+  * @return name The name of the file to read the image from.\n+  */\n+public abstract Image\n+getImage(String name);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns an image from the specified URL, which must be in a \n+  * recognized format.  Supported formats vary from toolkit to toolkit.\n+  *\n+  * @return url The URl to read the image from.\n+  */\n+public abstract Image\n+getImage(URL url);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Readies an image to be rendered on the screen.  The width and height\n+  * values can be set to the default sizes for the image by passing -1\n+  * in those parameters.\n+  *\n+  * @param image The image to prepare for rendering.\n+  * @param width The width of the image.\n+  * @param height The height of the image.\n+  * @param observer The observer to receive events about the preparation\n+  * process.\n+  *\n+  * @return <code>true</code> if the image is already prepared for rendering,\n+  * <code>false</code> otherwise.\n+  */\n+public abstract boolean\n+prepareImage(Image image, int width, int height, ImageObserver observer);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Checks the status of specified image as it is being readied for \n+  * rendering.\n+  *\n+  * @param image The image to prepare for rendering.\n+  * @param width The width of the image.\n+  * @param height The height of the image.\n+  * @param observer The observer to receive events about the preparation\n+  * process.\n+  *\n+  * @return A union of the bitmasks from \n+  * <code>java.awt.image.ImageObserver</code> that indicates the current\n+  * state of the imaging readying process.\n+  */\n+public abstract int\n+checkImage(Image image, int width, int height, ImageObserver observer);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates an image using the specified <code>ImageProducer</code>\n+  *\n+  * @param producer The <code>ImageProducer</code> to create the image from.\n+  *\n+  * @return The created image.\n+  */\n+public abstract Image\n+createImage(ImageProducer producer);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates an image from the specified portion of the byte array passed.\n+  * The array must be in a recognized format.  Supported formats vary from\n+  * toolkit to toolkit.\n+  *\n+  * @param data The raw image data.\n+  * @param offset The offset into the data where the image data starts.\n+  * @param len The length of the image data.\n+  *\n+  * @return The created image.\n+  */\n+public abstract Image\n+createImage(byte[] data, int offset, int len);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates an image from the specified byte array. The array must be in\n+  * a recognized format.  Supported formats vary from toolkit to toolkit.\n+  *\n+  * @param data The raw image data.\n+  *\n+  * @return The created image.\n+  */\n+public Image\n+createImage(byte[] data)\n+{\n+  return(createImage(data, 0, data.length));\n+}\n+\n+public abstract Image\n+createImage(String filename);\n+\n+public abstract Image\n+createImage(URL url);\n+\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns a instance of <code>PrintJob</code> for the specified \n+  * arguments.\n+  *\n+  * @param frame The window initiating the print job.\n+  * @param title The print job title.\n+  * @param props The print job properties.\n+  *\n+  * @return The requested print job, or <code>null</code> if the job\n+  * was cancelled.\n+  */\n+public abstract PrintJob\n+getPrintJob(Frame frame, String title, Properties props);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the system clipboard.\n+  *\n+  * @return THe system clipboard.\n+  */\n+public abstract Clipboard\n+getSystemClipboard();\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the accelerator key mask for menu shortcuts. The default is\n+  * <code>Event.CTRL_MASK</code>.  A toolkit must override this method\n+  * to change the default.\n+  *\n+  * @return The key mask for the menu accelerator key.\n+  */\n+public int\n+getMenuShortcutKeyMask()\n+{\n+  return Event.CTRL_MASK;\n+}\n+\n+public boolean\n+getLockingKeyState(int keyCode)\n+{\n+  if (keyCode != KeyEvent.VK_CAPS_LOCK\n+      && keyCode != KeyEvent.VK_NUM_LOCK\n+      && keyCode != KeyEvent.VK_SCROLL_LOCK)\n+    throw new IllegalArgumentException();\n+\n+  throw new UnsupportedOperationException();\n+}\n+\n+public void\n+setLockingKeyState(int keyCode, boolean on)\n+{\n+  if (keyCode != KeyEvent.VK_CAPS_LOCK\n+      && keyCode != KeyEvent.VK_NUM_LOCK\n+      && keyCode != KeyEvent.VK_SCROLL_LOCK)\n+    throw new IllegalArgumentException();\n+\n+  throw new UnsupportedOperationException();\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the event queue for the applet.  Despite the word \"System\"\n+  * in the name of this method, there is no guarantee that the same queue\n+  * is shared system wide.\n+  *\n+  * @return The event queue for this applet (or application)\n+  */\n+public final EventQueue\n+getSystemEventQueue()\n+{\n+  return(getSystemEventQueueImpl());\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * // FIXME: What does this do?\n+  */\n+protected abstract EventQueue\n+getSystemEventQueueImpl();\n+\n+/*************************************************************************/\n+\n+/**\n+  * Causes a \"beep\" tone to be generated.\n+  */\n+public abstract void\n+beep();\n+\n+public Cursor\n+createCustomCursor(Image cursor, Point hotSpot, String name)\n+  throws IndexOutOfBoundsException\n+{\n+  // Presumably the only reason this isn't abstract is for backwards\n+  // compatibility? FIXME?\n+  return null;\n+}\n+\n+public Dimension\n+getBestCursorSize(int preferredWidth, int preferredHeight)\n+{\n+  return new Dimension (0,0);\n+}\n+\n+public int\n+getMaximumCursorColors()\n+{\n+  return 0;\n+}\n+\n+public final Object\n+getDesktopProperty(String propertyName)\n+{\n+  return desktopProperties.get(propertyName);\n+}\n+\n+protected final void\n+setDesktopProperty(String name, Object newValue)\n+{\n+  Object oldValue = getDesktopProperty(name);\n+  desktopProperties.put(name, newValue);\n+  changeSupport.firePropertyChange(name, oldValue, newValue);\n+}\n+protected Object\n+lazilyLoadDesktopProperty(String name)\n+{\n+  // FIXME - what is this??\n+  return null;\n+}\n+\n+protected void\n+initializeDesktopProperties()\n+{\n+  // Overridden by toolkit implementation?\n+}\n+\n+public void\n+addPropertyChangeListener(String name, PropertyChangeListener pcl)\n+{\n+  changeSupport.addPropertyChangeListener(name, pcl);\n+}\n+  \n+public void\n+removePropertyChangeListener(String name, PropertyChangeListener pcl)\n+{\n+  changeSupport.removePropertyChangeListener(name, pcl);\n+}\n+\n+public void\n+addAWTEventListener(AWTEventListener listener, long eventMask)\n+{\n+  // SecurityManager s = System.getSecurityManager();\n+  // if (s != null)\n+  //  s.checkPermission(AWTPermission(\"listenToAllAWTEvents\"));\n+\n+  // FIXME\n+}\n+\n+public void\n+removeAWTEventListener(AWTEventListener listener)\n+{\n+  // FIXME\n+}\n+\n+} // class Toolkit"}, {"sha": "6ef9e70b6aa00d8ca7a31f70ea2bda63060dfabe", "filename": "libjava/java/awt/datatransfer/Clipboard.java", "status": "modified", "additions": 128, "deletions": 7, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FClipboard.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FClipboard.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fdatatransfer%2FClipboard.java?ref=92bc8733c6da3c352889c1f03e0b628b5158fedf", "patch": "@@ -1,15 +1,136 @@\n-/* Copyright (C) 2000  Free Software Foundation\n+/* Clipboard.java -- Class for transferring data via cut and paste.\n+   Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n \n-package java.awt.datatransfer;\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n-/* A very incomplete placeholder. */\n \n+package java.awt.datatransfer;\n+\n+/**\n+  * This class allows data to be transferred using a cut and paste type\n+  * mechanism.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n public class Clipboard\n {\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * The data being transferred.\n+  */\n+protected Transferable contents;\n+\n+/**\n+  * The owner of this clipboard.\n+  */\n+protected ClipboardOwner owner;\n+\n+// The clipboard name\n+private String name;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * Initializes a new instance of <code>Clipboard</code> with the\n+  * specified name.\n+  *\n+  * @param name The clipboard name.\n+  */\n+public \n+Clipboard(String name)\n+{\n+  this.name = name;\n }\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n+ */\n+\n+/**\n+  * Returns the name of the clipboard.\n+  */\n+public String\n+getName()\n+{\n+  return(name);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the contents of the clipboard.\n+  *\n+  * @param requestor The object requesting the contents.\n+  */\n+public synchronized Transferable\n+getContents(Object requestor)\n+{\n+  return(contents);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Sets the content and owner of this clipboard.\n+  * If the given owner is different from the current owner\n+  * then lostOwnership is called on the current owner.\n+  * XXX - is this called with the old or new contents.\n+  *\n+  * @param contents The new clipboard contents.\n+  * @param owner The new clipboard owner\n+  */\n+public synchronized void\n+setContents(Transferable contents, ClipboardOwner owner)\n+{\n+  if (this.owner != owner)\n+    if (this.owner != null)\n+      this.owner.lostOwnership(this, contents);\n+ \n+  this.owner = owner;\n+  this.contents = contents;\n+}\n+\n+} // class Clipboard\n+"}, {"sha": "3127e02e570df0c18afbc7f3f900889133a45ef9", "filename": "libjava/java/awt/datatransfer/ClipboardOwner.java", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FClipboardOwner.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FClipboardOwner.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fdatatransfer%2FClipboardOwner.java?ref=92bc8733c6da3c352889c1f03e0b628b5158fedf", "patch": "@@ -0,0 +1,60 @@\n+/* ClipboardOwner.java -- Interface for clipboard providers\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.datatransfer;\n+\n+/**\n+  * This interface is for classes that will own a clipboard object.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public interface ClipboardOwner\n+{\n+\n+/**\n+  * This method is called to notify this object that it no longer\n+  * has ownership of the specified <code>Clipboard</code>.\n+  *\n+  * @param clipboard The clipboard for which ownership was lost.\n+  * @param contents The contents of the clipboard which are no longer owned.\n+  */\n+public abstract void\n+lostOwnership(Clipboard clipboard, Transferable contents); \n+\n+} // interface ClipboardOwner\n+"}, {"sha": "3c6b2720e45dc58936683e9b88d12486929a1bc4", "filename": "libjava/java/awt/datatransfer/DataFlavor.java", "status": "added", "additions": 982, "deletions": 0, "changes": 982, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FDataFlavor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FDataFlavor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fdatatransfer%2FDataFlavor.java?ref=92bc8733c6da3c352889c1f03e0b628b5158fedf", "patch": "@@ -0,0 +1,982 @@\n+/* DataFlavor.java -- A type of data to transfer via the clipboard.\n+   Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.datatransfer;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.IOException;\n+import java.io.ObjectOutput;\n+import java.io.ObjectInput;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.UnsupportedEncodingException;\n+\n+/**\n+  * This class represents a particular data format used for transferring\n+  * data via the clipboard.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class DataFlavor implements java.io.Externalizable, Cloneable\n+{\n+\n+// FIXME: Serialization: Need to write methods for.\n+\n+/*\n+ * Static Variables\n+ */\n+\n+/**\n+  * This is the data flavor used for tranferring plain text.  The MIME\n+  * type is \"text/plain; charset=unicode\".  The representation class\n+  * is <code>java.io.InputStream</code>.\n+  *\n+  * @deprecated The charset unicode is platform specific and InputStream\n+  * deals with bytes not chars. Use <code>getRederForText()</code>.\n+  */\n+public static final DataFlavor plainTextFlavor;\n+\n+/**\n+  * This is the data flavor used for transferring Java strings.  The\n+  * MIME type is \"application/x-java-serialized-object\" and the \n+  * representation class is <code>java.lang.String</code>.\n+  */\n+public static final DataFlavor stringFlavor;\n+\n+/**\n+  * This is a data flavor used for transferring lists of files.  The\n+  * representation type is a <code>java.util.List</code>, with each element of \n+  * the list being a <code>java.io.File</code>.\n+  */\n+public static final DataFlavor javaFileListFlavor;\n+\n+/**\n+  * This is the MIME type used for transferring a serialized object.\n+  * The representation class is the type of object be deserialized.\n+  */\n+public static final String javaSerializedObjectMimeType =\n+  \"application/x-java-serialized-object\";\n+\n+/**\n+  * This is the MIME type used to transfer a Java object reference within\n+  * the same JVM.  The representation class is the class of the object\n+  * being transferred.\n+  */\n+public static final String javaJVMLocalObjectMimeType =\n+  \"application/x-java-jvm-local-object\";\n+\n+/**\n+  * This is the MIME type used to transfer a link to a remote object.\n+  * The representation class is the type of object being linked to.\n+  */\n+public static final String javaRemoteObjectMimeType =\n+  \"application/x-java-remote-object\";\n+\n+static\n+{\n+  plainTextFlavor\n+      = new DataFlavor(java.io.InputStream.class,\n+\t\t       \"text/plain; charset=unicode\",\n+\t\t       \"plain unicode text\");\n+\n+  stringFlavor\n+      = new DataFlavor(java.lang.String.class,\n+\t\t       \"Java Unicode String\");\n+\n+  javaFileListFlavor\n+      = new DataFlavor(java.util.List.class,\n+\t\t       \"Java File List\");\n+\n+  // javaFileListFlavor.mimeType = \"application/x-java-file-list\";\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+// The MIME type for this flavor\n+private final String mimeType;\n+\n+// The representation class for this flavor\n+private final Class representationClass;\n+\n+// The human readable name of this flavor\n+private String humanPresentableName;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Static Methods\n+ */\n+\n+/**\n+  * This method attempts to load the named class.  The following class\n+  * loaders are searched in order: the bootstrap class loader, the\n+  * system class loader, the context class loader (if it exists), and\n+  * the specified fallback class loader.\n+  *\n+  * @param className The name of the class to load.\n+  * @param classLoader The class loader to use if all others fail, which\n+  * may be <code>null</code>.\n+  *\n+  * @exception ClassNotFoundException If the class cannot be loaded.\n+  */\n+protected static final Class\n+tryToLoadClass(String className, ClassLoader classLoader)\n+               throws ClassNotFoundException\n+{\n+  try\n+    {\n+      return(Class.forName(className));\n+    }\n+  catch(Exception e) { ; }\n+  // Commented out for Java 1.1\n+  /*\n+  try\n+    {\n+      return(className.getClass().getClassLoader().findClass(className));\n+    }\n+  catch(Exception e) { ; }\n+\n+  try\n+    {\n+      return(ClassLoader.getSystemClassLoader().findClass(className));\n+    }\n+  catch(Exception e) { ; }\n+  */\n+\n+  // FIXME: What is the context class loader?\n+  /*\n+  try\n+    {\n+    }\n+  catch(Exception e) { ; }\n+  */\n+\n+  if (classLoader != null)\n+    return(classLoader.loadClass(className));\n+  else\n+    throw new ClassNotFoundException(className);\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * Empty public constructor needed for externalization.\n+  * Should not be used for normal instantiation.\n+  */\n+public\n+DataFlavor()\n+{\n+    mimeType = null;\n+    representationClass = null;\n+    humanPresentableName = null;\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Private constructor.\n+  */\n+private\n+DataFlavor(Class representationClass,\n+\t   String mimeType,\n+\t   String humanPresentableName)\n+{\n+    this.representationClass = representationClass;\n+    this.mimeType = mimeType;\n+    if (humanPresentableName != null)\n+\tthis.humanPresentableName = humanPresentableName;\n+    else\n+\tthis.humanPresentableName = mimeType;\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Initializes a new instance of <code>DataFlavor</code>.  The class\n+  * and human readable name are specified, the MIME type will be\n+  * \"application/x-java-serialized-object\". If the human readable name\n+  * is not specified (<code>null</code>) then the human readable name\n+  * will be the same as the MIME type.\n+  *\n+  * @param representationClass The representation class for this object.\n+  * @param humanPresentableName The display name of the object.\n+  */\n+public\n+DataFlavor(Class representationClass, String humanPresentableName)\n+{\n+    this(representationClass,\n+       \"application/x-java-serialized-object\"\n+       + \"; class=\"\n+       + representationClass.getName(),\n+       humanPresentableName);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Initializes a new instance of <code>DataFlavor</code> with the\n+  * specified MIME type and description.  If the MIME type has a\n+  * \"class=<rep class>\" parameter then the representation class will\n+  * be the class name specified. Otherwise the class defaults to\n+  * <code>java.io.InputStream</code>. If the human readable name\n+  * is not specified (<code>null</code>) then the human readable name\n+  * will be the same as the MIME type.\n+  *\n+  * @param mimeType The MIME type for this flavor.\n+  * @param humanPresentableName The display name of this flavor.\n+  * @param classLoader The class loader for finding classes if the default\n+  * class loaders do not work.\n+  *\n+  * @exception IllegalArgumentException If the representation class\n+  * specified cannot be loaded.\n+  */\n+public\n+DataFlavor(String mimeType, String humanPresentableName, \n+           ClassLoader classLoader) throws ClassNotFoundException\n+{\n+  this(getRepresentationClassFromMime(mimeType, classLoader),\n+       mimeType, humanPresentableName);\n+}\n+\n+private static Class\n+getRepresentationClassFromMime(String mimeString, ClassLoader classLoader)\n+{\n+  String classname = getParameter(\"class\", mimeString);\n+  if (classname != null)\n+    {\n+      try\n+        {\n+          return tryToLoadClass(classname, classLoader);\n+        }\n+      catch(Exception e)\n+        {\n+          throw new IllegalArgumentException(\"classname: \" + e.getMessage());\n+        }\n+    }\n+  else\n+    {\n+      return java.io.InputStream.class;\n+    }\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Initializes a new instance of <code>DataFlavor</code> with the\n+  * specified MIME type and description.  If the MIME type has a\n+  * \"class=<rep class>\" parameter then the representation class will\n+  * be the class name specified. Otherwise the class defaults to\n+  * <code>java.io.InputStream</code>. If the human readable name\n+  * is not specified (<code>null</code>) then the human readable name\n+  * will be the same as the MIME type. This is the same as calling\n+  * <code>new DataFlavor(mimeType, humanPresentableName, null)</code>.\n+  *\n+  * @param mimeType The MIME type for this flavor.\n+  * @param humanPresentableName The display name of this flavor.\n+  * @param classLoader The class loader for finding classes.\n+  *\n+  * @exception IllegalArgumentException If the representation class\n+  * specified cannot be loaded.\n+  */\n+public\n+DataFlavor(String mimeType, String humanPresentableName)\n+           throws ClassNotFoundException\n+{\n+  this(mimeType, humanPresentableName, null);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Initializes a new instance of <code>DataFlavor</code> with the specified\n+  * MIME type.  This type can have a \"class=\" parameter to specify the\n+  * representation class, and then the class must exist or an exception will\n+  * be thrown. If there is no \"class=\" parameter then the representation class\n+  * will be <code>java.io.InputStream</code>. This is the same as calling\n+  * <code>new DataFlavor(mimeType, null)</code>.\n+  *\n+  * @param mimeType The MIME type for this flavor.\n+  *\n+  * @exception IllegalArgumentException If a class is not specified in\n+  * the MIME type.\n+  * @exception ClassNotFoundException If the class cannot be loaded.\n+  */\n+public\n+DataFlavor(String mimeType) throws ClassNotFoundException\n+{\n+  this(mimeType, null);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the MIME type of this flavor.\n+  *\n+  * @return The MIME type for this flavor.\n+  */\n+public String\n+getMimeType()\n+{\n+  return(mimeType);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the representation class for this flavor.\n+  *\n+  * @return The representation class for this flavor.\n+  */\n+public Class\n+getRepresentationClass()\n+{\n+  return(representationClass);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the human presentable name for this flavor.\n+  *\n+  * @return The human presentable name for this flavor.\n+  */\n+public String\n+getHumanPresentableName()\n+{\n+  return(humanPresentableName);\n+} \n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the primary MIME type for this flavor.\n+  *\n+  * @return The primary MIME type for this flavor.\n+  */\n+public String\n+getPrimaryType()\n+{\n+  int idx = mimeType.indexOf(\"/\");\n+  if (idx == -1)\n+    return(mimeType);\n+\n+  return(mimeType.substring(0, idx));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the MIME subtype for this flavor.\n+  *\n+  * @return The MIME subtype for this flavor.\n+  */\n+public String\n+getSubType()\n+{\n+  int idx = mimeType.indexOf(\"/\");\n+  if (idx == -1)\n+    return(\"\");\n+\n+  String subtype = mimeType.substring(idx + 1);\n+\n+  idx = subtype.indexOf(\" \");\n+  if (idx == -1)\n+    return(subtype);\n+  else\n+    return(subtype.substring(0, idx));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the value of the named MIME type parameter, or <code>null</code>\n+  * if the parameter does not exist. Given the parameter name and the mime\n+  * string.\n+  *\n+  * @param paramName The name of the parameter.\n+  * @param mimeString The mime string from where the name should be found.\n+  *\n+  * @return The value of the parameter or null.\n+  */\n+private static String\n+getParameter(String paramName, String mimeString)\n+{\n+  int idx = mimeString.indexOf(paramName + \"=\");\n+  if (idx == -1)\n+    return(null);\n+\n+  String value = mimeString.substring(idx + paramName.length() + 2);\n+\n+  idx = value.indexOf(\" \");\n+  if (idx == -1)\n+    return(value);\n+  else\n+    return(value.substring(0, idx));\n+}\n+\n+/*************************************************************************/\n+/**\n+  * Returns the value of the named MIME type parameter, or <code>null</code>\n+  * if the parameter does not exist.\n+  *\n+  * @param paramName The name of the paramter.\n+  *\n+  * @return The value of the parameter.\n+  */\n+public String\n+getParameter(String paramName)\n+{\n+  return getParameter(paramName, mimeType);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Sets the human presentable name to the specified value.\n+  *\n+  * @param humanPresentableName The new display name.\n+  */\n+public void\n+setHumanPresentableName(String humanPresentableName)\n+{\n+  this.humanPresentableName = humanPresentableName;\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Tests the MIME type of this object for equality against the specified\n+  * MIME type.\n+  *\n+  * @param mimeType The MIME type to test against.\n+  *\n+  * @return <code>true</code> if the MIME type is equal to this object's\n+  * MIME type, <code>false</code> otherwise.\n+  */\n+public boolean\n+isMimeTypeEqual(String mimeType)\n+{\n+  // FIXME: Need to handle default attributes and parameters\n+\n+  return(this.mimeType.equals(mimeType));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Tests the MIME type of this object for equality against the specified\n+  * data flavor's MIME type\n+  *\n+  * @param flavor The flavor to test against.\n+  *\n+  * @return <code>true</code> if the flavor's MIME type is equal to this \n+  * object's MIME type, <code>false</code> otherwise.\n+  */\n+public boolean\n+isMimeTypeEqual(DataFlavor flavor)\n+{\n+  return(isMimeTypeEqual(flavor.getMimeType()));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Tests whether or not this flavor represents a serialized object.\n+  *\n+  * @return <code>true</code> if this flavor represents a serialized\n+  * object, <code>false</code> otherwise.\n+  */\n+public boolean\n+isMimeTypeSerializedObject()\n+{\n+  return(mimeType.startsWith(javaSerializedObjectMimeType));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Tests whether or not this flavor has a representation class of\n+  * <code>java.io.InputStream</code>.\n+  *\n+  * @param <code>true</code> if the representation class of this flavor\n+  * is <code>java.io.InputStream</code>, <code>false</code> otherwise.\n+  */\n+public boolean\n+isRepresentationClassInputStream()\n+{\n+  return(representationClass.getName().equals(\"java.io.InputStream\"));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Tests whether the representation class for this flavor is\n+  * serializable.\n+  *\n+  * @param <code>true</code> if the representation class is serializable,\n+  * <code>false</code> otherwise.\n+  */\n+public boolean\n+isRepresentationClassSerializable()\n+{\n+  Class[] interfaces = representationClass.getInterfaces();\n+\n+  int i = 0;\n+  while (i < interfaces.length)\n+    {\n+      if (interfaces[i].getName().equals(\"java.io.Serializable\"))\n+        return(true);\n+      ++i;\n+    }\n+\n+  return(false);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Tests whether the representation class for his flavor is remote.\n+  *\n+  * @return <code>true</code> if the representation class is remote,\n+  * <code>false</code> otherwise.\n+  */\n+public boolean\n+isRepresentationClassRemote()\n+{\n+  // FIXME: Implement\n+  throw new RuntimeException(\"Not implemented\");\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Tests whether or not this flavor represents a serialized object.\n+  *\n+  * @return <code>true</code> if this flavor represents a serialized\n+  * object, <code>false</code> otherwise.\n+  */\n+public boolean\n+isFlavorSerializedObjectType()\n+{\n+  // FIXME: What is the diff between this and isMimeTypeSerializedObject?\n+  return(mimeType.startsWith(javaSerializedObjectMimeType));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Tests whether or not this flavor represents a remote object.\n+  *\n+  * @return <code>true</code> if this flavor represents a remote object,\n+  * <code>false</code> otherwise.\n+  */\n+public boolean\n+isFlavorRemoteObjectType()\n+{\n+  return(mimeType.startsWith(javaRemoteObjectMimeType));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Tests whether or not this flavor represents a list of files.\n+  *\n+  * @return <code>true</code> if this flavor represents a list of files,\n+  * <code>false</code> otherwise.\n+  */\n+public boolean\n+isFlavorJavaFileListType()\n+{\n+  if (this.mimeType.equals(javaFileListFlavor.mimeType) &&\n+      this.representationClass.equals(javaFileListFlavor.representationClass))\n+    return(true);\n+\n+  return(false);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns a copy of this object.\n+  *\n+  * @return A copy of this object.\n+  */\n+public Object\n+clone()\n+{\n+  try\n+    {\n+      return(super.clone());\n+    }\n+  catch(Exception e)\n+    {\n+      return(null);\n+    }\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method test the specified <code>DataFlavor</code> for equality\n+  * against this object.  This will be true if the MIME type and\n+  * representation type are the equal.\n+  *\n+  * @param flavor The <code>DataFlavor</code> to test against.\n+  *\n+  * @return <code>true</code> if the flavor is equal to this object,\n+  * <code>false</code> otherwise.\n+  */\n+public boolean\n+equals(DataFlavor flavor)\n+{\n+  if (flavor == null)\n+    return(false);\n+\n+  if (!this.mimeType.toLowerCase().equals(flavor.mimeType.toLowerCase()))\n+    return(false);\n+\n+  if (!this.representationClass.equals(flavor.representationClass))\n+    return(false);\n+\n+  return(true);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method test the specified <code>Object</code> for equality\n+  * against this object.  This will be true if the following conditions\n+  * are met:\n+  * <p>\n+  * <ul>\n+  * <li>The object is not <code>null</code>.\n+  * <li>The object is an instance of <code>DataFlavor</code>.\n+  * <li>The object's MIME type and representation class are equal to\n+  * this object's.\n+  * </ul>\n+  *\n+  * @param obj The <code>Object</code> to test against.\n+  *\n+  * @return <code>true</code> if the flavor is equal to this object,\n+  * <code>false</code> otherwise.\n+  */\n+public boolean\n+equals(Object obj)\n+{\n+  if (obj == null)\n+    return(false);\n+\n+  if (!(obj instanceof DataFlavor))\n+    return(false);\n+\n+  return(equals((DataFlavor)obj));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Tests whether or not the specified string is equal to the MIME type\n+  * of this object.\n+  *\n+  * @param str The string to test against.\n+  *\n+  * @return <code>true</code> if the string is equal to this object's MIME\n+  * type, <code>false</code> otherwise.\n+  *\n+  * @deprecated Not compatible with <code>hashCode()</code>.\n+  *             Use <code>isMimeTypeEqual()</code>\n+  */\n+public boolean\n+equals(String str)\n+{\n+  return(isMimeTypeEqual(str));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the hash code for this data flavor.\n+  * The hash code is based on the (lower case) mime type and the\n+  * representation class.\n+  */\n+public int\n+hashCode()\n+{\n+  return(mimeType.toLowerCase().hashCode()^representationClass.hashCode());\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns <code>true</code> when the given <code>DataFlavor</code>\n+  * matches this one.\n+  */\n+public boolean\n+match(DataFlavor dataFlavor)\n+{\n+  // XXX - How is this different from equals?\n+  return(equals(dataFlavor));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method exists for backward compatibility.  It simply returns\n+  * the same name/value pair passed in.\n+  *\n+  * @param name The parameter name.\n+  * @param value The parameter value.\n+  *\n+  * @return The name/value pair.\n+  *\n+  * @deprecated\n+  */\n+protected String\n+normalizeMimeTypeParameter(String name, String value)\n+{\n+  return(name + \"=\" + value);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method exists for backward compatibility.  It simply returns\n+  * the MIME type string unchanged.\n+  *\n+  * @param type The MIME type.\n+  * \n+  * @return The MIME type.\n+  *\n+  * @deprecated\n+  */\n+protected String\n+normalizeMimeType(String type)\n+{\n+  return(type);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Serialize this class.\n+  *\n+  * @param stream The <code>ObjectOutput</code> stream to serialize to.\n+  */\n+public void\n+writeExternal(ObjectOutput stream) throws IOException\n+{\n+  // FIXME: Implement me\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * De-serialize this class.\n+  *\n+  * @param stream The <code>ObjectInput</code> stream to deserialize from.\n+  */\n+public void\n+readExternal(ObjectInput stream) throws IOException, ClassNotFoundException\n+{\n+  // FIXME: Implement me\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns a string representation of this DataFlavor. Including the\n+  * representation class name, MIME type and human presentable name.\n+  */\n+public String\n+toString()\n+{\n+  return(\"DataFlavor[representationClass=\"\n+         + representationClass.getName()\n+         + \",mimeType=\"\n+         + mimeType\n+         + \"humanPresentableName=\"\n+         + humanPresentableName);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * XXX - Currently returns <code>plainTextFlavor</code>.\n+  */\n+public static final DataFlavor\n+getTextPlainUnicodeFlavor()\n+{\n+  return(plainTextFlavor);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * XXX - Currently returns <code>java.io.InputStream</code>.\n+  *\n+  * @since 1.3\n+  */\n+public static final Class\n+getDefaultRepresentationClass()\n+{\n+  return(java.io.InputStream.class);\n+}\n+/*************************************************************************/\n+\n+/**\n+  * XXX - Currently returns <code>java.io.InputStream</code>.\n+  */\n+public static final String\n+getDefaultRepresentationClassAsString()\n+{\n+  return(getDefaultRepresentationClass().getName());\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Selects the best supported text flavor on this implementation.\n+  * Returns <code>null</code> when none of the given flavors is liked.\n+  *\n+  * The <code>DataFlavor</code> returned the first data flavor in the\n+  * array that has either a representation class which is (a subclass of)\n+  * <code>Reader</code> or <code>String</code>, or has a representation\n+  * class which is (a subclass of) <code>InputStream</code> and has a\n+  * primary MIME type of \"text\" and has an supported encoding.\n+  */\n+public static final DataFlavor\n+selectBestTextFlavor(DataFlavor[] availableFlavors)\n+{\n+  for(int i=0; i<availableFlavors.length; i++)\n+    {\n+      DataFlavor df = availableFlavors[i];\n+      Class c = df.representationClass;\n+\n+      // A Reader or String is good.\n+      if ((Reader.class.isAssignableFrom(c))\n+\t  || (String.class.isAssignableFrom(c)))\n+\t{\n+\t  return df;\n+\t}\n+\n+      // A InputStream is good if the mime primary type is \"text\"\n+      if ((InputStream.class.isAssignableFrom(c))\n+\t  && (\"text\".equals(df.getPrimaryType())))\n+        {\n+          String encoding = availableFlavors[i].getParameter(\"charset\");\n+          if (encoding == null)\n+            encoding = \"us-ascii\";\n+          Reader r = null;\n+          try\n+            {\n+              // Try to construct a dummy reader with the found encoding\n+              r = new InputStreamReader\n+                    (new ByteArrayInputStream(new byte[0]), encoding);\n+            }\n+          catch(UnsupportedEncodingException uee) { /* ignore */ }\n+          if (r != null)\n+            return df;\n+        }\n+    }\n+\n+  // Nothing found\n+  return(null);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Creates a <code>Reader</code> for a given <code>Transferable</code>.\n+  *\n+  * If the representation class is a (subclass of) <code>Reader</code>\n+  * then an instance of the representation class is returned. If the\n+  * representatation class is a <code>String</code> then a\n+  * <code>StringReader</code> is returned. And if the representation class\n+  * is a (subclass of) <code>InputStream</code> and the primary MIME type\n+  * is \"text\" then a <code>InputStreamReader</code> for the correct charset\n+  * encoding is returned.\n+  *\n+  * @param transferable The <code>Transferable</code> for which a text\n+  *                     <code>Reader</code> is requested.\n+  * @exception UnsupportedFlavorException when the transferable doesn't\n+  * support this <code>DataFlavor</code>. Or if the representable class\n+  * isn't a (subclass of) <code>Reader</code>, <code>String</code>,\n+  * <code>InputStream</code> and/or the primary MIME type isn't \"text\".\n+  * @exception IOException when any IOException occurs.\n+  * @exception UnsupportedEncodingException if the \"charset\" isn't supported\n+  * on this platform.\n+  */\n+public Reader\n+getReaderForText(Transferable transferable) throws UnsupportedFlavorException,\n+                                                   IOException,\n+                                                   UnsupportedEncodingException\n+{\n+    if (!transferable.isDataFlavorSupported(this))\n+        throw new UnsupportedFlavorException(this);\n+\n+    if (Reader.class.isAssignableFrom(representationClass))\n+        return((Reader)transferable.getTransferData(this));\n+\n+    if (String.class.isAssignableFrom(representationClass))\n+        return(new StringReader((String)transferable.getTransferData(this)));\n+\n+    if (InputStream.class.isAssignableFrom(representationClass)\n+        && \"text\".equals(getPrimaryType()))\n+      {\n+        InputStream in = (InputStream)transferable.getTransferData(this);\n+        String encoding = getParameter(\"charset\");\n+        if (encoding == null)\n+            encoding = \"us-ascii\";\n+        return(new InputStreamReader(in, encoding));\n+      }\n+\n+    throw new UnsupportedFlavorException(this);\n+}\n+\n+} // class DataFlavor\n+"}, {"sha": "96b160842d9bc22552376d8272199a02d873d353", "filename": "libjava/java/awt/datatransfer/FlavorMap.java", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FFlavorMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FFlavorMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fdatatransfer%2FFlavorMap.java?ref=92bc8733c6da3c352889c1f03e0b628b5158fedf", "patch": "@@ -0,0 +1,82 @@\n+/* FlavorMap.java -- Maps between flavor names and MIME types.\n+   Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.datatransfer;\n+\n+import java.util.Map;\n+\n+/**\n+  * This interface maps between native platform type names and DataFlavors.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public interface FlavorMap\n+{\n+\n+/**\n+  * Maps the specified <code>DataFlavor</code> objects to the native\n+  * data type name.  The returned <code>Map</code> has keys that are\n+  * the data flavors and values that are strings.  The returned map\n+  * may be modified.  This can be useful for implementing nested mappings.\n+  *\n+  * @param flavors An array of data flavors to map\n+  *                or null for all data flavors.\n+  *\n+  * @return A <code>Map</code> of native data types.\n+  */\n+public abstract Map\n+getNativesForFlavors(DataFlavor[] flavors);\n+\n+/*************************************************************************/\n+\n+/**\n+  * Maps the specified native type names to <code>DataFlavor</code>'s.\n+  * The returned <code>Map</code> has keys that are strings and values\n+  * that are <code>DataFlavor</code>'s.  The returned map may be\n+  * modified.  This can be useful for implementing nested mappings.\n+  *\n+  * @param natives An array of native types to map\n+  *                or null for all native types.\n+  *\n+  * @return A <code>Map</code> of data flavors.\n+  */\n+public abstract Map\n+getFlavorsForNatives(String[] natives);\n+\n+} // interface FlavorMap\n+"}, {"sha": "32bc8850b31558dac5587854efd4f177190e6363", "filename": "libjava/java/awt/datatransfer/MimeTypeParseException.java", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FMimeTypeParseException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FMimeTypeParseException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fdatatransfer%2FMimeTypeParseException.java?ref=92bc8733c6da3c352889c1f03e0b628b5158fedf", "patch": "@@ -0,0 +1,70 @@\n+/* MimeTypeParseException.java -- Thrown when MIME string couldn't be parsed.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.datatransfer;\n+\n+/**\n+  * MIME string couldn't be parsed correctly.\n+  *\n+  * @author Mark Wielaard (mark@klomp.org)\n+  */\n+public class MimeTypeParseException extends Exception \n+{\n+\n+/**\n+  * Initializes a new instance of <code>MimeTypeParseException</code>\n+  * without any message.\n+  */\n+public\n+MimeTypeParseException()\n+{\n+  super();\n+}\n+\n+/**\n+  * Initializes a new instance of <code>MimeTypeParseException</code>\n+  * with a specified detailed error message.\n+  */\n+public\n+MimeTypeParseException(String message)\n+{\n+  super(message);\n+}\n+\n+} // class MimeTypeParseException\n+"}, {"sha": "f6f0116272be27b431737532916d096923255cac", "filename": "libjava/java/awt/datatransfer/StringSelection.java", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FStringSelection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FStringSelection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fdatatransfer%2FStringSelection.java?ref=92bc8733c6da3c352889c1f03e0b628b5158fedf", "patch": "@@ -0,0 +1,159 @@\n+/* StringSelection.java -- Clipboard handler for text.\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.datatransfer;\n+\n+import java.io.StringBufferInputStream;\n+import java.io.IOException;\n+\n+/**\n+  * This class transfers a string as plain text using the clipboard.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class StringSelection implements Transferable, ClipboardOwner\n+{\n+\n+/*\n+ * Class Variables\n+ */\n+\n+// List of flavors we support\n+public static final DataFlavor[] supported_flavors \n+   = { DataFlavor.plainTextFlavor };\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+// This is the data to transfer\n+private String data;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * Transfer the specfied string as text.\n+  */\n+public\n+StringSelection(String data)\n+{\n+  this.data = data;\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n+ */\n+\n+/**\n+  * Returns a list of supported data flavors.\n+  *\n+  * @return A list of supported data flavors.\n+  */\n+public DataFlavor[]\n+getTransferDataFlavors()\n+{\n+  return(supported_flavors);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Tests whether or not the specified data flavor is supported.\n+  *\n+  * @param flavor The data flavor to test.\n+  *\n+  * @return <code>true</code> if the data flavor is supported,\n+  * <code>false</code> otherwise.\n+  */\n+public boolean\n+isDataFlavorSupported(DataFlavor flavor)\n+{\n+  for (int i = 0; i < supported_flavors.length; i++)\n+    if (supported_flavors[i].equals(flavor))\n+       return(true);\n+\n+  return(false);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns the data in the requested format.\n+  *\n+  * @param flavor The desired data flavor.\n+  *\n+  * @return The transferred data.\n+  *\n+  * @exception UnsupportedFlavorException If the specified flavor is not\n+  * supported.\n+  * @exception IOException If any other error occurs.\n+  */\n+public Object\n+getTransferData(DataFlavor flavor) throws UnsupportedFlavorException,\n+                                          IOException\n+{\n+  if (!isDataFlavorSupported(flavor))\n+    throw new UnsupportedFlavorException(flavor);\n+\n+  return(new StringBufferInputStream(data));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Called when ownership of the clipboard object is lost.\n+  *\n+  * @param clipboard The affected clipboard.\n+  * @param contents The clipboard contents.\n+  */\n+public void\n+lostOwnership(Clipboard clipboard, Transferable contents)\n+{\n+  // FIXME: What does this do?\n+}\n+\n+} // class StringSelection \n+"}, {"sha": "50064db4c92a4803aee8c9867a97bf2cc8247eb3", "filename": "libjava/java/awt/datatransfer/SystemFlavorMap.java", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FSystemFlavorMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FSystemFlavorMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fdatatransfer%2FSystemFlavorMap.java?ref=92bc8733c6da3c352889c1f03e0b628b5158fedf", "patch": "@@ -0,0 +1,180 @@\n+/* SystemFlavorMap.java -- Maps between native flavor names and MIME types.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.datatransfer;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+  * This class maps between native platform type names and DataFlavors.\n+  *\n+  * XXX - The current implementation does no mapping at all.\n+  *\n+  * @author Mark Wielaard (mark@klomp.org)\n+  */\n+public final class SystemFlavorMap implements FlavorMap\n+{\n+\n+/**\n+  * The default (instance) flavor map.\n+  */\n+private static FlavorMap defaultFlavorMap;\n+\n+/**\n+  * Private constructor.\n+  */\n+private SystemFlavorMap()\n+{\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Maps the specified <code>DataFlavor</code> objects to the native\n+  * data type name.  The returned <code>Map</code> has keys that are\n+  * the data flavors and values that are strings.  The returned map\n+  * may be modified.  This can be useful for implementing nested mappings.\n+  *\n+  * @param flavors An array of data flavors to map\n+  *                or null for all data flavors.\n+  *\n+  * @return A <code>Map</code> of native data types to data flavors.\n+  */\n+public Map\n+getNativesForFlavors(DataFlavor[] flavors)\n+{\n+  return(new HashMap());\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Maps the specified native type names to <code>DataFlavor</code>'s.\n+  * The returned <code>Map</code> has keys that are strings and values\n+  * that are <code>DataFlavor</code>'s.  The returned map may be\n+  * modified.  This can be useful for implementing nested mappings.\n+  *\n+  * @param natives An array of native types to map\n+  *                or null for all native types.\n+  *\n+  * @return A <code>Map</code> of data flavors to native type names.\n+  */\n+public Map\n+getFlavorsForNatives(String[] natives)\n+{\n+  return(new HashMap());\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the default (instance) (System)FlavorMap.\n+  */\n+public static FlavorMap\n+getDefaultFlavorMap()\n+{\n+  if (defaultFlavorMap == null)\n+    defaultFlavorMap = new SystemFlavorMap();\n+\n+  return(defaultFlavorMap);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the native type name for the given java mime type.\n+  */\n+public static String\n+encodeJavaMIMEType(String mime)\n+{\n+  return null;\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the native type name for the given data flavor.\n+  */\n+public static String\n+encodeDataFlavor(DataFlavor df)\n+{\n+  return null;\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns true if the native type name can be represented as\n+  * a java mime type.\n+  */\n+public static boolean\n+isJavaMIMEType(String name)\n+{\n+  return(false);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the java mime type for the given the native type name.\n+  */\n+public static String\n+decodeJavaMIMEType(String name)\n+{\n+  return null;\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the data flavor given the native type name\n+  * or null when no such data flavor exists.\n+  */\n+public static DataFlavor\n+decodeDataFlavor(String name) throws ClassNotFoundException\n+{\n+  String javaMIMEType = decodeJavaMIMEType(name);\n+  if (javaMIMEType != null)\n+    return(new DataFlavor(javaMIMEType));\n+  else\n+    return(null);\n+}\n+\n+} // class SystemFlavorMap\n+"}, {"sha": "52dac691e5ba36a7f911090baacc8f682553f93d", "filename": "libjava/java/awt/datatransfer/Transferable.java", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FTransferable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FTransferable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fdatatransfer%2FTransferable.java?ref=92bc8733c6da3c352889c1f03e0b628b5158fedf", "patch": "@@ -0,0 +1,92 @@\n+/* Transferable.java -- Data transfer source\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.datatransfer;\n+\n+import java.io.IOException;\n+\n+/**\n+  * This interface is implemented by classes that can transfer data.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public interface Transferable\n+{\n+\n+/**\n+  * Returns the data in the specified <code>DataFlavor</code>\n+  *\n+  * @param flavor The data flavor to return.\n+  *\n+  * @return The data in the appropriate flavor.\n+  *\n+  * @exception UnsupportedFlavorException If the flavor is not supported.\n+  * @exception IOException If the data is not available.\n+  */\n+public abstract Object\n+getTransferData(DataFlavor flavor) throws UnsupportedFlavorException,\n+                                          IOException;\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns a list of available data flavors for the \n+  * data being transferred.  The array returned will be sorted from most\n+  * preferred flavor at the beginning to least preferred at the end.\n+  *\n+  * @return A list of data flavors for this data.\n+  */\n+public abstract DataFlavor[]\n+getTransferDataFlavors();\n+\n+/*************************************************************************/\n+\n+/**\n+  * Tests whether or not this data can be delivered in the specified\n+  * data flavor.\n+  *\n+  * @param flavor The data flavor to test.\n+  *\n+  * @return <code>true</code> if the data flavor is supported,\n+  * <code>false</code> otherwise.\n+  */\n+public abstract boolean\n+isDataFlavorSupported(DataFlavor flavor);\n+\n+} // interface Transferable\n+"}, {"sha": "a31059ef23ac9fa7ce2ecc52658348313fa54bc9", "filename": "libjava/java/awt/datatransfer/UnsupportedFlavorException.java", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FUnsupportedFlavorException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bc8733c6da3c352889c1f03e0b628b5158fedf/libjava%2Fjava%2Fawt%2Fdatatransfer%2FUnsupportedFlavorException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fdatatransfer%2FUnsupportedFlavorException.java?ref=92bc8733c6da3c352889c1f03e0b628b5158fedf", "patch": "@@ -0,0 +1,62 @@\n+/* UnsupportedFlavorException.java -- Data flavor is not valid.\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.datatransfer;\n+\n+/**\n+  * The data flavor requested is not supported for the transfer data.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class UnsupportedFlavorException extends Exception \n+{\n+\n+/**\n+  * Initializes a new instance of <code>UnsupportedDataFlavor</code>\n+  * for the specified data flavor.\n+  *\n+  * @param flavor The data flavor that is not supported.\n+  */\n+public\n+UnsupportedFlavorException(DataFlavor flavor)\n+{\n+  super(flavor.getHumanPresentableName());\n+}\n+\n+} // class UnsupportedFlavorException \n+"}]}