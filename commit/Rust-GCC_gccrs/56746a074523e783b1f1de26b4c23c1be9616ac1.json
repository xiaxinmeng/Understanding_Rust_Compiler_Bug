{"sha": "56746a074523e783b1f1de26b4c23c1be9616ac1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY3NDZhMDc0NTIzZTc4M2IxZjFkZTI2YjRjMjNjMWJlOTYxNmFjMQ==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2004-12-27T16:43:25Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-12-27T16:43:25Z"}, "message": "trans-intrinsic.c (gfc_conv_intrinsic_ishft): Change to logicalshift.\n\ngcc/fortran/\n* trans-intrinsic.c (gfc_conv_intrinsic_ishft): Change to\nlogicalshift.  Call fold.  Remove 0-bit shift shortcut.\n(gfc_conv_intrinsic_ishftc): Convert first argument to at least\n4 bytes bits.  Convert 2nd and 3rd argument to 4 bytes.  Convert\nresult if width(arg 1) < 4 bytes.  Call fold.\n\nlibgfortran/\n* libgfortran/libgfortran.h (GFC_UINTEGER_1, GFC_UINTEGER_2):\nDefine.\n* intrinsics/ishftc.c: Update copyright years.\n(ishftc8): Change 'shift' and 'size' to GFC_INTEGER_4.\n* intrinsics/mvbits.c: Correcty non-ASCII character in my name.\nAdd implementations for GFC_INTEGER_1 and GFC_INTEGER_2.\n\ngcc/testsuite/\n* gfortran.dg/g77/f90-intrinsic-bit.f: New.\n\nFrom-SVN: r92642", "tree": {"sha": "b88e393afbb9bf77f96b70a52f9243489d970d7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b88e393afbb9bf77f96b70a52f9243489d970d7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56746a074523e783b1f1de26b4c23c1be9616ac1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56746a074523e783b1f1de26b4c23c1be9616ac1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56746a074523e783b1f1de26b4c23c1be9616ac1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56746a074523e783b1f1de26b4c23c1be9616ac1/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64092f8bc204184c4a78740dab1625753d61318e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64092f8bc204184c4a78740dab1625753d61318e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64092f8bc204184c4a78740dab1625753d61318e"}], "stats": {"total": 600, "additions": 567, "deletions": 33}, "files": [{"sha": "5f2707e67720be9bfe81ee2c965c2e5b3b8d5ff0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56746a074523e783b1f1de26b4c23c1be9616ac1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56746a074523e783b1f1de26b4c23c1be9616ac1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=56746a074523e783b1f1de26b4c23c1be9616ac1", "patch": "@@ -1,3 +1,11 @@\n+2004-12-27  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de> \n+\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_ishft): Change to\n+\tlogical\tshift.  Call fold.  Remove 0-bit shift shortcut.\n+\t(gfc_conv_intrinsic_ishftc): Convert first argument to at least\n+\t4 bytes bits.  Convert 2nd and 3rd argument to 4 bytes.  Convert\n+\tresult if width(arg 1) < 4 bytes.  Call fold.\n+\n 2004-12-23  Steven G. Kargl  <kargls@comcast.net>\n \n \t* gfortran.texi: Fix typo."}, {"sha": "56def1a7373d4d568f428c3682e8d990629aad9a", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 65, "deletions": 29, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56746a074523e783b1f1de26b4c23c1be9616ac1/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56746a074523e783b1f1de26b4c23c1be9616ac1/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=56746a074523e783b1f1de26b4c23c1be9616ac1", "patch": "@@ -1774,38 +1774,58 @@ gfc_conv_intrinsic_ibits (gfc_se * se, gfc_expr * expr)\n   se->expr = fold (build2 (BIT_AND_EXPR, type, tmp, mask));\n }\n \n-/* ISHFT (I, SHIFT) = (shift >= 0) ? i << shift : i >> -shift.  */\n+/* ISHFT (I, SHIFT) = (abs (shift) >= BIT_SIZE (i))\n+                        ? 0\n+\t \t        : ((shift >= 0) ? i << shift : i >> -shift)\n+   where all shifts are logical shifts.  */\n static void\n gfc_conv_intrinsic_ishft (gfc_se * se, gfc_expr * expr)\n {\n   tree arg;\n   tree arg2;\n   tree type;\n+  tree utype;\n   tree tmp;\n+  tree width;\n+  tree num_bits;\n+  tree cond;\n   tree lshift;\n   tree rshift;\n \n   arg = gfc_conv_intrinsic_function_args (se, expr);\n   arg2 = TREE_VALUE (TREE_CHAIN (arg));\n   arg = TREE_VALUE (arg);\n   type = TREE_TYPE (arg);\n+  utype = gfc_unsigned_type (type);\n+\n+  /* We convert to an unsigned type because we want a logical shift.\n+     The standard doesn't define the case of shifting negative\n+     numbers, and we try to be compatible with other compilers, most\n+     notably g77, here.  */\n+  arg = convert (utype, arg);\n+  width = fold (build1 (ABS_EXPR, TREE_TYPE (arg2), arg2));\n \n   /* Left shift if positive.  */\n-  lshift = build2 (LSHIFT_EXPR, type, arg, arg2);\n+  lshift = fold (build2 (LSHIFT_EXPR, type, arg, width));\n \n-  /* Right shift if negative.  This will perform an arithmetic shift as\n-     we are dealing with signed integers.  Section 13.5.7 allows this.  */\n-  tmp = build1 (NEGATE_EXPR, TREE_TYPE (arg2), arg2);\n-  rshift = build2 (RSHIFT_EXPR, type, arg, tmp);\n+  /* Right shift if negative.  */\n+  rshift = convert (type, fold (build2 (RSHIFT_EXPR, utype, arg, width)));\n \n-  tmp = build2 (GT_EXPR, boolean_type_node, arg2,\n-\t\tconvert (TREE_TYPE (arg2), integer_zero_node));\n-  rshift = build3 (COND_EXPR, type, tmp, lshift, rshift);\n+  tmp = fold (build2 (GE_EXPR, boolean_type_node, arg2,\n+\t\t      convert (TREE_TYPE (arg2), integer_zero_node)));\n+  tmp = fold (build3 (COND_EXPR, type, tmp, lshift, rshift));\n \n-  /* Do nothing if shift == 0.  */\n-  tmp = build2 (EQ_EXPR, boolean_type_node, arg2,\n-\t\tconvert (TREE_TYPE (arg2), integer_zero_node));\n-  se->expr = build3 (COND_EXPR, type, tmp, arg, rshift);\n+  /* The Fortran standard allows shift widths <= BIT_SIZE(I), whereas\n+     gcc requires a shift width < BIT_SIZE(I), so we have to catch this\n+     special case.  */\n+  num_bits = convert (TREE_TYPE (arg2),\t\n+\t\t      build_int_cst (NULL, TYPE_PRECISION (type)));\n+  cond = fold (build2 (GE_EXPR, boolean_type_node, width,\n+\t\t       convert (TREE_TYPE (arg2), num_bits)));\n+\n+  se->expr = fold (build3 (COND_EXPR, type, cond, \n+\t\t\t   convert (type, integer_zero_node),\n+\t\t\t   tmp));\n }\n \n /* Circular shift.  AKA rotate or barrel shift.  */\n@@ -1826,17 +1846,28 @@ gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n   if (arg3)\n     {\n       /* Use a library function for the 3 parameter version.  */\n+      tree int4type = gfc_get_int_type (4);\n+\n       type = TREE_TYPE (TREE_VALUE (arg));\n-      /* Convert all args to the same type otherwise we need loads of library\n-         functions.  SIZE and SHIFT cannot have values > BIT_SIZE (I) so the\n-         conversion is safe.  */\n-      tmp = convert (type, TREE_VALUE (arg2));\n-      TREE_VALUE (arg2) = tmp;\n-      tmp = convert (type, TREE_VALUE (arg3));\n-      TREE_VALUE (arg3) = tmp;\n+      /* We convert the first argument to at least 4 bytes, and\n+\t convert back afterwards.  This removes the need for library\n+\t functions for all argument sizes, and function will be\n+\t aligned to at least 32 bits, so there's no loss.  */\n+      if (expr->ts.kind < 4)\n+\t{\n+\t  tmp = convert (int4type, TREE_VALUE (arg));\n+\t  TREE_VALUE (arg) = tmp;\n+\t}\n+      /* Convert the SHIFT and SIZE args to INTEGER*4 otherwise we would\n+         need loads of library  functions.  They cannot have values >\n+\t BIT_SIZE (I) so the conversion is safe.  */\n+      TREE_VALUE (arg2) = convert (int4type, TREE_VALUE (arg2));\n+      TREE_VALUE (arg3) = convert (int4type, TREE_VALUE (arg3));\n \n       switch (expr->ts.kind)\n \t{\n+\tcase 1:\n+\tcase 2:\n \tcase 4:\n \t  tmp = gfor_fndecl_math_ishftc4;\n \t  break;\n@@ -1847,27 +1878,32 @@ gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n \t  gcc_unreachable ();\n \t}\n       se->expr = gfc_build_function_call (tmp, arg);\n+      /* Convert the result back to the original type, if we extended\n+\t the first argument's width above.  */\n+      if (expr->ts.kind < 4)\n+\tse->expr = convert (type, se->expr);\n+\n       return;\n     }\n   arg = TREE_VALUE (arg);\n   arg2 = TREE_VALUE (arg2);\n   type = TREE_TYPE (arg);\n \n   /* Rotate left if positive.  */\n-  lrot = build2 (LROTATE_EXPR, type, arg, arg2);\n+  lrot = fold (build2 (LROTATE_EXPR, type, arg, arg2));\n \n   /* Rotate right if negative.  */\n-  tmp = build1 (NEGATE_EXPR, TREE_TYPE (arg2), arg2);\n-  rrot = build2 (RROTATE_EXPR, type, arg, tmp);\n+  tmp = fold (build1 (NEGATE_EXPR, TREE_TYPE (arg2), arg2));\n+  rrot = fold (build2 (RROTATE_EXPR, type, arg, tmp));\n \n-  tmp = build2 (GT_EXPR, boolean_type_node, arg2,\n-\t\tconvert (TREE_TYPE (arg2), integer_zero_node));\n-  rrot = build3 (COND_EXPR, type, tmp, lrot, rrot);\n+  tmp = fold (build2 (GT_EXPR, boolean_type_node, arg2,\n+\t\t      convert (TREE_TYPE (arg2), integer_zero_node)));\n+  rrot = fold (build3 (COND_EXPR, type, tmp, lrot, rrot));\n \n   /* Do nothing if shift == 0.  */\n-  tmp = build2 (EQ_EXPR, boolean_type_node, arg2,\n-\t\tconvert (TREE_TYPE (arg2), integer_zero_node));\n-  se->expr = build3 (COND_EXPR, type, tmp, arg, rrot);\n+  tmp = fold (build2 (EQ_EXPR, boolean_type_node, arg2,\n+\t\t      convert (TREE_TYPE (arg2), integer_zero_node)));\n+  se->expr = fold (build3 (COND_EXPR, type, tmp, arg, rrot));\n }\n \n /* The length of a character string.  */"}, {"sha": "929a3261fa9ac5e03632f0a3fbdfc539bc6cac11", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56746a074523e783b1f1de26b4c23c1be9616ac1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56746a074523e783b1f1de26b4c23c1be9616ac1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=56746a074523e783b1f1de26b4c23c1be9616ac1", "patch": "@@ -1,3 +1,7 @@\n+2004-12-27  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\t* gfortran.dg/g77/f90-intrinsic-bit.f: New.\n+\n 2004-12-27  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/19148"}, {"sha": "b718a4cb41f0cd7ce1fbe311335b9cd1432f1c54", "filename": "gcc/testsuite/gfortran.dg/g77/f90-intrinsic-bit.f", "status": "added", "additions": 459, "deletions": 0, "changes": 459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56746a074523e783b1f1de26b4c23c1be9616ac1/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Ff90-intrinsic-bit.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56746a074523e783b1f1de26b4c23c1be9616ac1/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Ff90-intrinsic-bit.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Ff90-intrinsic-bit.f?ref=56746a074523e783b1f1de26b4c23c1be9616ac1", "patch": "@@ -0,0 +1,459 @@\n+c { dg-do run }\n+c  f90-intrinsic-bit.f\n+c\n+c Test Fortran 90 \n+c  * intrinsic bit manipulation functions - Section 13.10.10\n+c  * bitcopy subroutine - Section 13.9.3 \n+c David Billinghurst <David.Billinghurst@riotinto.com>\n+c\n+c Notes: \n+c  * g77 only supports scalar arguments\n+c  * third argument of ISHFTC is not optional in g77\n+\n+      logical fail\n+      integer   i, i2, ia, i3\n+      integer*2 j, j2, j3, ja\n+      integer*1 k, k2, k3, ka\n+      integer*8 m, m2, m3, ma\n+\n+      common /flags/ fail\n+      fail = .false.\n+\n+c     BIT_SIZE - Section 13.13.16\n+c     Determine BIT_SIZE by counting the bits \n+      ia = 0\n+      i = 0\n+      i = not(i)\n+      do while ( (i.ne.0) .and. (ia.lt.127) ) \n+         ia = ia + 1\n+         i = ishft(i,-1)\n+      end do\n+      call c_i(BIT_SIZE(i),ia,'BIT_SIZE(integer)')\n+      ja = 0\n+      j = 0\n+      j = not(j)\n+      do while  ( (j.ne.0) .and. (ja.lt.127) ) \n+         ja = ja + 1\n+         j = ishft(j,-1)\n+      end do\n+      call c_i2(BIT_SIZE(j),ja,'BIT_SIZE(integer*2)')\n+      ka = 0\n+      k = 0\n+      k = not(k)\n+      do while ( (k.ne.0) .and. (ka.lt.127) )\n+         ka = ka + 1\n+         k = ishft(k,-1)\n+      end do\n+      call c_i1(BIT_SIZE(k),ka,'BIT_SIZE(integer*1)')\n+      ma = 0\n+      m = 0\n+      m = not(m)\n+      do while ( (m.ne.0) .and. (ma.lt.127) )\n+         ma = ma + 1\n+         m = ishft(m,-1)\n+      end do\n+      call c_i8(BIT_SIZE(m),ma,'BIT_SIZE(integer*8)')\n+\n+c     BTEST  - Section 13.13.17\n+      j  = 7\n+      j2 = 3\n+      k  = 7\n+      k2 = 3\n+      m  = 7\n+      m2 = 3\n+      call c_l(BTEST(7,3),.true.,'BTEST(integer,integer)')\n+      call c_l(BTEST(7,j2),.true.,'BTEST(integer,integer*2)')\n+      call c_l(BTEST(7,k2),.true.,'BTEST(integer,integer*1)')\n+      call c_l(BTEST(7,m2),.true.,'BTEST(integer,integer*8)')\n+      call c_l(BTEST(j,3),.true.,'BTEST(integer*2,integer)')\n+      call c_l(BTEST(j,j2),.true.,'BTEST(integer*2,integer*2)')\n+      call c_l(BTEST(j,k2),.true.,'BTEST(integer*2,integer*1)')\n+      call c_l(BTEST(j,m2),.true.,'BTEST(integer*2,integer*8)')\n+      call c_l(BTEST(k,3),.true.,'BTEST(integer*1,integer)')\n+      call c_l(BTEST(k,j2),.true.,'BTEST(integer*1,integer*2)')\n+      call c_l(BTEST(k,k2),.true.,'BTEST(integer*1,integer*1)')\n+      call c_l(BTEST(k,m2),.true.,'BTEST(integer*1,integer*8)')\n+      call c_l(BTEST(m,3),.true.,'BTEST(integer*8,integer)')\n+      call c_l(BTEST(m,j2),.true.,'BTEST(integer*8,integer*2)')\n+      call c_l(BTEST(m,k2),.true.,'BTEST(integer*8,integer*1)')\n+      call c_l(BTEST(m,m2),.true.,'BTEST(integer*8,integer*8)')\n+ \n+c     IAND   - Section 13.13.40\n+      j  = 3\n+      j2 = 1\n+      ja = 1\n+      k  = 3\n+      k2 = 1\n+      ka = 1\n+      m  = 3\n+      m2 = 1\n+      ma = 1\n+      call c_i(IAND(3,1),1,'IAND(integer,integer)')\n+      call c_i2(IAND(j,j2),ja,'IAND(integer*2,integer*2)')\n+      call c_i1(IAND(k,k2),ka,'IAND(integer*1,integer*1)')\n+      call c_i8(IAND(m,m2),ma,'IAND(integer*8,integer*8)')\n+\n+\n+c     IBCLR  - Section 13.13.41\n+      j  = 14\n+      j2 = 1\n+      ja = 12\n+      k  = 14\n+      k2 = 1\n+      ka = 12\n+      m  = 14\n+      m2 = 1\n+      ma = 12\n+      call c_i(IBCLR(14,1),12,'IBCLR(integer,integer)')\n+      call c_i(IBCLR(14,j2),12,'IBCLR(integer,integer*2)')\n+      call c_i(IBCLR(14,k2),12,'IBCLR(integer,integer*1)')\n+      call c_i(IBCLR(14,m2),12,'IBCLR(integer,integer*8)')\n+      call c_i2(IBCLR(j,1),ja,'IBCLR(integer*2,integer)')\n+      call c_i2(IBCLR(j,j2),ja,'IBCLR(integer*2,integer*2)')\n+      call c_i2(IBCLR(j,k2),ja,'IBCLR(integer*2,integer*1)')\n+      call c_i2(IBCLR(j,m2),ja,'IBCLR(integer*2,integer*8)')\n+      call c_i1(IBCLR(k,1),ka,'IBCLR(integer*1,integer)')\n+      call c_i1(IBCLR(k,j2),ka,'IBCLR(integer*1,integer*2)')\n+      call c_i1(IBCLR(k,k2),ka,'IBCLR(integer*1,integer*1)')\n+      call c_i1(IBCLR(k,m2),ka,'IBCLR(integer*1,integer*8)')\n+      call c_i8(IBCLR(m,1),ma,'IBCLR(integer*8,integer)')\n+      call c_i8(IBCLR(m,j2),ma,'IBCLR(integer*8,integer*2)')\n+      call c_i8(IBCLR(m,k2),ma,'IBCLR(integer*8,integer*1)')\n+      call c_i8(IBCLR(m,m2),ma,'IBCLR(integer*8,integer*8)')\n+\n+c     IBSET  - Section 13.13.43\n+      j  = 12\n+      j2 = 1\n+      ja = 14\n+      k  = 12\n+      k2 = 1\n+      ka = 14\n+      m  = 12\n+      m2 = 1\n+      ma = 14\n+      call c_i(IBSET(12,1),14,'IBSET(integer,integer)')\n+      call c_i(IBSET(12,j2),14,'IBSET(integer,integer*2)')\n+      call c_i(IBSET(12,k2),14,'IBSET(integer,integer*1)')\n+      call c_i(IBSET(12,m2),14,'IBSET(integer,integer*8)')\n+      call c_i2(IBSET(j,1),ja,'IBSET(integer*2,integer)')\n+      call c_i2(IBSET(j,j2),ja,'IBSET(integer*2,integer*2)')\n+      call c_i2(IBSET(j,k2),ja,'IBSET(integer*2,integer*1)')\n+      call c_i2(IBSET(j,m2),ja,'IBSET(integer*2,integer*8)')\n+      call c_i1(IBSET(k,1),ka,'IBSET(integer*1,integer)')\n+      call c_i1(IBSET(k,j2),ka,'IBSET(integer*1,integer*2)')\n+      call c_i1(IBSET(k,k2),ka,'IBSET(integer*1,integer*1)')\n+      call c_i1(IBSET(k,m2),ka,'IBSET(integer*1,integer*8)')\n+      call c_i8(IBSET(m,1),ma,'IBSET(integer*8,integer)')\n+      call c_i8(IBSET(m,j2),ma,'IBSET(integer*8,integer*2)')\n+      call c_i8(IBSET(m,k2),ma,'IBSET(integer*8,integer*1)')\n+      call c_i8(IBSET(m,m2),ma,'IBSET(integer*8,integer*8)')\n+\n+c     IEOR   - Section 13.13.45\n+      j  = 3\n+      j2 = 1\n+      ja = 2\n+      k  = 3\n+      k2 = 1\n+      ka = 2\n+      m  = 3\n+      m2 = 1\n+      ma = 2\n+      call c_i(IEOR(3,1),2,'IEOR(integer,integer)')\n+      call c_i2(IEOR(j,j2),ja,'IEOR(integer*2,integer*2)')\n+      call c_i1(IEOR(k,k2),ka,'IEOR(integer*1,integer*1)')\n+      call c_i8(IEOR(m,m2),ma,'IEOR(integer*8,integer*8)')\n+\n+c     ISHFT  - Section 13.13.49\n+      i  = 3\n+      i2 = 1\n+      i3 = 0\n+      ia = 6\n+      j  = 3\n+      j2 = 1\n+      j3 = 0\n+      ja = 6\n+      k  = 3\n+      k2 = 1\n+      k3 = 0\n+      ka = 6\n+      m  = 3\n+      m2 = 1\n+      m3 = 0\n+      ma = 6\n+      call c_i(ISHFT(i,i2),ia,'ISHFT(integer,integer)')\n+      call c_i(ISHFT(i,BIT_SIZE(i)),i3,'ISHFT(integer,integer) 2')\n+      call c_i(ISHFT(i,-BIT_SIZE(i)),i3,'ISHFT(integer,integer) 3')\n+      call c_i(ISHFT(i,0),i,'ISHFT(integer,integer) 4')\n+      call c_i2(ISHFT(j,j2),ja,'ISHFT(integer*2,integer*2)')\n+      call c_i2(ISHFT(j,BIT_SIZE(j)),j3,\n+     $     'ISHFT(integer*2,integer*2) 2')\n+      call c_i2(ISHFT(j,-BIT_SIZE(j)),j3,\n+     $     'ISHFT(integer*2,integer*2) 3')\n+      call c_i2(ISHFT(j,0),j,'ISHFT(integer*2,integer*2) 4')\n+      call c_i1(ISHFT(k,k2),ka,'ISHFT(integer*1,integer*1)')\n+      call c_i1(ISHFT(k,BIT_SIZE(k)),k3,\n+     $     'ISHFT(integer*1,integer*1) 2')\n+      call c_i1(ISHFT(k,-BIT_SIZE(k)),k3,\n+     $     'ISHFT(integer*1,integer*1) 3')\n+      call c_i1(ISHFT(k,0),k,'ISHFT(integer*1,integer*1) 4')\n+      call c_i8(ISHFT(m,m2),ma,'ISHFT(integer*8,integer*8)')\n+      call c_i8(ISHFT(m,BIT_SIZE(m)),m3,\n+     $     'ISHFT(integer*8,integer*8) 2')\n+      call c_i8(ISHFT(m,-BIT_SIZE(m)),m3,\n+     $     'ISHFT(integer*8,integer*8) 3')\n+      call c_i8(ISHFT(m,0),m,'ISHFT(integer*8,integer*8) 4')\n+\n+c     ISHFTC - Section 13.13.50\n+c     The third argument is not optional in g77\n+      i  = 3\n+      i2 = 2\n+      i3 = 3\n+      ia = 5\n+      j  = 3\n+      j2 = 2\n+      j3 = 3\n+      ja = 5\n+      k  = 3\n+      k2 = 2\n+      k3 = 3\n+      ka = 5\n+      m2 = 2\n+      m3 = 3\n+      ma = 5\n+c     test all the combinations of arguments\n+      call c_i(ISHFTC(i,i2,i3),5,'ISHFTC(integer,integer,integer)')\n+      call c_i(ISHFTC(i,i2,j3),5,'ISHFTC(integer,integer,integer*2)')\n+      call c_i(ISHFTC(i,i2,k3),5,'ISHFTC(integer,integer,integer*1)')\n+      call c_i(ISHFTC(i,i2,m3),5,'ISHFTC(integer,integer,integer*8)')\n+      call c_i(ISHFTC(i,j2,i3),5,'ISHFTC(integer,integer*2,integer)')\n+      call c_i(ISHFTC(i,j2,j3),5,'ISHFTC(integer,integer*2,integer*2)')\n+      call c_i(ISHFTC(i,j2,k3),5,'ISHFTC(integer,integer*2,integer*1)')\n+      call c_i(ISHFTC(i,j2,m3),5,'ISHFTC(integer,integer*2,integer*8)')\n+      call c_i(ISHFTC(i,k2,i3),5,'ISHFTC(integer,integer*1,integer)')\n+      call c_i(ISHFTC(i,k2,j3),5,'ISHFTC(integer,integer*1,integer*2)')\n+      call c_i(ISHFTC(i,k2,k3),5,'ISHFTC(integer,integer*1,integer*1)')\n+      call c_i(ISHFTC(i,k2,m3),5,'ISHFTC(integer,integer*1,integer*8)')\n+      call c_i(ISHFTC(i,m2,i3),5,'ISHFTC(integer,integer*8,integer)')\n+      call c_i(ISHFTC(i,m2,j3),5,'ISHFTC(integer,integer*8,integer*2)')\n+      call c_i(ISHFTC(i,m2,k3),5,'ISHFTC(integer,integer*8,integer*1)')\n+      call c_i(ISHFTC(i,m2,m3),5,'ISHFTC(integer,integer*8,integer*8)')\n+\n+      call c_i2(ISHFTC(j,i2,i3),ja,'ISHFTC(integer*2,integer,integer)')\n+      call c_i2(ISHFTC(j,i2,j3),ja,\n+     $     'ISHFTC(integer*2,integer,integer*2)')\n+      call c_i2(ISHFTC(j,i2,k3),ja,\n+     $     'ISHFTC(integer*2,integer,integer*1)')\n+      call c_i2(ISHFTC(j,i2,m3),ja,\n+     $     'ISHFTC(integer*2,integer,integer*8)')\n+      call c_i2(ISHFTC(j,j2,i3),ja,\n+     $     'ISHFTC(integer*2,integer*2,integer)')\n+      call c_i2(ISHFTC(j,j2,j3),ja,\n+     $     'ISHFTC(integer*2,integer*2,integer*2)')\n+      call c_i2(ISHFTC(j,j2,k3),ja,\n+     $     'ISHFTC(integer*2,integer*2,integer*1)')\n+      call c_i2(ISHFTC(j,j2,m3),ja,\n+     $     'ISHFTC(integer*2,integer*2,integer*8)')\n+      call c_i2(ISHFTC(j,k2,i3),ja,\n+     $     'ISHFTC(integer*2,integer*1,integer)')\n+      call c_i2(ISHFTC(j,k2,j3),ja,\n+     $     'ISHFTC(integer*2,integer*1,integer*2)')\n+      call c_i2(ISHFTC(j,k2,k3),ja,\n+     $     'ISHFTC(integer*2,integer*1,integer*1)')\n+      call c_i2(ISHFTC(j,k2,m3),ja,\n+     $     'ISHFTC(integer*2,integer*1,integer*8)')\n+      call c_i2(ISHFTC(j,m2,i3),ja,\n+     $     'ISHFTC(integer*2,integer*8,integer)')\n+      call c_i2(ISHFTC(j,m2,j3),ja,\n+     $     'ISHFTC(integer*2,integer*8,integer*2)')\n+      call c_i2(ISHFTC(j,m2,k3),ja,\n+     $     'ISHFTC(integer*2,integer*8,integer*1)')\n+      call c_i2(ISHFTC(j,m2,m3),ja,\n+     $     'ISHFTC(integer*2,integer*8,integer*8)')\n+\n+      call c_i1(ISHFTC(k,i2,i3),ka,'ISHFTC(integer*1,integer,integer)')\n+      call c_i1(ISHFTC(k,i2,j3),ka,\n+     $     'ISHFTC(integer*1,integer,integer*2)')\n+      call c_i1(ISHFTC(k,i2,k3),ka,\n+     $     'ISHFTC(integer*1,integer,integer*1)')\n+      call c_i1(ISHFTC(k,i2,m3),ka,\n+     $     'ISHFTC(integer*1,integer,integer*8)')\n+      call c_i1(ISHFTC(k,j2,i3),ka,\n+     $     'ISHFTC(integer*1,integer*2,integer)')\n+      call c_i1(ISHFTC(k,j2,j3),ka,\n+     $     'ISHFTC(integer*1,integer*2,integer*2)')\n+      call c_i1(ISHFTC(k,j2,k3),ka,\n+     $     'ISHFTC(integer*1,integer*2,integer*1)')\n+      call c_i1(ISHFTC(k,j2,m3),ka,\n+     $     'ISHFTC(integer*1,integer*2,integer*8)')\n+      call c_i1(ISHFTC(k,k2,i3),ka,\n+     $     'ISHFTC(integer*1,integer*1,integer)')\n+      call c_i1(ISHFTC(k,k2,j3),ka,\n+     $     'ISHFTC(integer*1,integer*1,integer*2)')\n+      call c_i1(ISHFTC(k,k2,k3),ka,\n+     $     'ISHFTC(integer*1,integer*1,integer*1)')\n+      call c_i1(ISHFTC(k,k2,m3),ka,\n+     $     'ISHFTC(integer*1,integer*1,integer*8)')\n+      call c_i1(ISHFTC(k,m2,i3),ka,\n+     $     'ISHFTC(integer*1,integer*8,integer)')\n+      call c_i1(ISHFTC(k,m2,j3),ka,\n+     $     'ISHFTC(integer*1,integer*8,integer*2)')\n+      call c_i1(ISHFTC(k,m2,k3),ka,\n+     $     'ISHFTC(integer*1,integer*8,integer*1)')\n+      call c_i1(ISHFTC(k,m2,m3),ka,\n+     $     'ISHFTC(integer*1,integer*8,integer*8)')\n+\n+      call c_i8(ISHFTC(m,i2,i3),ma,'ISHFTC(integer*8,integer,integer)')\n+      call c_i8(ISHFTC(m,i2,j3),ma,\n+     $     'ISHFTC(integer*8,integer,integer*2)')\n+      call c_i8(ISHFTC(m,i2,k3),ma,\n+     $     'ISHFTC(integer*8,integer,integer*1)')\n+      call c_i8(ISHFTC(m,i2,m3),ma,\n+     $     'ISHFTC(integer*8,integer,integer*8)')\n+      call c_i8(ISHFTC(m,j2,i3),ma,\n+     $     'ISHFTC(integer*8,integer*2,integer)')\n+      call c_i8(ISHFTC(m,j2,j3),ma,\n+     $     'ISHFTC(integer*8,integer*2,integer*2)')\n+      call c_i8(ISHFTC(m,j2,k3),ma,\n+     $     'ISHFTC(integer*8,integer*2,integer*1)')\n+      call c_i8(ISHFTC(m,j2,m3),ma,\n+     $     'ISHFTC(integer*8,integer*2,integer*8)')\n+      call c_i8(ISHFTC(m,k2,i3),ma,\n+     $     'ISHFTC(integer*8,integer*1,integer)')\n+      call c_i8(ISHFTC(m,k2,j3),ma,\n+     $     'ISHFTC(integer*1,integer*8,integer*2)')\n+      call c_i8(ISHFTC(m,k2,k3),ma,\n+     $     'ISHFTC(integer*1,integer*8,integer*1)')\n+      call c_i8(ISHFTC(m,k2,m3),ma,\n+     $     'ISHFTC(integer*1,integer*8,integer*8)')\n+      call c_i8(ISHFTC(m,m2,i3),ma,\n+     $     'ISHFTC(integer*8,integer*8,integer)')\n+      call c_i8(ISHFTC(m,m2,j3),ma,\n+     $     'ISHFTC(integer*8,integer*8,integer*2)')\n+      call c_i8(ISHFTC(m,m2,k3),ma,\n+     $     'ISHFTC(integer*8,integer*8,integer*1)')\n+      call c_i8(ISHFTC(m,m2,m3),ma,\n+     $     'ISHFTC(integer*8,integer*8,integer*8)')\n+\n+c     test the corner cases\n+      call c_i(ISHFTC(i,BIT_SIZE(i),BIT_SIZE(i)),i,\n+     $     'ISHFTC(i,BIT_SIZE(i),BIT_SIZE(i)) i = integer')\n+      call c_i(ISHFTC(i,0,BIT_SIZE(i)),i,\n+     $     'ISHFTC(i,0,BIT_SIZE(i)) i = integer')\n+      call c_i(ISHFTC(i,-BIT_SIZE(i),BIT_SIZE(i)),i,\n+     $     'ISHFTC(i,-BIT_SIZE(i),BIT_SIZE(i)) i = integer')\n+      call c_i2(ISHFTC(j,BIT_SIZE(j),BIT_SIZE(j)),j,\n+     $     'ISHFTC(j,BIT_SIZE(j),BIT_SIZE(j)) j = integer*2')\n+      call c_i2(ISHFTC(j,0,BIT_SIZE(j)),j,\n+     $     'ISHFTC(j,0,BIT_SIZE(j)) j = integer*2')\n+      call c_i2(ISHFTC(j,-BIT_SIZE(j),BIT_SIZE(j)),j,\n+     $     'ISHFTC(j,-BIT_SIZE(j),BIT_SIZE(j)) j = integer*2')\n+      call c_i1(ISHFTC(k,BIT_SIZE(k),BIT_SIZE(k)),k,\n+     $     'ISHFTC(k,BIT_SIZE(k),BIT_SIZE(k)) k = integer*1')\n+      call c_i1(ISHFTC(k,0,BIT_SIZE(k)),k,\n+     $     'ISHFTC(k,0,BIT_SIZE(k)) k = integer*1')\n+      call c_i1(ISHFTC(k,-BIT_SIZE(k),BIT_SIZE(k)),k,\n+     $     'ISHFTC(k,-BIT_SIZE(k),BIT_SIZE(k)) k = integer*1')\n+      call c_i8(ISHFTC(m,BIT_SIZE(m),BIT_SIZE(m)),m,\n+     $     'ISHFTC(m,BIT_SIZE(m),BIT_SIZE(m)) m = integer*8')\n+      call c_i8(ISHFTC(m,0,BIT_SIZE(m)),m,\n+     $     'ISHFTC(m,0,BIT_SIZE(m)) m = integer*8')\n+      call c_i8(ISHFTC(m,-BIT_SIZE(m),BIT_SIZE(m)),m,\n+     $     'ISHFTC(m,-BIT_SIZE(m),BIT_SIZE(m)) m = integer*8')\n+\n+c     MVBITS - Section 13.13.74\n+      i = 6\n+      call MVBITS(7,2,2,i,0)\n+      call c_i(i,5,'MVBITS 1')\n+      j = 6\n+      j2 = 7\n+      ja = 5\n+      call MVBITS(j2,2,2,j,0)\n+      call c_i2(j,ja,'MVBITS 2')\n+      k = 6\n+      k2 = 7\n+      ka = 5\n+      call MVBITS(k2,2,2,k,0)\n+      call c_i1(k,ka,'MVBITS 3')\n+      m = 6\n+      m2 = 7\n+      ma = 5\n+      call MVBITS(m2,2,2,m,0)\n+      call c_i8(m,ma,'MVBITS 4')\n+\n+c     NOT    - Section 13.13.77\n+c     Rather than assume integer sizes, mask off high bits\n+      j  = 21\n+      j2 = 31\n+      ja = 10\n+      k  = 21\n+      k2 = 31\n+      ka = 10\n+      m  = 21\n+      m2 = 31\n+      ma = 10\n+      call c_i(IAND(NOT(21),31),10,'NOT(integer)')\n+      call c_i2(IAND(NOT(j),j2),ja,'NOT(integer*2)')\n+      call c_i1(IAND(NOT(k),k2),ka,'NOT(integer*1)')\n+      call c_i8(IAND(NOT(m),m2),ma,'NOT(integer*8)')\n+\n+      if ( fail ) call abort()\n+      end\n+\n+      subroutine failure(label)\n+c     Report failure and set flag\n+      character*(*) label\n+      logical fail\n+      common /flags/ fail\n+      write(6,'(a,a,a)') 'Test ',label,' FAILED'\n+      fail = .true.\n+      end\n+\n+      subroutine c_l(i,j,label)\n+c     Check if LOGICAL i equals j, and fail otherwise\n+      logical i,j\n+      character*(*) label\n+      if ( i .eqv. j ) then\n+         call failure(label)\n+         write(6,*) 'Got ',i,' expected ', j\n+      end if\n+      end\n+\n+      subroutine c_i(i,j,label)\n+c     Check if INTEGER i equals j, and fail otherwise\n+      integer i,j\n+      character*(*) label\n+      if ( i .ne. j ) then\n+         call failure(label)\n+         write(6,*) 'Got ',i,' expected ', j\n+      end if\n+      end\n+\n+      subroutine c_i2(i,j,label)\n+c     Check if INTEGER*2 i equals j, and fail otherwise\n+      integer*2 i,j\n+      character*(*) label\n+      if ( i .ne. j ) then\n+         call failure(label)\n+         write(6,*) 'Got ',i,' expected ', j\n+      end if\n+      end\n+\n+      subroutine c_i1(i,j,label)\n+c     Check if INTEGER*1 i equals j, and fail otherwise\n+      integer*1 i,j\n+      character*(*) label\n+      if ( i .ne. j ) then\n+         call failure(label)\n+         write(6,*) 'Got ',i,' expected ', j\n+      end if\n+      end\n+\n+      subroutine c_i8(i,j,label)\n+c     Check if INTEGER*8 i equals j, and fail otherwise\n+      integer*8 i,j\n+      character*(*) label\n+      if ( i .ne. j ) then\n+         call failure(label)\n+         write(6,*) 'Got ',i,' expected ', j\n+      end if\n+      end"}, {"sha": "8b1b53a636bf6690c6744ad6c62cff8c4f53e366", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56746a074523e783b1f1de26b4c23c1be9616ac1/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56746a074523e783b1f1de26b4c23c1be9616ac1/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=56746a074523e783b1f1de26b4c23c1be9616ac1", "patch": "@@ -1,3 +1,12 @@\n+2004-12-27  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\t* libgfortran/libgfortran.h (GFC_UINTEGER_1, GFC_UINTEGER_2): \n+\tDefine.\n+\t* intrinsics/ishftc.c: Update copyright years.\n+\t(ishftc8): Change 'shift' and 'size' to GFC_INTEGER_4.\n+\t* intrinsics/mvbits.c: Correcty non-ASCII character in my name.\n+\tAdd implementations for GFC_INTEGER_1 and GFC_INTEGER_2.\n+\n 2004-12-23  Bud Davis  <bdavis9659@comcast.net>\n \n \tPR fortran/19071"}, {"sha": "896faac06f727e2b6043e9b6c425d46a232b4392", "filename": "libgfortran/intrinsics/ishftc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56746a074523e783b1f1de26b4c23c1be9616ac1/libgfortran%2Fintrinsics%2Fishftc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56746a074523e783b1f1de26b4c23c1be9616ac1/libgfortran%2Fintrinsics%2Fishftc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fishftc.c?ref=56746a074523e783b1f1de26b4c23c1be9616ac1", "patch": "@@ -1,5 +1,5 @@\n /* Implementation of ishftc intrinsic.\n-   Copyright 2002 Free Software Foundation, Inc.\n+   Copyright 2002, 2004 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n This file is part of the GNU Fortran 95 runtime library (libgfor).\n@@ -41,11 +41,11 @@ ishftc4 (GFC_INTEGER_4 i, GFC_INTEGER_4 shift, GFC_INTEGER_4 size)\n   return (i & mask) | (bits >> (size - shift)) | ((i << shift) & ~mask);\n }\n \n-extern GFC_INTEGER_8 ishftc8 (GFC_INTEGER_8, GFC_INTEGER_8, GFC_INTEGER_8);\n+extern GFC_INTEGER_8 ishftc8 (GFC_INTEGER_8, GFC_INTEGER_4, GFC_INTEGER_4);\n export_proto(ishftc8);\n \n GFC_INTEGER_8\n-ishftc8 (GFC_INTEGER_8 i, GFC_INTEGER_8 shift, GFC_INTEGER_8 size)\n+ishftc8 (GFC_INTEGER_8 i, GFC_INTEGER_4 shift, GFC_INTEGER_4 size)\n {\n   GFC_INTEGER_8 mask;\n   GFC_UINTEGER_8 bits;"}, {"sha": "e1e3e40313cf8672ed5d071067dc805b66838e66", "filename": "libgfortran/intrinsics/mvbits.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56746a074523e783b1f1de26b4c23c1be9616ac1/libgfortran%2Fintrinsics%2Fmvbits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56746a074523e783b1f1de26b4c23c1be9616ac1/libgfortran%2Fintrinsics%2Fmvbits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fmvbits.c?ref=56746a074523e783b1f1de26b4c23c1be9616ac1", "patch": "@@ -1,6 +1,6 @@\n /* Implementation of the MVBITS intrinsic\n    Copyright (C) 2004 Free Software Foundation, Inc.\n-   Contributed by Tobias Schl\u00c3\u00bcter\n+   Contributed by Tobias Schl\u00fcter\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n \n@@ -48,6 +48,22 @@ SUB_NAME (const TYPE *from, const GFC_INTEGER_4 *frompos,\n #endif\n \n #ifndef SUB_NAME\n+#  define TYPE GFC_INTEGER_1\n+#  define UTYPE GFC_UINTEGER_1\n+#  define SUB_NAME mvbits_i1\n+#  include \"mvbits.c\"\n+#  undef SUB_NAME\n+#  undef TYPE\n+#  undef UTYPE\n+ \n+#  define TYPE GFC_INTEGER_2\n+#  define UTYPE GFC_UINTEGER_2\n+#  define SUB_NAME mvbits_i2\n+#  include \"mvbits.c\"\n+#  undef SUB_NAME\n+#  undef TYPE\n+#  undef UTYPE\n+ \n #  define TYPE GFC_INTEGER_4\n #  define UTYPE GFC_UINTEGER_4\n #  define SUB_NAME mvbits_i4"}, {"sha": "7ddc0ed7e93083fea0d74f2f53a960e7bba668bd", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56746a074523e783b1f1de26b4c23c1be9616ac1/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56746a074523e783b1f1de26b4c23c1be9616ac1/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=56746a074523e783b1f1de26b4c23c1be9616ac1", "patch": "@@ -189,6 +189,8 @@ typedef int8_t GFC_INTEGER_1;\n typedef int16_t GFC_INTEGER_2;\n typedef int32_t GFC_INTEGER_4;\n typedef int64_t GFC_INTEGER_8;\n+typedef uint8_t GFC_UINTEGER_1;\n+typedef uint16_t GFC_UINTEGER_2;\n typedef uint32_t GFC_UINTEGER_4;\n typedef uint64_t GFC_UINTEGER_8;\n typedef GFC_INTEGER_4 GFC_LOGICAL_4;"}]}