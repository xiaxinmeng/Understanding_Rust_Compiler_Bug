{"sha": "03b6478770fdc7a2db42653bd8532786fdc642bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNiNjQ3ODc3MGZkYzdhMmRiNDI2NTNiZDg1MzI3ODZmZGM2NDJiZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-17T13:44:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-17T13:44:24Z"}, "message": "[multiple changes]\n\n2009-04-17  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch3.adb: Minor reformatting\n\n2009-04-17  Pascal Obry  <obry@adacore.com>\n\n\t* adaint.c: Add __gnat_use_acl global variable to control use of ACL.\n\nFrom-SVN: r146269", "tree": {"sha": "3413539abc5e643fb40ea18e6e903ad24438c9dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3413539abc5e643fb40ea18e6e903ad24438c9dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03b6478770fdc7a2db42653bd8532786fdc642bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b6478770fdc7a2db42653bd8532786fdc642bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03b6478770fdc7a2db42653bd8532786fdc642bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b6478770fdc7a2db42653bd8532786fdc642bf/comments", "author": null, "committer": null, "parents": [{"sha": "054275e427bf1fd088708a2874daf993f10207db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/054275e427bf1fd088708a2874daf993f10207db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/054275e427bf1fd088708a2874daf993f10207db"}], "stats": {"total": 110, "additions": 77, "deletions": 33}, "files": [{"sha": "bf655e827cda115b8dc19c1a874df3f63f4f5a63", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b6478770fdc7a2db42653bd8532786fdc642bf/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b6478770fdc7a2db42653bd8532786fdc642bf/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=03b6478770fdc7a2db42653bd8532786fdc642bf", "patch": "@@ -1,3 +1,11 @@\n+2009-04-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch3.adb: Minor reformatting\n+\n+2009-04-17  Pascal Obry  <obry@adacore.com>\n+\n+\t* adaint.c: Add __gnat_use_acl global variable to control use of ACL.\n+\n 2009-04-17  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch3.adb (Build_Derived_Enumeration_Type): Diagnose properly"}, {"sha": "9ab2c201970df260d4447784b072bf2553b5bc0e", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 62, "deletions": 26, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b6478770fdc7a2db42653bd8532786fdc642bf/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b6478770fdc7a2db42653bd8532786fdc642bf/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=03b6478770fdc7a2db42653bd8532786fdc642bf", "patch": "@@ -331,6 +331,10 @@ const int __gnat_vmsp = 0;\n int __gnat_max_path_len = GNAT_MAX_PATH_LEN;\n int max_path_len = GNAT_MAX_PATH_LEN;\n \n+/* Control whether we can use ACL on Windows.  */\n+\n+int __gnat_use_acl = 1;\n+\n /* The following macro HAVE_READDIR_R should be defined if the\n    system provides the routine readdir_r.  */\n #undef HAVE_READDIR_R\n@@ -667,7 +671,7 @@ __gnat_os_filename (char *filename, char *w_filename ATTRIBUTE_UNUSED,\n \t\t    char *encoding ATTRIBUTE_UNUSED, int *e_length)\n {\n #if defined (_WIN32) && ! defined (__vxworks) && ! defined (IS_CROSS)\n-  WS2SC (os_name, (TCHAR *)w_filename, o_length);\n+  WS2SC (os_name, (TCHAR *)w_filename, (DWORD)o_length);\n   *o_length = strlen (os_name);\n   strcpy (encoding, \"encoding=utf8\");\n   *e_length = strlen (encoding);\n@@ -1609,7 +1613,7 @@ __gnat_get_libraries_from_registry (void)\n   for (index = 0; res == ERROR_SUCCESS; index++)\n     {\n       value_size = name_size = 256;\n-      res = RegEnumValueA (reg_key, index, (TCHAR*)name, &name_size, 0,\n+      res = RegEnumValueA (reg_key, index, name, &name_size, 0,\n                            &type, (LPBYTE)value, &value_size);\n \n       if (res == ERROR_SUCCESS && type == REG_SZ)\n@@ -1661,7 +1665,7 @@ __gnat_stat (char *name, struct stat *statbuf)\n   if (name_len == 2 && wname[1] == _T(':'))\n     _tcscat (wname, _T(\"\\\\\"));\n \n-  return _tstat (wname, statbuf);\n+  return _tstat (wname, (struct _stat *)statbuf);\n \n #else\n   return stat (name, statbuf);\n@@ -1861,12 +1865,18 @@ __gnat_is_readable_file (char *name)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n   GENERIC_MAPPING GenericMapping;\n \n-  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  if (__gnat_use_acl)\n+    {\n+      S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n-  ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n-  GenericMapping.GenericRead = GENERIC_READ;\n+      ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n+      GenericMapping.GenericRead = GENERIC_READ;\n+\n+      return __gnat_check_OWNER_ACL (wname, FILE_READ_DATA, GenericMapping);\n+    }\n+  else\n+    return 1;\n \n-  return __gnat_check_OWNER_ACL (wname, FILE_READ_DATA, GenericMapping);\n #else\n   int ret;\n   int mode;\n@@ -1887,12 +1897,18 @@ __gnat_is_writable_file (char *name)\n \n   S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n-  ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n-  GenericMapping.GenericWrite = GENERIC_WRITE;\n+  if (__gnat_use_acl)\n+    {\n+      ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n+      GenericMapping.GenericWrite = GENERIC_WRITE;\n+\n+      return __gnat_check_OWNER_ACL\n+\t(wname, FILE_WRITE_DATA | FILE_APPEND_DATA, GenericMapping)\n+\t&& !(GetFileAttributes (wname) & FILE_ATTRIBUTE_READONLY);\n+    }\n+  else\n+    return !(GetFileAttributes (wname) & FILE_ATTRIBUTE_READONLY);\n \n-  return __gnat_check_OWNER_ACL\n-    (wname, FILE_WRITE_DATA | FILE_APPEND_DATA, GenericMapping)\n-    && !(GetFileAttributes (wname) & FILE_ATTRIBUTE_READONLY);\n #else\n   int ret;\n   int mode;\n@@ -1913,10 +1929,17 @@ __gnat_is_executable_file (char *name)\n \n   S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n-  ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n-  GenericMapping.GenericExecute = GENERIC_EXECUTE;\n+  if (__gnat_use_acl)\n+    {\n+      ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n+      GenericMapping.GenericExecute = GENERIC_EXECUTE;\n+\n+      return __gnat_check_OWNER_ACL (wname, FILE_EXECUTE, GenericMapping);\n+    }\n+  else\n+    return GetFileAttributes (wname) != INVALID_FILE_ATTRIBUTES\n+      && _tcsstr (wname, _T(\".exe\")) - wname == (_tcslen (wname) - 4);\n \n-  return __gnat_check_OWNER_ACL (wname, FILE_EXECUTE, GenericMapping);\n #else\n   int ret;\n   int mode;\n@@ -1936,7 +1959,9 @@ __gnat_set_writable (char *name)\n \n   S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n-  __gnat_set_OWNER_ACL (wname, GRANT_ACCESS, FILE_GENERIC_WRITE);\n+  if (__gnat_use_acl)\n+    __gnat_set_OWNER_ACL (wname, GRANT_ACCESS, FILE_GENERIC_WRITE);\n+\n   SetFileAttributes\n     (wname, GetFileAttributes (wname) & ~FILE_ATTRIBUTE_READONLY);\n #elif ! defined (__vxworks) && ! defined(__nucleus__)\n@@ -1956,9 +1981,12 @@ __gnat_set_executable (char *name)\n #if defined (_WIN32) && !defined (RTX)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n \n-  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  if (__gnat_use_acl)\n+    {\n+      S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n-  __gnat_set_OWNER_ACL (wname, GRANT_ACCESS, FILE_GENERIC_EXECUTE);\n+      __gnat_set_OWNER_ACL (wname, GRANT_ACCESS, FILE_GENERIC_EXECUTE);\n+    }\n #elif ! defined (__vxworks) && ! defined(__nucleus__)\n   struct stat statbuf;\n \n@@ -1978,10 +2006,12 @@ __gnat_set_non_writable (char *name)\n \n   S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n-  __gnat_set_OWNER_ACL\n-    (wname, DENY_ACCESS,\n-     FILE_WRITE_DATA | FILE_APPEND_DATA |\n-     FILE_WRITE_EA | FILE_WRITE_ATTRIBUTES);\n+  if (__gnat_use_acl)\n+    __gnat_set_OWNER_ACL\n+      (wname, DENY_ACCESS,\n+       FILE_WRITE_DATA | FILE_APPEND_DATA |\n+       FILE_WRITE_EA | FILE_WRITE_ATTRIBUTES);\n+\n   SetFileAttributes\n     (wname, GetFileAttributes (wname) | FILE_ATTRIBUTE_READONLY);\n #elif ! defined (__vxworks) && ! defined(__nucleus__)\n@@ -2001,9 +2031,12 @@ __gnat_set_readable (char *name)\n #if defined (_WIN32) && !defined (RTX)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n \n-  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  if (__gnat_use_acl)\n+    {\n+      S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n-  __gnat_set_OWNER_ACL (wname, GRANT_ACCESS, FILE_GENERIC_READ);\n+      __gnat_set_OWNER_ACL (wname, GRANT_ACCESS, FILE_GENERIC_READ);\n+    }\n #elif ! defined (__vxworks) && ! defined(__nucleus__)\n   struct stat statbuf;\n \n@@ -2020,9 +2053,12 @@ __gnat_set_non_readable (char *name)\n #if defined (_WIN32) && !defined (RTX)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n \n-  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  if (__gnat_use_acl)\n+    {\n+      S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n-  __gnat_set_OWNER_ACL (wname, DENY_ACCESS, FILE_GENERIC_READ);\n+      __gnat_set_OWNER_ACL (wname, DENY_ACCESS, FILE_GENERIC_READ);\n+    }\n #elif ! defined (__vxworks) && ! defined(__nucleus__)\n   struct stat statbuf;\n "}, {"sha": "049752941d6337705f7eac24afd1081975c062ee", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b6478770fdc7a2db42653bd8532786fdc642bf/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b6478770fdc7a2db42653bd8532786fdc642bf/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=03b6478770fdc7a2db42653bd8532786fdc642bf", "patch": "@@ -4033,6 +4033,7 @@ package body Sem_Ch3 is\n          --  pre-allocate a freeze node, and set the proper link to the first\n          --  subtype. Freeze_Entity will use this preallocated freeze node when\n          --  it freezes the entity.\n+\n          --  This does not apply if the base type is a generic type, whose\n          --  declaration is independent of the current derived definition.\n \n@@ -5063,27 +5064,26 @@ package body Sem_Ch3 is\n                Lo :=\n                   Make_Attribute_Reference (Loc,\n                     Attribute_Name => Name_First,\n-                    Prefix => New_Reference_To (Derived_Type, Loc));\n+                    Prefix         => New_Reference_To (Derived_Type, Loc));\n                Set_Etype (Lo, Derived_Type);\n \n                Hi :=\n                   Make_Attribute_Reference (Loc,\n                     Attribute_Name => Name_Last,\n-                    Prefix => New_Reference_To (Derived_Type, Loc));\n+                    Prefix         => New_Reference_To (Derived_Type, Loc));\n                Set_Etype (Hi, Derived_Type);\n \n                Set_Scalar_Range (Derived_Type,\n                   Make_Range (Loc,\n-                    Low_Bound => Lo,\n+                    Low_Bound  => Lo,\n                     High_Bound => Hi));\n             else\n \n                --   Analyze subtype indication and verify compatibility\n                --   with parent type.\n \n-               if\n-                  Base_Type\n-                    (Process_Subtype (Indic, N)) /= Base_Type (Parent_Type)\n+               if Base_Type (Process_Subtype (Indic, N)) /=\n+                  Base_Type (Parent_Type)\n                then\n                   Error_Msg_N\n                     (\"illegal constraint for formal discrete type\", N);\n@@ -13607,7 +13607,7 @@ package body Sem_Ch3 is\n                     \"full declaration of } must be a record extension\",\n                     Prev, Id);\n \n-                  --  Set some attributes to produce a usable full view.\n+                  --  Set some attributes to produce a usable full view\n \n                   Set_Is_Tagged_Type (Id);\n                   Set_Primitive_Operations (Id, New_Elmt_List);"}]}