{"sha": "71851aaa7cfda669cb166577acaefff5a7c3d2dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE4NTFhYWE3Y2ZkYTY2OWNiMTY2NTc3YWNhZWZmZjVhN2MzZDJkZA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-03-29T20:32:43Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-03-29T20:32:43Z"}, "message": "61st Cygnus<->FSF merge\n\nFrom-SVN: r9244", "tree": {"sha": "5b9d9d5404cbad0feaf69f7ecd661ec56af42541", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b9d9d5404cbad0feaf69f7ecd661ec56af42541"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71851aaa7cfda669cb166577acaefff5a7c3d2dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71851aaa7cfda669cb166577acaefff5a7c3d2dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71851aaa7cfda669cb166577acaefff5a7c3d2dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71851aaa7cfda669cb166577acaefff5a7c3d2dd/comments", "author": null, "committer": null, "parents": [{"sha": "3a011f48fa21cb66f3eb59ef11e7eab7194d3634", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a011f48fa21cb66f3eb59ef11e7eab7194d3634", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a011f48fa21cb66f3eb59ef11e7eab7194d3634"}], "stats": {"total": 186, "additions": 129, "deletions": 57}, "files": [{"sha": "3f1f604c649bf96f9776719b189ae5dd5952deac", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71851aaa7cfda669cb166577acaefff5a7c3d2dd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71851aaa7cfda669cb166577acaefff5a7c3d2dd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=71851aaa7cfda669cb166577acaefff5a7c3d2dd", "patch": "@@ -5,8 +5,50 @@ Mon Mar 27 07:14:33 1995  Warner Losh\t<imp@village.org>\n \tdeclare sys_errlist and sys_nerr.\n \t(my_strerror): New function.\n \n+Tue Mar 28 14:16:35 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* search.c (get_binfo): Don't try to be so clever.\n+\n+\t* tree.c (copy_to_permanent): Also suspend_momentary().\n+\n+\t* cvt.c (cp_convert_to_pointer): Hand off to convert_fn_pointer even\n+\tif the types are the same.\n+\n+\t* decl.c (start_function): Handle extern inlines more like C++ says\n+        we should.\n+\n+\t* init.c (build_member_call): Hand constructor calls off to\n+\tbuild_functional_cast.\n+\n+\t* typeck2.c (build_functional_cast): Use DECL_NESTED_TYPENAME to get\n+\tthe name of the type.\n+\n+Tue Mar 28 13:13:56 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* decl.c (grokdeclarator): Check for the decl returned by\n+\tgrokfndecl to be null before using build_decl_attribute_variant.\n+\n+Mon Mar 27 18:04:41 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* init.c (build_new): Use build_pointer_type instead of\n+\tTYPE_POINTER_TO.\n+\n Fri Mar 24 12:11:24 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n+\t* typeck.c (build_conditional_expr): Handle pmfs.\n+\t(convert_for_assignment): Fix pmf support.\n+\n+\t* cvt.c (convert_fn_ptr): Support !flag_vtable_thunks.\n+\t(cp_convert_to_pointer): Handle pmfs.\n+\t(cp_convert): Pass pmfs to cp_convert_to_pointer.\n+\n+\t* typeck.c (common_type): Handle inheritance for pmfs.\n+\n+\t* typeck2.c (build_m_component_ref): Do access control.\n+\n+\t* typeck.c (comp_target_types): Check for conversion to void *\n+\tbefore checking trickier conversions.\n+\n \t* decl.c (duplicate_decls): Propagate DECL_ABSTRACT_VIRTUAL_P.\n \n \t* pt.c (push_tinst_level): Complain if template instantiation depth"}, {"sha": "0ceabf01533d29d0c120a896dcec8c9649a3ad29", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71851aaa7cfda669cb166577acaefff5a7c3d2dd/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71851aaa7cfda669cb166577acaefff5a7c3d2dd/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=71851aaa7cfda669cb166577acaefff5a7c3d2dd", "patch": "@@ -81,23 +81,29 @@ static tree\n convert_fn_ptr (type, expr)\n      tree type, expr;\n {\n-  tree binfo = get_binfo (TYPE_METHOD_BASETYPE (TREE_TYPE (TREE_TYPE (expr))),\n-\t\t\t  TYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n-\t\t\t  1);\n-  if (binfo == error_mark_node)\n+  if (flag_vtable_thunks)\n     {\n-      error (\"  in pointer to member conversion\");\n-      return error_mark_node;\n-    }\n-  if (binfo == NULL_TREE)\n-    {\n-      /* ARM 4.8 restriction. */\n-      error (\"invalid pointer to member conversion\");\n-      return error_mark_node;\n+      tree intype = TREE_TYPE (expr);\n+      tree binfo = get_binfo (TYPE_METHOD_BASETYPE (TREE_TYPE (intype)),\n+\t\t\t      TYPE_METHOD_BASETYPE (TREE_TYPE (type)), 1);\n+      if (binfo == error_mark_node)\n+\t{\n+\t  error (\"  in pointer to member conversion\");\n+\t  return error_mark_node;\n+\t}\n+      if (binfo == NULL_TREE)\n+\t{\n+\t  /* ARM 4.8 restriction. */\n+\t  error (\"invalid pointer to member conversion\");\n+\t  return error_mark_node;\n+\t}\n+\n+      if (BINFO_OFFSET_ZEROP (binfo))\n+\treturn build1 (NOP_EXPR, type, expr);\n+      return build1 (NOP_EXPR, type, build_thunk (BINFO_OFFSET (binfo), expr));\n     }\n-  if (BINFO_OFFSET_ZEROP (binfo))\n-    return build1 (NOP_EXPR, type, expr);\n-  return build1 (NOP_EXPR, type, build_thunk (BINFO_OFFSET (binfo), expr));\n+  else\n+    return build_ptrmemfunc (type, expr, 1);\n }\n \n /* if converting pointer to pointer\n@@ -111,8 +117,15 @@ cp_convert_to_pointer (type, expr)\n      tree type, expr;\n {\n   register tree intype = TREE_TYPE (expr);\n-  register enum tree_code form = TREE_CODE (intype);\n-  \n+  register enum tree_code form;\n+\n+  if (TYPE_PTRMEMFUNC_P (type))\n+    type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n+  if (TYPE_PTRMEMFUNC_P (intype))\n+    intype = TYPE_PTRMEMFUNC_FN_TYPE (intype);\n+\n+  form = TREE_CODE (intype);\n+\n   if (form == POINTER_TYPE || form == REFERENCE_TYPE)\n     {\n       intype = TYPE_MAIN_VARIANT (intype);\n@@ -149,10 +162,9 @@ cp_convert_to_pointer (type, expr)\n \t\t}\n \t    }\n \t}\n-      if (TYPE_MAIN_VARIANT (type) != intype\n-\t  && TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE\n+      if (TREE_CODE (TREE_TYPE (intype)) == METHOD_TYPE\n \t  && TREE_CODE (type) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (intype)) == METHOD_TYPE)\n+\t  && TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE)\n \treturn convert_fn_ptr (type, expr);\n \n       if (TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE\n@@ -1279,7 +1291,8 @@ cp_convert (type, expr, convtype, flags)\n \treturn truthvalue_conversion (e);\n       return fold (convert_to_integer (type, e));\n     }\n-  if (code == POINTER_TYPE || code == REFERENCE_TYPE)\n+  if (code == POINTER_TYPE || code == REFERENCE_TYPE\n+      || TYPE_PTRMEMFUNC_P (type))\n     return fold (cp_convert_to_pointer (type, e));\n   if (code == REAL_TYPE)\n     {"}, {"sha": "c6c63791c4428c255df4fdfe10d421462d3a39b0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71851aaa7cfda669cb166577acaefff5a7c3d2dd/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71851aaa7cfda669cb166577acaefff5a7c3d2dd/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=71851aaa7cfda669cb166577acaefff5a7c3d2dd", "patch": "@@ -9071,9 +9071,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t    decl = grokfndecl (ctype, type, declarator,\n \t\t\t       virtualp, flags, quals,\n \t\t\t       raises, friendp ? -1 : 0, publicp);\n-\t    decl = build_decl_attribute_variant (decl, decl_machine_attr);\n \t    if (decl == NULL_TREE)\n \t      return NULL_TREE;\n+\t    decl = build_decl_attribute_variant (decl, decl_machine_attr);\n \n \t    if (explicitp == 2)\n \t      DECL_NONCONVERTING_P (decl) = 1;\n@@ -10904,21 +10904,15 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \tDECL_EXTERNAL (decl1) = current_extern_inline;\n       DECL_INTERFACE_KNOWN (decl1) = 1;\n     }\n-  else if (current_extern_inline)\n-    {\n-      /* `extern inline' acts like a declaration except for\n-\t defining how to inline.  So set DECL_EXTERNAL in that case.  */\n-      DECL_EXTERNAL (decl1) = 1;\n-      DECL_INTERFACE_KNOWN (decl1) = 1;\n-    }\n   else\n     {\n       /* This is a definition, not a reference.\n \t So clear DECL_EXTERNAL.  */\n       DECL_EXTERNAL (decl1) = 0;\n       \n       if (DECL_INLINE (decl1) && (DECL_FUNCTION_MEMBER_P (decl1)\n-\t\t\t\t  || DECL_TEMPLATE_INSTANTIATION (decl1)))\n+\t\t\t\t  || DECL_TEMPLATE_INSTANTIATION (decl1)\n+\t\t\t\t  || current_extern_inline))\n \t/* We know nothing yet */;\n       else\n \t{"}, {"sha": "e9771519d1aaad79e4018399cf90da3824e3107c", "filename": "gcc/cp/init.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71851aaa7cfda669cb166577acaefff5a7c3d2dd/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71851aaa7cfda669cb166577acaefff5a7c3d2dd/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=71851aaa7cfda669cb166577acaefff5a7c3d2dd", "patch": "@@ -1785,6 +1785,9 @@ build_member_call (cname, name, parmlist)\n \n   decl = build_indirect_ref (decl, NULL_PTR);\n \n+  if (method_name == constructor_name (type)\n+      || method_name == constructor_name_full (type))\n+    return build_functional_cast (type, parmlist);\n   if (t = lookup_fnfields (basetype_path, method_name, 0))\n     return build_method_call (decl, method_name, parmlist, basetype_path,\n \t\t\t      LOOKUP_NORMAL|LOOKUP_NONVIRTUAL);\n@@ -2999,7 +3002,7 @@ build_new (placement, decl, init, use_global_new)\n     {\n       rval = build_opfncall (code, LOOKUP_GLOBAL|LOOKUP_COMPLAIN,\n \t\t\t     ptr_type_node, size, placement);\n-      rval = convert (TYPE_POINTER_TO (true_type), rval);\n+      rval = convert (build_pointer_type (true_type), rval);\n     }\n   else if (! has_array && flag_this_is_variable > 0\n \t   && TYPE_NEEDS_CONSTRUCTING (true_type) && init != void_type_node)"}, {"sha": "3e44bd2a3cf38e38360357cd5256dc7f9649f2c1", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71851aaa7cfda669cb166577acaefff5a7c3d2dd/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71851aaa7cfda669cb166577acaefff5a7c3d2dd/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=71851aaa7cfda669cb166577acaefff5a7c3d2dd", "patch": "@@ -427,18 +427,13 @@ get_binfo (parent, binfo, protect)\n   \n   if (TREE_CODE (parent) == TREE_VEC)\n     parent = BINFO_TYPE (parent);\n-  /* unions cannot participate in inheritance relationships */\n-  else if (TREE_CODE (parent) == UNION_TYPE)\n-    return NULL_TREE;\n-  else if (TREE_CODE (parent) != RECORD_TYPE)\n+  else if (! IS_AGGR_TYPE_CODE (TREE_CODE (parent)))\n     my_friendly_abort (89);\n \n   if (TREE_CODE (binfo) == TREE_VEC)\n     type = BINFO_TYPE (binfo);\n-  else if (TREE_CODE (binfo) == RECORD_TYPE)\n+  else if (IS_AGGR_TYPE_CODE (TREE_CODE (binfo)))\n     type = binfo;\n-  else if (TREE_CODE (binfo) == UNION_TYPE)\n-    return NULL_TREE;\n   else\n     my_friendly_abort (90);\n   "}, {"sha": "90c21b254f284062d5140013ff10404e822369b6", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71851aaa7cfda669cb166577acaefff5a7c3d2dd/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71851aaa7cfda669cb166577acaefff5a7c3d2dd/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=71851aaa7cfda669cb166577acaefff5a7c3d2dd", "patch": "@@ -1782,15 +1782,18 @@ copy_to_permanent (t)\n {\n   register struct obstack *ambient_obstack = current_obstack;\n   register struct obstack *ambient_saveable_obstack = saveable_obstack;\n+  int resume;\n \n   if (t == NULL_TREE || TREE_PERMANENT (t))\n     return t;\n \n   saveable_obstack = &permanent_obstack;\n   current_obstack = saveable_obstack;\n+  resume = suspend_momentary ();\n \n   t = make_deep_copy (t);\n \n+  resume_momentary (resume);\n   current_obstack = ambient_obstack;\n   saveable_obstack = ambient_saveable_obstack;\n "}, {"sha": "ff9bba1c3d218c07117c3d1e31045c63431a3a17", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71851aaa7cfda669cb166577acaefff5a7c3d2dd/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71851aaa7cfda669cb166577acaefff5a7c3d2dd/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=71851aaa7cfda669cb166577acaefff5a7c3d2dd", "patch": "@@ -389,7 +389,12 @@ common_type (t1, t2)\n \t  t1 = build_pointer_type (target);\n \telse\n \t  t1 = build_reference_type (target);\n-\treturn build_type_attribute_variant (t1, attributes);\n+\tt1 = build_type_attribute_variant (t1, attributes);\n+\n+\tif (TREE_CODE (target) == METHOD_TYPE)\n+\t  t1 = build_ptrmemfunc_type (t1);\n+\n+\treturn t1;\n       }\n #if 0\n     case POINTER_TYPE:\n@@ -464,14 +469,25 @@ common_type (t1, t2)\n \tcompiler_error (\"common_type called with uncommon aggregate types\");\n \n     case METHOD_TYPE:\n-      if (comptypes (TYPE_METHOD_BASETYPE (t1), TYPE_METHOD_BASETYPE (t2), 1)\n-\t  && TREE_CODE (TREE_TYPE (t1)) == TREE_CODE (TREE_TYPE (t2)))\n+      if (TREE_CODE (TREE_TYPE (t1)) == TREE_CODE (TREE_TYPE (t2)))\n \t{\n \t  /* Get this value the long way, since TYPE_METHOD_BASETYPE\n \t     is just the main variant of this.  */\n-\t  tree basetype = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t1)));\n+\t  tree basetype;\n \t  tree raises, t3;\n \n+\t  tree b1 = TYPE_OFFSET_BASETYPE (t1);\n+\t  tree b2 = TYPE_OFFSET_BASETYPE (t2);\n+\n+\t  if (DERIVED_FROM_P (b1, b2) && binfo_or_else (b1, b2))\n+\t    basetype = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t2)));\n+\t  else\n+\t    {\n+\t      if (binfo_or_else (b2, b1) == NULL_TREE)\n+\t\tcompiler_error (\"common_type called with uncommon method types\");\n+\t      basetype = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t1)));\n+\t    }\n+\n \t  raises = TYPE_RAISES_EXCEPTIONS (t1);\n \n \t  /* If this was a member function type, get back to the\n@@ -489,16 +505,15 @@ common_type (t1, t2)\n       return build_type_attribute_variant (t1, attributes);\n \n     case OFFSET_TYPE:\n-      if (TREE_CODE (TREE_TYPE (t1)) == TREE_CODE (TREE_TYPE (t2)))\n+      if (TREE_TYPE (t1) == TREE_TYPE (t2))\n \t{\n \t  tree b1 = TYPE_OFFSET_BASETYPE (t1);\n \t  tree b2 = TYPE_OFFSET_BASETYPE (t2);\n-\t  tree base;\n \n \t  if (DERIVED_FROM_P (b1, b2) && binfo_or_else (b1, b2))\n-\t    return build_type_attribute_variant (t1, attributes);\n-\t  else if (binfo_or_else (b2, b1))\n \t    return build_type_attribute_variant (t2, attributes);\n+\t  else if (binfo_or_else (b2, b1))\n+\t    return build_type_attribute_variant (t1, attributes);\n \t}\n       compiler_error (\"common_type called with uncommon member types\");\n \n@@ -782,10 +797,7 @@ comp_target_types (ttl, ttr, nptrs)\n \n       if (nptrs > 0)\n \t{\n-\t  if (TREE_CODE (ttl) == POINTER_TYPE\n-\t      || TREE_CODE (ttl) == ARRAY_TYPE)\n-\t    return comp_ptr_ttypes (ttl, ttr);\n-\t  else if (TREE_CODE (ttl) == VOID_TYPE\n+\t  if (TREE_CODE (ttl) == VOID_TYPE\n \t\t   && TREE_CODE (ttr) != FUNCTION_TYPE\n \t\t   && TREE_CODE (ttr) != METHOD_TYPE\n \t\t   && TREE_CODE (ttr) != OFFSET_TYPE)\n@@ -795,6 +807,9 @@ comp_target_types (ttl, ttr, nptrs)\n \t\t   && TREE_CODE (ttl) != METHOD_TYPE\n \t\t   && TREE_CODE (ttl) != OFFSET_TYPE)\n \t    return -1;\n+\t  else if (TREE_CODE (ttl) == POINTER_TYPE\n+\t\t   || TREE_CODE (ttl) == ARRAY_TYPE)\n+\t    return comp_ptr_ttypes (ttl, ttr);\n \t}\n \n       return comp_target_types (ttl, ttr, nptrs - 1);\n@@ -4588,7 +4603,7 @@ build_conditional_expr (ifexp, op1, op2)\n     {\n       if (code2 == ENUMERAL_TYPE)\n \t{\n-\t  message_2_types (error, \"enumeral mismatch in conditional expression: `%s' vs `%s'\", type1, type2);\n+\t  cp_error (\"enumeral mismatch in conditional expression: `%T' vs `%T'\", type1, type2);\n \t  return error_mark_node;\n \t}\n       else if (extra_warnings && ! IS_AGGR_TYPE_CODE (code2))\n@@ -4602,12 +4617,16 @@ build_conditional_expr (ifexp, op1, op2)\n     {\n       op1 = default_conversion (op1);\n       type1 = TREE_TYPE (op1);\n+      if (TYPE_PTRMEMFUNC_P (type1))\n+\ttype1 = TYPE_PTRMEMFUNC_FN_TYPE (type1);\n       code1 = TREE_CODE (type1);\n     }\n   if (code2 != VOID_TYPE)\n     {\n       op2 = default_conversion (op2);\n       type2 = TREE_TYPE (op2);\n+      if (TYPE_PTRMEMFUNC_P (type2))\n+\ttype2 = TYPE_PTRMEMFUNC_FN_TYPE (type2);\n       code2 = TREE_CODE (type2);\n     }\n \n@@ -4721,7 +4740,7 @@ build_conditional_expr (ifexp, op1, op2)\n \t an aggregate value, try converting to a scalar type.  */\n       if (code1 == RECORD_TYPE && code2 == RECORD_TYPE)\n \t{\n-\t  message_2_types (error, \"aggregate mismatch in conditional expression: `%s' vs `%s'\", type1, type2);\n+\t  cp_error (\"aggregate mismatch in conditional expression: `%T' vs `%T'\", type1, type2);\n \t  return error_mark_node;\n \t}\n       if (code1 == RECORD_TYPE && TYPE_HAS_CONVERSION (type1))\n@@ -6765,8 +6784,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n     return convert (type, rhs);\n \n   /* C++ */\n-  else if (((coder == POINTER_TYPE && TREE_CODE (rhs) == ADDR_EXPR\n-\t     && TREE_CODE (rhstype) == POINTER_TYPE\n+  else if (((coder == POINTER_TYPE\n \t     && TREE_CODE (TREE_TYPE (rhstype)) == METHOD_TYPE)\n \t    || integer_zerop (rhs)\n \t    || TYPE_PTRMEMFUNC_P (rhstype))"}, {"sha": "98cc90ddb2051b53edfcdec2e7ecea999108f8d2", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71851aaa7cfda669cb166577acaefff5a7c3d2dd/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71851aaa7cfda669cb166577acaefff5a7c3d2dd/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=71851aaa7cfda669cb166577acaefff5a7c3d2dd", "patch": "@@ -1392,6 +1392,7 @@ build_m_component_ref (datum, component)\n   tree type;\n   tree objtype = TREE_TYPE (datum);\n   tree rettype;\n+  tree binfo;\n \n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (component)))\n     {\n@@ -1424,13 +1425,16 @@ build_m_component_ref (datum, component)\n       cp_error (\"which is of non-aggregate type `%T'\", objtype);\n       return error_mark_node;\n     }\n-  \n-  if (! comptypes (TYPE_METHOD_BASETYPE (type), objtype, 0))\n+\n+  binfo = get_binfo (TYPE_METHOD_BASETYPE (type), objtype, 1);\n+  if (binfo == NULL_TREE)\n     {\n       cp_error (\"member type `%T::' incompatible with object type `%T'\",\n \t\tTYPE_METHOD_BASETYPE (type), objtype);\n       return error_mark_node;\n     }\n+  else if (binfo == error_mark_node)\n+    return error_mark_node;\n \n   return build (OFFSET_REF, rettype, datum, component);\n }\n@@ -1491,7 +1495,7 @@ build_functional_cast (exp, parms)\n     {\n       name = TYPE_NAME (type);\n       if (TREE_CODE (name) == TYPE_DECL)\n-\tname = DECL_NAME (name);\n+\tname = DECL_NESTED_TYPENAME (name);\n     }\n \n   if (! IS_AGGR_TYPE (type))"}]}