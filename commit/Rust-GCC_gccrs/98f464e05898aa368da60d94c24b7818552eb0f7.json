{"sha": "98f464e05898aa368da60d94c24b7818552eb0f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThmNDY0ZTA1ODk4YWEzNjhkYTYwZDk0YzI0Yjc4MTg1NTJlYjBmNw==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-05-12T19:29:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-05-12T19:29:21Z"}, "message": "except.c (duplicate_eh_region_1, [...]): New functions, based on old implementation removed with RTL inliner.\n\n\n\t* except.c  (duplicate_eh_region_1, duplicate_eh_region_2,\n\tduplicate_eh_regions): New functions, based on old\n\timplementation removed with RTL inliner.\n\t(reachable_next_level): Modify behaviour pre-inline.\n\t* except.h (duplicate_eh_regions_map, duplicate_eh_regions):\n\tDeclare.\n\t* function.h (struct function): Add after_inlining flag.\n\t* tree-optimize.c (tree_rest_of_compilation): Set it.\n\t* tree-eh.c (add_stmt_to_eh_region_fn): Initialize hashtable\n\twhen needed.\n\t* tree-cfg.c (label_to_block_fn): Deal with cases where\n\tlabel was never insterted into code.\n\nCo-Authored-By: Jan Hubicka <jh@suse.cz>\nCo-Authored-By: Stuart Hastings <stuart@apple.com>\n\nFrom-SVN: r99625", "tree": {"sha": "e8fbec3fe9a12f57e69dd33bd03e77391cc8bc6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8fbec3fe9a12f57e69dd33bd03e77391cc8bc6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98f464e05898aa368da60d94c24b7818552eb0f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98f464e05898aa368da60d94c24b7818552eb0f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98f464e05898aa368da60d94c24b7818552eb0f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98f464e05898aa368da60d94c24b7818552eb0f7/comments", "author": null, "committer": null, "parents": [{"sha": "1ed17cd539718575f2587c75bd69fa3259b25910", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ed17cd539718575f2587c75bd69fa3259b25910", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ed17cd539718575f2587c75bd69fa3259b25910"}], "stats": {"total": 179, "additions": 177, "deletions": 2}, "files": [{"sha": "cb6bc1bc2395907a0b5b548a51eec191cbb02f07", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f464e05898aa368da60d94c24b7818552eb0f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f464e05898aa368da60d94c24b7818552eb0f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98f464e05898aa368da60d94c24b7818552eb0f7", "patch": "@@ -1,3 +1,20 @@\n+2005-05-12  Steven Bosscher  <stevenb@suse.de>\n+\t    Stuart Hastings <stuart@apple.com>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\t    \n+\t* except.c  (duplicate_eh_region_1, duplicate_eh_region_2,\n+\tduplicate_eh_regions): New functions, based on old\n+\timplementation removed with RTL inliner.\n+\t(reachable_next_level): Modify behaviour pre-inline.\n+\t* except.h (duplicate_eh_regions_map, duplicate_eh_regions):\n+\tDeclare.\n+\t* function.h (struct function): Add after_inlining flag.\n+\t* tree-optimize.c (tree_rest_of_compilation): Set it.\n+\t* tree-eh.c (add_stmt_to_eh_region_fn): Initialize hashtable\n+\twhen needed.\n+\t* tree-cfg.c (label_to_block_fn): Deal with cases where\n+\tlabel was never insterted into code.\n+\n 2005-05-12  Zack Weinberg  <zack@codesourcery.com>\n \n \t* doc/cpp.texi: Document that #sccs is a synonym for #ident."}, {"sha": "9f1bfe926af5972937687c3d897aa7a53042c8e0", "filename": "gcc/except.c", "status": "modified", "additions": 149, "deletions": 2, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f464e05898aa368da60d94c24b7818552eb0f7/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f464e05898aa368da60d94c24b7818552eb0f7/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=98f464e05898aa368da60d94c24b7818552eb0f7", "patch": "@@ -853,6 +853,148 @@ current_function_has_exception_handlers (void)\n   return false;\n }\n \f\n+static struct eh_region *\n+duplicate_eh_region_1 (struct eh_region *o)\n+{\n+  struct eh_region *n = ggc_alloc_cleared (sizeof (struct eh_region));\n+\n+  *n = *o;\n+  \n+  n->region_number = o->region_number + cfun->eh->last_region_number;\n+  gcc_assert (!o->aka);\n+  \n+  return n;\n+}\n+\n+static void\n+duplicate_eh_region_2 (struct eh_region *o, struct eh_region **n_array,\n+\t\t       struct eh_region *prev_try)\n+{\n+  struct eh_region *n = n_array[o->region_number];\n+  \n+  switch (n->type)\n+    {\n+    case ERT_TRY:\n+      if (o->u.try.catch)\n+        n->u.try.catch = n_array[o->u.try.catch->region_number];\n+      if (o->u.try.last_catch)\n+        n->u.try.last_catch = n_array[o->u.try.last_catch->region_number];\n+      break;\n+      \n+    case ERT_CATCH:\n+      if (o->u.catch.next_catch)\n+\tn->u.catch.next_catch = n_array[o->u.catch.next_catch->region_number];\n+      if (o->u.catch.prev_catch)\n+\tn->u.catch.prev_catch = n_array[o->u.catch.prev_catch->region_number];\n+      break;\n+\n+    case ERT_CLEANUP:\n+      if (o->u.cleanup.prev_try)\n+\tn->u.cleanup.prev_try = n_array[o->u.cleanup.prev_try->region_number];\n+      else\n+        n->u.cleanup.prev_try = prev_try;\n+      break;\n+      \n+    default:\n+      break;\n+    }\n+  \n+  if (o->outer)\n+    n->outer = n_array[o->outer->region_number];\n+  if (o->inner)\n+    n->inner = n_array[o->inner->region_number];\n+  if (o->next_peer)\n+    n->next_peer = n_array[o->next_peer->region_number];\n+}\n+\n+/* Duplicate the EH regions of IFUN into current function, root the tree in\n+   OUTER_REGION and remap labels using MAP callback.  */\n+int\n+duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n+\t\t      void *data, int outer_region)\n+{\n+  int ifun_last_region_number = ifun->eh->last_region_number;\n+  struct eh_region **n_array, *root, *cur, *prev_try;\n+  int i;\n+  \n+  if (ifun_last_region_number == 0 || !ifun->eh->region_tree)\n+    return 0;\n+  \n+  n_array = xcalloc (ifun_last_region_number + 1, sizeof (*n_array));\n+  \n+  /* Search for the containing ERT_TRY region to fix up\n+     the prev_try short-cuts for ERT_CLEANUP regions.  */\n+  prev_try = NULL;\n+  if (outer_region > 0)\n+    for (prev_try = cfun->eh->region_array[outer_region];\n+         prev_try && prev_try->type != ERT_TRY;\n+\t prev_try = prev_try->outer)\n+      ;\n+\n+  for (i = 1; i <= ifun_last_region_number; ++i)\n+    {\n+      cur = ifun->eh->region_array[i];\n+      if (!cur || cur->region_number != i)\n+\tcontinue;\n+      n_array[i] = duplicate_eh_region_1 (cur);\n+      if (cur->tree_label)\n+\t{\n+\t  tree newlabel = map (cur->tree_label, data);\n+\t  n_array[i]->tree_label = newlabel;\n+\t}\n+      else\n+\tn_array[i]->tree_label = NULL;\n+    }\n+  for (i = 1; i <= ifun_last_region_number; ++i)\n+    {\n+      cur = ifun->eh->region_array[i];\n+      if (!cur || cur->region_number != i)\n+\tcontinue;\n+      duplicate_eh_region_2 (cur, n_array, prev_try);\n+    }\n+  \n+  root = n_array[ifun->eh->region_tree->region_number];\n+  gcc_assert (root->outer == NULL);\n+  if (outer_region > 0)\n+    {\n+      struct eh_region *cur = cfun->eh->region_array[outer_region];\n+      struct eh_region *p = cur->inner;\n+\n+      if (p)\n+\t{\n+\t  while (p->next_peer)\n+\t    p = p->next_peer;\n+\t  p->next_peer = root;\n+\t}\n+      else\n+        cur->inner = root;\n+      for (i = 1; i <= ifun_last_region_number; ++i)\n+\tif (n_array[i] && n_array[i]->outer == NULL)\n+\t  n_array[i]->outer = cur;\n+    }\n+  else\n+    {\n+      struct eh_region *p = cfun->eh->region_tree;\n+      if (p)\n+\t{\n+\t  while (p->next_peer)\n+\t    p = p->next_peer;\n+\t  p->next_peer = root;\n+\t}\n+      else\n+        cfun->eh->region_tree = root;\n+    }\n+  \n+  free (n_array);\n+  \n+  i = cfun->eh->last_region_number;\n+  cfun->eh->last_region_number = i + ifun_last_region_number;\n+  \n+  collect_eh_region_array ();\n+  \n+  return i;\n+}\n+\f\n static int\n t2r_eq (const void *pentry, const void *pdata)\n {\n@@ -2273,8 +2415,13 @@ reachable_next_level (struct eh_region *region, tree type_thrown,\n       /* Here we end our search, since no exceptions may propagate.\n \t If we've touched down at some landing pad previous, then the\n \t explicit function call we generated may be used.  Otherwise\n-\t the call is made by the runtime.  */\n-      if (info && info->saw_any_handlers)\n+\t the call is made by the runtime. \n+\n+         Before inlining, do not perform this optimization.  We may\n+\t inline a subroutine that contains handlers, and that will\n+\t change the value of saw_any_handlers.  */\n+\n+      if ((info && info->saw_any_handlers) || !cfun->after_inlining)\n \t{\n \t  add_reachable_handler (info, region, region);\n \t  return RNL_CAUGHT;"}, {"sha": "9526b865909dd0e6a232e35b2eae91c783fa3135", "filename": "gcc/except.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f464e05898aa368da60d94c24b7818552eb0f7/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f464e05898aa368da60d94c24b7818552eb0f7/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=98f464e05898aa368da60d94c24b7818552eb0f7", "patch": "@@ -81,6 +81,8 @@ extern void expand_eh_return (void);\n extern rtx expand_builtin_extend_pointer (tree);\n extern rtx get_exception_pointer (struct function *);\n extern rtx get_exception_filter (struct function *);\n+typedef tree (*duplicate_eh_regions_map) (tree, void *);\n+extern int duplicate_eh_regions (struct function *, duplicate_eh_regions_map, void *, int);\n \n extern void sjlj_emit_function_exit_after (rtx);\n "}, {"sha": "0720c12ca5de3ad0696ce1e3804e3865a1f2ef12", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f464e05898aa368da60d94c24b7818552eb0f7/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f464e05898aa368da60d94c24b7818552eb0f7/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=98f464e05898aa368da60d94c24b7818552eb0f7", "patch": "@@ -168,6 +168,7 @@ struct function GTY(())\n \n   /* The control flow graph for this function.  */\n   struct control_flow_graph *cfg;\n+  bool after_inlining;\n \n   /* For tree-optimize.c.  */\n "}, {"sha": "9860a29da006311c25f9c5508aadeeb78ce73268", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f464e05898aa368da60d94c24b7818552eb0f7/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f464e05898aa368da60d94c24b7818552eb0f7/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=98f464e05898aa368da60d94c24b7818552eb0f7", "patch": "@@ -823,6 +823,8 @@ label_to_block_fn (struct function *ifun, tree dest)\n       bsi_insert_before (&bsi, stmt, BSI_NEW_STMT);\n       uid = LABEL_DECL_UID (dest);\n     }\n+  if (VARRAY_SIZE (ifun->cfg->x_label_to_block_map) <= (unsigned int)uid)\n+    return NULL;\n   return VARRAY_BB (ifun->cfg->x_label_to_block_map, uid);\n }\n "}, {"sha": "3bf58300d27e4fb844d58ccadd601af72a3419bc", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f464e05898aa368da60d94c24b7818552eb0f7/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f464e05898aa368da60d94c24b7818552eb0f7/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=98f464e05898aa368da60d94c24b7818552eb0f7", "patch": "@@ -112,6 +112,11 @@ add_stmt_to_eh_region_fn (struct function *ifun, tree t, int num)\n   n->stmt = t;\n   n->region_nr = num;\n \n+  if (!get_eh_throw_stmt_table (ifun))\n+    set_eh_throw_stmt_table (ifun, htab_create_ggc (31, struct_ptr_hash,\n+\t\t\t\t\t\t    struct_ptr_eq,\n+\t\t\t\t\t\t    ggc_free));\n+\n   slot = htab_find_slot (get_eh_throw_stmt_table (ifun), n, INSERT);\n   gcc_assert (!*slot);\n   *slot = n;"}, {"sha": "c3ceb31f59cc71bf64d435beef9463de9dd46288", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f464e05898aa368da60d94c24b7818552eb0f7/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f464e05898aa368da60d94c24b7818552eb0f7/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=98f464e05898aa368da60d94c24b7818552eb0f7", "patch": "@@ -675,6 +675,7 @@ tree_rest_of_compilation (tree fndecl)\n      We haven't necessarily assigned RTL to all variables yet, so it's\n      not safe to try to expand expressions involving them.  */\n   cfun->x_dont_save_pending_sizes_p = 1;\n+  cfun->after_inlining = true;\n \n   node = cgraph_node (fndecl);\n "}]}