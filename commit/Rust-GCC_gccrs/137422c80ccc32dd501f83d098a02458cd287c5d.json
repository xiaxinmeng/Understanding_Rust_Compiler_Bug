{"sha": "137422c80ccc32dd501f83d098a02458cd287c5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM3NDIyYzgwY2NjMzJkZDUwMWY4M2QwOThhMDI0NThjZDI4N2M1ZA==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville.voutilainen@gmail.com", "date": "2016-07-29T19:01:39Z"}, "committer": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2016-07-29T19:01:39Z"}, "message": "Implement C++17 variable templates for type traits.\n\n\t* include/std/chrono (treat_as_floating_point_v): New.\n\t* include/std/ratio (ratio_equal_v, ratio_not_equal_v)\n\t(ratio_less_v, ratio_less_equal_v, ratio_greater_v)\n\t(ratio_greater_equal_v): Likewise.\n\t* include/std/system_error (is_error_code_enum_v)\n\t(is_error_condition_enum_v): Likewise.\n\t* include/std/tuple (tuple_size_v): Likewise.\n\t* type_traits (conjunction_v, disjunction_v, negation_v)\n\t(is_void_v, is_null_pointer_v, is_integral_v, is_floating_point_v)\n\t(is_array_v, is_pointer_v, is_lvalue_reference_v)\n\t(is_rvalue_reference_v, is_member_object_pointer_v)\n\t(is_member_function_pointer_v, is_enum_v, is_union_v)\n\t(is_class_v, is_function_v, is_reference_v, is_arithmetic_v)\n\t(is_fundamental_v, is_object_v, is_scalar_v, is_compound_v)\n\t(is_member_pointer_v, is_const_v, is_volatile_v, is_trivial_v)\n\t(is_trivially_copyable_v, is_standard_layout_v)\n\t(is_pod_v, is_literal_type_v, is_empty_v, is_polymorphic_v)\n\t(is_abstract_v, is_final_v, is_signed_v, is_unsigned_v)\n\t(is_constructible_v, is_default_constructible_v)\n\t(is_copy_constructible_v, is_move_constructible_v)\n\t(is_assignable_v, is_copy_assignable_v, is_move_assignable_v)\n\t(is_destructible_v, is_trivially_constructible_v)\n\t(is_trivially_default_constructible_v)\n \t(is_trivially_copy_constructible_v, is_trivially_move_constructible_v)\n\t(is_trivially_assignable_v, is_trivially_copy_assignable_v)\n\t(is_trivially_move_assignable_v, is_trivially_destructible_v)\n\t(is_nothrow_constructible_v, is_nothrow_default_constructible_v)\n\t(is_nothrow_copy_constructible_v, is_nothrow_move_constructible_v)\n\t(is_nothrow_assignable_v, is_nothrow_copy_assignable_v)\n\t(is_nothrow_move_assignable_v, is_nothrow_destructible_v)\n\t(has_virtual_destructor_v, alignment_of_v, rank_v, extent_v)\n\t(is_same_v, is_base_of_v, is_convertible_v): Likewise.\n\t* testsuite/19_diagnostics/error_code/is_error_code_v.cc: Likewise.\n\t* testsuite/20_util/duration/requirements/treat_as_floating_point_v.cc:\n\tLikewise.\n\t* testsuite/20_util/ratio/requirements/ratio_equal_v.cc: Likewise.\n\t* testsuite/20_util/tuple/tuple_size_v.cc: Likewise.\n\t* testsuite/20_util/variable_templates_for_traits.cc: Likewise.\n\nFrom-SVN: r238892", "tree": {"sha": "89a707b19fbcead7218595353b6d22c404daf2b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89a707b19fbcead7218595353b6d22c404daf2b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/137422c80ccc32dd501f83d098a02458cd287c5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/137422c80ccc32dd501f83d098a02458cd287c5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/137422c80ccc32dd501f83d098a02458cd287c5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/137422c80ccc32dd501f83d098a02458cd287c5d/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "466effe0271a4cbfd905724e2709f5503d66cd6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/466effe0271a4cbfd905724e2709f5503d66cd6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/466effe0271a4cbfd905724e2709f5503d66cd6b"}], "stats": {"total": 740, "additions": 739, "deletions": 1}, "files": [{"sha": "40102865bcece6e072d13c590bf99c7210843839", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=137422c80ccc32dd501f83d098a02458cd287c5d", "patch": "@@ -1,3 +1,45 @@\n+2016-07-29  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tImplement C++17 variable templates for type traits.\n+\t* include/std/chrono (treat_as_floating_point_v): New.\n+\t* include/std/ratio (ratio_equal_v, ratio_not_equal_v)\n+\t(ratio_less_v, ratio_less_equal_v, ratio_greater_v)\n+\t(ratio_greater_equal_v): Likewise.\n+\t* include/std/system_error (is_error_code_enum_v)\n+\t(is_error_condition_enum_v): Likewise.\n+\t* include/std/tuple (tuple_size_v): Likewise.\n+\t* type_traits (conjunction_v, disjunction_v, negation_v)\n+\t(is_void_v, is_null_pointer_v, is_integral_v, is_floating_point_v)\n+\t(is_array_v, is_pointer_v, is_lvalue_reference_v)\n+\t(is_rvalue_reference_v, is_member_object_pointer_v)\n+\t(is_member_function_pointer_v, is_enum_v, is_union_v)\n+\t(is_class_v, is_function_v, is_reference_v, is_arithmetic_v)\n+\t(is_fundamental_v, is_object_v, is_scalar_v, is_compound_v)\n+\t(is_member_pointer_v, is_const_v, is_volatile_v, is_trivial_v)\n+\t(is_trivially_copyable_v, is_standard_layout_v)\n+\t(is_pod_v, is_literal_type_v, is_empty_v, is_polymorphic_v)\n+\t(is_abstract_v, is_final_v, is_signed_v, is_unsigned_v)\n+\t(is_constructible_v, is_default_constructible_v)\n+\t(is_copy_constructible_v, is_move_constructible_v)\n+\t(is_assignable_v, is_copy_assignable_v, is_move_assignable_v)\n+\t(is_destructible_v, is_trivially_constructible_v)\n+\t(is_trivially_default_constructible_v)\n+ \t(is_trivially_copy_constructible_v, is_trivially_move_constructible_v)\n+\t(is_trivially_assignable_v, is_trivially_copy_assignable_v)\n+\t(is_trivially_move_assignable_v, is_trivially_destructible_v)\n+\t(is_nothrow_constructible_v, is_nothrow_default_constructible_v)\n+\t(is_nothrow_copy_constructible_v, is_nothrow_move_constructible_v)\n+\t(is_nothrow_assignable_v, is_nothrow_copy_assignable_v)\n+\t(is_nothrow_move_assignable_v, is_nothrow_destructible_v)\n+\t(has_virtual_destructor_v, alignment_of_v, rank_v, extent_v)\n+\t(is_same_v, is_base_of_v, is_convertible_v): Likewise.\n+\t* testsuite/19_diagnostics/error_code/is_error_code_v.cc: Likewise.\n+\t* testsuite/20_util/duration/requirements/treat_as_floating_point_v.cc:\n+\tLikewise.\n+\t* testsuite/20_util/ratio/requirements/ratio_equal_v.cc: Likewise.\n+\t* testsuite/20_util/tuple/tuple_size_v.cc: Likewise.\n+\t* testsuite/20_util/variable_templates_for_traits.cc: Likewise.\n+\n 2016-07-29  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* config/abi/post/aarch64-linux-gnu/baseline_symbols.txt: Update."}, {"sha": "fdb21b34d4348e3d944183f2175405ce9b89a533", "filename": "libstdc++-v3/include/std/chrono", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono?ref=137422c80ccc32dd501f83d098a02458cd287c5d", "patch": "@@ -208,7 +208,11 @@ _GLIBCXX_END_NAMESPACE_VERSION\n       struct treat_as_floating_point\n       : is_floating_point<_Rep>\n       { };\n-\n+#if __cplusplus > 201402L\n+    template <typename _Rep>\n+      constexpr bool treat_as_floating_point_v =\n+        treat_as_floating_point<_Rep>::value;\n+#endif // C++17\n     /// duration_values\n     template<typename _Rep>\n       struct duration_values"}, {"sha": "4a243a0cf73c84670c909a426e0a7cd99d067753", "filename": "libstdc++-v3/include/std/ratio", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fratio", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fratio", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fratio?ref=137422c80ccc32dd501f83d098a02458cd287c5d", "patch": "@@ -401,6 +401,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : integral_constant<bool, !ratio_less<_R1, _R2>::value>\n     { };\n \n+#if __cplusplus > 201402L\n+  template <typename _R1, typename _R2>\n+    constexpr bool ratio_equal_v = ratio_equal<_R1, _R2>::value;\n+  template <typename _R1, typename _R2>\n+    constexpr bool ratio_not_equal_v = ratio_not_equal<_R1, _R2>::value;\n+  template <typename _R1, typename _R2>\n+    constexpr bool ratio_less_v = ratio_less<_R1, _R2>::value;\n+  template <typename _R1, typename _R2>\n+    constexpr bool ratio_less_equal_v = ratio_less_equal<_R1, _R2>::value;\n+  template <typename _R1, typename _R2>\n+    constexpr bool ratio_greater_v = ratio_greater<_R1, _R2>::value;\n+  template <typename _R1, typename _R2>\n+    constexpr bool ratio_greater_equal_v\n+    = ratio_greater_equal<_R1, _R2>::value;\n+#endif // C++17\n+\n   template<typename _R1, typename _R2,\n       bool = (_R1::num >= 0),\n       bool = (_R2::num >= 0),"}, {"sha": "1ef64f46015d86b4747de7222abec876bc484739", "filename": "libstdc++-v3/include/std/system_error", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsystem_error", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsystem_error", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsystem_error?ref=137422c80ccc32dd501f83d098a02458cd287c5d", "patch": "@@ -60,6 +60,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct is_error_condition_enum<errc>\n     : public true_type { };\n \n+#if __cplusplus > 201402L\n+  template <typename _Tp>\n+    constexpr bool is_error_code_enum_v = is_error_code_enum<_Tp>::value;\n+  template <typename _Tp>\n+    constexpr bool is_error_condition_enum_v =\n+      is_error_condition_enum<_Tp>::value;\n+#endif // C++17\n   inline namespace _V2 {\n \n   /// error_category"}, {"sha": "c1c924c12122cb38dc94a77e960f2d03af075598", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=137422c80ccc32dd501f83d098a02458cd287c5d", "patch": "@@ -1265,6 +1265,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct tuple_size<tuple<_Elements...>>\n     : public integral_constant<std::size_t, sizeof...(_Elements)> { };\n \n+#if __cplusplus > 201402L\n+  template <typename _Tp>\n+    constexpr size_t tuple_size_v = tuple_size<_Tp>::value;\n+#endif\n+\n   template<std::size_t __i, typename _Head, typename... _Tail>\n     constexpr _Head&\n     __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept"}, {"sha": "bfdc3ba90cf824bb18ed31a56378bb822fd31721", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=137422c80ccc32dd501f83d098a02458cd287c5d", "patch": "@@ -172,6 +172,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct negation\n     : __not_<_Pp>\n     { };\n+\n+  template<typename... _Bn>\n+    constexpr bool conjunction_v\n+    = conjunction<_Bn...>::value;\n+  \n+  template<typename... _Bn>\n+    constexpr bool disjunction_v\n+    = disjunction<_Bn...>::value;\n+  \n+  template<typename _Pp>\n+    constexpr bool negation_v\n+    = negation<_Pp>::value;\n+\n #endif\n \n   // For several sfinae-friendly trait implementations we transport both the\n@@ -2765,6 +2778,159 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     constexpr bool is_nothrow_swappable_with_v =\n       is_nothrow_swappable_with<_Tp, _Up>::value;\n #endif // __cplusplus >= 201402L\n+\n+#if __cplusplus > 201402L\n+template <typename _Tp>\n+  constexpr bool is_void_v = is_void<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_integral_v = is_integral<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_array_v = is_array<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_pointer_v = is_pointer<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_lvalue_reference_v = is_lvalue_reference<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_rvalue_reference_v = is_rvalue_reference<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_member_object_pointer_v =\n+    is_member_object_pointer<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_member_function_pointer_v =\n+    is_member_function_pointer<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_enum_v = is_enum<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_union_v = is_union<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_class_v = is_class<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_function_v = is_function<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_reference_v = is_reference<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_object_v = is_object<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_scalar_v = is_scalar<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_compound_v = is_compound<_Tp>::value;\n+template <typename _Tp>\n+ constexpr bool is_member_pointer_v = is_member_pointer<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_const_v = is_const<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_volatile_v = is_volatile<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_trivial_v = is_trivial<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_trivially_copyable_v = is_trivially_copyable<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_standard_layout_v = is_standard_layout<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_pod_v = is_pod<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_literal_type_v = is_literal_type<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_empty_v = is_empty<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_polymorphic_v = is_polymorphic<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_abstract_v = is_abstract<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_final_v = is_final<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_signed_v = is_signed<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;\n+template <typename _Tp, typename... _Args>\n+  constexpr bool is_constructible_v = is_constructible<_Tp, _Args...>::value;\n+template <typename _Tp>\n+  constexpr bool is_default_constructible_v =\n+    is_default_constructible<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_copy_constructible_v = is_copy_constructible<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_move_constructible_v = is_move_constructible<_Tp>::value;\n+template <typename _Tp, typename _Up>\n+  constexpr bool is_assignable_v = is_assignable<_Tp, _Up>::value;\n+template <typename _Tp>\n+  constexpr bool is_copy_assignable_v = is_copy_assignable<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_move_assignable_v = is_move_assignable<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_destructible_v = is_destructible<_Tp>::value;\n+template <typename _Tp, typename... _Args>\n+  constexpr bool is_trivially_constructible_v =\n+    is_trivially_constructible<_Tp, _Args...>::value;\n+template <typename _Tp>\n+  constexpr bool is_trivially_default_constructible_v =\n+    is_trivially_default_constructible<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_trivially_copy_constructible_v =\n+    is_trivially_copy_constructible<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_trivially_move_constructible_v =\n+    is_trivially_move_constructible<_Tp>::value;\n+template <typename _Tp, typename _Up>\n+  constexpr bool is_trivially_assignable_v =\n+    is_trivially_assignable<_Tp, _Up>::value;\n+template <typename _Tp>\n+  constexpr bool is_trivially_copy_assignable_v =\n+    is_trivially_copy_assignable<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_trivially_move_assignable_v =\n+    is_trivially_move_assignable<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_trivially_destructible_v =\n+    is_trivially_destructible<_Tp>::value;\n+template <typename _Tp, typename... _Args>\n+  constexpr bool is_nothrow_constructible_v =\n+    is_nothrow_constructible<_Tp, _Args...>::value;\n+template <typename _Tp>\n+  constexpr bool is_nothrow_default_constructible_v =\n+    is_nothrow_default_constructible<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_nothrow_copy_constructible_v =\n+    is_nothrow_copy_constructible<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_nothrow_move_constructible_v =\n+    is_nothrow_move_constructible<_Tp>::value;\n+template <typename _Tp, typename _Up>\n+  constexpr bool is_nothrow_assignable_v =\n+    is_nothrow_assignable<_Tp, _Up>::value;\n+template <typename _Tp>\n+  constexpr bool is_nothrow_copy_assignable_v =\n+    is_nothrow_copy_assignable<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_nothrow_move_assignable_v =\n+    is_nothrow_move_assignable<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_nothrow_destructible_v =\n+    is_nothrow_destructible<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool has_virtual_destructor_v =\n+    has_virtual_destructor<_Tp>::value;\n+template <typename _Tp>\n+  constexpr size_t alignment_of_v = alignment_of<_Tp>::value;\n+template <typename _Tp>\n+  constexpr size_t rank_v = rank<_Tp>::value;\n+template <typename _Tp, unsigned _Idx = 0>\n+  constexpr size_t extent_v = extent<_Tp, _Idx>::value;\n+template <typename _Tp, typename _Up>\n+  constexpr bool is_same_v = is_same<_Tp, _Up>::value;\n+template <typename _Base, typename _Derived>\n+  constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;\n+template <typename _From, typename _To>\n+  constexpr bool is_convertible_v = is_convertible<_From, _To>::value;\n+#endif // C++17\n #endif\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "629cae1fcf8aa03859e10adc3829d183e6a079fb", "filename": "libstdc++-v3/testsuite/19_diagnostics/error_code/is_error_code_v.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Ftestsuite%2F19_diagnostics%2Ferror_code%2Fis_error_code_v.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Ftestsuite%2F19_diagnostics%2Ferror_code%2Fis_error_code_v.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F19_diagnostics%2Ferror_code%2Fis_error_code_v.cc?ref=137422c80ccc32dd501f83d098a02458cd287c5d", "patch": "@@ -0,0 +1,39 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2014-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <system_error>\n+#include <future>\n+using namespace std;\n+\n+// These tests are rather simple, the front-end tests already test\n+// variable templates, and the library tests for the underlying\n+// traits are more elaborate. These are just simple sanity tests.\n+\n+static_assert(is_error_code_enum_v<future_errc>\n+\t      && is_error_code_enum<future_errc>::value, \"\");\n+\n+static_assert(!is_error_code_enum_v<int>\n+\t      && !is_error_code_enum<int>::value, \"\");\n+\n+static_assert(is_error_condition_enum_v<errc>\n+\t      && is_error_condition_enum<errc>::value, \"\");\n+\n+static_assert(!is_error_condition_enum_v<int>\n+\t      && !is_error_condition_enum<int>::value, \"\");"}, {"sha": "0148239f5e0a67b859cb1733d024dd2c0172716f", "filename": "libstdc++-v3/testsuite/20_util/duration/requirements/treat_as_floating_point_v.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftreat_as_floating_point_v.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftreat_as_floating_point_v.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Frequirements%2Ftreat_as_floating_point_v.cc?ref=137422c80ccc32dd501f83d098a02458cd287c5d", "patch": "@@ -0,0 +1,33 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2014-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <chrono>\n+\n+using namespace std::chrono;\n+\n+// These tests are rather simple, the front-end tests already test\n+// variable templates, and the library tests for the underlying\n+// traits are more elaborate. These are just simple sanity tests.\n+\n+static_assert(!treat_as_floating_point_v<int>\n+\t      && !treat_as_floating_point<int>::value, \"\");\n+\n+static_assert(treat_as_floating_point_v<double>\n+\t      && treat_as_floating_point<double>::value, \"\");"}, {"sha": "1158a67dd395d9b0e9113089f6573cf9497e3151", "filename": "libstdc++-v3/testsuite/20_util/ratio/requirements/ratio_equal_v.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Frequirements%2Fratio_equal_v.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Frequirements%2Fratio_equal_v.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Frequirements%2Fratio_equal_v.cc?ref=137422c80ccc32dd501f83d098a02458cd287c5d", "patch": "@@ -0,0 +1,49 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2014-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <ratio>\n+\n+using namespace std;\n+\n+// These tests are rather simple, the front-end tests already test\n+// variable templates, and the library tests for the underlying\n+// traits are more elaborate. These are just simple sanity tests.\n+\n+static_assert(ratio_equal_v<ratio<1, 3>, ratio<2, 6>>\n+\t      && ratio_equal<ratio<1, 3>, ratio<2, 6>>::value, \"\");\n+\n+static_assert(ratio_not_equal_v<ratio<1, 3>, ratio<2, 5>>\n+\t      && ratio_not_equal<ratio<1, 3>, ratio<2, 5>>::value, \"\");\n+\n+static_assert(ratio_less_v<ratio<1, 4>, ratio<1, 3>>\n+\t      && ratio_less<ratio<1, 4>, ratio<1, 3>>::value, \"\");\n+\n+static_assert(ratio_less_equal_v<ratio<1, 4>, ratio<1, 4>>\n+\t      && ratio_less_equal_v<ratio<1, 4>, ratio<1, 3>>\n+\t      && ratio_less_equal<ratio<1, 4>, ratio<1, 4>>::value\n+\t      && ratio_less_equal<ratio<1, 4>, ratio<1, 3>>::value, \"\");\n+\n+static_assert(ratio_greater_v<ratio<1, 3>, ratio<1, 4>>\n+\t      && ratio_greater<ratio<1, 3>, ratio<1, 4>>::value, \"\");\n+\n+static_assert(ratio_greater_equal_v<ratio<1, 4>, ratio<1, 4>>\n+\t      && ratio_greater_equal_v<ratio<1, 3>, ratio<1, 4>>\n+\t      && ratio_greater_equal<ratio<1, 4>, ratio<1, 4>>::value\n+\t      && ratio_greater_equal<ratio<1, 3>, ratio<1, 4>>::value, \"\");"}, {"sha": "29ce5c1701f317ba1f3052fe5664b8b5350bc593", "filename": "libstdc++-v3/testsuite/20_util/tuple/tuple_size_v.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Ftuple_size_v.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Ftuple_size_v.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Ftuple_size_v.cc?ref=137422c80ccc32dd501f83d098a02458cd287c5d", "patch": "@@ -0,0 +1,33 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2014-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <tuple>\n+\n+using namespace std;\n+\n+// These tests are rather simple, the front-end tests already test\n+// variable templates, and the library tests for the underlying\n+// traits are more elaborate. These are just simple sanity tests.\n+\n+static_assert(tuple_size_v<tuple<int>> == 1\n+\t      && tuple_size<tuple<int>>::value == 1, \"\");\n+\n+static_assert(tuple_size_v<tuple<int, int>> == 2\n+\t      && tuple_size<tuple<int, int>>::value == 2, \"\");"}, {"sha": "5a497f12445d26c53ea644dc6c8a4946edafe9b5", "filename": "libstdc++-v3/testsuite/20_util/variable_templates_for_traits.cc", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariable_templates_for_traits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137422c80ccc32dd501f83d098a02458cd287c5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariable_templates_for_traits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariable_templates_for_traits.cc?ref=137422c80ccc32dd501f83d098a02458cd287c5d", "patch": "@@ -0,0 +1,344 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2014-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+\n+using namespace std;\n+\n+// These tests are rather simple, the front-end tests already test\n+// variable templates, and the library tests for the underlying\n+// traits are more elaborate. These are just simple sanity tests.\n+\n+static_assert(is_void_v<void> && is_void<void>::value, \"\");\n+static_assert(!is_void_v<int> && !is_void<int>::value, \"\");\n+\n+static_assert(is_null_pointer_v<nullptr_t>\n+\t      && is_null_pointer<nullptr_t>::value, \"\");\n+static_assert(!is_null_pointer_v<void*>\n+\t      && !is_null_pointer<void*>::value, \"\");\n+\n+static_assert(is_integral_v<int> && is_integral<int>::value, \"\");\n+static_assert(!is_integral_v<int*> && !is_integral<int*>::value, \"\");\n+\n+static_assert(is_floating_point_v<float>\n+\t      && is_floating_point<float>::value, \"\");\n+static_assert(!is_floating_point_v<int>\n+\t      && !is_floating_point<int>::value, \"\");\n+\n+static_assert(is_array_v<char[42]> && is_array<char[42]>::value, \"\");\n+static_assert(!is_array_v<char*> && !is_array<char*>::value, \"\");\n+\n+static_assert(is_pointer_v<int*> && is_pointer<int*>::value, \"\");\n+static_assert(!is_pointer_v<int> && !is_pointer<int>::value, \"\");\n+\n+static_assert(is_lvalue_reference_v<int&>\n+\t      && is_lvalue_reference<int&>::value, \"\");\n+static_assert(!is_lvalue_reference_v<int>\n+\t      && !is_lvalue_reference<int>::value, \"\");\n+\n+static_assert(is_rvalue_reference_v<int&&>\n+\t      && is_rvalue_reference<int&&>::value, \"\");\n+static_assert(!is_rvalue_reference_v<int>\n+\t      && !is_rvalue_reference<int>::value, \"\");\n+\n+struct EmptyFinal final {};\n+\n+static_assert(is_member_object_pointer_v<int (EmptyFinal::*)>\n+\t      && is_member_object_pointer<int (EmptyFinal::*)>::value, \"\");\n+static_assert(!is_member_object_pointer_v<void*>\n+\t      && !is_member_object_pointer<void*>::value, \"\");\n+\n+static_assert(is_member_function_pointer_v<int (EmptyFinal::*)()>\n+\t      && is_member_function_pointer<int (EmptyFinal::*)()>::value, \"\");\n+static_assert(!is_member_function_pointer_v<void*>\n+\t      && !is_member_function_pointer<void*>::value, \"\");\n+\n+enum Enum {};\n+\n+static_assert(is_enum_v<Enum> && is_enum<Enum>::value, \"\");\n+static_assert(!is_enum_v<int> && !is_enum<int>::value, \"\");\n+\n+union Union;\n+\n+static_assert(is_union_v<Union> && is_union<Union>::value, \"\");\n+static_assert(!is_union_v<int> && !is_union<int>::value, \"\");\n+\n+static_assert(is_class_v<EmptyFinal> && is_class<EmptyFinal>::value, \"\");\n+static_assert(!is_class_v<int> && !is_class<int>::value, \"\");\n+\n+static_assert(is_function_v<void()> && is_function<void()>::value, \"\");\n+static_assert(!is_function_v<void(*)()> && !is_function<void(*)()>::value, \"\");\n+\n+static_assert(is_reference_v<int&> && is_reference<int&>::value, \"\");\n+static_assert(!is_reference_v<int> && !is_reference<int>::value, \"\");\n+\n+static_assert(is_arithmetic_v<int> && is_arithmetic<int>::value, \"\");\n+static_assert(!is_arithmetic_v<void*> && !is_arithmetic<void*>::value, \"\");\n+\n+static_assert(is_fundamental_v<int> && is_fundamental<int>::value, \"\");\n+static_assert(!is_fundamental_v<EmptyFinal>\n+\t      && !is_fundamental<EmptyFinal>::value, \"\");\n+\n+static_assert(is_object_v<int> && is_object<int>::value, \"\");\n+static_assert(!is_object_v<int&> && !is_object<int&>::value, \"\");\n+\n+static_assert(is_scalar_v<int> && is_scalar<int>::value, \"\");\n+static_assert(!is_scalar_v<int&> && !is_scalar<int&>::value, \"\");\n+\n+static_assert(is_compound_v<EmptyFinal>\n+\t      && is_compound<EmptyFinal>::value, \"\");\n+static_assert(!is_compound_v<int> && !is_compound<int>::value, \"\");\n+\n+static_assert(is_member_pointer_v<int (EmptyFinal::*)>\n+\t      && is_member_pointer<int (EmptyFinal::*)>::value, \"\");\n+static_assert(!is_member_pointer_v<void*>\n+\t      && !is_member_pointer<void*>::value, \"\");\n+\n+static_assert(is_const_v<const int> && is_const<const int>::value, \"\");\n+static_assert(!is_const_v<int> && !is_const<int>::value, \"\");\n+\n+static_assert(is_volatile_v<volatile int>\n+\t      && is_volatile<volatile int>::value, \"\");\n+static_assert(!is_volatile_v<int> && !is_volatile<int>::value, \"\");\n+\n+struct NType\n+{\n+  NType(int);\n+  ~NType();\n+  int i;\n+private:\n+  NType(const NType&);\n+  NType& operator=(const NType&);\n+  int i2;\n+};\n+\n+static_assert(is_trivial_v<int> && is_trivial<int>::value, \"\");\n+static_assert(!is_trivial_v<NType> && !is_trivial<NType>::value, \"\");\n+\n+static_assert(is_trivially_copyable_v<int>\n+\t      && is_trivially_copyable<int>::value, \"\");\n+static_assert(!is_trivially_copyable_v<NType>\n+\t      && !is_trivially_copyable<NType>::value, \"\");\n+\n+static_assert(is_standard_layout_v<int>\n+\t      && is_standard_layout<int>::value, \"\");\n+static_assert(!is_standard_layout_v<NType>\n+\t      && !is_standard_layout<NType>::value, \"\");\n+\n+static_assert(is_pod_v<int>\n+\t      && is_pod<int>::value, \"\");\n+static_assert(!is_pod_v<NType>\n+\t      && !is_pod<NType>::value, \"\");\n+\n+static_assert(is_literal_type_v<int>\n+\t      && is_literal_type<int>::value, \"\");\n+static_assert(!is_literal_type_v<NType>\n+\t      && !is_literal_type<NType>::value, \"\");\n+\n+static_assert(is_empty_v<EmptyFinal>\n+\t      && is_empty<EmptyFinal>::value, \"\");\n+static_assert(!is_empty_v<NType>\n+\t      && !is_empty<NType>::value, \"\");\n+\n+struct Abstract {protected: virtual ~Abstract() = 0;};\n+struct Poly : Abstract {virtual ~Poly();};\n+\n+static_assert(is_polymorphic_v<Poly>\n+\t      && is_polymorphic<Poly>::value, \"\");\n+static_assert(!is_polymorphic_v<EmptyFinal>\n+\t      && !is_polymorphic<EmptyFinal>::value, \"\");\n+\n+\n+\n+static_assert(is_abstract_v<Abstract>\n+\t      && is_abstract<Abstract>::value, \"\");\n+static_assert(!is_abstract_v<EmptyFinal>\n+\t      && !is_abstract<EmptyFinal>::value, \"\");\n+\n+static_assert(is_final_v<EmptyFinal>\n+\t      && is_final<EmptyFinal>::value, \"\");\n+static_assert(!is_final_v<Abstract>\n+\t      && !is_final<Abstract>::value, \"\");\n+\n+static_assert(is_signed_v<int> && is_signed<int>::value, \"\");\n+static_assert(!is_signed_v<unsigned int>\n+\t      && !is_signed<unsigned int>::value, \"\");\n+\n+static_assert(is_constructible_v<int, int>\n+\t      && is_constructible<int, int>::value, \"\");\n+static_assert(!is_constructible_v<int, void*>\n+\t      && !is_constructible<int, void*>::value, \"\");\n+\n+static_assert(is_default_constructible_v<int>\n+\t      && is_default_constructible<int>::value, \"\");\n+static_assert(!is_default_constructible_v<NType>\n+\t      && !is_default_constructible<NType>::value, \"\");\n+\n+static_assert(is_copy_constructible_v<int>\n+\t      && is_copy_constructible<int>::value, \"\");\n+static_assert(!is_copy_constructible_v<NType>\n+\t      && !is_copy_constructible<NType>::value, \"\");\n+\n+static_assert(is_move_constructible_v<int>\n+\t      && is_copy_constructible<int>::value, \"\");\n+static_assert(!is_move_constructible_v<NType>\n+\t      && !is_copy_constructible<NType>::value, \"\");\n+\n+static_assert(is_assignable_v<int&, int>\n+\t      && is_assignable<int&, int>::value, \"\");\n+static_assert(!is_assignable_v<int, int>\n+\t      && !is_assignable<int, int>::value, \"\");\n+\n+static_assert(is_copy_assignable_v<int>\n+\t      && is_copy_assignable<int>::value, \"\");\n+static_assert(!is_copy_assignable_v<NType>\n+\t      && !is_copy_assignable<NType>::value, \"\");\n+\n+static_assert(is_move_assignable_v<int>\n+\t      && is_move_assignable<int>::value, \"\");\n+static_assert(!is_move_assignable_v<NType>\n+\t      && !is_move_assignable<NType>::value, \"\");\n+\n+static_assert(is_destructible_v<int>\n+\t      && is_destructible<int>::value, \"\");\n+static_assert(!is_destructible_v<Abstract>\n+\t      && !is_destructible<Abstract>::value, \"\");\n+\n+static_assert(is_trivially_constructible_v<int, int>\n+\t      && is_trivially_constructible<int, int>::value, \"\");\n+static_assert(!is_trivially_constructible_v<NType, NType>\n+\t      && !is_trivially_constructible<NType, NType>::value, \"\");\n+\n+static_assert(is_trivially_default_constructible_v<int>\n+\t      && is_trivially_default_constructible<int>::value, \"\");\n+static_assert(!is_trivially_default_constructible_v<NType>\n+\t      && !is_trivially_default_constructible<NType>::value, \"\");\n+\n+static_assert(is_trivially_copy_constructible_v<int>\n+\t      && is_trivially_copy_constructible<int>::value, \"\");\n+static_assert(!is_trivially_copy_constructible_v<NType>\n+\t      && !is_trivially_copy_constructible<NType>::value, \"\");\n+\n+static_assert(is_trivially_move_constructible_v<int>\n+\t      && is_trivially_move_constructible<int>::value, \"\");\n+static_assert(!is_trivially_move_constructible_v<NType>\n+\t      && !is_trivially_move_constructible<NType>::value, \"\");\n+\n+static_assert(is_trivially_assignable_v<int&, int>\n+\t      && is_trivially_assignable<int&, int>::value, \"\");\n+static_assert(!is_trivially_assignable_v<NType, NType>\n+\t      && !is_trivially_assignable<NType, NType>::value, \"\");\n+\n+static_assert(is_trivially_copy_assignable_v<int>\n+\t      && is_trivially_copy_assignable<int>::value, \"\");\n+static_assert(!is_trivially_copy_assignable_v<NType>\n+\t      && !is_trivially_copy_assignable<NType>::value, \"\");\n+\n+static_assert(is_trivially_move_assignable_v<int>\n+\t      && is_trivially_move_assignable<int>::value, \"\");\n+static_assert(!is_trivially_move_assignable_v<NType>\n+\t      && !is_trivially_move_assignable<NType>::value, \"\");\n+\n+static_assert(is_trivially_destructible_v<int>\n+\t      && is_trivially_destructible<int>::value, \"\");\n+static_assert(!is_trivially_destructible_v<Abstract>\n+\t      && !is_trivially_destructible<Abstract>::value, \"\");\n+\n+static_assert(is_nothrow_constructible_v<int, int>\n+\t      && is_nothrow_constructible<int, int>::value, \"\");\n+static_assert(!is_nothrow_constructible_v<NType, NType>\n+\t      && !is_nothrow_constructible<NType, NType>::value, \"\");\n+\n+static_assert(is_nothrow_default_constructible_v<int>\n+\t      && is_nothrow_default_constructible<int>::value, \"\");\n+static_assert(!is_nothrow_default_constructible_v<NType>\n+\t      && !is_nothrow_default_constructible<NType>::value, \"\");\n+\n+static_assert(is_nothrow_copy_constructible_v<int>\n+\t      && is_nothrow_copy_constructible<int>::value, \"\");\n+static_assert(!is_nothrow_copy_constructible_v<NType>\n+\t      && !is_nothrow_copy_constructible<NType>::value, \"\");\n+\n+static_assert(is_nothrow_move_constructible_v<int>\n+\t      && is_nothrow_move_constructible<int>::value, \"\");\n+static_assert(!is_nothrow_move_constructible_v<NType>\n+\t      && !is_nothrow_move_constructible<NType>::value, \"\");\n+\n+static_assert(is_nothrow_assignable_v<int&, int>\n+\t      && is_nothrow_assignable<int&, int>::value, \"\");\n+static_assert(!is_nothrow_assignable_v<NType, NType>\n+\t      && !is_nothrow_assignable<NType, NType>::value, \"\");\n+\n+static_assert(is_nothrow_copy_assignable_v<int>\n+\t      && is_nothrow_copy_assignable<int>::value, \"\");\n+static_assert(!is_nothrow_copy_assignable_v<NType>\n+\t      && !is_nothrow_copy_assignable<NType>::value, \"\");\n+\n+static_assert(is_nothrow_move_assignable_v<int>\n+\t      && is_nothrow_move_assignable<int>::value, \"\");\n+static_assert(!is_nothrow_move_assignable_v<NType>\n+\t      && !is_nothrow_move_assignable<NType>::value, \"\");\n+\n+static_assert(has_virtual_destructor_v<Abstract>\n+\t      && has_virtual_destructor<Abstract>::value, \"\");\n+static_assert(!has_virtual_destructor_v<NType>\n+\t      && !has_virtual_destructor<NType>::value, \"\");\n+\n+static_assert(alignment_of_v<int> == alignof(int)\n+\t      && alignment_of<int>::value == alignof(int) , \"\");\n+\n+static_assert(rank_v<int[1][1]> == rank<int[1][1]>::value, \"\");\n+\n+static_assert(extent_v<int[1][2], 1> == 2\n+\t      && extent<int[1][2], 1>::value == 2, \"\");\n+\n+static_assert(is_same_v<int, int> && is_same<int, int>::value, \"\");\n+static_assert(!is_same_v<int, char> && !is_same<int, char>::value, \"\");\n+\n+static_assert(is_base_of_v<Abstract, Poly>\n+\t      && is_base_of<Abstract, Poly>::value, \"\");\n+static_assert(!is_base_of_v<Abstract, NType>\n+\t      && !is_base_of<Abstract, NType>::value, \"\");\n+\n+static_assert(is_convertible_v<int&, const int&>\n+\t      && is_convertible<int&, const int&>::value, \"\");\n+static_assert(!is_convertible_v<const int&, int&>\n+\t      && !is_convertible<const int&, int&>::value, \"\");\n+\n+static_assert(negation_v<false_type>, \"\");\n+static_assert(!negation_v<true_type>, \"\");\n+static_assert(conjunction_v<>, \"\");\n+static_assert(!disjunction_v<>, \"\");\n+static_assert(conjunction_v<true_type>, \"\");\n+static_assert(!conjunction_v<false_type>, \"\");\n+static_assert(disjunction_v<true_type>, \"\");\n+static_assert(!disjunction_v<false_type>, \"\");\n+static_assert(conjunction_v<true_type, true_type>, \"\");\n+static_assert(!conjunction_v<true_type, false_type>, \"\");\n+static_assert(disjunction_v<false_type, true_type>, \"\");\n+static_assert(!disjunction_v<false_type, false_type>, \"\");\n+static_assert(conjunction_v<true_type, true_type,\n+              true_type>, \"\");\n+static_assert(!conjunction_v<true_type, true_type,\n+              false_type>, \"\");\n+static_assert(disjunction_v<false_type, false_type,\n+              true_type>, \"\");\n+static_assert(!disjunction_v<false_type, false_type,\n+              false_type>, \"\");"}]}