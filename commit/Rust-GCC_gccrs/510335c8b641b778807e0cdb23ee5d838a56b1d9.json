{"sha": "510335c8b641b778807e0cdb23ee5d838a56b1d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTEwMzM1YzhiNjQxYjc3ODgwN2UwY2RiMjNlZTVkODM4YTU2YjFkOQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2007-10-01T16:35:55Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2007-10-01T16:35:55Z"}, "message": "re PR middle-end/22156 (bit-field copying regressed)\n\nPR middle-end/22156\n* tree-sra.c (struct sra_elt): Add in_bitfld_block.\n(sra_hash_tree): Handle BIT_FIELD_REFs.\n(sra_elt_hash): Don't hash bitfld blocks.\n(sra_elt_eq): Skip them in parent compares as well.  Handle\nBIT_FIELD_REFs.\n(build_element_name_1): Handle BIT_FIELD_REFs.\n(instantiate_element): Propagate nowarn from parents.  Create\nBIT_FIELD_REF for variables that are widened by scalarization.\nGimple-zero-initialize all bit-field variables that are not\npart of parameters that are going to be scalarized on entry.\n(instantiate_missing_elements_1): Return the sra_elt.\n(canon_type_for_field): New.\n(try_instantiate_multiple_fields): New.  Infer widest possible\naccess mode from decl or member type, but clip it at word\nsize, and only widen it if a field crosses an alignment\nboundary.\n(instantiate_missing_elements): Use them.\n(generate_one_element_ref): Handle BIT_FIELD_REFs.\n(scalar_bitfield_p): New.\n(sra_build_assignment): Optimize assignments from scalarizable\nBIT_FIELD_REFs.  Use BITS_BIG_ENDIAN to determine shift\ncounts.\n(REPLDUP): New.\n(sra_build_bf_assignment): New.  Optimize assignments to\nscalarizable BIT_FIELD_REFs.\n(sra_build_elt_assignment): New.  Optimize BIT_FIELD_REF\nassignments to full variables.\n(generate_copy_inout): Use the new macros and functions.\n(generate_element_copy): Likewise.  Handle bitfld differences.\n(generate_element_zero): Don't recurse for blocks.  Use\nsra_build_elt_assignment.\n(generate_one_element_init): Take elt instead of var.  Use\nsra_build_elt_assignment.\n(generate_element_init_1): Adjust.\n(bitfield_overlap_info): New struct.\n(bitfield_overlaps_p): New.\n(sra_explode_bitfield_assignment): New.  Adjust widened\nvariables to account for endianness.\n(sra_sync_for_bitfield_assignment): New.\n(scalarize_use): Re-expand assignment to/from scalarized\nBIT_FIELD_REFs.  Explode or sync needed members for\nBIT_FIELD_REFs accesses or assignments.  Use REPLDUP.\n(scalarize_copy): Use REPLDUP.\n(scalarize_ldst): Move assert before dereference.  Adjust EH\nhandling.\n(dump_sra_elt_name): Handle BIT_FIELD_REFs.\n\nFrom-SVN: r128908", "tree": {"sha": "a56e7736aed8e9a5088b68d5f10ebf58a1d17d57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a56e7736aed8e9a5088b68d5f10ebf58a1d17d57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/510335c8b641b778807e0cdb23ee5d838a56b1d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/510335c8b641b778807e0cdb23ee5d838a56b1d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/510335c8b641b778807e0cdb23ee5d838a56b1d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/510335c8b641b778807e0cdb23ee5d838a56b1d9/comments", "author": null, "committer": null, "parents": [{"sha": "a567207e7133ad025029c1869e6ec292acd93f4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a567207e7133ad025029c1869e6ec292acd93f4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a567207e7133ad025029c1869e6ec292acd93f4a"}], "stats": {"total": 1333, "additions": 1283, "deletions": 50}, "files": [{"sha": "3c6aa3d0390bf647cc66fb58bce2aa7ffbce690b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/510335c8b641b778807e0cdb23ee5d838a56b1d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/510335c8b641b778807e0cdb23ee5d838a56b1d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=510335c8b641b778807e0cdb23ee5d838a56b1d9", "patch": "@@ -1,3 +1,53 @@\n+2007-10-01  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR middle-end/22156\n+\t* tree-sra.c (struct sra_elt): Add in_bitfld_block.\n+\t(sra_hash_tree): Handle BIT_FIELD_REFs.\n+\t(sra_elt_hash): Don't hash bitfld blocks.\n+\t(sra_elt_eq): Skip them in parent compares as well.  Handle\n+\tBIT_FIELD_REFs.\n+\t(build_element_name_1): Handle BIT_FIELD_REFs.\n+\t(instantiate_element): Propagate nowarn from parents.  Create\n+\tBIT_FIELD_REF for variables that are widened by scalarization.\n+\tGimple-zero-initialize all bit-field variables that are not\n+\tpart of parameters that are going to be scalarized on entry.\n+\t(instantiate_missing_elements_1): Return the sra_elt.\n+\t(canon_type_for_field): New.\n+\t(try_instantiate_multiple_fields): New.  Infer widest possible\n+\taccess mode from decl or member type, but clip it at word\n+\tsize, and only widen it if a field crosses an alignment\n+\tboundary.\n+\t(instantiate_missing_elements): Use them.\n+\t(generate_one_element_ref): Handle BIT_FIELD_REFs.\n+\t(scalar_bitfield_p): New.\n+\t(sra_build_assignment): Optimize assignments from scalarizable\n+\tBIT_FIELD_REFs.  Use BITS_BIG_ENDIAN to determine shift\n+\tcounts.\n+\t(REPLDUP): New.\n+\t(sra_build_bf_assignment): New.  Optimize assignments to\n+\tscalarizable BIT_FIELD_REFs.\n+\t(sra_build_elt_assignment): New.  Optimize BIT_FIELD_REF\n+\tassignments to full variables.\n+\t(generate_copy_inout): Use the new macros and functions.\n+\t(generate_element_copy): Likewise.  Handle bitfld differences.\n+\t(generate_element_zero): Don't recurse for blocks.  Use\n+\tsra_build_elt_assignment.\n+\t(generate_one_element_init): Take elt instead of var.  Use\n+\tsra_build_elt_assignment.\n+\t(generate_element_init_1): Adjust.\n+\t(bitfield_overlap_info): New struct.\n+\t(bitfield_overlaps_p): New.\n+\t(sra_explode_bitfield_assignment): New.  Adjust widened\n+\tvariables to account for endianness.\n+\t(sra_sync_for_bitfield_assignment): New.\n+\t(scalarize_use): Re-expand assignment to/from scalarized\n+\tBIT_FIELD_REFs.  Explode or sync needed members for\n+\tBIT_FIELD_REFs accesses or assignments.  Use REPLDUP.\n+\t(scalarize_copy): Use REPLDUP.\n+\t(scalarize_ldst): Move assert before dereference.  Adjust EH\n+\thandling.\n+\t(dump_sra_elt_name): Handle BIT_FIELD_REFs.\n+\n 2007-10-01  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* simplify-rtx.c (comparison_result, simplify_relational_operation_1):"}, {"sha": "ff7a52c1a76c871d71aba6dbbb4bfff05f0f1261", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1233, "deletions": 50, "changes": 1283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/510335c8b641b778807e0cdb23ee5d838a56b1d9/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/510335c8b641b778807e0cdb23ee5d838a56b1d9/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=510335c8b641b778807e0cdb23ee5d838a56b1d9", "patch": "@@ -146,6 +146,10 @@ struct sra_elt\n \n   /* True if there is BIT_FIELD_REF on the lhs with a vector. */\n   bool is_vector_lhs;\n+\n+  /* 1 if the element is a field that is part of a block, 2 if the field\n+     is the block itself, 0 if it's neither.  */\n+  char in_bitfld_block;\n };\n \n #define IS_ELEMENT_FOR_GROUP(ELEMENT) (TREE_CODE (ELEMENT) == RANGE_EXPR)\n@@ -204,6 +208,9 @@ extern void debug_sra_elt_name (struct sra_elt *);\n \n /* Forward declarations.  */\n static tree generate_element_ref (struct sra_elt *);\n+static tree sra_build_assignment (tree dst, tree src);\n+static void mark_all_v_defs (tree list);\n+\n \f\n /* Return true if DECL is an SRA candidate.  */\n \n@@ -461,6 +468,12 @@ sra_hash_tree (tree t)\n       h = iterative_hash_expr (DECL_FIELD_BIT_OFFSET (t), h);\n       break;\n \n+    case BIT_FIELD_REF:\n+      /* Don't take operand 0 into account, that's our parent.  */\n+      h = iterative_hash_expr (TREE_OPERAND (t, 1), 0);\n+      h = iterative_hash_expr (TREE_OPERAND (t, 2), h);\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -479,12 +492,14 @@ sra_elt_hash (const void *x)\n \n   h = sra_hash_tree (e->element);\n \n-  /* Take into account everything back up the chain.  Given that chain\n-     lengths are rarely very long, this should be acceptable.  If we\n-     truly identify this as a performance problem, it should work to\n-     hash the pointer value \"e->parent\".  */\n+  /* Take into account everything except bitfield blocks back up the\n+     chain.  Given that chain lengths are rarely very long, this\n+     should be acceptable.  If we truly identify this as a performance\n+     problem, it should work to hash the pointer value\n+     \"e->parent\".  */\n   for (p = e->parent; p ; p = p->parent)\n-    h = (h * 65521) ^ sra_hash_tree (p->element);\n+    if (!p->in_bitfld_block)\n+      h = (h * 65521) ^ sra_hash_tree (p->element);\n \n   return h;\n }\n@@ -497,8 +512,17 @@ sra_elt_eq (const void *x, const void *y)\n   const struct sra_elt *a = x;\n   const struct sra_elt *b = y;\n   tree ae, be;\n+  const struct sra_elt *ap = a->parent;\n+  const struct sra_elt *bp = b->parent;\n \n-  if (a->parent != b->parent)\n+  if (ap)\n+    while (ap->in_bitfld_block)\n+      ap = ap->parent;\n+  if (bp)\n+    while (bp->in_bitfld_block)\n+      bp = bp->parent;\n+\n+  if (ap != bp)\n     return false;\n \n   ae = a->element;\n@@ -533,6 +557,11 @@ sra_elt_eq (const void *x, const void *y)\n \treturn false;\n       return fields_compatible_p (ae, be);\n \n+    case BIT_FIELD_REF:\n+      return\n+\ttree_int_cst_equal (TREE_OPERAND (ae, 1), TREE_OPERAND (be, 1))\n+\t&& tree_int_cst_equal (TREE_OPERAND (ae, 2), TREE_OPERAND (be, 2));\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -898,7 +927,7 @@ sra_walk_asm_expr (tree expr, block_stmt_iterator *bsi,\n \n static void\n sra_walk_gimple_modify_stmt (tree expr, block_stmt_iterator *bsi,\n-\t\t      const struct sra_walk_fns *fns)\n+\t\t\t     const struct sra_walk_fns *fns)\n {\n   struct sra_elt *lhs_elt, *rhs_elt;\n   tree lhs, rhs;\n@@ -1187,6 +1216,15 @@ build_element_name_1 (struct sra_elt *elt)\n       sprintf (buffer, HOST_WIDE_INT_PRINT_DEC, TREE_INT_CST_LOW (t));\n       obstack_grow (&sra_obstack, buffer, strlen (buffer));\n     }\n+  else if (TREE_CODE (t) == BIT_FIELD_REF)\n+    {\n+      sprintf (buffer, \"B\" HOST_WIDE_INT_PRINT_DEC,\n+\t       tree_low_cst (TREE_OPERAND (t, 2), 1));\n+      obstack_grow (&sra_obstack, buffer, strlen (buffer));\n+      sprintf (buffer, \"F\" HOST_WIDE_INT_PRINT_DEC,\n+\t       tree_low_cst (TREE_OPERAND (t, 1), 1));\n+      obstack_grow (&sra_obstack, buffer, strlen (buffer));\n+    }\n   else\n     {\n       tree name = DECL_NAME (t);\n@@ -1219,13 +1257,34 @@ instantiate_element (struct sra_elt *elt)\n {\n   struct sra_elt *base_elt;\n   tree var, base;\n+  bool nowarn = TREE_NO_WARNING (elt->element);\n \n   for (base_elt = elt; base_elt->parent; base_elt = base_elt->parent)\n-    continue;\n+    if (!nowarn)\n+      nowarn = TREE_NO_WARNING (base_elt->parent->element);\n   base = base_elt->element;\n \n   elt->replacement = var = make_rename_temp (elt->type, \"SR\");\n \n+  if (DECL_P (elt->element)\n+      && !tree_int_cst_equal (DECL_SIZE (var), DECL_SIZE (elt->element)))\n+    {\n+      DECL_SIZE (var) = DECL_SIZE (elt->element);\n+      DECL_SIZE_UNIT (var) = DECL_SIZE_UNIT (elt->element);\n+\n+      elt->in_bitfld_block = 1;\n+      elt->replacement = build3 (BIT_FIELD_REF, elt->type, var,\n+\t\t\t\t DECL_SIZE (var),\n+\t\t\t\t BITS_BIG_ENDIAN\n+\t\t\t\t ? size_binop (MINUS_EXPR,\n+\t\t\t\t\t       TYPE_SIZE (elt->type),\n+\t\t\t\t\t       DECL_SIZE (var))\n+\t\t\t\t : bitsize_int (0));\n+      if (!INTEGRAL_TYPE_P (elt->type)\n+\t  || TYPE_UNSIGNED (elt->type))\n+\tBIT_FIELD_REF_UNSIGNED (elt->replacement) = 1;\n+    }\n+\n   /* For vectors, if used on the left hand side with BIT_FIELD_REF,\n      they are not a gimple register.  */\n   if (TREE_CODE (TREE_TYPE (var)) == VECTOR_TYPE && elt->is_vector_lhs)\n@@ -1250,9 +1309,7 @@ instantiate_element (struct sra_elt *elt)\n       DECL_DEBUG_EXPR_IS_FROM (var) = 1;\n       \n       DECL_IGNORED_P (var) = 0;\n-      TREE_NO_WARNING (var) = TREE_NO_WARNING (base);\n-      if (elt->element && TREE_NO_WARNING (elt->element))\n-\tTREE_NO_WARNING (var) = 1;\n+      TREE_NO_WARNING (var) = nowarn;\n     }\n   else\n     {\n@@ -1261,6 +1318,18 @@ instantiate_element (struct sra_elt *elt)\n       TREE_NO_WARNING (var) = 1;\n     }\n \n+  /* Zero-initialize bit-field scalarization variables, to avoid\n+     triggering undefined behavior.  */\n+  if (TREE_CODE (elt->element) == BIT_FIELD_REF\n+      || (var != elt->replacement\n+\t  && TREE_CODE (elt->replacement) == BIT_FIELD_REF))\n+    {\n+      tree init = sra_build_assignment (var, fold_convert (TREE_TYPE (var),\n+\t\t\t\t\t\t\t   integer_zero_node));\n+      insert_edge_copies (init, ENTRY_BLOCK_PTR);\n+      mark_all_v_defs (init);\n+    }\n+\n   if (dump_file)\n     {\n       fputs (\"  \", dump_file);\n@@ -1347,7 +1416,7 @@ sum_instantiated_sizes (struct sra_elt *elt, unsigned HOST_WIDE_INT *sizep)\n \n static void instantiate_missing_elements (struct sra_elt *elt);\n \n-static void\n+static struct sra_elt *\n instantiate_missing_elements_1 (struct sra_elt *elt, tree child, tree type)\n {\n   struct sra_elt *sub = lookup_element (elt, child, type, INSERT);\n@@ -1358,6 +1427,303 @@ instantiate_missing_elements_1 (struct sra_elt *elt, tree child, tree type)\n     }\n   else\n     instantiate_missing_elements (sub);\n+  return sub;\n+}\n+\n+/* Obtain the canonical type for field F of ELEMENT.  */\n+\n+static tree\n+canon_type_for_field (tree f, tree element)\n+{\n+  tree field_type = TREE_TYPE (f);\n+\n+  /* canonicalize_component_ref() unwidens some bit-field types (not\n+     marked as DECL_BIT_FIELD in C++), so we must do the same, lest we\n+     may introduce type mismatches.  */\n+  if (INTEGRAL_TYPE_P (field_type)\n+      && DECL_MODE (f) != TYPE_MODE (field_type))\n+    field_type = TREE_TYPE (get_unwidened (build3 (COMPONENT_REF,\n+\t\t\t\t\t\t   field_type,\n+\t\t\t\t\t\t   element,\n+\t\t\t\t\t\t   f, NULL_TREE),\n+\t\t\t\t\t   NULL_TREE));\n+\n+  return field_type;\n+}\n+\n+/* Look for adjacent fields of ELT starting at F that we'd like to\n+   scalarize as a single variable.  Return the last field of the\n+   group.  */\n+\n+static tree\n+try_instantiate_multiple_fields (struct sra_elt *elt, tree f)\n+{\n+  int count;\n+  unsigned HOST_WIDE_INT align, bit, size, alchk;\n+  enum machine_mode mode;\n+  tree first = f, prev;\n+  tree type, var;\n+  struct sra_elt *block;\n+\n+  if (!is_sra_scalar_type (TREE_TYPE (f))\n+      || !host_integerp (DECL_FIELD_OFFSET (f), 1)\n+      || !host_integerp (DECL_FIELD_BIT_OFFSET (f), 1)\n+      || !host_integerp (DECL_SIZE (f), 1)\n+      || lookup_element (elt, f, NULL, NO_INSERT))\n+    return f;\n+\n+  block = elt;\n+\n+  /* For complex and array objects, there are going to be integer\n+     literals as child elements.  In this case, we can't just take the\n+     alignment and mode of the decl, so we instead rely on the element\n+     type.\n+\n+     ??? We could try to infer additional alignment from the full\n+     object declaration and the location of the sub-elements we're\n+     accessing.  */\n+  for (count = 0; !DECL_P (block->element); count++)\n+    block = block->parent;\n+\n+  align = DECL_ALIGN (block->element);\n+  alchk = GET_MODE_BITSIZE (DECL_MODE (block->element));\n+\n+  if (count)\n+    {\n+      type = TREE_TYPE (block->element);\n+      while (count--)\n+\ttype = TREE_TYPE (type);\n+\n+      align = TYPE_ALIGN (type);\n+      alchk = GET_MODE_BITSIZE (TYPE_MODE (type));\n+    }\n+\n+  if (align < alchk)\n+    align = alchk;\n+\n+  /* Coalescing wider fields is probably pointless and\n+     inefficient.  */\n+  if (align > BITS_PER_WORD)\n+    align = BITS_PER_WORD;\n+\n+  bit = tree_low_cst (DECL_FIELD_OFFSET (f), 1) * BITS_PER_UNIT\n+    + tree_low_cst (DECL_FIELD_BIT_OFFSET (f), 1);\n+  size = tree_low_cst (DECL_SIZE (f), 1);\n+\n+  alchk = align - 1;\n+  alchk = ~alchk;\n+\n+  if ((bit & alchk) != ((bit + size - 1) & alchk))\n+    return f;\n+\n+  /* Find adjacent fields in the same alignment word.  */\n+\n+  for (prev = f, f = TREE_CHAIN (f);\n+       f && TREE_CODE (f) == FIELD_DECL\n+\t && is_sra_scalar_type (TREE_TYPE (f))\n+\t && host_integerp (DECL_FIELD_OFFSET (f), 1)\n+\t && host_integerp (DECL_FIELD_BIT_OFFSET (f), 1)\n+\t && host_integerp (DECL_SIZE (f), 1)\n+\t && !lookup_element (elt, f, NULL, NO_INSERT);\n+       prev = f, f = TREE_CHAIN (f))\n+    {\n+      unsigned HOST_WIDE_INT nbit, nsize;\n+\n+      nbit = tree_low_cst (DECL_FIELD_OFFSET (f), 1) * BITS_PER_UNIT\n+\t+ tree_low_cst (DECL_FIELD_BIT_OFFSET (f), 1);\n+      nsize = tree_low_cst (DECL_SIZE (f), 1);\n+\n+      if (bit + size == nbit)\n+\t{\n+\t  if ((bit & alchk) != ((nbit + nsize - 1) & alchk))\n+\t    {\n+\t      /* If we're at an alignment boundary, don't bother\n+\t\t growing alignment such that we can include this next\n+\t\t field.  */\n+\t      if ((nbit & alchk)\n+\t\t  || GET_MODE_BITSIZE (DECL_MODE (f)) <= align)\n+\t\tbreak;\n+\n+\t      align = GET_MODE_BITSIZE (DECL_MODE (f));\n+\t      alchk = align - 1;\n+\t      alchk = ~alchk;\n+\n+\t      if ((bit & alchk) != ((nbit + nsize - 1) & alchk))\n+\t\tbreak;\n+\t    }\n+\t  size += nsize;\n+\t}\n+      else if (nbit + nsize == bit)\n+\t{\n+\t  if ((nbit & alchk) != ((bit + size - 1) & alchk))\n+\t    {\n+\t      if ((bit & alchk)\n+\t\t  || GET_MODE_BITSIZE (DECL_MODE (f)) <= align)\n+\t\tbreak;\n+\n+\t      align = GET_MODE_BITSIZE (DECL_MODE (f));\n+\t      alchk = align - 1;\n+\t      alchk = ~alchk;\n+\n+\t      if ((nbit & alchk) != ((bit + size - 1) & alchk))\n+\t\tbreak;\n+\t    }\n+\t  bit = nbit;\n+\t  size += nsize;\n+\t}\n+      else\n+\tbreak;\n+    }\n+\n+  f = prev;\n+\n+  if (f == first)\n+    return f;\n+\n+  gcc_assert ((bit & alchk) == ((bit + size - 1) & alchk));\n+\n+  /* Try to widen the bit range so as to cover padding bits as well.  */\n+\n+  if ((bit & ~alchk) || size != align)\n+    {\n+      unsigned HOST_WIDE_INT mbit = bit & alchk;\n+      unsigned HOST_WIDE_INT msize = align;\n+\n+      for (f = TYPE_FIELDS (elt->type);\n+\t   f; f = TREE_CHAIN (f))\n+\t{\n+\t  unsigned HOST_WIDE_INT fbit, fsize;\n+\n+\t  /* Skip the fields from first to prev.  */\n+\t  if (f == first)\n+\t    {\n+\t      f = prev;\n+\t      continue;\n+\t    }\n+\n+\t  if (!(TREE_CODE (f) == FIELD_DECL\n+\t\t&& host_integerp (DECL_FIELD_OFFSET (f), 1)\n+\t\t&& host_integerp (DECL_FIELD_BIT_OFFSET (f), 1)))\n+\t    continue;\n+\n+\t  fbit = tree_low_cst (DECL_FIELD_OFFSET (f), 1) * BITS_PER_UNIT\n+\t    + tree_low_cst (DECL_FIELD_BIT_OFFSET (f), 1);\n+\n+\t  /* If we're past the selected word, we're fine.  */\n+\t  if ((bit & alchk) < (fbit & alchk))\n+\t    continue;\n+\n+\t  if (host_integerp (DECL_SIZE (f), 1))\n+\t    fsize = tree_low_cst (DECL_SIZE (f), 1);\n+\t  else\n+\t    /* Assume a variable-sized field takes up all space till\n+\t       the end of the word.  ??? Endianness issues?  */\n+\t    fsize = align - (fbit & alchk);\n+\n+\t  if ((fbit & alchk) < (bit & alchk))\n+\t    {\n+\t      /* A large field might start at a previous word and\n+\t\t extend into the selected word.  Exclude those\n+\t\t bits.  ??? Endianness issues? */\n+\t      HOST_WIDE_INT diff = fbit + fsize - mbit;\n+\n+\t      if (diff <= 0)\n+\t\tcontinue;\n+\n+\t      mbit += diff;\n+\t      msize -= diff;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Non-overlapping, great.  */\n+\t      if (fbit + fsize <= mbit\n+\t\t  || mbit + msize <= fbit)\n+\t\tcontinue;\n+\n+\t      if (fbit <= mbit)\n+\t\t{\n+\t\t  unsigned HOST_WIDE_INT diff = fbit + fsize - mbit;\n+\t\t  mbit += diff;\n+\t\t  msize -= diff;\n+\t\t}\n+\t      else if (fbit > mbit)\n+\t\tmsize -= (mbit + msize - fbit);\n+\t      else\n+\t\tgcc_unreachable ();\n+\t    }\n+\t}\n+\n+      bit = mbit;\n+      size = msize;\n+    }\n+\n+  /* Now we know the bit range we're interested in.  Find the smallest\n+     machine mode we can use to access it.  */\n+\n+  for (mode = smallest_mode_for_size (size, MODE_INT);\n+       ;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    {\n+      gcc_assert (mode != VOIDmode);\n+\n+      alchk = GET_MODE_PRECISION (mode) - 1;\n+      alchk = ~alchk;\n+\n+      if ((bit & alchk) == ((bit + size - 1) & alchk))\n+\tbreak;\n+    }\n+\n+  gcc_assert (~alchk < align);\n+\n+  /* Create the field group as a single variable.  */\n+\n+  type = lang_hooks.types.type_for_mode (mode, 1);\n+  gcc_assert (type);\n+  var = build3 (BIT_FIELD_REF, type, NULL_TREE,\n+\t\tbitsize_int (size),\n+\t\tbitsize_int (bit));\n+  BIT_FIELD_REF_UNSIGNED (var) = 1;\n+\n+  block = instantiate_missing_elements_1 (elt, var, type);\n+  gcc_assert (block && block->is_scalar);\n+\n+  var = block->replacement;\n+\n+  if ((bit & ~alchk)\n+      || (HOST_WIDE_INT)size != tree_low_cst (DECL_SIZE (var), 1))\n+    {\n+      block->replacement = build3 (BIT_FIELD_REF,\n+\t\t\t\t   TREE_TYPE (block->element), var,\n+\t\t\t\t   bitsize_int (size),\n+\t\t\t\t   bitsize_int (bit & ~alchk));\n+      BIT_FIELD_REF_UNSIGNED (block->replacement) = 1;\n+    }\n+\n+  block->in_bitfld_block = 2;\n+\n+  /* Add the member fields to the group, such that they access\n+     portions of the group variable.  */\n+\n+  for (f = first; f != TREE_CHAIN (prev); f = TREE_CHAIN (f))\n+    {\n+      tree field_type = canon_type_for_field (f, elt->element);\n+      struct sra_elt *fld = lookup_element (block, f, field_type, INSERT);\n+\n+      gcc_assert (fld && fld->is_scalar && !fld->replacement);\n+\n+      fld->replacement = build3 (BIT_FIELD_REF, field_type, var,\n+\t\t\t\t DECL_SIZE (f),\n+\t\t\t\t bitsize_int\n+\t\t\t\t ((TREE_INT_CST_LOW (DECL_FIELD_OFFSET (f))\n+\t\t\t\t   * BITS_PER_UNIT\n+\t\t\t\t   + (TREE_INT_CST_LOW\n+\t\t\t\t      (DECL_FIELD_BIT_OFFSET (f))))\n+\t\t\t\t  & ~alchk));\n+      BIT_FIELD_REF_UNSIGNED (fld->replacement) = TYPE_UNSIGNED (field_type);\n+      fld->in_bitfld_block = 1;\n+    }\n+\n+  return prev;\n }\n \n static void\n@@ -1373,21 +1739,17 @@ instantiate_missing_elements (struct sra_elt *elt)\n \tfor (f = TYPE_FIELDS (type); f ; f = TREE_CHAIN (f))\n \t  if (TREE_CODE (f) == FIELD_DECL)\n \t    {\n-\t      tree field_type = TREE_TYPE (f);\n-\n-\t      /* canonicalize_component_ref() unwidens some bit-field\n-\t\t types (not marked as DECL_BIT_FIELD in C++), so we\n-\t\t must do the same, lest we may introduce type\n-\t\t mismatches.  */\n-\t      if (INTEGRAL_TYPE_P (field_type)\n-\t\t  && DECL_MODE (f) != TYPE_MODE (field_type))\n-\t\tfield_type = TREE_TYPE (get_unwidened (build3 (COMPONENT_REF,\n-\t\t\t\t\t\t\t       field_type,\n-\t\t\t\t\t\t\t       elt->element,\n-\t\t\t\t\t\t\t       f, NULL_TREE),\n-\t\t\t\t\t\t       NULL_TREE));\n-\n-\t      instantiate_missing_elements_1 (elt, f, field_type);\n+\t      tree last = try_instantiate_multiple_fields (elt, f);\n+\n+\t      if (last != f)\n+\t\t{\n+\t\t  f = last;\n+\t\t  continue;\n+\t\t}\n+\n+\t      instantiate_missing_elements_1 (elt, f,\n+\t\t\t\t\t      canon_type_for_field\n+\t\t\t\t\t      (f, elt->element));\n \t    }\n \tbreak;\n       }\n@@ -1699,6 +2061,16 @@ generate_one_element_ref (struct sra_elt *elt, tree base)\n       {\n \ttree field = elt->element;\n \n+\t/* We can't test elt->in_bitfld_blk here because, when this is\n+\t   called from instantiate_element, we haven't set this field\n+\t   yet.  */\n+\tif (TREE_CODE (field) == BIT_FIELD_REF)\n+\t  {\n+\t    tree ret = unshare_expr (field);\n+\t    TREE_OPERAND (ret, 0) = base;\n+\t    return ret;\n+\t  }\n+\n \t/* Watch out for compatible records with differing field lists.  */\n \tif (DECL_FIELD_CONTEXT (field) != TYPE_MAIN_VARIANT (TREE_TYPE (base)))\n \t  field = find_compatible_field (TREE_TYPE (base), field);\n@@ -1735,11 +2107,180 @@ generate_element_ref (struct sra_elt *elt)\n     return elt->element;\n }\n \n+/* Return true if BF is a bit-field that we can handle like a scalar.  */\n+\n+static bool\n+scalar_bitfield_p (tree bf)\n+{\n+  return (TREE_CODE (bf) == BIT_FIELD_REF\n+\t  && (is_gimple_reg (TREE_OPERAND (bf, 0))\n+\t      || (TYPE_MODE (TREE_TYPE (TREE_OPERAND (bf, 0))) != BLKmode\n+\t\t  && (!TREE_SIDE_EFFECTS (TREE_OPERAND (bf, 0))\n+\t\t      || (GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE\n+\t\t\t\t\t\t       (TREE_OPERAND (bf, 0))))\n+\t\t\t  <= BITS_PER_WORD)))));\n+}\n+\n /* Create an assignment statement from SRC to DST.  */\n \n static tree\n sra_build_assignment (tree dst, tree src)\n {\n+  /* Turning BIT_FIELD_REFs into bit operations enables other passes\n+     to do a much better job at optimizing the code.  */\n+  if (scalar_bitfield_p (src))\n+    {\n+      tree cst, cst2, mask, minshift, maxshift;\n+      tree tmp, var, utype, stype;\n+      tree list, stmt;\n+      bool unsignedp = BIT_FIELD_REF_UNSIGNED (src);\n+\n+      var = TREE_OPERAND (src, 0);\n+      cst = TREE_OPERAND (src, 2);\n+      cst2 = size_binop (PLUS_EXPR, TREE_OPERAND (src, 1),\n+\t\t\t TREE_OPERAND (src, 2));\n+\n+      if (BITS_BIG_ENDIAN)\n+\t{\n+\t  maxshift = size_binop (MINUS_EXPR, TYPE_SIZE (TREE_TYPE (var)), cst);\n+\t  minshift = size_binop (MINUS_EXPR, TYPE_SIZE (TREE_TYPE (var)), cst2);\n+\t}\n+      else\n+\t{\n+\t  maxshift = cst2;\n+\t  minshift = cst;\n+\t}\n+\n+      stype = TREE_TYPE (var);\n+      if (!INTEGRAL_TYPE_P (stype))\n+\tstype = lang_hooks.types.type_for_size (TREE_INT_CST_LOW\n+\t\t\t\t\t\t(TYPE_SIZE (stype)), 1);\n+      else if (!TYPE_UNSIGNED (stype))\n+\tstype = unsigned_type_for (stype);\n+\n+      utype = TREE_TYPE (dst);\n+      if (!INTEGRAL_TYPE_P (utype))\n+\tutype = lang_hooks.types.type_for_size (TREE_INT_CST_LOW\n+\t\t\t\t\t\t(TYPE_SIZE (utype)), 1);\n+      else if (!TYPE_UNSIGNED (utype))\n+\tutype = unsigned_type_for (utype);\n+\n+      list = NULL;\n+\n+      cst2 = size_binop (MINUS_EXPR, maxshift, minshift);\n+      if (tree_int_cst_equal (cst2, TYPE_SIZE (utype)))\n+\t{\n+\t  unsignedp = true;\n+\t  mask = NULL_TREE;\n+\t}\n+      else\n+\t{\n+\t  mask = build_int_cst_wide (utype, 1, 0);\n+\t  cst = int_const_binop (LSHIFT_EXPR, mask, cst2, true);\n+\t  mask = int_const_binop (MINUS_EXPR, cst, mask, true);\n+\t}\n+\n+      tmp = make_rename_temp (stype, \"SR\");\n+      if (TYPE_MAIN_VARIANT (TREE_TYPE (var)) != TYPE_MAIN_VARIANT (stype))\n+\t{\n+\t  if (INTEGRAL_TYPE_P (TREE_TYPE (var)))\n+\t    stmt = build_gimple_modify_stmt (tmp,\n+\t\t\t\t\t     fold_convert (stype, var));\n+\t  else\n+\t    stmt = build_gimple_modify_stmt (tmp,\n+\t\t\t\t\t     fold_build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t\t  stype, var));\n+\t  append_to_statement_list (stmt, &list);\n+\n+\t  var = tmp;\n+\t}\n+\n+      if (!integer_zerop (minshift))\n+\t{\n+\t  tmp = make_rename_temp (stype, \"SR\");\n+\t  stmt = build_gimple_modify_stmt (tmp,\n+\t\t\t\t\t   fold_build2 (RSHIFT_EXPR, stype,\n+\t\t\t\t\t\t\tvar, minshift));\n+\t  append_to_statement_list (stmt, &list);\n+\n+\t  var = tmp;\n+\t}\n+\n+      if (TYPE_MAIN_VARIANT (utype) != TYPE_MAIN_VARIANT (stype))\n+\t{\n+\t  if (!mask && unsignedp\n+\t      && (TYPE_MAIN_VARIANT (utype)\n+\t\t  == TYPE_MAIN_VARIANT (TREE_TYPE (dst))))\n+\t    tmp = dst;\n+\t  else\n+\t    tmp = make_rename_temp (utype, \"SR\");\n+\n+\t  stmt = build_gimple_modify_stmt (tmp, fold_convert (utype, var));\n+\t  append_to_statement_list (stmt, &list);\n+\n+\t  var = tmp;\n+\t}\n+\n+      if (mask)\n+\t{\n+\t  if (!unsignedp\n+\t      || (TYPE_MAIN_VARIANT (TREE_TYPE (dst))\n+\t\t  != TYPE_MAIN_VARIANT (utype)))\n+\t    tmp = make_rename_temp (utype, \"SR\");\n+\t  else\n+\t    tmp = dst;\n+\n+\t  stmt = build_gimple_modify_stmt (tmp,\n+\t\t\t\t\t   fold_build2 (BIT_AND_EXPR, utype,\n+\t\t\t\t\t\t\tvar, mask));\n+\t  append_to_statement_list (stmt, &list);\n+\n+\t  var = tmp;\n+\t}\n+\n+      if (!unsignedp)\n+\t{\n+\t  tree signbit = int_const_binop (LSHIFT_EXPR,\n+\t\t\t\t\t  build_int_cst_wide (utype, 1, 0),\n+\t\t\t\t\t  size_binop (MINUS_EXPR, cst2,\n+\t\t\t\t\t\t      bitsize_int (1)),\n+\t\t\t\t\t  true);\n+\n+\t  tmp = make_rename_temp (utype, \"SR\");\n+\t  stmt = build_gimple_modify_stmt (tmp,\n+\t\t\t\t\t   fold_build2 (BIT_XOR_EXPR, utype,\n+\t\t\t\t\t\t\tvar, signbit));\n+\t  append_to_statement_list (stmt, &list);\n+\n+\t  var = tmp;\n+\n+\t  if (TYPE_MAIN_VARIANT (TREE_TYPE (dst)) != TYPE_MAIN_VARIANT (utype))\n+\t    tmp = make_rename_temp (utype, \"SR\");\n+\t  else\n+\t    tmp = dst;\n+\n+\t  stmt = build_gimple_modify_stmt (tmp,\n+\t\t\t\t\t   fold_build2 (MINUS_EXPR, utype,\n+\t\t\t\t\t\t\tvar, signbit));\n+\t  append_to_statement_list (stmt, &list);\n+\n+\t  var = tmp;\n+\t}\n+\n+      if (var != dst)\n+\t{\n+\t  if (INTEGRAL_TYPE_P (TREE_TYPE (dst)))\n+\t    var = fold_convert (TREE_TYPE (dst), var);\n+\t  else\n+\t    var = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (dst), var);\n+\n+\t  stmt = build_gimple_modify_stmt (dst, var);\n+\t  append_to_statement_list (stmt, &list);\n+\t}\n+\n+      return list;\n+    }\n+\n   /* It was hoped that we could perform some type sanity checking\n      here, but since front-ends can emit accesses of fields in types\n      different from their nominal types and copy structures containing\n@@ -1751,6 +2292,256 @@ sra_build_assignment (tree dst, tree src)\n   return build_gimple_modify_stmt (dst, src);\n }\n \n+/* BIT_FIELD_REFs must not be shared.  sra_build_elt_assignment()\n+   takes care of assignments, but we must create copies for uses.  */\n+#define REPLDUP(t) (TREE_CODE (t) != BIT_FIELD_REF ? (t) : unshare_expr (t))\n+\n+/* Emit an assignment from SRC to DST, but if DST is a scalarizable\n+   BIT_FIELD_REF, turn it into bit operations.  */\n+\n+static tree\n+sra_build_bf_assignment (tree dst, tree src)\n+{\n+  tree var, type, utype, tmp, tmp2, tmp3;\n+  tree list, stmt;\n+  tree cst, cst2, mask;\n+  tree minshift, maxshift;\n+\n+  if (TREE_CODE (dst) != BIT_FIELD_REF)\n+    return sra_build_assignment (dst, src);\n+\n+  var = TREE_OPERAND (dst, 0);\n+\n+  if (!scalar_bitfield_p (dst))\n+    return sra_build_assignment (REPLDUP (dst), src);\n+\n+  list = NULL;\n+\n+  cst = fold_convert (bitsizetype, TREE_OPERAND (dst, 2));\n+  cst2 = size_binop (PLUS_EXPR,\n+\t\t     fold_convert (bitsizetype, TREE_OPERAND (dst, 1)),\n+\t\t     cst);\n+\n+  if (BITS_BIG_ENDIAN)\n+    {\n+      maxshift = size_binop (MINUS_EXPR, TYPE_SIZE (TREE_TYPE (var)), cst);\n+      minshift = size_binop (MINUS_EXPR, TYPE_SIZE (TREE_TYPE (var)), cst2);\n+    }\n+  else\n+    {\n+      maxshift = cst2;\n+      minshift = cst;\n+    }\n+\n+  type = TREE_TYPE (var);\n+  if (!INTEGRAL_TYPE_P (type))\n+    type = lang_hooks.types.type_for_size\n+      (TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (var))), 1);\n+  if (TYPE_UNSIGNED (type))\n+    utype = type;\n+  else\n+    utype = unsigned_type_for (type);\n+\n+  mask = build_int_cst_wide (utype, 1, 0);\n+  cst = int_const_binop (LSHIFT_EXPR, mask, maxshift, true);\n+  cst2 = int_const_binop (LSHIFT_EXPR, mask, minshift, true);\n+  mask = int_const_binop (MINUS_EXPR, cst, cst2, true);\n+  mask = fold_build1 (BIT_NOT_EXPR, utype, mask);\n+\n+  if (TYPE_MAIN_VARIANT (utype) != TYPE_MAIN_VARIANT (TREE_TYPE (var))\n+      && !integer_zerop (mask))\n+    {\n+      tmp = var;\n+      if (!is_gimple_variable (tmp))\n+\ttmp = unshare_expr (var);\n+\n+      tmp2 = make_rename_temp (utype, \"SR\");\n+\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (var)))\n+\tstmt = build_gimple_modify_stmt (tmp2, fold_convert (utype, tmp));\n+      else\n+\tstmt = build_gimple_modify_stmt (tmp2, fold_build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t\t    utype, tmp));\n+      append_to_statement_list (stmt, &list);\n+    }\n+  else\n+    tmp2 = var;\n+\n+  if (!integer_zerop (mask))\n+    {\n+      tmp = make_rename_temp (utype, \"SR\");\n+      stmt = build_gimple_modify_stmt (tmp,\n+\t\t\t\t       fold_build2 (BIT_AND_EXPR, utype,\n+\t\t\t\t\t\t    tmp2, mask));\n+      append_to_statement_list (stmt, &list);\n+    }\n+  else\n+    tmp = mask;\n+\n+  if (is_gimple_reg (src) && INTEGRAL_TYPE_P (TREE_TYPE (src)))\n+    tmp2 = src;\n+  else if (INTEGRAL_TYPE_P (TREE_TYPE (src)))\n+    {\n+      tmp2 = make_rename_temp (TREE_TYPE (src), \"SR\");\n+      stmt = sra_build_assignment (tmp2, src);\n+      append_to_statement_list (stmt, &list);\n+    }\n+  else\n+    {\n+      tmp2 = make_rename_temp\n+\t(lang_hooks.types.type_for_size\n+\t (TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (src))),\n+\t  1), \"SR\");\n+      stmt = sra_build_assignment (tmp2, fold_build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t      TREE_TYPE (tmp2), src));\n+      append_to_statement_list (stmt, &list);\n+    }\n+\n+  if (!TYPE_UNSIGNED (TREE_TYPE (tmp2)))\n+    {\n+      tree ut = unsigned_type_for (TREE_TYPE (tmp2));\n+      tmp3 = make_rename_temp (ut, \"SR\");\n+      tmp2 = fold_convert (ut, tmp2);\n+      stmt = sra_build_assignment (tmp3, tmp2);\n+      append_to_statement_list (stmt, &list);\n+\n+      tmp2 = fold_build1 (BIT_NOT_EXPR, utype, mask);\n+      tmp2 = int_const_binop (RSHIFT_EXPR, tmp2, minshift, true);\n+      tmp2 = fold_convert (ut, tmp2);\n+      tmp2 = fold_build2 (BIT_AND_EXPR, utype, tmp3, tmp2);\n+\n+      if (tmp3 != tmp2)\n+\t{\n+\t  tmp3 = make_rename_temp (ut, \"SR\");\n+\t  stmt = sra_build_assignment (tmp3, tmp2);\n+\t  append_to_statement_list (stmt, &list);\n+\t}\n+\n+      tmp2 = tmp3;\n+    }\n+\n+  if (TYPE_MAIN_VARIANT (TREE_TYPE (tmp2)) != TYPE_MAIN_VARIANT (utype))\n+    {\n+      tmp3 = make_rename_temp (utype, \"SR\");\n+      tmp2 = fold_convert (utype, tmp2);\n+      stmt = sra_build_assignment (tmp3, tmp2);\n+      append_to_statement_list (stmt, &list);\n+      tmp2 = tmp3;\n+    }\n+\n+  if (!integer_zerop (minshift))\n+    {\n+      tmp3 = make_rename_temp (utype, \"SR\");\n+      stmt = build_gimple_modify_stmt (tmp3,\n+\t\t\t\t       fold_build2 (LSHIFT_EXPR, utype,\n+\t\t\t\t\t\t    tmp2, minshift));\n+      append_to_statement_list (stmt, &list);\n+      tmp2 = tmp3;\n+    }\n+\n+  if (utype != TREE_TYPE (var))\n+    tmp3 = make_rename_temp (utype, \"SR\");\n+  else\n+    tmp3 = var;\n+  stmt = build_gimple_modify_stmt (tmp3,\n+\t\t\t\t   fold_build2 (BIT_IOR_EXPR, utype,\n+\t\t\t\t\t\ttmp, tmp2));\n+  append_to_statement_list (stmt, &list);\n+\n+  if (tmp3 != var)\n+    {\n+      if (TREE_TYPE (var) == type)\n+\tstmt = build_gimple_modify_stmt (var,\n+\t\t\t\t\t fold_convert (type, tmp3));\n+      else\n+\tstmt = build_gimple_modify_stmt (var,\n+\t\t\t\t\t fold_build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t      TREE_TYPE (var), tmp3));\n+      append_to_statement_list (stmt, &list);\n+    }\n+\n+  return list;\n+}\n+\n+/* Expand an assignment of SRC to the scalarized representation of\n+   ELT.  If it is a field group, try to widen the assignment to cover\n+   the full variable.  */\n+\n+static tree\n+sra_build_elt_assignment (struct sra_elt *elt, tree src)\n+{\n+  tree dst = elt->replacement;\n+  tree var, tmp, cst, cst2, list, stmt;\n+\n+  if (TREE_CODE (dst) != BIT_FIELD_REF\n+      || !elt->in_bitfld_block)\n+    return sra_build_assignment (REPLDUP (dst), src);\n+\n+  var = TREE_OPERAND (dst, 0);\n+\n+  /* Try to widen the assignment to the entire variable.\n+     We need the source to be a BIT_FIELD_REF as well, such that, for\n+     BIT_FIELD_REF<d,sz,dp> = BIT_FIELD_REF<s,sz,sp>,\n+     by design, conditions are met such that we can turn it into\n+     d = BIT_FIELD_REF<s,dw,sp-dp>.  */\n+  if (elt->in_bitfld_block == 2\n+      && TREE_CODE (src) == BIT_FIELD_REF)\n+    {\n+      cst = TYPE_SIZE (TREE_TYPE (var));\n+      cst2 = size_binop (MINUS_EXPR, TREE_OPERAND (src, 2),\n+\t\t\t TREE_OPERAND (dst, 2));\n+\n+      src = TREE_OPERAND (src, 0);\n+\n+      /* Avoid full-width bit-fields.  */\n+      if (integer_zerop (cst2)\n+\t  && tree_int_cst_equal (cst, TYPE_SIZE (TREE_TYPE (src))))\n+\t{\n+\t  if (INTEGRAL_TYPE_P (TREE_TYPE (src))\n+\t      && !TYPE_UNSIGNED (TREE_TYPE (src)))\n+\t    src = fold_convert (unsigned_type_for (TREE_TYPE (src)), src);\n+\n+\t  /* If a single conversion won't do, we'll need a statement\n+\t     list.  */\n+\t  if (TYPE_MAIN_VARIANT (TREE_TYPE (var))\n+\t      != TYPE_MAIN_VARIANT (TREE_TYPE (src)))\n+\t    {\n+\t      list = NULL;\n+\n+\t      if (!INTEGRAL_TYPE_P (TREE_TYPE (src))\n+\t\t  || !TYPE_UNSIGNED (TREE_TYPE (src)))\n+\t\tsrc = fold_build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t   lang_hooks.types.type_for_size\n+\t\t\t\t   (TREE_INT_CST_LOW\n+\t\t\t\t    (TYPE_SIZE (TREE_TYPE (src))),\n+\t\t\t\t    1), src);\n+\n+\t      tmp = make_rename_temp (TREE_TYPE (src), \"SR\");\n+\t      stmt = build_gimple_modify_stmt (tmp, src);\n+\t      append_to_statement_list (stmt, &list);\n+\n+\t      stmt = sra_build_assignment (var,\n+\t\t\t\t\t   fold_convert (TREE_TYPE (var),\n+\t\t\t\t\t\t\t tmp));\n+\t      append_to_statement_list (stmt, &list);\n+\n+\t      return list;\n+\t    }\n+\n+\t  src = fold_convert (TREE_TYPE (var), src);\n+\t}\n+      else\n+\t{\n+\t  src = fold_build3 (BIT_FIELD_REF, TREE_TYPE (var), src, cst, cst2);\n+\t  BIT_FIELD_REF_UNSIGNED (src) = 1;\n+\t}\n+\n+      return sra_build_assignment (var, src);\n+    }\n+\n+  return sra_build_bf_assignment (dst, src);\n+}\n+\n /* Generate a set of assignment statements in *LIST_P to copy all\n    instantiated elements under ELT to or from the equivalent structure\n    rooted at EXPR.  COPY_OUT controls the direction of the copy, with\n@@ -1774,16 +2565,16 @@ generate_copy_inout (struct sra_elt *elt, bool copy_out, tree expr,\n       i = c->replacement;\n \n       t = build2 (COMPLEX_EXPR, elt->type, r, i);\n-      t = sra_build_assignment (expr, t);\n+      t = sra_build_bf_assignment (expr, t);\n       SSA_NAME_DEF_STMT (expr) = t;\n       append_to_statement_list (t, list_p);\n     }\n   else if (elt->replacement)\n     {\n       if (copy_out)\n-\tt = sra_build_assignment (elt->replacement, expr);\n+\tt = sra_build_elt_assignment (elt, expr);\n       else\n-\tt = sra_build_assignment (expr, elt->replacement);\n+\tt = sra_build_bf_assignment (expr, REPLDUP (elt->replacement));\n       append_to_statement_list (t, list_p);\n     }\n   else\n@@ -1808,6 +2599,19 @@ generate_element_copy (struct sra_elt *dst, struct sra_elt *src, tree *list_p)\n   FOR_EACH_ACTUAL_CHILD (dc, dst)\n     {\n       sc = lookup_element (src, dc->element, NULL, NO_INSERT);\n+      if (!sc && dc->in_bitfld_block == 2)\n+\t{\n+\t  struct sra_elt *dcs;\n+\n+\t  FOR_EACH_ACTUAL_CHILD (dcs, dc)\n+\t    {\n+\t      sc = lookup_element (src, dcs->element, NULL, NO_INSERT);\n+\t      gcc_assert (sc);\n+\t      generate_element_copy (dcs, sc, list_p);\n+\t    }\n+\n+\t  continue;\n+\t}\n       gcc_assert (sc);\n       generate_element_copy (dc, sc, list_p);\n     }\n@@ -1818,7 +2622,7 @@ generate_element_copy (struct sra_elt *dst, struct sra_elt *src, tree *list_p)\n \n       gcc_assert (src->replacement);\n \n-      t = sra_build_assignment (dst->replacement, src->replacement);\n+      t = sra_build_elt_assignment (dst, REPLDUP (src->replacement));\n       append_to_statement_list (t, list_p);\n     }\n }\n@@ -1839,8 +2643,9 @@ generate_element_zero (struct sra_elt *elt, tree *list_p)\n       return;\n     }\n \n-  FOR_EACH_ACTUAL_CHILD (c, elt)\n-    generate_element_zero (c, list_p);\n+  if (!elt->in_bitfld_block)\n+    FOR_EACH_ACTUAL_CHILD (c, elt)\n+      generate_element_zero (c, list_p);\n \n   if (elt->replacement)\n     {\n@@ -1849,7 +2654,7 @@ generate_element_zero (struct sra_elt *elt, tree *list_p)\n       gcc_assert (elt->is_scalar);\n       t = fold_convert (elt->type, integer_zero_node);\n \n-      t = sra_build_assignment (elt->replacement, t);\n+      t = sra_build_elt_assignment (elt, t);\n       append_to_statement_list (t, list_p);\n     }\n }\n@@ -1858,10 +2663,10 @@ generate_element_zero (struct sra_elt *elt, tree *list_p)\n    Add the result to *LIST_P.  */\n \n static void\n-generate_one_element_init (tree var, tree init, tree *list_p)\n+generate_one_element_init (struct sra_elt *elt, tree init, tree *list_p)\n {\n   /* The replacement can be almost arbitrarily complex.  Gimplify.  */\n-  tree stmt = sra_build_assignment (var, init);\n+  tree stmt = sra_build_elt_assignment (elt, init);\n   gimplify_and_add (stmt, list_p);\n }\n \n@@ -1890,7 +2695,7 @@ generate_element_init_1 (struct sra_elt *elt, tree init, tree *list_p)\n     {\n       if (elt->replacement)\n \t{\n-\t  generate_one_element_init (elt->replacement, init, list_p);\n+\t  generate_one_element_init (elt, init, list_p);\n \t  elt->visited = true;\n \t}\n       return result;\n@@ -2043,6 +2848,220 @@ sra_replace (block_stmt_iterator *bsi, tree list)\n     bsi_prev (bsi);\n }\n \n+/* Data structure that bitfield_overlaps_p fills in with information\n+   about the element passed in and how much of it overlaps with the\n+   bit-range passed it to.  */\n+\n+struct bitfield_overlap_info\n+{\n+  /* The bit-length of an element.  */\n+  tree field_len;\n+\n+  /* The bit-position of the element in its parent.  */\n+  tree field_pos;\n+\n+  /* The number of bits of the element that overlap with the incoming\n+     bit range.  */\n+  tree overlap_len;\n+\n+  /* The first bit of the element that overlaps with the incoming bit\n+     range.  */\n+  tree overlap_pos;\n+};\n+\n+/* Return true if a BIT_FIELD_REF<(FLD->parent), BLEN, BPOS>\n+   expression (refereced as BF below) accesses any of the bits in FLD,\n+   false if it doesn't.  If DATA is non-null, its field_len and\n+   field_pos are filled in such that BIT_FIELD_REF<(FLD->parent),\n+   field_len, field_pos> (referenced as BFLD below) represents the\n+   entire field FLD->element, and BIT_FIELD_REF<BFLD, overlap_len,\n+   overlap_pos> represents the portion of the entire field that\n+   overlaps with BF.  */\n+\n+static bool\n+bitfield_overlaps_p (tree blen, tree bpos, struct sra_elt *fld,\n+\t\t     struct bitfield_overlap_info *data)\n+{\n+  tree flen, fpos;\n+  bool ret;\n+\n+  if (TREE_CODE (fld->element) == FIELD_DECL)\n+    {\n+      flen = fold_convert (bitsizetype, DECL_SIZE (fld->element));\n+      fpos = fold_convert (bitsizetype, DECL_FIELD_OFFSET (fld->element));\n+      fpos = size_binop (MULT_EXPR, fpos, bitsize_int (BITS_PER_UNIT));\n+      fpos = size_binop (PLUS_EXPR, fpos, DECL_FIELD_BIT_OFFSET (fld->element));\n+    }\n+  else if (TREE_CODE (fld->element) == BIT_FIELD_REF)\n+    {\n+      flen = fold_convert (bitsizetype, TREE_OPERAND (fld->element, 1));\n+      fpos = fold_convert (bitsizetype, TREE_OPERAND (fld->element, 2));\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  gcc_assert (host_integerp (blen, 1)\n+\t      && host_integerp (bpos, 1)\n+\t      && host_integerp (flen, 1)\n+\t      && host_integerp (fpos, 1));\n+\n+  ret = ((!tree_int_cst_lt (fpos, bpos)\n+\t  && tree_int_cst_lt (size_binop (MINUS_EXPR, fpos, bpos),\n+\t\t\t      blen))\n+\t || (!tree_int_cst_lt (bpos, fpos)\n+\t     && tree_int_cst_lt (size_binop (MINUS_EXPR, bpos, fpos),\n+\t\t\t\t flen)));\n+\n+  if (!ret)\n+    return ret;\n+\n+  if (data)\n+    {\n+      tree bend, fend;\n+\n+      data->field_len = flen;\n+      data->field_pos = fpos;\n+\n+      fend = size_binop (PLUS_EXPR, fpos, flen);\n+      bend = size_binop (PLUS_EXPR, bpos, blen);\n+\n+      if (tree_int_cst_lt (bend, fend))\n+\tdata->overlap_len = size_binop (MINUS_EXPR, bend, fpos);\n+      else\n+\tdata->overlap_len = NULL;\n+\n+      if (tree_int_cst_lt (fpos, bpos))\n+\t{\n+\t  data->overlap_pos = size_binop (MINUS_EXPR, bpos, fpos);\n+\t  data->overlap_len = size_binop (MINUS_EXPR,\n+\t\t\t\t\t  data->overlap_len\n+\t\t\t\t\t  ? data->overlap_len\n+\t\t\t\t\t  : data->field_len,\n+\t\t\t\t\t  data->overlap_pos);\n+\t}\n+      else\n+\tdata->overlap_pos = NULL;\n+    }\n+\n+  return ret;\n+}\n+\n+/* Add to LISTP a sequence of statements that copies BLEN bits between\n+   VAR and the scalarized elements of ELT, starting a bit VPOS of VAR\n+   and at bit BPOS of ELT.  The direction of the copy is given by\n+   TO_VAR.  */\n+\n+static void\n+sra_explode_bitfield_assignment (tree var, tree vpos, bool to_var,\n+\t\t\t\t tree *listp, tree blen, tree bpos,\n+\t\t\t\t struct sra_elt *elt)\n+{\n+  struct sra_elt *fld;\n+  struct bitfield_overlap_info flp;\n+\n+  FOR_EACH_ACTUAL_CHILD (fld, elt)\n+    {\n+      tree flen, fpos;\n+\n+      if (!bitfield_overlaps_p (blen, bpos, fld, &flp))\n+\tcontinue;\n+\n+      flen = flp.overlap_len ? flp.overlap_len : flp.field_len;\n+      fpos = flp.overlap_pos ? flp.overlap_pos : bitsize_int (0);\n+\n+      if (fld->replacement)\n+\t{\n+\t  tree infld, invar, st;\n+\n+\t  infld = fld->replacement;\n+\n+\t  if (TREE_CODE (infld) == BIT_FIELD_REF)\n+\t    {\n+\t      fpos = size_binop (PLUS_EXPR, fpos, TREE_OPERAND (infld, 2));\n+\t      infld = TREE_OPERAND (infld, 0);\n+\t    }\n+\t  else if (BITS_BIG_ENDIAN && DECL_P (fld->element)\n+\t\t   && !tree_int_cst_equal (TYPE_SIZE (TREE_TYPE (infld)),\n+\t\t\t\t\t   DECL_SIZE (fld->element)))\n+\t    {\n+\t      fpos = size_binop (PLUS_EXPR, fpos,\n+\t\t\t\t TYPE_SIZE (TREE_TYPE (infld)));\n+\t      fpos = size_binop (MINUS_EXPR, fpos,\n+\t\t\t\t DECL_SIZE (fld->element));\n+\t    }\n+\n+\t  infld = fold_build3 (BIT_FIELD_REF,\n+\t\t\t       lang_hooks.types.type_for_size\n+\t\t\t       (TREE_INT_CST_LOW (flen), 1),\n+\t\t\t       infld, flen, fpos);\n+\t  BIT_FIELD_REF_UNSIGNED (infld) = 1;\n+\n+\t  invar = size_binop (MINUS_EXPR, flp.field_pos, bpos);\n+\t  if (flp.overlap_pos)\n+\t    invar = size_binop (PLUS_EXPR, invar, flp.overlap_pos);\n+\t  invar = size_binop (PLUS_EXPR, invar, vpos);\n+\n+\t  invar = fold_build3 (BIT_FIELD_REF, TREE_TYPE (infld),\n+\t\t\t       var, flen, invar);\n+\t  BIT_FIELD_REF_UNSIGNED (invar) = 1;\n+\n+\t  if (to_var)\n+\t    st = sra_build_bf_assignment (invar, infld);\n+\t  else\n+\t    st = sra_build_bf_assignment (infld, invar);\n+\n+\t  append_to_statement_list (st, listp);\n+\t}\n+      else\n+\t{\n+\t  tree sub = size_binop (MINUS_EXPR, flp.field_pos, bpos);\n+\t  sub = size_binop (PLUS_EXPR, vpos, sub);\n+\t  if (flp.overlap_pos)\n+\t    sub = size_binop (PLUS_EXPR, sub, flp.overlap_pos);\n+\n+\t  sra_explode_bitfield_assignment (var, sub, to_var, listp,\n+\t\t\t\t\t   flen, fpos, fld);\n+\t}\n+    }\n+}\n+\n+/* Add to LISTBEFOREP statements that copy scalarized members of ELT\n+   that overlap with BIT_FIELD_REF<(ELT->element), BLEN, BPOS> back\n+   into the full variable, and to LISTAFTERP, if non-NULL, statements\n+   that copy the (presumably modified) overlapping portions of the\n+   full variable back to the scalarized variables.  */\n+\n+static void\n+sra_sync_for_bitfield_assignment (tree *listbeforep, tree *listafterp,\n+\t\t\t\t  tree blen, tree bpos,\n+\t\t\t\t  struct sra_elt *elt)\n+{\n+  struct sra_elt *fld;\n+  struct bitfield_overlap_info flp;\n+\n+  FOR_EACH_ACTUAL_CHILD (fld, elt)\n+    if (bitfield_overlaps_p (blen, bpos, fld, &flp))\n+      {\n+\tif (fld->replacement || (!flp.overlap_len && !flp.overlap_pos))\n+\t  {\n+\t    generate_copy_inout (fld, false, generate_element_ref (fld),\n+\t\t\t\t listbeforep);\n+\t    mark_no_warning (fld);\n+\t    if (listafterp)\n+\t      generate_copy_inout (fld, true, generate_element_ref (fld),\n+\t\t\t\t   listafterp);\n+\t  }\n+\telse\n+\t  {\n+\t    tree flen = flp.overlap_len ? flp.overlap_len : flp.field_len;\n+\t    tree fpos = flp.overlap_pos ? flp.overlap_pos : bitsize_int (0);\n+\n+\t    sra_sync_for_bitfield_assignment (listbeforep, listafterp,\n+\t\t\t\t\t      flen, fpos, fld);\n+\t  }\n+      }\n+}\n+\n /* Scalarize a USE.  To recap, this is either a simple reference to ELT,\n    if elt is scalar, or some occurrence of ELT that requires a complete\n    aggregate.  IS_OUTPUT is true if ELT is being modified.  */\n@@ -2051,23 +3070,162 @@ static void\n scalarize_use (struct sra_elt *elt, tree *expr_p, block_stmt_iterator *bsi,\n \t       bool is_output, bool use_all)\n {\n-  tree list = NULL, stmt = bsi_stmt (*bsi);\n+  tree stmt = bsi_stmt (*bsi);\n+  tree bfexpr;\n \n   if (elt->replacement)\n     {\n+      tree replacement = elt->replacement;\n+\n       /* If we have a replacement, then updating the reference is as\n \t simple as modifying the existing statement in place.  */\n+      if (is_output\n+\t  && TREE_CODE (elt->replacement) == BIT_FIELD_REF\n+\t  && is_gimple_reg (TREE_OPERAND (elt->replacement, 0))\n+\t  && TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t  && &GIMPLE_STMT_OPERAND (stmt, 0) == expr_p)\n+\t{\n+\t  tree newstmt = sra_build_elt_assignment\n+\t    (elt, GIMPLE_STMT_OPERAND (stmt, 1));\n+\t  if (TREE_CODE (newstmt) != STATEMENT_LIST)\n+\t    {\n+\t      tree list = NULL;\n+\t      append_to_statement_list (newstmt, &list);\n+\t      newstmt = list;\n+\t    }\n+\t  sra_replace (bsi, newstmt);\n+\t  return;\n+\t}\n+      else if (!is_output\n+\t       && TREE_CODE (elt->replacement) == BIT_FIELD_REF\n+\t       && TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t       && &GIMPLE_STMT_OPERAND (stmt, 1) == expr_p)\n+\t{\n+\t  tree tmp = make_rename_temp\n+\t    (TREE_TYPE (GIMPLE_STMT_OPERAND (stmt, 0)), \"SR\");\n+\t  tree newstmt = sra_build_assignment (tmp, REPLDUP (elt->replacement));\n+\n+\t  if (TREE_CODE (newstmt) != STATEMENT_LIST)\n+\t    {\n+\t      tree list = NULL;\n+\t      append_to_statement_list (newstmt, &list);\n+\t      newstmt = list;\n+\t    }\n+\t  sra_insert_before (bsi, newstmt);\n+\t  replacement = tmp;\n+\t}\n       if (is_output)\n-\tmark_all_v_defs (stmt);\n-      *expr_p = elt->replacement;\n+\t  mark_all_v_defs (stmt);\n+      *expr_p = REPLDUP (replacement);\n       update_stmt (stmt);\n     }\n+  else if (use_all && is_output\n+\t   && TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t   && TREE_CODE (bfexpr\n+\t\t\t = GIMPLE_STMT_OPERAND (stmt, 0)) == BIT_FIELD_REF\n+\t   && &TREE_OPERAND (bfexpr, 0) == expr_p\n+\t   && INTEGRAL_TYPE_P (TREE_TYPE (bfexpr))\n+\t   && TREE_CODE (TREE_TYPE (*expr_p)) == RECORD_TYPE)\n+    {\n+      tree listbefore = NULL, listafter = NULL;\n+      tree blen = fold_convert (bitsizetype, TREE_OPERAND (bfexpr, 1));\n+      tree bpos = fold_convert (bitsizetype, TREE_OPERAND (bfexpr, 2));\n+      bool update = false;\n+\n+      if (!elt->use_block_copy)\n+\t{\n+\t  tree type = TREE_TYPE (bfexpr);\n+\t  tree var = make_rename_temp (type, \"SR\"), tmp, st;\n+\n+\t  GIMPLE_STMT_OPERAND (stmt, 0) = var;\n+\t  update = true;\n+\n+\t  if (!TYPE_UNSIGNED (type))\n+\t    {\n+\t      type = unsigned_type_for (type);\n+\t      tmp = make_rename_temp (type, \"SR\");\n+\t      st = build_gimple_modify_stmt (tmp,\n+\t\t\t\t\t     fold_convert (type, var));\n+\t      append_to_statement_list (st, &listafter);\n+\t      var = tmp;\n+\t    }\n+\n+\t  sra_explode_bitfield_assignment\n+\t    (var, bitsize_int (0), false, &listafter, blen, bpos, elt);\n+\t}\n+      else\n+\tsra_sync_for_bitfield_assignment\n+\t  (&listbefore, &listafter, blen, bpos, elt);\n+\n+      if (listbefore)\n+\t{\n+\t  mark_all_v_defs (listbefore);\n+\t  sra_insert_before (bsi, listbefore);\n+\t}\n+      if (listafter)\n+\t{\n+\t  mark_all_v_defs (listafter);\n+\t  sra_insert_after (bsi, listafter);\n+\t}\n+\n+      if (update)\n+\tupdate_stmt (stmt);\n+    }\n+  else if (use_all && !is_output\n+\t   && TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t   && TREE_CODE (bfexpr\n+\t\t\t = GIMPLE_STMT_OPERAND (stmt, 1)) == BIT_FIELD_REF\n+\t   && &TREE_OPERAND (GIMPLE_STMT_OPERAND (stmt, 1), 0) == expr_p\n+\t   && INTEGRAL_TYPE_P (TREE_TYPE (bfexpr))\n+\t   && TREE_CODE (TREE_TYPE (*expr_p)) == RECORD_TYPE)\n+    {\n+      tree list = NULL;\n+      tree blen = fold_convert (bitsizetype, TREE_OPERAND (bfexpr, 1));\n+      tree bpos = fold_convert (bitsizetype, TREE_OPERAND (bfexpr, 2));\n+      bool update = false;\n+\n+      if (!elt->use_block_copy)\n+\t{\n+\t  tree type = TREE_TYPE (bfexpr);\n+\t  tree var;\n+\n+\t  if (!TYPE_UNSIGNED (type))\n+\t    type = unsigned_type_for (type);\n+\n+\t  var = make_rename_temp (type, \"SR\");\n+\n+\t  append_to_statement_list (build_gimple_modify_stmt\n+\t\t\t\t    (var, build_int_cst_wide (type, 0, 0)),\n+\t\t\t\t    &list);\n+\n+\t  sra_explode_bitfield_assignment\n+\t    (var, bitsize_int (0), true, &list, blen, bpos, elt);\n+\n+\t  GIMPLE_STMT_OPERAND (stmt, 1) = var;\n+\t  update = true;\n+\t}\n+      else\n+\tsra_sync_for_bitfield_assignment\n+\t  (&list, NULL, blen, bpos, elt);\n+\n+      if (list)\n+\t{\n+\t  mark_all_v_defs (list);\n+\t  sra_insert_before (bsi, list);\n+\t}\n+\n+      if (update)\n+\tupdate_stmt (stmt);\n+    }\n   else\n     {\n-      /* Otherwise we need some copies.  If ELT is being read, then we want\n-\t to store all (modified) sub-elements back into the structure before\n-\t the reference takes place.  If ELT is being written, then we want to\n-\t load the changed values back into our shadow variables.  */\n+      tree list = NULL;\n+\n+      /* Otherwise we need some copies.  If ELT is being read, then we\n+\t want to store all (modified) sub-elements back into the\n+\t structure before the reference takes place.  If ELT is being\n+\t written, then we want to load the changed values back into\n+\t our shadow variables.  */\n       /* ??? We don't check modified for reads, we just always write all of\n \t the values.  We should be able to record the SSA number of the VOP\n \t for which the values were last read.  If that number matches the\n@@ -2111,7 +3269,7 @@ scalarize_copy (struct sra_elt *lhs_elt, struct sra_elt *rhs_elt,\n       gcc_assert (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT);\n \n       GIMPLE_STMT_OPERAND (stmt, 0) = lhs_elt->replacement;\n-      GIMPLE_STMT_OPERAND (stmt, 1) = rhs_elt->replacement;\n+      GIMPLE_STMT_OPERAND (stmt, 1) = REPLDUP (rhs_elt->replacement);\n       update_stmt (stmt);\n     }\n   else if (lhs_elt->use_block_copy || rhs_elt->use_block_copy)\n@@ -2265,20 +3423,41 @@ scalarize_ldst (struct sra_elt *elt, tree other,\n \n       mark_all_v_defs (stmt);\n       generate_copy_inout (elt, is_output, other, &list);\n-      mark_all_v_defs (list);\n       gcc_assert (list);\n+      mark_all_v_defs (list);\n \n       /* Preserve EH semantics.  */\n       if (stmt_ends_bb_p (stmt))\n \t{\n \t  tree_stmt_iterator tsi;\n-\t  tree first;\n-\n-\t  /* Extract the first statement from LIST.  */\n+\t  tree first, blist = NULL;\n+\t  bool thr = (bsi->bb->flags & EDGE_COMPLEX) != 0;\n+\n+\t  /* If the last statement of this BB created an EH edge\n+\t     before scalarization, we have to locate the first\n+\t     statement that can throw in the new statement list and\n+\t     use that as the last statement of this BB, such that EH\n+\t     semantics is preserved.  All statements up to this one\n+\t     are added to the same BB.  All other statements in the\n+\t     list will be added to normal outgoing edges of the same\n+\t     BB.  If they access any memory, it's the same memory, so\n+\t     we can assume they won't throw.  */\n \t  tsi = tsi_start (list);\n-\t  first = tsi_stmt (tsi);\n+\t  for (first = tsi_stmt (tsi);\n+\t       thr && !tsi_end_p (tsi) && !tree_could_throw_p (first);\n+\t       first = tsi_stmt (tsi))\n+\t    {\n+\t      tsi_delink (&tsi);\n+\t      append_to_statement_list (first, &blist);\n+\t    }\n+\n+\t  /* Extract the first remaining statement from LIST, this is\n+\t     the EH statement if there is one.  */\n \t  tsi_delink (&tsi);\n \n+\t  if (blist)\n+\t    sra_insert_before (bsi, blist);\n+\n \t  /* Replace the old statement with this new representative.  */\n \t  bsi_replace (bsi, first, true);\n \n@@ -2362,6 +3541,10 @@ dump_sra_elt_name (FILE *f, struct sra_elt *elt)\n \t    fputc ('.', f);\n \t  print_generic_expr (f, elt->element, dump_flags);\n \t}\n+      else if (TREE_CODE (elt->element) == BIT_FIELD_REF)\n+\tfprintf (f, \"$B\" HOST_WIDE_INT_PRINT_DEC \"F\" HOST_WIDE_INT_PRINT_DEC,\n+\t\t tree_low_cst (TREE_OPERAND (elt->element, 2), 1),\n+\t\t tree_low_cst (TREE_OPERAND (elt->element, 1), 1));\n       else if (TREE_CODE (elt->element) == RANGE_EXPR)\n \tfprintf (f, \"[\"HOST_WIDE_INT_PRINT_DEC\"..\"HOST_WIDE_INT_PRINT_DEC\"]\",\n \t\t TREE_INT_CST_LOW (TREE_OPERAND (elt->element, 0)),"}]}