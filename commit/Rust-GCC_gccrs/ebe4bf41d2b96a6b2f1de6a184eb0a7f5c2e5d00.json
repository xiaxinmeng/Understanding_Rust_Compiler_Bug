{"sha": "ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJlNGJmNDFkMmI5NmE2YjJmMWRlNmExODRlYjBhN2Y1YzJlNWQwMA==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2018-02-09T05:46:18Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-02-09T05:46:18Z"}, "message": "re PR c++/83659 (ICE on compilable C++ code: in tree_to_shwi, at tree.c:6821)\n\n\tPR c++/83659\n\t* fold-const.c (fold_indirect_ref_1): Use VECTOR_TYPE_P macro.\n\tFormatting fixes.  Verify first that tree_fits_poly_int64_p (op01).\n\tSync some changes from cxx_fold_indirect_ref.\n\n\t* constexpr.c (cxx_fold_indirect_ref): Sync some changes from\n\tfold_indirect_ref_1, including poly_*int64.  Verify first that\n\ttree_fits_poly_int64_p (op01).  Formatting fixes.\n\n\t* g++.dg/torture/pr83659.C: New test.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r257512", "tree": {"sha": "b8a9d8946a8bf5dbff8138544a0e796605787045", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8a9d8946a8bf5dbff8138544a0e796605787045"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5800666390320080558b2766738c21e82bf570e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5800666390320080558b2766738c21e82bf570e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5800666390320080558b2766738c21e82bf570e7"}], "stats": {"total": 118, "additions": 90, "deletions": 28}, "files": [{"sha": "d9c544387fc4d0b3ea30f2f2f6359a7e1bf3c2f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00", "patch": "@@ -1,3 +1,11 @@\n+2018-02-09  Marek Polacek  <polacek@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/83659\n+\t* fold-const.c (fold_indirect_ref_1): Use VECTOR_TYPE_P macro.\n+\tFormatting fixes.  Verify first that tree_fits_poly_int64_p (op01).\n+\tSync some changes from cxx_fold_indirect_ref.\n+\n 2018-02-09  Alexandre Oliva <aoliva@redhat.com>\n \n \t* cfgexpand.c (expand_gimple_basic_block): Handle inline entry"}, {"sha": "ac53a74d35f9fd4e3651bf59fcc0f93ceb624e7c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00", "patch": "@@ -1,3 +1,11 @@\n+2018-02-09  Marek Polacek  <polacek@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/83659\n+\t* constexpr.c (cxx_fold_indirect_ref): Sync some changes from\n+\tfold_indirect_ref_1, including poly_*int64.  Verify first that\n+\ttree_fits_poly_int64_p (op01).  Formatting fixes.\n+\n 2018-02-08  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* constexpr.c (cxx_eval_component_reference): Use INDIRECT_REF_P."}, {"sha": "729244127067186b93fddab856c0b0731d2263b3", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00", "patch": "@@ -3025,9 +3025,10 @@ cxx_eval_vec_init (const constexpr_ctx *ctx, tree t,\n static tree\n cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n {\n-  tree sub, subtype;\n+  tree sub = op0;\n+  tree subtype;\n+  poly_uint64 const_op01;\n \n-  sub = op0;\n   STRIP_NOPS (sub);\n   subtype = TREE_TYPE (sub);\n   if (!POINTER_TYPE_P (subtype))\n@@ -3082,7 +3083,8 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n \t{\n \t  tree part_width = TYPE_SIZE (type);\n \t  tree index = bitsize_int (0);\n-\t  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width, index);\n+\t  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width,\n+\t\t\t\t  index);\n \t}\n       /* Also handle conversion to an empty base class, which\n \t is represented with a NOP_EXPR.  */\n@@ -3107,7 +3109,7 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n \t}\n     }\n   else if (TREE_CODE (sub) == POINTER_PLUS_EXPR\n-\t   && TREE_CODE (TREE_OPERAND (sub, 1)) == INTEGER_CST)\n+\t   && poly_int_tree_p (TREE_OPERAND (sub, 1), &const_op01))\n     {\n       tree op00 = TREE_OPERAND (sub, 0);\n       tree op01 = TREE_OPERAND (sub, 1);\n@@ -3121,29 +3123,37 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n \n \t  /* ((foo*)&vectorfoo)[1] => BIT_FIELD_REF<vectorfoo,...> */\n \t  if (VECTOR_TYPE_P (op00type)\n-\t      && (same_type_ignoring_top_level_qualifiers_p\n-\t\t  (type, TREE_TYPE (op00type))))\n+\t      && same_type_ignoring_top_level_qualifiers_p\n+\t\t\t\t\t\t(type, TREE_TYPE (op00type))\n+\t      /* POINTER_PLUS_EXPR second operand is sizetype, unsigned,\n+\t\t but we want to treat offsets with MSB set as negative.\n+\t\t For the code below negative offsets are invalid and\n+\t\t TYPE_SIZE of the element is something unsigned, so\n+\t\t check whether op01 fits into poly_int64, which implies\n+\t\t it is from 0 to INTTYPE_MAXIMUM (HOST_WIDE_INT), and\n+\t\t then just use poly_uint64 because we want to treat the\n+\t\t value as unsigned.  */\n+\t      && tree_fits_poly_int64_p (op01))\n \t    {\n-\t      HOST_WIDE_INT offset = tree_to_shwi (op01);\n \t      tree part_width = TYPE_SIZE (type);\n-\t      unsigned HOST_WIDE_INT part_widthi = tree_to_shwi (part_width)/BITS_PER_UNIT;\n-\t      unsigned HOST_WIDE_INT indexi = offset * BITS_PER_UNIT;\n-\t      tree index = bitsize_int (indexi);\n-\n-\t      if (known_lt (offset / part_widthi,\n-\t\t\t    TYPE_VECTOR_SUBPARTS (op00type)))\n-\t\treturn fold_build3_loc (loc,\n-\t\t\t\t\tBIT_FIELD_REF, type, op00,\n-\t\t\t\t\tpart_width, index);\n-\n+\t      poly_uint64 max_offset\n+\t\t= (tree_to_uhwi (part_width) / BITS_PER_UNIT\n+\t\t   * TYPE_VECTOR_SUBPARTS (op00type));\n+\t      if (known_lt (const_op01, max_offset))\n+\t\t{\n+\t\t  tree index = bitsize_int (const_op01 * BITS_PER_UNIT);\n+\t\t  return fold_build3_loc (loc,\n+\t\t\t\t\t  BIT_FIELD_REF, type, op00,\n+\t\t\t\t\t  part_width, index);\n+\t\t}\n \t    }\n \t  /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */\n \t  else if (TREE_CODE (op00type) == COMPLEX_TYPE\n \t\t   && (same_type_ignoring_top_level_qualifiers_p\n \t\t       (type, TREE_TYPE (op00type))))\n \t    {\n-\t      tree size = TYPE_SIZE_UNIT (type);\n-\t      if (tree_int_cst_equal (size, op01))\n+\t      if (known_eq (wi::to_poly_offset (TYPE_SIZE_UNIT (type)),\n+\t\t\t    const_op01))\n \t\treturn fold_build1_loc (loc, IMAGPART_EXPR, type, op00);\n \t    }\n \t  /* ((foo *)&fooarray)[1] => fooarray[1] */\n@@ -3198,7 +3208,8 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n     {\n       tree type_domain;\n       tree min_val = size_zero_node;\n-      tree newsub = cxx_fold_indirect_ref (loc, TREE_TYPE (subtype), sub, NULL);\n+      tree newsub\n+\t= cxx_fold_indirect_ref (loc, TREE_TYPE (subtype), sub, NULL);\n       if (newsub)\n \tsub = newsub;\n       else"}, {"sha": "87d00a57476beaa905acf36523b764a960a69201", "filename": "gcc/fold-const.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00", "patch": "@@ -14115,6 +14115,7 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)\n     {\n       tree op = TREE_OPERAND (sub, 0);\n       tree optype = TREE_TYPE (op);\n+\n       /* *&CONST_DECL -> to the value of the const decl.  */\n       if (TREE_CODE (op) == CONST_DECL)\n \treturn DECL_INITIAL (op);\n@@ -14148,12 +14149,13 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)\n \t       && type == TREE_TYPE (optype))\n \treturn fold_build1_loc (loc, REALPART_EXPR, type, op);\n       /* *(foo *)&vectorfoo => BIT_FIELD_REF<vectorfoo,...> */\n-      else if (TREE_CODE (optype) == VECTOR_TYPE\n+      else if (VECTOR_TYPE_P (optype)\n \t       && type == TREE_TYPE (optype))\n \t{\n \t  tree part_width = TYPE_SIZE (type);\n \t  tree index = bitsize_int (0);\n-\t  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width, index);\n+\t  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width,\n+\t\t\t\t  index);\n \t}\n     }\n \n@@ -14171,8 +14173,17 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)\n \t  op00type = TREE_TYPE (op00);\n \n \t  /* ((foo*)&vectorfoo)[1] => BIT_FIELD_REF<vectorfoo,...> */\n-\t  if (TREE_CODE (op00type) == VECTOR_TYPE\n-\t      && type == TREE_TYPE (op00type))\n+\t  if (VECTOR_TYPE_P (op00type)\n+\t      && type == TREE_TYPE (op00type)\n+\t      /* POINTER_PLUS_EXPR second operand is sizetype, unsigned,\n+\t\t but we want to treat offsets with MSB set as negative.\n+\t\t For the code below negative offsets are invalid and\n+\t\t TYPE_SIZE of the element is something unsigned, so\n+\t\t check whether op01 fits into poly_int64, which implies\n+\t\t it is from 0 to INTTYPE_MAXIMUM (HOST_WIDE_INT), and\n+\t\t then just use poly_uint64 because we want to treat the\n+\t\t value as unsigned.  */\n+\t      && tree_fits_poly_int64_p (op01))\n \t    {\n \t      tree part_width = TYPE_SIZE (type);\n \t      poly_uint64 max_offset\n@@ -14199,16 +14210,16 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)\n \t\t   && type == TREE_TYPE (op00type))\n \t    {\n \t      tree type_domain = TYPE_DOMAIN (op00type);\n-\t      tree min = size_zero_node;\n+\t      tree min_val = size_zero_node;\n \t      if (type_domain && TYPE_MIN_VALUE (type_domain))\n-\t\tmin = TYPE_MIN_VALUE (type_domain);\n+\t\tmin_val = TYPE_MIN_VALUE (type_domain);\n \t      offset_int off = wi::to_offset (op01);\n \t      offset_int el_sz = wi::to_offset (TYPE_SIZE_UNIT (type));\n \t      offset_int remainder;\n \t      off = wi::divmod_trunc (off, el_sz, SIGNED, &remainder);\n-\t      if (remainder == 0 && TREE_CODE (min) == INTEGER_CST)\n+\t      if (remainder == 0 && TREE_CODE (min_val) == INTEGER_CST)\n \t\t{\n-\t\t  off = off + wi::to_offset (min);\n+\t\t  off = off + wi::to_offset (min_val);\n \t\t  op01 = wide_int_to_tree (sizetype, off);\n \t\t  return build4_loc (loc, ARRAY_REF, type, op00, op01,\n \t\t\t\t     NULL_TREE, NULL_TREE);"}, {"sha": "49a2275c73293d95e786859795979018d087cdf7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00", "patch": "@@ -1,3 +1,9 @@\n+2018-02-09  Marek Polacek  <polacek@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/83659\n+\t* g++.dg/torture/pr83659.C: New test.\n+\n 2018-02-08  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR tree-optimization/84136"}, {"sha": "bdcdca230ecc4e399bac22e07b0c447fa6b83862", "filename": "gcc/testsuite/g++.dg/torture/pr83659.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr83659.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr83659.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr83659.C?ref=ebe4bf41d2b96a6b2f1de6a184eb0a7f5c2e5d00", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/83659\n+// { dg-do compile }\n+\n+typedef int V __attribute__ ((__vector_size__ (16)));\n+V a;\n+V b[2];\n+\n+int\n+foo ()\n+{\n+  return reinterpret_cast <int *> (&a)[-1] += 1;\n+}\n+\n+int\n+bar ()\n+{\n+  return reinterpret_cast <int *> (&a[1])[-1];\n+}"}]}