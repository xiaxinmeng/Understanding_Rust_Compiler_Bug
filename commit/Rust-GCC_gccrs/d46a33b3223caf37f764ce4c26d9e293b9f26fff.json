{"sha": "d46a33b3223caf37f764ce4c26d9e293b9f26fff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ2YTMzYjMyMjNjYWYzN2Y3NjRjZTRjMjZkOWUyOTNiOWYyNmZmZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2002-01-02T11:37:00Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2002-01-02T11:37:00Z"}, "message": "re PR c++/775 (2.97 error declaring nested class a friend)\n\ncp:\n\tPR c++/775\n\t* cp-tree.h (handle_class_head): Adjust prototype.\n\t* decl2.c (handle_class_head): Add DEFN_P and NEW_TYPE_P\n\tparameters. Use for all class heads.\n\t* parse.y (named_class_head_sans_basetype, named_class_head,\n\tnamed_complex_class_head_sans_basetype,\n\tnamed_class_head_sans_basetype_defn,\n\tunnamed_class_head): Remove.\n\t(class_head, class_head_apparent_template): Recognize class heads\n\t(class_head_decl, class_head_defn): New reductions. Process class\n\theads.\n\t(structsp): Adjust class definition and class declaration\n\treductions.\n\t(maybe_base_class_list): Give diagnostic on empty list.\ntestsuite:\n\t* g++.dg/template/friend2.C: New test.\n\t* g++.old-deja/g++/brendan/crash8.C: Adjust location of error.\n\nFrom-SVN: r48466", "tree": {"sha": "d70dbbf96d384cc554f4062e493f143a44a5e130", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d70dbbf96d384cc554f4062e493f143a44a5e130"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d46a33b3223caf37f764ce4c26d9e293b9f26fff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d46a33b3223caf37f764ce4c26d9e293b9f26fff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d46a33b3223caf37f764ce4c26d9e293b9f26fff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d46a33b3223caf37f764ce4c26d9e293b9f26fff/comments", "author": null, "committer": null, "parents": [{"sha": "4542128ef1545dc28cf4e3a2e4232f6058267c1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4542128ef1545dc28cf4e3a2e4232f6058267c1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4542128ef1545dc28cf4e3a2e4232f6058267c1c"}], "stats": {"total": 419, "additions": 234, "deletions": 185}, "files": [{"sha": "3f05cb74a4255c0cc0ff9b04386890ee15af9546", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d46a33b3223caf37f764ce4c26d9e293b9f26fff/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d46a33b3223caf37f764ce4c26d9e293b9f26fff/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d46a33b3223caf37f764ce4c26d9e293b9f26fff", "patch": "@@ -1,3 +1,20 @@\n+2002-01-02  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/775\n+\t* cp-tree.h (handle_class_head): Adjust prototype.\n+\t* decl2.c (handle_class_head): Add DEFN_P and NEW_TYPE_P\n+\tparameters. Use for all class heads.\n+\t* parse.y (named_class_head_sans_basetype, named_class_head,\n+\tnamed_complex_class_head_sans_basetype,\n+\tnamed_class_head_sans_basetype_defn,\n+\tunnamed_class_head): Remove.\n+\t(class_head, class_head_apparent_template): Recognize class heads\n+\t(class_head_decl, class_head_defn): New reductions. Process class\n+\theads.\n+\t(structsp): Adjust class definition and class declaration\n+\treductions.\n+\t(maybe_base_class_list): Give diagnostic on empty list.\n+\n 2002-01-02  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/4379"}, {"sha": "45b8fbfed40819f781e6649cb370c1d762fcc27e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d46a33b3223caf37f764ce4c26d9e293b9f26fff/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d46a33b3223caf37f764ce4c26d9e293b9f26fff/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d46a33b3223caf37f764ce4c26d9e293b9f26fff", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for C++ parsing and type checking.\n    Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001 Free Software Foundation, Inc.\n+   2000, 2001, 2002 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -3769,7 +3769,7 @@ extern tree do_class_using_decl\t\t\tPARAMS ((tree));\n extern void do_using_directive\t\t\tPARAMS ((tree));\n extern void check_default_args\t\t\tPARAMS ((tree));\n extern void mark_used\t\t\t\tPARAMS ((tree));\n-extern tree handle_class_head\t\t\tPARAMS ((tree, tree, tree));\n+extern tree handle_class_head\t\t\tPARAMS ((tree, tree, tree, int, int *));\n extern tree lookup_arg_dependent                PARAMS ((tree, tree, tree));\n extern void finish_static_data_member_decl      PARAMS ((tree, tree, tree, int));\n extern tree build_artificial_parm               PARAMS ((tree, tree));"}, {"sha": "3ff1ccc622856156e53a1417b395eb5a5993e1ae", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 72, "deletions": 52, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d46a33b3223caf37f764ce4c26d9e293b9f26fff/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d46a33b3223caf37f764ce4c26d9e293b9f26fff/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d46a33b3223caf37f764ce4c26d9e293b9f26fff", "patch": "@@ -5162,70 +5162,90 @@ mark_used (decl)\n     instantiate_decl (decl, /*defer_ok=*/1);\n }\n \n-/* Helper function for named_class_head_sans_basetype nonterminal.  We\n-   have just seen something of the form `AGGR SCOPE::ID'.  Return a\n-   TYPE_DECL for the type declared by ID in SCOPE.  */\n+/* Helper function for class_head_decl and class_head_defn\n+   nonterminals. AGGR is the class, union or struct tag. SCOPE is the\n+   explicit scope used (NULL for no scope resolution). ID is the\n+   name. DEFN_P is true, if this is a definition of the class and\n+   NEW_TYPE_P is set to non-zero, if we push into the scope containing\n+   the to be defined aggregate.\n+   \n+   Return a TYPE_DECL for the type declared by ID in SCOPE.  */\n \n tree\n-handle_class_head (aggr, scope, id)\n+handle_class_head (aggr, scope, id, defn_p, new_type_p)\n      tree aggr, scope, id;\n+     int defn_p;\n+     int *new_type_p;\n {\n   tree decl = NULL_TREE;\n-\n-  if (TREE_CODE (id) == TYPE_DECL)\n-    /* We must bash typedefs back to the main decl of the type. Otherwise\n-       we become confused about scopes.  */\n-    decl = TYPE_MAIN_DECL (TREE_TYPE (id));\n-  else if (DECL_CLASS_TEMPLATE_P (id))\n-    decl = DECL_TEMPLATE_RESULT (id);\n-  else \n-    {\n-      tree current = current_scope ();\n+  tree current = current_scope ();\n+  bool xrefd_p = false;\n   \n-      if (current == NULL_TREE)\n-        current = current_namespace;\n-      if (scope == NULL_TREE)\n-        scope = global_namespace;\n+  if (current == NULL_TREE)\n+    current = current_namespace;\n \n-      if (TYPE_P (scope))\n+  *new_type_p = 0;\n+  \n+  if (scope)\n+    {\n+      if (TREE_CODE (id) == TYPE_DECL)\n+\t/* We must bash typedefs back to the main decl of the\n+       \t   type. Otherwise we become confused about scopes.  */\n+\tdecl = TYPE_MAIN_DECL (TREE_TYPE (id));\n+      else if (DECL_CLASS_TEMPLATE_P (id))\n+\tdecl = DECL_TEMPLATE_RESULT (id);\n+      else\n \t{\n-\t  /* According to the suggested resolution of core issue 180,\n-\t     'typename' is assumed after a class-key.  */\n-\t  decl = make_typename_type (scope, id, 1);\n-\t  if (decl != error_mark_node)\n-\t    decl = TYPE_MAIN_DECL (decl);\n+\t  if (TYPE_P (scope))\n+\t    {\n+\t      /* According to the suggested resolution of core issue\n+\t     \t 180, 'typename' is assumed after a class-key.  */\n+\t      decl = make_typename_type (scope, id, 1);\n+\t      if (decl != error_mark_node)\n+\t\tdecl = TYPE_MAIN_DECL (decl);\n+\t      else\n+\t\tdecl = NULL_TREE;\n+\t    }\n+\t  else if (scope == current)\n+\t    {\n+\t      /* We've been given AGGR SCOPE::ID, when we're already\n+             \t inside SCOPE.  Be nice about it.  */\n+\t      if (pedantic)\n+\t\tpedwarn (\"extra qualification `%T::' on member `%D' ignored\",\n+\t\t\t scope, id);\n+\t    }\n \t  else\n-\t    decl = NULL_TREE;\n+\t    error (\"`%T' does not have a class or union named `%D'\",\n+\t\t   scope, id);\n \t}\n-      else if (scope == current)\n-        {\n-          /* We've been given AGGR SCOPE::ID, when we're already inside SCOPE.\n-             Be nice about it.  */\n-          if (pedantic)\n-            pedwarn (\"extra qualification `%T::' on member `%D' ignored\",\n-                        FROB_CONTEXT (scope), id);\n-        }\n-      else if (scope != global_namespace)\n-\terror (\"`%T' does not have a nested type named `%D'\", scope, id);\n-      else\n-\terror (\"no file-scope type named `%D'\", id);\n-      \n-      /* Inject it at the current scope.  */\n-      if (! decl)\n-\tdecl = TYPE_MAIN_DECL (xref_tag (aggr, id, 1));\n     }\n- \n-  /* Enter the SCOPE.  If this turns out not to be a definition, the\n-     parser must leave the scope.  */\n-  push_scope (CP_DECL_CONTEXT (decl));\n-\n-  /* If we see something like:\n+  \n+  if (!decl)\n+    {\n+      decl = TYPE_MAIN_DECL (xref_tag (aggr, id, !defn_p));\n+      xrefd_p = true;\n+    }\n \n-       template <typename T> struct S::I ....\n-       \n-     we must create a TEMPLATE_DECL for the nested type.  */\n-  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n-    decl = push_template_decl (decl);\n+  if (!TYPE_BINFO (TREE_TYPE (decl)))\n+    {\n+      error (\"`%T' is not a class or union type\", decl);\n+      return error_mark_node;\n+    }\n+  \n+  if (defn_p)\n+    {\n+      /* For a definition, we want to enter the containing scope\n+\t before looking up any base classes etc. Only do so, if this\n+\t is different to the current scope.  */\n+      tree context = CP_DECL_CONTEXT (decl);\n+\n+      *new_type_p = current != context;\n+      if (*new_type_p)\n+\tpush_scope (context);\n+  \n+      if (!xrefd_p && PROCESSING_REAL_TEMPLATE_DECL_P ())\n+\tdecl = push_template_decl (decl);\n+    }\n \n   return decl;\n }"}, {"sha": "64f3dc1a31e3d3f696b44848e1d5d9e671b3d78e", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 105, "deletions": 129, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d46a33b3223caf37f764ce4c26d9e293b9f26fff/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d46a33b3223caf37f764ce4c26d9e293b9f26fff/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=d46a33b3223caf37f764ce4c26d9e293b9f26fff", "patch": "@@ -1,6 +1,6 @@\n /* YACC parser for C++ syntax.\n    Copyright (C) 1988, 1989, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -386,10 +386,8 @@ cp_parse_init ()\n %type <ttype> component_constructor_declarator\n %type <ttype> fn.def2 return_id constructor_declarator\n %type <ttype> .begin_function_body\n-%type <ttype> named_class_head_sans_basetype\n-%type <ftype> class_head named_class_head \n-%type <ftype> named_complex_class_head_sans_basetype \n-%type <ttype> unnamed_class_head\n+%type <ttype> class_head class_head_apparent_template\n+%type <ftype> class_head_decl class_head_defn\n %type <ttype> base_class_list\n %type <ttype> base_class_access_list\n %type <ttype> base_class maybe_base_class_list base_class.1\n@@ -418,7 +416,6 @@ cp_parse_init ()\n %type <ttype> explicit_template_type\n /* in order to recognize aggr tags as defining and thus shadowing.  */\n %token TYPENAME_DEFN IDENTIFIER_DEFN PTYPENAME_DEFN\n-%type <ttype> named_class_head_sans_basetype_defn\n %type <ttype> identifier_defn IDENTIFIER_DEFN TYPENAME_DEFN PTYPENAME_DEFN\n %type <ttype> handler_args\n %type <ttype> self_template_type .finish_template_type\n@@ -2277,8 +2274,21 @@ structsp:\n \t\t  if (!processing_template_decl)\n \t\t    pedwarn (\"using `typename' outside of template\"); }\n \t/* C++ extensions, merged with C to avoid shift/reduce conflicts */\n-\t| class_head '{'\n-                { $1.t = begin_class_definition ($1.t); \n+\t| class_head_defn maybe_base_class_list '{'\n+\t\t{\n+\t\t  if ($2 && $1.t != error_mark_node)\n+\t\t    {\n+\t\t      tree type = TREE_TYPE ($1.t);\n+\t\t  \n+\t\t      if (TREE_CODE (type) == TYPENAME_TYPE)\n+\t\t\t/* In a definition of a member class template,\n+                           we will get here with an implicit typename,\n+                           a TYPENAME_TYPE with a type. */\n+\t\t\ttype = TREE_TYPE (type);\n+\t\t      maybe_process_partial_specialization (type);\n+\t\t      xref_basetypes (current_aggr, $1.t, type, $2);\n+\t\t    }\n+\t\t  $1.t = begin_class_definition (TREE_TYPE ($1.t)); \n                   current_aggr = NULL_TREE; }\n           opt.component_decl_list '}' maybe_attribute\n \t\t{ \n@@ -2289,8 +2299,7 @@ structsp:\n \t\t    yychar = YYLEX;\n \t\t  semi = yychar == ';';\n \n-\t\t  t = finish_class_definition ($1.t, $6, semi,\n-\t\t\t\t\t       $1.new_type_flag); \n+\t\t  t = finish_class_definition ($1.t, $7, semi, $1.new_type_flag);\n \t\t  $<ttype>$ = t;\n \n \t\t  /* restore current_aggr */\n@@ -2307,32 +2316,13 @@ structsp:\n \t  pending_inlines\n                 {\n \t\t  finish_inline_definitions ();\n-\t\t  $$.t = $<ttype>7;\n+\t\t  $$.t = $<ttype>8;\n \t\t  $$.new_type_flag = 1; \n \t\t}\n-\t| class_head  %prec EMPTY\n+\t| class_head_decl\n \t\t{\n-\t\t  if ($1.new_type_flag && $1.t != error_mark_node)\n-\t\t    pop_scope (CP_DECL_CONTEXT (TYPE_MAIN_DECL ($1.t)));\n-\t\t  $$.new_type_flag = 0;\n-\t\t  if ($1.t == error_mark_node)\n-\t\t    $$.t = $1.t;\n-\t\t  else if (TYPE_BINFO ($1.t) == NULL_TREE)\n-\t\t    {\n-\t\t      error (\"%T is not a class type\", $1.t);\n-\t\t      $$.t = error_mark_node;\n-\t\t    } \n-\t\t  else\n-\t\t    {\n-\t\t      $$.t = $1.t;\n-\t\t      /* struct B: public A; is not accepted by the standard grammar.  */\n-\t\t      if (CLASS_TYPE_P ($$.t)\n-\t\t\t  && TYPE_BINFO_BASETYPES ($$.t) \n-\t\t\t  && !COMPLETE_TYPE_P ($$.t)\n-\t\t\t  && ! TYPE_BEING_DEFINED ($$.t))\n-\t\t\terror (\"base clause without member specification for `%#T'\",\n-\t\t\t\t  $$.t);\n-\t\t    }\n+\t\t  $$.t = TREE_TYPE ($1.t);\n+\t\t  $$.new_type_flag = $1.new_type_flag;\n \t\t}\n \t;\n \n@@ -2362,140 +2352,126 @@ aggr:\n \t\t{ $$ = build_tree_list ($2, $1); }\n \t;\n \n-named_class_head_sans_basetype:\n+class_head:\n \t  aggr identifier\n-\t\t{ \n-\t\t  current_aggr = $1; \n-\t\t  $$ = $2; \n+\t\t{\n+\t\t  current_aggr = $1;\n+\t\t  $$ = build_tree_list (NULL_TREE, $2);\n \t\t}\n-\t;\n-\n-named_class_head_sans_basetype_defn:\n-\t  aggr identifier_defn  %prec EMPTY\n-\t\t{ current_aggr = $$; $$ = $2; }\n-\t| named_class_head_sans_basetype '{'\n-\t\t{ yyungetc ('{', 1); }\n-\t| named_class_head_sans_basetype ':'\n-\t\t{ yyungetc (':', 1); }\n-\t;\n-\n-named_complex_class_head_sans_basetype:\n-\t  aggr nested_name_specifier identifier\n+\t| aggr nested_name_specifier identifier\n \t\t{\n \t\t  current_aggr = $1;\n-\t\t  $$.t = handle_class_head ($1, $2, $3);\n-\t\t  $$.new_type_flag = 1;\n+\t\t  $$ = build_tree_list ($2, $3);\n \t\t}\n \t| aggr global_scope nested_name_specifier identifier\n \t\t{\n \t\t  current_aggr = $1;\n-\t\t  $$.t = handle_class_head ($1, $3, $4);\n-\t\t  $$.new_type_flag = 1;\n+\t\t  $$ = build_tree_list ($3, $4);\n \t\t}\n \t| aggr global_scope identifier\n \t\t{\n \t\t  current_aggr = $1;\n-\t\t  $$.t = handle_class_head ($1, NULL_TREE, $3);\n-\t\t  $$.new_type_flag = 1;\n+\t\t  $$ = build_tree_list (global_namespace, $3);\n \t\t}\n-\t| aggr apparent_template_type\n+\t;\n+\n+class_head_apparent_template:\n+\t  aggr apparent_template_type\n \t\t{ \n \t\t  current_aggr = $1; \n-\t\t  $$.t = $2;\n-\t\t  $$.new_type_flag = 0;\n+\t\t  $$ = $2;\n \t\t}\n \t| aggr nested_name_specifier apparent_template_type\n \t\t{ \n \t\t  current_aggr = $1; \n-\t\t  $$.t = $3;\n-\t\t  push_scope (CP_DECL_CONTEXT ($$.t));\n-\t\t  $$.new_type_flag = 1;\n+\t\t  $$ = $3;\n \t\t}\n \t| aggr global_scope nested_name_specifier apparent_template_type\n \t\t{ \n \t\t  current_aggr = $1; \n-\t\t  $$.t = $4;\n-\t\t  push_scope (CP_DECL_CONTEXT ($$.t));\n-\t\t  $$.new_type_flag = 1;\n+\t\t  $$ = $4;\n \t\t}\n \t;\n \n-named_class_head:\n-\t  named_class_head_sans_basetype  %prec EMPTY\n-\t\t{ \n-\t\t  $$.t = xref_tag (current_aggr, $1, 1); \n-\t\t  $$.new_type_flag = 0;\n+class_head_decl:\n+\t  class_head %prec EMPTY\n+\t\t{\n+\t\t  $$.t = handle_class_head (current_aggr,\n+\t\t\t\t\t    TREE_PURPOSE ($1), TREE_VALUE ($1),\n+\t\t\t\t\t    0, &$$.new_type_flag);\n \t\t}\n-\t| named_class_head_sans_basetype_defn \n-                { $<ttype>$ = xref_tag (current_aggr, $1, 0); }\n-          /* Class name is unqualified, so we look for base classes\n-             in the current scope.  */\n-          maybe_base_class_list  %prec EMPTY\n-\t\t{ \n-\t\t  $$.t = $<ttype>2;\n-\t\t  $$.new_type_flag = 0;\n-\t\t  if ($3)\n-                    xref_basetypes (current_aggr, $1, $<ttype>2, $3); \n+\t| aggr identifier_defn %prec EMPTY\n+\t\t{\n+\t\t  current_aggr = $1;\n+\t\t  $$.t = TYPE_MAIN_DECL (xref_tag (current_aggr, $2, 0));\n+\t\t  $$.new_type_flag = 1;\n \t\t}\n-\t| named_complex_class_head_sans_basetype \n-\t  maybe_base_class_list\n-\t\t{ \n-\t\t  if ($1.t != error_mark_node)\n-\t\t    {\n-\t\t      tree type = TREE_TYPE ($1.t);\n-\n-\t\t      $$.t = type;\n-\t\t      $$.new_type_flag = $1.new_type_flag;\n-\t\t      if ((current_aggr == union_type_node)\n-\t\t\t  != (TREE_CODE (type) == UNION_TYPE))\n-\t\t\tpedwarn (current_aggr == union_type_node\n-\t                            ? \"`union' tag used in declaring `%#T'\"\n-\t                            : \"non-`union' tag used in declaring `%#T'\", \n-\t\t\t\t    type);\n-\t\t      else if (TREE_CODE (type) == RECORD_TYPE)\n-\t\t\t/* We might be specializing a template with a different\n-\t\t\t   class-key; deal.  */\n-\t\t\tCLASSTYPE_DECLARED_CLASS (type) \n-\t\t\t  = (current_aggr == class_type_node);\n-\t\t      if ($2)\n-\t\t\t{\n-                          if (TREE_CODE (type) == TYPENAME_TYPE)\n-                            /* In a definition of a member class template, we\n-                               will get here with an implicit typename, a\n-                               TYPENAME_TYPE with a type. */\n-                            type = TREE_TYPE (type);\n-\t\t\t  maybe_process_partial_specialization (type);\n-\t\t\t  xref_basetypes (current_aggr, $1.t, type, $2); \n-\t\t\t}\n-\t\t    }\n+\t| class_head_apparent_template %prec EMPTY\n+\t\t{\n+\t\t  $$.t = $1;\n+\t\t  $$.new_type_flag = 0;\n \t\t}\n \t;\n \n-unnamed_class_head:\n-\t  aggr '{'\n-\t\t{ $$ = xref_tag ($$, make_anon_name (), 0);\n-\t\t  yyungetc ('{', 1); }\n-\t;\n-\n-/* The tree output of this nonterminal a declarationf or the type\n-   named.  If NEW_TYPE_FLAG is set, then the name used in this\n-   class-head was explicitly qualified, e.g.:  `struct X::Y'.  We have\n-   already called push_scope for X.  */\n-class_head:\n-\t  unnamed_class_head\n-                {\n+class_head_defn:\n+\t  class_head '{'\n+\t\t{\n+\t\t  yyungetc ('{', 1);\n+\t\t  $$.t = handle_class_head (current_aggr,\n+\t\t\t\t\t    TREE_PURPOSE ($1), TREE_VALUE ($1),\n+\t\t\t\t\t    1, &$$.new_type_flag);\n+\t\t}\n+\t| class_head ':'\n+\t\t{\n+\t\t  yyungetc (':', 1);\n+\t\t  $$.t = handle_class_head (current_aggr,\n+\t\t\t\t\t    TREE_PURPOSE ($1), TREE_VALUE ($1),\n+\t\t\t\t\t    1, &$$.new_type_flag);\n+\t\t}\n+\t| class_head_apparent_template '{'\n+\t\t{\n+\t\t  yyungetc ('{', 1);\n+\t\t  $$.t = $1;\n+\t\t  $$.new_type_flag = 0;\n+\t\t}\n+\t| class_head_apparent_template ':'\n+\t\t{\n+\t\t  yyungetc (':', 1);\n \t\t  $$.t = $1;\n \t\t  $$.new_type_flag = 0;\n \t\t}\n-\t| named_class_head\n+\t| aggr identifier_defn '{'\n+\t\t{\n+\t\t  yyungetc ('{', 1);\n+\t\t  current_aggr = $1;\n+\t\t  $$.t = handle_class_head (current_aggr,\n+\t\t\t\t\t    NULL_TREE, $2,\n+\t\t\t\t\t    1, &$$.new_type_flag);\n+\t\t}\n+\t| aggr identifier_defn ':'\n+\t\t{\n+\t\t  yyungetc (':', 1);\n+\t\t  current_aggr = $1;\n+\t\t  $$.t = handle_class_head (current_aggr,\n+\t\t\t\t\t    NULL_TREE, $2,\n+\t\t\t\t\t    1, &$$.new_type_flag);\n+\t\t}\n+        | aggr '{'\n+\t\t{\n+\t\t  current_aggr = $1;\n+\t\t  $$.t = TYPE_MAIN_DECL (xref_tag ($1, make_anon_name (), 0));\n+\t\t  $$.new_type_flag = 0;\n+\t\t  yyungetc ('{', 1);\n+\t\t}\n \t;\n \n maybe_base_class_list:\n-\t  /* empty */  %prec EMPTY\n+\t  /* empty */\n \t\t{ $$ = NULL_TREE; }\n-\t| ':' see_typename  %prec EMPTY\n-\t\t{ yyungetc(':', 1); $$ = NULL_TREE; }\n-\t| ':' see_typename base_class_list  %prec EMPTY\n+\t| ':' see_typename\n+\t\t{ error (\"no bases given following `:'\");\n+\t\t  $$ = NULL_TREE; }\n+\t| ':' see_typename base_class_list\n \t\t{ $$ = $3; }\n \t;\n "}, {"sha": "96c503d1fad7635066e61725fbd94fc79582b6d8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d46a33b3223caf37f764ce4c26d9e293b9f26fff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d46a33b3223caf37f764ce4c26d9e293b9f26fff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d46a33b3223caf37f764ce4c26d9e293b9f26fff", "patch": "@@ -1,3 +1,8 @@\n+2002-01-02  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.dg/template/friend2.C: New test.\n+\t* g++.old-deja/g++/brendan/crash8.C: Adjust location of error.\n+\n 2002-01-02  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/other/ptrmem1.C: New test."}, {"sha": "7400534acac2413ee9cfd60c1816454759276306", "filename": "gcc/testsuite/g++.dg/template/friend3.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d46a33b3223caf37f764ce4c26d9e293b9f26fff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d46a33b3223caf37f764ce4c26d9e293b9f26fff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend3.C?ref=d46a33b3223caf37f764ce4c26d9e293b9f26fff", "patch": "@@ -0,0 +1,31 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 28 Dec 2001 <nathan@codesourcery.com>\n+\n+// PR 775 friend classes with qualified names inside template classes.\n+\n+struct A\n+{\n+  struct B {\n+    B () { }\n+  };\n+};\n+\n+template <class T>\n+struct C: A {\n+  friend A::B::B (); // 2.95.2 ICE\n+  friend struct A;\n+  friend struct A::B; // 2.97 error\n+};\n+\n+template class C<char>;\n+\n+template <typename T> class TPL\n+{\n+  class nested;\n+};\n+\n+template <typename T> class TPL<T>::nested \n+{\n+};"}, {"sha": "46cc16fa18c0ac5495bb6a55a3ea7cfbe3dc78b4", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash8.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d46a33b3223caf37f764ce4c26d9e293b9f26fff/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d46a33b3223caf37f764ce4c26d9e293b9f26fff/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash8.C?ref=d46a33b3223caf37f764ce4c26d9e293b9f26fff", "patch": "@@ -1,8 +1,8 @@\n // Build don't link: \n // GROUPS passed old-abort\n template<int a, int b>\n-class Elvis // ERROR - in template.*\n-{\n+class Elvis\n+{ // ERROR - in template.*\n } ;\n \n template<int a>"}]}