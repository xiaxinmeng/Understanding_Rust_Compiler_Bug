{"sha": "5f8f4a0743986087a48edfdda1c16aaa9f7d1388", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY4ZjRhMDc0Mzk4NjA4N2E0OGVkZmRkYTFjMTZhYWE5ZjdkMTM4OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-12-07T22:50:45Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-12-07T22:50:45Z"}, "message": "(unary_expr, expr_no_commas): Increment skip_evaluation when analyzing an expression that is known not to be evaluated.\n\n(unary_expr, expr_no_commas): Increment skip_evaluation when analyzing an\nexpression that is known not to be evaluated.\n(sizeof, alignof): New rules.\n\nFrom-SVN: r13231", "tree": {"sha": "3d0c825c6f0a2573a59905cae489cc6ed9991dc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d0c825c6f0a2573a59905cae489cc6ed9991dc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f8f4a0743986087a48edfdda1c16aaa9f7d1388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f8f4a0743986087a48edfdda1c16aaa9f7d1388", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f8f4a0743986087a48edfdda1c16aaa9f7d1388", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f8f4a0743986087a48edfdda1c16aaa9f7d1388/comments", "author": null, "committer": null, "parents": [{"sha": "d790567a759148db805d7bbe0e53ef20fa383044", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d790567a759148db805d7bbe0e53ef20fa383044", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d790567a759148db805d7bbe0e53ef20fa383044"}], "stats": {"total": 69, "additions": 55, "deletions": 14}, "files": [{"sha": "36d24e74e588d01c115d18a4d06ecf8b12802811", "filename": "gcc/c-parse.in", "status": "modified", "additions": 55, "deletions": 14, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f8f4a0743986087a48edfdda1c16aaa9f7d1388/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f8f4a0743986087a48edfdda1c16aaa9f7d1388/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=5f8f4a0743986087a48edfdda1c16aaa9f7d1388", "patch": "@@ -485,23 +485,35 @@ unary_expr:\n \t\t      $$ = build_unary_op (ADDR_EXPR, $$, 0);\n \t\t    } }\n */\n-\t| SIZEOF unary_expr  %prec UNARY\n-\t\t{ if (TREE_CODE ($2) == COMPONENT_REF\n+\t| sizeof unary_expr  %prec UNARY\n+\t\t{ skip_evaluation--;\n+\t\t  if (TREE_CODE ($2) == COMPONENT_REF\n \t\t      && DECL_BIT_FIELD (TREE_OPERAND ($2, 1)))\n \t\t    error (\"`sizeof' applied to a bit-field\");\n \t\t  $$ = c_sizeof (TREE_TYPE ($2)); }\n-\t| SIZEOF '(' typename ')'  %prec HYPERUNARY\n-\t\t{ $$ = c_sizeof (groktypename ($3)); }\n-\t| ALIGNOF unary_expr  %prec UNARY\n-\t\t{ $$ = c_alignof_expr ($2); }\n-\t| ALIGNOF '(' typename ')'  %prec HYPERUNARY\n-\t\t{ $$ = c_alignof (groktypename ($3)); }\n+\t| sizeof '(' typename ')'  %prec HYPERUNARY\n+\t\t{ skip_evaluation--;\n+\t\t  $$ = c_sizeof (groktypename ($3)); }\n+\t| alignof unary_expr  %prec UNARY\n+\t\t{ skip_evaluation--;\n+\t\t  $$ = c_alignof_expr ($2); }\n+\t| alignof '(' typename ')'  %prec HYPERUNARY\n+\t\t{ skip_evaluation--;\n+\t\t  $$ = c_alignof (groktypename ($3)); }\n \t| REALPART cast_expr %prec UNARY\n \t\t{ $$ = build_unary_op (REALPART_EXPR, $2, 0); }\n \t| IMAGPART cast_expr %prec UNARY\n \t\t{ $$ = build_unary_op (IMAGPART_EXPR, $2, 0); }\n \t;\n \n+sizeof:\n+\tSIZEOF { skip_evaluation++; }\n+\t;\n+\n+alignof:\n+\tALIGNOF { skip_evaluation++; }\n+\t;\n+\n cast_expr:\n \tunary_expr\n \t| '(' typename ')' cast_expr  %prec UNARY\n@@ -564,12 +576,41 @@ expr_no_commas:\n \t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n \t| expr_no_commas '^' expr_no_commas\n \t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas ANDAND expr_no_commas\n-\t\t{ $$ = parser_build_binary_op (TRUTH_ANDIF_EXPR, $1, $3); }\n-\t| expr_no_commas OROR expr_no_commas\n-\t\t{ $$ = parser_build_binary_op (TRUTH_ORIF_EXPR, $1, $3); }\n-\t| expr_no_commas '?' xexpr ':' expr_no_commas\n-\t\t{ $$ = build_conditional_expr ($1, $3, $5); }\n+\t| expr_no_commas ANDAND\n+\t\t{ $1 = truthvalue_conversion (default_conversion ($1));\n+\t\t  $<itype>2 = $1 == boolean_false_node;\n+\t\t  skip_evaluation += $<itype>2; }\n+\t  expr_no_commas\n+\t\t{ skip_evaluation -= $<itype>2;\n+\t\t  $$ = parser_build_binary_op (TRUTH_ANDIF_EXPR, $1, $4); }\n+\t| expr_no_commas OROR\n+\t\t{ $1 = truthvalue_conversion (default_conversion ($1));\n+\t\t  $<itype>3 = $1 == boolean_true_node;\n+\t\t  skip_evaluation += $<itype>3; }\n+\t  expr_no_commas\n+\t\t{ skip_evaluation -= $<itype>3;\n+\t\t  $$ = parser_build_binary_op (TRUTH_ORIF_EXPR, $1, $4); }\n+\t| expr_no_commas '?'\n+\t\t{ $1 = truthvalue_conversion (default_conversion ($1));\n+\t\t  $<itype>3 = $1 == boolean_true_node;\n+\t\t  $<itype>2 = $1 == boolean_false_node;\n+\t\t  skip_evaluation += $<itype>2; }\n+          expr ':'\n+\t\t{ skip_evaluation += $<itype>3 - $<itype>2; }\n+\t  expr_no_commas\n+\t\t{ skip_evaluation -= $<itype>3;\n+\t\t  $$ = build_conditional_expr ($1, $4, $7); }\n+\t| expr_no_commas '?'\n+\t\t{ if (pedantic)\n+\t\t    pedwarn (\"ANSI C forbids omitting the middle term of a ?: expression\");\n+\t\t  /* Make sure first operand is calculated only once.  */\n+\t\t  $<ttype>2 = save_expr ($1);\n+\t\t  $1 = truthvalue_conversion (default_conversion ($<ttype>2));\n+\t\t  $<itype>3 = $1 == boolean_true_node;\n+\t\t  skip_evaluation += $<itype>3; }\n+\t  ':' expr_no_commas\n+\t\t{ skip_evaluation -= $<itype>3;\n+\t\t  $$ = build_conditional_expr ($1, $<ttype>2, $5); }\n \t| expr_no_commas '=' expr_no_commas\n \t\t{ $$ = build_modify_expr ($1, NOP_EXPR, $3);\n \t\t  C_SET_EXP_ORIGINAL_CODE ($$, MODIFY_EXPR); }"}]}