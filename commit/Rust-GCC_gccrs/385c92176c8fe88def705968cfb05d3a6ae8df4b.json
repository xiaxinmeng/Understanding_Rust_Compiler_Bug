{"sha": "385c92176c8fe88def705968cfb05d3a6ae8df4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg1YzkyMTc2YzhmZTg4ZGVmNzA1OTY4Y2ZiMDVkM2E2YWU4ZGY0Yg==", "commit": {"author": {"name": "Stephane Carrez", "email": "Stephane.Carrez@worldnet.fr", "date": "2000-09-08T20:54:44Z"}, "committer": {"name": "Stephane Carrez", "email": "ciceron@gcc.gnu.org", "date": "2000-09-08T20:54:44Z"}, "message": "m68hc11.md: New file, machine description for 68HC11 & 68HC12.\n\n\t* config/m68hc11/m68hc11.md: New file, machine description for\n\t68HC11 & 68HC12.\n\t* config/m68hc11/m68hc11.h: New file, definitions for 68HC11 & 68HC12.\n\t* config/m68hc11/m68hc11.c: New file, functions for 68HC11 & 68HC12.\n\t* config/m68hc11/m68hc12.h: New file, definitions for 68HC12.\n\t* config/m68hc11/m68hc11-protos.h: New file.\n\t* config/m68hc11/m68hc11-crt0.S: New file, startup code.\n\t* config/m68hc11/t-m68hc11-gas: New file, makefile fragment.\n\t* config/m68hc11/xm-m68hc11.h: New file, target defs.\n\t* config/m68hc11/larith.asm: New file, libgcc routines.\n\nFrom-SVN: r36276", "tree": {"sha": "467b7de20407bbd3e956fda20262644868e07134", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/467b7de20407bbd3e956fda20262644868e07134"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/385c92176c8fe88def705968cfb05d3a6ae8df4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/385c92176c8fe88def705968cfb05d3a6ae8df4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/385c92176c8fe88def705968cfb05d3a6ae8df4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/385c92176c8fe88def705968cfb05d3a6ae8df4b/comments", "author": null, "committer": null, "parents": [{"sha": "e0b7ed05b23f828aa1e4415f2074b4c152b0a9be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0b7ed05b23f828aa1e4415f2074b4c152b0a9be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0b7ed05b23f828aa1e4415f2074b4c152b0a9be"}], "stats": {"total": 14190, "additions": 14190, "deletions": 0}, "files": [{"sha": "bfdf06d019df11491f0e28a7c66623d6a9ec7479", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=385c92176c8fe88def705968cfb05d3a6ae8df4b", "patch": "@@ -1,3 +1,16 @@\n+2000-09-08  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n+\n+\t* config/m68hc11/m68hc11.md: New file, machine description for\n+\t68HC11 & 68HC12.\n+\t* config/m68hc11/m68hc11.h: New file, definitions for 68HC11 & 68HC12.\n+\t* config/m68hc11/m68hc11.c: New file, functions for 68HC11 & 68HC12.\n+\t* config/m68hc11/m68hc12.h: New file, definitions for 68HC12.\n+\t* config/m68hc11/m68hc11-protos.h: New file.\n+\t* config/m68hc11/m68hc11-crt0.S: New file, startup code.\n+\t* config/m68hc11/t-m68hc11-gas: New file, makefile fragment.\n+\t* config/m68hc11/xm-m68hc11.h: New file, target defs.\n+\t* config/m68hc11/larith.asm: New file, libgcc routines.\n+\n 2000-09-08  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n \n \t* Makefile.in (DPBIT_FUNCS): Add _usi_to_df."}, {"sha": "e75772964f1195caa989c7976ddb83b12897658e", "filename": "gcc/config/m68hc11/larith.asm", "status": "added", "additions": 968, "deletions": 0, "changes": 968, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Flarith.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Flarith.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Flarith.asm?ref=385c92176c8fe88def705968cfb05d3a6ae8df4b", "patch": "@@ -0,0 +1,968 @@\n+/* libgcc1 routines for M68HC11.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file with other programs, and to distribute\n+those programs without any restriction coming from the use of this\n+file.  (The General Public License restrictions do apply in other\n+respects; for example, they cover modification of the file, and\n+distribution when not linked into another program.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+\t.file \"larith.asm\"\n+\n+\t.sect .text\n+\t\n+\n+#define REG(NAME)\t\t\t\\\n+NAME:\t.word 0;\t\t\t\\\n+\t.type NAME,@object ;\t\t\\\n+\t.size NAME,2\n+\n+#ifdef L_regs_min\n+/* Pseudo hard registers used by gcc.\n+   They must be located in page0. \n+   They will normally appear at the end of .page0 section.  */\n+\t.sect .page0\n+\t.globl _.tmp,_.frame\n+\t.globl _.z,_.xy\n+REG(_.tmp)\n+REG(_.z)\n+REG(_.xy)\n+REG(_.frame)\n+\n+#endif\n+\n+#ifdef L_regs_d1_8\n+/* Pseudo hard registers used by gcc.\n+   They must be located in page0. \n+   They will normally appear at the end of .page0 section.  */\n+\t.sect .page0\n+\t.globl _.d1,_.d2,_.d3,_.d4,_.d5,_.d6\n+\t.globl _.d7,_.d8\n+REG(_.d1)\n+REG(_.d2)\n+REG(_.d3)\n+REG(_.d4)\n+REG(_.d5)\n+REG(_.d6)\n+REG(_.d7)\n+REG(_.d8)\n+\n+#endif\n+\n+#ifdef L_regs_d8_16\n+/* Pseudo hard registers used by gcc.\n+   They must be located in page0. \n+   They will normally appear at the end of .page0 section.  */\n+\t.sect .page0\n+\t.globl _.d9,_.d10,_.d11,_.d12,_.d13,_.d14\n+\t.globl _.d15,_.d16\n+REG(_.d9)\n+REG(_.d10)\n+REG(_.d11)\n+REG(_.d12)\n+REG(_.d13)\n+REG(_.d14)\n+REG(_.d15)\n+REG(_.d16)\n+\n+#endif\n+\n+#ifdef L_regs_d17_32\n+/* Pseudo hard registers used by gcc.\n+   They must be located in page0. \n+   They will normally appear at the end of .page0 section.  */\n+\t.sect .page0\n+\t.globl _.d17,_.d18,_.d19,_.d20,_.d21,_.d22\n+\t.globl _.d23,_.d24,_.d25,_.d26,_.d27,_.d28\n+\t.globl _.d29,_.d30,_.d31,_.d32\n+REG(_.d17)\n+REG(_.d18)\n+REG(_.d19)\n+REG(_.d20)\n+REG(_.d21)\n+REG(_.d22)\n+REG(_.d23)\n+REG(_.d24)\n+REG(_.d25)\n+REG(_.d26)\n+REG(_.d27)\n+REG(_.d28)\n+REG(_.d29)\n+REG(_.d30)\n+REG(_.d31)\n+REG(_.d32)\n+#endif\n+\n+#ifdef L_premain\n+;;\n+;; Specific initialization for 68hc11 before the main.\n+;; Nothing special for a generic routine; Just enable interrupts.\n+;;\n+\t.sect .text\n+\t.globl __premain\n+__premain:\n+\tclra\n+\ttap\t; Clear both I and X.\n+\trts\n+#endif\n+\n+#ifdef L__exit\n+;;\n+;; Exit operation.  Just loop forever and wait for interrupts.\n+;; (no other place to go)\n+;;\n+\t.sect .text\n+\t.globl _exit\t\n+\t.globl exit\n+\t.weak  exit\n+exit:\n+_exit:\n+fatal:\n+\tcli\n+\twai\n+\tbra fatal\n+#endif\n+\n+#ifdef L_abort\n+;;\n+;; Abort operation.  This is defined for the GCC testsuite.\n+;;\n+\t.sect .text\n+\t.globl abort\n+abort:\n+\tldd\t#255\t\t; \n+\t.byte 0xCD\t\t; Generate an illegal instruction trap\n+\t.byte 0x03\t\t; The simulator catches this and stops.\n+\tjmp _exit\n+#endif\n+\t\n+#ifdef L_cleanup\n+;;\n+;; Cleanup operation used by exit().\n+;;\n+\t.sect .text\n+\t.globl _cleanup\n+_cleanup:\n+\trts\n+#endif\n+\n+;-----------------------------------------\n+; required gcclib code\n+;-----------------------------------------\n+#ifdef L_memcpy\n+\t.sect .text\n+\t.weak memcpy\n+\t.globl memcpy\n+\t.globl __memcpy\n+;;;\n+;;; void* memcpy(void*, const void*, size_t)\n+;;; \n+;;; D    = dst\tPmode\n+;;; 2,sp = src\tPmode\n+;;; 4,sp = size\tHImode (size_t)\n+;;; \n+__memcpy:\n+memcpy:\n+\txgdy\n+\ttsx\n+\tldd\t4,x\n+\tldx\t2,x\t\t; SRC = X, DST = Y\n+\tcpd\t#0\n+\tbeq\tEnd\n+\tpshy\n+\tinca\t\t\t; Correction for the deca below\n+L0:\n+\tpsha\t\t\t; Save high-counter part\n+L1:\n+\tldaa\t0,x\t\t; Copy up to 256 bytes\n+\tstaa\t0,y\n+\tinx\n+\tiny\n+\tdecb\n+\tbne\tL1\n+\tpula\n+\tdeca\n+\tbne\tL0\n+\tpuly\t\t\t; Restore Y to return the DST\n+End:\n+\txgdy\n+\trts\n+#endif\n+\n+#ifdef L_memset\n+\t.sect .text\n+\t.globl memset\n+\t.globl __memset\n+;;;\n+;;; void* memset(void*, int value, size_t)\n+;;; \n+#ifndef __HAVE_SHORT_INT__\n+;;; D    = dst\tPmode\n+;;; 2,sp = src\tSImode\n+;;; 6,sp = size\tHImode (size_t)\n+\tval  = 5\n+\tsize = 6\n+#else\n+;;; D    = dst\tPmode\n+;;; 2,sp = src\tSImode\n+;;; 6,sp = size\tHImode (size_t)\n+\tval  = 3\n+\tsize = 4\n+#endif\n+__memset:\n+memset:\n+\txgdx\n+\ttsy\n+\tldab\tval,y\n+\tldy\tsize,y\t\t; DST = X, CNT = Y\n+\tbeq\tEnd\n+\tpshx\n+L0:\n+\tstab\t0,x\t\t; Fill up to 256 bytes\n+\tinx\n+\tdey\n+\tbne\tL0\n+\tpulx\t\t\t; Restore X to return the DST\n+End:\n+\txgdx\n+\trts\n+#endif\n+\t\t\n+#ifdef L_adddi3\n+\t.sect .text\n+\t.globl ___adddi3\n+\n+___adddi3:\n+\ttsx\n+\ttsy\n+\tpshb\n+\tpsha\n+\tldd\t8,x\n+\taddd\t16,y\n+\tpshb\n+\tpsha\n+\n+\tldd\t6,x\n+\tadcb\t15,y\n+\tadca\t14,y\n+\tpshb\n+\tpsha\n+\n+\tldd\t4,x\n+\tadcb\t13,y\n+\tadca\t12,y\n+\tpshb\n+\tpsha\n+\t\n+\tldd\t2,x\n+\tadcb\t11,y\n+\tadca\t10,y\n+\ttsx\n+\tldy\t6,x\n+\n+\tstd\t0,y\n+\tpulx\n+\tstx\t2,y\n+\tpulx\n+\tstx\t4,y\n+\tpulx\n+\tstx\t6,y\n+\tpulx\n+\trts\n+#endif\n+\n+#ifdef L_subdi3\n+\t.sect .text\n+\t.globl ___subdi3\n+\n+___subdi3:\n+\ttsx\n+\ttsy\n+\tpshb\n+\tpsha\n+\tldd\t8,x\n+\tsubd\t16,y\n+\tpshb\n+\tpsha\n+\n+\tldd\t6,x\n+\tsbcb\t15,y\n+\tsbca\t14,y\n+\tpshb\n+\tpsha\n+\n+\tldd\t4,x\n+\tsbcb\t13,y\n+\tsbca\t12,y\n+\tpshb\n+\tpsha\n+\t\n+\tldd\t2,x\n+\tsbcb\t11,y\n+\tsbca\t10,y\n+\t\n+\ttsx\n+\tldy\t6,x\n+\n+\tstd\t0,y\n+\tpulx\n+\tstx\t2,y\n+\tpulx\n+\tstx\t4,y\n+\tpulx\n+\tstx\t6,y\n+\tpulx\n+\trts\n+#endif\n+\t\n+#ifdef L_notdi2\n+\t.sect .text\n+\t.globl ___notdi2\n+\n+___notdi2:\n+\ttsy\n+\txgdx\n+\tldd\t8,y\n+\tcoma\n+\tcomb\n+\tstd\t6,x\n+\t\n+\tldd\t6,y\n+\tcoma\n+\tcomb\n+\tstd\t4,x\n+\n+\tldd\t4,y\n+\tcoma\n+\tcomb\n+\tstd\t2,x\n+\n+\tldd\t2,y\n+\tcoma\n+\tcomb\n+\tstd\t0,x\n+\trts\n+#endif\n+\t\n+#ifdef L_negsi2\n+\t.sect .text\n+\t.globl ___negsi2\n+\n+___negsi2:\n+\tcomb\n+\tcoma\n+\taddd\t#1\n+\txgdx\n+\teorb\t#0xFF\n+\teora\t#0xFF\n+\tadcb\t#0\n+\tadca\t#0\n+\txgdx\n+\trts\n+#endif\n+\n+#ifdef L_one_cmplsi2\n+\t.sect .text\n+\t.globl ___one_cmplsi2\n+\n+___one_cmplsi2:\n+\tcomb\n+\tcoma\n+\txgdx\n+\tcomb\n+\tcoma\n+\txgdx\n+\trts\n+#endif\n+\t\n+#ifdef L_ashlsi3\n+\t.sect .text\n+\t.globl ___ashlsi3\n+\n+___ashlsi3:\n+\txgdy\n+\tclra\n+\tandb\t#0x1f\n+\txgdy\n+\tbeq\tReturn\n+Loop:\n+\tlsld\n+\txgdx\n+\trolb\n+\trola\n+\txgdx\n+\tdey\n+\tbne\tLoop\n+Return:\n+\trts\n+#endif\n+\n+#ifdef L_ashrsi3\n+\t.sect .text\n+\t.globl ___ashrsi3\n+\n+___ashrsi3:\n+\txgdy\n+\tclra\n+\tandb\t#0x1f\n+\txgdy\n+\tbeq\tReturn\n+Loop:\n+\txgdx\n+\tasra\n+\trorb\n+\txgdx\n+\trora\n+\trorb\n+\tdey\n+\tbne\tLoop\n+Return:\n+\trts\n+#endif\n+\n+#ifdef L_lshrsi3\n+\t.sect .text\n+\t.globl ___lshrsi3\n+\n+___lshrsi3:\n+\txgdy\n+\tclra\n+\tandb\t#0x1f\n+\txgdy\n+\tbeq\tReturn\n+Loop:\n+\txgdx\n+\tlsrd\n+\txgdx\n+\trora\n+\trorb\n+\tdey\n+\tbne\tLoop\n+Return:\n+\trts\n+#endif\n+\n+#ifdef L_lshrhi3\n+\t.sect .text\n+\t.globl ___lshrhi3\n+\n+___lshrhi3:\n+\tcpx\t#16\n+\tbge\tReturn_zero\n+\tcpx\t#0\n+\tbeq\tReturn\n+Loop:\n+\tlsrd\n+\tdex\n+\tbne\tLoop\n+Return:\n+\trts\n+Return_zero:\n+\tclra\n+\tclrb\n+\trts\n+#endif\n+\t\n+#ifdef L_lshlhi3\n+\t.sect .text\n+\t.globl ___lshlhi3\n+\n+___lshlhi3:\n+\tcpx\t#16\n+\tbge\tReturn_zero\n+\tcpx\t#0\n+\tbeq\tReturn\n+Loop:\n+\tlsld\n+\tdex\n+\tbne\tLoop\n+Return:\n+\trts\n+Return_zero:\n+\tclra\n+\tclrb\n+\trts\n+#endif\n+\n+#ifdef L_ashrhi3\n+\t.sect .text\n+\t.globl ___ashrhi3\n+\n+___ashrhi3:\n+\tcpx\t#16\n+\tbge\tReturn_minus_1_or_zero\n+\tcpx\t#0\n+\tbeq\tReturn\n+Loop:\n+\tasra\n+\trorb\n+\tdex\n+\tbne\tLoop\n+Return:\n+\trts\n+Return_minus_1_or_zero:\n+\tclrb\n+\ttsta\n+\tbpl\tReturn_zero\n+\tcomb\n+Return_zero:\n+\ttba\n+\trts\n+#endif\n+\t\n+#ifdef L_ashrqi3\n+\t.sect .text\n+\t.globl ___ashrqi3\n+\n+___ashrqi3:\n+\tcmpa\t#8\n+\tbge\tReturn_minus_1_or_zero\n+\ttsta\n+\tbeq\tReturn\n+Loop:\n+\tasrb\n+\tdeca\n+\tbne\tLoop\n+Return:\n+\trts\n+Return_minus_1_or_zero:\n+\tclrb\n+\ttstb\n+\tbpl\tReturn_zero\n+\tcoma\n+Return_zero:\n+\ttab\n+\trts\n+#endif\n+\n+#ifdef L_lshlqi3\n+\t.sect .text\n+\t.globl ___lshlqi3\n+\n+___lshlqi3:\n+\tcmpa\t#8\n+\tbge\tReturn_zero\n+\ttsta\n+\tbeq\tReturn\n+Loop:\n+\tlslb\n+\tdeca\n+\tbne\tLoop\n+Return:\n+\trts\n+Return_zero:\n+\tclrb\n+\trts\n+#endif\n+\n+#ifdef L_divmodhi4\n+\t.sect .text\n+\t.globl __divmodhi4\n+\n+;\n+;; D = numerator\n+;; X = denominator\n+;;\n+;; Result:\tD = D / X\n+;;\t\tX = D % X\n+;; \n+__divmodhi4:\n+\ttsta\n+\tbpl\tNumerator_pos\n+\tcomb\t\t\t; D = -D <=> D = (~D) + 1\n+\tcoma\n+\txgdx\n+\tinx\n+\ttsta\n+\tbpl\tNumerator_neg_denominator_pos\n+Numerator_neg_denominator_neg:\n+\tcomb\t\t\t; X = -X\n+\tcoma\n+\taddd\t#1\n+\txgdx\n+\tidiv\n+\tcoma\n+\tcomb\n+\txgdx\t\t\t; Remainder <= 0 and result >= 0\n+\tinx\n+\trts\n+\n+Numerator_pos_denominator_pos:\n+\txgdx\n+\tidiv\n+\txgdx\t\t\t; Both values are >= 0\n+\trts\n+\t\n+Numerator_pos:\n+\txgdx\n+\ttsta\n+\tbpl\tNumerator_pos_denominator_pos\n+Numerator_pos_denominator_neg:\n+\tcoma\t\t\t; X = -X\n+\tcomb\n+\txgdx\n+\tinx\n+\tidiv\n+\txgdx\t\t\t; Remainder >= 0 but result <= 0\n+\tcoma\n+\tcomb\n+\taddd\t#1\n+\trts\n+\t\n+Numerator_neg_denominator_pos:\n+\txgdx\n+\tidiv\n+\tcoma\t\t\t; One value is > 0 and the other < 0\n+\tcomb\t\t\t; Change the sign of result and remainder\n+\txgdx\n+\tinx\n+\tcoma\n+\tcomb\n+\taddd\t#1\n+\trts\n+#endif\n+\n+#ifdef L_mulqi3\n+       .sect .text\n+       .globl __mulqi3\n+\n+;\n+; short __mulqi3(signed char a, signed char b);\n+;\n+;\tsigned char a\t-> register A\n+;\tsigned char b\t-> register B\n+;\n+; returns the signed result of A * B in register D.\n+;\n+__mulqi3:\n+\ttsta\n+\tbmi\tA_neg\n+\ttstb\n+\tbmi\tB_neg\n+\tmul\n+\trts\n+B_neg:\n+\tnegb\n+\tbra\tA_or_B_neg\n+A_neg:\n+\tnega\n+\ttstb\n+\tbmi\tAB_neg\n+A_or_B_neg:\n+\tmul\n+\tcoma\n+\tcomb\n+\taddd\t#1\n+\trts\n+AB_neg:\n+\tnega\n+\tnegb\n+\tmul\n+\trts\n+#endif\n+\t\n+#ifdef L_mulhi3\n+\t.sect .text\n+\t.globl ___mulhi3\n+\n+;\n+;\n+;  unsigned short ___mulhi3(unsigned short a, unsigned short b)\n+;\n+;\ta = register D\n+;\tb = register X\n+;\n+___mulhi3:\n+\tstx\t*_.tmp\n+\tpshb\n+\tldab\t*_.tmp+1\n+\tmul\t\t\t; A.high * B.low\n+\tldaa\t*_.tmp\n+\tstab\t*_.tmp\n+\tpulb\n+\tpshb\n+\tmul\t\t\t; A.low * B.high\n+\taddb\t*_.tmp\n+\tstab\t*_.tmp\n+\tldaa\t*_.tmp+1\n+\tpulb\n+\tmul\t\t\t; A.low * B.low\n+\tadda\t*_.tmp\n+\trts\n+#endif\n+\n+#ifdef L_mulhi32\n+\t.sect .text\n+\t.globl __mulhi32\n+\n+;\n+;\n+;  unsigned long __mulhi32(unsigned short a, unsigned short b)\n+;\n+;\ta = register D\n+;\tb = value on stack\n+;\n+;\t+---------------+\n+;       |  B low\t| <- 5,x\n+;\t+---------------+\n+;       |  B high\t| <- 4,x\n+;\t+---------------+\n+;       |  PC low\t|  \n+;\t+---------------+\n+;       |  PC high\t|  \n+;\t+---------------+\n+;\t|  A low\t|\n+;\t+---------------+\n+;\t|  A high\t|\n+;\t+---------------+  <- 0,x\n+;\n+;\n+;      <B-low>    5,x\n+;      <B-high>   4,x\n+;      <ret>      2,x\n+;      <A-low>    1,x\n+;      <A-high>   0,x\n+;\n+__mulhi32:\n+\tpshb\n+\tpsha\n+\ttsx\n+\tldab\t4,x\n+\tmul\n+\txgdy\t\t\t; A.high * B.high\n+\tldab\t5,x\n+\tpula\n+\tmul\t\t\t; A.high * B.low\n+\tstd\t*_.tmp\n+\tldaa\t1,x\n+\tldab\t4,x\n+\tmul\t\t\t; A.low * B.high\n+\taddd\t*_.tmp\n+\tstab\t*_.tmp\n+\ttab\n+\taby\n+\tbcc\tN\n+\tldab\t#0xff\n+\taby\n+\tiny\n+N:\n+\tldab\t5,x\n+\tpula\n+\tmul\t\t\t; A.low * B.low\n+\tadda\t*_.tmp\n+\tbcc\tRet\n+\tiny\n+Ret:\n+\tpshy\n+\tpulx\n+\trts\n+\t\n+#endif\n+\n+#ifdef L_mulsi3\n+\t.sect .text\n+\t.globl __mulsi3\n+\n+;\n+;      <B-low>    8,y\n+;      <B-high>   6,y\n+;      <ret>      4,y\n+;\t<tmp>\t  2,y\n+;      <A-low>    0,y\n+;\n+; D,X   -> A\n+; Stack -> B\n+;\n+; The result is:\n+;\n+;\t(((A.low * B.high) + (A.high * B.low)) << 16) + (A.low * B.low)\n+;\n+;\n+;\n+\n+B_low\t=\t8\n+B_high\t=\t6\n+A_low\t=\t0\n+A_high\t=\t2\n+__mulsi3:\n+\tpshx\n+\tpshb\n+\tpsha\n+\ttsy\n+;\n+; If B.low is 0, optimize into: (A.low * B.high) << 16\n+;\n+\tldd\tB_low,y\n+\tbeq\tB_low_zero\n+;\n+; If A.high is 0, optimize into: (A.low * B.high) << 16 + (A.low * B.low)\n+;\n+\tstx\t*_.tmp\n+\tbeq\tA_high_zero\n+\tbsr\t___mulhi3\t\t; A.high * B.low\n+;\n+; If A.low is 0, optimize into: (A.high * B.low) << 16\n+;\n+\tldx\tA_low,y\n+\tbeq\tA_low_zero\t\t; X = 0, D = A.high * B.low\n+\tstd\t2,y\n+;\n+; If B.high is 0, we can avoid the (A.low * B.high) << 16 term.\n+;\n+\tldd\tB_high,y\n+\tbeq\tB_high_zero\n+\tbsr\t___mulhi3\t\t; A.low * B.high\n+\taddd\t2,y\n+\tstd\t2,y\n+;\n+; Here, we know that A.low and B.low are not 0.\n+;\n+B_high_zero:\n+\tldd\tB_low,y\t\t\t; A.low is on the stack\n+\tbsr\t__mulhi32\t\t; A.low * B.low\n+\txgdx\n+\ttsy\t\t\t\t; Y was clobbered, get it back\n+\taddd\t2,y\n+A_low_zero:\t\t\t\t; See A_low_zero_non_optimized below\n+\txgdx\n+Return:\n+\tins\n+\tins\n+\tins\n+\tins\n+\trts\n+;\n+; \n+; A_low_zero_non_optimized:\n+;\n+; At this step, X = 0 and D = (A.high * B.low)\n+; Optimize into: (A.high * B.low) << 16\n+;\n+;\txgdx\n+;\tclra\t\t\t; Since X was 0, clearing D is superfuous.\n+;\tclrb\n+;\tbra\tReturn\n+; ----------------\n+; B.low == 0, the result is:\t(A.low * B.high) << 16\n+;\n+; At this step:\n+;   D = B.low\t\t\t\t= 0 \n+;   X = A.high\t\t\t\t?\n+;       A.low is at A_low,y\t\t?\n+;       B.low is at B_low,y\t\t?\n+;\n+B_low_zero:\n+\tldd\tA_low,y\n+\tbeq\tZero1\n+\tldx\tB_high,y\n+\tbeq\tZero2\n+\tbsr\t___mulhi3\n+Zero1:\n+\txgdx\n+Zero2:\n+\tclra\n+\tclrb\n+\tbra\tReturn\n+; ----------------\n+; A.high is 0, optimize into: (A.low * B.high) << 16 + (A.low * B.low)\n+;\n+; At this step:\n+;   D = B.low\t\t\t\t!= 0 \n+;   X = A.high\t\t\t\t= 0\n+;       A.low is at A_low,y\t\t?\n+;       B.low is at B_low,y\t\t?\n+;\n+A_high_zero:\n+\tldd\tA_low,y\t\t; A.low\n+\tbeq\tZero1\n+\tldx\tB_high,y\t; B.high\n+\tbeq\tA_low_B_low\n+\tbsr\t___mulhi3\n+\tstd\t2,y\n+\tbra\tB_high_zero\t; Do the (A.low * B.low) and the add.\n+\n+; ----------------\n+; A.high and B.high are 0 optimize into: (A.low * B.low)\n+;\n+; At this step:\n+;   D = B.high\t\t\t\t= 0 \n+;   X = A.low\t\t\t\t!= 0\n+;       A.low is at A_low,y\t\t!= 0\n+;       B.high is at B_high,y\t\t= 0\n+;\n+A_low_B_low:\n+\tldd\tB_low,y\t\t\t; A.low is on the stack\n+\tbsr\t__mulhi32\n+\tbra\tReturn\n+#endif\n+\n+#ifdef L_map_data\n+\n+\t.sect\t.install3,\"ax\",@progbits\n+\t.globl\t__map_data_section\n+\n+__map_data_section:\n+\tldd\t#__data_section_size\n+\tbeq\tDone\n+\tldx\t#__data_image\n+\tldy\t#__data_section_start\n+Loop:\n+\tpsha\n+\tldaa\t0,x\n+\tstaa\t0,y\n+\tpula\n+\tinx\n+\tiny\n+\tsubd\t#1\n+\tbne\tLoop\n+Done:\n+\n+#endif\n+\n+#ifdef L_init_bss\n+\n+\t.sect\t.install3,\"ax\",@progbits\n+\t.globl\t__init_bss_section\n+\n+__init_bss_section:\n+\tldd\t#__bss_size\n+\tbeq\tDone\n+\tldx\t#__bss_start\n+Loop:\n+\tclr\t0,x\n+\tinx\n+\tsubd\t#1\n+\tbne\tLoop\n+Done:\n+\n+#endif\n+\t\n+;-----------------------------------------\n+; end required gcclib code\n+;-----------------------------------------"}, {"sha": "2e6a14476b9ae5253cf79739629a8e7f1fa8affd", "filename": "gcc/config/m68hc11/m68hc11-crt0.S", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-crt0.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-crt0.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-crt0.S?ref=385c92176c8fe88def705968cfb05d3a6ae8df4b", "patch": "@@ -0,0 +1,87 @@\n+/* Startup code for M68HC11.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file with other programs, and to distribute\n+those programs without any restriction coming from the use of this\n+file.  (The General Public License restrictions do apply in other\n+respects; for example, they cover modification of the file, and\n+distribution when not linked into another program.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\t\n+;-----------------------------------------\n+; startup code\n+;-----------------------------------------\n+\t.file\t\"crt0.s\"\n+\n+;; \n+;; \n+;; The linker concatenate the .install* sections in the following order:\n+;; \n+;; .install0\tSetup the stack pointer\n+;; .install1\tPlace holder for applications\n+;; .install2\tOptional installation of data section in memory\n+;; .install3\tPlace holder for applications\n+;; .install4\tInvokes the main\n+;; \n+\t.sect   .install0,\"ax\",@progbits\n+\t.globl _start\n+\n+_start:\n+;;\n+;; At this step, the stack is not initialized and interrupts are masked.\n+;; Applications only have 64 cycles to initialize some registers.\n+;;\n+;; To have a generic/configurable startup, initialize the stack to\n+;; the end of some memory region.  The _stack symbol is defined by\n+;; the linker.\n+;;\n+\tlds\t#_stack\n+\t\n+\t.sect\t.install2,\"ax\",@progbits\n+;;\n+;; Call a specific initialization operation.  The default is empty.\n+;; It can be overriden by applications.  It is intended to initialize\n+;; the 68hc11 registers.  Function prototype is:\n+;; \n+;;\tint __premain(void);\n+;; \n+\tjsr\t__premain\n+\t\n+;;\n+;; \n+;;\n+\t.sect\t.install4,\"ax\",@progbits\n+\tjsr     main\n+fatal:\n+\tjsr\texit\n+\tbra fatal\n+\n+;-----------------------------------------\n+; end startup code\n+;-----------------------------------------\n+;; Force loading of data section mapping and bss clear\n+\t.2byte\t__map_data_section\n+\t.2byte  __init_bss_section"}, {"sha": "b63fa30f20e940fa2beea3713cfeb22f6848414f", "filename": "gcc/config/m68hc11/m68hc11-protos.h", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h?ref=385c92176c8fe88def705968cfb05d3a6ae8df4b", "patch": "@@ -0,0 +1,174 @@\n+/* Prototypes for exported functions defined in m68hc11.c\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Stephane Carrez (stcarrez@worldnet.fr)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+extern int m68hc11_override_options PARAMS((void));\n+extern void m68hc11_conditional_register_usage PARAMS((void));\n+extern int hard_regno_mode_ok PARAMS((int, enum machine_mode));\n+\n+extern int m68hc11_total_frame_size PARAMS((void));\n+extern int m68hc11_initial_frame_pointer_offset PARAMS((void));\n+extern int m68hc11_initial_elimination_offset PARAMS((int, int));\n+\n+extern void expand_prologue PARAMS((void));\n+extern void expand_epilogue PARAMS((void));\n+extern void output_function_prologue PARAMS((FILE*, int));\n+extern void output_function_epilogue PARAMS((FILE*, int));\n+extern int m68hc11_function_block_profiler PARAMS((FILE*,int));\n+\n+extern int m68hc11_block_profiler PARAMS((FILE*,int));\n+\n+extern void m68hc11_asm_file_start PARAMS((FILE*, char*));\n+\n+#ifdef TREE_CODE\n+extern void m68hc11_function_arg_advance PARAMS((CUMULATIVE_ARGS*,\n+                                                 enum machine_mode,\n+                                                 tree,\n+                                                 int));\n+extern int m68hc11_valid_decl_attribute_p PARAMS((tree, tree,\n+\t\t\t\t\t          tree, tree));\n+extern int m68hc11_valid_type_attribute_p PARAMS((tree, tree,\n+\t\t\t\t\t\t  tree, tree));\n+extern int m68hc11_comp_type_attributes PARAMS((tree, tree));\n+extern void m68hc11_set_default_type_attributes PARAMS((tree));\n+extern void m68hc11_encode_section_info PARAMS((tree));\n+#endif\n+\n+#ifdef RTX_CODE\n+#if GCC_VERSION > 2095\n+extern rtx m68hc11_compare_op0;\n+extern rtx m68hc11_compare_op1;\n+#endif\n+\n+extern rtx m68hc11_soft_tmp_reg;\n+extern rtx iy_reg;\n+extern rtx d_reg;\n+\n+extern rtx m68hc11_expand_compare_and_branch PARAMS((enum rtx_code,\n+                                                     rtx, rtx, rtx));\n+extern enum reg_class preferred_reload_class PARAMS((rtx, enum reg_class));\n+\n+extern int m68hc11_go_if_legitimate_address PARAMS((rtx,\n+                                                    enum machine_mode,\n+                                                    int));\n+\n+extern int m68hc11_legitimize_address PARAMS((rtx*, rtx, enum machine_mode));\n+\n+extern void m68hc11_notice_update_cc PARAMS((rtx, rtx));\n+\n+extern void m68hc11_reorg PARAMS((rtx));\n+\n+extern void m68hc11_gen_movqi PARAMS((rtx, rtx*));\n+extern void m68hc11_gen_movhi PARAMS((rtx, rtx*));\n+extern void m68hc11_gen_rotate PARAMS((enum rtx_code, rtx, rtx*));\n+\n+extern void m68hc11_output_swap PARAMS((rtx,rtx*));\n+\n+extern int next_insn_test_reg PARAMS((rtx,rtx));\n+\n+extern void print_operand PARAMS((FILE*,rtx,int));\n+extern void print_operand_address PARAMS((FILE*,rtx));\n+\n+extern int m68hc11_reload_operands PARAMS((rtx*));\n+\n+extern int dead_register_here PARAMS((rtx, rtx));\n+\n+extern int push_pop_operand_p PARAMS((rtx));\n+extern void m68hc11_split_move PARAMS((rtx, rtx, rtx));\n+extern void m68hc11_split_compare_and_branch PARAMS((enum rtx_code,\n+                                                     rtx, rtx, rtx));\n+extern void aux_restore_IX_IY PARAMS((rtx));\n+extern void aux_validate_IX_IY PARAMS((rtx));\n+\n+extern rtx m68hc11_gen_lowpart PARAMS((enum machine_mode, rtx));\n+extern rtx m68hc11_gen_highpart PARAMS((enum machine_mode, rtx));\n+\n+#ifdef HAVE_MACHINE_MODES\n+extern int m68hc11_memory_move_cost PARAMS((enum machine_mode, enum reg_class,\n+                                           int));\n+extern int m68hc11_register_move_cost PARAMS((enum reg_class, enum reg_class));\n+extern int m68hc11_rtx_costs PARAMS((rtx, enum rtx_code, enum rtx_code));\n+extern int m68hc11_address_cost PARAMS((rtx));\n+\n+\n+extern void m68hc11_emit_libcall PARAMS((const char*, enum rtx_code,\n+                                         enum machine_mode, enum machine_mode,\n+                                         int, rtx*));\n+extern int m68hc11_small_indexed_indirect_p PARAMS((rtx, enum machine_mode));\n+extern int go_if_legitimate_address2 PARAMS((rtx, enum machine_mode, int));\n+\n+extern int reg_or_indexed_operand PARAMS((rtx,enum machine_mode));\n+extern int tst_operand PARAMS((rtx,enum machine_mode));\n+extern int cmp_operand PARAMS((rtx,enum machine_mode));\n+extern int memory_indexed_operand PARAMS((rtx, enum machine_mode));\n+\n+extern void m68hc11_split_logical PARAMS((enum machine_mode, int, rtx*));\n+\n+extern int m68hc11_register_indirect_p PARAMS((rtx, enum machine_mode));\n+\n+extern int symbolic_memory_operand PARAMS((rtx, enum machine_mode));\n+\n+extern int memory_reload_operand PARAMS((rtx, enum machine_mode));\n+extern int stack_register_operand PARAMS((rtx, enum machine_mode));\n+extern int d_register_operand PARAMS((rtx, enum machine_mode));\n+extern int hard_addr_reg_operand PARAMS((rtx, enum machine_mode));\n+extern int arith_src_operand PARAMS((rtx, enum machine_mode));\n+extern int m68hc11_logical_operator PARAMS((rtx, enum machine_mode));\n+extern int m68hc11_arith_operator PARAMS((rtx, enum machine_mode));\n+extern int m68hc11_non_shift_operator PARAMS((rtx, enum machine_mode));\n+extern int m68hc11_unary_operator PARAMS((rtx, enum machine_mode));\n+extern int non_push_operand PARAMS((rtx, enum machine_mode));\n+extern int hard_reg_operand PARAMS((rtx, enum machine_mode));\n+extern int soft_reg_operand PARAMS((rtx, enum machine_mode));\n+extern int reg_or_some_mem_operand PARAMS((rtx, enum machine_mode));\n+\n+extern enum reg_class limit_reload_class PARAMS((enum machine_mode, enum reg_class));\n+\n+#if defined TREE_CODE\n+extern void m68hc11_init_cumulative_args PARAMS((CUMULATIVE_ARGS*,\n+                                                 tree,\n+                                                 rtx));\n+\n+extern rtx m68hc11_function_arg PARAMS((const CUMULATIVE_ARGS* ,\n+                                        enum machine_mode,\n+                                        tree, int));\n+extern int m68hc11_function_arg_pass_by_reference PARAMS((const CUMULATIVE_ARGS*,\n+                                                          enum machine_mode,\n+                                                          tree,\n+                                                          int));\n+extern int m68hc11_function_arg_padding PARAMS((enum machine_mode, tree));\n+\n+extern void m68hc11_expand_builtin_va_start PARAMS((int, tree, rtx));\n+\n+extern rtx m68hc11_va_arg PARAMS((tree,tree));\n+extern void m68hc11_expand_builtin_va_start PARAMS((int,tree,rtx));\n+\n+extern void m68hc11_function_epilogue PARAMS((FILE*,int));\n+\n+#endif /* TREE_CODE */\n+\n+#if GCC_VERSION > 2095\n+extern HOST_WIDE_INT m68hc11_min_offset;\n+extern HOST_WIDE_INT m68hc11_max_offset;\n+#endif\n+#endif /* HAVE_MACHINE_MODES */\n+#endif /* RTX_CODE */\n+"}, {"sha": "787ddd1522dc73868529413706a7c8a1606a350f", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "added", "additions": 5067, "deletions": 0, "changes": 5067, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=385c92176c8fe88def705968cfb05d3a6ae8df4b"}, {"sha": "f802b20f58abf76684a2edafe1ac75b5d1b3b626", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "added", "additions": 1895, "deletions": 0, "changes": 1895, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=385c92176c8fe88def705968cfb05d3a6ae8df4b", "patch": "@@ -0,0 +1,1895 @@\n+/* Definitions of target machine for GNU compiler.\n+   Motorola 68HC11 and 68HC12.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Stephane Carrez (stcarrez@worldnet.fr)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+Note:\n+   A first 68HC11 port was made by Otto Lind (otto@coactive.com)\n+   on gcc 2.6.3.  I have used it as a starting point for this port.\n+   However, this new port is a complete re-write.  Its internal\n+   design is completely different.  The generated code is not\n+   compatible with the gcc 2.6.3 port.\n+\n+   The gcc 2.6.3 port is available at:\n+\n+   ftp.unina.it/pub/electronics/motorola/68hc11/gcc/gcc-6811-fsf.tar.gz\n+\n+*/\n+\n+#undef GCC_VERSION\n+#if 1 /* def N_*/\n+# define GCC_VERSION 2096\n+#else\n+# define GCC_VERSION 2095\n+\n+/* NLS support in 2.96 */\n+# define N_(X) X\n+#endif\n+\n+#include \"elfos.h\"\n+\n+/*****************************************************************************\n+**\n+** Controlling the Compilation Driver, `gcc'\n+**\n+*****************************************************************************/\n+\n+#undef ENDFILE_SPEC\n+\n+/* Compile and assemble for a 68hc11 unless there is a -m68hc12 option.  */\n+#ifndef ASM_SPEC\n+#define ASM_SPEC       \"%{m68hc12:-m68hc12}%{!m68hc12:-m68hc11}\"\n+#endif\n+\n+/* We need to tell the linker the target elf format.  Just pass an\n+   emulation option.  This can be overriden by -Wl option of gcc.  */\n+#ifndef LINK_SPEC\n+#define LINK_SPEC      \"%{m68hc12:-m m68hc12elf}%{!m68hc12:-m m68hc11elf}\"\n+#endif\n+\n+#ifndef LIB_SPEC\n+#define LIB_SPEC       \"\"\n+#endif\n+\n+#ifndef CC1_SPEC\n+#define CC1_SPEC       \"\"\n+#endif\n+\n+#ifndef CPP_SPEC\n+#define CPP_SPEC  \\\n+\"%{mshort:-D__HAVE_SHORT_INT__ -D__INT__=16 -D__INT_MAX__=32767}\\\n+ %{!mshort:-D__INT__=32 -D__INT_MAX__=2147483647}\\\n+ %{m68hc12:-Dmc6812 -DMC6812 -Dmc68hc12}\\\n+ %{!m68hc12:-Dmc6811 -DMC6811 -Dmc68hc11}\"\n+#endif\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \"crt1%O%s\"\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+#define CPP_PREDEFINES\t\t\"-Dmc68hc1x\"\n+\n+\n+#ifndef IN_LIBGCC2\n+#  include <stdio.h>\n+#endif\n+\n+#include \"gansidecl.h\"\n+\n+#if GCC_VERSION == 2095\n+#ifndef PARAMS\n+#if defined(ANSI_PROTOTYPES) || defined(__cplusplus)\n+#define PARAMS(args) args\n+#else\n+#define PARAMS(args) ()\n+#endif\n+#endif\n+\n+/* Forward type declaration for prototypes definitions.\n+   rtx_ptr is equivalent to rtx. Can't use the same name. */\n+struct rtx_def;\n+typedef struct rtx_def *rtx_ptr;\n+\n+union tree_node;\n+typedef union tree_node *tree_ptr;\n+\n+/* We can't declare enum machine_mode forward nor include 'machmode.h' here.\n+   Prototypes defined here will use an int instead. It's better than no\n+   prototype at all. */\n+\n+typedef int enum_machine_mode;\n+#endif\n+\n+/*****************************************************************************\n+**\n+** Run-time Target Specification\n+**\n+*****************************************************************************/\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+extern short *reg_renumber;\t/* def in local_alloc.c */\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+/* 6811 specific options\n+ *\n+ * For 68HC12, the auto inc/dec mode is disabled by default. The reason\n+ * is that for most programs, the reload pass will fail because it needs\n+ * more registers to save the value of the indexed register after the\n+ * memory access.  For simple programs, you can enable this\n+ * with -mauto-incdec.\n+ */\n+\n+#define MASK_SHORT              0002\t/* Compile with 16-bit `int' */\n+#define MASK_AUTO_INC_DEC       0004\n+#define MASK_M6811              0010\n+#define MASK_M6812              0020\n+\n+#define TARGET_OP_TIME\t\t(optimize && optimize_size == 0)\n+#define TARGET_SHORT            (target_flags & MASK_SHORT)\n+#define TARGET_M6811            (target_flags & MASK_M6811)\n+#define TARGET_M6812            (target_flags & MASK_M6812)\n+#define TARGET_AUTO_INC_DEC     (target_flags & MASK_AUTO_INC_DEC)\n+\n+/* Default target_flags if no switches specified.  */\n+#ifndef TARGET_DEFAULT\n+# define TARGET_DEFAULT\t\t(MASK_M6811)\n+#endif\n+\n+/* Define this macro as a C expression for the initializer of an\n+   array of string to tell the driver program which options are\n+   defaults for this target and thus do not need to be handled\n+   specially when using `MULTILIB_OPTIONS'.  */\n+#ifndef MULTILIB_DEFAULTS\n+# if TARGET_DEFAULT & MASK_M6811\n+#  define MULTILIB_DEFAULTS { \"m68hc11\" }\n+# else\n+#  define MULTILIB_DEFAULTS { \"m68hc12\" }\n+# endif\n+#endif\n+\n+/* Macro to define tables used to set the flags. This is a list in braces of\n+   pairs in braces, each pair being { \"NAME\", VALUE } where VALUE is the bits\n+   to set or minus the bits to clear. An empty string NAME is used to\n+   identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES\t\t\t\t\t\t\\\n+{ { \"short\", MASK_SHORT,\t\t\t\t\t\\\n+    N_(\"Compile with 16-bit integer mode\")},\t\t\t\\\n+  { \"noshort\", - MASK_SHORT,\t\t\t\t\t\\\n+    N_(\"Compile with 32-bit integer mode\")},\t\t\t\\\n+  { \"auto-incdec\", MASK_AUTO_INC_DEC,\t\t\t\t\\\n+    N_(\"Auto pre/post decrement increment allowed\")},\t\t\\\n+  { \"noauto-incdec\", - MASK_AUTO_INC_DEC,\t\t\t\\\n+    N_(\"Auto pre/post decrement increment not allowed\")},\t\\\n+  { \"68hc11\", MASK_M6811,\t\t\t\t\t\\\n+    N_(\"Compile for a 68HC11\")},\t\t\t\t\\\n+  { \"68hc12\", MASK_M6812,\t\t\t\t\t\\\n+    N_(\"Compile for a 68HC12\")},\t\t\t\t\\\n+  { \"6811\",   MASK_M6811,\t\t\t\t\t\\\n+    N_(\"Compile for a 68HC11\")},\t\t\t\t\\\n+  { \"6812\",   MASK_M6812,\t\t\t\t\t\\\n+    N_(\"Compile for a 68HC12\")},\t\t\t\t\\\n+  { \"\", TARGET_DEFAULT, 0 }}\n+\n+/* This macro is similar to `TARGET_SWITCHES' but defines names of\n+   command options that have values.  Its definition is an\n+   initializer with a subgrouping for each command option.\n+\n+   Each subgrouping contains a string constant, that defines the\n+   fixed part of the option name, and the address of a variable.  The\n+   variable, type `char *', is set to the variable part of the given\n+   option if the fixed part matches.  The actual option name is made\n+   by appending `-m' to the specified name.  */\n+#define TARGET_OPTIONS\t\t\t\t\t\t\t\\\n+{ { \"reg-alloc=\",\t&m68hc11_reg_alloc_order,                       \\\n+    N_(\"Specify the register allocation order\")},\t\t\t\\\n+  { \"soft-reg-count=\",\t&m68hc11_soft_reg_count,                        \\\n+    N_(\"Indicate the number of soft registers available\") },\t\t\\\n+  SUBTARGET_OPTIONS\t\t\t\t\t\t\t\\\n+}\n+\n+/* These are meant to be redefined in the host dependent files */\n+#define SUBTARGET_SWITCHES\n+#define SUBTARGET_OPTIONS\n+\n+extern const char *m68hc11_regparm_string;\n+extern const char *m68hc11_reg_alloc_order;\n+extern const char *m68hc11_soft_reg_count;\n+\n+#ifndef TARGET_M68HC12\n+# define TARGET_M68HC11 1\n+#endif\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+#define TARGET_VERSION\t\tfprintf (stderr, \" (MC68HC11/MC68HC12)\")\n+\n+/* Sometimes certain combinations of command options do not make\n+   sense on a particular target machine.  You can define a macro\n+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n+   defined, is executed once just after all the command options have\n+   been parsed.\n+\n+   Don't use this macro to turn on various extra optimizations for\n+   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n+\n+#define OVERRIDE_OPTIONS\tm68hc11_override_options ();\n+\f\n+\n+/* target machine storage layout */\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+#define BYTES_BIG_ENDIAN \t1\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields. */\n+#define BITS_BIG_ENDIAN         0\n+\n+/* Define this if most significant word of a multiword number is numbered.  */\n+#define WORDS_BIG_ENDIAN \t1\n+\n+/* Number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT\t\t8\n+\n+/* Number of bits in a word */\n+#define BITS_PER_WORD\t\t16\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD\t\t(BITS_PER_WORD/8)\n+\n+/* Define if you don't want extended real, but do want to use the\n+   software floating point emulator for REAL_ARITHMETIC and\n+   decimal <-> binary conversion.  */\n+#define REAL_ARITHMETIC\n+\n+/* Width in bits of a pointer.  See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE\t\t16\n+\n+/* Definition of size_t.  This is really an unsigned short as the\n+   68hc11 only handles a 64K address space.  */\n+#define SIZE_TYPE               \"short unsigned int\"\n+\n+/* A C expression for a string describing the name of the data type\n+   to use for the result of subtracting two pointers.  The typedef\n+   name `ptrdiff_t' is defined using the contents of the string.\n+   The 68hc11 only has a 64K address space.  */\n+#define PTRDIFF_TYPE            \"short int\"\n+\n+/* Allocation boundary (bits) for storing pointers in memory.  */\n+#define POINTER_BOUNDARY\t8\n+\n+/* Normal alignment required for function parameters on the stack, in bits.\n+   This can't be less than BITS_PER_WORD */\n+#define PARM_BOUNDARY\t\t(BITS_PER_WORD)\n+\n+/* Boundary (bits) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY\t\t8\n+\n+/* Allocation boundary (bits) for the code of a function.  */\n+#define FUNCTION_BOUNDARY\t8\n+\n+/* Biggest alignment that any data type can require on this machine,\n+   in bits. */\n+#define BIGGEST_ALIGNMENT\t8\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY\t8\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* Define this if instructions will fail to work if given data not\n+   on the nominal alignment.  If instructions will merely go slower\n+   in that case, do not define this macro.  */\n+#define STRICT_ALIGNMENT\t0\n+\n+/* An integer expression for the size in bits of the largest integer\n+   machine mode that should actually be used.  All integer machine modes of\n+   this size or smaller can be used for structures and unions with the\n+   appropriate sizes.  */\n+#define MAX_FIXED_MODE_SIZE\t64\n+\n+/* Floats are checked in a generic way. */\n+/* #define CHECK_FLOAT_VALUE(MODE, D, OVERFLOW) */\n+\n+\n+\f\n+/* target machine storage layout */\n+\n+/* Size (bits) of the type \"int\" on target machine\n+   (If undefined, default is BITS_PER_WORD).  */\n+#define INT_TYPE_SIZE           (TARGET_SHORT ? 16 : 32)\n+\n+/* Size (bits) of the type \"short\" on target machine */\n+#define SHORT_TYPE_SIZE\t\t16\n+\n+/* Size (bits) of the type \"long\" on target machine */\n+#define LONG_TYPE_SIZE\t\t32\n+\n+/* Size (bits) of the type \"long long\" on target machine */\n+#define LONG_LONG_TYPE_SIZE     64\n+\n+/* Size (bits) of the type \"char\" on target machine */\n+#define CHAR_TYPE_SIZE\t\t8\n+\n+/* A C expression for the size in bits of the type `float' on the\n+   target machine. If you don't define this, the default is one word.\n+   Don't use default: a word is only 16.  */\n+#define FLOAT_TYPE_SIZE         32\n+\n+/* A C expression for the size in bits of the type double on the target\n+   machine. If you don't define this, the default is two words.\n+   Be IEEE compliant.  */\n+#define DOUBLE_TYPE_SIZE        64\n+\n+#define LONG_DOUBLE_TYPE_SIZE   64\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR\t0\n+\n+/* Define these to avoid dependence on meaning of `int'.\n+   Note that WCHAR_TYPE_SIZE is used in cexp.y,\n+   where TARGET_SHORT is not available.  */\n+#define WCHAR_TYPE              \"short int\"\n+#define WCHAR_TYPE_SIZE         16\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL\t\t007\n+#define TARGET_BS\t\t010\n+#define TARGET_TAB\t\t011\n+#define TARGET_NEWLINE\t\t012\n+#define TARGET_VT\t\t013\n+#define TARGET_FF\t\t014\n+#define TARGET_CR\t\t015\n+\f\n+\n+/* Standard register usage.  */\n+\n+#define HARD_REG_SIZE           (UNITS_PER_WORD)\n+\n+/* Assign names to real MC68HC11 registers.\n+   A and B registers are not really used (A+B = D)\n+   X register is first so that GCC allocates X+D for 32-bit integers and\n+   the lowpart of that integer will be D.  Having the lower part in D is\n+   better for 32<->16bit conversions and for many arithmetic operations.  */\n+#define HARD_X_REGNUM\t\t0\n+#define HARD_D_REGNUM\t\t1\n+#define HARD_Y_REGNUM\t\t2\n+#define HARD_SP_REGNUM\t\t3\n+#define HARD_PC_REGNUM\t\t4\n+#define HARD_A_REGNUM\t\t5\n+#define HARD_B_REGNUM\t\t6\n+#define HARD_CCR_REGNUM\t\t7\n+\n+/* The Z register does not really exist in the 68HC11.  This a fake register\n+   for GCC.  It is treated exactly as an index register (X or Y).  It is only\n+   in the A_REGS class, which is the BASE_REG_CLASS for GCC.  Defining this\n+   register helps the reload pass of GCC.  Otherwise, the reload often aborts\n+   with register spill failures.\n+\n+   The Z register is replaced by either X or Y during the machine specific\n+   reorg (m68hc11_reorg).  It is saved in the SOFT_Z_REGNUM soft-register\n+   when this is necessary.\n+\n+   It's possible to tell GCC not to use this register with -ffixed-z.  */\n+#define HARD_Z_REGNUM           8\n+\n+/* The frame pointer is a soft-register.  It's treated as such by GCC:\n+   it is not and must not be part of the BASE_REG_CLASS.  */\n+#define DEFAULT_HARD_FP_REGNUM  (9)\n+#define HARD_FP_REGNUM\t\t(9)\n+#define HARD_AP_REGNUM\t\t(HARD_FP_REGNUM)\n+\n+/* Temporary soft-register used in some cases when an operand came\n+   up into a bad register class (D, X, Y, SP) and gcc failed to\n+   recognize this. This register is never allocated by GCC.  */\n+#define SOFT_TMP_REGNUM          10\n+\n+/* The soft-register which is used to save the Z register\n+   (see Z register replacement notes in m68hc11.c).  */\n+#define SOFT_Z_REGNUM            11\n+\n+/* The soft-register which is used to save either X or Y. */\n+#define SOFT_SAVED_XY_REGNUM     12\n+\n+/* A fake clobber register for 68HC12 patterns.  */\n+#define FAKE_CLOBBER_REGNUM     (13)\n+\n+/* Define 32 soft-registers of 16-bit each.  By default,\n+   only 12 of them are enabled and can be used by GCC.  The\n+   -msoft-reg-count=<n> option allows to control the number of valid\n+   soft-registers. GCC can put 32-bit values in them\n+   by allocating consecutive registers.  The first 3 soft-registers\n+   are never allocated by GCC.  They are used in case the insn template needs\n+   a temporary register, or for the Z register replacement.  */\n+\n+#define MAX_SOFT_REG_COUNT      (32)\n+#define SOFT_REG_FIXED          0, 0, 0, 0, 0, 0, 0, 0, \\\n+\t\t\t\t0, 0, 0, 0, 1, 1, 1, 1, \\\n+\t\t\t\t1, 1, 1, 1, 1, 1, 1, 1, \\\n+\t\t\t\t1, 1, 1, 1, 1, 1, 1, 1\n+#define SOFT_REG_USED           0, 0, 0, 0, 0, 0, 0, 0, \\\n+\t\t\t\t0, 0, 0, 0, 1, 1, 1, 1, \\\n+\t\t\t\t1, 1, 1, 1, 1, 1, 1, 1, \\\n+\t\t\t\t1, 1, 1, 1, 1, 1, 1, 1\n+#define SOFT_REG_ORDER\t\t\\\n+SOFT_REG_FIRST, SOFT_REG_FIRST+1,SOFT_REG_FIRST+2,SOFT_REG_FIRST+3,\\\n+SOFT_REG_FIRST+4, SOFT_REG_FIRST+5,SOFT_REG_FIRST+6,SOFT_REG_FIRST+7,\\\n+SOFT_REG_FIRST+8, SOFT_REG_FIRST+9,SOFT_REG_FIRST+10,SOFT_REG_FIRST+11,\\\n+SOFT_REG_FIRST+12, SOFT_REG_FIRST+13,SOFT_REG_FIRST+14,SOFT_REG_FIRST+15,\\\n+SOFT_REG_FIRST+16, SOFT_REG_FIRST+17,SOFT_REG_FIRST+18,SOFT_REG_FIRST+19,\\\n+SOFT_REG_FIRST+20, SOFT_REG_FIRST+21,SOFT_REG_FIRST+22,SOFT_REG_FIRST+23,\\\n+SOFT_REG_FIRST+24, SOFT_REG_FIRST+25,SOFT_REG_FIRST+26,SOFT_REG_FIRST+27,\\\n+SOFT_REG_FIRST+28, SOFT_REG_FIRST+29,SOFT_REG_FIRST+30,SOFT_REG_FIRST+31\n+\n+#define SOFT_REG_NAMES\t\t\t\t\t\t\t\\\n+\"*_.d1\",  \"*_.d2\",  \"*_.d3\",  \"*_.d4\", \\\n+\"*_.d5\",  \"*_.d6\",  \"*_.d7\",  \"*_.d8\",\t\\\n+\"*_.d9\",  \"*_.d10\", \"*_.d11\", \"*_.d12\", \\\n+\"*_.d13\", \"*_.d14\", \"*_.d15\", \"*_.d16\",\t\\\n+\"*_.d17\", \"*_.d18\", \"*_.d19\", \"*_.d20\", \\\n+\"*_.d21\", \"*_.d22\", \"*_.d23\", \"*_.d24\", \\\n+\"*_.d25\", \"*_.d26\", \"*_.d27\", \"*_.d28\", \\\n+\"*_.d29\", \"*_.d30\", \"*_.d31\", \"*_.d32\"\n+\n+/* First available soft-register for GCC. */\n+#define SOFT_REG_FIRST          (SOFT_SAVED_XY_REGNUM+2)\n+\n+/* Last available soft-register for GCC. */\n+#define SOFT_REG_LAST           (SOFT_REG_FIRST+MAX_SOFT_REG_COUNT)\n+#define SOFT_FP_REGNUM\t\t(SOFT_REG_LAST)\n+#define SOFT_AP_REGNUM\t\t(SOFT_FP_REGNUM+1)\n+\n+/* Number of actual hardware registers. The hardware registers are assigned\n+   numbers for the compiler from 0 to just below FIRST_PSEUDO_REGISTER. \n+   All registers that the compiler knows about must be given numbers, even\n+   those that are not normally considered general registers. */\n+#define FIRST_PSEUDO_REGISTER\t(SOFT_REG_LAST+2)\n+\n+/* 1 for registers that have pervasive standard uses and are not available\n+   for the register allocator. */\n+#define FIXED_REGISTERS \\\n+  {0, 0, 0, 1, 1, 1, 1, 1,   0, 1,  1,   1,1, 1, SOFT_REG_FIXED, 1, 1}\n+/* X, D, Y, SP,PC,A, B, CCR, Z, FP,ZTMP,ZR,XYR, FK, D1 - D32, SOFT-FP, AP */\n+\n+/* 1 for registers not available across function calls. For our pseudo\n+   registers, all are available.  */\n+#define CALL_USED_REGISTERS \\\n+  {1, 1, 1, 1, 1, 1, 1, 1,   1, 1,  1,   1,1, 1, SOFT_REG_USED, 1, 1}\n+/* X, D, Y, SP,PC,A, B, CCR, Z, FP, ZTMP,ZR,XYR, D1 - 32,     SOFT-FP, AP */\n+\n+\n+/* Define this macro to change register usage conditional on target flags.\n+\n+   The soft-registers are disabled or enabled according to the\n+  -msoft-reg-count=<n> option. */\n+\n+\n+#define CONDITIONAL_REGISTER_USAGE (m68hc11_conditional_register_usage ())\n+\n+/* List the order in which to allocate registers.  Each register must be\n+   listed once, even those in FIXED_REGISTERS.  */\n+#define REG_ALLOC_ORDER\t\t\t\t\t\t\t\\\n+{ HARD_D_REGNUM, HARD_X_REGNUM, HARD_Y_REGNUM,\t\t\t\t\\\n+  SOFT_REG_ORDER, HARD_Z_REGNUM, HARD_PC_REGNUM, HARD_A_REGNUM,\t\t\\\n+  HARD_B_REGNUM, HARD_CCR_REGNUM, HARD_FP_REGNUM, SOFT_FP_REGNUM,\t\\\n+  HARD_SP_REGNUM, SOFT_TMP_REGNUM, SOFT_Z_REGNUM, SOFT_SAVED_XY_REGNUM, \\\n+  SOFT_AP_REGNUM, FAKE_CLOBBER_REGNUM  }\n+\n+/* A C expression for the number of consecutive hard registers,\n+   starting at register number REGNO, required to hold a value of\n+   mode MODE.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE) \\\n+((Q_REGNO_P (REGNO)) ? (GET_MODE_SIZE (MODE)) : \\\n+   ((GET_MODE_SIZE (MODE) + HARD_REG_SIZE - 1) / HARD_REG_SIZE))\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+    - 8 bit values are stored anywhere (except the SP register).\n+    - 16 bit values can be stored in any register whose mode is 16\n+    - 32 bit values can be stored in D, X registers or in a soft register\n+      (except the last one because we need 2 soft registers)\n+    - Values whose size is > 32 bit are not stored in real hard\n+      registers.  They may be stored in soft registers if there are\n+      enough of them.  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+     hard_regno_mode_ok (REGNO,MODE)\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers when one has\n+   mode MODE1 and one has mode MODE2.  If HARD_REGNO_MODE_OK could produce\n+   different values for MODE1 and MODE2, for any hard reg, then this must be\n+   0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2)                   \\\n+     (((MODE1) == (MODE2))                              \\\n+      || ((MODE1) == SImode && (MODE2) == HImode)\t\\\n+      || ((MODE1) == HImode && (MODE2) == SImode))\n+\f\n+\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+/* The M68hc11 has so fiew registers that it's not possible for GCC to\n+   do any register allocation without breaking. We extend the processor\n+   registers by having soft registers. These registers are treated as\n+   hard registers by GCC but they are located in memory and accessed by page0\n+   accesses (IND mode).  */\n+enum reg_class\n+{\n+  NO_REGS,\n+  D_REGS,\t\t\t/* 16-bit data register */\n+  X_REGS,\t\t\t/* 16-bit X register */\n+  Y_REGS,\t\t\t/* 16-bit Y register */\n+  SP_REGS,\t\t\t/* 16 bit stack pointer */\n+  DA_REGS,\t\t\t/* 8-bit A reg. */\n+  DB_REGS,\t\t\t/* 8-bit B reg. */\n+  Z_REGS,\t\t\t/* 16-bit fake Z register */\n+  D8_REGS,\t\t\t/* 8-bit A or B reg. */\n+  Q_REGS,\t\t\t/* 8-bit (byte (QI)) data (A, B or D) */\n+  D_OR_X_REGS,\t\t\t/* D or X register */\n+  D_OR_Y_REGS,\t\t\t/* D or Y register */\n+  D_OR_SP_REGS,\t\t\t/* D or SP register */\n+  X_OR_Y_REGS,\t\t\t/* IX or Y register */\n+  A_REGS,\t\t\t/* 16-bit address register (X, Y, Z) */\n+  X_OR_SP_REGS,\t\t\t/* X or SP register */\n+  Y_OR_SP_REGS,\t\t\t/* Y or SP register */\n+  X_OR_Y_OR_D_REGS,\t\t/* X, Y or D */\n+  A_OR_D_REGS,\t\t\t/* X, Y, Z or D */\n+  A_OR_SP_REGS,\t\t\t/* X, Y, Z or SP */\n+  H_REGS,\t\t\t/* 16-bit hard register (D, X, Y, Z, SP) */\n+  S_REGS,\t\t\t/* 16-bit soft register */\n+  D_OR_S_REGS,\t\t\t/* 16-bit soft register or D register */\n+  X_OR_S_REGS,\t\t\t/* 16-bit soft register or X register */\n+  Y_OR_S_REGS,\t\t\t/* 16-bit soft register or Y register */\n+  SP_OR_S_REGS,\t\t\t/* 16-bit soft register or SP register */\n+  D_OR_X_OR_S_REGS,\t\t/* 16-bit soft register or D or X register */\n+  D_OR_Y_OR_S_REGS,\t\t/* 16-bit soft register or D or Y register */\n+  D_OR_SP_OR_S_REGS,\t\t/* 16-bit soft register or D or SP register */\n+  A_OR_S_REGS,\t\t\t/* 16-bit soft register or X, Y registers */\n+  D_OR_A_OR_S_REGS,\t\t/* 16-bit soft register or D, X, Y registers */\n+  TMP_REGS,\t\t\t/* 16 bit fake scratch register */\n+  D_OR_A_OR_TMP_REGS,\t\t/* General scratch register */\n+  G_REGS,\t\t\t/* 16-bit general register\n+                                   (H_REGS + soft registers) */\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+/* alias GENERAL_REGS to G_REGS. */\n+#define GENERAL_REGS\tG_REGS\n+\n+#define N_REG_CLASSES\t(int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+#define REG_CLASS_NAMES \\\n+{ \"NO_REGS\",                                    \\\n+      \"D_REGS\",                                 \\\n+      \"X_REGS\",                                 \\\n+      \"Y_REGS\",                                 \\\n+      \"SP_REGS\",                                \\\n+      \"DA_REGS\",                                \\\n+      \"DB_REGS\",                                \\\n+      \"D8_REGS\",                                \\\n+      \"Z_REGS\",                                 \\\n+      \"Q_REGS\",                                 \\\n+      \"D_OR_X_REGS\",                            \\\n+      \"D_OR_Y_REGS\",                            \\\n+      \"D_OR_SP_REGS\",                           \\\n+      \"X_OR_Y_REGS\",                            \\\n+      \"A_REGS\",                                 \\\n+      \"X_OR_SP_REGS\",                           \\\n+      \"Y_OR_SP_REGS\",                           \\\n+      \"X_OR_Y_OR_D_REGS\",                       \\\n+      \"A_OR_D_REGS\",                            \\\n+      \"A_OR_SP_REGS\",                           \\\n+      \"H_REGS\",                                 \\\n+      \"S_REGS\",                                 \\\n+      \"D_OR_S_REGS\",                            \\\n+      \"X_OR_S_REGS\",                            \\\n+      \"Y_OR_S_REGS\",                            \\\n+      \"SP_OR_S_REGS\",                           \\\n+      \"D_OR_X_OR_S_REGS\",                       \\\n+      \"D_OR_Y_OR_S_REGS\",                       \\\n+      \"D_OR_SP_OR_S_REGS\",                      \\\n+      \"A_OR_S_REGS\",                            \\\n+      \"D_OR_A_OR_S_REGS\",                       \\\n+      \"TMP_REGS\",\t\t\t\t\\\n+      \"D_OR_A_OR_TMP_REGS\",\t\t\t\\\n+      \"G_REGS\",                                 \\\n+      \"ALL_REGS\" }\n+\n+/* An initializer containing the contents of the register classes,\n+   as integers which are bit masks.  The Nth integer specifies the\n+   contents of class N.  The way the integer MASK is interpreted is\n+   that register R is in the class if `MASK & (1 << R)' is 1.  */\n+\n+/*--------------------------------------------------------------\n+   X\t\t0x00000001\n+   D\t\t0x00000002\n+   Y\t\t0x00000004\n+   SP\t\t0x00000008\n+   PC\t\t0x00000010\n+   A\t\t0x00000020\n+   B\t\t0x00000040\n+   CCR\t\t0x00000080\n+   Z\t\t0x00000100\n+   FRAME        0x00000200\n+   ZTMP\t\t0x00000400\n+   ZREG\t\t0x00000800\n+   XYREG\t0x00001000\n+   FAKE         0x00002000\n+   Di\t\t0xFFFFc000, 0x03FFF\n+   SFRAME       0x00000000, 0x04000\n+   AP           0x00000000, 0x08000\n+\n+   D_OR_X_REGS represents D+X. It is used for 32-bits numbers.\n+   A_REGS      represents a valid base register for indexing. It represents\n+\t       X,Y and the Z register.\n+   S_REGS      represents the soft-registers. This includes the hard frame\n+\t       and soft frame registers.\n+--------------------------------------------------------------*/\n+\n+#define REG_CLASS_CONTENTS \\\n+/* NO_REGS */\t\t{{ 0x00000000, 0x00000000 },\t\t\t\\\n+/* D_REGS  */\t\t { 0x00000002, 0x00000000 }, /* D */            \\\n+/* X_REGS  */\t\t { 0x00000001, 0x00000000 }, /* X */            \\\n+/* Y_REGS  */\t\t { 0x00000004, 0x00000000 }, /* Y */            \\\n+/* SP_REGS */\t\t { 0x00000008, 0x00000000 }, /* SP */           \\\n+/* DA_REGS */\t\t { 0x00000020, 0x00000000 }, /* A */            \\\n+/* DB_REGS */\t\t { 0x00000040, 0x00000000 }, /* B */            \\\n+/* D8_REGS */\t\t { 0x00000060, 0x00000000 }, /* A B */          \\\n+/* Z_REGS  */\t\t { 0x00000100, 0x00000000 }, /* Z */            \\\n+/* Q_REGS  */\t\t { 0x00000062, 0x00000000 }, /* A B D */        \\\n+/* D_OR_X_REGS */        { 0x00000003, 0x00000000 }, /* D X */          \\\n+/* D_OR_Y_REGS */        { 0x00000006, 0x00000000 }, /* D Y */          \\\n+/* D_OR_SP_REGS */       { 0x0000000A, 0x00000000 }, /* D SP */         \\\n+/* X_OR_Y_REGS  */\t { 0x00000005, 0x00000000 }, /* X Y */          \\\n+/* A_REGS  */\t\t { 0x00000105, 0x00000000 }, /* X Y Z */        \\\n+/* X_OR_SP_REGS */       { 0x00000009, 0x00000000 }, /* X SP */         \\\n+/* Y_OR_SP_REGS */       { 0x0000000C, 0x00000000 }, /* Y SP */         \\\n+/* X_OR_Y_OR_D_REGS */   { 0x00000007, 0x00000000 }, /* D X Y */        \\\n+/* A_OR_D_REGS  */       { 0x00000107, 0x00000000 }, /* D X Y Z */      \\\n+/* A_OR_SP_REGS */       { 0x0000010D, 0x00000000 }, /* X Y SP */       \\\n+/* H_REGS  */\t\t { 0x0000010F, 0x00000000 }, /* D X Y SP */     \\\n+/* S_REGS  */\t\t { 0xFFFFDE00, 0x00007FFF }, /* _.D,..,FP,Z*  */  \\\n+/* D_OR_S_REGS */\t { 0xFFFFDE02, 0x00007FFF }, /* D _.D */        \\\n+/* X_OR_S_REGS */\t { 0xFFFFDE01, 0x00007FFF }, /* X _.D */        \\\n+/* Y_OR_S_REGS */\t { 0xFFFFDE04, 0x00007FFF }, /* Y _.D */        \\\n+/* SP_OR_S_REGS */\t { 0xFFFFDE08, 0x00007FFF }, /* SP _.D */\t\\\n+/* D_OR_X_OR_S_REGS */\t { 0xFFFFDE03, 0x00007FFF }, /* D X _.D */      \\\n+/* D_OR_Y_OR_S_REGS */\t { 0xFFFFDE06, 0x00007FFF }, /* D Y _.D */      \\\n+/* D_OR_SP_OR_S_REGS */\t { 0xFFFFDE0A, 0x00007FFF }, /* D SP _.D */     \\\n+/* A_OR_S_REGS */\t { 0xFFFFDF05, 0x00007FFF }, /* X Y _.D */      \\\n+/* D_OR_A_OR_S_REGS */\t { 0xFFFFDF07, 0x00007FFF }, /* D X Y _.D */    \\\n+/* TMP_REGS  */\t         { 0x00002000, 0x00000000 }, /* FAKE */\t\t\\\n+/* D_OR_A_OR_TMP_REGS*/  { 0x00002107, 0x00000000 }, /* D X Y Z Fake */  \\\n+/* G_REGS  */\t\t { 0xFFFFFF1F, 0x00007FFF }, /* ? _.D D X Y */   \\\n+/* ALL_REGS*/\t\t { 0xFFFFFFFF, 0x00007FFF }}\n+\n+\n+/* set up a C expression whose value is a register class containing hard\n+   register REGNO */\n+#define Q_REGNO_P(REGNO)\t((REGNO) == HARD_A_REGNUM \\\n+\t\t\t\t || (REGNO) == HARD_B_REGNUM)\n+#define Q_REG_P(X)              (REG_P (X) && Q_REGNO_P (REGNO (X)))\n+\n+#define D_REGNO_P(REGNO)        ((REGNO) == HARD_D_REGNUM)\n+#define D_REG_P(X)              (REG_P (X) && D_REGNO_P (REGNO (X)))\n+\n+#define DB_REGNO_P(REGNO)       ((REGNO) == HARD_B_REGNUM)\n+#define DB_REG_P(X)             (REG_P (X) && DB_REGNO_P (REGNO (X)))\n+#define DA_REGNO_P(REGNO)       ((REGNO) == HARD_A_REGNUM)\n+#define DA_REG_P(X)             (REG_P (X) && DA_REGNO_P (REGNO (X)))\n+\n+#define X_REGNO_P(REGNO)        ((REGNO) == HARD_X_REGNUM)\n+#define X_REG_P(X)              (REG_P (X) && X_REGNO_P (REGNO (X)))\n+\n+#define Y_REGNO_P(REGNO)        ((REGNO) == HARD_Y_REGNUM)\n+#define Y_REG_P(X)              (REG_P (X) && Y_REGNO_P (REGNO (X)))\n+\n+#define SP_REGNO_P(REGNO)       ((REGNO) == HARD_SP_REGNUM)\n+#define SP_REG_P(X)             (REG_P (X) && SP_REGNO_P (REGNO (X)))\n+\n+/* Address register.  */\n+#define A_REGNO_P(REGNO)        ((REGNO) == HARD_X_REGNUM \\\n+                                 || (REGNO) == HARD_Y_REGNUM \\\n+                                 || (REGNO) == HARD_Z_REGNUM)\n+#define A_REG_P(X)              (REG_P (X) && A_REGNO_P (REGNO (X)))\n+\n+/* M68hc11 hard registers.  */\n+#define H_REGNO_P(REGNO)        (D_REGNO_P (REGNO) || A_REGNO_P (REGNO) \\\n+\t\t\t\t || SP_REGNO_P (REGNO) || Q_REGNO_P (REGNO))\n+#define H_REG_P(X)              (REG_P (X) && H_REGNO_P (REGNO (X)))\n+\n+#define FAKE_REGNO_P(REGNO)     ((REGNO) == FAKE_CLOBBER_REGNUM)\n+#define FAKE_REG_P(X)           (REG_P (X) && FAKE_REGNO_P (REGNO (X)))\n+\n+/* Soft registers (or register emulation for gcc).  The temporary register\n+   used by insn template must be part of the S_REGS class so that it\n+   matches the 'u' constraint.  */\n+#define S_REGNO_P(REGNO)        ((REGNO) >= SOFT_TMP_REGNUM \\\n+                                 && (REGNO) <= SOFT_REG_LAST \\\n+                                 && (REGNO) != FAKE_CLOBBER_REGNUM)\n+#define S_REG_P(X)              (REG_P (X) && S_REGNO_P (REGNO (X)))\n+\n+#define Z_REGNO_P(REGNO)        ((REGNO) == HARD_Z_REGNUM)\n+#define Z_REG_P(X)              (REG_P (X) && Z_REGNO_P (REGNO (X)))\n+\n+/* General register.  */\n+#define G_REGNO_P(REGNO)        (H_REGNO_P (REGNO) || S_REGNO_P (REGNO) \\\n+                                 || ((REGNO) == HARD_PC_REGNUM) \\\n+\t\t\t\t || ((REGNO) == HARD_FP_REGNUM) \\\n+\t\t\t\t || ((REGNO) == SOFT_FP_REGNUM) \\\n+\t\t\t\t || ((REGNO) == FAKE_CLOBBER_REGNUM) \\\n+\t\t\t\t || ((REGNO) == SOFT_AP_REGNUM))\n+\n+#define G_REG_P(X)              (REG_P (X) && G_REGNO_P (REGNO (X)))\n+\n+#define REGNO_REG_CLASS(REGNO) \\\n+  (D_REGNO_P (REGNO) ? D_REGS : \\\n+   (X_REGNO_P (REGNO) ? X_REGS : \\\n+    (Y_REGNO_P (REGNO) ? Y_REGS : \\\n+     (SP_REGNO_P (REGNO) ? SP_REGS : \\\n+      (Z_REGNO_P (REGNO) ? Z_REGS : \\\n+       (H_REGNO_P (REGNO) ? H_REGS : \\\n+        (FAKE_REGNO_P (REGNO) ? TMP_REGS : \\\n+\t (S_REGNO_P (REGNO) ? S_REGS : \\\n+\t  (DA_REGNO_P (REGNO) ? DA_REGS: \\\n+\t   (DB_REGNO_P (REGNO) ? DB_REGS: \\\n+            (G_REGNO_P (REGNO) ? G_REGS : ALL_REGS)))))))))))\n+\n+\n+/* Get reg_class from a letter in the machine description.  */\n+\n+extern enum reg_class m68hc11_tmp_regs_class;\n+#define REG_CLASS_FROM_LETTER(C) \\\n+   ((C) == 'a' ? DA_REGS : \\\n+    (C) == 'A' ? A_REGS : \\\n+    (C) == 'b' ? DB_REGS : \\\n+    (C) == 'B' ? X_OR_Y_REGS : \\\n+    (C) == 'd' ? D_REGS : \\\n+    (C) == 'D' ? D_OR_X_REGS : \\\n+    (C) == 'q' ? Q_REGS : \\\n+    (C) == 'h' ? H_REGS : \\\n+    (C) == 't' ? TMP_REGS : \\\n+    (C) == 'u' ? S_REGS : \\\n+    (C) == 'v' ? m68hc11_tmp_regs_class : \\\n+    (C) == 'w' ? SP_REGS : \\\n+    (C) == 'x' ? X_REGS : \\\n+    (C) == 'y' ? Y_REGS : \\\n+    (C) == 'z' ? Z_REGS : NO_REGS)\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)\tpreferred_reload_class(X,CLASS)\n+\n+\n+#define LIMIT_RELOAD_CLASS(MODE, CLASS) limit_reload_class(MODE,CLASS)\n+\n+#define SMALL_REGISTER_CLASSES 1\n+\n+/* A C expression whose value is nonzero if pseudos that have been\n+   assigned to registers of class CLASS would likely be spilled\n+   because registers of CLASS are needed for spill registers.\n+\n+   The default value of this macro returns 1 if CLASS has exactly one\n+   register and zero otherwise.  On most machines, this default\n+   should be used.  Only define this macro to some other expression\n+   if pseudo allocated by `local-alloc.c' end up in memory because\n+   their hard registers were needed for spill registers.  If this\n+   macro returns nonzero for those classes, those pseudos will only\n+   be allocated by `global.c', which knows how to reallocate the\n+   pseudo to another register.  If there would not be another\n+   register available for reallocation, you should not change the\n+   definition of this macro since the only effect of such a\n+   definition would be to slow down register allocation.  */\n+\n+#define CLASS_LIKELY_SPILLED_P(CLASS)\t\t\t\t\t\\\n+  (((CLASS) == D_REGS)\t\t\t\t\t\t\t\\\n+   || ((CLASS) == X_REGS)                                               \\\n+   || ((CLASS) == Y_REGS)                                               \\\n+   || ((CLASS) == A_REGS)                                               \\\n+   || ((CLASS) == SP_REGS)                                              \\\n+   || ((CLASS) == D_OR_X_REGS)                                          \\\n+   || ((CLASS) == D_OR_Y_REGS)                                          \\\n+   || ((CLASS) == X_OR_SP_REGS)                                         \\\n+   || ((CLASS) == Y_OR_SP_REGS)                                         \\\n+   || ((CLASS) == D_OR_SP_REGS))\n+\n+/* Return the maximum number of consecutive registers needed to represent\n+   mode MODE in a register of class CLASS.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\\\n+(((CLASS) == DA_REGS || (CLASS) == DB_REGS \\\n+   || (CLASS) == D8_REGS || (CLASS) == Q_REGS) ? GET_MODE_SIZE (MODE) \\\n+ : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   `L' is for range -65536 to 65536\n+   `M' is for values whose 16-bit low part is 0\n+   'N' is for +1 or -1.\n+   'O' is for 16 (for rotate using swap).\n+   'P' is for range -8 to 2 (used by addhi_sp)\n+\n+   'I', 'J', 'K' are not used.  */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n+  ((C) == 'L' ? (VALUE) >= -65536 && (VALUE) <= 65535 : \\\n+   (C) == 'M' ? ((VALUE) & 0x0ffffL) == 0 : \\\n+   (C) == 'N' ? ((VALUE) == 1 || (VALUE) == -1): \\\n+   (C) == 'O' ? (VALUE) == 16 : \\\n+   (C) == 'P' ? (VALUE) <= 2 && (VALUE) >= -8 : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   No floating-point constants are valid on 68HC11.  */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  0\n+\n+/* 'U' represents certain kind of memory indexed operand for 68HC12.\n+   and any memory operand for 68HC11.  */\n+#define EXTRA_CONSTRAINT(OP, C)                         \\\n+((C) == 'U' ? m68hc11_small_indexed_indirect_p (OP, GET_MODE (OP)) : 0)\n+\n+\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.\n+\n+   Don't define for 68HC11, the frame pointer is the bottom\n+   of local variables.  */\n+/* #define FRAME_GROWS_DOWNWARD */\n+\n+/* Define this if successive arguments to a function occupy decreasing \n+   addresses in the stack.  */\n+/* #define ARGS_GROW_DOWNWARD */\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+extern int m68hc11_sp_correction;\n+#define STARTING_FRAME_OFFSET\t\tm68hc11_sp_correction\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+\n+#define FIRST_PARM_OFFSET(FNDECL)\t2\n+\n+/* A C expression whose value is RTL representing the location of the\n+   incoming return address at the beginning of any function, before the\n+   prologue.  This RTL is either a REG, indicating that the return\n+   value is saved in REG, or a MEM representing a location in\n+   the stack.\n+  \n+   Before the prologue, RA is at 0(sp). */\n+#define INCOMING_RETURN_ADDR_RTX \\\n+    gen_rtx_MEM (VOIDmode, gen_rtx_REG (VOIDmode, STACK_POINTER_REGNUM))\n+\n+/* Before the prologue, the top of the frame is at 2(sp).  */\n+#define INCOMING_FRAME_SP_OFFSET        2\n+\n+/* Define this if functions should assume that stack space has been\n+   allocated for arguments even when their values are passed in\n+   registers.\n+  \n+   The value of this macro is the size, in bytes, of the area reserved for\n+   arguments passed in registers.\n+  \n+   This space can either be allocated by the caller or be a part of the\n+   machine-dependent stack frame: `OUTGOING_REG_PARM_STACK_SPACE'\n+   says which. */\n+/* #define REG_PARM_STACK_SPACE(FNDECL)\t2 */\n+\n+/* Define this macro if REG_PARM_STACK_SPACE is defined but stack\n+   parameters don't skip the area specified by REG_PARM_STACK_SPACE.\n+   Normally, when a parameter is not passed in registers, it is placed on\n+   the stack beyond the REG_PARM_STACK_SPACE area.  Defining this macro  \n+   suppresses this behavior and causes the parameter to be passed on the\n+   stack in its natural location.  */\n+/* #define STACK_PARMS_IN_REG_PARM_AREA */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM\t\tHARD_SP_REGNUM\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM\t\tSOFT_FP_REGNUM\n+\n+#define HARD_FRAME_POINTER_REGNUM\tHARD_FP_REGNUM\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM\t\tSOFT_AP_REGNUM\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM\t        SOFT_REG_FIRST\n+\n+\f\n+/* Definitions for register eliminations.\n+\n+   This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.\n+\n+   We have two registers that are eliminated on the 6811. The psuedo arg\n+   pointer and pseudo frame pointer registers can always be eliminated;\n+   they are replaced with either the stack or the real frame pointer. */\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\\\n+{{ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\t\t\\\n+ {ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM},\t\\\n+ {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n+ {FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms may be\n+   accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c. */\n+#define FRAME_POINTER_REQUIRED\t0\n+\n+/* Given FROM and TO register numbers, say whether this elimination is allowed.\n+   Frame pointer elimination is automatically handled.\n+\n+   All other eliminations are valid.  */\n+\n+#define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\\\n+ ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM\t\\\n+  ? ! frame_pointer_needed\t\t\t\t\t\\\n+  : 1)\n+\n+\n+/* Define the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+    { OFFSET = m68hc11_initial_elimination_offset (FROM, TO); }\n+\n+/* LONGJMP_RESTORE_FROM_STACK */\n+\n+\f\n+/* Passing Function Arguments on the Stack.  */\n+\n+/* When a prototype says `char' or `short', really pass an `int'.  */\n+/* #define PROMOTE_PROTOTYPES */\n+\n+/* If we generate an insn to push BYTES bytes, this says how many the\n+   stack pointer really advances by. No rounding or alignment needed\n+   for MC6811. */\n+#define PUSH_ROUNDING(BYTES)\t(BYTES)\n+\n+/* Value is 1 if returning from a function call automatically pops the\n+   arguments described by the number-of-args field in the call. FUNTYPE is\n+   the data type of the function (as a tree), or for a library call it is\n+   an identifier node for the subroutine name.\n+  \n+   The standard MC6811 call, with arg count word, includes popping the\n+   args as part of the call template. */\n+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE)\t0\n+\n+/* Nonzero if type TYPE should be returned in memory.\n+   Blocks and data types largers than 4 bytes cannot be returned\n+   in the register (D + X = 4).  */\n+#define RETURN_IN_MEMORY(TYPE)\t\t\t\t\\\n+    ((TYPE_MODE (TYPE) == BLKmode)\t\t\t\\\n+     ? (int_size_in_bytes (TYPE) > 4)\t\t\t\\\n+     : (GET_MODE_SIZE (TYPE_MODE (TYPE)) > 4))\n+\n+\f\n+/* Passing Arguments in Registers.  */\n+\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.  */\n+\n+typedef struct m68hc11_args\n+{\n+  int words;\n+  int nregs;\n+} CUMULATIVE_ARGS;\n+\n+/* A C expression that indicates when an argument must be passed by reference.\n+   If nonzero for an argument, a copy of that argument is made in memory and a\n+   pointer to the argument is passed instead of the argument itself.\n+   The pointer is passed in whatever way is appropriate for passing a pointer\n+   to that type.\n+ \n+   64-bit numbers are passed by reference. */\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n+    m68hc11_function_arg_pass_by_reference (& (CUM), (MODE), (TYPE), (NAMED))\n+\n+\n+/* If defined, a C expression which determines whether, and in which direction,\n+   to pad out an argument with extra space.  The value should be of type\n+   `enum direction': either `upward' to pad above the argument,\n+   `downward' to pad below, or `none' to inhibit padding.\n+\n+   Structures are stored left shifted in their argument slot.  */\n+#define FUNCTION_ARG_PADDING(MODE, TYPE) \\\n+  m68hc11_function_arg_padding ((MODE), (TYPE))\n+\n+/* A C expression that indicates when it is the called function's\n+   responsibility to make a copy of arguments passed by invisible\n+   reference.  Normally, the caller makes a copy and passes the\n+   address of the copy to the routine being called.  When\n+   FUNCTION_ARG_CALLEE_COPIES is defined and is nonzero, the caller\n+   does not make a copy.  Instead, it passes a pointer to the \"live\"\n+   value.  The called function must not modify this value.  If it can\n+   be determined that the value won't be modified, it need not make a\n+   copy; otherwise a copy must be made. */\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED)\t\t\\\n+    ((NAMED) && FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED))\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to a\n+   function whose data type is FNTYPE. For a library call, FNTYPE is 0. */\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT) \\\n+    (m68hc11_init_cumulative_args (&CUM, FNTYPE, LIBNAME))\n+\n+/* Update the data in CUM to advance over an argument of mode MODE and data\n+   type TYPE. (TYPE is null for libcalls where that information may not be\n+   available.) */\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \\\n+    (m68hc11_function_arg_advance (&CUM, MODE, TYPE, NAMED))\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  (m68hc11_function_arg (&CUM, MODE, TYPE, NAMED))\n+\n+/* Define the profitability of saving registers around calls.\n+\n+   Disable this because the saving instructions generated by\n+   caller-save need a reload and the way it is implemented,\n+   it forbids all spill registers at that point.  Enabling\n+   caller saving results in spill failure.  */\n+#define CALLER_SAVE_PROFITABLE(REFS,CALLS) 0\n+\n+/* Implement `va_arg'.  */\n+#define EXPAND_BUILTIN_VA_START(stdarg, valist, nextarg) \\\n+  m68hc11_expand_builtin_va_start (stdarg, valist, nextarg)\n+\n+#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n+  m68hc11_va_arg (valist, type)\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE)\tm68hc11_function_epilogue(FILE, SIZE)\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.\n+\n+   Passing an arg partly in register and memory does not work at all.\n+   Don't do that.  */\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) (0)\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   D is for 16-bit values, X is for 32-bit (X+D).  */\n+#define FUNCTION_ARG_REGNO_P(N)\t\\\n+     (((N) == HARD_D_REGNUM) || ((N) == HARD_X_REGNUM))\n+\n+/* All return values are in the D or X+D registers:\n+    - 8 and 16-bit values are returned in D.\n+      BLKmode are passed in D as pointer.\n+    - 32-bit values are returned in X + D.\n+      The high part is passed in X and the low part in D.\n+      For GCC, the register number must be HARD_X_REGNUM.  */\n+#define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\t\\\n+     gen_rtx (REG, TYPE_MODE (VALTYPE),\t\t\t\t\t\\\n+              ((TYPE_MODE (VALTYPE) == BLKmode\t\t\t\t\\\n+\t        || GET_MODE_SIZE (TYPE_MODE (VALTYPE)) <= 2)\t\t\\\n+\t\t   ? HARD_D_REGNUM : HARD_X_REGNUM))\n+\n+#define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n+     gen_rtx (REG, MODE,\t\t\t\t\t\t\\\n+              (((MODE) == BLKmode || GET_MODE_SIZE (MODE) <= 2)\t\t\\\n+                   ? HARD_D_REGNUM : HARD_X_REGNUM))\n+\n+/* 1 if N is a possible register number for a function value.  */\n+#define FUNCTION_VALUE_REGNO_P(N) \\\n+     ((N) == HARD_D_REGNUM || (N) == HARD_X_REGNUM)\n+\n+/* Register in which address to store a structure value is passed to a\n+   function.  */\n+#define STRUCT_VALUE_REGNUM\tHARD_D_REGNUM\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in functions\n+   that have frame pointers. No definition is equivalent to always zero.  */\n+#define EXIT_IGNORE_STACK\t0\n+\n+\f\n+/* Generating Code for Profiling.  */\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\t\\\n+    asm_fprintf (FILE, \"\\tldy LP%d\\n\\tjsr mcount\\n\", (LABELNO))\n+\n+/* Output assembler code to FILE to initialize this source file's\n+   basic block profiling info, if that has not already been done. */\n+#define FUNCTION_BLOCK_PROFILER(FILE, BLOCK_OR_LABEL)\t\\\n+    m68hc11_function_block_profiler(FILE, BLOCK_OR_LABEL)\n+\n+/* Output assembler code to FILE to increment the counter for\n+  the BLOCKNO'th basic block in this source file.  */\n+#define BLOCK_PROFILER(FILE, BLOCKNO)\t\t\t\\\n+    m68hc11_block_profiler(FILE, BLOCKNO)\n+\n+/* Output assembler code to FILE to indicate return from \n+   a function during basic block profiling.  */\n+#define FUNCTION_BLOCK_PROFILER_EXIT(FILE)\t\t\\\n+    asm_fprintf (FILE, \"\\tjsr %U__bb_trace_ret\\n\");\n+\n+/* Save all registers which may be clobbered by a function call.\n+   MACHINE_STATE_SAVE and MACHINE_STATE_RESTORE are target-code macros,\n+   used in libgcc2.c.  They may not refer to TARGET_* macros !!!\n+\n+   We don't need to save the CCR nor the soft registers because\n+   they will be saved by gcc.  */\n+#define MACHINE_STATE_SAVE(id) \\\n+  {\t\t\t       \\\n+    asm (\"pshy\");\t       \\\n+    asm (\"pshx\");\t       \\\n+    asm (\"psha\");\t       \\\n+    asm (\"pshb\");\t       \\\n+  }\n+\n+#define MACHINE_STATE_RESTORE(id) \\\n+  {\t\t\t       \\\n+    asm (\"pulb\");\t       \\\n+    asm (\"pula\");\t       \\\n+    asm (\"pulx\");\t       \\\n+    asm (\"puly\");\t       \\\n+  }\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.  */\n+#define TRAMPOLINE_TEMPLATE(FILE) { \\\n+  fprintf (FILE, \"\\t.bogus\\t\\t; TRAMPOLINE_TEMPLATE unimplemented\\n\"); }\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+#define TRAMPOLINE_SIZE\t\t0\n+\n+/* A C statement to initialize the variable parts of a trampoline.\n+   ADDR is an RTX for the address of the trampoline; FNADDR is an\n+   RTX for the address of the nested function; STATIC_CHAIN is an\n+   RTX for the static chain value that should be passed to the\n+   function when it is called.  */\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) { \\\n+\t}\n+\f\n+\n+/* If defined, a C expression whose value is nonzero if IDENTIFIER\n+   with arguments ARGS is a valid machine specific attribute for DECL.\n+   The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n+\n+#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, NAME, ARGS) \\\n+  (m68hc11_valid_decl_attribute_p (DECL, ATTRIBUTES, NAME, ARGS))\n+\n+/* If defined, a C expression whose value is nonzero if IDENTIFIER\n+   with arguments ARGS is a valid machine specific attribute for TYPE.\n+   The attributes in ATTRIBUTES have previously been assigned to TYPE.  */\n+\n+#define VALID_MACHINE_TYPE_ATTRIBUTE(TYPE, ATTRIBUTES, NAME, ARGS) \\\n+  (m68hc11_valid_type_attribute_p (TYPE, ATTRIBUTES, NAME, ARGS))\n+\n+/* If defined, a C expression whose value is zero if the attributes on\n+   TYPE1 and TYPE2 are incompatible, one if they are compatible, and\n+   two if they are nearly compatible (which causes a warning to be\n+   generated).  */\n+\n+#define COMP_TYPE_ATTRIBUTES(TYPE1, TYPE2) \\\n+  (m68hc11_comp_type_attributes (TYPE1, TYPE2))\n+\n+/* If defined, a C statement that assigns default attributes to newly\n+   defined TYPE.  */\n+\n+#define SET_DEFAULT_TYPE_ATTRIBUTES(TYPE) \\\n+  (m68hc11_set_default_type_attributes (TYPE))\n+\n+/* Define this macro if references to a symbol must be treated\n+   differently depending on something about the variable or function\n+   named by the symbol (such as what section it is in).\n+\n+   For the 68HC11, we want to recognize trap handlers so that we\n+   handle calls to traps in a special manner (by issuing the trap).\n+   This information is stored in SYMBOL_REF_FLAG.  */\n+\n+#define ENCODE_SECTION_INFO(DECL) m68hc11_encode_section_info (DECL)\n+\n+/* Override what GCC does for section info to let us recognize traps.  */\n+\n+#define REDO_SECTION_INFO_P(DECL) 1\n+\n+/* `INIT_TARGET_OPTABS'\n+     Define this macro as a C statement that declares additional library\n+     routines renames existing ones. `init_optabs' calls this macro\n+     after initializing all the normal library routines.\n+\n+     Overrides the memcpy */\n+\n+#define INIT_TARGET_OPTABS\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    memcpy_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__memcpy\");\t\t\\\n+    memcmp_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__memcmp\");\t\t\\\n+    memset_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__memset\");\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* The 68HC12 has all the post/pre increment/decrement modes.  */\n+#define HAVE_POST_INCREMENT (TARGET_M6812 && TARGET_AUTO_INC_DEC)\n+#define HAVE_PRE_INCREMENT  (TARGET_M6812 && TARGET_AUTO_INC_DEC)\n+#define HAVE_POST_DECREMENT (TARGET_M6812 && TARGET_AUTO_INC_DEC)\n+#define HAVE_PRE_DECREMENT  (TARGET_M6812 && TARGET_AUTO_INC_DEC)\n+\n+/* The class value for base registers.  This depends on the target:\n+   A_REGS for 68HC11 and A_OR_SP_REGS for 68HC12.  The class value\n+   is stored at init time.  */\n+extern enum reg_class m68hc11_base_reg_class;\n+#define BASE_REG_CLASS\t\tm68hc11_base_reg_class\n+\n+/* The class value for index registers.  This is NO_REGS for 68HC11.  */\n+\n+extern enum reg_class m68hc11_index_reg_class;\n+#define INDEX_REG_CLASS\t        m68hc11_index_reg_class\n+\n+/* These assume that REGNO is a hard or pseudo reg number. They give nonzero\n+   only if REGNO is a hard reg of the suitable class or a pseudo reg currently\n+   allocated to a suitable hard reg.  Since they use reg_renumber, they are\n+   safe only once reg_renumber has been allocated, which happens in\n+   local-alloc.c.  */\n+\n+\n+/* Internal macro, return 1 if REGNO is a valid base register.  */\n+#if GCC_VERSION == 2095\n+# define REG_VALID_P(REGNO) ((REGNO) >= 0)\n+#else\n+# define REG_VALID_P(REGNO) (1)\t/* ? */\n+#endif\n+\n+extern unsigned char m68hc11_reg_valid_for_base[FIRST_PSEUDO_REGISTER];\n+#define REG_VALID_FOR_BASE_P(REGNO) \\\n+    (REG_VALID_P (REGNO) && (REGNO) < FIRST_PSEUDO_REGISTER \\\n+     && m68hc11_reg_valid_for_base[REGNO])\n+\n+/* Internal macro, return 1 if REGNO is a valid index register.  */\n+extern unsigned char m68hc11_reg_valid_for_index[FIRST_PSEUDO_REGISTER];\n+#define REG_VALID_FOR_INDEX_P(REGNO) \\\n+    (REG_VALID_P (REGNO) >= 0 && (REGNO) < FIRST_PSEUDO_REGISTER \\\n+     && m68hc11_reg_valid_for_index[REGNO])\n+\n+/* Internal macro, the nonstrict definition for REGNO_OK_FOR_BASE_P.  */\n+#define REGNO_OK_FOR_BASE_NONSTRICT_P(REGNO) \\\n+    ((REGNO) >= FIRST_PSEUDO_REGISTER \\\n+     || REG_VALID_FOR_BASE_P (REGNO) \\\n+     || (REGNO) == FRAME_POINTER_REGNUM \\\n+     || (REGNO) == HARD_FRAME_POINTER_REGNUM \\\n+     || (REGNO) == ARG_POINTER_REGNUM \\\n+     || (reg_renumber && REG_VALID_FOR_BASE_P (reg_renumber[REGNO])))\n+\n+/* Internal macro, the nonstrict definition for REGNO_OK_FOR_INDEX_P.  */\n+#define REGNO_OK_FOR_INDEX_NONSTRICT_P(REGNO) \\\n+    (TARGET_M6812 \\\n+     && ((REGNO) >= FIRST_PSEUDO_REGISTER \\\n+         || REG_VALID_FOR_INDEX_P (REGNO) \\\n+         || (reg_renumber && REG_VALID_FOR_INDEX_P (reg_renumber[REGNO]))))\n+\n+/* Internal macro, the strict definition for REGNO_OK_FOR_BASE_P.  */\n+#define REGNO_OK_FOR_BASE_STRICT_P(REGNO) \\\n+    ((REGNO) < FIRST_PSEUDO_REGISTER ? REG_VALID_FOR_BASE_P (REGNO) \\\n+     : (reg_renumber && REG_VALID_FOR_BASE_P (reg_renumber[REGNO])))\n+\n+/* Internal macro, the strict definition for REGNO_OK_FOR_INDEX_P.  */\n+#define REGNO_OK_FOR_INDEX_STRICT_P(REGNO) \\\n+    (TARGET_M6812 \\\n+     && ((REGNO) < FIRST_PSEUDO_REGISTER ? REG_VALID_FOR_INDEX_P (REGNO) \\\n+         : (reg_renumber && REG_VALID_FOR_INDEX_P (reg_renumber[REGNO]))))\n+\n+#define REGNO_OK_FOR_BASE_P2(REGNO,STRICT) \\\n+    ((STRICT) ? (REGNO_OK_FOR_BASE_STRICT_P (REGNO)) \\\n+              : (REGNO_OK_FOR_BASE_NONSTRICT_P (REGNO)))\n+\n+#define REGNO_OK_FOR_INDEX_P2(REGNO,STRICT) \\\n+    ((STRICT) ? (REGNO_OK_FOR_INDEX_STRICT_P (REGNO)) \\\n+              : (REGNO_OK_FOR_INDEX_NONSTRICT_P (REGNO)))\n+\n+#define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_BASE_STRICT_P (REGNO)\n+#define REGNO_OK_FOR_INDEX_P(REGNO) REGNO_OK_FOR_INDEX_STRICT_P (REGNO)\n+\n+#define REG_OK_FOR_BASE_STRICT_P(X)     REGNO_OK_FOR_BASE_STRICT_P (REGNO (X))\n+#define REG_OK_FOR_BASE_NONSTRICT_P(X)  REGNO_OK_FOR_BASE_NONSTRICT_P (REGNO (X))\n+#define REG_OK_FOR_INDEX_STRICT_P(X)    REGNO_OK_FOR_INDEX_STRICT_P (REGNO (X))\n+#define REG_OK_FOR_INDEX_NONSTRICT_P(X) REGNO_OK_FOR_INDEX_NONSTRICT_P (REGNO (X))\n+\n+/* see PUSH_POP_ADDRESS_P() below for an explanation of this.  */\n+#define IS_STACK_PUSH(operand) \\\n+    ((GET_CODE (operand) == MEM) \\\n+     && (GET_CODE (XEXP (operand, 0)) == PRE_DEC) \\\n+     && (SP_REG_P (XEXP (XEXP (operand, 0), 0))))\n+\n+#define IS_STACK_POP(operand) \\\n+    ((GET_CODE (operand) == MEM) \\\n+     && (GET_CODE (XEXP (operand, 0)) == POST_INC) \\\n+     && (SP_REG_P (XEXP (XEXP (operand, 0), 0))))\n+\n+/* 1 if X is an rtx for a constant that is a valid address.  */\n+#define CONSTANT_ADDRESS_P(X)\t(CONSTANT_P (X))\n+\n+/* Maximum number of registers that can appear in a valid memory address */\n+#define MAX_REGS_PER_ADDRESS\t2\n+\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a\n+   valid memory address for an instruction. The MODE argument is the\n+   machine mode for the MEM expression that wants to use this address.  */\n+\n+/*--------------------------------------------------------------\n+   Valid addresses are either direct or indirect (MEM) versions\n+   of the following forms:\n+\tconstant\t\tN\n+\tregister\t\t,X\n+\tindexed\t\t\tN,X\n+--------------------------------------------------------------*/\n+\n+/* The range of index that is allowed by indirect addressing. */\n+\n+#define VALID_MIN_OFFSET m68hc11_min_offset\n+#define VALID_MAX_OFFSET m68hc11_max_offset\n+\n+/* The offset values which are allowed by the n,x and n,y addressing modes.\n+   Take into account the size of the mode because we may have to add\n+   a mode offset to access the lowest part of the data.\n+   (For example, for an SImode, the last valid offset is 252.) */\n+#define VALID_CONSTANT_OFFSET_P(X,MODE)\t\t\\\n+((GET_CODE (X) == CONST_INT) &&\t\t\t\\\n+ ((INTVAL (X) >= VALID_MIN_OFFSET)\t\t\\\n+    && ((INTVAL (X) <= VALID_MAX_OFFSET\t\t\\\n+\t\t- (HOST_WIDE_INT) (GET_MODE_SIZE (MODE) + 1)))))\n+\n+/* This is included to allow stack push/pop operations. Special hacks in the\n+   md and m6811.c files exist to support this.  */\n+#define PUSH_POP_ADDRESS_P(X) \\\n+  (((GET_CODE (X) == PRE_DEC) || (GET_CODE (X) == POST_INC)) \\\n+\t&& SP_REG_P (XEXP (X, 0)))\n+\n+/* Go to ADDR if X is a valid address. */\n+#ifndef REG_OK_STRICT\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n+{ \\\n+  if (m68hc11_go_if_legitimate_address ((X), (MODE), 0)) goto ADDR; \\\n+}\n+#else\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t \\\n+{\t\t\t\t\t\t\t \\\n+  if (m68hc11_go_if_legitimate_address ((X), (MODE), 1)) goto ADDR; \\\n+}\n+#endif\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx and check its\n+   validity for a certain class.  We have two alternate definitions for each\n+   of them.  The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.  The symbol\n+   REG_OK_STRICT causes the latter definition to be used.\n+  \n+   Most source files want to accept pseudo regs in the hope that they will\n+   get allocated to the class that the insn wants them to be in. Source files\n+   for reload pass need to be strict. After reload, it makes no difference,\n+   since pseudo regs have been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_NONSTRICT_P(X)\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_NONSTRICT_P(X)\n+#else\n+#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_STRICT_P(X)\n+#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_STRICT_P(X)\n+#endif\n+\n+\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+  \n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+  \n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+  \n+   It is always safe for this macro to do nothing.\n+   It exists to recognize opportunities to optimize the output.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)                     \\\n+{ rtx operand = (X);                                            \\\n+  if (m68hc11_legitimize_address (&operand, (OLDX), (MODE)))\t\\\n+    {                                                           \\\n+      (X) = operand;                                            \\\n+      GO_IF_LEGITIMATE_ADDRESS (MODE,X,WIN);                    \\\n+    }                                                           \\\n+}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.  */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (ADDR) == PRE_DEC || GET_CODE (ADDR) == POST_DEC\t\t\\\n+      || GET_CODE (ADDR) == PRE_INC || GET_CODE (ADDR) == POST_INC)\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X)\t1\n+\n+\f\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) \\\n+\tm68hc11_notice_update_cc ((EXP), (INSN))\n+\n+/* Compute the cost of computing a constant rtl expression RTX whose rtx-code\n+   is CODE.  The body of this macro is a portion of a switch statement.  If\n+   the code is computed here, return it with a return statement. Otherwise,\n+   break from the switch.  */\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n+ case CONST_INT:\t\t\t \\\n+    if (RTX == const0_rtx) return 0;\t \\\n+ case CONST:\t\t\t\t \\\n+    return 0;                            \\\n+ case LABEL_REF:\t\t\t \\\n+ case SYMBOL_REF:\t\t\t \\\n+   return 1;\t\t\t\t \\\n+ case CONST_DOUBLE:\t\t\t \\\n+   return 0;\n+\n+#define DEFAULT_RTX_COSTS(X,CODE,OUTER_CODE)\t\t\\\n+    return m68hc11_rtx_costs (X, CODE, OUTER_CODE);\n+\n+\n+/* An expression giving the cost of an addressing mode that contains\n+   ADDRESS.  If not defined, the cost is computed from the ADDRESS\n+   expression and the `CONST_COSTS' values.  */\n+\n+#define ADDRESS_COST(RTX) m68hc11_address_cost (RTX)\n+\n+/* Move costs between classes of registers */\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\\\n+    (m68hc11_register_move_cost (CLASS1, CLASS2))\n+\n+/* Move cost between register and memory.\n+    - Move to a 16-bit register is reasonable,\n+    - Move to a soft register can be expensive.  */\n+#define MEMORY_MOVE_COST(MODE,CLASS,IN)\t\t\\\n+    m68hc11_memory_move_cost ((MODE),(CLASS),(IN))\n+\n+/* A C expression for the cost of a branch instruction.  A value of 1\n+   is the default; other values are interpreted relative to that.\n+\n+   Pretend branches are cheap because GCC generates sub-optimal code\n+   for the default value.  */\n+#define BRANCH_COST 0\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS\t0\n+\n+/* It is as good to call a constant function address as to call an address\n+   kept in a register.  */\n+#define NO_FUNCTION_CSE\n+\n+/* Try a machine-dependent way of reloading an illegitimate address\n+   operand.  If we find one, push the reload and jump to WIN.  This\n+   macro is used in only one place: `find_reloads_address' in reload.c.\n+\n+   For M68HC11, we handle large displacements of a base register\n+   by splitting the addend accors an addhi3 insn.\n+\n+   For M68HC12, the 64K offset range is available.\n+   */\n+\n+#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)     \\\n+do {                                                                    \\\n+  /* We must recognize output that we have already generated ourselves.  */ \\\n+  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+      && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\t\\\n+      && GET_CODE (XEXP (XEXP (X, 0), 0)) == REG\t\t\t\\\n+      && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\t\\\n+      && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL_PTR,       \\\n+                   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,        \\\n+                   OPNUM, TYPE);                                        \\\n+      goto WIN;                                                         \\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS                                              \\\n+      && GET_CODE (XEXP (X, 0)) == REG                                  \\\n+      && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n+      && !VALID_CONSTANT_OFFSET_P (XEXP (X, 1), MODE))                  \\\n+    {                                                                   \\\n+      HOST_WIDE_INT val = INTVAL (XEXP (X, 1));                         \\\n+      HOST_WIDE_INT low, high;                                          \\\n+      high = val & (~0x0FF);                                            \\\n+      low  = val & 0x00FF;                                              \\\n+      if (low >= 256-15) { high += 16; low -= 16; }                     \\\n+      /* Reload the high part into a base reg; leave the low part       \\\n+         in the mem directly.  */                                       \\\n+                                                                        \\\n+      X = gen_rtx_PLUS (Pmode,\t\t\t\t\t\t\\\n+                        gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\\\n+                                      GEN_INT (high)),                  \\\n+                        GEN_INT (low));                                 \\\n+                                                                        \\\n+      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL_PTR,       \\\n+                   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,        \\\n+                   OPNUM, TYPE);                                        \\\n+      goto WIN;                                                         \\\n+    }                                                                   \\\n+} while (0)\n+\n+\f\n+/* Defining the Output Assembler Language.  */\n+\n+/* A default list of other sections which we might be \"in\" at any given\n+   time.  For targets that use additional sections (e.g. .tdesc) you\n+   should override this definition in the target-specific file which\n+   includes this file.  */\n+\n+/* Output before read-only data.  */\n+#define TEXT_SECTION_ASM_OP\t(\"\\t.sect\\t.text\")\n+\n+/* Output before writable data.  */\n+#define DATA_SECTION_ASM_OP\t(\"\\t.sect\\t.data\")\n+\n+/* Output before uninitialized data.  */\n+#define BSS_SECTION_ASM_OP \t(\"\\t.sect\\t.bss\")\n+\n+/* This is how to begin an assembly language file.  Most svr4 assemblers want\n+   at least a .file directive to come first, and some want to see a .version\n+   directive come right after that.  Here we just establish a default\n+   which generates only the .file directive.  If you need a .version\n+   directive for any specific target, you should override this definition\n+   in the target-specific file which includes this one.  */\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)                            \\\n+    m68hc11_asm_file_start ((FILE), main_input_filename)\n+\n+/* Comment character */\n+#define ASM_COMMENT_START\t\";\"\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+#define ASM_APP_ON \t\t\"; Begin inline assembler code\\n#APP\\n\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+#define ASM_APP_OFF \t\t\"; End of inline assembler code\\n#NO_APP\\n\"\n+\n+/* Output #ident as a .ident.  */\n+\n+/* This is how to output a `long double' extended real constant.  */\n+\n+#define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)  \t\t\t\t\\\n+    ASM_OUTPUT_DOUBLE(FILE,VALUE)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n+do { long l[2];\t\t\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n+     fprintf (FILE, \"\\t%s\\t0x%lx,0x%lx\\n\", ASM_LONG, l[0], l[1]);\t\\\n+   } while (0)\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\\\n+do { long l;\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\\\n+     fprintf ((FILE), \"\\t%s\\t0x%lx\\n\", ASM_LONG, l);\t\\\n+   } while (0)\n+\n+/* This is how to output an assembler line defining a `long' constant.  */\n+#define ASM_OUTPUT_INT(FILE,VALUE)\t\t        \\\n+( fprintf (FILE, \"\\t%s\\t\", ASM_LONG),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)\t\t\t\\\n+( fprintf (FILE, \"\\t%s\\t\", ASM_SHORT),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)\t\t\t\\\n+( fprintf (FILE, \"\\t%s\\t\", ASM_BYTE_OP),\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\t\\\n+  putc ('\\n', FILE))\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)\t\t\t\\\n+  fprintf ((FILE), \"%s 0x%x\\n\", ASM_BYTE_OP, (VALUE))\n+\n+\n+/* Define the parentheses used to group arithmetic operations in assembler\n+ * code.  \n+ */\n+#define ASM_OPEN_PAREN\t\t\"(\"\n+#define ASM_CLOSE_PAREN\t\t\")\"\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fprintf (FILE, \"%s \", GLOBAL_ASM_OP);\t\t\\\n+       assemble_name (FILE, NAME);\t\t\t\\\n+       fputs (\"\\n\", FILE);} while (0)\n+\n+/* output external reference */\n+#define ASM_OUTPUT_EXTERNAL(FILE,DECL,NAME) \\\n+  {fputs (\"\\t; extern\\t\", FILE); \\\n+  assemble_name (FILE, NAME); \\\n+  fputs (\"\\n\", FILE);}\n+\n+\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* How to refer to registers in assembler output.  This sequence is indexed\n+   by compiler's hard-register-number (see above).  */\n+#define REGISTER_NAMES\t\t\t\t\t\t\\\n+{ \"x\", \"d\", \"y\", \"sp\", \"pc\", \"a\", \"b\", \"ccr\", \"z\",\t\t\\\n+  \"*_.frame\", \"*_.tmp\", \"*_.z\", \"*_.xy\", \"*fake clobber\",\t\\\n+  SOFT_REG_NAMES, \"*sframe\", \"*ap\"}\n+\n+\n+/* Output a float value (represented as a C double) as an immediate operand.\n+   This macro is a 68k-specific macro.  */\n+\n+#define ASM_OUTPUT_FLOAT_OPERAND(CODE,FILE,VALUE)\t\t\\\n+ do {\t\t\t\t\t\t\t\t\\\n+      long l;\t\t\t\t\t\t\t\\\n+      REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\t\\\n+      asm_fprintf ((FILE), \"%I0x%lx\", l);\t\t\t\\\n+     } while (0)\n+\n+/* Output a double value (represented as a C double) as an immediate operand.\n+   This macro is a 68k-specific macro.  */\n+#define ASM_OUTPUT_DOUBLE_OPERAND(FILE,VALUE)\t\t\t\t\\\n+ do { char dstr[30];\t\t\t\t\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\\\n+      asm_fprintf (FILE, \"%I0r%s\", dstr);\t\t\t\t\\\n+    } while (0)\n+\n+/* Note, long double immediate operands are not actually\n+   generated by m68k.md.  */\n+#define ASM_OUTPUT_LONG_DOUBLE_OPERAND(FILE,VALUE)\t\t\t\\\n+ do { char dstr[30];\t\t\t\t\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\\\n+      asm_fprintf (FILE, \"%I0r%s\", dstr);\t\t\t\t\\\n+    } while (0)\n+\n+/* Print an instruction operand X on file FILE. CODE is the code from the\n+   %-spec for printing this operand. If `%z3' was used to print operand\n+   3, then CODE is 'z'.  */\n+\n+#define PRINT_OPERAND(FILE, X, CODE) \\\n+  print_operand (FILE, X, CODE)\n+\n+/* Print a memory operand whose address is X, on file FILE. */\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) \\\n+  print_operand_address (FILE, ADDR)\n+\n+/* This is how to output an insn to push/pop a register on the stack.\n+   It need not be very fast code.  \n+\n+   Don't define because we don't know how to handle that with\n+   the STATIC_CHAIN_REGNUM (soft register).  Saving the static\n+   chain must be made inside FUNCTION_PROFILER.  */\n+\n+#undef ASM_OUTPUT_REG_PUSH\n+#undef ASM_OUTPUT_REG_POP\n+\n+/* This is how to output an element of a case-vector that is relative. */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n+  asm_fprintf (FILE, \"\\t%s\\tL%d-L%d\\n\", ASM_SHORT, VALUE, REL)\n+\n+/* This is how to output an element of a case-vector that is absolute. */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n+  asm_fprintf (FILE, \"\\t%s\\t.L%d\\n\", ASM_SHORT, VALUE)\n+\n+/* This is how to output an assembler line that says to advance the\n+   location counter to a multiple of 2**LOG bytes.  */\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\t\t\\\n+  do {                                                  \\\n+      if ((LOG) > 1)                                    \\\n+          asm_fprintf ((FILE), \"\\t%s\\n\", ALIGN_ASM_OP); \\\n+  } while (0)\n+\n+\f\n+/* Assembler Commands for Exception Regions.  */\n+\n+/* Default values provided by GCC should be ok. Assumming that DWARF-2\n+   frame unwind info is ok for this platform. */\n+\n+/* How to renumber registers for dbx and gdb. */\n+#define DBX_REGISTER_NUMBER(REGNO) \\\n+ ((REGNO))\n+\n+#undef PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+\n+/* The prefix for local labels.  You should be able to define this as\n+   an empty string, or any arbitrary string (such as \".\", \".L%\", etc)\n+   without having to make any other changes to account for the specific\n+   definition.  Note it is a string literal, not interpreted by printf\n+   and friends. */\n+#define LOCAL_LABEL_PREFIX \".\"\n+\n+/* The prefix for immediate operands.  */\n+#define IMMEDIATE_PREFIX \"#\"\n+#define GLOBAL_ASM_OP   \".globl\"\n+#define ASM_LONG        \".long\"\n+#define ASM_SHORT       \".word\"\n+\n+\f\n+/* Miscellaneous Parameters.  */\n+\n+/* Define the codes that are matched by predicates in m68hc11.c.  */\n+#define PREDICATE_CODES \\\n+{\"stack_register_operand\",   {SUBREG, REG}},\t\t\t\t\\\n+{\"d_register_operand\",       {SUBREG, REG}},\t\t\t\t\\\n+{\"hard_addr_reg_operand\",    {SUBREG, REG}},\t\t\t\t\\\n+{\"hard_reg_operand\",         {SUBREG, REG}},\t\t\t\t\\\n+{\"m68hc11_logical_operator\", {AND, IOR, XOR}},\t\t\t\t\\\n+{\"m68hc11_arith_operator\",   {AND, IOR, XOR, PLUS, MINUS,\t\t\\\n+\t\t\t      ASHIFT, ASHIFTRT, LSHIFTRT,\t\t\\\n+\t\t\t      ROTATE, ROTATERT }},\t\t\t\\\n+{\"m68hc11_non_shift_operator\", {AND, IOR, XOR, PLUS, MINUS}},\t\t\\\n+{\"m68hc11_unary_operator\",   {NEG, NOT, SIGN_EXTEND, ZERO_EXTEND}},\t\\\n+{\"non_push_operand\",         {SUBREG, REG, MEM}},\t\t\t\\\n+{\"reg_or_some_mem_operand\",  {SUBREG, REG, MEM}},\t\t\t\\\n+{\"tst_operand\",              {SUBREG, REG, MEM}},\t\t\t\\\n+{\"cmp_operand\",              {SUBREG, REG, MEM, SYMBOL_REF, LABEL_REF,\t\\\n+\t\t\t     CONST_INT, CONST_DOUBLE}},\n+\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE\tPmode\n+\n+/* Specify the tree operation to be used to convert reals to integers. */\n+#define IMPLICIT_FIX_EXPR\tFIX_ROUND_EXPR\n+\n+/* This flag, if defined, says the same insns that convert to a signed fixnum\n+   also convert validly to an unsigned one.  */\n+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR\t\tTRUNC_DIV_EXPR\n+\n+/* Max number of bytes we can move from memory to memory in one\n+   reasonably fast instruction.  */\n+#define MOVE_MAX \t\t2\n+\n+/* MOVE_RATIO is the number of move instructions that is better than a\n+   block move.  Make this small on 6811, since the code size grows very\n+   large with each move.  */\n+#define MOVE_RATIO\t\t3\n+\n+/* Define if shifts truncate the shift count which implies one can omit\n+   a sign-extension or zero-extension of a shift count.  */\n+#define SHIFT_COUNT_TRUNCATED\t1\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)\t1\n+\n+/* Specify the machine mode that pointers have. After generation of rtl, the\n+   compiler makes no further distinction between pointers and any other\n+   objects of this machine mode.  */\n+#define Pmode\t\t\tHImode\n+\n+/* A function address in a call instruction is a byte address (for indexing\n+   purposes) so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE\t\tQImode\n+\n+/* define SCCS_DIRECTIVE if SCCS directives should be ignored */\n+#define SCCS_DIRECTIVE\t\t1\n+\n+/* Allow $ in identifiers */\n+#define DOLLARS_IN_IDENTIFIERS\t1\n+\n+/* Machine-dependent reorg pass.\n+   Specific optimizations are defined here:\n+    - this pass changes the Z register into either X or Y\n+      (it preserves X/Y previous values in a memory slot in page0). \n+\n+   When this pass is finished, the global variable\n+   'z_replacement_completed' is set to 2.  */\n+#define MACHINE_DEPENDENT_REORG(X)\tm68hc11_reorg (X)\n+\n+extern int debug_m6811;\n+extern int z_replacement_completed;\n+extern int current_function_interrupt;\n+extern int current_function_trap;\n+\n+#if GCC_VERSION == 2095\n+extern rtx_ptr iy_reg;\n+extern rtx_ptr iy_reg;\n+extern rtx_ptr d_reg;\n+extern rtx_ptr m68hc11_soft_tmp_reg;\n+extern rtx_ptr m68hc11_compare_op0;\n+extern rtx_ptr m68hc11_compare_op1;\n+extern long m68hc11_min_offset;\n+extern long m68hc11_max_offset;\n+#endif"}, {"sha": "b8330693044573804047c3d796909a05b91aa98e", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "added", "additions": 5840, "deletions": 0, "changes": 5840, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=385c92176c8fe88def705968cfb05d3a6ae8df4b"}, {"sha": "c911c47f879717e1eeee0fd94358e02f99218b9b", "filename": "gcc/config/m68hc11/m68hc12.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Fm68hc12.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Fm68hc12.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc12.h?ref=385c92176c8fe88def705968cfb05d3a6ae8df4b", "patch": "@@ -0,0 +1,43 @@\n+/* Definitions of target machine for GNU compiler, for m68hc12.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Stephane Carrez (stcarrez@worldnet.fr).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Compile and assemble for a 68hc12 unless there is a -m68hc11 option.  */\n+#define ASM_SPEC       \"%{m68hc11:-m68hc11}%{!m68hc11:-m68hc12}\"\n+#define LIB_SPEC       \"\"\n+#define CC1_SPEC       \"\"\n+\n+/* We need to tell the linker the target elf format.  Just pass an\n+   emulation option.  This can be overriden by -Wl option of gcc.  */\n+#define LINK_SPEC      \"%{m68hc11:-m m68hc11elf}%{!m68hc11:-m m68hc12elf}\"\n+\n+#define CPP_SPEC  \\\n+\"%{mshort:-D__HAVE_SHORT_INT__ -D__INT__=16 -D__INT_MAX__=32767}\\\n+ %{!mshort:-D__INT__=32 -D__INT_MAX__=2147483647}\\\n+ %{m68hc11:-Dmc6811 -DMC6811 -Dmc68hc11}\\\n+ %{!m68hc11:-Dmc6812 -DMC6812 -Dmc68hc12}\"\n+\n+/* Default target_flags if no switches specified.  */\n+#define TARGET_DEFAULT\t\t(MASK_M6812)\n+\n+#define TARGET_M68HC12\n+\n+#include \"m68hc11/m68hc11.h\"\n+"}, {"sha": "221a8530c934cca0610278dfa25163561538124c", "filename": "gcc/config/m68hc11/t-m68hc11-gas", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Ft-m68hc11-gas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Ft-m68hc11-gas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Ft-m68hc11-gas?ref=385c92176c8fe88def705968cfb05d3a6ae8df4b", "patch": "@@ -0,0 +1,79 @@\n+RANLIB_FOR_TARGET = ` \\\n+  if [ -f $(objdir)/../binutils/ranlib ] ; then \\\n+    echo $(objdir)/../binutils/ranlib ; \\\n+  else \\\n+    if [ \"$(host_canonical)\" = \"$(target)\" ] ; then \\\n+      echo ranlib; \\\n+    else \\\n+       if [ -f $(bindir)/$(target_alias)-ranlib ] ; then \\\n+\t  echo $(bindir)/$(target_alias)-ranlib ; \\\n+       else \\\n+          t='$(program_transform_cross_name)'; echo ranlib | sed -e $$t ; \\\n+       fi; \\\n+    fi; \\\n+  fi`\n+\n+T_CPPFLAGS = -DUSE_GAS\n+\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = m68hc11/larith.asm\n+LIB1ASMFUNCS = _mulsi3 \\\n+\t_mulqi3 _ashlsi3 _ashrsi3 _lshrsi3 \\\n+\t_divmodhi4 _mulhi3 _mulhi32 \\\n+\t_memcpy _memset _negsi2 _one_cmplsi2 \\\n+\t_regs_min _regs_d1_8 _regs_d8_16 _regs_d17_32 \\\n+\t_premain __exit _abort _cleanup \\\n+\t_adddi3 _subdi3 _notdi2 \\\n+\t_ashrhi3 _lshrhi3 _lshlhi3 _ashrqi3 _lshlqi3 _map_data _init_bss\n+\n+TARGET_LIBGCC2_CFLAGS = -DUSE_GAS -DIN_GCC\n+\n+# 32-bit div/mod from the mn10200 port.  Prototypes have been added\n+# to avoid problems in passing 16/32-bit int (last param of udivmodsi4).\n+LIB2FUNCS_EXTRA = $(srcdir)/config/m68hc11/udivmodsi4.c \\\n+\t$(srcdir)/config/m68hc11/divmod.c $(srcdir)/config/m68hc11/udivmod.c\n+\n+# Don't compile with -g1 this reduces the size of some sections (.eh_frame).\n+LIBGCC2_DEBUG_CFLAGS =\n+LIBGCC2_CFLAGS = -Os $(LIBGCC2_INCLUDES) $(TARGET_LIBGCC2_CFLAGS) $(LIBGCC2_DEBUG_CFLAGS) $(GTHREAD_FLAGS) -DIN_LIBGCC2\n+\n+MULTILIB_OPTIONS  = m68hc11/m68hc12 mshort fshort-double\n+MULTILIB_DIRNAMES =\n+MULTILIB_MATCHES  = m68hc11=m6811 m68hc12=m6812\n+MULTILIB_EXCEPTIONS = -mnoshort -mno68hc11\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib\n+\n+# We want fine grained libraries, so use the new code to build the\n+# floating point emulation libraries.\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define SMALL_MACHINE' >> dp-bit.c\n+\techo '#define CMPtype HItype' >> dp-bit.c\n+\techo '#ifdef __LITTLE_ENDIAN__' > dp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >>dp-bit.c\n+\techo '#endif' \t\t>> dp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\techo '#define CMPtype HItype' >> fp-bit.c\n+\techo '#define SMALL_MACHINE' >> fp-bit.c\n+\techo '#ifdef __LITTLE_ENDIAN__' >> fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >>fp-bit.c\n+\techo '#endif' \t\t>> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+CRT0_S = $(srcdir)/config/m68hc11/m68hc11-crt0.S\n+MCRT0_S= $(srcdir)/config/m68hc11/m68hc11-crt0.S\n+\n+CRT0STUFF_T_CFLAGS =\n+\n+# Assemble startup files.\n+$(T)crt1.o: $(CRT0_S) $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -c -o $(T)crt1.o -x assembler-with-cpp $(CRT0_S)\n+\n+EXTRA_MULTILIB_PARTS = crt1.o"}, {"sha": "bd471f0a311adbdbbb264feb080eec798fe64aeb", "filename": "gcc/config/m68hc11/xm-m68hc11.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Fxm-m68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385c92176c8fe88def705968cfb05d3a6ae8df4b/gcc%2Fconfig%2Fm68hc11%2Fxm-m68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fxm-m68hc11.h?ref=385c92176c8fe88def705968cfb05d3a6ae8df4b", "patch": "@@ -0,0 +1,24 @@\n+/* Configuration for GNU C-compiler for Motorola 68HC11 and 68HC12.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Stephane Carrez (stcarrez@worldnet.fr)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"tm.h\"\n+\n+#define inhibit_libc"}]}