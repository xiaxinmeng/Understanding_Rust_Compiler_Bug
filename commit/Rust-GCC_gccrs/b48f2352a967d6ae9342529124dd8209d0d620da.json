{"sha": "b48f2352a967d6ae9342529124dd8209d0d620da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ4ZjIzNTJhOTY3ZDZhZTkzNDI1MjkxMjRkZDgyMDlkMGQ2MjBkYQ==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2018-06-15T19:17:19Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2018-06-15T19:17:19Z"}, "message": "typed-splay-tree.h (typed_splay_tree::remove): New function.\n\n2018-06-15  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        * typed-splay-tree.h (typed_splay_tree::remove): New function.\n        (typed_splay_tree::closure,\n        typed_splay_tree::inner_foreach_fn, typed_splay_tree::m_inner): Deleted.\n        (typed_splay_tree::typed_splay_tree,\n        typed_splay_tree::operator =): Declared private.\n        (typed_splay_tree::splay_tree_key, typed_splay_tree::splay_tree_value,\n        typed_splay_tree::splay_tree_node_s, typed_splay_tree::KDEL,\n        typed_splay_tree::VDEL, typed_splay_tree::splay_tree_delete_helper,\n        typed_splay_tree::rotate_left, typed_splay_tree::rotate_right,\n        typed_splay_tree::splay_tree_splay,\n        typed_splay_tree::splay_tree_foreach_helper,\n        typed_splay_tree::splay_tree_insert,\n        typed_splay_tree::splay_tree_remove,\n        typed_splay_tree::splay_tree_lookup,\n        typed_splay_tree::splay_tree_predecessor,\n        typed_splay_tree::splay_tree_successor,\n        typed_splay_tree::splay_tree_min,\n        typed_splay_tree::splay_tree_max): Took over from splay-tree.c/.h.\n        (typed_splay_tree::root, typed_splay_tree::comp,\n        typed_splay_tree::delete_key,\n        typed_splay_tree::delete_value): New data members.\n        * typed-splay-tree.c (selftest::test_str_to_int): Add a test for\n        typed_splay_tree::remove.\n\nFrom-SVN: r261645", "tree": {"sha": "7570cd0e69310017bf292bc7fe51f1d363289a6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7570cd0e69310017bf292bc7fe51f1d363289a6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b48f2352a967d6ae9342529124dd8209d0d620da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48f2352a967d6ae9342529124dd8209d0d620da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b48f2352a967d6ae9342529124dd8209d0d620da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48f2352a967d6ae9342529124dd8209d0d620da/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "df25ffcc4138d4c65642d9ef9028069d95f6e10c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df25ffcc4138d4c65642d9ef9028069d95f6e10c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df25ffcc4138d4c65642d9ef9028069d95f6e10c"}], "stats": {"total": 573, "additions": 527, "deletions": 46}, "files": [{"sha": "c91c81effcc1c240a8728e6f5745a75628fee090", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48f2352a967d6ae9342529124dd8209d0d620da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48f2352a967d6ae9342529124dd8209d0d620da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b48f2352a967d6ae9342529124dd8209d0d620da", "patch": "@@ -1,3 +1,29 @@\n+2018-06-15  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\t* typed-splay-tree.h (typed_splay_tree::remove): New function.\n+\t(typed_splay_tree::closure,\n+\ttyped_splay_tree::inner_foreach_fn, typed_splay_tree::m_inner): Deleted.\n+\t(typed_splay_tree::typed_splay_tree,\n+\ttyped_splay_tree::operator =): Declared private.\n+\t(typed_splay_tree::splay_tree_key, typed_splay_tree::splay_tree_value,\n+\ttyped_splay_tree::splay_tree_node_s, typed_splay_tree::KDEL,\n+\ttyped_splay_tree::VDEL, typed_splay_tree::splay_tree_delete_helper,\n+\ttyped_splay_tree::rotate_left, typed_splay_tree::rotate_right,\n+\ttyped_splay_tree::splay_tree_splay,\n+\ttyped_splay_tree::splay_tree_foreach_helper,\n+\ttyped_splay_tree::splay_tree_insert,\n+\ttyped_splay_tree::splay_tree_remove,\n+\ttyped_splay_tree::splay_tree_lookup,\n+\ttyped_splay_tree::splay_tree_predecessor,\n+\ttyped_splay_tree::splay_tree_successor,\n+\ttyped_splay_tree::splay_tree_min,\n+\ttyped_splay_tree::splay_tree_max): Took over from splay-tree.c/.h.\n+\t(typed_splay_tree::root, typed_splay_tree::comp,\n+\ttyped_splay_tree::delete_key,\n+\ttyped_splay_tree::delete_value): New data members.\n+\t* typed-splay-tree.c (selftest::test_str_to_int): Add a test for\n+\ttyped_splay_tree::remove.\n+\n 2018-06-15  Matthew Fortune  <matthew.fortune@mips.com>\n \n \t* config/mips/mips.h (ASM_SPEC): Pass through -mcrc, -mno-crc,"}, {"sha": "344920f2d4c510d8d06182f782015d75560f50a6", "filename": "gcc/typed-splay-tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48f2352a967d6ae9342529124dd8209d0d620da/gcc%2Ftyped-splay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48f2352a967d6ae9342529124dd8209d0d620da/gcc%2Ftyped-splay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftyped-splay-tree.c?ref=b48f2352a967d6ae9342529124dd8209d0d620da", "patch": "@@ -47,6 +47,9 @@ test_str_to_int ()\n   t.insert (\"a\", 1);\n   t.insert (\"b\", 2);\n   t.insert (\"c\", 3);\n+  t.insert (\"d\", 4);\n+\n+  t.remove (\"d\");\n \n   ASSERT_EQ (1, t.lookup (\"a\"));\n   ASSERT_EQ (2, t.lookup (\"b\"));"}, {"sha": "e8ba21982dca329e70b6869c4f0c4e608c590e7d", "filename": "gcc/typed-splay-tree.h", "status": "modified", "additions": 498, "deletions": 46, "changes": 544, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48f2352a967d6ae9342529124dd8209d0d620da/gcc%2Ftyped-splay-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48f2352a967d6ae9342529124dd8209d0d620da/gcc%2Ftyped-splay-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftyped-splay-tree.h?ref=b48f2352a967d6ae9342529124dd8209d0d620da", "patch": "@@ -20,8 +20,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TYPED_SPLAY_TREE_H\n #define GCC_TYPED_SPLAY_TREE_H\n \n-#include \"splay-tree.h\"\n-\n /* Typesafe wrapper around libiberty's splay-tree.h.  */\n template <typename KEY_TYPE, typename VALUE_TYPE>\n class typed_splay_tree\n@@ -44,27 +42,66 @@ class typed_splay_tree\n   value_type predecessor (key_type k);\n   value_type successor (key_type k);\n   void insert (key_type k, value_type v);\n+  void remove (key_type k);\n   value_type max ();\n   value_type min ();\n   int foreach (foreach_fn, void *);\n \n  private:\n-  /* Helper type for typed_splay_tree::foreach.  */\n-  struct closure\n-  {\n-    closure (foreach_fn outer_cb, void *outer_user_data)\n-    : m_outer_cb (outer_cb), m_outer_user_data (outer_user_data) {}\n-\n-    foreach_fn m_outer_cb;\n-    void *m_outer_user_data;\n-  };\n+  /* Copy and assignment ops are not supported.  */\n+  typed_splay_tree (const typed_splay_tree &);\n+  typed_splay_tree & operator = (const typed_splay_tree &);\n+\n+  typedef key_type splay_tree_key;\n+  typedef value_type splay_tree_value;\n+\n+  /* The nodes in the splay tree.  */\n+  struct splay_tree_node_s {\n+    /* The key.  */\n+    splay_tree_key key;\n+\n+    /* The value.  */\n+    splay_tree_value value;\n \n-  static int inner_foreach_fn (splay_tree_node node, void *user_data);\n+    /* The left and right children, respectively.  */\n+    splay_tree_node_s *left, *right;\n+\n+    /* Used as temporary value for tree traversals.  */\n+    splay_tree_node_s *back;\n+  };\n+  typedef splay_tree_node_s *splay_tree_node;\n+\n+  inline void KDEL (splay_tree_key);\n+  inline void VDEL (splay_tree_value);\n+  void splay_tree_delete_helper (splay_tree_node);\n+  static inline void rotate_left (splay_tree_node *,\n+\t\t\t\t  splay_tree_node, splay_tree_node);\n+  static inline void rotate_right (splay_tree_node *,\n+\t\t\t\t   splay_tree_node, splay_tree_node);\n+  void splay_tree_splay (splay_tree_key);\n+  static int splay_tree_foreach_helper (splay_tree_node,\n+\t\t\t\t\tforeach_fn, void*);\n+  splay_tree_node splay_tree_insert (splay_tree_key, splay_tree_value);\n+  void splay_tree_remove (splay_tree_key key);\n+  splay_tree_node splay_tree_lookup (splay_tree_key key);\n+  splay_tree_node splay_tree_predecessor (splay_tree_key);\n+  splay_tree_node splay_tree_successor (splay_tree_key);\n+  splay_tree_node splay_tree_max ();\n+  splay_tree_node splay_tree_min ();\n \n   static value_type node_to_value (splay_tree_node node);\n \n- private:\n-  ::splay_tree m_inner;\n+  /* The root of the tree.  */\n+  splay_tree_node root;\n+\n+  /* The comparision function.  */\n+  compare_fn comp;\n+\n+  /* The deallocate-key function.  NULL if no cleanup is necessary.  */\n+  delete_key_fn delete_key;\n+\n+  /* The deallocate-value function.  NULL if no cleanup is necessary.  */\n+  delete_value_fn delete_value;\n };\n \n /* Constructor for typed_splay_tree <K, V>.  */\n@@ -75,12 +112,10 @@ inline typed_splay_tree<KEY_TYPE, VALUE_TYPE>::\n \t\t    delete_key_fn delete_key_fn,\n \t\t    delete_value_fn delete_value_fn)\n {\n-  m_inner = splay_tree_new ((splay_tree_compare_fn)\n-\t\t\t    (void (*) (void)) compare_fn,\n-\t\t\t    (splay_tree_delete_key_fn)\n-\t\t\t    (void (*) (void)) delete_key_fn,\n-\t\t\t    (splay_tree_delete_value_fn)\n-\t\t\t    (void (*) (void)) delete_value_fn);\n+  root = NULL;\n+  comp = compare_fn;\n+  delete_key = delete_key_fn;\n+  delete_value = delete_value_fn;\n }\n \n /* Destructor for typed_splay_tree <K, V>.  */\n@@ -89,7 +124,7 @@ template <typename KEY_TYPE, typename VALUE_TYPE>\n inline typed_splay_tree<KEY_TYPE, VALUE_TYPE>::\n   ~typed_splay_tree ()\n {\n-  splay_tree_delete (m_inner);\n+  splay_tree_delete_helper (root);\n }\n \n /* Lookup KEY, returning a value if present, and NULL\n@@ -99,7 +134,7 @@ template <typename KEY_TYPE, typename VALUE_TYPE>\n inline VALUE_TYPE\n typed_splay_tree<KEY_TYPE, VALUE_TYPE>::lookup (key_type key)\n {\n-  splay_tree_node node = splay_tree_lookup (m_inner, (splay_tree_key)key);\n+  splay_tree_node node = splay_tree_lookup (key);\n   return node_to_value (node);\n }\n \n@@ -110,7 +145,7 @@ template <typename KEY_TYPE, typename VALUE_TYPE>\n inline VALUE_TYPE\n typed_splay_tree<KEY_TYPE, VALUE_TYPE>::predecessor (key_type key)\n {\n-  splay_tree_node node = splay_tree_predecessor (m_inner, (splay_tree_key)key);\n+  splay_tree_node node = splay_tree_predecessor (key);\n   return node_to_value (node);\n }\n \n@@ -119,9 +154,9 @@ typed_splay_tree<KEY_TYPE, VALUE_TYPE>::predecessor (key_type key)\n \n template <typename KEY_TYPE, typename VALUE_TYPE>\n inline VALUE_TYPE\n-typed_splay_tree<KEY_TYPE, VALUE_TYPE>::successor (key_type k)\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::successor (key_type key)\n {\n-  splay_tree_node node = splay_tree_successor (m_inner, (splay_tree_key)k);\n+  splay_tree_node node = splay_tree_successor (key);\n   return node_to_value (node);\n }\n \n@@ -134,9 +169,16 @@ inline void\n typed_splay_tree<KEY_TYPE, VALUE_TYPE>::insert (key_type key,\n \t\t\t\t\t\tvalue_type value)\n {\n-  splay_tree_insert (m_inner,\n-\t\t     (splay_tree_key)key,\n-\t\t     (splay_tree_value)value);\n+  splay_tree_insert (key, value);\n+}\n+\n+/* Remove a node (associating KEY with VALUE).  */\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+inline void\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::remove (key_type key)\n+{\n+  splay_tree_remove (key);\n }\n \n /* Get the value with maximal key.  */\n@@ -145,7 +187,7 @@ template <typename KEY_TYPE, typename VALUE_TYPE>\n inline VALUE_TYPE\n typed_splay_tree<KEY_TYPE, VALUE_TYPE>::max ()\n {\n-  return node_to_value (splay_tree_max (m_inner));\n+  return node_to_value (splay_tree_max ());\n }\n \n /* Get the value with minimal key.  */\n@@ -154,7 +196,7 @@ template <typename KEY_TYPE, typename VALUE_TYPE>\n inline VALUE_TYPE\n typed_splay_tree<KEY_TYPE, VALUE_TYPE>::min ()\n {\n-  return node_to_value (splay_tree_min (m_inner));\n+  return node_to_value (splay_tree_min ());\n }\n \n /* Call OUTER_CB, passing it the OUTER_USER_DATA, for every node,\n@@ -164,37 +206,447 @@ typed_splay_tree<KEY_TYPE, VALUE_TYPE>::min ()\n \n template <typename KEY_TYPE, typename VALUE_TYPE>\n inline int\n-typed_splay_tree<KEY_TYPE, VALUE_TYPE>::foreach (foreach_fn outer_cb,\n-\t\t\t\t\t\t void *outer_user_data)\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::foreach (foreach_fn foreach_fn,\n+\t\t\t\t\t\t void *user_data)\n {\n-  closure c (outer_cb, outer_user_data);\n+  return splay_tree_foreach_helper (root, foreach_fn, user_data);\n+}\n \n-  return splay_tree_foreach (m_inner, inner_foreach_fn, &c);\n+/* Internal function for converting from splay_tree_node to\n+   VALUE_TYPE.  */\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+inline VALUE_TYPE\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::node_to_value (splay_tree_node node)\n+{\n+  if (node)\n+    return node->value;\n+  else\n+    return 0;\n }\n \n-/* Helper function for typed_splay_tree::foreach.  */\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+inline void\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::KDEL(splay_tree_key x)\n+{\n+  if (delete_key)\n+    (*delete_key)(x);\n+}\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+inline void\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::VDEL(splay_tree_value x)\n+{\n+  if (delete_value)\n+    (*delete_value)(x);\n+}\n+\n+/* Deallocate NODE (a member of SP), and all its sub-trees.  */\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+void\n+typed_splay_tree<KEY_TYPE,\n+\t\t VALUE_TYPE>::splay_tree_delete_helper (splay_tree_node node)\n+{\n+  splay_tree_node pending = NULL;\n+  splay_tree_node active = NULL;\n+\n+  if (!node)\n+    return;\n+\n+  KDEL (node->key);\n+  VDEL (node->value);\n+\n+  /* We use the \"back\" field to hold the \"next\" pointer.  */\n+  node->back = pending;\n+  pending = node;\n+\n+  /* Now, keep processing the pending list until there aren't any\n+     more.  This is a little more complicated than just recursing, but\n+     it doesn't toast the stack for large trees.  */\n+\n+  while (pending)\n+    {\n+      active = pending;\n+      pending = NULL;\n+      while (active)\n+\t{\n+\t  splay_tree_node temp;\n+\n+\t  /* active points to a node which has its key and value\n+\t     deallocated, we just need to process left and right.  */\n+\n+\t  if (active->left)\n+\t    {\n+\t      KDEL (active->left->key);\n+\t      VDEL (active->left->value);\n+\t      active->left->back = pending;\n+\t      pending = active->left;\n+\t    }\n+\t  if (active->right)\n+\t    {\n+\t      KDEL (active->right->key);\n+\t      VDEL (active->right->value);\n+\t      active->right->back = pending;\n+\t      pending = active->right;\n+\t    }\n+\n+\t  temp = active;\n+\t  active = temp->back;\n+\t  delete temp;\n+\t}\n+    }\n+}\n+\n+/* Rotate the edge joining the left child N with its parent P.  PP is the\n+   grandparents' pointer to P.  */\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+inline void\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::rotate_left (splay_tree_node *pp,\n+\t\t\t\t\t\t     splay_tree_node p,\n+\t\t\t\t\t\t     splay_tree_node n)\n+{\n+  splay_tree_node tmp;\n+  tmp = n->right;\n+  n->right = p;\n+  p->left = tmp;\n+  *pp = n;\n+}\n+\n+/* Rotate the edge joining the right child N with its parent P.  PP is the\n+   grandparents' pointer to P.  */\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+inline void\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::rotate_right (splay_tree_node *pp,\n+\t\t\t\t\t\t      splay_tree_node p,\n+\t\t\t\t\t\t      splay_tree_node n)\n+{\n+  splay_tree_node tmp;\n+  tmp = n->left;\n+  n->left = p;\n+  p->right = tmp;\n+  *pp = n;\n+}\n+\n+/* Bottom up splay of key.  */\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+void\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::splay_tree_splay (splay_tree_key key)\n+{\n+  if (root == NULL)\n+    return;\n+\n+  do {\n+    int cmp1, cmp2;\n+    splay_tree_node n, c;\n+\n+    n = root;\n+    cmp1 = (*comp) (key, n->key);\n+\n+    /* Found.  */\n+    if (cmp1 == 0)\n+      return;\n+\n+    /* Left or right?  If no child, then we're done.  */\n+    if (cmp1 < 0)\n+      c = n->left;\n+    else\n+      c = n->right;\n+    if (!c)\n+      return;\n+\n+    /* Next one left or right?  If found or no child, we're done\n+       after one rotation.  */\n+    cmp2 = (*comp) (key, c->key);\n+    if (cmp2 == 0\n+\t|| (cmp2 < 0 && !c->left)\n+\t|| (cmp2 > 0 && !c->right))\n+      {\n+\tif (cmp1 < 0)\n+\t  rotate_left (&root, n, c);\n+\telse\n+\t  rotate_right (&root, n, c);\n+\treturn;\n+      }\n+\n+    /* Now we have the four cases of double-rotation.  */\n+    if (cmp1 < 0 && cmp2 < 0)\n+      {\n+\trotate_left (&n->left, c, c->left);\n+\trotate_left (&root, n, n->left);\n+      }\n+    else if (cmp1 > 0 && cmp2 > 0)\n+      {\n+\trotate_right (&n->right, c, c->right);\n+\trotate_right (&root, n, n->right);\n+      }\n+    else if (cmp1 < 0 && cmp2 > 0)\n+      {\n+\trotate_right (&n->left, c, c->right);\n+\trotate_left (&root, n, n->left);\n+      }\n+    else if (cmp1 > 0 && cmp2 < 0)\n+      {\n+\trotate_left (&n->right, c, c->left);\n+\trotate_right (&root, n, n->right);\n+      }\n+  } while (1);\n+}\n+\n+/* Call FN, passing it the DATA, for every node below NODE, all of\n+   which are from SP, following an in-order traversal.  If FN every\n+   returns a non-zero value, the iteration ceases immediately, and the\n+   value is returned.  Otherwise, this function returns 0.  */\n \n template <typename KEY_TYPE, typename VALUE_TYPE>\n int\n-typed_splay_tree<KEY_TYPE, VALUE_TYPE>::inner_foreach_fn (splay_tree_node node,\n-\t\t\t\t\t\t\t  void *user_data)\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::splay_tree_foreach_helper (\n+\t\t\t\t\t\tsplay_tree_node node,\n+\t\t\t\t\t\tforeach_fn fn, void *data)\n {\n-  closure *c = (closure *)user_data;\n+  int val;\n+  splay_tree_node stack;\n+\n+  /* A non-recursive implementation is used to avoid filling the stack\n+     for large trees.  Splay trees are worst case O(n) in the depth of\n+     the tree.  */\n+\n+  stack = NULL;\n+  val = 0;\n+\n+  for (;;)\n+    {\n+      while (node != NULL)\n+\t{\n+\t  node->back = stack;\n+\t  stack = node;\n+\t  node = node->left;\n+\t}\n+\n+      if (stack == NULL)\n+\tbreak;\n+\n+      node = stack;\n+      stack = stack->back;\n+\n+      val = (*fn) (node->key, node->value, data);\n+      if (val)\n+\tbreak;\n \n-  return c->m_outer_cb ((KEY_TYPE)node->key, (VALUE_TYPE)node->value,\n-\t\t\tc->m_outer_user_data);\n+      node = node->right;\n+    }\n+\n+  return val;\n }\n \n-/* Internal function for converting from splay_tree_node to\n-   VALUE_TYPE.  */\n+/* Insert a new node (associating KEY with DATA) into SP.  If a\n+   previous node with the indicated KEY exists, its data is replaced\n+   with the new value.  Returns the new node.  */\n+\n template <typename KEY_TYPE, typename VALUE_TYPE>\n-inline VALUE_TYPE\n-typed_splay_tree<KEY_TYPE, VALUE_TYPE>::node_to_value (splay_tree_node node)\n+typename typed_splay_tree<KEY_TYPE, VALUE_TYPE>::splay_tree_node\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::splay_tree_insert (\n+\t\t\t\t\t\tsplay_tree_key key,\n+\t\t\t\t\t\tsplay_tree_value value)\n {\n-  if (node)\n-    return (value_type)node->value;\n+  int comparison = 0;\n+\n+  splay_tree_splay (key);\n+\n+  if (root)\n+    comparison = (*comp)(root->key, key);\n+\n+  if (root && comparison == 0)\n+    {\n+      /* If the root of the tree already has the indicated KEY, just\n+\t replace the value with VALUE.  */\n+      VDEL(root->value);\n+      root->value = value;\n+    }\n+  else\n+    {\n+      /* Create a new node, and insert it at the root.  */\n+      splay_tree_node node;\n+\n+      node = new splay_tree_node_s;\n+      node->key = key;\n+      node->value = value;\n+\n+      if (!root)\n+\tnode->left = node->right = 0;\n+      else if (comparison < 0)\n+\t{\n+\t  node->left = root;\n+\t  node->right = node->left->right;\n+\t  node->left->right = 0;\n+\t}\n+      else\n+\t{\n+\t  node->right = root;\n+\t  node->left = node->right->left;\n+\t  node->right->left = 0;\n+\t}\n+\n+      root = node;\n+    }\n+\n+  return root;\n+}\n+\n+/* Remove KEY from SP.  It is not an error if it did not exist.  */\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+void\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::splay_tree_remove (splay_tree_key key)\n+{\n+  splay_tree_splay (key);\n+\n+  if (root && (*comp) (root->key, key) == 0)\n+    {\n+      splay_tree_node left, right;\n+\n+      left = root->left;\n+      right = root->right;\n+\n+      /* Delete the root node itself.  */\n+      VDEL (root->value);\n+      delete root;\n+\n+      /* One of the children is now the root.  Doesn't matter much\n+\t which, so long as we preserve the properties of the tree.  */\n+      if (left)\n+\t{\n+\t  root = left;\n+\n+\t  /* If there was a right child as well, hang it off the\n+\t     right-most leaf of the left child.  */\n+\t  if (right)\n+\t    {\n+\t      while (left->right)\n+\t\tleft = left->right;\n+\t      left->right = right;\n+\t    }\n+\t}\n+      else\n+\troot = right;\n+    }\n+}\n+\n+/* Lookup KEY in SP, returning VALUE if present, and NULL\n+   otherwise.  */\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+typename typed_splay_tree<KEY_TYPE, VALUE_TYPE>::splay_tree_node\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::splay_tree_lookup (splay_tree_key key)\n+{\n+  splay_tree_splay (key);\n+\n+  if (root && (*comp)(root->key, key) == 0)\n+    return root;\n   else\n     return 0;\n }\n \n+/* Return the node in SP with the greatest key.  */\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+typename typed_splay_tree<KEY_TYPE, VALUE_TYPE>::splay_tree_node\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::splay_tree_max ()\n+{\n+  splay_tree_node n = root;\n+\n+  if (!n)\n+    return NULL;\n+\n+  while (n->right)\n+    n = n->right;\n+\n+  return n;\n+}\n+\n+/* Return the node in SP with the smallest key.  */\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+typename typed_splay_tree<KEY_TYPE, VALUE_TYPE>::splay_tree_node\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::splay_tree_min ()\n+{\n+  splay_tree_node n = root;\n+\n+  if (!n)\n+    return NULL;\n+\n+  while (n->left)\n+    n = n->left;\n+\n+  return n;\n+}\n+\n+/* Return the immediate predecessor KEY, or NULL if there is no\n+   predecessor.  KEY need not be present in the tree.  */\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+typename typed_splay_tree<KEY_TYPE, VALUE_TYPE>::splay_tree_node\n+typed_splay_tree<KEY_TYPE,\n+\t\t VALUE_TYPE>::splay_tree_predecessor (splay_tree_key key)\n+{\n+  int comparison;\n+  splay_tree_node node;\n+\n+  /* If the tree is empty, there is certainly no predecessor.  */\n+  if (!root)\n+    return NULL;\n+\n+  /* Splay the tree around KEY.  That will leave either the KEY\n+     itself, its predecessor, or its successor at the root.  */\n+  splay_tree_splay (key);\n+  comparison = (*comp)(root->key, key);\n+\n+  /* If the predecessor is at the root, just return it.  */\n+  if (comparison < 0)\n+    return root;\n+\n+  /* Otherwise, find the rightmost element of the left subtree.  */\n+  node = root->left;\n+  if (node)\n+    while (node->right)\n+      node = node->right;\n+\n+  return node;\n+}\n+\n+/* Return the immediate successor KEY, or NULL if there is no\n+   successor.  KEY need not be present in the tree.  */\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+typename typed_splay_tree<KEY_TYPE, VALUE_TYPE>::splay_tree_node\n+typed_splay_tree<KEY_TYPE,\n+\t\t VALUE_TYPE>::splay_tree_successor (splay_tree_key key)\n+{\n+  int comparison;\n+  splay_tree_node node;\n+\n+  /* If the tree is empty, there is certainly no successor.  */\n+  if (!root)\n+    return NULL;\n+\n+  /* Splay the tree around KEY.  That will leave either the KEY\n+     itself, its predecessor, or its successor at the root.  */\n+  splay_tree_splay (key);\n+  comparison = (*comp)(root->key, key);\n+\n+  /* If the successor is at the root, just return it.  */\n+  if (comparison > 0)\n+    return root;\n+\n+  /* Otherwise, find the leftmost element of the right subtree.  */\n+  node = root->right;\n+  if (node)\n+    while (node->left)\n+      node = node->left;\n+\n+  return node;\n+}\n+\n #endif  /* GCC_TYPED_SPLAY_TREE_H  */"}]}