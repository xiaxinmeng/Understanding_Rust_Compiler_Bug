{"sha": "e09173d84dabd186ad2463f47350c1bcabfeab8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA5MTczZDg0ZGFiZDE4NmFkMjQ2M2Y0NzM1MGMxYmNhYmZlYWI4Zg==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-01-14T20:57:17Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-01-14T20:57:17Z"}, "message": "slp: support complex multiply and complex multiply conjugate\n\nThis adds support for complex multiply and complex multiply and accumulate to\nthe vect pattern detector.\n\nExample of instructions matched:\n\n#include <stdio.h>\n#include <complex.h>\n\n#define N 200\n#define ROT\n#define TYPE float\n#define TYPE2 float\n\nvoid g (TYPE2 complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n{\n  for (int i=0; i < N; i++)\n    {\n      c[i] =  a[i] * (b[i] ROT);\n    }\n}\n\nvoid g_f1 (TYPE2 complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n{\n  for (int i=0; i < N; i++)\n    {\n      c[i] =  conjf (a[i]) * (b[i] ROT);\n    }\n}\n\nvoid g_s1 (TYPE2 complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n{\n  for (int i=0; i < N; i++)\n    {\n      c[i] =  a[i] * conjf (b[i] ROT);\n    }\n}\n\ngcc/ChangeLog:\n\n\t* internal-fn.def (COMPLEX_MUL, COMPLEX_MUL_CONJ): New.\n\t* optabs.def (cmul_optab, cmul_conj_optab): New.\n\t* doc/md.texi: Document them.\n\t* tree-vect-slp-patterns.c (vect_match_call_complex_mla,\n\tvect_normalize_conj_loc, is_eq_or_top, vect_validate_multiplication,\n\tvect_build_combine_node, class complex_mul_pattern,\n\tcomplex_mul_pattern::matches, complex_mul_pattern::recognize,\n\tcomplex_mul_pattern::build): New.", "tree": {"sha": "8b76954fcb2ae4aed721b553fe421f2b7eb8d982", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b76954fcb2ae4aed721b553fe421f2b7eb8d982"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e09173d84dabd186ad2463f47350c1bcabfeab8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e09173d84dabd186ad2463f47350c1bcabfeab8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e09173d84dabd186ad2463f47350c1bcabfeab8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e09173d84dabd186ad2463f47350c1bcabfeab8f/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "500600c78408ab4c6450c7eeaea2e3657e305ed2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/500600c78408ab4c6450c7eeaea2e3657e305ed2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/500600c78408ab4c6450c7eeaea2e3657e305ed2"}], "stats": {"total": 416, "additions": 416, "deletions": 0}, "files": [{"sha": "60e8c94810a3f27a4fa8d59367b0710323504e9c", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09173d84dabd186ad2463f47350c1bcabfeab8f/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09173d84dabd186ad2463f47350c1bcabfeab8f/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=e09173d84dabd186ad2463f47350c1bcabfeab8f", "patch": "@@ -6202,6 +6202,50 @@ The operation is only supported for vector modes @var{m}.\n \n This pattern is not allowed to @code{FAIL}.\n \n+@cindex @code{cmul@var{m}4} instruction pattern\n+@item @samp{cmul@var{m}4}\n+Perform a vector multiply that is semantically the same as multiply of\n+complex numbers.\n+\n+@smallexample\n+  complex TYPE c[N];\n+  complex TYPE a[N];\n+  complex TYPE b[N];\n+  for (int i = 0; i < N; i += 1)\n+    @{\n+      c[i] = a[i] * b[i];\n+    @}\n+@end smallexample\n+\n+In GCC lane ordering the real part of the number must be in the even lanes with\n+the imaginary part in the odd lanes.\n+\n+The operation is only supported for vector modes @var{m}.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n+@cindex @code{cmul_conj@var{m}4} instruction pattern\n+@item @samp{cmul_conj@var{m}4}\n+Perform a vector multiply by conjugate that is semantically the same as a\n+multiply of complex numbers where the second multiply arguments is conjugated.\n+\n+@smallexample\n+  complex TYPE c[N];\n+  complex TYPE a[N];\n+  complex TYPE b[N];\n+  for (int i = 0; i < N; i += 1)\n+    @{\n+      c[i] = a[i] * conj (b[i]);\n+    @}\n+@end smallexample\n+\n+In GCC lane ordering the real part of the number must be in the even lanes with\n+the imaginary part in the odd lanes.\n+\n+The operation is only supported for vector modes @var{m}.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n @cindex @code{ffs@var{m}2} instruction pattern\n @item @samp{ffs@var{m}2}\n Store into operand 0 one plus the index of the least significant 1-bit"}, {"sha": "e3e4fe5ebadb446408b68b7408f4b86f42695b8d", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09173d84dabd186ad2463f47350c1bcabfeab8f/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09173d84dabd186ad2463f47350c1bcabfeab8f/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=e09173d84dabd186ad2463f47350c1bcabfeab8f", "patch": "@@ -279,6 +279,8 @@ DEF_INTERNAL_FLT_FLOATN_FN (FMAX, ECF_CONST, fmax, binary)\n DEF_INTERNAL_OPTAB_FN (XORSIGN, ECF_CONST, xorsign, binary)\n DEF_INTERNAL_OPTAB_FN (COMPLEX_ADD_ROT90, ECF_CONST, cadd90, binary)\n DEF_INTERNAL_OPTAB_FN (COMPLEX_ADD_ROT270, ECF_CONST, cadd270, binary)\n+DEF_INTERNAL_OPTAB_FN (COMPLEX_MUL, ECF_CONST, cmul, binary)\n+DEF_INTERNAL_OPTAB_FN (COMPLEX_MUL_CONJ, ECF_CONST, cmul_conj, binary)\n \n \n /* FP scales.  */"}, {"sha": "fcc27d00dbadb8dd0f6793c12d45e8c5a5ab509e", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09173d84dabd186ad2463f47350c1bcabfeab8f/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09173d84dabd186ad2463f47350c1bcabfeab8f/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=e09173d84dabd186ad2463f47350c1bcabfeab8f", "patch": "@@ -292,6 +292,8 @@ OPTAB_D (copysign_optab, \"copysign$F$a3\")\n OPTAB_D (xorsign_optab, \"xorsign$F$a3\")\n OPTAB_D (cadd90_optab, \"cadd90$a3\")\n OPTAB_D (cadd270_optab, \"cadd270$a3\")\n+OPTAB_D (cmul_optab, \"cmul$a3\")\n+OPTAB_D (cmul_conj_optab, \"cmul_conj$a3\")\n OPTAB_D (cos_optab, \"cos$a2\")\n OPTAB_D (cosh_optab, \"cosh$a2\")\n OPTAB_D (exp10_optab, \"exp10$a2\")"}, {"sha": "dc96be51dfe2f8176621183f7e8f61da0252c770", "filename": "gcc/tree-vect-slp-patterns.c", "status": "modified", "additions": 368, "deletions": 0, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09173d84dabd186ad2463f47350c1bcabfeab8f/gcc%2Ftree-vect-slp-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09173d84dabd186ad2463f47350c1bcabfeab8f/gcc%2Ftree-vect-slp-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp-patterns.c?ref=e09173d84dabd186ad2463f47350c1bcabfeab8f", "patch": "@@ -717,6 +717,374 @@ complex_add_pattern::recognize (slp_tree_to_load_perm_map_t *perm_cache,\n   return new complex_add_pattern (node, &ops, ifn);\n }\n \n+/*******************************************************************************\n+ * complex_mul_pattern\n+ ******************************************************************************/\n+\n+/* Helper function of that looks for a match in the CHILDth child of NODE.  The\n+   child used is stored in RES.\n+\n+   If the match is successful then ARGS will contain the operands matched\n+   and the complex_operation_t type is returned.  If match is not successful\n+   then CMPLX_NONE is returned and ARGS is left unmodified.  */\n+\n+static inline complex_operation_t\n+vect_match_call_complex_mla (slp_tree node, unsigned child,\n+\t\t\t     vec<slp_tree> *args = NULL, slp_tree *res = NULL)\n+{\n+  gcc_assert (child < SLP_TREE_CHILDREN (node).length ());\n+\n+  slp_tree data = SLP_TREE_CHILDREN (node)[child];\n+\n+  if (res)\n+    *res = data;\n+\n+  return vect_detect_pair_op (data, false, args);\n+}\n+\n+/* Check to see if either of the trees in ARGS are a NEGATE_EXPR.  If the first\n+   child (args[0]) is a NEGATE_EXPR then NEG_FIRST_P is set to TRUE.\n+\n+   If a negate is found then the values in ARGS are reordered such that the\n+   negate node is always the second one and the entry is replaced by the child\n+   of the negate node.  */\n+\n+static inline bool\n+vect_normalize_conj_loc (vec<slp_tree> args, bool *neg_first_p = NULL)\n+{\n+  gcc_assert (args.length () == 2);\n+  bool neg_found = false;\n+\n+  if (vect_match_expression_p (args[0], NEGATE_EXPR))\n+    {\n+      std::swap (args[0], args[1]);\n+      neg_found = true;\n+      if (neg_first_p)\n+\t*neg_first_p = true;\n+    }\n+  else if (vect_match_expression_p (args[1], NEGATE_EXPR))\n+    {\n+      neg_found = true;\n+      if (neg_first_p)\n+\t*neg_first_p = false;\n+    }\n+\n+  if (neg_found)\n+    args[1] = SLP_TREE_CHILDREN (args[1])[0];\n+\n+  return neg_found;\n+}\n+\n+/* Helper function to check if PERM is KIND or PERM_TOP.  */\n+\n+static inline bool\n+is_eq_or_top (complex_load_perm_t perm, complex_perm_kinds_t kind)\n+{\n+  return perm.first == kind || perm.first == PERM_TOP;\n+}\n+\n+/* Helper function that checks to see if LEFT_OP and RIGHT_OP are both MULT_EXPR\n+   nodes but also that they represent an operation that is either a complex\n+   multiplication or a complex multiplication by conjugated value.\n+\n+   Of the negation is expected to be in the first half of the tree (As required\n+   by an FMS pattern) then NEG_FIRST is true.  If the operation is a conjugate\n+   operation then CONJ_FIRST_OPERAND is set to indicate whether the first or\n+   second operand contains the conjugate operation.  */\n+\n+static inline bool\n+vect_validate_multiplication (slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t     vec<slp_tree> left_op, vec<slp_tree> right_op,\n+\t\t\t     bool neg_first, bool *conj_first_operand,\n+\t\t\t     bool fms)\n+{\n+  /* The presence of a negation indicates that we have either a conjugate or a\n+     rotation.  We need to distinguish which one.  */\n+  *conj_first_operand = false;\n+  complex_perm_kinds_t kind;\n+\n+  /* Complex conjugates have the negation on the imaginary part of the\n+     number where rotations affect the real component.  So check if the\n+     negation is on a dup of lane 1.  */\n+  if (fms)\n+    {\n+      /* Canonicalization for fms is not consistent. So have to test both\n+\t variants to be sure.  This needs to be fixed in the mid-end so\n+\t this part can be simpler.  */\n+      kind = linear_loads_p (perm_cache, right_op[0]).first;\n+      if (!((kind == PERM_ODDODD\n+\t   && is_eq_or_top (linear_loads_p (perm_cache, right_op[1]),\n+\t\t\t     PERM_ODDEVEN))\n+\t  || (kind == PERM_ODDEVEN\n+\t      && is_eq_or_top (linear_loads_p (perm_cache, right_op[1]),\n+\t\t\t     PERM_ODDODD))))\n+\treturn false;\n+    }\n+  else\n+    {\n+      if (linear_loads_p (perm_cache, right_op[1]).first != PERM_ODDODD\n+\t  && !is_eq_or_top (linear_loads_p (perm_cache, right_op[0]),\n+\t\t\t    PERM_ODDEVEN))\n+\treturn false;\n+    }\n+\n+  /* Deal with differences in indexes.  */\n+  int index1 = fms ? 1 : 0;\n+  int index2 = fms ? 0 : 1;\n+\n+  /* Check if the conjugate is on the second first or second operand.  The\n+     order of the node with the conjugate value determines this, and the dup\n+     node must be one of lane 0 of the same DR as the neg node.  */\n+  kind = linear_loads_p (perm_cache, left_op[index1]).first;\n+  if (kind == PERM_TOP)\n+    {\n+      if (linear_loads_p (perm_cache, left_op[index2]).first == PERM_EVENODD)\n+\treturn true;\n+    }\n+  else if (kind == PERM_EVENODD)\n+    {\n+      if ((kind = linear_loads_p (perm_cache, left_op[index2]).first) == PERM_EVENODD)\n+\treturn false;\n+    }\n+  else if (!neg_first)\n+    *conj_first_operand = true;\n+  else\n+    return false;\n+\n+  if (kind != PERM_EVENEVEN)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Helper function to help distinguish between a conjugate and a rotation in a\n+   complex multiplication.  The operations have similar shapes but the order of\n+   the load permutes are different.  This function returns TRUE when the order\n+   is consistent with a multiplication or multiplication by conjugated\n+   operand but returns FALSE if it's a multiplication by rotated operand.  */\n+\n+static inline bool\n+vect_validate_multiplication (slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t     vec<slp_tree> op, complex_perm_kinds_t permKind)\n+{\n+  /* The left node is the more common case, test it first.  */\n+  if (!is_eq_or_top (linear_loads_p (perm_cache, op[0]), permKind))\n+    {\n+      if (!is_eq_or_top (linear_loads_p (perm_cache, op[1]), permKind))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* This function combines two nodes containing only even and only odd lanes\n+   together into a single node which contains the nodes in even/odd order\n+   by using a lane permute.\n+\n+   The lanes in EVEN and ODD are duplicated 2 times inside the vectors.\n+   So for a lanes = 4 EVEN contains {EVEN1, EVEN1, EVEN2, EVEN2}.\n+\n+   The tree REPRESENTATION is taken from the supplied REP along with the\n+   vectype which must be the same between all three nodes.\n+*/\n+\n+static slp_tree\n+vect_build_combine_node (slp_tree even, slp_tree odd, slp_tree rep)\n+{\n+  vec<std::pair<unsigned, unsigned> > perm;\n+  perm.create (SLP_TREE_LANES (rep));\n+\n+  for (unsigned x = 0; x < SLP_TREE_LANES (rep); x+=2)\n+    {\n+      perm.quick_push (std::make_pair (0, x));\n+      perm.quick_push (std::make_pair (1, x+1));\n+    }\n+\n+  slp_tree vnode = vect_create_new_slp_node (2, SLP_TREE_CODE (even));\n+  SLP_TREE_CODE (vnode) = VEC_PERM_EXPR;\n+  SLP_TREE_LANE_PERMUTATION (vnode) = perm;\n+\n+  SLP_TREE_CHILDREN (vnode).create (2);\n+  SLP_TREE_CHILDREN (vnode).quick_push (even);\n+  SLP_TREE_CHILDREN (vnode).quick_push (odd);\n+  SLP_TREE_REF_COUNT (even)++;\n+  SLP_TREE_REF_COUNT (odd)++;\n+  SLP_TREE_REF_COUNT (vnode) = 1;\n+\n+  SLP_TREE_LANES (vnode) = SLP_TREE_LANES (rep);\n+  gcc_assert (perm.length () == SLP_TREE_LANES (vnode));\n+  /* Representation is set to that of the current node as the vectorizer\n+     can't deal with VEC_PERMs with no representation, as would be the\n+     case with invariants.  */\n+  SLP_TREE_REPRESENTATIVE (vnode) = SLP_TREE_REPRESENTATIVE (rep);\n+  SLP_TREE_VECTYPE (vnode) = SLP_TREE_VECTYPE (rep);\n+  return vnode;\n+}\n+\n+class complex_mul_pattern : public complex_pattern\n+{\n+  protected:\n+    complex_mul_pattern (slp_tree *node, vec<slp_tree> *m_ops, internal_fn ifn)\n+      : complex_pattern (node, m_ops, ifn)\n+    {\n+      this->m_num_args = 2;\n+    }\n+\n+  public:\n+    void build (vec_info *);\n+    static internal_fn\n+    matches (complex_operation_t op, slp_tree_to_load_perm_map_t *, slp_tree *,\n+\t     vec<slp_tree> *);\n+\n+    static vect_pattern*\n+    recognize (slp_tree_to_load_perm_map_t *, slp_tree *);\n+\n+    static vect_pattern*\n+    mkInstance (slp_tree *node, vec<slp_tree> *m_ops, internal_fn ifn)\n+    {\n+      return new complex_mul_pattern (node, m_ops, ifn);\n+    }\n+\n+};\n+\n+/* Pattern matcher for trying to match complex multiply pattern in SLP tree\n+   If the operation matches then IFN is set to the operation it matched\n+   and the arguments to the two replacement statements are put in m_ops.\n+\n+   If no match is found then IFN is set to IFN_LAST and m_ops is unchanged.\n+\n+   This function matches the patterns shaped as:\n+\n+   double ax = (b[i+1] * a[i]);\n+   double bx = (a[i+1] * b[i]);\n+\n+   c[i] = c[i] - ax;\n+   c[i+1] = c[i+1] + bx;\n+\n+   If a match occurred then TRUE is returned, else FALSE.  The initial match is\n+   expected to be in OP1 and the initial match operands in args0.  */\n+\n+internal_fn\n+complex_mul_pattern::matches (complex_operation_t op,\n+\t\t\t      slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t      slp_tree *node, vec<slp_tree> *ops)\n+{\n+  internal_fn ifn = IFN_LAST;\n+\n+  if (op != MINUS_PLUS)\n+    return IFN_LAST;\n+\n+  slp_tree root = *node;\n+  /* First two nodes must be a multiply.  */\n+  auto_vec<slp_tree> muls;\n+  if (vect_match_call_complex_mla (root, 0) != MULT_MULT\n+      || vect_match_call_complex_mla (root, 1, &muls) != MULT_MULT)\n+    return IFN_LAST;\n+\n+  /* Now operand2+4 may lead to another expression.  */\n+  auto_vec<slp_tree> left_op, right_op;\n+  left_op.safe_splice (SLP_TREE_CHILDREN (muls[0]));\n+  right_op.safe_splice (SLP_TREE_CHILDREN (muls[1]));\n+\n+  if (linear_loads_p (perm_cache, left_op[1]).first == PERM_ODDEVEN)\n+    return IFN_LAST;\n+\n+  bool neg_first = false;\n+  bool conj_first_operand = false;\n+  bool is_neg = vect_normalize_conj_loc (right_op, &neg_first);\n+\n+  if (!is_neg)\n+    {\n+      /* A multiplication needs to multiply agains the real pair, otherwise\n+\t the pattern matches that of FMS.   */\n+      if (!vect_validate_multiplication (perm_cache, left_op, PERM_EVENEVEN)\n+\t  || vect_normalize_conj_loc (left_op))\n+\treturn IFN_LAST;\n+      ifn = IFN_COMPLEX_MUL;\n+    }\n+  else if (is_neg)\n+    {\n+      if (!vect_validate_multiplication (perm_cache, left_op, right_op,\n+\t\t\t\t\t neg_first, &conj_first_operand,\n+\t\t\t\t\t false))\n+\treturn IFN_LAST;\n+\n+      ifn = IFN_COMPLEX_MUL_CONJ;\n+    }\n+\n+  if (!vect_pattern_validate_optab (ifn, *node))\n+    return IFN_LAST;\n+\n+  ops->truncate (0);\n+  ops->create (3);\n+\n+  complex_perm_kinds_t kind = linear_loads_p (perm_cache, left_op[0]).first;\n+  if (kind == PERM_EVENODD)\n+    {\n+      ops->quick_push (left_op[1]);\n+      ops->quick_push (right_op[1]);\n+      ops->quick_push (left_op[0]);\n+    }\n+  else if (kind == PERM_TOP)\n+    {\n+      ops->quick_push (left_op[1]);\n+      ops->quick_push (right_op[1]);\n+      ops->quick_push (left_op[0]);\n+    }\n+  else if (kind == PERM_EVENEVEN && !conj_first_operand)\n+    {\n+      ops->quick_push (left_op[0]);\n+      ops->quick_push (right_op[0]);\n+      ops->quick_push (left_op[1]);\n+    }\n+  else\n+    {\n+      ops->quick_push (left_op[0]);\n+      ops->quick_push (right_op[1]);\n+      ops->quick_push (left_op[1]);\n+    }\n+\n+  return ifn;\n+}\n+\n+/* Attempt to recognize a complex mul pattern.  */\n+\n+vect_pattern*\n+complex_mul_pattern::recognize (slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t\tslp_tree *node)\n+{\n+  auto_vec<slp_tree> ops;\n+  complex_operation_t op\n+    = vect_detect_pair_op (*node, true, &ops);\n+  internal_fn ifn\n+    = complex_mul_pattern::matches (op, perm_cache, node, &ops);\n+  if (ifn == IFN_LAST)\n+    return NULL;\n+\n+  return new complex_mul_pattern (node, &ops, ifn);\n+}\n+\n+/* Perform a replacement of the detected complex mul pattern with the new\n+   instruction sequences.  */\n+\n+void\n+complex_mul_pattern::build (vec_info *vinfo)\n+{\n+  slp_tree node;\n+  unsigned i;\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (*this->m_node), i, node)\n+    vect_free_slp_tree (node);\n+\n+  /* First re-arrange the children.  */\n+  SLP_TREE_CHILDREN (*this->m_node).reserve_exact (2);\n+  SLP_TREE_CHILDREN (*this->m_node)[0] = this->m_ops[2];\n+  SLP_TREE_CHILDREN (*this->m_node)[1] =\n+    vect_build_combine_node (this->m_ops[0], this->m_ops[1], *this->m_node);\n+  SLP_TREE_REF_COUNT (this->m_ops[2])++;\n+\n+  /* And then rewrite the node itself.  */\n+  complex_pattern::build (vinfo);\n+}\n+\n /*******************************************************************************\n  * Pattern matching definitions\n  ******************************************************************************/"}]}