{"sha": "638381579be16f630292273a23ffc9282906ada9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM4MzgxNTc5YmUxNmY2MzAyOTIyNzNhMjNmZmM5MjgyOTA2YWRhOQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-09-02T11:58:27Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-09-02T11:58:27Z"}, "message": "revert: builtins.c (fold_builtin_memory_op): Use the alias oracle to query if the memory regions for memmove overlap.\n\n2009-09-02  Richard Guenther  <rguenther@suse.de>\n\n        Revert\n        2009-08-31  Richard Guenther  <rguenther@suse.de>\n\n        * builtins.c (fold_builtin_memory_op): Use the alias oracle\n        to query if the memory regions for memmove overlap.\n        * tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Relax the\n        asserts on pointers, instead deal with odd trees.\n        (ptr_derefs_may_alias_p): Likewise.\n        (refs_may_alias_p_1): Constructor bases also never alias.\n\nFrom-SVN: r151320", "tree": {"sha": "8abc37f10cdf2132775fb5ee7b794240831fd6ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8abc37f10cdf2132775fb5ee7b794240831fd6ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/638381579be16f630292273a23ffc9282906ada9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/638381579be16f630292273a23ffc9282906ada9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/638381579be16f630292273a23ffc9282906ada9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/638381579be16f630292273a23ffc9282906ada9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "42c089971e4987c1fc1338d7ff659f2be9c9b7e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42c089971e4987c1fc1338d7ff659f2be9c9b7e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42c089971e4987c1fc1338d7ff659f2be9c9b7e5"}], "stats": {"total": 100, "additions": 82, "deletions": 18}, "files": [{"sha": "a35edee60a11da11d5c9c19cffd620ed8525b64f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/638381579be16f630292273a23ffc9282906ada9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/638381579be16f630292273a23ffc9282906ada9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=638381579be16f630292273a23ffc9282906ada9", "patch": "@@ -1,3 +1,15 @@\n+2009-09-02  Richard Guenther  <rguenther@suse.de>\n+\n+\tRevert\n+\t2009-08-31  Richard Guenther  <rguenther@suse.de>\n+\n+\t* builtins.c (fold_builtin_memory_op): Use the alias oracle\n+\tto query if the memory regions for memmove overlap.\n+\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Relax the\n+\tasserts on pointers, instead deal with odd trees.\n+\t(ptr_derefs_may_alias_p): Likewise.\n+\t(refs_may_alias_p_1): Constructor bases also never alias.\n+\n 2009-08-01  Christian Bruel  <christian.bruel@st.com>\n \n \tRevert:"}, {"sha": "b657275720e806227825a647929ff583c7d1ad12", "filename": "gcc/builtins.c", "status": "modified", "additions": 51, "deletions": 7, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/638381579be16f630292273a23ffc9282906ada9/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/638381579be16f630292273a23ffc9282906ada9/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=638381579be16f630292273a23ffc9282906ada9", "patch": "@@ -8990,8 +8990,6 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n \n       if (endp == 3)\n \t{\n-\t  ao_ref srcref, destref;\n-\n \t  src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n \t  dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n \n@@ -9014,16 +9012,62 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n \t    }\n \n \t  /* If *src and *dest can't overlap, optimize into memcpy as well.  */\n-\t  ao_ref_init_from_ptr_and_size (&srcref, src, len);\n-\t  ao_ref_init_from_ptr_and_size (&destref, dest, len);\n-\t  if (!refs_may_alias_p_1 (&srcref, &destref, false))\n+\t  srcvar = build_fold_indirect_ref_loc (loc, src);\n+\t  destvar = build_fold_indirect_ref_loc (loc, dest);\n+\t  if (srcvar\n+\t      && !TREE_THIS_VOLATILE (srcvar)\n+\t      && destvar\n+\t      && !TREE_THIS_VOLATILE (destvar))\n \t    {\n-\t      tree fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+\t      tree src_base, dest_base, fn;\n+\t      HOST_WIDE_INT src_offset = 0, dest_offset = 0;\n+\t      HOST_WIDE_INT size = -1;\n+\t      HOST_WIDE_INT maxsize = -1;\n+\n+\t      src_base = srcvar;\n+\t      if (handled_component_p (src_base))\n+\t\tsrc_base = get_ref_base_and_extent (src_base, &src_offset,\n+\t\t\t\t\t\t    &size, &maxsize);\n+\t      dest_base = destvar;\n+\t      if (handled_component_p (dest_base))\n+\t\tdest_base = get_ref_base_and_extent (dest_base, &dest_offset,\n+\t\t\t\t\t\t     &size, &maxsize);\n+\t      if (host_integerp (len, 1))\n+\t\t{\n+\t\t  maxsize = tree_low_cst (len, 1);\n+\t\t  if (maxsize\n+\t\t      > INTTYPE_MAXIMUM (HOST_WIDE_INT) / BITS_PER_UNIT)\n+\t\t    maxsize = -1;\n+\t\t  else\n+\t\t    maxsize *= BITS_PER_UNIT;\n+\t\t}\n+\t      else\n+\t\tmaxsize = -1;\n+\t      if (SSA_VAR_P (src_base)\n+\t\t  && SSA_VAR_P (dest_base))\n+\t\t{\n+\t\t  if (operand_equal_p (src_base, dest_base, 0)\n+\t\t      && ranges_overlap_p (src_offset, maxsize,\n+\t\t\t\t\t   dest_offset, maxsize))\n+\t\t    return NULL_TREE;\n+\t\t}\n+\t      else if (TREE_CODE (src_base) == INDIRECT_REF\n+\t\t       && TREE_CODE (dest_base) == INDIRECT_REF)\n+\t\t{\n+\t\t  if (! operand_equal_p (TREE_OPERAND (src_base, 0),\n+\t\t\t\t\t TREE_OPERAND (dest_base, 0), 0)\n+\t\t      || ranges_overlap_p (src_offset, maxsize,\n+\t\t\t\t\t   dest_offset, maxsize))\n+\t\t    return NULL_TREE;\n+\t\t}\n+\t      else\n+\t\treturn NULL_TREE;\n+\n+\t      fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n \t      if (!fn)\n \t\treturn NULL_TREE;\n \t      return build_call_expr_loc (loc, fn, 3, dest, src, len);\n \t    }\n-\n \t  return NULL_TREE;\n \t}\n "}, {"sha": "7e83a84b82ce063dac09d617b5aa1c082bd8c269", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/638381579be16f630292273a23ffc9282906ada9/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/638381579be16f630292273a23ffc9282906ada9/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=638381579be16f630292273a23ffc9282906ada9", "patch": "@@ -168,9 +168,12 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n {\n   struct ptr_info_def *pi;\n \n-  gcc_assert (TREE_CODE (decl) == VAR_DECL\n-\t      || TREE_CODE (decl) == PARM_DECL\n-\t      || TREE_CODE (decl) == RESULT_DECL);\n+  gcc_assert ((TREE_CODE (ptr) == SSA_NAME\n+\t       || TREE_CODE (ptr) == ADDR_EXPR\n+\t       || TREE_CODE (ptr) == INTEGER_CST)\n+\t      && (TREE_CODE (decl) == VAR_DECL\n+\t\t  || TREE_CODE (decl) == PARM_DECL\n+\t\t  || TREE_CODE (decl) == RESULT_DECL));\n \n   /* Non-aliased variables can not be pointed to.  */\n   if (!may_be_aliased (decl))\n@@ -194,9 +197,9 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n \treturn true;\n     }\n \n-  /* We can end up with dereferencing non-SSA name pointers.\n+  /* We can end up with dereferencing constant pointers.\n      Just bail out in this case.  */\n-  if (TREE_CODE (ptr) != SSA_NAME)\n+  if (TREE_CODE (ptr) == INTEGER_CST)\n     return true;\n \n   /* If we do not have useful points-to information for this pointer\n@@ -217,6 +220,13 @@ ptr_derefs_may_alias_p (tree ptr1, tree ptr2)\n {\n   struct ptr_info_def *pi1, *pi2;\n \n+  gcc_assert ((TREE_CODE (ptr1) == SSA_NAME\n+\t       || TREE_CODE (ptr1) == ADDR_EXPR\n+\t       || TREE_CODE (ptr1) == INTEGER_CST)\n+\t      && (TREE_CODE (ptr2) == SSA_NAME\n+\t\t  || TREE_CODE (ptr2) == ADDR_EXPR\n+\t\t  || TREE_CODE (ptr2) == INTEGER_CST));\n+\n   /* ADDR_EXPR pointers either just offset another pointer or directly\n      specify the pointed-to set.  */\n   if (TREE_CODE (ptr1) == ADDR_EXPR)\n@@ -244,10 +254,10 @@ ptr_derefs_may_alias_p (tree ptr1, tree ptr2)\n \treturn true;\n     }\n \n-  /* We can end up with dereferencing non-SSA name pointers.\n+  /* We can end up with dereferencing constant pointers.\n      Just bail out in this case.  */\n-  if (TREE_CODE (ptr1) != SSA_NAME \n-      || TREE_CODE (ptr2) != SSA_NAME)\n+  if (TREE_CODE (ptr1) == INTEGER_CST\n+      || TREE_CODE (ptr2) == INTEGER_CST)\n     return true;\n \n   /* We may end up with two empty points-to solutions for two same pointers.\n@@ -771,9 +781,7 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n   if (TREE_CODE (base1) == SSA_NAME\n       || TREE_CODE (base2) == SSA_NAME\n       || is_gimple_min_invariant (base1)\n-      || is_gimple_min_invariant (base2)\n-      || TREE_CODE (base1) == CONSTRUCTOR\n-      || TREE_CODE (base2) == CONSTRUCTOR)\n+      || is_gimple_min_invariant (base2))\n     return false;\n \n   /* Defer to simple offset based disambiguation if we have"}]}