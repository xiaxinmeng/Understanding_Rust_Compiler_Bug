{"sha": "ab22c1fa94acc05ddfe9403debd55a69a714723e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIyMmMxZmE5NGFjYzA1ZGRmZTk0MDNkZWJkNTVhNjlhNzE0NzIzZQ==", "commit": {"author": {"name": "Chao-ying Fu", "email": "fu@mips.com", "date": "2007-08-20T22:26:47Z"}, "committer": {"name": "Chao-ying Fu", "email": "chaoyingfu@gcc.gnu.org", "date": "2007-08-20T22:26:47Z"}, "message": "c-common.h (enum rid): Add new enumeration values of RID_SAT, RID_FRACT, and RID_ACCUM.\n\n\t* c-common.h (enum rid): Add new enumeration values of RID_SAT,\n\tRID_FRACT, and RID_ACCUM.  RID_SAT needs to be inserted before\n\tRID_ONEWAY, so that it can be checked in declspecs_add_type.\n\t(c_common_fixed_point_type_for_size): Declare.\n\t* c-parser.c (reswords): Add _Fract, _Accum, and _Sat.\n\t(c_token_starts_typename): Handle RID_FRACT, RID_ACCUM, and RID_SAT.\n\t(c_token_starts_declspecs): Likewise.\n\t(c_parser_declspecs): Likewise.\n\t(c_parser_attributes): Likewise.\n\t* c-tree.h (enum c_typespec_keyword): Add cts_fract and cts_accum.\n\t(c_declspecs): Add saturating_p.\n\t* c-decl.c (build_null_declspecs): Initialize saturating_p.\n\t(declspecs_add_type): Avoid using complex with _Fract, _Accum, or _Sat.\n\tHandle RID_SAT.\n\tAvoid using void, bool, char, int, float, double, _Decimal32,\n\t_Decimal64, _Decimal128, and complex with _Sat.\n\tHandle RID_FRACT and RID_ACCUM.\n\tMake sure _Sat is used with _Fract or _Accum.\n\t(finish_declspecs): Handle cts_fract and cts_accum.\n\t* c-common.c (fixed-value.h): New include.\n\t(constant_expression_warning): Handle FIXED_CST.\n\t(overflow_warning): Likewise.\n\t(warnings_for_convert_and_check): Likewise.\n\t(c_common_fixed_point_type_for_size): New.\n\t(c_common_type_for_mode): Handle fixed-point modes to\n\treturn various saturating/non-saturating, signed/unsigned types.\n\t(c_common_signed_or_unsigned_type): Support fixed-point types.\n\t(shorten_compare): Check fixed-point zero.\n\tHandle FIXED_POINT_TYPE.\n\t(c_common_truthvalue_conversion): Handle FIXED_CST.\n\tHandle FIXED_POINT_TYPE.\n\t(c_common_nodes_and_builtins): Record builtin types for fixed-point\n\ttypes.\n\t(handle_mode_attribute): Handle fixed-point modes.  Need to check\n\tif the signness of base type and fixed-point modes are consistent.\n\t(handle_vector_size_attribute): Handle fixed-point modes.\n\t(same_scalar_type_ignoring_signedness): Handle FIXED_POINT_TYPE.\n\t(warn_for_div_by_zero): Check fixed-point zero.\n\t* c-typeck.c (c_common_type): Check FIXED_POINT_TYPE.  Build\n\ta common fixed-point type based on fbit, ibit, sign, and saturation.\n\t(build_unary_op): Allow FIXED_POINT_TYPE for CONVERT_EXPR,\n\tNEGATE_EXPR, TRUTH_NOT_EXPR, PREINCREMENT_EXPR, POSTINCREMENT_EXPR,\n\tPREDECREMENT_EXPR, and POSTDECREMENT_EXPR.\n\t(convert_for_assignment): Support FIXED_POINT_TYPE.\n\t(digest_init): Handle FIXED_POINT_TYPE.\n\t(build_binary_op): Support FIXED_POINT_TYPE in *_DIV_EXPR,\n\tTRUTH_ANDIF_EXPR, TRUTH_ORIF_EXPR, TRUTH_AND_EXPR, TRUTH_OR_EXPR,\n\tTRUTH_XOR_EXPR, RSHIFT_EXPR, LSHIFT_EXPR, EQ_EXPR, NE_EXPR, LE_EXPR,\n\tGE_EXPR, LT_EXPR, GT_EXPR.\n\t* target-def.h (TARGET_FIXED_POINT_SUPPORTED_P): New.\n\t(TARGET_INITIALIZER): Add TARGET_FIXED_POINT_SUPPORTED_P.\n\t* target.h (gcc_target): Add fixed_point_supported_p.\n\t* targhooks.c (default_scalar_mode_supported_p): Handle MODE_FRACT,\n\tMODE_UFRACT, MODE_ACCUM, and MODE_UACCUM.\n\t(default_fixed_point_supported_p): Define.\n\t* targhooks.h (default_fixed_point_supported_p): Declare.\n\t* doc/tm.texi (TARGET_FIXED_POINT_SUPPORTED_P): Add.\n\t* doc/install.texi (Configuration): Add --enable-fixed-point.\n\t* configure.ac (--enable-fixed-point): New to enable fixed-point\n\tarithmetic extension to C.  For mips targets, we enable it by default.\n\t* configure, config.in: Regenerate.\n\nFrom-SVN: r127652", "tree": {"sha": "64870172714a26b5105facd128201e6fef2f87b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64870172714a26b5105facd128201e6fef2f87b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab22c1fa94acc05ddfe9403debd55a69a714723e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab22c1fa94acc05ddfe9403debd55a69a714723e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab22c1fa94acc05ddfe9403debd55a69a714723e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab22c1fa94acc05ddfe9403debd55a69a714723e/comments", "author": null, "committer": null, "parents": [{"sha": "43f1474491615c9c895716ef0e2a01d0280b1ef1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43f1474491615c9c895716ef0e2a01d0280b1ef1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43f1474491615c9c895716ef0e2a01d0280b1ef1"}], "stats": {"total": 11755, "additions": 6457, "deletions": 5298}, "files": [{"sha": "39535283140cb37c6c9d4583b7e563ad66d7cfb3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab22c1fa94acc05ddfe9403debd55a69a714723e", "patch": "@@ -1,3 +1,67 @@\n+2007-08-20  Chao-ying Fu  <fu@mips.com>\n+\n+\t* c-common.h (enum rid): Add new enumeration values of RID_SAT,\n+\tRID_FRACT, and RID_ACCUM.  RID_SAT needs to be inserted before\n+\tRID_ONEWAY, so that it can be checked in declspecs_add_type.\n+\t(c_common_fixed_point_type_for_size): Declare.\n+\t* c-parser.c (reswords): Add _Fract, _Accum, and _Sat.\n+\t(c_token_starts_typename): Handle RID_FRACT, RID_ACCUM, and RID_SAT.\n+\t(c_token_starts_declspecs): Likewise.\n+\t(c_parser_declspecs): Likewise.\n+\t(c_parser_attributes): Likewise.\n+\t* c-tree.h (enum c_typespec_keyword): Add cts_fract and cts_accum.\n+\t(c_declspecs): Add saturating_p.\n+\t* c-decl.c (build_null_declspecs): Initialize saturating_p.\n+\t(declspecs_add_type): Avoid using complex with _Fract, _Accum, or _Sat.\n+\tHandle RID_SAT.\n+\tAvoid using void, bool, char, int, float, double, _Decimal32,\n+\t_Decimal64, _Decimal128, and complex with _Sat.\n+\tHandle RID_FRACT and RID_ACCUM.\n+\tMake sure _Sat is used with _Fract or _Accum.\n+\t(finish_declspecs): Handle cts_fract and cts_accum.\n+\t* c-common.c (fixed-value.h): New include.\n+\t(constant_expression_warning): Handle FIXED_CST.\n+\t(overflow_warning): Likewise.\n+\t(warnings_for_convert_and_check): Likewise.\n+\t(c_common_fixed_point_type_for_size): New.\n+\t(c_common_type_for_mode): Handle fixed-point modes to\n+\treturn various saturating/non-saturating, signed/unsigned types.\n+\t(c_common_signed_or_unsigned_type): Support fixed-point types.\n+\t(shorten_compare): Check fixed-point zero.\n+\tHandle FIXED_POINT_TYPE.\n+\t(c_common_truthvalue_conversion): Handle FIXED_CST.\n+\tHandle FIXED_POINT_TYPE.\n+\t(c_common_nodes_and_builtins): Record builtin types for fixed-point\n+\ttypes.\n+\t(handle_mode_attribute): Handle fixed-point modes.  Need to check\n+\tif the signness of base type and fixed-point modes are consistent.\n+\t(handle_vector_size_attribute): Handle fixed-point modes.\n+\t(same_scalar_type_ignoring_signedness): Handle FIXED_POINT_TYPE.\n+\t(warn_for_div_by_zero): Check fixed-point zero.\n+\t* c-typeck.c (c_common_type): Check FIXED_POINT_TYPE.  Build\n+\ta common fixed-point type based on fbit, ibit, sign, and saturation.\n+\t(build_unary_op): Allow FIXED_POINT_TYPE for CONVERT_EXPR,\n+\tNEGATE_EXPR, TRUTH_NOT_EXPR, PREINCREMENT_EXPR, POSTINCREMENT_EXPR,\n+\tPREDECREMENT_EXPR, and POSTDECREMENT_EXPR.\n+\t(convert_for_assignment): Support FIXED_POINT_TYPE.\n+\t(digest_init): Handle FIXED_POINT_TYPE.\n+\t(build_binary_op): Support FIXED_POINT_TYPE in *_DIV_EXPR,\n+\tTRUTH_ANDIF_EXPR, TRUTH_ORIF_EXPR, TRUTH_AND_EXPR, TRUTH_OR_EXPR,\n+\tTRUTH_XOR_EXPR, RSHIFT_EXPR, LSHIFT_EXPR, EQ_EXPR, NE_EXPR, LE_EXPR,\n+\tGE_EXPR, LT_EXPR, GT_EXPR.\n+\t* target-def.h (TARGET_FIXED_POINT_SUPPORTED_P): New.\n+\t(TARGET_INITIALIZER): Add TARGET_FIXED_POINT_SUPPORTED_P.\n+\t* target.h (gcc_target): Add fixed_point_supported_p.\n+\t* targhooks.c (default_scalar_mode_supported_p): Handle MODE_FRACT,\n+\tMODE_UFRACT, MODE_ACCUM, and MODE_UACCUM.\n+\t(default_fixed_point_supported_p): Define.\n+\t* targhooks.h (default_fixed_point_supported_p): Declare.\n+\t* doc/tm.texi (TARGET_FIXED_POINT_SUPPORTED_P): Add.\n+\t* doc/install.texi (Configuration): Add --enable-fixed-point.\n+\t* configure.ac (--enable-fixed-point): New to enable fixed-point\n+\tarithmetic extension to C.  For mips targets, we enable it by default.\n+\t* configure, config.in: Regenerate.\n+\n 2007-08-20  Pawel Sikora  <pluto@pld-linux.org>\n \n         * doc/invoke.texi (-Wnon-virtual-dtor): Update documentation."}, {"sha": "6c088302e46e1b0067d42a10169890df9cdab211", "filename": "gcc/c-common.c", "status": "modified", "additions": 286, "deletions": 10, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=ab22c1fa94acc05ddfe9403debd55a69a714723e", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"real.h\"\n #include \"cgraph.h\"\n #include \"target-def.h\"\n+#include \"fixed-value.h\"\n \n cpp_reader *parse_in;\t\t/* Declared in c-pragma.h.  */\n \n@@ -929,6 +930,7 @@ void\n constant_expression_warning (tree value)\n {\n   if ((TREE_CODE (value) == INTEGER_CST || TREE_CODE (value) == REAL_CST\n+       || TREE_CODE (value) == FIXED_CST\n        || TREE_CODE (value) == VECTOR_CST\n        || TREE_CODE (value) == COMPLEX_CST)\n       && TREE_OVERFLOW (value)\n@@ -963,6 +965,10 @@ overflow_warning (tree value)\n       warning (OPT_Woverflow, \"floating point overflow in expression\");\n       break;\n       \n+    case FIXED_CST:\n+      warning (OPT_Woverflow, \"fixed-point overflow in expression\");\n+      break;\n+\n     case VECTOR_CST:\n       warning (OPT_Woverflow, \"vector overflow in expression\");\n       break;\n@@ -1360,7 +1366,8 @@ warnings_for_convert_and_check (tree type, tree expr, tree result)\n       else\n \tconversion_warning (type, expr);\n     }\n-  else if (TREE_CODE (result) == INTEGER_CST && TREE_OVERFLOW (result)) \n+  else if ((TREE_CODE (result) == INTEGER_CST\n+\t    || TREE_CODE (result) == FIXED_CST) && TREE_OVERFLOW (result))\n     warning (OPT_Woverflow,\n              \"overflow in implicit constant conversion\");\n   else\n@@ -1928,13 +1935,44 @@ c_common_type_for_size (unsigned int bits, int unsignedp)\n   return 0;\n }\n \n+/* Return a fixed-point type that has at least IBIT ibits and FBIT fbits\n+   that is unsigned if UNSIGNEDP is nonzero, otherwise signed;\n+   and saturating if SATP is nonzero, otherwise not saturating.  */\n+\n+tree\n+c_common_fixed_point_type_for_size (unsigned int ibit, unsigned int fbit,\n+\t\t\t\t    int unsignedp, int satp)\n+{\n+  enum machine_mode mode;\n+  if (ibit == 0)\n+    mode = unsignedp ? UQQmode : QQmode;\n+  else\n+    mode = unsignedp ? UHAmode : HAmode;\n+\n+  for (; mode != VOIDmode; mode = GET_MODE_WIDER_MODE (mode))\n+    if (GET_MODE_IBIT (mode) >= ibit && GET_MODE_FBIT (mode) >= fbit)\n+      break;\n+\n+  if (mode == VOIDmode || !targetm.scalar_mode_supported_p (mode))\n+    {\n+      sorry (\"GCC cannot support operators with integer types and \"\n+\t     \"fixed-point types that have too many integral and \"\n+\t     \"fractional bits together\");\n+      return 0;\n+    }\n+\n+  return c_common_type_for_mode (mode, satp);\n+}\n+\n /* Used for communication between c_common_type_for_mode and\n    c_register_builtin_type.  */\n static GTY(()) tree registered_builtin_types;\n \n /* Return a data type that has machine mode MODE.\n    If the mode is an integer,\n-   then UNSIGNEDP selects between signed and unsigned types.  */\n+   then UNSIGNEDP selects between signed and unsigned types.\n+   If the mode is a fixed-point mode,\n+   then UNSIGNEDP selects between saturating and nonsaturating types.  */\n \n tree\n c_common_type_for_mode (enum machine_mode mode, int unsignedp)\n@@ -2034,6 +2072,95 @@ c_common_type_for_mode (enum machine_mode mode, int unsignedp)\n   if (mode == TYPE_MODE (dfloat128_type_node))\n     return dfloat128_type_node;\n \n+  if (ALL_SCALAR_FIXED_POINT_MODE_P (mode))\n+    {\n+      if (mode == TYPE_MODE (short_fract_type_node))\n+\treturn unsignedp ? sat_short_fract_type_node : short_fract_type_node;\n+      if (mode == TYPE_MODE (fract_type_node))\n+\treturn unsignedp ? sat_fract_type_node : fract_type_node;\n+      if (mode == TYPE_MODE (long_fract_type_node))\n+\treturn unsignedp ? sat_long_fract_type_node : long_fract_type_node;\n+      if (mode == TYPE_MODE (long_long_fract_type_node))\n+\treturn unsignedp ? sat_long_long_fract_type_node\n+\t\t\t : long_long_fract_type_node;\n+\n+      if (mode == TYPE_MODE (unsigned_short_fract_type_node))\n+\treturn unsignedp ? sat_unsigned_short_fract_type_node\n+\t\t\t : unsigned_short_fract_type_node;\n+      if (mode == TYPE_MODE (unsigned_fract_type_node))\n+\treturn unsignedp ? sat_unsigned_fract_type_node\n+\t\t\t : unsigned_fract_type_node;\n+      if (mode == TYPE_MODE (unsigned_long_fract_type_node))\n+\treturn unsignedp ? sat_unsigned_long_fract_type_node\n+\t\t\t : unsigned_long_fract_type_node;\n+      if (mode == TYPE_MODE (unsigned_long_long_fract_type_node))\n+\treturn unsignedp ? sat_unsigned_long_long_fract_type_node\n+\t\t\t : unsigned_long_long_fract_type_node;\n+\n+      if (mode == TYPE_MODE (short_accum_type_node))\n+\treturn unsignedp ? sat_short_accum_type_node : short_accum_type_node;\n+      if (mode == TYPE_MODE (accum_type_node))\n+\treturn unsignedp ? sat_accum_type_node : accum_type_node;\n+      if (mode == TYPE_MODE (long_accum_type_node))\n+\treturn unsignedp ? sat_long_accum_type_node : long_accum_type_node;\n+      if (mode == TYPE_MODE (long_long_accum_type_node))\n+\treturn unsignedp ? sat_long_long_accum_type_node\n+\t\t\t : long_long_accum_type_node;\n+\n+      if (mode == TYPE_MODE (unsigned_short_accum_type_node))\n+\treturn unsignedp ? sat_unsigned_short_accum_type_node\n+\t\t\t : unsigned_short_accum_type_node;\n+      if (mode == TYPE_MODE (unsigned_accum_type_node))\n+\treturn unsignedp ? sat_unsigned_accum_type_node\n+\t\t\t : unsigned_accum_type_node;\n+      if (mode == TYPE_MODE (unsigned_long_accum_type_node))\n+\treturn unsignedp ? sat_unsigned_long_accum_type_node\n+\t\t\t : unsigned_long_accum_type_node;\n+      if (mode == TYPE_MODE (unsigned_long_long_accum_type_node))\n+\treturn unsignedp ? sat_unsigned_long_long_accum_type_node\n+\t\t\t : unsigned_long_long_accum_type_node;\n+\n+      if (mode == QQmode)\n+\treturn unsignedp ? sat_qq_type_node : qq_type_node;\n+      if (mode == HQmode)\n+\treturn unsignedp ? sat_hq_type_node : hq_type_node;\n+      if (mode == SQmode)\n+\treturn unsignedp ? sat_sq_type_node : sq_type_node;\n+      if (mode == DQmode)\n+\treturn unsignedp ? sat_dq_type_node : dq_type_node;\n+      if (mode == TQmode)\n+\treturn unsignedp ? sat_tq_type_node : tq_type_node;\n+\n+      if (mode == UQQmode)\n+\treturn unsignedp ? sat_uqq_type_node : uqq_type_node;\n+      if (mode == UHQmode)\n+\treturn unsignedp ? sat_uhq_type_node : uhq_type_node;\n+      if (mode == USQmode)\n+\treturn unsignedp ? sat_usq_type_node : usq_type_node;\n+      if (mode == UDQmode)\n+\treturn unsignedp ? sat_udq_type_node : udq_type_node;\n+      if (mode == UTQmode)\n+\treturn unsignedp ? sat_utq_type_node : utq_type_node;\n+\n+      if (mode == HAmode)\n+\treturn unsignedp ? sat_ha_type_node : ha_type_node;\n+      if (mode == SAmode)\n+\treturn unsignedp ? sat_sa_type_node : sa_type_node;\n+      if (mode == DAmode)\n+\treturn unsignedp ? sat_da_type_node : da_type_node;\n+      if (mode == TAmode)\n+\treturn unsignedp ? sat_ta_type_node : ta_type_node;\n+\n+      if (mode == UHAmode)\n+\treturn unsignedp ? sat_uha_type_node : uha_type_node;\n+      if (mode == USAmode)\n+\treturn unsignedp ? sat_usa_type_node : usa_type_node;\n+      if (mode == UDAmode)\n+\treturn unsignedp ? sat_uda_type_node : uda_type_node;\n+      if (mode == UTAmode)\n+\treturn unsignedp ? sat_uta_type_node : uta_type_node;\n+    }\n+\n   for (t = registered_builtin_types; t; t = TREE_CHAIN (t))\n     if (TYPE_MODE (TREE_VALUE (t)) == mode)\n       return TREE_VALUE (t);\n@@ -2095,6 +2222,54 @@ c_common_signed_or_unsigned_type (int unsignedp, tree type)\n   if (type1 == intQI_type_node || type1 == unsigned_intQI_type_node)\n     return unsignedp ? unsigned_intQI_type_node : intQI_type_node;\n \n+#define C_COMMON_FIXED_TYPES(SAT,NAME) \\\n+  if (type1 == SAT ## short_ ## NAME ## _type_node \\\n+      || type1 == SAT ## unsigned_short_ ## NAME ## _type_node) \\\n+    return unsignedp ? SAT ## unsigned_short_ ## NAME ## _type_node \\\n+\t\t     : SAT ## short_ ## NAME ## _type_node; \\\n+  if (type1 == SAT ## NAME ## _type_node \\\n+      || type1 == SAT ## unsigned_ ## NAME ## _type_node) \\\n+    return unsignedp ? SAT ## unsigned_ ## NAME ## _type_node \\\n+\t\t     : SAT ## NAME ## _type_node; \\\n+  if (type1 == SAT ## long_ ## NAME ## _type_node \\\n+      || type1 == SAT ## unsigned_long_ ## NAME ## _type_node) \\\n+    return unsignedp ? SAT ## unsigned_long_ ## NAME ## _type_node \\\n+\t\t     : SAT ## long_ ## NAME ## _type_node; \\\n+  if (type1 == SAT ## long_long_ ## NAME ## _type_node \\\n+      || type1 == SAT ## unsigned_long_long_ ## NAME ## _type_node) \\\n+    return unsignedp ? SAT ## unsigned_long_long_ ## NAME ## _type_node \\\n+\t\t     : SAT ## long_long_ ## NAME ## _type_node;\n+\n+#define C_COMMON_FIXED_MODE_TYPES(SAT,NAME) \\\n+  if (type1 == SAT ## NAME ## _type_node \\\n+      || type1 == SAT ## u ## NAME ## _type_node) \\\n+    return unsignedp ? SAT ## u ## NAME ## _type_node \\\n+\t\t     : SAT ## NAME ## _type_node;\n+\n+  C_COMMON_FIXED_TYPES (, fract);\n+  C_COMMON_FIXED_TYPES (sat_, fract);\n+  C_COMMON_FIXED_TYPES (, accum);\n+  C_COMMON_FIXED_TYPES (sat_, accum);\n+\n+  C_COMMON_FIXED_MODE_TYPES (, qq);\n+  C_COMMON_FIXED_MODE_TYPES (, hq);\n+  C_COMMON_FIXED_MODE_TYPES (, sq);\n+  C_COMMON_FIXED_MODE_TYPES (, dq);\n+  C_COMMON_FIXED_MODE_TYPES (, tq);\n+  C_COMMON_FIXED_MODE_TYPES (sat_, qq);\n+  C_COMMON_FIXED_MODE_TYPES (sat_, hq);\n+  C_COMMON_FIXED_MODE_TYPES (sat_, sq);\n+  C_COMMON_FIXED_MODE_TYPES (sat_, dq);\n+  C_COMMON_FIXED_MODE_TYPES (sat_, tq);\n+  C_COMMON_FIXED_MODE_TYPES (, ha);\n+  C_COMMON_FIXED_MODE_TYPES (, sa);\n+  C_COMMON_FIXED_MODE_TYPES (, da);\n+  C_COMMON_FIXED_MODE_TYPES (, ta);\n+  C_COMMON_FIXED_MODE_TYPES (sat_, ha);\n+  C_COMMON_FIXED_MODE_TYPES (sat_, sa);\n+  C_COMMON_FIXED_MODE_TYPES (sat_, da);\n+  C_COMMON_FIXED_MODE_TYPES (sat_, ta);\n+\n   /* For ENUMERAL_TYPEs in C++, must check the mode of the types, not\n      the precision; they have precision set to match their range, but\n      may use a wider mode to match an ABI.  If we change modes, we may\n@@ -2323,7 +2498,8 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n      the second arg is 0.  */\n \n   if (TREE_CONSTANT (primop0)\n-      && !integer_zerop (primop1) && !real_zerop (primop1))\n+      && !integer_zerop (primop1) && !real_zerop (primop1)\n+      && !fixed_zerop (primop1))\n     {\n       tree tem = primop0;\n       int temi = unsignedp0;\n@@ -2378,6 +2554,7 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n      and see if that preserves the constant's value.  */\n \n   if (!real1 && !real2\n+      && TREE_CODE (TREE_TYPE (primop0)) != FIXED_POINT_TYPE\n       && TREE_CODE (primop1) == INTEGER_CST\n       && TYPE_PRECISION (TREE_TYPE (primop0)) < TYPE_PRECISION (*restype_ptr))\n     {\n@@ -2783,6 +2960,12 @@ c_common_truthvalue_conversion (tree expr)\n \t     ? truthvalue_true_node\n \t     : truthvalue_false_node;\n \n+    case FIXED_CST:\n+      return fixed_compare (NE_EXPR, &TREE_FIXED_CST (expr),\n+\t\t\t    &FCONST0 (TYPE_MODE (TREE_TYPE (expr))))\n+\t     ? truthvalue_true_node\n+\t     : truthvalue_false_node;\n+\n     case FUNCTION_DECL:\n       expr = build_unary_op (ADDR_EXPR, expr, 0);\n       /* Fall through.  */\n@@ -2883,6 +3066,14 @@ c_common_truthvalue_conversion (tree expr)\n \t       0));\n     }\n \n+  if (TREE_CODE (TREE_TYPE (expr)) == FIXED_POINT_TYPE)\n+    {\n+      tree fixed_zero_node = build_fixed (TREE_TYPE (expr),\n+\t\t\t\t\t  FCONST0 (TYPE_MODE\n+\t\t\t\t\t\t   (TREE_TYPE (expr))));\n+      return build_binary_op (NE_EXPR, expr, fixed_zero_node, 1);\n+    }\n+\n   return build_binary_op (NE_EXPR, expr, integer_zero_node, 1);\n }\n \f\n@@ -3594,6 +3785,67 @@ c_common_nodes_and_builtins (void)\n       record_builtin_type (RID_DFLOAT128, NULL, dfloat128_type_node);\n     }\n \n+  if (targetm.fixed_point_supported_p ())\n+    {\n+      record_builtin_type (RID_MAX, \"short _Fract\", short_fract_type_node);\n+      record_builtin_type (RID_FRACT, NULL, fract_type_node);\n+      record_builtin_type (RID_MAX, \"long _Fract\", long_fract_type_node);\n+      record_builtin_type (RID_MAX, \"long long _Fract\",\n+\t\t\t   long_long_fract_type_node);\n+      record_builtin_type (RID_MAX, \"unsigned short _Fract\",\n+\t\t\t   unsigned_short_fract_type_node);\n+      record_builtin_type (RID_MAX, \"unsigned _Fract\",\n+\t\t\t   unsigned_fract_type_node);\n+      record_builtin_type (RID_MAX, \"unsigned long _Fract\",\n+\t\t\t   unsigned_long_fract_type_node);\n+      record_builtin_type (RID_MAX, \"unsigned long long _Fract\",\n+\t\t\t   unsigned_long_long_fract_type_node);\n+      record_builtin_type (RID_MAX, \"_Sat short _Fract\",\n+\t\t\t   sat_short_fract_type_node);\n+      record_builtin_type (RID_MAX, \"_Sat _Fract\", sat_fract_type_node);\n+      record_builtin_type (RID_MAX, \"_Sat long _Fract\",\n+\t\t\t   sat_long_fract_type_node);\n+      record_builtin_type (RID_MAX, \"_Sat long long _Fract\",\n+\t\t\t   sat_long_long_fract_type_node);\n+      record_builtin_type (RID_MAX, \"_Sat unsigned short _Fract\",\n+\t\t\t   sat_unsigned_short_fract_type_node);\n+      record_builtin_type (RID_MAX, \"_Sat unsigned _Fract\",\n+\t\t\t   sat_unsigned_fract_type_node);\n+      record_builtin_type (RID_MAX, \"_Sat unsigned long _Fract\",\n+\t\t\t   sat_unsigned_long_fract_type_node);\n+      record_builtin_type (RID_MAX, \"_Sat unsigned long long _Fract\",\n+\t\t\t   sat_unsigned_long_long_fract_type_node);\n+      record_builtin_type (RID_MAX, \"short _Accum\", short_accum_type_node);\n+      record_builtin_type (RID_ACCUM, NULL, accum_type_node);\n+      record_builtin_type (RID_MAX, \"long _Accum\", long_accum_type_node);\n+      record_builtin_type (RID_MAX, \"long long _Accum\",\n+\t\t\t   long_long_accum_type_node);\n+      record_builtin_type (RID_MAX, \"unsigned short _Accum\",\n+\t\t\t   unsigned_short_accum_type_node);\n+      record_builtin_type (RID_MAX, \"unsigned _Accum\",\n+\t\t\t   unsigned_accum_type_node);\n+      record_builtin_type (RID_MAX, \"unsigned long _Accum\",\n+\t\t\t   unsigned_long_accum_type_node);\n+      record_builtin_type (RID_MAX, \"unsigned long long _Accum\",\n+\t\t\t   unsigned_long_long_accum_type_node);\n+      record_builtin_type (RID_MAX, \"_Sat short _Accum\",\n+\t\t\t   sat_short_accum_type_node);\n+      record_builtin_type (RID_MAX, \"_Sat _Accum\", sat_accum_type_node);\n+      record_builtin_type (RID_MAX, \"_Sat long _Accum\",\n+\t\t\t   sat_long_accum_type_node);\n+      record_builtin_type (RID_MAX, \"_Sat long long _Accum\",\n+\t\t\t  sat_long_long_accum_type_node);\n+      record_builtin_type (RID_MAX, \"_Sat unsigned short _Accum\",\n+\t\t\t   sat_unsigned_short_accum_type_node);\n+      record_builtin_type (RID_MAX, \"_Sat unsigned _Accum\",\n+\t\t\t   sat_unsigned_accum_type_node);\n+      record_builtin_type (RID_MAX, \"_Sat unsigned long _Accum\",\n+\t\t\t   sat_unsigned_long_accum_type_node);\n+      record_builtin_type (RID_MAX, \"_Sat unsigned long long _Accum\",\n+\t\t\t   sat_unsigned_long_long_accum_type_node);\n+\n+    }\n+\n   lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n \t\t\t\t\t get_identifier (\"complex int\"),\n \t\t\t\t\t complex_integer_type_node));\n@@ -5013,6 +5265,10 @@ handle_mode_attribute (tree *node, tree name, tree args,\n \tcase MODE_PARTIAL_INT:\n \tcase MODE_FLOAT:\n \tcase MODE_DECIMAL_FLOAT:\n+\tcase MODE_FRACT:\n+\tcase MODE_UFRACT:\n+\tcase MODE_ACCUM:\n+\tcase MODE_UACCUM:\n \t  valid_mode = targetm.scalar_mode_supported_p (mode);\n \t  break;\n \n@@ -5023,6 +5279,10 @@ handle_mode_attribute (tree *node, tree name, tree args,\n \n \tcase MODE_VECTOR_INT:\n \tcase MODE_VECTOR_FLOAT:\n+\tcase MODE_VECTOR_FRACT:\n+\tcase MODE_VECTOR_UFRACT:\n+\tcase MODE_VECTOR_ACCUM:\n+\tcase MODE_VECTOR_UACCUM:\n \t  warning (OPT_Wattributes, \"specifying vector types with \"\n \t\t   \"__attribute__ ((mode)) is deprecated\");\n \t  warning (OPT_Wattributes,\n@@ -5056,7 +5316,20 @@ handle_mode_attribute (tree *node, tree name, tree args,\n \t  typefm = fn (TREE_TYPE (type), mode, false);\n \t}\n       else\n-\ttypefm = lang_hooks.types.type_for_mode (mode, TYPE_UNSIGNED (type));\n+\t{\n+\t  /* For fixed-point modes, we need to test if the signness of type\n+\t     and the machine mode are consistent.  */\n+\t  if (ALL_FIXED_POINT_MODE_P (mode)\n+\t      && TYPE_UNSIGNED (type) != UNSIGNED_FIXED_POINT_MODE_P (mode))\n+\t    {\n+\t      error (\"signness of type and machine mode %qs don't match\", p);\n+\t      return NULL_TREE;\n+\t    }\n+\t  /* For fixed-point modes, we need to pass saturating info.  */\n+\t  typefm = lang_hooks.types.type_for_mode (mode,\n+\t\t\tALL_FIXED_POINT_MODE_P (mode) ? TYPE_SATURATING (type)\n+\t\t\t\t\t\t      : TYPE_UNSIGNED (type));\n+\t}\n \n       if (typefm == NULL_TREE)\n \t{\n@@ -5805,7 +6078,8 @@ handle_vector_size_attribute (tree *node, tree name, tree args,\n       || TREE_CODE (type) == UNION_TYPE\n       || TREE_CODE (type) == VECTOR_TYPE\n       || (!SCALAR_FLOAT_MODE_P (orig_mode)\n-\t  && GET_MODE_CLASS (orig_mode) != MODE_INT)\n+\t  && GET_MODE_CLASS (orig_mode) != MODE_INT\n+\t  && !ALL_SCALAR_FIXED_POINT_MODE_P (orig_mode))\n       || !host_integerp (TYPE_SIZE_UNIT (type), 1))\n     {\n       error (\"invalid vector type for attribute %qE\", name);\n@@ -6938,8 +7212,9 @@ same_scalar_type_ignoring_signedness (tree t1, tree t2)\n {\n   enum tree_code c1 = TREE_CODE (t1), c2 = TREE_CODE (t2);\n \n-  gcc_assert ((c1 == INTEGER_TYPE || c1 == REAL_TYPE)\n-\t      && (c2 == INTEGER_TYPE || c2 == REAL_TYPE));\n+  gcc_assert ((c1 == INTEGER_TYPE || c1 == REAL_TYPE || c1 == FIXED_POINT_TYPE)\n+\t      && (c2 == INTEGER_TYPE || c2 == REAL_TYPE\n+\t\t  || c2 == FIXED_POINT_TYPE));\n \n   /* Equality works here because c_common_signed_type uses\n      TYPE_MAIN_VARIANT.  */\n@@ -7104,11 +7379,12 @@ struct gcc_targetcm targetcm = TARGETCM_INITIALIZER;\n void\n warn_for_div_by_zero (tree divisor)\n {\n-  /* If DIVISOR is zero, and has integral type, issue a warning about\n-     division by zero.  Do not issue a warning if DIVISOR has a\n+  /* If DIVISOR is zero, and has integral or fixed-point type, issue a warning\n+     about division by zero.  Do not issue a warning if DIVISOR has a\n      floating-point type, since we consider 0.0/0.0 a valid way of\n      generating a NaN.  */\n-  if (skip_evaluation == 0 && integer_zerop (divisor))\n+  if (skip_evaluation == 0\n+      && (integer_zerop (divisor) || fixed_zerop (divisor)))\n     warning (OPT_Wdiv_by_zero, \"division by zero\");\n }\n "}, {"sha": "a41cf6f245f9e04a480e21be05d0f7b9e390d53f", "filename": "gcc/c-common.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=ab22c1fa94acc05ddfe9403debd55a69a714723e", "patch": "@@ -52,7 +52,7 @@ enum rid\n   RID_VOLATILE, RID_SIGNED,  RID_AUTO,  RID_RESTRICT,\n \n   /* C extensions */\n-  RID_COMPLEX, RID_THREAD,\n+  RID_COMPLEX, RID_THREAD, RID_SAT,\n \n   /* C++ */\n   RID_FRIEND, RID_VIRTUAL, RID_EXPLICIT, RID_EXPORT, RID_MUTABLE,\n@@ -72,6 +72,7 @@ enum rid\n   RID_EXTENSION, RID_IMAGPART, RID_REALPART, RID_LABEL,      RID_CHOOSE_EXPR,\n   RID_TYPES_COMPATIBLE_P,\n   RID_DFLOAT32, RID_DFLOAT64, RID_DFLOAT128,\n+  RID_FRACT, RID_ACCUM,\n \n   /* Too many ways of getting the name of a function as a string */\n   RID_FUNCTION_NAME, RID_PRETTY_FUNCTION_NAME, RID_C99_FUNCTION_NAME,\n@@ -670,6 +671,8 @@ extern int c_common_handle_option (size_t code, const char *arg, int value);\n extern bool c_common_missing_argument (const char *opt, size_t code);\n extern tree c_common_type_for_mode (enum machine_mode, int);\n extern tree c_common_type_for_size (unsigned int, int);\n+extern tree c_common_fixed_point_type_for_size (unsigned int, unsigned int,\n+\t\t\t\t\t\tint, int);\n extern tree c_common_unsigned_type (tree);\n extern tree c_common_signed_type (tree);\n extern tree c_common_signed_or_unsigned_type (int, tree);"}, {"sha": "d6eb39aa45c13f44ecc908e3e92fa808abe0ca36", "filename": "gcc/c-decl.c", "status": "modified", "additions": 178, "deletions": 3, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=ab22c1fa94acc05ddfe9403debd55a69a714723e", "patch": "@@ -7134,6 +7134,7 @@ build_null_declspecs (void)\n   ret->const_p = false;\n   ret->volatile_p = false;\n   ret->restrict_p = false;\n+  ret->saturating_p = false;\n   return ret;\n }\n \n@@ -7196,7 +7197,7 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t}\n       if ((int) i <= (int) RID_LAST_MODIFIER)\n \t{\n-\t  /* \"long\", \"short\", \"signed\", \"unsigned\" or \"_Complex\".  */\n+\t  /* \"long\", \"short\", \"signed\", \"unsigned\", \"_Complex\" or \"_Sat\".  */\n \t  bool dupe = false;\n \t  switch (i)\n \t    {\n@@ -7356,9 +7357,55 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      else if (specs->typespec_word == cts_dfloat128)\n \t\terror (\"both %<complex%> and %<_Decimal128%> in \"\n \t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_fract)\n+\t\terror (\"both %<complex%> and %<_Fract%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_accum)\n+\t\terror (\"both %<complex%> and %<_Accum%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->saturating_p)\n+\t\terror (\"both %<complex%> and %<_Sat%> in \"\n+\t\t       \"declaration specifiers\");\n \t      else\n \t\tspecs->complex_p = true;\n \t      break;\n+\t    case RID_SAT:\n+\t      dupe = specs->saturating_p;\n+\t      if (pedantic)\n+\t\tpedwarn (\"ISO C does not support saturating types\");\n+\t      if (specs->typespec_word == cts_void)\n+\t\terror (\"both %<_Sat%> and %<void%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_bool)\n+\t\terror (\"both %<_Sat%> and %<_Bool%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_char)\n+\t\terror (\"both %<_Sat%> and %<char%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_int)\n+\t\terror (\"both %<_Sat%> and %<int%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_float)\n+\t\terror (\"both %<_Sat%> and %<float%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_double)\n+\t\terror (\"both %<_Sat%> and %<double%> in \"\n+\t\t       \"declaration specifiers\");\n+              else if (specs->typespec_word == cts_dfloat32)\n+\t\terror (\"both %<_Sat%> and %<_Decimal32%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_dfloat64)\n+\t\terror (\"both %<_Sat%> and %<_Decimal64%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->typespec_word == cts_dfloat128)\n+\t\terror (\"both %<_Sat%> and %<_Decimal128%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else if (specs->complex_p)\n+\t\terror (\"both %<_Sat%> and %<complex%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else\n+\t\tspecs->saturating_p = true;\n+\t      break;\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n@@ -7370,7 +7417,8 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t}\n       else\n \t{\n-\t  /* \"void\", \"_Bool\", \"char\", \"int\", \"float\" or \"double\".  */\n+\t  /* \"void\", \"_Bool\", \"char\", \"int\", \"float\", \"double\", \"_Decimal32\",\n+\t     \"_Decimal64\", \"_Decimal128\", \"_Fract\" or \"_Accum\".  */\n \t  if (specs->typespec_word != cts_none)\n \t    {\n \t      error (\"two or more data types in declaration specifiers\");\n@@ -7394,6 +7442,9 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      else if (specs->complex_p)\n \t\terror (\"both %<complex%> and %<void%> in \"\n \t\t       \"declaration specifiers\");\n+\t      else if (specs->saturating_p)\n+\t\terror (\"both %<_Sat%> and %<void%> in \"\n+\t\t       \"declaration specifiers\");\n \t      else\n \t\tspecs->typespec_word = cts_void;\n \t      return specs;\n@@ -7413,6 +7464,9 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      else if (specs->complex_p)\n \t\terror (\"both %<complex%> and %<_Bool%> in \"\n \t\t       \"declaration specifiers\");\n+\t      else if (specs->saturating_p)\n+\t\terror (\"both %<_Sat%> and %<_Bool%> in \"\n+\t\t       \"declaration specifiers\");\n \t      else\n \t\tspecs->typespec_word = cts_bool;\n \t      return specs;\n@@ -7423,11 +7477,18 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      else if (specs->short_p)\n \t\terror (\"both %<short%> and %<char%> in \"\n \t\t       \"declaration specifiers\");\n+\t      else if (specs->saturating_p)\n+\t\terror (\"both %<_Sat%> and %<char%> in \"\n+\t\t       \"declaration specifiers\");\n \t      else\n \t\tspecs->typespec_word = cts_char;\n \t      return specs;\n \t    case RID_INT:\n-\t      specs->typespec_word = cts_int;\n+\t      if (specs->saturating_p)\n+\t\terror (\"both %<_Sat%> and %<int%> in \"\n+\t\t       \"declaration specifiers\");\n+\t      else\n+\t\tspecs->typespec_word = cts_int;\n \t      return specs;\n \t    case RID_FLOAT:\n \t      if (specs->long_p)\n@@ -7442,6 +7503,9 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      else if (specs->unsigned_p)\n \t\terror (\"both %<unsigned%> and %<float%> in \"\n \t\t       \"declaration specifiers\");\n+\t      else if (specs->saturating_p)\n+\t\terror (\"both %<_Sat%> and %<float%> in \"\n+\t\t       \"declaration specifiers\");\n \t      else\n \t\tspecs->typespec_word = cts_float;\n \t      return specs;\n@@ -7458,6 +7522,9 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      else if (specs->unsigned_p)\n \t\terror (\"both %<unsigned%> and %<double%> in \"\n \t\t       \"declaration specifiers\");\n+\t      else if (specs->saturating_p)\n+\t\terror (\"both %<_Sat%> and %<double%> in \"\n+\t\t       \"declaration specifiers\");\n \t      else\n \t\tspecs->typespec_word = cts_double;\n \t      return specs;\n@@ -7490,6 +7557,9 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n                 else if (specs->complex_p)\n                   error (\"both %<complex%> and %<%s%> in \"\n                          \"declaration specifiers\", str);\n+                else if (specs->saturating_p)\n+                  error (\"both %<_Sat%> and %<%s%> in \"\n+                         \"declaration specifiers\", str);\n \t\telse if (i == RID_DFLOAT32)\n \t\t  specs->typespec_word = cts_dfloat32;\n \t\telse if (i == RID_DFLOAT64)\n@@ -7502,6 +7572,27 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      if (pedantic)\n \t\tpedwarn (\"ISO C does not support decimal floating point\");\n \t      return specs;\n+\t    case RID_FRACT:\n+\t    case RID_ACCUM:\n+\t      {\n+\t\tconst char *str;\n+\t\tif (i == RID_FRACT)\n+\t\t  str = \"_Fract\";\n+\t\telse\n+\t\t  str = \"_Accum\";\n+                if (specs->complex_p)\n+                  error (\"both %<complex%> and %<%s%> in \"\n+                         \"declaration specifiers\", str);\n+\t\telse if (i == RID_FRACT)\n+\t\t    specs->typespec_word = cts_fract;\n+\t\telse\n+\t\t    specs->typespec_word = cts_accum;\n+\t      }\n+\t      if (!targetm.fixed_point_supported_p ())\n+\t\terror (\"fixed-point types not supported for this target\");\n+\t      if (pedantic)\n+\t\tpedwarn (\"ISO C does not support fixed-point types\");\n+\t      return specs;\n \t    default:\n \t      /* ObjC reserved word \"id\", handled below.  */\n \t      break;\n@@ -7673,6 +7764,8 @@ finish_declspecs (struct c_declspecs *specs)\n      \"_Complex short\" is equivalent to \"_Complex short int\".  */\n   if (specs->typespec_word == cts_none)\n     {\n+      if (specs->saturating_p)\n+\terror (\"%<_Sat%> is used without %<_Fract%> or %<_Accum%>\");\n       if (specs->long_p || specs->short_p\n \t  || specs->signed_p || specs->unsigned_p)\n \t{\n@@ -7792,6 +7885,88 @@ finish_declspecs (struct c_declspecs *specs)\n       else\n \tspecs->type = dfloat128_type_node;\n       break;\n+    case cts_fract:\n+       gcc_assert (!specs->complex_p);\n+       if (specs->saturating_p)\n+\t{\n+\t  if (specs->long_long_p)\n+\t    specs->type = specs->unsigned_p\n+\t\t\t  ? sat_unsigned_long_long_fract_type_node\n+\t\t\t  : sat_long_long_fract_type_node;\n+\t  else if (specs->long_p)\n+\t    specs->type = specs->unsigned_p\n+\t\t\t  ? sat_unsigned_long_fract_type_node\n+\t\t\t  : sat_long_fract_type_node;\n+\t  else if (specs->short_p)\n+\t    specs->type = specs->unsigned_p\n+\t\t\t  ? sat_unsigned_short_fract_type_node\n+\t\t\t  : sat_short_fract_type_node;\n+\t  else\n+\t    specs->type = specs->unsigned_p\n+\t\t\t  ? sat_unsigned_fract_type_node\n+\t\t\t  : sat_fract_type_node;\n+          }\n+      else\n+\t{\n+\t  if (specs->long_long_p)\n+\t    specs->type = specs->unsigned_p\n+\t\t\t  ? unsigned_long_long_fract_type_node\n+\t\t\t  : long_long_fract_type_node;\n+\t  else if (specs->long_p)\n+\t    specs->type = specs->unsigned_p\n+\t\t\t  ? unsigned_long_fract_type_node\n+\t\t\t  : long_fract_type_node;\n+\t  else if (specs->short_p)\n+\t    specs->type = specs->unsigned_p\n+\t\t\t  ? unsigned_short_fract_type_node\n+\t\t\t  : short_fract_type_node;\n+\t  else\n+\t    specs->type = specs->unsigned_p\n+\t\t\t  ? unsigned_fract_type_node\n+\t\t\t  : fract_type_node;\n+          }\n+      break;\n+    case cts_accum:\n+       gcc_assert (!specs->complex_p);\n+       if (specs->saturating_p)\n+\t{\n+\t  if (specs->long_long_p)\n+\t    specs->type = specs->unsigned_p\n+\t\t\t  ? sat_unsigned_long_long_accum_type_node\n+\t\t\t  : sat_long_long_accum_type_node;\n+\t  else if (specs->long_p)\n+\t    specs->type = specs->unsigned_p\n+\t\t\t  ? sat_unsigned_long_accum_type_node\n+\t\t\t  : sat_long_accum_type_node;\n+\t  else if (specs->short_p)\n+\t    specs->type = specs->unsigned_p\n+\t\t\t  ? sat_unsigned_short_accum_type_node\n+\t\t\t  : sat_short_accum_type_node;\n+\t  else\n+\t    specs->type = specs->unsigned_p\n+\t\t\t  ? sat_unsigned_accum_type_node\n+\t\t\t  : sat_accum_type_node;\n+          }\n+      else\n+\t{\n+\t  if (specs->long_long_p)\n+\t    specs->type = specs->unsigned_p\n+\t\t\t  ? unsigned_long_long_accum_type_node\n+\t\t\t  : long_long_accum_type_node;\n+\t  else if (specs->long_p)\n+\t    specs->type = specs->unsigned_p\n+\t\t\t  ? unsigned_long_accum_type_node\n+\t\t\t  : long_accum_type_node;\n+\t  else if (specs->short_p)\n+\t    specs->type = specs->unsigned_p\n+\t\t\t  ? unsigned_short_accum_type_node\n+\t\t\t  : short_accum_type_node;\n+\t  else\n+\t    specs->type = specs->unsigned_p\n+\t\t\t  ? unsigned_accum_type_node\n+\t\t\t  : accum_type_node;\n+          }\n+      break;\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "4cd9479badab6bef9cd4d17d9138978aad6a9426", "filename": "gcc/c-parser.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=ab22c1fa94acc05ddfe9403debd55a69a714723e", "patch": "@@ -80,6 +80,9 @@ static const struct resword reswords[] =\n   { \"_Decimal32\",       RID_DFLOAT32,  D_EXT },\n   { \"_Decimal64\",       RID_DFLOAT64,  D_EXT },\n   { \"_Decimal128\",      RID_DFLOAT128, D_EXT },\n+  { \"_Fract\",           RID_FRACT,     D_EXT },\n+  { \"_Accum\",           RID_ACCUM,     D_EXT },\n+  { \"_Sat\",             RID_SAT,       D_EXT },\n   { \"__FUNCTION__\",\tRID_FUNCTION_NAME, 0 },\n   { \"__PRETTY_FUNCTION__\", RID_PRETTY_FUNCTION_NAME, 0 },\n   { \"__alignof\",\tRID_ALIGNOF,\t0 },\n@@ -486,6 +489,9 @@ c_token_starts_typename (c_token *token)\n \tcase RID_VOLATILE:\n \tcase RID_RESTRICT:\n \tcase RID_ATTRIBUTE:\n+\tcase RID_FRACT:\n+\tcase RID_ACCUM:\n+\tcase RID_SAT:\n \t  return true;\n \tdefault:\n \t  return false;\n@@ -560,6 +566,9 @@ c_token_starts_declspecs (c_token *token)\n \tcase RID_VOLATILE:\n \tcase RID_RESTRICT:\n \tcase RID_ATTRIBUTE:\n+\tcase RID_FRACT:\n+\tcase RID_ACCUM:\n+\tcase RID_SAT:\n \t  return true;\n \tdefault:\n \t  return false;\n@@ -1493,6 +1502,12 @@ c_parser_asm_definition (c_parser *parser)\n      _Decimal32\n      _Decimal64\n      _Decimal128\n+     _Fract\n+     _Accum\n+     _Sat\n+\n+  (_Fract, _Accum, and _Sat are new from ISO/IEC DTR 18037:\n+   http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1169.pdf)\n \n    Objective-C:\n \n@@ -1595,6 +1610,9 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \tcase RID_DFLOAT64:\n \tcase RID_DFLOAT128:\n \tcase RID_BOOL:\n+\tcase RID_FRACT:\n+\tcase RID_ACCUM:\n+\tcase RID_SAT:\n \t  if (!typespec_ok)\n \t    goto out;\n \t  attrs_ok = true;\n@@ -2857,6 +2875,9 @@ c_parser_attributes (c_parser *parser)\n \t\tcase RID_DFLOAT64:\n \t\tcase RID_DFLOAT128:\n \t\tcase RID_BOOL:\n+\t\tcase RID_FRACT:\n+\t\tcase RID_ACCUM:\n+\t\tcase RID_SAT:\n \t\t  ok = true;\n \t\t  break;\n \t\tdefault:"}, {"sha": "f2727f82c37a34a5063b1d12b9264f6eb301f21a", "filename": "gcc/c-tree.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=ab22c1fa94acc05ddfe9403debd55a69a714723e", "patch": "@@ -202,7 +202,8 @@ enum c_storage_class {\n };\n \n /* A type specifier keyword \"void\", \"_Bool\", \"char\", \"int\", \"float\",\n-   \"double\", or none of these.  */\n+   \"double\", \"_Decimal32\", \"_Decimal64\", \"_Decimal128\", \"_Fract\", \"_Accum\",\n+   or none of these.  */\n enum c_typespec_keyword {\n   cts_none,\n   cts_void,\n@@ -213,7 +214,9 @@ enum c_typespec_keyword {\n   cts_double,\n   cts_dfloat32,\n   cts_dfloat64,\n-  cts_dfloat128\n+  cts_dfloat128,\n+  cts_fract,\n+  cts_accum\n };\n \n /* A sequence of declaration specifiers in C.  */\n@@ -281,6 +284,8 @@ struct c_declspecs {\n   BOOL_BITFIELD volatile_p : 1;\n   /* Whether \"restrict\" was specified.  */\n   BOOL_BITFIELD restrict_p : 1;\n+  /* Whether \"_Sat\" was specified.  */\n+  BOOL_BITFIELD saturating_p : 1;\n };\n \n /* The various kinds of declarators in C.  */"}, {"sha": "61b0e2ee9ff5aa3e365b733202366575fe18a3e0", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 137, "deletions": 20, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=ab22c1fa94acc05ddfe9403debd55a69a714723e", "patch": "@@ -604,9 +604,11 @@ c_common_type (tree t1, tree t2)\n   code2 = TREE_CODE (t2);\n \n   gcc_assert (code1 == VECTOR_TYPE || code1 == COMPLEX_TYPE\n-\t      || code1 == REAL_TYPE || code1 == INTEGER_TYPE);\n+\t      || code1 == FIXED_POINT_TYPE || code1 == REAL_TYPE\n+\t      || code1 == INTEGER_TYPE);\n   gcc_assert (code2 == VECTOR_TYPE || code2 == COMPLEX_TYPE\n-\t      || code2 == REAL_TYPE || code2 == INTEGER_TYPE);\n+\t      || code2 == FIXED_POINT_TYPE || code2 == REAL_TYPE\n+\t      || code2 == INTEGER_TYPE);\n \n   /* When one operand is a decimal float type, the other operand cannot be\n      a generic float type or a complex type.  We also disallow vector types\n@@ -681,6 +683,91 @@ c_common_type (tree t1, tree t2)\n \treturn dfloat32_type_node;\n     }\n \n+  /* Deal with fixed-point types.  */\n+  if (code1 == FIXED_POINT_TYPE || code2 == FIXED_POINT_TYPE)\n+    {\n+      unsigned int unsignedp = 0, satp = 0;\n+      enum machine_mode m1, m2;\n+      unsigned int fbit1, ibit1, fbit2, ibit2, max_fbit, max_ibit;\n+\n+      m1 = TYPE_MODE (t1);\n+      m2 = TYPE_MODE (t2);\n+\n+      /* If one input type is saturating, the result type is saturating.  */\n+      if (TYPE_SATURATING (t1) || TYPE_SATURATING (t2))\n+\tsatp = 1;\n+\n+      /* If both fixed-point types are unsigned, the result type is unsigned.\n+\t When mixing fixed-point and integer types, follow the sign of the\n+\t fixed-point type.\n+\t Otherwise, the result type is signed.  */\n+      if ((TYPE_UNSIGNED (t1) && TYPE_UNSIGNED (t2)\n+\t   && code1 == FIXED_POINT_TYPE && code2 == FIXED_POINT_TYPE)\n+\t  || (code1 == FIXED_POINT_TYPE && code2 != FIXED_POINT_TYPE\n+\t      && TYPE_UNSIGNED (t1))\n+\t  || (code1 != FIXED_POINT_TYPE && code2 == FIXED_POINT_TYPE\n+\t      && TYPE_UNSIGNED (t2)))\n+\tunsignedp = 1;\n+\n+      /* The result type is signed.  */\n+      if (unsignedp == 0)\n+\t{\n+\t  /* If the input type is unsigned, we need to convert to the\n+\t     signed type.  */\n+\t  if (code1 == FIXED_POINT_TYPE && TYPE_UNSIGNED (t1))\n+\t    {\n+\t      unsigned char mclass = 0;\n+\t      if (GET_MODE_CLASS (m1) == MODE_UFRACT)\n+\t\tmclass = MODE_FRACT;\n+\t      else if (GET_MODE_CLASS (m1) == MODE_UACCUM)\n+\t\tmclass = MODE_ACCUM;\n+\t      else\n+\t\tgcc_unreachable ();\n+\t      m1 = mode_for_size (GET_MODE_PRECISION (m1), mclass, 0);\n+\t    }\n+\t  if (code2 == FIXED_POINT_TYPE && TYPE_UNSIGNED (t2))\n+\t    {\n+\t      unsigned char mclass = 0;\n+\t      if (GET_MODE_CLASS (m2) == MODE_UFRACT)\n+\t\tmclass = MODE_FRACT;\n+\t      else if (GET_MODE_CLASS (m2) == MODE_UACCUM)\n+\t\tmclass = MODE_ACCUM;\n+\t      else\n+\t\tgcc_unreachable ();\n+\t      m2 = mode_for_size (GET_MODE_PRECISION (m2), mclass, 0);\n+\t    }\n+\t}\n+\n+      if (code1 == FIXED_POINT_TYPE)\n+\t{\n+\t  fbit1 = GET_MODE_FBIT (m1);\n+\t  ibit1 = GET_MODE_IBIT (m1);\n+\t}\n+      else\n+\t{\n+\t  fbit1 = 0;\n+\t  /* Signed integers need to subtract one sign bit.  */\n+\t  ibit1 = TYPE_PRECISION (t1) - (!TYPE_UNSIGNED (t1));\n+\t}\n+\n+      if (code2 == FIXED_POINT_TYPE)\n+\t{\n+\t  fbit2 = GET_MODE_FBIT (m2);\n+\t  ibit2 = GET_MODE_IBIT (m2);\n+\t}\n+      else\n+\t{\n+\t  fbit2 = 0;\n+\t  /* Signed integers need to subtract one sign bit.  */\n+\t  ibit2 = TYPE_PRECISION (t2) - (!TYPE_UNSIGNED (t2));\n+\t}\n+\n+      max_ibit = ibit1 >= ibit2 ?  ibit1 : ibit2;\n+      max_fbit = fbit1 >= fbit2 ?  fbit1 : fbit2;\n+      return c_common_fixed_point_type_for_size (max_ibit, max_fbit, unsignedp,\n+\t\t\t\t\t\t satp);\n+    }\n+\n   /* Both real or both integers; use the one with greater precision.  */\n \n   if (TYPE_PRECISION (t1) > TYPE_PRECISION (t2))\n@@ -2808,7 +2895,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t is enough to prevent anybody from looking inside for\n \t associativity, but won't generate any code.  */\n       if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE\n-\t    || typecode == COMPLEX_TYPE\n+\t    || typecode == FIXED_POINT_TYPE || typecode == COMPLEX_TYPE\n \t    || typecode == VECTOR_TYPE))\n \t{\n \t  error (\"wrong type argument to unary plus\");\n@@ -2821,7 +2908,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \n     case NEGATE_EXPR:\n       if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE\n-\t    || typecode == COMPLEX_TYPE\n+\t    || typecode == FIXED_POINT_TYPE || typecode == COMPLEX_TYPE\n \t    || typecode == VECTOR_TYPE))\n \t{\n \t  error (\"wrong type argument to unary minus\");\n@@ -2878,7 +2965,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n       break;\n \n     case TRUTH_NOT_EXPR:\n-      if (typecode != INTEGER_TYPE\n+      if (typecode != INTEGER_TYPE && typecode != FIXED_POINT_TYPE\n \t  && typecode != REAL_TYPE && typecode != POINTER_TYPE\n \t  && typecode != COMPLEX_TYPE)\n \t{\n@@ -2931,7 +3018,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \n       /* Report invalid types.  */\n \n-      if (typecode != POINTER_TYPE\n+      if (typecode != POINTER_TYPE && typecode != FIXED_POINT_TYPE\n \t  && typecode != INTEGER_TYPE && typecode != REAL_TYPE)\n \t{\n \t  if (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n@@ -2975,6 +3062,25 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t    inc = c_size_in_bytes (TREE_TYPE (result_type));\n \t    inc = fold_convert (sizetype, inc);\n \t  }\n+\telse if (FRACT_MODE_P (TYPE_MODE (result_type)))\n+\t  {\n+\t    /* For signed fract types, we invert ++ to -- or\n+\t       -- to ++, and change inc from 1 to -1, because\n+\t       it is not possible to represent 1 in signed fract constants.\n+\t       For unsigned fract types, the result always overflows and\n+\t       we get an undefined (original) or the maximum value.  */\n+\t    if (code == PREINCREMENT_EXPR)\n+\t      code = PREDECREMENT_EXPR;\n+\t    else if (code == PREDECREMENT_EXPR)\n+\t      code = PREINCREMENT_EXPR;\n+\t    else if (code == POSTINCREMENT_EXPR)\n+\t      code = POSTDECREMENT_EXPR;\n+\t    else /* code == POSTDECREMENT_EXPR  */\n+\t      code = POSTINCREMENT_EXPR;\n+\n+\t    inc = integer_minus_one_node;\n+\t    inc = convert (argtype, inc);\n+\t  }\n \telse\n \t  {\n \t    inc = integer_one_node;\n@@ -3924,9 +4030,11 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n     return convert (type, rhs);\n   /* Arithmetic types all interconvert, and enum is treated like int.  */\n   else if ((codel == INTEGER_TYPE || codel == REAL_TYPE\n+\t    || codel == FIXED_POINT_TYPE\n \t    || codel == ENUMERAL_TYPE || codel == COMPLEX_TYPE\n \t    || codel == BOOLEAN_TYPE)\n \t   && (coder == INTEGER_TYPE || coder == REAL_TYPE\n+\t       || coder == FIXED_POINT_TYPE\n \t       || coder == ENUMERAL_TYPE || coder == COMPLEX_TYPE\n \t       || coder == BOOLEAN_TYPE))\n     return convert_and_check (type, rhs);\n@@ -4746,9 +4854,9 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n \n   /* Handle scalar types, including conversions.  */\n \n-  if (code == INTEGER_TYPE || code == REAL_TYPE || code == POINTER_TYPE\n-      || code == ENUMERAL_TYPE || code == BOOLEAN_TYPE || code == COMPLEX_TYPE\n-      || code == VECTOR_TYPE)\n+  if (code == INTEGER_TYPE || code == REAL_TYPE || code == FIXED_POINT_TYPE\n+      || code == POINTER_TYPE || code == ENUMERAL_TYPE || code == BOOLEAN_TYPE\n+      || code == COMPLEX_TYPE || code == VECTOR_TYPE)\n     {\n       if (TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE\n \t  && (TREE_CODE (init) == STRING_CST\n@@ -7862,8 +7970,10 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       warn_for_div_by_zero (op1);\n \n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n+\t   || code0 == FIXED_POINT_TYPE\n \t   || code0 == COMPLEX_TYPE || code0 == VECTOR_TYPE)\n \t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n+\t      || code1 == FIXED_POINT_TYPE\n \t      || code1 == COMPLEX_TYPE || code1 == VECTOR_TYPE))\n \t{\n \t  enum tree_code tcode0 = code0, tcode1 = code1;\n@@ -7873,7 +7983,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  if (code1 == COMPLEX_TYPE || code1 == VECTOR_TYPE)\n \t    tcode1 = TREE_CODE (TREE_TYPE (TREE_TYPE (op1)));\n \n-\t  if (!(tcode0 == INTEGER_TYPE && tcode1 == INTEGER_TYPE))\n+\t  if (!((tcode0 == INTEGER_TYPE && tcode1 == INTEGER_TYPE)\n+\t      || (tcode0 == FIXED_POINT_TYPE && tcode1 == FIXED_POINT_TYPE)))\n \t    resultcode = RDIV_EXPR;\n \t  else\n \t    /* Although it would be tempting to shorten always here, that\n@@ -7924,9 +8035,11 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n     case TRUTH_OR_EXPR:\n     case TRUTH_XOR_EXPR:\n       if ((code0 == INTEGER_TYPE || code0 == POINTER_TYPE\n-\t   || code0 == REAL_TYPE || code0 == COMPLEX_TYPE)\n+\t   || code0 == REAL_TYPE || code0 == COMPLEX_TYPE\n+\t   || code0 == FIXED_POINT_TYPE)\n \t  && (code1 == INTEGER_TYPE || code1 == POINTER_TYPE\n-\t      || code1 == REAL_TYPE || code1 == COMPLEX_TYPE))\n+\t      || code1 == REAL_TYPE || code1 == COMPLEX_TYPE\n+\t      || code1 == FIXED_POINT_TYPE))\n \t{\n \t  /* Result of these operations is always an int,\n \t     but that does not mean the operands should be\n@@ -7943,7 +8056,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t Also set SHORT_SHIFT if shifting rightward.  */\n \n     case RSHIFT_EXPR:\n-      if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n+      if ((code0 == INTEGER_TYPE || code0 == FIXED_POINT_TYPE)\n+\t  && code1 == INTEGER_TYPE)\n \t{\n \t  if (TREE_CODE (op1) == INTEGER_CST && skip_evaluation == 0)\n \t    {\n@@ -7971,7 +8085,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       break;\n \n     case LSHIFT_EXPR:\n-      if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n+      if ((code0 == INTEGER_TYPE || code0 == FIXED_POINT_TYPE)\n+\t  && code1 == INTEGER_TYPE)\n \t{\n \t  if (TREE_CODE (op1) == INTEGER_CST && skip_evaluation == 0)\n \t    {\n@@ -8002,9 +8117,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t but don't convert the args to int!  */\n       build_type = integer_type_node;\n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n-\t   || code0 == COMPLEX_TYPE)\n+\t   || code0 == FIXED_POINT_TYPE || code0 == COMPLEX_TYPE)\n \t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n-\t      || code1 == COMPLEX_TYPE))\n+\t      || code1 == FIXED_POINT_TYPE || code1 == COMPLEX_TYPE))\n \tshort_compare = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n@@ -8072,8 +8187,10 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n     case LT_EXPR:\n     case GT_EXPR:\n       build_type = integer_type_node;\n-      if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE)\n-\t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n+      if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n+\t   || code0 == FIXED_POINT_TYPE)\n+\t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n+\t      || code1 == FIXED_POINT_TYPE))\n \tshort_compare = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n@@ -8134,10 +8251,10 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n     }\n \n   if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE || code0 == COMPLEX_TYPE\n-       || code0 == VECTOR_TYPE)\n+       || code0 == FIXED_POINT_TYPE || code0 == VECTOR_TYPE)\n       &&\n       (code1 == INTEGER_TYPE || code1 == REAL_TYPE || code1 == COMPLEX_TYPE\n-       || code1 == VECTOR_TYPE))\n+       || code1 == FIXED_POINT_TYPE || code1 == VECTOR_TYPE))\n     {\n       int none_complex = (code0 != COMPLEX_TYPE && code1 != COMPLEX_TYPE);\n "}, {"sha": "723b88fc8e7a1baee6996ad058d728163a96760d", "filename": "gcc/config.in", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=ab22c1fa94acc05ddfe9403debd55a69a714723e", "patch": "@@ -65,6 +65,12 @@\n #endif\n \n \n+/* Define to 1 to enable fixed-point arithmetic extension to C. */\n+#ifndef USED_FOR_TARGET\n+#undef ENABLE_FIXED_POINT\n+#endif\n+\n+\n /* Define if you want fold checked that it never destructs its argument. This\n    is quite expensive. */\n #ifndef USED_FOR_TARGET\n@@ -1363,37 +1369,37 @@\n #endif\n \n \n-/* The size of a `int', as computed by sizeof. */\n+/* The size of `int', as computed by sizeof. */\n #ifndef USED_FOR_TARGET\n #undef SIZEOF_INT\n #endif\n \n \n-/* The size of a `long', as computed by sizeof. */\n+/* The size of `long', as computed by sizeof. */\n #ifndef USED_FOR_TARGET\n #undef SIZEOF_LONG\n #endif\n \n \n-/* The size of a `long long', as computed by sizeof. */\n+/* The size of `long long', as computed by sizeof. */\n #ifndef USED_FOR_TARGET\n #undef SIZEOF_LONG_LONG\n #endif\n \n \n-/* The size of a `short', as computed by sizeof. */\n+/* The size of `short', as computed by sizeof. */\n #ifndef USED_FOR_TARGET\n #undef SIZEOF_SHORT\n #endif\n \n \n-/* The size of a `void *', as computed by sizeof. */\n+/* The size of `void *', as computed by sizeof. */\n #ifndef USED_FOR_TARGET\n #undef SIZEOF_VOID_P\n #endif\n \n \n-/* The size of a `__int64', as computed by sizeof. */\n+/* The size of `__int64', as computed by sizeof. */\n #ifndef USED_FOR_TARGET\n #undef SIZEOF___INT64\n #endif"}, {"sha": "c027bf8c4132dd703f930c8858b63fd3642e368c", "filename": "gcc/configure", "status": "modified", "additions": 5694, "deletions": 5256, "changes": 10950, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=ab22c1fa94acc05ddfe9403debd55a69a714723e"}, {"sha": "dd3516ac904f03bfef9e543ef1974b96c12f6433", "filename": "gcc/configure.ac", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=ab22c1fa94acc05ddfe9403debd55a69a714723e", "patch": "@@ -641,6 +641,28 @@ AC_DEFINE_UNQUOTED(ENABLE_DECIMAL_BID_FORMAT, $bid,\n [Define to 1 to specify that we are using the BID decimal floating\n point format instead of DPD])\n \n+# Enable C extension for fixed-point arithmetic.\n+AC_ARG_ENABLE(fixed-point,\n+[  --enable-fixed-point    enable fixed-point arithmetic extension to C],\n+[\n+],\n+[\n+  case $target in\n+    mips*-*-*)\n+      enable_fixed_point=yes\n+      ;;\n+    *)\n+      AC_MSG_WARN(fixed-point is not supported for this target, ignored)\n+      enable_fixed_point=no\n+      ;;\n+  esac\n+])\n+AC_SUBST(enable_fixed_point)\n+\n+fixedpoint=`if test $enable_fixed_point = yes; then echo 1; else echo 0; fi`\n+AC_DEFINE_UNQUOTED(ENABLE_FIXED_POINT, $fixedpoint,\n+[Define to 1 to enable fixed-point arithmetic extension to C.])\n+\n # Enable threads\n # Pass with no value to take the default\n # Pass with a value to specify a thread package"}, {"sha": "e55e93c50f5800a4117c905e1b859cfb7614a7eb", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=ab22c1fa94acc05ddfe9403debd55a69a714723e", "patch": "@@ -1317,6 +1317,13 @@ or @samp{dpd}).  The @samp{bid} (binary integer decimal) format is\n default on i386 and x86_64 systems, and the @samp{dpd} (densely packed\n decimal) format is default on PowerPC systems.\n \n+@item --enable-fixed-point\n+@itemx --disable-fixed-point\n+Enable (or disable) support for C fixed-point arithmetic.\n+This option is enabled by default for some targets (such as MIPS) which\n+have hardware-support for fixed-point operations.  On other targets, you\n+may enable this option manually.\n+\n @item --with-long-double-128\n Specify if @code{long double} type should be 128-bit by default on selected\n GNU/Linux architectures.  If using @code{--without-long-double-128},"}, {"sha": "2079ccb195bdea77206e8b025e95d6e4ee5d6925", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=ab22c1fa94acc05ddfe9403debd55a69a714723e", "patch": "@@ -1502,6 +1502,10 @@ may affect its placement.\n Returns true if the target supports decimal floating point.\n @end deftypefn\n \n+@deftypefn {Target Hook} {bool} TARGET_FIXED_POINT_SUPPORTED_P (void)\n+Returns true if the target supports fixed-point arithmetic.\n+@end deftypefn\n+\n @deftypefn {Target Hook} {const char *} TARGET_MANGLE_TYPE (tree @var{type})\n If your target defines any fundamental types, or any types your target\n uses should be mangled differently from the default, define this hook"}, {"sha": "12b329704bfffb58dc362ddb78eb97307f19a75e", "filename": "gcc/target-def.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=ab22c1fa94acc05ddfe9403debd55a69a714723e", "patch": "@@ -437,6 +437,10 @@\n #define TARGET_DECIMAL_FLOAT_SUPPORTED_P default_decimal_float_supported_p\n #endif\n \n+#ifndef TARGET_FIXED_POINT_SUPPORTED_P\n+#define TARGET_FIXED_POINT_SUPPORTED_P default_fixed_point_supported_p\n+#endif\n+\n #ifndef TARGET_VECTOR_MODE_SUPPORTED_P\n #define TARGET_VECTOR_MODE_SUPPORTED_P hook_bool_mode_false\n #endif\n@@ -689,6 +693,7 @@\n   TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P,\t\\\n   TARGET_MS_BITFIELD_LAYOUT_P,\t\t\t\\\n   TARGET_DECIMAL_FLOAT_SUPPORTED_P,\t\t\\\n+  TARGET_FIXED_POINT_SUPPORTED_P,\t\t\\\n   TARGET_ALIGN_ANON_BITFIELD,\t\t\t\\\n   TARGET_NARROW_VOLATILE_BITFIELD,\t\t\\\n   TARGET_INIT_BUILTINS,\t\t\t\t\\"}, {"sha": "7094d4d7a8920bcc245c10fcbbb8dfc930ce13ef", "filename": "gcc/target.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=ab22c1fa94acc05ddfe9403debd55a69a714723e", "patch": "@@ -479,6 +479,9 @@ struct gcc_target\n   /* True if the target supports decimal floating point.  */\n   bool (* decimal_float_supported_p) (void);\n \n+  /* True if the target supports fixed-point.  */\n+  bool (* fixed_point_supported_p) (void);\n+\n   /* Return true if anonymous bitfields affect structure alignment.  */\n   bool (* align_anon_bitfield) (void);\n "}, {"sha": "7e68289f72163b51dcd4be76f75c0900e4f0b362", "filename": "gcc/targhooks.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=ab22c1fa94acc05ddfe9403debd55a69a714723e", "patch": "@@ -298,6 +298,10 @@ default_scalar_mode_supported_p (enum machine_mode mode)\n       return false;\n \n     case MODE_DECIMAL_FLOAT:\n+    case MODE_FRACT:\n+    case MODE_UFRACT:\n+    case MODE_ACCUM:\n+    case MODE_UACCUM:\n       return false;\n \n     default:\n@@ -313,6 +317,14 @@ default_decimal_float_supported_p (void)\n   return ENABLE_DECIMAL_FLOAT;\n }\n \n+/* True if the target supports fixed-point arithmetic.  */\n+\n+bool\n+default_fixed_point_supported_p (void)\n+{\n+  return ENABLE_FIXED_POINT;\n+}\n+\n /* NULL if INSN insn is valid within a low-overhead loop, otherwise returns\n    an error message.\n   "}, {"sha": "816b7fcf5f407ec6de2ca31a13a13c7e412f622c", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22c1fa94acc05ddfe9403debd55a69a714723e/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=ab22c1fa94acc05ddfe9403debd55a69a714723e", "patch": "@@ -55,6 +55,7 @@ extern void default_unwind_emit (FILE *, rtx);\n \n extern bool default_scalar_mode_supported_p (enum machine_mode);\n extern bool default_decimal_float_supported_p (void);\n+extern bool default_fixed_point_supported_p (void);\n \n extern const char * default_invalid_within_doloop (rtx);\n "}]}