{"sha": "24aacafbfc3bae66cb43bdfadaa3411cd9383ae4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRhYWNhZmJmYzNiYWU2NmNiNDNiZGZhZGFhMzQxMWNkOTM4M2FlNA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@redhat.com", "date": "2002-12-13T01:24:52Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2002-12-13T01:24:52Z"}, "message": "re PR debug/1621 (Debugging with complex numbers)\n\nFix for PR 1621.\n\t* dbxout.c (dbxout_fptype_value): New.\n\t(dbxout_type, case COMPLEX_TYPE): Call it.  Use 'R' instead of 'r'.\n\nFrom-SVN: r60087", "tree": {"sha": "aa3334d83c30777077594e33900e57114100da1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa3334d83c30777077594e33900e57114100da1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24aacafbfc3bae66cb43bdfadaa3411cd9383ae4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24aacafbfc3bae66cb43bdfadaa3411cd9383ae4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24aacafbfc3bae66cb43bdfadaa3411cd9383ae4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24aacafbfc3bae66cb43bdfadaa3411cd9383ae4/comments", "author": null, "committer": null, "parents": [{"sha": "09da15320b1856ba010101ca5a1c2766d493c1b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09da15320b1856ba010101ca5a1c2766d493c1b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09da15320b1856ba010101ca5a1c2766d493c1b4"}], "stats": {"total": 65, "additions": 63, "deletions": 2}, "files": [{"sha": "bad7c43ad1008ff89ddd1d1d75dad238f3aa3652", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24aacafbfc3bae66cb43bdfadaa3411cd9383ae4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24aacafbfc3bae66cb43bdfadaa3411cd9383ae4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=24aacafbfc3bae66cb43bdfadaa3411cd9383ae4", "patch": "@@ -1,3 +1,8 @@\n+2002-12-12  Jim Wilson  <wilson@redhat.com>\n+\n+\t* dbxout.c (dbxout_fptype_value): New.\n+\t(dbxout_type, case COMPLEX_TYPE): Call it.  Use 'R' instead of 'r'.\n+\n 2002-12-12  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* c-decl.c: Fix a comment typo."}, {"sha": "60ca66479f28b99c166ee1ce47c23de2f53d2f0f", "filename": "gcc/dbxout.c", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24aacafbfc3bae66cb43bdfadaa3411cd9383ae4/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24aacafbfc3bae66cb43bdfadaa3411cd9383ae4/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=24aacafbfc3bae66cb43bdfadaa3411cd9383ae4", "patch": "@@ -294,6 +294,7 @@ static void dbxout_finish\t\tPARAMS ((const char *));\n static void dbxout_start_source_file\tPARAMS ((unsigned, const char *));\n static void dbxout_end_source_file\tPARAMS ((unsigned));\n static void dbxout_typedefs\t\tPARAMS ((tree));\n+static void dbxout_fptype_value\t\tPARAMS ((tree));\n static void dbxout_type_index\t\tPARAMS ((tree));\n #if DBX_CONTIN_LENGTH > 0\n static void dbxout_continue\t\tPARAMS ((void));\n@@ -689,6 +690,61 @@ dbxout_finish (filename)\n #endif /* DBX_OUTPUT_MAIN_SOURCE_FILE_END */\n }\n \n+/* Output floating point type values used by the 'R' stab letter.\n+   These numbers come from include/aout/stab_gnu.h in binutils/gdb.\n+\n+   There are only 3 real/complex types defined, and we need 7/6.\n+   We use NF_SINGLE as a generic float type, and NF_COMPLEX as a generic\n+   complex type.  Since we have the type size anyways, we don't really need\n+   to distinguish between different FP types, we only need to distinguish\n+   between float and complex.  This works fine with gdb.\n+\n+   We only use this for complex types, to avoid breaking backwards\n+   compatibility for real types.  complex types aren't in ISO C90, so it is\n+   OK if old debuggers don't understand the debug info we emit for them.  */\n+\n+/* ??? These are supposed to be IEEE types, but we don't check for that.\n+   We could perhaps add additional numbers for non-IEEE types if we need\n+   them.  */\n+\n+static void\n+dbxout_fptype_value (type)\n+     tree type;\n+{\n+  char value = '0';\n+  enum machine_mode mode = TYPE_MODE (type);\n+\n+  if (TREE_CODE (type) == REAL_TYPE)\n+    {\n+      if (mode == SFmode)\n+\tvalue = '1';\n+      else if (mode == DFmode)\n+\tvalue = '2';\n+      else if (mode == TFmode || mode == XFmode)\n+\tvalue = '6';\n+      else\n+\t/* Use NF_SINGLE as a generic real type for other sizes.  */\n+\tvalue = '1';\n+    }\n+  else if (TREE_CODE (type) == COMPLEX_TYPE)\n+    {\n+      if (mode == SCmode)\n+\tvalue = '3';\n+      else if (mode == DCmode)\n+\tvalue = '4';\n+      else if (mode == TCmode || mode == XCmode)\n+\tvalue = '5';\n+      else\n+\t/* Use NF_COMPLEX as a generic complex type for other sizes.  */\n+\tvalue = '3';\n+    }\n+  else\n+    abort ();\n+\n+  putc (value, asmfile);\n+  CHARS (1);\n+}\n+\n /* Output the index of a type.  */\n \n static void\n@@ -1362,9 +1418,9 @@ dbxout_type (type, full)\n \n       if (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE)\n \t{\n-\t  fprintf (asmfile, \"r\");\n+\t  putc ('R', asmfile);\n \t  CHARS (1);\n-\t  dbxout_type_index (type);\n+\t  dbxout_fptype_value (type);\n \t  putc (';', asmfile);\n \t  CHARS (1);\n \t  print_wide_int (2 * int_size_in_bytes (TREE_TYPE (type)));"}]}