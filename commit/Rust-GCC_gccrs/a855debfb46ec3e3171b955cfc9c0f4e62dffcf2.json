{"sha": "a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg1NWRlYmZiNDZlYzNlMzE3MWI5NTVjZmM5YzBmNGU2MmRmZmNmMg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-02-17T19:57:18Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-02-17T19:57:18Z"}, "message": "libquadmath.texi (FLT128_DIG, [...]): Document.\n\n\t* libquadmath.texi (FLT128_DIG, FLT128_MIN_10_EXP,\n\tFLT128_MAX_10_EXP): Document.\n\t(strtoflt128): Remove obsolete comment.\n\t* configure.ac (HAVE_STRTOULL): New check.\n\t* printf/gmp-impl.h (mpn_construct_float128): New prototype,\n\tdefine.\n\t* printf/mul_n.c: Include <config.h>.\n\t* printf/add_n.c: Likewise.\n\t* printf/cmp.c: Likewise.\n\t* printf/fpioconst.c: Likewise.\n\t* printf/mul_1.c: Likewise.\n\t* printf/rshift.c: Likewise.\n\t* printf/lshift.c: Likewise.\n\t* printf/submul_1.c: Likewise.\n\t* printf/sub_n.c: Likewise.\n\t* printf/divrem.c: Likewise.\n\t* printf/addmul_1.c: Likewise.\n\t* printf/mul.c: Likewise.\n\t* printf/quadmath-printf.h (isupper, isdigit, tolower): Change\n\tto avoid evaluating argument multiple times.\n\t(isxdigit): Redefine.\n\t* strtod/strtoflt128.c: New file.\n\t* strtod/strtod_l.c: New file.\n\t* strtod/mpn2flt128.c: New file.\n\t* strtod/grouping.h: New file.\n\t* strtod/tens_in_limb.c: New file.\n\t* gdtoa/arith.h: Removed.\n\t* gdtoa/gd_qnan.h: Removed.\n\t* gdtoa/gdtoa_fltrnds.h: Removed.\n\t* gdtoa/gdtoa.h: Removed.\n\t* gdtoa/gdtoaimp.h: Removed.\n\t* gdtoa/gethex.c: Removed.\n\t* gdtoa/gmisc.c: Removed.\n\t* gdtoa/hd_init.c: Removed.\n\t* gdtoa/hexnan.c: Removed.\n\t* gdtoa/makefile: Removed.\n\t* gdtoa/misc.c: Removed.\n\t* gdtoa/README.gdtoa: Removed.\n\t* gdtoa/smisc.c: Removed.\n\t* gdtoa/strtodg.c: Removed.\n\t* gdtoa/strtopQ.c: Removed.\n\t* gdtoa/sum.c: Removed.\n\t* quadmath.h (FLT128_DIG, FLT128_MIN_10_EXP, FLT128_MAX_10_EXP):\n\tDefine.\n\t* Makefile.am (libquadmath_la_SOURCES): Remove gdtoa/*, add\n\tstrtod/strtoflt128.c, strtod/mpn2flt128.c and strtod/tens_in_limb.c.\n\t* config.h.in: Regenerated.\n\t* configure: Regenerated.\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r170254", "tree": {"sha": "b5a17c88786cf39ebb208a8d2d138097c0866b3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5a17c88786cf39ebb208a8d2d138097c0866b3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa381cb2a157ab74bf8117938f3da5ba51095c2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa381cb2a157ab74bf8117938f3da5ba51095c2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa381cb2a157ab74bf8117938f3da5ba51095c2a"}], "stats": {"total": 6238, "additions": 1919, "deletions": 4319}, "files": [{"sha": "fe1dfed0daacc867d48b75b69f7f61aad3e1d2ef", "filename": "libquadmath/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2FChangeLog?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -1,3 +1,55 @@\n+2011-02-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* libquadmath.texi (FLT128_DIG, FLT128_MIN_10_EXP,\n+\tFLT128_MAX_10_EXP): Document.\n+\t(strtoflt128): Remove obsolete comment.\n+\t* configure.ac (HAVE_STRTOULL): New check.\n+\t* printf/gmp-impl.h (mpn_construct_float128): New prototype,\n+\tdefine.\n+\t* printf/mul_n.c: Include <config.h>.\n+\t* printf/add_n.c: Likewise.\n+\t* printf/cmp.c: Likewise.\n+\t* printf/fpioconst.c: Likewise.\n+\t* printf/mul_1.c: Likewise.\n+\t* printf/rshift.c: Likewise.\n+\t* printf/lshift.c: Likewise.\n+\t* printf/submul_1.c: Likewise.\n+\t* printf/sub_n.c: Likewise.\n+\t* printf/divrem.c: Likewise.\n+\t* printf/addmul_1.c: Likewise.\n+\t* printf/mul.c: Likewise.\n+\t* printf/quadmath-printf.h (isupper, isdigit, tolower): Change\n+\tto avoid evaluating argument multiple times.\n+\t(isxdigit): Redefine.\n+\t* strtod/strtoflt128.c: New file.\n+\t* strtod/strtod_l.c: New file.\n+\t* strtod/mpn2flt128.c: New file.\n+\t* strtod/grouping.h: New file.\n+\t* strtod/tens_in_limb.c: New file.\n+\t* gdtoa/arith.h: Removed.\n+\t* gdtoa/gd_qnan.h: Removed.\n+\t* gdtoa/gdtoa_fltrnds.h: Removed.\n+\t* gdtoa/gdtoa.h: Removed.\n+\t* gdtoa/gdtoaimp.h: Removed.\n+\t* gdtoa/gethex.c: Removed.\n+\t* gdtoa/gmisc.c: Removed.\n+\t* gdtoa/hd_init.c: Removed.\n+\t* gdtoa/hexnan.c: Removed.\n+\t* gdtoa/makefile: Removed.\n+\t* gdtoa/misc.c: Removed.\n+\t* gdtoa/README.gdtoa: Removed.\n+\t* gdtoa/smisc.c: Removed.\n+\t* gdtoa/strtodg.c: Removed.\n+\t* gdtoa/strtopQ.c: Removed.\n+\t* gdtoa/sum.c: Removed.\n+\t* quadmath.h (FLT128_DIG, FLT128_MIN_10_EXP, FLT128_MAX_10_EXP):\n+\tDefine.\n+\t* Makefile.am (libquadmath_la_SOURCES): Remove gdtoa/*, add\n+\tstrtod/strtoflt128.c, strtod/mpn2flt128.c and strtod/tens_in_limb.c.\n+\t* config.h.in: Regenerated.\n+\t* configure: Regenerated.\n+\t* Makefile.in: Regenerated.\n+\n 2011-02-16  Jakub Jelinek  <jakub@redhat.com>\n \n \t* printf/quadmath-printf.c: Also check __GLIBC__ when checking"}, {"sha": "d8dc2c3943504768a24594ab699c78ace4b8afc1", "filename": "libquadmath/Makefile.am", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2FMakefile.am?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -43,11 +43,6 @@ nodist_libsubinclude_HEADERS = quadmath.h quadmath_weak.h\n libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n \n libquadmath_la_SOURCES = \\\n-  gdtoa/arith.h gdtoa/gdtoa_fltrnds.h gdtoa/gd_qnan.h gdtoa/gdtoaimp.h \\\n-  gdtoa/gdtoa.h quadmath-imp.h \\\n-  gdtoa/hd_init.c gdtoa/smisc.c gdtoa/sum.c \\\n-  gdtoa/gethex.c gdtoa/hexnan.c gdtoa/strtodg.c \\\n-  gdtoa/gmisc.c gdtoa/misc.c gdtoa/strtopQ.c \\\n   math/acoshq.c math/fmodq.c math/acosq.c math/frexpq.c \\\n   math/rem_pio2q.c math/asinhq.c math/hypotq.c math/remainderq.c \\\n   math/asinq.c math/rintq.c math/atan2q.c math/isinfq.c \\\n@@ -68,7 +63,8 @@ libquadmath_la_SOURCES = \\\n   printf/addmul_1.c printf/add_n.c printf/cmp.c printf/divrem.c \\\n   printf/flt1282mpn.c printf/fpioconst.c printf/lshift.c printf/mul_1.c \\\n   printf/mul_n.c printf/mul.c printf/printf_fphex.c printf/printf_fp.c \\\n-  printf/quadmath-printf.c printf/rshift.c printf/submul_1.c printf/sub_n.c\n+  printf/quadmath-printf.c printf/rshift.c printf/submul_1.c printf/sub_n.c \\\n+  strtod/strtoflt128.c strtod/mpn2flt128.c strtod/tens_in_limb.c\n \n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS"}, {"sha": "6bf7c11388e794563cee787b4d78d417f601d741", "filename": "libquadmath/Makefile.in", "status": "modified", "additions": 73, "deletions": 103, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2FMakefile.in?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -87,59 +87,57 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(infodir)\" \\\n \t\"$(DESTDIR)$(libsubincludedir)\"\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__dirstamp = $(am__leading_dot)dirstamp\n-@BUILD_LIBQUADMATH_TRUE@am_libquadmath_la_OBJECTS = gdtoa/hd_init.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tgdtoa/smisc.lo gdtoa/sum.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tgdtoa/gethex.lo gdtoa/hexnan.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tgdtoa/strtodg.lo gdtoa/gmisc.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tgdtoa/misc.lo gdtoa/strtopQ.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/acoshq.lo math/fmodq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/acosq.lo math/frexpq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/rem_pio2q.lo math/asinhq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/hypotq.lo math/remainderq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/asinq.lo math/rintq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/atan2q.lo math/isinfq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/roundq.lo math/atanhq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/isnanq.lo math/scalblnq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/atanq.lo math/j0q.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/scalbnq.lo math/cbrtq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/j1q.lo math/signbitq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/ceilq.lo math/jnq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/sincos_table.lo math/complex.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/ldexpq.lo math/sincosq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/copysignq.lo math/lgammaq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/sincosq_kernel.lo math/coshq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/llroundq.lo math/sinhq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/cosq.lo math/log10q.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/sinq.lo math/cosq_kernel.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/log1pq.lo math/sinq_kernel.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/erfq.lo math/logq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/sqrtq.lo math/expm1q.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/lroundq.lo math/tanhq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/expq.lo math/modfq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/tanq.lo math/fabsq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/nanq.lo math/tgammaq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/finiteq.lo math/nextafterq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/truncq.lo math/floorq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/powq.lo math/fmaq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/cacoshq.lo math/cacosq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/casinhq.lo math/casinq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/catanhq.lo math/catanq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/cimagq.lo math/conjq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/cprojq.lo math/crealq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/fdimq.lo math/fmaxq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/fminq.lo math/ilogbq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/llrintq.lo math/log2q.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/lrintq.lo math/nearbyintq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/remquoq.lo printf/addmul_1.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tprintf/add_n.lo printf/cmp.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tprintf/divrem.lo printf/flt1282mpn.lo \\\n+@BUILD_LIBQUADMATH_TRUE@am_libquadmath_la_OBJECTS = math/acoshq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/fmodq.lo math/acosq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/frexpq.lo math/rem_pio2q.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/asinhq.lo math/hypotq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/remainderq.lo math/asinq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/rintq.lo math/atan2q.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/isinfq.lo math/roundq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/atanhq.lo math/isnanq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/scalblnq.lo math/atanq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/j0q.lo math/scalbnq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/cbrtq.lo math/j1q.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/signbitq.lo math/ceilq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/jnq.lo math/sincos_table.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/complex.lo math/ldexpq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/sincosq.lo math/copysignq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/lgammaq.lo math/sincosq_kernel.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/coshq.lo math/llroundq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/sinhq.lo math/cosq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/log10q.lo math/sinq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/cosq_kernel.lo math/log1pq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/sinq_kernel.lo math/erfq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/logq.lo math/sqrtq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/expm1q.lo math/lroundq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/tanhq.lo math/expq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/modfq.lo math/tanq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/fabsq.lo math/nanq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/tgammaq.lo math/finiteq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/nextafterq.lo math/truncq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/floorq.lo math/powq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/fmaq.lo math/cacoshq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/cacosq.lo math/casinhq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/casinq.lo math/catanhq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/catanq.lo math/cimagq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/conjq.lo math/cprojq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/crealq.lo math/fdimq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/fmaxq.lo math/fminq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/ilogbq.lo math/llrintq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/log2q.lo math/lrintq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/nearbyintq.lo math/remquoq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tprintf/addmul_1.lo printf/add_n.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tprintf/cmp.lo printf/divrem.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tprintf/flt1282mpn.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tprintf/fpioconst.lo printf/lshift.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tprintf/mul_1.lo printf/mul_n.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tprintf/mul.lo printf/printf_fphex.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tprintf/printf_fp.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tprintf/quadmath-printf.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tprintf/rshift.lo printf/submul_1.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tprintf/sub_n.lo\n+@BUILD_LIBQUADMATH_TRUE@\tprintf/sub_n.lo strtod/strtoflt128.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tstrtod/mpn2flt128.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tstrtod/tens_in_limb.lo\n libquadmath_la_OBJECTS = $(am_libquadmath_la_OBJECTS)\n libquadmath_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n \t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n@@ -323,11 +321,6 @@ AUTOMAKE_OPTIONS = 1.8 foreign\n @BUILD_LIBQUADMATH_TRUE@nodist_libsubinclude_HEADERS = quadmath.h quadmath_weak.h\n @BUILD_LIBQUADMATH_TRUE@libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n @BUILD_LIBQUADMATH_TRUE@libquadmath_la_SOURCES = \\\n-@BUILD_LIBQUADMATH_TRUE@  gdtoa/arith.h gdtoa/gdtoa_fltrnds.h gdtoa/gd_qnan.h gdtoa/gdtoaimp.h \\\n-@BUILD_LIBQUADMATH_TRUE@  gdtoa/gdtoa.h quadmath-imp.h \\\n-@BUILD_LIBQUADMATH_TRUE@  gdtoa/hd_init.c gdtoa/smisc.c gdtoa/sum.c \\\n-@BUILD_LIBQUADMATH_TRUE@  gdtoa/gethex.c gdtoa/hexnan.c gdtoa/strtodg.c \\\n-@BUILD_LIBQUADMATH_TRUE@  gdtoa/gmisc.c gdtoa/misc.c gdtoa/strtopQ.c \\\n @BUILD_LIBQUADMATH_TRUE@  math/acoshq.c math/fmodq.c math/acosq.c math/frexpq.c \\\n @BUILD_LIBQUADMATH_TRUE@  math/rem_pio2q.c math/asinhq.c math/hypotq.c math/remainderq.c \\\n @BUILD_LIBQUADMATH_TRUE@  math/asinq.c math/rintq.c math/atan2q.c math/isinfq.c \\\n@@ -348,7 +341,8 @@ AUTOMAKE_OPTIONS = 1.8 foreign\n @BUILD_LIBQUADMATH_TRUE@  printf/addmul_1.c printf/add_n.c printf/cmp.c printf/divrem.c \\\n @BUILD_LIBQUADMATH_TRUE@  printf/flt1282mpn.c printf/fpioconst.c printf/lshift.c printf/mul_1.c \\\n @BUILD_LIBQUADMATH_TRUE@  printf/mul_n.c printf/mul.c printf/printf_fphex.c printf/printf_fp.c \\\n-@BUILD_LIBQUADMATH_TRUE@  printf/quadmath-printf.c printf/rshift.c printf/submul_1.c printf/sub_n.c\n+@BUILD_LIBQUADMATH_TRUE@  printf/quadmath-printf.c printf/rshift.c printf/submul_1.c printf/sub_n.c \\\n+@BUILD_LIBQUADMATH_TRUE@  strtod/strtoflt128.c strtod/mpn2flt128.c strtod/tens_in_limb.c\n \n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n@@ -501,24 +495,6 @@ clean-toolexeclibLTLIBRARIES:\n \t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n \t  rm -f \"$${dir}/so_locations\"; \\\n \tdone\n-gdtoa/$(am__dirstamp):\n-\t@$(MKDIR_P) gdtoa\n-\t@: > gdtoa/$(am__dirstamp)\n-gdtoa/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) gdtoa/$(DEPDIR)\n-\t@: > gdtoa/$(DEPDIR)/$(am__dirstamp)\n-gdtoa/hd_init.lo: gdtoa/$(am__dirstamp) \\\n-\tgdtoa/$(DEPDIR)/$(am__dirstamp)\n-gdtoa/smisc.lo: gdtoa/$(am__dirstamp) gdtoa/$(DEPDIR)/$(am__dirstamp)\n-gdtoa/sum.lo: gdtoa/$(am__dirstamp) gdtoa/$(DEPDIR)/$(am__dirstamp)\n-gdtoa/gethex.lo: gdtoa/$(am__dirstamp) gdtoa/$(DEPDIR)/$(am__dirstamp)\n-gdtoa/hexnan.lo: gdtoa/$(am__dirstamp) gdtoa/$(DEPDIR)/$(am__dirstamp)\n-gdtoa/strtodg.lo: gdtoa/$(am__dirstamp) \\\n-\tgdtoa/$(DEPDIR)/$(am__dirstamp)\n-gdtoa/gmisc.lo: gdtoa/$(am__dirstamp) gdtoa/$(DEPDIR)/$(am__dirstamp)\n-gdtoa/misc.lo: gdtoa/$(am__dirstamp) gdtoa/$(DEPDIR)/$(am__dirstamp)\n-gdtoa/strtopQ.lo: gdtoa/$(am__dirstamp) \\\n-\tgdtoa/$(DEPDIR)/$(am__dirstamp)\n math/$(am__dirstamp):\n \t@$(MKDIR_P) math\n \t@: > math/$(am__dirstamp)\n@@ -645,29 +621,23 @@ printf/submul_1.lo: printf/$(am__dirstamp) \\\n \tprintf/$(DEPDIR)/$(am__dirstamp)\n printf/sub_n.lo: printf/$(am__dirstamp) \\\n \tprintf/$(DEPDIR)/$(am__dirstamp)\n+strtod/$(am__dirstamp):\n+\t@$(MKDIR_P) strtod\n+\t@: > strtod/$(am__dirstamp)\n+strtod/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) strtod/$(DEPDIR)\n+\t@: > strtod/$(DEPDIR)/$(am__dirstamp)\n+strtod/strtoflt128.lo: strtod/$(am__dirstamp) \\\n+\tstrtod/$(DEPDIR)/$(am__dirstamp)\n+strtod/mpn2flt128.lo: strtod/$(am__dirstamp) \\\n+\tstrtod/$(DEPDIR)/$(am__dirstamp)\n+strtod/tens_in_limb.lo: strtod/$(am__dirstamp) \\\n+\tstrtod/$(DEPDIR)/$(am__dirstamp)\n libquadmath.la: $(libquadmath_la_OBJECTS) $(libquadmath_la_DEPENDENCIES) \n \t$(libquadmath_la_LINK) $(am_libquadmath_la_rpath) $(libquadmath_la_OBJECTS) $(libquadmath_la_LIBADD) $(LIBS)\n \n mostlyclean-compile:\n \t-rm -f *.$(OBJEXT)\n-\t-rm -f gdtoa/gethex.$(OBJEXT)\n-\t-rm -f gdtoa/gethex.lo\n-\t-rm -f gdtoa/gmisc.$(OBJEXT)\n-\t-rm -f gdtoa/gmisc.lo\n-\t-rm -f gdtoa/hd_init.$(OBJEXT)\n-\t-rm -f gdtoa/hd_init.lo\n-\t-rm -f gdtoa/hexnan.$(OBJEXT)\n-\t-rm -f gdtoa/hexnan.lo\n-\t-rm -f gdtoa/misc.$(OBJEXT)\n-\t-rm -f gdtoa/misc.lo\n-\t-rm -f gdtoa/smisc.$(OBJEXT)\n-\t-rm -f gdtoa/smisc.lo\n-\t-rm -f gdtoa/strtodg.$(OBJEXT)\n-\t-rm -f gdtoa/strtodg.lo\n-\t-rm -f gdtoa/strtopQ.$(OBJEXT)\n-\t-rm -f gdtoa/strtopQ.lo\n-\t-rm -f gdtoa/sum.$(OBJEXT)\n-\t-rm -f gdtoa/sum.lo\n \t-rm -f math/acoshq.$(OBJEXT)\n \t-rm -f math/acoshq.lo\n \t-rm -f math/acosq.$(OBJEXT)\n@@ -854,19 +824,16 @@ mostlyclean-compile:\n \t-rm -f printf/sub_n.lo\n \t-rm -f printf/submul_1.$(OBJEXT)\n \t-rm -f printf/submul_1.lo\n+\t-rm -f strtod/mpn2flt128.$(OBJEXT)\n+\t-rm -f strtod/mpn2flt128.lo\n+\t-rm -f strtod/strtoflt128.$(OBJEXT)\n+\t-rm -f strtod/strtoflt128.lo\n+\t-rm -f strtod/tens_in_limb.$(OBJEXT)\n+\t-rm -f strtod/tens_in_limb.lo\n \n distclean-compile:\n \t-rm -f *.tab.c\n \n-@AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/gethex.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/gmisc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/hd_init.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/hexnan.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/misc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/smisc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/strtodg.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/strtopQ.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/sum.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/acoshq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/acosq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/asinhq.Plo@am__quote@\n@@ -960,6 +927,9 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/rshift.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/sub_n.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/submul_1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@strtod/$(DEPDIR)/mpn2flt128.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@strtod/$(DEPDIR)/strtoflt128.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@strtod/$(DEPDIR)/tens_in_limb.Plo@am__quote@\n \n .c.o:\n @am__fastdepCC_TRUE@\tdepbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\\.o$$||'`;\\\n@@ -990,9 +960,9 @@ mostlyclean-libtool:\n \n clean-libtool:\n \t-rm -rf .libs _libs\n-\t-rm -rf gdtoa/.libs gdtoa/_libs\n \t-rm -rf math/.libs math/_libs\n \t-rm -rf printf/.libs printf/_libs\n+\t-rm -rf strtod/.libs strtod/_libs\n \n distclean-libtool:\n \t-rm -f libtool config.lt\n@@ -1239,12 +1209,12 @@ clean-generic:\n distclean-generic:\n \t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n \t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n-\t-rm -f gdtoa/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f gdtoa/$(am__dirstamp)\n \t-rm -f math/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f math/$(am__dirstamp)\n \t-rm -f printf/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f printf/$(am__dirstamp)\n+\t-rm -f strtod/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f strtod/$(am__dirstamp)\n \n maintainer-clean-generic:\n \t@echo \"This command is intended for maintainers to use\"\n@@ -1257,7 +1227,7 @@ clean-am: clean-aminfo clean-generic clean-libtool \\\n \n distclean: distclean-am distclean-multi\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf gdtoa/$(DEPDIR) math/$(DEPDIR) printf/$(DEPDIR)\n+\t-rm -rf math/$(DEPDIR) printf/$(DEPDIR) strtod/$(DEPDIR)\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-hdr distclean-libtool distclean-tags\n@@ -1381,7 +1351,7 @@ installcheck-am:\n maintainer-clean: maintainer-clean-am maintainer-clean-multi\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n \t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf gdtoa/$(DEPDIR) math/$(DEPDIR) printf/$(DEPDIR)\n+\t-rm -rf math/$(DEPDIR) printf/$(DEPDIR) strtod/$(DEPDIR)\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-aminfo \\\n \tmaintainer-clean-generic"}, {"sha": "ea3f10c27868d41525f1366f9765b3391928e6f7", "filename": "libquadmath/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fconfig.h.in?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -69,6 +69,9 @@\n /* Define to 1 if you have the <string.h> header file. */\n #undef HAVE_STRING_H\n \n+/* Define to 1 if you have the `strtoull' function. */\n+#undef HAVE_STRTOULL\n+\n /* Define to 1 if you have the <sys/stat.h> header file. */\n #undef HAVE_SYS_STAT_H\n "}, {"sha": "8735ac5a17d5b974e8b4ce02ddae1a1db097e4b5", "filename": "libquadmath/configure", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fconfigure?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -12255,6 +12255,17 @@ $as_echo \"#define HAVE_FETESTEXCEPT 1\" >>confdefs.h\n \n fi\n \n+  for ac_func in strtoull\n+do :\n+  ac_fn_c_check_func \"$LINENO\" \"strtoull\" \"ac_cv_func_strtoull\"\n+if test \"x$ac_cv_func_strtoull\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_STRTOULL 1\n+_ACEOF\n+\n+fi\n+done\n+\n else\n   if test \"x$ac_cv_lib_m_sqrtl\" = x\"\"yes; then\n "}, {"sha": "8559c1d5aad55fdcc2d81a008f90ddf0e82a0af1", "filename": "libquadmath/configure.ac", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fconfigure.ac?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -124,6 +124,7 @@ if test x$gcc_no_link != xyes; then\n   AC_CHECK_LIB([m],[feupdateenv],[AC_DEFINE([HAVE_FEUPDATEENV],[1],[libm includes feupdateenv])])\n   AC_CHECK_LIB([m],[fesetenv],[AC_DEFINE([HAVE_FESETENV],[1],[libm includes fesetenv])])\n   AC_CHECK_LIB([m],[fetestexcept],[AC_DEFINE([HAVE_FETESTEXCEPT],[1],[libm includes fetestexcept])])\n+  AC_CHECK_FUNCS(strtoull)\n else\n   if test \"x$ac_cv_lib_m_sqrtl\" = x\"\"yes; then\n     AC_DEFINE([HAVE_SQRTL],[1],[libm includes sqrtl])  "}, {"sha": "069fd0832c39936d4c7fff887f50577ca4ad87bd", "filename": "libquadmath/gdtoa/README.gdtoa", "status": "removed", "additions": 0, "deletions": 369, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2FREADME.gdtoa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2FREADME.gdtoa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2FREADME.gdtoa?ref=fa381cb2a157ab74bf8117938f3da5ba51095c2a", "patch": "@@ -1,369 +0,0 @@\n-The content below is the README file of the gdtoa distribution, available\n-from http://www.netlib.org/fp/\n-\n-----------------------------------------------------\n-\n-This directory contains source for a library of binary -> decimal\n-and decimal -> binary conversion routines, for single-, double-,\n-and extended-precision IEEE binary floating-point arithmetic, and\n-other IEEE-like binary floating-point, including \"double double\",\n-as in\n-\n-\tT. J. Dekker, \"A Floating-Point Technique for Extending the\n-\tAvailable Precision\", Numer. Math. 18 (1971), pp. 224-242\n-\n-and\n-\n-\t\"Inside Macintosh: PowerPC Numerics\", Addison-Wesley, 1994\n-\n-The conversion routines use double-precision floating-point arithmetic\n-and, where necessary, high precision integer arithmetic.  The routines\n-are generalizations of the strtod and dtoa routines described in\n-\n-\tDavid M. Gay, \"Correctly Rounded Binary-Decimal and\n-\tDecimal-Binary Conversions\", Numerical Analysis Manuscript\n-\tNo. 90-10, Bell Labs, Murray Hill, 1990;\n-\thttp://cm.bell-labs.com/cm/cs/what/ampl/REFS/rounding.ps.gz\n-\n-(based in part on papers by Clinger and Steele & White: see the\n-references in the above paper).\n-\n-The present conversion routines should be able to use any of IEEE binary,\n-VAX, or IBM-mainframe double-precision arithmetic internally, but I (dmg)\n-have so far only had a chance to test them with IEEE double precision\n-arithmetic.\n-\n-The core conversion routines are strtodg for decimal -> binary conversions\n-and gdtoa for binary -> decimal conversions.  These routines operate\n-on arrays of unsigned 32-bit integers of type ULong, a signed 32-bit\n-exponent of type Long, and arithmetic characteristics described in\n-struct FPI; FPI, Long, and ULong are defined in gdtoa.h.  File arith.h\n-is supposed to provide #defines that cause gdtoa.h to define its\n-types correctly.  File arithchk.c is source for a program that\n-generates a suitable arith.h on all systems where I've been able to\n-test it.\n-\n-The core conversion routines are meant to be called by helper routines\n-that know details of the particular binary arithmetic of interest and\n-convert.  The present directory provides helper routines for 5 variants\n-of IEEE binary floating-point arithmetic, each indicated by one or\n-two letters:\n-\n-\tf\tIEEE single precision\n-\td\tIEEE double precision\n-\tx\tIEEE extended precision, as on Intel 80x87\n-\t\tand software emulations of Motorola 68xxx chips\n-\t\tthat do not pad the way the 68xxx does, but\n-\t\tonly store 80 bits\n-\txL\tIEEE extended precision, as on Motorola 68xxx chips\n-\tQ\tquad precision, as on Sun Sparc chips\n-\tdd\tdouble double, pairs of IEEE double numbers\n-\t\twhose sum is the desired value\n-\n-For decimal -> binary conversions, there are three families of\n-helper routines: one for round-nearest (or the current rounding\n-mode on IEEE-arithmetic systems that provide the C99 fegetround()\n-function, if compiled with -DHonor_FLT_ROUNDS):\n-\n-\tstrtof\n-\tstrtod\n-\tstrtodd\n-\tstrtopd\n-\tstrtopf\n-\tstrtopx\n-\tstrtopxL\n-\tstrtopQ\n-\n-one with rounding direction specified:\n-\n-\tstrtorf\n-\tstrtord\n-\tstrtordd\n-\tstrtorx\n-\tstrtorxL\n-\tstrtorQ\n-\n-and one for computing an interval (at most one bit wide) that contains\n-the decimal number:\n-\n-\tstrtoIf\n-\tstrtoId\n-\tstrtoIdd\n-\tstrtoIx\n-\tstrtoIxL\n-\tstrtoIQ\n-\n-The latter call strtoIg, which makes one call on strtodg and adjusts\n-the result to provide the desired interval.  On systems where native\n-arithmetic can easily make one-ulp adjustments on values in the\n-desired floating-point format, it might be more efficient to use the\n-native arithmetic.  Routine strtodI is a variant of strtoId that\n-illustrates one way to do this for IEEE binary double-precision\n-arithmetic -- but whether this is more efficient remains to be seen.\n-\n-Functions strtod and strtof have \"natural\" return types, float and\n-double -- strtod is specified by the C standard, and strtof appears\n-in the stdlib.h of some systems, such as (at least some) Linux systems.\n-The other functions write their results to their final argument(s):\n-to the final two argument for the strtoI... (interval) functions,\n-and to the final argument for the others (strtop... and strtor...).\n-Where possible, these arguments have \"natural\" return types (double*\n-or float*), to permit at least some type checking.  In reality, they\n-are viewed as arrays of ULong (or, for the \"x\" functions, UShort)\n-values. On systems where long double is the appropriate type, one can\n-pass long double* final argument(s) to these routines.  The int value\n-that these routines return is the return value from the call they make\n-on strtodg; see the enum of possible return values in gdtoa.h.\n-\n-Source files g_ddfmt.c, misc.c, smisc.c, strtod.c, strtodg.c, and ulp.c\n-should use true IEEE double arithmetic (not, e.g., double extended),\n-at least for storing (and viewing the bits of) the variables declared\n-\"double\" within them.\n-\n-One detail indicated in struct FPI is whether the target binary\n-arithmetic departs from the IEEE standard by flushing denormalized\n-numbers to 0.  On systems that do this, the helper routines for\n-conversion to double-double format (when compiled with\n-Sudden_Underflow #defined) penalize the bottom of the exponent\n-range so that they return a nonzero result only when the least\n-significant bit of the less significant member of the pair of\n-double values returned can be expressed as a normalized double\n-value.  An alternative would be to drop to 53-bit precision near\n-the bottom of the exponent range.  To get correct rounding, this\n-would (in general) require two calls on strtodg (one specifying\n-126-bit arithmetic, then, if necessary, one specifying 53-bit\n-arithmetic).\n-\n-By default, the core routine strtodg and strtod set errno to ERANGE\n-if the result overflows to +Infinity or underflows to 0.  Compile\n-these routines with NO_ERRNO #defined to inhibit errno assignments.\n-\n-Routine strtod is based on netlib's \"dtoa.c from fp\", and\n-(f = strtod(s,se)) is more efficient for some conversions than, say,\n-strtord(s,se,1,&f).  Parts of strtod require true IEEE double\n-arithmetic with the default rounding mode (round-to-nearest) and, on\n-systems with IEEE extended-precision registers, double-precision\n-(53-bit) rounding precision.  If the machine uses (the equivalent of)\n-Intel 80x87 arithmetic, the call\n-\t_control87(PC_53, MCW_PC);\n-does this with many compilers.  Whether this or another call is\n-appropriate depends on the compiler; for this to work, it may be\n-necessary to #include \"float.h\" or another system-dependent header\n-file.\n-\n-Source file strtodnrp.c gives a strtod that does not require 53-bit\n-rounding precision on systems (such as Intel IA32 systems) that may\n-suffer double rounding due to use of extended-precision registers.\n-For some conversions this variant of strtod is less efficient than the\n-one in strtod.c when the latter is run with 53-bit rounding precision.\n-\n-The values that the strto* routines return for NaNs are determined by\n-gd_qnan.h, which the makefile generates by running the program whose\n-source is qnan.c.  Note that the rules for distinguishing signaling\n-from quiet NaNs are system-dependent.  For cross-compilation, you need\n-to determine arith.h and gd_qnan.h suitably, e.g., using the\n-arithmetic of the target machine.\n-\n-C99's hexadecimal floating-point constants are recognized by the\n-strto* routines (but this feature has not yet been heavily tested).\n-Compiling with NO_HEX_FP #defined disables this feature.\n-\n-When compiled with -DINFNAN_CHECK, the strto* routines recognize C99's\n-NaN and Infinity syntax.  Moreover, unless No_Hex_NaN is #defined, the\n-strto* routines also recognize C99's NaN(...) syntax: they accept\n-(case insensitively) strings of the form NaN(x), where x is a string\n-of hexadecimal digits and spaces; if there is only one string of\n-hexadecimal digits, it is taken for the fraction bits of the resulting\n-NaN; if there are two or more strings of hexadecimal digits, each\n-string is assigned to the next available sequence of 32-bit words of\n-fractions bits (starting with the most significant), right-aligned in\n-each sequence.\n-\n-For binary -> decimal conversions, I've provided just one family\n-of helper routines:\n-\n-\tg_ffmt\n-\tg_dfmt\n-\tg_ddfmt\n-\tg_xfmt\n-\tg_xLfmt\n-\tg_Qfmt\n-\n-which do a \"%g\" style conversion either to a specified number of decimal\n-places (if their ndig argument is positive), or to the shortest\n-decimal string that rounds to the given binary floating-point value\n-(if ndig <= 0).  They write into a buffer supplied as an argument\n-and return either a pointer to the end of the string (a null character)\n-in the buffer, if the buffer was long enough, or 0.  Other forms of\n-conversion are easily done with the help of gdtoa(), such as %e or %f\n-style and conversions with direction of rounding specified (so that, if\n-desired, the decimal value is either >= or <= the binary value).\n-On IEEE-arithmetic systems that provide the C99 fegetround() function,\n-if compiled with -DHonor_FLT_ROUNDS, these routines honor the current\n-rounding mode.\n-\n-For an example of more general conversions based on dtoa(), see\n-netlib's \"printf.c from ampl/solvers\".\n-\n-For double-double -> decimal, g_ddfmt() assumes IEEE-like arithmetic\n-of precision max(126, #bits(input)) bits, where #bits(input) is the\n-number of mantissa bits needed to represent the sum of the two double\n-values in the input.\n-\n-The makefile creates a library, gdtoa.a.  To use the helper\n-routines, a program only needs to include gdtoa.h.  All the\n-source files for gdtoa.a include a more extensive gdtoaimp.h;\n-among other things, gdtoaimp.h has #defines that make \"internal\"\n-names end in _D2A.  To make a \"system\" library, one could modify\n-these #defines to make the names start with __.\n-\n-Various comments about possible #defines appear in gdtoaimp.h,\n-but for most purposes, arith.h should set suitable #defines.\n-\n-Systems with preemptive scheduling of multiple threads require some\n-manual intervention.  On such systems, it's necessary to compile\n-dmisc.c, dtoa.c gdota.c, and misc.c with MULTIPLE_THREADS #defined,\n-and to provide (or suitably #define) two locks, acquired by\n-ACQUIRE_DTOA_LOCK(n) and freed by FREE_DTOA_LOCK(n) for n = 0 or 1.\n-(The second lock, accessed in pow5mult, ensures lazy evaluation of\n-only one copy of high powers of 5; omitting this lock would introduce\n-a small probability of wasting memory, but would otherwise be harmless.)\n-Routines that call dtoa or gdtoa directly must also invoke freedtoa(s)\n-to free the value s returned by dtoa or gdtoa.  It's OK to do so whether\n-or not MULTIPLE_THREADS is #defined, and the helper g_*fmt routines\n-listed above all do this indirectly (in gfmt_D2A(), which they all call).\n-\n-By default, there is a private pool of memory of length 2000 bytes\n-for intermediate quantities, and MALLOC (see gdtoaimp.h) is called only\n-if the private pool does not suffice.   2000 is large enough that MALLOC\n-is called only under very unusual circumstances (decimal -> binary\n-conversion of very long strings) for conversions to and from double\n-precision.  For systems with preemptively scheduled multiple threads\n-or for conversions to extended or quad, it may be appropriate to\n-#define PRIVATE_MEM nnnn, where nnnn is a suitable value > 2000.\n-For extended and quad precisions, -DPRIVATE_MEM=20000 is probably\n-plenty even for many digits at the ends of the exponent range.\n-Use of the private pool avoids some overhead.\n-\n-Directory test provides some test routines.  See its README.\n-I've also tested this stuff (except double double conversions)\n-with Vern Paxson's testbase program: see\n-\n-\tV. Paxson and W. Kahan, \"A Program for Testing IEEE Binary-Decimal\n-\tConversion\", manuscript, May 1991,\n-\tftp://ftp.ee.lbl.gov/testbase-report.ps.Z .\n-\n-(The same ftp directory has source for testbase.)\n-\n-Some system-dependent additions to CFLAGS in the makefile:\n-\n-\tHU-UX: -Aa -Ae\n-\tOSF (DEC Unix): -ieee_with_no_inexact\n-\tSunOS 4.1x: -DKR_headers -DBad_float_h\n-\n-If you want to put this stuff into a shared library and your\n-operating system requires export lists for shared libraries,\n-the following would be an appropriate export list:\n-\n-\tdtoa\n-\tfreedtoa\n-\tg_Qfmt\n-\tg_ddfmt\n-\tg_dfmt\n-\tg_ffmt\n-\tg_xLfmt\n-\tg_xfmt\n-\tgdtoa\n-\tstrtoIQ\n-\tstrtoId\n-\tstrtoIdd\n-\tstrtoIf\n-\tstrtoIx\n-\tstrtoIxL\n-\tstrtod\n-\tstrtodI\n-\tstrtodg\n-\tstrtof\n-\tstrtopQ\n-\tstrtopd\n-\tstrtopdd\n-\tstrtopf\n-\tstrtopx\n-\tstrtopxL\n-\tstrtorQ\n-\tstrtord\n-\tstrtordd\n-\tstrtorf\n-\tstrtorx\n-\tstrtorxL\n-\n-When time permits, I (dmg) hope to write in more detail about the\n-present conversion routines; for now, this README file must suffice.\n-Meanwhile, if you wish to write helper functions for other kinds of\n-IEEE-like arithmetic, some explanation of struct FPI and the bits\n-array may be helpful.  Both gdtoa and strtodg operate on a bits array\n-described by FPI *fpi.  The bits array is of type ULong, a 32-bit\n-unsigned integer type.  Floating-point numbers have fpi->nbits bits,\n-with the least significant 32 bits in bits[0], the next 32 bits in\n-bits[1], etc.  These numbers are regarded as integers multiplied by\n-2^e (i.e., 2 to the power of the exponent e), where e is the second\n-argument (be) to gdtoa and is stored in *exp by strtodg.  The minimum\n-and maximum exponent values fpi->emin and fpi->emax for normalized\n-floating-point numbers reflect this arrangement.  For example, the\n-P754 standard for binary IEEE arithmetic specifies doubles as having\n-53 bits, with normalized values of the form 1.xxxxx... times 2^(b-1023),\n-with 52 bits (the x's) and the biased exponent b represented explicitly;\n-b is an unsigned integer in the range 1 <= b <= 2046 for normalized\n-finite doubles, b = 0 for denormals, and b = 2047 for Infinities and NaNs.\n-To turn an IEEE double into the representation used by strtodg and gdtoa,\n-we multiply 1.xxxx... by 2^52 (to make it an integer) and reduce the\n-exponent e = (b-1023) by 52:\n-\n-\tfpi->emin = 1 - 1023 - 52\n-\tfpi->emax = 1046 - 1023 - 52\n-\n-In various wrappers for IEEE double, we actually write -53 + 1 rather\n-than -52, to emphasize that there are 53 bits including one implicit bit.\n-Field fpi->rounding indicates the desired rounding direction, with\n-possible values\n-\tFPI_Round_zero = toward 0,\n-\tFPI_Round_near = unbiased rounding -- the IEEE default,\n-\tFPI_Round_up = toward +Infinity, and\n-\tFPI_Round_down = toward -Infinity\n-given in gdtoa.h.\n-\n-Field fpi->sudden_underflow indicates whether strtodg should return\n-denormals or flush them to zero.  Normal floating-point numbers have\n-bit fpi->nbits in the bits array on.  Denormals have it off, with\n-exponent = fpi->emin.  Strtodg provides distinct return values for normals\n-and denormals; see gdtoa.h.\n-\n-Compiling g__fmt.c, strtod.c, and strtodg.c with -DUSE_LOCALE causes\n-the decimal-point character to be taken from the current locale; otherwise\n-it is '.'.\n-\n-Source files dtoa.c and strtod.c in this directory are derived from\n-netlib's \"dtoa.c from fp\" and are meant to function equivalently.\n-When compiled with Honor_FLT_ROUNDS #defined (on systems that provide\n-FLT_ROUNDS and fegetround() as specified in the C99 standard), they\n-honor the current rounding mode.  Because FLT_ROUNDS is buggy on some\n-(Linux) systems -- not reflecting calls on fesetround(), as the C99\n-standard says it should -- when Honor_FLT_ROUNDS is #defined, the\n-current rounding mode is obtained from fegetround() rather than from\n-FLT_ROUNDS, unless Trust_FLT_ROUNDS is also #defined.\n-\n-Compile with -DUSE_LOCALE to use the current locale; otherwise\n-decimal points are assumed to be '.'.  With -DUSE_LOCALE, unless\n-you also compile with -DNO_LOCALE_CACHE, the details about the\n-current \"decimal point\" character string are cached and assumed not\n-to change during the program's execution.\n-\n-On machines with a 64-bit long double and perhaps a 113-bit \"quad\"\n-type, you can invoke \"make Printf\" to add Printf (and variants, such\n-as Fprintf) to gdtoa.a.  These are analogs, declared in stdio1.h, of\n-printf and fprintf, etc. in which %La, %Le, %Lf, and %Lg are for long\n-double and (if appropriate) %Lqa, %Lqe, %Lqf, and %Lqg are for quad\n-precision printing.\n-\n-Please send comments to\tDavid M. Gay (dmg at acm dot org, with \" at \"\n-changed at \"@\" and \" dot \" changed to \".\")."}, {"sha": "f4209e31e89e885213890efaf9a47068b94c8fdf", "filename": "libquadmath/gdtoa/arith.h", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Farith.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Farith.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Farith.h?ref=fa381cb2a157ab74bf8117938f3da5ba51095c2a", "patch": "@@ -1,14 +0,0 @@\n-#include <stdint.h>\n-\n-#if __LITTLE_ENDIAN__\n-# define IEEE_8087\n-#elif __BIG_ENDIAN__\n-# define IEEE_MC68k\n-#else\n-// Because quad math is typically performed on little-endian hardware\n-//# error \"Unknown endianness\"\n-# define IEEE_8087\n-#endif\n-\n-// This should be 32 bit integer type\n-#define Long int"}, {"sha": "68d90e440f2b50e92866fb46b705f84da6eb096c", "filename": "libquadmath/gdtoa/gd_qnan.h", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fgd_qnan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fgd_qnan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fgd_qnan.h?ref=fa381cb2a157ab74bf8117938f3da5ba51095c2a", "patch": "@@ -1,12 +0,0 @@\n-#define f_QNAN 0x7fc00000\n-#define d_QNAN0 0x0\n-#define d_QNAN1 0x7ff80000\n-#define ld_QNAN0 0x0\n-#define ld_QNAN1 0x0\n-#define ld_QNAN2 0x0\n-#define ld_QNAN3 0x7fff8000\n-#define ldus_QNAN0 0x0\n-#define ldus_QNAN1 0x0\n-#define ldus_QNAN2 0x0\n-#define ldus_QNAN3 0xc000\n-#define ldus_QNAN4 0x7fff"}, {"sha": "de10a436c5ab4ea7629132c6c84e0ebabe93da3c", "filename": "libquadmath/gdtoa/gdtoa.h", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fgdtoa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fgdtoa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fgdtoa.h?ref=fa381cb2a157ab74bf8117938f3da5ba51095c2a", "patch": "@@ -1,153 +0,0 @@\n-/****************************************************************\n-\n-The author of this software is David M. Gay.\n-\n-Copyright (C) 1998 by Lucent Technologies\n-All Rights Reserved\n-\n-Permission to use, copy, modify, and distribute this software and\n-its documentation for any purpose and without fee is hereby\n-granted, provided that the above copyright notice appear in all\n-copies and that both that the copyright notice and this\n-permission notice and warranty disclaimer appear in supporting\n-documentation, and that the name of Lucent or any of its entities\n-not be used in advertising or publicity pertaining to\n-distribution of the software without specific, written prior\n-permission.\n-\n-LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n-INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n-IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n-SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n-IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n-THIS SOFTWARE.\n-\n-****************************************************************/\n-\n-/* Please send bug reports to David M. Gay (dmg at acm dot org,\n- * with \" at \" changed at \"@\" and \" dot \" changed to \".\").\t*/\n-\n-#ifndef GDTOA_H_INCLUDED\n-#define GDTOA_H_INCLUDED\n-\n-#include \"arith.h\"\n-#include <stddef.h> /* for size_t */\n-#include <stdlib.h> /* for strtod */\n-\n-#ifndef Long\n-#define Long long\n-#endif\n-#ifndef ULong\n-typedef unsigned Long ULong;\n-#endif\n-#ifndef UShort\n-typedef unsigned short UShort;\n-#endif\n-\n-#ifndef ANSI\n-#ifdef KR_headers\n-#define ANSI(x) ()\n-#define Void /*nothing*/\n-#else\n-#define ANSI(x) x\n-#define Void void\n-#endif\n-#endif /* ANSI */\n-\n-#ifndef CONST\n-#ifdef KR_headers\n-#define CONST /* blank */\n-#else\n-#define CONST const\n-#endif\n-#endif /* CONST */\n-\n- enum {\t/* return values from strtodg */\n-\tSTRTOG_Zero\t= 0,\n-\tSTRTOG_Normal\t= 1,\n-\tSTRTOG_Denormal\t= 2,\n-\tSTRTOG_Infinite\t= 3,\n-\tSTRTOG_NaN\t= 4,\n-\tSTRTOG_NaNbits\t= 5,\n-\tSTRTOG_NoNumber\t= 6,\n-\tSTRTOG_Retmask\t= 7,\n-\n-\t/* The following may be or-ed into one of the above values. */\n-\n-\tSTRTOG_Neg\t= 0x08, /* does not affect STRTOG_Inexlo or STRTOG_Inexhi */\n-\tSTRTOG_Inexlo\t= 0x10,\t/* returned result rounded toward zero */\n-\tSTRTOG_Inexhi\t= 0x20, /* returned result rounded away from zero */\n-\tSTRTOG_Inexact\t= 0x30,\n-\tSTRTOG_Underflow= 0x40,\n-\tSTRTOG_Overflow\t= 0x80\n-\t};\n-\n- typedef struct\n-FPI {\n-\tint nbits;\n-\tint emin;\n-\tint emax;\n-\tint rounding;\n-\tint sudden_underflow;\n-\t} FPI;\n-\n-enum {\t/* FPI.rounding values: same as FLT_ROUNDS */\n-\tFPI_Round_zero = 0,\n-\tFPI_Round_near = 1,\n-\tFPI_Round_up = 2,\n-\tFPI_Round_down = 3\n-\t};\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-extern char* dtoa  ANSI((double d, int mode, int ndigits, int *decpt,\n-\t\t\tint *sign, char **rve));\n-extern char* gdtoa ANSI((FPI *fpi, int be, ULong *bits, int *kindp,\n-\t\t\tint mode, int ndigits, int *decpt, char **rve));\n-extern void freedtoa ANSI((char*));\n-extern int strtodg ANSI((CONST char*, char**, FPI*, Long*, ULong*));\n-\n-extern char*\tg_ddfmt  ANSI((char*, double*, int, size_t));\n-extern char*\tg_dfmt   ANSI((char*, double*, int, size_t));\n-extern char*\tg_ffmt   ANSI((char*, float*,  int, size_t));\n-extern char*\tg_Qfmt   ANSI((char*, void*,   int, size_t));\n-extern char*\tg_xfmt   ANSI((char*, void*,   int, size_t));\n-extern char*\tg_xLfmt  ANSI((char*, void*,   int, size_t));\n-\n-extern int\tstrtoId  ANSI((CONST char*, char**, double*, double*));\n-extern int\tstrtoIdd ANSI((CONST char*, char**, double*, double*));\n-extern int\tstrtoIf  ANSI((CONST char*, char**, float*, float*));\n-extern int\tstrtoIQ  ANSI((CONST char*, char**, void*, void*));\n-extern int\tstrtoIx  ANSI((CONST char*, char**, void*, void*));\n-extern int\tstrtoIxL ANSI((CONST char*, char**, void*, void*));\n-extern int\tstrtord  ANSI((CONST char*, char**, int, double*));\n-extern int\tstrtordd ANSI((CONST char*, char**, int, double*));\n-extern int\tstrtorf  ANSI((CONST char*, char**, int, float*));\n-extern int\tstrtorQ  ANSI((CONST char*, char**, int, void*));\n-extern int\tstrtorx  ANSI((CONST char*, char**, int, void*));\n-extern int\tstrtorxL ANSI((CONST char*, char**, int, void*));\n-#if 1\n-extern int\tstrtodI  ANSI((CONST char*, char**, double*));\n-extern int\tstrtopd  ANSI((CONST char*, char**, double*));\n-extern int\tstrtopdd ANSI((CONST char*, char**, double*));\n-extern int\tstrtopf  ANSI((CONST char*, char**, float*));\n-extern int\tquadmath_strtopQ  ANSI((CONST char*, char**, void*));\n-extern int\tstrtopx  ANSI((CONST char*, char**, void*));\n-extern int\tstrtopxL ANSI((CONST char*, char**, void*));\n-#else\n-#define strtopd(s,se,x) strtord(s,se,1,x)\n-#define strtopdd(s,se,x) strtordd(s,se,1,x)\n-#define strtopf(s,se,x) strtorf(s,se,1,x)\n-#define strtopQ(s,se,x) strtorQ(s,se,1,x)\n-#define strtopx(s,se,x) strtorx(s,se,1,x)\n-#define strtopxL(s,se,x) strtorxL(s,se,1,x)\n-#endif\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-#endif /* GDTOA_H_INCLUDED */"}, {"sha": "33e5f9e5342c8568e487b6a43115ce8091e35b7d", "filename": "libquadmath/gdtoa/gdtoa_fltrnds.h", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fgdtoa_fltrnds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fgdtoa_fltrnds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fgdtoa_fltrnds.h?ref=fa381cb2a157ab74bf8117938f3da5ba51095c2a", "patch": "@@ -1,18 +0,0 @@\n-\tFPI *fpi, fpi1;\n-\tint Rounding;\n-#ifdef Trust_FLT_ROUNDS /*{{ only define this if FLT_ROUNDS really works! */\n-\tRounding = Flt_Rounds;\n-#else /*}{*/\n-\tRounding = 1;\n-\tswitch(fegetround()) {\n-\t  case FE_TOWARDZERO:\tRounding = 0; break;\n-\t  case FE_UPWARD:\tRounding = 2; break;\n-\t  case FE_DOWNWARD:\tRounding = 3;\n-\t  }\n-#endif /*}}*/\n-\tfpi = &fpi0;\n-\tif (Rounding != 1) {\n-\t\tfpi1 = fpi0;\n-\t\tfpi = &fpi1;\n-\t\tfpi1.rounding = Rounding;\n-\t\t}"}, {"sha": "4aa8f78d307263c14fe521fbc708ff67e40c7c56", "filename": "libquadmath/gdtoa/gdtoaimp.h", "status": "removed", "additions": 0, "deletions": 620, "changes": 620, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fgdtoaimp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fgdtoaimp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fgdtoaimp.h?ref=fa381cb2a157ab74bf8117938f3da5ba51095c2a", "patch": "@@ -1,620 +0,0 @@\n-/****************************************************************\n-\n-The author of this software is David M. Gay.\n-\n-Copyright (C) 1998-2000 by Lucent Technologies\n-All Rights Reserved\n-\n-Permission to use, copy, modify, and distribute this software and\n-its documentation for any purpose and without fee is hereby\n-granted, provided that the above copyright notice appear in all\n-copies and that both that the copyright notice and this\n-permission notice and warranty disclaimer appear in supporting\n-documentation, and that the name of Lucent or any of its entities\n-not be used in advertising or publicity pertaining to\n-distribution of the software without specific, written prior\n-permission.\n-\n-LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n-INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n-IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n-SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n-IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n-THIS SOFTWARE.\n-\n-****************************************************************/\n-\n-/* This is a variation on dtoa.c that converts arbitary binary\n-   floating-point formats to and from decimal notation.  It uses\n-   double-precision arithmetic internally, so there are still\n-   various #ifdefs that adapt the calculations to the native\n-   double-precision arithmetic (any of IEEE, VAX D_floating,\n-   or IBM mainframe arithmetic).\n-\n-   Please send bug reports to David M. Gay (dmg at acm dot org,\n-   with \" at \" changed at \"@\" and \" dot \" changed to \".\").\n- */\n-\n-/* On a machine with IEEE extended-precision registers, it is\n- * necessary to specify double-precision (53-bit) rounding precision\n- * before invoking strtod or dtoa.  If the machine uses (the equivalent\n- * of) Intel 80x87 arithmetic, the call\n- *\t_control87(PC_53, MCW_PC);\n- * does this with many compilers.  Whether this or another call is\n- * appropriate depends on the compiler; for this to work, it may be\n- * necessary to #include \"float.h\" or another system-dependent header\n- * file.\n- */\n-\n-/* strtod for IEEE-, VAX-, and IBM-arithmetic machines.\n- *\n- * This strtod returns a nearest machine number to the input decimal\n- * string (or sets errno to ERANGE).  With IEEE arithmetic, ties are\n- * broken by the IEEE round-even rule.  Otherwise ties are broken by\n- * biased rounding (add half and chop).\n- *\n- * Inspired loosely by William D. Clinger's paper \"How to Read Floating\n- * Point Numbers Accurately\" [Proc. ACM SIGPLAN '90, pp. 112-126].\n- *\n- * Modifications:\n- *\n- *\t1. We only require IEEE, IBM, or VAX double-precision\n- *\t\tarithmetic (not IEEE double-extended).\n- *\t2. We get by with floating-point arithmetic in a case that\n- *\t\tClinger missed -- when we're computing d * 10^n\n- *\t\tfor a small integer d and the integer n is not too\n- *\t\tmuch larger than 22 (the maximum integer k for which\n- *\t\twe can represent 10^k exactly), we may be able to\n- *\t\tcompute (d*10^k) * 10^(e-k) with just one roundoff.\n- *\t3. Rather than a bit-at-a-time adjustment of the binary\n- *\t\tresult in the hard case, we use floating-point\n- *\t\tarithmetic to determine the adjustment to within\n- *\t\tone bit; only in really hard cases do we need to\n- *\t\tcompute a second residual.\n- *\t4. Because of 3., we don't need a large table of powers of 10\n- *\t\tfor ten-to-e (just some small tables, e.g. of 10^k\n- *\t\tfor 0 <= k <= 22).\n- */\n-\n-/*\n- * #define IEEE_8087 for IEEE-arithmetic machines where the least\n- *\tsignificant byte has the lowest address.\n- * #define IEEE_MC68k for IEEE-arithmetic machines where the most\n- *\tsignificant byte has the lowest address.\n- * #define Long int on machines with 32-bit ints and 64-bit longs.\n- * #define Sudden_Underflow for IEEE-format machines without gradual\n- *\tunderflow (i.e., that flush to zero on underflow).\n- * #define IBM for IBM mainframe-style floating-point arithmetic.\n- * #define VAX for VAX-style floating-point arithmetic (D_floating).\n- * #define No_leftright to omit left-right logic in fast floating-point\n- *\tcomputation of dtoa.\n- * #define Check_FLT_ROUNDS if FLT_ROUNDS can assume the values 2 or 3.\n- * #define RND_PRODQUOT to use rnd_prod and rnd_quot (assembly routines\n- *\tthat use extended-precision instructions to compute rounded\n- *\tproducts and quotients) with IBM.\n- * #define ROUND_BIASED for IEEE-format with biased rounding.\n- * #define Inaccurate_Divide for IEEE-format with correctly rounded\n- *\tproducts but inaccurate quotients, e.g., for Intel i860.\n- * #define NO_LONG_LONG on machines that do not have a \"long long\"\n- *\tinteger type (of >= 64 bits).  On such machines, you can\n- *\t#define Just_16 to store 16 bits per 32-bit Long when doing\n- *\thigh-precision integer arithmetic.  Whether this speeds things\n- *\tup or slows things down depends on the machine and the number\n- *\tbeing converted.  If long long is available and the name is\n- *\tsomething other than \"long long\", #define Llong to be the name,\n- *\tand if \"unsigned Llong\" does not work as an unsigned version of\n- *\tLlong, #define #ULLong to be the corresponding unsigned type.\n- * #define KR_headers for old-style C function headers.\n- * #define Bad_float_h if your system lacks a float.h or if it does not\n- *\tdefine some or all of DBL_DIG, DBL_MAX_10_EXP, DBL_MAX_EXP,\n- *\tFLT_RADIX, FLT_ROUNDS, and DBL_MAX.\n- * #define MALLOC your_malloc, where your_malloc(n) acts like malloc(n)\n- *\tif memory is available and otherwise does something you deem\n- *\tappropriate.  If MALLOC is undefined, malloc will be invoked\n- *\tdirectly -- and assumed always to succeed.  Similarly, if you\n- *\twant something other than the system's free() to be called to\n- *\trecycle memory acquired from MALLOC, #define FREE to be the\n- *\tname of the alternate routine.  (FREE or free is only called in\n- *\tpathological cases, e.g., in a gdtoa call after a gdtoa return in\n- *\tmode 3 with thousands of digits requested.)\n- * #define Omit_Private_Memory to omit logic (added Jan. 1998) for making\n- *\tmemory allocations from a private pool of memory when possible.\n- *\tWhen used, the private pool is PRIVATE_MEM bytes long:  2304 bytes,\n- *\tunless #defined to be a different length.  This default length\n- *\tsuffices to get rid of MALLOC calls except for unusual cases,\n- *\tsuch as decimal-to-binary conversion of a very long string of\n- *\tdigits.  When converting IEEE double precision values, the\n- *\tlongest string gdtoa can return is about 751 bytes long.  For\n- *\tconversions by strtod of strings of 800 digits and all gdtoa\n- *\tconversions of IEEE doubles in single-threaded executions with\n- *\t8-byte pointers, PRIVATE_MEM >= 7400 appears to suffice; with\n- *\t4-byte pointers, PRIVATE_MEM >= 7112 appears adequate.\n- * #define NO_INFNAN_CHECK if you do not wish to have INFNAN_CHECK\n- *\t#defined automatically on IEEE systems.  On such systems,\n- *\twhen INFNAN_CHECK is #defined, strtod checks\n- *\tfor Infinity and NaN (case insensitively).\n- *\tWhen INFNAN_CHECK is #defined and No_Hex_NaN is not #defined,\n- *\tstrtodg also accepts (case insensitively) strings of the form\n- *\tNaN(x), where x is a string of hexadecimal digits (optionally\n- *\tpreceded by 0x or 0X) and spaces; if there is only one string\n- *\tof hexadecimal digits, it is taken for the fraction bits of the\n- *\tresulting NaN; if there are two or more strings of hexadecimal\n- *\tdigits, each string is assigned to the next available sequence\n- *\tof 32-bit words of fractions bits (starting with the most\n- *\tsignificant), right-aligned in each sequence.\n- *\tUnless GDTOA_NON_PEDANTIC_NANCHECK is #defined, input \"NaN(...)\"\n- *\tis consumed even when ... has the wrong form (in which case the\n- *\t\"(...)\" is consumed but ignored).\n- * #define MULTIPLE_THREADS if the system offers preemptively scheduled\n- *\tmultiple threads.  In this case, you must provide (or suitably\n- *\t#define) two locks, acquired by ACQUIRE_DTOA_LOCK(n) and freed\n- *\tby FREE_DTOA_LOCK(n) for n = 0 or 1.  (The second lock, accessed\n- *\tin pow5mult, ensures lazy evaluation of only one copy of high\n- *\tpowers of 5; omitting this lock would introduce a small\n- *\tprobability of wasting memory, but would otherwise be harmless.)\n- *\tYou must also invoke freedtoa(s) to free the value s returned by\n- *\tdtoa.  You may do so whether or not MULTIPLE_THREADS is #defined.\n- * #define IMPRECISE_INEXACT if you do not care about the setting of\n- *\tthe STRTOG_Inexact bits in the special case of doing IEEE double\n- *\tprecision conversions (which could also be done by the strtod in\n- *\tdtoa.c).\n- * #define NO_HEX_FP to disable recognition of C9x's hexadecimal\n- *\tfloating-point constants.\n- * #define -DNO_ERRNO to suppress setting errno (in strtod.c and\n- *\tstrtodg.c).\n- * #define NO_STRING_H to use private versions of memcpy.\n- *\tOn some K&R systems, it may also be necessary to\n- *\t#define DECLARE_SIZE_T in this case.\n- * #define USE_LOCALE to use the current locale's decimal_point value.\n- */\n-\n-#ifndef GDTOAIMP_H_INCLUDED\n-#define GDTOAIMP_H_INCLUDED\n-#include \"gdtoa.h\"\n-#include \"gd_qnan.h\"\n-#ifdef Honor_FLT_ROUNDS\n-#include <fenv.h>\n-#endif\n-\n-#ifdef DEBUG\n-#include \"stdio.h\"\n-#define Bug(x) {fprintf(stderr, \"%s\\n\", x); exit(1);}\n-#endif\n-\n-#include \"stdlib.h\"\n-#include \"string.h\"\n-\n-#ifdef KR_headers\n-#define Char char\n-#else\n-#define Char void\n-#endif\n-\n-#ifdef MALLOC\n-extern Char *MALLOC ANSI((size_t));\n-#else\n-#define MALLOC malloc\n-#endif\n-\n-#undef IEEE_Arith\n-#undef Avoid_Underflow\n-#ifdef IEEE_MC68k\n-#define IEEE_Arith\n-#endif\n-#ifdef IEEE_8087\n-#define IEEE_Arith\n-#endif\n-\n-#include \"errno.h\"\n-#ifdef Bad_float_h\n-\n-#ifdef IEEE_Arith\n-#define DBL_DIG 15\n-#define DBL_MAX_10_EXP 308\n-#define DBL_MAX_EXP 1024\n-#define FLT_RADIX 2\n-#define DBL_MAX 1.7976931348623157e+308\n-#endif\n-\n-#ifdef IBM\n-#define DBL_DIG 16\n-#define DBL_MAX_10_EXP 75\n-#define DBL_MAX_EXP 63\n-#define FLT_RADIX 16\n-#define DBL_MAX 7.2370055773322621e+75\n-#endif\n-\n-#ifdef VAX\n-#define DBL_DIG 16\n-#define DBL_MAX_10_EXP 38\n-#define DBL_MAX_EXP 127\n-#define FLT_RADIX 2\n-#define DBL_MAX 1.7014118346046923e+38\n-#define n_bigtens 2\n-#endif\n-\n-#ifndef LONG_MAX\n-#define LONG_MAX 2147483647\n-#endif\n-\n-#else /* ifndef Bad_float_h */\n-#include \"float.h\"\n-#endif /* Bad_float_h */\n-\n-#ifdef IEEE_Arith\n-#define Scale_Bit 0x10\n-#define n_bigtens 5\n-#endif\n-\n-#ifdef IBM\n-#define n_bigtens 3\n-#endif\n-\n-#ifdef VAX\n-#define n_bigtens 2\n-#endif\n-\n-#ifndef __MATH_H__\n-#include \"math.h\"\n-#endif\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-#if defined(IEEE_8087) + defined(IEEE_MC68k) + defined(VAX) + defined(IBM) != 1\n-Exactly one of IEEE_8087, IEEE_MC68k, VAX, or IBM should be defined.\n-#endif\n-\n-typedef union { double d; ULong L[2]; } U;\n-\n-#ifdef IEEE_8087\n-#define word0(x) (x)->L[1]\n-#define word1(x) (x)->L[0]\n-#else\n-#define word0(x) (x)->L[0]\n-#define word1(x) (x)->L[1]\n-#endif\n-#define dval(x) (x)->d\n-\n-/* The following definition of Storeinc is appropriate for MIPS processors.\n- * An alternative that might be better on some machines is\n- * #define Storeinc(a,b,c) (*a++ = b << 16 | c & 0xffff)\n- */\n-#if defined(IEEE_8087) + defined(VAX)\n-#define Storeinc(a,b,c) (((unsigned short *)a)[1] = (unsigned short)b, \\\n-((unsigned short *)a)[0] = (unsigned short)c, a++)\n-#else\n-#define Storeinc(a,b,c) (((unsigned short *)a)[0] = (unsigned short)b, \\\n-((unsigned short *)a)[1] = (unsigned short)c, a++)\n-#endif\n-\n-/* #define P DBL_MANT_DIG */\n-/* Ten_pmax = floor(P*log(2)/log(5)) */\n-/* Bletch = (highest power of 2 < DBL_MAX_10_EXP) / 16 */\n-/* Quick_max = floor((P-1)*log(FLT_RADIX)/log(10) - 1) */\n-/* Int_max = floor(P*log(FLT_RADIX)/log(10) - 1) */\n-\n-#ifdef IEEE_Arith\n-#define Exp_shift  20\n-#define Exp_shift1 20\n-#define Exp_msk1    0x100000\n-#define Exp_msk11   0x100000\n-#define Exp_mask  0x7ff00000\n-#define P 53\n-#define Bias 1023\n-#define Emin (-1022)\n-#define Exp_1  0x3ff00000\n-#define Exp_11 0x3ff00000\n-#define Ebits 11\n-#define Frac_mask  0xfffff\n-#define Frac_mask1 0xfffff\n-#define Ten_pmax 22\n-#define Bletch 0x10\n-#define Bndry_mask  0xfffff\n-#define Bndry_mask1 0xfffff\n-#define LSB 1\n-#define Sign_bit 0x80000000\n-#define Log2P 1\n-#define Tiny0 0\n-#define Tiny1 1\n-#define Quick_max 14\n-#define Int_max 14\n-\n-#ifndef Flt_Rounds\n-#ifdef FLT_ROUNDS\n-#define Flt_Rounds FLT_ROUNDS\n-#else\n-#define Flt_Rounds 1\n-#endif\n-#endif /*Flt_Rounds*/\n-\n-#else /* ifndef IEEE_Arith */\n-#undef  Sudden_Underflow\n-#define Sudden_Underflow\n-#ifdef IBM\n-#undef Flt_Rounds\n-#define Flt_Rounds 0\n-#define Exp_shift  24\n-#define Exp_shift1 24\n-#define Exp_msk1   0x1000000\n-#define Exp_msk11  0x1000000\n-#define Exp_mask  0x7f000000\n-#define P 14\n-#define Bias 65\n-#define Exp_1  0x41000000\n-#define Exp_11 0x41000000\n-#define Ebits 8\t/* exponent has 7 bits, but 8 is the right value in b2d */\n-#define Frac_mask  0xffffff\n-#define Frac_mask1 0xffffff\n-#define Bletch 4\n-#define Ten_pmax 22\n-#define Bndry_mask  0xefffff\n-#define Bndry_mask1 0xffffff\n-#define LSB 1\n-#define Sign_bit 0x80000000\n-#define Log2P 4\n-#define Tiny0 0x100000\n-#define Tiny1 0\n-#define Quick_max 14\n-#define Int_max 15\n-#else /* VAX */\n-#undef Flt_Rounds\n-#define Flt_Rounds 1\n-#define Exp_shift  23\n-#define Exp_shift1 7\n-#define Exp_msk1    0x80\n-#define Exp_msk11   0x800000\n-#define Exp_mask  0x7f80\n-#define P 56\n-#define Bias 129\n-#define Exp_1  0x40800000\n-#define Exp_11 0x4080\n-#define Ebits 8\n-#define Frac_mask  0x7fffff\n-#define Frac_mask1 0xffff007f\n-#define Ten_pmax 24\n-#define Bletch 2\n-#define Bndry_mask  0xffff007f\n-#define Bndry_mask1 0xffff007f\n-#define LSB 0x10000\n-#define Sign_bit 0x8000\n-#define Log2P 1\n-#define Tiny0 0x80\n-#define Tiny1 0\n-#define Quick_max 15\n-#define Int_max 15\n-#endif /* IBM, VAX */\n-#endif /* IEEE_Arith */\n-\n-#ifndef IEEE_Arith\n-#define ROUND_BIASED\n-#endif\n-\n-#ifdef RND_PRODQUOT\n-#define rounded_product(a,b) a = rnd_prod(a, b)\n-#define rounded_quotient(a,b) a = rnd_quot(a, b)\n-#ifdef KR_headers\n-extern double rnd_prod(), rnd_quot();\n-#else\n-extern double rnd_prod(double, double), rnd_quot(double, double);\n-#endif\n-#else\n-#define rounded_product(a,b) a *= b\n-#define rounded_quotient(a,b) a /= b\n-#endif\n-\n-#define Big0 (Frac_mask1 | Exp_msk1*(DBL_MAX_EXP+Bias-1))\n-#define Big1 0xffffffff\n-\n-#undef  Pack_16\n-#ifndef Pack_32\n-#define Pack_32\n-#endif\n-\n-#ifdef NO_LONG_LONG\n-#undef ULLong\n-#ifdef Just_16\n-#undef Pack_32\n-#define Pack_16\n-/* When Pack_32 is not defined, we store 16 bits per 32-bit Long.\n- * This makes some inner loops simpler and sometimes saves work\n- * during multiplications, but it often seems to make things slightly\n- * slower.  Hence the default is now to store 32 bits per Long.\n- */\n-#endif\n-#else\t/* long long available */\n-#ifndef Llong\n-#define Llong long long\n-#endif\n-#ifndef ULLong\n-#define ULLong unsigned Llong\n-#endif\n-#endif /* NO_LONG_LONG */\n-\n-#ifdef Pack_32\n-#define ULbits 32\n-#define kshift 5\n-#define kmask 31\n-#define ALL_ON 0xffffffff\n-#else\n-#define ULbits 16\n-#define kshift 4\n-#define kmask 15\n-#define ALL_ON 0xffff\n-#endif\n-\n-#ifndef MULTIPLE_THREADS\n-#define ACQUIRE_DTOA_LOCK(n)\t/*nothing*/\n-#define FREE_DTOA_LOCK(n)\t/*nothing*/\n-#endif\n-\n-#define Kmax 9\n-\n- struct\n-Bigint {\n-\tstruct Bigint *next;\n-\tint k, maxwds, sign, wds;\n-\tULong x[1];\n-\t};\n-\n- typedef struct Bigint Bigint;\n-\n-#ifdef NO_STRING_H\n-#ifdef DECLARE_SIZE_T\n-typedef unsigned int size_t;\n-#endif\n-extern void memcpy_D2A ANSI((void*, const void*, size_t));\n-#define Bcopy(x,y) memcpy_D2A(&x->sign,&y->sign,y->wds*sizeof(ULong) + 2*sizeof(int))\n-#else /* !NO_STRING_H */\n-#define Bcopy(x,y) memcpy(&x->sign,&y->sign,y->wds*sizeof(ULong) + 2*sizeof(int))\n-#endif /* NO_STRING_H */\n-\n-#define Balloc __quadmath_Balloc_D2A\n-#define Bfree __quadmath_Bfree_D2A\n-#define ULtoQ __quadmath_ULtoQ_D2A\n-#define ULtof __quadmath_ULtof_D2A\n-#define ULtod __quadmath_ULtod_D2A\n-#define ULtodd __quadmath_ULtodd_D2A\n-#define ULtox __quadmath_ULtox_D2A\n-#define ULtoxL __quadmath_ULtoxL_D2A\n-#define any_on __quadmath_any_on_D2A\n-#define b2d __quadmath_b2d_D2A\n-#define bigtens __quadmath_bigtens_D2A\n-#define cmp __quadmath_cmp_D2A\n-#define copybits __quadmath_copybits_D2A\n-#define d2b __quadmath_d2b_D2A\n-#define decrement __quadmath_decrement_D2A\n-#define diff __quadmath_diff_D2A\n-#define dtoa_result __quadmath_dtoa_result_D2A\n-#define g__fmt __quadmath_g__fmt_D2A\n-#define gethex __quadmath_gethex_D2A\n-#define hexdig __quadmath_hexdig_D2A\n-#define hexnan __quadmath_hexnan_D2A\n-#define hi0bits_D2A __quadmath_hi0bits_D2A\n-#define hi0bits(x) __quadmath_hi0bits_D2A((ULong)(x))\n-#define i2b __quadmath_i2b_D2A\n-#define increment __quadmath_increment_D2A\n-#define lo0bits __quadmath_lo0bits_D2A\n-#define lshift __quadmath_lshift_D2A\n-#define match __quadmath_match_D2A\n-#define mult __quadmath_mult_D2A\n-#define multadd __quadmath_multadd_D2A\n-#define nrv_alloc __quadmath_nrv_alloc_D2A\n-#define pow5mult __quadmath_pow5mult_D2A\n-#define quorem __quadmath_quorem_D2A\n-#define ratio __quadmath_ratio_D2A\n-#define rshift __quadmath_rshift_D2A\n-#define rv_alloc __quadmath_rv_alloc_D2A\n-#define s2b __quadmath_s2b_D2A\n-#define set_ones __quadmath_set_ones_D2A\n-#ifdef NO_STRING_H\n-#define strcp __quadmath_strcp_D2A\n-#endif\n-#define strtoIg __quadmath_strtoIg_D2A\n-#define sum __quadmath_sum_D2A\n-#define tens __quadmath_tens_D2A\n-#define tinytens __quadmath_tinytens_D2A\n-#define tinytens __quadmath_tinytens_D2A\n-#define trailz __quadmath_trailz_D2A\n-#define ulp __quadmath_ulp_D2A\n-\n- extern char *dtoa_result;\n- extern CONST double bigtens[], tens[], tinytens[];\n- extern unsigned char hexdig[];\n-\n- extern Bigint *Balloc ANSI((int));\n- extern void Bfree ANSI((Bigint*));\n- extern void ULtof ANSI((ULong*, ULong*, Long, int));\n- extern void ULtod ANSI((ULong*, ULong*, Long, int));\n- extern void ULtodd ANSI((ULong*, ULong*, Long, int));\n- extern void ULtoQ ANSI((ULong*, ULong*, Long, int));\n- extern void ULtox ANSI((UShort*, ULong*, Long, int));\n- extern void ULtoxL ANSI((ULong*, ULong*, Long, int));\n- extern ULong any_on ANSI((Bigint*, int));\n- extern double b2d ANSI((Bigint*, int*));\n- extern int cmp ANSI((Bigint*, Bigint*));\n- extern void copybits ANSI((ULong*, int, Bigint*));\n- extern Bigint *d2b ANSI((double, int*, int*));\n- extern void decrement ANSI((Bigint*));\n- extern Bigint *diff ANSI((Bigint*, Bigint*));\n- extern char *dtoa ANSI((double d, int mode, int ndigits,\n-\t\t\tint *decpt, int *sign, char **rve));\n- extern char *g__fmt ANSI((char*, char*, char*, int, ULong, size_t));\n- extern int gethex ANSI((CONST char**, FPI*, Long*, Bigint**, int));\n- extern void hexdig_init_D2A(Void);\n- extern int hexnan ANSI((CONST char**, FPI*, ULong*));\n- extern int hi0bits_D2A ANSI((ULong));\n- extern Bigint *i2b ANSI((int));\n- extern Bigint *increment ANSI((Bigint*));\n- extern int lo0bits ANSI((ULong*));\n- extern Bigint *lshift ANSI((Bigint*, int));\n- extern int match ANSI((CONST char**, char*));\n- extern Bigint *mult ANSI((Bigint*, Bigint*));\n- extern Bigint *multadd ANSI((Bigint*, int, int));\n- extern char *nrv_alloc ANSI((char*, char **, int));\n- extern Bigint *pow5mult ANSI((Bigint*, int));\n- extern int quorem ANSI((Bigint*, Bigint*));\n- extern double ratio ANSI((Bigint*, Bigint*));\n- extern void rshift ANSI((Bigint*, int));\n- extern char *rv_alloc ANSI((int));\n- extern Bigint *s2b ANSI((CONST char*, int, int, ULong, int));\n- extern Bigint *set_ones ANSI((Bigint*, int));\n-#ifdef NO_STRING_H\n- extern char *strcpy ANSI((char*, const char*));\n-#endif\n- extern int strtoIg ANSI((CONST char*, char**, FPI*, Long*, Bigint**, int*));\n- extern Bigint *sum ANSI((Bigint*, Bigint*));\n- extern int trailz ANSI((Bigint*));\n- extern double ulp ANSI((U*));\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-/*\n- * NAN_WORD0 and NAN_WORD1 are only referenced in strtod.c.  Prior to\n- * 20050115, they used to be hard-wired here (to 0x7ff80000 and 0,\n- * respectively), but now are determined by compiling and running\n- * qnan.c to generate gd_qnan.h, which specifies d_QNAN0 and d_QNAN1.\n- * Formerly gdtoaimp.h recommended supplying suitable -DNAN_WORD0=...\n- * and -DNAN_WORD1=...  values if necessary.  This should still work.\n- * (On HP Series 700/800 machines, -DNAN_WORD0=0x7ff40000 works.)\n- */\n-#ifdef IEEE_Arith\n-#ifndef NO_INFNAN_CHECK\n-#undef INFNAN_CHECK\n-#define INFNAN_CHECK\n-#endif\n-#ifdef IEEE_MC68k\n-#define _0 0\n-#define _1 1\n-#ifndef NAN_WORD0\n-#define NAN_WORD0 d_QNAN0\n-#endif\n-#ifndef NAN_WORD1\n-#define NAN_WORD1 d_QNAN1\n-#endif\n-#else\n-#define _0 1\n-#define _1 0\n-#ifndef NAN_WORD0\n-#define NAN_WORD0 d_QNAN1\n-#endif\n-#ifndef NAN_WORD1\n-#define NAN_WORD1 d_QNAN0\n-#endif\n-#endif\n-#else\n-#undef INFNAN_CHECK\n-#endif\n-\n-#undef SI\n-#ifdef Sudden_Underflow\n-#define SI 1\n-#else\n-#define SI 0\n-#endif\n-\n-#endif /* GDTOAIMP_H_INCLUDED */"}, {"sha": "a9982c9d33a76095a8281498749ba20072f5fab2", "filename": "libquadmath/gdtoa/gethex.c", "status": "removed", "additions": 0, "deletions": 350, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fgethex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fgethex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fgethex.c?ref=fa381cb2a157ab74bf8117938f3da5ba51095c2a", "patch": "@@ -1,350 +0,0 @@\n-/****************************************************************\n-\n-The author of this software is David M. Gay.\n-\n-Copyright (C) 1998 by Lucent Technologies\n-All Rights Reserved\n-\n-Permission to use, copy, modify, and distribute this software and\n-its documentation for any purpose and without fee is hereby\n-granted, provided that the above copyright notice appear in all\n-copies and that both that the copyright notice and this\n-permission notice and warranty disclaimer appear in supporting\n-documentation, and that the name of Lucent or any of its entities\n-not be used in advertising or publicity pertaining to\n-distribution of the software without specific, written prior\n-permission.\n-\n-LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n-INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n-IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n-SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n-IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n-THIS SOFTWARE.\n-\n-****************************************************************/\n-\n-/* Please send bug reports to David M. Gay (dmg at acm dot org,\n- * with \" at \" changed at \"@\" and \" dot \" changed to \".\").\t*/\n-\n-#include \"gdtoaimp.h\"\n-\n-#ifdef USE_LOCALE\n-#include \"locale.h\"\n-#endif\n-\n- int\n-#ifdef KR_headers\n-gethex(sp, fpi, exp, bp, sign)\n-\tCONST char **sp; FPI *fpi; Long *exp; Bigint **bp; int sign;\n-#else\n-gethex( CONST char **sp, FPI *fpi, Long *exp, Bigint **bp, int sign)\n-#endif\n-{\n-\tBigint *b;\n-\tCONST unsigned char *decpt, *s0, *s, *s1;\n-\tint big, esign, havedig, irv, j, k, n, n0, nbits, up, zret;\n-\tULong L, lostbits, *x;\n-\tLong e, e1;\n-#ifdef USE_LOCALE\n-\tint i;\n-#ifdef NO_LOCALE_CACHE\n-\tconst unsigned char *decimalpoint = (unsigned char*)localeconv()->decimal_point;\n-#else\n-\tconst unsigned char *decimalpoint;\n-\tstatic unsigned char *decimalpoint_cache;\n-\tif (!(s0 = decimalpoint_cache)) {\n-\t\ts0 = (unsigned char*)localeconv()->decimal_point;\n-\t\tif ((decimalpoint_cache = (char*)MALLOC(strlen(s0) + 1))) {\n-\t\t\tstrcpy(decimalpoint_cache, s0);\n-\t\t\ts0 = decimalpoint_cache;\n-\t\t\t}\n-\t\t}\n-\tdecimalpoint = s0;\n-#endif\n-#endif\n-\n-\tif (!hexdig['0'])\n-\t\thexdig_init_D2A();\n-\t*bp = 0;\n-\thavedig = 0;\n-\ts0 = *(CONST unsigned char **)sp + 2;\n-\twhile(s0[havedig] == '0')\n-\t\thavedig++;\n-\ts0 += havedig;\n-\ts = s0;\n-\tdecpt = 0;\n-\tzret = 0;\n-\te = 0;\n-\tif (hexdig[*s])\n-\t\thavedig++;\n-\telse {\n-\t\tzret = 1;\n-#ifdef USE_LOCALE\n-\t\tfor(i = 0; decimalpoint[i]; ++i) {\n-\t\t\tif (s[i] != decimalpoint[i])\n-\t\t\t\tgoto pcheck;\n-\t\t\t}\n-\t\tdecpt = s += i;\n-#else\n-\t\tif (*s != '.')\n-\t\t\tgoto pcheck;\n-\t\tdecpt = ++s;\n-#endif\n-\t\tif (!hexdig[*s])\n-\t\t\tgoto pcheck;\n-\t\twhile(*s == '0')\n-\t\t\ts++;\n-\t\tif (hexdig[*s])\n-\t\t\tzret = 0;\n-\t\thavedig = 1;\n-\t\ts0 = s;\n-\t\t}\n-\twhile(hexdig[*s])\n-\t\ts++;\n-#ifdef USE_LOCALE\n-\tif (*s == *decimalpoint && !decpt) {\n-\t\tfor(i = 1; decimalpoint[i]; ++i) {\n-\t\t\tif (s[i] != decimalpoint[i])\n-\t\t\t\tgoto pcheck;\n-\t\t\t}\n-\t\tdecpt = s += i;\n-#else\n-\tif (*s == '.' && !decpt) {\n-\t\tdecpt = ++s;\n-#endif\n-\t\twhile(hexdig[*s])\n-\t\t\ts++;\n-\t\t}/*}*/\n-\tif (decpt)\n-\t\te = -(((Long)(s-decpt)) << 2);\n- pcheck:\n-\ts1 = s;\n-\tbig = esign = 0;\n-\tswitch(*s) {\n-\t  case 'p':\n-\t  case 'P':\n-\t\tswitch(*++s) {\n-\t\t  case '-':\n-\t\t\tesign = 1;\n-\t\t\t/* no break */\n-\t\t  case '+':\n-\t\t\ts++;\n-\t\t  }\n-\t\tif ((n = hexdig[*s]) == 0 || n > 0x19) {\n-\t\t\ts = s1;\n-\t\t\tbreak;\n-\t\t\t}\n-\t\te1 = n - 0x10;\n-\t\twhile((n = hexdig[*++s]) !=0 && n <= 0x19) {\n-\t\t\tif (e1 & 0xf8000000)\n-\t\t\t\tbig = 1;\n-\t\t\te1 = 10*e1 + n - 0x10;\n-\t\t\t}\n-\t\tif (esign)\n-\t\t\te1 = -e1;\n-\t\te += e1;\n-\t  }\n-\t*sp = (char*)s;\n-\tif (!havedig)\n-\t\t*sp = (char*)s0 - 1;\n-\tif (zret)\n-\t\treturn STRTOG_Zero;\n-\tif (big) {\n-\t\tif (esign) {\n-\t\t\tswitch(fpi->rounding) {\n-\t\t\t  case FPI_Round_up:\n-\t\t\t\tif (sign)\n-\t\t\t\t\tbreak;\n-\t\t\t\tgoto ret_tiny;\n-\t\t\t  case FPI_Round_down:\n-\t\t\t\tif (!sign)\n-\t\t\t\t\tbreak;\n-\t\t\t\tgoto ret_tiny;\n-\t\t\t  }\n-\t\t\tgoto retz;\n- ret_tiny:\n-\t\t\tb = Balloc(0);\n-\t\t\tb->wds = 1;\n-\t\t\tb->x[0] = 1;\n-\t\t\tgoto dret;\n-\t\t\t}\n-\t\tswitch(fpi->rounding) {\n-\t\t  case FPI_Round_near:\n-\t\t\tgoto ovfl1;\n-\t\t  case FPI_Round_up:\n-\t\t\tif (!sign)\n-\t\t\t\tgoto ovfl1;\n-\t\t\tgoto ret_big;\n-\t\t  case FPI_Round_down:\n-\t\t\tif (sign)\n-\t\t\t\tgoto ovfl1;\n-\t\t\tgoto ret_big;\n-\t\t  }\n- ret_big:\n-\t\tnbits = fpi->nbits;\n-\t\tn0 = n = nbits >> kshift;\n-\t\tif (nbits & kmask)\n-\t\t\t++n;\n-\t\tfor(j = n, k = 0; j >>= 1; ++k);\n-\t\t*bp = b = Balloc(k);\n-\t\tb->wds = n;\n-\t\tfor(j = 0; j < n0; ++j)\n-\t\t\tb->x[j] = ALL_ON;\n-\t\tif (n > n0)\n-\t\t\tb->x[j] = ULbits >> (ULbits - (nbits & kmask));\n-\t\t*exp = fpi->emin;\n-\t\treturn STRTOG_Normal | STRTOG_Inexlo;\n-\t\t}\n-\tn = s1 - s0 - 1;\n-\tfor(k = 0; n > (1 << (kshift-2)) - 1; n >>= 1)\n-\t\tk++;\n-\tb = Balloc(k);\n-\tx = b->x;\n-\tn = 0;\n-\tL = 0;\n-#ifdef USE_LOCALE\n-\tfor(i = 0; decimalpoint[i+1]; ++i);\n-#endif\n-\twhile(s1 > s0) {\n-#ifdef USE_LOCALE\n-\t\tif (*--s1 == decimalpoint[i]) {\n-\t\t\ts1 -= i;\n-\t\t\tcontinue;\n-\t\t\t}\n-#else\n-\t\tif (*--s1 == '.')\n-\t\t\tcontinue;\n-#endif\n-\t\tif (n == ULbits) {\n-\t\t\t*x++ = L;\n-\t\t\tL = 0;\n-\t\t\tn = 0;\n-\t\t\t}\n-\t\tL |= (hexdig[*s1] & 0x0f) << n;\n-\t\tn += 4;\n-\t\t}\n-\t*x++ = L;\n-\tb->wds = n = x - b->x;\n-\tn = ULbits*n - hi0bits(L);\n-\tnbits = fpi->nbits;\n-\tlostbits = 0;\n-\tx = b->x;\n-\tif (n > nbits) {\n-\t\tn -= nbits;\n-\t\tif (any_on(b,n)) {\n-\t\t\tlostbits = 1;\n-\t\t\tk = n - 1;\n-\t\t\tif (x[k>>kshift] & 1 << (k & kmask)) {\n-\t\t\t\tlostbits = 2;\n-\t\t\t\tif (k > 0 && any_on(b,k))\n-\t\t\t\t\tlostbits = 3;\n-\t\t\t\t}\n-\t\t\t}\n-\t\trshift(b, n);\n-\t\te += n;\n-\t\t}\n-\telse if (n < nbits) {\n-\t\tn = nbits - n;\n-\t\tb = lshift(b, n);\n-\t\te -= n;\n-\t\tx = b->x;\n-\t\t}\n-\tif (e > fpi->emax) {\n- ovfl:\n-\t\tBfree(b);\n- ovfl1:\n-#ifndef NO_ERRNO\n-\t\terrno = ERANGE;\n-#endif\n-\t\treturn STRTOG_Infinite | STRTOG_Overflow | STRTOG_Inexhi;\n-\t\t}\n-\tirv = STRTOG_Normal;\n-\tif (e < fpi->emin) {\n-\t\tirv = STRTOG_Denormal;\n-\t\tn = fpi->emin - e;\n-\t\tif (n >= nbits) {\n-\t\t\tswitch (fpi->rounding) {\n-\t\t\t  case FPI_Round_near:\n-\t\t\t\tif (n == nbits && (n < 2 || any_on(b,n-1)))\n-\t\t\t\t\tgoto one_bit;\n-\t\t\t\tbreak;\n-\t\t\t  case FPI_Round_up:\n-\t\t\t\tif (!sign)\n-\t\t\t\t\tgoto one_bit;\n-\t\t\t\tbreak;\n-\t\t\t  case FPI_Round_down:\n-\t\t\t\tif (sign) {\n- one_bit:\n-\t\t\t\t\tx[0] = b->wds = 1;\n- dret:\n-\t\t\t\t\t*bp = b;\n-\t\t\t\t\t*exp = fpi->emin;\n-#ifndef NO_ERRNO\n-\t\t\t\t\terrno = ERANGE;\n-#endif\n-\t\t\t\t\treturn STRTOG_Denormal | STRTOG_Inexhi\n-\t\t\t\t\t\t| STRTOG_Underflow;\n-\t\t\t\t\t}\n-\t\t\t  }\n-\t\t\tBfree(b);\n- retz:\n-#ifndef NO_ERRNO\n-\t\t\terrno = ERANGE;\n-#endif\n-\t\t\treturn STRTOG_Zero | STRTOG_Inexlo | STRTOG_Underflow;\n-\t\t\t}\n-\t\tk = n - 1;\n-\t\tif (lostbits)\n-\t\t\tlostbits = 1;\n-\t\telse if (k > 0)\n-\t\t\tlostbits = any_on(b,k);\n-\t\tif (x[k>>kshift] & 1 << (k & kmask))\n-\t\t\tlostbits |= 2;\n-\t\tnbits -= n;\n-\t\trshift(b,n);\n-\t\te = fpi->emin;\n-\t\t}\n-\tif (lostbits) {\n-\t\tup = 0;\n-\t\tswitch(fpi->rounding) {\n-\t\t  case FPI_Round_zero:\n-\t\t\tbreak;\n-\t\t  case FPI_Round_near:\n-\t\t\tif (lostbits & 2\n-\t\t\t && (lostbits | x[0]) & 1)\n-\t\t\t\tup = 1;\n-\t\t\tbreak;\n-\t\t  case FPI_Round_up:\n-\t\t\tup = 1 - sign;\n-\t\t\tbreak;\n-\t\t  case FPI_Round_down:\n-\t\t\tup = sign;\n-\t\t  }\n-\t\tif (up) {\n-\t\t\tk = b->wds;\n-\t\t\tb = increment(b);\n-\t\t\tx = b->x;\n-\t\t\tif (irv == STRTOG_Denormal) {\n-\t\t\t\tif (nbits == fpi->nbits - 1\n-\t\t\t\t && x[nbits >> kshift] & 1 << (nbits & kmask))\n-\t\t\t\t\tirv =  STRTOG_Normal;\n-\t\t\t\t}\n-\t\t\telse if (b->wds > k\n-\t\t\t || ((n = nbits & kmask) !=0\n-\t\t\t      && hi0bits(x[k-1]) < 32-n)) {\n-\t\t\t\trshift(b,1);\n-\t\t\t\tif (++e > fpi->emax)\n-\t\t\t\t\tgoto ovfl;\n-\t\t\t\t}\n-\t\t\tirv |= STRTOG_Inexhi;\n-\t\t\t}\n-\t\telse\n-\t\t\tirv |= STRTOG_Inexlo;\n-\t\t}\n-\t*bp = b;\n-\t*exp = e;\n-\treturn irv;\n-\t}"}, {"sha": "8270ef944797b8a707a33160a6207b2f3baa15be", "filename": "libquadmath/gdtoa/gmisc.c", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fgmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fgmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fgmisc.c?ref=fa381cb2a157ab74bf8117938f3da5ba51095c2a", "patch": "@@ -1,86 +0,0 @@\n-/****************************************************************\n-\n-The author of this software is David M. Gay.\n-\n-Copyright (C) 1998 by Lucent Technologies\n-All Rights Reserved\n-\n-Permission to use, copy, modify, and distribute this software and\n-its documentation for any purpose and without fee is hereby\n-granted, provided that the above copyright notice appear in all\n-copies and that both that the copyright notice and this\n-permission notice and warranty disclaimer appear in supporting\n-documentation, and that the name of Lucent or any of its entities\n-not be used in advertising or publicity pertaining to\n-distribution of the software without specific, written prior\n-permission.\n-\n-LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n-INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n-IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n-SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n-IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n-THIS SOFTWARE.\n-\n-****************************************************************/\n-\n-/* Please send bug reports to David M. Gay (dmg at acm dot org,\n- * with \" at \" changed at \"@\" and \" dot \" changed to \".\").\t*/\n-\n-#include \"gdtoaimp.h\"\n-\n- void\n-#ifdef KR_headers\n-rshift(b, k) Bigint *b; int k;\n-#else\n-rshift(Bigint *b, int k)\n-#endif\n-{\n-\tULong *x, *x1, *xe, y;\n-\tint n;\n-\n-\tx = x1 = b->x;\n-\tn = k >> kshift;\n-\tif (n < b->wds) {\n-\t\txe = x + b->wds;\n-\t\tx += n;\n-\t\tif (k &= kmask) {\n-\t\t\tn = ULbits - k;\n-\t\t\ty = *x++ >> k;\n-\t\t\twhile(x < xe) {\n-\t\t\t\t*x1++ = (y | (*x << n)) & ALL_ON;\n-\t\t\t\ty = *x++ >> k;\n-\t\t\t\t}\n-\t\t\tif ((*x1 = y) !=0)\n-\t\t\t\tx1++;\n-\t\t\t}\n-\t\telse\n-\t\t\twhile(x < xe)\n-\t\t\t\t*x1++ = *x++;\n-\t\t}\n-\tif ((b->wds = x1 - b->x) == 0)\n-\t\tb->x[0] = 0;\n-\t}\n-\n- int\n-#ifdef KR_headers\n-trailz(b) Bigint *b;\n-#else\n-trailz(Bigint *b)\n-#endif\n-{\n-\tULong L, *x, *xe;\n-\tint n = 0;\n-\n-\tx = b->x;\n-\txe = x + b->wds;\n-\tfor(n = 0; x < xe && !*x; x++)\n-\t\tn += ULbits;\n-\tif (x < xe) {\n-\t\tL = *x;\n-\t\tn += lo0bits(&L);\n-\t\t}\n-\treturn n;\n-\t}"}, {"sha": "fa6e18dee8f4cff8f350629ce1fd4ec38ba1a676", "filename": "libquadmath/gdtoa/hd_init.c", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fhd_init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fhd_init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fhd_init.c?ref=fa381cb2a157ab74bf8117938f3da5ba51095c2a", "patch": "@@ -1,55 +0,0 @@\n-/****************************************************************\n-\n-The author of this software is David M. Gay.\n-\n-Copyright (C) 2000 by Lucent Technologies\n-All Rights Reserved\n-\n-Permission to use, copy, modify, and distribute this software and\n-its documentation for any purpose and without fee is hereby\n-granted, provided that the above copyright notice appear in all\n-copies and that both that the copyright notice and this\n-permission notice and warranty disclaimer appear in supporting\n-documentation, and that the name of Lucent or any of its entities\n-not be used in advertising or publicity pertaining to\n-distribution of the software without specific, written prior\n-permission.\n-\n-LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n-INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n-IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n-SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n-IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n-THIS SOFTWARE.\n-\n-****************************************************************/\n-\n-/* Please send bug reports to David M. Gay (dmg at acm dot org,\n- * with \" at \" changed at \"@\" and \" dot \" changed to \".\").\t*/\n-\n-#include \"gdtoaimp.h\"\n-\n- unsigned char hexdig[256];\n-\n- static void\n-#ifdef KR_headers\n-htinit(h, s, inc) unsigned char *h; unsigned char *s; int inc;\n-#else\n-htinit(unsigned char *h, unsigned char *s, int inc)\n-#endif\n-{\n-\tint i, j;\n-\tfor(i = 0; (j = s[i]) !=0; i++)\n-\t\th[j] = i + inc;\n-\t}\n-\n- void\n-hexdig_init_D2A(Void)\n-{\n-#define USC (unsigned char *)\n-\thtinit(hexdig, USC \"0123456789\", 0x10);\n-\thtinit(hexdig, USC \"abcdef\", 0x10 + 10);\n-\thtinit(hexdig, USC \"ABCDEF\", 0x10 + 10);\n-\t}"}, {"sha": "a443721f52dd17319893bb83af20d654a3ee2d76", "filename": "libquadmath/gdtoa/hexnan.c", "status": "removed", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fhexnan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fhexnan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fhexnan.c?ref=fa381cb2a157ab74bf8117938f3da5ba51095c2a", "patch": "@@ -1,150 +0,0 @@\n-/****************************************************************\n-\n-The author of this software is David M. Gay.\n-\n-Copyright (C) 2000 by Lucent Technologies\n-All Rights Reserved\n-\n-Permission to use, copy, modify, and distribute this software and\n-its documentation for any purpose and without fee is hereby\n-granted, provided that the above copyright notice appear in all\n-copies and that both that the copyright notice and this\n-permission notice and warranty disclaimer appear in supporting\n-documentation, and that the name of Lucent or any of its entities\n-not be used in advertising or publicity pertaining to\n-distribution of the software without specific, written prior\n-permission.\n-\n-LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n-INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n-IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n-SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n-IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n-THIS SOFTWARE.\n-\n-****************************************************************/\n-\n-/* Please send bug reports to David M. Gay (dmg at acm dot org,\n- * with \" at \" changed at \"@\" and \" dot \" changed to \".\").\t*/\n-\n-#include \"gdtoaimp.h\"\n-\n- static void\n-#ifdef KR_headers\n-L_shift(x, x1, i) ULong *x; ULong *x1; int i;\n-#else\n-L_shift(ULong *x, ULong *x1, int i)\n-#endif\n-{\n-\tint j;\n-\n-\ti = 8 - i;\n-\ti <<= 2;\n-\tj = ULbits - i;\n-\tdo {\n-\t\t*x |= x[1] << j;\n-\t\tx[1] >>= i;\n-\t\t} while(++x < x1);\n-\t}\n-\n- int\n-#ifdef KR_headers\n-hexnan(sp, fpi, x0)\n-\tCONST char **sp; FPI *fpi; ULong *x0;\n-#else\n-hexnan( CONST char **sp, FPI *fpi, ULong *x0)\n-#endif\n-{\n-\tULong c, h, *x, *x1, *xe;\n-\tCONST char *s;\n-\tint havedig, hd0, i, nbits;\n-\n-\tif (!hexdig['0'])\n-\t\thexdig_init_D2A();\n-\tnbits = fpi->nbits;\n-\tx = x0 + (nbits >> kshift);\n-\tif (nbits & kmask)\n-\t\tx++;\n-\t*--x = 0;\n-\tx1 = xe = x;\n-\thavedig = hd0 = i = 0;\n-\ts = *sp;\n-\t/* allow optional initial 0x or 0X */\n-\twhile((c = *(CONST unsigned char*)(s+1)) && c <= ' ')\n-\t\t++s;\n-\tif (s[1] == '0' && (s[2] == 'x' || s[2] == 'X')\n-\t && *(CONST unsigned char*)(s+3) > ' ')\n-\t\ts += 2;\n-\twhile((c = *(CONST unsigned char*)++s)) {\n-\t\tif (!(h = hexdig[c])) {\n-\t\t\tif (c <= ' ') {\n-\t\t\t\tif (hd0 < havedig) {\n-\t\t\t\t\tif (x < x1 && i < 8)\n-\t\t\t\t\t\tL_shift(x, x1, i);\n-\t\t\t\t\tif (x <= x0) {\n-\t\t\t\t\t\ti = 8;\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t}\n-\t\t\t\t\thd0 = havedig;\n-\t\t\t\t\t*--x = 0;\n-\t\t\t\t\tx1 = x;\n-\t\t\t\t\ti = 0;\n-\t\t\t\t\t}\n-\t\t\t\twhile(*(CONST unsigned char*)(s+1) <= ' ')\n-\t\t\t\t\t++s;\n-\t\t\t\tif (s[1] == '0' && (s[2] == 'x' || s[2] == 'X')\n-\t\t\t\t && *(CONST unsigned char*)(s+3) > ' ')\n-\t\t\t\t\ts += 2;\n-\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\tif (/*(*/ c == ')' && havedig) {\n-\t\t\t\t*sp = s + 1;\n-\t\t\t\tbreak;\n-\t\t\t\t}\n-#ifndef GDTOA_NON_PEDANTIC_NANCHECK\n-\t\t\tdo {\n-\t\t\t\tif (/*(*/ c == ')') {\n-\t\t\t\t\t*sp = s + 1;\n-\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t} while((c = *++s));\n-#endif\n-\t\t\treturn STRTOG_NaN;\n-\t\t\t}\n-\t\thavedig++;\n-\t\tif (++i > 8) {\n-\t\t\tif (x <= x0)\n-\t\t\t\tcontinue;\n-\t\t\ti = 1;\n-\t\t\t*--x = 0;\n-\t\t\t}\n-\t\t*x = (*x << 4) | (h & 0xf);\n-\t\t}\n-\tif (!havedig)\n-\t\treturn STRTOG_NaN;\n-\tif (x < x1 && i < 8)\n-\t\tL_shift(x, x1, i);\n-\tif (x > x0) {\n-\t\tx1 = x0;\n-\t\tdo *x1++ = *x++;\n-\t\t\twhile(x <= xe);\n-\t\tdo *x1++ = 0;\n-\t\t\twhile(x1 <= xe);\n-\t\t}\n-\telse {\n-\t\t/* truncate high-order word if necessary */\n-\t\tif ( (i = nbits & (ULbits-1)) !=0)\n-\t\t\t*xe &= ((ULong)0xffffffff) >> (ULbits - i);\n-\t\t}\n-\tfor(x1 = xe;; --x1) {\n-\t\tif (*x1 != 0)\n-\t\t\tbreak;\n-\t\tif (x1 == x0) {\n-\t\t\t*x1 = 1;\n-\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\treturn STRTOG_NaNbits;\n-\t}"}, {"sha": "c9a61e9951f5b719a0cedb8da6c5f846a4103491", "filename": "libquadmath/gdtoa/makefile", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fmakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fmakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fmakefile?ref=fa381cb2a157ab74bf8117938f3da5ba51095c2a", "patch": "@@ -1,42 +0,0 @@\n-# /****************************************************************\n-# Copyright (C) 1998 by Lucent Technologies\n-# All Rights Reserved\n-#\n-# Permission to use, copy, modify, and distribute this software and\n-# its documentation for any purpose and without fee is hereby\n-# granted, provided that the above copyright notice appear in all\n-# copies and that both that the copyright notice and this\n-# permission notice and warranty disclaimer appear in supporting\n-# documentation, and that the name of Lucent or any of its entities\n-# not be used in advertising or publicity pertaining to\n-# distribution of the software without specific, written prior\n-# permission.\n-#\n-# LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n-# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n-# IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n-# SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n-# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n-# THIS SOFTWARE.\n-#\n-# ****************************************************************/\n-\n-.SUFFIXES: .c .o\n-CC = cc\n-CFLAGS = -g\n-\n-.c.o:\n-\t$(CC) -c $(CFLAGS) $*.c\n-\n-all: gdtoa.a\n-\n-gdtoa.a: dmisc.c g_Qfmt.c g__fmt.c gdtoa.c gethex.c gmisc.c hd_init.c\\\n-\t hexnan.c misc.c smisc.c strtopQ.c strtodg.c sum.c ulp.c\n-\t$(CC) -c $(CFLAGS) $?\n-\tx=`echo $? | sed 's/\\.c/.o/g'` && ar ruv gdtoa.a $$x && rm $$x\n-\tranlib gdtoa.a || true\n-\n-clean:\n-\trm -f *.[ao]"}, {"sha": "ed81c470fbaf88414e32257d5f6d1661d7bd36c8", "filename": "libquadmath/gdtoa/misc.c", "status": "removed", "additions": 0, "deletions": 875, "changes": 875, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fmisc.c?ref=fa381cb2a157ab74bf8117938f3da5ba51095c2a", "patch": "@@ -1,875 +0,0 @@\n-/****************************************************************\n-\n-The author of this software is David M. Gay.\n-\n-Copyright (C) 1998, 1999 by Lucent Technologies\n-All Rights Reserved\n-\n-Permission to use, copy, modify, and distribute this software and\n-its documentation for any purpose and without fee is hereby\n-granted, provided that the above copyright notice appear in all\n-copies and that both that the copyright notice and this\n-permission notice and warranty disclaimer appear in supporting\n-documentation, and that the name of Lucent or any of its entities\n-not be used in advertising or publicity pertaining to\n-distribution of the software without specific, written prior\n-permission.\n-\n-LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n-INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n-IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n-SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n-IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n-THIS SOFTWARE.\n-\n-****************************************************************/\n-\n-/* Please send bug reports to David M. Gay (dmg at acm dot org,\n- * with \" at \" changed at \"@\" and \" dot \" changed to \".\").\t*/\n-\n-#include \"gdtoaimp.h\"\n-\n- static Bigint *freelist[Kmax+1];\n-#ifndef Omit_Private_Memory\n-#ifndef PRIVATE_MEM\n-#define PRIVATE_MEM 2304\n-#endif\n-#define PRIVATE_mem ((PRIVATE_MEM+sizeof(double)-1)/sizeof(double))\n-static double private_mem[PRIVATE_mem], *pmem_next = private_mem;\n-#endif\n-\n- Bigint *\n-Balloc\n-#ifdef KR_headers\n-\t(k) int k;\n-#else\n-\t(int k)\n-#endif\n-{\n-\tint x;\n-\tBigint *rv;\n-#ifndef Omit_Private_Memory\n-\tunsigned int len;\n-#endif\n-\n-\tACQUIRE_DTOA_LOCK(0);\n-\t/* The k > Kmax case does not need ACQUIRE_DTOA_LOCK(0), */\n-\t/* but this case seems very unlikely. */\n-\tif (k <= Kmax && (rv = freelist[k]) !=0) {\n-\t\tfreelist[k] = rv->next;\n-\t\t}\n-\telse {\n-\t\tx = 1 << k;\n-#ifdef Omit_Private_Memory\n-\t\trv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));\n-#else\n-\t\tlen = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)\n-\t\t\t/sizeof(double);\n-\t\tif (k <= Kmax && pmem_next - private_mem + len <= PRIVATE_mem) {\n-\t\t\trv = (Bigint*)pmem_next;\n-\t\t\tpmem_next += len;\n-\t\t\t}\n-\t\telse\n-\t\t\trv = (Bigint*)MALLOC(len*sizeof(double));\n-#endif\n-\t\trv->k = k;\n-\t\trv->maxwds = x;\n-\t\t}\n-\tFREE_DTOA_LOCK(0);\n-\trv->sign = rv->wds = 0;\n-\treturn rv;\n-\t}\n-\n- void\n-Bfree\n-#ifdef KR_headers\n-\t(v) Bigint *v;\n-#else\n-\t(Bigint *v)\n-#endif\n-{\n-\tif (v) {\n-\t\tif (v->k > Kmax)\n-#ifdef FREE\n-\t\t\tFREE((void*)v);\n-#else\n-\t\t\tfree((void*)v);\n-#endif\n-\t\telse {\n-\t\t\tACQUIRE_DTOA_LOCK(0);\n-\t\t\tv->next = freelist[v->k];\n-\t\t\tfreelist[v->k] = v;\n-\t\t\tFREE_DTOA_LOCK(0);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n- int\n-lo0bits\n-#ifdef KR_headers\n-\t(y) ULong *y;\n-#else\n-\t(ULong *y)\n-#endif\n-{\n-\tint k;\n-\tULong x = *y;\n-\n-\tif (x & 7) {\n-\t\tif (x & 1)\n-\t\t\treturn 0;\n-\t\tif (x & 2) {\n-\t\t\t*y = x >> 1;\n-\t\t\treturn 1;\n-\t\t\t}\n-\t\t*y = x >> 2;\n-\t\treturn 2;\n-\t\t}\n-\tk = 0;\n-\tif (!(x & 0xffff)) {\n-\t\tk = 16;\n-\t\tx >>= 16;\n-\t\t}\n-\tif (!(x & 0xff)) {\n-\t\tk += 8;\n-\t\tx >>= 8;\n-\t\t}\n-\tif (!(x & 0xf)) {\n-\t\tk += 4;\n-\t\tx >>= 4;\n-\t\t}\n-\tif (!(x & 0x3)) {\n-\t\tk += 2;\n-\t\tx >>= 2;\n-\t\t}\n-\tif (!(x & 1)) {\n-\t\tk++;\n-\t\tx >>= 1;\n-\t\tif (!x)\n-\t\t\treturn 32;\n-\t\t}\n-\t*y = x;\n-\treturn k;\n-\t}\n-\n- Bigint *\n-multadd\n-#ifdef KR_headers\n-\t(b, m, a) Bigint *b; int m, a;\n-#else\n-\t(Bigint *b, int m, int a)\t/* multiply by m and add a */\n-#endif\n-{\n-\tint i, wds;\n-#ifdef ULLong\n-\tULong *x;\n-\tULLong carry, y;\n-#else\n-\tULong carry, *x, y;\n-#ifdef Pack_32\n-\tULong xi, z;\n-#endif\n-#endif\n-\tBigint *b1;\n-\n-\twds = b->wds;\n-\tx = b->x;\n-\ti = 0;\n-\tcarry = a;\n-\tdo {\n-#ifdef ULLong\n-\t\ty = *x * (ULLong)m + carry;\n-\t\tcarry = y >> 32;\n-\t\t*x++ = y & 0xffffffffUL;\n-#else\n-#ifdef Pack_32\n-\t\txi = *x;\n-\t\ty = (xi & 0xffff) * m + carry;\n-\t\tz = (xi >> 16) * m + (y >> 16);\n-\t\tcarry = z >> 16;\n-\t\t*x++ = (z << 16) + (y & 0xffff);\n-#else\n-\t\ty = *x * m + carry;\n-\t\tcarry = y >> 16;\n-\t\t*x++ = y & 0xffff;\n-#endif\n-#endif\n-\t\t}\n-\t\twhile(++i < wds);\n-\tif (carry) {\n-\t\tif (wds >= b->maxwds) {\n-\t\t\tb1 = Balloc(b->k+1);\n-\t\t\tBcopy(b1, b);\n-\t\t\tBfree(b);\n-\t\t\tb = b1;\n-\t\t\t}\n-\t\tb->x[wds++] = carry;\n-\t\tb->wds = wds;\n-\t\t}\n-\treturn b;\n-\t}\n-\n- int\n-hi0bits_D2A\n-#ifdef KR_headers\n-\t(x) ULong x;\n-#else\n-\t(ULong x)\n-#endif\n-{\n-\tint k = 0;\n-\n-\tif (!(x & 0xffff0000)) {\n-\t\tk = 16;\n-\t\tx <<= 16;\n-\t\t}\n-\tif (!(x & 0xff000000)) {\n-\t\tk += 8;\n-\t\tx <<= 8;\n-\t\t}\n-\tif (!(x & 0xf0000000)) {\n-\t\tk += 4;\n-\t\tx <<= 4;\n-\t\t}\n-\tif (!(x & 0xc0000000)) {\n-\t\tk += 2;\n-\t\tx <<= 2;\n-\t\t}\n-\tif (!(x & 0x80000000)) {\n-\t\tk++;\n-\t\tif (!(x & 0x40000000))\n-\t\t\treturn 32;\n-\t\t}\n-\treturn k;\n-\t}\n-\n- Bigint *\n-i2b\n-#ifdef KR_headers\n-\t(i) int i;\n-#else\n-\t(int i)\n-#endif\n-{\n-\tBigint *b;\n-\n-\tb = Balloc(1);\n-\tb->x[0] = i;\n-\tb->wds = 1;\n-\treturn b;\n-\t}\n-\n- Bigint *\n-mult\n-#ifdef KR_headers\n-\t(a, b) Bigint *a, *b;\n-#else\n-\t(Bigint *a, Bigint *b)\n-#endif\n-{\n-\tBigint *c;\n-\tint k, wa, wb, wc;\n-\tULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;\n-\tULong y;\n-#ifdef ULLong\n-\tULLong carry, z;\n-#else\n-\tULong carry, z;\n-#ifdef Pack_32\n-\tULong z2;\n-#endif\n-#endif\n-\n-\tif (a->wds < b->wds) {\n-\t\tc = a;\n-\t\ta = b;\n-\t\tb = c;\n-\t\t}\n-\tk = a->k;\n-\twa = a->wds;\n-\twb = b->wds;\n-\twc = wa + wb;\n-\tif (wc > a->maxwds)\n-\t\tk++;\n-\tc = Balloc(k);\n-\tfor(x = c->x, xa = x + wc; x < xa; x++)\n-\t\t*x = 0;\n-\txa = a->x;\n-\txae = xa + wa;\n-\txb = b->x;\n-\txbe = xb + wb;\n-\txc0 = c->x;\n-#ifdef ULLong\n-\tfor(; xb < xbe; xc0++) {\n-\t\tif ( (y = *xb++) !=0) {\n-\t\t\tx = xa;\n-\t\t\txc = xc0;\n-\t\t\tcarry = 0;\n-\t\t\tdo {\n-\t\t\t\tz = *x++ * (ULLong)y + *xc + carry;\n-\t\t\t\tcarry = z >> 32;\n-\t\t\t\t*xc++ = z & 0xffffffffUL;\n-\t\t\t\t}\n-\t\t\t\twhile(x < xae);\n-\t\t\t*xc = carry;\n-\t\t\t}\n-\t\t}\n-#else\n-#ifdef Pack_32\n-\tfor(; xb < xbe; xb++, xc0++) {\n-\t\tif ( (y = *xb & 0xffff) !=0) {\n-\t\t\tx = xa;\n-\t\t\txc = xc0;\n-\t\t\tcarry = 0;\n-\t\t\tdo {\n-\t\t\t\tz = (*x & 0xffff) * y + (*xc & 0xffff) + carry;\n-\t\t\t\tcarry = z >> 16;\n-\t\t\t\tz2 = (*x++ >> 16) * y + (*xc >> 16) + carry;\n-\t\t\t\tcarry = z2 >> 16;\n-\t\t\t\tStoreinc(xc, z2, z);\n-\t\t\t\t}\n-\t\t\t\twhile(x < xae);\n-\t\t\t*xc = carry;\n-\t\t\t}\n-\t\tif ( (y = *xb >> 16) !=0) {\n-\t\t\tx = xa;\n-\t\t\txc = xc0;\n-\t\t\tcarry = 0;\n-\t\t\tz2 = *xc;\n-\t\t\tdo {\n-\t\t\t\tz = (*x & 0xffff) * y + (*xc >> 16) + carry;\n-\t\t\t\tcarry = z >> 16;\n-\t\t\t\tStoreinc(xc, z, z2);\n-\t\t\t\tz2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;\n-\t\t\t\tcarry = z2 >> 16;\n-\t\t\t\t}\n-\t\t\t\twhile(x < xae);\n-\t\t\t*xc = z2;\n-\t\t\t}\n-\t\t}\n-#else\n-\tfor(; xb < xbe; xc0++) {\n-\t\tif ( (y = *xb++) !=0) {\n-\t\t\tx = xa;\n-\t\t\txc = xc0;\n-\t\t\tcarry = 0;\n-\t\t\tdo {\n-\t\t\t\tz = *x++ * y + *xc + carry;\n-\t\t\t\tcarry = z >> 16;\n-\t\t\t\t*xc++ = z & 0xffff;\n-\t\t\t\t}\n-\t\t\t\twhile(x < xae);\n-\t\t\t*xc = carry;\n-\t\t\t}\n-\t\t}\n-#endif\n-#endif\n-\tfor(xc0 = c->x, xc = xc0 + wc; wc > 0 && !*--xc; --wc) ;\n-\tc->wds = wc;\n-\treturn c;\n-\t}\n-\n- static Bigint *p5s;\n-\n- Bigint *\n-pow5mult\n-#ifdef KR_headers\n-\t(b, k) Bigint *b; int k;\n-#else\n-\t(Bigint *b, int k)\n-#endif\n-{\n-\tBigint *b1, *p5, *p51;\n-\tint i;\n-\tstatic int p05[3] = { 5, 25, 125 };\n-\n-\tif ( (i = k & 3) !=0)\n-\t\tb = multadd(b, p05[i-1], 0);\n-\n-\tif (!(k >>= 2))\n-\t\treturn b;\n-\tif ((p5 = p5s) == 0) {\n-\t\t/* first time */\n-#ifdef MULTIPLE_THREADS\n-\t\tACQUIRE_DTOA_LOCK(1);\n-\t\tif (!(p5 = p5s)) {\n-\t\t\tp5 = p5s = i2b(625);\n-\t\t\tp5->next = 0;\n-\t\t\t}\n-\t\tFREE_DTOA_LOCK(1);\n-#else\n-\t\tp5 = p5s = i2b(625);\n-\t\tp5->next = 0;\n-#endif\n-\t\t}\n-\tfor(;;) {\n-\t\tif (k & 1) {\n-\t\t\tb1 = mult(b, p5);\n-\t\t\tBfree(b);\n-\t\t\tb = b1;\n-\t\t\t}\n-\t\tif (!(k >>= 1))\n-\t\t\tbreak;\n-\t\tif ((p51 = p5->next) == 0) {\n-#ifdef MULTIPLE_THREADS\n-\t\t\tACQUIRE_DTOA_LOCK(1);\n-\t\t\tif (!(p51 = p5->next)) {\n-\t\t\t\tp51 = p5->next = mult(p5,p5);\n-\t\t\t\tp51->next = 0;\n-\t\t\t\t}\n-\t\t\tFREE_DTOA_LOCK(1);\n-#else\n-\t\t\tp51 = p5->next = mult(p5,p5);\n-\t\t\tp51->next = 0;\n-#endif\n-\t\t\t}\n-\t\tp5 = p51;\n-\t\t}\n-\treturn b;\n-\t}\n-\n- Bigint *\n-lshift\n-#ifdef KR_headers\n-\t(b, k) Bigint *b; int k;\n-#else\n-\t(Bigint *b, int k)\n-#endif\n-{\n-\tint i, k1, n, n1;\n-\tBigint *b1;\n-\tULong *x, *x1, *xe, z;\n-\n-\tn = k >> kshift;\n-\tk1 = b->k;\n-\tn1 = n + b->wds + 1;\n-\tfor(i = b->maxwds; n1 > i; i <<= 1)\n-\t\tk1++;\n-\tb1 = Balloc(k1);\n-\tx1 = b1->x;\n-\tfor(i = 0; i < n; i++)\n-\t\t*x1++ = 0;\n-\tx = b->x;\n-\txe = x + b->wds;\n-\tif (k &= kmask) {\n-#ifdef Pack_32\n-\t\tk1 = 32 - k;\n-\t\tz = 0;\n-\t\tdo {\n-\t\t\t*x1++ = *x << k | z;\n-\t\t\tz = *x++ >> k1;\n-\t\t\t}\n-\t\t\twhile(x < xe);\n-\t\tif ((*x1 = z) !=0)\n-\t\t\t++n1;\n-#else\n-\t\tk1 = 16 - k;\n-\t\tz = 0;\n-\t\tdo {\n-\t\t\t*x1++ = *x << k  & 0xffff | z;\n-\t\t\tz = *x++ >> k1;\n-\t\t\t}\n-\t\t\twhile(x < xe);\n-\t\tif (*x1 = z)\n-\t\t\t++n1;\n-#endif\n-\t\t}\n-\telse do\n-\t\t*x1++ = *x++;\n-\t\twhile(x < xe);\n-\tb1->wds = n1 - 1;\n-\tBfree(b);\n-\treturn b1;\n-\t}\n-\n- int\n-cmp\n-#ifdef KR_headers\n-\t(a, b) Bigint *a, *b;\n-#else\n-\t(Bigint *a, Bigint *b)\n-#endif\n-{\n-\tULong *xa, *xa0, *xb, *xb0;\n-\tint i, j;\n-\n-\ti = a->wds;\n-\tj = b->wds;\n-#ifdef DEBUG\n-\tif (i > 1 && !a->x[i-1])\n-\t\tBug(\"cmp called with a->x[a->wds-1] == 0\");\n-\tif (j > 1 && !b->x[j-1])\n-\t\tBug(\"cmp called with b->x[b->wds-1] == 0\");\n-#endif\n-\tif (i -= j)\n-\t\treturn i;\n-\txa0 = a->x;\n-\txa = xa0 + j;\n-\txb0 = b->x;\n-\txb = xb0 + j;\n-\tfor(;;) {\n-\t\tif (*--xa != *--xb)\n-\t\t\treturn *xa < *xb ? -1 : 1;\n-\t\tif (xa <= xa0)\n-\t\t\tbreak;\n-\t\t}\n-\treturn 0;\n-\t}\n-\n- Bigint *\n-diff\n-#ifdef KR_headers\n-\t(a, b) Bigint *a, *b;\n-#else\n-\t(Bigint *a, Bigint *b)\n-#endif\n-{\n-\tBigint *c;\n-\tint i, wa, wb;\n-\tULong *xa, *xae, *xb, *xbe, *xc;\n-#ifdef ULLong\n-\tULLong borrow, y;\n-#else\n-\tULong borrow, y;\n-#ifdef Pack_32\n-\tULong z;\n-#endif\n-#endif\n-\n-\ti = cmp(a,b);\n-\tif (!i) {\n-\t\tc = Balloc(0);\n-\t\tc->wds = 1;\n-\t\tc->x[0] = 0;\n-\t\treturn c;\n-\t\t}\n-\tif (i < 0) {\n-\t\tc = a;\n-\t\ta = b;\n-\t\tb = c;\n-\t\ti = 1;\n-\t\t}\n-\telse\n-\t\ti = 0;\n-\tc = Balloc(a->k);\n-\tc->sign = i;\n-\twa = a->wds;\n-\txa = a->x;\n-\txae = xa + wa;\n-\twb = b->wds;\n-\txb = b->x;\n-\txbe = xb + wb;\n-\txc = c->x;\n-\tborrow = 0;\n-#ifdef ULLong\n-\tdo {\n-\t\ty = (ULLong)*xa++ - *xb++ - borrow;\n-\t\tborrow = y >> 32 & 1UL;\n-\t\t*xc++ = y & 0xffffffffUL;\n-\t\t}\n-\t\twhile(xb < xbe);\n-\twhile(xa < xae) {\n-\t\ty = *xa++ - borrow;\n-\t\tborrow = y >> 32 & 1UL;\n-\t\t*xc++ = y & 0xffffffffUL;\n-\t\t}\n-#else\n-#ifdef Pack_32\n-\tdo {\n-\t\ty = (*xa & 0xffff) - (*xb & 0xffff) - borrow;\n-\t\tborrow = (y & 0x10000) >> 16;\n-\t\tz = (*xa++ >> 16) - (*xb++ >> 16) - borrow;\n-\t\tborrow = (z & 0x10000) >> 16;\n-\t\tStoreinc(xc, z, y);\n-\t\t}\n-\t\twhile(xb < xbe);\n-\twhile(xa < xae) {\n-\t\ty = (*xa & 0xffff) - borrow;\n-\t\tborrow = (y & 0x10000) >> 16;\n-\t\tz = (*xa++ >> 16) - borrow;\n-\t\tborrow = (z & 0x10000) >> 16;\n-\t\tStoreinc(xc, z, y);\n-\t\t}\n-#else\n-\tdo {\n-\t\ty = *xa++ - *xb++ - borrow;\n-\t\tborrow = (y & 0x10000) >> 16;\n-\t\t*xc++ = y & 0xffff;\n-\t\t}\n-\t\twhile(xb < xbe);\n-\twhile(xa < xae) {\n-\t\ty = *xa++ - borrow;\n-\t\tborrow = (y & 0x10000) >> 16;\n-\t\t*xc++ = y & 0xffff;\n-\t\t}\n-#endif\n-#endif\n-\twhile(!*--xc)\n-\t\twa--;\n-\tc->wds = wa;\n-\treturn c;\n-\t}\n-\n- double\n-b2d\n-#ifdef KR_headers\n-\t(a, e) Bigint *a; int *e;\n-#else\n-\t(Bigint *a, int *e)\n-#endif\n-{\n-\tULong *xa, *xa0, w, y, z;\n-\tint k;\n-\tU d;\n-#ifdef VAX\n-\tULong d0, d1;\n-#else\n-#define d0 word0(&d)\n-#define d1 word1(&d)\n-#endif\n-\n-\txa0 = a->x;\n-\txa = xa0 + a->wds;\n-\ty = *--xa;\n-#ifdef DEBUG\n-\tif (!y) Bug(\"zero y in b2d\");\n-#endif\n-\tk = hi0bits(y);\n-\t*e = 32 - k;\n-#ifdef Pack_32\n-\tif (k < Ebits) {\n-\t\td0 = Exp_1 | y >> (Ebits - k);\n-\t\tw = xa > xa0 ? *--xa : 0;\n-\t\td1 = y << ((32-Ebits) + k) | w >> (Ebits - k);\n-\t\tgoto ret_d;\n-\t\t}\n-\tz = xa > xa0 ? *--xa : 0;\n-\tif (k -= Ebits) {\n-\t\td0 = Exp_1 | y << k | z >> (32 - k);\n-\t\ty = xa > xa0 ? *--xa : 0;\n-\t\td1 = z << k | y >> (32 - k);\n-\t\t}\n-\telse {\n-\t\td0 = Exp_1 | y;\n-\t\td1 = z;\n-\t\t}\n-#else\n-\tif (k < Ebits + 16) {\n-\t\tz = xa > xa0 ? *--xa : 0;\n-\t\td0 = Exp_1 | y << k - Ebits | z >> Ebits + 16 - k;\n-\t\tw = xa > xa0 ? *--xa : 0;\n-\t\ty = xa > xa0 ? *--xa : 0;\n-\t\td1 = z << k + 16 - Ebits | w << k - Ebits | y >> 16 + Ebits - k;\n-\t\tgoto ret_d;\n-\t\t}\n-\tz = xa > xa0 ? *--xa : 0;\n-\tw = xa > xa0 ? *--xa : 0;\n-\tk -= Ebits + 16;\n-\td0 = Exp_1 | y << k + 16 | z << k | w >> 16 - k;\n-\ty = xa > xa0 ? *--xa : 0;\n-\td1 = w << k + 16 | y << k;\n-#endif\n- ret_d:\n-#ifdef VAX\n-\tword0(&d) = d0 >> 16 | d0 << 16;\n-\tword1(&d) = d1 >> 16 | d1 << 16;\n-#endif\n-\treturn dval(&d);\n-\t}\n-#undef d0\n-#undef d1\n-\n- Bigint *\n-d2b\n-#ifdef KR_headers\n-\t(dd, e, bits) double dd; int *e, *bits;\n-#else\n-\t(double dd, int *e, int *bits)\n-#endif\n-{\n-\tBigint *b;\n-\tU d;\n-#ifndef Sudden_Underflow\n-\tint i;\n-#endif\n-\tint de, k;\n-\tULong *x, y, z;\n-#ifdef VAX\n-\tULong d0, d1;\n-#else\n-#define d0 word0(&d)\n-#define d1 word1(&d)\n-#endif\n-\td.d = dd;\n-#ifdef VAX\n-\td0 = word0(&d) >> 16 | word0(&d) << 16;\n-\td1 = word1(&d) >> 16 | word1(&d) << 16;\n-#endif\n-\n-#ifdef Pack_32\n-\tb = Balloc(1);\n-#else\n-\tb = Balloc(2);\n-#endif\n-\tx = b->x;\n-\n-\tz = d0 & Frac_mask;\n-\td0 &= 0x7fffffff;\t/* clear sign bit, which we ignore */\n-#ifdef Sudden_Underflow\n-\tde = (int)(d0 >> Exp_shift);\n-#ifndef IBM\n-\tz |= Exp_msk11;\n-#endif\n-#else\n-\tif ( (de = (int)(d0 >> Exp_shift)) !=0)\n-\t\tz |= Exp_msk1;\n-#endif\n-#ifdef Pack_32\n-\tif ( (y = d1) !=0) {\n-\t\tif ( (k = lo0bits(&y)) !=0) {\n-\t\t\tx[0] = y | z << (32 - k);\n-\t\t\tz >>= k;\n-\t\t\t}\n-\t\telse\n-\t\t\tx[0] = y;\n-#ifndef Sudden_Underflow\n-\t\ti =\n-#endif\n-\t\t     b->wds = (x[1] = z) !=0 ? 2 : 1;\n-\t\t}\n-\telse {\n-\t\tk = lo0bits(&z);\n-\t\tx[0] = z;\n-#ifndef Sudden_Underflow\n-\t\ti =\n-#endif\n-\t\t    b->wds = 1;\n-\t\tk += 32;\n-\t\t}\n-#else\n-\tif ( (y = d1) !=0) {\n-\t\tif ( (k = lo0bits(&y)) !=0)\n-\t\t\tif (k >= 16) {\n-\t\t\t\tx[0] = y | z << 32 - k & 0xffff;\n-\t\t\t\tx[1] = z >> k - 16 & 0xffff;\n-\t\t\t\tx[2] = z >> k;\n-\t\t\t\ti = 2;\n-\t\t\t\t}\n-\t\t\telse {\n-\t\t\t\tx[0] = y & 0xffff;\n-\t\t\t\tx[1] = y >> 16 | z << 16 - k & 0xffff;\n-\t\t\t\tx[2] = z >> k & 0xffff;\n-\t\t\t\tx[3] = z >> k+16;\n-\t\t\t\ti = 3;\n-\t\t\t\t}\n-\t\telse {\n-\t\t\tx[0] = y & 0xffff;\n-\t\t\tx[1] = y >> 16;\n-\t\t\tx[2] = z & 0xffff;\n-\t\t\tx[3] = z >> 16;\n-\t\t\ti = 3;\n-\t\t\t}\n-\t\t}\n-\telse {\n-#ifdef DEBUG\n-\t\tif (!z)\n-\t\t\tBug(\"Zero passed to d2b\");\n-#endif\n-\t\tk = lo0bits(&z);\n-\t\tif (k >= 16) {\n-\t\t\tx[0] = z;\n-\t\t\ti = 0;\n-\t\t\t}\n-\t\telse {\n-\t\t\tx[0] = z & 0xffff;\n-\t\t\tx[1] = z >> 16;\n-\t\t\ti = 1;\n-\t\t\t}\n-\t\tk += 32;\n-\t\t}\n-\twhile(!x[i])\n-\t\t--i;\n-\tb->wds = i + 1;\n-#endif\n-#ifndef Sudden_Underflow\n-\tif (de) {\n-#endif\n-#ifdef IBM\n-\t\t*e = (de - Bias - (P-1) << 2) + k;\n-\t\t*bits = 4*P + 8 - k - hi0bits(word0(&d) & Frac_mask);\n-#else\n-\t\t*e = de - Bias - (P-1) + k;\n-\t\t*bits = P - k;\n-#endif\n-#ifndef Sudden_Underflow\n-\t\t}\n-\telse {\n-\t\t*e = de - Bias - (P-1) + 1 + k;\n-#ifdef Pack_32\n-\t\t*bits = 32*i - hi0bits(x[i-1]);\n-#else\n-\t\t*bits = (i+2)*16 - hi0bits(x[i]);\n-#endif\n-\t\t}\n-#endif\n-\treturn b;\n-\t}\n-#undef d0\n-#undef d1\n-\n- CONST double\n-#ifdef IEEE_Arith\n-bigtens[] = { 1e16, 1e32, 1e64, 1e128, 1e256 };\n-CONST double tinytens[] = { 1e-16, 1e-32, 1e-64, 1e-128, 1e-256\n-\t\t};\n-#else\n-#ifdef IBM\n-bigtens[] = { 1e16, 1e32, 1e64 };\n-CONST double tinytens[] = { 1e-16, 1e-32, 1e-64 };\n-#else\n-bigtens[] = { 1e16, 1e32 };\n-CONST double tinytens[] = { 1e-16, 1e-32 };\n-#endif\n-#endif\n-\n- CONST double\n-tens[] = {\n-\t\t1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,\n-\t\t1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n-\t\t1e20, 1e21, 1e22\n-#ifdef VAX\n-\t\t, 1e23, 1e24\n-#endif\n-\t\t};\n-\n-#ifdef NO_STRING_H\n- char *\n-#ifdef KR_headers\n-strcpy_D2A(a, b) char *a; char *b;\n-#else\n-strcpy_D2A(char *a, CONST char *b)\n-#endif\n-{\n-\twhile((*a = *b++))\n-\t\ta++;\n-\treturn a;\n-\t}\n-\n-\n- Char *\n-#ifdef KR_headers\n-memcpy_D2A(a, b, len) Char *a; Char *b; size_t len;\n-#else\n-memcpy_D2A(void *a1, void *b1, size_t len)\n-#endif\n-{\n-\tchar *a = (char*)a1, *ae = a + len;\n-\tchar *b = (char*)b1, *a0 = a;\n-\twhile(a < ae)\n-\t\t*a++ = *b++;\n-\treturn a0;\n-\t}\n-\n-#endif /* NO_STRING_H */"}, {"sha": "f4dbafb21c5f7c37f7f3f87e9ce943fecffd2a9e", "filename": "libquadmath/gdtoa/smisc.c", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fsmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fsmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fsmisc.c?ref=fa381cb2a157ab74bf8117938f3da5ba51095c2a", "patch": "@@ -1,191 +0,0 @@\n-/****************************************************************\n-\n-The author of this software is David M. Gay.\n-\n-Copyright (C) 1998, 1999 by Lucent Technologies\n-All Rights Reserved\n-\n-Permission to use, copy, modify, and distribute this software and\n-its documentation for any purpose and without fee is hereby\n-granted, provided that the above copyright notice appear in all\n-copies and that both that the copyright notice and this\n-permission notice and warranty disclaimer appear in supporting\n-documentation, and that the name of Lucent or any of its entities\n-not be used in advertising or publicity pertaining to\n-distribution of the software without specific, written prior\n-permission.\n-\n-LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n-INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n-IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n-SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n-IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n-THIS SOFTWARE.\n-\n-****************************************************************/\n-\n-/* Please send bug reports to David M. Gay (dmg at acm dot org,\n- * with \" at \" changed at \"@\" and \" dot \" changed to \".\").\t*/\n-\n-#include \"gdtoaimp.h\"\n-\n- Bigint *\n-s2b\n-#ifdef KR_headers\n-\t(s, nd0, nd, y9, dplen) CONST char *s; int dplen, nd0, nd; ULong y9;\n-#else\n-\t(CONST char *s, int nd0, int nd, ULong y9, int dplen)\n-#endif\n-{\n-\tBigint *b;\n-\tint i, k;\n-\tLong x, y;\n-\n-\tx = (nd + 8) / 9;\n-\tfor(k = 0, y = 1; x > y; y <<= 1, k++) ;\n-#ifdef Pack_32\n-\tb = Balloc(k);\n-\tb->x[0] = y9;\n-\tb->wds = 1;\n-#else\n-\tb = Balloc(k+1);\n-\tb->x[0] = y9 & 0xffff;\n-\tb->wds = (b->x[1] = y9 >> 16) ? 2 : 1;\n-#endif\n-\n-\ti = 9;\n-\tif (9 < nd0) {\n-\t\ts += 9;\n-\t\tdo b = multadd(b, 10, *s++ - '0');\n-\t\t\twhile(++i < nd0);\n-\t\ts += dplen;\n-\t\t}\n-\telse\n-\t\ts += dplen + 9;\n-\tfor(; i < nd; i++)\n-\t\tb = multadd(b, 10, *s++ - '0');\n-\treturn b;\n-\t}\n-\n- double\n-ratio\n-#ifdef KR_headers\n-\t(a, b) Bigint *a, *b;\n-#else\n-\t(Bigint *a, Bigint *b)\n-#endif\n-{\n-\tU da, db;\n-\tint k, ka, kb;\n-\n-\tdval(&da) = b2d(a, &ka);\n-\tdval(&db) = b2d(b, &kb);\n-\tk = ka - kb + ULbits*(a->wds - b->wds);\n-#ifdef IBM\n-\tif (k > 0) {\n-\t\tword0(&da) += (k >> 2)*Exp_msk1;\n-\t\tif (k &= 3)\n-\t\t\tdval(&da) *= 1 << k;\n-\t\t}\n-\telse {\n-\t\tk = -k;\n-\t\tword0(&db) += (k >> 2)*Exp_msk1;\n-\t\tif (k &= 3)\n-\t\t\tdval(&db) *= 1 << k;\n-\t\t}\n-#else\n-\tif (k > 0)\n-\t\tword0(&da) += k*Exp_msk1;\n-\telse {\n-\t\tk = -k;\n-\t\tword0(&db) += k*Exp_msk1;\n-\t\t}\n-#endif\n-\treturn dval(&da) / dval(&db);\n-\t}\n-\n-#ifdef INFNAN_CHECK\n-\n- int\n-match\n-#ifdef KR_headers\n-\t(sp, t) char **sp, *t;\n-#else\n-\t(CONST char **sp, char *t)\n-#endif\n-{\n-\tint c, d;\n-\tCONST char *s = *sp;\n-\n-\twhile( (d = *t++) !=0) {\n-\t\tif ((c = *++s) >= 'A' && c <= 'Z')\n-\t\t\tc += 'a' - 'A';\n-\t\tif (c != d)\n-\t\t\treturn 0;\n-\t\t}\n-\t*sp = s + 1;\n-\treturn 1;\n-\t}\n-#endif /* INFNAN_CHECK */\n-\n- void\n-#ifdef KR_headers\n-copybits(c, n, b) ULong *c; int n; Bigint *b;\n-#else\n-copybits(ULong *c, int n, Bigint *b)\n-#endif\n-{\n-\tULong *ce, *x, *xe;\n-#ifdef Pack_16\n-\tint nw, nw1;\n-#endif\n-\n-\tce = c + ((n-1) >> kshift) + 1;\n-\tx = b->x;\n-#ifdef Pack_32\n-\txe = x + b->wds;\n-\twhile(x < xe)\n-\t\t*c++ = *x++;\n-#else\n-\tnw = b->wds;\n-\tnw1 = nw & 1;\n-\tfor(xe = x + (nw - nw1); x < xe; x += 2)\n-\t\tStoreinc(c, x[1], x[0]);\n-\tif (nw1)\n-\t\t*c++ = *x;\n-#endif\n-\twhile(c < ce)\n-\t\t*c++ = 0;\n-\t}\n-\n- ULong\n-#ifdef KR_headers\n-any_on(b, k) Bigint *b; int k;\n-#else\n-any_on(Bigint *b, int k)\n-#endif\n-{\n-\tint n, nwds;\n-\tULong *x, *x0, x1, x2;\n-\n-\tx = b->x;\n-\tnwds = b->wds;\n-\tn = k >> kshift;\n-\tif (n > nwds)\n-\t\tn = nwds;\n-\telse if (n < nwds && (k &= kmask)) {\n-\t\tx1 = x2 = x[n];\n-\t\tx1 >>= k;\n-\t\tx1 <<= k;\n-\t\tif (x1 != x2)\n-\t\t\treturn 1;\n-\t\t}\n-\tx0 = x;\n-\tx += n;\n-\twhile(x > x0)\n-\t\tif (*--x)\n-\t\t\treturn 1;\n-\treturn 0;\n-\t}"}, {"sha": "5059869ecf5f74a83908330f2e2a329f5607946c", "filename": "libquadmath/gdtoa/strtodg.c", "status": "removed", "additions": 0, "deletions": 1065, "changes": 1065, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fstrtodg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fstrtodg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fstrtodg.c?ref=fa381cb2a157ab74bf8117938f3da5ba51095c2a", "patch": "@@ -1,1065 +0,0 @@\n-/****************************************************************\n-\n-The author of this software is David M. Gay.\n-\n-Copyright (C) 1998-2001 by Lucent Technologies\n-All Rights Reserved\n-\n-Permission to use, copy, modify, and distribute this software and\n-its documentation for any purpose and without fee is hereby\n-granted, provided that the above copyright notice appear in all\n-copies and that both that the copyright notice and this\n-permission notice and warranty disclaimer appear in supporting\n-documentation, and that the name of Lucent or any of its entities\n-not be used in advertising or publicity pertaining to\n-distribution of the software without specific, written prior\n-permission.\n-\n-LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n-INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n-IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n-SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n-IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n-THIS SOFTWARE.\n-\n-****************************************************************/\n-\n-/* Please send bug reports to David M. Gay (dmg at acm dot org,\n- * with \" at \" changed at \"@\" and \" dot \" changed to \".\").\t*/\n-\n-#include \"gdtoaimp.h\"\n-\n-#ifdef USE_LOCALE\n-#include \"locale.h\"\n-#endif\n-\n- static CONST int\n-fivesbits[] = {\t 0,  3,  5,  7, 10, 12, 14, 17, 19, 21,\n-\t\t24, 26, 28, 31, 33, 35, 38, 40, 42, 45,\n-\t\t47, 49, 52\n-#ifdef VAX\n-\t\t, 54, 56\n-#endif\n-\t\t};\n-\n- Bigint *\n-#ifdef KR_headers\n-increment(b) Bigint *b;\n-#else\n-increment(Bigint *b)\n-#endif\n-{\n-\tULong *x, *xe;\n-\tBigint *b1;\n-#ifdef Pack_16\n-\tULong carry = 1, y;\n-#endif\n-\n-\tx = b->x;\n-\txe = x + b->wds;\n-#ifdef Pack_32\n-\tdo {\n-\t\tif (*x < (ULong)0xffffffffL) {\n-\t\t\t++*x;\n-\t\t\treturn b;\n-\t\t\t}\n-\t\t*x++ = 0;\n-\t\t} while(x < xe);\n-#else\n-\tdo {\n-\t\ty = *x + carry;\n-\t\tcarry = y >> 16;\n-\t\t*x++ = y & 0xffff;\n-\t\tif (!carry)\n-\t\t\treturn b;\n-\t\t} while(x < xe);\n-\tif (carry)\n-#endif\n-\t{\n-\t\tif (b->wds >= b->maxwds) {\n-\t\t\tb1 = Balloc(b->k+1);\n-\t\t\tBcopy(b1,b);\n-\t\t\tBfree(b);\n-\t\t\tb = b1;\n-\t\t\t}\n-\t\tb->x[b->wds++] = 1;\n-\t\t}\n-\treturn b;\n-\t}\n-\n- void\n-#ifdef KR_headers\n-decrement(b) Bigint *b;\n-#else\n-decrement(Bigint *b)\n-#endif\n-{\n-\tULong *x, *xe;\n-#ifdef Pack_16\n-\tULong borrow = 1, y;\n-#endif\n-\n-\tx = b->x;\n-\txe = x + b->wds;\n-#ifdef Pack_32\n-\tdo {\n-\t\tif (*x) {\n-\t\t\t--*x;\n-\t\t\tbreak;\n-\t\t\t}\n-\t\t*x++ = 0xffffffffL;\n-\t\t}\n-\t\twhile(x < xe);\n-#else\n-\tdo {\n-\t\ty = *x - borrow;\n-\t\tborrow = (y & 0x10000) >> 16;\n-\t\t*x++ = y & 0xffff;\n-\t\t} while(borrow && x < xe);\n-#endif\n-\t}\n-\n- static int\n-#ifdef KR_headers\n-all_on(b, n) Bigint *b; int n;\n-#else\n-all_on(Bigint *b, int n)\n-#endif\n-{\n-\tULong *x, *xe;\n-\n-\tx = b->x;\n-\txe = x + (n >> kshift);\n-\twhile(x < xe)\n-\t\tif ((*x++ & ALL_ON) != ALL_ON)\n-\t\t\treturn 0;\n-\tif (n &= kmask)\n-\t\treturn ((*x | (ALL_ON << n)) & ALL_ON) == ALL_ON;\n-\treturn 1;\n-\t}\n-\n- Bigint *\n-#ifdef KR_headers\n-set_ones(b, n) Bigint *b; int n;\n-#else\n-set_ones(Bigint *b, int n)\n-#endif\n-{\n-\tint k;\n-\tULong *x, *xe;\n-\n-\tk = (n + ((1 << kshift) - 1)) >> kshift;\n-\tif (b->k < k) {\n-\t\tBfree(b);\n-\t\tb = Balloc(k);\n-\t\t}\n-\tk = n >> kshift;\n-\tif (n &= kmask)\n-\t\tk++;\n-\tb->wds = k;\n-\tx = b->x;\n-\txe = x + k;\n-\twhile(x < xe)\n-\t\t*x++ = ALL_ON;\n-\tif (n)\n-\t\tx[-1] >>= ULbits - n;\n-\treturn b;\n-\t}\n-\n- static int\n-rvOK\n-#ifdef KR_headers\n- (d, fpi, exp, bits, exact, rd, irv)\n- U *d; FPI *fpi; Long *exp; ULong *bits; int exact, rd, *irv;\n-#else\n- (U *d, FPI *fpi, Long *exp, ULong *bits, int exact, int rd, int *irv)\n-#endif\n-{\n-\tBigint *b;\n-\tULong carry, inex, lostbits;\n-\tint bdif, e, j, k, k1, nb, rv;\n-\n-\tcarry = rv = 0;\n-\tb = d2b(dval(d), &e, &bdif);\n-\tbdif -= nb = fpi->nbits;\n-\te += bdif;\n-\tif (bdif <= 0) {\n-\t\tif (exact)\n-\t\t\tgoto trunc;\n-\t\tgoto ret;\n-\t\t}\n-\tif (P == nb) {\n-\t\tif (\n-#ifndef IMPRECISE_INEXACT\n-\t\t\texact &&\n-#endif\n-\t\t\tfpi->rounding ==\n-#ifdef RND_PRODQUOT\n-\t\t\t\t\tFPI_Round_near\n-#else\n-\t\t\t\t\tFlt_Rounds\n-#endif\n-\t\t\t) goto trunc;\n-\t\tgoto ret;\n-\t\t}\n-\tswitch(rd) {\n-\t  case 1: /* round down (toward -Infinity) */\n-\t\tgoto trunc;\n-\t  case 2: /* round up (toward +Infinity) */\n-\t\tbreak;\n-\t  default: /* round near */\n-\t\tk = bdif - 1;\n-\t\tif (k < 0)\n-\t\t\tgoto trunc;\n-\t\tif (!k) {\n-\t\t\tif (!exact)\n-\t\t\t\tgoto ret;\n-\t\t\tif (b->x[0] & 2)\n-\t\t\t\tbreak;\n-\t\t\tgoto trunc;\n-\t\t\t}\n-\t\tif (b->x[k>>kshift] & ((ULong)1 << (k & kmask)))\n-\t\t\tbreak;\n-\t\tgoto trunc;\n-\t  }\n-\t/* \"break\" cases: round up 1 bit, then truncate; bdif > 0 */\n-\tcarry = 1;\n- trunc:\n-\tinex = lostbits = 0;\n-\tif (bdif > 0) {\n-\t\tif ( (lostbits = any_on(b, bdif)) !=0)\n-\t\t\tinex = STRTOG_Inexlo;\n-\t\trshift(b, bdif);\n-\t\tif (carry) {\n-\t\t\tinex = STRTOG_Inexhi;\n-\t\t\tb = increment(b);\n-\t\t\tif ( (j = nb & kmask) !=0)\n-\t\t\t\tj = ULbits - j;\n-\t\t\tif (hi0bits(b->x[b->wds - 1]) != j) {\n-\t\t\t\tif (!lostbits)\n-\t\t\t\t\tlostbits = b->x[0] & 1;\n-\t\t\t\trshift(b, 1);\n-\t\t\t\te++;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\telse if (bdif < 0)\n-\t\tb = lshift(b, -bdif);\n-\tif (e < fpi->emin) {\n-\t\tk = fpi->emin - e;\n-\t\te = fpi->emin;\n-\t\tif (k > nb || fpi->sudden_underflow) {\n-\t\t\tb->wds = inex = 0;\n-\t\t\t*irv = STRTOG_Underflow | STRTOG_Inexlo;\n-\t\t\t}\n-\t\telse {\n-\t\t\tk1 = k - 1;\n-\t\t\tif (k1 > 0 && !lostbits)\n-\t\t\t\tlostbits = any_on(b, k1);\n-\t\t\tif (!lostbits && !exact)\n-\t\t\t\tgoto ret;\n-\t\t\tlostbits |=\n-\t\t\t  carry = b->x[k1>>kshift] & (1 << (k1 & kmask));\n-\t\t\trshift(b, k);\n-\t\t\t*irv = STRTOG_Denormal;\n-\t\t\tif (carry) {\n-\t\t\t\tb = increment(b);\n-\t\t\t\tinex = STRTOG_Inexhi | STRTOG_Underflow;\n-\t\t\t\t}\n-\t\t\telse if (lostbits)\n-\t\t\t\tinex = STRTOG_Inexlo | STRTOG_Underflow;\n-\t\t\t}\n-\t\t}\n-\telse if (e > fpi->emax) {\n-\t\te = fpi->emax + 1;\n-\t\t*irv = STRTOG_Infinite | STRTOG_Overflow | STRTOG_Inexhi;\n-#ifndef NO_ERRNO\n-\t\terrno = ERANGE;\n-#endif\n-\t\tb->wds = inex = 0;\n-\t\t}\n-\t*exp = e;\n-\tcopybits(bits, nb, b);\n-\t*irv |= inex;\n-\trv = 1;\n- ret:\n-\tBfree(b);\n-\treturn rv;\n-\t}\n-\n- static int\n-#ifdef KR_headers\n-mantbits(d) U *d;\n-#else\n-mantbits(U *d)\n-#endif\n-{\n-\tULong L;\n-#ifdef VAX\n-\tL = word1(d) << 16 | word1(d) >> 16;\n-\tif (L)\n-#else\n-\tif ( (L = word1(d)) !=0)\n-#endif\n-\t\treturn P - lo0bits(&L);\n-#ifdef VAX\n-\tL = word0(d) << 16 | word0(d) >> 16 | Exp_msk11;\n-#else\n-\tL = word0(d) | Exp_msk1;\n-#endif\n-\treturn P - 32 - lo0bits(&L);\n-\t}\n-\n- int\n-strtodg\n-#ifdef KR_headers\n-\t(s00, se, fpi, exp, bits)\n-\tCONST char *s00; char **se; FPI *fpi; Long *exp; ULong *bits;\n-#else\n-\t(CONST char *s00, char **se, FPI *fpi, Long *exp, ULong *bits)\n-#endif\n-{\n-\tint abe, abits, asub;\n-\tint bb0, bb2, bb5, bbe, bd2, bd5, bbbits, bs2, c, decpt, denorm;\n-\tint dsign, e, e1, e2, emin, esign, finished, i, inex, irv;\n-\tint j, k, nbits, nd, nd0, nf, nz, nz0, rd, rvbits, rve, rve1, sign;\n-\tint sudden_underflow;\n-\tCONST char *s, *s0, *s1;\n-\tdouble adj0, tol;\n-\tLong L;\n-\tU adj, rv;\n-\tULong *b, *be, y, z;\n-\tBigint *ab, *bb, *bb1, *bd, *bd0, *bs, *delta, *rvb, *rvb0;\n-#ifdef USE_LOCALE /*{{*/\n-#ifdef NO_LOCALE_CACHE\n-\tchar *decimalpoint = localeconv()->decimal_point;\n-\tint dplen = strlen(decimalpoint);\n-#else\n-\tchar *decimalpoint;\n-\tstatic char *decimalpoint_cache;\n-\tstatic int dplen;\n-\tif (!(s0 = decimalpoint_cache)) {\n-\t\ts0 = localeconv()->decimal_point;\n-\t\tif ((decimalpoint_cache = (char*)MALLOC(strlen(s0) + 1))) {\n-\t\t\tstrcpy(decimalpoint_cache, s0);\n-\t\t\ts0 = decimalpoint_cache;\n-\t\t\t}\n-\t\tdplen = strlen(s0);\n-\t\t}\n-\tdecimalpoint = (char*)s0;\n-#endif /*NO_LOCALE_CACHE*/\n-#else  /*USE_LOCALE}{*/\n-#define dplen 1\n-#endif /*USE_LOCALE}}*/\n-\n-\tirv = STRTOG_Zero;\n-\tdenorm = sign = nz0 = nz = 0;\n-\tdval(&rv) = 0.;\n-\trvb = 0;\n-\tnbits = fpi->nbits;\n-\tfor(s = s00;;s++) switch(*s) {\n-\t\tcase '-':\n-\t\t\tsign = 1;\n-\t\t\t/* no break */\n-\t\tcase '+':\n-\t\t\tif (*++s)\n-\t\t\t\tgoto break2;\n-\t\t\t/* no break */\n-\t\tcase 0:\n-\t\t\tsign = 0;\n-\t\t\tirv = STRTOG_NoNumber;\n-\t\t\ts = s00;\n-\t\t\tgoto ret;\n-\t\tcase '\\t':\n-\t\tcase '\\n':\n-\t\tcase '\\v':\n-\t\tcase '\\f':\n-\t\tcase '\\r':\n-\t\tcase ' ':\n-\t\t\tcontinue;\n-\t\tdefault:\n-\t\t\tgoto break2;\n-\t\t}\n- break2:\n-\tif (*s == '0') {\n-#ifndef NO_HEX_FP\n-\t\tswitch(s[1]) {\n-\t\t  case 'x':\n-\t\t  case 'X':\n-\t\t\tirv = gethex(&s, fpi, exp, &rvb, sign);\n-\t\t\tif (irv == STRTOG_NoNumber) {\n-\t\t\t\ts = s00;\n-\t\t\t\tsign = 0;\n-\t\t\t\t}\n-\t\t\tgoto ret;\n-\t\t  }\n-#endif\n-\t\tnz0 = 1;\n-\t\twhile(*++s == '0') ;\n-\t\tif (!*s)\n-\t\t\tgoto ret;\n-\t\t}\n-\tsudden_underflow = fpi->sudden_underflow;\n-\ts0 = s;\n-\ty = z = 0;\n-\tfor(decpt = nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++)\n-\t\tif (nd < 9)\n-\t\t\ty = 10*y + c - '0';\n-\t\telse if (nd < 16)\n-\t\t\tz = 10*z + c - '0';\n-\tnd0 = nd;\n-#ifdef USE_LOCALE\n-\tif (c == *decimalpoint) {\n-\t\tfor(i = 1; decimalpoint[i]; ++i)\n-\t\t\tif (s[i] != decimalpoint[i])\n-\t\t\t\tgoto dig_done;\n-\t\ts += i;\n-\t\tc = *s;\n-#else\n-\tif (c == '.') {\n-\t\tc = *++s;\n-#endif\n-\t\tdecpt = 1;\n-\t\tif (!nd) {\n-\t\t\tfor(; c == '0'; c = *++s)\n-\t\t\t\tnz++;\n-\t\t\tif (c > '0' && c <= '9') {\n-\t\t\t\ts0 = s;\n-\t\t\t\tnf += nz;\n-\t\t\t\tnz = 0;\n-\t\t\t\tgoto have_dig;\n-\t\t\t\t}\n-\t\t\tgoto dig_done;\n-\t\t\t}\n-\t\tfor(; c >= '0' && c <= '9'; c = *++s) {\n- have_dig:\n-\t\t\tnz++;\n-\t\t\tif (c -= '0') {\n-\t\t\t\tnf += nz;\n-\t\t\t\tfor(i = 1; i < nz; i++)\n-\t\t\t\t\tif (nd++ < 9)\n-\t\t\t\t\t\ty *= 10;\n-\t\t\t\t\telse if (nd <= DBL_DIG + 1)\n-\t\t\t\t\t\tz *= 10;\n-\t\t\t\tif (nd++ < 9)\n-\t\t\t\t\ty = 10*y + c;\n-\t\t\t\telse if (nd <= DBL_DIG + 1)\n-\t\t\t\t\tz = 10*z + c;\n-\t\t\t\tnz = 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}/*}*/\n- dig_done:\n-\te = 0;\n-\tif (c == 'e' || c == 'E') {\n-\t\tif (!nd && !nz && !nz0) {\n-\t\t\tirv = STRTOG_NoNumber;\n-\t\t\ts = s00;\n-\t\t\tgoto ret;\n-\t\t\t}\n-\t\ts00 = s;\n-\t\tesign = 0;\n-\t\tswitch(c = *++s) {\n-\t\t\tcase '-':\n-\t\t\t\tesign = 1;\n-\t\t\tcase '+':\n-\t\t\t\tc = *++s;\n-\t\t\t}\n-\t\tif (c >= '0' && c <= '9') {\n-\t\t\twhile(c == '0')\n-\t\t\t\tc = *++s;\n-\t\t\tif (c > '0' && c <= '9') {\n-\t\t\t\tL = c - '0';\n-\t\t\t\ts1 = s;\n-\t\t\t\twhile((c = *++s) >= '0' && c <= '9')\n-\t\t\t\t\tL = 10*L + c - '0';\n-\t\t\t\tif (s - s1 > 8 || L > 19999)\n-\t\t\t\t\t/* Avoid confusion from exponents\n-\t\t\t\t\t * so large that e might overflow.\n-\t\t\t\t\t */\n-\t\t\t\t\te = 19999; /* safe for 16 bit ints */\n-\t\t\t\telse\n-\t\t\t\t\te = (int)L;\n-\t\t\t\tif (esign)\n-\t\t\t\t\te = -e;\n-\t\t\t\t}\n-\t\t\telse\n-\t\t\t\te = 0;\n-\t\t\t}\n-\t\telse\n-\t\t\ts = s00;\n-\t\t}\n-\tif (!nd) {\n-\t\tif (!nz && !nz0) {\n-#ifdef INFNAN_CHECK\n-\t\t\t/* Check for Nan and Infinity */\n-\t\t\tif (!decpt)\n-\t\t\t switch(c) {\n-\t\t\t  case 'i':\n-\t\t\t  case 'I':\n-\t\t\t\tif (match(&s,\"nf\")) {\n-\t\t\t\t\t--s;\n-\t\t\t\t\tif (!match(&s,\"inity\"))\n-\t\t\t\t\t\t++s;\n-\t\t\t\t\tirv = STRTOG_Infinite;\n-\t\t\t\t\tgoto infnanexp;\n-\t\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t  case 'n':\n-\t\t\t  case 'N':\n-\t\t\t\tif (match(&s, \"an\")) {\n-\t\t\t\t\tirv = STRTOG_NaN;\n-\t\t\t\t\t*exp = fpi->emax + 1;\n-#ifndef No_Hex_NaN\n-\t\t\t\t\tif (*s == '(') /*)*/\n-\t\t\t\t\t\tirv = hexnan(&s, fpi, bits);\n-#endif\n-\t\t\t\t\tgoto infnanexp;\n-\t\t\t\t\t}\n-\t\t\t  }\n-#endif /* INFNAN_CHECK */\n-\t\t\tirv = STRTOG_NoNumber;\n-\t\t\ts = s00;\n-\t\t\t}\n-\t\tgoto ret;\n-\t\t}\n-\n-\tirv = STRTOG_Normal;\n-\te1 = e -= nf;\n-\trd = 0;\n-\tswitch(fpi->rounding & 3) {\n-\t  case FPI_Round_up:\n-\t\trd = 2 - sign;\n-\t\tbreak;\n-\t  case FPI_Round_zero:\n-\t\trd = 1;\n-\t\tbreak;\n-\t  case FPI_Round_down:\n-\t\trd = 1 + sign;\n-\t  }\n-\n-\t/* Now we have nd0 digits, starting at s0, followed by a\n-\t * decimal point, followed by nd-nd0 digits.  The number we're\n-\t * after is the integer represented by those digits times\n-\t * 10**e */\n-\n-\tif (!nd0)\n-\t\tnd0 = nd;\n-\tk = nd < DBL_DIG + 1 ? nd : DBL_DIG + 1;\n-\tdval(&rv) = y;\n-\tif (k > 9)\n-\t\tdval(&rv) = tens[k - 9] * dval(&rv) + z;\n-\tbd0 = 0;\n-\tif (nbits <= P && nd <= DBL_DIG) {\n-\t\tif (!e) {\n-\t\t\tif (rvOK(&rv, fpi, exp, bits, 1, rd, &irv))\n-\t\t\t\tgoto ret;\n-\t\t\t}\n-\t\telse if (e > 0) {\n-\t\t\tif (e <= Ten_pmax) {\n-#ifdef VAX\n-\t\t\t\tgoto vax_ovfl_check;\n-#else\n-\t\t\t\ti = fivesbits[e] + mantbits(&rv) <= P;\n-\t\t\t\t/* rv = */ rounded_product(dval(&rv), tens[e]);\n-\t\t\t\tif (rvOK(&rv, fpi, exp, bits, i, rd, &irv))\n-\t\t\t\t\tgoto ret;\n-\t\t\t\te1 -= e;\n-\t\t\t\tgoto rv_notOK;\n-#endif\n-\t\t\t\t}\n-\t\t\ti = DBL_DIG - nd;\n-\t\t\tif (e <= Ten_pmax + i) {\n-\t\t\t\t/* A fancier test would sometimes let us do\n-\t\t\t\t * this for larger i values.\n-\t\t\t\t */\n-\t\t\t\te2 = e - i;\n-\t\t\t\te1 -= i;\n-\t\t\t\tdval(&rv) *= tens[i];\n-#ifdef VAX\n-\t\t\t\t/* VAX exponent range is so narrow we must\n-\t\t\t\t * worry about overflow here...\n-\t\t\t\t */\n- vax_ovfl_check:\n-\t\t\t\tdval(&adj) = dval(&rv);\n-\t\t\t\tword0(&adj) -= P*Exp_msk1;\n-\t\t\t\t/* adj = */ rounded_product(dval(&adj), tens[e2]);\n-\t\t\t\tif ((word0(&adj) & Exp_mask)\n-\t\t\t\t > Exp_msk1*(DBL_MAX_EXP+Bias-1-P))\n-\t\t\t\t\tgoto rv_notOK;\n-\t\t\t\tword0(&adj) += P*Exp_msk1;\n-\t\t\t\tdval(&rv) = dval(&adj);\n-#else\n-\t\t\t\t/* rv = */ rounded_product(dval(&rv), tens[e2]);\n-#endif\n-\t\t\t\tif (rvOK(&rv, fpi, exp, bits, 0, rd, &irv))\n-\t\t\t\t\tgoto ret;\n-\t\t\t\te1 -= e2;\n-\t\t\t\t}\n-\t\t\t}\n-#ifndef Inaccurate_Divide\n-\t\telse if (e >= -Ten_pmax) {\n-\t\t\t/* rv = */ rounded_quotient(dval(&rv), tens[-e]);\n-\t\t\tif (rvOK(&rv, fpi, exp, bits, 0, rd, &irv))\n-\t\t\t\tgoto ret;\n-\t\t\te1 -= e;\n-\t\t\t}\n-#endif\n-\t\t}\n- rv_notOK:\n-\te1 += nd - k;\n-\n-\t/* Get starting approximation = rv * 10**e1 */\n-\n-\te2 = 0;\n-\tif (e1 > 0) {\n-\t\tif ( (i = e1 & 15) !=0)\n-\t\t\tdval(&rv) *= tens[i];\n-\t\tif (e1 &= ~15) {\n-\t\t\te1 >>= 4;\n-\t\t\twhile(e1 >= (1 << (n_bigtens-1))) {\n-\t\t\t\te2 += ((word0(&rv) & Exp_mask)\n-\t\t\t\t\t>> Exp_shift1) - Bias;\n-\t\t\t\tword0(&rv) &= ~Exp_mask;\n-\t\t\t\tword0(&rv) |= Bias << Exp_shift1;\n-\t\t\t\tdval(&rv) *= bigtens[n_bigtens-1];\n-\t\t\t\te1 -= 1 << (n_bigtens-1);\n-\t\t\t\t}\n-\t\t\te2 += ((word0(&rv) & Exp_mask) >> Exp_shift1) - Bias;\n-\t\t\tword0(&rv) &= ~Exp_mask;\n-\t\t\tword0(&rv) |= Bias << Exp_shift1;\n-\t\t\tfor(j = 0; e1 > 0; j++, e1 >>= 1)\n-\t\t\t\tif (e1 & 1)\n-\t\t\t\t\tdval(&rv) *= bigtens[j];\n-\t\t\t}\n-\t\t}\n-\telse if (e1 < 0) {\n-\t\te1 = -e1;\n-\t\tif ( (i = e1 & 15) !=0)\n-\t\t\tdval(&rv) /= tens[i];\n-\t\tif (e1 &= ~15) {\n-\t\t\te1 >>= 4;\n-\t\t\twhile(e1 >= (1 << (n_bigtens-1))) {\n-\t\t\t\te2 += ((word0(&rv) & Exp_mask)\n-\t\t\t\t\t>> Exp_shift1) - Bias;\n-\t\t\t\tword0(&rv) &= ~Exp_mask;\n-\t\t\t\tword0(&rv) |= Bias << Exp_shift1;\n-\t\t\t\tdval(&rv) *= tinytens[n_bigtens-1];\n-\t\t\t\te1 -= 1 << (n_bigtens-1);\n-\t\t\t\t}\n-\t\t\te2 += ((word0(&rv) & Exp_mask) >> Exp_shift1) - Bias;\n-\t\t\tword0(&rv) &= ~Exp_mask;\n-\t\t\tword0(&rv) |= Bias << Exp_shift1;\n-\t\t\tfor(j = 0; e1 > 0; j++, e1 >>= 1)\n-\t\t\t\tif (e1 & 1)\n-\t\t\t\t\tdval(&rv) *= tinytens[j];\n-\t\t\t}\n-\t\t}\n-#ifdef IBM\n-\t/* e2 is a correction to the (base 2) exponent of the return\n-\t * value, reflecting adjustments above to avoid overflow in the\n-\t * native arithmetic.  For native IBM (base 16) arithmetic, we\n-\t * must multiply e2 by 4 to change from base 16 to 2.\n-\t */\n-\te2 <<= 2;\n-#endif\n-\trvb = d2b(dval(&rv), &rve, &rvbits);\t/* rv = rvb * 2^rve */\n-\trve += e2;\n-\tif ((j = rvbits - nbits) > 0) {\n-\t\trshift(rvb, j);\n-\t\trvbits = nbits;\n-\t\trve += j;\n-\t\t}\n-\tbb0 = 0;\t/* trailing zero bits in rvb */\n-\te2 = rve + rvbits - nbits;\n-\tif (e2 > fpi->emax + 1)\n-\t\tgoto huge;\n-\trve1 = rve + rvbits - nbits;\n-\tif (e2 < (emin = fpi->emin)) {\n-\t\tdenorm = 1;\n-\t\tj = rve - emin;\n-\t\tif (j > 0) {\n-\t\t\trvb = lshift(rvb, j);\n-\t\t\trvbits += j;\n-\t\t\t}\n-\t\telse if (j < 0) {\n-\t\t\trvbits += j;\n-\t\t\tif (rvbits <= 0) {\n-\t\t\t\tif (rvbits < -1) {\n- ufl:\n-\t\t\t\t\trvb->wds = 0;\n-\t\t\t\t\trvb->x[0] = 0;\n-\t\t\t\t\t*exp = emin;\n-\t\t\t\t\tirv = STRTOG_Underflow | STRTOG_Inexlo;\n-\t\t\t\t\tgoto ret;\n-\t\t\t\t\t}\n-\t\t\t\trvb->x[0] = rvb->wds = rvbits = 1;\n-\t\t\t\t}\n-\t\t\telse\n-\t\t\t\trshift(rvb, -j);\n-\t\t\t}\n-\t\trve = rve1 = emin;\n-\t\tif (sudden_underflow && e2 + 1 < emin)\n-\t\t\tgoto ufl;\n-\t\t}\n-\n-\t/* Now the hard part -- adjusting rv to the correct value.*/\n-\n-\t/* Put digits into bd: true value = bd * 10^e */\n-\n-\tbd0 = s2b(s0, nd0, nd, y, dplen);\n-\n-\tfor(;;) {\n-\t\tbd = Balloc(bd0->k);\n-\t\tBcopy(bd, bd0);\n-\t\tbb = Balloc(rvb->k);\n-\t\tBcopy(bb, rvb);\n-\t\tbbbits = rvbits - bb0;\n-\t\tbbe = rve + bb0;\n-\t\tbs = i2b(1);\n-\n-\t\tif (e >= 0) {\n-\t\t\tbb2 = bb5 = 0;\n-\t\t\tbd2 = bd5 = e;\n-\t\t\t}\n-\t\telse {\n-\t\t\tbb2 = bb5 = -e;\n-\t\t\tbd2 = bd5 = 0;\n-\t\t\t}\n-\t\tif (bbe >= 0)\n-\t\t\tbb2 += bbe;\n-\t\telse\n-\t\t\tbd2 -= bbe;\n-\t\tbs2 = bb2;\n-\t\tj = nbits + 1 - bbbits;\n-\t\ti = bbe + bbbits - nbits;\n-\t\tif (i < emin)\t/* denormal */\n-\t\t\tj += i - emin;\n-\t\tbb2 += j;\n-\t\tbd2 += j;\n-\t\ti = bb2 < bd2 ? bb2 : bd2;\n-\t\tif (i > bs2)\n-\t\t\ti = bs2;\n-\t\tif (i > 0) {\n-\t\t\tbb2 -= i;\n-\t\t\tbd2 -= i;\n-\t\t\tbs2 -= i;\n-\t\t\t}\n-\t\tif (bb5 > 0) {\n-\t\t\tbs = pow5mult(bs, bb5);\n-\t\t\tbb1 = mult(bs, bb);\n-\t\t\tBfree(bb);\n-\t\t\tbb = bb1;\n-\t\t\t}\n-\t\tbb2 -= bb0;\n-\t\tif (bb2 > 0)\n-\t\t\tbb = lshift(bb, bb2);\n-\t\telse if (bb2 < 0)\n-\t\t\trshift(bb, -bb2);\n-\t\tif (bd5 > 0)\n-\t\t\tbd = pow5mult(bd, bd5);\n-\t\tif (bd2 > 0)\n-\t\t\tbd = lshift(bd, bd2);\n-\t\tif (bs2 > 0)\n-\t\t\tbs = lshift(bs, bs2);\n-\t\tasub = 1;\n-\t\tinex = STRTOG_Inexhi;\n-\t\tdelta = diff(bb, bd);\n-\t\tif (delta->wds <= 1 && !delta->x[0])\n-\t\t\tbreak;\n-\t\tdsign = delta->sign;\n-\t\tdelta->sign = finished = 0;\n-\t\tL = 0;\n-\t\ti = cmp(delta, bs);\n-\t\tif (rd && i <= 0) {\n-\t\t\tirv = STRTOG_Normal;\n-\t\t\tif ( (finished = dsign ^ (rd&1)) !=0) {\n-\t\t\t\tif (dsign != 0) {\n-\t\t\t\t\tirv |= STRTOG_Inexhi;\n-\t\t\t\t\tgoto adj1;\n-\t\t\t\t\t}\n-\t\t\t\tirv |= STRTOG_Inexlo;\n-\t\t\t\tif (rve1 == emin)\n-\t\t\t\t\tgoto adj1;\n-\t\t\t\tfor(i = 0, j = nbits; j >= ULbits;\n-\t\t\t\t\t\ti++, j -= ULbits) {\n-\t\t\t\t\tif (rvb->x[i] & ALL_ON)\n-\t\t\t\t\t\tgoto adj1;\n-\t\t\t\t\t}\n-\t\t\t\tif (j > 1 && lo0bits(rvb->x + i) < j - 1)\n-\t\t\t\t\tgoto adj1;\n-\t\t\t\trve = rve1 - 1;\n-\t\t\t\trvb = set_ones(rvb, rvbits = nbits);\n-\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\tirv |= dsign ? STRTOG_Inexlo : STRTOG_Inexhi;\n-\t\t\tbreak;\n-\t\t\t}\n-\t\tif (i < 0) {\n-\t\t\t/* Error is less than half an ulp -- check for\n-\t\t\t * special case of mantissa a power of two.\n-\t\t\t */\n-\t\t\tirv = dsign\n-\t\t\t\t? STRTOG_Normal | STRTOG_Inexlo\n-\t\t\t\t: STRTOG_Normal | STRTOG_Inexhi;\n-\t\t\tif (dsign || bbbits > 1 || denorm || rve1 == emin)\n-\t\t\t\tbreak;\n-\t\t\tdelta = lshift(delta,1);\n-\t\t\tif (cmp(delta, bs) > 0) {\n-\t\t\t\tirv = STRTOG_Normal | STRTOG_Inexlo;\n-\t\t\t\tgoto drop_down;\n-\t\t\t\t}\n-\t\t\tbreak;\n-\t\t\t}\n-\t\tif (i == 0) {\n-\t\t\t/* exactly half-way between */\n-\t\t\tif (dsign) {\n-\t\t\t\tif (denorm && all_on(rvb, rvbits)) {\n-\t\t\t\t\t/*boundary case -- increment exponent*/\n-\t\t\t\t\trvb->wds = 1;\n-\t\t\t\t\trvb->x[0] = 1;\n-\t\t\t\t\trve = emin + nbits - (rvbits = 1);\n-\t\t\t\t\tirv = STRTOG_Normal | STRTOG_Inexhi;\n-\t\t\t\t\tdenorm = 0;\n-\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\tirv = STRTOG_Normal | STRTOG_Inexlo;\n-\t\t\t\t}\n-\t\t\telse if (bbbits == 1) {\n-\t\t\t\tirv = STRTOG_Normal;\n- drop_down:\n-\t\t\t\t/* boundary case -- decrement exponent */\n-\t\t\t\tif (rve1 == emin) {\n-\t\t\t\t\tirv = STRTOG_Normal | STRTOG_Inexhi;\n-\t\t\t\t\tif (rvb->wds == 1 && rvb->x[0] == 1)\n-\t\t\t\t\t\tsudden_underflow = 1;\n-\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\trve -= nbits;\n-\t\t\t\trvb = set_ones(rvb, rvbits = nbits);\n-\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\telse\n-\t\t\t\tirv = STRTOG_Normal | STRTOG_Inexhi;\n-\t\t\tif ((bbbits < nbits && !denorm) || !(rvb->x[0] & 1))\n-\t\t\t\tbreak;\n-\t\t\tif (dsign) {\n-\t\t\t\trvb = increment(rvb);\n-\t\t\t\tj = kmask & (ULbits - (rvbits & kmask));\n-\t\t\t\tif (hi0bits(rvb->x[rvb->wds - 1]) != j)\n-\t\t\t\t\trvbits++;\n-\t\t\t\tirv = STRTOG_Normal | STRTOG_Inexhi;\n-\t\t\t\t}\n-\t\t\telse {\n-\t\t\t\tif (bbbits == 1)\n-\t\t\t\t\tgoto undfl;\n-\t\t\t\tdecrement(rvb);\n-\t\t\t\tirv = STRTOG_Normal | STRTOG_Inexlo;\n-\t\t\t\t}\n-\t\t\tbreak;\n-\t\t\t}\n-\t\tif ((dval(&adj) = ratio(delta, bs)) <= 2.) {\n- adj1:\n-\t\t\tinex = STRTOG_Inexlo;\n-\t\t\tif (dsign) {\n-\t\t\t\tasub = 0;\n-\t\t\t\tinex = STRTOG_Inexhi;\n-\t\t\t\t}\n-\t\t\telse if (denorm && bbbits <= 1) {\n- undfl:\n-\t\t\t\trvb->wds = 0;\n-\t\t\t\trve = emin;\n-\t\t\t\tirv = STRTOG_Underflow | STRTOG_Inexlo;\n-\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\tadj0 = dval(&adj) = 1.;\n-\t\t\t}\n-\t\telse {\n-\t\t\tadj0 = dval(&adj) *= 0.5;\n-\t\t\tif (dsign) {\n-\t\t\t\tasub = 0;\n-\t\t\t\tinex = STRTOG_Inexlo;\n-\t\t\t\t}\n-\t\t\tif (dval(&adj) < 2147483647.) {\n-\t\t\t\tL = adj0;\n-\t\t\t\tadj0 -= L;\n-\t\t\t\tswitch(rd) {\n-\t\t\t\t  case 0:\n-\t\t\t\t\tif (adj0 >= .5)\n-\t\t\t\t\t\tgoto inc_L;\n-\t\t\t\t\tbreak;\n-\t\t\t\t  case 1:\n-\t\t\t\t\tif (asub && adj0 > 0.)\n-\t\t\t\t\t\tgoto inc_L;\n-\t\t\t\t\tbreak;\n-\t\t\t\t  case 2:\n-\t\t\t\t\tif (!asub && adj0 > 0.) {\n- inc_L:\n-\t\t\t\t\t\tL++;\n-\t\t\t\t\t\tinex = STRTOG_Inexact - inex;\n-\t\t\t\t\t\t}\n-\t\t\t\t  }\n-\t\t\t\tdval(&adj) = L;\n-\t\t\t\t}\n-\t\t\t}\n-\t\ty = rve + rvbits;\n-\n-\t\t/* adj *= ulp(dval(&rv)); */\n-\t\t/* if (asub) rv -= adj; else rv += adj; */\n-\n-\t\tif (!denorm && rvbits < nbits) {\n-\t\t\trvb = lshift(rvb, j = nbits - rvbits);\n-\t\t\trve -= j;\n-\t\t\trvbits = nbits;\n-\t\t\t}\n-\t\tab = d2b(dval(&adj), &abe, &abits);\n-\t\tif (abe < 0)\n-\t\t\trshift(ab, -abe);\n-\t\telse if (abe > 0)\n-\t\t\tab = lshift(ab, abe);\n-\t\trvb0 = rvb;\n-\t\tif (asub) {\n-\t\t\t/* rv -= adj; */\n-\t\t\tj = hi0bits(rvb->x[rvb->wds-1]);\n-\t\t\trvb = diff(rvb, ab);\n-\t\t\tk = rvb0->wds - 1;\n-\t\t\tif (denorm)\n-\t\t\t\t/* do nothing */;\n-\t\t\telse if (rvb->wds <= k\n-\t\t\t\t|| hi0bits( rvb->x[k]) >\n-\t\t\t\t   hi0bits(rvb0->x[k])) {\n-\t\t\t\t/* unlikely; can only have lost 1 high bit */\n-\t\t\t\tif (rve1 == emin) {\n-\t\t\t\t\t--rvbits;\n-\t\t\t\t\tdenorm = 1;\n-\t\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\trvb = lshift(rvb, 1);\n-\t\t\t\t\t--rve;\n-\t\t\t\t\t--rve1;\n-\t\t\t\t\tL = finished = 0;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\telse {\n-\t\t\trvb = sum(rvb, ab);\n-\t\t\tk = rvb->wds - 1;\n-\t\t\tif (k >= rvb0->wds\n-\t\t\t || hi0bits(rvb->x[k]) < hi0bits(rvb0->x[k])) {\n-\t\t\t\tif (denorm) {\n-\t\t\t\t\tif (++rvbits == nbits)\n-\t\t\t\t\t\tdenorm = 0;\n-\t\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\trshift(rvb, 1);\n-\t\t\t\t\trve++;\n-\t\t\t\t\trve1++;\n-\t\t\t\t\tL = 0;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\tBfree(ab);\n-\t\tBfree(rvb0);\n-\t\tif (finished)\n-\t\t\tbreak;\n-\n-\t\tz = rve + rvbits;\n-\t\tif (y == z && L) {\n-\t\t\t/* Can we stop now? */\n-\t\t\ttol = dval(&adj) * 5e-16; /* > max rel error */\n-\t\t\tdval(&adj) = adj0 - .5;\n-\t\t\tif (dval(&adj) < -tol) {\n-\t\t\t\tif (adj0 > tol) {\n-\t\t\t\t\tirv |= inex;\n-\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\telse if (dval(&adj) > tol && adj0 < 1. - tol) {\n-\t\t\t\tirv |= inex;\n-\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\tbb0 = denorm ? 0 : trailz(rvb);\n-\t\tBfree(bb);\n-\t\tBfree(bd);\n-\t\tBfree(bs);\n-\t\tBfree(delta);\n-\t\t}\n-\tif (!denorm && (j = nbits - rvbits)) {\n-\t\tif (j > 0)\n-\t\t\trvb = lshift(rvb, j);\n-\t\telse\n-\t\t\trshift(rvb, -j);\n-\t\trve -= j;\n-\t\t}\n-\t*exp = rve;\n-\tBfree(bb);\n-\tBfree(bd);\n-\tBfree(bs);\n-\tBfree(bd0);\n-\tBfree(delta);\n-\tif (rve > fpi->emax) {\n-\t\tswitch(fpi->rounding & 3) {\n-\t\t  case FPI_Round_near:\n-\t\t\tgoto huge;\n-\t\t  case FPI_Round_up:\n-\t\t\tif (!sign)\n-\t\t\t\tgoto huge;\n-\t\t\tbreak;\n-\t\t  case FPI_Round_down:\n-\t\t\tif (sign)\n-\t\t\t\tgoto huge;\n-\t\t  }\n-\t\t/* Round to largest representable magnitude */\n-\t\tBfree(rvb);\n-\t\trvb = 0;\n-\t\tirv = STRTOG_Normal | STRTOG_Inexlo;\n-\t\t*exp = fpi->emax;\n-\t\tb = bits;\n-\t\tbe = b + ((fpi->nbits + 31) >> 5);\n-\t\twhile(b < be)\n-\t\t\t*b++ = -1;\n-\t\tif ((j = fpi->nbits & 0x1f))\n-\t\t\t*--be >>= (32 - j);\n-\t\tgoto ret;\n- huge:\n-\t\trvb->wds = 0;\n-\t\tirv = STRTOG_Infinite | STRTOG_Overflow | STRTOG_Inexhi;\n-#ifndef NO_ERRNO\n-\t\terrno = ERANGE;\n-#endif\n- infnanexp:\n-\t\t*exp = fpi->emax + 1;\n-\t\t}\n- ret:\n-\tif (denorm) {\n-\t\tif (sudden_underflow) {\n-\t\t\trvb->wds = 0;\n-\t\t\tirv = STRTOG_Underflow | STRTOG_Inexlo;\n-#ifndef NO_ERRNO\n-\t\t\terrno = ERANGE;\n-#endif\n-\t\t\t}\n-\t\telse  {\n-\t\t\tirv = (irv & ~STRTOG_Retmask) |\n-\t\t\t\t(rvb->wds > 0 ? STRTOG_Denormal : STRTOG_Zero);\n-\t\t\tif (irv & STRTOG_Inexact) {\n-\t\t\t\tirv |= STRTOG_Underflow;\n-#ifndef NO_ERRNO\n-\t\t\t\terrno = ERANGE;\n-#endif\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\tif (se)\n-\t\t*se = (char *)s;\n-\tif (sign)\n-\t\tirv |= STRTOG_Neg;\n-\tif (rvb) {\n-\t\tcopybits(bits, nbits, rvb);\n-\t\tBfree(rvb);\n-\t\t}\n-\treturn irv;\n-\t}"}, {"sha": "6a84173a47fb79b9c863689bc31383da99791313", "filename": "libquadmath/gdtoa/strtopQ.c", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2FstrtopQ.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2FstrtopQ.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2FstrtopQ.c?ref=fa381cb2a157ab74bf8117938f3da5ba51095c2a", "patch": "@@ -1,103 +0,0 @@\n-/****************************************************************\n-\n-The author of this software is David M. Gay.\n-\n-Copyright (C) 1998, 2000 by Lucent Technologies\n-All Rights Reserved\n-\n-Permission to use, copy, modify, and distribute this software and\n-its documentation for any purpose and without fee is hereby\n-granted, provided that the above copyright notice appear in all\n-copies and that both that the copyright notice and this\n-permission notice and warranty disclaimer appear in supporting\n-documentation, and that the name of Lucent or any of its entities\n-not be used in advertising or publicity pertaining to\n-distribution of the software without specific, written prior\n-permission.\n-\n-LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n-INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n-IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n-SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n-IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n-THIS SOFTWARE.\n-\n-****************************************************************/\n-\n-/* Please send bug reports to David M. Gay (dmg at acm dot org,\n- * with \" at \" changed at \"@\" and \" dot \" changed to \".\").\t*/\n-\n-#include \"gdtoaimp.h\"\n-\n-#undef _0\n-#undef _1\n-\n-/* one or the other of IEEE_MC68k or IEEE_8087 should be #defined */\n-\n-#ifdef IEEE_MC68k\n-#define _0 0\n-#define _1 1\n-#define _2 2\n-#define _3 3\n-#endif\n-#ifdef IEEE_8087\n-#define _0 3\n-#define _1 2\n-#define _2 1\n-#define _3 0\n-#endif\n-\n-__float128\n-strtoflt128(CONST char *s, char **sp)\n-{\n-\tstatic FPI fpi0 = { 113, 1-16383-113+1, 32766 - 16383 - 113 + 1, 1, SI };\n-\tULong bits[4];\n-\tLong exp;\n-\tint k;\n-\tunion { __float128 f; ULong L[4]; } u;\n-\tULong *L = &u.L[0];\n-#ifdef Honor_FLT_ROUNDS\n-#include \"gdtoa_fltrnds.h\"\n-#else\n-#define fpi &fpi0\n-#endif\n-\n-\tk = strtodg(s, sp, fpi, &exp, bits);\n-\tswitch(k & STRTOG_Retmask) {\n-\t  case STRTOG_NoNumber:\n-\t  case STRTOG_Zero:\n-\t\tL[0] = L[1] = L[2] = L[3] = 0;\n-\t\tbreak;\n-\n-\t  case STRTOG_Normal:\n-\t  case STRTOG_NaNbits:\n-\t\tL[_3] = bits[0];\n-\t\tL[_2] = bits[1];\n-\t\tL[_1] = bits[2];\n-\t\tL[_0] = (bits[3] & ~0x10000) | ((exp + 0x3fff + 112) << 16);\n-\t\tbreak;\n-\n-\t  case STRTOG_Denormal:\n-\t\tL[_3] = bits[0];\n-\t\tL[_2] = bits[1];\n-\t\tL[_1] = bits[2];\n-\t\tL[_0] = bits[3];\n-\t\tbreak;\n-\n-\t  case STRTOG_Infinite:\n-\t\tL[_0] = 0x7fff0000;\n-\t\tL[_1] = L[_2] = L[_3] = 0;\n-\t\tbreak;\n-\n-\t  case STRTOG_NaN:\n-\t\tL[_0] = ld_QNAN3;\n-\t\tL[_1] = ld_QNAN2;\n-\t\tL[_2] = ld_QNAN1;\n-\t\tL[_3] = ld_QNAN0;\n-\t  }\n-\tif (k & STRTOG_Neg)\n-\t\tL[_0] |= 0x80000000L;\n-\treturn u.f;\n-}"}, {"sha": "dc0c88bcfab85f022a52a99da024a61cadddceca", "filename": "libquadmath/gdtoa/sum.c", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fsum.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa381cb2a157ab74bf8117938f3da5ba51095c2a/libquadmath%2Fgdtoa%2Fsum.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fsum.c?ref=fa381cb2a157ab74bf8117938f3da5ba51095c2a", "patch": "@@ -1,98 +0,0 @@\n-/****************************************************************\n-\n-The author of this software is David M. Gay.\n-\n-Copyright (C) 1998 by Lucent Technologies\n-All Rights Reserved\n-\n-Permission to use, copy, modify, and distribute this software and\n-its documentation for any purpose and without fee is hereby\n-granted, provided that the above copyright notice appear in all\n-copies and that both that the copyright notice and this\n-permission notice and warranty disclaimer appear in supporting\n-documentation, and that the name of Lucent or any of its entities\n-not be used in advertising or publicity pertaining to\n-distribution of the software without specific, written prior\n-permission.\n-\n-LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n-INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n-IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n-SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n-IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n-THIS SOFTWARE.\n-\n-****************************************************************/\n-\n-/* Please send bug reports to David M. Gay (dmg at acm dot org,\n- * with \" at \" changed at \"@\" and \" dot \" changed to \".\").\t*/\n-\n-#include \"gdtoaimp.h\"\n-\n- Bigint *\n-#ifdef KR_headers\n-sum(a, b) Bigint *a; Bigint *b;\n-#else\n-sum(Bigint *a, Bigint *b)\n-#endif\n-{\n-\tBigint *c;\n-\tULong carry, *xc, *xa, *xb, *xe, y;\n-#ifdef Pack_32\n-\tULong z;\n-#endif\n-\n-\tif (a->wds < b->wds) {\n-\t\tc = b; b = a; a = c;\n-\t\t}\n-\tc = Balloc(a->k);\n-\tc->wds = a->wds;\n-\tcarry = 0;\n-\txa = a->x;\n-\txb = b->x;\n-\txc = c->x;\n-\txe = xc + b->wds;\n-#ifdef Pack_32\n-\tdo {\n-\t\ty = (*xa & 0xffff) + (*xb & 0xffff) + carry;\n-\t\tcarry = (y & 0x10000) >> 16;\n-\t\tz = (*xa++ >> 16) + (*xb++ >> 16) + carry;\n-\t\tcarry = (z & 0x10000) >> 16;\n-\t\tStoreinc(xc, z, y);\n-\t\t}\n-\t\twhile(xc < xe);\n-\txe += a->wds - b->wds;\n-\twhile(xc < xe) {\n-\t\ty = (*xa & 0xffff) + carry;\n-\t\tcarry = (y & 0x10000) >> 16;\n-\t\tz = (*xa++ >> 16) + carry;\n-\t\tcarry = (z & 0x10000) >> 16;\n-\t\tStoreinc(xc, z, y);\n-\t\t}\n-#else\n-\tdo {\n-\t\ty = *xa++ + *xb++ + carry;\n-\t\tcarry = (y & 0x10000) >> 16;\n-\t\t*xc++ = y & 0xffff;\n-\t\t}\n-\t\twhile(xc < xe);\n-\txe += a->wds - b->wds;\n-\twhile(xc < xe) {\n-\t\ty = *xa++ + carry;\n-\t\tcarry = (y & 0x10000) >> 16;\n-\t\t*xc++ = y & 0xffff;\n-\t\t}\n-#endif\n-\tif (carry) {\n-\t\tif (c->wds == c->maxwds) {\n-\t\t\tb = Balloc(c->k + 1);\n-\t\t\tBcopy(b, c);\n-\t\t\tBfree(c);\n-\t\t\tc = b;\n-\t\t\t}\n-\t\tc->x[c->wds++] = 1;\n-\t\t}\n-\treturn c;\n-\t}"}, {"sha": "f2557c8e61ac840b407f5360401d19ed13ed9e59", "filename": "libquadmath/libquadmath.texi", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Flibquadmath.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Flibquadmath.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Flibquadmath.texi?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -109,6 +109,9 @@ The following macros are defined, which give the numeric limits of the\n @item @code{FLT128_MANT_DIG}: number of digits in the mantissa (bit precision)\n @item @code{FLT128_MIN_EXP}: maximal negative exponent\n @item @code{FLT128_MAX_EXP}: maximal positive exponent\n+@item @code{FLT128_DIG}: number of decimal digits in the mantissa\n+@item @code{FLT128_MIN_10_EXP}: maximal negative decimal exponent\n+@item @code{FLT128_MAX_10_EXP}: maximal positive decimal exponent\n @end table\n \n The following mathematical constants of type @code{__float128} are defined.\n@@ -260,10 +263,6 @@ The function @code{dmath_strtopQ} converts a string into a\n @item Syntax\n @code{__float128 strtoflt128 (const char *s, char **sp)}\n \n-@c The return values are defined in gdtoa/gdtoa.h STRTOG_*\n-@c However, the values are currently not exported - thus we\n-@c do not define them here, either.\n-\n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{s}  @tab input string"}, {"sha": "749cf3ee8ad346723689219fecaaab64ce313867", "filename": "libquadmath/printf/add_n.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fadd_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fadd_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fadd_n.c?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -19,6 +19,7 @@ along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n MA 02111-1307, USA. */\n \n+#include <config.h>\n #include \"gmp-impl.h\"\n \n mp_limb_t"}, {"sha": "f527f98483938cb526e350ce2022cdb92cb30285", "filename": "libquadmath/printf/addmul_1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Faddmul_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Faddmul_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Faddmul_1.c?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -22,6 +22,7 @@ along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n MA 02111-1307, USA. */\n \n+#include <config.h>\n #include \"gmp-impl.h\"\n \n mp_limb_t"}, {"sha": "a4be43e2a174f761430ba503688bb233a8c63abc", "filename": "libquadmath/printf/cmp.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fcmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fcmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fcmp.c?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -19,6 +19,7 @@ along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n MA 02111-1307, USA. */\n \n+#include <config.h>\n #include \"gmp-impl.h\"\n \n /* Compare OP1_PTR/OP1_SIZE with OP2_PTR/OP2_SIZE."}, {"sha": "944d1a0c08c081ded89970e7b7ece73974321f39", "filename": "libquadmath/printf/divrem.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fdivrem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fdivrem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fdivrem.c?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -20,6 +20,7 @@ along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n MA 02111-1307, USA. */\n \n+#include <config.h>\n #include \"gmp-impl.h\"\n \n /* Divide num (NP/NSIZE) by den (DP/DSIZE) and write"}, {"sha": "8c67e6f904f3b485750473ef3ba041e082a07ff3", "filename": "libquadmath/printf/fpioconst.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Ffpioconst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Ffpioconst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Ffpioconst.c?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -18,6 +18,7 @@\n    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n    02111-1307 USA.  */\n \n+#include <config.h>\n #include \"gmp-impl.h\"\t\t/* This defines BITS_PER_MP_LIMB.  */\n #include \"fpioconst.h\"\n "}, {"sha": "ca49e19661366f1e35cc4bc00ccc9a4f87030a2f", "filename": "libquadmath/printf/gmp-impl.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fgmp-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fgmp-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fgmp-impl.h?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -140,6 +140,10 @@ mp_limb_t mpn_submul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)\n mp_size_t mpn_extract_flt128 (mp_ptr res_ptr, mp_size_t size, int *expt,\n \t\t\t      int *is_neg, __float128 value) attribute_hidden;\n \n+#define mpn_construct_float128 __MPN(construct_float128)\n+__float128 mpn_construct_float128 (mp_srcptr frac_ptr, int expt, int sign)\n+     attribute_hidden;\n+\n #define mpn_divmod(qp,np,nsize,dp,dsize) mpn_divrem (qp,0,np,nsize,dp,dsize)\n \n static inline mp_limb_t"}, {"sha": "58aa8d4649f64ceb17c23523be03417900e196dc", "filename": "libquadmath/printf/lshift.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Flshift.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Flshift.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Flshift.c?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -19,6 +19,7 @@ along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n MA 02111-1307, USA. */\n \n+#include <config.h>\n #include \"gmp-impl.h\"\n \n /* Shift U (pointed to by UP and USIZE digits long) CNT bits to the left"}, {"sha": "d31fa36fa98eb7477ef968d0e9654e43d0136957", "filename": "libquadmath/printf/mul.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fmul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fmul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fmul.c?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -19,6 +19,7 @@ along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n MA 02111-1307, USA. */\n \n+#include <config.h>\n #include \"gmp-impl.h\"\n \n /* Multiply the natural numbers u (pointed to by UP, with USIZE limbs)"}, {"sha": "48a273f075bd7a20f577e91f30c9719891e733a7", "filename": "libquadmath/printf/mul_1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fmul_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fmul_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fmul_1.c?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -20,6 +20,7 @@ along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n MA 02111-1307, USA. */\n \n+#include <config.h>\n #include \"gmp-impl.h\"\n \n mp_limb_t"}, {"sha": "c4bc1bed28fad2832a1235b784c535cd9cded70c", "filename": "libquadmath/printf/mul_n.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fmul_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fmul_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fmul_n.c?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -19,6 +19,7 @@ along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n MA 02111-1307, USA. */\n \n+#include <config.h>\n #include \"gmp-impl.h\"\n \n /* Multiply the natural numbers u (pointed to by UP) and v (pointed to by VP),"}, {"sha": "9e574c1eccc3221a87b18a4dd23b53ebd5c41810", "filename": "libquadmath/printf/quadmath-printf.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fquadmath-printf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fquadmath-printf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fquadmath-printf.h?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -62,10 +62,20 @@ Boston, MA 02110-1301, USA.  */\n /* Won't work for EBCDIC.  */\n #undef isupper\n #undef isdigit\n+#undef isxdigit\n #undef tolower\n-#define isupper(x) ((x) >= 'A' && (x) <= 'Z')\n-#define isdigit(x) ((x) >= '0' && (x) <= '9')\n-#define tolower(x) (isupper (x) ? (x) - 'A' + 'a' : (x))\n+#define isupper(x) \\\n+  ({__typeof(x) __is_x = (x); __is_x >= 'A' && __is_x <= 'Z'; })\n+#define isdigit(x) \\\n+  ({__typeof(x) __is_x = (x); __is_x >= '0' && __is_x <= '9'; })\n+#define isxdigit(x) \\\n+  ({__typeof(x) __is_x = (x); \\\n+    (__is_x >= '0' && __is_x <= '9') \\\n+    || ((x) >= 'A' && (x) <= 'F') \\\n+    || ((x) >= 'a' && (x) <= 'f'); })\n+#define tolower(x) \\\n+  ({__typeof(x) __is_x = (x); \\\n+    (__is_x >= 'A' && __is_x <= 'Z') ? __is_x - 'A' + 'a' : __is_x; })\n #endif\n \n #ifndef CHAR_MAX"}, {"sha": "17fd914d9d0299bb021339232dda91002aadb998", "filename": "libquadmath/printf/rshift.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Frshift.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Frshift.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Frshift.c?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -19,6 +19,7 @@ along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n MA 02111-1307, USA. */\n \n+#include <config.h>\n #include \"gmp-impl.h\"\n \n /* Shift U (pointed to by UP and USIZE limbs long) CNT bits to the right"}, {"sha": "92e7187313ba8200d78b154e2f38ed83b5782ded", "filename": "libquadmath/printf/sub_n.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fsub_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fsub_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fsub_n.c?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -19,6 +19,7 @@ along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n MA 02111-1307, USA. */\n \n+#include <config.h>\n #include \"gmp-impl.h\"\n \n mp_limb_t"}, {"sha": "31903c6284e85e0fc9109b7d54bc695c5a795047", "filename": "libquadmath/printf/submul_1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fsubmul_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fprintf%2Fsubmul_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fsubmul_1.c?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -22,6 +22,7 @@ along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n MA 02111-1307, USA. */\n \n+#include <config.h>\n #include \"gmp-impl.h\"\n \n mp_limb_t"}, {"sha": "863fe440b23040b204d47ff5ddee444a2476b25a", "filename": "libquadmath/quadmath.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fquadmath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fquadmath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fquadmath.h?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -144,8 +144,9 @@ extern int quadmath_snprintf (char *str, size_t size,\n #define FLT128_MANT_DIG 113\n #define FLT128_MIN_EXP (-16381)\n #define FLT128_MAX_EXP 16384\n-/* TODO -- One day, we need to add the following macros:\n-   FLT128_DIG, FLT128_MIN_10_EXP, FLT128_MAX_10_EXP */\n+#define FLT128_DIG 33\n+#define FLT128_MIN_10_EXP (-4931)\n+#define FLT128_MAX_10_EXP 4932\n \n \n #define HUGE_VALQ __builtin_huge_valq()"}, {"sha": "a1660871254bff60a078489cc08c60182a23b17a", "filename": "libquadmath/strtod/grouping.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fstrtod%2Fgrouping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fstrtod%2Fgrouping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fstrtod%2Fgrouping.h?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -0,0 +1,37 @@\n+/* Internal header for proving correct grouping in strings of numbers.\n+   Copyright (C) 1995,1996,1997,1998,2000,2003 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.  */\n+\n+/* Find the maximum prefix of the string between BEGIN and END which\n+   satisfies the grouping rules.  It is assumed that at least one digit\n+   follows BEGIN directly.  */\n+extern const wchar_t *__correctly_grouped_prefixwc (const wchar_t *begin,\n+\t\t\t\t\t\t    const wchar_t *end,\n+\t\t\t\t\t\t    wchar_t thousands,\n+\t\t\t\t\t\t    const char *grouping)\n+     attribute_hidden;\n+\n+extern const char *__correctly_grouped_prefixmb (const char *begin,\n+\t\t\t\t\t\t const char *end,\n+\t\t\t\t\t\t const char *thousands,\n+\t\t\t\t\t\t const char *grouping)\n+     attribute_hidden;\n+\n+/* Disable grouping support for now.  */\n+#define __correctly_grouped_prefixmb(b,e,t,g) e"}, {"sha": "844ae97d834ff2ab9c87f1dfb9764d95c2d3f555", "filename": "libquadmath/strtod/mpn2flt128.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fstrtod%2Fmpn2flt128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fstrtod%2Fmpn2flt128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fstrtod%2Fmpn2flt128.c?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -0,0 +1,51 @@\n+/* Copyright (C) 1995,1996,1997,1998,1999,2002,2003\n+\tFree Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.  */\n+\n+#include <config.h>\n+#include <float.h>\n+#include <math.h>\n+#include \"../printf/gmp-impl.h\"\n+\n+/* Convert a multi-precision integer of the needed number of bits (113 for\n+   long double) and an integral power of two to a `long double' in IEEE854\n+   quad-precision format.  */\n+\n+__float128\n+mpn_construct_float128 (mp_srcptr frac_ptr, int expt, int sign)\n+{\n+  ieee854_float128 u;\n+\n+  u.ieee.negative = sign;\n+  u.ieee.exponent = expt + IEEE854_FLOAT128_BIAS;\n+#if BITS_PER_MP_LIMB == 32\n+  u.ieee.mant_low = (((uint64_t) frac_ptr[1]) << 32)\n+\t\t    | (frac_ptr[0] & 0xffffffff);\n+  u.ieee.mant_high = (((uint64_t) frac_ptr[3]\n+\t\t       & (((mp_limb_t) 1 << (FLT128_MANT_DIG - 96)) - 1))\n+\t\t      << 32) | (frac_ptr[2] & 0xffffffff);\n+#elif BITS_PER_MP_LIMB == 64\n+  u.ieee.mant_low = frac_ptr[0];\n+  u.ieee.mant_high = frac_ptr[1]\n+\t\t     & (((mp_limb_t) 1 << (FLT128_MANT_DIG - 64)) - 1);\n+#else\n+  #error \"mp_limb size \" BITS_PER_MP_LIMB \"not accounted for\"\n+#endif\n+\n+  return u.value;\n+}"}, {"sha": "a3df5e2bae87ca7f682cad4cc0abc894d185f137", "filename": "libquadmath/strtod/strtod_l.c", "status": "added", "additions": 1571, "deletions": 0, "changes": 1571, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fstrtod%2Fstrtod_l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fstrtod%2Fstrtod_l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fstrtod%2Fstrtod_l.c?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -0,0 +1,1571 @@\n+/* Convert string representing a number to float value, using given locale.\n+   Copyright (C) 1997,1998,2002,2004,2005,2006,2007,2008,2009,2010\n+   Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.  */\n+\n+#include <config.h>\n+#include <stdarg.h>\n+#include <string.h>\n+#include <float.h>\n+#include <math.h>\n+#define NDEBUG 1\n+#include <assert.h>\n+#ifdef HAVE_ERRNO_H\n+#include <errno.h>\n+#endif\n+#include \"../printf/quadmath-printf.h\"\n+#include \"../printf/fpioconst.h\"\n+\n+\n+#undef L_\n+#ifdef USE_WIDE_CHAR\n+# define STRING_TYPE wchar_t\n+# define CHAR_TYPE wint_t\n+# define L_(Ch) L##Ch\n+# define ISSPACE(Ch) __iswspace_l ((Ch), loc)\n+# define ISDIGIT(Ch) __iswdigit_l ((Ch), loc)\n+# define ISXDIGIT(Ch) __iswxdigit_l ((Ch), loc)\n+# define TOLOWER(Ch) __towlower_l ((Ch), loc)\n+# define TOLOWER_C(Ch) __towlower_l ((Ch), _nl_C_locobj_ptr)\n+# define STRNCASECMP(S1, S2, N) \\\n+  __wcsncasecmp_l ((S1), (S2), (N), _nl_C_locobj_ptr)\n+# define STRTOULL(S, E, B) ____wcstoull_l_internal ((S), (E), (B), 0, loc)\n+#else\n+# define STRING_TYPE char\n+# define CHAR_TYPE char\n+# define L_(Ch) Ch\n+# define ISSPACE(Ch) isspace (Ch)\n+# define ISDIGIT(Ch) isdigit (Ch)\n+# define ISXDIGIT(Ch) isxdigit (Ch)\n+# define TOLOWER(Ch) tolower (Ch)\n+# define TOLOWER_C(Ch) \\\n+  ({__typeof(Ch) __tlc = (Ch); \\\n+    (__tlc >= 'A' && __tlc <= 'Z') ? __tlc - 'A' + 'a' : __tlc; })\n+# define STRNCASECMP(S1, S2, N) \\\n+  __quadmath_strncasecmp_c (S1, S2, N)\n+# ifdef HAVE_STRTOULL\n+#  define STRTOULL(S, E, B) strtoull (S, E, B)\n+# else\n+#  define STRTOULL(S, E, B) strtoul (S, E, B)\n+# endif\n+\n+static inline int\n+__quadmath_strncasecmp_c (const char *s1, const char *s2, size_t n)\n+{\n+  const unsigned char *p1 = (const unsigned char *) s1;\n+  const unsigned char *p2 = (const unsigned char *) s2;\n+  int result;\n+  if (p1 == p2 || n == 0)\n+    return 0;\n+  while ((result = TOLOWER_C (*p1) - TOLOWER_C (*p2++)) == 0)\n+    if (*p1++ == '\\0' || --n == 0)\n+      break;\n+\n+  return result;\n+}\n+#endif\n+\n+\n+/* Constants we need from float.h; select the set for the FLOAT precision.  */\n+#define MANT_DIG\tPASTE(FLT,_MANT_DIG)\n+#define\tDIG\t\tPASTE(FLT,_DIG)\n+#define\tMAX_EXP\t\tPASTE(FLT,_MAX_EXP)\n+#define\tMIN_EXP\t\tPASTE(FLT,_MIN_EXP)\n+#define MAX_10_EXP\tPASTE(FLT,_MAX_10_EXP)\n+#define MIN_10_EXP\tPASTE(FLT,_MIN_10_EXP)\n+\n+/* Extra macros required to get FLT expanded before the pasting.  */\n+#define PASTE(a,b)\tPASTE1(a,b)\n+#define PASTE1(a,b)\ta##b\n+\n+/* Function to construct a floating point number from an MP integer\n+   containing the fraction bits, a base 2 exponent, and a sign flag.  */\n+extern FLOAT MPN2FLOAT (mp_srcptr mpn, int exponent, int negative);\n+\f\n+/* Definitions according to limb size used.  */\n+#if\tBITS_PER_MP_LIMB == 32\n+# define MAX_DIG_PER_LIMB\t9\n+# define MAX_FAC_PER_LIMB\t1000000000UL\n+#elif\tBITS_PER_MP_LIMB == 64\n+# define MAX_DIG_PER_LIMB\t19\n+# define MAX_FAC_PER_LIMB\t10000000000000000000ULL\n+#else\n+# error \"mp_limb_t size \" BITS_PER_MP_LIMB \"not accounted for\"\n+#endif\n+\n+#define _tens_in_limb __quadmath_tens_in_limb\n+extern const mp_limb_t _tens_in_limb[MAX_DIG_PER_LIMB + 1] attribute_hidden;\n+\f\n+#ifndef\thowmany\n+#define\thowmany(x,y)\t\t(((x)+((y)-1))/(y))\n+#endif\n+#define SWAP(x, y)\t\t({ typeof(x) _tmp = x; x = y; y = _tmp; })\n+\n+#define NDIG\t\t\t(MAX_10_EXP - MIN_10_EXP + 2 * MANT_DIG)\n+#define HEXNDIG\t\t\t((MAX_EXP - MIN_EXP + 7) / 8 + 2 * MANT_DIG)\n+#define\tRETURN_LIMB_SIZE\t\thowmany (MANT_DIG, BITS_PER_MP_LIMB)\n+\n+#define RETURN(val,end)\t\t\t\t\t\t\t      \\\n+    do { if (endptr != NULL) *endptr = (STRING_TYPE *) (end);\t\t      \\\n+\t return val; } while (0)\n+\n+/* Maximum size necessary for mpn integers to hold floating point numbers.  */\n+#define\tMPNSIZE\t\t(howmany (MAX_EXP + 2 * MANT_DIG, BITS_PER_MP_LIMB) \\\n+\t\t\t + 2)\n+/* Declare an mpn integer variable that big.  */\n+#define\tMPN_VAR(name)\tmp_limb_t name[MPNSIZE]; mp_size_t name##size\n+/* Copy an mpn integer value.  */\n+#define MPN_ASSIGN(dst, src) \\\n+\tmemcpy (dst, src, (dst##size = src##size) * sizeof (mp_limb_t))\n+\n+\n+/* Return a floating point number of the needed type according to the given\n+   multi-precision number after possible rounding.  */\n+static FLOAT\n+round_and_return (mp_limb_t *retval, int exponent, int negative,\n+\t\t  mp_limb_t round_limb, mp_size_t round_bit, int more_bits)\n+{\n+  if (exponent < MIN_EXP - 1)\n+    {\n+      mp_size_t shift = MIN_EXP - 1 - exponent;\n+\n+      if (shift > MANT_DIG)\n+\t{\n+#if defined HAVE_ERRNO_H && defined EDOM\n+\t  errno = EDOM;\n+#endif\n+\t  return 0.0;\n+\t}\n+\n+      more_bits |= (round_limb & ((((mp_limb_t) 1) << round_bit) - 1)) != 0;\n+      if (shift == MANT_DIG)\n+\t/* This is a special case to handle the very seldom case where\n+\t   the mantissa will be empty after the shift.  */\n+\t{\n+\t  int i;\n+\n+\t  round_limb = retval[RETURN_LIMB_SIZE - 1];\n+\t  round_bit = (MANT_DIG - 1) % BITS_PER_MP_LIMB;\n+\t  for (i = 0; i < RETURN_LIMB_SIZE; ++i)\n+\t    more_bits |= retval[i] != 0;\n+\t  MPN_ZERO (retval, RETURN_LIMB_SIZE);\n+\t}\n+      else if (shift >= BITS_PER_MP_LIMB)\n+\t{\n+\t  int i;\n+\n+\t  round_limb = retval[(shift - 1) / BITS_PER_MP_LIMB];\n+\t  round_bit = (shift - 1) % BITS_PER_MP_LIMB;\n+\t  for (i = 0; i < (shift - 1) / BITS_PER_MP_LIMB; ++i)\n+\t    more_bits |= retval[i] != 0;\n+\t  more_bits |= ((round_limb & ((((mp_limb_t) 1) << round_bit) - 1))\n+\t\t\t!= 0);\n+\n+\t  (void) mpn_rshift (retval, &retval[shift / BITS_PER_MP_LIMB],\n+\t\t\t     RETURN_LIMB_SIZE - (shift / BITS_PER_MP_LIMB),\n+\t\t\t     shift % BITS_PER_MP_LIMB);\n+\t  MPN_ZERO (&retval[RETURN_LIMB_SIZE - (shift / BITS_PER_MP_LIMB)],\n+\t\t    shift / BITS_PER_MP_LIMB);\n+\t}\n+      else if (shift > 0)\n+\t{\n+\t  round_limb = retval[0];\n+\t  round_bit = shift - 1;\n+\t  (void) mpn_rshift (retval, retval, RETURN_LIMB_SIZE, shift);\n+\t}\n+      /* This is a hook for the m68k long double format, where the\n+\t exponent bias is the same for normalized and denormalized\n+\t numbers.  */\n+#ifndef DENORM_EXP\n+# define DENORM_EXP (MIN_EXP - 2)\n+#endif\n+      exponent = DENORM_EXP;\n+#if defined HAVE_ERRNO_H && defined ERANGE\n+      errno = ERANGE;\n+#endif\n+    }\n+\n+  if ((round_limb & (((mp_limb_t) 1) << round_bit)) != 0\n+      && (more_bits || (retval[0] & 1) != 0\n+\t  || (round_limb & ((((mp_limb_t) 1) << round_bit) - 1)) != 0))\n+    {\n+      mp_limb_t cy = mpn_add_1 (retval, retval, RETURN_LIMB_SIZE, 1);\n+\n+      if (((MANT_DIG % BITS_PER_MP_LIMB) == 0 && cy) ||\n+\t  ((MANT_DIG % BITS_PER_MP_LIMB) != 0 &&\n+\t   (retval[RETURN_LIMB_SIZE - 1]\n+\t    & (((mp_limb_t) 1) << (MANT_DIG % BITS_PER_MP_LIMB))) != 0))\n+\t{\n+\t  ++exponent;\n+\t  (void) mpn_rshift (retval, retval, RETURN_LIMB_SIZE, 1);\n+\t  retval[RETURN_LIMB_SIZE - 1]\n+\t    |= ((mp_limb_t) 1) << ((MANT_DIG - 1) % BITS_PER_MP_LIMB);\n+\t}\n+      else if (exponent == DENORM_EXP\n+\t       && (retval[RETURN_LIMB_SIZE - 1]\n+\t\t   & (((mp_limb_t) 1) << ((MANT_DIG - 1) % BITS_PER_MP_LIMB)))\n+\t       != 0)\n+\t  /* The number was denormalized but now normalized.  */\n+\texponent = MIN_EXP - 1;\n+    }\n+\n+  if (exponent > MAX_EXP)\n+    return negative ? -FLOAT_HUGE_VAL : FLOAT_HUGE_VAL;\n+\n+  return MPN2FLOAT (retval, exponent, negative);\n+}\n+\n+\n+/* Read a multi-precision integer starting at STR with exactly DIGCNT digits\n+   into N.  Return the size of the number limbs in NSIZE at the first\n+   character od the string that is not part of the integer as the function\n+   value.  If the EXPONENT is small enough to be taken as an additional\n+   factor for the resulting number (see code) multiply by it.  */\n+static const STRING_TYPE *\n+str_to_mpn (const STRING_TYPE *str, int digcnt, mp_limb_t *n, mp_size_t *nsize,\n+\t    int *exponent\n+#ifndef USE_WIDE_CHAR\n+\t    , const char *decimal, size_t decimal_len, const char *thousands\n+#endif\n+\n+\t    )\n+{\n+  /* Number of digits for actual limb.  */\n+  int cnt = 0;\n+  mp_limb_t low = 0;\n+  mp_limb_t start;\n+\n+  *nsize = 0;\n+  assert (digcnt > 0);\n+  do\n+    {\n+      if (cnt == MAX_DIG_PER_LIMB)\n+\t{\n+\t  if (*nsize == 0)\n+\t    {\n+\t      n[0] = low;\n+\t      *nsize = 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      mp_limb_t cy;\n+\t      cy = mpn_mul_1 (n, n, *nsize, MAX_FAC_PER_LIMB);\n+\t      cy += mpn_add_1 (n, n, *nsize, low);\n+\t      if (cy != 0)\n+\t\t{\n+\t\t  n[*nsize] = cy;\n+\t\t  ++(*nsize);\n+\t\t}\n+\t    }\n+\t  cnt = 0;\n+\t  low = 0;\n+\t}\n+\n+      /* There might be thousands separators or radix characters in\n+\t the string.  But these all can be ignored because we know the\n+\t format of the number is correct and we have an exact number\n+\t of characters to read.  */\n+#ifdef USE_WIDE_CHAR\n+      if (*str < L'0' || *str > L'9')\n+\t++str;\n+#else\n+      if (*str < '0' || *str > '9')\n+\t{\n+\t  int inner = 0;\n+\t  if (thousands != NULL && *str == *thousands\n+\t      && ({ for (inner = 1; thousands[inner] != '\\0'; ++inner)\n+\t\t      if (thousands[inner] != str[inner])\n+\t\t\tbreak;\n+\t\t    thousands[inner] == '\\0'; }))\n+\t    str += inner;\n+\t  else\n+\t    str += decimal_len;\n+\t}\n+#endif\n+      low = low * 10 + *str++ - L_('0');\n+      ++cnt;\n+    }\n+  while (--digcnt > 0);\n+\n+  if (*exponent > 0 && cnt + *exponent <= MAX_DIG_PER_LIMB)\n+    {\n+      low *= _tens_in_limb[*exponent];\n+      start = _tens_in_limb[cnt + *exponent];\n+      *exponent = 0;\n+    }\n+  else\n+    start = _tens_in_limb[cnt];\n+\n+  if (*nsize == 0)\n+    {\n+      n[0] = low;\n+      *nsize = 1;\n+    }\n+  else\n+    {\n+      mp_limb_t cy;\n+      cy = mpn_mul_1 (n, n, *nsize, start);\n+      cy += mpn_add_1 (n, n, *nsize, low);\n+      if (cy != 0)\n+\tn[(*nsize)++] = cy;\n+    }\n+\n+  return str;\n+}\n+\n+\n+/* Shift {PTR, SIZE} COUNT bits to the left, and fill the vacated bits\n+   with the COUNT most significant bits of LIMB.\n+\n+   Tege doesn't like this function so I have to write it here myself. :)\n+   --drepper */\n+static inline void\n+__attribute ((always_inline))\n+mpn_lshift_1 (mp_limb_t *ptr, mp_size_t size, unsigned int count,\n+\t      mp_limb_t limb)\n+{\n+  if (__builtin_constant_p (count) && count == BITS_PER_MP_LIMB)\n+    {\n+      /* Optimize the case of shifting by exactly a word:\n+\t just copy words, with no actual bit-shifting.  */\n+      mp_size_t i;\n+      for (i = size - 1; i > 0; --i)\n+\tptr[i] = ptr[i - 1];\n+      ptr[0] = limb;\n+    }\n+  else\n+    {\n+      (void) mpn_lshift (ptr, ptr, size, count);\n+      ptr[0] |= limb >> (BITS_PER_MP_LIMB - count);\n+    }\n+}\n+\n+\n+#define INTERNAL(x) INTERNAL1(x)\n+#define INTERNAL1(x) __##x##_internal\n+#ifndef ____STRTOF_INTERNAL\n+# define ____STRTOF_INTERNAL INTERNAL (__STRTOF)\n+#endif\n+\n+/* This file defines a function to check for correct grouping.  */\n+#include \"grouping.h\"\n+\n+\n+/* Return a floating point number with the value of the given string NPTR.\n+   Set *ENDPTR to the character after the last used one.  If the number is\n+   smaller than the smallest representable number, set `errno' to ERANGE and\n+   return 0.0.  If the number is too big to be represented, set `errno' to\n+   ERANGE and return HUGE_VAL with the appropriate sign.  */\n+FLOAT\n+____STRTOF_INTERNAL (nptr, endptr, group)\n+     const STRING_TYPE *nptr;\n+     STRING_TYPE **endptr;\n+     int group;\n+{\n+  int negative;\t\t\t/* The sign of the number.  */\n+  MPN_VAR (num);\t\t/* MP representation of the number.  */\n+  int exponent;\t\t\t/* Exponent of the number.  */\n+\n+  /* Numbers starting `0X' or `0x' have to be processed with base 16.  */\n+  int base = 10;\n+\n+  /* When we have to compute fractional digits we form a fraction with a\n+     second multi-precision number (and we sometimes need a second for\n+     temporary results).  */\n+  MPN_VAR (den);\n+\n+  /* Representation for the return value.  */\n+  mp_limb_t retval[RETURN_LIMB_SIZE];\n+  /* Number of bits currently in result value.  */\n+  int bits;\n+\n+  /* Running pointer after the last character processed in the string.  */\n+  const STRING_TYPE *cp, *tp;\n+  /* Start of significant part of the number.  */\n+  const STRING_TYPE *startp, *start_of_digits;\n+  /* Points at the character following the integer and fractional digits.  */\n+  const STRING_TYPE *expp;\n+  /* Total number of digit and number of digits in integer part.  */\n+  int dig_no, int_no, lead_zero;\n+  /* Contains the last character read.  */\n+  CHAR_TYPE c;\n+\n+  /* The radix character of the current locale.  */\n+#ifdef USE_WIDE_CHAR\n+  wchar_t decimal;\n+#else\n+  const char *decimal;\n+  size_t decimal_len;\n+#endif\n+  /* The thousands character of the current locale.  */\n+#ifdef USE_WIDE_CHAR\n+  wchar_t thousands = L'\\0';\n+#else\n+  const char *thousands = NULL;\n+#endif\n+  /* The numeric grouping specification of the current locale,\n+     in the format described in <locale.h>.  */\n+  const char *grouping;\n+  /* Used in several places.  */\n+  int cnt;\n+\n+#if defined USE_LOCALECONV && !defined USE_NL_LANGINFO\n+  const struct lconv *lc = localeconv ();\n+#endif\n+\n+  if (__builtin_expect (group, 0))\n+    {\n+#ifdef USE_NL_LANGINFO\n+      grouping = nl_langinfo (GROUPING);\n+      if (*grouping <= 0 || *grouping == CHAR_MAX)\n+\tgrouping = NULL;\n+      else\n+\t{\n+\t  /* Figure out the thousands separator character.  */\n+#ifdef USE_WIDE_CHAR\n+\t  thousands = nl_langinfo_wc (_NL_NUMERIC_THOUSANDS_SEP_WC);\n+\t  if (thousands == L'\\0')\n+\t    grouping = NULL;\n+#else\n+\t  thousands = nl_langinfo (THOUSANDS_SEP);\n+\t  if (*thousands == '\\0')\n+\t    {\n+\t      thousands = NULL;\n+\t      grouping = NULL;\n+\t    }\n+#endif\n+\t}\n+#elif defined USE_LOCALECONV\n+      grouping = lc->grouping;\n+      if (grouping == NULL || *grouping <= 0 || *grouping == CHAR_MAX)\n+\tgrouping = NULL;\n+      else\n+\t{\n+\t  /* Figure out the thousands separator character.  */\n+\t  thousands = lc->thousands_sep;\n+\t  if (thousands == NULL || *thousands == '\\0')\n+\t    {\n+\t      thousands = NULL;\n+\t      grouping = NULL;\n+\t    }\n+\t}\n+#else\n+      grouping = NULL;\n+#endif\n+    }\n+  else\n+    grouping = NULL;\n+\n+  /* Find the locale's decimal point character.  */\n+#ifdef USE_WIDE_CHAR\n+  decimal = nl_langinfo_wc (_NL_NUMERIC_DECIMAL_POINT_WC);\n+  assert (decimal != L'\\0');\n+# define decimal_len 1\n+#else\n+#ifdef USE_NL_LANGINFO\n+  decimal = nl_langinfo (DECIMAL_POINT);\n+  decimal_len = strlen (decimal);\n+  assert (decimal_len > 0);\n+#elif defined USE_LOCALECONV\n+  decimal = lc->decimal_point;\n+  if (decimal == NULL || *decimal == '\\0')\n+    decimal = \".\";\n+  decimal_len = strlen (decimal);\n+#else\n+  decimal = \".\";\n+  decimal_len = 1;\n+#endif\n+#endif\n+\n+  /* Prepare number representation.  */\n+  exponent = 0;\n+  negative = 0;\n+  bits = 0;\n+\n+  /* Parse string to get maximal legal prefix.  We need the number of\n+     characters of the integer part, the fractional part and the exponent.  */\n+  cp = nptr - 1;\n+  /* Ignore leading white space.  */\n+  do\n+    c = *++cp;\n+  while (ISSPACE (c));\n+\n+  /* Get sign of the result.  */\n+  if (c == L_('-'))\n+    {\n+      negative = 1;\n+      c = *++cp;\n+    }\n+  else if (c == L_('+'))\n+    c = *++cp;\n+\n+  /* Return 0.0 if no legal string is found.\n+     No character is used even if a sign was found.  */\n+#ifdef USE_WIDE_CHAR\n+  if (c == (wint_t) decimal\n+      && (wint_t) cp[1] >= L'0' && (wint_t) cp[1] <= L'9')\n+    {\n+      /* We accept it.  This funny construct is here only to indent\n+\t the code correctly.  */\n+    }\n+#else\n+  for (cnt = 0; decimal[cnt] != '\\0'; ++cnt)\n+    if (cp[cnt] != decimal[cnt])\n+      break;\n+  if (decimal[cnt] == '\\0' && cp[cnt] >= '0' && cp[cnt] <= '9')\n+    {\n+      /* We accept it.  This funny construct is here only to indent\n+\t the code correctly.  */\n+    }\n+#endif\n+  else if (c < L_('0') || c > L_('9'))\n+    {\n+      /* Check for `INF' or `INFINITY'.  */\n+      CHAR_TYPE lowc = TOLOWER_C (c);\n+\n+      if (lowc == L_('i') && STRNCASECMP (cp, L_(\"inf\"), 3) == 0)\n+\t{\n+\t  /* Return +/- infinity.  */\n+\t  if (endptr != NULL)\n+\t    *endptr = (STRING_TYPE *)\n+\t\t      (cp + (STRNCASECMP (cp + 3, L_(\"inity\"), 5) == 0\n+\t\t\t     ? 8 : 3));\n+\n+\t  return negative ? -FLOAT_HUGE_VAL : FLOAT_HUGE_VAL;\n+\t}\n+\n+      if (lowc == L_('n') && STRNCASECMP (cp, L_(\"nan\"), 3) == 0)\n+\t{\n+\t  /* Return NaN.  */\n+\t  FLOAT retval = NAN;\n+\n+\t  cp += 3;\n+\n+\t  /* Match `(n-char-sequence-digit)'.  */\n+\t  if (*cp == L_('('))\n+\t    {\n+\t      const STRING_TYPE *startp = cp;\n+\t      do\n+\t\t++cp;\n+\t      while ((*cp >= L_('0') && *cp <= L_('9'))\n+\t\t     || ({ CHAR_TYPE lo = TOLOWER (*cp);\n+\t\t\t   lo >= L_('a') && lo <= L_('z'); })\n+\t\t     || *cp == L_('_'));\n+\n+\t      if (*cp != L_(')'))\n+\t\t/* The closing brace is missing.  Only match the NAN\n+\t\t   part.  */\n+\t\tcp = startp;\n+\t      else\n+\t\t{\n+\t\t  /* This is a system-dependent way to specify the\n+\t\t     bitmask used for the NaN.  We expect it to be\n+\t\t     a number which is put in the mantissa of the\n+\t\t     number.  */\n+\t\t  STRING_TYPE *endp;\n+\t\t  unsigned long long int mant;\n+\n+\t\t  mant = STRTOULL (startp + 1, &endp, 0);\n+\t\t  if (endp == cp)\n+\t\t    SET_MANTISSA (retval, mant);\n+\n+\t\t  /* Consume the closing brace.  */\n+\t\t  ++cp;\n+\t\t}\n+\t    }\n+\n+\t  if (endptr != NULL)\n+\t    *endptr = (STRING_TYPE *) cp;\n+\n+\t  return retval;\n+\t}\n+\n+      /* It is really a text we do not recognize.  */\n+      RETURN (0.0, nptr);\n+    }\n+\n+  /* First look whether we are faced with a hexadecimal number.  */\n+  if (c == L_('0') && TOLOWER (cp[1]) == L_('x'))\n+    {\n+      /* Okay, it is a hexa-decimal number.  Remember this and skip\n+\t the characters.  BTW: hexadecimal numbers must not be\n+\t grouped.  */\n+      base = 16;\n+      cp += 2;\n+      c = *cp;\n+      grouping = NULL;\n+    }\n+\n+  /* Record the start of the digits, in case we will check their grouping.  */\n+  start_of_digits = startp = cp;\n+\n+  /* Ignore leading zeroes.  This helps us to avoid useless computations.  */\n+#ifdef USE_WIDE_CHAR\n+  while (c == L'0' || ((wint_t) thousands != L'\\0' && c == (wint_t) thousands))\n+    c = *++cp;\n+#else\n+  if (__builtin_expect (thousands == NULL, 1))\n+    while (c == '0')\n+      c = *++cp;\n+  else\n+    {\n+      /* We also have the multibyte thousands string.  */\n+      while (1)\n+\t{\n+\t  if (c != '0')\n+\t    {\n+\t      for (cnt = 0; thousands[cnt] != '\\0'; ++cnt)\n+\t\tif (thousands[cnt] != cp[cnt])\n+\t\t  break;\n+\t      if (thousands[cnt] != '\\0')\n+\t\tbreak;\n+\t      cp += cnt - 1;\n+\t    }\n+\t  c = *++cp;\n+\t}\n+    }\n+#endif\n+\n+  /* If no other digit but a '0' is found the result is 0.0.\n+     Return current read pointer.  */\n+  CHAR_TYPE lowc = TOLOWER (c);\n+  if (!((c >= L_('0') && c <= L_('9'))\n+\t|| (base == 16 && lowc >= L_('a') && lowc <= L_('f'))\n+\t|| (\n+#ifdef USE_WIDE_CHAR\n+\t    c == (wint_t) decimal\n+#else\n+\t    ({ for (cnt = 0; decimal[cnt] != '\\0'; ++cnt)\n+\t\t if (decimal[cnt] != cp[cnt])\n+\t\t   break;\n+\t       decimal[cnt] == '\\0'; })\n+#endif\n+\t    /* '0x.' alone is not a valid hexadecimal number.\n+\t       '.' alone is not valid either, but that has been checked\n+\t       already earlier.  */\n+\t    && (base != 16\n+\t\t|| cp != start_of_digits\n+\t\t|| (cp[decimal_len] >= L_('0') && cp[decimal_len] <= L_('9'))\n+\t\t|| ({ CHAR_TYPE lo = TOLOWER (cp[decimal_len]);\n+\t\t      lo >= L_('a') && lo <= L_('f'); })))\n+\t|| (base == 16 && (cp != start_of_digits\n+\t\t\t   && lowc == L_('p')))\n+\t|| (base != 16 && lowc == L_('e'))))\n+    {\n+#ifdef USE_WIDE_CHAR\n+      tp = __correctly_grouped_prefixwc (start_of_digits, cp, thousands,\n+\t\t\t\t\t grouping);\n+#else\n+      tp = __correctly_grouped_prefixmb (start_of_digits, cp, thousands,\n+\t\t\t\t\t grouping);\n+#endif\n+      /* If TP is at the start of the digits, there was no correctly\n+\t grouped prefix of the string; so no number found.  */\n+      RETURN (negative ? -0.0 : 0.0,\n+\t      tp == start_of_digits ? (base == 16 ? cp - 1 : nptr) : tp);\n+    }\n+\n+  /* Remember first significant digit and read following characters until the\n+     decimal point, exponent character or any non-FP number character.  */\n+  startp = cp;\n+  dig_no = 0;\n+  while (1)\n+    {\n+      if ((c >= L_('0') && c <= L_('9'))\n+\t  || (base == 16\n+\t      && ({ CHAR_TYPE lo = TOLOWER (c);\n+\t\t    lo >= L_('a') && lo <= L_('f'); })))\n+\t++dig_no;\n+      else\n+\t{\n+#ifdef USE_WIDE_CHAR\n+\t  if (__builtin_expect ((wint_t) thousands == L'\\0', 1)\n+\t      || c != (wint_t) thousands)\n+\t    /* Not a digit or separator: end of the integer part.  */\n+\t    break;\n+#else\n+\t  if (__builtin_expect (thousands == NULL, 1))\n+\t    break;\n+\t  else\n+\t    {\n+\t      for (cnt = 0; thousands[cnt] != '\\0'; ++cnt)\n+\t\tif (thousands[cnt] != cp[cnt])\n+\t\t  break;\n+\t      if (thousands[cnt] != '\\0')\n+\t\tbreak;\n+\t      cp += cnt - 1;\n+\t    }\n+#endif\n+\t}\n+      c = *++cp;\n+    }\n+\n+  if (__builtin_expect (grouping != NULL, 0) && cp > start_of_digits)\n+    {\n+      /* Check the grouping of the digits.  */\n+#ifdef USE_WIDE_CHAR\n+      tp = __correctly_grouped_prefixwc (start_of_digits, cp, thousands,\n+\t\t\t\t\t grouping);\n+#else\n+      tp = __correctly_grouped_prefixmb (start_of_digits, cp, thousands,\n+\t\t\t\t\t grouping);\n+#endif\n+      if (cp != tp)\n+\t{\n+\t  /* Less than the entire string was correctly grouped.  */\n+\n+\t  if (tp == start_of_digits)\n+\t    /* No valid group of numbers at all: no valid number.  */\n+\t    RETURN (0.0, nptr);\n+\n+\t  if (tp < startp)\n+\t    /* The number is validly grouped, but consists\n+\t       only of zeroes.  The whole value is zero.  */\n+\t    RETURN (negative ? -0.0 : 0.0, tp);\n+\n+\t  /* Recompute DIG_NO so we won't read more digits than\n+\t     are properly grouped.  */\n+\t  cp = tp;\n+\t  dig_no = 0;\n+\t  for (tp = startp; tp < cp; ++tp)\n+\t    if (*tp >= L_('0') && *tp <= L_('9'))\n+\t      ++dig_no;\n+\n+\t  int_no = dig_no;\n+\t  lead_zero = 0;\n+\n+\t  goto number_parsed;\n+\t}\n+    }\n+\n+  /* We have the number of digits in the integer part.  Whether these\n+     are all or any is really a fractional digit will be decided\n+     later.  */\n+  int_no = dig_no;\n+  lead_zero = int_no == 0 ? -1 : 0;\n+\n+  /* Read the fractional digits.  A special case are the 'american\n+     style' numbers like `16.' i.e. with decimal point but without\n+     trailing digits.  */\n+  if (\n+#ifdef USE_WIDE_CHAR\n+      c == (wint_t) decimal\n+#else\n+      ({ for (cnt = 0; decimal[cnt] != '\\0'; ++cnt)\n+\t   if (decimal[cnt] != cp[cnt])\n+\t     break;\n+\t decimal[cnt] == '\\0'; })\n+#endif\n+      )\n+    {\n+      cp += decimal_len;\n+      c = *cp;\n+      while ((c >= L_('0') && c <= L_('9')) ||\n+\t     (base == 16 && ({ CHAR_TYPE lo = TOLOWER (c);\n+\t\t\t       lo >= L_('a') && lo <= L_('f'); })))\n+\t{\n+\t  if (c != L_('0') && lead_zero == -1)\n+\t    lead_zero = dig_no - int_no;\n+\t  ++dig_no;\n+\t  c = *++cp;\n+\t}\n+    }\n+\n+  /* Remember start of exponent (if any).  */\n+  expp = cp;\n+\n+  /* Read exponent.  */\n+  lowc = TOLOWER (c);\n+  if ((base == 16 && lowc == L_('p'))\n+      || (base != 16 && lowc == L_('e')))\n+    {\n+      int exp_negative = 0;\n+\n+      c = *++cp;\n+      if (c == L_('-'))\n+\t{\n+\t  exp_negative = 1;\n+\t  c = *++cp;\n+\t}\n+      else if (c == L_('+'))\n+\tc = *++cp;\n+\n+      if (c >= L_('0') && c <= L_('9'))\n+\t{\n+\t  int exp_limit;\n+\n+\t  /* Get the exponent limit. */\n+\t  if (base == 16)\n+\t    exp_limit = (exp_negative ?\n+\t\t\t -MIN_EXP + MANT_DIG + 4 * int_no :\n+\t\t\t MAX_EXP - 4 * int_no + 4 * lead_zero + 3);\n+\t  else\n+\t    exp_limit = (exp_negative ?\n+\t\t\t -MIN_10_EXP + MANT_DIG + int_no :\n+\t\t\t MAX_10_EXP - int_no + lead_zero + 1);\n+\n+\t  do\n+\t    {\n+\t      exponent *= 10;\n+\t      exponent += c - L_('0');\n+\n+\t      if (__builtin_expect (exponent > exp_limit, 0))\n+\t\t/* The exponent is too large/small to represent a valid\n+\t\t   number.  */\n+\t\t{\n+\t \t  FLOAT result;\n+\n+\t\t  /* We have to take care for special situation: a joker\n+\t\t     might have written \"0.0e100000\" which is in fact\n+\t\t     zero.  */\n+\t\t  if (lead_zero == -1)\n+\t\t    result = negative ? -0.0 : 0.0;\n+\t\t  else\n+\t\t    {\n+\t\t      /* Overflow or underflow.  */\n+#if defined HAVE_ERRNO_H && defined ERANGE\n+\t\t      errno = ERANGE;\n+#endif\n+\t\t      result = (exp_negative ? (negative ? -0.0 : 0.0) :\n+\t\t\t\tnegative ? -FLOAT_HUGE_VAL : FLOAT_HUGE_VAL);\n+\t\t    }\n+\n+\t\t  /* Accept all following digits as part of the exponent.  */\n+\t\t  do\n+\t\t    ++cp;\n+\t\t  while (*cp >= L_('0') && *cp <= L_('9'));\n+\n+\t\t  RETURN (result, cp);\n+\t\t  /* NOTREACHED */\n+\t\t}\n+\n+\t      c = *++cp;\n+\t    }\n+\t  while (c >= L_('0') && c <= L_('9'));\n+\n+\t  if (exp_negative)\n+\t    exponent = -exponent;\n+\t}\n+      else\n+\tcp = expp;\n+    }\n+\n+  /* We don't want to have to work with trailing zeroes after the radix.  */\n+  if (dig_no > int_no)\n+    {\n+      while (expp[-1] == L_('0'))\n+\t{\n+\t  --expp;\n+\t  --dig_no;\n+\t}\n+      assert (dig_no >= int_no);\n+    }\n+\n+  if (dig_no == int_no && dig_no > 0 && exponent < 0)\n+    do\n+      {\n+\twhile (! (base == 16 ? ISXDIGIT (expp[-1]) : ISDIGIT (expp[-1])))\n+\t  --expp;\n+\n+\tif (expp[-1] != L_('0'))\n+\t  break;\n+\n+\t--expp;\n+\t--dig_no;\n+\t--int_no;\n+\texponent += base == 16 ? 4 : 1;\n+      }\n+    while (dig_no > 0 && exponent < 0);\n+\n+ number_parsed:\n+\n+  /* The whole string is parsed.  Store the address of the next character.  */\n+  if (endptr)\n+    *endptr = (STRING_TYPE *) cp;\n+\n+  if (dig_no == 0)\n+    return negative ? -0.0 : 0.0;\n+\n+  if (lead_zero)\n+    {\n+      /* Find the decimal point */\n+#ifdef USE_WIDE_CHAR\n+      while (*startp != decimal)\n+\t++startp;\n+#else\n+      while (1)\n+\t{\n+\t  if (*startp == decimal[0])\n+\t    {\n+\t      for (cnt = 1; decimal[cnt] != '\\0'; ++cnt)\n+\t\tif (decimal[cnt] != startp[cnt])\n+\t\t  break;\n+\t      if (decimal[cnt] == '\\0')\n+\t\tbreak;\n+\t    }\n+\t  ++startp;\n+\t}\n+#endif\n+      startp += lead_zero + decimal_len;\n+      exponent -= base == 16 ? 4 * lead_zero : lead_zero;\n+      dig_no -= lead_zero;\n+    }\n+\n+  /* If the BASE is 16 we can use a simpler algorithm.  */\n+  if (base == 16)\n+    {\n+      static const int nbits[16] = { 0, 1, 2, 2, 3, 3, 3, 3,\n+\t\t\t\t     4, 4, 4, 4, 4, 4, 4, 4 };\n+      int idx = (MANT_DIG - 1) / BITS_PER_MP_LIMB;\n+      int pos = (MANT_DIG - 1) % BITS_PER_MP_LIMB;\n+      mp_limb_t val;\n+\n+      while (!ISXDIGIT (*startp))\n+\t++startp;\n+      while (*startp == L_('0'))\n+\t++startp;\n+      if (ISDIGIT (*startp))\n+\tval = *startp++ - L_('0');\n+      else\n+\tval = 10 + TOLOWER (*startp++) - L_('a');\n+      bits = nbits[val];\n+      /* We cannot have a leading zero.  */\n+      assert (bits != 0);\n+\n+      if (pos + 1 >= 4 || pos + 1 >= bits)\n+\t{\n+\t  /* We don't have to care for wrapping.  This is the normal\n+\t     case so we add the first clause in the `if' expression as\n+\t     an optimization.  It is a compile-time constant and so does\n+\t     not cost anything.  */\n+\t  retval[idx] = val << (pos - bits + 1);\n+\t  pos -= bits;\n+\t}\n+      else\n+\t{\n+\t  retval[idx--] = val >> (bits - pos - 1);\n+\t  retval[idx] = val << (BITS_PER_MP_LIMB - (bits - pos - 1));\n+\t  pos = BITS_PER_MP_LIMB - 1 - (bits - pos - 1);\n+\t}\n+\n+      /* Adjust the exponent for the bits we are shifting in.  */\n+      exponent += bits - 1 + (int_no - 1) * 4;\n+\n+      while (--dig_no > 0 && idx >= 0)\n+\t{\n+\t  if (!ISXDIGIT (*startp))\n+\t    startp += decimal_len;\n+\t  if (ISDIGIT (*startp))\n+\t    val = *startp++ - L_('0');\n+\t  else\n+\t    val = 10 + TOLOWER (*startp++) - L_('a');\n+\n+\t  if (pos + 1 >= 4)\n+\t    {\n+\t      retval[idx] |= val << (pos - 4 + 1);\n+\t      pos -= 4;\n+\t    }\n+\t  else\n+\t    {\n+\t      retval[idx--] |= val >> (4 - pos - 1);\n+\t      val <<= BITS_PER_MP_LIMB - (4 - pos - 1);\n+\t      if (idx < 0)\n+\t\treturn round_and_return (retval, exponent, negative, val,\n+\t\t\t\t\t BITS_PER_MP_LIMB - 1, dig_no > 0);\n+\n+\t      retval[idx] = val;\n+\t      pos = BITS_PER_MP_LIMB - 1 - (4 - pos - 1);\n+\t    }\n+\t}\n+\n+      /* We ran out of digits.  */\n+      MPN_ZERO (retval, idx);\n+\n+      return round_and_return (retval, exponent, negative, 0, 0, 0);\n+    }\n+\n+  /* Now we have the number of digits in total and the integer digits as well\n+     as the exponent and its sign.  We can decide whether the read digits are\n+     really integer digits or belong to the fractional part; i.e. we normalize\n+     123e-2 to 1.23.  */\n+  {\n+    register int incr = (exponent < 0 ? MAX (-int_no, exponent)\n+\t\t\t : MIN (dig_no - int_no, exponent));\n+    int_no += incr;\n+    exponent -= incr;\n+  }\n+\n+  if (__builtin_expect (int_no + exponent > MAX_10_EXP + 1, 0))\n+    {\n+#if defined HAVE_ERRNO_H && defined ERANGE\n+      errno = ERANGE;\n+#endif\n+      return negative ? -FLOAT_HUGE_VAL : FLOAT_HUGE_VAL;\n+    }\n+\n+  if (__builtin_expect (exponent < MIN_10_EXP - (DIG + 1), 0))\n+    {\n+#if defined HAVE_ERRNO_H && defined ERANGE\n+      errno = ERANGE;\n+#endif\n+      return negative ? -0.0 : 0.0;\n+    }\n+\n+  if (int_no > 0)\n+    {\n+      /* Read the integer part as a multi-precision number to NUM.  */\n+      startp = str_to_mpn (startp, int_no, num, &numsize, &exponent\n+#ifndef USE_WIDE_CHAR\n+\t\t\t   , decimal, decimal_len, thousands\n+#endif\n+\t\t\t   );\n+\n+      if (exponent > 0)\n+\t{\n+\t  /* We now multiply the gained number by the given power of ten.  */\n+\t  mp_limb_t *psrc = num;\n+\t  mp_limb_t *pdest = den;\n+\t  int expbit = 1;\n+\t  const struct mp_power *ttab = &_fpioconst_pow10[0];\n+\n+\t  do\n+\t    {\n+\t      if ((exponent & expbit) != 0)\n+\t\t{\n+\t\t  size_t size = ttab->arraysize - _FPIO_CONST_OFFSET;\n+\t\t  mp_limb_t cy;\n+\t\t  exponent ^= expbit;\n+\n+\t\t  /* FIXME: not the whole multiplication has to be\n+\t\t     done.  If we have the needed number of bits we\n+\t\t     only need the information whether more non-zero\n+\t\t     bits follow.  */\n+\t\t  if (numsize >= ttab->arraysize - _FPIO_CONST_OFFSET)\n+\t\t    cy = mpn_mul (pdest, psrc, numsize,\n+\t\t\t\t  &__tens[ttab->arrayoff\n+\t\t\t\t\t  + _FPIO_CONST_OFFSET],\n+\t\t\t\t  size);\n+\t\t  else\n+\t\t    cy = mpn_mul (pdest, &__tens[ttab->arrayoff\n+\t\t\t\t\t\t + _FPIO_CONST_OFFSET],\n+\t\t\t\t  size, psrc, numsize);\n+\t\t  numsize += size;\n+\t\t  if (cy == 0)\n+\t\t    --numsize;\n+\t\t  (void) SWAP (psrc, pdest);\n+\t\t}\n+\t      expbit <<= 1;\n+\t      ++ttab;\n+\t    }\n+\t  while (exponent != 0);\n+\n+\t  if (psrc == den)\n+\t    memcpy (num, den, numsize * sizeof (mp_limb_t));\n+\t}\n+\n+      /* Determine how many bits of the result we already have.  */\n+      count_leading_zeros (bits, num[numsize - 1]);\n+      bits = numsize * BITS_PER_MP_LIMB - bits;\n+\n+      /* Now we know the exponent of the number in base two.\n+\t Check it against the maximum possible exponent.  */\n+      if (__builtin_expect (bits > MAX_EXP, 0))\n+\t{\n+#if defined HAVE_ERRNO_H && defined ERANGE\n+\t  errno = ERANGE;\n+#endif\n+\t  return negative ? -FLOAT_HUGE_VAL : FLOAT_HUGE_VAL;\n+\t}\n+\n+      /* We have already the first BITS bits of the result.  Together with\n+\t the information whether more non-zero bits follow this is enough\n+\t to determine the result.  */\n+      if (bits > MANT_DIG)\n+\t{\n+\t  int i;\n+\t  const mp_size_t least_idx = (bits - MANT_DIG) / BITS_PER_MP_LIMB;\n+\t  const mp_size_t least_bit = (bits - MANT_DIG) % BITS_PER_MP_LIMB;\n+\t  const mp_size_t round_idx = least_bit == 0 ? least_idx - 1\n+\t\t\t\t\t\t     : least_idx;\n+\t  const mp_size_t round_bit = least_bit == 0 ? BITS_PER_MP_LIMB - 1\n+\t\t\t\t\t\t     : least_bit - 1;\n+\n+\t  if (least_bit == 0)\n+\t    memcpy (retval, &num[least_idx],\n+\t\t    RETURN_LIMB_SIZE * sizeof (mp_limb_t));\n+\t  else\n+\t    {\n+\t      for (i = least_idx; i < numsize - 1; ++i)\n+\t\tretval[i - least_idx] = (num[i] >> least_bit)\n+\t\t\t\t\t| (num[i + 1]\n+\t\t\t\t\t   << (BITS_PER_MP_LIMB - least_bit));\n+\t      if (i - least_idx < RETURN_LIMB_SIZE)\n+\t\tretval[RETURN_LIMB_SIZE - 1] = num[i] >> least_bit;\n+\t    }\n+\n+\t  /* Check whether any limb beside the ones in RETVAL are non-zero.  */\n+\t  for (i = 0; num[i] == 0; ++i)\n+\t    ;\n+\n+\t  return round_and_return (retval, bits - 1, negative,\n+\t\t\t\t   num[round_idx], round_bit,\n+\t\t\t\t   int_no < dig_no || i < round_idx);\n+\t  /* NOTREACHED */\n+\t}\n+      else if (dig_no == int_no)\n+\t{\n+\t  const mp_size_t target_bit = (MANT_DIG - 1) % BITS_PER_MP_LIMB;\n+\t  const mp_size_t is_bit = (bits - 1) % BITS_PER_MP_LIMB;\n+\n+\t  if (target_bit == is_bit)\n+\t    {\n+\t      memcpy (&retval[RETURN_LIMB_SIZE - numsize], num,\n+\t\t      numsize * sizeof (mp_limb_t));\n+\t      /* FIXME: the following loop can be avoided if we assume a\n+\t\t maximal MANT_DIG value.  */\n+\t      MPN_ZERO (retval, RETURN_LIMB_SIZE - numsize);\n+\t    }\n+\t  else if (target_bit > is_bit)\n+\t    {\n+\t      (void) mpn_lshift (&retval[RETURN_LIMB_SIZE - numsize],\n+\t\t\t\t num, numsize, target_bit - is_bit);\n+\t      /* FIXME: the following loop can be avoided if we assume a\n+\t\t maximal MANT_DIG value.  */\n+\t      MPN_ZERO (retval, RETURN_LIMB_SIZE - numsize);\n+\t    }\n+\t  else\n+\t    {\n+\t      mp_limb_t cy;\n+\t      assert (numsize < RETURN_LIMB_SIZE);\n+\n+\t      cy = mpn_rshift (&retval[RETURN_LIMB_SIZE - numsize],\n+\t\t\t       num, numsize, is_bit - target_bit);\n+\t      retval[RETURN_LIMB_SIZE - numsize - 1] = cy;\n+\t      /* FIXME: the following loop can be avoided if we assume a\n+\t\t maximal MANT_DIG value.  */\n+\t      MPN_ZERO (retval, RETURN_LIMB_SIZE - numsize - 1);\n+\t    }\n+\n+\t  return round_and_return (retval, bits - 1, negative, 0, 0, 0);\n+\t  /* NOTREACHED */\n+\t}\n+\n+      /* Store the bits we already have.  */\n+      memcpy (retval, num, numsize * sizeof (mp_limb_t));\n+#if RETURN_LIMB_SIZE > 1\n+      if (numsize < RETURN_LIMB_SIZE)\n+# if RETURN_LIMB_SIZE == 2\n+\tretval[numsize] = 0;\n+# else\n+\tMPN_ZERO (retval + numsize, RETURN_LIMB_SIZE - numsize);\n+# endif\n+#endif\n+    }\n+\n+  /* We have to compute at least some of the fractional digits.  */\n+  {\n+    /* We construct a fraction and the result of the division gives us\n+       the needed digits.  The denominator is 1.0 multiplied by the\n+       exponent of the lowest digit; i.e. 0.123 gives 123 / 1000 and\n+       123e-6 gives 123 / 1000000.  */\n+\n+    int expbit;\n+    int neg_exp;\n+    int more_bits;\n+    mp_limb_t cy;\n+    mp_limb_t *psrc = den;\n+    mp_limb_t *pdest = num;\n+    const struct mp_power *ttab = &_fpioconst_pow10[0];\n+\n+    assert (dig_no > int_no && exponent <= 0);\n+\n+\n+    /* For the fractional part we need not process too many digits.  One\n+       decimal digits gives us log_2(10) ~ 3.32 bits.  If we now compute\n+\t\t\tceil(BITS / 3) =: N\n+       digits we should have enough bits for the result.  The remaining\n+       decimal digits give us the information that more bits are following.\n+       This can be used while rounding.  (Two added as a safety margin.)  */\n+    if (dig_no - int_no > (MANT_DIG - bits + 2) / 3 + 2)\n+      {\n+\tdig_no = int_no + (MANT_DIG - bits + 2) / 3 + 2;\n+\tmore_bits = 1;\n+      }\n+    else\n+      more_bits = 0;\n+\n+    neg_exp = dig_no - int_no - exponent;\n+\n+    /* Construct the denominator.  */\n+    densize = 0;\n+    expbit = 1;\n+    do\n+      {\n+\tif ((neg_exp & expbit) != 0)\n+\t  {\n+\t    mp_limb_t cy;\n+\t    neg_exp ^= expbit;\n+\n+\t    if (densize == 0)\n+\t      {\n+\t\tdensize = ttab->arraysize - _FPIO_CONST_OFFSET;\n+\t\tmemcpy (psrc, &__tens[ttab->arrayoff + _FPIO_CONST_OFFSET],\n+\t\t\tdensize * sizeof (mp_limb_t));\n+\t      }\n+\t    else\n+\t      {\n+\t\tcy = mpn_mul (pdest, &__tens[ttab->arrayoff\n+\t\t\t\t\t     + _FPIO_CONST_OFFSET],\n+\t\t\t      ttab->arraysize - _FPIO_CONST_OFFSET,\n+\t\t\t      psrc, densize);\n+\t\tdensize += ttab->arraysize - _FPIO_CONST_OFFSET;\n+\t\tif (cy == 0)\n+\t\t  --densize;\n+\t\t(void) SWAP (psrc, pdest);\n+\t      }\n+\t  }\n+\texpbit <<= 1;\n+\t++ttab;\n+      }\n+    while (neg_exp != 0);\n+\n+    if (psrc == num)\n+      memcpy (den, num, densize * sizeof (mp_limb_t));\n+\n+    /* Read the fractional digits from the string.  */\n+    (void) str_to_mpn (startp, dig_no - int_no, num, &numsize, &exponent\n+#ifndef USE_WIDE_CHAR\n+\t\t       , decimal, decimal_len, thousands\n+#endif\n+\t\t       );\n+\n+    /* We now have to shift both numbers so that the highest bit in the\n+       denominator is set.  In the same process we copy the numerator to\n+       a high place in the array so that the division constructs the wanted\n+       digits.  This is done by a \"quasi fix point\" number representation.\n+\n+       num:   ddddddddddd . 0000000000000000000000\n+\t      |--- m ---|\n+       den:                            ddddddddddd      n >= m\n+\t\t\t\t       |--- n ---|\n+     */\n+\n+    count_leading_zeros (cnt, den[densize - 1]);\n+\n+    if (cnt > 0)\n+      {\n+\t/* Don't call `mpn_shift' with a count of zero since the specification\n+\t   does not allow this.  */\n+\t(void) mpn_lshift (den, den, densize, cnt);\n+\tcy = mpn_lshift (num, num, numsize, cnt);\n+\tif (cy != 0)\n+\t  num[numsize++] = cy;\n+      }\n+\n+    /* Now we are ready for the division.  But it is not necessary to\n+       do a full multi-precision division because we only need a small\n+       number of bits for the result.  So we do not use mpn_divmod\n+       here but instead do the division here by hand and stop whenever\n+       the needed number of bits is reached.  The code itself comes\n+       from the GNU MP Library by Torbj\\\"orn Granlund.  */\n+\n+    exponent = bits;\n+\n+    switch (densize)\n+      {\n+      case 1:\n+\t{\n+\t  mp_limb_t d, n, quot;\n+\t  int used = 0;\n+\n+\t  n = num[0];\n+\t  d = den[0];\n+\t  assert (numsize == 1 && n < d);\n+\n+\t  do\n+\t    {\n+\t      udiv_qrnnd (quot, n, n, 0, d);\n+\n+#define got_limb\t\t\t\t\t\t\t      \\\n+\t      if (bits == 0)\t\t\t\t\t\t      \\\n+\t\t{\t\t\t\t\t\t\t      \\\n+\t\t  register int cnt;\t\t\t\t\t      \\\n+\t\t  if (quot == 0)\t\t\t\t\t      \\\n+\t\t    cnt = BITS_PER_MP_LIMB;\t\t\t\t      \\\n+\t\t  else\t\t\t\t\t\t\t      \\\n+\t\t    count_leading_zeros (cnt, quot);\t\t\t      \\\n+\t\t  exponent -= cnt;\t\t\t\t\t      \\\n+\t\t  if (BITS_PER_MP_LIMB - cnt > MANT_DIG)\t\t      \\\n+\t\t    {\t\t\t\t\t\t\t      \\\n+\t\t      used = MANT_DIG + cnt;\t\t\t\t      \\\n+\t\t      retval[0] = quot >> (BITS_PER_MP_LIMB - used);\t      \\\n+\t\t      bits = MANT_DIG + 1;\t\t\t\t      \\\n+\t\t    }\t\t\t\t\t\t\t      \\\n+\t\t  else\t\t\t\t\t\t\t      \\\n+\t\t    {\t\t\t\t\t\t\t      \\\n+\t\t      /* Note that we only clear the second element.  */      \\\n+\t\t      /* The conditional is determined at compile time.  */   \\\n+\t\t      if (RETURN_LIMB_SIZE > 1)\t\t\t\t      \\\n+\t\t\tretval[1] = 0;\t\t\t\t\t      \\\n+\t\t      retval[0] = quot;\t\t\t\t\t      \\\n+\t\t      bits = -cnt;\t\t\t\t\t      \\\n+\t\t    }\t\t\t\t\t\t\t      \\\n+\t\t}\t\t\t\t\t\t\t      \\\n+\t      else if (bits + BITS_PER_MP_LIMB <= MANT_DIG)\t\t      \\\n+\t\tmpn_lshift_1 (retval, RETURN_LIMB_SIZE, BITS_PER_MP_LIMB,     \\\n+\t\t\t      quot);\t\t\t\t\t      \\\n+\t      else\t\t\t\t\t\t\t      \\\n+\t\t{\t\t\t\t\t\t\t      \\\n+\t\t  used = MANT_DIG - bits;\t\t\t\t      \\\n+\t\t  if (used > 0)\t\t\t\t\t\t      \\\n+\t\t    mpn_lshift_1 (retval, RETURN_LIMB_SIZE, used, quot);      \\\n+\t\t}\t\t\t\t\t\t\t      \\\n+\t      bits += BITS_PER_MP_LIMB\n+\n+\t      got_limb;\n+\t    }\n+\t  while (bits <= MANT_DIG);\n+\n+\t  return round_and_return (retval, exponent - 1, negative,\n+\t\t\t\t   quot, BITS_PER_MP_LIMB - 1 - used,\n+\t\t\t\t   more_bits || n != 0);\n+\t}\n+      case 2:\n+\t{\n+\t  mp_limb_t d0, d1, n0, n1;\n+\t  mp_limb_t quot = 0;\n+\t  int used = 0;\n+\n+\t  d0 = den[0];\n+\t  d1 = den[1];\n+\n+\t  if (numsize < densize)\n+\t    {\n+\t      if (num[0] >= d1)\n+\t\t{\n+\t\t  /* The numerator of the number occupies fewer bits than\n+\t\t     the denominator but the one limb is bigger than the\n+\t\t     high limb of the numerator.  */\n+\t\t  n1 = 0;\n+\t\t  n0 = num[0];\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (bits <= 0)\n+\t\t    exponent -= BITS_PER_MP_LIMB;\n+\t\t  else\n+\t\t    {\n+\t\t      if (bits + BITS_PER_MP_LIMB <= MANT_DIG)\n+\t\t\tmpn_lshift_1 (retval, RETURN_LIMB_SIZE,\n+\t\t\t\t      BITS_PER_MP_LIMB, 0);\n+\t\t      else\n+\t\t\t{\n+\t\t\t  used = MANT_DIG - bits;\n+\t\t\t  if (used > 0)\n+\t\t\t    mpn_lshift_1 (retval, RETURN_LIMB_SIZE, used, 0);\n+\t\t\t}\n+\t\t      bits += BITS_PER_MP_LIMB;\n+\t\t    }\n+\t\t  n1 = num[0];\n+\t\t  n0 = 0;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      n1 = num[1];\n+\t      n0 = num[0];\n+\t    }\n+\n+\t  while (bits <= MANT_DIG)\n+\t    {\n+\t      mp_limb_t r;\n+\n+\t      if (n1 == d1)\n+\t\t{\n+\t\t  /* QUOT should be either 111..111 or 111..110.  We need\n+\t\t     special treatment of this rare case as normal division\n+\t\t     would give overflow.  */\n+\t\t  quot = ~(mp_limb_t) 0;\n+\n+\t\t  r = n0 + d1;\n+\t\t  if (r < d1)\t/* Carry in the addition?  */\n+\t\t    {\n+\t\t      add_ssaaaa (n1, n0, r - d0, 0, 0, d0);\n+\t\t      goto have_quot;\n+\t\t    }\n+\t\t  n1 = d0 - (d0 != 0);\n+\t\t  n0 = -d0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  udiv_qrnnd (quot, r, n1, n0, d1);\n+\t\t  umul_ppmm (n1, n0, d0, quot);\n+\t\t}\n+\n+\t    q_test:\n+\t      if (n1 > r || (n1 == r && n0 > 0))\n+\t\t{\n+\t\t  /* The estimated QUOT was too large.  */\n+\t\t  --quot;\n+\n+\t\t  sub_ddmmss (n1, n0, n1, n0, 0, d0);\n+\t\t  r += d1;\n+\t\t  if (r >= d1)\t/* If not carry, test QUOT again.  */\n+\t\t    goto q_test;\n+\t\t}\n+\t      sub_ddmmss (n1, n0, r, 0, n1, n0);\n+\n+\t    have_quot:\n+\t      got_limb;\n+\t    }\n+\n+\t  return round_and_return (retval, exponent - 1, negative,\n+\t\t\t\t   quot, BITS_PER_MP_LIMB - 1 - used,\n+\t\t\t\t   more_bits || n1 != 0 || n0 != 0);\n+\t}\n+      default:\n+\t{\n+\t  int i;\n+\t  mp_limb_t cy, dX, d1, n0, n1;\n+\t  mp_limb_t quot = 0;\n+\t  int used = 0;\n+\n+\t  dX = den[densize - 1];\n+\t  d1 = den[densize - 2];\n+\n+\t  /* The division does not work if the upper limb of the two-limb\n+\t     numerator is greater than the denominator.  */\n+\t  if (mpn_cmp (num, &den[densize - numsize], numsize) > 0)\n+\t    num[numsize++] = 0;\n+\n+\t  if (numsize < densize)\n+\t    {\n+\t      mp_size_t empty = densize - numsize;\n+\t      register int i;\n+\n+\t      if (bits <= 0)\n+\t\texponent -= empty * BITS_PER_MP_LIMB;\n+\t      else\n+\t\t{\n+\t\t  if (bits + empty * BITS_PER_MP_LIMB <= MANT_DIG)\n+\t\t    {\n+\t\t      /* We make a difference here because the compiler\n+\t\t\t cannot optimize the `else' case that good and\n+\t\t\t this reflects all currently used FLOAT types\n+\t\t\t and GMP implementations.  */\n+#if RETURN_LIMB_SIZE <= 2\n+\t\t      assert (empty == 1);\n+\t\t      mpn_lshift_1 (retval, RETURN_LIMB_SIZE,\n+\t\t\t\t    BITS_PER_MP_LIMB, 0);\n+#else\n+\t\t      for (i = RETURN_LIMB_SIZE - 1; i >= empty; --i)\n+\t\t\tretval[i] = retval[i - empty];\n+\t\t      while (i >= 0)\n+\t\t\tretval[i--] = 0;\n+#endif\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      used = MANT_DIG - bits;\n+\t\t      if (used >= BITS_PER_MP_LIMB)\n+\t\t\t{\n+\t\t\t  register int i;\n+\t\t\t  (void) mpn_lshift (&retval[used\n+\t\t\t\t\t\t     / BITS_PER_MP_LIMB],\n+\t\t\t\t\t     retval,\n+\t\t\t\t\t     (RETURN_LIMB_SIZE\n+\t\t\t\t\t      - used / BITS_PER_MP_LIMB),\n+\t\t\t\t\t     used % BITS_PER_MP_LIMB);\n+\t\t\t  for (i = used / BITS_PER_MP_LIMB - 1; i >= 0; --i)\n+\t\t\t    retval[i] = 0;\n+\t\t\t}\n+\t\t      else if (used > 0)\n+\t\t\tmpn_lshift_1 (retval, RETURN_LIMB_SIZE, used, 0);\n+\t\t    }\n+\t\t  bits += empty * BITS_PER_MP_LIMB;\n+\t\t}\n+\t      for (i = numsize; i > 0; --i)\n+\t\tnum[i + empty] = num[i - 1];\n+\t      MPN_ZERO (num, empty + 1);\n+\t    }\n+\t  else\n+\t    {\n+\t      int i;\n+\t      assert (numsize == densize);\n+\t      for (i = numsize; i > 0; --i)\n+\t\tnum[i] = num[i - 1];\n+\t    }\n+\n+\t  den[densize] = 0;\n+\t  n0 = num[densize];\n+\n+\t  while (bits <= MANT_DIG)\n+\t    {\n+\t      if (n0 == dX)\n+\t\t/* This might over-estimate QUOT, but it's probably not\n+\t\t   worth the extra code here to find out.  */\n+\t\tquot = ~(mp_limb_t) 0;\n+\t      else\n+\t\t{\n+\t\t  mp_limb_t r;\n+\n+\t\t  udiv_qrnnd (quot, r, n0, num[densize - 1], dX);\n+\t\t  umul_ppmm (n1, n0, d1, quot);\n+\n+\t\t  while (n1 > r || (n1 == r && n0 > num[densize - 2]))\n+\t\t    {\n+\t\t      --quot;\n+\t\t      r += dX;\n+\t\t      if (r < dX) /* I.e. \"carry in previous addition?\" */\n+\t\t\tbreak;\n+\t\t      n1 -= n0 < d1;\n+\t\t      n0 -= d1;\n+\t\t    }\n+\t\t}\n+\n+\t      /* Possible optimization: We already have (q * n0) and (1 * n1)\n+\t\t after the calculation of QUOT.  Taking advantage of this, we\n+\t\t could make this loop make two iterations less.  */\n+\n+\t      cy = mpn_submul_1 (num, den, densize + 1, quot);\n+\n+\t      if (num[densize] != cy)\n+\t\t{\n+\t\t  cy = mpn_add_n (num, num, den, densize);\n+\t\t  assert (cy != 0);\n+\t\t  --quot;\n+\t\t}\n+\t      n0 = num[densize] = num[densize - 1];\n+\t      for (i = densize - 1; i > 0; --i)\n+\t\tnum[i] = num[i - 1];\n+\n+\t      got_limb;\n+\t    }\n+\n+\t  for (i = densize; num[i] == 0 && i >= 0; --i)\n+\t    ;\n+\t  return round_and_return (retval, exponent - 1, negative,\n+\t\t\t\t   quot, BITS_PER_MP_LIMB - 1 - used,\n+\t\t\t\t   more_bits || i >= 0);\n+\t}\n+      }\n+  }\n+\n+  /* NOTREACHED */\n+}"}, {"sha": "acdf36e9e8a359b7e6e08ad5111969ac6ad67b2c", "filename": "libquadmath/strtod/strtoflt128.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fstrtod%2Fstrtoflt128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fstrtod%2Fstrtoflt128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fstrtod%2Fstrtoflt128.c?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -0,0 +1,50 @@\n+/* Copyright (C) 1999, 2004 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.  */\n+\n+/* The actual implementation for all floating point sizes is in strtod.c.\n+   These macros tell it to produce the `__float128' version, `strtold'.  */\n+\n+#define FLOAT\t\t__float128\n+#define FLT\t\tFLT128\n+#ifdef USE_WIDE_CHAR\n+# define STRTOF\t\twcstoflt128\n+# define __STRTOF\t__wcstoflt128\n+#else\n+# define STRTOF\t\tstrtoflt128\n+# define __STRTOF\t__strtoflt128\n+#endif\n+#define MPN2FLOAT\tmpn_construct_float128\n+#define FLOAT_HUGE_VAL\tHUGE_VALQ\n+#define SET_MANTISSA(flt, mant) \\\n+  do { ieee854_float128 u;\t\t\t\t\t\t      \\\n+       u.value = (flt);\t\t\t\t\t\t\t      \\\n+       u.ieee.mant_high = 0x800000000000ULL;\t\t\t\t      \\\n+       u.ieee.mant_low = mant;\t\t\t\t\t\t      \\\n+       (flt) = u.value;\t\t\t\t\t\t\t      \\\n+  } while (0)\n+\n+static inline __attribute__((__always_inline__))\n+__float128 ____strtoflt128_internal (const char *, char **, int);\n+\n+#include \"strtod_l.c\"\n+\n+__float128\n+strtoflt128 (const char *nptr, char **endptr)\n+{\n+  return ____STRTOF_INTERNAL (nptr, endptr, 0);\n+}"}, {"sha": "b78a73e01d66b0ef54a09f331f0d84e9f90b9fa0", "filename": "libquadmath/strtod/tens_in_limb.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fstrtod%2Ftens_in_limb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a855debfb46ec3e3171b955cfc9c0f4e62dffcf2/libquadmath%2Fstrtod%2Ftens_in_limb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fstrtod%2Ftens_in_limb.c?ref=a855debfb46ec3e3171b955cfc9c0f4e62dffcf2", "patch": "@@ -0,0 +1,33 @@\n+#include <config.h>\n+#include \"../printf/gmp-impl.h\"\n+\n+\n+/* Definitions according to limb size used.  */\n+#if\tBITS_PER_MP_LIMB == 32\n+# define MAX_DIG_PER_LIMB\t9\n+# define MAX_FAC_PER_LIMB\t1000000000UL\n+#elif\tBITS_PER_MP_LIMB == 64\n+# define MAX_DIG_PER_LIMB\t19\n+# define MAX_FAC_PER_LIMB\t10000000000000000000ULL\n+#else\n+# error \"mp_limb_t size \" BITS_PER_MP_LIMB \"not accounted for\"\n+#endif\n+\n+\n+/* Local data structure.  */\n+const mp_limb_t __quadmath_tens_in_limb[MAX_DIG_PER_LIMB + 1] attribute_hidden\n+=\n+{    0,                   10,                   100,\n+     1000,                10000,                100000L,\n+     1000000L,            10000000L,            100000000L,\n+     1000000000L\n+#if BITS_PER_MP_LIMB > 32\n+\t        ,\t  10000000000ULL,       100000000000ULL,\n+     1000000000000ULL,    10000000000000ULL,    100000000000000ULL,\n+     1000000000000000ULL, 10000000000000000ULL, 100000000000000000ULL,\n+     1000000000000000000ULL, 10000000000000000000ULL\n+#endif\n+#if BITS_PER_MP_LIMB > 64\n+  #error \"Need to expand tens_in_limb table to\" MAX_DIG_PER_LIMB\n+#endif\n+};"}]}