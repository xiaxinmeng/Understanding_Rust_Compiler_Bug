{"sha": "99281ca45f7416b82a4b590d0c6077e4c63651a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTkyODFjYTQ1Zjc0MTZiODJhNGI1OTBkMGM2MDc3ZTRjNjM2NTFhNA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1992-10-15T20:59:46Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1992-10-15T20:59:46Z"}, "message": "entered into RCS\n\nFrom-SVN: r2482", "tree": {"sha": "fd64a6fbb805238c337a78b01ced6a870c5f5b12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd64a6fbb805238c337a78b01ced6a870c5f5b12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99281ca45f7416b82a4b590d0c6077e4c63651a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99281ca45f7416b82a4b590d0c6077e4c63651a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99281ca45f7416b82a4b590d0c6077e4c63651a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99281ca45f7416b82a4b590d0c6077e4c63651a4/comments", "author": null, "committer": null, "parents": [{"sha": "6702af89aff8f0462aa8b67a6f5bb5d495678de3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6702af89aff8f0462aa8b67a6f5bb5d495678de3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6702af89aff8f0462aa8b67a6f5bb5d495678de3"}], "stats": {"total": 2467, "additions": 2467, "deletions": 0}, "files": [{"sha": "027740a3ccbe27d0d8e0f5a3aefde4b489160407", "filename": "gcc/config/elxsi/elxsi.h", "status": "added", "additions": 976, "deletions": 0, "changes": 976, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99281ca45f7416b82a4b590d0c6077e4c63651a4/gcc%2Fconfig%2Felxsi%2Felxsi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99281ca45f7416b82a4b590d0c6077e4c63651a4/gcc%2Fconfig%2Felxsi%2Felxsi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Felxsi.h?ref=99281ca45f7416b82a4b590d0c6077e4c63651a4", "patch": "@@ -0,0 +1,976 @@\n+/* Definitions of target machine for GNU compiler.  Elxsi version.\n+   Copyright (C) 1987, 1988, 1992 Free Software Foundation, Inc.\n+   This port, done by Mike Stump <mrs@cygnus.com> in 1988, and is the first\n+   64 bit port of GNU CC.\n+   Based upon the VAX port.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 1, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Delxsi -Dunix\"\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+\n+#define TARGET_VERSION fprintf (stderr, \" (elxsi)\");\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+/* Nonzero if compiling code that Unix assembler can assemble.  */\n+#define TARGET_UNIX_ASM (target_flags & 1)\n+\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES  \\\n+  { {\"unix\", 1},  \\\n+    {\"embos\", -1},  \\\n+    { \"\", TARGET_DEFAULT}}\n+\n+/* Default target_flags if no switches specified.  */\n+\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT 1\n+#endif\n+\f\n+/* Target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.\n+   This is not true on the vax.  */\n+/* #define BITS_BIG_ENDIAN */\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if most significant word of a multiword number is numbered.  */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* Number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 64\n+#define Rmode DImode\n+\n+#define INT_TYPE_SIZE 32\n+\n+#define LONG_TYPE_SIZE 32\n+\n+#define LONG_LONG_TYPE_SIZE 64\n+\n+#define FLOAT_TYPE_SIZE 32\n+\n+#define DOUBLE_TYPE_SIZE 64\n+\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 8\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n+#define POINTER_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 8\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 8\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 32\n+\n+/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT 0\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.  */\n+#define FIRST_PSEUDO_REGISTER 16\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+   On the elxsi, these is the .r15 (aka .sp).  */\n+#define FIXED_REGISTERS {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS {1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+   On the vax, all registers are one word long.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+ ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2)  1\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 15\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 14\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED 0\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH)\t\t\t\\\n+{ int regno;\t\t\t\t\t\t\t\\\n+  int offset = 0;\t\t\t\t\t\t\\\n+  for( regno=0; regno < FIRST_PSEUDO_REGISTER;  regno++ )\t\\\n+    if( regs_ever_live[regno] && !call_used_regs[regno] )\t\\\n+      offset += 8;\t\t\t\t\t\t\\\n+  (DEPTH) = (offset + ((get_frame_size() + 3) & ~3) );\t\t\\\n+  (DEPTH) = 0;\t\t\t\t\t\t\t\\\n+}\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 14\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM 0\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+#define STRUCT_VALUE_REGNUM 1\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+/* The vax has only one kind of registers, so NO_REGS and ALL_REGS\n+   are the only classes.  */\n+\n+enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+ {\"NO_REGS\", \"GENERAL_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS {0, 0x07fff, 0xffff}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) (REGNO == 15 ? ALL_REGS : GENERAL_REGS)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+\n+#define INDEX_REG_CLASS GENERAL_REGS\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C) NO_REGS\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.  */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n+    ((C) == 'I' ? (VALUE) >=-16 && (VALUE) <=15 : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 1\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+/* On the vax, this is always the size of MODE in words,\n+   since all registers are the same size.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+ ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET -4\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 4\n+\n+/* Value is 1 if returning from a function call automatically\n+   pops the arguments described by the number-of-args field in the call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+\n+   On the Vax, the RET insn always pops all the args for any function.  */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) (SIZE)\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+/* On the Vax the return value is in R0 regardless.  */   \n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+/* On the Vax the return value is in R0 regardless.  */   \n+\n+#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, 0)\n+\n+/* Define this if PCC uses the nonreentrant convention for returning\n+   structure and union values.  */\n+\n+#define PCC_STATIC_STRUCT_RETURN\n+\n+/* 1 if N is a possible register number for a function value.\n+   On the Vax, R0 is the only register thus used.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On the Vax, no registers are used in this way.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) 0\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On the vax, this is a single integer, which is a number of bytes\n+   of arguments scanned so far.  */\n+\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On the vax, the offset starts at 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,x)\t\\\n+ ((CUM) = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+ ((CUM) += ((MODE) != BLKmode\t\t\t\\\n+\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n+\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+/* On the vax all args are pushed.  */   \n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE)\t\t\t\t\t\\\n+{ register int regno;\t\t\t\t\t\t\t\\\n+  register int cnt = 0;\t\t\t\t\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\t\\\n+  /* the below two lines are a HACK, and should be deleted, but \t\\\n+     for now are very much needed (1.35) */\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\t\\\n+    regs_ever_live[14]=1, call_used_regs[14]=0;\t\t\t\t\\\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\t\\\n+    if (regs_ever_live[regno] && !call_used_regs[regno])\t\t\\\n+\tcnt+=8;\t\t\t\t\t\t\t\t\\\n+  if ((SIZE)+cnt)\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tadd.64\\t.sp,=%d\\n\", -(SIZE)-cnt);\t\t\t\\\n+  cnt = 0;\t\t\t\t\t\t\t\t\\\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\t\\\n+    if (regs_ever_live[regno] && !call_used_regs[regno])\t\t\\\n+      fprintf (FILE, \"\\tst.64\\t.r%d,[.sp]%d\\n\", regno, (cnt+=8)-12); \t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tadd.64\\t.r14,.sp,=%d\\n\", (SIZE)+cnt);\t\t\\\n+}\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+   fprintf (FILE, \"\\tld.64\\t.r0,.LP%d\\n\\tcall\\tmcount\\n\", (LABELNO));\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 0\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.  */\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE)\t\t\t\t\t\\\n+{ register int regno;\t\t\t\t\t\t\t\\\n+  register int cnt = 0;\t\t\t\t\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\t\\\n+  extern int current_function_calls_alloca;\t\t\t\t\t\t\\\n+  /* this conditional is ONLY here because there is a BUG;\t\t\\\n+\t     EXIT_IGNORE_STACK is ignored itself when the first part of\t\t\\\n+\t     the condition is true! (atleast in version 1.35) */\t\t\\\n+  /* the 8*10 is for 64 bits of .r5 - .r14 */\t\t\t\t\\\n+  if (current_function_calls_alloca || (SIZE)>=(256-8*10)) {\t\t\\\n+    /* use .r4 as a temporary! Ok for now.... */\t\t\t\\\n+    fprintf (FILE, \"\\tld.64\\t.r4,.r14\\n\");\t\t\t\t\\\n+    for (regno = FIRST_PSEUDO_REGISTER-1; regno >= 0; --regno)\t\t\\\n+      if (regs_ever_live[regno] && !call_used_regs[regno])\t\t\\\n+       \tcnt+=8;\t\t\t\t\t\t\t\t\\\n+    for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\t\t\\\n+      if (regs_ever_live[regno] && !call_used_regs[regno])\t\t\\\n+       fprintf (FILE, \"\\tld.64\\t.r%d,[.r14]%d\\n\", regno,\t\t\\\n+\t\t-((cnt-=8) + 8)-4-(SIZE));\t\t\t\t\\\n+    fprintf (FILE, \"\\tld.64\\t.sp,.r4\\n\\texit\\t0\\n\");\t\t\t\\\n+  } else {\t\t\t\t\t\t\t\t\\\n+    for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\t\t\\\n+      if (regs_ever_live[regno] && !call_used_regs[regno])\t\t\\\n+         fprintf (FILE, \"\\tld.64\\t.r%d,[.sp]%d\\n\", regno, (cnt+=8)-12);\t\\\n+    fprintf (FILE, \"\\texit\\t%d\\n\", (SIZE)+cnt);\t\t\t\t\\\n+  } }\n+\n+/* If the memory address ADDR is relative to the frame pointer,\n+   correct it to be relative to the stack pointer instead.\n+   This is for when we don't use a frame pointer.\n+   ADDR should be a variable name.  */\n+\n+#define FIX_FRAME_POINTER_ADDRESS(ADDR,DEPTH) \\\n+{ int offset = -1;\t\t\t\t\t\t\t\\\n+  rtx regs = stack_pointer_rtx;\t\t\t\t\t\t\\\n+  if (ADDR == frame_pointer_rtx)\t\t\t\t\t\\\n+    offset = 0;\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (ADDR) == PLUS && XEXP (ADDR, 1) == frame_pointer_rtx \\\n+\t   && GET_CODE (XEXP (ADDR, 0)) == CONST_INT)\t\t\t\\\n+    offset = INTVAL (XEXP (ADDR, 0));\t\t\t\t\t\\\n+  else if (GET_CODE (ADDR) == PLUS && XEXP (ADDR, 0) == frame_pointer_rtx \\\n+\t   && GET_CODE (XEXP (ADDR, 1)) == CONST_INT)\t\t\t\\\n+    offset = INTVAL (XEXP (ADDR, 1));\t\t\t\t\t\\\n+  else if (GET_CODE (ADDR) == PLUS && XEXP (ADDR, 0) == frame_pointer_rtx) \\\n+    { rtx other_reg = XEXP (ADDR, 1);\t\t\t\t\t\\\n+      offset = 0;\t\t\t\t\t\t\t\\\n+      regs = gen_rtx (PLUS, Pmode, stack_pointer_rtx, other_reg); }\t\\\n+  else if (GET_CODE (ADDR) == PLUS && XEXP (ADDR, 1) == frame_pointer_rtx) \\\n+    { rtx other_reg = XEXP (ADDR, 0);\t\t\t\t\t\\\n+      offset = 0;\t\t\t\t\t\t\t\\\n+      regs = gen_rtx (PLUS, Pmode, stack_pointer_rtx, other_reg); }\t\\\n+  if (offset >= 0)\t\t\t\t\t\t\t\\\n+    { int regno;\t\t\t\t\t\t\t\\\n+      extern char call_used_regs[];\t\t\t\t\t\\\n+      offset += 4; /* I don't know why??? */\t\t\t\t\\\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\t\\\n+        if (regs_ever_live[regno] && ! call_used_regs[regno])\t\t\\\n+          offset += 8;\t\t\t\t\t\t\t\\\n+      ADDR = plus_constant (regs, offset + (DEPTH)); } }\n+\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* #define HAVE_POST_INCREMENT */\n+/* #define HAVE_POST_DECREMENT */\n+\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(regno)  \\\n+((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n+#define REGNO_OK_FOR_BASE_P(regno) \\\n+((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* 1 if X is an rtx for a constant that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X) CONSTANT_P (X)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) \\\n+    (GET_CODE (X) != CONST_DOUBLE)\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) 1\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) 1\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   CONSTANT_ADDRESS_P is actually machine-independent.  */\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n+{ \t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == REG) goto ADDR;\t\t\t\t\t\\\n+  if (CONSTANT_ADDRESS_P (X)) goto ADDR; \t\t\t\t\\\n+  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n+    { /* Handle [index]<address> represented with index-sum outermost */\\\n+      if (GET_CODE (XEXP (X, 0)) == REG && \\\n+\t  GET_CODE (XEXP (X, 1)) == CONST_INT) \\\n+\tgoto ADDR;\t\t\t\t\t\t\t\\\n+      if (GET_CODE (XEXP (X, 1)) == REG && \\\n+\t  GET_CODE (XEXP (X, 0)) == CONST_INT) \\\n+\tgoto ADDR; } \\\n+ }\n+\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   For the vax, nothing needs to be done.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for. */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n+\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the case instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* This flag, if defined, says the same insns that convert to a signed fixnum\n+   also convert validly to an unsigned one.  */\n+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 8\n+\n+/* Define this if zero-extension is slow (more than one real instruction).  */\n+/* #define SLOW_ZERO_EXTEND */\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count.  */\n+/* #define SHIFT_COUNT_TRUNCATED */\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE QImode\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    /* Constant zero is super cheap due to clr instruction.  */\t\\\n+    if (RTX == const0_rtx) return 0;\t\t\t\t\\\n+    if ((unsigned) INTVAL (RTX) < 077) return 1;\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    return 3;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    return 5;\n+\n+/*\n+ * We can use the BSD C library routines for the gnulib calls that are\n+ * still generated, since that's what they boil down to anyways.\n+ */\n+\n+/* #define UDIVSI3_LIBCALL \"*udiv\" */\n+/* #define UMODSI3_LIBCALL \"*urem\" */\n+\n+/* Check a `double' value for validity for a particular machine mode.  */\n+\n+/* note that it is very hard to accidently create a number that fits in a\n+   double but not in a float, since their ranges are almost the same */\n+#define CHECK_FLOAT_VALUE(mode, d) \\\n+  if ((mode) == SFmode) \\\n+    { \\\n+      if ((d) > 1.7014117331926443e+38) \\\n+\t{ error (\"magnitude of constant too large for `float'\"); \\\n+\t  (d) = 1.7014117331926443e+38; } \\\n+      else if ((d) < -1.7014117331926443e+38) \\\n+\t{ error (\"magnitude of constant too large for `float'\"); \\\n+\t  (d) = -1.7014117331926443e+38; } \\\n+      else if (((d) > 0) && ((d) < 2.9387358770557188e-39)) \\\n+\t{ warning (\"`float' constant truncated to zero\"); \\\n+\t  (d) = 0.0; } \\\n+      else if (((d) < 0) && ((d) > -2.9387358770557188e-39)) \\\n+\t{ warning (\"`float' constant truncated to zero\"); \\\n+\t  (d) = 0.0; } \\\n+    }\n+\f\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  No extra ones are needed for the vax.  */\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) \\\n+\tCC_STATUS_INIT;\n+\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Output the name of the file we are compiling.  */\n+#define ASM_OUTPUT_SOURCE_FILENAME(STREAM, NAME) \\\n+    fprintf(STREAM, \"\\t.file\\t\\\"%s\\\"\\n\", NAME);\n+\n+/* Output at beginning of assembler file.  */\n+#define ASM_FILE_START(FILE) fprintf (FILE, \"\");\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"\"\n+\n+/* Output before read-only data.  */\n+\n+#define TEXT_SECTION_ASM_OP \"\\t.inst\"\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \"\\t.var\"\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\".r0\", \".r1\", \".r2\", \".r3\", \".r4\", \".r5\", \".r6\", \".r7\", \".r8\", \\\n+ \".r9\", \".r10\", \".r11\", \".r12\", \".r13\", \".r14\", \".sp\"}\n+\n+/* This is BSD, so it wants DBX format.  */\n+\n+/* #define DBX_DEBUGGING_INFO */\n+\n+/* How to renumber registers for dbx and gdb.\n+   Vax needs no change in the numeration.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* Do not break .stabs pseudos into continuations.  */\n+\n+#define DBX_CONTIN_LENGTH 0\n+\n+/* This is the char to use for continuation (in case we need to turn\n+   continuation back on).  */\n+\n+#define DBX_CONTIN_CHAR '?'\n+\n+/* Don't use the `xsfoo;' construct in DBX output; this system\n+   doesn't support it.  */\n+\n+#define DBX_NO_XREFS\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\"\\t.extdef\\t\", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \".%s%d\", PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a `double' constant.\n+   It is .dfloat or .gfloat, depending.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+{ union {double d; int i[2]; } tem;\t\t\t\t\\\n+  tem.d = (VALUE);\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.data\\t%d{32}, %d{32}\\n\", tem.i[0], tem.i[1]); }\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+{ union {float f; int i; } tem;\t\t\t\t\t\\\n+  tem.f = (VALUE);\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.data %d{32}\\n\", tem.i); }\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( \\\n+\tfprintf (FILE, \"\\t.data\\t\"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"{32}\\n\"))\n+\n+#define ASM_OUTPUT_DOUBLE_INT(FILE,VALUE)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t.data\\t\");\t\t\t\t\\\n+\tif (GET_CODE (VALUE) == CONST_DOUBLE)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"%d\", CONST_DOUBLE_HIGH (VALUE)); \\\n+\t\tfprintf (FILE, \"{32}, \");\t\t\t\\\n+\t\tfprintf (FILE, \"%d\", CONST_DOUBLE_LOW (VALUE)); \\\n+\t\tfprintf (FILE, \"{32}\\n\");\t\t\t\\\n+\t} else if (GET_CODE (VALUE) == CONST_INT)\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t\tint val = INTVAL (VALUE);\t\t\t\\\n+\t\tfprintf (FILE, \"%d\", val < 0 ? -1 : 0);\t\t\\\n+\t\tfprintf (FILE, \"{32}, \");\t\t\t\\\n+\t\tfprintf (FILE, \"%d\", val);\t\t\t\\\n+\t\tfprintf (FILE, \"{32}\\n\");\t\t\t\\\n+\t} else abort ();\t\t\t\t\t\\\n+}\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.data\\t\"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"{16}\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.data\\t\"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"{8}\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.data\\t%d{8}\\n\", (VALUE))\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tsubi.64\\t4,.sp\\n\\tst.32\\t%s,[.sp]\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tld.32\\t%s,[.sp]\\n\\taddi.64\\t4,.sp\\n\", reg_names[REGNO])\n+\n+/* This is how to output an element of a case-vector that is absolute.\n+   (The Vax does not use such vectors,\n+   but we must define this macro anyway.)  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.data .L%d{32}\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\t.data .L%d-.L%d{32}\\n\", VALUE, REL)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n+  if (LOG!=0) fprintf (FILE, \"\\t.align\\t%d\\n\", (LOG)); else 0\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter by SIZE bytes.  */\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.space %d\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%d\\n\", (ROUNDED)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".bss \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%d,%d\\n\", (SIZE),(ROUNDED)))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* Print an instruction operand X on file FILE.\n+   CODE is the code from the %-spec that requested printing this operand;\n+   if `%z3' was used to print operand 3, then CODE is 'z'.  */\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+{ \\\n+  if (CODE == 'r' && GET_CODE (X) == MEM && GET_CODE (XEXP (X, 0)) == REG)\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", reg_names[REGNO (XEXP (X, 0))]);\t\t\\\n+  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    output_address (XEXP (X, 0));\t\t\t\t\t\\\n+  else \\\n+  { \\\n+\t/*debug_rtx(X);*/ \\\n+\tputc ('=', FILE); \\\n+\toutput_addr_const (FILE, X); } \\\n+   }\n+\n+/* Print a memory operand whose address is X, on file FILE.\n+   This uses a function in output-vax.c.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+ print_operand_address (FILE, ADDR)\n+\n+/* Functions used in the md file. */\n+\n+extern char *cmp_set();\n+extern char *cmp_jmp();\n+\n+/* These are stubs, and have yet to bee written. */\n+\n+#define TRAMPOLINE_SIZE 26\n+#define TRAMPOLINE_TEMPLATE(FILE)\n+#define  INITIALIZE_TRAMPOLINE(TRAMP,FNADDR,CXT)"}, {"sha": "f9a0cb6993964677268192f75816487f369456d2", "filename": "gcc/config/elxsi/elxsi.md", "status": "added", "additions": 1440, "deletions": 0, "changes": 1440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99281ca45f7416b82a4b590d0c6077e4c63651a4/gcc%2Fconfig%2Felxsi%2Felxsi.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99281ca45f7416b82a4b590d0c6077e4c63651a4/gcc%2Fconfig%2Felxsi%2Felxsi.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Felxsi.md?ref=99281ca45f7416b82a4b590d0c6077e4c63651a4", "patch": "@@ -0,0 +1,1440 @@\n+;;- Machine description for GNU compiler\n+;;- Elxsi Version\n+;;   Copyright (C) 1987, 1988, 1992 Free Software Foundation, Inc.\n+;;  This port done by Mike Stump <mrs@cygnus.com> in 1988, and is the first\n+;;  64 bit port of GNU CC.\n+;;  Based upon the VAX port.\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 1, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+\n+;;- Instruction patterns.  When multiple patterns apply,\n+;;- the first one in the file is chosen.\n+;;-\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+;;-\n+;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n+;;- updates for most instructions.\n+\n+\n+(define_insn \"\"\n+  [(set (reg:SI 15)\n+\t (plus:SI (reg:SI 15)\n+\t\t  (match_operand:SI 0 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"add.64\\\\t.sp,%0\")\n+\n+(define_insn \"\"\n+  [(set (reg:SI 15)\n+\t (plus:SI (match_operand:SI 0 \"general_operand\" \"g\")\n+\t\t  (reg:SI 15)))]\n+  \"\"\n+  \"add.64\\\\t.sp,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"r\")\n+\t (plus:SI (reg:SI 15)\n+\t\t  (match_operand:SI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"ld.32\\\\t%0,.sp\\;add.64\\\\t%0,%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"r\")\n+\t (plus:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t  (reg:SI 15)))]\n+  \"\"\n+  \"ld.32\\\\t%0,.sp\\;add.64\\\\t%0,%1\")\n+\n+(define_insn \"\"\n+  [(set (reg:SI 15)\n+\t (minus:SI (reg:SI 15)\n+\t\t   (match_operand:SI 0 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"sub.64\\\\t.sp,%0\")\n+\n+(define_insn \"\"\n+  [(set (reg:SI 15)\n+\t (match_operand:SI 0 \"general_operand\" \"rm\"))]\n+  \"\"\n+  \"ld.32\\\\t.sp,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"m,r\")\n+\t (reg:SI 15))]\n+  \"\"\n+  \"*\n+  if (which_alternative == 0)\n+    return \\\"st.32\\\\t.sp,%0\\\";\n+  return \\\"ld.32\\\\t%0,.sp\\\";\n+\")\n+\n+; tstdi is first test insn so that it is the one to match\n+; a constant argument.\n+\n+(define_insn \"tstdi\"\n+  [(set (cc0)\n+\t(match_operand:DI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"*\n+    extern rtx cmp_op0, cmp_op1;\n+    cmp_op0=operands[0]; cmp_op1=0;\n+    return \\\";\\\\ttstdi\\\\t%0\\\";\n+\")\n+\n+(define_insn \"tstdf\"\n+  [(set (cc0)\n+\t(match_operand:DF 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"*\n+    extern rtx cmp_op0, cmp_op1;\n+    cmp_op0=operands[0]; cmp_op1=0;\n+    return \\\";\\\\ttstdf\\\\t%0\\\";\n+\")\n+\n+(define_insn \"tstsf\"\n+  [(set (cc0)\n+\t(match_operand:SF 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"*\n+    extern rtx cmp_op0, cmp_op1;\n+    cmp_op0=operands[0]; cmp_op1=0;\n+    return \\\";\\\\ttstsf\\\\t%0\\\";\n+\")\n+\n+(define_insn \"cmpdi\"\n+  [(set (cc0)\n+\t(compare (match_operand:DI 0 \"register_operand\" \"r\")\n+\t\t (match_operand:DI 1 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"*\n+    extern rtx cmp_op0, cmp_op1;\n+    cmp_op0=operands[0]; cmp_op1=operands[1];\n+    return \\\";\\\\tcmpdi\\\\t%0,%1\\\";\n+\")\n+\n+(define_insn \"cmpdf\"\n+  [(set (cc0)\n+\t(compare (match_operand:DF 0 \"register_operand\" \"r\")\n+\t\t (match_operand:DF 1 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"*\n+    extern rtx cmp_op0, cmp_op1;\n+    cmp_op0=operands[0]; cmp_op1=operands[1];\n+    return \\\";\\\\tcmpdf\\\\t%0,%1\\\";\n+\")\n+\n+(define_insn \"cmpsf\"\n+  [(set (cc0)\n+\t(compare (match_operand:SF 0 \"register_operand\" \"r\")\n+\t\t (match_operand:SF 1 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"*\n+    extern rtx cmp_op0, cmp_op1;\n+    cmp_op0=operands[0]; cmp_op1=operands[1];\n+    return \\\";\\\\tcmpsf\\\\t%0,%1\\\";\n+\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (eq (match_operand:DI 1 \"register_operand\" \"r\")\n+\t         (match_operand:DI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmp.64\\\\t%0,%1,%2:eq\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (ne (match_operand:DI 1 \"register_operand\" \"r\")\n+\t         (match_operand:DI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmp.64\\\\t%0,%1,%2:ne\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (le (match_operand:DI 1 \"register_operand\" \"r\")\n+\t         (match_operand:DI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmp.64\\\\t%0,%1,%2:le\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (leu (match_operand:DI 1 \"register_operand\" \"r\")\n+\t         (match_operand:DI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmpu.64\\\\t%0,%1,%2:le\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (lt (match_operand:DI 1 \"register_operand\" \"r\")\n+\t         (match_operand:DI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmp.64\\\\t%0,%1,%2:lt\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (ltu (match_operand:DI 1 \"register_operand\" \"r\")\n+\t         (match_operand:DI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmpu.64\\\\t%0,%1,%2:lt\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (ge (match_operand:DI 1 \"register_operand\" \"r\")\n+\t         (match_operand:DI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmp.64\\\\t%0,%1,%2:ge\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (geu (match_operand:DI 1 \"register_operand\" \"r\")\n+\t         (match_operand:DI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmpu.64\\\\t%0,%1,%2:ge\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (gt (match_operand:DI 1 \"register_operand\" \"r\")\n+\t         (match_operand:DI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmp.64\\\\t%0,%1,%2:gt\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (gtu (match_operand:DI 1 \"register_operand\" \"r\")\n+\t         (match_operand:DI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmpu.64\\\\t%0,%1,%2:gt\")\n+\n+(define_insn \"seq\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(eq (cc0) (const_int 0)))]\n+  \"\"\n+  \"* return cmp_set(\\\"\\\", \\\"eq\\\", operands[0]); \")\n+\n+(define_insn \"sne\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ne (cc0) (const_int 0)))]\n+  \"\"\n+  \"* return cmp_set(\\\"\\\", \\\"ne\\\", operands[0]); \")\n+\n+(define_insn \"sle\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(le (cc0) (const_int 0)))]\n+  \"\"\n+  \"* return cmp_set(\\\"\\\", \\\"le\\\", operands[0]); \")\n+\n+(define_insn \"sleu\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(leu (cc0) (const_int 0)))]\n+  \"\"\n+  \"* return cmp_set(\\\"u\\\", \\\"le\\\", operands[0]); \")\n+\n+(define_insn \"slt\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(lt (cc0) (const_int 0)))]\n+  \"\"\n+  \"* return cmp_set(\\\"\\\", \\\"lt\\\", operands[0]); \")\n+\n+(define_insn \"sltu\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ltu (cc0) (const_int 0)))]\n+  \"\"\n+  \"* return cmp_set(\\\"u\\\", \\\"lt\\\", operands[0]); \")\n+\n+(define_insn \"sge\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ge (cc0) (const_int 0)))]\n+  \"\"\n+  \"* return cmp_set(\\\"\\\", \\\"ge\\\", operands[0]); \")\n+\n+(define_insn \"sgeu\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(geu (cc0) (const_int 0)))]\n+  \"\"\n+  \"* return cmp_set(\\\"u\\\", \\\"ge\\\", operands[0]); \")\n+\n+(define_insn \"sgt\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(gt (cc0) (const_int 0)))]\n+  \"\"\n+  \"* return cmp_set(\\\"\\\", \\\"gt\\\", operands[0]); \")\n+\n+(define_insn \"sgtu\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(gtu (cc0) (const_int 0)))]\n+  \"\"\n+  \"* return cmp_set(\\\"u\\\", \\\"gt\\\", operands[0]); \")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(eq (match_operand:SI 1 \"register_operand\" \"r\")\n+\t    (match_operand:SI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.32\\\\t%0,%1,%2:eq\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ne (match_operand:SI 1 \"register_operand\" \"r\")\n+\t    (match_operand:SI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.32\\\\t%0,%1,%2:ne\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(le (match_operand:SI 1 \"register_operand\" \"r\")\n+\t    (match_operand:SI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.32\\\\t%0,%1,%2:le\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(leu (match_operand:SI 1 \"register_operand\" \"r\")\n+\t    (match_operand:SI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmpu.32\\\\t%0,%1,%2:le\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lt (match_operand:SI 1 \"register_operand\" \"r\")\n+\t    (match_operand:SI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.32\\\\t%0,%1,%2:lt\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ltu (match_operand:SI 1 \"register_operand\" \"r\")\n+\t    (match_operand:SI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmpu.32\\\\t%0,%1,%2:lt\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ge (match_operand:SI 1 \"register_operand\" \"r\")\n+\t    (match_operand:SI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.32\\\\t%0,%1,%2:ge\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(geu (match_operand:SI 1 \"register_operand\" \"r\")\n+\t    (match_operand:SI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmpu.32\\\\t%0,%1,%2:ge\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(gt (match_operand:SI 1 \"register_operand\" \"r\")\n+\t    (match_operand:SI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.32\\\\t%0,%1,%2:gt\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(gtu (match_operand:SI 1 \"register_operand\" \"r\")\n+\t    (match_operand:SI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmpu.32\\\\t%0,%1,%2:gt\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(eq (match_operand:HI 1 \"register_operand\" \"r\")\n+\t    (match_operand:HI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.16\\\\t%0,%1,%2:eq\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ne (match_operand:HI 1 \"register_operand\" \"r\")\n+\t    (match_operand:HI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.16\\\\t%0,%1,%2:ne\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(le (match_operand:HI 1 \"register_operand\" \"r\")\n+\t    (match_operand:HI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.16\\\\t%0,%1,%2:le\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(leu (match_operand:HI 1 \"register_operand\" \"r\")\n+\t    (match_operand:HI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmpu.16\\\\t%0,%1,%2:le\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(lt (match_operand:HI 1 \"register_operand\" \"r\")\n+\t    (match_operand:HI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.16\\\\t%0,%1,%2:lt\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ltu (match_operand:HI 1 \"register_operand\" \"r\")\n+\t    (match_operand:HI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmpu.16\\\\t%0,%1,%2:lt\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ge (match_operand:HI 1 \"register_operand\" \"r\")\n+\t    (match_operand:HI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.16\\\\t%0,%1,%2:ge\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(geu (match_operand:HI 1 \"register_operand\" \"r\")\n+\t    (match_operand:HI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmpu.16\\\\t%0,%1,%2:ge\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(gt (match_operand:HI 1 \"register_operand\" \"r\")\n+\t    (match_operand:HI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.16\\\\t%0,%1,%2:gt\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(gtu (match_operand:HI 1 \"register_operand\" \"r\")\n+\t    (match_operand:HI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmpu.16\\\\t%0,%1,%2:gt\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(eq (match_operand:QI 1 \"register_operand\" \"r\")\n+\t    (match_operand:QI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.8\\\\t%0,%1,%2:eq\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(ne (match_operand:QI 1 \"register_operand\" \"r\")\n+\t    (match_operand:QI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.8\\\\t%0,%1,%2:ne\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(le (match_operand:QI 1 \"register_operand\" \"r\")\n+\t    (match_operand:QI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.8\\\\t%0,%1,%2:le\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(leu (match_operand:QI 1 \"register_operand\" \"r\")\n+\t    (match_operand:QI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmpu.8\\\\t%0,%1,%2:le\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(lt (match_operand:QI 1 \"register_operand\" \"r\")\n+\t    (match_operand:QI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.8\\\\t%0,%1,%2:lt\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(ltu (match_operand:QI 1 \"register_operand\" \"r\")\n+\t    (match_operand:QI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmpu.8\\\\t%0,%1,%2:lt\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(ge (match_operand:QI 1 \"register_operand\" \"r\")\n+\t    (match_operand:QI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.8\\\\t%0,%1,%2:ge\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(geu (match_operand:QI 1 \"register_operand\" \"r\")\n+\t    (match_operand:QI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmpu.8\\\\t%0,%1,%2:ge\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(gt (match_operand:QI 1 \"register_operand\" \"r\")\n+\t    (match_operand:QI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmp.8\\\\t%0,%1,%2:gt\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(gtu (match_operand:QI 1 \"register_operand\" \"r\")\n+\t    (match_operand:QI 2 \"general_operand\" \"m\")))]\n+  \"\"\n+  \"cmpu.8\\\\t%0,%1,%2:gt\")\n+\n+\f\n+\n+(define_insn \"movdf\"  [(set (match_operand:DF 0 \"general_operand\" \"=r,m\")\n+\t(match_operand:DF 1 \"general_operand\" \"rm,r\"))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"ld.64\\\\t%0,%1\\\";\n+  return \\\"st.64\\\\t%1,%0\\\";\n+}\")\n+\n+(define_insn \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=r,m\")\n+\t(match_operand:SF 1 \"general_operand\" \"rm,r\"))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"ld.32\\\\t%0,%1\\\";\n+  return \\\"st.32\\\\t%1,%0\\\";\n+}\")\n+\n+(define_insn \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=r,m,rm\")\n+\t(match_operand:DI 1 \"general_operand\" \"g,r,I\"))]\n+  \"\"\n+  \"*\n+  if (which_alternative == 0)\n+    return \\\"ld.64\\\\t%0,%1\\\";\n+  else if (which_alternative == 1)\n+    return \\\"st.64\\\\t%1,%0\\\";\n+  else\n+    if (GET_CODE(operands[1])==CONST_INT) {\n+      if (INTVAL(operands[1]) >= 0)\n+        return \\\"sti.64\\\\t%c1,%0\\\";\n+      else\n+        return \\\"stin.64\\\\t%n1,%0\\\";\n+    }\n+\")\n+\n+(define_insn \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r,m,r\")\n+\t(match_operand:SI 1 \"general_operand\" \"rm,rI,i\"))]\n+  \"\"\n+  \"*\n+  if (which_alternative == 0)\n+    return \\\"ld.32\\\\t%0,%1\\\";\n+  else if (which_alternative == 1) {\n+    if (GET_CODE(operands[1])==CONST_INT) {\n+      if (INTVAL(operands[1]) >= 0)\n+        return \\\"sti.32\\\\t%c1,%0\\\";\n+      else\n+        return \\\"stin.32\\\\t%n1,%0\\\";\n+    }\n+    return \\\"st.32\\\\t%1,%0\\\";\n+  } else\n+    return \\\"ld.64\\\\t%0,%1 ; I only want 32\\\";\n+\")\n+\n+(define_insn \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,m,r\")\n+\t(match_operand:HI 1 \"general_operand\" \"m,rI,ri\"))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"ld.16\\\\t%0,%1\\\";\n+  if (which_alternative == 2)\n+    return \\\"ld.64\\\\t%0,%1\\\\t; I only want 16\\\";\n+  if (GET_CODE(operands[1])==CONST_INT) {\n+    if (INTVAL(operands[1]) >= 0)\n+      return \\\"sti.16\\\\t%c1,%0\\\";\n+    else\n+      return \\\"stin.16\\\\t%n1,%0\\\";\n+  }\n+  return \\\"st.16\\\\t%1,%0\\\";\n+}\")\n+\n+(define_insn \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,m,r\")\n+\t(match_operand:QI 1 \"general_operand\" \"m,rI,ri\"))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"ld.8\\\\t%0,%1\\\";\n+  if (which_alternative == 2)\n+    return \\\"ld.64\\\\t%0,%1\\\\t; I only want 8\\\";\n+  if (GET_CODE(operands[1])==CONST_INT) {\n+    if (INTVAL(operands[1]) >= 0)\n+      return \\\"sti.8\\\\t%c1,%0\\\";\n+    else\n+      return \\\"stin.8\\\\t%n1,%0\\\";\n+  }\n+  return \\\"st.8\\\\t%1,%0\\\";\n+}\")\n+\f\n+;; Extension and truncation insns.\n+;; Those for integer source operand\n+;; are ordered widest source type first.\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(truncate:SF (match_operand:DF 1 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"cvt.ds\\\\t%0,%1\")\n+\n+(define_insn \"truncdiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,m,r\")\n+\t(truncate:QI (match_operand:DI 1 \"general_operand\" \"m,r,0\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"ld.8\\\\t%0,%1\\\";\n+  else if (which_alternative == 1)\n+    return \\\"st.8\\\\t%1,%0\\\";\n+  return \\\"\\\";\n+}\")\n+\n+(define_insn \"truncdihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,m,r\")\n+\t(truncate:HI (match_operand:DI 1 \"general_operand\" \"m,r,0\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"ld.16\\\\t%0,%1\\\";\n+  if (which_alternative == 1)\n+    return \\\"st.16\\\\t%1,%0\\\";\n+  return \\\"\\\";\n+}\")\n+\n+(define_insn \"truncdisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r,m\")\n+\t(truncate:SI (match_operand:DI 1 \"general_operand\" \"rm,r\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"ld.32\\\\t%0,%1\\\";\n+  return \\\"st.32\\\\t%1,%0\\\";\n+}\")\n+\n+(define_insn \"truncsiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,m,r\")\n+\t(truncate:QI (match_operand:SI 1 \"general_operand\" \"m,r,0\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"ld.8\\\\t%0,%1\\\";\n+  if (which_alternative == 1)\n+    return \\\"st.8\\\\t%1,%0\\\";\n+  return \\\"\\\";\n+}\")\n+\n+(define_insn \"truncsihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,m,r\")\n+\t(truncate:HI (match_operand:SI 1 \"general_operand\" \"m,r,0\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"ld.16\\\\t%0,%1\\\";\n+  if (which_alternative == 1)\n+    return \\\"st.16\\\\t%1,%0\\\";\n+  return \\\"\\\";\n+}\")\n+\n+(define_insn \"trunchiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,m,r\")\n+\t(truncate:QI (match_operand:HI 1 \"general_operand\" \"m,r,0\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"ld.8\\\\t%0,%1\\\";\n+  if (which_alternative == 1)\n+    return \\\"st.8\\\\t%1,%0\\\";\n+  return \\\"\\\";\n+}\")\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DF (match_operand:SF 1 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"cvt.sd\\\\t%0,%1\")\n+\n+(define_insn \"extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI (match_operand:SI 1 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"ld.32\\\\t%0,%1\")\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+     if (which_alternative==0)\n+       return \\\"ld.16\\\\t%0,%1\\\";\n+     return \\\"extract\\\\t%0,%1:bit 48,16\\\";\n+\")\n+\n+(define_insn \"extendhidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:DI (match_operand:HI 1 \"general_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+     if (which_alternative==0)\n+       return \\\"ld.16\\\\t%0,%1\\\";\n+     return \\\"extract\\\\t%0,%1:bit 48,16\\\";\n+\")\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"general_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+     if (which_alternative==0)\n+       return \\\"ld.8\\\\t%0,%1\\\";\n+     return \\\"extract\\\\t%0,%1:bit 56,8\\\";\n+\")\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"general_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+     if (which_alternative==0)\n+       return \\\"ld.8\\\\t%0,%1\\\";\n+     return \\\"extract\\\\t%0,%1:bit 56,8\\\";\n+\")\n+\n+(define_insn \"extendqidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:DI (match_operand:QI 1 \"general_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+     if (which_alternative==0)\n+       return \\\"ld.8\\\\t%0,%1\\\";\n+     return \\\"extract\\\\t%0,%1:bit 56,8\\\";\n+\")\n+\n+(define_insn \"zero_extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (match_operand:SI 1 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"ldz.32\\\\t%0,%1\")\n+\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"general_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+     if (which_alternative==0)\n+       return \\\"ldz.16\\\\t%0,%1\\\";\n+     return \\\"extractz\\\\t%0,%1:bit 48,16\\\";\n+\")\n+\n+(define_insn \"zero_extendhidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:DI (match_operand:HI 1 \"general_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+     if (which_alternative==0)\n+       return \\\"ldz.16\\\\t%0,%1\\\";\n+     return \\\"extractz\\\\t%0,%1:bit 48,16\\\";\n+\")\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:HI (match_operand:QI 1 \"general_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+     if (which_alternative==0)\n+       return \\\"ldz.8\\\\t%0,%1\\\";\n+     return \\\"extractz\\\\t%0,%1:bit 56,8\\\";\n+\")\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"general_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+     if (which_alternative==0)\n+       return \\\"ldz.8\\\\t%0,%1\\\";\n+     return \\\"extractz\\\\t%0,%1:bit 56,8\\\";\n+\")\n+\n+(define_insn \"zero_extendqidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:DI (match_operand:QI 1 \"general_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+     if (which_alternative==0)\n+       return \\\"ldz.8\\\\t%0,%1\\\";\n+     return \\\"extractz\\\\t%0,%1:bit 56,8\\\";\n+\")\n+\n+\f\n+\n+(define_insn \"lshldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(lshift:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rn\")))]\n+  \"\"\n+  \"sll\\\\t%0,%1,%2\")\n+\n+(define_insn \"ashrdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rn\")))]\n+  \"\"\n+  \"sra\\\\t%0,%1,%2\")\n+\n+(define_insn \"lshrdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rn\")))]\n+  \"\"\n+  \"srl\\\\t%0,%1,%2\")\n+\n+(define_insn \"ashldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rn\")))]\n+  \"\"\n+  \"sla\\\\t%0,%1,%2\")\n+\n+(define_insn \"anddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(and:DI (match_operand:DI 1 \"general_operand\" \"%0,r\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"g,g\")))]\n+  \"1 /*which_alternative == 0 || check356(operands[2])*/\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"and\\\\t%0,%2\\\";\n+    return \\\"and\\\\t%0,%1,%2\\\";\n+\")\n+\n+(define_insn \"iordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(ior:DI (match_operand:DI 1 \"general_operand\" \"%0,r\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"g,g\")))]\n+  \"1 /*which_alternative == 0 || check356(operands[2])*/\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"or\\\\t%0,%2\\\";\n+    return \\\"or\\\\t%0,%1,%2\\\";\n+\")\n+\n+(define_insn \"xordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(xor:DI (match_operand:DI 1 \"general_operand\" \"%0,r\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"g,g\")))]\n+  \"1 /*which_alternative == 0 || check356(operands[2])*/\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"xor\\\\t%0,%2\\\";\n+    return \\\"xor\\\\t%0,%1,%2\\\";\n+\")\n+\n+(define_insn \"one_cmpldi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(not:DI (match_operand:DI 1 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"not\\\\t%0,%1\")\n+\n+;; gcc 2.1 does not widen ~si into ~di.\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:DI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"not\\\\t%0,%1\")\n+\n+(define_insn \"negdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(neg:DI (match_operand:DI 1 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"neg.64\\\\t%0,%1\")\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(neg:SI (match_operand:SI 1 \"general_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"neg.32\\\\t%0,%1\\\";\n+    return \\\"neg.64\\\\t%0,%1 ; I only want 32\\\";\n+\")\n+\n+(define_insn \"neghi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(neg:HI (match_operand:HI 1 \"general_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"neg.16\\\\t%0,%1\\\";\n+    return \\\"neg.64\\\\t%0,%1 ; I only want 16\\\";\n+\")\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(plus:DF (match_operand:DF 1 \"general_operand\" \"%0\")\n+\t\t  (match_operand:DF 2 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"fadd.64\\\\t%0,%2\")\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(plus:SF (match_operand:SF 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:SF 2 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"fadd.32\\\\t%0,%2\")\n+\n+;; There is also an addi.64  4,.r0'' optimization\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,r\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"g,g\")))]\n+  \"1 /*which_alternative == 0 || check356(operands[2])*/\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"add.64\\\\t%0,%2\\\";\n+    return \\\"add.64\\\\t%0,%1,%2\\\";\n+\")\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,r,0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"m,m,g\")))]\n+  \"1 /*which_alternative != 1 || check356(operands[2])*/\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"add.32\\\\t%0,%2\\\";\n+    if (which_alternative == 1)\n+      return \\\"add.32\\\\t%0,%1,%2\\\";\n+    return \\\"add.64\\\\t%0,%2 ; I only want 32\\\";\n+\")\n+\n+(define_insn \"addhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n+\t(plus:HI (match_operand:HI 1 \"general_operand\" \"%0,r,0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"m,m,g\")))]\n+  \"1 /*which_alternative != 1 || check356(operands[2])*/\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"add.16\\\\t%0,%2\\\";\n+    if (which_alternative == 1)\n+      return \\\"add.16\\\\t%0,%1,%2\\\";\n+    return \\\"add.64\\\\t%0,%2 ; I only want 16\\\";\n+\")\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(minus:DF (match_operand:DF 1 \"general_operand\" \"0\")\n+\t\t  (match_operand:DF 2 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"fsub.64\\\\t%0,%2\")\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(minus:SF (match_operand:SF 1 \"general_operand\" \"0\")\n+\t\t  (match_operand:SF 2 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"fsub.32\\\\t%0,%2\")\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n+\t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,g,r\")\n+\t\t  (match_operand:DI 2 \"general_operand\" \"g,r,g\")))]\n+  \"1 /*which_alternative == 0 || check356(operands[which_alternative])*/\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"sub.64\\\\t%0,%2\\\";\n+    else if (which_alternative == 1)\n+      return \\\"subr.64\\\\t%0,%2,%1\\\";\n+    else\n+      return \\\"sub.64\\\\t%0,%1,%2\\\";\n+\")\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,m,r,0\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"m,r,m,g\")))]\n+  \"1 /*which_alternative == 0 || check356(operands[which_alternative])*/\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"sub.32\\\\t%0,%2\\\";\n+    else if (which_alternative == 1)\n+      return \\\"subr.32\\\\t%0,%2,%1\\\";\n+    else if (which_alternative == 2)\n+      return \\\"sub.32\\\\t%0,%1,%2\\\";\n+    else\n+      return \\\"sub.64\\\\t%0,%2 ; I only want 32\\\";\n+\")\n+\n+(define_insn \"subhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,m,r,0\")\n+\t\t  (match_operand:HI 2 \"general_operand\" \"m,r,m,g\")))]\n+  \"1 /*which_alternative == 0 || check356(operands[which_alternative])*/\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"sub.16\\\\t%0,%2\\\";\n+    else if (which_alternative == 1)\n+      return \\\"subr.16\\\\t%0,%2,%1\\\";\n+    else if (which_alternative == 2)\n+      return \\\"sub.16\\\\t%0,%1,%2\\\";\n+    else\n+      return \\\"sub.64\\\\t%0,%2 ; I only want 16\\\";\n+\")\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(mult:DF (match_operand:DF 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:DF 2 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"fmul.64\\\\t%0,%2\")\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(mult:SF (match_operand:SF 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:SF 2 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"fmul.32\\\\t%0,%2\")\n+\n+(define_insn \"muldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(mult:DI (match_operand:DI 1 \"general_operand\" \"%0,r\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"g,g\")))]\n+  \"1 /*which_alternative == 0 || check356(operands[2])*/\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"mul.64\\\\t%0,%2\\\";\n+    return \\\"mul.64\\\\t%0,%1,%2\\\";\n+\")\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(mult:SI (match_operand:SI 1 \"general_operand\" \"%0,r,0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"m,m,g\")))]\n+  \"1 /*which_alternative == 0 || check356(operands[2])*/\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"mul.32\\\\t%0,%2\\\";\n+    else if (which_alternative == 1)\n+      return \\\"mul.32\\\\t%0,%1,%2\\\";\n+    else\n+      return \\\"mul.64\\\\t%0,%2 ; I only want 32\\\";\n+\")\n+\n+(define_insn \"mulhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n+\t(mult:HI (match_operand:HI 1 \"general_operand\" \"%0,r,0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"m,m,g\")))]\n+  \"1 /*which_alternative == 0 || check356(operands[2])*/\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"mul.16\\\\t%0,%2\\\";\n+    else if (which_alternative == 1)\n+      return \\\"mul.16\\\\t%0,%1,%2\\\";\n+    else\n+      return \\\"mul.64\\\\t%0,%2 ; I only want 16\\\";\n+\")\n+\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(div:DF (match_operand:DF 1 \"general_operand\" \"0\")\n+\t\t(match_operand:DF 2 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"fdiv.64\\\\t%0,%2\")\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(div:SF (match_operand:SF 1 \"general_operand\" \"0\")\n+\t\t(match_operand:SF 2 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"fdiv.32\\\\t%0,%2\")\n+\n+(define_insn \"divdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n+\t(div:DI (match_operand:DI 1 \"general_operand\" \"0,g,r\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"g,r,g\")))]\n+  \"1 /*which_alternative == 0 || check356(operands[which_alternative])*/\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"div.64\\\\t%0,%2\\\";\n+    else if (which_alternative == 1)\n+      return \\\"divr.64\\\\t%0,%2,%1\\\";\n+    else\n+      return \\\"div.64\\\\t%0,%1,%2\\\";\n+\")\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(div:SI (match_operand:SI 1 \"general_operand\" \"0,m,r,0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"m,r,m,g\")))]\n+  \"1 /*which_alternative == 0 || check356(operands[which_alternative])*/\"\n+  \"*\n+/* We don't ignore high bits. */\n+if (0) {\n+    if (which_alternative == 0)\n+      return \\\"div.32\\\\t%0,%2\\\";\n+    else if (which_alternative == 1)\n+      return \\\"divr.32\\\\t%0,%2,%1\\\";\n+    else if (which_alternative == 2)\n+      return \\\"div.32\\\\t%0,%1,%2\\\";\n+    else\n+      return \\\"ld.32\\\\t%0,%0\\;div.64\\\\t%0,%2 ; I only want 32\\\";\n+} else {\n+    if (which_alternative == 0)\n+      return \\\"ld.32\\\\t%0,%0\\;div.32\\\\t%0,%2\\\";\n+    else if (which_alternative == 1)\n+      return \\\"ld.32\\\\t%2,%2\\;divr.32\\\\t%0,%2,%1\\\";\n+    else if (which_alternative == 2)\n+      return \\\"ld.32\\\\t%1,%1\\;div.32\\\\t%0,%1,%2\\\";\n+    else\n+      return \\\"ld.32\\\\t%0,%0\\;div.64\\\\t%0,%2 ; I only want 32\\\";\n+}\n+\")\n+\n+(define_insn \"divhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r,r\")\n+\t(div:HI (match_operand:HI 1 \"general_operand\" \"0,m,r,0,0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"m,r,m,r,i\")))]\n+  \"1 /*which_alternative == 0 || check356(operands[which_alternative])*/\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"extract\\\\t%0,%0:bit 48,16\\;div.16\\\\t%0,%2\\\";\n+    else if (which_alternative == 1)\n+      return \\\"extract\\\\t%2,%2:bit 48,16\\;divr.16\\\\t%0,%2,%1\\\";\n+    else if (which_alternative == 2)\n+      return \\\"extract\\\\t%1,%1:bit 48,16\\;div.16\\\\t%0,%1,%2\\\";\n+    else if (which_alternative == 3)\n+      return \\\"extract\\\\t%0,%0:bit 48,16\\;extract\\\\t%2,%2:bit 48,16\\;div.64\\\\t%0,%2 ; I only want 16\\\";\n+    else\n+      return \\\"extract\\\\t%0,%0:bit 48,16\\;div.64\\\\t%0,%2 ; I only want 16\\\";\n+\")\n+\n+(define_insn \"modhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r,r\")\n+\t(mod:HI (match_operand:HI 1 \"general_operand\" \"0,m,r,0,0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"m,r,m,r,i\")))]\n+  \"1 /*which_alternative == 0 || check356(operands[which_alternative])*/\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"extract\\\\t%0,%0:bit 48,16\\;rem.16\\\\t%0,%2\\\";\n+    else if (which_alternative == 1)\n+      return \\\"extract\\\\t%2,%2:bit 48,16\\;remr.16\\\\t%0,%2,%1\\\";\n+    else if (which_alternative == 2)\n+      return \\\"extract\\\\t%1,%1:bit 48,16\\;rem.16\\\\t%0,%1,%2\\\";\n+    else if (which_alternative == 3)\n+      return \\\"extract\\\\t%0,%0:bit 48,16\\;extract\\\\t%2,%2:bit 48,16\\;rem.64\\\\t%0,%2 ; I only want 16\\\";\n+    else\n+      return \\\"extract\\\\t%0,%0:bit 48,16\\;rem.64\\\\t%0,%2 ; I only want 16\\\";\n+\")\n+\n+(define_insn \"moddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n+\t(mod:DI (match_operand:DI 1 \"general_operand\" \"0,g,r\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"g,r,g\")))]\n+  \"1 /*which_alternative == 0 || check356(operands[which_alternative])*/\"\n+  \"*\n+    if (which_alternative == 0)\n+      return \\\"rem.64\\\\t%0,%2\\\";\n+    else if (which_alternative == 1)\n+      return \\\"remr.64\\\\t%0,%2,%1\\\";\n+    else\n+      return \\\"rem.64\\\\t%0,%1,%2\\\";\n+\")\n+\n+(define_insn \"modsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(mod:SI (match_operand:SI 1 \"general_operand\" \"0,m,r,0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"m,r,m,g\")))]\n+  \"1 /*which_alternative == 0 || check356(operands[which_alternative])*/\"\n+  \"*\n+/* There is a micro code bug with the below... */\n+if (0) {\n+    if (which_alternative == 0)\n+      return \\\"rem.32\\\\t%0,%2\\\";\n+    else if (which_alternative == 1)\n+      return \\\"remr.32\\\\t%0,%2,%1\\\";\n+    else if (which_alternative == 2)\n+      return \\\"rem.32\\\\t%0,%1,%2\\\";\n+    else\n+      return \\\"ld.32\\\\t%0,%0\\;rem.64\\\\t%0,%2 ; I only want 32\\\";\n+} else {\n+    if (which_alternative == 0)\n+      return \\\"ld.32\\\\t%0,%0\\;rem.32\\\\t%0,%2\\\";\n+    else if (which_alternative == 1)\n+      return \\\"ld.32\\\\t%2,%2\\;remr.32\\\\t%0,%2,%1\\\";\n+    else if (which_alternative == 2)\n+      return \\\"ld.32\\\\t%1,%1\\;rem.32\\\\t%0,%1,%2\\\";\n+    else\n+      return \\\"ld.32\\\\t%0,%0\\;rem.64\\\\t%0,%2 ; I only want 32\\\";\n+}\n+\")\n+\n+\f\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"jmp\\\\t%l0\")\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+;; Maybe %l0 is better, maybe we can relax register only.\n+  \"verify this before use ld.32\\\\t.r0,%0\\;br.reg\\\\t.r0\")\n+\n+(define_insn \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"\\\", 2, operands[0]); \")\n+\n+(define_insn \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"\\\", 8, operands[0]); \")\n+\n+(define_insn \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"\\\", 0, operands[0]); \")\n+\n+(define_insn \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"u\\\", 0, operands[0]); \")\n+\n+(define_insn \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"\\\", 6, operands[0]); \")\n+\n+(define_insn \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"u\\\", 6, operands[0]); \")\n+\n+(define_insn \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"\\\", 4, operands[0]); \")\n+\n+(define_insn \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"u\\\", 4, operands[0]); \")\n+\n+(define_insn \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"\\\", 10, operands[0]); \")\n+\n+(define_insn \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"u\\\", 10, operands[0]); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"\\\", 8, operands[0]); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"\\\", 2, operands[0]); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"\\\", 10, operands[0]); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"u\\\", 10, operands[0]); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"\\\", 4, operands[0]); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"u\\\", 4, operands[0]); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"\\\", 6, operands[0]); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"u\\\", 6, operands[0]); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"\\\", 0, operands[0]); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return cmp_jmp(\\\"u\\\", 0, operands[0]); \")\n+\n+;; Note that operand 1 is total size of args, in bytes,\n+;; and what the call insn wants is the number of words.\n+(define_insn \"call\"\n+  [(call (match_operand:QI 0 \"general_operand\" \"m\")\n+\t (match_operand:QI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+  if (GET_CODE (operands[0]) == MEM && GET_CODE (XEXP (operands[0], 0)) == REG)\n+    if (REGNO (XEXP (operands[0], 0)) != 0)\n+      return \\\"add.64\\\\t.sp,=-4\\;ld.64\\\\t.r0,=.+11\\;st.32\\\\t.r0,[.sp]\\;br.reg\\\\t%r0\\;add.64\\\\t.sp,=4\\;add.64\\\\t.sp,%1\\\";\n+    else\n+      return \\\"add.64\\\\t.sp,=-4\\;ld.64\\\\t.r1,=.+11\\;st.32\\\\t.r1,[.sp]\\;br.reg\\\\t%r0\\;add.64\\\\t.sp,=4\\;add.64\\\\t.sp,%1\\\";\n+  else\n+    return \\\"add.64\\\\t.sp,=-4\\;call\\\\t%0\\;add.64\\\\t.sp,=4\\;add.64\\\\t.sp,%1\\\";\n+  \")\n+\n+(define_insn \"call_value\"\n+  [(set (match_operand 0 \"\" \"g\")\n+\t(call (match_operand:QI 1 \"general_operand\" \"m\")\n+\t      (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+  if (GET_CODE (operands[1]) == MEM && GET_CODE (XEXP (operands[1], 0)) == REG)\n+    if (REGNO (XEXP (operands[1], 0)) != 0)\n+      return \\\"add.64\\\\t.sp,=-4\\;ld.64\\\\t.r0,=.+11\\;st.32\\\\t.r0,[.sp]\\;br.reg\\\\t%r1\\;add.64\\\\t.sp,=4\\;add.64\\\\t.sp,%2\\\";\n+    else\n+      return \\\"add.64\\\\t.sp,=-4\\;ld.64\\\\t.r1,=.+11\\;st.32\\\\t.r1,[.sp]\\;br.reg\\\\t%r1\\;add.64\\\\t.sp,=4\\;add.64\\\\t.sp,%2\\\";\n+  else\n+    return \\\"add.64\\\\t.sp,=-4\\;call\\\\t%1\\;add.64\\\\t.sp,=4\\;add.64\\\\t.sp,%2\\\";\n+  \")\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"br.reg\\\\t%0\")\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\")\n+\n+\f\n+\f\n+;;- Local variables:\n+;;- mode:emacs-lisp\n+;;- comment-start: \"!;;- \"\n+;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;;- eval: (modify-syntax-entry ?[ \"(]\")\n+;;- eval: (modify-syntax-entry ?] \")[\")\n+;;- eval: (modify-syntax-entry ?{ \"(}\")\n+;;- eval: (modify-syntax-entry ?} \"){\")\n+;;- End:"}, {"sha": "30a458d87b4667b5ab8ad3301ecbc2fe5ade56a9", "filename": "gcc/config/elxsi/x-elxsi", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99281ca45f7416b82a4b590d0c6077e4c63651a4/gcc%2Fconfig%2Felxsi%2Fx-elxsi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99281ca45f7416b82a4b590d0c6077e4c63651a4/gcc%2Fconfig%2Felxsi%2Fx-elxsi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Fx-elxsi?ref=99281ca45f7416b82a4b590d0c6077e4c63651a4", "patch": "@@ -0,0 +1,9 @@\n+# Our make needs a little help...\n+MAKE=make\n+\n+# We don't support -g yet, so don't try and use it.\n+CFLAGS =\n+LIBGCC2_CFLAGS = -O2 $(GCC_CFLAGS)\n+\n+# Hide xmalloc so that it does not conflict with the one in libc.a, Ick!\n+X_CFLAGS = -Dxmalloc=my_xmalloc"}, {"sha": "86bfca11ebb66921781634990b0505dabf117bdb", "filename": "gcc/config/elxsi/xm-elxsi.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99281ca45f7416b82a4b590d0c6077e4c63651a4/gcc%2Fconfig%2Felxsi%2Fxm-elxsi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99281ca45f7416b82a4b590d0c6077e4c63651a4/gcc%2Fconfig%2Felxsi%2Fxm-elxsi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Fxm-elxsi.h?ref=99281ca45f7416b82a4b590d0c6077e4c63651a4", "patch": "@@ -0,0 +1,42 @@\n+/* Configuration for GNU C-compiler for Elxsi.\n+   Copyright (C) 1987 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 1, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* #defines that need visibility everywhere.  */\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* target machine dependencies.\n+   tm.h is a symbolic link to the actual target specific file.   */\n+#include \"tm.h\"\n+\n+/* This describes the machine the compiler is hosted on.  */\n+#define HOST_BITS_PER_CHAR 8\n+#define HOST_BITS_PER_SHORT 16\n+#define HOST_BITS_PER_INT 32\n+#define HOST_BITS_PER_LONG 32\n+\n+/* Arguments to use with `exit'.  */\n+#define SUCCESS_EXIT_CODE 0\n+#define FATAL_EXIT_CODE 33\n+\n+/* If compiled with GNU C, use the built-in alloca */\n+#ifdef __GNUC__\n+#define alloca __builtin_alloca\n+#endif\n+"}]}