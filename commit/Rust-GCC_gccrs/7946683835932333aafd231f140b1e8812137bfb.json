{"sha": "7946683835932333aafd231f140b1e8812137bfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk0NjY4MzgzNTkzMjMzM2FhZmQyMzFmMTQwYjFlODgxMjEzN2JmYg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2015-07-01T12:24:09Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-07-01T12:24:09Z"}, "message": "alloc_traits.h (__alloctr_rebind): Remove.\n\n\t* include/bits/alloc_traits.h (__alloctr_rebind): Remove.\n\t(__allocator_traits_base): New base class.\n\t(__alloc_rebind): Reimplement in terms of detection idiom.\n\t(allocator_traits): Derive from __allocator_traits_base. Reimplement\n\tnested types in terms of detection idiom. Simplify SFINAE constraints\n\ton overloaded static member functions.\n\t* include/bits/hashtable.h (_Hashtable): Use __alloc_rebind instead\n\tof __alloctr_rebind.\n\t* testsuite/20_util/scoped_allocator/propagation.cc: Define rebind.\n\t* testsuite/23_containers/unordered_set/instantiation_neg.cc: Adjust\n\tdg-error line number.\n\nFrom-SVN: r225244", "tree": {"sha": "c9a4fa80f7b0e895d8e2fdc59cfd42a9bddc9bbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9a4fa80f7b0e895d8e2fdc59cfd42a9bddc9bbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7946683835932333aafd231f140b1e8812137bfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7946683835932333aafd231f140b1e8812137bfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7946683835932333aafd231f140b1e8812137bfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7946683835932333aafd231f140b1e8812137bfb/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f44c5556fc384b57ea0c8c6908701bb5f1c4ed4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f44c5556fc384b57ea0c8c6908701bb5f1c4ed4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f44c5556fc384b57ea0c8c6908701bb5f1c4ed4"}], "stats": {"total": 287, "additions": 103, "deletions": 184}, "files": [{"sha": "e87c303d47b089854b8a97bb00c70891a4db2f7b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7946683835932333aafd231f140b1e8812137bfb/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7946683835932333aafd231f140b1e8812137bfb/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7946683835932333aafd231f140b1e8812137bfb", "patch": "@@ -1,5 +1,17 @@\n 2015-07-01  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/bits/alloc_traits.h (__alloctr_rebind): Remove.\n+\t(__allocator_traits_base): New base class.\n+\t(__alloc_rebind): Reimplement in terms of detection idiom.\n+\t(allocator_traits): Derive from __allocator_traits_base. Reimplement\n+\tnested types in terms of detection idiom. Simplify SFINAE constraints\n+\ton overloaded static member functions.\n+\t* include/bits/hashtable.h (_Hashtable): Use __alloc_rebind instead\n+\tof __alloctr_rebind.\n+\t* testsuite/20_util/scoped_allocator/propagation.cc: Define rebind.\n+\t* testsuite/23_containers/unordered_set/instantiation_neg.cc: Adjust\n+\tdg-error line number.\n+\n \t* include/bits/ptr_traits.h (__ptrtr_elt_type, __ptrtr_diff_type,\n \t__ptrtr_rebind, __ptrtr_not_void): Remove\n \t(__get_first_arg, __replace_first_arg, __make_not_void): Define new"}, {"sha": "e5ed92b9e29e44aa5ed595cebf96400536a90bc9", "filename": "libstdc++-v3/include/bits/alloc_traits.h", "status": "modified", "additions": 82, "deletions": 178, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7946683835932333aafd231f140b1e8812137bfb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7946683835932333aafd231f140b1e8812137bfb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h?ref=7946683835932333aafd231f140b1e8812137bfb", "patch": "@@ -40,207 +40,161 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n-  template<typename _Alloc, typename _Tp>\n-    class __alloctr_rebind_helper\n-    {\n-      template<typename _Alloc2, typename _Tp2>\n-\tstatic constexpr true_type\n-\t_S_chk(typename _Alloc2::template rebind<_Tp2>::other*);\n-\n-      template<typename, typename>\n-\tstatic constexpr false_type\n-\t_S_chk(...);\n-\n-    public:\n-      using __type = decltype(_S_chk<_Alloc, _Tp>(nullptr));\n-    };\n-\n-  template<typename _Alloc, typename _Tp,\n-\t   bool = __alloctr_rebind_helper<_Alloc, _Tp>::__type::value>\n-    struct __alloctr_rebind;\n-\n-  template<typename _Alloc, typename _Tp>\n-    struct __alloctr_rebind<_Alloc, _Tp, true>\n-    {\n-      typedef typename _Alloc::template rebind<_Tp>::other __type;\n-    };\n-\n-  template<template<typename, typename...> class _Alloc, typename _Tp,\n-\t   typename _Up, typename... _Args>\n-    struct __alloctr_rebind<_Alloc<_Up, _Args...>, _Tp, false>\n-    {\n-      typedef _Alloc<_Tp, _Args...> __type;\n-    };\n-\n-  template<typename _Alloc, typename _Tp>\n-    using __alloc_rebind = typename __alloctr_rebind<_Alloc, _Tp>::__type;\n+  struct __allocator_traits_base\n+  {\n+    template<typename _Alloc, typename _Up>\n+      using __rebind = typename _Alloc::template rebind<_Up>::other;\n+\n+  protected:\n+    template<typename _Tp>\n+      using __pointer = typename _Tp::pointer;\n+    template<typename _Tp>\n+      using __c_pointer = typename _Tp::const_pointer;\n+    template<typename _Tp>\n+      using __v_pointer = typename _Tp::void_pointer;\n+    template<typename _Tp>\n+      using __cv_pointer = typename _Tp::const_void_pointer;\n+    template<typename _Tp>\n+      using __diff_type = typename _Tp::difference_type;\n+    template<typename _Tp>\n+      using __size_type = typename _Tp::size_type;\n+    template<typename _Tp>\n+      using __pocca = typename _Tp::propagate_on_container_copy_assignment;\n+    template<typename _Tp>\n+      using __pocma = typename _Tp::propagate_on_container_move_assignment;\n+    template<typename _Tp>\n+      using __pocs = typename _Tp::propagate_on_container_swap;\n+    template<typename _Tp>\n+      using __equal = typename _Tp::is_always_equal;\n+  };\n+\n+  template<typename _Alloc, typename _Up>\n+    using __alloc_rebind = __detected_or_t_<__replace_first_arg_t,\n+\t\t\t\t\t    __allocator_traits_base::__rebind,\n+\t\t\t\t\t    _Alloc, _Up>;\n \n   /**\n    * @brief  Uniform interface to all allocator types.\n    * @ingroup allocators\n   */\n   template<typename _Alloc>\n-    struct allocator_traits\n+    struct allocator_traits : __allocator_traits_base\n     {\n       /// The allocator type\n       typedef _Alloc allocator_type;\n       /// The allocated type\n       typedef typename _Alloc::value_type value_type;\n \n-#define _GLIBCXX_ALLOC_TR_NESTED_TYPE(_NTYPE, _ALT) \\\n-  private: \\\n-    template<typename _Tp> \\\n-      static typename _Tp::_NTYPE _S_##_NTYPE##_helper(_Tp*); \\\n-    static _ALT _S_##_NTYPE##_helper(...); \\\n-    typedef decltype(_S_##_NTYPE##_helper((_Alloc*)0)) __##_NTYPE; \\\n-  public:\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(pointer, value_type*)\n-\n       /**\n        * @brief   The allocator's pointer type.\n        *\n        * @c Alloc::pointer if that type exists, otherwise @c value_type*\n       */\n-      typedef __pointer pointer;\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(const_pointer,\n-  typename pointer_traits<pointer>::template rebind<const value_type>)\n+      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;\n \n       /**\n        * @brief   The allocator's const pointer type.\n        *\n        * @c Alloc::const_pointer if that type exists, otherwise\n        * <tt> pointer_traits<pointer>::rebind<const value_type> </tt>\n       */\n-      typedef __const_pointer const_pointer;\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(void_pointer,\n-  typename pointer_traits<pointer>::template rebind<void>)\n+      using const_pointer\n+\t= __detected_or_t<__ptr_rebind<pointer, const value_type>,\n+\t\t\t  __c_pointer, _Alloc>;\n \n       /**\n        * @brief   The allocator's void pointer type.\n        *\n        * @c Alloc::void_pointer if that type exists, otherwise\n        * <tt> pointer_traits<pointer>::rebind<void> </tt>\n       */\n-      typedef __void_pointer void_pointer;\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(const_void_pointer,\n-  typename pointer_traits<pointer>::template rebind<const void>)\n+      using void_pointer\n+\t= __detected_or_t<__ptr_rebind<pointer, void>, __v_pointer, _Alloc>;\n \n       /**\n        * @brief   The allocator's const void pointer type.\n        *\n        * @c Alloc::const_void_pointer if that type exists, otherwise\n        * <tt> pointer_traits<pointer>::rebind<const void> </tt>\n       */\n-      typedef __const_void_pointer const_void_pointer;\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(difference_type,\n-\t\t\t      typename pointer_traits<pointer>::difference_type)\n+      using const_void_pointer\n+\t= __detected_or_t<__ptr_rebind<pointer, const void>, __cv_pointer,\n+\t\t\t  _Alloc>;\n \n       /**\n        * @brief   The allocator's difference type\n        *\n        * @c Alloc::difference_type if that type exists, otherwise\n        * <tt> pointer_traits<pointer>::difference_type </tt>\n       */\n-      typedef __difference_type difference_type;\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(size_type,\n-\t\t\t      typename make_unsigned<difference_type>::type)\n+      using difference_type\n+\t= __detected_or_t<typename pointer_traits<pointer>::difference_type,\n+\t\t\t  __diff_type, _Alloc>;\n \n       /**\n        * @brief   The allocator's size type\n        *\n        * @c Alloc::size_type if that type exists, otherwise\n        * <tt> make_unsigned<difference_type>::type </tt>\n       */\n-      typedef __size_type size_type;\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_copy_assignment,\n-\t\t\t      false_type)\n+      using size_type\n+\t= __detected_or_t<typename make_unsigned<difference_type>::type,\n+\t\t\t  __size_type, _Alloc>;\n \n       /**\n        * @brief   How the allocator is propagated on copy assignment\n        *\n        * @c Alloc::propagate_on_container_copy_assignment if that type exists,\n        * otherwise @c false_type\n       */\n-      typedef __propagate_on_container_copy_assignment\n-\tpropagate_on_container_copy_assignment;\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_move_assignment,\n-\t\t\t      false_type)\n+      using propagate_on_container_copy_assignment\n+\t= __detected_or_t<false_type, __pocca, _Alloc>;\n \n       /**\n        * @brief   How the allocator is propagated on move assignment\n        *\n        * @c Alloc::propagate_on_container_move_assignment if that type exists,\n        * otherwise @c false_type\n       */\n-      typedef __propagate_on_container_move_assignment\n-\tpropagate_on_container_move_assignment;\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,\n-\t\t\t      false_type)\n+      using propagate_on_container_move_assignment\n+\t= __detected_or_t<false_type, __pocma, _Alloc>;\n \n       /**\n        * @brief   How the allocator is propagated on swap\n        *\n        * @c Alloc::propagate_on_container_swap if that type exists,\n        * otherwise @c false_type\n       */\n-      typedef __propagate_on_container_swap propagate_on_container_swap;\n-\n-_GLIBCXX_ALLOC_TR_NESTED_TYPE(is_always_equal,\n-\t\t\t      typename is_empty<_Alloc>::type)\n+      using propagate_on_container_swap\n+\t= __detected_or_t<false_type, __pocs, _Alloc>;\n \n       /**\n        * @brief   Whether all instances of the allocator type compare equal.\n        *\n        * @c Alloc::is_always_equal if that type exists,\n        * otherwise @c is_empty<Alloc>::type\n       */\n-      typedef __is_always_equal is_always_equal;\n-\n-#undef _GLIBCXX_ALLOC_TR_NESTED_TYPE\n+      using is_always_equal\n+\t= __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;\n \n       template<typename _Tp>\n-\tusing rebind_alloc = typename __alloctr_rebind<_Alloc, _Tp>::__type;\n+\tusing rebind_alloc = __alloc_rebind<_Alloc, _Tp>;\n       template<typename _Tp>\n \tusing rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n \n-    private:\n-      template<typename _Alloc2>\n-\tstruct __allocate_helper\n-\t{\n-\t  template<typename _Alloc3,\n-\t    typename = decltype(std::declval<_Alloc3*>()->allocate(\n-\t\t  std::declval<size_type>(),\n-\t\t  std::declval<const_void_pointer>()))>\n-\t    static true_type __test(int);\n-\n-\t  template<typename>\n-\t    static false_type __test(...);\n-\n-\t  using type = decltype(__test<_Alloc>(0));\n-\t};\n+      static_assert(!is_same<rebind_alloc<value_type>, __undefined>::value,\n+\t  \"allocator defines rebind or is like Alloc<T, Args>\");\n \n+    private:\n       template<typename _Alloc2>\n-\tusing __has_allocate = typename __allocate_helper<_Alloc2>::type;\n-\n-      template<typename _Alloc2,\n-\t       typename = _Require<__has_allocate<_Alloc2>>>\n-\tstatic pointer\n-\t_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint)\n+\tstatic auto\n+\t_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)\n+\t-> decltype(__a.allocate(__n, __hint))\n \t{ return __a.allocate(__n, __hint); }\n \n-      template<typename _Alloc2, typename _UnusedHint,\n-\t       typename = _Require<__not_<__has_allocate<_Alloc2>>>>\n+      template<typename _Alloc2>\n \tstatic pointer\n-\t_S_allocate(_Alloc2& __a, size_type __n, _UnusedHint)\n+\t_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)\n \t{ return __a.allocate(__n); }\n \n       template<typename _Tp, typename... _Args>\n@@ -273,57 +227,24 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(is_always_equal,\n \t_S_construct(_Alloc&, _Tp* __p, _Args&&... __args)\n \t{ ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }\n \n-      template<typename _Tp>\n-\tstruct __destroy_helper\n-\t{\n-\t  template<typename _Alloc2,\n-\t    typename = decltype(std::declval<_Alloc2*>()->destroy(\n-\t\t  std::declval<_Tp*>()))>\n-\t    static true_type __test(int);\n-\n-\t  template<typename>\n-\t    static false_type __test(...);\n-\n-\t  using type = decltype(__test<_Alloc>(0));\n-\t};\n-\n-      template<typename _Tp>\n-\tusing __has_destroy = typename __destroy_helper<_Tp>::type;\n-\n-      template<typename _Tp>\n-\tstatic _Require<__has_destroy<_Tp>>\n-\t_S_destroy(_Alloc& __a, _Tp* __p)\n+      template<typename _Alloc2, typename _Tp>\n+\tstatic auto\n+\t_S_destroy(_Alloc2& __a, _Tp* __p, int)\n+\t-> decltype(__a.destroy(__p))\n \t{ __a.destroy(__p); }\n \n-      template<typename _Tp>\n-\tstatic _Require<__not_<__has_destroy<_Tp>>>\n-\t_S_destroy(_Alloc&, _Tp* __p)\n+      template<typename _Alloc2, typename _Tp>\n+\tstatic void\n+\t_S_destroy(_Alloc2&, _Tp* __p, ...)\n \t{ __p->~_Tp(); }\n \n       template<typename _Alloc2>\n-\tstruct __maxsize_helper\n-\t{\n-\t  template<typename _Alloc3,\n-\t    typename = decltype(std::declval<_Alloc3*>()->max_size())>\n-\t    static true_type __test(int);\n-\n-\t  template<typename>\n-\t    static false_type __test(...);\n-\n-\t  using type = decltype(__test<_Alloc2>(0));\n-\t};\n-\n-      template<typename _Alloc2>\n-\tusing __has_max_size = typename __maxsize_helper<_Alloc2>::type;\n-\n-      template<typename _Alloc2,\n-\t       typename = _Require<__has_max_size<_Alloc2>>>\n-\tstatic size_type\n+\tstatic auto\n \t_S_max_size(_Alloc2& __a, int)\n+\t-> decltype(__a.max_size())\n \t{ return __a.max_size(); }\n \n-      template<typename _Alloc2,\n-\t       typename = _Require<__not_<__has_max_size<_Alloc2>>>>\n+      template<typename _Alloc2>\n \tstatic size_type\n \t_S_max_size(_Alloc2&, ...)\n \t{\n@@ -334,30 +255,12 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(is_always_equal,\n \t}\n \n       template<typename _Alloc2>\n-\tstruct __select_helper\n-\t{\n-\t  template<typename _Alloc3, typename\n-\t    = decltype(std::declval<_Alloc3*>()\n-\t\t->select_on_container_copy_construction())>\n-\t    static true_type __test(int);\n-\n-\t  template<typename>\n-\t    static false_type __test(...);\n-\n-\t  using type = decltype(__test<_Alloc2>(0));\n-\t};\n-\n-      template<typename _Alloc2>\n-\tusing __has_soccc = typename __select_helper<_Alloc2>::type;\n-\n-      template<typename _Alloc2,\n-\t       typename = _Require<__has_soccc<_Alloc2>>>\n-\tstatic _Alloc2\n+\tstatic auto\n \t_S_select(_Alloc2& __a, int)\n+\t-> decltype(__a.select_on_container_copy_construction())\n \t{ return __a.select_on_container_copy_construction(); }\n \n-      template<typename _Alloc2,\n-\t       typename = _Require<__not_<__has_soccc<_Alloc2>>>>\n+      template<typename _Alloc2>\n \tstatic _Alloc2\n \t_S_select(_Alloc2& __a, ...)\n \t{ return __a; }\n@@ -388,7 +291,7 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(is_always_equal,\n       */\n       static pointer\n       allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)\n-      { return _S_allocate(__a, __n, __hint); }\n+      { return _S_allocate(__a, __n, __hint, 0); }\n \n       /**\n        *  @brief  Deallocate memory.\n@@ -398,7 +301,8 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(is_always_equal,\n        *\n        *  Calls <tt> a.deallocate(p, n) </tt>\n       */\n-      static void deallocate(_Alloc& __a, pointer __p, size_type __n)\n+      static void\n+      deallocate(_Alloc& __a, pointer __p, size_type __n)\n       { __a.deallocate(__p, __n); }\n \n       /**\n@@ -427,7 +331,7 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(is_always_equal,\n       */\n       template <class _Tp>\n \tstatic void destroy(_Alloc& __a, _Tp* __p)\n-\t{ _S_destroy(__a, __p); }\n+\t{ _S_destroy(__a, __p, 0); }\n \n       /**\n        *  @brief  The maximum supported allocation size"}, {"sha": "48810044079a9ec4761e74897f31e911a4489561", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7946683835932333aafd231f140b1e8812137bfb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7946683835932333aafd231f140b1e8812137bfb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=7946683835932333aafd231f140b1e8812137bfb", "patch": "@@ -179,15 +179,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>,\n       private __detail::_Hashtable_alloc<\n-\ttypename __alloctr_rebind<_Alloc,\n-\t  __detail::_Hash_node<_Value,\n-\t\t\t       _Traits::__hash_cached::value> >::__type>\n+\t__alloc_rebind<_Alloc,\n+\t\t       __detail::_Hash_node<_Value,\n+\t\t\t\t\t    _Traits::__hash_cached::value>>>\n     {\n       using __traits_type = _Traits;\n       using __hash_cached = typename __traits_type::__hash_cached;\n       using __node_type = __detail::_Hash_node<_Value, __hash_cached::value>;\n-      using __node_alloc_type =\n-\ttypename __alloctr_rebind<_Alloc, __node_type>::__type;\n+      using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;\n \n       using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;\n "}, {"sha": "a3da6c0a3df622a8a98b8c934dd3b56ad30231bc", "filename": "libstdc++-v3/testsuite/20_util/scoped_allocator/propagation.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7946683835932333aafd231f140b1e8812137bfb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2Fpropagation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7946683835932333aafd231f140b1e8812137bfb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2Fpropagation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2Fpropagation.cc?ref=7946683835932333aafd231f140b1e8812137bfb", "patch": "@@ -41,6 +41,10 @@ template<typename T>\n template<typename T, bool copy, bool move, bool swap>\n   struct test_allocator : minimal_allocator<T>\n   {\n+    template<typename U>\n+      struct rebind\n+      { using other = test_allocator<U, copy, move, swap>; };\n+\n     struct propagate_on_container_copy_assignment\n     : std::integral_constant<bool, copy> { };\n "}, {"sha": "ac199004b32773fa4cd63281af547ad0fe76ee7e", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/instantiation_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7946683835932333aafd231f140b1e8812137bfb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7946683835932333aafd231f140b1e8812137bfb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc?ref=7946683835932333aafd231f140b1e8812137bfb", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"with noexcept\" \"\" { target *-*-* } 266 }\n+// { dg-error \"with noexcept\" \"\" { target *-*-* } 265 }\n \n #include <unordered_set>\n "}]}