{"sha": "f507d20235bb7c05ce24c92f65b8aead2594e797", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjUwN2QyMDIzNWJiN2MwNWNlMjRjOTJmNjViOGFlYWQyNTk0ZTc5Nw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-07-12T15:03:07Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-07-12T15:03:07Z"}, "message": "Add tests that test boundary values of params\n\n\t* Makefile.in: Append rule for params-options.h.\n\t* params-options.h: New file.\n\t* gcc.dg/params/blocksort-part.c: New test.\n\t* gcc.dg/params/params.exp: New file.\n\nFrom-SVN: r238249", "tree": {"sha": "ed5bbb73c5f6dd48aa4855bdb8068a991f80f701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed5bbb73c5f6dd48aa4855bdb8068a991f80f701"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f507d20235bb7c05ce24c92f65b8aead2594e797", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f507d20235bb7c05ce24c92f65b8aead2594e797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f507d20235bb7c05ce24c92f65b8aead2594e797", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f507d20235bb7c05ce24c92f65b8aead2594e797/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d6f7c125d85f7b2fb5f8625d4992fbe48f4547d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6f7c125d85f7b2fb5f8625d4992fbe48f4547d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6f7c125d85f7b2fb5f8625d4992fbe48f4547d4"}], "stats": {"total": 816, "additions": 815, "deletions": 1}, "files": [{"sha": "982ba69fb70df858f3cb5c6ca4a10fb4a95d2838", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f507d20235bb7c05ce24c92f65b8aead2594e797/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f507d20235bb7c05ce24c92f65b8aead2594e797/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f507d20235bb7c05ce24c92f65b8aead2594e797", "patch": "@@ -4,6 +4,11 @@\n \t* expr.c (store_constructor): Mask sign-extended bits when widening\n \tsub-word constructor element at the start of a word.\n \n+2016-07-12  Martin Liska  <mliska@suse.cz>\n+\n+\t* Makefile.in: Append rule for params-options.h.\n+\t* params-options.h: New file.\n+\n 2016-07-12  Martin Liska  <mliska@suse.cz>\n \n \t* ira-build.c (mark_loops_for_removal): Properly iterate"}, {"sha": "0786fa377bc70689db66a00c698d4ddba98f1ce3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f507d20235bb7c05ce24c92f65b8aead2594e797/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f507d20235bb7c05ce24c92f65b8aead2594e797/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f507d20235bb7c05ce24c92f65b8aead2594e797", "patch": "@@ -2502,7 +2502,7 @@ generated_files = config.h tm.h $(TM_P_H) $(TM_H) multilib.h \\\n        $(ALL_GTFILES_H) gtype-desc.c gtype-desc.h gcov-iov.h \\\n        options.h target-hooks-def.h insn-opinit.h \\\n        common/common-target-hooks-def.h pass-instances.def \\\n-       c-family/c-target-hooks-def.h params.list case-cfn-macros.h \\\n+       c-family/c-target-hooks-def.h params.list params.options case-cfn-macros.h \\\n        cfn-operators.pd\n \n #\f\n@@ -3334,6 +3334,13 @@ s-params.list: $(srcdir)/params-list.h $(srcdir)/params.def\n \t$(SHELL) $(srcdir)/../move-if-change tmp-params.list params.list\n \t$(STAMP) s-params.list\n \n+params.options: s-params.options; @true\n+s-params.options: $(srcdir)/params-options.h $(srcdir)/params.def\n+\t$(CPP) $(srcdir)/params-options.h | sed 's/^#.*//;/^$$/d' > tmp-params.options\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-params.options params.options\n+\t$(STAMP) s-params.options\n+\n+\n PLUGIN_HEADERS = $(TREE_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   toplev.h $(DIAGNOSTIC_CORE_H) $(BASIC_BLOCK_H) $(HASH_TABLE_H) \\\n   tree-ssa-alias.h $(INTERNAL_FN_H) gimple-fold.h tree-eh.h gimple-expr.h \\"}, {"sha": "44bb3c2d36e914636b0ef3d7df3d29ee7afadbd0", "filename": "gcc/params-options.h", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f507d20235bb7c05ce24c92f65b8aead2594e797/gcc%2Fparams-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f507d20235bb7c05ce24c92f65b8aead2594e797/gcc%2Fparams-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams-options.h?ref=f507d20235bb7c05ce24c92f65b8aead2594e797", "patch": "@@ -0,0 +1,27 @@\n+/* File used to generate params.list\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define DEFPARAM(enumerator, option, nocmsgid, default, min, max) \\\n+  option=default,min,max\n+#define DEFPARAMENUM5(enumerator, option, nocmsgid, default, \\\n+\t\t      v0, v1, v2, v3, v4) \\\n+  option=v0,v1,v2,v3,v4\n+#include \"params.def\"\n+#undef DEFPARAM\n+#undef DEFPARAMENUM5"}, {"sha": "95b685986179b77618fc102bf72c0654ed94932b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f507d20235bb7c05ce24c92f65b8aead2594e797/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f507d20235bb7c05ce24c92f65b8aead2594e797/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f507d20235bb7c05ce24c92f65b8aead2594e797", "patch": "@@ -1,3 +1,8 @@\n+2016-07-12  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcc.dg/params/blocksort-part.c: New test.\n+\t* gcc.dg/params/params.exp: New file.\n+\n 2016-07-12  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR middle-end/71700"}, {"sha": "0eef2f3f7ccd2390c376268bb490b8fba62cef75", "filename": "gcc/testsuite/gcc.dg/params/blocksort-part.c", "status": "added", "additions": 706, "deletions": 0, "changes": 706, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f507d20235bb7c05ce24c92f65b8aead2594e797/gcc%2Ftestsuite%2Fgcc.dg%2Fparams%2Fblocksort-part.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f507d20235bb7c05ce24c92f65b8aead2594e797/gcc%2Ftestsuite%2Fgcc.dg%2Fparams%2Fblocksort-part.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fparams%2Fblocksort-part.c?ref=f507d20235bb7c05ce24c92f65b8aead2594e797", "patch": "@@ -0,0 +1,706 @@\n+\n+/*-------------------------------------------------------------*/\n+/*--- Block sorting machinery                               ---*/\n+/*---                                           blocksort.c ---*/\n+/*-------------------------------------------------------------*/\n+\n+/* ------------------------------------------------------------------\n+   This file is part of bzip2/libbzip2, a program and library for\n+   lossless, block-sorting data compression.\n+\n+   bzip2/libbzip2 version 1.0.6 of 6 September 2010\n+   Copyright (C) 1996-2010 Julian Seward <jseward@bzip.org>\n+\n+   Please read the WARNING, DISCLAIMER and PATENTS sections in the \n+   README file.\n+\n+   This program is released under the terms of the license contained\n+   in the file LICENSE.\n+   ------------------------------------------------------------------ */\n+\n+typedef char            Char;\n+typedef unsigned char   Bool;\n+typedef unsigned char   UChar;\n+typedef int             Int32;\n+typedef unsigned int    UInt32;\n+typedef short           Int16;\n+typedef unsigned short  UInt16;\n+\n+#define True  ((Bool)1)\n+#define False ((Bool)0)\n+\n+#define BZ_M_IDLE      1\n+#define BZ_M_RUNNING   2\n+#define BZ_M_FLUSHING  3\n+#define BZ_M_FINISHING 4\n+\n+#define BZ_S_OUTPUT    1\n+#define BZ_S_INPUT     2\n+\n+#define BZ_N_RADIX 2\n+#define BZ_N_QSORT 12\n+#define BZ_N_SHELL 18\n+#define BZ_N_OVERSHOOT (BZ_N_RADIX + BZ_N_QSORT + BZ_N_SHELL + 2)\n+\n+/*---------------------------------------------*/\n+/*--- Fallback O(N log(N)^2) sorting        ---*/\n+/*--- algorithm, for repetitive blocks      ---*/\n+/*---------------------------------------------*/\n+\n+/*---------------------------------------------*/\n+void fallbackSimpleSort ( UInt32* fmap, \n+                          UInt32* eclass, \n+                          Int32   lo, \n+                          Int32   hi )\n+{\n+   Int32 i, j, tmp;\n+   UInt32 ec_tmp;\n+\n+   if (lo == hi) return;\n+\n+   if (hi - lo > 3) {\n+      for ( i = hi-4; i >= lo; i-- ) {\n+         tmp = fmap[i];\n+         ec_tmp = eclass[tmp];\n+         for ( j = i+4; j <= hi && ec_tmp > eclass[fmap[j]]; j += 4 )\n+            fmap[j-4] = fmap[j];\n+         fmap[j-4] = tmp;\n+      }\n+   }\n+\n+   for ( i = hi-1; i >= lo; i-- ) {\n+      tmp = fmap[i];\n+      ec_tmp = eclass[tmp];\n+      for ( j = i+1; j <= hi && ec_tmp > eclass[fmap[j]]; j++ )\n+         fmap[j-1] = fmap[j];\n+      fmap[j-1] = tmp;\n+   }\n+}\n+\n+\n+/*---------------------------------------------*/\n+#define fswap(zz1, zz2) \\\n+   { Int32 zztmp = zz1; zz1 = zz2; zz2 = zztmp; }\n+\n+#define fvswap(zzp1, zzp2, zzn)       \\\n+{                                     \\\n+   Int32 yyp1 = (zzp1);               \\\n+   Int32 yyp2 = (zzp2);               \\\n+   Int32 yyn  = (zzn);                \\\n+   while (yyn > 0) {                  \\\n+      fswap(fmap[yyp1], fmap[yyp2]);  \\\n+      yyp1++; yyp2++; yyn--;          \\\n+   }                                  \\\n+}\n+\n+\n+#define fmin(a,b) ((a) < (b)) ? (a) : (b)\n+\n+#define fpush(lz,hz) { stackLo[sp] = lz; \\\n+                       stackHi[sp] = hz; \\\n+                       sp++; }\n+\n+#define fpop(lz,hz) { sp--;              \\\n+                      lz = stackLo[sp];  \\\n+                      hz = stackHi[sp]; }\n+\n+#define FALLBACK_QSORT_SMALL_THRESH 10\n+#define FALLBACK_QSORT_STACK_SIZE   100\n+\n+\n+void fallbackQSort3 ( UInt32* fmap, \n+                      UInt32* eclass,\n+                      Int32   loSt, \n+                      Int32   hiSt )\n+{\n+   Int32 unLo, unHi, ltLo, gtHi, n, m;\n+   Int32 sp, lo, hi;\n+   UInt32 med, r, r3;\n+   Int32 stackLo[FALLBACK_QSORT_STACK_SIZE];\n+   Int32 stackHi[FALLBACK_QSORT_STACK_SIZE];\n+\n+   r = 0;\n+\n+   sp = 0;\n+   fpush ( loSt, hiSt );\n+\n+   while (sp > 0) {\n+\n+      fpop ( lo, hi );\n+      if (hi - lo < FALLBACK_QSORT_SMALL_THRESH) {\n+         fallbackSimpleSort ( fmap, eclass, lo, hi );\n+         continue;\n+      }\n+\n+      /* Random partitioning.  Median of 3 sometimes fails to\n+         avoid bad cases.  Median of 9 seems to help but \n+         looks rather expensive.  This too seems to work but\n+         is cheaper.  Guidance for the magic constants \n+         7621 and 32768 is taken from Sedgewick's algorithms\n+         book, chapter 35.\n+      */\n+      r = ((r * 7621) + 1) % 32768;\n+      r3 = r % 3;\n+      if (r3 == 0) med = eclass[fmap[lo]]; else\n+      if (r3 == 1) med = eclass[fmap[(lo+hi)>>1]]; else\n+                   med = eclass[fmap[hi]];\n+\n+      unLo = ltLo = lo;\n+      unHi = gtHi = hi;\n+\n+      while (1) {\n+         while (1) {\n+            if (unLo > unHi) break;\n+            n = (Int32)eclass[fmap[unLo]] - (Int32)med;\n+            if (n == 0) { \n+               fswap(fmap[unLo], fmap[ltLo]); \n+               ltLo++; unLo++; \n+               continue; \n+            };\n+            if (n > 0) break;\n+            unLo++;\n+         }\n+         while (1) {\n+            if (unLo > unHi) break;\n+            n = (Int32)eclass[fmap[unHi]] - (Int32)med;\n+            if (n == 0) { \n+               fswap(fmap[unHi], fmap[gtHi]); \n+               gtHi--; unHi--; \n+               continue; \n+            };\n+            if (n < 0) break;\n+            unHi--;\n+         }\n+         if (unLo > unHi) break;\n+         fswap(fmap[unLo], fmap[unHi]); unLo++; unHi--;\n+      }\n+\n+      if (gtHi < ltLo) continue;\n+\n+      n = fmin(ltLo-lo, unLo-ltLo); fvswap(lo, unLo-n, n);\n+      m = fmin(hi-gtHi, gtHi-unHi); fvswap(unLo, hi-m+1, m);\n+\n+      n = lo + unLo - ltLo - 1;\n+      m = hi - (gtHi - unHi) + 1;\n+\n+      if (n - lo > hi - m) {\n+         fpush ( lo, n );\n+         fpush ( m, hi );\n+      } else {\n+         fpush ( m, hi );\n+         fpush ( lo, n );\n+      }\n+   }\n+}\n+\n+#undef fmin\n+#undef fpush\n+#undef fpop\n+#undef fswap\n+#undef fvswap\n+#undef FALLBACK_QSORT_SMALL_THRESH\n+#undef FALLBACK_QSORT_STACK_SIZE\n+\n+\n+/*---------------------------------------------*/\n+/* Pre:\n+      nblock > 0\n+      eclass exists for [0 .. nblock-1]\n+      ((UChar*)eclass) [0 .. nblock-1] holds block\n+      ptr exists for [0 .. nblock-1]\n+\n+   Post:\n+      ((UChar*)eclass) [0 .. nblock-1] holds block\n+      All other areas of eclass destroyed\n+      fmap [0 .. nblock-1] holds sorted order\n+      bhtab [ 0 .. 2+(nblock/32) ] destroyed\n+*/\n+\n+#define       SET_BH(zz)  bhtab[(zz) >> 5] |= (1 << ((zz) & 31))\n+#define     CLEAR_BH(zz)  bhtab[(zz) >> 5] &= ~(1 << ((zz) & 31))\n+#define     ISSET_BH(zz)  (bhtab[(zz) >> 5] & (1 << ((zz) & 31)))\n+#define      WORD_BH(zz)  bhtab[(zz) >> 5]\n+#define UNALIGNED_BH(zz)  ((zz) & 0x01f)\n+\n+void fallbackSort ( UInt32* fmap, \n+                    UInt32* eclass, \n+                    UInt32* bhtab,\n+                    Int32   nblock,\n+                    Int32   verb )\n+{\n+   Int32 ftab[257];\n+   Int32 ftabCopy[256];\n+   Int32 H, i, j, k, l, r, cc, cc1;\n+   Int32 nNotDone;\n+   Int32 nBhtab;\n+   UChar* eclass8 = (UChar*)eclass;\n+\n+   /*--\n+      Initial 1-char radix sort to generate\n+      initial fmap and initial BH bits.\n+   --*/\n+   for (i = 0; i < 257;    i++) ftab[i] = 0;\n+   for (i = 0; i < nblock; i++) ftab[eclass8[i]]++;\n+   for (i = 0; i < 256;    i++) ftabCopy[i] = ftab[i];\n+   for (i = 1; i < 257;    i++) ftab[i] += ftab[i-1];\n+\n+   for (i = 0; i < nblock; i++) {\n+      j = eclass8[i];\n+      k = ftab[j] - 1;\n+      ftab[j] = k;\n+      fmap[k] = i;\n+   }\n+\n+   nBhtab = 2 + (nblock / 32);\n+   for (i = 0; i < nBhtab; i++) bhtab[i] = 0;\n+   for (i = 0; i < 256; i++) SET_BH(ftab[i]);\n+\n+   /*--\n+      Inductively refine the buckets.  Kind-of an\n+      \"exponential radix sort\" (!), inspired by the\n+      Manber-Myers suffix array construction algorithm.\n+   --*/\n+\n+   /*-- set sentinel bits for block-end detection --*/\n+   for (i = 0; i < 32; i++) { \n+      SET_BH(nblock + 2*i);\n+      CLEAR_BH(nblock + 2*i + 1);\n+   }\n+\n+   /*-- the log(N) loop --*/\n+   H = 1;\n+   while (1) {\n+\n+\n+      j = 0;\n+      for (i = 0; i < nblock; i++) {\n+         if (ISSET_BH(i)) j = i;\n+         k = fmap[i] - H; if (k < 0) k += nblock;\n+         eclass[k] = j;\n+      }\n+\n+      nNotDone = 0;\n+      r = -1;\n+      while (1) {\n+\n+\t /*-- find the next non-singleton bucket --*/\n+         k = r + 1;\n+         while (ISSET_BH(k) && UNALIGNED_BH(k)) k++;\n+         if (ISSET_BH(k)) {\n+            while (WORD_BH(k) == 0xffffffff) k += 32;\n+            while (ISSET_BH(k)) k++;\n+         }\n+         l = k - 1;\n+         if (l >= nblock) break;\n+         while (!ISSET_BH(k) && UNALIGNED_BH(k)) k++;\n+         if (!ISSET_BH(k)) {\n+            while (WORD_BH(k) == 0x00000000) k += 32;\n+            while (!ISSET_BH(k)) k++;\n+         }\n+         r = k - 1;\n+         if (r >= nblock) break;\n+\n+         /*-- now [l, r] bracket current bucket --*/\n+         if (r > l) {\n+            nNotDone += (r - l + 1);\n+            fallbackQSort3 ( fmap, eclass, l, r );\n+\n+            /*-- scan bucket and generate header bits-- */\n+            cc = -1;\n+            for (i = l; i <= r; i++) {\n+               cc1 = eclass[fmap[i]];\n+               if (cc != cc1) { SET_BH(i); cc = cc1; };\n+            }\n+         }\n+      }\n+\n+      H *= 2;\n+      if (H > nblock || nNotDone == 0) break;\n+   }\n+\n+   /*-- \n+      Reconstruct the original block in\n+      eclass8 [0 .. nblock-1], since the\n+      previous phase destroyed it.\n+   --*/\n+   j = 0;\n+   for (i = 0; i < nblock; i++) {\n+      while (ftabCopy[j] == 0) j++;\n+      ftabCopy[j]--;\n+      eclass8[fmap[i]] = (UChar)j;\n+   }\n+}\n+\n+#undef       SET_BH\n+#undef     CLEAR_BH\n+#undef     ISSET_BH\n+#undef      WORD_BH\n+#undef UNALIGNED_BH\n+\n+\n+/*---------------------------------------------*/\n+/*--- The main, O(N^2 log(N)) sorting       ---*/\n+/*--- algorithm.  Faster for \"normal\"       ---*/\n+/*--- non-repetitive blocks.                ---*/\n+/*---------------------------------------------*/\n+\n+/*---------------------------------------------*/\n+Bool mainGtU ( UInt32  i1, \n+               UInt32  i2,\n+               UChar*  block, \n+               UInt16* quadrant,\n+               UInt32  nblock,\n+               Int32*  budget )\n+{\n+   Int32  k;\n+   UChar  c1, c2;\n+   UInt16 s1, s2;\n+\n+   /* 1 */\n+   c1 = block[i1]; c2 = block[i2];\n+   if (c1 != c2) return (c1 > c2);\n+   i1++; i2++;\n+   /* 2 */\n+   c1 = block[i1]; c2 = block[i2];\n+   if (c1 != c2) return (c1 > c2);\n+   i1++; i2++;\n+   /* 3 */\n+   c1 = block[i1]; c2 = block[i2];\n+   if (c1 != c2) return (c1 > c2);\n+   i1++; i2++;\n+   /* 4 */\n+   c1 = block[i1]; c2 = block[i2];\n+   if (c1 != c2) return (c1 > c2);\n+   i1++; i2++;\n+   /* 5 */\n+   c1 = block[i1]; c2 = block[i2];\n+   if (c1 != c2) return (c1 > c2);\n+   i1++; i2++;\n+   /* 6 */\n+   c1 = block[i1]; c2 = block[i2];\n+   if (c1 != c2) return (c1 > c2);\n+   i1++; i2++;\n+   /* 7 */\n+   c1 = block[i1]; c2 = block[i2];\n+   if (c1 != c2) return (c1 > c2);\n+   i1++; i2++;\n+   /* 8 */\n+   c1 = block[i1]; c2 = block[i2];\n+   if (c1 != c2) return (c1 > c2);\n+   i1++; i2++;\n+   /* 9 */\n+   c1 = block[i1]; c2 = block[i2];\n+   if (c1 != c2) return (c1 > c2);\n+   i1++; i2++;\n+   /* 10 */\n+   c1 = block[i1]; c2 = block[i2];\n+   if (c1 != c2) return (c1 > c2);\n+   i1++; i2++;\n+   /* 11 */\n+   c1 = block[i1]; c2 = block[i2];\n+   if (c1 != c2) return (c1 > c2);\n+   i1++; i2++;\n+   /* 12 */\n+   c1 = block[i1]; c2 = block[i2];\n+   if (c1 != c2) return (c1 > c2);\n+   i1++; i2++;\n+\n+   k = nblock + 8;\n+\n+   do {\n+      /* 1 */\n+      c1 = block[i1]; c2 = block[i2];\n+      if (c1 != c2) return (c1 > c2);\n+      s1 = quadrant[i1]; s2 = quadrant[i2];\n+      if (s1 != s2) return (s1 > s2);\n+      i1++; i2++;\n+      /* 2 */\n+      c1 = block[i1]; c2 = block[i2];\n+      if (c1 != c2) return (c1 > c2);\n+      s1 = quadrant[i1]; s2 = quadrant[i2];\n+      if (s1 != s2) return (s1 > s2);\n+      i1++; i2++;\n+      /* 3 */\n+      c1 = block[i1]; c2 = block[i2];\n+      if (c1 != c2) return (c1 > c2);\n+      s1 = quadrant[i1]; s2 = quadrant[i2];\n+      if (s1 != s2) return (s1 > s2);\n+      i1++; i2++;\n+      /* 4 */\n+      c1 = block[i1]; c2 = block[i2];\n+      if (c1 != c2) return (c1 > c2);\n+      s1 = quadrant[i1]; s2 = quadrant[i2];\n+      if (s1 != s2) return (s1 > s2);\n+      i1++; i2++;\n+      /* 5 */\n+      c1 = block[i1]; c2 = block[i2];\n+      if (c1 != c2) return (c1 > c2);\n+      s1 = quadrant[i1]; s2 = quadrant[i2];\n+      if (s1 != s2) return (s1 > s2);\n+      i1++; i2++;\n+      /* 6 */\n+      c1 = block[i1]; c2 = block[i2];\n+      if (c1 != c2) return (c1 > c2);\n+      s1 = quadrant[i1]; s2 = quadrant[i2];\n+      if (s1 != s2) return (s1 > s2);\n+      i1++; i2++;\n+      /* 7 */\n+      c1 = block[i1]; c2 = block[i2];\n+      if (c1 != c2) return (c1 > c2);\n+      s1 = quadrant[i1]; s2 = quadrant[i2];\n+      if (s1 != s2) return (s1 > s2);\n+      i1++; i2++;\n+      /* 8 */\n+      c1 = block[i1]; c2 = block[i2];\n+      if (c1 != c2) return (c1 > c2);\n+      s1 = quadrant[i1]; s2 = quadrant[i2];\n+      if (s1 != s2) return (s1 > s2);\n+      i1++; i2++;\n+\n+      if (i1 >= nblock) i1 -= nblock;\n+      if (i2 >= nblock) i2 -= nblock;\n+\n+      k -= 8;\n+      (*budget)--;\n+   }\n+      while (k >= 0);\n+\n+   return False;\n+}\n+\n+\n+/*---------------------------------------------*/\n+/*--\n+   Knuth's increments seem to work better\n+   than Incerpi-Sedgewick here.  Possibly\n+   because the number of elems to sort is\n+   usually small, typically <= 20.\n+--*/\n+Int32 incs[14] = { 1, 4, 13, 40, 121, 364, 1093, 3280,\n+                   9841, 29524, 88573, 265720,\n+                   797161, 2391484 };\n+\n+void mainSimpleSort ( UInt32* ptr,\n+                      UChar*  block,\n+                      UInt16* quadrant,\n+                      Int32   nblock,\n+                      Int32   lo, \n+                      Int32   hi, \n+                      Int32   d,\n+                      Int32*  budget )\n+{\n+   Int32 i, j, h, bigN, hp;\n+   UInt32 v;\n+\n+   bigN = hi - lo + 1;\n+   if (bigN < 2) return;\n+\n+   hp = 0;\n+   while (incs[hp] < bigN) hp++;\n+   hp--;\n+\n+   for (; hp >= 0; hp--) {\n+      h = incs[hp];\n+\n+      i = lo + h;\n+      while (True) {\n+\n+         /*-- copy 1 --*/\n+         if (i > hi) break;\n+         v = ptr[i];\n+         j = i;\n+         while ( mainGtU ( \n+                    ptr[j-h]+d, v+d, block, quadrant, nblock, budget \n+                 ) ) {\n+            ptr[j] = ptr[j-h];\n+            j = j - h;\n+            if (j <= (lo + h - 1)) break;\n+         }\n+         ptr[j] = v;\n+         i++;\n+\n+         /*-- copy 2 --*/\n+         if (i > hi) break;\n+         v = ptr[i];\n+         j = i;\n+         while ( mainGtU ( \n+                    ptr[j-h]+d, v+d, block, quadrant, nblock, budget \n+                 ) ) {\n+            ptr[j] = ptr[j-h];\n+            j = j - h;\n+            if (j <= (lo + h - 1)) break;\n+         }\n+         ptr[j] = v;\n+         i++;\n+\n+         /*-- copy 3 --*/\n+         if (i > hi) break;\n+         v = ptr[i];\n+         j = i;\n+         while ( mainGtU ( \n+                    ptr[j-h]+d, v+d, block, quadrant, nblock, budget \n+                 ) ) {\n+            ptr[j] = ptr[j-h];\n+            j = j - h;\n+            if (j <= (lo + h - 1)) break;\n+         }\n+         ptr[j] = v;\n+         i++;\n+\n+         if (*budget < 0) return;\n+      }\n+   }\n+}\n+\n+\n+/*---------------------------------------------*/\n+/*--\n+   The following is an implementation of\n+   an elegant 3-way quicksort for strings,\n+   described in a paper \"Fast Algorithms for\n+   Sorting and Searching Strings\", by Robert\n+   Sedgewick and Jon L. Bentley.\n+--*/\n+\n+#define mswap(zz1, zz2) \\\n+   { Int32 zztmp = zz1; zz1 = zz2; zz2 = zztmp; }\n+\n+#define mvswap(zzp1, zzp2, zzn)       \\\n+{                                     \\\n+   Int32 yyp1 = (zzp1);               \\\n+   Int32 yyp2 = (zzp2);               \\\n+   Int32 yyn  = (zzn);                \\\n+   while (yyn > 0) {                  \\\n+      mswap(ptr[yyp1], ptr[yyp2]);    \\\n+      yyp1++; yyp2++; yyn--;          \\\n+   }                                  \\\n+}\n+\n+UChar mmed3 ( UChar a, UChar b, UChar c )\n+{\n+   UChar t;\n+   if (a > b) { t = a; a = b; b = t; };\n+   if (b > c) { \n+      b = c;\n+      if (a > b) b = a;\n+   }\n+   return b;\n+}\n+\n+#define mmin(a,b) ((a) < (b)) ? (a) : (b)\n+\n+#define mpush(lz,hz,dz) { stackLo[sp] = lz; \\\n+                          stackHi[sp] = hz; \\\n+                          stackD [sp] = dz; \\\n+                          sp++; }\n+\n+#define mpop(lz,hz,dz) { sp--;             \\\n+                         lz = stackLo[sp]; \\\n+                         hz = stackHi[sp]; \\\n+                         dz = stackD [sp]; }\n+\n+\n+#define mnextsize(az) (nextHi[az]-nextLo[az])\n+\n+#define mnextswap(az,bz)                                        \\\n+   { Int32 tz;                                                  \\\n+     tz = nextLo[az]; nextLo[az] = nextLo[bz]; nextLo[bz] = tz; \\\n+     tz = nextHi[az]; nextHi[az] = nextHi[bz]; nextHi[bz] = tz; \\\n+     tz = nextD [az]; nextD [az] = nextD [bz]; nextD [bz] = tz; }\n+\n+\n+#define MAIN_QSORT_SMALL_THRESH 20\n+#define MAIN_QSORT_DEPTH_THRESH (BZ_N_RADIX + BZ_N_QSORT)\n+#define MAIN_QSORT_STACK_SIZE 100\n+\n+void mainQSort3 ( UInt32* ptr,\n+                  UChar*  block,\n+                  UInt16* quadrant,\n+                  Int32   nblock,\n+                  Int32   loSt, \n+                  Int32   hiSt, \n+                  Int32   dSt,\n+                  Int32*  budget )\n+{\n+   Int32 unLo, unHi, ltLo, gtHi, n, m, med;\n+   Int32 sp, lo, hi, d;\n+\n+   Int32 stackLo[MAIN_QSORT_STACK_SIZE];\n+   Int32 stackHi[MAIN_QSORT_STACK_SIZE];\n+   Int32 stackD [MAIN_QSORT_STACK_SIZE];\n+\n+   Int32 nextLo[3];\n+   Int32 nextHi[3];\n+   Int32 nextD [3];\n+\n+   sp = 0;\n+   mpush ( loSt, hiSt, dSt );\n+\n+   while (sp > 0) {\n+\n+      mpop ( lo, hi, d );\n+      if (hi - lo < MAIN_QSORT_SMALL_THRESH || \n+          d > MAIN_QSORT_DEPTH_THRESH) {\n+         mainSimpleSort ( ptr, block, quadrant, nblock, lo, hi, d, budget );\n+         if (*budget < 0) return;\n+         continue;\n+      }\n+\n+      med = (Int32) \n+            mmed3 ( block[ptr[ lo         ]+d],\n+                    block[ptr[ hi         ]+d],\n+                    block[ptr[ (lo+hi)>>1 ]+d] );\n+\n+      unLo = ltLo = lo;\n+      unHi = gtHi = hi;\n+\n+      while (True) {\n+         while (True) {\n+            if (unLo > unHi) break;\n+            n = ((Int32)block[ptr[unLo]+d]) - med;\n+            if (n == 0) { \n+               mswap(ptr[unLo], ptr[ltLo]); \n+               ltLo++; unLo++; continue; \n+            };\n+            if (n >  0) break;\n+            unLo++;\n+         }\n+         while (True) {\n+            if (unLo > unHi) break;\n+            n = ((Int32)block[ptr[unHi]+d]) - med;\n+            if (n == 0) { \n+               mswap(ptr[unHi], ptr[gtHi]); \n+               gtHi--; unHi--; continue; \n+            };\n+            if (n <  0) break;\n+            unHi--;\n+         }\n+         if (unLo > unHi) break;\n+         mswap(ptr[unLo], ptr[unHi]); unLo++; unHi--;\n+      }\n+\n+      if (gtHi < ltLo) {\n+         mpush(lo, hi, d+1 );\n+         continue;\n+      }\n+\n+      n = mmin(ltLo-lo, unLo-ltLo); mvswap(lo, unLo-n, n);\n+      m = mmin(hi-gtHi, gtHi-unHi); mvswap(unLo, hi-m+1, m);\n+\n+      n = lo + unLo - ltLo - 1;\n+      m = hi - (gtHi - unHi) + 1;\n+\n+      nextLo[0] = lo;  nextHi[0] = n;   nextD[0] = d;\n+      nextLo[1] = m;   nextHi[1] = hi;  nextD[1] = d;\n+      nextLo[2] = n+1; nextHi[2] = m-1; nextD[2] = d+1;\n+\n+      if (mnextsize(0) < mnextsize(1)) mnextswap(0,1);\n+      if (mnextsize(1) < mnextsize(2)) mnextswap(1,2);\n+      if (mnextsize(0) < mnextsize(1)) mnextswap(0,1);\n+\n+\n+      mpush (nextLo[0], nextHi[0], nextD[0]);\n+      mpush (nextLo[1], nextHi[1], nextD[1]);\n+      mpush (nextLo[2], nextHi[2], nextD[2]);\n+   }\n+}"}, {"sha": "f2f397e42ec7059a45d0ea4fe4b8e42c3ac4ad94", "filename": "gcc/testsuite/gcc.dg/params/params.exp", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f507d20235bb7c05ce24c92f65b8aead2594e797/gcc%2Ftestsuite%2Fgcc.dg%2Fparams%2Fparams.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f507d20235bb7c05ce24c92f65b8aead2594e797/gcc%2Ftestsuite%2Fgcc.dg%2Fparams%2Fparams.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fparams%2Fparams.exp?ref=f507d20235bb7c05ce24c92f65b8aead2594e797", "patch": "@@ -0,0 +1,64 @@\n+# Copyright (C) 2016 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# Initialize `dg'.\n+dg-init\n+\n+proc param_run_test { param_name param_value } {\n+    global srcdir\n+    global subdir\n+\n+    dg-runtest $srcdir/$subdir/blocksort-part.c \"\" \"-O3 --param $param_name=$param_value\"\n+}\n+\n+set fd [open \"$objdir/../../params.options\" r]\n+set text [read $fd]\n+close $fd\n+\n+# Main loop.\n+foreach params [split $text \"\\n\"] {\n+    set parts [split $params \"=\"]\n+    set name [string trim [lindex $parts 0] '\"']\n+    set values [split [lindex $parts 1] \",\"]\n+    if { [llength $values] == 3 } {\n+\tset default [lindex $values 0]\n+\tset min [lindex $values 1]\n+\tset max [lindex $values 2]\n+\tset int_max \"INT_MAX\"\n+\n+\tif { $min != -1 } {\n+\t    param_run_test $name $min\n+\t}\n+\tif { $max != $min && $max > 0 && $max != $int_max } {\n+\t    param_run_test $name $max\n+\t}\n+    }\n+    if { [llength $values] == 5 } {\n+\tforeach v $values {\n+\t    param_run_test $name $v\n+\t}\n+    }\n+}\n+\n+# All done.\n+dg-finish"}]}