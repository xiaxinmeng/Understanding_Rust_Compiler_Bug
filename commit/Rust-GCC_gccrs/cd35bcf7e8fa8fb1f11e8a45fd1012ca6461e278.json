{"sha": "cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QzNWJjZjdlOGZhOGZiMWYxMWU4YTQ1ZmQxMDEyY2E2NDYxZTI3OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-06-18T08:31:03Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-06-18T08:31:03Z"}, "message": "lto-symtab.c (lto_varpool_replace_node): Remove code handling extra name aliases.\n\n\t* lto-symtab.c (lto_varpool_replace_node): Remove code handling\n\textra name aliases.\n\t(lto_symtab_resolve_can_prevail_p): Likewise.\n\t(lto_symtab_merge_cgraph_nodes): Update alias_of pointers.\n\t* cgraphbuild.c (record_reference): Remove extra body alias code.\n\t(mark_load): Likewise.\n\t(mark_store): Likewise.\n\t* cgraph.h (varpool_node): Remove extra_name filed;\n\tadd alias_of and extraname_alias.\n\t(varpool_create_variable_alias, varpool_for_node_and_aliases): Declare.\n\t(varpool_alias_aliased_node): New inline function.\n\t(varpool_variable_node): New function.\n\t* cgraphunit.c (handle_alias_pairs): Handle also variable aliases.\n\t* ipa-ref.c (ipa_record_reference): Allow aliases on variables.\n\t* lto-cgraph.c (lto_output_varpool_node): Update streaming.\n\t(input_varpool_node): Likewise.\n\t* lto-streamer-out.c (produce_symtab): Remove extra name aliases.\n\t(varpool_externally_visible_p): Remove extra body alias code.\n\t(function_and_variable_visibility): Likewise.\n\t* tree-ssa-structalias.c (associate_varinfo_to_alias_1): New function.\n\t(ipa_pta_execute): Use it.\n\t* varpool.c (varpool_remove_node): Remove extra name alias code.\n\t(varpool_mark_needed_node): Likewise.\n\t(varpool_analyze_pending_decls): Analyze aliases.\n\t(assemble_aliases): New functoin.\n\t(varpool_assemble_decl): Use it.\n\t(varpool_create_variable_alias): New function.\n\t(varpool_extra_name_alias): Rewrite.\n\t(varpool_for_node_and_aliases): New function.\n\nFrom-SVN: r175167", "tree": {"sha": "d841d5d2b4ed36e1175fc28ca05d5529968c1c38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d841d5d2b4ed36e1175fc28ca05d5529968c1c38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/comments", "author": null, "committer": null, "parents": [{"sha": "d3ff9ee4686ea27a0df76224c790c67284889f57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3ff9ee4686ea27a0df76224c790c67284889f57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3ff9ee4686ea27a0df76224c790c67284889f57"}], "stats": {"total": 382, "additions": 235, "deletions": 147}, "files": [{"sha": "4fe0b105bf0b7aaddaeca47c013f69145dd3bce4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278", "patch": "@@ -1,3 +1,35 @@\n+2011-06-18  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-symtab.c (lto_varpool_replace_node): Remove code handling\n+\textra name aliases.\n+\t(lto_symtab_resolve_can_prevail_p): Likewise.\n+\t(lto_symtab_merge_cgraph_nodes): Update alias_of pointers.\n+\t* cgraphbuild.c (record_reference): Remove extra body alias code.\n+\t(mark_load): Likewise.\n+\t(mark_store): Likewise.\n+\t* cgraph.h (varpool_node): Remove extra_name filed;\n+\tadd alias_of and extraname_alias.\n+\t(varpool_create_variable_alias, varpool_for_node_and_aliases): Declare.\n+\t(varpool_alias_aliased_node): New inline function.\n+\t(varpool_variable_node): New function.\n+\t* cgraphunit.c (handle_alias_pairs): Handle also variable aliases.\n+\t* ipa-ref.c (ipa_record_reference): Allow aliases on variables.\n+\t* lto-cgraph.c (lto_output_varpool_node): Update streaming.\n+\t(input_varpool_node): Likewise.\n+\t* lto-streamer-out.c (produce_symtab): Remove extra name aliases.\n+\t(varpool_externally_visible_p): Remove extra body alias code.\n+\t(function_and_variable_visibility): Likewise.\n+\t* tree-ssa-structalias.c (associate_varinfo_to_alias_1): New function.\n+\t(ipa_pta_execute): Use it.\n+\t* varpool.c (varpool_remove_node): Remove extra name alias code.\n+\t(varpool_mark_needed_node): Likewise.\n+\t(varpool_analyze_pending_decls): Analyze aliases.\n+\t(assemble_aliases): New functoin.\n+\t(varpool_assemble_decl): Use it.\n+\t(varpool_create_variable_alias): New function.\n+\t(varpool_extra_name_alias): Rewrite.\n+\t(varpool_for_node_and_aliases): New function.\n+\n 2011-06-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/49411"}, {"sha": "dd08febaf124be293520f64fb3c4d303e3169130", "filename": "gcc/cgraph.h", "status": "modified", "additions": 49, "deletions": 3, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278", "patch": "@@ -380,13 +380,12 @@ DEF_VEC_ALLOC_P(cgraph_edge_p,heap);\n \n struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) varpool_node {\n   tree decl;\n+  /* For aliases points to declaration DECL is alias of.  */\n+  tree alias_of;\n   /* Pointer to the next function in varpool_nodes.  */\n   struct varpool_node *next, *prev;\n   /* Pointer to the next function in varpool_nodes_queue.  */\n   struct varpool_node *next_needed, *prev_needed;\n-  /* For normal nodes a pointer to the first extra name alias.  For alias\n-     nodes a pointer to the normal node.  */\n-  struct varpool_node *extra_name;\n   /* Circular list of nodes in the same comdat group if non-NULL.  */\n   struct varpool_node *same_comdat_group;\n   struct ipa_ref_list ref_list;\n@@ -415,6 +414,7 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) varpool_node {\n   /* Set for aliases once they got through assemble_alias.  Also set for\n      extra name aliases in varpool_extra_name_alias.  */\n   unsigned alias : 1;\n+  unsigned extra_name_alias : 1;\n   /* Set when variable is used from other LTRANS partition.  */\n   unsigned used_from_other_partition : 1;\n   /* Set when variable is available in the other LTRANS partition.\n@@ -665,9 +665,13 @@ bool varpool_analyze_pending_decls (void);\n void varpool_remove_unreferenced_decls (void);\n void varpool_empty_needed_queue (void);\n struct varpool_node * varpool_extra_name_alias (tree, tree);\n+struct varpool_node * varpool_create_variable_alias (tree, tree);\n const char * varpool_node_name (struct varpool_node *node);\n void varpool_reset_queue (void);\n bool const_value_known_p (tree);\n+bool varpool_for_node_and_aliases (struct varpool_node *,\n+\t\t                   bool (*) (struct varpool_node *, void *),\n+\t\t\t           void *, bool);\n \n /* Walk all reachable static variables.  */\n #define FOR_EACH_STATIC_VARIABLE(node) \\\n@@ -968,6 +972,20 @@ cgraph_alias_aliased_node (struct cgraph_node *n)\n   return NULL;\n }\n \n+/* Return node that alias N is aliasing.  */\n+\n+static inline struct varpool_node *\n+varpool_alias_aliased_node (struct varpool_node *n)\n+{\n+  struct ipa_ref *ref;\n+\n+  ipa_ref_list_reference_iterate (&n->ref_list, 0, ref);\n+  gcc_checking_assert (ref->use == IPA_REF_ALIAS);\n+  if (ref->refered_type == IPA_REF_CGRAPH)\n+    return ipa_ref_varpool_node (ref);\n+  return NULL;\n+}\n+\n /* Given NODE, walk the alias chain to return the function NODE is alias of.\n    Walk through thunk, too.\n    When AVAILABILITY is non-NULL, get minimal availablity in the chain.  */\n@@ -1026,6 +1044,34 @@ cgraph_function_or_thunk_node (struct cgraph_node *node, enum availability *avai\n   return NULL;\n }\n \n+/* Given NODE, walk the alias chain to return the function NODE is alias of.\n+   Do not walk through thunks.\n+   When AVAILABILITY is non-NULL, get minimal availablity in the chain.  */\n+\n+static inline struct varpool_node *\n+varpool_variable_node (struct varpool_node *node, enum availability *availability)\n+{\n+  if (availability)\n+    *availability = cgraph_variable_initializer_availability (node);\n+  while (node)\n+    {\n+      if (node->alias && node->analyzed)\n+\tnode = varpool_alias_aliased_node (node);\n+      else\n+\treturn node;\n+      if (node && availability)\n+\t{\n+\t  enum availability a;\n+\t  a = cgraph_variable_initializer_availability (node);\n+\t  if (a < *availability)\n+\t    *availability = a;\n+\t}\n+    }\n+  if (*availability)\n+    *availability = AVAIL_NOT_AVAILABLE;\n+  return NULL;\n+}\n+\n /* Return true when the edge E represents a direct recursion.  */\n static inline bool\n cgraph_edge_recursive_p (struct cgraph_edge *e)"}, {"sha": "8bf883005936bbf12058860a85e56faad480e236", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278", "patch": "@@ -87,8 +87,6 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n \t  if (lang_hooks.callgraph.analyze_expr)\n \t    lang_hooks.callgraph.analyze_expr (&decl, walk_subtrees);\n \t  varpool_mark_needed_node (vnode);\n-\t  if (vnode->alias && vnode->extra_name)\n-\t    vnode = vnode->extra_name;\n \t  ipa_record_reference (NULL, ctx->varpool_node,\n \t\t\t\tNULL, vnode,\n \t\t\t\tIPA_REF_ADDR, NULL);\n@@ -261,8 +259,6 @@ mark_address (gimple stmt, tree addr, void *data)\n       if (lang_hooks.callgraph.analyze_expr)\n \tlang_hooks.callgraph.analyze_expr (&addr, &walk_subtrees);\n       varpool_mark_needed_node (vnode);\n-      if (vnode->alias && vnode->extra_name)\n-\tvnode = vnode->extra_name;\n       ipa_record_reference ((struct cgraph_node *)data, NULL,\n \t\t\t    NULL, vnode,\n \t\t\t    IPA_REF_ADDR, stmt);\n@@ -296,8 +292,6 @@ mark_load (gimple stmt, tree t, void *data)\n       if (lang_hooks.callgraph.analyze_expr)\n \tlang_hooks.callgraph.analyze_expr (&t, &walk_subtrees);\n       varpool_mark_needed_node (vnode);\n-      if (vnode->alias && vnode->extra_name)\n-\tvnode = vnode->extra_name;\n       ipa_record_reference ((struct cgraph_node *)data, NULL,\n \t\t\t    NULL, vnode,\n \t\t\t    IPA_REF_LOAD, stmt);\n@@ -320,8 +314,6 @@ mark_store (gimple stmt, tree t, void *data)\n       if (lang_hooks.callgraph.analyze_expr)\n \tlang_hooks.callgraph.analyze_expr (&t, &walk_subtrees);\n       varpool_mark_needed_node (vnode);\n-      if (vnode->alias && vnode->extra_name)\n-\tvnode = vnode->extra_name;\n       ipa_record_reference ((struct cgraph_node *)data, NULL,\n \t\t\t    NULL, vnode,\n \t\t\t    IPA_REF_STORE, stmt);"}, {"sha": "6683d2a5df375f62cec0792d94bdd90ca3ce11ed", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278", "patch": "@@ -1186,6 +1186,7 @@ handle_alias_pairs (void)\n   unsigned i;\n   struct cgraph_node *target_node;\n   struct cgraph_node *src_node;\n+  struct varpool_node *target_vnode;\n   \n   for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p);)\n     {\n@@ -1206,6 +1207,20 @@ handle_alias_pairs (void)\n \t  cgraph_create_function_alias (p->decl, target_node->decl);\n \t  VEC_unordered_remove (alias_pair, alias_pairs, i);\n \t}\n+      else if (TREE_CODE (p->decl) == VAR_DECL\n+\t       && !lookup_attribute (\"weakref\", DECL_ATTRIBUTES (p->decl))\n+\t       && (target_vnode = varpool_node_for_asm (p->target)) != NULL)\n+\t{\n+\t  /* Normally EXTERNAL flag is used to mark external inlines,\n+\t     however for aliases it seems to be allowed to use it w/o\n+\t     any meaning. See gcc.dg/attr-alias-3.c  \n+\t     However for weakref we insist on EXTERNAL flag being set.\n+\t     See gcc.dg/attr-alias-5.c  */\n+\t  if (DECL_EXTERNAL (p->decl))\n+\t    DECL_EXTERNAL (p->decl) = 0;\n+\t  varpool_create_variable_alias (p->decl, target_vnode->decl);\n+\t  VEC_unordered_remove (alias_pair, alias_pairs, i);\n+\t}\n       else\n \t{\n \t  if (dump_file)"}, {"sha": "8520bca33acf3d5e6c8fb2fef42d48ee7d42bf97", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278", "patch": "@@ -68,7 +68,7 @@ ipa_record_reference (struct cgraph_node *refering_node,\n     {\n       ref->refering.varpool_node = refering_varpool_node;\n       ref->refering_type = IPA_REF_VARPOOL;\n-      gcc_assert (use_type == IPA_REF_ADDR);\n+      gcc_assert (use_type == IPA_REF_ADDR || use_type == IPA_REF_ALIAS);\n     }\n   if (refered_node)\n     {"}, {"sha": "9d9cb4366a0bfb2fce7cace7d61c623a1d6d2eac", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 12, "deletions": 35, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278", "patch": "@@ -544,8 +544,6 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n {\n   bool boundary_p = !varpool_node_in_set_p (node, vset) && node->analyzed;\n   struct bitpack_d bp;\n-  struct varpool_node *alias;\n-  int count = 0;\n   int ref;\n \n   lto_output_var_decl_index (ob->decl_state, ob->main_stream, node->decl);\n@@ -554,7 +552,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n   bp_pack_value (&bp, node->force_output, 1);\n   bp_pack_value (&bp, node->finalized, 1);\n   bp_pack_value (&bp, node->alias, 1);\n-  gcc_assert (!node->alias || !node->extra_name);\n+  bp_pack_value (&bp, node->alias_of != NULL, 1);\n   gcc_assert (node->finalized || !node->analyzed);\n   gcc_assert (node->needed);\n   /* Constant pool initializers can be de-unified into individual ltrans units.\n@@ -573,11 +571,9 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n \t\t\t\t\t\t\t   set, vset), 1);\n       bp_pack_value (&bp, boundary_p, 1);  /* in_other_partition.  */\n     }\n-  /* Also emit any extra name aliases.  */\n-  for (alias = node->extra_name; alias; alias = alias->next)\n-    count++;\n-  bp_pack_value (&bp, count != 0, 1);\n   lto_output_bitpack (&bp);\n+  if (node->alias_of)\n+    lto_output_var_decl_index (ob->decl_state, ob->main_stream, node->alias_of);\n   if (node->same_comdat_group && !boundary_p)\n     {\n       ref = lto_varpool_encoder_lookup (varpool_encoder, node->same_comdat_group);\n@@ -588,17 +584,6 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n   lto_output_sleb128_stream (ob->main_stream, ref);\n   lto_output_enum (ob->main_stream, ld_plugin_symbol_resolution,\n \t\t   LDPR_NUM_KNOWN, node->resolution);\n-\n-  if (count)\n-    {\n-      lto_output_uleb128_stream (ob->main_stream, count);\n-      for (alias = node->extra_name; alias; alias = alias->next)\n-\t{\n-\t  lto_output_var_decl_index (ob->decl_state, ob->main_stream, alias->decl);\n-\t  lto_output_enum (ob->main_stream, ld_plugin_symbol_resolution,\n-\t\t\t   LDPR_NUM_KNOWN, alias->resolution);\n-\t}\n-    }\n }\n \n /* Output the varpool NODE to OB. \n@@ -780,7 +765,7 @@ compute_ltrans_boundary (struct lto_out_decl_state *state,\n   for (vsi = vsi_start (vset); !vsi_end_p (vsi); vsi_next (&vsi))\n     {\n       struct varpool_node *vnode = vsi_node (vsi);\n-      gcc_assert (!vnode->alias);\n+      gcc_assert (!vnode->alias || vnode->alias_of);\n       lto_varpool_encoder_encode (varpool_encoder, vnode);\n       lto_set_varpool_encoder_encode_initializer (varpool_encoder, vnode);\n       add_references (encoder, varpool_encoder, &vnode->ref_list);\n@@ -1054,9 +1039,8 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   tree var_decl;\n   struct varpool_node *node;\n   struct bitpack_d bp;\n-  bool aliases_p;\n-  int count;\n   int ref = LCC_NOT_FOUND;\n+  bool non_null_aliasof;\n \n   decl_index = lto_input_uleb128 (ib);\n   var_decl = lto_file_decl_data_get_var_decl (file_data, decl_index);\n@@ -1068,6 +1052,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   node->force_output = bp_unpack_value (&bp, 1);\n   node->finalized = bp_unpack_value (&bp, 1);\n   node->alias = bp_unpack_value (&bp, 1);\n+  non_null_aliasof = bp_unpack_value (&bp, 1);\n   node->analyzed = node->finalized; \n   node->used_from_other_partition = bp_unpack_value (&bp, 1);\n   node->in_other_partition = bp_unpack_value (&bp, 1);\n@@ -1076,27 +1061,19 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n       DECL_EXTERNAL (node->decl) = 1;\n       TREE_STATIC (node->decl) = 0;\n     }\n-  aliases_p = bp_unpack_value (&bp, 1);\n   if (node->finalized)\n     varpool_mark_needed_node (node);\n+  if (non_null_aliasof)\n+    {\n+      decl_index = lto_input_uleb128 (ib);\n+      node->alias_of = lto_file_decl_data_get_var_decl (file_data, decl_index);\n+    }\n   ref = lto_input_sleb128 (ib);\n   /* Store a reference for now, and fix up later to be a pointer.  */\n   node->same_comdat_group = (struct varpool_node *) (intptr_t) ref;\n   node->resolution = lto_input_enum (ib, ld_plugin_symbol_resolution,\n \t\t\t\t     LDPR_NUM_KNOWN);\n-  if (aliases_p)\n-    {\n-      count = lto_input_uleb128 (ib);\n-      for (; count > 0; count --)\n-\t{\n-\t  tree decl = lto_file_decl_data_get_var_decl (file_data,\n-\t\t\t\t\t\t       lto_input_uleb128 (ib));\n-\t  struct varpool_node *alias;\n-\t  alias = varpool_extra_name_alias (decl, var_decl);\n-\t  alias->resolution = lto_input_enum (ib, ld_plugin_symbol_resolution,\n-\t\t\t\t\t      LDPR_NUM_KNOWN);\n-\t}\n-    }\n+\n   return node;\n }\n "}, {"sha": "19b0ae8bb1e59627a8a96d27620eb389778f60cb", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278", "patch": "@@ -2557,7 +2557,7 @@ produce_symtab (struct output_block *ob,\n   char *section_name = lto_get_section_name (LTO_section_symtab, NULL, NULL);\n   struct pointer_set_t *seen;\n   struct cgraph_node *node;\n-  struct varpool_node *vnode, *valias;\n+  struct varpool_node *vnode;\n   struct lto_output_stream stream;\n   lto_varpool_encoder_t varpool_encoder = ob->decl_state->varpool_node_encoder;\n   lto_cgraph_encoder_t encoder = ob->decl_state->cgraph_node_encoder;\n@@ -2617,11 +2617,9 @@ produce_symtab (struct output_block *ob,\n \t  && vnode->finalized \n \t  && DECL_VIRTUAL_P (vnode->decl))\n \tcontinue;\n-      if (vnode->alias)\n+      if (vnode->alias && !vnode->alias_of)\n \tcontinue;\n       write_symbol (cache, &stream, vnode->decl, seen, false);\n-      for (valias = vnode->extra_name; valias; valias = valias->next)\n-        write_symbol (cache, &stream, valias->decl, seen, true);\n     }\n   for (i = 0; i < lto_varpool_encoder_size (varpool_encoder); i++)\n     {\n@@ -2633,11 +2631,9 @@ produce_symtab (struct output_block *ob,\n \t  && vnode->finalized \n \t  && DECL_VIRTUAL_P (vnode->decl))\n \tcontinue;\n-      if (vnode->alias)\n+      if (vnode->alias && !vnode->alias_of)\n \tcontinue;\n       write_symbol (cache, &stream, vnode->decl, seen, false);\n-      for (valias = vnode->extra_name; valias; valias = valias->next)\n-        write_symbol (cache, &stream, valias->decl, seen, true);\n     }\n \n   /* Write all aliases.  */"}, {"sha": "2bbf064ee7d52be4fd99a2e9ee2ad519f04b6f71", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 5, "deletions": 27, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278", "patch": "@@ -268,32 +268,9 @@ lto_varpool_replace_node (struct varpool_node *vnode,\n       gcc_assert (!vnode->analyzed || prevailing_node->analyzed);\n       varpool_mark_needed_node (prevailing_node);\n     }\n-  /* Relink aliases.  */\n-  if (vnode->extra_name && !vnode->alias)\n-    {\n-      struct varpool_node *alias, *last;\n-      for (alias = vnode->extra_name;\n-\t   alias; alias = alias->next)\n-\t{\n-\t  last = alias;\n-\t  alias->extra_name = prevailing_node;\n-\t}\n-\n-      if (prevailing_node->extra_name)\n-\t{\n-\t  last->next = prevailing_node->extra_name;\n-\t  prevailing_node->extra_name->prev = last;\n-\t}\n-      prevailing_node->extra_name = vnode->extra_name;\n-      vnode->extra_name = NULL;\n-    }\n   gcc_assert (!vnode->finalized || prevailing_node->finalized);\n   gcc_assert (!vnode->analyzed || prevailing_node->analyzed);\n \n-  /* When replacing by an alias, the references goes to the original\n-     variable.  */\n-  if (prevailing_node->alias && prevailing_node->extra_name)\n-    prevailing_node = prevailing_node->extra_name;\n   ipa_clone_refering (NULL, prevailing_node, &vnode->ref_list);\n \n   /* Be sure we can garbage collect the initializer.  */\n@@ -438,14 +415,11 @@ lto_symtab_resolve_can_prevail_p (lto_symtab_entry_t e)\n   if (TREE_CODE (e->decl) == FUNCTION_DECL)\n     return (e->node && e->node->analyzed);\n \n-  /* A variable should have a size.  */\n   else if (TREE_CODE (e->decl) == VAR_DECL)\n     {\n       if (!e->vnode)\n \treturn false;\n-      if (e->vnode->finalized)\n-\treturn true;\n-      return e->vnode->alias && e->vnode->extra_name->finalized;\n+      return e->vnode->finalized;\n     }\n \n   gcc_unreachable ();\n@@ -779,13 +753,17 @@ void\n lto_symtab_merge_cgraph_nodes (void)\n {\n   struct cgraph_node *node;\n+  struct varpool_node *vnode;\n   lto_symtab_maybe_init_hash_table ();\n   htab_traverse (lto_symtab_identifiers, lto_symtab_merge_cgraph_nodes_1, NULL);\n \n   for (node = cgraph_nodes; node; node = node->next)\n     if ((node->thunk.thunk_p || node->alias)\n \t&& node->thunk.alias)\n       node->thunk.alias = lto_symtab_prevailing_decl (node->thunk.alias);\n+  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+    if (vnode->alias_of)\n+      vnode->alias_of = lto_symtab_prevailing_decl (vnode->alias_of);\n }\n \n /* Given the decl DECL, return the prevailing decl with the same name. */"}, {"sha": "6f076dcd3e7a5c13b87e4edc665429331c5eab58", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278", "patch": "@@ -6685,6 +6685,16 @@ associate_varinfo_to_alias (struct cgraph_node *node, void *data)\n   return false;\n }\n \n+/* Associate node with varinfo DATA. Worker for\n+   varpool_for_node_and_aliases.  */\n+static bool\n+associate_varinfo_to_alias_1 (struct varpool_node *node, void *data)\n+{\n+  if (node->alias)\n+    insert_vi_for_tree (node->decl, (varinfo_t)data);\n+  return false;\n+}\n+\n /* Execute the driver for IPA PTA.  */\n static unsigned int\n ipa_pta_execute (void)\n@@ -6716,14 +6726,12 @@ ipa_pta_execute (void)\n   /* Create constraints for global variables and their initializers.  */\n   for (var = varpool_nodes; var; var = var->next)\n     {\n-      struct varpool_node *alias;\n       varinfo_t vi;\n+      if (var->alias)\n+\tcontinue;\n \n       vi = get_vi_for_tree (var->decl);\n-\n-      /* Associate the varinfo node with all aliases.  */\n-      for (alias = var->extra_name; alias; alias = alias->next)\n-\tinsert_vi_for_tree (alias->decl, vi);\n+      varpool_for_node_and_aliases (var, associate_varinfo_to_alias_1, vi, true);\n     }\n \n   if (dump_file)"}, {"sha": "d223779a5c195e877688d6e36f4d30798249f47a", "filename": "gcc/varpool.c", "status": "modified", "additions": 105, "deletions": 61, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=cd35bcf7e8fa8fb1f11e8a45fd1012ca6461e278", "patch": "@@ -131,7 +131,7 @@ varpool_node (tree decl)\n   struct varpool_node key, *node, **slot;\n \n   gcc_assert (TREE_CODE (decl) == VAR_DECL\n-\t      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)));\n+\t      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl) || in_lto_p));\n \n   if (!varpool_hash)\n     varpool_hash = htab_create_ggc (10, hash_varpool_node,\n@@ -162,25 +162,14 @@ varpool_remove_node (struct varpool_node *node)\n   gcc_assert (*slot == node);\n   htab_clear_slot (varpool_hash, slot);\n   gcc_assert (!varpool_assembled_nodes_queue);\n-  if (!node->alias)\n-    while (node->extra_name)\n-      varpool_remove_node (node->extra_name);\n   if (node->next)\n     node->next->prev = node->prev;\n   if (node->prev)\n     node->prev->next = node->next;\n   else\n     {\n-      if (node->alias && node->extra_name)\n-\t{\n-          gcc_assert (node->extra_name->extra_name == node);\n-\t  node->extra_name->extra_name = node->next;\n-\t}\n-      else\n-\t{\n-          gcc_assert (varpool_nodes == node);\n-          varpool_nodes = node->next;\n-\t}\n+      gcc_assert (varpool_nodes == node);\n+      varpool_nodes = node->next;\n     }\n   if (varpool_first_unanalyzed_node == node)\n     varpool_first_unanalyzed_node = node->next_needed;\n@@ -311,8 +300,6 @@ varpool_enqueue_needed_node (struct varpool_node *node)\n void\n varpool_mark_needed_node (struct varpool_node *node)\n {\n-  if (node->alias && node->extra_name)\n-    node = node->extra_name;\n   if (!node->needed && node->finalized\n       && !TREE_ASM_WRITTEN (node->decl))\n     varpool_enqueue_needed_node (node);\n@@ -473,7 +460,40 @@ varpool_analyze_pending_decls (void)\n \t     already informed about increased alignment.  */\n           align_variable (decl, 0);\n \t}\n-      if (DECL_INITIAL (decl))\n+      if (node->alias && node->alias_of)\n+\t{\n+\t  struct varpool_node *tgt = varpool_node (node->alias_of);\n+\t  if (!VEC_length (ipa_ref_t, node->ref_list.references))\n+\t    ipa_record_reference (NULL, node, NULL, tgt, IPA_REF_ALIAS, NULL);\n+\t  /* C++ FE sometimes change linkage flags after producing same body aliases.  */\n+\t  if (node->extra_name_alias)\n+\t    {\n+\t      DECL_WEAK (node->decl) = DECL_WEAK (node->alias_of);\n+\t      TREE_PUBLIC (node->decl) = TREE_PUBLIC (node->alias_of);\n+\t      DECL_VISIBILITY (node->decl) = DECL_VISIBILITY (node->alias_of);\n+\t      if (TREE_PUBLIC (node->decl))\n+\t\t{\n+\t\t  DECL_COMDAT (node->decl) = DECL_COMDAT (node->alias_of);\n+\t\t  DECL_COMDAT_GROUP (node->decl) = DECL_COMDAT_GROUP (node->alias_of);\n+\t\t  if (DECL_ONE_ONLY (node->alias_of) && !node->same_comdat_group)\n+\t\t    {\n+\t\t      node->same_comdat_group = tgt;\n+\t\t      if (!tgt->same_comdat_group)\n+\t\t\ttgt->same_comdat_group = node;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  struct varpool_node *n;\n+\t\t\t  for (n = tgt->same_comdat_group;\n+\t\t\t       n->same_comdat_group != tgt;\n+\t\t\t       n = n->same_comdat_group)\n+\t\t\t    ;\n+\t\t\t  n->same_comdat_group = node;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      else if (DECL_INITIAL (decl))\n \trecord_references_in_initializer (decl, analyzed);\n       if (node->same_comdat_group)\n \t{\n@@ -488,6 +508,23 @@ varpool_analyze_pending_decls (void)\n   return changed;\n }\n \n+/* Assemble thunks and aliases asociated to NODE.  */\n+\n+static void\n+assemble_aliases (struct varpool_node *node)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+  for (i = 0; ipa_ref_list_refering_iterate (&node->ref_list, i, ref); i++)\n+    if (ref->use == IPA_REF_ALIAS)\n+      {\n+\tstruct varpool_node *alias = ipa_ref_refering_varpool_node (ref);\n+\tassemble_alias (alias->decl,\n+\t\t\tDECL_ASSEMBLER_NAME (alias->alias_of));\n+\tassemble_aliases (alias);\n+      }\n+}\n+\n /* Output one variable, if necessary.  Return whether we output it.  */\n bool\n varpool_assemble_decl (struct varpool_node *node)\n@@ -503,25 +540,13 @@ varpool_assemble_decl (struct varpool_node *node)\n       assemble_variable (decl, 0, 1, 0);\n       if (TREE_ASM_WRITTEN (decl))\n \t{\n-\t  struct varpool_node *alias;\n-\n \t  node->next_needed = varpool_assembled_nodes_queue;\n \t  node->prev_needed = NULL;\n \t  if (varpool_assembled_nodes_queue)\n \t    varpool_assembled_nodes_queue->prev_needed = node;\n \t  varpool_assembled_nodes_queue = node;\n \t  node->finalized = 1;\n-\n-\t  /* Also emit any extra name aliases.  */\n-\t  for (alias = node->extra_name; alias; alias = alias->next)\n-\t    {\n-\t      /* Update linkage fields in case they've changed.  */\n-\t      DECL_WEAK (alias->decl) = DECL_WEAK (decl);\n-\t      TREE_PUBLIC (alias->decl) = TREE_PUBLIC (decl);\n-\t      DECL_VISIBILITY (alias->decl) = DECL_VISIBILITY (decl);\n-\t      assemble_alias (alias->decl, DECL_ASSEMBLER_NAME (decl));\n-\t    }\n-\n+\t  assemble_aliases (node);\n \t  return true;\n \t}\n     }\n@@ -670,38 +695,36 @@ add_new_static_var (tree type)\n    Extra name aliases are output whenever DECL is output.  */\n \n struct varpool_node *\n-varpool_extra_name_alias (tree alias, tree decl)\n+varpool_create_variable_alias (tree alias, tree decl)\n {\n-  struct varpool_node key, *alias_node, *decl_node, **slot;\n-\n-#ifndef ASM_OUTPUT_DEF\n-  /* If aliases aren't supported by the assembler, fail.  */\n-  return NULL;\n-#endif\n+  struct varpool_node *alias_node;\n \n   gcc_assert (TREE_CODE (decl) == VAR_DECL);\n   gcc_assert (TREE_CODE (alias) == VAR_DECL);\n-  /* Make sure the hash table has been created.  */\n-  decl_node = varpool_node (decl);\n-\n-  key.decl = alias;\n+  alias_node = varpool_node (alias);\n+  alias_node->alias = 1;\n+  alias_node->finalized = 1;\n+  alias_node->alias_of = decl;\n+  if (decide_is_variable_needed (alias_node, alias)\n+      || alias_node->needed)\n+    varpool_mark_needed_node (alias_node);\n+  return alias_node;\n+}\n \n-  slot = (struct varpool_node **) htab_find_slot (varpool_hash, &key, INSERT);\n+/* Attempt to mark ALIAS as an alias to DECL.  Return TRUE if successful.\n+   Extra name aliases are output whenever DECL is output.  */\n \n-  /* If the varpool_node has been already created, fail.  */\n-  if (*slot)\n-    return NULL;\n+struct varpool_node *\n+varpool_extra_name_alias (tree alias, tree decl)\n+{\n+  struct varpool_node *alias_node;\n \n-  alias_node = ggc_alloc_cleared_varpool_node ();\n-  alias_node->decl = alias;\n-  alias_node->alias = 1;\n-  alias_node->extra_name = decl_node;\n-  alias_node->next = decl_node->extra_name;\n-  ipa_empty_ref_list (&alias_node->ref_list);\n-  if (decl_node->extra_name)\n-    decl_node->extra_name->prev = alias_node;\n-  decl_node->extra_name = alias_node;\n-  *slot = alias_node;\n+#ifndef ASM_OUTPUT_DEF\n+  /* If aliases aren't supported by the assembler, fail.  */\n+  return NULL;\n+#endif\n+  alias_node = varpool_create_variable_alias (alias, decl);\n+  alias_node->extra_name_alias = true;\n   return alias_node;\n }\n \n@@ -711,17 +734,38 @@ varpool_extra_name_alias (tree alias, tree decl)\n bool\n varpool_used_from_object_file_p (struct varpool_node *node)\n {\n-  struct varpool_node *alias;\n-\n   if (!TREE_PUBLIC (node->decl))\n     return false;\n   if (resolution_used_from_other_file_p (node->resolution))\n     return true;\n-  for (alias = node->extra_name; alias; alias = alias->next)\n-    if (TREE_PUBLIC (alias->decl)\n-\t&& resolution_used_from_other_file_p (alias->resolution))\n-      return true;\n   return false;\n }\n \n+/* Call calback on NODE and aliases asociated to NODE. \n+   When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n+   skipped. */\n+\n+bool\n+varpool_for_node_and_aliases (struct varpool_node *node,\n+\t\t\t      bool (*callback) (struct varpool_node *, void *),\n+\t\t\t      void *data,\n+\t\t\t      bool include_overwritable)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+\n+  if (callback (node, data))\n+    return true;\n+  for (i = 0; ipa_ref_list_refering_iterate (&node->ref_list, i, ref); i++)\n+    if (ref->use == IPA_REF_ALIAS)\n+      {\n+\tstruct varpool_node *alias = ipa_ref_refering_varpool_node (ref);\n+\tif (include_overwritable\n+\t    || cgraph_variable_initializer_availability (alias) > AVAIL_OVERWRITABLE)\n+          if (varpool_for_node_and_aliases (alias, callback, data,\n+\t\t\t\t\t   include_overwritable))\n+\t    return true;\n+      }\n+  return false;\n+}\n #include \"gt-varpool.h\""}]}