{"sha": "235cfbc40ffdc27a7578595042e4c1965e2000ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM1Y2ZiYzQwZmZkYzI3YTc1Nzg1OTUwNDJlNGMxOTY1ZTIwMDBlZA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-11-24T11:49:46Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-11-24T11:49:46Z"}, "message": "Overhaul sequence point warnings (again)\n\nFrom-SVN: r37706", "tree": {"sha": "4a5a8c5bbd55425bdea0737edf13bbc8e8817f59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a5a8c5bbd55425bdea0737edf13bbc8e8817f59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/235cfbc40ffdc27a7578595042e4c1965e2000ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/235cfbc40ffdc27a7578595042e4c1965e2000ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/235cfbc40ffdc27a7578595042e4c1965e2000ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/235cfbc40ffdc27a7578595042e4c1965e2000ed/comments", "author": null, "committer": null, "parents": [{"sha": "58ecb5e2cd33addcf73d70f87d0f3a5ff221e226", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58ecb5e2cd33addcf73d70f87d0f3a5ff221e226", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58ecb5e2cd33addcf73d70f87d0f3a5ff221e226"}], "stats": {"total": 634, "additions": 425, "deletions": 209}, "files": [{"sha": "9f4335299aa656700d8c1307041ce6b9478c1ebf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235cfbc40ffdc27a7578595042e4c1965e2000ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235cfbc40ffdc27a7578595042e4c1965e2000ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=235cfbc40ffdc27a7578595042e4c1965e2000ed", "patch": "@@ -3,6 +3,20 @@\n \t* combine.c (cant_combine_insn_p): New function.\n \t(try_combine): Use it.\n \n+\t* Makefile.in (c-common.o): Depend on $(OBSTACK_H).\n+\t* c-common.c (c-obstack.c): Include \"obstack.h\".\n+\t(struct reverse_tree): Delete.\n+\t(reverse_list, reverse_max_depth): Delete.\n+\t(build_reverse_tree, common_ancestor, modify_ok): Delete functions.\n+\t(struct tlist, struct tlist_cache): New.\n+\t(tlist_obstack, tlist_firstobj, warned_ids, save_expr_cache): New.\n+\t(add_tlist, merge_tlist, verify_tree, warning_candidate_p,\n+\twarn_for_collisions, warn_for_collisions_1, new_tlist): New\n+\tstatic functions.\n+\t(verify_sequence_points): Rewritten.\n+\t* fold-const.c (fold): Don't lose possibly important sequence\n+\tpoints when removing one arm of TRUTH_ORIF_EXPRs or TRUTH_ANDIF_EXPRs.\n+\n 2000-11-24  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* gcc/cse.c (cse_insn): Removed conversion of REG_EQUIV to REG_EQUAL"}, {"sha": "2c5941828e16b9147b7d2f9a6a274a16b0d723eb", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235cfbc40ffdc27a7578595042e4c1965e2000ed/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235cfbc40ffdc27a7578595042e4c1965e2000ed/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=235cfbc40ffdc27a7578595042e4c1965e2000ed", "patch": "@@ -1214,7 +1214,7 @@ s-under: $(GCC_PASSES)\n \n # A file used by all variants of C.\n \n-c-common.o : c-common.c $(CONFIG_H) system.h $(TREE_H) \\\n+c-common.o : c-common.c $(CONFIG_H) system.h $(TREE_H) $(OBSTACK_H) \\\n \t$(C_COMMON_H) flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n \t$(EXPR_H) diagnostic.h\n "}, {"sha": "3b1462a9d7bba17d28e47a9af4d8b63f54e9fa7c", "filename": "gcc/c-common.c", "status": "modified", "additions": 354, "deletions": 204, "changes": 558, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235cfbc40ffdc27a7578595042e4c1965e2000ed/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235cfbc40ffdc27a7578595042e4c1965e2000ed/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=235cfbc40ffdc27a7578595042e4c1965e2000ed", "patch": "@@ -33,6 +33,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tm_p.h\"\n #include \"intl.h\"\n #include \"diagnostic.h\"\n+#include \"obstack.h\"\n \n #if USE_CPPLIB\n #include \"cpplib.h\"\n@@ -3414,193 +3415,388 @@ convert_and_check (type, expr)\n   return t;\n }\n \f\n-/* Describe a reversed version of a normal tree, so that we can get to the\n-   parent of each node.  */\n-struct reverse_tree\n+/* A node in a list that describes references to variables (EXPR), which are\n+   either read accesses if WRITER is zero, or write accesses, in which case\n+   WRITER is the parent of EXPR.  */\n+struct tlist\n {\n-  /* All reverse_tree structures for a given tree are chained through this\n-     field.  */\n-  struct reverse_tree *next;\n-  /* The parent of this node.  */\n-  struct reverse_tree *parent;\n-  /* The actual tree node.  */\n-  tree x;\n-  /* The operand number this node corresponds to in the parent.  */\n-  int operandno;\n-  /* Describe whether this expression is written to or read.  */\n-  char read, write;\n+  struct tlist *next;\n+  tree expr, writer;\n };\n \n-/* A list of all reverse_tree structures for a given expression, built by\n-   build_reverse_tree.  */\n-static struct reverse_tree *reverse_list;\n-/* The maximum depth of a tree, computed by build_reverse_tree.  */\n-static int reverse_max_depth;\n-\n-static void build_reverse_tree PARAMS ((tree, struct reverse_tree *, int, int,\n-\t\t\t\t\tint, int));\n-static struct reverse_tree *common_ancestor PARAMS ((struct reverse_tree *,\n-\t\t\t\t\t\t     struct reverse_tree *,\n-\t\t\t\t\t\t     struct reverse_tree **,\n-\t\t\t\t\t\t     struct reverse_tree **));\n-static int modify_ok PARAMS ((struct reverse_tree *, struct reverse_tree *));\n+/* Used to implement a cache the results of a call to verify_tree.  We only\n+   use this for SAVE_EXPRs.  */\n+struct tlist_cache\n+{\n+  struct tlist_cache *next;\n+  struct tlist *cache_before_sp;\n+  struct tlist *cache_after_sp;\n+  tree expr;\n+};\n+\n+/* Obstack to use when allocating tlist structures, and corresponding\n+   firstobj.  */\n+static struct obstack tlist_obstack;\n+static char *tlist_firstobj = 0;\n+\n+/* Keep track of the identifiers we've warned about, so we can avoid duplicate\n+   warnings.  */\n+static struct tlist *warned_ids;\n+/* SAVE_EXPRs need special treatment.  We process them only once and then\n+   cache the results.  */\n+static struct tlist_cache *save_expr_cache;\n+\n+static void add_tlist PARAMS ((struct tlist **, struct tlist *, tree, int));\n+static void merge_tlist PARAMS ((struct tlist **, struct tlist *, int));\n+static void verify_tree PARAMS ((tree, struct tlist **, struct tlist **, tree));\n+static int warning_candidate_p PARAMS ((tree));\n+static void warn_for_collisions PARAMS ((struct tlist *));\n+static void warn_for_collisions_1 PARAMS ((tree, tree, struct tlist *, int));\n+static struct tlist *new_tlist PARAMS ((struct tlist *, tree, tree));\n static void verify_sequence_points PARAMS ((tree));\n \n-/* Recursively process an expression, X, building a reverse tree while\n-   descending and recording OPERANDNO, READ, and WRITE in the created\n-   structures.  DEPTH is used to compute reverse_max_depth.\n-   FIXME: if walk_tree gets moved out of the C++ front end, this should\n-   probably use walk_tree.  */\n+/* Create a new struct tlist and fill in its fields.  */\n+static struct tlist *\n+new_tlist (next, t, writer)\n+     struct tlist *next;\n+     tree t;\n+     tree writer;\n+{\n+  struct tlist *l;\n+  l = (struct tlist *) obstack_alloc (&tlist_obstack, sizeof *l);\n+  l->next = next;\n+  l->expr = t;\n+  l->writer = writer;\n+  return l;\n+}\n+\n+/* Add duplicates of the nodes found in ADD to the list *TO.  If EXCLUDE_WRITER\n+   is nonnull, we ignore any node we find which has a writer equal to it.  */\n+\n+static void\n+add_tlist (to, add, exclude_writer, copy)\n+     struct tlist **to;\n+     struct tlist *add;\n+     tree exclude_writer;\n+     int copy;\n+{\n+  while (add)\n+    {\n+      struct tlist *next = add->next;\n+      if (! copy)\n+\tadd->next = *to;\n+      if (! exclude_writer || add->writer != exclude_writer)\n+\t*to = copy ? new_tlist (*to, add->expr, add->writer) : add;\n+      add = next;\n+    }\n+}\n+\n+/* Merge the nodes of ADD into TO.  This merging process is done so that for\n+   each variable that already exists in TO, no new node is added; however if\n+   there is a write access recorded in ADD, and an occurrence on TO is only\n+   a read access, then the occurrence in TO will be modified to record the\n+   write.  */\n+\n+static void\n+merge_tlist (to, add, copy)\n+     struct tlist **to;\n+     struct tlist *add;\n+     int copy;\n+{\n+  struct tlist **end = to;\n+\n+  while (*end)\n+    end = &(*end)->next;\n+\n+  while (add)\n+    {\n+      int found = 0;\n+      struct tlist *tmp2;\n+      struct tlist *next = add->next;\n+\n+      for (tmp2 = *to; tmp2; tmp2 = tmp2->next)\n+\tif (tmp2->expr == add->expr)\n+\t  {\n+\t    found = 1;\n+\t    if (! tmp2->writer)\n+\t      tmp2->writer = add->writer;\n+\t  }\n+      if (! found)\n+\t{\n+\t  *end = copy ? add : new_tlist (NULL, add->expr, add->writer);\n+\t  end = &(*end)->next;\n+\t  *end = 0;\n+\t}\n+      add = next;\n+    }\n+}\n+\n+/* WRITTEN is a variable, WRITER is its parent.  Warn if any of the variable\n+   references in list LIST conflict with it, excluding reads if ONLY writers\n+   is nonzero.  */\n \n static void\n-build_reverse_tree (x, parent, operandno, read, write, depth)\n+warn_for_collisions_1 (written, writer, list, only_writes)\n+     tree written, writer;\n+     struct tlist *list;\n+     int only_writes;\n+{\n+  struct tlist *tmp;\n+\n+  /* Avoid duplicate warnings.  */\n+  for (tmp = warned_ids; tmp; tmp = tmp->next)\n+    if (tmp->expr == written)\n+      return;\n+\n+  while (list)\n+    {\n+      if (list->expr == written\n+\t  && list->writer != writer\n+\t  && (! only_writes || list->writer))\n+\t{\n+\t  warned_ids = new_tlist (warned_ids, written, NULL_TREE);\n+\t  warning (\"operation on `%s' may be undefined\",\n+\t\t   IDENTIFIER_POINTER (DECL_NAME (list->expr)));\n+\t}\n+      list = list->next;\n+    }\n+}\n+\n+/* Given a list LIST of references to variables, find whether any of these\n+   can cause conflicts due to missing sequence points.  */\n+\n+static void\n+warn_for_collisions (list)\n+     struct tlist *list;\n+{\n+  struct tlist *tmp;\n+  \n+  for (tmp = list; tmp; tmp = tmp->next)\n+    {\n+      if (tmp->writer)\n+\twarn_for_collisions_1 (tmp->expr, tmp->writer, list, 0);\n+    }\n+}\n+\n+/* Return nonzero if X is a tree that can be verified by the sequence poitn\n+   warnings.  */\n+static int\n+warning_candidate_p (x)\n      tree x;\n-     struct reverse_tree *parent;\n-     int operandno, read, write, depth;\n {\n-  struct reverse_tree *node;\n+  return TREE_CODE (x) == VAR_DECL || TREE_CODE (x) == PARM_DECL;\n+}\n \n-  if (x == 0 || x == error_mark_node)\n-    return;\n+/* Walk the tree X, and record accesses to variables.  If X is written by the\n+   parent tree, WRITER is the parent.\n+   We store accesses in one of the two lists: PBEFORE_SP, and PNO_SP.  If this\n+   expression or its only operand forces a sequence point, then everything up\n+   to the sequence point is stored in PBEFORE_SP.  Everything else gets stored\n+   in PNO_SP.\n+   Once we return, we will have emitted warnings if any subexpression before\n+   such a sequence point could be undefined.  On a higher level, however, the\n+   sequence point may not be relevant, and we'll merge the two lists.\n+\n+   Example: (b++, a) + b;\n+   The call that processes the COMPOUND_EXPR will store the increment of B\n+   in PBEFORE_SP, and the use of A in PNO_SP.  The higher-level call that\n+   processes the PLUS_EXPR will need to merge the two lists so that\n+   eventually, all accesses end up on the same list (and we'll warn about the\n+   unordered subexpressions b++ and b.\n+\n+   A note on merging.  If we modify the former example so that our expression\n+   becomes\n+     (b++, b) + a\n+   care must be taken not simply to add all three expressions into the final\n+   PNO_SP list.  The function merge_tlist takes care of that by merging the\n+   before-SP list of the COMPOUND_EXPR into its after-SP list in a special\n+   way, so that no more than one access to B is recorded.  */\n \n-  node = (struct reverse_tree *) xmalloc (sizeof (struct reverse_tree));\n+static void\n+verify_tree (x, pbefore_sp, pno_sp, writer)\n+     tree x;\n+     struct tlist **pbefore_sp, **pno_sp;\n+     tree writer;\n+{\n+  struct tlist *tmp_before, *tmp_nosp, *tmp_list2, *tmp_list3;\n+  enum tree_code code;\n+  char class;\n \n-  node->parent = parent;\n-  node->x = x;\n-  node->read = read;\n-  node->write = write;\n-  node->operandno = operandno;\n-  node->next = reverse_list;\n-  reverse_list = node;\n-  if (depth > reverse_max_depth)\n-    reverse_max_depth = depth;\n+ restart:\n+  code = TREE_CODE (x);\n+  class = TREE_CODE_CLASS (code);\n \n-  switch (TREE_CODE (x))\n+  if (warning_candidate_p (x))\n     {\n+      *pno_sp = new_tlist (*pno_sp, x, writer);\n+      return;\n+    }\n+\n+  switch (code)\n+    {\n+    case COMPOUND_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+      tmp_before = tmp_nosp = tmp_list3 = 0;\n+      verify_tree (TREE_OPERAND (x, 0), &tmp_before, &tmp_nosp, NULL_TREE);\n+      warn_for_collisions (tmp_nosp);\n+      merge_tlist (pbefore_sp, tmp_before, 0);\n+      merge_tlist (pbefore_sp, tmp_nosp, 0);\n+      verify_tree (TREE_OPERAND (x, 1), &tmp_list3, pno_sp, NULL_TREE);\n+      merge_tlist (pbefore_sp, tmp_list3, 0);\n+      return;\n+\n+    case COND_EXPR:\n+      tmp_before = tmp_list2 = 0;\n+      verify_tree (TREE_OPERAND (x, 0), &tmp_before, &tmp_list2, NULL_TREE);\n+      warn_for_collisions (tmp_list2);\n+      merge_tlist (pbefore_sp, tmp_before, 0);\n+      merge_tlist (pbefore_sp, tmp_list2, 1);\n+\n+      tmp_list3 = tmp_nosp = 0;\n+      verify_tree (TREE_OPERAND (x, 1), &tmp_list3, &tmp_nosp, NULL_TREE);\n+      warn_for_collisions (tmp_nosp);\n+      merge_tlist (pbefore_sp, tmp_list3, 0);\n+\n+      tmp_list3 = tmp_list2 = 0;\n+      verify_tree (TREE_OPERAND (x, 2), &tmp_list3, &tmp_list2, NULL_TREE);\n+      warn_for_collisions (tmp_list2);\n+      merge_tlist (pbefore_sp, tmp_list3, 0);\n+      /* Rather than add both tmp_nosp and tmp_list2, we have to merge the\n+\t two first, to avoid warning for (a ? b++ : b++).  */\n+      merge_tlist (&tmp_nosp, tmp_list2, 0);\n+      add_tlist (pno_sp, tmp_nosp, NULL_TREE, 0);\n+      return;\n+\n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n-      build_reverse_tree (TREE_OPERAND (x, 0), node, 0, 1, 1, depth + 1);\n-      break;\n+      verify_tree (TREE_OPERAND (x, 0), pno_sp, pno_sp, x);\n+      return;\n+\n+    case MODIFY_EXPR:\n+      tmp_before = tmp_nosp = tmp_list3 = 0;\n+      verify_tree (TREE_OPERAND (x, 1), &tmp_before, &tmp_nosp, NULL_TREE);\n+      verify_tree (TREE_OPERAND (x, 0), &tmp_list3, &tmp_list3, x);\n+      /* Expressions inside the LHS are not ordered wrt. the sequence points\n+\t in the RHS.  Example:\n+\t   *a = (a++, 2)\n+\t Despite the fact that the modification of \"a\" is in the before_sp\n+\t list (tmp_before), it conflicts with the use of \"a\" in the LHS.\n+\t We can handle this by adding the contents of tmp_list3\n+\t to those of tmp_before, and redoing the collision warnings for that\n+\t list.  */\n+      add_tlist (&tmp_before, tmp_list3, x, 1);\n+      warn_for_collisions (tmp_before);\n+      /* Exclude the LHS itself here; we first have to merge it into the\n+\t tmp_nosp list.  This is done to avoid warning for \"a = a\"; if we\n+\t didn't exclude the LHS, we'd get it twice, once as a read and once\n+\t as a write.  */\n+      add_tlist (pno_sp, tmp_list3, x, 0);\n+      warn_for_collisions_1 (TREE_OPERAND (x, 0), x, tmp_nosp, 1);\n+\n+      merge_tlist (pbefore_sp, tmp_before, 0);\n+      if (warning_candidate_p (TREE_OPERAND (x, 0)))\n+\tmerge_tlist (&tmp_nosp, new_tlist (NULL, TREE_OPERAND (x, 0), x), 0);\n+      add_tlist (pno_sp, tmp_nosp, NULL_TREE, 1);\n+      return;\n \n     case CALL_EXPR:\n-      build_reverse_tree (TREE_OPERAND (x, 0), node, 0, 1, 0, depth + 1);\n-      x = TREE_OPERAND (x, 1);\n-      while (x)\n-\t{\n-\t  build_reverse_tree (TREE_VALUE (x), node, 1, 1, 0, depth + 1);\n-\t  x = TREE_CHAIN (x);\n-\t}\n-      break;\n+      /* We need to warn about conflicts among arguments and conflicts between\n+\t args and the function address.  Side effects of the function address,\n+\t however, are not ordered by the sequence point of the call.  */\n+      tmp_before = tmp_nosp = tmp_list2 = tmp_list3 = 0;\n+      verify_tree (TREE_OPERAND (x, 0), &tmp_before, &tmp_nosp, NULL_TREE);\n+      if (TREE_OPERAND (x, 1))\n+\tverify_tree (TREE_OPERAND (x, 1), &tmp_list2, &tmp_list3, NULL_TREE);\n+      merge_tlist (&tmp_list3, tmp_list2, 0);\n+      add_tlist (&tmp_before, tmp_list3, NULL_TREE, 0);\n+      add_tlist (&tmp_before, tmp_nosp, NULL_TREE, 0);\n+      warn_for_collisions (tmp_before);\n+      add_tlist (pbefore_sp, tmp_before, NULL_TREE, 0);\n+      return;\n \n     case TREE_LIST:\n       /* Scan all the list, e.g. indices of multi dimensional array.  */\n       while (x)\n \t{\n-\t  build_reverse_tree (TREE_VALUE (x), node, 0, 1, 0, depth + 1);\n+\t  tmp_before = tmp_nosp = 0;\n+\t  verify_tree (TREE_VALUE (x), &tmp_before, &tmp_nosp, NULL_TREE);\n+\t  merge_tlist (&tmp_nosp, tmp_before, 0);\n+\t  add_tlist (pno_sp, tmp_nosp, NULL_TREE, 0);\n \t  x = TREE_CHAIN (x);\n \t}\n-      break;\n+      return;\n \n-    case MODIFY_EXPR:\n-      build_reverse_tree (TREE_OPERAND (x, 0), node, 0, 0, 1, depth + 1);\n-      build_reverse_tree (TREE_OPERAND (x, 1), node, 1, 1, 0, depth + 1);\n-      break;\n+    case SAVE_EXPR:\n+      {\n+\tstruct tlist_cache *t;\n+\tfor (t = save_expr_cache; t; t = t->next)\n+\t  if (t->expr == x)\n+\t    break;\n \n-    default:\n-      switch (TREE_CODE_CLASS (TREE_CODE (x)))\n-\t{\n-\tcase 'r':\n-\tcase '<':\n-\tcase '2':\n-\tcase 'b':\n-\tcase '1':\n-\tcase 'e':\n-\tcase 's':\n-\tcase 'x':\n+\tif (! t)\n \t  {\n-\t    int lp;\n-\t    int max = first_rtl_op (TREE_CODE (x));\n-\t    for (lp = 0; lp < max; lp++)\n-\t      build_reverse_tree (TREE_OPERAND (x, lp), node, lp, 1, 0,\n-\t\t\t\t  depth + 1);\n-\t    break;\n+\t    t = (struct tlist_cache *) obstack_alloc (&tlist_obstack,\n+\t\t\t\t\t\t      sizeof *t);\n+\t    t->next = save_expr_cache;\n+\t    t->expr = x;\n+\t    save_expr_cache = t;\n+\n+\t    tmp_before = tmp_nosp = 0;\n+\t    verify_tree (TREE_OPERAND (x, 0), &tmp_before, &tmp_nosp, NULL_TREE);\n+\t    warn_for_collisions (tmp_nosp);\n+\n+\t    tmp_list3 = 0;\n+\t    while (tmp_nosp)\n+\t      {\n+\t\tstruct tlist *t = tmp_nosp;\n+\t\ttmp_nosp = t->next;\n+\t\tmerge_tlist (&tmp_list3, t, 0);\n+\t      }\n+\t    t->cache_before_sp = tmp_before;\n+\t    t->cache_after_sp = tmp_list3;\n \t  }\n-\tdefault:\n-\t  break;\n-\t}\n+\tmerge_tlist (pbefore_sp, t->cache_before_sp, 1);\n+\tadd_tlist (pno_sp, t->cache_after_sp, NULL_TREE, 1);\n+\treturn;\n+      }\n+    default:\n       break;\n     }\n-}\n-\n-/* Given nodes P1 and P2 as well as enough scratch space pointed to by TMP1\n-   and TMP2, find the common ancestor of P1 and P2.  */\n \n-static struct reverse_tree *\n-common_ancestor (p1, p2, tmp1, tmp2)\n-     struct reverse_tree *p1, *p2;\n-     struct reverse_tree **tmp1, **tmp2;\n-{\n-  struct reverse_tree *t1 = p1;\n-  struct reverse_tree *t2 = p2;\n-  int i, j;\n-\n-  /* First, check if we're actually looking at the same expression twice,\n-     which can happen if it's wrapped in a SAVE_EXPR - in this case there's\n-     no chance of conflict.  */\n-  while (t1 && t2 && t1->x == t2->x)\n+  if (class == '1')\n     {\n-      if (TREE_CODE (t1->x) == SAVE_EXPR)\n-\treturn 0;\n-      t1 = t1->parent;\n-      t2 = t2->parent;\n+      if (first_rtl_op (code) == 0)\n+\treturn;\n+      x = TREE_OPERAND (x, 0);\n+      writer = 0;\n+      goto restart;\n     }\n \n-  for (i = 0; p1; i++, p1 = p1->parent)\n-    tmp1[i] = p1;\n-  for (j = 0; p2; j++, p2 = p2->parent)\n-    tmp2[j] = p2;\n-  while (tmp1[i - 1] == tmp2[j - 1])\n-    i--, j--;\n-\n-  return tmp1[i];\n-}\n-\n-/* Subroutine of verify_sequence_points to check whether a node T corresponding\n-   to a MODIFY_EXPR invokes undefined behaviour.  OTHER occurs somewhere in the\n-   RHS, and an identical expression is the LHS of T.\n-   For MODIFY_EXPRs, some special cases apply when testing for undefined\n-   behaviour if one of the expressions we found is the LHS of the MODIFY_EXPR.\n-   If the other expression is just a use, then there's no undefined behaviour.\n-   Likewise, if the other expression is wrapped inside another expression that\n-   will force a sequence point, then there's no undefined behaviour either.  */\n-\n-static int\n-modify_ok (t, other)\n-     struct reverse_tree *t, *other;\n-{\n-  struct reverse_tree *p;\n-\n-  if (! other->write)\n-    return 1;\n-\n-  /* See if there's an intervening sequence point.  */\n-  for (p = other; p->parent != t; p = p->parent)\n+  switch (class)\n     {\n-      if ((TREE_CODE (p->parent->x) == COMPOUND_EXPR\n-\t   || TREE_CODE (p->parent->x) == TRUTH_ANDIF_EXPR\n-\t   || TREE_CODE (p->parent->x) == TRUTH_ORIF_EXPR\n-\t   || TREE_CODE (p->parent->x) == COND_EXPR)\n-\t  && p->operandno == 0)\n-\treturn 1;\n-      if (TREE_CODE (p->parent->x) == SAVE_EXPR)\n-\treturn 1;\n-      if (TREE_CODE (p->parent->x) == CALL_EXPR\n-\t  && p->operandno != 0)\n-\treturn 1;\n+    case 'r':\n+    case '<':\n+    case '2':\n+    case 'b':\n+    case 'e':\n+    case 's':\n+    case 'x':\n+      {\n+\tint lp;\n+\tint max = first_rtl_op (TREE_CODE (x));\n+\tfor (lp = 0; lp < max; lp++)\n+\t  {\n+\t    tmp_before = tmp_nosp = 0;\n+\t    verify_tree (TREE_OPERAND (x, lp), &tmp_before, &tmp_nosp, NULL_TREE);\n+\t    merge_tlist (&tmp_nosp, tmp_before, 0);\n+\t    add_tlist (pno_sp, tmp_nosp, NULL_TREE, 0);\n+\t  }\n+\tbreak;\n+      }\n     }\n-  return 0;\n }\n \n /* Try to warn for undefined behaviour in EXPR due to missing sequence\n@@ -3610,65 +3806,19 @@ static void\n verify_sequence_points (expr)\n      tree expr;\n {\n-  struct reverse_tree **tmp1, **tmp2;\n-  struct reverse_tree *p;\n-\n-  reverse_list = 0;\n-  reverse_max_depth = 0;\n-  build_reverse_tree (expr, NULL, 0, 1, 0, 1);\n-\n-  tmp1 = (struct reverse_tree **) xmalloc (sizeof (struct reverse_tree *)\n-\t\t\t\t\t   * reverse_max_depth);\n-  tmp2 = (struct reverse_tree **) xmalloc (sizeof (struct reverse_tree *)\n-\t\t\t\t\t   * reverse_max_depth);\n-\n-  /* Search for multiple occurrences of the same variable, where either both\n-     occurrences are writes, or one is a read and a write.  If we can't prove\n-     that these are ordered by a sequence point, warn that the expression is\n-     undefined.  */\n-  for (p = reverse_list; p; p = p->next)\n-    {\n-      struct reverse_tree *p2;\n-      if (TREE_CODE (p->x) != VAR_DECL && TREE_CODE (p->x) != PARM_DECL)\n-\tcontinue;\n-      for (p2 = p->next; p2; p2 = p2->next)\n-\t{\n-\t  if ((TREE_CODE (p2->x) == VAR_DECL || TREE_CODE (p2->x) == PARM_DECL)\n-\t      && DECL_NAME (p->x) == DECL_NAME (p2->x)\n-\t      && (p->write || p2->write))\n-\t    {\n-\t      struct reverse_tree *t = common_ancestor (p, p2, tmp1, tmp2);\n+  struct tlist *before_sp = 0, *after_sp = 0;\n \n-\t      if (t == 0\n-\t\t  || TREE_CODE (t->x) == COMPOUND_EXPR\n-\t\t  || TREE_CODE (t->x) == TRUTH_ANDIF_EXPR\n-\t\t  || TREE_CODE (t->x) == TRUTH_ORIF_EXPR\n-\t\t  || TREE_CODE (t->x) == COND_EXPR)\n-\t\tcontinue;\n-\t      if (TREE_CODE (t->x) == MODIFY_EXPR\n-\t\t  && p->parent == t\n-\t\t  && modify_ok (t, p2))\n-\t\tcontinue;\n-\t      if (TREE_CODE (t->x) == MODIFY_EXPR\n-\t\t  && p2->parent == t\n-\t\t  && modify_ok (t, p))\n-\t\tcontinue;\n-\n-\t      warning (\"operation on `%s' may be undefined\",\n-\t\t       IDENTIFIER_POINTER (DECL_NAME (p->x)));\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  while (reverse_list)\n+  warned_ids = 0;\n+  save_expr_cache = 0;\n+  if (tlist_firstobj == 0)\n     {\n-      struct reverse_tree *p = reverse_list;\n-      reverse_list = p->next;\n-      free (p);\n+      gcc_obstack_init (&tlist_obstack);\n+      tlist_firstobj = obstack_alloc (&tlist_obstack, 0);\n     }\n-  free (tmp1);\n-  free (tmp2);\n+\n+  verify_tree (expr, &before_sp, &after_sp, 0);\n+  warn_for_collisions (after_sp);\n+  obstack_free (&tlist_obstack, tlist_firstobj);\n }\n \n void"}, {"sha": "9284a1943a97e69c5b0ccf894239a63cfac28047", "filename": "gcc/fold-const.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235cfbc40ffdc27a7578595042e4c1965e2000ed/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235cfbc40ffdc27a7578595042e4c1965e2000ed/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=235cfbc40ffdc27a7578595042e4c1965e2000ed", "patch": "@@ -5962,7 +5962,9 @@ fold (expr)\n       /* If either arg is constant true, drop it.  */\n       if (TREE_CODE (arg0) == INTEGER_CST && ! integer_zerop (arg0))\n \treturn non_lvalue (convert (type, arg1));\n-      if (TREE_CODE (arg1) == INTEGER_CST && ! integer_zerop (arg1))\n+      if (TREE_CODE (arg1) == INTEGER_CST && ! integer_zerop (arg1)\n+\t  /* Preserve sequence points.  */\n+\t  && (code != TRUTH_ANDIF_EXPR || ! TREE_SIDE_EFFECTS (arg0)))\n \treturn non_lvalue (convert (type, arg0));\n       /* If second arg is constant zero, result is zero, but first arg\n \t must be evaluated.  */\n@@ -6048,7 +6050,9 @@ fold (expr)\n       /* If either arg is constant zero, drop it.  */\n       if (TREE_CODE (arg0) == INTEGER_CST && integer_zerop (arg0))\n \treturn non_lvalue (convert (type, arg1));\n-      if (TREE_CODE (arg1) == INTEGER_CST && integer_zerop (arg1))\n+      if (TREE_CODE (arg1) == INTEGER_CST && integer_zerop (arg1)\n+\t  /* Preserve sequence points.  */\n+\t  && (code != TRUTH_ORIF_EXPR || ! TREE_SIDE_EFFECTS (arg0)))\n \treturn non_lvalue (convert (type, arg0));\n       /* If second arg is constant true, result is true, but we must\n \t evaluate first arg.  */"}, {"sha": "237ab8f71bd5852f52a0a84330e38e1ee0d8e823", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235cfbc40ffdc27a7578595042e4c1965e2000ed/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235cfbc40ffdc27a7578595042e4c1965e2000ed/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=235cfbc40ffdc27a7578595042e4c1965e2000ed", "patch": "@@ -1,3 +1,7 @@\n+2000-11-24  Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+\t* gcc.dg/sequence-point-1.c: Add some new tests.\n+\n 2000-11-24  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.old-deja/g++.other/vaarg4.C: New test."}, {"sha": "1faf4a9e24a0f46acfa4fbb56d879c0b35648d2d", "filename": "gcc/testsuite/gcc.dg/sequence-pt-1.c", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235cfbc40ffdc27a7578595042e4c1965e2000ed/gcc%2Ftestsuite%2Fgcc.dg%2Fsequence-pt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235cfbc40ffdc27a7578595042e4c1965e2000ed/gcc%2Ftestsuite%2Fgcc.dg%2Fsequence-pt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsequence-pt-1.c?ref=235cfbc40ffdc27a7578595042e4c1965e2000ed", "patch": "@@ -19,7 +19,7 @@ typedef __SIZE_TYPE__ size_t;\n \n void\n foo (int a, int b, int n, int p, int *ptr, struct s *sptr,\n-     int *ap, int *bp, int **cp, char *ans)\n+     int *ap, int *bp, int **cp, char *ans, int (*fnp[8])(int))\n {\n   int len;\n     \n@@ -44,17 +44,35 @@ foo (int a, int b, int n, int p, int *ptr, struct s *sptr,\n   a = (bp[a++] = b) + 1; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   a = b++ * b++; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   a = fnb (b++, b++); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  a = (*fnp[b++]) (b++); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  a = (*fnp[b]) (b++); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  a = (*fnp[b++]) (b); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   *ap = fnc (ap++); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   (a += b) + (a += n); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   a =  (b, b++) + (b++, b); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   ap[a++] += a; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   ap[a+=1] += a; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   ap[a++] += a++; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   ap[a+=1] += a++; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  a = a++, b = a; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  b = a, a = a++; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  a = (b++ ? n : a) + b; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  b ? a = a++ : a; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  b ? a : a = a++; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  b && (a = a++); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  (a = a++) && b; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  b, (a = a++); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  (a = a++), b; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  a ^= b ^= a ^= b; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n \n+  a = a; /* { dg-bogus \"undefined\" \"bogus sequence point warning\" } */\n   a = (a++ && 4); /* { dg-bogus \"undefined\" \"bogus sequence point warning\" } */\n+  a = ! (a++ && 4); /* { dg-bogus \"undefined\" \"bogus sequence point warning\" } */\n+  a = - (a++ && 4); /* { dg-bogus \"undefined\" \"bogus sequence point warning\" } */\n+  a = (double) (a++ && 4); /* { dg-bogus \"undefined\" \"bogus sequence point warning\" } */\n   len = sprintf (ans, \"%d\", len++); /* { dg-bogus \"undefined\" \"bogus sequence point warning\" } */\n-  a = fn (a++); /* { dg-bogus \"undefined\" \"sequence point warning\" } */\n+  a = fn (a++); /* { dg-bogus \"undefined\" \"bogus sequence point warning\" } */\n+  b++, (b + b); /* { dg-bogus \"undefined\" \"bogus sequence point warning\" } */\n   (a = b++), (a = b++); /* { dg-bogus \"undefined\" \"bogus sequence point warning\" } */\n   a = (b++, b++); /* { dg-bogus \"undefined\" \"bogus sequence point warning\" } */\n   a = b++ && b++; /* { dg-bogus \"undefined\" \"bogus sequence point warning\" } */\n@@ -63,4 +81,30 @@ foo (int a, int b, int n, int p, int *ptr, struct s *sptr,\n   a = (b++ ? a : b++); /* { dg-bogus \"undefined\" \"bogus sequence point warning\" } */\n   ap[a++] += bp[b]; /* { dg-bogus \"undefined\" \"bogus sequence point warning\" } */\n   ap[a += 1] += 1; /* { dg-bogus \"undefined\" \"bogus sequence point warning\" } */\n+  *ptr < 128 ? *ptr++ : *(ptr += 2); /* { dg-bogus \"undefined\" \"bogus sequence point warning\" } */\n+\n+  /* The following will be represented internally with a tree consisting of\n+     many duplicated SAVE_EXPRs.  This caused the previous version of the\n+     sequence point warning code to fail by running out of virtual memory.  */\n+  a = ((b & 1 ? 21 : 0)\n+       | (b & 2 ? 22 : 0)\n+       | (b & 3 ? 23 : 0)\n+       | (b & 4 ? 24 : 0)\n+       | (b & 5 ? 25 : 0)\n+       | (b & 6 ? 26 : 0)\n+       | (b & 7 ? 27 : 0)\n+       | (b & 8 ? 28 : 0)\n+       | (b & 9 ? 29 : 0)\n+       | (b & 10 ? 30 : 0)\n+       | (b & 11 ? 31 : 0)\n+       | (b & 12 ? 32 : 0)\n+       | (b & 13 ? 1 : 0)\n+       | (b & 14 ? 2 : 0)\n+       | (b & 15 ? 3 : 0)\n+       | (b & 16 ? 4 : 0)\n+       | (b & 17 ? 5 : 0)\n+       | (b & 18 ? 6 : 0)\n+       | (b & 19 ? 7 : 0)\n+       | (b & 20 ? 8 : 0)\n+       | (b & 21 ? 9 : 0));\n }"}]}