{"sha": "02d895504cc59be06fc3f7ec0cfd4eb160561211", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJkODk1NTA0Y2M1OWJlMDZmYzNmN2VjMGNmZDRlYjE2MDU2MTIxMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-29T14:47:44Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-29T14:47:44Z"}, "message": "Don't defer choice of vector type for bools (PR 92596)\n\nNow that stmt_vec_info records the choice between vector mask\ntypes and normal nonmask types, we can use that information in\nvect_get_vector_types_for_stmt instead of deferring the choice\nof vector type till later.\n\nvect_get_mask_type_for_stmt used to check whether the boolean inputs\nto an operation:\n(a) consistently used mask types or consistently used nonmask types; and\n(b) agreed on the number of elements.\n\n(b) shouldn't be a problem when (a) is met.  If the operation\nconsistently uses mask types, tree-vect-patterns.c will have corrected\nany mismatches in mask precision.  (This is because we only use mask\ntypes for a small well-known set of operations and tree-vect-patterns.c\nknows how to handle any that could have different mask precisions.)\nAnd if the operation consistently uses normal nonmask types, there's\nno reason why booleans should need extra vector compatibility checks\ncompared to ordinary integers.\n\nSo the potential difficulties all seem to come from (a).  Now that\nwe've chosen the result type ahead of time, we also have to consider\nwhether the outputs and inputs consistently use mask types.\n\nTaking each vectorizable_* routine in turn:\n\n- vectorizable_call\n\n    vect_get_vector_types_for_stmt only handled booleans specially\n    for gassigns, so vect_get_mask_type_for_stmt never had chance to\n    handle calls.  I'm not sure we support any calls that operate on\n    booleans, but as things stand, a boolean result would always have\n    a nonmask type.  Presumably any vector argument would also need to\n    use nonmask types, unless it corresponds to internal_fn_mask_index\n    (which is already a special case).\n\n    For safety, I've added a check for mask/nonmask combinations here\n    even though we didn't check this previously.\n\n- vectorizable_simd_clone_call\n\n    Again, vect_get_mask_type_for_stmt never had chance to handle calls.\n    The result of the call will always be a nonmask type and the patch\n    for PR 92710 rejects mask arguments.  So all booleans should\n    consistently use nonmask types here.\n\n- vectorizable_conversion\n\n    The function already rejects any conversion between booleans in which\n    one type isn't a mask type.\n\n- vectorizable_operation\n\n    This function definitely needs a consistency check, e.g. to handle\n    & and | in which one operand is loaded from memory and the other is\n    a comparison result.  Ideally we'd handle this via pattern stmts\n    instead (like we do for the all-mask case), but that's future work.\n\n- vectorizable_assignment\n\n    VECT_SCALAR_BOOLEAN_TYPE_P requires single-bit precision, so the\n    current code already rejects problematic cases.\n\n- vectorizable_load\n\n    Loads always produce nonmask types and there are no relevant inputs\n    to check against.\n\n- vectorizable_store\n\n    vect_check_store_rhs already rejects mask/nonmask combinations\n    via useless_type_conversion_p.\n\n- vectorizable_reduction\n- vectorizable_lc_phi\n\n    PHIs always have nonmask types.  After the change above, attempts\n    to combine the PHI result with a mask type would be rejected by\n    vectorizable_operation.  (Again, it would be better to handle\n    this using pattern stmts.)\n\n- vectorizable_induction\n\n    We don't generate inductions for booleans.\n\n- vectorizable_shift\n\n    The function already rejects boolean shifts via type_has_mode_precision_p.\n\n- vectorizable_condition\n\n    The function already rejects mismatches via useless_type_conversion_p.\n\n- vectorizable_comparison\n\n    The function already rejects comparisons between mask and nonmask types.\n    The result is always a mask type.\n\n2019-11-29  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\tPR tree-optimization/92596\n\t* tree-vect-stmts.c (vectorizable_call): Punt on hybrid mask/nonmask\n\toperations.\n\t(vectorizable_operation): Likewise, instead of relying on\n\tvect_get_mask_type_for_stmt to do this.\n\t(vect_get_vector_types_for_stmt): Always return a vector type\n\timmediately, rather than deferring the choice for boolean results.\n\tUse a vector mask type instead of a normal vector if\n\tvect_use_mask_type_p.\n\t(vect_get_mask_type_for_stmt): Delete.\n\t* tree-vect-loop.c (vect_determine_vf_for_stmt_1): Remove\n\tmask_producers argument and special boolean_type_node handling.\n\t(vect_determine_vf_for_stmt): Remove mask_producers argument and\n\tupdate calls to vect_determine_vf_for_stmt_1.  Remove doubled call.\n\t(vect_determine_vectorization_factor): Update call accordingly.\n\t* tree-vect-slp.c (vect_build_slp_tree_1): Remove special\n\tboolean_type_node handling.\n\t(vect_slp_analyze_node_operations_1): Likewise.\n\ngcc/testsuite/\n\tPR tree-optimization/92596\n\t* gcc.dg/vect/bb-slp-pr92596.c: New test.\n\t* gcc.dg/vect/bb-slp-43.c: Likewise.\n\nFrom-SVN: r278851", "tree": {"sha": "f5842a2462cf34f8b20f78ac536079cf262b7675", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5842a2462cf34f8b20f78ac536079cf262b7675"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02d895504cc59be06fc3f7ec0cfd4eb160561211", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02d895504cc59be06fc3f7ec0cfd4eb160561211", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02d895504cc59be06fc3f7ec0cfd4eb160561211", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02d895504cc59be06fc3f7ec0cfd4eb160561211/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0c3ea6b3424ee4d32d97ca5d7453891b587b3132", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c3ea6b3424ee4d32d97ca5d7453891b587b3132", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c3ea6b3424ee4d32d97ca5d7453891b587b3132"}], "stats": {"total": 294, "additions": 113, "deletions": 181}, "files": [{"sha": "002d9aa1217c1d67fc366ed29e7f17b2eaf95485", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d895504cc59be06fc3f7ec0cfd4eb160561211/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d895504cc59be06fc3f7ec0cfd4eb160561211/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02d895504cc59be06fc3f7ec0cfd4eb160561211", "patch": "@@ -1,3 +1,24 @@\n+2019-11-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/92596\n+\t* tree-vect-stmts.c (vectorizable_call): Punt on hybrid mask/nonmask\n+\toperations.\n+\t(vectorizable_operation): Likewise, instead of relying on\n+\tvect_get_mask_type_for_stmt to do this.\n+\t(vect_get_vector_types_for_stmt): Always return a vector type\n+\timmediately, rather than deferring the choice for boolean results.\n+\tUse a vector mask type instead of a normal vector if\n+\tvect_use_mask_type_p.\n+\t(vect_get_mask_type_for_stmt): Delete.\n+\t* tree-vect-loop.c (vect_determine_vf_for_stmt_1): Remove\n+\tmask_producers argument and special boolean_type_node handling.\n+\t(vect_determine_vf_for_stmt): Remove mask_producers argument and\n+\tupdate calls to vect_determine_vf_for_stmt_1.  Remove doubled call.\n+\t(vect_determine_vectorization_factor): Update call accordingly.\n+\t* tree-vect-slp.c (vect_build_slp_tree_1): Remove special\n+\tboolean_type_node handling.\n+\t(vect_slp_analyze_node_operations_1): Likewise.\n+\n 2019-11-29  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (stmt_vec_info::mask_precision): New field."}, {"sha": "57544a5c17a3c4265b59ac263c5be977748452f9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d895504cc59be06fc3f7ec0cfd4eb160561211/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d895504cc59be06fc3f7ec0cfd4eb160561211/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=02d895504cc59be06fc3f7ec0cfd4eb160561211", "patch": "@@ -1,3 +1,9 @@\n+2019-11-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/92596\n+\t* gcc.dg/vect/bb-slp-pr92596.c: New test.\n+\t* gcc.dg/vect/bb-slp-43.c: Likewise.\n+\n 2019-11-29  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.dg/vect/vect-bool-cmp-2.c: New test."}, {"sha": "a65d9513c4d519ca4bd96840e172a47ca957fa26", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-43.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d895504cc59be06fc3f7ec0cfd4eb160561211/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d895504cc59be06fc3f7ec0cfd4eb160561211/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-43.c?ref=02d895504cc59be06fc3f7ec0cfd4eb160561211", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+\n+void\n+f (int *restrict x, short *restrict y)\n+{\n+  x[0] = x[0] == 1 & y[0] == 2;\n+  x[1] = x[1] == 1 & y[1] == 2;\n+  x[2] = x[2] == 1 & y[2] == 2;\n+  x[3] = x[3] == 1 & y[3] == 2;\n+  x[4] = x[4] == 1 & y[4] == 2;\n+  x[5] = x[5] == 1 & y[5] == 2;\n+  x[6] = x[6] == 1 & y[6] == 2;\n+  x[7] = x[7] == 1 & y[7] == 2;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"mixed mask and nonmask\" \"slp2\" } } */\n+/* { dg-final { scan-tree-dump-not \"vector operands from scalars\" \"slp2\" { target { { vect_int && vect_bool_cmp } && { vect_unpack && vect_hw_misalign } } xfail vect_variable_length } } } */"}, {"sha": "f3dd08d9878cb4446a4cd2de65f2e6567150ebf2", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr92596.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d895504cc59be06fc3f7ec0cfd4eb160561211/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr92596.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d895504cc59be06fc3f7ec0cfd4eb160561211/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr92596.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr92596.c?ref=02d895504cc59be06fc3f7ec0cfd4eb160561211", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+typedef struct {\n+  long n[5];\n+} secp256k1_fe;\n+\n+secp256k1_fe a;\n+\n+void fn1(int p1) { a.n[0] = a.n[1] = a.n[2] = p1; }\n+void fn2() {\n+  int b;\n+  fn1(!b);\n+}"}, {"sha": "ab48a05dbed35ec59904cd409d9a84b87f1b62fc", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d895504cc59be06fc3f7ec0cfd4eb160561211/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d895504cc59be06fc3f7ec0cfd4eb160561211/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=02d895504cc59be06fc3f7ec0cfd4eb160561211", "patch": "@@ -163,8 +163,7 @@ static stmt_vec_info vect_is_simple_reduction (loop_vec_info, stmt_vec_info,\n static opt_result\n vect_determine_vf_for_stmt_1 (stmt_vec_info stmt_info,\n \t\t\t      bool vectype_maybe_set_p,\n-\t\t\t      poly_uint64 *vf,\n-\t\t\t      vec<stmt_vec_info > *mask_producers)\n+\t\t\t      poly_uint64 *vf)\n {\n   gimple *stmt = stmt_info->stmt;\n \n@@ -192,8 +191,6 @@ vect_determine_vf_for_stmt_1 (stmt_vec_info stmt_info,\n \tgcc_assert ((STMT_VINFO_DATA_REF (stmt_info)\n \t\t     || vectype_maybe_set_p)\n \t\t    && STMT_VINFO_VECTYPE (stmt_info) == stmt_vectype);\n-      else if (stmt_vectype == boolean_type_node)\n-\tmask_producers->safe_push (stmt_info);\n       else\n \tSTMT_VINFO_VECTYPE (stmt_info) = stmt_vectype;\n     }\n@@ -206,21 +203,17 @@ vect_determine_vf_for_stmt_1 (stmt_vec_info stmt_info,\n \n /* Subroutine of vect_determine_vectorization_factor.  Set the vector\n    types of STMT_INFO and all attached pattern statements and update\n-   the vectorization factor VF accordingly.  If some of the statements\n-   produce a mask result whose vector type can only be calculated later,\n-   add them to MASK_PRODUCERS.  Return true on success or false if\n-   something prevented vectorization.  */\n+   the vectorization factor VF accordingly.  Return true on success\n+   or false if something prevented vectorization.  */\n \n static opt_result\n-vect_determine_vf_for_stmt (stmt_vec_info stmt_info, poly_uint64 *vf,\n-\t\t\t    vec<stmt_vec_info > *mask_producers)\n+vect_determine_vf_for_stmt (stmt_vec_info stmt_info, poly_uint64 *vf)\n {\n   vec_info *vinfo = stmt_info->vinfo;\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"==> examining statement: %G\",\n \t\t     stmt_info->stmt);\n-  opt_result res\n-    = vect_determine_vf_for_stmt_1 (stmt_info, false, vf, mask_producers);\n+  opt_result res = vect_determine_vf_for_stmt_1 (stmt_info, false, vf);\n   if (!res)\n     return res;\n \n@@ -239,10 +232,7 @@ vect_determine_vf_for_stmt (stmt_vec_info stmt_info, poly_uint64 *vf,\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"==> examining pattern def stmt: %G\",\n \t\t\t     def_stmt_info->stmt);\n-\t  if (!vect_determine_vf_for_stmt_1 (def_stmt_info, true,\n-\t\t\t\t\t     vf, mask_producers))\n-\t  res = vect_determine_vf_for_stmt_1 (def_stmt_info, true,\n-\t\t\t\t\t      vf, mask_producers);\n+\t  res = vect_determine_vf_for_stmt_1 (def_stmt_info, true, vf);\n \t  if (!res)\n \t    return res;\n \t}\n@@ -251,7 +241,7 @@ vect_determine_vf_for_stmt (stmt_vec_info stmt_info, poly_uint64 *vf,\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"==> examining pattern statement: %G\",\n \t\t\t stmt_info->stmt);\n-      res = vect_determine_vf_for_stmt_1 (stmt_info, true, vf, mask_producers);\n+      res = vect_determine_vf_for_stmt_1 (stmt_info, true, vf);\n       if (!res)\n \treturn res;\n     }\n@@ -296,7 +286,6 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n   tree vectype;\n   stmt_vec_info stmt_info;\n   unsigned i;\n-  auto_vec<stmt_vec_info> mask_producers;\n \n   DUMP_VECT_SCOPE (\"vect_determine_vectorization_factor\");\n \n@@ -354,8 +343,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t{\n \t  stmt_info = loop_vinfo->lookup_stmt (gsi_stmt (si));\n \t  opt_result res\n-\t    = vect_determine_vf_for_stmt (stmt_info, &vectorization_factor,\n-\t\t\t\t\t  &mask_producers);\n+\t    = vect_determine_vf_for_stmt (stmt_info, &vectorization_factor);\n \t  if (!res)\n \t    return res;\n         }\n@@ -373,16 +361,6 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n     return opt_result::failure_at (vect_location,\n \t\t\t\t   \"not vectorized: unsupported data-type\\n\");\n   LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n-\n-  for (i = 0; i < mask_producers.length (); i++)\n-    {\n-      stmt_info = mask_producers[i];\n-      opt_tree mask_type = vect_get_mask_type_for_stmt (stmt_info);\n-      if (!mask_type)\n-\treturn opt_result::propagate_failure (mask_type);\n-      STMT_VINFO_VECTYPE (stmt_info) = mask_type;\n-    }\n-\n   return opt_result::success ();\n }\n "}, {"sha": "0d420e44bb0d977c9bc38bc6a7e0b875facfd2eb", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 33, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d895504cc59be06fc3f7ec0cfd4eb160561211/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d895504cc59be06fc3f7ec0cfd4eb160561211/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=02d895504cc59be06fc3f7ec0cfd4eb160561211", "patch": "@@ -925,17 +925,6 @@ vect_build_slp_tree_1 (unsigned char *swap,\n \t      || rhs_code == LROTATE_EXPR\n \t      || rhs_code == RROTATE_EXPR)\n \t    {\n-\t      if (vectype == boolean_type_node)\n-\t\t{\n-\t\t  if (dump_enabled_p ())\n-\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t     \"Build SLP failed: shift of a\"\n-\t\t\t\t     \" boolean.\\n\");\n-\t\t  /* Fatal mismatch.  */\n-\t\t  matches[0] = false;\n-\t\t  return false;\n-\t\t}\n-\n \t      vec_mode = TYPE_MODE (vectype);\n \n \t      /* First see if we have a vector/vector shift.  */\n@@ -1157,9 +1146,8 @@ vect_build_slp_tree_1 (unsigned char *swap,\n   if (alt_stmt_code != ERROR_MARK\n       && TREE_CODE_CLASS (alt_stmt_code) != tcc_reference)\n     {\n-      if (vectype == boolean_type_node\n-\t  || !vect_two_operations_perm_ok_p (stmts, group_size,\n-\t\t\t\t\t     vectype, alt_stmt_code))\n+      if (!vect_two_operations_perm_ok_p (stmts, group_size,\n+\t\t\t\t\t  vectype, alt_stmt_code))\n \t{\n \t  for (i = 0; i < group_size; ++i)\n \t    if (gimple_assign_rhs_code (stmts[i]->stmt) == alt_stmt_code)\n@@ -2751,25 +2739,6 @@ vect_slp_analyze_node_operations_1 (vec_info *vinfo, slp_tree node,\n   stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n   gcc_assert (STMT_SLP_TYPE (stmt_info) != loop_vect);\n \n-  /* For BB vectorization vector types are assigned here.\n-     Memory accesses already got their vector type assigned\n-     in vect_analyze_data_refs.  */\n-  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n-  if (bb_vinfo && STMT_VINFO_VECTYPE (stmt_info) == boolean_type_node)\n-    {\n-      unsigned int group_size = SLP_TREE_SCALAR_STMTS (node).length ();\n-      tree vectype = vect_get_mask_type_for_stmt (stmt_info, group_size);\n-      if (!vectype)\n-\t/* vect_get_mask_type_for_stmt has already explained the\n-\t   failure.  */\n-\treturn false;\n-\n-      stmt_vec_info sstmt_info;\n-      unsigned int i;\n-      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, sstmt_info)\n-\tSTMT_VINFO_VECTYPE (sstmt_info) = vectype;\n-    }\n-\n   /* Calculate the number of vector statements to be created for the\n      scalar stmts in this node.  For SLP reductions it is equal to the\n      number of vector statements in the children (which has already been"}, {"sha": "2cb6b1544ea1216640220f0b4808406f94f8ae49", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 45, "deletions": 118, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d895504cc59be06fc3f7ec0cfd4eb160561211/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d895504cc59be06fc3f7ec0cfd4eb160561211/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=02d895504cc59be06fc3f7ec0cfd4eb160561211", "patch": "@@ -3325,6 +3325,15 @@ vectorizable_call (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       return false;\n     }\n \n+  if (VECTOR_BOOLEAN_TYPE_P (vectype_out)\n+      != VECTOR_BOOLEAN_TYPE_P (vectype_in))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"mixed mask and nonmask vector types\\n\");\n+      return false;\n+    }\n+\n   /* FORNOW */\n   nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n@@ -5982,7 +5991,8 @@ vectorizable_operation (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \n   /* Most operations cannot handle bit-precision types without extra\n      truncations.  */\n-  if (!VECTOR_BOOLEAN_TYPE_P (vectype_out)\n+  bool mask_op_p = VECTOR_BOOLEAN_TYPE_P (vectype_out);\n+  if (!mask_op_p\n       && !type_has_mode_precision_p (TREE_TYPE (scalar_dest))\n       /* Exception are bitwise binary operations.  */\n       && code != BIT_IOR_EXPR\n@@ -6044,10 +6054,11 @@ vectorizable_operation (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   if (maybe_ne (nunits_out, nunits_in))\n     return false;\n \n+  tree vectype2 = NULL_TREE, vectype3 = NULL_TREE;\n   if (op_type == binary_op || op_type == ternary_op)\n     {\n       op1 = gimple_assign_rhs2 (stmt);\n-      if (!vect_is_simple_use (op1, vinfo, &dt[1]))\n+      if (!vect_is_simple_use (op1, vinfo, &dt[1], &vectype2))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6058,7 +6069,7 @@ vectorizable_operation (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   if (op_type == ternary_op)\n     {\n       op2 = gimple_assign_rhs3 (stmt);\n-      if (!vect_is_simple_use (op2, vinfo, &dt[2]))\n+      if (!vect_is_simple_use (op2, vinfo, &dt[2], &vectype3))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6083,6 +6094,21 @@ vectorizable_operation (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \n   gcc_assert (ncopies >= 1);\n \n+  /* Reject attempts to combine mask types with nonmask types, e.g. if\n+     we have an AND between a (nonmask) boolean loaded from memory and\n+     a (mask) boolean result of a comparison.\n+\n+     TODO: We could easily fix these cases up using pattern statements.  */\n+  if (VECTOR_BOOLEAN_TYPE_P (vectype) != mask_op_p\n+      || (vectype2 && VECTOR_BOOLEAN_TYPE_P (vectype2) != mask_op_p)\n+      || (vectype3 && VECTOR_BOOLEAN_TYPE_P (vectype3) != mask_op_p))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"mixed mask and nonmask vector types\\n\");\n+      return false;\n+    }\n+\n   /* Supportable by target?  */\n \n   vec_mode = TYPE_MODE (vectype);\n@@ -12026,9 +12052,6 @@ vect_gen_while_not (gimple_seq *seq, tree mask_type, tree start_index,\n \n    - Set *STMT_VECTYPE_OUT to:\n      - NULL_TREE if the statement doesn't need to be vectorized;\n-     - boolean_type_node if the statement is a boolean operation whose\n-       vector type can only be determined once all the other vector types\n-       are known; and\n      - the equivalent of STMT_VINFO_VECTYPE otherwise.\n \n    - Set *NUNITS_VECTYPE_OUT to the vector type that contains the maximum\n@@ -12085,11 +12108,22 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n   tree scalar_type = NULL_TREE;\n   if (group_size == 0 && STMT_VINFO_VECTYPE (stmt_info))\n     {\n-      *stmt_vectype_out = vectype = STMT_VINFO_VECTYPE (stmt_info);\n+      vectype = STMT_VINFO_VECTYPE (stmt_info);\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"precomputed vectype: %T\\n\", vectype);\n     }\n+  else if (vect_use_mask_type_p (stmt_info))\n+    {\n+      unsigned int precision = stmt_info->mask_precision;\n+      scalar_type = build_nonstandard_integer_type (precision, 1);\n+      vectype = get_mask_type_for_scalar_type (vinfo, scalar_type, group_size);\n+      if (!vectype)\n+\treturn opt_result::failure_at (stmt, \"not vectorized: unsupported\"\n+\t\t\t\t       \" data-type %T\\n\", scalar_type);\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"vectype: %T\\n\", vectype);\n+    }\n   else\n     {\n       if (data_reference *dr = STMT_VINFO_DATA_REF (stmt_info))\n@@ -12099,28 +12133,6 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n       else\n \tscalar_type = TREE_TYPE (gimple_get_lhs (stmt));\n \n-      /* Pure bool ops don't participate in number-of-units computation.\n-\t For comparisons use the types being compared.  */\n-      if (!STMT_VINFO_DATA_REF (stmt_info)\n-\t  && VECT_SCALAR_BOOLEAN_TYPE_P (scalar_type)\n-\t  && is_gimple_assign (stmt)\n-\t  && gimple_assign_rhs_code (stmt) != COND_EXPR)\n-\t{\n-\t  *stmt_vectype_out = boolean_type_node;\n-\n-\t  tree rhs1 = gimple_assign_rhs1 (stmt);\n-\t  if (TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_comparison\n-\t      && !VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (rhs1)))\n-\t    scalar_type = TREE_TYPE (rhs1);\n-\t  else\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t \"pure bool operation.\\n\");\n-\t      return opt_result::success ();\n-\t    }\n-\t}\n-\n       if (dump_enabled_p ())\n \t{\n \t  if (group_size)\n@@ -12138,18 +12150,15 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n \t\t\t\t       \" unsupported data-type %T\\n\",\n \t\t\t\t       scalar_type);\n \n-      if (!*stmt_vectype_out)\n-\t*stmt_vectype_out = vectype;\n-\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location, \"vectype: %T\\n\", vectype);\n     }\n+  *stmt_vectype_out = vectype;\n \n   /* Don't try to compute scalar types if the stmt produces a boolean\n      vector; use the existing vector type instead.  */\n   tree nunits_vectype = vectype;\n-  if (!VECTOR_BOOLEAN_TYPE_P (vectype)\n-      && *stmt_vectype_out != boolean_type_node)\n+  if (!VECTOR_BOOLEAN_TYPE_P (vectype))\n     {\n       /* The number of units is set according to the smallest scalar\n \t type (or the largest vector size, but we only support one\n@@ -12174,9 +12183,8 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n \t}\n     }\n \n-  gcc_assert (*stmt_vectype_out == boolean_type_node\n-\t      || multiple_p (TYPE_VECTOR_SUBPARTS (nunits_vectype),\n-\t\t\t     TYPE_VECTOR_SUBPARTS (*stmt_vectype_out)));\n+  gcc_assert (multiple_p (TYPE_VECTOR_SUBPARTS (nunits_vectype),\n+\t\t\t  TYPE_VECTOR_SUBPARTS (*stmt_vectype_out)));\n \n   if (dump_enabled_p ())\n     {\n@@ -12188,84 +12196,3 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n   *nunits_vectype_out = nunits_vectype;\n   return opt_result::success ();\n }\n-\n-/* Try to determine the correct vector type for STMT_INFO, which is a\n-   statement that produces a scalar boolean result.  Return the vector\n-   type on success, otherwise return NULL_TREE.  If GROUP_SIZE is nonzero\n-   and we're performing BB vectorization, make sure that the number of\n-   elements in the vector is no bigger than GROUP_SIZE.  */\n-\n-opt_tree\n-vect_get_mask_type_for_stmt (stmt_vec_info stmt_info, unsigned int group_size)\n-{\n-  vec_info *vinfo = stmt_info->vinfo;\n-  gimple *stmt = stmt_info->stmt;\n-  tree mask_type = NULL;\n-  tree vectype, scalar_type;\n-\n-  if (is_gimple_assign (stmt)\n-      && TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_comparison\n-      && !VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (stmt))))\n-    {\n-      scalar_type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n-      mask_type = get_mask_type_for_scalar_type (vinfo, scalar_type,\n-\t\t\t\t\t\t group_size);\n-\n-      if (!mask_type)\n-\treturn opt_tree::failure_at (stmt,\n-\t\t\t\t     \"not vectorized: unsupported mask\\n\");\n-    }\n-  else\n-    {\n-      tree rhs;\n-      ssa_op_iter iter;\n-      enum vect_def_type dt;\n-\n-      FOR_EACH_SSA_TREE_OPERAND (rhs, stmt, iter, SSA_OP_USE)\n-\t{\n-\t  if (!vect_is_simple_use (rhs, stmt_info->vinfo, &dt, &vectype))\n-\t    return opt_tree::failure_at (stmt,\n-\t\t\t\t\t \"not vectorized:can't compute mask\"\n-\t\t\t\t\t \" type for statement, %G\", stmt);\n-\n-\t  /* No vectype probably means external definition.\n-\t     Allow it in case there is another operand which\n-\t     allows to determine mask type.  */\n-\t  if (!vectype)\n-\t    continue;\n-\n-\t  if (!mask_type)\n-\t    mask_type = vectype;\n-\t  else if (maybe_ne (TYPE_VECTOR_SUBPARTS (mask_type),\n-\t\t\t     TYPE_VECTOR_SUBPARTS (vectype)))\n-\t    return opt_tree::failure_at (stmt,\n-\t\t\t\t\t \"not vectorized: different sized mask\"\n-\t\t\t\t\t \" types in statement, %T and %T\\n\",\n-\t\t\t\t\t mask_type, vectype);\n-\t  else if (VECTOR_BOOLEAN_TYPE_P (mask_type)\n-\t\t   != VECTOR_BOOLEAN_TYPE_P (vectype))\n-\t    return opt_tree::failure_at (stmt,\n-\t\t\t\t\t \"not vectorized: mixed mask and \"\n-\t\t\t\t\t \"nonmask vector types in statement, \"\n-\t\t\t\t\t \"%T and %T\\n\",\n-\t\t\t\t\t mask_type, vectype);\n-\t}\n-\n-      /* We may compare boolean value loaded as vector of integers.\n-\t Fix mask_type in such case.  */\n-      if (mask_type\n-\t  && !VECTOR_BOOLEAN_TYPE_P (mask_type)\n-\t  && gimple_code (stmt) == GIMPLE_ASSIGN\n-\t  && TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_comparison)\n-\tmask_type = truth_type_for (mask_type);\n-    }\n-\n-  /* No mask_type should mean loop invariant predicate.\n-     This is probably a subject for optimization in if-conversion.  */\n-  if (!mask_type)\n-    return opt_tree::failure_at (stmt,\n-\t\t\t\t \"not vectorized: can't compute mask type \"\n-\t\t\t\t \"for statement: %G\", stmt);\n-\n-  return opt_tree::success (mask_type);\n-}"}]}