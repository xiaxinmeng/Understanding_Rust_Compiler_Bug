{"sha": "329d2f0df7d6d22c87ab3338b94caef68139cd58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI5ZDJmMGRmN2Q2ZDIyYzg3YWIzMzM4Yjk0Y2FlZjY4MTM5Y2Q1OA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-04-16T21:08:51Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-04-19T19:49:04Z"}, "message": "tree-optimization/100081 - Limit depth of logical expression windback.\n\nLimit how many logical expressions GORI will look back through when\nevaluating outgoing edge range.\n\n\tPR tree-optimization/100081\n\t* gimple-range-cache.h (ranger_cache): Inherit from gori_compute\n\trather than gori_compute_cache.\n\t* gimple-range-gori.cc (is_gimple_logical_p): Move to top of file.\n\t(range_def_chain::m_logical_depth): New member.\n\t(range_def_chain::range_def_chain): Initialize m_logical_depth.\n\t(range_def_chain::get_def_chain): Don't build defchains through more\n\tthan LOGICAL_LIMIT logical expressions.\n\t* params.opt (param_ranger_logical_depth): New.", "tree": {"sha": "f70ab418e58c0ff0b6008744c9a4f7f5becd4cb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f70ab418e58c0ff0b6008744c9a4f7f5becd4cb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/329d2f0df7d6d22c87ab3338b94caef68139cd58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/329d2f0df7d6d22c87ab3338b94caef68139cd58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/329d2f0df7d6d22c87ab3338b94caef68139cd58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/329d2f0df7d6d22c87ab3338b94caef68139cd58/comments", "author": null, "committer": null, "parents": [{"sha": "dc7d1c74ffb1cc85e67984632f581d526c783770", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc7d1c74ffb1cc85e67984632f581d526c783770", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc7d1c74ffb1cc85e67984632f581d526c783770"}], "stats": {"total": 74, "additions": 47, "deletions": 27}, "files": [{"sha": "2b36a02654b8cb5069153c0276c95d364d9201da", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/329d2f0df7d6d22c87ab3338b94caef68139cd58/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/329d2f0df7d6d22c87ab3338b94caef68139cd58/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=329d2f0df7d6d22c87ab3338b94caef68139cd58", "patch": "@@ -87,7 +87,7 @@ class ssa_global_cache\n // them available for gori-computes to query so outgoing edges can be\n // properly calculated.\n \n-class ranger_cache : public gori_compute_cache\n+class ranger_cache : public gori_compute\n {\n public:\n   ranger_cache (class gimple_ranger &q);"}, {"sha": "420282deb2d3bdbc6882d4ee303fbfe7bd1048f4", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/329d2f0df7d6d22c87ab3338b94caef68139cd58/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/329d2f0df7d6d22c87ab3338b94caef68139cd58/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=329d2f0df7d6d22c87ab3338b94caef68139cd58", "patch": "@@ -29,6 +29,32 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-pretty-print.h\"\n #include \"gimple-range.h\"\n \n+// Return TRUE if GS is a logical && or || expression.\n+\n+static inline bool\n+is_gimple_logical_p (const gimple *gs)\n+{\n+  // Look for boolean and/or condition.\n+  if (is_gimple_assign (gs))\n+    switch (gimple_expr_code (gs))\n+      {\n+\tcase TRUTH_AND_EXPR:\n+\tcase TRUTH_OR_EXPR:\n+\t  return true;\n+\n+\tcase BIT_AND_EXPR:\n+\tcase BIT_IOR_EXPR:\n+\t  // Bitwise operations on single bits are logical too.\n+\t  if (types_compatible_p (TREE_TYPE (gimple_assign_rhs1 (gs)),\n+\t\t\t\t  boolean_type_node))\n+\t    return true;\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+      }\n+  return false;\n+}\n \n /* RANGE_DEF_CHAIN is used to determine what SSA names in a block can\n    have range information calculated for them, and what the\n@@ -76,6 +102,7 @@ class range_def_chain\n private:\n   vec<bitmap> m_def_chain;\t// SSA_NAME : def chain components.\n   void build_def_chain (tree name, bitmap result, basic_block bb);\n+  int m_logical_depth;\n };\n \n \n@@ -85,6 +112,7 @@ range_def_chain::range_def_chain ()\n {\n   m_def_chain.create (0);\n   m_def_chain.safe_grow_cleared (num_ssa_names);\n+  m_logical_depth = 0;\n }\n \n // Destruct a range_def_chain.\n@@ -157,6 +185,7 @@ range_def_chain::get_def_chain (tree name)\n {\n   tree ssa1, ssa2, ssa3;\n   unsigned v = SSA_NAME_VERSION (name);\n+  bool is_logical = false;\n \n   // If it has already been processed, just return the cached value.\n   if (has_def_chain (name))\n@@ -169,6 +198,15 @@ range_def_chain::get_def_chain (tree name)\n   gimple *stmt = SSA_NAME_DEF_STMT (name);\n   if (gimple_range_handler (stmt))\n     {\n+      is_logical = is_gimple_logical_p (stmt);\n+      // Terminate the def chains if we see too many cascading logical stmts.\n+      if (is_logical)\n+\t{\n+\t  if (m_logical_depth == param_ranger_logical_depth)\n+\t    return NULL;\n+\t  m_logical_depth++;\n+\t}\n+\n       ssa1 = gimple_range_ssa_p (gimple_range_operand1 (stmt));\n       ssa2 = gimple_range_ssa_p (gimple_range_operand2 (stmt));\n       ssa3 = NULL_TREE;\n@@ -195,6 +233,9 @@ range_def_chain::get_def_chain (tree name)\n   if (ssa3)\n     build_def_chain (ssa3, m_def_chain[v], bb);\n \n+  if (is_logical)\n+    m_logical_depth--;\n+\n   // If we run into pathological cases where the defintion chains are\n   // huge (ie  huge basic block fully unrolled) we might be able to limit\n   // this by deciding here that if some criteria is satisfied, we change the\n@@ -562,32 +603,6 @@ gori_compute::compute_operand_range_switch (irange &r, gswitch *s,\n   return false;\n }\n \n-// Return TRUE if GS is a logical && or || expression.\n-\n-static inline bool\n-is_gimple_logical_p (const gimple *gs)\n-{\n-  // Look for boolean and/or condition.\n-  if (gimple_code (gs) == GIMPLE_ASSIGN)\n-    switch (gimple_expr_code (gs))\n-      {\n-\tcase TRUTH_AND_EXPR:\n-\tcase TRUTH_OR_EXPR:\n-\t  return true;\n-\n-\tcase BIT_AND_EXPR:\n-\tcase BIT_IOR_EXPR:\n-\t  // Bitwise operations on single bits are logical too.\n-\t  if (types_compatible_p (TREE_TYPE (gimple_assign_rhs1 (gs)),\n-\t\t\t\t  boolean_type_node))\n-\t    return true;\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-      }\n-  return false;\n-}\n \n // Return an evaluation for NAME as it would appear in STMT when the\n // statement's lhs evaluates to LHS.  If successful, return TRUE and"}, {"sha": "7c7aa78992a5f988a6b5c9952ebdd5fc5c1cf277", "filename": "gcc/params.opt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/329d2f0df7d6d22c87ab3338b94caef68139cd58/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/329d2f0df7d6d22c87ab3338b94caef68139cd58/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=329d2f0df7d6d22c87ab3338b94caef68139cd58", "patch": "@@ -157,6 +157,11 @@ Enum(evrp_mode) String(trace) Value(EVRP_MODE_TRACE)\n EnumValue\n Enum(evrp_mode) String(debug) Value(EVRP_MODE_DEBUG)\n \n+-param=ranger-logical-depth=\n+Common Joined UInteger Var(param_ranger_logical_depth) Init(6) IntegerRange(1, 999) Param Optimization\n+Maximum depth of logical expression evaluation ranger will look through when\n+evaluting outgoing edge ranges.\n+\n -param=fsm-maximum-phi-arguments=\n Common Joined UInteger Var(param_fsm_maximum_phi_arguments) Init(100) IntegerRange(1, 999999) Param Optimization\n Maximum number of arguments a PHI may have before the FSM threader will not try to thread through its block."}]}