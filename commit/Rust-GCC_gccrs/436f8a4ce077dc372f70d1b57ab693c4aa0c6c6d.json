{"sha": "436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM2ZjhhNGNlMDc3ZGMzNzJmNzBkMWI1N2FiNjkzYzRhYTBjNmM2ZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-03-11T15:43:14Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-03-11T15:43:14Z"}, "message": "re PR c++/8700 (unhelpful error message for binding temp to reference)\n\n\tPR c++/8700\n\t* call.c (convert_class_to_reference): Adjust usage of\n\tsplice_viable.\n\t(any_viable): Remove.\n\t(splice_viable): Combine with any_viable.\n\t(print_z_candidates): Avoid printing duplicates.\n\t(build_user_type_conversion_1): Adjust usage of splice_viable.\n\t(build_new_function_call): Likewise.\n\t(build_operator_new_call): Likewise.\n\t(build_object_call): Likewise.\n\t(build_conditional_expr): Likewise.\n\t(build_new_op): Likewise.\n\t(build_new_method_call): Likewise.\n\t(joust): Remove spurious comment.\n\t* cp-tree.h (DECL_FRIENDLIST): Correct documentation.\n\t* decl2.c (arg_assoc_class): Simplify.\n\t* friend.c (add_friend): Likewise.\n\nFrom-SVN: r64173", "tree": {"sha": "06a7a25a0f012883df97a7adf593d48822400080", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06a7a25a0f012883df97a7adf593d48822400080"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d/comments", "author": null, "committer": null, "parents": [{"sha": "1be4def3c6aa88e74c2a74a445405191706e323e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1be4def3c6aa88e74c2a74a445405191706e323e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1be4def3c6aa88e74c2a74a445405191706e323e"}], "stats": {"total": 215, "additions": 132, "deletions": 83}, "files": [{"sha": "121c2aefbac8a11c3fdcb9afed4e882fa742b914", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d", "patch": "@@ -1,3 +1,23 @@\n+2003-03-11  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/8700\n+\t* call.c (convert_class_to_reference): Adjust usage of\n+\tsplice_viable.\n+\t(any_viable): Remove.\n+\t(splice_viable): Combine with any_viable.\n+\t(print_z_candidates): Avoid printing duplicates.\n+\t(build_user_type_conversion_1): Adjust usage of splice_viable.\n+\t(build_new_function_call): Likewise.\n+\t(build_operator_new_call): Likewise.\n+\t(build_object_call): Likewise.\n+\t(build_conditional_expr): Likewise.\n+\t(build_new_op): Likewise.\n+\t(build_new_method_call): Likewise.\n+\t(joust): Remove spurious comment.\n+\t* cp-tree.h (DECL_FRIENDLIST): Correct documentation.\n+\t* decl2.c (arg_assoc_class): Simplify.\n+\t* friend.c (add_friend): Likewise.\n+\n 2003-03-11  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/8660"}, {"sha": "c8baf749588c7f5f13cd200e374920488ea24c6d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 105, "deletions": 69, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d", "patch": "@@ -58,8 +58,7 @@ static tree resolve_args (tree);\n static struct z_candidate *build_user_type_conversion_1 (tree, tree, int);\n static void print_z_candidates (struct z_candidate *);\n static tree build_this (tree);\n-static struct z_candidate *splice_viable (struct z_candidate *);\n-static bool any_viable (struct z_candidate *);\n+static struct z_candidate *splice_viable (struct z_candidate *, bool, bool *);\n static bool any_strictly_viable (struct z_candidate *);\n static struct z_candidate *add_template_candidate\n         (struct z_candidate **, tree, tree, tree, tree, tree, \n@@ -958,6 +957,7 @@ convert_class_to_reference (tree t, tree s, tree expr)\n   tree reference_type;\n   struct z_candidate *candidates;\n   struct z_candidate *cand;\n+  bool any_viable_p;\n \n   conversions = lookup_conversions (s);\n   if (!conversions)\n@@ -1053,12 +1053,12 @@ convert_class_to_reference (tree t, tree s, tree expr)\n       conversions = TREE_CHAIN (conversions);\n     }\n \n+  candidates = splice_viable (candidates, pedantic, &any_viable_p);\n   /* If none of the conversion functions worked out, let our caller\n      know.  */\n-  if (!any_viable (candidates))\n+  if (!any_viable_p)\n     return NULL_TREE;\n-  \n-  candidates = splice_viable (candidates);\n+\n   cand = tourney (candidates);\n   if (!cand)\n     return NULL_TREE;\n@@ -2373,14 +2373,42 @@ add_template_conv_candidate (struct z_candidate **candidates, tree tmpl,\n \t\t\t\t conversion_path, 0, obj, DEDUCE_CONV);\n }\n \n+/* The CANDS are the set of candidates that were considered for\n+   overload resolution.  Return the set of viable candidates.  If none\n+   of the candidates were viable, set *ANY_VIABLE_P to true.  STRICT_P\n+   is true if a candidate should be considered viable only if it is\n+   strictly viable.  */\n \n-static bool\n-any_viable (struct z_candidate *cands)\n+static struct z_candidate*\n+splice_viable (struct z_candidate *cands,\n+\t       bool strict_p,\n+\t       bool *any_viable_p)\n {\n-  for (; cands; cands = cands->next)\n-    if (pedantic ? cands->viable == 1 : cands->viable)\n-      return true;\n-  return false;\n+  struct z_candidate *viable;\n+  struct z_candidate **last_viable;\n+  struct z_candidate **cand;\n+\n+  viable = NULL;\n+  last_viable = &viable;\n+  *any_viable_p = false;\n+\n+  cand = &cands; \n+  while (*cand) \n+    {\n+      struct z_candidate *c = *cand;\n+      if (strict_p ? c->viable == 1 : c->viable)\n+\t{\n+\t  *last_viable = c;\n+\t  *cand = c->next;\n+\t  c->next = NULL;\n+\t  last_viable = &c->next;\n+\t  *any_viable_p = true;\n+\t}\n+      else\n+\tcand = &c->next;\n+    }\n+\n+  return viable ? viable : cands;\n }\n \n static bool\n@@ -2392,33 +2420,56 @@ any_strictly_viable (struct z_candidate *cands)\n   return false;\n }\n \n-static struct z_candidate *\n-splice_viable (struct z_candidate *cands)\n-{\n-  struct z_candidate **p = &cands;\n-\n-  for (; *p; )\n-    {\n-      if (pedantic ? (*p)->viable == 1 : (*p)->viable)\n-\tp = &((*p)->next);\n-      else\n-\t*p = (*p)->next;\n-    }\n-\n-  return cands;\n-}\n-\n static tree\n build_this (tree obj)\n {\n   /* Fix this to work on non-lvalues.  */\n   return build_unary_op (ADDR_EXPR, obj, 0);\n }\n \n+/* Returns true iff functions are equivalent. Equivalent functions are\n+   not '==' only if one is a function-local extern function or if\n+   both are extern \"C\".  */\n+\n+static inline int\n+equal_functions (tree fn1, tree fn2)\n+{\n+  if (DECL_LOCAL_FUNCTION_P (fn1) || DECL_LOCAL_FUNCTION_P (fn2)\n+      || DECL_EXTERN_C_FUNCTION_P (fn1))\n+    return decls_match (fn1, fn2);\n+  return fn1 == fn2;\n+}\n+\n static void\n print_z_candidates (struct z_candidate *candidates)\n {\n-  const char *str = \"candidates are:\";\n+  const char *str;\n+  struct z_candidate *cand1;\n+  struct z_candidate **cand2;\n+\n+  /* There may be duplicates in the set of candidates.  We put off\n+     checking this condition as long as possible, since we have no way\n+     to eliminate duplicates from a set of functions in less than n^2\n+     time.  Now we are about to emit an error message, so it is more\n+     permissible to go slowly.  */\n+  for (cand1 = candidates; cand1; cand1 = cand1->next)\n+    {\n+      tree fn = cand1->fn;\n+      /* Skip builtin candidates and conversion functions.  */\n+      if (TREE_CODE (fn) != FUNCTION_DECL)\n+\tcontinue;\n+      cand2 = &cand1->next;\n+      while (*cand2)\n+\t{\n+\t  if (TREE_CODE ((*cand2)->fn) == FUNCTION_DECL\n+\t      && equal_functions (fn, (*cand2)->fn))\n+\t    *cand2 = (*cand2)->next;\n+\t  else\n+\t    cand2 = &(*cand2)->next;\n+\t}\n+    }\n+\n+  str = \"candidates are:\";\n   for (; candidates; candidates = candidates->next)\n     {\n       if (TREE_CODE (candidates->fn) == IDENTIFIER_NODE)\n@@ -2487,6 +2538,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n   tree fromtype = TREE_TYPE (expr);\n   tree ctors = NULL_TREE, convs = NULL_TREE;\n   tree args = NULL_TREE;\n+  bool any_viable_p;\n \n   /* We represent conversion within a hierarchy using RVALUE_CONV and\n      BASE_CONV, as specified by [over.best.ics]; these become plain\n@@ -2602,12 +2654,11 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t}\n     }\n \n-  if (! any_viable (candidates))\n+  candidates = splice_viable (candidates, pedantic, &any_viable_p);\n+  if (!any_viable_p)\n     return 0;\n \n-  candidates = splice_viable (candidates);\n   cand = tourney (candidates);\n-\n   if (cand == 0)\n     {\n       if (flags & LOOKUP_COMPLAIN)\n@@ -2802,15 +2853,11 @@ perform_overload_resolution (tree fn,\n \t\t  LOOKUP_NORMAL,\n \t\t  candidates);\n \n-  if (! any_viable (*candidates))\n-    {\n-      *any_viable_p = false;\n-      return NULL;\n-    }\n+  *candidates = splice_viable (*candidates, pedantic, any_viable_p);\n+  if (!*any_viable_p)\n+    return NULL;\n \n-  *candidates = splice_viable (*candidates);\n   cand = tourney (*candidates);\n-\n   return cand;\n }\n \n@@ -2840,7 +2887,7 @@ build_new_function_call (tree fn, tree args)\n \t       DECL_NAME (OVL_CURRENT (fn)), args);\n       else\n \terror (\"call of overloaded `%D(%A)' is ambiguous\",\n-\t       DECL_NAME (OVL_FUNCTION (fn)), args);\n+\t       DECL_NAME (OVL_CURRENT (fn)), args);\n       if (candidates)\n \tprint_z_candidates (candidates);\n       return error_mark_node;\n@@ -2884,7 +2931,7 @@ build_operator_new_call (tree fnname, tree args, tree *size, tree *cookie_size)\n \t       DECL_NAME (OVL_CURRENT (fns)), args);\n       else\n \terror (\"call of overlopaded `%D(%A)' is ambiguous\",\n-\t       DECL_NAME (OVL_FUNCTION (fns)), args);\n+\t       DECL_NAME (OVL_CURRENT (fns)), args);\n       if (candidates)\n \tprint_z_candidates (candidates);\n       return error_mark_node;\n@@ -2943,6 +2990,7 @@ build_object_call (tree obj, tree args)\n   struct z_candidate *candidates = 0, *cand;\n   tree fns, convs, mem_args = NULL_TREE;\n   tree type = TREE_TYPE (obj);\n+  bool any_viable_p;\n \n   if (TYPE_PTRMEMFUNC_P (type))\n     {\n@@ -3011,16 +3059,15 @@ build_object_call (tree obj, tree args)\n \t  }\n     }\n \n-  if (! any_viable (candidates))\n+  candidates = splice_viable (candidates, pedantic, &any_viable_p);\n+  if (!any_viable_p)\n     {\n       error (\"no match for call to `(%T) (%A)'\", TREE_TYPE (obj), args);\n       print_z_candidates (candidates);\n       return error_mark_node;\n     }\n \n-  candidates = splice_viable (candidates);\n   cand = tourney (candidates);\n-\n   if (cand == 0)\n     {\n       error (\"call of `(%T) (%A)' is ambiguous\", TREE_TYPE (obj), args);\n@@ -3302,6 +3349,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n     {\n       tree args[3];\n       tree conv;\n+      bool any_viable_p;\n \n       /* Rearrange the arguments so that add_builtin_candidate only has\n \t to know about two args.  In build_builtin_candidates, the\n@@ -3320,13 +3368,13 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \n \t If the overload resolution fails, the program is\n \t ill-formed.  */\n-      if (!any_viable (candidates))\n+      candidates = splice_viable (candidates, pedantic, &any_viable_p);\n+      if (!any_viable_p)\n \t{\n \t  op_error (COND_EXPR, NOP_EXPR, arg1, arg2, arg3, \"no match\");\n \t  print_z_candidates (candidates);\n \t  return error_mark_node;\n \t}\n-      candidates = splice_viable (candidates);\n       cand = tourney (candidates);\n       if (!cand)\n \t{\n@@ -3565,7 +3613,8 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n   tree args[3];\n   enum tree_code code2 = NOP_EXPR;\n   tree conv;\n-  bool viable_candidates;\n+  bool strict_p;\n+  bool any_viable_p;\n \n   if (error_operand_p (arg1) \n       || error_operand_p (arg2) \n@@ -3675,15 +3724,16 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n \t operators.  The built-in candidate set for COMPONENT_REF\n \t would be empty too, but since there are no such built-in\n \t operators, we accept non-strict matches for them.  */\n-      viable_candidates = any_strictly_viable (candidates);\n+      strict_p = true;\n       break;\n \n     default:\n-      viable_candidates = any_viable (candidates);\n+      strict_p = pedantic;\n       break;\n     }      \n \n-  if (! viable_candidates)\n+  candidates = splice_viable (candidates, strict_p, &any_viable_p);\n+  if (!any_viable_p)\n     {\n       switch (code)\n \t{\n@@ -3717,9 +3767,8 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n \t}\n       return error_mark_node;\n     }\n-  candidates = splice_viable (candidates);\n-  cand = tourney (candidates);\n \n+  cand = tourney (candidates);\n   if (cand == 0)\n     {\n       if (flags & LOOKUP_COMPLAIN)\n@@ -4885,6 +4934,7 @@ build_new_method_call (tree instance, tree fns, tree args,\n   tree fn;\n   tree class_type;\n   int template_only = 0;\n+  bool any_viable_p;\n \n   my_friendly_assert (instance != NULL_TREE, 20020729);\n \n@@ -5001,7 +5051,8 @@ build_new_method_call (tree instance, tree fns, tree args,\n \t\t\t\tflags);\n     }\n \n-  if (! any_viable (candidates))\n+  candidates = splice_viable (candidates, pedantic, &any_viable_p);\n+  if (!any_viable_p)\n     {\n       /* XXX will LOOKUP_SPECULATIVELY be needed when this is done?  */\n       if (flags & LOOKUP_SPECULATIVELY)\n@@ -5023,9 +5074,8 @@ build_new_method_call (tree instance, tree fns, tree args,\n       print_z_candidates (candidates);\n       return error_mark_node;\n     }\n-  candidates = splice_viable (candidates);\n-  cand = tourney (candidates);\n \n+  cand = tourney (candidates);\n   if (cand == 0)\n     {\n       char *pretty_name;\n@@ -5555,19 +5605,6 @@ add_warning (struct z_candidate *winner, struct z_candidate *loser)\n \t\t\t\twinner->warnings);\n }\n \n-/* Returns true iff functions are equivalent. Equivalent functions are\n-   not '==' only if one is a function-local extern function or if\n-   both are extern \"C\".  */\n-\n-static inline int\n-equal_functions (tree fn1, tree fn2)\n-{\n-  if (DECL_LOCAL_FUNCTION_P (fn1) || DECL_LOCAL_FUNCTION_P (fn2)\n-      || DECL_EXTERN_C_FUNCTION_P (fn1))\n-    return decls_match (fn1, fn2);\n-  return fn1 == fn2;\n-}\n-\n /* Compare two candidates for overloading as described in\n    [over.match.best].  Return values:\n \n@@ -5748,7 +5785,6 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n          TREE_VEC_LENGTH (cand1->convs)\n \t - (DECL_NONSTATIC_MEMBER_FUNCTION_P (cand1->fn)\n \t    - DECL_CONSTRUCTOR_P (cand1->fn)));\n-      /* HERE */\n       if (winner)\n         return winner;\n     }\n@@ -5805,7 +5841,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n   if (DECL_P (cand1->fn) && DECL_P (cand2->fn)\n       && equal_functions (cand1->fn, cand2->fn))\n     return 1;\n-\n+ \n tweak:\n \n   /* Extension: If the worst conversion for one candidate is worse than the"}, {"sha": "db603bacb737292d371a0e07128e34ff9b71ca26", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d", "patch": "@@ -2657,14 +2657,8 @@ struct lang_decl GTY(())\n /* The format of each node in the DECL_FRIENDLIST is as follows:\n \n    The TREE_PURPOSE will be the name of a function, i.e., an\n-   IDENTIFIER_NODE.  The TREE_VALUE will be itself a TREE_LIST, the\n-   list of functions with that name which are friends.  The\n-   TREE_PURPOSE of each node in this sublist will be error_mark_node,\n-   if the function was declared a friend individually, in which case\n-   the TREE_VALUE will be the function_decl.  If, however, all\n-   functions with a given name in a class were declared to be friends,\n-   the TREE_PUROSE will be the class type, and the TREE_VALUE will be\n-   NULL_TREE.  */\n+   IDENTIFIER_NODE.  The TREE_VALUE will be itself a TREE_LIST, whose\n+   TREE_VALUEs are friends with the given name.  */\n #define DECL_FRIENDLIST(NODE)\t\t(DECL_INITIAL (NODE))\n #define FRIEND_NAME(LIST) (TREE_PURPOSE (LIST))\n #define FRIEND_DECLS(LIST) (TREE_VALUE (LIST))"}, {"sha": "c2f1f6c35597340b516165841b3c5be267c1ab72", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d", "patch": "@@ -3936,13 +3936,12 @@ arg_assoc_class (struct arg_lookup *k, tree type)\n   /* Process friends.  */\n   for (list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type)); list; \n        list = TREE_CHAIN (list))\n-    if (k->name == TREE_PURPOSE (list))\n-      for (friends = TREE_VALUE (list); friends; \n+    if (k->name == FRIEND_NAME (list))\n+      for (friends = FRIEND_DECLS (list); friends; \n \t   friends = TREE_CHAIN (friends))\n \t/* Only interested in global functions with potentially hidden\n            (i.e. unqualified) declarations.  */\n-\tif (TREE_PURPOSE (friends) == error_mark_node && TREE_VALUE (friends)\n-\t    && decl_namespace (TREE_VALUE (friends)) == context)\n+\tif (decl_namespace (TREE_VALUE (friends)) == context)\n \t  if (add_function (k, TREE_VALUE (friends)))\n \t    return true;\n "}, {"sha": "3ecd3177195a509a4f4a1140e1cb092a91c72520", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=436f8a4ce077dc372f70d1b57ab693c4aa0c6c6d", "patch": "@@ -165,7 +165,7 @@ add_friend (type, decl)\n \n \t  maybe_add_class_template_decl_list (type, decl, /*friend_p=*/1);\n \n-\t  TREE_VALUE (list) = tree_cons (error_mark_node, decl,\n+\t  TREE_VALUE (list) = tree_cons (NULL_TREE, decl,\n \t\t\t\t\t TREE_VALUE (list));\n \t  return;\n \t}\n@@ -175,7 +175,7 @@ add_friend (type, decl)\n   maybe_add_class_template_decl_list (type, decl, /*friend_p=*/1);\n \n   DECL_FRIENDLIST (typedecl)\n-    = tree_cons (DECL_NAME (decl), build_tree_list (error_mark_node, decl),\n+    = tree_cons (DECL_NAME (decl), build_tree_list (NULL_TREE, decl),\n \t\t DECL_FRIENDLIST (typedecl));\n   if (!uses_template_parms (type))\n     DECL_BEFRIENDING_CLASSES (decl) "}]}