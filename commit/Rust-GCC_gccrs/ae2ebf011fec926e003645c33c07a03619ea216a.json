{"sha": "ae2ebf011fec926e003645c33c07a03619ea216a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWUyZWJmMDExZmVjOTI2ZTAwMzY0NWMzM2MwN2EwMzYxOWVhMjE2YQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-06-17T13:19:02Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-06-17T13:19:02Z"}, "message": "c++: ICE with IMPLICIT_CONV_EXPR in array subscript [PR95508]\n\nSince r10-7096 convert_like, when called in a template, creates an\nIMPLICIT_CONV_EXPR when we're converting to/from array type.\n\nIn this test, we have e[f], and we're converting f (of type class A) to\nint, so convert_like in build_new_op_1 created the IMPLICIT_CONV_EXPR\nthat got into cp_build_array_ref which calls maybe_constant_value.  My\npatch above failed to adjust this spot to call fold_non_dependent_expr\ninstead, which can handle codes like I_C_E in a template.  Fixed by\nusing a new function maybe_fold_non_dependent_expr, which, if the expr\ncan't be evaluated to a constant, returns the original expression.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/95508\n\t* constexpr.c (maybe_fold_non_dependent_expr): New.\n\t* cp-tree.h (maybe_fold_non_dependent_expr): Declare.\n\t* typeck.c (cp_build_array_ref): Call maybe_fold_non_dependent_expr\n\tinstead of maybe_constant_value.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/95508\n\t* g++.dg/template/conv16.C: New test.", "tree": {"sha": "22786700ccebc85f8db4afd3fe82fefb9be4f656", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22786700ccebc85f8db4afd3fe82fefb9be4f656"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae2ebf011fec926e003645c33c07a03619ea216a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae2ebf011fec926e003645c33c07a03619ea216a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae2ebf011fec926e003645c33c07a03619ea216a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae2ebf011fec926e003645c33c07a03619ea216a/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d2b0866d760f822c137b69f14d1c51fc760ce53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d2b0866d760f822c137b69f14d1c51fc760ce53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d2b0866d760f822c137b69f14d1c51fc760ce53"}], "stats": {"total": 34, "additions": 33, "deletions": 1}, "files": [{"sha": "f766abd3a11d4e534007a5afe34c6adc6f783a62", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2ebf011fec926e003645c33c07a03619ea216a/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2ebf011fec926e003645c33c07a03619ea216a/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=ae2ebf011fec926e003645c33c07a03619ea216a", "patch": "@@ -7093,6 +7093,19 @@ fold_non_dependent_expr (tree t,\n   return maybe_constant_value (t, object, manifestly_const_eval);\n }\n \n+/* Like fold_non_dependent_expr, but if EXPR couldn't be folded to a constant,\n+   return the original expression.  */\n+\n+tree\n+maybe_fold_non_dependent_expr (tree expr,\n+\t\t\t       tsubst_flags_t complain/*=tf_warning_or_error*/)\n+{\n+  tree t = fold_non_dependent_expr (expr, complain);\n+  if (t && TREE_CONSTANT (t))\n+    return t;\n+\n+  return expr;\n+}\n \n /* Like maybe_constant_init but first fully instantiate the argument.  */\n "}, {"sha": "ee276107928ebd1cf4f26d566f3e1058baa068b1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2ebf011fec926e003645c33c07a03619ea216a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2ebf011fec926e003645c33c07a03619ea216a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ae2ebf011fec926e003645c33c07a03619ea216a", "patch": "@@ -7933,6 +7933,8 @@ extern tree maybe_constant_init\t\t\t(tree, tree = NULL_TREE, bool = false);\n extern tree fold_non_dependent_expr\t\t(tree,\n \t\t\t\t\t\t tsubst_flags_t = tf_warning_or_error,\n \t\t\t\t\t\t bool = false, tree = NULL_TREE);\n+extern tree maybe_fold_non_dependent_expr\t(tree,\n+\t\t\t\t\t\t tsubst_flags_t = tf_warning_or_error);\n extern tree fold_non_dependent_init\t\t(tree,\n \t\t\t\t\t\t tsubst_flags_t = tf_warning_or_error,\n \t\t\t\t\t\t bool = false);"}, {"sha": "7e84f11579b47386e7e825ede3165221681fc81d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2ebf011fec926e003645c33c07a03619ea216a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2ebf011fec926e003645c33c07a03619ea216a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ae2ebf011fec926e003645c33c07a03619ea216a", "patch": "@@ -3565,7 +3565,7 @@ cp_build_array_ref (location_t loc, tree array, tree idx,\n \t pointer arithmetic.)  */\n       idx = cp_perform_integral_promotions (idx, complain);\n \n-      idx = maybe_constant_value (idx);\n+      idx = maybe_fold_non_dependent_expr (idx, complain);\n \n       /* An array that is indexed by a non-constant\n \t cannot be stored in a register; we must be able to do"}, {"sha": "c0843efdf9d0cbaec119b672d41006dbc503878b", "filename": "gcc/testsuite/g++.dg/template/conv16.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2ebf011fec926e003645c33c07a03619ea216a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2ebf011fec926e003645c33c07a03619ea216a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv16.C?ref=ae2ebf011fec926e003645c33c07a03619ea216a", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/95508\n+// { dg-do compile }\n+\n+template <typename>\n+struct A;\n+template <typename>\n+struct B {\n+  operator int () { return 0; }\n+};\n+template <>\n+struct A<unsigned> : B<int> {};\n+struct D {\n+  template <typename>\n+  int foo () { return e[f]; }\n+  int e[6];\n+  A<unsigned> f;\n+};"}]}