{"sha": "1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE2M2YwNTg3NjFiOWQ0YjkzZDBhZGE1Y2RiNWE2YmQzY2IyNjY1Yw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-10-13T06:59:13Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-10-13T06:59:13Z"}, "message": "re PR tree-optimization/82525 ([GRAPHITE] codegen error for modulo operations we cannot represent)\n\n2017-10-13  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/82525\n\t* graphite-isl-ast-to-gimple.c\n\t(translate_isl_ast_to_gimple::widest_int_from_isl_expr_int): Split\n\tout from ...\n\t(translate_isl_ast_to_gimple::gcc_expression_from_isl_expr_int): Here.\n\tFail code generation when we cannot represent the isl integer.\n\t(binary_op_to_tree): Elide modulo operations that are no-ops\n\tin the type we code generate.  Remove now superfluous code\n\tgeneration errors.\n\n\t* gcc.dg/graphite/id-30.c: New testcase.\n\t* gfortran.dg/graphite/id-28.f90: Likewise.\n\nFrom-SVN: r253706", "tree": {"sha": "581e7ac190de1cea496c0d90c21b1324a5770339", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/581e7ac190de1cea496c0d90c21b1324a5770339"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cae827b1a1a2f02d08fa0602e1cdaf991a8248ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cae827b1a1a2f02d08fa0602e1cdaf991a8248ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cae827b1a1a2f02d08fa0602e1cdaf991a8248ea"}], "stats": {"total": 138, "additions": 94, "deletions": 44}, "files": [{"sha": "890ee0e5d0e848c6ab4392c11977f1947939fa2b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c", "patch": "@@ -1,3 +1,15 @@\n+2017-10-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/82525\n+\t* graphite-isl-ast-to-gimple.c\n+\t(translate_isl_ast_to_gimple::widest_int_from_isl_expr_int): Split\n+\tout from ...\n+\t(translate_isl_ast_to_gimple::gcc_expression_from_isl_expr_int): Here.\n+\tFail code generation when we cannot represent the isl integer.\n+\t(binary_op_to_tree): Elide modulo operations that are no-ops\n+\tin the type we code generate.  Remove now superfluous code\n+\tgeneration errors.\n+\n 2017-10-13  Richard Biener  <rguenther@suse.de>\n \n \t* graphite-scop-detection.c (loop_ivs_can_be_represented): Remove."}, {"sha": "9a9f8c86726f951ec7d036309f95b4a15f43ae46", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c", "patch": "@@ -177,6 +177,7 @@ class translate_isl_ast_to_gimple\n   tree gcc_expression_from_isl_ast_expr_id (tree type,\n \t\t\t\t\t    __isl_keep isl_ast_expr *expr_id,\n \t\t\t\t\t    ivs_params &ip);\n+  widest_int widest_int_from_isl_expr_int (__isl_keep isl_ast_expr *expr);\n   tree gcc_expression_from_isl_expr_int (tree type,\n \t\t\t\t\t __isl_take isl_ast_expr *expr);\n   tree gcc_expression_from_isl_expr_op (tree type,\n@@ -265,29 +266,46 @@ gcc_expression_from_isl_ast_expr_id (tree type,\n   return fold_convert (type, *val);\n }\n \n-/* Converts an isl_ast_expr_int expression E to a GCC expression tree of\n-   type TYPE.  */\n+/* Converts an isl_ast_expr_int expression E to a widest_int.\n+   Raises a code generation error when the constant doesn't fit.  */\n \n-tree translate_isl_ast_to_gimple::\n-gcc_expression_from_isl_expr_int (tree type, __isl_take isl_ast_expr *expr)\n+widest_int translate_isl_ast_to_gimple::\n+widest_int_from_isl_expr_int (__isl_keep isl_ast_expr *expr)\n {\n   gcc_assert (isl_ast_expr_get_type (expr) == isl_ast_expr_int);\n   isl_val *val = isl_ast_expr_get_val (expr);\n   size_t n = isl_val_n_abs_num_chunks (val, sizeof (HOST_WIDE_INT));\n   HOST_WIDE_INT *chunks = XALLOCAVEC (HOST_WIDE_INT, n);\n-  tree res;\n-  if (isl_val_get_abs_num_chunks (val, sizeof (HOST_WIDE_INT), chunks) == -1)\n-    res = NULL_TREE;\n-  else\n+  if (n > WIDE_INT_MAX_ELTS\n+      || isl_val_get_abs_num_chunks (val, sizeof (HOST_WIDE_INT), chunks) == -1)\n     {\n-      widest_int wi = widest_int::from_array (chunks, n, true);\n-      if (isl_val_is_neg (val))\n-\twi = -wi;\n-      res = wide_int_to_tree (type, wi);\n+      isl_val_free (val);\n+      set_codegen_error ();\n+      return 0;\n     }\n+  widest_int wi = widest_int::from_array (chunks, n, true);\n+  if (isl_val_is_neg (val))\n+    wi = -wi;\n   isl_val_free (val);\n+  return wi;\n+}\n+\n+/* Converts an isl_ast_expr_int expression E to a GCC expression tree of\n+   type TYPE.  Raises a code generation error when the constant doesn't fit.  */\n+\n+tree translate_isl_ast_to_gimple::\n+gcc_expression_from_isl_expr_int (tree type, __isl_take isl_ast_expr *expr)\n+{\n+  widest_int wi = widest_int_from_isl_expr_int (expr);\n   isl_ast_expr_free (expr);\n-  return res;\n+  if (codegen_error_p ())\n+    return NULL_TREE;\n+  if (wi::min_precision (wi, TYPE_SIGN (type)) > TYPE_PRECISION (type))\n+    {\n+      set_codegen_error ();\n+      return NULL_TREE;\n+    }\n+  return wide_int_to_tree (type, wi);\n }\n \n /* Converts a binary isl_ast_expr_op expression E to a GCC expression tree of\n@@ -296,14 +314,25 @@ gcc_expression_from_isl_expr_int (tree type, __isl_take isl_ast_expr *expr)\n tree translate_isl_ast_to_gimple::\n binary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n {\n+  enum isl_ast_op_type expr_type = isl_ast_expr_get_op_type (expr);\n   isl_ast_expr *arg_expr = isl_ast_expr_get_op_arg (expr, 0);\n   tree tree_lhs_expr = gcc_expression_from_isl_expression (type, arg_expr, ip);\n   arg_expr = isl_ast_expr_get_op_arg (expr, 1);\n-  tree tree_rhs_expr = gcc_expression_from_isl_expression (type, arg_expr, ip);\n-\n-  enum isl_ast_op_type expr_type = isl_ast_expr_get_op_type (expr);\n   isl_ast_expr_free (expr);\n \n+  /* From our constraint generation we may get modulo operations that\n+     we cannot represent explicitely but that are no-ops for TYPE.\n+     Elide those.  */\n+  if (expr_type == isl_ast_op_pdiv_r\n+      && isl_ast_expr_get_type (arg_expr) == isl_ast_expr_int\n+      && (wi::exact_log2 (widest_int_from_isl_expr_int (arg_expr))\n+\t  >= TYPE_PRECISION (type)))\n+    {\n+      isl_ast_expr_free (arg_expr);\n+      return tree_lhs_expr;\n+    }\n+\n+  tree tree_rhs_expr = gcc_expression_from_isl_expression (type, arg_expr, ip);\n   if (codegen_error_p ())\n     return NULL_TREE;\n \n@@ -319,44 +348,16 @@ binary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n       return fold_build2 (MULT_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n \n     case isl_ast_op_div:\n-      /* As isl operates on arbitrary precision numbers, we may end up with\n-\t division by 2^64 that is folded to 0.  */\n-      if (integer_zerop (tree_rhs_expr))\n-\t{\n-\t  set_codegen_error ();\n-\t  return NULL_TREE;\n-\t}\n       return fold_build2 (EXACT_DIV_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n \n     case isl_ast_op_pdiv_q:\n-      /* As isl operates on arbitrary precision numbers, we may end up with\n-\t division by 2^64 that is folded to 0.  */\n-      if (integer_zerop (tree_rhs_expr))\n-\t{\n-\t  set_codegen_error ();\n-\t  return NULL_TREE;\n-\t}\n       return fold_build2 (TRUNC_DIV_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n \n     case isl_ast_op_zdiv_r:\n     case isl_ast_op_pdiv_r:\n-      /* As isl operates on arbitrary precision numbers, we may end up with\n-\t division by 2^64 that is folded to 0.  */\n-      if (integer_zerop (tree_rhs_expr))\n-\t{\n-\t  set_codegen_error ();\n-\t  return NULL_TREE;\n-\t}\n       return fold_build2 (TRUNC_MOD_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n \n     case isl_ast_op_fdiv_q:\n-      /* As isl operates on arbitrary precision numbers, we may end up with\n-\t division by 2^64 that is folded to 0.  */\n-      if (integer_zerop (tree_rhs_expr))\n-\t{\n-\t  set_codegen_error ();\n-\t  return NULL_TREE;\n-\t}\n       return fold_build2 (FLOOR_DIV_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n \n     case isl_ast_op_and:"}, {"sha": "874ede28bd333d04d462baf07567e0dcd2092f6c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c", "patch": "@@ -1,3 +1,9 @@\n+2017-10-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/82525\n+\t* gcc.dg/graphite/id-30.c: New testcase.\n+\t* gfortran.dg/graphite/id-28.f90: Likewise.\n+\n 2017-10-13  Alan Modra  <amodra@gmail.com>\n \n \t* gcc.target/i386/asm-mem.c: New test."}, {"sha": "f8144cec4f28a36c58c1cd3004146732174be7f3", "filename": "gcc/testsuite/gcc.dg/graphite/id-30.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fid-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fid-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fid-30.c?ref=1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c", "patch": "@@ -0,0 +1,16 @@\n+/* The modulo constraints we generate for the niter expression\n+     (unsinged long)ubound - (unsigned long)lbound\n+   end up with a modulo that we cannot represent in the expression\n+   type we are using (int64_t), so we run into the codegen error\n+   where ISL generates a modulo/divide by sth that doesn't fit the\n+   type we code-generate with.  Verify we properly elide those.  */\n+\n+void foo (double *a, long int lbound0, long int ubound0,\n+\t  long int lbound1, long int ubound1, long int stride1)\n+{\n+  if (lbound0 < ubound0)\n+    for (long int i = lbound0; i <= ubound0; ++i)\n+      if (lbound1 < ubound1)\n+\tfor (long int j = lbound1; j <= ubound1; ++j)\n+\t  a[i*stride1 + j] = 0.;\n+}"}, {"sha": "d66cb12006e79cd36eff9ee2a657d9fe8f888adf", "filename": "gcc/testsuite/gfortran.dg/graphite/id-28.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-28.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-28.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-28.f90?ref=1163f058761b9d4b93d0ada5cdb5a6bd3cb2665c", "patch": "@@ -0,0 +1,15 @@\n+! Verify we elide modulo operations we cannot represent\n+module OPMATRIX_MODULE\n+   implicit none\n+   type opmatrix_type\n+   real(kind=kind(1.0d0)), dimension(:,:), pointer :: restricted\n+   end type\n+   interface zero_\n+      module procedure zero\n+   end interface\n+contains\n+   subroutine zero(self)\n+      type(opmatrix_type) :: self\n+      self%restricted = 0.0d0\n+   end subroutine\n+end"}]}