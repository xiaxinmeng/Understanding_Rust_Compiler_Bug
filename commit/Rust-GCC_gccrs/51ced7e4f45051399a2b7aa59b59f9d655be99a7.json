{"sha": "51ced7e4f45051399a2b7aa59b59f9d655be99a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFjZWQ3ZTRmNDUwNTEzOTlhMmI3YWE1OWI1OWY5ZDY1NWJlOTlhNw==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-10-14T09:10:45Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-10-14T09:10:45Z"}, "message": "target-insns.def: Add memory_blockage.\n\n\t* target-insns.def: Add memory_blockage.\n\t* optabs.c (expand_memory_blockage): New function.\n\t(expand_asm_memory_barrier): Rename ...\n\t(expand_asm_memory_blockage): ... to this.\n\t(expand_mem_thread_fence): Call expand_memory_blockage\n\tinstead of expand_asm_memory_barrier.\n\t(expand_mem_singnal_fence): Ditto.\n\t(expand_atomic_load): Ditto.\n\t(expand_atomic_store): Ditto.\n\t* doc/md.texi (Standard Pattern Names For Generation):\n\tDocument memory_blockage instruction pattern.\n\nFrom-SVN: r253750", "tree": {"sha": "85897537203413654d7240dc2f45cfdf6836419b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85897537203413654d7240dc2f45cfdf6836419b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51ced7e4f45051399a2b7aa59b59f9d655be99a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51ced7e4f45051399a2b7aa59b59f9d655be99a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51ced7e4f45051399a2b7aa59b59f9d655be99a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51ced7e4f45051399a2b7aa59b59f9d655be99a7/comments", "author": null, "committer": null, "parents": [{"sha": "5c20e429775e6b72b42a3c7b3c3be77f535d4bb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c20e429775e6b72b42a3c7b3c3be77f535d4bb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c20e429775e6b72b42a3c7b3c3be77f535d4bb6"}], "stats": {"total": 59, "additions": 46, "deletions": 13}, "files": [{"sha": "53edcc367e7a1dddd0ca0bdb8a2fa86437717a78", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ced7e4f45051399a2b7aa59b59f9d655be99a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ced7e4f45051399a2b7aa59b59f9d655be99a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51ced7e4f45051399a2b7aa59b59f9d655be99a7", "patch": "@@ -1,3 +1,17 @@\n+2017-10-14  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* target-insns.def: Add memory_blockage.\n+\t* optabs.c (expand_memory_blockage): New function.\n+\t(expand_asm_memory_barrier): Rename ...\n+\t(expand_asm_memory_blockage): ... to this.\n+\t(expand_mem_thread_fence): Call expand_memory_blockage\n+\tinstead of expand_asm_memory_barrier.\n+\t(expand_mem_singnal_fence): Ditto.\n+\t(expand_atomic_load): Ditto.\n+\t(expand_atomic_store): Ditto.\n+\t* doc/md.texi (Standard Pattern Names For Generation):\n+\tDocument memory_blockage instruction pattern.\n+\n 2017-10-13  Sebastian Perta  <sebastian.perta@renesas.com>\n \n \t* config/rl78/rl78.c (rl78_emit_libcall): New function.\n@@ -27,8 +41,7 @@\n \n 2017-10-13  Jan Hubicka  <hubicka@ucw.cz>\n \n-\t* cfghooks.c (verify_flow_info): Check that edge probabilities are\n-\tset.\n+\t* cfghooks.c (verify_flow_info): Check that edge probabilities are set.\n \n 2017-10-13  Nathan Sidwell  <nathan@acm.org>\n \n@@ -63,8 +76,7 @@\n \tgraphite_expression_type_precision): Avoid global constructor\n \tby moving ...\n \t(translate_isl_ast_to_gimple::translate_isl_ast_to_gimple): Here.\n-\t(translate_isl_ast_to_gimple::graphite_expr_type): Add type\n-\tmember.\n+\t(translate_isl_ast_to_gimple::graphite_expr_type): Add type member.\n \t(translate_isl_ast_to_gimple::translate_isl_ast_node_for): Use it.\n \t(translate_isl_ast_to_gimple::build_iv_mapping): Likewise.\n \t(translate_isl_ast_to_gimple::graphite_create_new_guard): Likewise."}, {"sha": "c4c113850fe1f04cce1caa4bb07f610d123eb59a", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ced7e4f45051399a2b7aa59b59f9d655be99a7/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ced7e4f45051399a2b7aa59b59f9d655be99a7/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=51ced7e4f45051399a2b7aa59b59f9d655be99a7", "patch": "@@ -6734,6 +6734,15 @@ scheduler and other passes from moving instructions and using register\n equivalences across the boundary defined by the blockage insn.\n This needs to be an UNSPEC_VOLATILE pattern or a volatile ASM.\n \n+@cindex @code{memory_blockage} instruction pattern\n+@item @samp{memory_blockage}\n+This pattern, if defined, represents a compiler memory barrier, and will be\n+placed at points across which RTL passes may not propagate memory accesses.\n+This instruction needs to read and write volatile BLKmode memory.  It does\n+not need to generate any machine instruction.  If this pattern is not defined,\n+the compiler falls back to emitting an instruction corresponding\n+to @code{asm volatile (\"\" ::: \"memory\")}.\n+\n @cindex @code{memory_barrier} instruction pattern\n @item @samp{memory_barrier}\n If the target memory model is not fully synchronous, then this pattern"}, {"sha": "46df49abb1041c8200d9c386e917f46b9c1c6975", "filename": "gcc/optabs.c", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ced7e4f45051399a2b7aa59b59f9d655be99a7/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ced7e4f45051399a2b7aa59b59f9d655be99a7/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=51ced7e4f45051399a2b7aa59b59f9d655be99a7", "patch": "@@ -6273,10 +6273,10 @@ expand_atomic_compare_and_swap (rtx *ptarget_bool, rtx *ptarget_oval,\n   return true;\n }\n \n-/* Generate asm volatile(\"\" : : : \"memory\") as the memory barrier.  */\n+/* Generate asm volatile(\"\" : : : \"memory\") as the memory blockage.  */\n \n static void\n-expand_asm_memory_barrier (void)\n+expand_asm_memory_blockage (void)\n {\n   rtx asm_op, clob;\n \n@@ -6292,6 +6292,17 @@ expand_asm_memory_barrier (void)\n   emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, asm_op, clob)));\n }\n \n+/* Do not propagate memory accesses across this point.  */\n+\n+static void\n+expand_memory_blockage (void)\n+{\n+  if (targetm.have_memory_blockage)\n+    emit_insn (gen_memory_blockage ());\n+  else\n+    expand_asm_memory_blockage ();\n+}\n+\n /* This routine will either emit the mem_thread_fence pattern or issue a \n    sync_synchronize to generate a fence for memory model MEMMODEL.  */\n \n@@ -6303,14 +6314,14 @@ expand_mem_thread_fence (enum memmodel model)\n   if (targetm.have_mem_thread_fence ())\n     {\n       emit_insn (targetm.gen_mem_thread_fence (GEN_INT (model)));\n-      expand_asm_memory_barrier ();\n+      expand_memory_blockage ();\n     }\n   else if (targetm.have_memory_barrier ())\n     emit_insn (targetm.gen_memory_barrier ());\n   else if (synchronize_libfunc != NULL_RTX)\n     emit_library_call (synchronize_libfunc, LCT_NORMAL, VOIDmode);\n   else\n-    expand_asm_memory_barrier ();\n+    expand_memory_blockage ();\n }\n \n /* Emit a signal fence with given memory model.  */\n@@ -6321,7 +6332,7 @@ expand_mem_signal_fence (enum memmodel model)\n   /* No machine barrier is required to implement a signal fence, but\n      a compiler memory barrier must be issued, except for relaxed MM.  */\n   if (!is_mm_relaxed (model))\n-    expand_asm_memory_barrier ();\n+    expand_memory_blockage ();\n }\n \n /* This function expands the atomic load operation:\n@@ -6343,15 +6354,15 @@ expand_atomic_load (rtx target, rtx mem, enum memmodel model)\n       struct expand_operand ops[3];\n       rtx_insn *last = get_last_insn ();\n       if (is_mm_seq_cst (model))\n-\texpand_asm_memory_barrier ();\n+\texpand_memory_blockage ();\n \n       create_output_operand (&ops[0], target, mode);\n       create_fixed_operand (&ops[1], mem);\n       create_integer_operand (&ops[2], model);\n       if (maybe_expand_insn (icode, 3, ops))\n \t{\n \t  if (!is_mm_relaxed (model))\n-\t    expand_asm_memory_barrier ();\n+\t    expand_memory_blockage ();\n \t  return ops[0].value;\n \t}\n       delete_insns_since (last);\n@@ -6401,14 +6412,14 @@ expand_atomic_store (rtx mem, rtx val, enum memmodel model, bool use_release)\n     {\n       rtx_insn *last = get_last_insn ();\n       if (!is_mm_relaxed (model))\n-\texpand_asm_memory_barrier ();\n+\texpand_memory_blockage ();\n       create_fixed_operand (&ops[0], mem);\n       create_input_operand (&ops[1], val, mode);\n       create_integer_operand (&ops[2], model);\n       if (maybe_expand_insn (icode, 3, ops))\n \t{\n \t  if (is_mm_seq_cst (model))\n-\t    expand_asm_memory_barrier ();\n+\t    expand_memory_blockage ();\n \t  return const0_rtx;\n \t}\n       delete_insns_since (last);"}, {"sha": "75976b2f8d99bb8ea72fa6c6109fe3b53f58562e", "filename": "gcc/target-insns.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ced7e4f45051399a2b7aa59b59f9d655be99a7/gcc%2Ftarget-insns.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ced7e4f45051399a2b7aa59b59f9d655be99a7/gcc%2Ftarget-insns.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-insns.def?ref=51ced7e4f45051399a2b7aa59b59f9d655be99a7", "patch": "@@ -60,6 +60,7 @@ DEF_TARGET_INSN (jump, (rtx x0))\n DEF_TARGET_INSN (load_multiple, (rtx x0, rtx x1, rtx x2))\n DEF_TARGET_INSN (mem_thread_fence, (rtx x0))\n DEF_TARGET_INSN (memory_barrier, (void))\n+DEF_TARGET_INSN (memory_blockage, (void))\n DEF_TARGET_INSN (movstr, (rtx x0, rtx x1, rtx x2))\n DEF_TARGET_INSN (nonlocal_goto, (rtx x0, rtx x1, rtx x2, rtx x3))\n DEF_TARGET_INSN (nonlocal_goto_receiver, (void))"}]}