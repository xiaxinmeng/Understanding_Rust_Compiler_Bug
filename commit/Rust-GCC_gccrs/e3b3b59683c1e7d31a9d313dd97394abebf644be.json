{"sha": "e3b3b59683c1e7d31a9d313dd97394abebf644be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNiM2I1OTY4M2MxZTdkMzFhOWQzMTNkZDk3Mzk0YWJlYmY2NDRiZQ==", "commit": {"author": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2020-11-13T17:45:59Z"}, "committer": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2020-11-13T18:01:51Z"}, "message": "[PATCH] Implementation of asm goto outputs\n\ngcc/\n\t* cfgexpand.c (expand_asm_stmt): Output asm goto with outputs too.\n\tPlace insns after asm goto on edges.\n\t* doc/extend.texi: Reflect the changes in asm goto documentation.\n\t* gimple.c (gimple_build_asm_1): Remove an assert checking output\n\tabsence for asm goto.\n\t* gimple.h (gimple_asm_label_op, gimple_asm_set_label_op): Take\n\tpossible asm goto outputs into account.\n\t* ira.c (ira): Remove critical edges for potential asm goto output\n\treloads.\n\t(ira_nullify_asm_goto): New function.\n\t* ira.h (ira_nullify_asm_goto): New prototype.\n\t* lra-assigns.c (lra_split_hard_reg_for): Use ira_nullify_asm_goto.\n\tCheck that splitting is done inside a basic block.\n\t* lra-constraints.c (curr_insn_transform): Permit output reloads\n\tfor any jump insn.\n\t* lra-spills.c (lra_final_code_change): Remove USEs added in ira\n\tfor asm gotos.\n\t* lra.c (lra_process_new_insns): Place output reload insns after\n\tjumps in the beginning of destination BBs.\n\t* reload.c (find_reloads): Report error for asm gotos with\n\toutputs.  Modify them to keep CFG consistency to avoid crashes.\n\t* tree-into-ssa.c (rewrite_stmt): Don't put debug stmt after asm\n\tgoto.\n\ngcc/c/\n\t* c-parser.c (c_parser_asm_statement): Parse outputs for asm\n\tgoto too.\n\t* c-typeck.c (build_asm_expr): Remove an assert checking output\n\tabsence for asm goto.\n\ngcc/cp\n\t* parser.c (cp_parser_asm_definition): Parse outputs for asm\n\tgoto too.\n\ngcc/testsuite/\n\t* c-c++-common/asmgoto-2.c: Permit output in asm goto.\n\t* gcc.c-torture/compile/asmgoto-2.c: New.\n\t* gcc.c-torture/compile/asmgoto-3.c: New.\n\t* gcc.c-torture/compile/asmgoto-4.c: New.\n\t* gcc.c-torture/compile/asmgoto-5.c: New.", "tree": {"sha": "34a176a8e704a5a27a214f391da1c5ca041a2462", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34a176a8e704a5a27a214f391da1c5ca041a2462"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3b3b59683c1e7d31a9d313dd97394abebf644be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3b3b59683c1e7d31a9d313dd97394abebf644be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3b3b59683c1e7d31a9d313dd97394abebf644be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3b3b59683c1e7d31a9d313dd97394abebf644be/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67100cb50ea22e1fc855360b887959f874fafe2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67100cb50ea22e1fc855360b887959f874fafe2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67100cb50ea22e1fc855360b887959f874fafe2c"}], "stats": {"total": 514, "additions": 455, "deletions": 59}, "files": [{"sha": "7540a15d65d6f7eb82e11e3188da212de7bf08d8", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -7144,10 +7144,7 @@ c_parser_asm_statement (c_parser *parser)\n \tswitch (section)\n \t  {\n \t  case 0:\n-\t    /* For asm goto, we don't allow output operands, but reserve\n-\t       the slot for a future extension that does allow them.  */\n-\t    if (!is_goto)\n-\t      outputs = c_parser_asm_operands (parser);\n+\t    outputs = c_parser_asm_operands (parser);\n \t    break;\n \t  case 1:\n \t    inputs = c_parser_asm_operands (parser);"}, {"sha": "413109c916c3554a4e86440d108e6ad1c4dd4116", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -10666,10 +10666,6 @@ build_asm_expr (location_t loc, tree string, tree outputs, tree inputs,\n       TREE_VALUE (tail) = input;\n     }\n \n-  /* ASMs with labels cannot have outputs.  This should have been\n-     enforced by the parser.  */\n-  gcc_assert (outputs == NULL || labels == NULL);\n-\n   args = build_stmt (loc, ASM_EXPR, string, outputs, inputs, clobbers, labels);\n \n   /* asm statements without outputs, including simple ones, are treated"}, {"sha": "1df6f4bc55a39230c98e58af6c2d765652db8324", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -3371,20 +3371,21 @@ expand_asm_stmt (gasm *stmt)\n \t\t\t       ARGVEC CONSTRAINTS OPNAMES))\n      If there is more than one, put them inside a PARALLEL.  */\n \n-  if (nlabels > 0 && nclobbers == 0)\n-    {\n-      gcc_assert (noutputs == 0);\n-      emit_jump_insn (body);\n-    }\n-  else if (noutputs == 0 && nclobbers == 0)\n+  if (noutputs == 0 && nclobbers == 0)\n     {\n       /* No output operands: put in a raw ASM_OPERANDS rtx.  */\n-      emit_insn (body);\n+      if (nlabels > 0)\n+\temit_jump_insn (body);\n+      else\n+\temit_insn (body);\n     }\n   else if (noutputs == 1 && nclobbers == 0)\n     {\n       ASM_OPERANDS_OUTPUT_CONSTRAINT (body) = constraints[0];\n-      emit_insn (gen_rtx_SET (output_rvec[0], body));\n+      if (nlabels > 0)\n+\temit_jump_insn (gen_rtx_SET (output_rvec[0], body));\n+      else \n+\temit_insn (gen_rtx_SET (output_rvec[0], body));\n     }\n   else\n     {\n@@ -3461,7 +3462,27 @@ expand_asm_stmt (gasm *stmt)\n   if (after_md_seq)\n     emit_insn (after_md_seq);\n   if (after_rtl_seq)\n-    emit_insn (after_rtl_seq);\n+    {\n+      if (nlabels == 0)\n+\temit_insn (after_rtl_seq);\n+      else\n+\t{\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  \n+\t  FOR_EACH_EDGE (e, ei, gimple_bb (stmt)->succs)\n+\t    {\n+\t      start_sequence ();\n+\t      for (rtx_insn *curr = after_rtl_seq;\n+\t\t   curr != NULL_RTX;\n+\t\t   curr = NEXT_INSN (curr))\n+\t\temit_insn (copy_insn (PATTERN (curr)));\n+\t      rtx_insn *copy = get_insns ();\n+\t      end_sequence ();\n+\t      insert_insn_on_edge (copy, e);\n+\t    }\n+\t}\n+    }\n \n   free_temp_slots ();\n   crtl->has_asm_statement = 1;"}, {"sha": "68f1cfa23f2306034b4269b21d6e3719cf5b5310", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -20534,8 +20534,7 @@ cp_parser_asm_definition (cp_parser* parser)\n \t      && cp_lexer_next_token_is_not (parser->lexer,\n \t\t\t\t\t     CPP_SCOPE)\n \t      && cp_lexer_next_token_is_not (parser->lexer,\n-\t\t\t\t\t     CPP_CLOSE_PAREN)\n-\t      && !goto_p)\n+\t\t\t\t\t     CPP_CLOSE_PAREN))\n             {\n               outputs = cp_parser_asm_operand_list (parser);\n               if (outputs == error_mark_node)"}, {"sha": "af25f66c8b4285a2dff4397b90135d4d10d7964b", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -9566,7 +9566,7 @@ asm @var{asm-qualifiers} ( @var{AssemblerTemplate}\n                  @r{[} : @var{Clobbers} @r{]} @r{]})\n \n asm @var{asm-qualifiers} ( @var{AssemblerTemplate} \n-                      : \n+                      : @var{OutputOperands}\n                       : @var{InputOperands}\n                       : @var{Clobbers}\n                       : @var{GotoLabels})\n@@ -9673,7 +9673,7 @@ there is no need for the output variables. Also, the optimizers may move\n code out of loops if they believe that the code will always return the same \n result (i.e.@: none of its input values change between calls). Using the \n @code{volatile} qualifier disables these optimizations. @code{asm} statements \n-that have no output operands, including @code{asm goto} statements, \n+that have no output operands and @code{asm goto} statements, \n are implicitly volatile.\n \n This i386 code demonstrates a case that does not use (or require) the \n@@ -10532,9 +10532,6 @@ case, consider using the @code{__builtin_unreachable} intrinsic after the\n using the @code{hot} and @code{cold} label attributes (@pxref{Label \n Attributes}).\n \n-An @code{asm goto} statement cannot have outputs.\n-This is due to an internal restriction of \n-the compiler: control transfer instructions cannot have outputs. \n If the assembler code does modify anything, use the @code{\"memory\"} clobber \n to force the \n optimizers to flush all register values to memory and reload them if \n@@ -10543,6 +10540,13 @@ necessary after the @code{asm} statement.\n Also note that an @code{asm goto} statement is always implicitly\n considered volatile.\n \n+Be careful when you set output operands inside @code{asm goto} only on\n+some possible control flow paths.  If you don't set up the output on\n+given path and never use it on this path, it is okay.  Otherwise, you\n+should use @samp{+} constraint modifier meaning that the operand is\n+input and output one.  With this modifier you will have the correct\n+values on all possible paths from the @code{asm goto}.\n+\n To reference a label in the assembler template,\n prefix it with @samp{%l} (lowercase @samp{L}) followed \n by its (zero-based) position in @var{GotoLabels} plus the number of input \n@@ -10588,6 +10592,41 @@ error:\n @}\n @end example\n \n+The following example shows an @code{asm goto} that uses an output.\n+\n+@example\n+int foo(int count)\n+@{\n+  asm goto (\"dec %0; jb %l[stop]\"\n+            : \"+r\" (count)\n+            :\n+            :\n+            : stop);\n+  return count;\n+stop:\n+  return 0;\n+@}\n+@end example\n+\n+The following artificial example shows an @code{asm goto} that sets\n+up an output only on one path inside the @code{asm goto}.  Usage of\n+constraint modifier @code{=} instead of @code{+} would be wrong as\n+@code{factor} is used on all paths from the @code{asm goto}.\n+\n+@example\n+int foo(int inp)\n+@{\n+  int factor = 0;\n+  asm goto (\"cmp %1, 10; jb %l[lab]; mov 2, %0\"\n+            : \"+r\" (factor)\n+            : \"r\" (inp)\n+            :\n+            : lab);\n+lab:\n+  return inp * factor; /* return 2 * inp or 0 if inp < 10 */\n+@}\n+@end example\n+\n @anchor{x86Operandmodifiers}\n @subsubsection x86 Operand Modifiers\n "}, {"sha": "60afc54e794e69ffd33698387acf73ce351a2e9a", "filename": "gcc/gimple.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -611,10 +611,6 @@ gimple_build_asm_1 (const char *string, unsigned ninputs, unsigned noutputs,\n   gasm *p;\n   int size = strlen (string);\n \n-  /* ASMs with labels cannot have outputs.  This should have been\n-     enforced by the front end.  */\n-  gcc_assert (nlabels == 0 || noutputs == 0);\n-\n   p = as_a <gasm *> (\n         gimple_build_with_ops (GIMPLE_ASM, ERROR_MARK,\n \t\t\t       ninputs + noutputs + nclobbers + nlabels));"}, {"sha": "d359f7827b19f6e5caec3f0f87ec5f33daad125a", "filename": "gcc/gimple.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -4025,7 +4025,7 @@ static inline tree\n gimple_asm_label_op (const gasm *asm_stmt, unsigned index)\n {\n   gcc_gimple_checking_assert (index < asm_stmt->nl);\n-  return asm_stmt->op[index + asm_stmt->ni + asm_stmt->nc];\n+  return asm_stmt->op[index + asm_stmt->no + asm_stmt->ni + asm_stmt->nc];\n }\n \n /* Set LABEL_OP to be label operand INDEX in GIMPLE_ASM ASM_STMT.  */\n@@ -4035,7 +4035,7 @@ gimple_asm_set_label_op (gasm *asm_stmt, unsigned index, tree label_op)\n {\n   gcc_gimple_checking_assert (index < asm_stmt->nl\n \t\t\t      && TREE_CODE (label_op) == TREE_LIST);\n-  asm_stmt->op[index + asm_stmt->ni + asm_stmt->nc] = label_op;\n+  asm_stmt->op[index + asm_stmt->no + asm_stmt->ni + asm_stmt->nc] = label_op;\n }\n \n /* Return the string representing the assembly instruction in"}, {"sha": "3c824e9be392a45bd23da1222682284501549894", "filename": "gcc/ira.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -5401,6 +5401,48 @@ ira (FILE *f)\n   int ira_max_point_before_emit;\n   bool saved_flag_caller_saves = flag_caller_saves;\n   enum ira_region saved_flag_ira_region = flag_ira_region;\n+  basic_block bb;\n+  edge_iterator ei;\n+  edge e;\n+  bool output_jump_reload_p = false;\n+  \n+  if (ira_use_lra_p)\n+    {\n+      /* First put potential jump output reloads on the output edges\n+\t as USE which will be removed at the end of LRA.  The major\n+\t goal is actually to create BBs for critical edges for LRA and\n+\t populate them later by live info.  In LRA it will be\n+\t difficult to do this. */\n+      FOR_EACH_BB_FN (bb, cfun)\n+\t{\n+\t  rtx_insn *end = BB_END (bb);\n+\t  if (!JUMP_P (end))\n+\t    continue;\n+\t  extract_insn (end);\n+\t  for (int i = 0; i < recog_data.n_operands; i++)\n+\t    if (recog_data.operand_type[i] != OP_IN)\n+\t      {\n+\t\toutput_jump_reload_p = true;\n+\t\tFOR_EACH_EDGE (e, ei, bb->succs)\n+\t\t  if (EDGE_CRITICAL_P (e)\n+\t\t      && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n+\t\t    {\n+\t\t      ira_assert (!(e->flags & EDGE_ABNORMAL));\n+\t\t      start_sequence ();\n+\t\t      /* We need to put some no-op insn here.  We can\n+\t\t\t not put a note as commit_edges insertion will\n+\t\t\t fail.  */\n+\t\t      emit_insn (gen_rtx_USE (VOIDmode, const1_rtx));\n+\t\t      rtx_insn *insns = get_insns ();\n+\t\t      end_sequence ();\n+\t\t      insert_insn_on_edge (insns, e);\n+\t\t    }\n+\t\tbreak;\n+\t      }\n+\t}\n+      if (output_jump_reload_p)\n+\tcommit_edge_insertions ();\n+    }\n \n   if (flag_ira_verbose < 10)\n     {\n@@ -5709,6 +5751,21 @@ ira (FILE *f)\n     }\n }\n \n+/* Modify asm goto to avoid further trouble with this insn.  We can\n+   not replace the insn by USE as in other asm insns as we still\n+   need to keep CFG consistency.  */\n+void\n+ira_nullify_asm_goto (rtx_insn *insn)\n+{\n+  ira_assert (JUMP_P (insn) && INSN_CODE (insn) < 0);\n+  rtx tmp = extract_asm_operands (PATTERN (insn));\n+  PATTERN (insn) = gen_rtx_ASM_OPERANDS (VOIDmode, ggc_strdup (\"\"), \"\", 0,\n+\t\t\t\t\t rtvec_alloc (0),\n+\t\t\t\t\t rtvec_alloc (0),\n+\t\t\t\t\t ASM_OPERANDS_LABEL_VEC (tmp),\n+\t\t\t\t\t ASM_OPERANDS_SOURCE_LOCATION(tmp));\n+}\n+\n static void\n do_reload (void)\n {"}, {"sha": "0da06ee846bbeb0d79b46efc5da7f8709cf38739", "filename": "gcc/ira.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -213,6 +213,7 @@ extern void ira_register_new_scratch_op (rtx_insn *insn, int nop, int icode);\n extern bool ira_remove_insn_scratches (rtx_insn *insn, bool all_p, FILE *dump_file,\n \t\t\t\t       rtx (*get_reg) (rtx original));\n extern void ira_restore_scratches (FILE *dump_file);\n+extern void ira_nullify_asm_goto (rtx_insn *insn);\n \n /* ira-costs.c */\n extern void ira_costs_c_finalize (void);"}, {"sha": "b040f7f6f3388ad2f4a4052960dac8d4d032e4f8", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -1715,8 +1715,8 @@ find_reload_regno_insns (int regno, rtx_insn * &start, rtx_insn * &finish)\n \tstart_insn = lra_insn_recog_data[uid]->insn;\n       n++;\n     }\n-  /* For reload pseudo we should have at most 3 insns referring for it:\n-     input/output reload insns and the original insn.  */\n+  /* For reload pseudo we should have at most 3 insns referring for\n+     it: input/output reload insns and the original insn.  */\n   if (n > 3)\n     return false;\n   if (n > 1)\n@@ -1792,7 +1792,8 @@ lra_split_hard_reg_for (void)\n       {\n \tif (! find_reload_regno_insns (i, first, last))\n \t  continue;\n-\tif (spill_hard_reg_in_range (i, rclass, first, last))\n+\tif (BLOCK_FOR_INSN (first) == BLOCK_FOR_INSN (last)\n+\t    && spill_hard_reg_in_range (i, rclass, first, last))\n \t  {\n \t    bitmap_clear (&failed_reload_pseudos);\n \t    return true;\n@@ -1817,16 +1818,10 @@ lra_split_hard_reg_for (void)\n \t  lra_asm_error_p = asm_p = true;\n \t  error_for_asm (insn,\n \t\t\t \"%<asm%> operand has impossible constraints\");\n-\t  /* Avoid further trouble with this insn.\n-\t     For asm goto, instead of fixing up all the edges\n-\t     just clear the template and clear input operands\n-\t     (asm goto doesn't have any output operands).  */\n+\t  /* Avoid further trouble with this insn.  */\n \t  if (JUMP_P (insn))\n \t    {\n-\t      rtx asm_op = extract_asm_operands (PATTERN (insn));\n-\t      ASM_OPERANDS_TEMPLATE (asm_op) = ggc_strdup (\"\");\n-\t      ASM_OPERANDS_INPUT_VEC (asm_op) = rtvec_alloc (0);\n-\t      ASM_OPERANDS_INPUT_CONSTRAINT_VEC (asm_op) = rtvec_alloc (0);\n+\t      ira_nullify_asm_goto (insn);\n \t      lra_update_insn_regno_info (insn);\n \t    }\n \t  else"}, {"sha": "f034c7749e9b8245dc4f6ce4e891ffd75248e8f9", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -3954,10 +3954,10 @@ curr_insn_transform (bool check_only_p)\n   no_input_reloads_p = no_output_reloads_p = false;\n   goal_alt_number = -1;\n   change_p = sec_mem_p = false;\n-  /* JUMP_INSNs and CALL_INSNs are not allowed to have any output\n-     reloads; neither are insns that SET cc0.  Insns that use CC0 are\n-     not allowed to have any input reloads.  */\n-  if (JUMP_P (curr_insn) || CALL_P (curr_insn))\n+  /* CALL_INSNs are not allowed to have any output reloads; neither\n+     are insns that SET cc0.  Insns that use CC0 are not allowed to\n+     have any input reloads.  */\n+  if (CALL_P (curr_insn))\n     no_output_reloads_p = true;\n \n   if (HAVE_cc0 && reg_referenced_p (cc0_rtx, PATTERN (curr_insn)))"}, {"sha": "85c36647be0d421277158069fe14058286ddaf92", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -788,6 +788,14 @@ lra_final_code_change (void)\n \t{\n \t  rtx pat = PATTERN (insn);\n \n+\t  if (GET_CODE (pat) == USE && XEXP (pat, 0) == const1_rtx)\n+\t    {\n+\t      /* Remove markers to eliminate critical edges for jump insn\n+\t\t output reloads (see code in ira.c::ira).  */\n+\t      lra_invalidate_insn_data (insn);\n+\t      delete_insn (insn);\n+\t      continue;\n+\t    }\n \t  if (GET_CODE (pat) == CLOBBER && LRA_TEMP_CLOBBER_P (pat))\n \t    {\n \t      /* Remove clobbers temporarily created in LRA.  We don't"}, {"sha": "673554d0a4b6e0abe1ac3adf4fbe8cb9db49bae3", "filename": "gcc/lra.c", "status": "modified", "additions": 56, "deletions": 13, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -1852,8 +1852,6 @@ void\n lra_process_new_insns (rtx_insn *insn, rtx_insn *before, rtx_insn *after,\n \t\t       const char *title)\n {\n-  rtx_insn *last;\n-\n   if (before == NULL_RTX && after == NULL_RTX)\n     return;\n   if (lra_dump_file != NULL)\n@@ -1864,12 +1862,6 @@ lra_process_new_insns (rtx_insn *insn, rtx_insn *before, rtx_insn *after,\n \t  fprintf (lra_dump_file,\"    %s before:\\n\", title);\n \t  dump_rtl_slim (lra_dump_file, before, NULL, -1, 0);\n \t}\n-      if (after != NULL_RTX)\n-\t{\n-\t  fprintf (lra_dump_file, \"    %s after:\\n\", title);\n-\t  dump_rtl_slim (lra_dump_file, after, NULL, -1, 0);\n-\t}\n-      fprintf (lra_dump_file, \"\\n\");\n     }\n   if (before != NULL_RTX)\n     {\n@@ -1883,12 +1875,63 @@ lra_process_new_insns (rtx_insn *insn, rtx_insn *before, rtx_insn *after,\n     {\n       if (cfun->can_throw_non_call_exceptions)\n \tcopy_reg_eh_region_note_forward (insn, after, NULL);\n-      for (last = after; NEXT_INSN (last) != NULL_RTX; last = NEXT_INSN (last))\n-\t;\n-      emit_insn_after (after, insn);\n-      push_insns (last, insn);\n-      setup_sp_offset (after, last);\n+      if (! JUMP_P (insn))\n+\t{\n+\t  rtx_insn *last;\n+\t  \n+\t  if (lra_dump_file != NULL)\n+\t    {\n+\t      fprintf (lra_dump_file, \"    %s after:\\n\", title);\n+\t      dump_rtl_slim (lra_dump_file, after, NULL, -1, 0);\n+\t    }\n+\t  for (last = after;\n+\t       NEXT_INSN (last) != NULL_RTX;\n+\t       last = NEXT_INSN (last))\n+\t    ;\n+\t  emit_insn_after (after, insn);\n+\t  push_insns (last, insn);\n+\t  setup_sp_offset (after, last);\n+\t}\n+      else\n+\t{\n+\t  /* Put output reload insns on successor BBs: */\n+\t  edge_iterator ei;\n+\t  edge e;\n+\t  \n+\t  FOR_EACH_EDGE (e, ei, BLOCK_FOR_INSN (insn)->succs)\n+\t    if (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n+\t      {\n+\t\t/* We already made the edge no-critical in ira.c::ira */\n+\t\tlra_assert (!EDGE_CRITICAL_P (e));\n+\t\trtx_insn *tmp = BB_HEAD (e->dest);\n+\t\tif (LABEL_P (tmp))\n+\t\t  tmp = NEXT_INSN (tmp);\n+\t\tif (NOTE_INSN_BASIC_BLOCK_P (tmp))\n+\t\t  tmp = NEXT_INSN (tmp);\n+\t\tstart_sequence ();\n+\t\tfor (rtx_insn *curr = after;\n+\t\t     curr != NULL_RTX;\n+\t\t     curr = NEXT_INSN (curr))\n+\t\t  emit_insn (copy_insn (PATTERN (curr)));\n+\t\trtx_insn *copy = get_insns (), *last = get_last_insn ();\n+\t\tend_sequence ();\n+\t\tif (lra_dump_file != NULL)\n+\t\t  {\n+\t\t    fprintf (lra_dump_file, \"    %s after in bb%d:\\n\", title,\n+\t\t\t     e->dest->index);\n+\t\t    dump_rtl_slim (lra_dump_file, copy, NULL, -1, 0);\n+\t\t  }\n+\t\temit_insn_before (copy, tmp);\n+\t\tpush_insns (last, PREV_INSN (copy));\n+\t\tsetup_sp_offset (copy, last);\n+\t\t/* We can ignore BB live info here as it and reg notes\n+\t\t   will be updated before the next assignment\n+\t\t   sub-pass. */\n+\t      }\n+\t}\n     }\n+  if (lra_dump_file != NULL)\n+    fprintf (lra_dump_file, \"\\n\");\n   if (cfun->can_throw_non_call_exceptions)\n     {\n       rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);"}, {"sha": "445f9bdca43bf91c75c16fefbf2f53fc80360e1b", "filename": "gcc/reload.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -2656,6 +2656,22 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n   hard_regs_live_known = live_known;\n   static_reload_reg_p = reload_reg_p;\n \n+  if (JUMP_P (insn) && INSN_CODE (insn) < 0)\n+    {\n+      extract_insn (insn);\n+      for (i = 0; i < recog_data.n_operands; i++)\n+\tif (recog_data.operand_type[i] != OP_IN)\n+\t  break;\n+      if (i < recog_data.n_operands)\n+\t{\n+\t  error_for_asm (insn,\n+\t\t\t \"the target does not support asm goto \"\n+\t\t\t \"with outputs in %<asm%>\");\n+\t  ira_nullify_asm_goto (insn);\n+\t  return 0;\n+\t}\n+    }\n+\n   /* JUMP_INSNs and CALL_INSNs are not allowed to have any output reloads;\n      neither are insns that SET cc0.  Insns that use CC0 are not allowed\n      to have any input reloads.  */"}, {"sha": "fb81cdec21da624ca697df2da6ed7c540475e6a3", "filename": "gcc/testsuite/c-c++-common/asmgoto-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasmgoto-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasmgoto-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasmgoto-2.c?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -7,7 +7,7 @@ foo (void)\n   __label__ lab;\n   int i = 0;\n   asm goto (\"\" : : : : lab);\n-  asm goto (\"\" : \"=r\" (i) : : : lab);\t/* { dg-error \"expected\" } */\n+  asm goto (\"\" : \"=r\" (i) : : : lab);\n   asm goto (\"\" : : : : );\t/* { dg-error \"expected\" } */\n   asm goto (\"\" : : : \"memory\");\t/* { dg-error \"expected\" } */\n   asm goto (\"\" : : : );\t\t/* { dg-error \"expected\" } */"}, {"sha": "f1b30c028847733c3bf1e334dfd2496b67c4f76b", "filename": "gcc/testsuite/gcc.c-torture/compile/asmgoto-2.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fasmgoto-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fasmgoto-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fasmgoto-2.c?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -0,0 +1,65 @@\n+/* This test should be switched off for a new target with less than 4 allocatable registers */\n+/* { dg-do compile } */\n+int\n+foo (void)\n+{\n+  int x, y, z, v;\n+  \n+  asm goto (\"\": \"=r\" (x), \"=r\" (y), \"=r\" (z), \"=r\" (v) : : : lab, lab2, lab3, lab4);\n+ lab:\n+  return x;\n+ lab2:\n+  return y;\n+ lab3:\n+  return z;\n+ lab4:\n+  return v;\n+}\n+\n+int\n+foo2 (void)\n+{\n+  int x = 0, y = 1, z = 2, v = 3;\n+  \n+  asm goto (\"\": \"+r\" (x), \"+r\" (y), \"+r\" (z), \"+r\" (v) : : : lab, lab2, lab3, lab4);\n+ lab:\n+  return x;\n+ lab2:\n+  return y;\n+ lab3:\n+  return z;\n+ lab4:\n+  return v;\n+}\n+\n+int\n+foo3 (void)\n+{\n+  int x, y, z, v;\n+  \n+  asm goto (\"\": \"=rm\" (x), \"=mr\" (y), \"=rm\" (z), \"=mr\" (v) : : : lab, lab2, lab3, lab4);\n+ lab:\n+  return x;\n+ lab2:\n+  return y;\n+ lab3:\n+  return z;\n+ lab4:\n+  return v;\n+}\n+\n+int\n+foo4 (void)\n+{\n+  int x, y, z, v;\n+  \n+  asm goto (\"\": \"=r,m\" (x), \"=m,r\" (y), \"=r,m\" (z), \"=m,r\" (v) : : : lab, lab2, lab3, lab4);\n+ lab:\n+  return x;\n+ lab2:\n+  return y;\n+ lab3:\n+  return z;\n+ lab4:\n+  return v;\n+}"}, {"sha": "842b73e772df8875982c2b7630739d1bacaba2a9", "filename": "gcc/testsuite/gcc.c-torture/compile/asmgoto-3.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fasmgoto-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fasmgoto-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fasmgoto-3.c?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -0,0 +1,89 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+\n+int\n+foo (void)\n+{\n+  int x;\n+  \n+  asm goto (\"\": \"=a\" (x) : : : lab);\n+ lab:\n+  return x;\n+}\n+\n+int\n+foo2 (void)\n+{\n+  int x, y;\n+  \n+  asm goto (\"\": \"=a\" (x), \"=d\" (y) : : : lab, lab2);\n+ lab:\n+  return x;\n+ lab2:\n+  return y;\n+}\n+\n+int\n+foo3 (void)\n+{\n+  int x, y, z;\n+  \n+  asm goto (\"\": \"=a\" (x), \"=d\" (y), \"=c\" (z) : : : lab, lab2, lab3);\n+ lab:\n+  return x;\n+ lab2:\n+  return y;\n+ lab3:\n+  return z;\n+}\n+\n+int\n+foo4 (void)\n+{\n+  int x, y, z, v;\n+  \n+  asm goto (\"\": \"=a\" (x), \"=d\" (y), \"=c\" (z) , \"=b\" (v) : : : lab, lab2, lab3, lab4);\n+ lab:\n+  return x;\n+ lab2:\n+  return y;\n+ lab3:\n+  return z;\n+ lab4:\n+  return v;\n+}\n+\n+int\n+foo5 (void)\n+{\n+  int x, y, z, v, w;\n+  \n+  asm goto (\"\": \"=a\" (x), \"=d\" (y), \"=c\" (z), \"=b\" (v), \"=S\" (w) : : : lab, lab2, lab3, lab4, lab5);\n+ lab:\n+  return x;\n+ lab2:\n+  return y;\n+ lab3:\n+  return z;\n+ lab4:\n+  return v;\n+ lab5:\n+  return w;\n+}\n+\n+int\n+foo6 (void)\n+{\n+  int x = 0, y = 1, z = 2, v = 3, w = 4;\n+  \n+  asm goto (\"\": \"+a\" (x), \"+d\" (y), \"+c\" (z), \"+b\" (v), \"+S\" (w) : : : lab, lab2, lab3, lab4, lab5);\n+ lab:\n+  return x;\n+ lab2:\n+  return y;\n+ lab3:\n+  return z;\n+ lab4:\n+  return v;\n+ lab5:\n+  return w;\n+}"}, {"sha": "844157e48fc258d4faef4173b100e1de586b5497", "filename": "gcc/testsuite/gcc.c-torture/compile/asmgoto-4.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fasmgoto-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fasmgoto-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fasmgoto-4.c?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -0,0 +1,14 @@\n+/* Check that LRA really puts output reloads for p4 in two successors blocks */\n+/* { dg-do compile { target { { i?86-*-* x86_64-*-* } && { ! ia32 } } } } */\n+/* { dg-options \"-O0 -fdump-rtl-reload\" } */\n+\n+int f (int *p1, int *p2, int *p3, int *p4) {\n+  asm volatile goto (\n+            \"\"\n+            : \"=r\" (*p2), \"=a\" (p4)\n+            : \"r\" (*p2), \"r\" (p2)\n+            : \"r8\", \"r9\" : lab, lab2);\n+ lab: return p2 - p4;\n+ lab2: return p3 - p4;\n+}\n+/* { dg-final { scan-rtl-dump-times \"Inserting insn reload after in bb\" 2 \"reload\" } } */"}, {"sha": "94c14dd400591bcf7aa6bdd4efed2b12c23a96f3", "filename": "gcc/testsuite/gcc.c-torture/compile/asmgoto-5.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fasmgoto-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fasmgoto-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fasmgoto-5.c?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -0,0 +1,56 @@\n+/* Test to generate output reload in asm goto on x86_64.  */\n+/* { dg-do compile } */\n+/* { dg-skip-if \"no O0\" { { i?86-*-* x86_64-*-* } && { ! ia32 } } { \"-O0\" } { \"\" } } */\n+\n+#if defined __x86_64__\n+#define ASM(s) asm (s)\n+#else\n+#define ASM(s)\n+#endif\n+\n+int\n+foo (int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8,\n+     int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16)\n+{\n+  register int v0 ASM (\"rax\") = a3;\n+  register int v1 ASM (\"rbx\") = a4;\n+  register int v2 ASM (\"rcx\") = a5;\n+  register int v3 ASM (\"rdx\") = a6;\n+  register int v4 ASM (\"rsi\") = a7;\n+  register int v5 ASM (\"rdi\") = a8;\n+  register int v6 ASM (\"r8\") = a9;\n+  register int v7 ASM (\"r9\") = a10;\n+  register int v8 ASM (\"r10\") = a11;\n+  register int v9 ASM (\"r11\") = a12;\n+  register int v10 ASM (\"r12\") = a13;\n+  register int v11 ASM (\"r13\") = a14;\n+  register int v12 ASM (\"r14\") = a15;\n+  register int v13 ASM (\"r15\") = a16;\n+  int x;\n+  \n+  v0 += a0;\n+  v1 += a1;\n+  v2 += a2;\n+  v0 |= a0;\n+  v1 |= a1;\n+  v2 |= a2;\n+  v0 ^= a0;\n+  v1 ^= a1;\n+  v2 ^= a2;\n+  v0 &= a0;\n+  v1 &= a1;\n+  v2 &= a2;\n+  asm goto (\"\": \"=r\" (x) : : : lab);\n+  a1 ^= a0;\n+  a2 = a1;\n+  a0 |= a2;\n+  a0 |= x;\n+ lab:\n+  v0 += x + a0 + a1 + a2;\n+  v1 -= a0 - a1 - a2;\n+  v2 |= a0 | a1 | a2;\n+  v3 |= a0 & a1 & a2;\n+  v4 ^= a0 ^ a1 ^ a2;\n+  return  v0 + v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8 + v9 + v10 + v11 + v12 + v13 + a0 + a1 + a2;\n+}\n+"}, {"sha": "51c619d3280132fb0776e97b7d232126f9c61d74", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b3b59683c1e7d31a9d313dd97394abebf644be/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=e3b3b59683c1e7d31a9d313dd97394abebf644be", "patch": "@@ -1412,6 +1412,10 @@ rewrite_stmt (gimple_stmt_iterator *si)\n \tSET_DEF (def_p, name);\n \tregister_new_def (DEF_FROM_PTR (def_p), var);\n \n+\t/* Do not insert debug stmts if the stmt ends the BB.  */\n+\tif (stmt_ends_bb_p (stmt))\n+\t  continue;\n+\t\n \ttracked_var = target_for_debug_bind (var);\n \tif (tracked_var)\n \t  {"}]}