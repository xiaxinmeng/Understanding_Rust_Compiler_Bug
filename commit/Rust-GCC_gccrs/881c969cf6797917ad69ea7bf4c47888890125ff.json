{"sha": "881c969cf6797917ad69ea7bf4c47888890125ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgxYzk2OWNmNjc5NzkxN2FkNjllYTdiZjRjNDc4ODg4OTAxMjVmZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-10-31T20:08:51Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-10-31T20:08:51Z"}, "message": "[C++ PATCH] overloaded operator fns [5/N]\n\nhttps://gcc.gnu.org/ml/gcc-patches/2017-10/\n\t* cp-tree.h (struct operator_name_info_t): Rename to ...\n\t(struct ovl_op_info_t): ... here.  Add tree_code field.\n\t(operator_name_info, assignment_operator_name_info): Delete.\n\t(ovl_op_info): Declare.\n\t(OVL_OP_INFO): Adjust.\n\t* decl.c (grok_op_properties): Use ovl_op_flags.\n\t* lex.c (operator_name_info, assignment_operator_name_info):\n\tDelete.\n\t(ovl_op_info): Define.\n\t(set_operator_ident): Adjust.\n\t(init_operators): Set tree_code.\n\t* mangle.c (write_unqualified_id): Adjust operator array scan.\n\nFrom-SVN: r254279", "tree": {"sha": "e834aa3532529a8b1d13db828ee7c5e64fbd2442", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e834aa3532529a8b1d13db828ee7c5e64fbd2442"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/881c969cf6797917ad69ea7bf4c47888890125ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/881c969cf6797917ad69ea7bf4c47888890125ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/881c969cf6797917ad69ea7bf4c47888890125ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/881c969cf6797917ad69ea7bf4c47888890125ff/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c67624232a1cb16a99497605dde681eee711dbbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c67624232a1cb16a99497605dde681eee711dbbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c67624232a1cb16a99497605dde681eee711dbbd"}], "stats": {"total": 129, "additions": 68, "deletions": 61}, "files": [{"sha": "191fa111f6a7f095d29900cafcda3df0801adb2e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c969cf6797917ad69ea7bf4c47888890125ff/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c969cf6797917ad69ea7bf4c47888890125ff/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=881c969cf6797917ad69ea7bf4c47888890125ff", "patch": "@@ -1,5 +1,18 @@\n 2017-10-31  Nathan Sidwell  <nathan@acm.org>\n \n+\t* cp-tree.h (struct operator_name_info_t): Rename to ...\n+\t(struct ovl_op_info_t): ... here.  Add tree_code field.\n+\t(operator_name_info, assignment_operator_name_info): Delete.\n+\t(ovl_op_info): Declare.\n+\t(OVL_OP_INFO): Adjust.\n+\t* decl.c (grok_op_properties): Use ovl_op_flags.\n+\t* lex.c (operator_name_info, assignment_operator_name_info):\n+\tDelete.\n+\t(ovl_op_info): Define.\n+\t(set_operator_ident): Adjust.\n+\t(init_operators): Set tree_code.\n+\t* mangle.c (write_unqualified_id): Adjust operator array scan.\n+\n \t* lex.c (init_operators): Allow NULL operator name.  Don't add\n \tspecial cases.\n \t* operators.def: Use NULL for mangling only operators.  Move to"}, {"sha": "257c8776f0ee1a217583a1acc8ec003f26e81b5e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c969cf6797917ad69ea7bf4c47888890125ff/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c969cf6797917ad69ea7bf4c47888890125ff/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=881c969cf6797917ad69ea7bf4c47888890125ff", "patch": "@@ -5485,29 +5485,26 @@ enum ovl_op_flags\n     OVL_OP_FLAG_VEC = 2\t\t/* vector new or delete  */\n   };\n \n-struct GTY(()) operator_name_info_t {\n+struct GTY(()) ovl_op_info_t {\n   /* The IDENTIFIER_NODE for the operator.  */\n   tree identifier;\n   /* The name of the operator.  */\n   const char *name;\n   /* The mangled name of the operator.  */\n   const char *mangled_name;\n+  /* The tree code.  */\n+  enum tree_code tree_code : 16;\n   /* The ovl_op_flags of the operator */\n   unsigned flags : 8;\n };\n \n-/* A mapping from tree codes to operator name information.  */\n-extern GTY(()) operator_name_info_t operator_name_info\n-  [(int) MAX_TREE_CODES];\n-/* Similar, but for assignment operators.  */\n-extern GTY(()) operator_name_info_t assignment_operator_name_info\n-  [(int) MAX_TREE_CODES];\n+/* Overloaded operator info indexed by ass_op_p & tree_code.  */\n+extern GTY(()) ovl_op_info_t ovl_op_info[2][MAX_TREE_CODES];\n \n /* Given an ass_op_p boolean and a tree code, return a pointer to its\n    overloaded operator info.  */\n #define OVL_OP_INFO(IS_ASS_P, TREE_CODE)\t\t\t\\\n-  (((IS_ASS_P) ? assignment_operator_name_info : operator_name_info)\t\\\n-   + (TREE_CODE))\n+  (&ovl_op_info[(IS_ASS_P) != 0][(TREE_CODE)])\n \n /* A type-qualifier, or bitmask therefore, using the TYPE_QUAL\n    constants.  */"}, {"sha": "d60b8dd775a221cfd33464dfe5ac09da565996d8", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c969cf6797917ad69ea7bf4c47888890125ff/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c969cf6797917ad69ea7bf4c47888890125ff/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=881c969cf6797917ad69ea7bf4c47888890125ff", "patch": "@@ -12898,8 +12898,8 @@ unary_op_p (enum tree_code code)\n \t  || code == TYPE_EXPR);\n }\n \n-/* DECL is a declaration for an overloaded operator.  If COMPLAIN is true,\n-   errors are issued for invalid declarations.  */\n+/* DECL is a declaration for an overloaded or conversion operator.  If\n+   COMPLAIN is true, errors are issued for invalid declarations.  */\n \n bool\n grok_op_properties (tree decl, bool complain)\n@@ -12912,52 +12912,54 @@ grok_op_properties (tree decl, bool complain)\n   if (class_type && !CLASS_TYPE_P (class_type))\n     class_type = NULL_TREE;\n \n-  enum tree_code operator_code = ERROR_MARK;\n+  tree_code operator_code = ERROR_MARK;\n+  unsigned op_flags = OVL_OP_FLAG_NONE;\n   if (IDENTIFIER_CONV_OP_P (name))\n-    operator_code = TYPE_EXPR;\n+    {\n+      /* Conversion operators are TYPE_EXPR for the purposes of this\n+\t function.  */\n+      operator_code = TYPE_EXPR;\n+      op_flags = OVL_OP_FLAG_UNARY;\n+    }\n   else\n     {\n       /* It'd be nice to hang something else of the identifier to\n \t find CODE more directly.  */\n       bool assign_op = IDENTIFIER_ASSIGN_OP_P (name);\n-      const operator_name_info_t *oni\n-\t= (assign_op ? assignment_operator_name_info : operator_name_info);\n-\n+      const ovl_op_info_t *ovl_op = OVL_OP_INFO (assign_op, 0);\n       if (false)\n \t;\n-#define DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, KIND)\t\t\\\n-      else if (assign_op == (KIND == cik_assign_op)\t\t\\\n-\t       && oni[int (CODE)].identifier == name)\t\t\\\n+#define DEF_OPERATOR(NAME, CODE, MANGLING, FLAGS, KIND)\t\t\\\n+      else if (ovl_op[CODE].identifier == name)\t\t\t\\\n \toperator_code = (CODE);\n #include \"operators.def\"\n #undef DEF_OPERATOR\n       else\n \tgcc_unreachable ();\n-      }\n-    while (0);\n-  gcc_assert (operator_code != MAX_TREE_CODES);\n-  DECL_OVERLOADED_OPERATOR_CODE (decl) = operator_code;\n+      gcc_assert (operator_code != ERROR_MARK);\n+      op_flags = ovl_op[operator_code].flags;\n+      DECL_OVERLOADED_OPERATOR_CODE (decl) = operator_code;\n+    }\n \n-  if (operator_code == NEW_EXPR || operator_code == VEC_NEW_EXPR\n-      || operator_code == DELETE_EXPR || operator_code == VEC_DELETE_EXPR)\n+  if (op_flags & OVL_OP_FLAG_ALLOC)\n     {\n       /* operator new and operator delete are quite special.  */\n       if (class_type)\n-\tswitch (operator_code)\n+\tswitch (op_flags)\n \t  {\n-\t  case NEW_EXPR:\n+\t  case OVL_OP_FLAG_ALLOC:\n \t    TYPE_HAS_NEW_OPERATOR (class_type) = 1;\n \t    break;\n \n-\t  case DELETE_EXPR:\n+\t  case OVL_OP_FLAG_ALLOC | OVL_OP_FLAG_DELETE:\n \t    TYPE_GETS_DELETE (class_type) |= 1;\n \t    break;\n \n-\t  case VEC_NEW_EXPR:\n+\t  case OVL_OP_FLAG_ALLOC | OVL_OP_FLAG_VEC:\n \t    TYPE_HAS_ARRAY_NEW_OPERATOR (class_type) = 1;\n \t    break;\n \n-\t  case VEC_DELETE_EXPR:\n+\t  case OVL_OP_FLAG_ALLOC | OVL_OP_FLAG_DELETE | OVL_OP_FLAG_VEC:\n \t    TYPE_GETS_DELETE (class_type) |= 2;\n \t    break;\n \n@@ -12987,12 +12989,12 @@ grok_op_properties (tree decl, bool complain)\n \t    }\n \t}\n \n-      if (operator_code == DELETE_EXPR || operator_code == VEC_DELETE_EXPR)\n+      if (op_flags & OVL_OP_FLAG_DELETE)\n \tTREE_TYPE (decl) = coerce_delete_type (TREE_TYPE (decl));\n       else\n \t{\n-\t  TREE_TYPE (decl) = coerce_new_type (TREE_TYPE (decl));\n \t  DECL_IS_OPERATOR_NEW (decl) = 1;\n+\t  TREE_TYPE (decl) = coerce_new_type (TREE_TYPE (decl));\n \t}\n \n       return true;\n@@ -13043,9 +13045,9 @@ grok_op_properties (tree decl, bool complain)\n \t}\n     }\n \n-  /* There are no restrictions on the arguments to an overloaded\n-     \"operator ()\".  */\n   if (operator_code == CALL_EXPR)\n+    /* There are no further restrictions on the arguments to an overloaded\n+       \"operator ()\".  */\n     return true;\n \n   if (operator_code == COND_EXPR)"}, {"sha": "af081f4d024dc5e1b9ef834804e024dffb6314dd", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c969cf6797917ad69ea7bf4c47888890125ff/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c969cf6797917ad69ea7bf4c47888890125ff/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=881c969cf6797917ad69ea7bf4c47888890125ff", "patch": "@@ -77,10 +77,7 @@ cxx_finish (void)\n   c_common_finish ();\n }\n \n-/* A mapping from tree codes to operator name information.  */\n-operator_name_info_t operator_name_info[(int) MAX_TREE_CODES];\n-/* Similar, but for assignment operators.  */\n-operator_name_info_t assignment_operator_name_info[(int) MAX_TREE_CODES];\n+ovl_op_info_t ovl_op_info[2][MAX_TREE_CODES];\n \n /* Get the name of the kind of identifier T.  */\n \n@@ -117,7 +114,7 @@ set_identifier_kind (tree id, cp_identifier_kind kind)\n    operator PTR describes.  */\n \n static tree\n-set_operator_ident (operator_name_info_t *ptr)\n+set_operator_ident (ovl_op_info_t *ptr)\n {\n   char buffer[32];\n   size_t len = snprintf (buffer, sizeof (buffer), \"operator%s%s\",\n@@ -136,12 +133,13 @@ static void\n init_operators (void)\n {\n   tree identifier;\n-  operator_name_info_t *oni;\n+  ovl_op_info_t *oni;\n \n #define DEF_OPERATOR(NAME, CODE, MANGLING, FLAGS, KIND)\t\t\t\\\n   oni = OVL_OP_INFO (KIND == cik_assign_op, CODE);\t\t\t\\\n   oni->name = NAME;\t\t\t\t\t\t\t\\\n   oni->mangled_name = MANGLING;\t\t\t\t\t\t\\\n+  oni->tree_code = CODE;\t\t\t\t\t\t\\\n   oni->flags = FLAGS;\t\t\t\t\t\t\t\\\n   if (NAME) {\t\t\t\t\t\t\t\t\\\n     identifier = set_operator_ident (oni);\t\t\t\t\\"}, {"sha": "7feb889e9aad806951566edd33f900bd5a470d38", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c969cf6797917ad69ea7bf4c47888890125ff/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c969cf6797917ad69ea7bf4c47888890125ff/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=881c969cf6797917ad69ea7bf4c47888890125ff", "patch": "@@ -1265,32 +1265,29 @@ write_unqualified_id (tree identifier)\n     write_conversion_operator_name (TREE_TYPE (identifier));\n   else if (IDENTIFIER_ANY_OP_P (identifier))\n     {\n-      int i;\n       const char *mangled_name = NULL;\n+      bool assop = IDENTIFIER_ASSIGN_OP_P (identifier);\n \n       /* Unfortunately, there is no easy way to go from the\n \t name of the operator back to the corresponding tree\n \t code.  */\n-      for (i = 0; i < MAX_TREE_CODES; ++i)\n-\tif (operator_name_info[i].identifier == identifier)\n-\t  {\n-\t    /* The ABI says that we prefer binary operator\n-\t       names to unary operator names.  */\n-\t    if (operator_name_info[i].flags == OVL_OP_FLAG_BINARY)\n-\t      {\n-\t\tmangled_name = operator_name_info[i].mangled_name;\n-\t\tbreak;\n-\t      }\n-\t    else if (!mangled_name)\n-\t      mangled_name = operator_name_info[i].mangled_name;\n-\t  }\n-\telse if (assignment_operator_name_info[i].identifier\n-\t\t == identifier)\n-\t  {\n-\t    mangled_name\n-\t      = assignment_operator_name_info[i].mangled_name;\n-\t    break;\n-\t  }\n+      for (unsigned i = 0; i < MAX_TREE_CODES; ++i)\n+\t{\n+\t  const ovl_op_info_t *ovl_op = OVL_OP_INFO (assop, i);\n+\n+\t  if (ovl_op->identifier == identifier)\n+\t    {\n+\t      /* The ABI says that we prefer binary operator\n+\t\t names to unary operator names.  */\n+\t      if (ovl_op->flags == OVL_OP_FLAG_BINARY)\n+\t\t{\n+\t\t  mangled_name = ovl_op->mangled_name;\n+\t\t  break;\n+\t\t}\n+\t      else if (!mangled_name)\n+\t\tmangled_name = ovl_op->mangled_name;\n+\t    }\n+\t}\n       write_string (mangled_name);\n     }\n   else if (UDLIT_OPER_P (identifier))"}]}