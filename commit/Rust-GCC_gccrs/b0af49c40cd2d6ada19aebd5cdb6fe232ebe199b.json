{"sha": "b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBhZjQ5YzQwY2QyZDZhZGExOWFlYmQ1Y2RiNmZlMjMyZWJlMTk5Yg==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-09-03T20:05:42Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-09-03T20:05:42Z"}, "message": "Use DR_IS_WRITE instead of !DR_IS_READ.\n\n2010-09-03  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* tree-data-ref.c (dr_may_alias_p): Replace !DR_IS_READ with\n\tDR_IS_WRITE.\n\t(compute_all_dependences): Same.\n\t(create_rdg_edge_for_ddr): Same.\n\t* tree-data-ref.h (DR_IS_WRITE): New.\n\t(ddr_is_anti_dependent): Replace !DR_IS_READ with DR_IS_WRITE.\n\t* tree-if-conv.c (write_memrefs_written_at_least_once): Same.\n\t(write_memrefs_written_at_least_once): Same.\n\t* tree-predcom.c (suitable_component_p): Same.\n\t(determine_roots_comp): Same.\n\t(execute_load_motion): Same.\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence): Same.\n\t(vect_enhance_data_refs_alignment): Same.\n\t(vect_analyze_group_access): Same.\n\nFrom-SVN: r163841", "tree": {"sha": "3121c570d8493a5ae6a5f6645bb5df55a57f04dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3121c570d8493a5ae6a5f6645bb5df55a57f04dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0edf45a3f9e04e29a2ad83d9fbd3075c5f8a00cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0edf45a3f9e04e29a2ad83d9fbd3075c5f8a00cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0edf45a3f9e04e29a2ad83d9fbd3075c5f8a00cb"}], "stats": {"total": 60, "additions": 39, "deletions": 21}, "files": [{"sha": "19b86e1a1c6cea87b7e6d8b4d91bc1d39a4cb841", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b", "patch": "@@ -1,3 +1,20 @@\n+2010-09-03  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* tree-data-ref.c (dr_may_alias_p): Replace !DR_IS_READ with\n+\tDR_IS_WRITE.\n+\t(compute_all_dependences): Same.\n+\t(create_rdg_edge_for_ddr): Same.\n+\t* tree-data-ref.h (DR_IS_WRITE): New.\n+\t(ddr_is_anti_dependent): Replace !DR_IS_READ with DR_IS_WRITE.\n+\t* tree-if-conv.c (write_memrefs_written_at_least_once): Same.\n+\t(write_memrefs_written_at_least_once): Same.\n+\t* tree-predcom.c (suitable_component_p): Same.\n+\t(determine_roots_comp): Same.\n+\t(execute_load_motion): Same.\n+\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence): Same.\n+\t(vect_enhance_data_refs_alignment): Same.\n+\t(vect_analyze_group_access): Same.\n+\n 2010-09-03  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \tPR testsuite/42843"}, {"sha": "e1d2dfcadca5d6c2acf9288c001522cba94d62d4", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b", "patch": "@@ -1335,12 +1335,12 @@ dr_may_alias_p (const struct data_reference *a, const struct data_reference *b)\n     return false;\n \n   /* Query the alias oracle.  */\n-  if (!DR_IS_READ (a) && !DR_IS_READ (b))\n+  if (DR_IS_WRITE (a) && DR_IS_WRITE (b))\n     {\n       if (!refs_output_dependent_p (DR_REF (a), DR_REF (b)))\n \treturn false;\n     }\n-  else if (DR_IS_READ (a) && !DR_IS_READ (b))\n+  else if (DR_IS_READ (a) && DR_IS_WRITE (b))\n     {\n       if (!refs_anti_dependent_p (DR_REF (a), DR_REF (b)))\n \treturn false;\n@@ -1372,7 +1372,7 @@ dr_may_alias_p (const struct data_reference *a, const struct data_reference *b)\n     decl_b = SSA_NAME_VAR (addr_b);\n \n   if (TYPE_RESTRICT (type_a) && TYPE_RESTRICT (type_b)\n-      && (!DR_IS_READ (a) || !DR_IS_READ (b))\n+      && (DR_IS_WRITE (a) || DR_IS_WRITE (b))\n       && decl_a && DECL_P (decl_a)\n       && decl_b && DECL_P (decl_b)\n       && decl_a != decl_b\n@@ -4107,7 +4107,7 @@ compute_all_dependences (VEC (data_reference_p, heap) *datarefs,\n \n   FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, a)\n     for (j = i + 1; VEC_iterate (data_reference_p, datarefs, j, b); j++)\n-      if (!DR_IS_READ (a) || !DR_IS_READ (b) || compute_self_and_rr)\n+      if (DR_IS_WRITE (a) || DR_IS_WRITE (b) || compute_self_and_rr)\n \t{\n \t  ddr = initialize_data_dependence_relation (a, b, loop_nest);\n \t  VEC_safe_push (ddr_p, heap, *dependence_relations, ddr);\n@@ -4772,11 +4772,11 @@ create_rdg_edge_for_ddr (struct graph *rdg, ddr_p ddr)\n   /* Determines the type of the data dependence.  */\n   if (DR_IS_READ (dra) && DR_IS_READ (drb))\n     RDGE_TYPE (e) = input_dd;\n-  else if (!DR_IS_READ (dra) && !DR_IS_READ (drb))\n+  else if (DR_IS_WRITE (dra) && DR_IS_WRITE (drb))\n     RDGE_TYPE (e) = output_dd;\n-  else if (!DR_IS_READ (dra) && DR_IS_READ (drb))\n+  else if (DR_IS_WRITE (dra) && DR_IS_READ (drb))\n     RDGE_TYPE (e) = flow_dd;\n-  else if (DR_IS_READ (dra) && !DR_IS_READ (drb))\n+  else if (DR_IS_READ (dra) && DR_IS_WRITE (drb))\n     RDGE_TYPE (e) = anti_dd;\n }\n "}, {"sha": "844a2aea3b023d53b5c4ece416150020a8516244", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b", "patch": "@@ -193,6 +193,7 @@ struct data_reference\n #define DR_ACCESS_FN(DR, I)        VEC_index (tree, DR_ACCESS_FNS (DR), I)\n #define DR_NUM_DIMENSIONS(DR)      VEC_length (tree, DR_ACCESS_FNS (DR))\n #define DR_IS_READ(DR)             (DR)->is_read\n+#define DR_IS_WRITE(DR)            (!DR_IS_READ (DR))\n #define DR_BASE_ADDRESS(DR)        (DR)->innermost.base_address\n #define DR_OFFSET(DR)              (DR)->innermost.offset\n #define DR_INIT(DR)                (DR)->innermost.init\n@@ -473,7 +474,7 @@ ddr_is_anti_dependent (ddr_p ddr)\n {\n   return (DDR_ARE_DEPENDENT (ddr) == NULL_TREE\n \t  && DR_IS_READ (DDR_A (ddr))\n-\t  && !DR_IS_READ (DDR_B (ddr))\n+\t  && DR_IS_WRITE (DDR_B (ddr))\n \t  && !same_access_functions (ddr));\n }\n "}, {"sha": "e92090f9085b15e562190a3e56497566e118c802", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b", "patch": "@@ -533,7 +533,7 @@ write_memrefs_written_at_least_once (gimple stmt,\n \n   for (i = 0; VEC_iterate (data_reference_p, drs, i, a); i++)\n     if (DR_STMT (a) == stmt\n-\t&& !DR_IS_READ (a))\n+\t&& DR_IS_WRITE (a))\n       {\n \tbool found = false;\n \tint x = DR_WRITTEN_AT_LEAST_ONCE (a);\n@@ -546,7 +546,7 @@ write_memrefs_written_at_least_once (gimple stmt,\n \n \tfor (j = 0; VEC_iterate (data_reference_p, drs, j, b); j++)\n \t  if (DR_STMT (b) != stmt\n-\t      && !DR_IS_READ (b)\n+\t      && DR_IS_WRITE (b)\n \t      && same_data_refs_base_objects (a, b))\n \t    {\n \t      tree cb = bb_predicate (gimple_bb (DR_STMT (b)));"}, {"sha": "be2cfc4d6c7696d6fe8cf9417a16a387272a852c", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b", "patch": "@@ -829,7 +829,7 @@ suitable_component_p (struct loop *loop, struct component *comp)\n       gcc_assert (dominated_by_p (CDI_DOMINATORS, ba, bp));\n       bp = ba;\n \n-      if (!DR_IS_READ (a->ref))\n+      if (DR_IS_WRITE (a->ref))\n \thas_write = true;\n     }\n \n@@ -1197,7 +1197,7 @@ determine_roots_comp (struct loop *loop,\n \n   FOR_EACH_VEC_ELT (dref, comp->refs, i, a)\n     {\n-      if (!chain || !DR_IS_READ (a->ref)\n+      if (!chain || DR_IS_WRITE (a->ref)\n \t  || double_int_ucmp (uhwi_to_double_int (MAX_DISTANCE),\n \t\t\t      double_int_sub (a->offset, last_ofs)) <= 0)\n \t{\n@@ -1611,7 +1611,7 @@ execute_load_motion (struct loop *loop, chain_p chain, bitmap tmp_vars)\n   gcc_assert (chain->type == CT_INVARIANT);\n   gcc_assert (!chain->combined);\n   FOR_EACH_VEC_ELT (dref, chain->refs, i, a)\n-    if (!DR_IS_READ (a->ref))\n+    if (DR_IS_WRITE (a->ref))\n       n_writes++;\n \n   /* If there are no reads in the loop, there is nothing to do.  */\n@@ -1627,7 +1627,7 @@ execute_load_motion (struct loop *loop, chain_p chain, bitmap tmp_vars)\n       bool is_read = DR_IS_READ (a->ref);\n       mark_virtual_ops_for_renaming (a->stmt);\n \n-      if (!DR_IS_READ (a->ref))\n+      if (DR_IS_WRITE (a->ref))\n \t{\n \t  n_writes--;\n \t  if (n_writes)"}, {"sha": "7944d8bcb8057df993b95adf49370fbf11d410a4", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=b0af49c40cd2d6ada19aebd5cdb6fe232ebe199b", "patch": "@@ -614,7 +614,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n         }\n \n       /* We do not vectorize basic blocks with write-write dependencies.  */\n-      if (!DR_IS_READ (dra) && !DR_IS_READ (drb))\n+      if (DR_IS_WRITE (dra) && DR_IS_WRITE (drb))\n         return true;\n \n       /* We deal with read-write dependencies in basic blocks later (by\n@@ -641,7 +641,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n         }\n \n       /* Do not vectorize basic blcoks with write-write dependences.  */\n-      if (!DR_IS_READ (dra) && !DR_IS_READ (drb))\n+      if (DR_IS_WRITE (dra) && DR_IS_WRITE (drb))\n         return true;\n \n       /* Check if this dependence is allowed in basic block vectorization.  */ \n@@ -1553,7 +1553,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n                       dr0 = dr;\n                     }\n \n-                  if (!first_store && !DR_IS_READ (dr))\n+                  if (!first_store && DR_IS_WRITE (dr))\n                     first_store = dr;\n                 }\n \n@@ -1565,7 +1565,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n               if (!supportable_dr_alignment)\n                 {\n                   dr0 = dr;\n-                  if (!first_store && !DR_IS_READ (dr))\n+                  if (!first_store && DR_IS_WRITE (dr))\n                     first_store = dr;\n                 }\n             }\n@@ -2078,7 +2078,7 @@ vect_analyze_group_access (struct data_reference *dr)\n                                      DR_INIT (STMT_VINFO_DATA_REF (\n \t\t\t\t\t\t   vinfo_for_stmt (next)))))\n             {\n-              if (!DR_IS_READ (data_ref))\n+              if (DR_IS_WRITE (data_ref))\n                 {\n                   if (vect_print_dump_info (REPORT_DETAILS))\n                     fprintf (vect_dump, \"Two store stmts share the same dr.\");\n@@ -2123,7 +2123,7 @@ vect_analyze_group_access (struct data_reference *dr)\n \t    {\n \t      /* FORNOW: SLP of accesses with gaps is not supported.  */\n \t      slp_impossible = true;\n-\t      if (!DR_IS_READ (data_ref))\n+\t      if (DR_IS_WRITE (data_ref))\n \t\t{\n \t\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t\t    fprintf (vect_dump, \"interleaved store with gaps\");\n@@ -2215,7 +2215,7 @@ vect_analyze_group_access (struct data_reference *dr)\n \n       /* SLP: create an SLP data structure for every interleaving group of\n \t stores for further analysis in vect_analyse_slp.  */\n-      if (!DR_IS_READ (dr) && !slp_impossible)\n+      if (DR_IS_WRITE (dr) && !slp_impossible)\n         {\n           if (loop_vinfo)\n             VEC_safe_push (gimple, heap, LOOP_VINFO_STRIDED_STORES (loop_vinfo),"}]}