{"sha": "0da9afa6d6ac1ca516bc62d97ef1b8e727ea96b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRhOWFmYTZkNmFjMWNhNTE2YmM2MmQ5N2VmMWI4ZTcyN2VhOTZiNw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2000-08-08T01:17:06Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-08-08T01:17:06Z"}, "message": "Fix most compile time warning messages\n\nFrom-SVN: r35559", "tree": {"sha": "a4d7d30a4b313f984a0c562d312be2cb5d5e1132", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4d7d30a4b313f984a0c562d312be2cb5d5e1132"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0da9afa6d6ac1ca516bc62d97ef1b8e727ea96b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0da9afa6d6ac1ca516bc62d97ef1b8e727ea96b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0da9afa6d6ac1ca516bc62d97ef1b8e727ea96b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0da9afa6d6ac1ca516bc62d97ef1b8e727ea96b7/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "94260abda471a61ed20c928b9faa18e9afe087b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94260abda471a61ed20c928b9faa18e9afe087b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94260abda471a61ed20c928b9faa18e9afe087b6"}], "stats": {"total": 114, "additions": 60, "deletions": 54}, "files": [{"sha": "12609e2dcb62e3e8f3a4a9a4f92d2ac3ee5060dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da9afa6d6ac1ca516bc62d97ef1b8e727ea96b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da9afa6d6ac1ca516bc62d97ef1b8e727ea96b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0da9afa6d6ac1ca516bc62d97ef1b8e727ea96b7", "patch": "@@ -1,4 +1,7 @@\n-2000-08-07  Nick Clifton  <nickc@cygnus.com>\n+2000-08-07  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/mips/mips.c: Fix compile time warning messages.\n+\t* config/mips/mips-protos.h: Add prototype for equality_op.\n \n \t* mn10300.h (TARGET_SWITCHES): Document `-mam33'.\n "}, {"sha": "126ca1d3933068e91cf207cea0a97a505d444604", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da9afa6d6ac1ca516bc62d97ef1b8e727ea96b7/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da9afa6d6ac1ca516bc62d97ef1b8e727ea96b7/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=0da9afa6d6ac1ca516bc62d97ef1b8e727ea96b7", "patch": "@@ -96,6 +96,7 @@ extern int\t\treg_or_0_operand PARAMS ((rtx, enum machine_mode));\n extern int\t\ttrue_reg_or_0_operand PARAMS ((rtx, enum machine_mode));\n extern int\t\tsimple_memory_operand PARAMS ((rtx, enum machine_mode));\n extern int\t\tdouble_memory_operand PARAMS ((rtx, enum machine_mode));\n+extern int\t\tequality_op PARAMS ((rtx, enum machine_mode));\n extern int\t\tsmall_int PARAMS ((rtx, enum machine_mode));\n extern int\t\tuns_arith_operand PARAMS ((rtx, enum machine_mode));\n extern struct rtx_def *\tembedded_pic_offset PARAMS ((rtx));"}, {"sha": "963a5ae3e035e23e4e97c7a7aaf8540165276c86", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 55, "deletions": 53, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da9afa6d6ac1ca516bc62d97ef1b8e727ea96b7/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da9afa6d6ac1ca516bc62d97ef1b8e727ea96b7/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0da9afa6d6ac1ca516bc62d97ef1b8e727ea96b7", "patch": "@@ -692,7 +692,7 @@ mips16_simple_memory_operand (reg, offset, mode)\n     off = 0x100;\n   else\n     off = 0x20;\n-  if (INTVAL (offset) >= 0 && INTVAL (offset) < off * size)\n+  if (INTVAL (offset) >= 0 && INTVAL (offset) < (HOST_WIDE_INT)(off * size))\n     return 1;\n   return 0;\n }\n@@ -715,7 +715,7 @@ simple_memory_operand (op, mode)\n   /* ??? This isn't strictly correct.  It is OK to accept multiword modes\n      here, since the length attributes are being set correctly, but only\n      if the address is offsettable.  LO_SUM is not offsettable.  */\n-  if (GET_MODE_SIZE (GET_MODE (op)) > UNITS_PER_WORD)\n+  if (GET_MODE_SIZE (GET_MODE (op)) > (unsigned) UNITS_PER_WORD)\n     return 0;\n \n   /* Decode the address now.  */\n@@ -868,7 +868,7 @@ double_memory_operand (op, mode)\n \t     address will get reloaded anyhow.  */\n \t  if (GET_CODE (addr) == PLUS\n \t      && GET_CODE (XEXP (addr, 0)) == REG\n-\t      && (REGNO (XEXP (addr, 0)) == HARD_FRAME_POINTER_REGNUM\n+\t      && (REGNO (XEXP (addr, 0)) == (unsigned) HARD_FRAME_POINTER_REGNUM\n \t\t  || REGNO (XEXP (addr, 0)) == STACK_POINTER_REGNUM)\n \t      && ((GET_CODE (XEXP (addr, 1)) == CONST_INT\n \t\t   && ! SMALL_INT (XEXP (addr, 1)))\n@@ -885,7 +885,7 @@ double_memory_operand (op, mode)\n \t      maddr = XEXP (addr, 0);\n \t      if (GET_CODE (maddr) == PLUS\n \t\t  && GET_CODE (XEXP (maddr, 0)) == REG\n-\t\t  && (REGNO (XEXP (maddr, 0)) == HARD_FRAME_POINTER_REGNUM\n+\t\t  && (REGNO (XEXP (maddr, 0)) == (unsigned) HARD_FRAME_POINTER_REGNUM\n \t\t      || REGNO (XEXP (maddr, 0)) == STACK_POINTER_REGNUM)\n \t\t  && ((GET_CODE (XEXP (maddr, 1)) == CONST_INT\n \t\t       && ! SMALL_INT (XEXP (maddr, 1)))\n@@ -905,7 +905,7 @@ double_memory_operand (op, mode)\n \t      addr = XEXP (XEXP (addr, 0), 0);\n \t      if (GET_CODE (addr) == PLUS\n \t\t  && GET_CODE (XEXP (addr, 0)) == REG\n-\t\t  && (REGNO (XEXP (addr, 0)) == HARD_FRAME_POINTER_REGNUM\n+\t\t  && (REGNO (XEXP (addr, 0)) == (unsigned) HARD_FRAME_POINTER_REGNUM\n \t\t      || REGNO (XEXP (addr, 0)) == STACK_POINTER_REGNUM)\n \t\t  && ((GET_CODE (XEXP (addr, 1)) == CONST_INT\n \t\t       && ! SMALL_INT (XEXP (addr, 1)))\n@@ -1199,7 +1199,7 @@ mips_check_split (address, mode)\n {     \n   /* ??? This is the same check used in simple_memory_operand.\n      We use it here because LO_SUM is not offsettable.  */\n-  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+  if (GET_MODE_SIZE (mode) > (unsigned) UNITS_PER_WORD)\n     return 0;\n \n   if ((GET_CODE (address) == SYMBOL_REF && ! SYMBOL_REF_FLAG (address))\n@@ -1246,7 +1246,7 @@ mips_legitimate_address_p (mode, xinsn, strict)\n   /* Check for constant before stripping off SUBREG, so that we don't\t\n      accept (subreg (const_int)) which will fail to reload. */   \t\n   if (CONSTANT_ADDRESS_P (xinsn)\t\t\t\t\t\n-      && ! (mips_split_addresses && mips_check_split (xinsn, mode))\t\n+      && ! (mips_split_addresses && mips_check_split (xinsn, mode))\n       && (! TARGET_MIPS16 || mips16_constant (xinsn, mode, 1, 0)))\t\n     return 1;\t\t\t\t\t\t\t\t\n \t\t\t\t\t\t\t\t\t\n@@ -1619,7 +1619,7 @@ mips_fill_delay_slot (ret, type, operands, cur_insn)\n   dslots_number_nops = num_nops;\n   mips_load_reg = set_reg;\n   if (GET_MODE_SIZE (mode)\n-      > (FP_REG_P (REGNO (set_reg)) ? UNITS_PER_FPREG : UNITS_PER_WORD))\n+      > (unsigned) (FP_REG_P (REGNO (set_reg)) ? UNITS_PER_FPREG : UNITS_PER_WORD))\n     mips_load_reg2 = gen_rtx_REG (SImode, REGNO (set_reg) + 1);\n   else\n     mips_load_reg2 = 0;\n@@ -3183,7 +3183,7 @@ block_move_loop (dest_reg, src_reg, bytes, align, orig_dest, orig_src)\n   rtx bytes_rtx;\n   int leftover;\n \n-  if (bytes < 2 * MAX_MOVE_BYTES)\n+  if (bytes < 2U * MAX_MOVE_BYTES)\n     abort ();\n \n   leftover = bytes % MAX_MOVE_BYTES;\n@@ -3250,7 +3250,7 @@ block_move_call (dest_reg, src_reg, bytes_rtx)\n   /* We want to pass the size as Pmode, which will normally be SImode\n      but will be DImode if we are using 64 bit longs and pointers.  */\n   if (GET_MODE (bytes_rtx) != VOIDmode\n-      && GET_MODE (bytes_rtx) != Pmode)\n+      && GET_MODE (bytes_rtx) != (unsigned) Pmode)\n     bytes_rtx = convert_to_mode (Pmode, bytes_rtx, 1);\n \n #ifdef TARGET_MEM_FUNCTIONS\n@@ -3292,7 +3292,7 @@ expand_block_move (operands)\n   if (constp && bytes == 0)\n     return;\n \n-  if (align > UNITS_PER_WORD)\n+  if (align > (unsigned) UNITS_PER_WORD)\n     align = UNITS_PER_WORD;\n \n   /* Move the address into scratch registers.  */\n@@ -3302,18 +3302,18 @@ expand_block_move (operands)\n   if (TARGET_MEMCPY)\n     block_move_call (dest_reg, src_reg, bytes_rtx);\n \n-  else if (constp && bytes <= 2 * MAX_MOVE_BYTES\n-\t   && align == UNITS_PER_WORD)\n+  else if (constp && bytes <= 2U * MAX_MOVE_BYTES\n+\t   && align == (unsigned) UNITS_PER_WORD)\n     move_by_pieces (orig_dest, orig_src, bytes, align * BITS_PER_WORD);\n \t\n-  else if (constp && bytes <= 2 * MAX_MOVE_BYTES)\n+  else if (constp && bytes <= 2U * MAX_MOVE_BYTES)\n     emit_insn (gen_movstrsi_internal (change_address (orig_dest, BLKmode,\n \t\t\t\t\t\t      dest_reg),\n \t\t\t\t      change_address (orig_src, BLKmode,\n \t\t\t\t\t\t      src_reg),\n \t\t\t\t      bytes_rtx, align_rtx));\n \n-  else if (constp && align >= UNITS_PER_WORD && optimize)\n+  else if (constp && align >= (unsigned) UNITS_PER_WORD && optimize)\n     block_move_loop (dest_reg, src_reg, bytes, align, orig_dest, orig_src);\n \n   else if (constp && optimize)\n@@ -3857,7 +3857,7 @@ function_arg (cum, mode, type, named)\n   rtx ret;\n   int regbase = -1;\n   int bias = 0;\n-  int *arg_words = &cum->arg_words;\n+  unsigned int *arg_words = &cum->arg_words;\n   int struct_p = (type != 0\n \t\t  && (TREE_CODE (type) == RECORD_TYPE\n \t\t      || TREE_CODE (type) == UNION_TYPE\n@@ -3938,7 +3938,7 @@ function_arg (cum, mode, type, named)\n \n       /* Drops through.  */\n     case BLKmode:\n-      if (type != NULL_TREE && TYPE_ALIGN (type) > BITS_PER_WORD\n+      if (type != NULL_TREE && TYPE_ALIGN (type) > (unsigned) BITS_PER_WORD\n \t  && ! TARGET_64BIT && mips_abi != ABI_EABI)\n \tcum->arg_words += (cum->arg_words & 1);\n       regbase = GP_ARG_FIRST;\n@@ -3957,7 +3957,7 @@ function_arg (cum, mode, type, named)\n       regbase = GP_ARG_FIRST;\n     }\n \n-  if (*arg_words >= MAX_ARGS_IN_REGISTERS)\n+  if (*arg_words >= (unsigned) MAX_ARGS_IN_REGISTERS)\n     {\n       if (TARGET_DEBUG_E_MODE)\n \tfprintf (stderr, \"<stack>%s\\n\", struct_p ? \", [struct]\" : \"\");\n@@ -4007,7 +4007,7 @@ function_arg (cum, mode, type, named)\n \n \t      chunks\n \t\t= tree_low_cst (TYPE_SIZE_UNIT (type), 1) / UNITS_PER_WORD;\n-\t      if (chunks + *arg_words + bias > MAX_ARGS_IN_REGISTERS)\n+\t      if (chunks + *arg_words + bias > (unsigned) MAX_ARGS_IN_REGISTERS)\n \t\tchunks = MAX_ARGS_IN_REGISTERS - *arg_words - bias;\n \n \t      /* assign_parms checks the mode of ENTRY_PARM, so we must\n@@ -4110,7 +4110,7 @@ function_arg_partial_nregs (cum, mode, type, named)\n   if ((mode == BLKmode\n        || GET_MODE_CLASS (mode) != MODE_COMPLEX_INT\n        || GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)\n-      && cum->arg_words < MAX_ARGS_IN_REGISTERS\n+      && cum->arg_words < (unsigned) MAX_ARGS_IN_REGISTERS\n       && mips_abi != ABI_EABI)\n     {\n       int words;\n@@ -4120,7 +4120,7 @@ function_arg_partial_nregs (cum, mode, type, named)\n       else\n \twords = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n \n-      if (words + cum->arg_words <= MAX_ARGS_IN_REGISTERS)\n+      if (words + cum->arg_words <= (unsigned) MAX_ARGS_IN_REGISTERS)\n \treturn 0;\t\t/* structure fits in registers */\n \n       if (TARGET_DEBUG_E_MODE)\n@@ -4130,7 +4130,7 @@ function_arg_partial_nregs (cum, mode, type, named)\n       return MAX_ARGS_IN_REGISTERS - cum->arg_words;\n     }\n \n-  else if (mode == DImode && cum->arg_words == MAX_ARGS_IN_REGISTERS-1\n+  else if (mode == DImode && cum->arg_words == MAX_ARGS_IN_REGISTERS - 1U\n \t   && ! TARGET_64BIT && mips_abi != ABI_EABI)\n     {\n       if (TARGET_DEBUG_E_MODE)\n@@ -4638,7 +4638,7 @@ override_options ()\n      user. */\n #ifdef TARGET_DEFAULT\n   if (TARGET_SINGLE_FLOAT && TARGET_SOFT_FLOAT)\n-    target_flags &= ~(TARGET_DEFAULT&(MASK_SOFT_FLOAT|MASK_SINGLE_FLOAT));\n+    target_flags &= ~((TARGET_DEFAULT) & (MASK_SOFT_FLOAT | MASK_SINGLE_FLOAT));\n #endif\n \n   /* Get the architectural level.  */\n@@ -4755,10 +4755,10 @@ override_options ()\n     mips_cpu_string = MIPS_CPU_STRING_DEFAULT;\n #endif\n \n-  /* Identify the processor type */\n+  /* Identify the processor type.  */\n   if (mips_cpu_string == 0\n-      || !strcmp (mips_cpu_string, \"default\")\n-      || !strcmp (mips_cpu_string, \"DEFAULT\"))\n+      || ! strcmp (mips_cpu_string, \"default\")\n+      || ! strcmp (mips_cpu_string, \"DEFAULT\"))\n     {\n       switch (mips_isa)\n \t{\n@@ -4780,7 +4780,6 @@ override_options ()\n \t  break;\n \t}\n     }\n-\n   else\n     {\n       const char *p = mips_cpu_string;\n@@ -4795,7 +4794,7 @@ override_options ()\n \tp++;\n \n       /* Since there is no difference between a R2000 and R3000 in\n-\t terms of the scheduler, we collapse them into just an R3000. */\n+\t terms of the scheduler, we collapse them into just an R3000.  */\n \n       mips_cpu = PROCESSOR_DEFAULT;\n       switch (*p)\n@@ -6419,7 +6418,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t  && GET_MODE (base_reg_rtx) == SImode)\n \t\t{\n \t\t  insn = emit_move_insn (base_reg_rtx,\n-\t\t\t\t\t GEN_INT (gp_offset & 0xffff0000));\n+\t\t\t\t\t GEN_INT (gp_offset & 0xffff0000U));\n \t\t  if (store_p)\n \t\t    RTX_FRAME_RELATED_P (insn) = 1;\n \t\t  insn\n@@ -6637,7 +6636,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t  && GET_MODE (base_reg_rtx) == SImode)\n \t\t{\n \t\t  insn = emit_move_insn (base_reg_rtx,\n-\t\t\t\t\t GEN_INT (fp_offset & 0xffff0000));\n+\t\t\t\t\t GEN_INT (fp_offset & 0xffff0000U));\n \t\t  if (store_p)\n \t\t    RTX_FRAME_RELATED_P (insn) = 1;\n \t\t  insn = emit_insn (gen_iorsi3 (base_reg_rtx, base_reg_rtx,\n@@ -6839,9 +6838,9 @@ function_prologue (file, size)\n \t  dest = SET_DEST (set);\n \t  if (GET_CODE (dest) != MEM)\n \t    continue;\n-\t  if (GET_MODE_SIZE (GET_MODE (dest)) == UNITS_PER_WORD)\n+\t  if (GET_MODE_SIZE (GET_MODE (dest)) == (unsigned) UNITS_PER_WORD)\n \t    ;\n-\t  else if (GET_MODE_SIZE (GET_MODE (dest)) == 2 * UNITS_PER_WORD\n+\t  else if (GET_MODE_SIZE (GET_MODE (dest)) == 2U * UNITS_PER_WORD\n \t\t   && REGNO (src) < GP_REG_FIRST + 7)\n \t    ;\n \t  else\n@@ -6851,11 +6850,12 @@ function_prologue (file, size)\n \t  if (GET_CODE (base) != REG\n \t      || GET_CODE (offset) != CONST_INT)\n \t    continue;\n-\t  if (REGNO (base) == STACK_POINTER_REGNUM\n-\t      && INTVAL (offset) == tsize + (REGNO (src) - 4) * UNITS_PER_WORD)\n+\t  if (REGNO (base) == (unsigned) STACK_POINTER_REGNUM\n+\t      && (unsigned HOST_WIDE_INT) INTVAL (offset)\n+\t      == tsize + (REGNO (src) - 4) * UNITS_PER_WORD)\n \t    ;\n-\t  else if (REGNO (base) == HARD_FRAME_POINTER_REGNUM\n-\t\t   && (INTVAL (offset)\n+\t  else if (REGNO (base) == (unsigned) HARD_FRAME_POINTER_REGNUM\n+\t\t   && ((unsigned HOST_WIDE_INT) INTVAL (offset)\n \t\t       == (tsize\n \t\t\t   + (REGNO (src) - 4) * UNITS_PER_WORD\n \t\t\t   - current_function_outgoing_args_size)))\n@@ -6966,7 +6966,7 @@ mips_expand_prologue ()\n      of the first argument in the variable part of the argument list,\n      otherwise GP_ARG_LAST+1.  Note also if the last argument is \n      the varargs special argument, and treat it as part of the\n-     variable arguments. \n+     variable arguments.\n      \n      This is only needed if store_args_on_stack is true. */\n \n@@ -7179,7 +7179,7 @@ mips_expand_prologue ()\n \t\t  && GET_MODE (tmp_rtx) == SImode)\n \t\t{\n \t\t  insn = emit_move_insn (tmp_rtx,\n-\t\t\t\t\t GEN_INT (tsize & 0xffff0000));\n+\t\t\t\t\t GEN_INT (tsize & 0xffff0000U));\n \t\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t\t  insn = emit_insn (gen_iorsi3 (tmp_rtx, tmp_rtx,\n \t\t\t\t\t\tGEN_INT (tsize & 0x0000ffff)));\n@@ -7298,7 +7298,7 @@ mips_expand_prologue ()\n /* Do any necessary cleanup after a function to restore stack, frame,\n    and regs. */\n \n-#define RA_MASK ((long) 0x80000000)\t/* 1 << 31 */\n+#define RA_MASK ((unsigned long) 0x80000000U)\t/* 1 << 31 */\n #define PIC_OFFSET_TABLE_MASK (1 << (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n \n void\n@@ -7580,7 +7580,7 @@ mips_select_rtx_section (mode, x)\n       /* For hosted applications, always put constants in small data if\n \t possible, as this gives the best performance.  */\n      \n-      if (GET_MODE_SIZE (mode) <= mips_section_threshold\n+      if (GET_MODE_SIZE (mode) <= (unsigned) mips_section_threshold\n \t  && mips_section_threshold > 0)\n \tSMALL_DATA_SECTION ();\n       else if (flag_pic && symbolic_expression_p (x))\n@@ -7791,16 +7791,15 @@ function_arg_pass_by_reference (cum, mode, type, named)\n      here hopefully is not relevant to mips_va_arg.  */\n   if (cum && MUST_PASS_IN_STACK (mode, type))\n      {\n-        /* Don't pass the actual CUM to FUNCTION_ARG, because we would \n-           get double copies of any offsets generated for small structs \n-           passed in registers. */\n-        CUMULATIVE_ARGS temp;\n-        temp = *cum;\n-        if (FUNCTION_ARG (temp, mode, type, named) != 0)\n-           return 1;\n+       /* Don't pass the actual CUM to FUNCTION_ARG, because we would \n+\t  get double copies of any offsets generated for small structs \n+\t  passed in registers. */\n+       CUMULATIVE_ARGS temp;\n+       temp = *cum;\n+       if (FUNCTION_ARG (temp, mode, type, named) != 0)\n+\t return 1;\n      }\n \n-\n   /* Otherwise, we only do this if EABI is selected.  */\n   if (mips_abi != ABI_EABI)\n     return 0;\n@@ -8145,7 +8144,10 @@ mips16_constant (x, mode, addr, addend)\n          knows how to handle this.  We can always accept a string\n          constant, which is the other case in which SYMBOL_REF_FLAG\n          will be set.  */\n-      if (! addr && ! addend && SYMBOL_REF_FLAG (x) && mode == Pmode)\n+      if (! addr\n+\t  && ! addend\n+\t  && SYMBOL_REF_FLAG (x)\n+\t  && mode == (enum machine_mode) Pmode)\n \treturn 1;\n \n       /* We can accept a string constant, which will have\n@@ -8716,14 +8718,14 @@ mips16_optimize_gp (first)\n \t  && GET_CODE (XEXP (SET_SRC (set), 0)) == REG\n \t  && REGNO (XEXP (SET_SRC (set), 0)) == GP_REG_FIRST + 28\n \t  && GET_CODE (SET_DEST (set)) == REG\n-\t  && GET_MODE (SET_DEST (set)) == Pmode)\n+\t  && GET_MODE (SET_DEST (set)) == (unsigned) Pmode)\n \tgpcopy = SET_DEST (set);\n       else if (slot == NULL_RTX\n \t       && gpcopy != NULL_RTX\n \t       && GET_CODE (SET_DEST (set)) == MEM\n \t       && GET_CODE (SET_SRC (set)) == REG\n \t       && REGNO (SET_SRC (set)) == REGNO (gpcopy)\n-\t       && GET_MODE (SET_DEST (set)) == Pmode)\n+\t       && GET_MODE (SET_DEST (set)) == (unsigned) Pmode)\n \t{\n \t  rtx base, offset;\n \n@@ -8740,7 +8742,7 @@ mips16_optimize_gp (first)\n \t       && reg_overlap_mentioned_p (SET_DEST (set), gpcopy)\n \t       && (GET_CODE (SET_DEST (set)) != REG\n \t\t   || REGNO (SET_DEST (set)) != REGNO (gpcopy)\n-\t\t   || GET_MODE (SET_DEST (set)) != Pmode\n+\t\t   || GET_MODE (SET_DEST (set)) != (unsigned) Pmode\n \t\t   || ((GET_CODE (SET_SRC (set)) != CONST\n \t\t\t|| GET_CODE (XEXP (SET_SRC (set), 0)) != REG\n \t\t\t|| (REGNO (XEXP (SET_SRC (set), 0))\n@@ -8859,7 +8861,7 @@ mips16_optimize_gp (first)\n \n       set = PATTERN (insn);\n       if (GET_CODE (set) != SET\n-\t  || GET_MODE (SET_DEST (set)) != Pmode)\n+\t  || GET_MODE (SET_DEST (set)) != (unsigned) Pmode)\n \tcontinue;\n \n       if (GET_CODE (SET_DEST (set)) == MEM"}]}