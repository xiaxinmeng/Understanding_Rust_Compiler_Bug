{"sha": "07faf2d6cd7cc39b86bd8be098ad85dbfb67d565", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdmYWYyZDZjZDdjYzM5Yjg2YmQ4YmUwOThhZDg1ZGJmYjY3ZDU2NQ==", "commit": {"author": {"name": "Stephane Carrez", "email": "stcarrez@nerim.fr", "date": "2003-03-31T20:28:40Z"}, "committer": {"name": "Stephane Carrez", "email": "ciceron@gcc.gnu.org", "date": "2003-03-31T20:28:40Z"}, "message": "m68hc11.c (expand_prologue): For an interrupt handler save the soft registers after the frame pointer so...\n\n\t* config/m68hc11/m68hc11.c (expand_prologue): For an interrupt handler\n\tsave the soft registers after the frame pointer so that gdb can unwind\n\tthe frame more easily.\n\t(expand_epilogue): Likewise in opposite order; allow to use X register\n\tas scratch if the return value is by reference.\n\nFrom-SVN: r65104", "tree": {"sha": "06ec6b8c8cc9c7c03b4dd72db5c7b90b77f2f6d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06ec6b8c8cc9c7c03b4dd72db5c7b90b77f2f6d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07faf2d6cd7cc39b86bd8be098ad85dbfb67d565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07faf2d6cd7cc39b86bd8be098ad85dbfb67d565", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07faf2d6cd7cc39b86bd8be098ad85dbfb67d565", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07faf2d6cd7cc39b86bd8be098ad85dbfb67d565/comments", "author": null, "committer": null, "parents": [{"sha": "adff28c38d207dc3a6007b81380407de0b3def57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adff28c38d207dc3a6007b81380407de0b3def57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adff28c38d207dc3a6007b81380407de0b3def57"}], "stats": {"total": 26, "additions": 17, "deletions": 9}, "files": [{"sha": "57283ce89ce12fd91b963fd7679eacbd40a9762e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07faf2d6cd7cc39b86bd8be098ad85dbfb67d565/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07faf2d6cd7cc39b86bd8be098ad85dbfb67d565/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07faf2d6cd7cc39b86bd8be098ad85dbfb67d565", "patch": "@@ -1,3 +1,11 @@\n+2003-03-31  Stephane Carrez  <stcarrez@nerim.fr>\n+\n+\t* config/m68hc11/m68hc11.c (expand_prologue): For an interrupt handler\n+\tsave the soft registers after the frame pointer so that gdb can unwind\n+\tthe frame more easily.\n+\t(expand_epilogue): Likewise in opposite order; allow to use X register\n+\tas scratch if the return value is by reference.\n+\n 2003-03-31  Jason Merrill  <jason@redhat.com>\n \n \tPR java/10145"}, {"sha": "0e8f36495b2dfc67b963cd62616180d50f5f09f4", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07faf2d6cd7cc39b86bd8be098ad85dbfb67d565/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07faf2d6cd7cc39b86bd8be098ad85dbfb67d565/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=07faf2d6cd7cc39b86bd8be098ad85dbfb67d565", "patch": "@@ -1683,6 +1683,10 @@ expand_prologue ()\n   else\n     scratch = ix_reg;\n \n+  /* Save current stack frame.  */\n+  if (frame_pointer_needed)\n+    emit_move_after_reload (stack_push_word, hard_frame_pointer_rtx, scratch);\n+\n   /* For an interrupt handler, we must preserve _.tmp, _.z and _.xy.\n      Other soft registers in page0 need not to be saved because they\n      will be restored by C functions.  For a trap handler, we don't\n@@ -1697,10 +1701,6 @@ expand_prologue ()\n \t\t\t      scratch);\n     }\n \n-  /* Save current stack frame.  */\n-  if (frame_pointer_needed)\n-    emit_move_after_reload (stack_push_word, hard_frame_pointer_rtx, scratch);\n-\n   /* Allocate local variables.  */\n   if (TARGET_M6812 && (size > 4 || size == 3))\n     {\n@@ -1774,7 +1774,7 @@ expand_epilogue ()\n   else\n     return_size = GET_MODE_SIZE (GET_MODE (current_function_return_rtx));\n \n-  if (return_size > HARD_REG_SIZE)\n+  if (return_size > HARD_REG_SIZE && return_size <= 2 * HARD_REG_SIZE)\n     scratch = iy_reg;\n   else\n     scratch = ix_reg;\n@@ -1821,10 +1821,6 @@ expand_epilogue ()\n \t\t\t       stack_pointer_rtx, GEN_INT (1)));\n     }\n \n-  /* Restore previous frame pointer.  */\n-  if (frame_pointer_needed)\n-    emit_move_after_reload (hard_frame_pointer_rtx, stack_pop_word, scratch);\n-\n   /* For an interrupt handler, restore ZTMP, ZREG and XYREG.  */\n   if (current_function_interrupt)\n     {\n@@ -1835,6 +1831,10 @@ expand_epilogue ()\n       emit_move_after_reload (m68hc11_soft_tmp_reg, stack_pop_word, scratch);\n     }\n \n+  /* Restore previous frame pointer.  */\n+  if (frame_pointer_needed)\n+    emit_move_after_reload (hard_frame_pointer_rtx, stack_pop_word, scratch);\n+\n   /* If the trap handler returns some value, copy the value\n      in D, X onto the stack so that the rti will pop the return value\n      correctly.  */"}]}