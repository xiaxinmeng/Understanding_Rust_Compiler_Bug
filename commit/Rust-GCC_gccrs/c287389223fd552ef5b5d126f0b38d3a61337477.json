{"sha": "c287389223fd552ef5b5d126f0b38d3a61337477", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI4NzM4OTIyM2ZkNTUyZWY1YjVkMTI2ZjBiMzhkM2E2MTMzNzQ3Nw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-01-25T12:30:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-01-25T12:30:41Z"}, "message": "re PR target/69264 (ICE building spidermonkey -mcpu=970 -maltivec -O3: rs6000_builtin_vectorization_cost, at config/rs6000/rs6000.c:4350)\n\n2017-01-25  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/69264\n\t* target.def (vector_alignment_reachable): Improve documentation.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.c (default_builtin_vector_alignment_reachable): Simplify\n\tand add a comment.\n\t* tree-vect-data-refs.c (vect_supportable_dr_alignment): Revert\n\tearlier changes with respect to TYPE_USER_ALIGN.\n\t(vector_alignment_reachable_p): Likewise.  Improve dumping.\n\n\t* g++.dg/torture/pr69264.C: New testcase.\n\nFrom-SVN: r244897", "tree": {"sha": "08b96969ab8ba3ee47ab40747bc7b01a1188b120", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08b96969ab8ba3ee47ab40747bc7b01a1188b120"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c287389223fd552ef5b5d126f0b38d3a61337477", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c287389223fd552ef5b5d126f0b38d3a61337477", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c287389223fd552ef5b5d126f0b38d3a61337477", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c287389223fd552ef5b5d126f0b38d3a61337477/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b3f1c7e908c2505e52bd090a4b40346daa4f8851", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3f1c7e908c2505e52bd090a4b40346daa4f8851", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3f1c7e908c2505e52bd090a4b40346daa4f8851"}], "stats": {"total": 140, "additions": 111, "deletions": 29}, "files": [{"sha": "7e0b4c66650e39c82a2841de2bfa48af196c68b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c287389223fd552ef5b5d126f0b38d3a61337477/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c287389223fd552ef5b5d126f0b38d3a61337477/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c287389223fd552ef5b5d126f0b38d3a61337477", "patch": "@@ -1,3 +1,14 @@\n+2017-01-25  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/69264\n+\t* target.def (vector_alignment_reachable): Improve documentation.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.c (default_builtin_vector_alignment_reachable): Simplify\n+\tand add a comment.\n+\t* tree-vect-data-refs.c (vect_supportable_dr_alignment): Revert\n+\tearlier changes with respect to TYPE_USER_ALIGN.\n+\t(vector_alignment_reachable_p): Likewise.  Improve dumping.\n+\n 2016-01-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR target/79145"}, {"sha": "909589c373b9cce6cfce2f15bab37226c3ab0320", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c287389223fd552ef5b5d126f0b38d3a61337477/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c287389223fd552ef5b5d126f0b38d3a61337477/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=c287389223fd552ef5b5d126f0b38d3a61337477", "patch": "@@ -5745,7 +5745,7 @@ misalignment value (@var{misalign}).\n @end deftypefn\n \n @deftypefn {Target Hook} bool TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE (const_tree @var{type}, bool @var{is_packed})\n-Return true if vector alignment is reachable (by peeling N iterations) for the given type.\n+Return true if vector alignment is reachable (by peeling N iterations) for the given scalar type @var{type}.  @var{is_packed} is false if the scalar access using @var{type} is known to be naturally aligned.\n @end deftypefn\n \n @deftypefn {Target Hook} bool TARGET_VECTORIZE_VEC_PERM_CONST_OK (machine_mode, const unsigned char *@var{sel})"}, {"sha": "7308da16cdba033859b5b520d2b0063a3420d69c", "filename": "gcc/target.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c287389223fd552ef5b5d126f0b38d3a61337477/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c287389223fd552ef5b5d126f0b38d3a61337477/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=c287389223fd552ef5b5d126f0b38d3a61337477", "patch": "@@ -1801,10 +1801,10 @@ misalignment value (@var{misalign}).\",\n  default_builtin_vectorization_cost)\n \n /* Return true if vector alignment is reachable (by peeling N\n-   iterations) for the given type.  */\n+   iterations) for the given scalar type.  */\n DEFHOOK\n (vector_alignment_reachable,\n- \"Return true if vector alignment is reachable (by peeling N iterations) for the given type.\",\n+ \"Return true if vector alignment is reachable (by peeling N iterations) for the given scalar type @var{type}.  @var{is_packed} is false if the scalar access using @var{type} is known to be naturally aligned.\",\n  bool, (const_tree type, bool is_packed),\n  default_builtin_vector_alignment_reachable)\n "}, {"sha": "1cdec068ed87456dc636e22ab0e187cd2bd55040", "filename": "gcc/targhooks.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c287389223fd552ef5b5d126f0b38d3a61337477/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c287389223fd552ef5b5d126f0b38d3a61337477/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=c287389223fd552ef5b5d126f0b38d3a61337477", "patch": "@@ -1127,20 +1127,12 @@ default_vector_alignment (const_tree type)\n   return align;\n }\n \n+/* By default assume vectors of element TYPE require a multiple of the natural\n+   alignment of TYPE.  TYPE is naturally aligned if IS_PACKED is false.  */\n bool\n-default_builtin_vector_alignment_reachable (const_tree type, bool is_packed)\n+default_builtin_vector_alignment_reachable (const_tree /*type*/, bool is_packed)\n {\n-  if (is_packed)\n-    return false;\n-\n-  /* Assuming that types whose size is > pointer-size are not guaranteed to be\n-     naturally aligned.  */\n-  if (tree_int_cst_compare (TYPE_SIZE (type), bitsize_int (POINTER_SIZE)) > 0)\n-    return false;\n-\n-  /* Assuming that types whose size is <= pointer-size\n-     are naturally aligned.  */\n-  return true;\n+  return ! is_packed;\n }\n \n /* By default, assume that a target supports any factor of misalignment"}, {"sha": "43e18fea091a4195ee7d9974990bb852b39669ba", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c287389223fd552ef5b5d126f0b38d3a61337477/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c287389223fd552ef5b5d126f0b38d3a61337477/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c287389223fd552ef5b5d126f0b38d3a61337477", "patch": "@@ -1,3 +1,8 @@\n+2017-01-25  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/69264\n+\t* g++.dg/torture/pr69264.C: New testcase.\n+\n 2016-01-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR target/79145"}, {"sha": "4375380675802dcd2340eb4843cfdf9e0e11bbfe", "filename": "gcc/testsuite/g++.dg/torture/pr69264.C", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c287389223fd552ef5b5d126f0b38d3a61337477/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr69264.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c287389223fd552ef5b5d126f0b38d3a61337477/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr69264.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr69264.C?ref=c287389223fd552ef5b5d126f0b38d3a61337477", "patch": "@@ -0,0 +1,81 @@\n+// { dg-do compile }\n+// { dg-additional-options \"-mcpu=970 -maltivec\" { target powerpc*-*-* } }\n+\n+typedef union {\n+    long int asBits;\n+} jsval_layout;\n+static jsval_layout STRING_TO_JSVAL_IMPL() {}\n+\n+typedef __attribute__ ((aligned(sizeof (long int)))) long int jsval;\n+class Value {\n+public:\n+    void setString() {\n+\tdata = STRING_TO_JSVAL_IMPL();\n+    }\n+    jsval_layout data;\n+} __attribute__ ((aligned(8)));\n+\n+static Value StringValue()\n+{\n+  Value v;\n+  v.setString();\n+  return v;\n+}\n+\n+static const jsval & Jsvalify(const Value & v)\n+{\n+  return (const jsval &)v;\n+}\n+\n+static Value *Valueify(jsval *v)\n+{\n+  return (Value *) v;\n+}\n+\n+struct JSObject {\n+    void getQNameLocalName();\n+};\n+static Value IdToValue(int id)\n+{\n+  if (id)\n+    return StringValue();\n+}\n+\n+static jsval IdToJsval(int id)\n+{\n+  return Jsvalify(IdToValue(id));\n+}\n+\n+class AutoGCRooter;\n+struct JSContext {\n+    AutoGCRooter *autoGCRooters;\n+};\n+class AutoGCRooter {\n+public:\n+    AutoGCRooter(JSContext *cx) {}\n+};\n+class AutoArrayRooter:AutoGCRooter {\n+public:\n+    AutoArrayRooter(JSContext *cx, Value *vec):AutoGCRooter(cx)\n+    {\n+      array = vec;\n+      cx->autoGCRooters = this;\n+    }\n+    Value *array;\n+};\n+\n+static void PutProperty(JSContext *cx, int id, jsval *vp)\n+{\n+  JSObject *nameobj;\n+  jsval roots[3];\n+  roots[1] = IdToJsval(id);\n+  roots[2] = *vp;\n+  AutoArrayRooter tvr(cx, Valueify(roots));\n+  nameobj->getQNameLocalName();\n+}\n+\n+void xml_defineProperty(JSContext *cx, int id, const Value *v)\n+{\n+  jsval tmp = Jsvalify(*v);\n+  PutProperty(cx, id, &tmp);\n+}"}, {"sha": "33a32b818e90f90a8ff1ca066fd0cfdff6c85f70", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c287389223fd552ef5b5d126f0b38d3a61337477/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c287389223fd552ef5b5d126f0b38d3a61337477/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=c287389223fd552ef5b5d126f0b38d3a61337477", "patch": "@@ -1098,12 +1098,9 @@ vector_alignment_reachable_p (struct data_reference *dr)\n       bool is_packed = not_size_aligned (DR_REF (dr));\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t                 \"Unknown misalignment, is_packed = %d\\n\",is_packed);\n-      if ((TYPE_USER_ALIGN (type) && !is_packed)\n-\t  || targetm.vectorize.vector_alignment_reachable (type, is_packed))\n-\treturn true;\n-      else\n-\treturn false;\n+\t                 \"Unknown misalignment, %snaturally aligned\\n\",\n+\t\t\t is_packed ? \"not \" : \"\");\n+      return targetm.vectorize.vector_alignment_reachable (type, is_packed);\n     }\n \n   return true;\n@@ -6153,10 +6150,8 @@ vect_supportable_dr_alignment (struct data_reference *dr,\n       if (!known_alignment_for_access_p (dr))\n \tis_packed = not_size_aligned (DR_REF (dr));\n \n-      if ((TYPE_USER_ALIGN (type) && !is_packed)\n-\t  || targetm.vectorize.\n-\t       support_vector_misalignment (mode, type,\n-\t\t\t\t\t    DR_MISALIGNMENT (dr), is_packed))\n+      if (targetm.vectorize.support_vector_misalignment\n+\t    (mode, type, DR_MISALIGNMENT (dr), is_packed))\n \t/* Can't software pipeline the loads, but can at least do them.  */\n \treturn dr_unaligned_supported;\n     }\n@@ -6168,10 +6163,8 @@ vect_supportable_dr_alignment (struct data_reference *dr,\n       if (!known_alignment_for_access_p (dr))\n \tis_packed = not_size_aligned (DR_REF (dr));\n \n-     if ((TYPE_USER_ALIGN (type) && !is_packed)\n-\t || targetm.vectorize.\n-\t      support_vector_misalignment (mode, type,\n-\t\t\t\t\t   DR_MISALIGNMENT (dr), is_packed))\n+     if (targetm.vectorize.support_vector_misalignment\n+\t   (mode, type, DR_MISALIGNMENT (dr), is_packed))\n        return dr_unaligned_supported;\n     }\n "}]}