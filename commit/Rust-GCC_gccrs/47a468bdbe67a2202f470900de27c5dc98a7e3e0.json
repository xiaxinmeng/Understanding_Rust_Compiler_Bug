{"sha": "47a468bdbe67a2202f470900de27c5dc98a7e3e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdhNDY4YmRiZTY3YTIyMDJmNDcwOTAwZGUyN2M1ZGM5OGE3ZTNlMA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-04-23T09:55:33Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-04-23T09:55:33Z"}, "message": "Fix std::variant regression caused by never-valueless optimization\n\nA regression was introduced by the recent changes to provide the strong\nexception safety guarantee for \"never valueless\" types that have O(1),\nnon-throwing move assignment. The problematic code is:\n\n  else if constexpr (__detail::__variant::_Never_valueless_alt<type>())\n    {\n      // This construction might throw:\n      variant __tmp(in_place_index<_Np>, __il,\n                    std::forward<_Args>(__args)...);\n      // But _Never_valueless_alt<type> means this won't:\n      *this = std::move(__tmp);\n    }\n\nWhen the variant is not assignable, the assignment is ill-formed, so\nshould not be attempted. When the variant has a copy assignment operator\nbut not a move assignment operator, the assignment performs a copy\nassignment and that could throw, so should not be attempted.\n\nThe solution is to only take that branch when the variant has a move\nassignment operator, which is determined by the _Traits::_S_move_assign\nconstant. When that is false the strong exception safety guarantee is\nnot possible, and so the __never_valueless function should also depend\non _S_move_assign.\n\nWhile testing the fixes for this I noticed that the partial\nspecialization _Never_valueless_alt<basic_string<C,T,A>> incorrectly\nassumed that is_nothrow_move_constructible<basic_string<C,T,A>> is\nalways true, but that's wrong for fully-dynamic COW strings. Fix the\npartial specialization, and improve the comment describing\n_Never_valueless_alt to be clear it depends on move construction as well\nas move assignment.\n\nFinally, I also observed that _Variant_storage<false, T...>::_M_valid()\nwas not taking advantage of the __never_valueless<T...>() function to\navoid a runtime check. Only the _Variant_storage<true, T...>::_M_valid()\nfunction was using __never_valueless. That is also fixed.\n\n\tPR libstdc++/87431\n\t* include/bits/basic_string.h (_Never_valueless_alt): Make partial\n\tspecialization also depend on is_nothrow_move_constructible.\n\t* include/std/variant (__detail::__variant::__never_valueless()):\n\tOnly true if the variant would have a move assignment operator.\n\t(__detail::__variant::_Variant_storage<false, T...>::_M_valid()):\n\tCheck __never_valueless<T...>().\n\t(variant::emplace): Only perform non-throwing move assignments\n\tfor never-valueless alternatives if the variant has a move assignment\n\toperator.\n\t* testsuite/20_util/variant/compile.cc: Check that never-valueless\n\ttypes can be emplaced into non-assignable variants.\n\t* testsuite/20_util/variant/run.cc: Check that never-valueless types\n\tdon't get copied when emplaced into non-assignable variants.\n\nFrom-SVN: r270502", "tree": {"sha": "c5618522eb97e1abea03c4452fb2b69c07e1a324", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5618522eb97e1abea03c4452fb2b69c07e1a324"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47a468bdbe67a2202f470900de27c5dc98a7e3e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a468bdbe67a2202f470900de27c5dc98a7e3e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47a468bdbe67a2202f470900de27c5dc98a7e3e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a468bdbe67a2202f470900de27c5dc98a7e3e0/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be46043e07689050ba4522e907db618d26fc1bb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be46043e07689050ba4522e907db618d26fc1bb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be46043e07689050ba4522e907db618d26fc1bb8"}], "stats": {"total": 89, "additions": 81, "deletions": 8}, "files": [{"sha": "0949c94ae198c13e9117a660bb107c0c66826b3e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a468bdbe67a2202f470900de27c5dc98a7e3e0/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a468bdbe67a2202f470900de27c5dc98a7e3e0/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=47a468bdbe67a2202f470900de27c5dc98a7e3e0", "patch": "@@ -1,5 +1,20 @@\n 2019-04-23  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tPR libstdc++/87431\n+\t* include/bits/basic_string.h (_Never_valueless_alt): Make partial\n+\tspecialization also depend on is_nothrow_move_constructible.\n+\t* include/std/variant (__detail::__variant::__never_valueless()):\n+\tOnly true if the variant would have a move assignment operator.\n+\t(__detail::__variant::_Variant_storage<false, T...>::_M_valid()):\n+\tCheck __never_valueless<T...>().\n+\t(variant::emplace): Only perform non-throwing move assignments\n+\tfor never-valueless alternatives if the variant has a move assignment\n+\toperator.\n+\t* testsuite/20_util/variant/compile.cc: Check that never-valueless\n+\ttypes can be emplaced into non-assignable variants.\n+\t* testsuite/20_util/variant/run.cc: Check that never-valueless types\n+\tdon't get copied when emplaced into non-assignable variants.\n+\n \t* include/std/variant (__detail::__variant::__ref_cast): Remove\n \tunused function.\n \t(__detail::__variant::_Uninitialized::_M_get)"}, {"sha": "922536965e34214d480929a652e8f306492a7276", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a468bdbe67a2202f470900de27c5dc98a7e3e0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a468bdbe67a2202f470900de27c5dc98a7e3e0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=47a468bdbe67a2202f470900de27c5dc98a7e3e0", "patch": "@@ -6849,10 +6849,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     template<typename> struct _Never_valueless_alt; // see <variant>\n \n     // Provide the strong exception-safety guarantee when emplacing a\n-    // basic_string into a variant, but only if move assignment cannot throw.\n+    // basic_string into a variant, but only if moving the string cannot throw.\n     template<typename _Tp, typename _Traits, typename _Alloc>\n       struct _Never_valueless_alt<std::basic_string<_Tp, _Traits, _Alloc>>\n-      : std::is_nothrow_move_assignable<std::basic_string<_Tp, _Traits, _Alloc>>\n+      : __and_<\n+\tis_nothrow_move_constructible<std::basic_string<_Tp, _Traits, _Alloc>>,\n+\tis_nothrow_move_assignable<std::basic_string<_Tp, _Traits, _Alloc>>\n+\t>::type\n       { };\n   }  // namespace __detail::__variant\n #endif // C++17"}, {"sha": "b71bb027f2bb265dc4c627a931e0af1bafaf6b06", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a468bdbe67a2202f470900de27c5dc98a7e3e0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a468bdbe67a2202f470900de27c5dc98a7e3e0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=47a468bdbe67a2202f470900de27c5dc98a7e3e0", "patch": "@@ -340,9 +340,9 @@ namespace __variant\n     { };\n \n   // Specialize _Never_valueless_alt for other types which have a\n-  // non-throwing and cheap move assignment operator, so that emplacing\n-  // the type will provide the strong exception-safety guarantee,\n-  // by creating and moving a temporary.\n+  // non-throwing and cheap move construction and move assignment operator,\n+  // so that emplacing the type will provide the strong exception-safety\n+  // guarantee, by creating and moving a temporary.\n   // Whether _Never_valueless_alt<T> is true or not affects the ABI of a\n   // variant using that alternative, so we can't change the value later!\n \n@@ -352,7 +352,8 @@ namespace __variant\n   template <typename... _Types>\n     constexpr bool __never_valueless()\n     {\n-      return (_Never_valueless_alt<_Types>::value && ...);\n+      return _Traits<_Types...>::_S_move_assign\n+\t&& (_Never_valueless_alt<_Types>::value && ...);\n     }\n \n   // Defines index and the dtor, possibly trivial.\n@@ -407,6 +408,8 @@ namespace __variant\n       constexpr bool\n       _M_valid() const noexcept\n       {\n+\tif constexpr (__never_valueless<_Types...>())\n+\t  return true;\n \treturn this->_M_index != __index_type(variant_npos);\n       }\n \n@@ -1428,7 +1431,8 @@ namespace __variant\n \t      this->_M_reset();\n \t      __variant_construct_by_index<_Np>(*this, __tmp);\n \t    }\n-\t  else if constexpr (__detail::__variant::_Never_valueless_alt<type>())\n+\t  else if constexpr (__detail::__variant::_Never_valueless_alt<type>()\n+\t      && _Traits::_S_move_assign)\n \t    {\n \t      // This construction might throw:\n \t      variant __tmp(in_place_index<_Np>,\n@@ -1474,7 +1478,8 @@ namespace __variant\n \t      __variant_construct_by_index<_Np>(*this, __il,\n \t\t  std::forward<_Args>(__args)...);\n \t    }\n-\t  else if constexpr (__detail::__variant::_Never_valueless_alt<type>())\n+\t  else if constexpr (__detail::__variant::_Never_valueless_alt<type>()\n+\t      && _Traits::_S_move_assign)\n \t    {\n \t      // This construction might throw:\n \t      variant __tmp(in_place_index<_Np>, __il,"}, {"sha": "afd593d2fef42c3dadd593eedc0a0e5a15cf5b04", "filename": "libstdc++-v3/testsuite/20_util/variant/compile.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a468bdbe67a2202f470900de27c5dc98a7e3e0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a468bdbe67a2202f470900de27c5dc98a7e3e0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc?ref=47a468bdbe67a2202f470900de27c5dc98a7e3e0", "patch": "@@ -479,6 +479,20 @@ void test_emplace()\n   static_assert(has_index_emplace<variant<int>, 0>(0));\n   static_assert(!has_type_emplace<variant<AllDeleted>, AllDeleted>(0));\n   static_assert(!has_index_emplace<variant<AllDeleted>, 0>(0));\n+  static_assert(has_type_emplace<variant<int, AllDeleted>, int>(0));\n+  static_assert(has_index_emplace<variant<int, AllDeleted>, 0>(0));\n+  static_assert(has_type_emplace<variant<int, vector<int>, AllDeleted>, vector<int>>(0));\n+  static_assert(has_index_emplace<variant<int, vector<int>, AllDeleted>, 1>(0));\n+\n+  // The above tests only check the emplace members are available for\n+  // overload resolution. The following odr-uses will instantiate them:\n+  variant<int, vector<int>, AllDeleted> v;\n+  v.emplace<0>(1);\n+  v.emplace<int>(1);\n+  v.emplace<1>(1, 1);\n+  v.emplace<vector<int>>(1, 1);\n+  v.emplace<1>({1, 2, 3, 4});\n+  v.emplace<vector<int>>({1, 2, 3, 4});\n }\n \n void test_triviality()"}, {"sha": "ec1e86805cda636c7b5d6b665765a8ddadeb432b", "filename": "libstdc++-v3/testsuite/20_util/variant/run.cc", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a468bdbe67a2202f470900de27c5dc98a7e3e0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Frun.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a468bdbe67a2202f470900de27c5dc98a7e3e0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Frun.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Frun.cc?ref=47a468bdbe67a2202f470900de27c5dc98a7e3e0", "patch": "@@ -23,6 +23,7 @@\n #include <vector>\n #include <unordered_set>\n #include <memory_resource>\n+#include <ext/throw_allocator.h>\n #include <testsuite_hooks.h>\n \n using namespace std;\n@@ -254,6 +255,41 @@ void emplace()\n     VERIFY(&v.emplace<0>({1,2,3}) == &std::get<0>(v));\n     VERIFY(&v.emplace<vector<int>>({1,2,3}) == &std::get<vector<int>>(v));\n   }\n+\n+  {\n+    // Ensure no copies of the vector are made, only moves.\n+    // See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=87431#c21\n+\n+    // static_assert(__detail::__variant::_Never_valueless_alt<vector<AlwaysThrow>>::value);\n+    variant<int, DeletedMoves, vector<AlwaysThrow>> v;\n+    v.emplace<2>(1);\n+    v.emplace<vector<AlwaysThrow>>(1);\n+    v.emplace<0>(0);\n+\n+    // To test the emplace(initializer_list<U>, Args&&...) members we\n+    // can't use AlwaysThrow because elements in an initialier_list\n+    // are always copied. Use throw_allocator instead.\n+    using Vector = vector<int, __gnu_cxx::throw_allocator_limit<int>>;\n+    // static_assert(__detail::__variant::_Never_valueless_alt<Vector>::value);\n+    variant<int, DeletedMoves, Vector> vv;\n+    Vector::allocator_type::set_limit(1);\n+    vv.emplace<2>(1, 1);\n+    Vector::allocator_type::set_limit(1);\n+    vv.emplace<Vector>(1, 1);\n+    Vector::allocator_type::set_limit(1);\n+    vv.emplace<0>(0);\n+    Vector::allocator_type::set_limit(1);\n+    vv.emplace<2>({1, 2, 3});\n+    Vector::allocator_type::set_limit(1);\n+    vv.emplace<Vector>({1, 2, 3, 4});\n+    try {\n+      Vector::allocator_type::set_limit(0);\n+      vv.emplace<2>(1, 1);\n+      VERIFY(false);\n+    } catch (__gnu_cxx::forced_error) {\n+    }\n+    VERIFY(vv.valueless_by_exception());\n+  }\n }\n \n void test_get()"}]}