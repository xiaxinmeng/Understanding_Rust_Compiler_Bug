{"sha": "8e1e41e7afc6a9cc022c724f99f488029f22a680", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUxZTQxZTdhZmM2YTljYzAyMmM3MjRmOTlmNDg4MDI5ZjIyYTY4MA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-03-06T20:15:38Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-03-06T20:15:38Z"}, "message": "re PR fortran/47850 (ICE in gfc_conv_array_initializer)\n\n2011-03-06  Paul Thomas  <pault@gcc.gnu.org>\n\t    Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/47850\n\t* expr.c (gfc_is_constant_expr): Only use gfc_constant_ac if\n\tthe expression has an iterator.  Otherwise, iterate through the\n\tarray, checking for constant expressions for each element.\n\n2011-03-06  Paul Thomas  <pault@gcc.gnu.org>\n\t    Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/47850\n\t* gfortran.dg/array_constructor_37.f90 : New test.\n\n\nCo-Authored-By: Jerry DeLisle <jvdelisle@gcc.gnu.org>\n\nFrom-SVN: r170720", "tree": {"sha": "e9edb9949d0537de89a1f09509893c31efd28885", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9edb9949d0537de89a1f09509893c31efd28885"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e1e41e7afc6a9cc022c724f99f488029f22a680", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e1e41e7afc6a9cc022c724f99f488029f22a680", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e1e41e7afc6a9cc022c724f99f488029f22a680", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e1e41e7afc6a9cc022c724f99f488029f22a680/comments", "author": null, "committer": null, "parents": [{"sha": "787a8c0feb104e6de4349c9485becd7292c2c9f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/787a8c0feb104e6de4349c9485becd7292c2c9f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/787a8c0feb104e6de4349c9485becd7292c2c9f7"}], "stats": {"total": 56, "additions": 52, "deletions": 4}, "files": [{"sha": "a479ef6721010788eadf9ee6d83bd3abf3cf69cb", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1e41e7afc6a9cc022c724f99f488029f22a680/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1e41e7afc6a9cc022c724f99f488029f22a680/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8e1e41e7afc6a9cc022c724f99f488029f22a680", "patch": "@@ -1,3 +1,11 @@\n+2011-03-06  Paul Thomas  <pault@gcc.gnu.org>\n+\t    Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/47850\n+\t* expr.c (gfc_is_constant_expr): Only use gfc_constant_ac if\n+\tthe expression has an iterator.  Otherwise, iterate through the\n+\tarray, checking for constant expressions for each element.\n+\n 2011-03-04  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR libfortran/47802"}, {"sha": "58b6036094a6268dae17ee00fca489913629b49d", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1e41e7afc6a9cc022c724f99f488029f22a680/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1e41e7afc6a9cc022c724f99f488029f22a680/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=8e1e41e7afc6a9cc022c724f99f488029f22a680", "patch": "@@ -937,16 +937,18 @@ gfc_is_constant_expr (gfc_expr *e)\n       return e->ref == NULL || (gfc_is_constant_expr (e->ref->u.ss.start)\n \t\t\t\t&& gfc_is_constant_expr (e->ref->u.ss.end));\n \n+    case EXPR_ARRAY:\n     case EXPR_STRUCTURE:\n-      for (c = gfc_constructor_first (e->value.constructor);\n-\t   c; c = gfc_constructor_next (c))\n+      c = gfc_constructor_first (e->value.constructor);\n+      if ((e->expr_type == EXPR_ARRAY) && c && c->iterator)\n+        return gfc_constant_ac (e);\n+\n+      for (; c; c = gfc_constructor_next (c))\n \tif (!gfc_is_constant_expr (c->expr))\n \t  return 0;\n \n       return 1;\n \n-    case EXPR_ARRAY:\n-      return gfc_constant_ac (e);\n \n     default:\n       gfc_internal_error (\"gfc_is_constant_expr(): Unknown expression type\");"}, {"sha": "60d0fae49f302231db7d8ad943eddb89a9a26efc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1e41e7afc6a9cc022c724f99f488029f22a680/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1e41e7afc6a9cc022c724f99f488029f22a680/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e1e41e7afc6a9cc022c724f99f488029f22a680", "patch": "@@ -1,3 +1,9 @@\n+2011-03-06  Paul Thomas  <pault@gcc.gnu.org>\n+\t    Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/47850\n+\t* gfortran.dg/array_constructor_37.f90 : New test.\n+\n 2011-03-05  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/abi/mangle39.C: ABI v5, not 6."}, {"sha": "5c66cce1cf585d12d56cb6159fb4d477913544e7", "filename": "gcc/testsuite/gfortran.dg/array_constructor_37.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1e41e7afc6a9cc022c724f99f488029f22a680/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_37.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1e41e7afc6a9cc022c724f99f488029f22a680/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_37.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_37.f90?ref=8e1e41e7afc6a9cc022c724f99f488029f22a680", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do compile }\n+! Check the fix for PR47850, in which the argument of ANY, below, was not\n+! simplified, thereby causing an ICE.\n+!\n+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org> but based on James van Buskirk's program in\n+! http://groups.google.com/group/comp.lang.fortran/browse_thread/thread/625faf82578e9af8\n+!\n+!\n+program Cindex\n+   implicit none\n+   integer,parameter :: SENSOR_CHANNEL(8) = &\n+      [10,12,17,20,22,30,33,34]\n+   integer,parameter :: NLTE_CHANNEL(3) = [20,22,34]\n+   integer,parameter :: N_NLTE_CHANNELS = size(NLTE_CHANNEL)\n+   integer,parameter :: N_CHANNELS = size(SENSOR_CHANNEL)\n+   integer i\n+   integer,parameter :: C_INDEX(8) = unpack( &\n+      vector = [(i,i=1,size(SENSOR_CHANNEL))], &\n+      mask = [(any(SENSOR_CHANNEL(i) == NLTE_CHANNEL), &\n+         i=lbound(SENSOR_CHANNEL,1),ubound(SENSOR_CHANNEL,1))], &\n+      field = 0)\n+   character(20) fmt\n+\n+   write(fmt,'(a,i0,a)') '(a,t19,',size(SENSOR_CHANNEL),'(i3:\",\"))'\n+   write(*,fmt) 'SENSOR_CHANNEL = ',SENSOR_CHANNEL\n+   write(fmt,'(a,i0,a)') '(a,t19,',size(NLTE_CHANNEL),'(i3:\",\"))'\n+   write(*,fmt) 'NLTE_CHANNEL = ',NLTE_CHANNEL\n+   write(*,'(a,t19,i3)') 'N_NLTE_CHANNELS = ',N_NLTE_CHANNELS\n+   write(*,'(a,t19,i3)') 'N_CHANNELS = ',N_CHANNELS\n+   write(fmt,'(a,i0,a)') '(a,t19,',size(C_INDEX),'(i3:\",\"))'\n+   write(*,fmt) 'C_INDEX = ',C_INDEX\n+end program Cindex"}]}