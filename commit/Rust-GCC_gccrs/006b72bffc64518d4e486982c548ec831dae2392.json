{"sha": "006b72bffc64518d4e486982c548ec831dae2392", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA2YjcyYmZmYzY0NTE4ZDRlNDg2OTgyYzU0OGVjODMxZGFlMjM5Mg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2011-11-27T10:09:15Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-11-27T10:09:15Z"}, "message": "hard-reg-set.h (target_hard_regs): Add x_accessible_reg_set and x_operand_reg_set.\n\ngcc/\n\t* hard-reg-set.h (target_hard_regs): Add x_accessible_reg_set\n\tand x_operand_reg_set.\n\t(accessible_reg_set, operand_reg_set): New macros.\n\t* reginfo.c (init_reg_sets): Initialize accessible_reg_set and\n\toperand_reg_set.\n\t(saved_accessible_reg_set, saved_operand_reg_set): New variables.\n\t(save_register_info): Save them.\n\t(restore_register_info): Restore them.\n\t(init_reg_sets_1): Limit operand_reg_set to accessible_reg_set.\n\tRemove NO_REGS registers from operand_reg_set.  Treat members\n\tof operand_reg_set as fixed.\n\t* recog.c (general_operand): Check operand_reg_set rather than\n\tNO_REGS.\n\t(register_operand, nonmemory_operand): Likewise.\n\t* varasm.c (make_decl_rtl): Always use DECL_MODE as the mode of\n\tregister variables.  Check accessible_reg_set and operand_reg_set.\n\t* config/mips/mips.c (mips_conditional_register_usage): Remove\n\tinaccessible register from accessible_reg_set, rather than just\n\tmaking them fixed.\n\ngcc/testsuite/\n\t* gcc.target/mips/mips.exp (mips-dg-options): Make -mno-dsp\n\timply -mno-dspr2.\n\t* gcc.target/mips/no-dsp-1.c: New test.\n\t* gcc.target/mips/soft-float-1.c: Likewise.\n\nFrom-SVN: r181760", "tree": {"sha": "550c92021f891ad0b45cc382f700d0d14027acd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/550c92021f891ad0b45cc382f700d0d14027acd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/006b72bffc64518d4e486982c548ec831dae2392", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/006b72bffc64518d4e486982c548ec831dae2392", "html_url": "https://github.com/Rust-GCC/gccrs/commit/006b72bffc64518d4e486982c548ec831dae2392", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/006b72bffc64518d4e486982c548ec831dae2392/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a58371f313034981ebdcdbd6e7604a41df281a00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a58371f313034981ebdcdbd6e7604a41df281a00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a58371f313034981ebdcdbd6e7604a41df281a00"}], "stats": {"total": 160, "additions": 117, "deletions": 43}, "files": [{"sha": "8fc34d64d95001f026dd2b3902ae817f5cb43ddb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006b72bffc64518d4e486982c548ec831dae2392/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006b72bffc64518d4e486982c548ec831dae2392/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=006b72bffc64518d4e486982c548ec831dae2392", "patch": "@@ -1,3 +1,25 @@\n+2011-11-27  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* hard-reg-set.h (target_hard_regs): Add x_accessible_reg_set\n+\tand x_operand_reg_set.\n+\t(accessible_reg_set, operand_reg_set): New macros.\n+\t* reginfo.c (init_reg_sets): Initialize accessible_reg_set and\n+\toperand_reg_set.\n+\t(saved_accessible_reg_set, saved_operand_reg_set): New variables.\n+\t(save_register_info): Save them.\n+\t(restore_register_info): Restore them.\n+\t(init_reg_sets_1): Limit operand_reg_set to accessible_reg_set.\n+\tRemove NO_REGS registers from operand_reg_set.  Treat members\n+\tof operand_reg_set as fixed.\n+\t* recog.c (general_operand): Check operand_reg_set rather than\n+\tNO_REGS.\n+\t(register_operand, nonmemory_operand): Likewise.\n+\t* varasm.c (make_decl_rtl): Always use DECL_MODE as the mode of\n+\tregister variables.  Check accessible_reg_set and operand_reg_set.\n+\t* config/mips/mips.c (mips_conditional_register_usage): Remove\n+\tinaccessible register from accessible_reg_set, rather than just\n+\tmaking them fixed.\n+\n 2011-11-27  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* config/pa/pa-linux.h (TARGET_GAS): Remove comment."}, {"sha": "ea971a91d9cd4bc39e8507b0b298fff8c333603d", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=006b72bffc64518d4e486982c548ec831dae2392", "patch": "@@ -15835,31 +15835,26 @@ mips_conditional_register_usage (void)\n       global_regs[CCDSP_PO_REGNUM] = 1;\n       global_regs[CCDSP_SC_REGNUM] = 1;\n     }\n-  else \n-    {\n-      int regno;\n+  else\n+    AND_COMPL_HARD_REG_SET (accessible_reg_set,\n+\t\t\t    reg_class_contents[(int) DSP_ACC_REGS]);\n \n-      for (regno = DSP_ACC_REG_FIRST; regno <= DSP_ACC_REG_LAST; regno++)\n-\tfixed_regs[regno] = call_used_regs[regno] = 1;\n-    }\n   if (!TARGET_HARD_FLOAT)\n     {\n-      int regno;\n-\n-      for (regno = FP_REG_FIRST; regno <= FP_REG_LAST; regno++)\n-\tfixed_regs[regno] = call_used_regs[regno] = 1;\n-      for (regno = ST_REG_FIRST; regno <= ST_REG_LAST; regno++)\n-\tfixed_regs[regno] = call_used_regs[regno] = 1;\n+      AND_COMPL_HARD_REG_SET (accessible_reg_set,\n+\t\t\t      reg_class_contents[(int) FP_REGS]);\n+      AND_COMPL_HARD_REG_SET (accessible_reg_set,\n+\t\t\t      reg_class_contents[(int) ST_REGS]);\n     }\n-  else if (! ISA_HAS_8CC)\n+  else if (!ISA_HAS_8CC)\n     {\n-      int regno;\n-\n       /* We only have a single condition-code register.  We implement\n \t this by fixing all the condition-code registers and generating\n \t RTL that refers directly to ST_REG_FIRST.  */\n-      for (regno = ST_REG_FIRST; regno <= ST_REG_LAST; regno++)\n-\tfixed_regs[regno] = call_used_regs[regno] = 1;\n+      AND_COMPL_HARD_REG_SET (accessible_reg_set,\n+\t\t\t      reg_class_contents[(int) ST_REGS]);\n+      SET_HARD_REG_BIT (accessible_reg_set, FPSW_REGNUM);\n+      fixed_regs[FPSW_REGNUM] = call_used_regs[FPSW_REGNUM] = 1;\n     }\n   /* In MIPS16 mode, we permit the $t temporary registers to be used\n      for reload.  We prohibit the unused $s registers, since they"}, {"sha": "9823a5b34410f5af6ff81d7ba69b34c115c6a64e", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=006b72bffc64518d4e486982c548ec831dae2392", "patch": "@@ -583,6 +583,13 @@ hard_reg_set_iter_next (hard_reg_set_iterator *iter, unsigned *regno)\n extern char global_regs[FIRST_PSEUDO_REGISTER];\n \n struct target_hard_regs {\n+  /* The set of registers that actually exist on the current target.  */\n+  HARD_REG_SET x_accessible_reg_set;\n+\n+  /* The set of registers that should be considered to be register\n+     operands.  It is a subset of x_accessible_reg_set.  */\n+  HARD_REG_SET x_operand_reg_set;\n+\n   /* Indexed by hard register number, contains 1 for registers\n      that are fixed use (stack pointer, pc, frame pointer, etc.;.\n      These are the registers that cannot be used to allocate\n@@ -659,6 +666,10 @@ extern struct target_hard_regs *this_target_hard_regs;\n #define this_target_hard_regs (&default_target_hard_regs)\n #endif\n \n+#define accessible_reg_set \\\n+  (this_target_hard_regs->x_accessible_reg_set)\n+#define operand_reg_set \\\n+  (this_target_hard_regs->x_operand_reg_set)\n #define fixed_regs \\\n   (this_target_hard_regs->x_fixed_regs)\n #define fixed_reg_set \\"}, {"sha": "19f00b176d7d689b1999f84404484a027b249537", "filename": "gcc/recog.c", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=006b72bffc64518d4e486982c548ec831dae2392", "patch": "@@ -925,10 +925,7 @@ next_insn_tests_no_inequality (rtx insn)\n    it has.\n \n    The main use of this function is as a predicate in match_operand\n-   expressions in the machine description.\n-\n-   For an explanation of this function's behavior for registers of\n-   class NO_REGS, see the comment for `register_operand'.  */\n+   expressions in the machine description.  */\n \n int\n general_operand (rtx op, enum machine_mode mode)\n@@ -998,9 +995,8 @@ general_operand (rtx op, enum machine_mode mode)\n     }\n \n   if (code == REG)\n-    /* A register whose class is NO_REGS is not a general operand.  */\n     return (REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t    || REGNO_REG_CLASS (REGNO (op)) != NO_REGS);\n+\t    || in_hard_reg_set_p (operand_reg_set, GET_MODE (op), REGNO (op)));\n \n   if (code == MEM)\n     {\n@@ -1033,15 +1029,7 @@ address_operand (rtx op, enum machine_mode mode)\n    If MODE is VOIDmode, accept a register in any mode.\n \n    The main use of this function is as a predicate in match_operand\n-   expressions in the machine description.\n-\n-   As a special exception, registers whose class is NO_REGS are\n-   not accepted by `register_operand'.  The reason for this change\n-   is to allow the representation of special architecture artifacts\n-   (such as a condition code register) without extending the rtl\n-   definitions.  Since registers of class NO_REGS cannot be used\n-   as registers in any case where register classes are examined,\n-   it is most consistent to keep this function from accepting them.  */\n+   expressions in the machine description.  */\n \n int\n register_operand (rtx op, enum machine_mode mode)\n@@ -1080,11 +1068,10 @@ register_operand (rtx op, enum machine_mode mode)\n       op = sub;\n     }\n \n-  /* We don't consider registers whose class is NO_REGS\n-     to be a register operand.  */\n   return (REG_P (op)\n \t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t      || REGNO_REG_CLASS (REGNO (op)) != NO_REGS));\n+\t      || in_hard_reg_set_p (operand_reg_set,\n+\t\t\t\t    GET_MODE (op), REGNO (op))));\n }\n \n /* Return 1 for a register in Pmode; ignore the tested mode.  */\n@@ -1203,11 +1190,10 @@ nonmemory_operand (rtx op, enum machine_mode mode)\n       op = SUBREG_REG (op);\n     }\n \n-  /* We don't consider registers whose class is NO_REGS\n-     to be a register operand.  */\n   return (REG_P (op)\n \t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t      || REGNO_REG_CLASS (REGNO (op)) != NO_REGS));\n+\t      || in_hard_reg_set_p (operand_reg_set,\n+\t\t\t\t    GET_MODE (op), REGNO (op))));\n }\n \n /* Return 1 if OP is a valid operand that stands for pushing a"}, {"sha": "f6f91a9975b61a462869ad8b4bb089f38b4106c7", "filename": "gcc/reginfo.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=006b72bffc64518d4e486982c548ec831dae2392", "patch": "@@ -192,6 +192,9 @@ init_reg_sets (void)\n   memcpy (reg_alloc_order, initial_reg_alloc_order, sizeof reg_alloc_order);\n #endif\n   memcpy (reg_names, initial_reg_names, sizeof reg_names);\n+\n+  SET_HARD_REG_SET (accessible_reg_set);\n+  SET_HARD_REG_SET (operand_reg_set);\n }\n \n /* Initialize may_move_cost and friends for mode M.  */\n@@ -292,6 +295,8 @@ static char saved_call_used_regs[FIRST_PSEUDO_REGISTER];\n static char saved_call_really_used_regs[FIRST_PSEUDO_REGISTER];\n #endif\n static const char *saved_reg_names[FIRST_PSEUDO_REGISTER];\n+static HARD_REG_SET saved_accessible_reg_set;\n+static HARD_REG_SET saved_operand_reg_set;\n \n /* Save the register information.  */\n void\n@@ -315,6 +320,8 @@ save_register_info (void)\n   /* And similarly for reg_names.  */\n   gcc_assert (sizeof reg_names == sizeof saved_reg_names);\n   memcpy (saved_reg_names, reg_names, sizeof reg_names);\n+  COPY_HARD_REG_SET (saved_accessible_reg_set, accessible_reg_set);\n+  COPY_HARD_REG_SET (saved_operand_reg_set, operand_reg_set);\n }\n \n /* Restore the register information.  */\n@@ -330,6 +337,8 @@ restore_register_info (void)\n #endif\n \n   memcpy (reg_names, saved_reg_names, sizeof reg_names);\n+  COPY_HARD_REG_SET (accessible_reg_set, saved_accessible_reg_set);\n+  COPY_HARD_REG_SET (operand_reg_set, saved_operand_reg_set);\n }\n \n /* After switches have been processed, which perhaps alter\n@@ -459,8 +468,27 @@ init_reg_sets_1 (void)\n   else\n     CLEAR_REG_SET (fixed_reg_set_regset);\n \n+  AND_HARD_REG_SET (operand_reg_set, accessible_reg_set);\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n+      /* As a special exception, registers whose class is NO_REGS are\n+\t not accepted by `register_operand'.  The reason for this change\n+\t is to allow the representation of special architecture artifacts\n+\t (such as a condition code register) without extending the rtl\n+\t definitions.  Since registers of class NO_REGS cannot be used\n+\t as registers in any case where register classes are examined,\n+\t it is better to apply this exception in a target-independent way.  */\n+      if (REGNO_REG_CLASS (i) == NO_REGS)\n+\tCLEAR_HARD_REG_BIT (operand_reg_set, i);\n+\n+      /* If a register is too limited to be treated as a register operand,\n+\t then it should never be allocated to a pseudo.  */\n+      if (!TEST_HARD_REG_BIT (operand_reg_set, i))\n+\t{\n+\t  fixed_regs[i] = 1;\n+\t  call_used_regs[i] = 1;\n+\t}\n+\n       /* call_used_regs must include fixed_regs.  */\n       gcc_assert (!fixed_regs[i] || call_used_regs[i]);\n #ifdef CALL_REALLY_USED_REGISTERS"}, {"sha": "bfb1ac68a594f253153a14cff5f8115d6cacaf6e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=006b72bffc64518d4e486982c548ec831dae2392", "patch": "@@ -1,3 +1,10 @@\n+2011-11-27  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* gcc.target/mips/mips.exp (mips-dg-options): Make -mno-dsp\n+\timply -mno-dspr2.\n+\t* gcc.target/mips/no-dsp-1.c: New test.\n+\t* gcc.target/mips/soft-float-1.c: Likewise.\n+\n 2011-11-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/49912"}, {"sha": "55b26f9602d858790393002ec2fb168bd45c90a5", "filename": "gcc/testsuite/gcc.target/mips/mips.exp", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp?ref=006b72bffc64518d4e486982c548ec831dae2392", "patch": "@@ -834,6 +834,10 @@ proc mips-dg-finish {} {\n #            |                           |\n #         -mexplicit-relocs           -mno-explicit-relocs\n #            |                           |\n+#         -mdspr2                     -mno-dspr2\n+#            |                           |\n+#         -mdsp                       -mno-dsp\n+#            |                           |\n #            +-- gp, abi & arch ---------+\n #\n # For these purposes, the \"gp\", \"abi\" & \"arch\" option groups are treated\n@@ -1136,14 +1140,14 @@ proc mips-dg-options { args } {\n \t\tmips_make_test_option options \"-mfp32\"\n \t    }\n \t    mips_make_test_option options \"-mno-dsp\"\n-\t    mips_make_test_option options \"-mno-dspr2\"\n \t}\n \tunset arch\n \tunset isa\n \tunset isa_rev\n     }\n \n     # Handle dependencies between options on the right of the diagram.\n+    mips_option_dependency options \"-mno-dsp\" \"-mno-dspr2\"\n     mips_option_dependency options \"-mno-explicit-relocs\" \"-mgpopt\"\n     switch -- [mips_test_option options small-data] {\n \t\"\" -"}, {"sha": "093037579b9f4d4cf57357dafb99e6954f09e171", "filename": "gcc/testsuite/gcc.target/mips/no-dsp-1.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fno-dsp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fno-dsp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fno-dsp-1.c?ref=006b72bffc64518d4e486982c548ec831dae2392", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-options \"-mno-dsp\" } */\n+\n+void\n+foo (void)\n+{\n+  register int x asm (\"$ac1hi\"); /* { dg-error \"cannot be accessed\" } */\n+}"}, {"sha": "4c45646279782f1da00ff88ad09aa7c2d0a4d532", "filename": "gcc/testsuite/gcc.target/mips/soft-float-1.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsoft-float-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsoft-float-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsoft-float-1.c?ref=006b72bffc64518d4e486982c548ec831dae2392", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-options \"-msoft-float\" } */\n+\n+void\n+foo (void)\n+{\n+  register float x asm (\"$f0\"); /* { dg-error \"cannot be accessed\" } */\n+}"}, {"sha": "8d555487818a2d164949d69675ec365ea9ab5f39", "filename": "gcc/varasm.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006b72bffc64518d4e486982c548ec831dae2392/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=006b72bffc64518d4e486982c548ec831dae2392", "patch": "@@ -1198,16 +1198,23 @@ make_decl_rtl (tree decl)\n   else if (TREE_CODE (decl) != FUNCTION_DECL && DECL_REGISTER (decl))\n     {\n       const char *asmspec = name+1;\n+      enum machine_mode mode = DECL_MODE (decl);\n       reg_number = decode_reg_name (asmspec);\n       /* First detect errors in declaring global registers.  */\n       if (reg_number == -1)\n \terror (\"register name not specified for %q+D\", decl);\n       else if (reg_number < 0)\n \terror (\"invalid register name for %q+D\", decl);\n-      else if (TYPE_MODE (TREE_TYPE (decl)) == BLKmode)\n+      else if (mode == BLKmode)\n \terror (\"data type of %q+D isn%'t suitable for a register\",\n \t       decl);\n-      else if (! HARD_REGNO_MODE_OK (reg_number, TYPE_MODE (TREE_TYPE (decl))))\n+      else if (!in_hard_reg_set_p (accessible_reg_set, mode, reg_number))\n+\terror (\"the register specified for %q+D cannot be accessed\"\n+\t       \" by the current target\", decl);\n+      else if (!in_hard_reg_set_p (operand_reg_set, mode, reg_number))\n+\terror (\"the register specified for %q+D is not general enough\"\n+\t       \" to be used as a register variable\", decl);\n+      else if (!HARD_REGNO_MODE_OK (reg_number, mode))\n \terror (\"register specified for %q+D isn%'t suitable for data type\",\n                decl);\n       /* Now handle properly declared static register variables.  */\n@@ -1230,7 +1237,7 @@ make_decl_rtl (tree decl)\n \t     confused with that register and be eliminated.  This usage is\n \t     somewhat suspect...  */\n \n-\t  SET_DECL_RTL (decl, gen_rtx_raw_REG (DECL_MODE (decl), reg_number));\n+\t  SET_DECL_RTL (decl, gen_rtx_raw_REG (mode, reg_number));\n \t  ORIGINAL_REGNO (DECL_RTL (decl)) = reg_number;\n \t  REG_USERVAR_P (DECL_RTL (decl)) = 1;\n \n@@ -1242,7 +1249,7 @@ make_decl_rtl (tree decl)\n \t      name = IDENTIFIER_POINTER (DECL_NAME (decl));\n \t      ASM_DECLARE_REGISTER_GLOBAL (asm_out_file, decl, reg_number, name);\n #endif\n-\t      nregs = hard_regno_nregs[reg_number][DECL_MODE (decl)];\n+\t      nregs = hard_regno_nregs[reg_number][mode];\n \t      while (nregs > 0)\n \t\tglobalize_reg (decl, reg_number + --nregs);\n \t    }"}]}