{"sha": "cd08718d57d1552fa2dbca96809e4915559685e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QwODcxOGQ1N2QxNTUyZmEyZGJjYTk2ODA5ZTQ5MTU1NTk2ODVlNw==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-04-21T09:35:13Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-04-21T10:08:49Z"}, "message": "coroutines: Fix handling of ramp return value [PR94661]\n\nCoroutine ramp functions have synthesised return values (the\nuser-authored function body cannot have an explicit 'return').\nThe current implementation attempts to optimise by building\nthe return in-place, in the manner of C++17 code. Clearly,\nthat was too ambitious and the fix builds a target expr for\nthe constructed version and passes that to finish_return_stmt.\n\nThis also means that we now get the same error messages for\nimplicit use of deleted CTORs etc.\n\ngcc/cp/ChangeLog:\n\n2020-04-21 Iain Sandoe <iain@sandoe.co.uk>\n\n\tPR c++/94661\n\t* coroutines.cc (morph_fn_to_coro): Simplify return\n\tvalue computation.\n\ngcc/testsuite/ChangeLog:\n\n\t2020-04-21 Iain Sandoe <iain@sandoe.co.uk>\n\n\tPR c++/94661\n\t* g++.dg/coroutines/ramp-return-a.C: New test.\n\t* g++.dg/coroutines/ramp-return-b.C: New test.\n\t* g++.dg/coroutines/ramp-return-c.C: New test.", "tree": {"sha": "37ffcf044fd423793a76e3882d07be0dd811d3fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37ffcf044fd423793a76e3882d07be0dd811d3fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd08718d57d1552fa2dbca96809e4915559685e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd08718d57d1552fa2dbca96809e4915559685e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd08718d57d1552fa2dbca96809e4915559685e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd08718d57d1552fa2dbca96809e4915559685e7/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6cbe9654d14588f8bcaf267730fa4c694216eee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6cbe9654d14588f8bcaf267730fa4c694216eee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6cbe9654d14588f8bcaf267730fa4c694216eee"}], "stats": {"total": 192, "additions": 160, "deletions": 32}, "files": [{"sha": "5b2bff8c561b2d6c42b3749c84212420fb5ac8f6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd08718d57d1552fa2dbca96809e4915559685e7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd08718d57d1552fa2dbca96809e4915559685e7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cd08718d57d1552fa2dbca96809e4915559685e7", "patch": "@@ -1,3 +1,9 @@\n+2020-04-21 Iain Sandoe <iain@sandoe.co.uk>\n+\n+\tPR c++/94661\n+\t* coroutines.cc (morph_fn_to_coro): Simplify return\n+\tvalue computation.\n+\n 2020-04-17  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/94592"}, {"sha": "30676eba6c23f75042aa48070bbedb8c62db030f", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 15, "deletions": 32, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd08718d57d1552fa2dbca96809e4915559685e7/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd08718d57d1552fa2dbca96809e4915559685e7/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=cd08718d57d1552fa2dbca96809e4915559685e7", "patch": "@@ -3726,23 +3726,14 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n     }\n \n   tree gro_context_body = push_stmt_list ();\n-  tree gro, gro_bind_vars;\n-  if (same_type_p (TREE_TYPE (get_ro), fn_return_type))\n-    {\n-      gro = DECL_RESULT (orig);\n-      gro_bind_vars = NULL_TREE; /* We don't need a separate var.  */\n-    }\n-  else\n-    {\n-      gro = build_lang_decl (VAR_DECL, get_identifier (\"coro.gro\"),\n-\t\t\t     TREE_TYPE (TREE_OPERAND (get_ro, 0)));\n-      DECL_CONTEXT (gro) = current_scope ();\n-      r = build_stmt (fn_start, DECL_EXPR, gro);\n-      add_stmt (r);\n-      gro_bind_vars = gro; /* We need a temporary var.  */\n-    }\n-\n-  /* Initialize our actual var.  */\n+  tree gro = build_lang_decl (VAR_DECL, get_identifier (\"coro.gro\"),\n+\t\t\t      TREE_TYPE (get_ro));\n+  DECL_CONTEXT (gro) = current_scope ();\n+  add_decl_expr (gro);\n+  tree gro_bind_vars = gro;\n+\n+  /* We have to sequence the call to get_return_object before initial\n+     suspend.  */\n   r = build2_loc (fn_start, INIT_EXPR, TREE_TYPE (gro), gro, get_ro);\n   r = coro_build_cvt_void_expr_stmt (r, fn_start);\n   add_stmt (r);\n@@ -3779,30 +3770,22 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n      logically doing things related to the end of the function.  */\n \n   /* The ramp is done, we just need the return value.  */\n-  if (!same_type_p (TREE_TYPE (gro), fn_return_type))\n+  if (!same_type_p (TREE_TYPE (get_ro), fn_return_type))\n     {\n       /* construct the return value with a single GRO param.  */\n       vec<tree, va_gc> *args = make_tree_vector_single (gro);\n-      r = build_special_member_call (DECL_RESULT (orig),\n+      r = build_special_member_call (NULL_TREE,\n \t\t\t\t     complete_ctor_identifier, &args,\n \t\t\t\t     fn_return_type, LOOKUP_NORMAL,\n \t\t\t\t     tf_warning_or_error);\n-      r = coro_build_cvt_void_expr_stmt (r, input_location);\n-      add_stmt (r);\n-      release_tree_vector (args);\n+      r = build_cplus_new (fn_return_type, r, tf_warning_or_error);\n     }\n-  /* Else the GRO is the return and we already built it in place.  */\n+  else\n+    r = rvalue (gro); /* The GRO is the return value.  */\n \n-  bool no_warning;\n-  r = check_return_expr (DECL_RESULT (orig), &no_warning);\n-  if (error_operand_p (r) && warn_return_type)\n-    /* Suppress -Wreturn-type for the ramp.  */\n-    TREE_NO_WARNING (orig) = true;\n+  finish_return_stmt (r);\n \n-  r = build_stmt (input_location, RETURN_EXPR, DECL_RESULT (orig));\n-  TREE_NO_WARNING (r) |= no_warning;\n-  r = maybe_cleanup_point_expr_void (r);\n-  add_stmt (r);\n+  /* Finish up the ramp function.  */\n   BIND_EXPR_VARS (gro_context_bind) = gro_bind_vars;\n   BIND_EXPR_BODY (gro_context_bind) = pop_stmt_list (gro_context_body);\n   BIND_EXPR_BODY (ramp_bind) = pop_stmt_list (ramp_body);"}, {"sha": "89178740200958d0647d9c44750da05de9752ebb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd08718d57d1552fa2dbca96809e4915559685e7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd08718d57d1552fa2dbca96809e4915559685e7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cd08718d57d1552fa2dbca96809e4915559685e7", "patch": "@@ -1,3 +1,10 @@\n+2020-04-21 Iain Sandoe <iain@sandoe.co.uk>\n+\n+\tPR c++/94661\n+\t* g++.dg/coroutines/ramp-return-a.C: New test.\n+\t* g++.dg/coroutines/ramp-return-b.C: New test.\n+\t* g++.dg/coroutines/ramp-return-c.C: New test.\n+\n 2020-04-17  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/94592"}, {"sha": "c6e445e0529a6b1845883b71f50e523aec4f35dc", "filename": "gcc/testsuite/g++.dg/coroutines/ramp-return-a.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd08718d57d1552fa2dbca96809e4915559685e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Framp-return-a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd08718d57d1552fa2dbca96809e4915559685e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Framp-return-a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Framp-return-a.C?ref=cd08718d57d1552fa2dbca96809e4915559685e7", "patch": "@@ -0,0 +1,24 @@\n+//  { dg-additional-options \"-std=c++14\" }\n+\n+#include \"ramp-return.h\"\n+\n+task<int>\n+foo ()\n+{\n+ std::coroutine_handle<promise<int>> _handle;\n+ return task<int> (_handle);\n+}\n+\n+// This ICEd for the PR.\n+\n+task<int>\n+bar ()\n+{\n+  co_return 0;\n+}\n+\n+task<std::vector<int>>\n+baz ()\n+{\n+  co_return std::vector<int>();\n+}"}, {"sha": "d0e5d1f3c7f54cdff9eb165a4b4b512a60b8151c", "filename": "gcc/testsuite/g++.dg/coroutines/ramp-return-b.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd08718d57d1552fa2dbca96809e4915559685e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Framp-return-b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd08718d57d1552fa2dbca96809e4915559685e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Framp-return-b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Framp-return-b.C?ref=cd08718d57d1552fa2dbca96809e4915559685e7", "patch": "@@ -0,0 +1,22 @@\n+//  { dg-options \"-fcoroutines -std=c++14\" }\n+#define DELETE_COPY_CTOR 1\n+#include \"ramp-return.h\"\n+\n+task<int>\n+foo ()\n+{\n+ std::coroutine_handle<promise<int>> _handle;\n+ return task<int> (_handle);  // { dg-error {use of deleted function 'task<T>::task\\(const task<T>&\\) \\[with T = int\\]'} }\n+}\n+\n+task<int>\n+bar ()\n+{\n+  co_return 0;\n+} // { dg-error {use of deleted function 'task<T>::task\\(const task<T>&\\) \\[with T = int\\]'} }\n+\n+task<std::vector<int>>\n+baz ()\n+{\n+  co_return std::vector<int>();\n+} // { dg-error {use of deleted function 'task<T>::task\\(const task<T>&\\) \\[with T = std::vector<int>\\]'} }"}, {"sha": "e030ca1b7aeba3531217d19cd6ccb07543acaad7", "filename": "gcc/testsuite/g++.dg/coroutines/ramp-return-c.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd08718d57d1552fa2dbca96809e4915559685e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Framp-return-c.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd08718d57d1552fa2dbca96809e4915559685e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Framp-return-c.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Framp-return-c.C?ref=cd08718d57d1552fa2dbca96809e4915559685e7", "patch": "@@ -0,0 +1,22 @@\n+//  { dg-additional-options \"-std=c++17\" }\n+#define DELETE_COPY_CTOR 1\n+#include \"ramp-return.h\"\n+\n+task<int>\n+foo ()\n+{\n+ std::coroutine_handle<promise<int>> _handle;\n+ return task<int> (_handle); \n+}\n+\n+task<int>\n+bar ()\n+{\n+  co_return 0;\n+}\n+\n+task<std::vector<int>>\n+baz ()\n+{\n+  co_return std::vector<int>();\n+}"}, {"sha": "f41a07dafbe0d2c93586f3c39e177f609fe3e8cb", "filename": "gcc/testsuite/g++.dg/coroutines/ramp-return.h", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd08718d57d1552fa2dbca96809e4915559685e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Framp-return.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd08718d57d1552fa2dbca96809e4915559685e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Framp-return.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Framp-return.h?ref=cd08718d57d1552fa2dbca96809e4915559685e7", "patch": "@@ -0,0 +1,64 @@\n+#include \"coro.h\"\n+\n+#include <exception>\n+#include <vector>\n+\n+template <typename T>\n+struct promise {\n+  T _value;\n+  coro::coroutine_handle<> _continuation = nullptr;\n+\n+  struct final_awaitable {\n+    bool _has_continuation;\n+    final_awaitable(bool has_continuation)\n+        : _has_continuation(has_continuation) {}\n+\n+    bool await_ready() const noexcept { return !_has_continuation; }\n+\n+    template <typename Promise>\n+    coro::coroutine_handle<>\n+    await_suspend(coro::coroutine_handle<Promise> coro) noexcept {\n+      return coro.promise()._continuation;\n+    }\n+\n+    void await_resume() noexcept {}\n+  };\n+\n+  auto get_return_object() noexcept {\n+    return coro::coroutine_handle<promise>::from_promise(*this);\n+  }\n+\n+  auto initial_suspend() noexcept { return coro::suspend_always(); }\n+\n+  auto final_suspend() noexcept {\n+    return final_awaitable(_continuation != nullptr);\n+  }\n+\n+  void return_value(T value) { _value = value; }\n+\n+  void unhandled_exception() { std::terminate(); }\n+};\n+\n+template <typename T> \n+struct task {\n+  using promise_type = promise<T>;\n+  std::coroutine_handle<promise<T>> _handle;\n+\n+  task (coro::coroutine_handle<promise<T>> handle) : _handle(handle) {}\n+#if DELETE_COPY_CTOR\n+ task (const task &) = delete; // no copying\n+#endif\n+#if DELETE_MOVE_CTOR\n+ task(task&& t) noexcept\n+    : _handle(t._handle) { t._handle = nullptr; }\n+#endif\n+  bool await_ready() noexcept { return _handle.done(); }\n+\n+  std::coroutine_handle<>\n+  await_suspend(std::coroutine_handle<> handle) noexcept {\n+    _handle.promise()._continuation = handle;\n+    return _handle;\n+  }\n+\n+  T await_resume() noexcept { return _handle.promise()._value; }\n+};"}]}