{"sha": "2dbd0234aa886bd84b12fae2f7e604aa99f092a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRiZDAyMzRhYTg4NmJkODRiMTJmYWUyZjdlNjA0YWE5OWYwOTJhNQ==", "commit": {"author": {"name": "Jerry Quinn", "email": "jlquinn@optonline.net", "date": "2003-12-19T20:44:18Z"}, "committer": {"name": "Jerry Quinn", "email": "jlquinn@gcc.gnu.org", "date": "2003-12-19T20:44:18Z"}, "message": "2003-12-19  Jerry Quinn  <jlquinn@optonline.net>\n\n        * include/bits/locale_facet.h\n        (__ctype_abstract_base,ctype<charT>,ctype<char>,ctype<wchar_t>):\n        Document.\n\nFrom-SVN: r74848", "tree": {"sha": "c246c1fc2a81ecfb7372209e98af7b16f1c9b8cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c246c1fc2a81ecfb7372209e98af7b16f1c9b8cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2dbd0234aa886bd84b12fae2f7e604aa99f092a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dbd0234aa886bd84b12fae2f7e604aa99f092a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dbd0234aa886bd84b12fae2f7e604aa99f092a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dbd0234aa886bd84b12fae2f7e604aa99f092a5/comments", "author": {"login": "jlquinn", "id": 826841, "node_id": "MDQ6VXNlcjgyNjg0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/826841?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlquinn", "html_url": "https://github.com/jlquinn", "followers_url": "https://api.github.com/users/jlquinn/followers", "following_url": "https://api.github.com/users/jlquinn/following{/other_user}", "gists_url": "https://api.github.com/users/jlquinn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlquinn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlquinn/subscriptions", "organizations_url": "https://api.github.com/users/jlquinn/orgs", "repos_url": "https://api.github.com/users/jlquinn/repos", "events_url": "https://api.github.com/users/jlquinn/events{/privacy}", "received_events_url": "https://api.github.com/users/jlquinn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "01da266767ed121543f3a167fd5dc8b4fec4f6cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01da266767ed121543f3a167fd5dc8b4fec4f6cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01da266767ed121543f3a167fd5dc8b4fec4f6cf"}], "stats": {"total": 938, "additions": 933, "deletions": 5}, "files": [{"sha": "a8f93feb50c627f84b70612689ccf8a9e5650e6e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbd0234aa886bd84b12fae2f7e604aa99f092a5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbd0234aa886bd84b12fae2f7e604aa99f092a5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2dbd0234aa886bd84b12fae2f7e604aa99f092a5", "patch": "@@ -1,3 +1,9 @@\n+2003-12-19  Jerry Quinn  <jlquinn@optonline.net>\n+\n+        * include/bits/locale_facet.h\n+        (__ctype_abstract_base,ctype<charT>,ctype<char>,ctype<wchar_t>):\n+        Document.\n+\n 2003-12-19  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/locale_facets.tcc (num_get::_M_extract_int,"}, {"sha": "eecb15c1b74bdfbb1941e2780d1b9db63aac0e85", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 927, "deletions": 5, "changes": 932, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbd0234aa886bd84b12fae2f7e604aa99f092a5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbd0234aa886bd84b12fae2f7e604aa99f092a5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=2dbd0234aa886bd84b12fae2f7e604aa99f092a5", "patch": "@@ -145,57 +145,217 @@ namespace std\n   #include <bits/ctype_base.h>\n \n   // Common base for ctype<_CharT>.  \n+  /**\n+   *  @brief  Common base for ctype facet\n+   *\n+   *  This template class provides implementations of the public functions\n+   *  that forward to the protected virtual functions.\n+   *\n+   *  This template also provides abtract stubs for the protected virtual\n+   *  functions.\n+  */\n   template<typename _CharT>\n     class __ctype_abstract_base : public locale::facet, public ctype_base\n     {\n     public:\n       // Types:\n+      /// Typedef for the template parameter\n       typedef _CharT char_type;\n \n+      /**\n+       *  @brief  Test char_type classification.\n+       *\n+       *  This function finds a mask M for @a c and compares it to mask @a m.\n+       *  It does so by returning the value of ctype<char_type>::do_is().\n+       *\n+       *  @param c  The char_type to compare the mask of.\n+       *  @param m  The mask to compare against.\n+       *  @return  (M & m) != 0.\n+      */\n       bool \n       is(mask __m, char_type __c) const\n       { return this->do_is(__m, __c); }\n \n+      /**\n+       *  @brief  Return a mask array.\n+       *\n+       *  This function finds the mask for each char_type in the range [lo,hi)\n+       *  and successively writes it to vec.  vec must have as many elements\n+       *  as the char array.  It does so by returning the value of\n+       *  ctype<char_type>::do_is().\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @param vec  Pointer to an array of mask storage.\n+       *  @return  @a hi.\n+      */\n       const char_type*\n       is(const char_type *__lo, const char_type *__hi, mask *__vec) const   \n       { return this->do_is(__lo, __hi, __vec); }\n \n+      /**\n+       *  @brief  Find char_type matching a mask\n+       *\n+       *  This function searches for and returns the first char_type c in\n+       *  [lo,hi) for which is(m,c) is true.  It does so by returning\n+       *  ctype<char_type>::do_scan_is().\n+       *\n+       *  @param m  The mask to compare against.\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  Pointer to matching char_type if found, else @a hi.\n+      */\n       const char_type*\n       scan_is(mask __m, const char_type* __lo, const char_type* __hi) const\n       { return this->do_scan_is(__m, __lo, __hi); }\n \n+      /**\n+       *  @brief  Find char_type not matching a mask\n+       *\n+       *  This function searches for and returns the first char_type c in\n+       *  [lo,hi) for which is(m,c) is false.  It does so by returning\n+       *  ctype<char_type>::do_scan_not().\n+       *\n+       *  @param m  The mask to compare against.\n+       *  @param lo  Pointer to first char in range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  Pointer to non-matching char if found, else @a hi.\n+      */\n       const char_type*\n       scan_not(mask __m, const char_type* __lo, const char_type* __hi) const\n       { return this->do_scan_not(__m, __lo, __hi); }\n \n+      /**\n+       *  @brief  Convert to uppercase.\n+       *\n+       *  This function converts the argument to uppercase if possible.\n+       *  If not possible (for example, '2'), returns the argument.  It does\n+       *  so by returning ctype<char_type>::do_toupper().\n+       *\n+       *  @param c  The char_type to convert.\n+       *  @return  The uppercase char_type if convertible, else @a c.\n+      */\n       char_type \n       toupper(char_type __c) const\n       { return this->do_toupper(__c); }\n \n+      /**\n+       *  @brief  Convert array to uppercase.\n+       *\n+       *  This function converts each char_type in the range [lo,hi) to\n+       *  uppercase if possible.  Other elements remain untouched.  It does so\n+       *  by returning ctype<char_type>:: do_toupper(lo, hi).\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  @a hi.\n+      */\n       const char_type*\n       toupper(char_type *__lo, const char_type* __hi) const\n       { return this->do_toupper(__lo, __hi); }\n \n-      char_type \n+      /**\n+       *  @brief  Convert to lowercase.\n+       *\n+       *  This function converts the argument to lowercase if possible.  If\n+       *  not possible (for example, '2'), returns the argument.  It does so\n+       *  by returning ctype<char_type>::do_tolower(c).\n+       *\n+       *  @param c  The char_type to convert.\n+       *  @return  The lowercase char_type if convertible, else @a c.\n+      */\n+      char_type\n       tolower(char_type __c) const\n       { return this->do_tolower(__c); }\n \n+      /**\n+       *  @brief  Convert array to lowercase.\n+       *\n+       *  This function converts each char_type in the range [lo,hi) to\n+       *  lowercase if possible.  Other elements remain untouched.  It does so\n+       *  by returning ctype<char_type>:: do_tolower(lo, hi).\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  @a hi.\n+      */\n       const char_type*\n       tolower(char_type* __lo, const char_type* __hi) const\n       { return this->do_tolower(__lo, __hi); }\n \n-      char_type \n+      /**\n+       *  @brief  Widen char to char_type\n+       *\n+       *  This function converts the char argument to char_type using the\n+       *  simplest reasonable transformation.  It does so by returning\n+       *  ctype<char_type>::do_widen(c).\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param c  The char to convert.\n+       *  @return  The converted char_type.\n+      */\n+      char_type\n       widen(char __c) const\n       { return this->do_widen(__c); }\n \n+      /**\n+       *  @brief  Widen array to char_type\n+       *\n+       *  This function converts each char in the input to char_type using the\n+       *  simplest reasonable transformation.  It does so by returning\n+       *  ctype<char_type>::do_widen(c).\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @param to  Pointer to the destination array.\n+       *  @return  @a hi.\n+      */\n       const char*\n       widen(const char* __lo, const char* __hi, char_type* __to) const\n       { return this->do_widen(__lo, __hi, __to); }\n \n+      /**\n+       *  @brief  Narrow char_type to char\n+       *\n+       *  This function converts the char_type to char using the simplest\n+       *  reasonable transformation.  If the conversion fails, dfault is\n+       *  returned instead.  It does so by returning\n+       *  ctype<char_type>::do_narrow(c).\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param c  The char_type to convert.\n+       *  @param dfault  Char to return if conversion fails.\n+       *  @return  The converted char.\n+      */\n       char \n       narrow(char_type __c, char __dfault) const\n       { return this->do_narrow(__c, __dfault); }\n \n+      /**\n+       *  @brief  Narrow array to char array\n+       *\n+       *  This function converts each char_type in the input to char using the\n+       *  simplest reasonable transformation and writes the results to the\n+       *  destination array.  For any char_type in the input that cannot be\n+       *  converted, @a dfault is used instead.  It does so by returning\n+       *  ctype<char_type>::do_narrow(lo, hi, dfault, to).\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @param dfault  Char to use if conversion fails.\n+       *  @param to  Pointer to the destination array.\n+       *  @return  @a hi.\n+      */\n       const char_type*\n       narrow(const char_type* __lo, const char_type* __hi,\n \t      char __dfault, char *__to) const\n@@ -208,49 +368,253 @@ namespace std\n       virtual \n       ~__ctype_abstract_base() { }\n       \n-      virtual bool \n+      /**\n+       *  @brief  Test char_type classification.\n+       *\n+       *  This function finds a mask M for @a c and compares it to mask @a m.\n+       *\n+       *  do_is() is a hook for a derived facet to change the behavior of\n+       *  classifying.  do_is() must always return the same result for the\n+       *  same input.\n+       *\n+       *  @param c  The char_type to find the mask of.\n+       *  @param m  The mask to compare against.\n+       *  @return  (M & m) != 0.\n+      */\n+      virtual bool\n       do_is(mask __m, char_type __c) const = 0;\n \n+      /**\n+       *  @brief  Return a mask array.\n+       *\n+       *  This function finds the mask for each char_type in the range [lo,hi)\n+       *  and successively writes it to vec.  vec must have as many elements\n+       *  as the input.\n+       *\n+       *  do_is() is a hook for a derived facet to change the behavior of\n+       *  classifying.  do_is() must always return the same result for the\n+       *  same input.\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @param vec  Pointer to an array of mask storage.\n+       *  @return  @a hi.\n+      */\n       virtual const char_type*\n       do_is(const char_type* __lo, const char_type* __hi, \n \t    mask* __vec) const = 0;\n \n+      /**\n+       *  @brief  Find char_type matching mask\n+       *\n+       *  This function searches for and returns the first char_type c in\n+       *  [lo,hi) for which is(m,c) is true.\n+       *\n+       *  do_scan_is() is a hook for a derived facet to change the behavior of\n+       *  match searching.  do_is() must always return the same result for the\n+       *  same input.\n+       *\n+       *  @param m  The mask to compare against.\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  Pointer to a matching char_type if found, else @a hi.\n+      */\n       virtual const char_type*\n       do_scan_is(mask __m, const char_type* __lo,\n \t\t const char_type* __hi) const = 0;\n \n+      /**\n+       *  @brief  Find char_type not matching mask\n+       *\n+       *  This function searches for and returns a pointer to the first\n+       *  char_type c of [lo,hi) for which is(m,c) is false.\n+       *\n+       *  do_scan_is() is a hook for a derived facet to change the behavior of\n+       *  match searching.  do_is() must always return the same result for the\n+       *  same input.\n+       *\n+       *  @param m  The mask to compare against.\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  Pointer to a non-matching char_type if found, else @a hi.\n+      */\n       virtual const char_type*\n       do_scan_not(mask __m, const char_type* __lo, \n \t\t  const char_type* __hi) const = 0;\n \n+      /**\n+       *  @brief  Convert to uppercase.\n+       *\n+       *  This virtual function converts the char_type argument to uppercase\n+       *  if possible.  If not possible (for example, '2'), returns the\n+       *  argument.\n+       *\n+       *  do_toupper() is a hook for a derived facet to change the behavior of\n+       *  uppercasing.  do_toupper() must always return the same result for\n+       *  the same input.\n+       *\n+       *  @param c  The char_type to convert.\n+       *  @return  The uppercase char_type if convertible, else @a c.\n+      */\n       virtual char_type \n       do_toupper(char_type) const = 0;\n \n+      /**\n+       *  @brief  Convert array to uppercase.\n+       *\n+       *  This virtual function converts each char_type in the range [lo,hi)\n+       *  to uppercase if possible.  Other elements remain untouched.\n+       *\n+       *  do_toupper() is a hook for a derived facet to change the behavior of\n+       *  uppercasing.  do_toupper() must always return the same result for\n+       *  the same input.\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  @a hi.\n+      */\n       virtual const char_type*\n       do_toupper(char_type* __lo, const char_type* __hi) const = 0;\n \n-      virtual char_type \n+      /**\n+       *  @brief  Convert to lowercase.\n+       *\n+       *  This virtual function converts the argument to lowercase if\n+       *  possible.  If not possible (for example, '2'), returns the argument.\n+       *\n+       *  do_tolower() is a hook for a derived facet to change the behavior of\n+       *  lowercasing.  do_tolower() must always return the same result for\n+       *  the same input.\n+       *\n+       *  @param c  The char_type to convert.\n+       *  @return  The lowercase char_type if convertible, else @a c.\n+      */\n+      virtual char_type\n       do_tolower(char_type) const = 0;\n \n+      /**\n+       *  @brief  Convert array to lowercase.\n+       *\n+       *  This virtual function converts each char_type in the range [lo,hi)\n+       *  to lowercase if possible.  Other elements remain untouched.\n+       *\n+       *  do_tolower() is a hook for a derived facet to change the behavior of\n+       *  lowercasing.  do_tolower() must always return the same result for\n+       *  the same input.\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  @a hi.\n+      */\n       virtual const char_type*\n       do_tolower(char_type* __lo, const char_type* __hi) const = 0;\n       \n+      /**\n+       *  @brief  Widen char\n+       *\n+       *  This virtual function converts the char to char_type using the\n+       *  simplest reasonable transformation.\n+       *\n+       *  do_widen() is a hook for a derived facet to change the behavior of\n+       *  widening.  do_widen() must always return the same result for the\n+       *  same input.\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param c  The char to convert.\n+       *  @return  The converted char_type\n+      */\n       virtual char_type \n       do_widen(char) const = 0;\n \n+      /**\n+       *  @brief  Widen char array\n+       *\n+       *  This function converts each char in the input to char_type using the\n+       *  simplest reasonable transformation.\n+       *\n+       *  do_widen() is a hook for a derived facet to change the behavior of\n+       *  widening.  do_widen() must always return the same result for the\n+       *  same input.\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param lo  Pointer to start range.\n+       *  @param hi  Pointer to end of range.\n+       *  @param to  Pointer to the destination array.\n+       *  @return  @a hi.\n+      */\n       virtual const char*\n       do_widen(const char* __lo, const char* __hi, \n \t       char_type* __dest) const = 0;\n \n+      /**\n+       *  @brief  Narrow char_type to char\n+       *\n+       *  This virtual function converts the argument to char using the\n+       *  simplest reasonable transformation.  If the conversion fails, dfault\n+       *  is returned instead.\n+       *\n+       *  do_narrow() is a hook for a derived facet to change the behavior of\n+       *  narrowing.  do_narrow() must always return the same result for the\n+       *  same input.\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param c  The char_type to convert.\n+       *  @param dfault  Char to return if conversion fails.\n+       *  @return  The converted char.\n+      */\n       virtual char \n       do_narrow(char_type, char __dfault) const = 0;\n \n+      /**\n+       *  @brief  Narrow char_type array to char\n+       *\n+       *  This virtual function converts each char_type in the range [lo,hi) to\n+       *  char using the simplest reasonable transformation and writes the\n+       *  results to the destination array.  For any element in the input that\n+       *  cannot be converted, @a dfault is used instead.\n+       *\n+       *  do_narrow() is a hook for a derived facet to change the behavior of\n+       *  narrowing.  do_narrow() must always return the same result for the\n+       *  same input.\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @param dfault  Char to use if conversion fails.\n+       *  @param to  Pointer to the destination array.\n+       *  @return  @a hi.\n+      */\n       virtual const char_type*\n       do_narrow(const char_type* __lo, const char_type* __hi,\n \t\tchar __dfault, char* __dest) const = 0;\n     };\n \n   // NB: Generic, mostly useless implementation.\n+  /**\n+   *  @brief  Template ctype facet\n+   *\n+   *  This template class defines classification and conversion functions for\n+   *  character sets.  It wraps <cctype> functionality.  Ctype gets used by\n+   *  streams for many I/O operations.\n+   *\n+   *  This template provides the protected virtual functions the developer\n+   *  will have to replace in a derived class or specialization to make a\n+   *  working facet.  The public functions that access them are defined in\n+   *  __ctype_abstract_base, to allow for implementation flexibility.  See\n+   *  ctype<wchar_t> for an example.  The functions are documented in\n+   *  __ctype_abstract_base.\n+   *\n+   *  Note: implementations are provided for all the protected virtual\n+   *  functions, but will likely not be useful.\n+  */\n   template<typename _CharT>\n     class ctype : public __ctype_abstract_base<_CharT>\n     {\n@@ -259,6 +623,7 @@ namespace std\n       typedef _CharT \t\t  \tchar_type;\n       typedef typename ctype::mask \tmask;\n \n+      /// The facet id for ctype<char_type>\n       static locale::id \t       \tid;\n \n       explicit \n@@ -311,11 +676,20 @@ namespace std\n     locale::id ctype<_CharT>::id;\n \n   // 22.2.1.3  ctype<char> specialization.\n+  /**\n+   *  @brief  The ctype<char> specialization.\n+   *\n+   *  This class defines classification and conversion functions for\n+   *  the char type.  It gets used by char streams for many I/O\n+   *  operations.  The char specialization provides a number of\n+   *  optimizations as well.\n+  */\n   template<>\n     class ctype<char> : public locale::facet, public ctype_base\n     {\n     public:\n       // Types:\n+      /// Typedef for the template parameter char.\n       typedef char \t       \tchar_type;\n \n     protected:\n@@ -332,44 +706,175 @@ namespace std\n \t\t\t\t\t\t// 2 non-consecutive\n       \n     public:\n+      /// The facet id for ctype<char>\n       static locale::id        id;\n+      /// The size of the mask table.  It is SCHAR_MAX + 1.\n       static const size_t      table_size = 1 + static_cast<unsigned char>(-1);\n \n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is the constructor provided by the standard.\n+       *\n+       *  @param table If non-zero, table is used as the per-char mask.\n+       *               Else classic_table() is used.\n+       *  @param del   If true, passes ownership of table to this facet.\n+       *  @param refs  Passed to the base facet class.\n+      */\n       explicit \n       ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);\n \n+      /**\n+       *  @brief  Constructor performs static initialization.\n+       *\n+       *  This constructor is used to construct the initial C locale facet.\n+       *\n+       *  @param cloc  Handle to C locale data.\n+       *  @param table If non-zero, table is used as the per-char mask.\n+       *  @param del   If true, passes ownership of table to this facet.\n+       *  @param refs  Passed to the base facet class.\n+      */\n       explicit \n       ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false, \n \t    size_t __refs = 0);\n \n-      inline bool \n+      /**\n+       *  @brief  Test char classification.\n+       *\n+       *  This function compares the mask table[c] to @a m.\n+       *\n+       *  @param c  The char to compare the mask of.\n+       *  @param m  The mask to compare against.\n+       *  @return  True if m & table[c] is true, false otherwise.\n+      */\n+      inline bool\n       is(mask __m, char __c) const;\n  \n+      /**\n+       *  @brief  Return a mask array.\n+       *\n+       *  This function finds the mask for each char in the range [lo, hi) and\n+       *  successively writes it to vec.  vec must have as many elements as\n+       *  the char array.\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @param vec  Pointer to an array of mask storage.\n+       *  @return  @a hi.\n+      */\n       inline const char*\n       is(const char* __lo, const char* __hi, mask* __vec) const;\n  \n+      /**\n+       *  @brief  Find char matching a mask\n+       *\n+       *  This function searches for and returns the first char in [lo,hi) for\n+       *  which is(m,char) is true.\n+       *\n+       *  @param m  The mask to compare against.\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  Pointer to a matching char if found, else @a hi.\n+      */\n       inline const char*\n       scan_is(mask __m, const char* __lo, const char* __hi) const;\n \n+      /**\n+       *  @brief  Find char not matching a mask\n+       *\n+       *  This function searches for and returns a pointer to the first char\n+       *  in [lo,hi) for which is(m,char) is false.\n+       *\n+       *  @param m  The mask to compare against.\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  Pointer to a non-matching char if found, else @a hi.\n+      */\n       inline const char*\n       scan_not(mask __m, const char* __lo, const char* __hi) const;\n      \n+      /**\n+       *  @brief  Convert to uppercase.\n+       *\n+       *  This function converts the char argument to uppercase if possible.\n+       *  If not possible (for example, '2'), returns the argument.\n+       *\n+       *  toupper() acts as if it returns ctype<char>::do_toupper(c).\n+       *  do_toupper() must always return the same result for the same input.\n+       *\n+       *  @param c  The char to convert.\n+       *  @return  The uppercase char if convertible, else @a c.\n+      */\n       char_type \n       toupper(char_type __c) const\n       { return this->do_toupper(__c); }\n \n+      /**\n+       *  @brief  Convert array to uppercase.\n+       *\n+       *  This function converts each char in the range [lo,hi) to uppercase\n+       *  if possible.  Other chars remain untouched.\n+       *\n+       *  toupper() acts as if it returns ctype<char>:: do_toupper(lo, hi).\n+       *  do_toupper() must always return the same result for the same input.\n+       *\n+       *  @param lo  Pointer to first char in range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  @a hi.\n+      */\n       const char_type*\n       toupper(char_type *__lo, const char_type* __hi) const\n       { return this->do_toupper(__lo, __hi); }\n \n+      /**\n+       *  @brief  Convert to lowercase.\n+       *\n+       *  This function converts the char argument to lowercase if possible.\n+       *  If not possible (for example, '2'), returns the argument.\n+       *\n+       *  tolower() acts as if it returns ctype<char>::do_tolower(c).\n+       *  do_tolower() must always return the same result for the same input.\n+       *\n+       *  @param c  The char to convert.\n+       *  @return  The lowercase char if convertible, else @a c.\n+      */\n       char_type \n       tolower(char_type __c) const\n       { return this->do_tolower(__c); }\n \n+      /**\n+       *  @brief  Convert array to lowercase.\n+       *\n+       *  This function converts each char in the range [lo,hi) to lowercase\n+       *  if possible.  Other chars remain untouched.\n+       *\n+       *  tolower() acts as if it returns ctype<char>:: do_tolower(lo, hi).\n+       *  do_tolower() must always return the same result for the same input.\n+       *\n+       *  @param lo  Pointer to first char in range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  @a hi.\n+      */\n       const char_type*\n       tolower(char_type* __lo, const char_type* __hi) const\n       { return this->do_tolower(__lo, __hi); }\n \n+      /**\n+       *  @brief  Widen char\n+       *\n+       *  This function converts the char to char_type using the simplest\n+       *  reasonable transformation.  For an underived ctype<char> facet, the\n+       *  argument will be returned unchanged.\n+       *\n+       *  This function works as if it returns ctype<char>::do_widen(c).\n+       *  do_widen() must always return the same result for the same input.\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param c  The char to convert.\n+       *  @return  The converted character.\n+      */\n       char_type \n       widen(char __c) const\n       { \n@@ -378,6 +883,24 @@ namespace std\n \treturn this->do_widen(__c);\n       }\n \n+      /**\n+       *  @brief  Widen char array\n+       *\n+       *  This function converts each char in the input to char using the\n+       *  simplest reasonable transformation.  For an underived ctype<char>\n+       *  facet, the argument will be copied unchanged.\n+       *\n+       *  This function works as if it returns ctype<char>::do_widen(c).\n+       *  do_widen() must always return the same result for the same input.\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param lo  Pointer to first char in range.\n+       *  @param hi  Pointer to end of range.\n+       *  @param to  Pointer to the destination array.\n+       *  @return  @a hi.\n+      */\n       const char*\n       widen(const char* __lo, const char* __hi, char_type* __to) const\n       {\n@@ -390,6 +913,24 @@ namespace std\n \treturn this->do_widen(__lo, __hi, __to);\n       }\n \n+      /**\n+       *  @brief  Narrow char\n+       *\n+       *  This function converts the char to char using the simplest\n+       *  reasonable transformation.  If the conversion fails, dfault is\n+       *  returned instead.  For an underived ctype<char> facet, @a c\n+       *  will be returned unchanged.\n+       *\n+       *  This function works as if it returns ctype<char>::do_narrow(c).\n+       *  do_narrow() must always return the same result for the same input.\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param c  The char to convert.\n+       *  @param dfault  Char to return if conversion fails.\n+       *  @return  The converted character.\n+      */\n       char \n       narrow(char_type __c, char __dfault) const\n       {\n@@ -399,6 +940,28 @@ namespace std\n \treturn __t;\n       }\n \n+      /**\n+       *  @brief  Narrow char array\n+       *\n+       *  This function converts each char in the input to char using the\n+       *  simplest reasonable transformation and writes the results to the\n+       *  destination array.  For any char in the input that cannot be\n+       *  converted, @a dfault is used instead.  For an underived ctype<char>\n+       *  facet, the argument will be copied unchanged.\n+       *\n+       *  This function works as if it returns ctype<char>::do_narrow(lo, hi,\n+       *  dfault, to).  do_narrow() must always return the same result for the\n+       *  same input.\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @param dfault  Char to use if conversion fails.\n+       *  @param to  Pointer to the destination array.\n+       *  @return  @a hi.\n+      */\n       const char_type*\n       narrow(const char_type* __lo, const char_type* __hi,\n \t     char __dfault, char *__to) const\n@@ -414,43 +977,183 @@ namespace std\n       }\n \n     protected:\n+      /// Returns a pointer to the mask table provided to the constructor, or\n+      /// the default from classic_table() if none was provided.\n       const mask* \n       table() const throw()\n       { return _M_table; }\n \n+      /// Returns a pointer to the C locale mask table.\n       static const mask* \n       classic_table() throw();\n \n+      /**\n+       *  @brief  Destructor.\n+       *\n+       *  This function deletes table() if @a del was true in the\n+       *  constructor.\n+      */\n       virtual \n       ~ctype();\n \n+      /**\n+       *  @brief  Convert to uppercase.\n+       *\n+       *  This virtual function converts the char argument to uppercase if\n+       *  possible.  If not possible (for example, '2'), returns the argument.\n+       *\n+       *  do_toupper() is a hook for a derived facet to change the behavior of\n+       *  uppercasing.  do_toupper() must always return the same result for\n+       *  the same input.\n+       *\n+       *  @param c  The char to convert.\n+       *  @return  The uppercase char if convertible, else @a c.\n+      */\n       virtual char_type \n       do_toupper(char_type) const;\n \n+      /**\n+       *  @brief  Convert array to uppercase.\n+       *\n+       *  This virtual function converts each char in the range [lo,hi) to\n+       *  uppercase if possible.  Other chars remain untouched.\n+       *\n+       *  do_toupper() is a hook for a derived facet to change the behavior of\n+       *  uppercasing.  do_toupper() must always return the same result for\n+       *  the same input.\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  @a hi.\n+      */\n       virtual const char_type*\n       do_toupper(char_type* __lo, const char_type* __hi) const;\n \n+      /**\n+       *  @brief  Convert to lowercase.\n+       *\n+       *  This virtual function converts the char argument to lowercase if\n+       *  possible.  If not possible (for example, '2'), returns the argument.\n+       *\n+       *  do_tolower() is a hook for a derived facet to change the behavior of\n+       *  lowercasing.  do_tolower() must always return the same result for\n+       *  the same input.\n+       *\n+       *  @param c  The char to convert.\n+       *  @return  The lowercase char if convertible, else @a c.\n+      */\n       virtual char_type \n       do_tolower(char_type) const;\n \n+      /**\n+       *  @brief  Convert array to lowercase.\n+       *\n+       *  This virtual function converts each char in the range [lo,hi) to\n+       *  lowercase if possible.  Other chars remain untouched.\n+       *\n+       *  do_tolower() is a hook for a derived facet to change the behavior of\n+       *  lowercasing.  do_tolower() must always return the same result for\n+       *  the same input.\n+       *\n+       *  @param lo  Pointer to first char in range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  @a hi.\n+      */\n       virtual const char_type*\n       do_tolower(char_type* __lo, const char_type* __hi) const;\n       \n+      /**\n+       *  @brief  Widen char\n+       *\n+       *  This virtual function converts the char to char using the simplest\n+       *  reasonable transformation.  For an underived ctype<char> facet, the\n+       *  argument will be returned unchanged.\n+       *\n+       *  do_widen() is a hook for a derived facet to change the behavior of\n+       *  widening.  do_widen() must always return the same result for the\n+       *  same input.\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param c  The char to convert.\n+       *  @return  The converted character.\n+      */\n       virtual char_type \n       do_widen(char __c) const\n       { return __c; }\n \n+      /**\n+       *  @brief  Widen char array\n+       *\n+       *  This function converts each char in the range [lo,hi) to char using\n+       *  the simplest reasonable transformation.  For an underived\n+       *  ctype<char> facet, the argument will be copied unchanged.\n+       *\n+       *  do_widen() is a hook for a derived facet to change the behavior of\n+       *  widening.  do_widen() must always return the same result for the\n+       *  same input.\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @param to  Pointer to the destination array.\n+       *  @return  @a hi.\n+      */\n       virtual const char*\n       do_widen(const char* __lo, const char* __hi, char_type* __dest) const\n       {\n \tmemcpy(__dest, __lo, __hi - __lo);\n \treturn __hi;\n       }\n \n+      /**\n+       *  @brief  Narrow char\n+       *\n+       *  This virtual function converts the char to char using the simplest\n+       *  reasonable transformation.  If the conversion fails, dfault is\n+       *  returned instead.  For an underived ctype<char> facet, @a c will be\n+       *  returned unchanged.\n+       *\n+       *  do_narrow() is a hook for a derived facet to change the behavior of\n+       *  narrowing.  do_narrow() must always return the same result for the\n+       *  same input.\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param c  The char to convert.\n+       *  @param dfault  Char to return if conversion fails.\n+       *  @return  The converted char.\n+      */\n       virtual char \n       do_narrow(char_type __c, char) const\n       { return __c; }\n \n+      /**\n+       *  @brief  Narrow char array to char array\n+       *\n+       *  This virtual function converts each char in the range [lo,hi) to\n+       *  char using the simplest reasonable transformation and writes the\n+       *  results to the destination array.  For any char in the input that\n+       *  cannot be converted, @a dfault is used instead.  For an underived\n+       *  ctype<char> facet, the argument will be copied unchanged.\n+       *\n+       *  do_narrow() is a hook for a derived facet to change the behavior of\n+       *  narrowing.  do_narrow() must always return the same result for the\n+       *  same input.\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @param dfault  Char to use if conversion fails.\n+       *  @param to  Pointer to the destination array.\n+       *  @return  @a hi.\n+      */\n       virtual const char_type*\n       do_narrow(const char_type* __lo, const char_type* __hi,\n \t\tchar, char* __dest) const\n@@ -512,11 +1215,22 @@ namespace std\n \n #ifdef _GLIBCXX_USE_WCHAR_T\n   // 22.2.1.3  ctype<wchar_t> specialization\n+  /**\n+   *  @brief  The ctype<wchar_t> specialization.\n+   *\n+   *  This class defines classification and conversion functions for the\n+   *  wchar_t type.  It gets used by wchar_t streams for many I/O operations.\n+   *  The wchar_t specialization provides a number of optimizations as well.\n+   *\n+   *  ctype<wchar_t> inherits its public methods from\n+   *  __ctype_abstract_base<wchar_t>.\n+  */\n   template<>\n     class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>\n     {\n     public:\n       // Types:\n+      /// Typedef for the template parameter wchar_t.\n       typedef wchar_t \t       \tchar_type;\n       typedef wctype_t\t       \t__wmask_type;\n \n@@ -534,55 +1248,263 @@ namespace std\n \n     public:\n       // Data Members:\n+      /// The facet id for ctype<wchar_t>\n       static locale::id        \tid;\n \n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is the constructor provided by the standard.\n+       *\n+       *  @param refs  Passed to the base facet class.\n+      */\n       explicit \n       ctype(size_t __refs = 0);\n \n+      /**\n+       *  @brief  Constructor performs static initialization.\n+       *\n+       *  This constructor is used to construct the initial C locale facet.\n+       *\n+       *  @param cloc  Handle to C locale data.\n+       *  @param refs  Passed to the base facet class.\n+      */\n       explicit \n       ctype(__c_locale __cloc, size_t __refs = 0);\n \n     protected:\n       __wmask_type\n       _M_convert_to_wmask(const mask __m) const;\n \n+      /// Destructor\n       virtual \n       ~ctype();\n \n+      /**\n+       *  @brief  Test wchar_t classification.\n+       *\n+       *  This function finds a mask M for @a c and compares it to mask @a m.\n+       *\n+       *  do_is() is a hook for a derived facet to change the behavior of\n+       *  classifying.  do_is() must always return the same result for the\n+       *  same input.\n+       *\n+       *  @param c  The wchar_t to find the mask of.\n+       *  @param m  The mask to compare against.\n+       *  @return  (M & m) != 0.\n+      */\n       virtual bool \n       do_is(mask __m, char_type __c) const;\n \n+      /**\n+       *  @brief  Return a mask array.\n+       *\n+       *  This function finds the mask for each wchar_t in the range [lo,hi)\n+       *  and successively writes it to vec.  vec must have as many elements\n+       *  as the input.\n+       *\n+       *  do_is() is a hook for a derived facet to change the behavior of\n+       *  classifying.  do_is() must always return the same result for the\n+       *  same input.\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @param vec  Pointer to an array of mask storage.\n+       *  @return  @a hi.\n+      */\n       virtual const char_type*\n       do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;\n \n+      /**\n+       *  @brief  Find wchar_t matching mask\n+       *\n+       *  This function searches for and returns the first wchar_t c in\n+       *  [lo,hi) for which is(m,c) is true.\n+       *\n+       *  do_scan_is() is a hook for a derived facet to change the behavior of\n+       *  match searching.  do_is() must always return the same result for the\n+       *  same input.\n+       *\n+       *  @param m  The mask to compare against.\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  Pointer to a matching wchar_t if found, else @a hi.\n+      */\n       virtual const char_type*\n       do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;\n \n+      /**\n+       *  @brief  Find wchar_t not matching mask\n+       *\n+       *  This function searches for and returns a pointer to the first\n+       *  wchar_t c of [lo,hi) for which is(m,c) is false.\n+       *\n+       *  do_scan_is() is a hook for a derived facet to change the behavior of\n+       *  match searching.  do_is() must always return the same result for the\n+       *  same input.\n+       *\n+       *  @param m  The mask to compare against.\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  Pointer to a non-matching wchar_t if found, else @a hi.\n+      */\n       virtual const char_type*\n       do_scan_not(mask __m, const char_type* __lo, \n \t\t  const char_type* __hi) const;\n \n+      /**\n+       *  @brief  Convert to uppercase.\n+       *\n+       *  This virtual function converts the wchar_t argument to uppercase if\n+       *  possible.  If not possible (for example, '2'), returns the argument.\n+       *\n+       *  do_toupper() is a hook for a derived facet to change the behavior of\n+       *  uppercasing.  do_toupper() must always return the same result for\n+       *  the same input.\n+       *\n+       *  @param c  The wchar_t to convert.\n+       *  @return  The uppercase wchar_t if convertible, else @a c.\n+      */\n       virtual char_type \n       do_toupper(char_type) const;\n \n+      /**\n+       *  @brief  Convert array to uppercase.\n+       *\n+       *  This virtual function converts each wchar_t in the range [lo,hi) to\n+       *  uppercase if possible.  Other elements remain untouched.\n+       *\n+       *  do_toupper() is a hook for a derived facet to change the behavior of\n+       *  uppercasing.  do_toupper() must always return the same result for\n+       *  the same input.\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  @a hi.\n+      */\n       virtual const char_type*\n       do_toupper(char_type* __lo, const char_type* __hi) const;\n \n+      /**\n+       *  @brief  Convert to lowercase.\n+       *\n+       *  This virtual function converts the argument to lowercase if\n+       *  possible.  If not possible (for example, '2'), returns the argument.\n+       *\n+       *  do_tolower() is a hook for a derived facet to change the behavior of\n+       *  lowercasing.  do_tolower() must always return the same result for\n+       *  the same input.\n+       *\n+       *  @param c  The wchar_t to convert.\n+       *  @return  The lowercase wchar_t if convertible, else @a c.\n+      */\n       virtual char_type \n       do_tolower(char_type) const;\n \n+      /**\n+       *  @brief  Convert array to lowercase.\n+       *\n+       *  This virtual function converts each wchar_t in the range [lo,hi) to\n+       *  lowercase if possible.  Other elements remain untouched.\n+       *\n+       *  do_tolower() is a hook for a derived facet to change the behavior of\n+       *  lowercasing.  do_tolower() must always return the same result for\n+       *  the same input.\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @return  @a hi.\n+      */\n       virtual const char_type*\n       do_tolower(char_type* __lo, const char_type* __hi) const;\n       \n+      /**\n+       *  @brief  Widen char to wchar_t\n+       *\n+       *  This virtual function converts the char to wchar_t using the\n+       *  simplest reasonable transformation.  For an underived ctype<wchar_t>\n+       *  facet, the argument will be cast to wchar_t.\n+       *\n+       *  do_widen() is a hook for a derived facet to change the behavior of\n+       *  widening.  do_widen() must always return the same result for the\n+       *  same input.\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param c  The char to convert.\n+       *  @return  The converted wchar_t.\n+      */\n       virtual char_type \n       do_widen(char) const;\n \n+      /**\n+       *  @brief  Widen char array to wchar_t array\n+       *\n+       *  This function converts each char in the input to wchar_t using the\n+       *  simplest reasonable transformation.  For an underived ctype<wchar_t>\n+       *  facet, the argument will be copied, casting each element to wchar_t.\n+       *\n+       *  do_widen() is a hook for a derived facet to change the behavior of\n+       *  widening.  do_widen() must always return the same result for the\n+       *  same input.\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param lo  Pointer to start range.\n+       *  @param hi  Pointer to end of range.\n+       *  @param to  Pointer to the destination array.\n+       *  @return  @a hi.\n+      */\n       virtual const char*\n       do_widen(const char* __lo, const char* __hi, char_type* __dest) const;\n \n+      /**\n+       *  @brief  Narrow wchar_t to char\n+       *\n+       *  This virtual function converts the argument to char using the\n+       *  simplest reasonable transformation.  If the conversion fails, dfault\n+       *  is returned instead.  For an underived ctype<wchar_t> facet, @a c will\n+       *  be cast to char and returned.\n+       *\n+       *  do_narrow() is a hook for a derived facet to change the behavior of\n+       *  narrowing.  do_narrow() must always return the same result for the\n+       *  same input.\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param c  The wchar_t to convert.\n+       *  @param dfault  Char to return if conversion fails.\n+       *  @return  The converted char.\n+      */\n       virtual char \n       do_narrow(char_type, char __dfault) const;\n \n+      /**\n+       *  @brief  Narrow wchar_t array to char array\n+       *\n+       *  This virtual function converts each wchar_t in the range [lo,hi) to\n+       *  char using the simplest reasonable transformation and writes the\n+       *  results to the destination array.  For any wchar_t in the input that\n+       *  cannot be converted, @a dfault is used instead.  For an underived\n+       *  ctype<wchar_t> facet, the argument will be copied, casting each\n+       *  element to char.\n+       *\n+       *  do_narrow() is a hook for a derived facet to change the behavior of\n+       *  narrowing.  do_narrow() must always return the same result for the\n+       *  same input.\n+       *\n+       *  Note: this is not what you want for codepage conversions.  See\n+       *  codecvt for that.\n+       *\n+       *  @param lo  Pointer to start of range.\n+       *  @param hi  Pointer to end of range.\n+       *  @param dfault  Char to use if conversion fails.\n+       *  @param to  Pointer to the destination array.\n+       *  @return  @a hi.\n+      */\n       virtual const char_type*\n       do_narrow(const char_type* __lo, const char_type* __hi,\n \t\tchar __dfault, char* __dest) const;"}]}