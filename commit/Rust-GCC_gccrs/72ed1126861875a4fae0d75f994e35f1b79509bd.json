{"sha": "72ed1126861875a4fae0d75f994e35f1b79509bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJlZDExMjY4NjE4NzVhNGZhZTBkNzVmOTk0ZTM1ZjFiNzk1MDliZA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2015-04-16T07:57:56Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2015-04-16T07:57:56Z"}, "message": "rl78-opts.h (enum rl78_mul_types): Add MUL_G14 and MUL_UNINIT.\n\n \t* config/rl78/rl78-opts.h (enum rl78_mul_types): Add MUL_G14 and\n \tMUL_UNINIT.\n \t(enum rl78_cpu_type): New.\n \t* config/rl78/rl78-virt.md (attr valloc): Add divhi and divsi.\n \t(umulhi3_shift_virt): Remove m constraint from operand 1.\n \t(umulqihi3_virt): Likewise.\n \t* config/rl78/rl78.c (rl78_option_override): Add code to process\n \t-mcpu and -mmul options.\n \t(rl78_alloc_physical_registers): Add code to handle divhi and\n \tdivsi valloc attributes.\n \t(set_origin): Likewise.\n \t* config/rl78/rl78.h (RL78_MUL_G14): Define.\n \t(TARGET_G10, TARGET_G13, TARGET_G14): Define.\n \t(TARGET_CPU_CPP_BUILTINS): Define __RL78_MUL_xxx__ and\n \t__RL78_Gxx__.\n \t(ASM_SPEC): Pass -mcpu on to assembler.\n \t* config/rl78/rl78.md (mulqi3): Add a clobber of AX.\n \t(mulqi3_rl78): Likewise.\n \t(mulhi3_g13): Likewise.\n \t(mulhi3): Generate the G13 or G14 versions of the insn directly.\n \t(mulsi3): Likewise.\n \t(mulhi3_g14): Add clobbers of AX and BC.\n \t(mulsi3_g14): Likewise.\n \t(mulsi3_g13): Likewise.\n \t(udivmodhi4, udivmodhi4_g14, udivmodsi4): New patterns.\n \t(udivmodsi4_g14, udivmodsi4_g13): New patterns.\n \t* config/rl78/rl78.opt (mmul): Initialise value to\n \tRL78_MUL_UNINIT.\n \t(mcpu): New option.\n \t(m13, m14, mrl78): New option aliases.\n \t* config/rl78/t-rl78 (MULTILIB_OPTIONS): Add mg13 and mg14.\n \t(MULTILIB_DIRNAMES): Add g13 and g14.\n \t* doc/invoke.texi: Document -mcpu and -mmul options.\n\n \t* config/rl78/divmodhi.S: Add G14 and G13 versions of the __divhi3\n \tand __modhi3 functions.\n\t* config/rl78/divmodso.S: Add G14 and G13 versions of the\n \t__divsi3, __udivsi3, __modsi3 and __umodsi3 functions.\n\nFrom-SVN: r222142", "tree": {"sha": "6058a55ad9abb695d0a8f4a9b314ab329d819ebc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6058a55ad9abb695d0a8f4a9b314ab329d819ebc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72ed1126861875a4fae0d75f994e35f1b79509bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72ed1126861875a4fae0d75f994e35f1b79509bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72ed1126861875a4fae0d75f994e35f1b79509bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72ed1126861875a4fae0d75f994e35f1b79509bd/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8a474dc5d7d152653e90e960eff1852d1c7ff914", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a474dc5d7d152653e90e960eff1852d1c7ff914", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a474dc5d7d152653e90e960eff1852d1c7ff914"}], "stats": {"total": 1556, "additions": 1496, "deletions": 60}, "files": [{"sha": "5ff0a23a1bbff79756966997db98e40ec3cba809", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72ed1126861875a4fae0d75f994e35f1b79509bd", "patch": "@@ -1,3 +1,39 @@\n+2015-04-16  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/rl78/rl78-opts.h (enum rl78_mul_types): Add MUL_G14 and\n+\tMUL_UNINIT.\n+\t(enum rl78_cpu_type): New.\n+\t* config/rl78/rl78-virt.md (attr valloc): Add divhi and divsi.\n+\t(umulhi3_shift_virt): Remove m constraint from operand 1.\n+\t(umulqihi3_virt): Likewise.\n+\t* config/rl78/rl78.c (rl78_option_override): Add code to process\n+\t-mcpu and -mmul options.\n+\t(rl78_alloc_physical_registers): Add code to handle divhi and\n+\tdivsi valloc attributes.\n+\t(set_origin): Likewise.\n+\t* config/rl78/rl78.h (RL78_MUL_G14): Define.\n+\t(TARGET_G10, TARGET_G13, TARGET_G14): Define.\n+\t(TARGET_CPU_CPP_BUILTINS): Define __RL78_MUL_xxx__ and\n+\t__RL78_Gxx__.\n+\t(ASM_SPEC): Pass -mcpu on to assembler.\n+\t* config/rl78/rl78.md (mulqi3): Add a clobber of AX.\n+\t(mulqi3_rl78): Likewise.\n+\t(mulhi3_g13): Likewise.\n+\t(mulhi3): Generate the G13 or G14 versions of the insn directly.\n+\t(mulsi3): Likewise.\n+\t(mulhi3_g14): Add clobbers of AX and BC.\n+\t(mulsi3_g14): Likewise.\n+\t(mulsi3_g13): Likewise.\n+\t(udivmodhi4, udivmodhi4_g14, udivmodsi4): New patterns.\n+\t(udivmodsi4_g14, udivmodsi4_g13): New patterns.\n+\t* config/rl78/rl78.opt (mmul): Initialise value to\n+\tRL78_MUL_UNINIT.\n+\t(mcpu): New option.\n+\t(m13, m14, mrl78): New option aliases.\n+\t* config/rl78/t-rl78 (MULTILIB_OPTIONS): Add mg13 and mg14.\n+\t(MULTILIB_DIRNAMES): Add g13 and g14.\n+\t* doc/invoke.texi: Document -mcpu and -mmul options.\n+\n 2015-04-16  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-ccp.c (likely_value): See if we have operands that\n@@ -75,6 +111,7 @@\n \t* config/rx/t-rx (MULTILIB_OPTIONS): Add mno-allow-string-insns.\n \t(MULTILIB_DIRNAMES): Add no-strings.\n \t* doc/invoke.texi: Document -mno-allow-string-insns.\n+\n 2015-04-15  Alan Modra  <amodra@gmail.com>\n \n \tPR target/65408"}, {"sha": "6fa54cc1143759891dd9ee953b3741d7a68cc39a", "filename": "gcc/config/rl78/rl78-opts.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Fconfig%2Frl78%2Frl78-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Fconfig%2Frl78%2Frl78-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-opts.h?ref=72ed1126861875a4fae0d75f994e35f1b79509bd", "patch": "@@ -24,7 +24,17 @@ enum rl78_mul_types\n {\n   MUL_NONE,\n   MUL_RL78,\n-  MUL_G13\n+  MUL_G13,\n+  MUL_G14,\n+  MUL_UNINIT\n+};\n+\n+enum rl78_cpu_types\n+{\n+  CPU_G10,\n+  CPU_G13,\n+  CPU_G14,\n+  CPU_UNINIT\n };\n \n #endif"}, {"sha": "c70beaec539e8d3a3b825830a5b542f42bcdee89", "filename": "gcc/config/rl78/rl78-virt.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Fconfig%2Frl78%2Frl78-virt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Fconfig%2Frl78%2Frl78-virt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-virt.md?ref=72ed1126861875a4fae0d75f994e35f1b79509bd", "patch": "@@ -28,7 +28,7 @@\n ;; instruction - op1 is of the form \"a = op(b)\", op2 is \"a = b op c\"\n ;; etc.\n \n-(define_attr \"valloc\" \"op1,op2,ro1,cmp,umul,macax\"\n+(define_attr \"valloc\" \"op1,op2,ro1,cmp,umul,macax,divhi,divsi\"\n   (const_string \"op2\"))\n \n ;;---------- Moving ------------------------\n@@ -113,7 +113,7 @@\n )\n \n (define_insn \"*umulhi3_shift_virt\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=vm\")\n+  [(set (match_operand:HI          0 \"register_operand\" \"=v\")\n         (mult:HI (match_operand:HI 1 \"rl78_nonfar_operand\" \"%vim\")\n                  (match_operand:HI 2 \"rl78_24_operand\" \"Ni\")))]\n   \"rl78_virt_insns_ok () && !TARGET_G10\"\n@@ -122,7 +122,7 @@\n )\n \n (define_insn \"*umulqihi3_virt\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=vm\")\n+  [(set (match_operand:HI                          0 \"register_operand\" \"=v\")\n         (mult:HI (zero_extend:HI (match_operand:QI 1 \"rl78_nonfar_operand\" \"%vim\"))\n                  (zero_extend:HI (match_operand:QI 2 \"general_operand\" \"vim\"))))]\n   \"rl78_virt_insns_ok () && !TARGET_G10\""}, {"sha": "64698045e8af8ecfa96ada20ed79045d52daa1ae", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 101, "deletions": 3, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=72ed1126861875a4fae0d75f994e35f1b79509bd", "patch": "@@ -377,6 +377,48 @@ rl78_option_override (void)\n       && strcmp (lang_hooks.name, \"GNU GIMPLE\"))\n     /* Address spaces are currently only supported by C.  */\n     error (\"-mes0 can only be used with C\");\n+\n+  switch (rl78_cpu_type)\n+    {\n+    case CPU_UNINIT:\n+      rl78_cpu_type = CPU_G14;\n+      if (rl78_mul_type == MUL_UNINIT)\n+\trl78_mul_type = MUL_NONE;\n+      break;\n+\n+    case CPU_G10:\n+      switch (rl78_mul_type)\n+\t{\n+\tcase MUL_UNINIT: rl78_mul_type = MUL_NONE; break;\n+\tcase MUL_NONE:   break;\n+\tcase MUL_G13:  \t error (\"-mmul=g13 cannot be used with -mcpu=g10\"); break;\n+\tcase MUL_G14:  \t error (\"-mmul=g14 cannot be used with -mcpu=g10\"); break;\n+\t}\n+      break;\n+\n+    case CPU_G13:\n+      switch (rl78_mul_type)\n+\t{\n+\tcase MUL_UNINIT: rl78_mul_type = MUL_G13; break;\n+\tcase MUL_NONE:   break;\n+\tcase MUL_G13:  \tbreak;\n+\t  /* The S2 core does not have mul/div instructions.  */\n+\tcase MUL_G14: \terror (\"-mmul=g14 cannot be used with -mcpu=g13\"); break;\n+\t}\n+      break;\n+\n+    case CPU_G14:\n+      switch (rl78_mul_type)\n+\t{\n+\tcase MUL_UNINIT: rl78_mul_type = MUL_G14; break;\n+\tcase MUL_NONE:   break;\n+\tcase MUL_G14:  \tbreak;\n+\t/* The G14 core does not have the hardware multiply peripheral used by the\n+\t   G13 core, hence you cannot use G13 multipliy routines on G14 hardware.  */\n+\tcase MUL_G13: \terror (\"-mmul=g13 cannot be used with -mcpu=g14\"); break;\n+\t}\n+      break;\n+    }\n }\n \n /* Most registers are 8 bits.  Some are 16 bits because, for example,\n@@ -3514,6 +3556,18 @@ rl78_alloc_physical_registers (void)\n \t  record_content (BC, NULL_RTX);\n \t  record_content (DE, NULL_RTX);\n \t}\n+      else if (valloc_method == VALLOC_DIVHI)\n+\t{\n+\t  record_content (AX, NULL_RTX);\n+\t  record_content (BC, NULL_RTX);\n+\t}\n+      else if (valloc_method == VALLOC_DIVSI)\n+\t{\n+\t  record_content (AX, NULL_RTX);\n+\t  record_content (BC, NULL_RTX);\n+\t  record_content (DE, NULL_RTX);\n+\t  record_content (HL, NULL_RTX);\n+\t}\n \n       if (insn_ok_now (insn))\n \tcontinue;\n@@ -3541,6 +3595,7 @@ rl78_alloc_physical_registers (void)\n \t  break;\n \tcase VALLOC_UMUL:\n \t  rl78_alloc_physical_registers_umul (insn);\n+\t  record_content (AX, NULL_RTX);\n \t  break;\n \tcase VALLOC_MACAX:\n \t  /* Macro that clobbers AX.  */\n@@ -3549,6 +3604,18 @@ rl78_alloc_physical_registers (void)\n \t  record_content (BC, NULL_RTX);\n \t  record_content (DE, NULL_RTX);\n \t  break;\n+\tcase VALLOC_DIVSI:\n+\t  rl78_alloc_address_registers_div (insn);\n+\t  record_content (AX, NULL_RTX);\n+\t  record_content (BC, NULL_RTX);\n+\t  record_content (DE, NULL_RTX);\n+\t  record_content (HL, NULL_RTX);\n+\t  break;\n+\tcase VALLOC_DIVHI:\n+\t  rl78_alloc_address_registers_div (insn);\n+\t  record_content (AX, NULL_RTX);\n+\t  record_content (BC, NULL_RTX);\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -3863,6 +3930,37 @@ set_origin (rtx pat, rtx_insn * insn, int * origins, int * age)\n \t    age[i] = 0;\n \t  }\n     }\n+  else if (get_attr_valloc (insn) == VALLOC_DIVHI)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Resetting origin of AX/DE for DIVHI pattern.\\n\");\n+\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (i == A_REG\n+\t    || i == X_REG\n+\t    || i == D_REG\n+\t    || i == E_REG\n+\t    || origins[i] == A_REG\n+\t    || origins[i] == X_REG\n+\t    || origins[i] == D_REG\n+\t    || origins[i] == E_REG)\n+\t  {\n+\t    origins[i] = i;\n+\t    age[i] = 0;\n+\t  }\n+    }\n+  else if (get_attr_valloc (insn) == VALLOC_DIVSI)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Resetting origin of AX/BC/DE/HL for DIVSI pattern.\\n\");\n+\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (i <= 7 || origins[i] <= 7)\n+\t  {\n+\t    origins[i] = i;\n+\t    age[i] = 0;\n+\t  }\n+    }\n \n   if (GET_CODE (src) == ASHIFT\n       || GET_CODE (src) == ASHIFTRT\n@@ -4087,7 +4185,7 @@ rl78_rtx_costs (rtx   x,\n       switch (code)\n \t{\n \tcase MULT:\n-\t  if (RL78_MUL_RL78)\n+\t  if (RL78_MUL_G14)\n \t    *total = COSTS_N_INSNS (14);\n \t  else if (RL78_MUL_G13)\n \t    *total = COSTS_N_INSNS (29);\n@@ -4407,7 +4505,7 @@ rl78_insert_attributes (tree decl, tree *attributes ATTRIBUTE_UNUSED)\n       tree type = TREE_TYPE (decl);\n       tree attr = TYPE_ATTRIBUTES (type);\n       int q = TYPE_QUALS_NO_ADDR_SPACE (type) | ENCODE_QUAL_ADDR_SPACE (ADDR_SPACE_FAR);\n-      \n+\n       TREE_TYPE (decl) = build_type_attribute_qual_variant (type, attr, q);\n     }\n }\n@@ -4503,7 +4601,7 @@ rl78_flags_already_set (rtx op, rtx operand)\n     {\n       if (LABEL_P (insn))\n \tbreak;\n-      \n+\n       if (! INSN_P (insn))\n \tcontinue;\n "}, {"sha": "066b0d1323cfca3af56ec87ef5c3b2b14be3ad1f", "filename": "gcc/config/rl78/rl78.h", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Fconfig%2Frl78%2Frl78.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Fconfig%2Frl78%2Frl78.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.h?ref=72ed1126861875a4fae0d75f994e35f1b79509bd", "patch": "@@ -20,20 +20,32 @@\n \f\n \n #define RL78_MUL_NONE\t(rl78_mul_type == MUL_NONE)\n-#define RL78_MUL_RL78\t(rl78_mul_type == MUL_RL78)\n #define RL78_MUL_G13\t(rl78_mul_type == MUL_G13)\n+#define RL78_MUL_G14\t(rl78_mul_type == MUL_G14)\n+\n+#define TARGET_G10\t(rl78_cpu_type == CPU_G10)\n+#define TARGET_G13\t(rl78_cpu_type == CPU_G13)\n+#define TARGET_G14\t(rl78_cpu_type == CPU_G14)\n \n #define TARGET_CPU_CPP_BUILTINS()               \\\n   do                                            \\\n     {                                           \\\n       builtin_define (\"__RL78__\"); \t\t\\\n       builtin_assert (\"cpu=RL78\"); \t\t\\\n-      if (RL78_MUL_RL78)\t\t\t\\\n-\tbuiltin_define (\"__RL78_MUL_RL78__\"); \t\\\n-      if (RL78_MUL_G13)\t\t\t\t\\\n+      \t\t\t\t\t\t\\\n+      if (RL78_MUL_NONE)\t\t\t\\\n+\tbuiltin_define (\"__RL78_MUL_NONE__\"); \t\\\n+      else if (RL78_MUL_G13)\t\t\t\\\n \tbuiltin_define (\"__RL78_MUL_G13__\"); \t\\\n+      else if (RL78_MUL_G14)\t\t\t\\\n+\tbuiltin_define (\"__RL78_MUL_G14__\"); \t\\\n+      \t\t\t\t\t\t\\\n       if (TARGET_G10)\t\t\t\t\\\n \tbuiltin_define (\"__RL78_G10__\"); \t\\\n+      else if (TARGET_G13)\t\t\t\\\n+\tbuiltin_define (\"__RL78_G13__\"); \t\\\n+      else if (TARGET_G14)\t\t\t\\\n+\tbuiltin_define (\"__RL78_G14__\"); \t\\\n     }                                           \\\n   while (0)\n \n@@ -46,7 +58,14 @@\n #undef  ASM_SPEC\n #define ASM_SPEC \"\\\n %{mrelax:-relax} \\\n-%{mg10} \\\n+%{mg10:--mg10} \\\n+%{mg13:--mg13} \\\n+%{mg14:--mg14} \\\n+%{mrl78:--mg14} \\\n+%{mcpu=g10:--mg10} \\\n+%{mcpu=g13:--mg13} \\\n+%{mcpu=g14:--mg14} \\\n+%{mcpu=rl78:--mg14} \\\n \"\n \n #undef  LINK_SPEC\n@@ -160,11 +179,11 @@\n */\n #define REGISTER_NAMES\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n-    \"x\", \"a\", \"c\", \"b\", \"e\", \"d\", \"l\", \"h\", \t\t\t\\\n-    \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\\\n+    \"x\",   \"a\",   \"c\",   \"b\",   \"e\",   \"d\",   \"l\",   \"h\", \t\\\n+    \"r8\",  \"r9\",  \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\\\n     \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\t\\\n     \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",\t\\\n-      \"sp\", \"ap\", \"psw\", \"es\", \"cs\"\t\t\t\t\\\n+    \"sp\",  \"ap\",  \"psw\", \"es\",  \"cs\"\t\t\t\t\\\n   }\n \n #define ADDITIONAL_REGISTER_NAMES\t\\"}, {"sha": "2ea788e5817b1c77b4cfa914c670f76e9861a581", "filename": "gcc/config/rl78/rl78.md", "status": "modified", "additions": 279, "deletions": 23, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Fconfig%2Frl78%2Frl78.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Fconfig%2Frl78%2Frl78.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.md?ref=72ed1126861875a4fae0d75f994e35f1b79509bd", "patch": "@@ -288,10 +288,13 @@\n )\n \n (define_expand \"mulqi3\"\n-  [(set (match_operand:QI          0 \"register_operand\")\n-\t(mult:QI  (match_operand:QI 1 \"general_operand\")\n-\t\t  (match_operand:QI 2 \"nonmemory_operand\")))\n-   ]\n+  [(parallel\n+    [(set (match_operand:QI            0 \"register_operand\")\n+\t   (mult:QI  (match_operand:QI 1 \"general_operand\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\")))\n+      (clobber (reg:HI AX_REG))\n+    ])\n+  ]\n   \"\" ; mulu supported by all targets\n   \"\"\n )\n@@ -302,7 +305,13 @@\n \t\t (match_operand:HI 2 \"nonmemory_operand\")))\n    ]\n   \"! RL78_MUL_NONE\"\n-  \"\"\n+  {\n+    if (RL78_MUL_G14)\n+      emit_insn (gen_mulhi3_g14 (operands[0], operands[1], operands[2]));\n+    else /* RL78_MUL_G13 */\n+      emit_insn (gen_mulhi3_g13 (operands[0], operands[1], operands[2]));\n+    DONE;\n+  }\n )\n \n (define_expand \"mulsi3\"\n@@ -311,14 +320,21 @@\n \t\t (match_operand:SI 2 \"nonmemory_operand\")))\n    ]\n   \"! RL78_MUL_NONE\"\n-  \"\"\n+  {\n+    if (RL78_MUL_G14)\n+      emit_insn (gen_mulsi3_g14 (operands[0], operands[1], operands[2]));\n+    else /* RL78_MUL_G13 */\n+      emit_insn (gen_mulsi3_g13 (operands[0], operands[1], operands[2]));\n+    DONE;\n+  }\n )\n \n (define_insn \"*mulqi3_rl78\"\n   [(set (match_operand:QI          0 \"register_operand\" \"=&v\")\n \t(mult:QI (match_operand:QI 1 \"general_operand\" \"viU\")\n \t\t (match_operand:QI 2 \"general_operand\" \"vi\")))\n-   ]\n+   (clobber (reg:HI AX_REG))\n+  ]\n   \"\" ; mulu supported by all targets\n   \"; mulqi macro %0 = %1 * %2\n \tmov    a, %h1\n@@ -328,31 +344,34 @@\n \tmov    a, x\n \tmov    %h0, a\n \t; end of mulqi macro\"\n-;;  [(set_attr \"valloc\" \"macax\")]\n+  [(set_attr \"valloc\" \"macax\")]\n )\n \n-(define_insn \"*mulhi3_rl78\"\n+(define_insn \"mulhi3_g14\"\n   [(set (match_operand:HI          0 \"register_operand\" \"=&v\")\n \t(mult:HI (match_operand:HI 1 \"general_operand\" \"viU\")\n \t\t (match_operand:HI 2 \"general_operand\" \"vi\")))\n-   ]\n-  \"RL78_MUL_RL78\"\n-  \"; mulhi macro %0 = %1 * %2\n+   (clobber (reg:HI AX_REG))\n+   (clobber (reg:HI BC_REG))\n+  ]\n+  \"RL78_MUL_G14\"\n+  \"; G14 mulhi macro %0 = %1 * %2\n \tmovw    ax, %h1\n \tmovw    bc, %h2\n \tmulhu   ; bcax = bc * ax\n \tmovw    %h0, ax\n \t; end of mulhi macro\"\n-;;  [(set_attr \"valloc\" \"macax\")]\n+  [(set_attr \"valloc\" \"macax\")]\n )\n \n-(define_insn \"*mulhi3_g13\"\n+(define_insn \"mulhi3_g13\"\n   [(set (match_operand:HI          0 \"register_operand\" \"=&v\")\n \t(mult:HI (match_operand:HI 1 \"general_operand\" \"viU\")\n \t\t (match_operand:HI 2 \"general_operand\" \"vi\")))\n-   ]\n+   (clobber (reg:HI AX_REG))\n+  ]\n   \"RL78_MUL_G13\"\n-  \"; mulhi macro %0 = %1 * %2\n+  \"; G13 mulhi macro %0 = %1 * %2\n \tmov     a, #0x00\n \tmov     !0xf00e8, a     ; MDUC\n \tmovw    ax, %h1\n@@ -363,19 +382,21 @@\n \tmovw    ax, 0xffff6     ; MDBL\n \tmovw    %h0, ax\n         ; end of mulhi macro\"\n-;;  [(set_attr \"valloc\" \"umul\")]\n+  [(set_attr \"valloc\" \"macax\")]\n )\n \n ;; 0xFFFF0 is MACR(L).  0xFFFF2 is MACR(H) but we don't care about it\n ;; because we're only using the lower 16 bits (which is the upper 16\n ;; bits of the result).\n-(define_insn \"mulsi3_rl78\"\n+(define_insn \"mulsi3_g14\"\n   [(set (match_operand:SI          0 \"register_operand\" \"=&v\")\n \t(mult:SI (match_operand:SI 1 \"general_operand\" \"viU\")\n \t\t (match_operand:SI 2 \"general_operand\" \"vi\")))\n-   ]\n-  \"RL78_MUL_RL78\"\n-  \"; mulsi macro %0 = %1 * %2\n+   (clobber (reg:HI AX_REG))\n+   (clobber (reg:HI BC_REG))\n+  ]\n+  \"RL78_MUL_G14\"\n+  \"; G14 mulsi macro %0 = %1 * %2\n \tmovw\tax, %h1\n \tmovw\tbc, %h2\n \tMULHU\t; bcax = bc * ax\n@@ -403,9 +424,11 @@\n   [(set (match_operand:SI          0 \"register_operand\" \"=&v\")\n \t(mult:SI (match_operand:SI 1 \"general_operand\" \"viU\")\n \t\t (match_operand:SI 2 \"general_operand\" \"viU\")))\n-   ]\n+   (clobber (reg:HI AX_REG))\n+   (clobber (reg:HI BC_REG))\n+  ]\n   \"RL78_MUL_G13\"\n-  \"; mulsi macro %0 = %1 * %2\n+  \"; G13 mulsi macro %0 = %1 * %2\n \tmov\ta, #0x00\n \tmov\t!0xf00e8, a\t; MDUC\n \tmovw\tax, %h1\n@@ -441,3 +464,236 @@\n \t; end of mulsi macro\"\n   [(set_attr \"valloc\" \"macax\")]\n )\n+\n+(define_expand \"udivmodhi4\"\n+  [(parallel\n+    [(set (match_operand:HI          0 \"register_operand\")\n+          (udiv:HI (match_operand:HI 1 \"register_operand\")\n+                   (match_operand:HI 2 \"register_operand\")))\n+     (set (match_operand:HI          3 \"register_operand\")\n+          (umod:HI (match_dup 1) (match_dup 2)))\n+     (clobber (reg:HI AX_REG))\n+     (clobber (reg:HI DE_REG))\n+    ])\n+   ]\n+  \"RL78_MUL_G14\"\n+  \"\"\n+)\n+\n+(define_insn \"*udivmodhi4_g14\"\n+  [(set (match_operand:HI          0 \"register_operand\" \"=v\")\n+\t(udiv:HI (match_operand:HI 1 \"register_operand\" \"v\")\n+\t\t (match_operand:HI 2 \"register_operand\" \"v\")))\n+   (set (match_operand:HI          3 \"register_operand\" \"=v\")\n+\t(umod:HI (match_dup 1) (match_dup 2)))\n+   (clobber (reg:HI AX_REG))\n+   (clobber (reg:HI DE_REG))\n+  ]\n+  \"RL78_MUL_G14\"\n+  {\n+    if (find_reg_note (insn, REG_UNUSED, operands[3]))\n+      return \"; G14 udivhi macro %0 = %1 / %2 \\n\\\n+\tmovw    ax, %h1 \\n\\\n+\tmovw    de, %h2 \\n\\\n+\tpush\tpsw\t; Save the current interrupt status \\n\\\n+\tdi\t\t; Disable interrupts. See Renesas Technical update TN-RL*-A025B/E \\n\\\n+\tdivhu   \t; ax = ax / de \\n\\\n+\tpop\tpsw\t; Restore saved interrupt status \\n\\\n+\tmovw    %h0, ax \\n\\\n+\t; end of udivhi macro\";\n+    else if (find_reg_note (insn, REG_UNUSED, operands[0]))\n+      return \"; G14 umodhi macro %3 = %1 %% %2 \\n\\\n+\tmovw    ax, %h1 \\n\\\n+\tmovw    de, %h2 \\n\\\n+\tpush\tpsw\t; Save the current interrupt status \\n\\\n+\tdi\t\t; Disable interrupts. See Renesas Technical update TN-RL*-A025B/E \\n\\\n+\tdivhu   \t; de = ax %% de \\n\\\n+\tpop\tpsw\t; Restore saved interrupt status \\n\\\n+\tmovw\tax, de \\n\\\n+\tmovw    %h3, ax \\n\\\n+\t; end of umodhi macro\";\n+    else\n+      return \"; G14 udivmodhi macro %0 = %1 / %2 and %3 = %1 %% %2 \\n\\\n+\tmovw    ax, %h1 \\n\\\n+\tmovw    de, %h2 \\n\\\n+\tpush\tpsw\t; Save the current interrupt status \\n\\\n+\tdi\t\t; Disable interrupts. See Renesas Technical update TN-RL*-A025B/E \\n\\\n+\tdivhu   \t; ax = ax / de, de = ax %% de \\n\\\n+\tpop\tpsw\t; Restore saved interrupt status \\n\\\n+\tmovw    %h0, ax \\n\\\n+\tmovw\tax, de \\n\\\n+\tmovw    %h3, ax \\n\\\n+\t; end of udivmodhi macro\";\n+  }\n+  [(set_attr \"valloc\" \"divhi\")]\n+)\n+\n+(define_expand \"udivmodsi4\"\n+  [(parallel\n+    [(set (match_operand:SI          0 \"register_operand\")\n+          (udiv:SI (match_operand:SI 1 \"register_operand\")\n+                   (match_operand:SI 2 \"register_operand\")))\n+     (set (match_operand:SI          3 \"register_operand\")\n+          (umod:SI (match_dup 1) (match_dup 2)))\n+    ])\n+   ]\n+  \"! RL78_MUL_NONE && ! optimize_size\"\n+  {\n+    if (RL78_MUL_G14)\n+      emit_insn (gen_udivmodsi4_g14 (operands[0], operands[1], operands[2], operands[3]));\n+    else /* RL78_MUL_G13 */\n+      emit_insn (gen_udivmodsi4_g13 (operands[0], operands[1], operands[2], operands[3]));\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"udivmodsi4_g14\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=v\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"v\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"v\")))\n+   (set (match_operand:SI          3 \"register_operand\" \"=v\")\n+\t(umod:SI (match_dup 1) (match_dup 2)))\n+   (clobber (reg:HI AX_REG))\n+   (clobber (reg:HI BC_REG))\n+   (clobber (reg:HI DE_REG))\n+   (clobber (reg:HI HL_REG))\n+  ]\n+  \"RL78_MUL_G14\"\n+  {\n+    if (find_reg_note (insn, REG_UNUSED, operands[3]))\n+      return \"; G14 udivsi macro %0 = %1 / %2 \\n\\\n+\tmovw    ax, %h1 \\n\\\n+\tmovw    bc, %H1 \\n\\\n+\tmovw    de, %h2 \\n\\\n+\tmovw    hl, %H2 \\n\\\n+\tpush\tpsw\t; Save the current interrupt status \\n\\\n+\tdi\t\t; Disable interrupts. See Renesas Technical update TN-RL*-A025B/E \\n\\\n+\tdivwu   \t; bcax = bcax / hlde \\n\\\n+\tpop\tpsw\t; Restore saved interrupt status \\n\\\n+\tmovw    %h0, ax \\n\\\n+\tmovw\tax, bc \\n\\\n+\tmovw    %H0, ax \\n\\\n+\t; end of udivsi macro\";\n+    else if (find_reg_note (insn, REG_UNUSED, operands[0]))\n+      return \"; G14 umodsi macro %3 = %1 %% %2 \\n\\\n+\tmovw    ax, %h1 \\n\\\n+\tmovw    bc, %H1 \\n\\\n+\tmovw    de, %h2 \\n\\\n+\tmovw    hl, %H2 \\n\\\n+\tpush\tpsw\t; Save the current interrupt status \\n\\\n+\tdi\t\t; Disable interrupts. See Renesas Technical update TN-RL*-A025B/E \\n\\\n+\tdivwu   \t; hlde = bcax %% hlde \\n\\\n+\tpop\tpsw\t; Restore saved interrupt status \\n\\\n+\tmovw\tax, de \\n\\\n+\tmovw    %h3, ax \\n\\\n+\tmovw\tax, hl \\n\\\n+\tmovw    %H3, ax \\n\\\n+\t; end of umodsi macro\";\n+    else\n+      return \"; G14 udivmodsi macro %0 = %1 / %2 and %3 = %1 %% %2 \\n\\\n+\tmovw    ax, %h1 \\n\\\n+\tmovw    bc, %H1 \\n\\\n+\tmovw    de, %h2 \\n\\\n+\tmovw    hl, %H2 \\n\\\n+\tpush\tpsw\t; Save the current interrupt status \\n\\\n+\tdi\t\t; Disable interrupts. See Renesas Technical update TN-RL*-A025B/E \\n\\\n+\tdivwu   \t; bcax = bcax / hlde, hlde = bcax %% hlde \\n\\\n+\tpop\tpsw\t; Restore saved interrupt status \\n\\\n+\tmovw    %h0, ax \\n\\\n+\tmovw\tax, bc \\n\\\n+\tmovw    %H0, ax \\n\\\n+\tmovw\tax, de \\n\\\n+\tmovw    %h3, ax \\n\\\n+\tmovw\tax, hl \\n\\\n+\tmovw    %H3, ax \\n\\\n+\t; end of udivmodsi macro\";\n+  }\n+  [(set_attr \"valloc\" \"divsi\")]\n+)\n+\n+;; Warning: these values match the silicon not the documentation.\n+;; 0xFFFF0 is MDAL.  0xFFFF2 is MDAH.\n+;; 0xFFFF6 is MDBL.  0xFFFF4 is MDBH.\n+;; 0xF00E0 is MDCL.  0xF00E2 is MDCH.\n+;; 0xF00E8 is MDUC.\n+\n+(define_insn \"udivmodsi4_g13\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=v\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"v\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"v\")))\n+   (set (match_operand:SI          3 \"register_operand\" \"=v\")\n+\t(umod:SI (match_dup 1) (match_dup 2)))\n+   (clobber (reg:HI AX_REG))\n+  ]\n+  \"RL78_MUL_G13\"\n+  {\n+    if (find_reg_note (insn, REG_UNUSED, operands[3]))\n+      return \"; G13 udivsi macro %0 = %1 / %2 \\n\\\n+\tmov\ta, #0xC0\t; Set DIVMODE=1 and MACMODE=1 \\n\\\n+\tmov\t!0xf00e8, a\t; This preps the peripheral for division without interrupt generation \\n\\\n+\tmovw\tax, %H1\t\t\\n\\\n+\tmovw\t0xffff2, ax\t; MDAH \\n\\\n+\tmovw\tax, %h1\t\t\\n\\\n+\tmovw\t0xffff0, ax\t; MDAL \\n\\\n+\tmovw\tax, %H2\t\t\\n\\\n+\tmovw\t0xffff4, ax\t; MDBH \\n\\\n+\tmovw\tax, %h2\t\t\\n\\\n+\tmovw\t0xffff6, ax\t; MDBL \\n\\\n+\tmov\ta, #0xC1\t; Set the DIVST bit in MDUC \\n\\\n+\tmov\t!0xf00e8, a\t; This starts the division op \\n\\\n+1:\tmov\ta, !0xf00e8\t; Wait 16 clocks or until DIVST is clear \\n\\\n+\tbt\ta.0, $1b\t\\n\\\n+\tmovw    ax, 0xffff0\t; Read the quotient \\n\\\n+\tmovw\t%h0, ax\t\t\\n\\\n+\tmovw    ax, 0xffff2\t\\n\\\n+\tmovw\t%H0, ax\t\t\\n\\\n+\t; end of udivsi macro\";\n+    else if (find_reg_note (insn, REG_UNUSED, operands[0]))\n+      return \"; G13 umodsi macro %3 = %1 %% %2 \\n\\\n+\tmov\ta, #0xC0\t; Set DIVMODE=1 and MACMODE=1 \\n\\\n+\tmov\t!0xf00e8, a\t; This preps the peripheral for division without interrupt generation \\n\\\n+\tmovw\tax, %H1\t\t\\n\\\n+\tmovw\t0xffff2, ax\t; MDAH \\n\\\n+\tmovw\tax, %h1\t\t\\n\\\n+\tmovw\t0xffff0, ax\t; MDAL \\n\\\n+\tmovw\tax, %H2\t\t\\n\\\n+\tmovw\t0xffff4, ax\t; MDBH \\n\\\n+\tmovw\tax, %h2\t\t\\n\\\n+\tmovw\t0xffff6, ax\t; MDBL \\n\\\n+\tmov\ta, #0xC1\t; Set the DIVST bit in MDUC \\n\\\n+\tmov\t!0xf00e8, a\t; This starts the division op \\n\\\n+1:\tmov\ta, !0xf00e8\t; Wait 16 clocks or until DIVST is clear \\n\\\n+\tbt\ta.0, $1b\t\\n\\\n+  \tmovw\tax, !0xf00e0\t; Read the remainder \\n\\\n+\tmovw\t%h3, ax\t\t\\n\\\n+\tmovw\tax, !0xf00e2\t\\n\\\n+\tmovw\t%H3, ax\t\t\\n\\\n+\t; end of umodsi macro\";\n+    else\n+      return \"; G13 udivmodsi macro %0 = %1 / %2 and %3 = %1 %% %2 \\n\\\n+\tmov\ta, #0xC0\t; Set DIVMODE=1 and MACMODE=1 \\n\\\n+\tmov\t!0xf00e8, a\t; This preps the peripheral for division without interrupt generation \\n\\\n+\tmovw\tax, %H1\t\t\\n\\\n+\tmovw\t0xffff2, ax\t; MDAH \\n\\\n+\tmovw\tax, %h1\t\t\\n\\\n+\tmovw\t0xffff0, ax\t; MDAL \\n\\\n+\tmovw\tax, %H2\t\t\\n\\\n+\tmovw\t0xffff4, ax\t; MDBH \\n\\\n+\tmovw\tax, %h2\t\t\\n\\\n+\tmovw\t0xffff6, ax\t; MDBL \\n\\\n+\tmov\ta, #0xC1\t; Set the DIVST bit in MDUC \\n\\\n+\tmov\t!0xf00e8, a\t; This starts the division op \\n\\\n+1:\tmov\ta, !0xf00e8\t; Wait 16 clocks or until DIVST is clear \\n\\\n+\tbt\ta.0, $1b\t\\n\\\n+\tmovw    ax, 0xffff0\t; Read the quotient \\n\\\n+\tmovw\t%h0, ax\t\t\\n\\\n+\tmovw    ax, 0xffff2\t\\n\\\n+\tmovw\t%H0, ax\t\t\\n\\\n+  \tmovw\tax, !0xf00e0\t; Read the remainder \\n\\\n+\tmovw\t%h3, ax\t\t\\n\\\n+\tmovw\tax, !0xf00e2\t\\n\\\n+\tmovw\t%H3, ax\t\t\\n\\\n+\t; end of udivmodsi macro\";\n+      }\n+  [(set_attr \"valloc\" \"macax\")]\n+)"}, {"sha": "80b894a6e674598aa111d3189bd0e57577f1ea4a", "filename": "gcc/config/rl78/rl78.opt", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Fconfig%2Frl78%2Frl78.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Fconfig%2Frl78%2Frl78.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.opt?ref=72ed1126861875a4fae0d75f994e35f1b79509bd", "patch": "@@ -27,20 +27,23 @@ Target Report\n Use the simulator runtime.\n \n mmul=\n-Target RejectNegative Joined Var(rl78_mul_type) Report Tolower Enum(rl78_mul_types) Init(MUL_NONE)\n-Select hardware or software multiplication support.\n+Target RejectNegative Joined Var(rl78_mul_type) Report Tolower Enum(rl78_mul_types) Init(MUL_UNINIT)\n+Selects the type of hardware multiplication and division to use (none/g13/g14).\n \n Enum\n Name(rl78_mul_types) Type(enum rl78_mul_types)\n \n EnumValue\n-Enum(rl78_mul_types) String(none) Value(MUL_NONE)\n+Enum(rl78_mul_types) String(g10) Value(MUL_NONE)\n \n EnumValue\n-Enum(rl78_mul_types) String(rl78) Value(MUL_RL78)\n+Enum(rl78_mul_types) String(g13) Value(MUL_G13)\n \n EnumValue\n-Enum(rl78_mul_types) String(g13) Value(MUL_G13)\n+Enum(rl78_mul_types) String(g14) Value(MUL_G14)\n+\n+EnumValue\n+Enum(rl78_mul_types) String(rl78) Value(MUL_G14)\n \n mallregs\n Target Mask(ALLREGS) Report Optimization\n@@ -50,9 +53,40 @@ mrelax\n Target Report Optimization\n Enable assembler and linker relaxation.  Enabled by default at -Os.\n \n+mcpu=\n+Target RejectNegative Joined Var(rl78_cpu_type) Report ToLower Enum(rl78_cpu_types) Init(CPU_UNINIT)\n+Selects the type of RL78 core being targeted (g10/g13/g14).  The default is the G14.  If set, also selects the hardware multiply support to be used.\n+\n+Enum\n+Name(rl78_cpu_types) Type(enum rl78_cpu_types)\n+\n+EnumValue\n+Enum(rl78_cpu_types) String(g10) Value(CPU_G10)\n+\n+EnumValue\n+Enum(rl78_cpu_types) String(g13) Value(CPU_G13)\n+\n+EnumValue\n+Enum(rl78_cpu_types) String(g14) Value(CPU_G14)\n+\n+EnumValue\n+Enum(rl78_cpu_types) String(rl78) Value(CPU_G14)\n+\n mg10\n-Target Mask(G10) Report\n-Target the RL78/G10 series\n+Target RejectNegative Report Alias(mcpu=, g10)\n+Alias for -mcpu=g10\n+\n+mg13\n+Target RejectNegative Report Alias(mcpu=, g13)\n+Alias for -mcpu=g13\n+\n+mg14\n+Target RejectNegative Report Alias(mcpu=, g14)\n+Alias for -mcpu=g14\n+\n+mrl78\n+Target RejectNegative Report Alias(mcpu=, g14)\n+Alias for -mcpu=g14\n \n mes0\n Target Mask(ES0)"}, {"sha": "bd8fab430e0f4c227e2e8032251d1283e730878d", "filename": "gcc/config/rl78/t-rl78", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Fconfig%2Frl78%2Ft-rl78", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Fconfig%2Frl78%2Ft-rl78", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Ft-rl78?ref=72ed1126861875a4fae0d75f994e35f1b79509bd", "patch": "@@ -23,5 +23,7 @@ rl78-c.o: $(srcdir)/config/rl78/rl78-c.c $(RTL_H) $(TREE_H) $(CONFIG_H) $(TM_H)\n \n # Enable multilibs:\n \n-MULTILIB_OPTIONS    = mg10\n-MULTILIB_DIRNAMES   = g10\n+MULTILIB_OPTIONS    = mg10/mg13/mg14\n+MULTILIB_DIRNAMES   = g10 g13 g14\n+\n+MULTILIB_MATCHES    = mg10=mcpu?g10 mg13=mcpu?g13 mg14=mcpu?g14 mg14=mcpu?rl78"}, {"sha": "bb173854663c3c8196b48879d64bcc1beedae910", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 71, "deletions": 13, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=72ed1126861875a4fae0d75f994e35f1b79509bd", "patch": "@@ -265,7 +265,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wmain -Wmaybe-uninitialized -Wmemset-transposed-args -Wmissing-braces @gol\n -Wmissing-field-initializers -Wmissing-include-dirs @gol\n -Wno-multichar  -Wnonnull  -Wnormalized=@r{[}none@r{|}id@r{|}nfc@r{|}nfkc@r{]} @gol\n- -Wodr  -Wno-overflow  -Wopenmp-simd @gol\n+-Wodr  -Wno-overflow  -Wopenmp-simd @gol\n -Woverlength-strings  -Wpacked  -Wpacked-bitfield-compat  -Wpadded @gol\n -Wparentheses  -Wpedantic-ms-format -Wno-pedantic-ms-format @gol\n -Wpointer-arith  -Wno-pointer-to-int-cast @gol\n@@ -277,7 +277,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wstack-protector -Wstack-usage=@var{len} -Wstrict-aliasing @gol\n -Wstrict-aliasing=n @gol -Wstrict-overflow -Wstrict-overflow=@var{n} @gol\n -Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{]} @gol\n--Wsuggest-final-types @gol -Wsuggest-final-methods @gol -Wsuggest-override @gol\n+-Wsuggest-final-types @gol -Wsuggest-final-methods -Wsuggest-override @gol\n -Wmissing-format-attribute @gol\n -Wswitch  -Wswitch-default  -Wswitch-enum -Wswitch-bool -Wsync-nand @gol\n -Wsystem-headers  -Wtrampolines  -Wtrigraphs  -Wtype-limits  -Wundef @gol\n@@ -405,7 +405,7 @@ Objective-C and Objective-C++ Dialects}.\n -fisolate-erroneous-paths-dereference -fisolate-erroneous-paths-attribute @gol\n -fivopts -fkeep-inline-functions -fkeep-static-consts @gol\n -flive-range-shrinkage @gol\n--floop-block -floop-interchange -floop-strip-mine @gol  \n+-floop-block -floop-interchange -floop-strip-mine @gol\n -floop-unroll-and-jam -floop-nest-optimize @gol\n -floop-parallelize-all -flra-remat -flto -flto-compression-level @gol\n -flto-partition=@var{alg} -flto-report -flto-report-wpa -fmerge-all-constants @gol\n@@ -870,7 +870,8 @@ Objective-C and Objective-C++ Dialects}.\n See RS/6000 and PowerPC Options.\n \n @emph{RL78 Options}\n-@gccoptlist{-msim -mmul=none -mmul=g13 -mmul=rl78 @gol\n+@gccoptlist{-msim -mmul=none -mmul=g13 -mmul=g14 -mallregs @gol\n+-mcpu=g10 -mcpu=g13 -mcpu=g14 -mg10 -mg13 -mg14 @gol\n -m64bit-doubles -m32bit-doubles}\n \n @emph{RS/6000 and PowerPC Options}\n@@ -1786,7 +1787,7 @@ Using this option is roughly equivalent to adding the\n \n The option @option{-fno-gnu89-inline} explicitly tells GCC to use the\n C99 semantics for @code{inline} when in C99 or gnu99 mode (i.e., it\n-specifies the default behavior).  \n+specifies the default behavior).\n This option is not supported in @option{-std=c90} or\n @option{-std=gnu90} mode.\n \n@@ -2090,7 +2091,7 @@ Version 0 refers to the version conforming most closely to\n the C++ ABI specification.  Therefore, the ABI obtained using version 0\n will change in different versions of G++ as ABI bugs are fixed.\n \n-Version 1 is the version of the C++ ABI that first appeared in G++ 3.2.  \n+Version 1 is the version of the C++ ABI that first appeared in G++ 3.2.\n \n Version 2 is the version of the C++ ABI that first appeared in G++\n 3.4, and was the default through G++ 4.9.\n@@ -4354,7 +4355,6 @@ pointers. This warning level may give a larger number of\n false positives and is deactivated by default.\n @end table\n \n-\n @item -Wbool-compare\n @opindex Wno-bool-compare\n @opindex Wbool-compare\n@@ -5890,7 +5890,7 @@ Bounds Checker builtins}, for more information.\n @opindex fchkp-check-incomplete-type\n @opindex fno-chkp-check-incomplete-type\n Generate pointer bounds checks for variables with incomplete type.\n-Enabled by default.  \n+Enabled by default.\n \n @item -fchkp-narrow-bounds\n @opindex fchkp-narrow-bounds\n@@ -18730,14 +18730,72 @@ Links in additional target libraries to support operation within a\n simulator.\n \n @item -mmul=none\n+@itemx -mmul=g10\n @itemx -mmul=g13\n+@itemx -mmul=g14\n @itemx -mmul=rl78\n @opindex mmul\n-Specifies the type of hardware multiplication support to be used.  The\n-default is @samp{none}, which uses software multiplication functions.\n-The @samp{g13} option is for the hardware multiply/divide peripheral\n-only on the RL78/G13 targets.  The @samp{rl78} option is for the\n-standard hardware multiplication defined in the RL78 software manual.\n+Specifies the type of hardware multiplication and division support to\n+be used.  The simplest is @code{none}, which uses software for both\n+multiplication and division.  This is the default.  The @code{g13}\n+value is for the hardware multiply/divide peripheral found on the\n+RL78/G13 (S2 core) targets.  The @code{g14} value selects the use of\n+the multiplication and division instructions supported by the RL78/G14\n+(S3 core) parts.  The value @code{rl78} is an alias for @code{g14} and\n+the value @code{mg10} is an alias for @code{none}.\n+\n+In addition a C preprocessor macro is defined, based upon the setting\n+of this option.  Possible values are: @code{__RL78_MUL_NONE__},\n+@code{__RL78_MUL_G13__} or @code{__RL78_MUL_G14__}.\n+\n+@item -mcpu=g10\n+@itemx -mcpu=g13\n+@itemx -mcpu=g14\n+@itemx -mcpu=rl78\n+@opindex mcpu\n+Specifies the RL78 core to target.  The default is the G14 core, also\n+known as an S3 core or just RL78.  The G13 or S2 core does not have\n+multiply or divide instructions, instead it uses a hardware peripheral\n+for these operations.  The G10 or S1 core does not have register\n+banks, so it uses a different calling convention.\n+\n+If this option is set it also selects the type of hardware multiply\n+support to use, unless this is overridden by an explicit\n+@option{-mmul=none} option on the command line.  Thus specifying\n+@option{-mcpu=g13} enables the use of the G13 hardware multiply\n+peripheral and specifying @option{-mcpu=g10} disables the use of\n+hardware multipications altogether.\n+\n+Note, although the RL78/G14 core is the default target, specifying\n+@option{-mcpu=g14} or @option{-mcpu=rl78} on the command line does\n+change the behaviour of the toolchain since it also enables G14\n+hardware multiply support.  If these options are not specified on the\n+command line then software multiplication routines will be used even\n+though the code targets the RL78 core.  This is for backwards\n+compatibility with older toolchains which did not have hardware\n+multiply and divide support.\n+\n+In addition a C preprocessor macro is defined, based upon the setting\n+of this option.  Possible values are: @code{__RL78_G10__},\n+@code{__RL78_G13__} or @code{__RL78_G14__}.\n+\n+@item -mg10\n+@itemx -mg13\n+@itemx -mg14\n+@itemx -mrl78\n+@opindex mg10\n+@opindex mg13\n+@opindex mg14\n+@opindex mrl78\n+These are aliases for the corresponding @option{-mcpu=} option.  They\n+are provided for backwards compatibility.\n+\n+@item -mallregs\n+@opindex mallregs\n+Allow the compiler to use all of the available registers.  By default\n+registers @code{r24..r31} are reserved for use in interrupt handlers.\n+With this option enabled these registers can be used in ordinary\n+functions as well.\n \n @item -m64bit-doubles\n @itemx -m32bit-doubles"}, {"sha": "639d12de6832d49e35b199d06e9ebf3e5cf909a1", "filename": "gcc/testsuite/gcc.c-torture/execute/20101011-1.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20101011-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed1126861875a4fae0d75f994e35f1b79509bd/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20101011-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20101011-1.c?ref=72ed1126861875a4fae0d75f994e35f1b79509bd", "patch": "@@ -12,6 +12,18 @@\n #elif defined (__sh__)\n   /* On SH division by zero does not trap.  */\n # define DO_TEST 0\n+#elif defined (__v850__)\n+  /* On V850 division by zero does not trap.  */\n+# define DO_TEST 0\n+#elif defined (__MSP430__)\n+  /* On MSP430 division by zero does not trap.  */\n+# define DO_TEST 0\n+#elif defined (__RL78__)\n+  /* On RL78 division by zero does not trap.  */\n+# define DO_TEST 0\n+#elif defined (__RX__)\n+  /* On RX division by zero does not trap.  */\n+# define DO_TEST 0\n #elif defined (__aarch64__)\n   /* On AArch64 integer division by zero does not trap.  */\n # define DO_TEST 0"}, {"sha": "a21afe86fc51c118c22779f8cb930ca4081bb366", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed1126861875a4fae0d75f994e35f1b79509bd/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed1126861875a4fae0d75f994e35f1b79509bd/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=72ed1126861875a4fae0d75f994e35f1b79509bd", "patch": "@@ -1,3 +1,10 @@\n+2015-04-16  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/rl78/divmodhi.S: Add G14 and G13 versions of the __divhi3\n+\tand __modhi3 functions.\n+\t* config/rl78/divmodso.S: Add G14 and G13 versions of the\n+\t__divsi3, __udivsi3, __modsi3 and __umodsi3 functions.\n+\n 2015-04-15  Chen Gang  <gang.chen.5i5j@gmail.com>\n \n \t* gthr-single.h (__GTHREAD_MUTEX_INIT_FUNCTION): Use empty"}, {"sha": "adf91e2c9e624ea820a44a226dc54a3045c7ce60", "filename": "libgcc/config/rl78/divmodhi.S", "status": "modified", "additions": 362, "deletions": 0, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed1126861875a4fae0d75f994e35f1b79509bd/libgcc%2Fconfig%2Frl78%2Fdivmodhi.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed1126861875a4fae0d75f994e35f1b79509bd/libgcc%2Fconfig%2Frl78%2Fdivmodhi.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Fdivmodhi.S?ref=72ed1126861875a4fae0d75f994e35f1b79509bd", "patch": "@@ -25,6 +25,360 @@\n \n #include \"vregs.h\"\n \n+#if defined __RL78_MUL_G14__\n+\n+START_FUNC ___divhi3\n+\t;; r8 = 4[sp] / 6[sp]\n+\n+\t;; Test for a negative denumerator.\n+\tmovw\tax, [sp+6]\n+\tmov1\tcy, a.7\n+\tmovw\tde, ax\n+\tbc\t$__div_neg_den\n+\n+\t;; Test for a negative numerator.\n+\tmovw\tax, [sp+4]\n+\tmov1\tcy, a.7\n+\tbc\t$__div_neg_num\n+\n+\t;; Neither are negative - we can use the unsigned divide instruction.\n+__div_no_convert:\t\n+\tpush\tpsw\n+\tdi\n+\tdivhu\n+\tpop\tpsw\n+\t\n+\tmovw\tr8, ax\n+\tret\n+\n+__div_neg_den:\n+\t;; Negate the denumerator (which is in DE)\n+\tclrw\tax\n+\tsubw\tax, de\n+\tmovw\tde, ax\n+\t\n+\t;; Test for a negative numerator.\n+\tmovw\tax, [sp+4]\n+\tmov1\tcy, a.7\n+\t;; If it is not negative then we perform the division and then negate the result.\n+\tbnc\t$__div_then_convert\n+\n+\t;; Otherwise we negate the numerator and then go with an unsigned division.\n+\tmovw\tbc, ax\n+\tclrw\tax\n+\tsubw\tax, bc\n+\tbr\t$__div_no_convert\n+\n+__div_neg_num:\n+\t;; Negate the numerator (which is in AX)\n+\t;; We know that the denumerator is positive.\n+\tmovw\tbc, ax\n+\tclrw\tax\n+\tsubw\tax, bc\n+\t\n+__div_then_convert:\n+\tpush\tpsw\n+\tdi\n+\tdivhu\n+\tpop\tpsw\n+\t\n+\t;; Negate result and transfer into r8\n+\tmovw\tbc, ax\n+\tclrw\tax\n+\tsubw\tax, bc\n+\tmovw\tr8, ax\n+\tret\n+\n+END_FUNC ___divhi3\n+\n+;----------------------------------------------------------------------\n+\n+START_FUNC ___modhi3\n+\t;; r8 = 4[sp] % 6[sp]\n+\n+\t;; Test for a negative denumerator.\n+\tmovw\tax, [sp+6]\n+\tmov1\tcy, a.7\n+\tmovw\tde, ax\n+\tbc\t$__mod_neg_den\n+\n+\t;; Test for a negative numerator.\n+\tmovw\tax, [sp+4]\n+\tmov1\tcy, a.7\n+\tbc\t$__mod_neg_num\n+\n+\t;; Neither are negative - we can use the unsigned divide instruction.\n+__mod_no_convert:\t\n+\tpush\tpsw\n+\tdi\n+\tdivhu\n+\tpop\tpsw\n+\n+\tmovw\tax, de\n+\tmovw\tr8, ax\n+\tret\n+\n+__mod_neg_den:\t\n+\t;; Negate the denumerator (which is in DE)\n+\tclrw\tax\n+\tsubw\tax, de\n+\tmovw\tde, ax\n+\t\n+\t;; Test for a negative numerator.\n+\tmovw\tax, [sp+4]\n+\tmov1\tcy, a.7\n+\t;; If it is not negative then we perform the modulo operation without conversion.\n+\tbnc\t$__mod_no_convert\n+\n+\t;; Otherwise we negate the numerator and then go with an unsigned modulo operation.\n+\tmovw\tbc, ax\n+\tclrw\tax\n+\tsubw\tax, bc\n+\tbr\t$__mod_then_convert\n+\n+__mod_neg_num:\n+\t;; Negate the numerator (which is in AX)\n+\t;; We know that the denumerator is positive.\n+\tmovw\tbc, ax\n+\tclrw\tax\n+\tsubw\tax, bc\n+\t\n+__mod_then_convert:\n+\tpush\tpsw\n+\tdi\n+\tdivhu\n+\tpop\tpsw\n+\n+\t;; Negate result and transfer into r8\n+\tclrw\t  ax\n+\tsubw\t  ax, de\n+\tmovw\t  r8, ax\n+\tret\n+\n+END_FUNC ___modhi3\n+\n+;----------------------------------------------------------------------\n+\n+#elif defined __RL78_MUL_G13__\n+\n+\t;; The G13 S2 core does not have a 16 bit divide peripheral.\n+\t;; So instead we perform a 32-bit divide and twiddle the inputs\n+\t;; as necessary.\n+\n+\t;; Hardware registers.  Note - these values match the silicon, not the documentation.\n+\tMDAL = 0xffff0\n+\tMDAH = 0xffff2\n+\tMDBL = 0xffff6\n+\tMDBH = 0xffff4\n+\tMDCL = 0xf00e0\n+\tMDCH = 0xf00e2\n+\tMDUC = 0xf00e8\n+\n+.macro _Negate src, dest\n+\tmovw\tax, !\\src\n+\tmovw\tbc, ax\n+\tclrw\tax\n+\tsubw\tax, bc\n+\tmovw\t\\dest, ax\n+.endm\n+\t\n+;----------------------------------------------------------------------\n+\t\n+START_FUNC ___divhi3\n+\t;; r8 = 4[sp] / 6[sp] (signed division)\n+\n+\tmov\ta, #0xC0\t; Set DIVMODE=1 and MACMODE=1\n+\tmov\t!MDUC, a\t; This preps the peripheral for division without interrupt generation\n+\n+\tclrw\tax     \t\t; Clear the top 16-bits of the divisor and dividend\n+\tmovw\tMDBH, ax\n+\tmovw\tMDAH, ax\n+\t\n+\t;; Load and test for a negative denumerator.\n+\tmovw\tax, [sp+6]\n+\tmovw\tMDBL, ax\n+\tmov1\tcy, a.7\n+\tbc\t$__div_neg_den\n+\n+\t;; Load and test for a negative numerator.\n+\tmovw\tax, [sp+4]\n+\tmov1\tcy, a.7\n+\tmovw\tMDAL, ax\n+\tbc\t$__div_neg_num\n+\n+\t;; Neither are negative - we can use the unsigned divide hardware.\n+__div_no_convert:\t\n+\tmov\ta, #0xC1\t; Set the DIVST bit in MDUC\n+\tmov\t!MDUC, a\t; This starts the division op\n+\n+1:\tmov\ta, !MDUC\t; Wait 16 clocks or until DIVST is clear\n+\tbt\ta.0, $1b\n+\n+  \tmovw\tax, MDAL\t; Read the result\n+\tmovw\tr8, ax\n+\tret\n+\n+__div_neg_den:\n+\t;; Negate the denumerator (which is in MDBL)\n+\t_Negate MDBL MDBL\n+\n+\t;; Load and test for a negative numerator.\n+\tmovw\tax, [sp+4]\n+\tmov1\tcy, a.7\n+\tmovw\tMDAL, ax\n+\t;; If it is not negative then we perform the division and then negate the result.\n+\tbnc\t$__div_then_convert\n+\n+\t;; Otherwise we negate the numerator and then go with a straightforward unsigned division.\n+\t_Negate MDAL MDAL\n+\tbr\t$!__div_no_convert\n+\n+__div_neg_num:\n+\t;; Negate the numerator (which is in MDAL)\n+\t;; We know that the denumerator is positive.\n+\t_Negate MDAL MDAL\n+\t\n+__div_then_convert:\n+\tmov\ta, #0xC1\t; Set the DIVST bit in MDUC\n+\tmov\t!MDUC, a\t; This starts the division op\n+\n+1:\tmov\ta, !MDUC\t; Wait 16 clocks or until DIVST is clear\n+\tbt\ta.0, $1b\n+\n+\t;; Negate result and transfer into r8\n+\t_Negate MDAL r8\n+\tret\n+\n+END_FUNC ___divhi3\n+\n+;----------------------------------------------------------------------\n+\n+START_FUNC ___modhi3\n+\t;; r8 = 4[sp] % 6[sp] (signed modulus)\n+\n+\tmov\ta, #0xC0\t; Set DIVMODE=1 and MACMODE=1\n+\tmov\t!MDUC, a\t; This preps the peripheral for division without interrupt generation\n+\n+\tclrw\tax     \t\t; Clear the top 16-bits of the divisor and dividend\n+\tmovw\tMDBH, ax\n+\tmovw\tMDAH, ax\n+\t\n+\t;; Load and test for a negative denumerator.\n+\tmovw\tax, [sp+6]\n+\tmovw\tMDBL, ax\n+\tmov1\tcy, a.7\n+\tbc\t$__mod_neg_den\n+\n+\t;; Load and test for a negative numerator.\n+\tmovw\tax, [sp+4]\n+\tmov1\tcy, a.7\n+\tmovw\tMDAL, ax\n+\tbc\t$__mod_neg_num\n+\n+\t;; Neither are negative - we can use the unsigned divide hardware\n+__mod_no_convert:\t\n+\tmov\ta, #0xC1\t; Set the DIVST bit in MDUC\n+\tmov\t!MDUC, a\t; This starts the division op\n+\n+1:\tmov\ta, !MDUC\t; Wait 16 clocks or until DIVST is clear\n+\tbt\ta.0, $1b\n+\n+  \tmovw\tax, !MDCL\t; Read the remainder\n+\tmovw\tr8, ax\n+\tret\n+\n+__mod_neg_den:\n+\t;; Negate the denumerator (which is in MDBL)\n+\t_Negate MDBL MDBL\n+\t\n+\t;; Load and test for a negative numerator.\n+\tmovw\tax, [sp+4]\n+\tmov1\tcy, a.7\n+\tmovw\tMDAL, ax\n+\t;; If it is not negative then we perform the modulo operation without conversion.\n+\tbnc\t$__mod_no_convert\n+\n+\t;; Otherwise we negate the numerator and then go with a modulo followed by negation.\n+\t_Negate MDAL MDAL\n+\tbr\t$!__mod_then_convert\n+\n+__mod_neg_num:\n+\t;; Negate the numerator (which is in MDAL)\n+\t;; We know that the denumerator is positive.\n+\t_Negate MDAL MDAL\n+\t\n+__mod_then_convert:\n+\tmov\ta, #0xC1\t; Set the DIVST bit in MDUC\n+\tmov\t!MDUC, a\t; This starts the division op\n+\n+1:\tmov\ta, !MDUC\t; Wait 16 clocks or until DIVST is clear\n+\tbt\ta.0, $1b\n+\n+\t_Negate\tMDCL r8\n+\tret\n+\n+END_FUNC ___modhi3\n+\n+;----------------------------------------------------------------------\n+\n+START_FUNC ___udivhi3\n+\t;; r8 = 4[sp] / 6[sp] (unsigned division)\n+\n+\tmov\ta, #0xC0\t; Set DIVMODE=1 and MACMODE=1\n+\tmov\t!MDUC, a\t; This preps the peripheral for division without interrupt generation\n+\n+\tmovw\tax, [sp+4]\t; Load the divisor\n+\tmovw\tMDAL, ax\n+\tmovw\tax, [sp+6]\t; Load the dividend\n+\tmovw\tMDBL, ax\n+\tclrw\tax\n+\tmovw\tMDAH, ax\n+\tmovw\tMDBH, ax\n+\t\n+\tmov\ta, #0xC1\t; Set the DIVST bit in MDUC\n+\tmov\t!MDUC, a\t; This starts the division op\n+\n+1:\tmov\ta, !MDUC\t; Wait 16 clocks or until DIVST is clear\n+\tbt\ta.0, $1b\n+\n+  \tmovw\tax, !MDAL\t; Read the remainder\n+\tmovw\tr8, ax\n+\tret\n+\n+END_FUNC   ___udivhi3\n+\n+;----------------------------------------------------------------------\n+\n+START_FUNC ___umodhi3\n+\t;; r8 = 4[sp] % 6[sp] (unsigned modulus)\n+\n+\tmov\ta, #0xC0\t; Set DIVMODE=1 and MACMODE=1\n+\tmov\t!MDUC, a\t; This preps the peripheral for division without interrupt generation\n+\n+\tmovw\tax, [sp+4]\t; Load the divisor\n+\tmovw\tMDAL, ax\n+\tmovw\tax, [sp+6]\t; Load the dividend\n+\tmovw\tMDBL, ax\n+\tclrw\tax\n+\tmovw\tMDAH, ax\n+\tmovw\tMDBH, ax\n+\t\n+\tmov\ta, #0xC1\t; Set the DIVST bit in MDUC\n+\tmov\t!MDUC, a\t; This starts the division op\n+\n+1:\tmov\ta, !MDUC\t; Wait 16 clocks or until DIVST is clear\n+\tbt\ta.0, $1b\n+\n+  \tmovw\tax, !MDCL\t; Read the remainder\n+\tmovw\tr8, ax\n+\tret\n+\t\n+END_FUNC   ___umodhi3\n+\n+;----------------------------------------------------------------------\n+\t\n+#elif defined __RL78_MUL_NONE__\n+\t\n .macro MAKE_GENERIC  which,need_result\n \n \t.if \\need_result\n@@ -328,3 +682,11 @@ mod_no_neg:\n mod_skip_restore_den:\t\n \tret\n END_FUNC ___modhi3\n+\n+;----------------------------------------------------------------------\n+\n+#else\n+\n+#error \"Unknown RL78 hardware multiply/divide support\"\n+\n+#endif"}, {"sha": "987a9e31126a79729aefdefb584e95b8e29fb2f8", "filename": "libgcc/config/rl78/divmodsi.S", "status": "modified", "additions": 541, "deletions": 0, "changes": 541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ed1126861875a4fae0d75f994e35f1b79509bd/libgcc%2Fconfig%2Frl78%2Fdivmodsi.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ed1126861875a4fae0d75f994e35f1b79509bd/libgcc%2Fconfig%2Frl78%2Fdivmodsi.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Fdivmodsi.S?ref=72ed1126861875a4fae0d75f994e35f1b79509bd", "patch": "@@ -25,6 +25,537 @@\n \n #include \"vregs.h\"\n \n+#if defined __RL78_MUL_G14__\n+\n+START_FUNC ___divsi3\n+\t;; r8,r10 = 4[sp],6[sp] / 8[sp],10[sp]\n+\n+\t;; Load and test for a negative denumerator.\n+\tmovw\tax, [sp+8]\n+\tmovw\tde, ax\n+\tmovw\tax, [sp+10]\n+\tmov1\tcy, a.7\n+\tmovw\thl, ax\n+\tbc\t$__div_neg_den\n+\n+\t;; Load and test for a negative numerator.\n+\tmovw\tax, [sp+6]\n+\tmov1\tcy, a.7\n+\tmovw\tbc, ax\n+\tmovw\tax, [sp+4]\n+\tbc\t$__div_neg_num\n+\n+\t;; Neither are negative - we can use the unsigned divide instruction.\n+__div_no_convert:\t\n+\tpush\tpsw\n+\tdi\n+\tdivwu\n+\tpop\tpsw\n+\t\n+\tmovw\tr8, ax\n+\tmovw\tax, bc\n+\tmovw\tr10, ax\n+\tret\n+\n+__div_neg_den:\n+\t;; Negate the denumerator (which is in HLDE)\n+\tclrw\tax\n+\tsubw\tax, de\n+\tmovw\tde, ax\n+\tclrw\tax\n+\tsknc\n+\tdecw\tax\n+\tsubw\tax, hl\n+\tmovw\thl, ax\n+\t\n+\t;; Load and test for a negative numerator.\n+\tmovw\tax, [sp+6]\n+\tmov1\tcy, a.7\n+\tmovw\tbc, ax\n+\tmovw\tax, [sp+4]\n+\t;; If it is not negative then we perform the division and then negate the result.\n+\tbnc\t$__div_then_convert\n+\n+\t;; Otherwise we negate the numerator and then go with a straightforward unsigned division.\n+\t;; The negation is complicated because AX, BC, DE and HL are already in use.\n+\t;;              ax: numL  bc: numH  r8:       r10:\n+\txchw\tax, bc\t\t\t    \n+\t;;              ax: numH  bc: numL  r8:       r10:\n+\tmovw\tr8, ax\t\t\t    \n+\t;;              ax:       bc: numL  r8: numH  r10:\n+\tclrw\tax\t\t\t    \n+\t;;              ax:    0  bc: numL  r8: numH  r10:\n+\tsubw\tax, bc\t\t\t    \n+\t;;              ax: -numL bc:       r8: numH  r10:\n+\tmovw\tr10, ax\t\t\t    \n+\t;;              ax:       bc:       r8: numH  r10: -numL\n+\tmovw\tax, r8\t\t\t    \n+\t;;              ax: numH  bc:       r8:       r10: -numL\n+\tmovw\tbc, ax\t\t\t    \n+\t;;              ax:       bc: numH  r8:       r10: -numL\n+\tclrw\tax\t\t\t    \n+\t;;              ax:    0  bc: numH  r8:       r10: -numL\n+\tsknc\t\t\t\t    \n+\tdecw\tax\t\t\t    \n+\t;;              ax:    -1 bc: numH  r8:       r10: -numL\n+\tsubw\tax, bc\t\t\t    \n+\t;;              ax: -numH bc:       r8:       r10: -numL\n+\tmovw\tbc, ax\t\t\t    \n+\t;;              ax:       bc: -numH r8:       r10: -numL\n+\tmovw\tax, r10\t\t\t    \n+\t;;              ax: -numL bc: -numH r8:       r10:\n+\tbr\t$!__div_no_convert\n+\n+__div_neg_num:\n+\t;; Negate the numerator (which is in BCAX)\n+\t;; We know that the denumerator is positive.\n+\t;; Note - we temporarily overwrite DE.  We know that we can safely load it again off the stack again.\n+\tmovw\tde, ax\n+\tclrw\tax\n+\tsubw\tax, de\n+\tmovw\tde, ax\n+\tclrw\tax\n+\tsknc\n+\tdecw\tax\n+\tsubw\tax, bc\n+\tmovw\tbc, ax\n+\n+\tmovw\tax, [sp+8]\n+\txchw\tax, de\n+\t\n+__div_then_convert:\n+\tpush\tpsw\n+\tdi\n+\tdivwu\n+\tpop\tpsw\n+\n+\t;; Negate result (in BCAX) and transfer into r8,r10\n+\tmovw\tde, ax\n+\tclrw\tax\n+\tsubw\tax, de\n+\tmovw\tr8, ax\n+\tclrw\tax\n+\tsknc\n+\tdecw\tax\n+\tsubw\tax, bc\n+\tmovw\tr10, ax\n+\tret\n+\n+END_FUNC ___divsi3\n+\n+;----------------------------------------------------------------------\n+\n+START_FUNC ___udivsi3\n+\t;; r8,r10 = 4[sp],6[sp] / 8[sp],10[sp]\n+\t;; Used when compiling with -Os specified.\n+\n+\tmovw\tax, [sp+10]\n+\tmovw\thl, ax\n+\tmovw\tax, [sp+8]\n+\tmovw\tde, ax\n+\tmovw\tax, [sp+6]\n+\tmovw\tbc, ax\n+\tmovw    ax, [sp+4]\n+\tpush\tpsw\t; Save the current interrupt status\n+\tdi\t\t; Disable interrupts. See Renesas Technical update TN-RL*-A025B/E\n+\tdivwu   \t; bcax = bcax / hlde\n+\tpop\tpsw\t; Restore saved interrupt status\n+\tmovw    r8, ax\n+\tmovw\tax, bc\n+\tmovw    r10, ax\n+\tret\n+\n+END_FUNC ___udivsi3\n+\n+;----------------------------------------------------------------------\n+\t\n+START_FUNC ___modsi3\n+\t;; r8,r10 = 4[sp],6[sp] % 8[sp],10[sp]\n+\n+\t;; Load and test for a negative denumerator.\n+\tmovw\tax, [sp+8]\n+\tmovw\tde, ax\n+\tmovw\tax, [sp+10]\n+\tmov1\tcy, a.7\n+\tmovw\thl, ax\n+\tbc\t$__mod_neg_den\n+\n+\t;; Load and test for a negative numerator.\n+\tmovw\tax, [sp+6]\n+\tmov1\tcy, a.7\n+\tmovw\tbc, ax\n+\tmovw\tax, [sp+4]\n+\tbc\t$__mod_neg_num\n+\n+\t;; Neither are negative - we can use the unsigned divide instruction.\n+__mod_no_convert:\t\n+\tpush\tpsw\n+\tdi\n+\tdivwu\n+\tpop\tpsw\n+\n+\tmovw\tax, de\n+\tmovw\tr8, ax\n+\tmovw\tax, hl\n+\tmovw\tr10, ax\n+\tret\n+\n+__mod_neg_den:\n+\t;; Negate the denumerator (which is in HLDE)\n+\tclrw\tax\n+\tsubw\tax, de\n+\tmovw\tde, ax\n+\tclrw\tax\n+\tsknc\n+\tdecw\tax\n+\tsubw\tax, hl\n+\tmovw\thl, ax\n+\t\n+\t;; Load and test for a negative numerator.\n+\tmovw\tax, [sp+6]\n+\tmov1\tcy, a.7\n+\tmovw\tbc, ax\n+\tmovw\tax, [sp+4]\n+\t;; If it is not negative then we perform the modulo operation without conversion\n+\tbnc\t$__mod_no_convert\n+\n+\t;; Otherwise we negate the numerator and then go with a modulo followed by negation.\n+\t;; The negation is complicated because AX, BC, DE and HL are already in use.\n+\txchw\tax, bc\t\t\t    \n+\tmovw\tr8, ax\t\t\t    \n+\tclrw\tax\t\t\t    \n+\tsubw\tax, bc\t\t\t    \n+\tmovw\tr10, ax\t\t\t    \n+\tmovw\tax, r8\t\t\t    \n+\tmovw\tbc, ax\t\t\t    \n+\tclrw\tax\t\t\t    \n+\tsknc\t\t\t\t    \n+\tdecw\tax\t\t\t    \n+\tsubw\tax, bc\t\t\t    \n+\tmovw\tbc, ax\t\t\t    \n+\tmovw\tax, r10\t\t\t    \n+\tbr\t$!__mod_then_convert\n+\n+__mod_neg_num:\n+\t;; Negate the numerator (which is in BCAX)\n+\t;; We know that the denumerator is positive.\n+\t;; Note - we temporarily overwrite DE.  We know that we can safely load it again off the stack again.\n+\tmovw\tde, ax\n+\tclrw\tax\n+\tsubw\tax, de\n+\tmovw\tde, ax\n+\tclrw\tax\n+\tsknc\n+\tdecw\tax\n+\tsubw\tax, bc\n+\tmovw\tbc, ax\n+\n+\tmovw\tax, [sp+8]\n+\txchw\tax, de\n+\t\n+__mod_then_convert:\n+\tpush\tpsw\n+\tdi\n+\tdivwu\n+\tpop\tpsw\n+\n+\t;; Negate result (in HLDE) and transfer into r8,r10\n+\tclrw\tax\n+\tsubw\tax, de\n+\tmovw\tr8, ax\n+\tclrw\tax\n+\tsknc\n+\tdecw\tax\n+\tsubw\tax, hl\n+\tmovw\tr10, ax\n+\tret\n+\n+END_FUNC ___modsi3\n+\n+;----------------------------------------------------------------------\n+\n+START_FUNC ___umodsi3\n+\t;; r8,r10 = 4[sp],6[sp] % 8[sp],10[sp]\n+\t;; Used when compiling with -Os specified.\n+\n+\tmovw\tax, [sp+10]\n+\tmovw\thl, ax\n+\tmovw\tax, [sp+8]\n+\tmovw\tde, ax\n+\tmovw\tax, [sp+6]\n+\tmovw\tbc, ax\n+\tmovw    ax, [sp+4]\n+\tpush\tpsw\t; Save the current interrupt status\n+\tdi\t\t; Disable interrupts. See Renesas Technical update TN-RL*-A025B/E\n+\tdivwu   \t; hlde = bcax %% hlde\n+\tpop\tpsw\t; Restore saved interrupt status\n+\tmovw\tax, de\n+\tmovw    r8, ax\n+\tmovw\tax, hl\n+\tmovw    r10, ax\n+\tret\n+\n+END_FUNC   ___umodsi3\n+\n+;----------------------------------------------------------------------\n+\n+#elif defined __RL78_MUL_G13__\n+\n+;----------------------------------------------------------------------\n+\n+\t;; Hardware registers.  Note - these values match the silicon, not the documentation.\n+\tMDAL = 0xffff0\n+\tMDAH = 0xffff2\n+\tMDBL = 0xffff6\n+\tMDBH = 0xffff4\n+\tMDCL = 0xf00e0\n+\tMDCH = 0xf00e2\n+\tMDUC = 0xf00e8\n+\n+.macro _Negate low, high\n+\tmovw\tax, \\low\n+\tmovw\tbc, ax\n+\tclrw\tax\n+\tsubw\tax, bc\n+\tmovw\t\\low, ax\n+\tmovw\tax, \\high\n+\tmovw\tbc, ax\n+\tclrw\tax\n+\tsknc\n+\tdecw\tax\n+\tsubw\tax, bc\n+\tmovw\t\\high, ax\n+.endm\n+\t\n+;----------------------------------------------------------------------\n+\n+START_FUNC ___divsi3\n+\t;; r8,r10 = 4[sp],6[sp] / 8[sp],10[sp]\n+\n+\tmov\ta, #0xC0\t; Set DIVMODE=1 and MACMODE=1\n+\tmov\t!MDUC, a\t; This preps the peripheral for division without interrupt generation\n+\n+\t;; Load and test for a negative denumerator.\n+\tmovw\tax, [sp+8]\n+\tmovw\tMDBL, ax\n+\tmovw\tax, [sp+10]\n+\tmov1\tcy, a.7\n+\tmovw\tMDBH, ax\n+\tbc\t$__div_neg_den\n+\n+\t;; Load and test for a negative numerator.\n+\tmovw\tax, [sp+6]\n+\tmov1\tcy, a.7\n+\tmovw\tMDAH, ax\n+\tmovw\tax, [sp+4]\n+\tmovw\tMDAL, ax\n+\tbc\t$__div_neg_num\n+\n+\t;; Neither are negative - we can use the unsigned divide hardware.\n+__div_no_convert:\t\n+\tmov\ta, #0xC1\t; Set the DIVST bit in MDUC\n+\tmov\t!MDUC, a\t; This starts the division op\n+\n+1:\tmov\ta, !MDUC\t; Wait 16 clocks or until DIVST is clear\n+\tbt\ta.0, $1b\n+\n+  \tmovw\tax, MDAL\t; Read the result\n+\tmovw\tr8, ax\n+\tmovw\tax, MDAH\n+\tmovw\tr10, ax\t\n+\tret\n+\n+__div_neg_den:\n+\t;; Negate the denumerator (which is in MDBL/MDBH)\n+\t_Negate MDBL MDBH\n+\n+\t;; Load and test for a negative numerator.\n+\tmovw\tax, [sp+6]\n+\tmov1\tcy, a.7\n+\tmovw\tMDAH, ax\n+\tmovw\tax, [sp+4]\n+\tmovw\tMDAL, ax\n+\t;; If it is not negative then we perform the division and then negate the result.\n+\tbnc\t$__div_then_convert\n+\n+\t;; Otherwise we negate the numerator and then go with a straightforward unsigned division.\n+\t_Negate MDAL MDAH\n+\tbr\t$!__div_no_convert\n+\n+__div_neg_num:\n+\t;; Negate the numerator (which is in MDAL/MDAH)\n+\t;; We know that the denumerator is positive.\n+\t_Negate MDAL MDAH\n+\t\n+__div_then_convert:\n+\tmov\ta, #0xC1\t; Set the DIVST bit in MDUC\n+\tmov\t!MDUC, a\t; This starts the division op\n+\n+1:\tmov\ta, !MDUC\t; Wait 16 clocks or until DIVST is clear\n+\tbt\ta.0, $1b\n+\n+\t;; Negate result and transfer into r8,r10\n+\t_Negate MDAL MDAH    \t; FIXME: This could be coded more efficiently.\n+\tmovw\tr10, ax\n+\tmovw\tax, MDAL\n+\tmovw\tr8, ax\n+\n+\tret\n+\n+END_FUNC ___divsi3\n+\n+;----------------------------------------------------------------------\n+\n+START_FUNC ___modsi3\n+\t;; r8,r10 = 4[sp],6[sp] % 8[sp],10[sp]\n+\n+\tmov\ta, #0xC0\t; Set DIVMODE=1 and MACMODE=1\n+\tmov\t!MDUC, a\t; This preps the peripheral for division without interrupt generation\n+\n+\t;; Load and test for a negative denumerator.\n+\tmovw\tax, [sp+8]\n+\tmovw\tMDBL, ax\n+\tmovw\tax, [sp+10]\n+\tmov1\tcy, a.7\n+\tmovw\tMDBH, ax\n+\tbc\t$__mod_neg_den\n+\n+\t;; Load and test for a negative numerator.\n+\tmovw\tax, [sp+6]\n+\tmov1\tcy, a.7\n+\tmovw\tMDAH, ax\n+\tmovw\tax, [sp+4]\n+\tmovw\tMDAL, ax\n+\tbc\t$__mod_neg_num\n+\n+\t;; Neither are negative - we can use the unsigned divide hardware\n+__mod_no_convert:\t\n+\tmov\ta, #0xC1\t; Set the DIVST bit in MDUC\n+\tmov\t!MDUC, a\t; This starts the division op\n+\n+1:\tmov\ta, !MDUC\t; Wait 16 clocks or until DIVST is clear\n+\tbt\ta.0, $1b\n+\n+  \tmovw\tax, !MDCL\t; Read the remainder\n+\tmovw\tr8, ax\n+\tmovw\tax, !MDCH\n+\tmovw\tr10, ax\t\n+\tret\n+\n+__mod_neg_den:\n+\t;; Negate the denumerator (which is in MDBL/MDBH)\n+\t_Negate MDBL MDBH\n+\t\n+\t;; Load and test for a negative numerator.\n+\tmovw\tax, [sp+6]\n+\tmov1\tcy, a.7\n+\tmovw\tMDAH, ax\n+\tmovw\tax, [sp+4]\n+\tmovw\tMDAL, ax\n+\t;; If it is not negative then we perform the modulo operation without conversion\n+\tbnc\t$__mod_no_convert\n+\n+\t;; Otherwise we negate the numerator and then go with a modulo followed by negation.\n+\t_Negate MDAL MDAH\n+\tbr\t$!__mod_then_convert\n+\n+__mod_neg_num:\n+\t;; Negate the numerator (which is in MDAL/MDAH)\n+\t;; We know that the denumerator is positive.\n+\t_Negate MDAL MDAH\n+\t\n+__mod_then_convert:\n+\tmov\ta, #0xC1\t; Set the DIVST bit in MDUC\n+\tmov\t!MDUC, a\t; This starts the division op\n+\n+1:\tmov\ta, !MDUC\t; Wait 16 clocks or until DIVST is clear\n+\tbt\ta.0, $1b\n+\n+\tmovw\tax, !MDCL\n+\tmovw\tbc, ax\n+\tclrw\tax\n+\tsubw\tax, bc\n+\tmovw\tr8, ax\n+\tmovw\tax, !MDCH\n+\tmovw\tbc, ax\n+\tclrw\tax\n+\tsknc\n+\tdecw\tax\n+\tsubw\tax, bc\n+\tmovw\tr10, ax\n+\tret\n+\n+END_FUNC ___modsi3\n+\n+;----------------------------------------------------------------------\n+\n+START_FUNC ___udivsi3\n+\t;; r8,r10 = 4[sp],6[sp] / 8[sp],10[sp]\n+\t;; Used when compilng with -Os specified.\n+\n+\tmov\ta, #0xC0\t; Set DIVMODE=1 and MACMODE=1\n+\tmov\t!MDUC, a\t; This preps the peripheral for division without interrupt generation\n+\n+\tmovw\tax, [sp+4]\t; Load the divisor\n+\tmovw\tMDAL, ax\n+\tmovw\tax, [sp+6]\n+\tmovw\tMDAH, ax\n+\tmovw\tax, [sp+8]\t; Load the dividend\n+\tmovw\tMDBL, ax\n+\tmovw    ax, [sp+10]\n+\tmovw\tMDBH, ax\n+\t\n+\tmov\ta, #0xC1\t; Set the DIVST bit in MDUC\n+\tmov\t!MDUC, a\t; This starts the division op\n+\n+1:\tmov\ta, !MDUC\t; Wait 16 clocks or until DIVST is clear\n+\tbt\ta.0, $1b\n+\n+  \tmovw\tax, !MDAL\t; Read the result\n+\tmovw\tr8, ax\n+\tmovw\tax, !MDAH\n+\tmovw\tr10, ax\t\n+\tret\n+\t\n+END_FUNC   ___udivsi3\n+\n+;----------------------------------------------------------------------\n+\n+START_FUNC ___umodsi3\n+\t;; r8,r10 = 4[sp],6[sp] % 8[sp],10[sp]\n+\t;; Used when compilng with -Os specified.\n+\t;; Note - hardware address match the silicon, not the documentation\n+\n+\tmov\ta, #0xC0\t; Set DIVMODE=1 and MACMODE=1\n+\tmov\t!MDUC, a\t; This preps the peripheral for division without interrupt generation\n+\n+\tmovw\tax, [sp+4]\t; Load the divisor\n+\tmovw\tMDAL, ax\n+\tmovw\tax, [sp+6]\n+\tmovw\tMDAH, ax\n+\tmovw\tax, [sp+8]\t; Load the dividend\n+\tmovw\tMDBL, ax\n+\tmovw    ax, [sp+10]\n+\tmovw\tMDBH, ax\n+\t\n+\tmov\ta, #0xC1\t; Set the DIVST bit in MDUC\n+\tmov\t!MDUC, a\t; This starts the division op\n+\n+1:\tmov\ta, !MDUC\t; Wait 16 clocks or until DIVST is clear\n+\tbt\ta.0, $1b\n+\n+  \tmovw\tax, !MDCL\t; Read the remainder\n+\tmovw\tr8, ax\n+\tmovw\tax, !MDCH\n+\tmovw\tr10, ax\t\n+\tret\n+\t\n+END_FUNC   ___umodsi3\n+\n+;----------------------------------------------------------------------\n+\n+#elif defined __RL78_MUL_NONE__\n+\n .macro MAKE_GENERIC  which,need_result\n \n \t.if \\need_result\n@@ -67,6 +598,8 @@\n \tbitB2 = bit+2\n \tbitB3 = bit+3\n \n+;----------------------------------------------------------------------\n+\n START_FUNC __generic_sidivmod\\which\n \n num_lt_den\\which:\n@@ -533,3 +1066,11 @@ mod_skip_restore_den:\n  .endif\t\n \tret\n END_FUNC ___modsi3\n+\n+;----------------------------------------------------------------------\n+\n+#else\n+\n+#error \"Unknown RL78 hardware multiply/divide support\"\n+\n+#endif"}]}