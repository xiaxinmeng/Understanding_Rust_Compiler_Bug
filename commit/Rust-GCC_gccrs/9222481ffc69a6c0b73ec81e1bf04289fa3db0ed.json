{"sha": "9222481ffc69a6c0b73ec81e1bf04289fa3db0ed", "node_id": "C_kwDOANBUbNoAKDkyMjI0ODFmZmM2OWE2YzBiNzNlYzgxZTFiZjA0Mjg5ZmEzZGIwZWQ", "commit": {"author": {"name": "Xionghu Luo", "email": "luoxhu@linux.ibm.com", "date": "2021-10-28T02:21:20Z"}, "committer": {"name": "Xionghu Luo", "email": "luoxhu@linux.ibm.com", "date": "2021-10-28T02:21:20Z"}, "message": "rs6000: Fix wrong code generation for vec_sel [PR94613]\n\nThe vsel instruction is a bit-wise select instruction.  Using an\nIF_THEN_ELSE to express it in RTL is wrong and leads to wrong code\nbeing generated in the combine pass.  Per element selection is a\nsubset of per bit-wise selection,with the patch the pattern is\nwritten using bit operations.  But there are 8 different patterns\nto define \"op0 := (op1 & ~op3) | (op2 & op3)\":\n\n(~op3&op1) | (op3&op2),\n(~op3&op1) | (op2&op3),\n(op3&op2) | (~op3&op1),\n(op2&op3) | (~op3&op1),\n(op1&~op3) | (op3&op2),\n(op1&~op3) | (op2&op3),\n(op3&op2) | (op1&~op3),\n(op2&op3) | (op1&~op3),\n\nThe latter 4 cases does not follow canonicalisation rules, non-canonical\nRTL is invalid RTL in vregs pass.  Secondly, combine pass will swap\n(op1&~op3) to (~op3&op1) by commutative canonical, which could reduce\nit to the FIRST 4 patterns, but it won't swap (op2&op3) | (~op3&op1) to\n(~op3&op1) | (op2&op3), so this patch handles it with 4 patterns with\ndifferent NOT op3 position and check equality inside it.\n\nTested pass on P7, P8 and P9.\n\ngcc/ChangeLog:\n\n2021-10-28  Xionghu Luo  <luoxhu@linux.ibm.com>\n\n\tPR target/94613\n\t* config/rs6000/altivec.md (*altivec_vsel<mode>): Change to ...\n\t(altivec_vsel<mode>): ... this and update define.\n\t(*altivec_vsel<mode>_uns): Delete.\n\t(altivec_vsel<mode>2): New define_insn.\n\t(altivec_vsel<mode>3): Likewise.\n\t(altivec_vsel<mode>4): Likewise.\n\t* config/rs6000/rs6000-call.c (altivec_expand_vec_sel_builtin): New.\n\t(altivec_expand_builtin): Call altivec_expand_vec_sel_builtin to expand\n\tvel_sel.\n\t* config/rs6000/rs6000.c (rs6000_emit_vector_cond_expr): Use bit-wise\n\tselection instead of per element.\n\t* config/rs6000/vector.md:\n\t* config/rs6000/vsx.md (*vsx_xxsel<mode>): Change to ...\n\t(vsx_xxsel<mode>): ... this and update define.\n\t(*vsx_xxsel<mode>_uns): Delete.\n\t(vsx_xxsel<mode>2): New define_insn.\n\t(vsx_xxsel<mode>3): Likewise.\n\t(vsx_xxsel<mode>4): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n2021-10-28  Xionghu Luo  <luoxhu@linux.ibm.com>\n\n\tPR target/94613\n\t* gcc.target/powerpc/pr94613.c: New test.", "tree": {"sha": "1f5849ca2b67e1a1233eaebe0b17cc63501cbb19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f5849ca2b67e1a1233eaebe0b17cc63501cbb19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9222481ffc69a6c0b73ec81e1bf04289fa3db0ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9222481ffc69a6c0b73ec81e1bf04289fa3db0ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9222481ffc69a6c0b73ec81e1bf04289fa3db0ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9222481ffc69a6c0b73ec81e1bf04289fa3db0ed/comments", "author": {"login": "xionghul", "id": 4607154, "node_id": "MDQ6VXNlcjQ2MDcxNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4607154?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xionghul", "html_url": "https://github.com/xionghul", "followers_url": "https://api.github.com/users/xionghul/followers", "following_url": "https://api.github.com/users/xionghul/following{/other_user}", "gists_url": "https://api.github.com/users/xionghul/gists{/gist_id}", "starred_url": "https://api.github.com/users/xionghul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xionghul/subscriptions", "organizations_url": "https://api.github.com/users/xionghul/orgs", "repos_url": "https://api.github.com/users/xionghul/repos", "events_url": "https://api.github.com/users/xionghul/events{/privacy}", "received_events_url": "https://api.github.com/users/xionghul/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xionghul", "id": 4607154, "node_id": "MDQ6VXNlcjQ2MDcxNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4607154?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xionghul", "html_url": "https://github.com/xionghul", "followers_url": "https://api.github.com/users/xionghul/followers", "following_url": "https://api.github.com/users/xionghul/following{/other_user}", "gists_url": "https://api.github.com/users/xionghul/gists{/gist_id}", "starred_url": "https://api.github.com/users/xionghul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xionghul/subscriptions", "organizations_url": "https://api.github.com/users/xionghul/orgs", "repos_url": "https://api.github.com/users/xionghul/repos", "events_url": "https://api.github.com/users/xionghul/events{/privacy}", "received_events_url": "https://api.github.com/users/xionghul/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5720c450fab749664b32dbcd14d0a66f8ba57e5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5720c450fab749664b32dbcd14d0a66f8ba57e5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5720c450fab749664b32dbcd14d0a66f8ba57e5f"}], "stats": {"total": 276, "additions": 221, "deletions": 55}, "files": [{"sha": "158b3a708a3131401042fe008ea4276e3799150a", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 46, "deletions": 16, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9222481ffc69a6c0b73ec81e1bf04289fa3db0ed/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9222481ffc69a6c0b73ec81e1bf04289fa3db0ed/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=9222481ffc69a6c0b73ec81e1bf04289fa3db0ed", "patch": "@@ -681,26 +681,56 @@\n   \"vcmpgefp %0,%1,%2\"\n   [(set_attr \"type\" \"veccmp\")])\n \n-(define_insn \"*altivec_vsel<mode>\"\n+(define_insn \"altivec_vsel<mode>\"\n   [(set (match_operand:VM 0 \"altivec_register_operand\" \"=v\")\n-\t(if_then_else:VM\n-\t (ne:CC (match_operand:VM 1 \"altivec_register_operand\" \"v\")\n-\t\t(match_operand:VM 4 \"zero_constant\" \"\"))\n-\t (match_operand:VM 2 \"altivec_register_operand\" \"v\")\n-\t (match_operand:VM 3 \"altivec_register_operand\" \"v\")))]\n-  \"VECTOR_MEM_ALTIVEC_P (<MODE>mode)\"\n-  \"vsel %0,%3,%2,%1\"\n+\t(ior:VM\n+\t  (and:VM\n+\t    (not:VM (match_operand:VM 3 \"altivec_register_operand\" \"v\"))\n+\t    (match_operand:VM 1 \"altivec_register_operand\" \"v\"))\n+\t  (and:VM\n+\t    (match_dup 3)\n+\t    (match_operand:VM 2 \"altivec_register_operand\" \"v\"))))]\n+  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+  \"vsel %0,%1,%2,%3\"\n   [(set_attr \"type\" \"vecmove\")])\n \n-(define_insn \"*altivec_vsel<mode>_uns\"\n+(define_insn \"altivec_vsel<mode>2\"\n   [(set (match_operand:VM 0 \"altivec_register_operand\" \"=v\")\n-\t(if_then_else:VM\n-\t (ne:CCUNS (match_operand:VM 1 \"altivec_register_operand\" \"v\")\n-\t\t   (match_operand:VM 4 \"zero_constant\" \"\"))\n-\t (match_operand:VM 2 \"altivec_register_operand\" \"v\")\n-\t (match_operand:VM 3 \"altivec_register_operand\" \"v\")))]\n-  \"VECTOR_MEM_ALTIVEC_P (<MODE>mode)\"\n-  \"vsel %0,%3,%2,%1\"\n+\t(ior:VM\n+\t  (and:VM\n+\t    (not:VM (match_operand:VM 3 \"altivec_register_operand\" \"v\"))\n+\t    (match_operand:VM 1 \"altivec_register_operand\" \"v\"))\n+\t  (and:VM\n+\t    (match_operand:VM 2 \"altivec_register_operand\" \"v\")\n+\t    (match_dup 3))))]\n+  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+  \"vsel %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"vecmove\")])\n+\n+(define_insn \"altivec_vsel<mode>3\"\n+  [(set (match_operand:VM 0 \"altivec_register_operand\" \"=v\")\n+\t(ior:VM\n+\t  (and:VM\n+\t    (match_operand:VM 3 \"altivec_register_operand\" \"v\")\n+\t    (match_operand:VM 1 \"altivec_register_operand\" \"v\"))\n+\t  (and:VM\n+\t    (not:VM (match_dup 3))\n+\t    (match_operand:VM 2 \"altivec_register_operand\" \"v\"))))]\n+  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+  \"vsel %0,%2,%1,%3\"\n+  [(set_attr \"type\" \"vecmove\")])\n+\n+(define_insn \"altivec_vsel<mode>4\"\n+  [(set (match_operand:VM 0 \"altivec_register_operand\" \"=v\")\n+\t(ior:VM\n+\t  (and:VM\n+\t    (match_operand:VM 1 \"altivec_register_operand\" \"v\")\n+\t    (match_operand:VM 3 \"altivec_register_operand\" \"v\"))\n+\t  (and:VM\n+\t    (not:VM (match_dup 3))\n+\t    (match_operand:VM 2 \"altivec_register_operand\" \"v\"))))]\n+  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+  \"vsel %0,%2,%1,%3\"\n   [(set_attr \"type\" \"vecmove\")])\n \n ;; Fused multiply add."}, {"sha": "783c3c506c8529f3e6303fd0c71e57968a8d4f4f", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9222481ffc69a6c0b73ec81e1bf04289fa3db0ed/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9222481ffc69a6c0b73ec81e1bf04289fa3db0ed/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=9222481ffc69a6c0b73ec81e1bf04289fa3db0ed", "patch": "@@ -11173,6 +11173,45 @@ altivec_expand_vec_ext_builtin (tree exp, rtx target)\n   return target;\n }\n \n+/* Expand vec_sel builtin.  */\n+static rtx\n+altivec_expand_vec_sel_builtin (enum insn_code icode, tree exp, rtx target)\n+{\n+  rtx op0, op1, op2, pat;\n+  tree arg0, arg1, arg2;\n+\n+  arg0 = CALL_EXPR_ARG (exp, 0);\n+  op0 = expand_normal (arg0);\n+  arg1 = CALL_EXPR_ARG (exp, 1);\n+  op1 = expand_normal (arg1);\n+  arg2 = CALL_EXPR_ARG (exp, 2);\n+  op2 = expand_normal (arg2);\n+\n+  machine_mode tmode = insn_data[icode].operand[0].mode;\n+  machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  machine_mode mode1 = insn_data[icode].operand[2].mode;\n+  machine_mode mode2 = insn_data[icode].operand[3].mode;\n+\n+  if (target == 0 || GET_MODE (target) != tmode\n+      || !(*insn_data[icode].operand[0].predicate) (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+\n+  if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))\n+    op0 = copy_to_mode_reg (mode0, op0);\n+  if (!(*insn_data[icode].operand[2].predicate) (op1, mode1))\n+    op1 = copy_to_mode_reg (mode1, op1);\n+  if (!(*insn_data[icode].operand[3].predicate) (op2, mode2))\n+    op2 = copy_to_mode_reg (mode2, op2);\n+\n+  pat = GEN_FCN (icode) (target, op0, op1, op2, op2);\n+  if (pat)\n+    emit_insn (pat);\n+  else\n+    return NULL_RTX;\n+\n+  return target;\n+}\n+\n /* Expand the builtin in EXP and store the result in TARGET.  Store\n    true in *EXPANDEDP if we found a builtin to expand.  */\n static rtx\n@@ -11358,6 +11397,29 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n \temit_insn (pat);\n       return NULL_RTX;\n \n+    case ALTIVEC_BUILTIN_VSEL_2DF:\n+      return altivec_expand_vec_sel_builtin (CODE_FOR_altivec_vselv2df, exp,\n+\t\t\t\t\t     target);\n+    case ALTIVEC_BUILTIN_VSEL_2DI:\n+    case ALTIVEC_BUILTIN_VSEL_2DI_UNS:\n+      return altivec_expand_vec_sel_builtin (CODE_FOR_altivec_vselv2di, exp,\n+\t\t\t\t\t     target);\n+    case ALTIVEC_BUILTIN_VSEL_4SF:\n+      return altivec_expand_vec_sel_builtin (CODE_FOR_altivec_vselv4sf, exp,\n+\t\t\t\t\t     target);\n+    case ALTIVEC_BUILTIN_VSEL_4SI:\n+    case ALTIVEC_BUILTIN_VSEL_4SI_UNS:\n+      return altivec_expand_vec_sel_builtin (CODE_FOR_altivec_vselv4si, exp,\n+\t\t\t\t\t     target);\n+    case ALTIVEC_BUILTIN_VSEL_8HI:\n+    case ALTIVEC_BUILTIN_VSEL_8HI_UNS:\n+      return altivec_expand_vec_sel_builtin (CODE_FOR_altivec_vselv8hi, exp,\n+\t\t\t\t\t     target);\n+    case ALTIVEC_BUILTIN_VSEL_16QI:\n+    case ALTIVEC_BUILTIN_VSEL_16QI_UNS:\n+      return altivec_expand_vec_sel_builtin (CODE_FOR_altivec_vselv16qi, exp,\n+\t\t\t\t\t     target);\n+\n     case ALTIVEC_BUILTIN_DSSALL:\n       emit_insn (gen_altivec_dssall ());\n       return NULL_RTX;"}, {"sha": "1dcb9b1aee207cb80762874736a7c561975f7127", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9222481ffc69a6c0b73ec81e1bf04289fa3db0ed/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9222481ffc69a6c0b73ec81e1bf04289fa3db0ed/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9222481ffc69a6c0b73ec81e1bf04289fa3db0ed", "patch": "@@ -16033,9 +16033,7 @@ rs6000_emit_vector_cond_expr (rtx dest, rtx op_true, rtx op_false,\n   machine_mode dest_mode = GET_MODE (dest);\n   machine_mode mask_mode = GET_MODE (cc_op0);\n   enum rtx_code rcode = GET_CODE (cond);\n-  machine_mode cc_mode = CCmode;\n   rtx mask;\n-  rtx cond2;\n   bool invert_move = false;\n \n   if (VECTOR_UNIT_NONE_P (dest_mode))\n@@ -16075,8 +16073,6 @@ rs6000_emit_vector_cond_expr (rtx dest, rtx op_true, rtx op_false,\n     case GEU:\n     case LTU:\n     case LEU:\n-      /* Mark unsigned tests with CCUNSmode.  */\n-      cc_mode = CCUNSmode;\n \n       /* Invert condition to avoid compound test if necessary.  */\n       if (rcode == GEU || rcode == LEU)\n@@ -16096,6 +16092,9 @@ rs6000_emit_vector_cond_expr (rtx dest, rtx op_true, rtx op_false,\n   if (!mask)\n     return 0;\n \n+  if (mask_mode != dest_mode)\n+    mask = simplify_gen_subreg (dest_mode, mask, mask_mode, 0);\n+\n   if (invert_move)\n     std::swap (op_true, op_false);\n \n@@ -16135,13 +16134,11 @@ rs6000_emit_vector_cond_expr (rtx dest, rtx op_true, rtx op_false,\n   if (!REG_P (op_false) && !SUBREG_P (op_false))\n     op_false = force_reg (dest_mode, op_false);\n \n-  cond2 = gen_rtx_fmt_ee (NE, cc_mode, gen_lowpart (dest_mode, mask),\n-\t\t\t  CONST0_RTX (dest_mode));\n-  emit_insn (gen_rtx_SET (dest,\n-\t\t\t  gen_rtx_IF_THEN_ELSE (dest_mode,\n-\t\t\t\t\t\tcond2,\n-\t\t\t\t\t\top_true,\n-\t\t\t\t\t\top_false)));\n+  rtx tmp = gen_rtx_IOR (dest_mode,\n+\t\t\t gen_rtx_AND (dest_mode, gen_rtx_NOT (dest_mode, mask),\n+\t\t\t\t      op_false),\n+\t\t\t gen_rtx_AND (dest_mode, mask, op_true));\n+  emit_insn (gen_rtx_SET (dest, tmp));\n   return 1;\n }\n "}, {"sha": "062aef70f2bb1b241524a6be49c4c13f759d4a1c", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9222481ffc69a6c0b73ec81e1bf04289fa3db0ed/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9222481ffc69a6c0b73ec81e1bf04289fa3db0ed/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=9222481ffc69a6c0b73ec81e1bf04289fa3db0ed", "patch": "@@ -916,23 +916,21 @@\n ;; which is in the reverse order that we want\n (define_expand \"vector_select_<mode>\"\n   [(set (match_operand:VEC_L 0 \"vlogical_operand\")\n-\t(if_then_else:VEC_L\n-\t (ne:CC (match_operand:VEC_L 3 \"vlogical_operand\")\n-\t\t(match_dup 4))\n-\t (match_operand:VEC_L 2 \"vlogical_operand\")\n-\t (match_operand:VEC_L 1 \"vlogical_operand\")))]\n-  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"operands[4] = CONST0_RTX (<MODE>mode);\")\n+\t(ior:VEC_L\n+\t  (and:VEC_L (not:VEC_L (match_operand:VEC_L 3 \"vlogical_operand\"))\n+\t\t     (match_operand:VEC_L 1 \"vlogical_operand\"))\n+\t  (and:VEC_L (match_dup 3)\n+\t\t     (match_operand:VEC_L 2 \"vlogical_operand\"))))]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\")\n \n (define_expand \"vector_select_<mode>_uns\"\n   [(set (match_operand:VEC_L 0 \"vlogical_operand\")\n-\t(if_then_else:VEC_L\n-\t (ne:CCUNS (match_operand:VEC_L 3 \"vlogical_operand\")\n-\t\t   (match_dup 4))\n-\t (match_operand:VEC_L 2 \"vlogical_operand\")\n-\t (match_operand:VEC_L 1 \"vlogical_operand\")))]\n-  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"operands[4] = CONST0_RTX (<MODE>mode);\")\n+\t(ior:VEC_L\n+\t  (and:VEC_L (not:VEC_L (match_operand:VEC_L 3 \"vlogical_operand\"))\n+\t\t     (match_operand:VEC_L 1 \"vlogical_operand\"))\n+\t  (and:VEC_L (match_dup 3)\n+\t\t     (match_operand:VEC_L 2 \"vlogical_operand\"))))]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\")\n \n ;; Expansions that compare vectors producing a vector result and a predicate,\n ;; setting CR6 to indicate a combined status"}, {"sha": "73fd2ce8abb213b3670c4f89c34ea822c5fb0b85", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9222481ffc69a6c0b73ec81e1bf04289fa3db0ed/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9222481ffc69a6c0b73ec81e1bf04289fa3db0ed/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=9222481ffc69a6c0b73ec81e1bf04289fa3db0ed", "patch": "@@ -2185,30 +2185,62 @@\n   [(set_attr \"type\" \"<VStype_simple>\")])\n \n ;; Vector select\n-(define_insn \"*vsx_xxsel<mode>\"\n+(define_insn \"vsx_xxsel<mode>\"\n   [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(if_then_else:VSX_L\n-\t (ne:CC (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t(match_operand:VSX_L 4 \"zero_constant\" \"\"))\n-\t (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t (match_operand:VSX_L 3 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+\t(ior:VSX_L\n+\t  (and:VSX_L\n+\t    (not:VSX_L (match_operand:VSX_L 3 \"vsx_register_operand\" \"<VSr>,wa\"))\n+\t    (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,wa\"))\n+\t  (and:VSX_L\n+\t    (match_dup 3)\n+\t    (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,wa\"))))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"xxsel %x0,%x3,%x2,%x1\"\n+  \"xxsel %x0,%x1,%x2,%x3\"\n   [(set_attr \"type\" \"vecmove\")\n    (set_attr \"isa\" \"<VSisa>\")])\n \n-(define_insn \"*vsx_xxsel<mode>_uns\"\n+(define_insn \"vsx_xxsel<mode>2\"\n   [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(if_then_else:VSX_L\n-\t (ne:CCUNS (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t   (match_operand:VSX_L 4 \"zero_constant\" \"\"))\n-\t (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t (match_operand:VSX_L 3 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+\t(ior:VSX_L\n+\t  (and:VSX_L\n+\t    (not:VSX_L (match_operand:VSX_L 3 \"vsx_register_operand\" \"<VSr>,wa\"))\n+\t    (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,wa\"))\n+\t  (and:VSX_L\n+\t    (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,wa\")\n+\t    (match_dup 3))))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"xxsel %x0,%x3,%x2,%x1\"\n+  \"xxsel %x0,%x1,%x2,%x3\"\n   [(set_attr \"type\" \"vecmove\")\n    (set_attr \"isa\" \"<VSisa>\")])\n \n+(define_insn \"vsx_xxsel<mode>3\"\n+  [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+\t(ior:VSX_L\n+\t  (and:VSX_L\n+\t    (match_operand:VSX_L 3 \"vsx_register_operand\" \"<VSr>,wa\")\n+\t    (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,wa\"))\n+\t  (and:VSX_L\n+\t    (not:VSX_L (match_dup 3))\n+\t    (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,wa\"))))]\n+ \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"xxsel %x0,%x2,%x1,%x3\"\n+ [(set_attr \"type\" \"vecmove\")\n+ (set_attr \"isa\" \"<VSisa>\")])\n+\n+(define_insn \"vsx_xxsel<mode>4\"\n+  [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+\t(ior:VSX_L\n+\t  (and:VSX_L\n+\t    (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,wa\")\n+\t    (match_operand:VSX_L 3 \"vsx_register_operand\" \"<VSr>,wa\"))\n+\t  (and:VSX_L\n+\t    (not:VSX_L (match_dup 3))\n+\t    (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,wa\"))))]\n+ \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n+ \"xxsel %x0,%x2,%x1,%x3\"\n+ [(set_attr \"type\" \"vecmove\")\n+ (set_attr \"isa\" \"<VSisa>\")])\n+\n ;; Copy sign\n (define_insn \"vsx_copysign<mode>3\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=wa\")"}, {"sha": "13cab13cb83772b0a285e457de16d96e0a7e022a", "filename": "gcc/testsuite/gcc.target/powerpc/pr94613.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9222481ffc69a6c0b73ec81e1bf04289fa3db0ed/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr94613.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9222481ffc69a6c0b73ec81e1bf04289fa3db0ed/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr94613.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr94613.c?ref=9222481ffc69a6c0b73ec81e1bf04289fa3db0ed", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-O2 -maltivec\" } */\n+\n+#include <altivec.h>\n+\n+/* The initial implementation of vec_sel used an IF_THEN_ELSE rtx.\n+   This did NOT match what the vsel instruction does.  vsel is a\n+   bit-wise operation.  Using IF_THEN_ELSE made the + operation to be\n+   simplified away in combine.  A plus operation affects other bits in\n+   the same element. Hence per-element simplifications are wrong for\n+   vsel.  */\n+vector unsigned char __attribute__((noinline))\n+foo (vector unsigned char a, vector unsigned char b, vector unsigned char c)\n+{\n+  return vec_sel (a + b, c, a);\n+}\n+\n+vector unsigned char __attribute__((noinline))\n+foor (vector unsigned char a, vector unsigned char b, vector unsigned char c)\n+{\n+  return vec_sel (c, a + b, ~a);\n+}\n+\n+vector unsigned char __attribute__((noinline))\n+bar (vector unsigned char a, vector unsigned char b, vector unsigned char c)\n+{\n+  return vec_sel (a | b, c, a);\n+}\n+\n+int\n+main ()\n+{\n+  vector unsigned char v = (vector unsigned char){ 1 };\n+\n+  if (foo (v, v, v)[0] != 3)\n+      __builtin_abort ();\n+\n+  if (bar (v, v, v)[0] != 1)\n+    __builtin_abort ();\n+\n+  if (foor (v, v, v)[0] != 3)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+"}]}