{"sha": "3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI2NmRkYjM2YTAwMGE2ZDNmYmFkMzU0MWZmYjY3YmE5ODBlNWE2Nw==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2017-06-12T12:52:30Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2017-06-12T12:52:30Z"}, "message": "Support multilibs and devices that see flash in RAM address range.\n\ngcc/\n\tSupport multilibs and devices that see flash in RAM address range.\n\n\tPR target/81072\n\t* config/avr/avr-arch.h (avr_arch_id) <ARCH_AVRXMEGA3>: New enum.\n\t(avr_mcu_t) <flash_pm_offset>: New field.\n\t(avr_device_specific_features) <AVR_ISA_RCALL>: New enum.\n\t* config/avr/avr.h (AVR_SHORT_CALLS): New define.\n\t(AVR_HAVE_JMP_CALL): Don't set if AVR_SHORT_CALLS.\n\t(AVR_TINY_PM_OFFSET): Remove macro.\n\t* config/avr/avr.opt (-mshort-calls): New option.\n\t* config/avr/gen-avr-mmcu-specs.c (print_mcu)\n\t[*self_spec]: Add / remove -mshort-calls depending on AVR_ISA_RCALL.\n\t* config/avr/avr-c.c (avr_cpu_cpp_builtins)\n\t<__AVR_SHORT_CALLS__>: Built-in define if AVR_SHORT_CALLS.\n\t<__AVR_HAVE_JMP_CALL__>: Use AVR_HAVE_JMP_CALL as condition\n\tinstead of avr_arch->have_jmp_call.\n\t<__AVR_PM_BASE_ADDRESS__>: Built-in define if avr_arch->flash_pm_offset.\n\t[AVR_TINY] <__AVR_TINY_PM_BASE_ADDRESS__>: Use\n\tavr_arch->flash_pm_offset to define.\n\t* config/avr/avr-devices.c (avr_arch_types): Add initializers for\n\tnew field flash_pm_offset.  Add entry for avrxmega3.\n\t(avr_texinfo): Add entry for avrxmega3.\n\t* config/avr/avr-mcus.def: Add entries for: avrxmega3,\n\tattiny212, attiny214,\n\tattiny412, attiny414, attiny416, attiny417,\n\tattiny814, attiny816, attiny817,\n\tattiny1614, attiny1616, attiny1617,\n\tattiny3214, attiny3216, attiny3217.\n\t* config/avr/avr.c (avr_assemble_integer)[AVR_TINY]: Use\n\tavr_arch->flash_pm_offset instead of AVR_TINY_PM_OFFSET.\n\t(avr_print_operand_address) [AVR_TINY]: Same.\n\t(avr_asm_init_sections) <readonly_data_section>: Only patch\n\tcallback if avr_arch->flash_pm_offset = 0.\n\t(avr_asm_named_section) <avr_need_copy_data_p>: Skip setting it\n\tfor rodata if avr_arch->flash_pm_offset != 0.\n\t(avr_encode_section_info) [AVR_TINY]: Adjust comment.\n\t* config/avr/genmultilib.awk (dir_rcall, opt_rcall): New vars.\n\t(opts) [AVR_ISA_RCALL]: Append opt_rcall.\n\t(m_options): Append opt_rcall.\n\t(m_dirnames): Append dir_rcall.\n\t* config/avr/t-multilib: Regenerate.\n\t* configure.ac [target=avr]: Check whether avrxmega3 default\n\tlinker description file works as needed.\n\t* configure: Regenerate.\n\t* doc/avr-mmcu.texi: Regenerate.\n\t* doc/invoke.texi (AVR Options) <-mshort-calls>: Document it.\n\t<__AVR_ARCH__>: Document avrxmega3 and 103.\n\t<__AVR_HAVE_JMP_CALL__>: Adjust documentation.\n\t<__AVR_SHORT_CALLS__>: Document it.\n\t<__AVR_PM_BASE_ADDRESS__>: Document it.\n\t* doc/extend.texi (AVR Options) <-mshort-calls>: Document it.\n\t(AVR Variable Attributes) <progmem>: Document this is\n\tnot needed for avrxmega3.\n\t(AVR Named Address Spaces) <__flash>: Dito.\n\nFrom-SVN: r249124", "tree": {"sha": "a84ea0d61e0bfaf33feebe29b109cc4f0d4b2062", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a84ea0d61e0bfaf33feebe29b109cc4f0d4b2062"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/comments", "author": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c41b76e9f61229742328ba95f9085a3460e9a79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c41b76e9f61229742328ba95f9085a3460e9a79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c41b76e9f61229742328ba95f9085a3460e9a79"}], "stats": {"total": 424, "additions": 341, "deletions": 83}, "files": [{"sha": "d4f4dee2714130eaac2a2ac6ffd282af50f66f1d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "patch": "@@ -1,4 +1,62 @@\n-2017-06-11  Jan Hubicka  <hubicka@ucw.cz>\n+2017-06-12  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tSupport multilibs and devices that see flash in RAM address range.\n+\n+\tPR target/81072\n+\t* config/avr/avr-arch.h (avr_arch_id) <ARCH_AVRXMEGA3>: New enum.\n+\t(avr_mcu_t) <flash_pm_offset>: New field.\n+\t(avr_device_specific_features) <AVR_ISA_RCALL>: New enum.\n+\t* config/avr/avr.h (AVR_SHORT_CALLS): New define.\n+\t(AVR_HAVE_JMP_CALL): Don't set if AVR_SHORT_CALLS.\n+\t(AVR_TINY_PM_OFFSET): Remove macro.\n+\t* config/avr/avr.opt (-mshort-calls): New option.\n+\t* config/avr/gen-avr-mmcu-specs.c (print_mcu)\n+\t[*self_spec]: Add / remove -mshort-calls depending on AVR_ISA_RCALL.\n+\t* config/avr/avr-c.c (avr_cpu_cpp_builtins)\n+\t<__AVR_SHORT_CALLS__>: Built-in define if AVR_SHORT_CALLS.\n+\t<__AVR_HAVE_JMP_CALL__>: Use AVR_HAVE_JMP_CALL as condition\n+\tinstead of avr_arch->have_jmp_call.\n+\t<__AVR_PM_BASE_ADDRESS__>: Built-in define if avr_arch->flash_pm_offset.\n+\t[AVR_TINY] <__AVR_TINY_PM_BASE_ADDRESS__>: Use\n+\tavr_arch->flash_pm_offset to define.\n+\t* config/avr/avr-devices.c (avr_arch_types): Add initializers for\n+\tnew field flash_pm_offset.  Add entry for avrxmega3.\n+\t(avr_texinfo): Add entry for avrxmega3.\n+\t* config/avr/avr-mcus.def: Add entries for: avrxmega3,\n+\tattiny212, attiny214,\n+\tattiny412, attiny414, attiny416, attiny417,\n+\tattiny814, attiny816, attiny817,\n+\tattiny1614, attiny1616, attiny1617,\n+\tattiny3214, attiny3216, attiny3217.\n+\t* config/avr/avr.c (avr_assemble_integer)[AVR_TINY]: Use\n+\tavr_arch->flash_pm_offset instead of AVR_TINY_PM_OFFSET.\n+\t(avr_print_operand_address) [AVR_TINY]: Same.\n+\t(avr_asm_init_sections) <readonly_data_section>: Only patch\n+\tcallback if avr_arch->flash_pm_offset = 0.\n+\t(avr_asm_named_section) <avr_need_copy_data_p>: Skip setting it\n+\tfor rodata if avr_arch->flash_pm_offset != 0.\n+\t(avr_encode_section_info) [AVR_TINY]: Adjust comment.\n+\t* config/avr/genmultilib.awk (dir_rcall, opt_rcall): New vars.\n+\t(opts) [AVR_ISA_RCALL]: Append opt_rcall.\n+\t(m_options): Append opt_rcall.\n+\t(m_dirnames): Append dir_rcall.\n+\t* config/avr/t-multilib: Regenerate.\n+\n+\t* configure.ac [target=avr]: Check whether avrxmega3 default\n+\tlinker description file works as needed.\n+\t* configure: Regenerate.\n+\t* doc/avr-mmcu.texi: Regenerate.\n+\t* doc/invoke.texi (AVR Options) <-mshort-calls>: Document it.\n+\t<__AVR_ARCH__>: Document avrxmega3 and 103.\n+\t<__AVR_HAVE_JMP_CALL__>: Adjust documentation.\n+\t<__AVR_SHORT_CALLS__>: Document it.\n+\t<__AVR_PM_BASE_ADDRESS__>: Document it.\n+\t* doc/extend.texi (AVR Options) <-mshort-calls>: Document it.\n+\t(AVR Variable Attributes) <progmem>: Document this is\n+\tnot needed for avrxmega3.\n+\t(AVR Named Address Spaces) <__flash>: Dito.\n+\n+2017-06-12  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* cgraph.c (cgraph_node::dump): Complain about profile insanities.\n "}, {"sha": "e38345b69e3bb48a640fdd1f3a00ee4003f9d59f", "filename": "gcc/config/avr/avr-arch.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Favr-arch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Favr-arch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-arch.h?ref=3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "patch": "@@ -41,6 +41,7 @@ enum avr_arch_id\n   ARCH_AVR6,\n   ARCH_AVRTINY,\n   ARCH_AVRXMEGA2,\n+  ARCH_AVRXMEGA3,\n   ARCH_AVRXMEGA4,\n   ARCH_AVRXMEGA5,\n   ARCH_AVRXMEGA6,\n@@ -86,6 +87,9 @@ typedef struct\n   /* Default start of data section address for architecture.  */\n   int default_data_section_start;\n \n+  /* Offset where flash memory is seen in RAM address range or 0.  */\n+  int flash_pm_offset;\n+\n   /* Offset between SFR address and RAM address:\n      SFR-address = RAM-address - sfr_offset  */\n   int sfr_offset;\n@@ -150,16 +154,27 @@ AVR_ERRATA_SKIP\n \n      For information please refer the following respective errata links\n        http://www.atmel.com/dyn/resources/prod_documents/doc2494.pdf\n-       http://www.atmel.com/dyn/resources/prod_documents/doc1436.pdf  */\n+       http://www.atmel.com/dyn/resources/prod_documents/doc1436.pdf\n+\n+AVR_ISA_RCALL\n+  Always use RJMP / RCALL and assume JMP / CALL are not available.\n+  This affects multilib selection via specs generation and -mshort-calls.\n+  Even if a device like ATtiny417 from avrxmega3 supports JMP / CALL, we\n+  assume these instructions are not available and we set the built-in\n+  macro __AVR_HAVE_JMP_CALL__ accordingly.  This macro is used to\n+  determine a rough estimate of flash size in libgcc, and AVR-LibC uses\n+  this macro to determine vector sizes.  */\n \n enum avr_device_specific_features\n {\n   AVR_ISA_NONE,\n   AVR_ISA_RMW     = 0x1, /* device has RMW instructions. */\n   AVR_SHORT_SP    = 0x2, /* Stack Pointer has 8 bits width. */\n   AVR_ERRATA_SKIP = 0x4, /* device has a core erratum. */\n-  AVR_ISA_LDS     = 0x8  /* whether LDS / STS is valid for all data in static\n+  AVR_ISA_LDS     = 0x8, /* whether LDS / STS is valid for all data in static\n                             storage.  Only useful for reduced Tiny.  */\n+  AVR_ISA_RCALL   = 0x10 /* Use RJMP / RCALL even though JMP / CALL\n+                            are available (-mshort-calls).  */\n };\n \n /* Map architecture to its texinfo string.  */"}, {"sha": "81ffc4e43210d4c507bb5f9c9b418ed0cda2eccc", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "patch": "@@ -313,11 +313,16 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n       cpp_define (pfile, \"__AVR_ENHANCED__\");\n       cpp_define (pfile, \"__AVR_HAVE_MUL__\");\n     }\n+\n+  if (AVR_HAVE_JMP_CALL)\n+    cpp_define (pfile, \"__AVR_HAVE_JMP_CALL__\");\n+\n   if (avr_arch->have_jmp_call)\n-    {\n-      cpp_define (pfile, \"__AVR_MEGA__\");\n-      cpp_define (pfile, \"__AVR_HAVE_JMP_CALL__\");\n-    }\n+    cpp_define (pfile, \"__AVR_MEGA__\");\n+\n+  if (AVR_SHORT_CALLS)\n+    cpp_define (pfile, \"__AVR_SHORT_CALLS__\");\n+\n   if (AVR_XMEGA)\n     cpp_define (pfile, \"__AVR_XMEGA__\");\n \n@@ -335,9 +340,13 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n          (ATtiny4/5/9/10/20 and 40) mapped program memory starts at 0x4000. */\n \n       cpp_define_formatted (pfile, \"__AVR_TINY_PM_BASE_ADDRESS__=0x%x\",\n-                            AVR_TINY_PM_OFFSET);\n+                            avr_arch->flash_pm_offset);\n     }\n \n+  if (avr_arch->flash_pm_offset)\n+    cpp_define_formatted (pfile, \"__AVR_PM_BASE_ADDRESS__=0x%x\",\n+                          avr_arch->flash_pm_offset);\n+\n   if (AVR_HAVE_EIJMP_EICALL)\n     {\n       cpp_define (pfile, \"__AVR_HAVE_EIJMP_EICALL__\");"}, {"sha": "6810ff1cc0f7470433fedccd68addbc522678155", "filename": "gcc/config/avr/avr-devices.c", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Favr-devices.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Favr-devices.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-devices.c?ref=3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "patch": "@@ -34,30 +34,31 @@ const avr_arch_t\n avr_arch_types[] =\n {\n   /* unknown device specified */\n-  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, NULL, AVR_MMCU_DEFAULT },\n+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 0,      32, NULL, AVR_MMCU_DEFAULT },\n   /*\n-    A  M  J  LM E  E  E  X  R  T  d S   S O   A\n-    S  U  M  PO L  L  I  M  A  I  a t   F ff  r\n-    M  L  P  MV P  P  J  E  M  N  t a   R s   c\n-             XW M  M  M  G  P  Y  a r     e   h\n-                   X  P  A  D       t     t   ID   */\n-  { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"1\",   \"avr1\"  },\n-  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"2\",   \"avr2\"  },\n-  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"25\",  \"avr25\" },\n-  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"3\",   \"avr3\"  },\n-  { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, \"31\",  \"avr31\" },\n-  { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"35\",  \"avr35\" },\n-  { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"4\",   \"avr4\"  },\n-  { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"5\",   \"avr5\"  },\n-  { 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0x0060, 32, \"51\",  \"avr51\" },\n-  { 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0x0060, 32, \"6\",   \"avr6\"  },\n-\n-  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0x0040,  0, \"100\", \"avrtiny\" },\n-  { 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0x2000,  0, \"102\", \"avrxmega2\" },\n-  { 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0x2000,  0, \"104\", \"avrxmega4\" },\n-  { 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0x2000,  0, \"105\", \"avrxmega5\" },\n-  { 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0x2000,  0, \"106\", \"avrxmega6\" },\n-  { 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0x2000,  0, \"107\", \"avrxmega7\" }\n+    A  M  J  LM E  E  E  X  R  T  d S     FPO     S O   A\n+    S  U  M  PO L  L  I  M  A  I  a t     lMff    F ff  r\n+    M  L  P  MV P  P  J  E  M  N  t a     a s     R s   c\n+             XW M  M  M  G  P  Y  a r     s e       e   h\n+                   X  P  A  D       t     h t       t   ID   */\n+  { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 0,      32, \"1\",   \"avr1\"  },\n+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 0,      32, \"2\",   \"avr2\"  },\n+  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 0,      32, \"25\",  \"avr25\" },\n+  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0x0060, 0,      32, \"3\",   \"avr3\"  },\n+  { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0x0060, 0,      32, \"31\",  \"avr31\" },\n+  { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0x0060, 0,      32, \"35\",  \"avr35\" },\n+  { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 0,      32, \"4\",   \"avr4\"  },\n+  { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0x0060, 0,      32, \"5\",   \"avr5\"  },\n+  { 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0x0060, 0,      32, \"51\",  \"avr51\" },\n+  { 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0x0060, 0,      32, \"6\",   \"avr6\"  },\n+\n+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0x0040, 0x4000, 0, \"100\", \"avrtiny\" },\n+  { 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0x2000, 0,      0, \"102\", \"avrxmega2\" },\n+  { 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0x2000, 0x8000, 0, \"103\", \"avrxmega3\" },\n+  { 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0x2000, 0,      0, \"104\", \"avrxmega4\" },\n+  { 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0x2000, 0,      0, \"105\", \"avrxmega5\" },\n+  { 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0x2000, 0,      0, \"106\", \"avrxmega6\" },\n+  { 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0x2000, 0,      0, \"107\", \"avrxmega7\" }\n };\n \n const avr_arch_info_t\n@@ -95,6 +96,9 @@ avr_texinfo[] =\n   { ARCH_AVRXMEGA2,\n     \"``XMEGA'' devices with more than 8@tie{}KiB and up to 64@tie{}KiB \"\n     \"of program memory.\" },\n+  { ARCH_AVRXMEGA3,\n+    \"``XMEGA'' devices with up to 64@tie{}KiB of combined program memory \"\n+\t\"and RAM, and with program memory visible in the RAM address space.\" },\n   { ARCH_AVRXMEGA4,\n     \"``XMEGA'' devices with more than 64@tie{}KiB and up to 128@tie{}KiB \"\n     \"of program memory.\" },"}, {"sha": "08a8b69c57768d9b40cba8c3750796f59d98af65", "filename": "gcc/config/avr/avr-mcus.def", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Favr-mcus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Favr-mcus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-mcus.def?ref=3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "patch": "@@ -299,6 +299,23 @@ AVR_MCU (\"atxmega16c4\",      ARCH_AVRXMEGA2, AVR_ISA_RMW,  \"__AVR_ATxmega16C4__\"\n AVR_MCU (\"atxmega32a4u\",     ARCH_AVRXMEGA2, AVR_ISA_RMW,  \"__AVR_ATxmega32A4U__\", 0x2000, 0x0, 0x9000)\n AVR_MCU (\"atxmega32c4\",      ARCH_AVRXMEGA2, AVR_ISA_RMW,  \"__AVR_ATxmega32C4__\",  0x2000, 0x0, 0x9000)\n AVR_MCU (\"atxmega32e5\",      ARCH_AVRXMEGA2, AVR_ISA_NONE, \"__AVR_ATxmega32E5__\",  0x2000, 0x0, 0x9000)\n+/* Xmega, Flash + RAM < 64K, flash visible in RAM address space */\n+AVR_MCU (\"avrxmega3\",        ARCH_AVRXMEGA3, AVR_ISA_NONE,  NULL,                  0x3f00, 0x0, 0x8000)\n+AVR_MCU (\"attiny212\",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, \"__AVR_ATtiny212__\",   0x3f80, 0x0, 0x800)\n+AVR_MCU (\"attiny214\",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, \"__AVR_ATtiny214__\",   0x3f80, 0x0, 0x800)\n+AVR_MCU (\"attiny412\",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, \"__AVR_ATtiny412__\",   0x3f00, 0x0, 0x1000)\n+AVR_MCU (\"attiny414\",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, \"__AVR_ATtiny414__\",   0x3f00, 0x0, 0x1000)\n+AVR_MCU (\"attiny416\",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, \"__AVR_ATtiny416__\",   0x3f00, 0x0, 0x1000)\n+AVR_MCU (\"attiny417\",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, \"__AVR_ATtiny417__\",   0x3f00, 0x0, 0x1000)\n+AVR_MCU (\"attiny814\",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, \"__AVR_ATtiny814__\",   0x3e00, 0x0, 0x2000)\n+AVR_MCU (\"attiny816\",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, \"__AVR_ATtiny816__\",   0x3e00, 0x0, 0x2000)\n+AVR_MCU (\"attiny817\",        ARCH_AVRXMEGA3, AVR_ISA_RCALL, \"__AVR_ATtiny817__\",   0x3e00, 0x0, 0x2000)\n+AVR_MCU (\"attiny1614\",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  \"__AVR_ATtiny1614__\",  0x3800, 0x0, 0x4000)\n+AVR_MCU (\"attiny1616\",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  \"__AVR_ATtiny1616__\",  0x3800, 0x0, 0x4000)\n+AVR_MCU (\"attiny1617\",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  \"__AVR_ATtiny1617__\",  0x3800, 0x0, 0x4000)\n+AVR_MCU (\"attiny3214\",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  \"__AVR_ATtiny3214__\",  0x3800, 0x0, 0x8000)\n+AVR_MCU (\"attiny3216\",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  \"__AVR_ATtiny3216__\",  0x3800, 0x0, 0x8000)\n+AVR_MCU (\"attiny3217\",       ARCH_AVRXMEGA3, AVR_ISA_NONE,  \"__AVR_ATtiny3217__\",  0x3800, 0x0, 0x8000)\n /* Xmega, 64K < Flash <= 128K, RAM <= 64K */\n AVR_MCU (\"avrxmega4\",        ARCH_AVRXMEGA4, AVR_ISA_NONE, NULL,                   0x2000, 0x0, 0x11000)\n AVR_MCU (\"atxmega64a3\",      ARCH_AVRXMEGA4, AVR_ISA_NONE, \"__AVR_ATxmega64A3__\",  0x2000, 0x0, 0x11000)"}, {"sha": "4f385d5682f6d373384630d897b0f76509b4c45b", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "patch": "@@ -2502,7 +2502,7 @@ avr_print_operand_address (FILE *file, machine_mode /*mode*/, rtx addr)\n   if (AVR_TINY\n       && avr_address_tiny_pm_p (addr))\n     {\n-      addr = plus_constant (Pmode, addr, AVR_TINY_PM_OFFSET);\n+      addr = plus_constant (Pmode, addr, avr_arch->flash_pm_offset);\n     }\n \n   switch (GET_CODE (addr))\n@@ -9398,7 +9398,7 @@ avr_assemble_integer (rtx x, unsigned int size, int aligned_p)\n   if (AVR_TINY\n       && avr_address_tiny_pm_p (x))\n     {\n-      x = plus_constant (Pmode, x, AVR_TINY_PM_OFFSET);\n+      x = plus_constant (Pmode, x, avr_arch->flash_pm_offset);\n     }\n \n   return default_assemble_integer (x, size, aligned_p);\n@@ -9998,9 +9998,11 @@ static void\n avr_asm_init_sections (void)\n {\n   /* Override section callbacks to keep track of `avr_need_clear_bss_p'\n-     resp. `avr_need_copy_data_p'.  */\n+     resp. `avr_need_copy_data_p'.  If flash is not mapped to RAM then\n+     we have also to track .rodata because it is located in RAM then.  */\n \n-  readonly_data_section->unnamed.callback = avr_output_data_section_asm_op;\n+  if (0 == avr_arch->flash_pm_offset)\n+    readonly_data_section->unnamed.callback = avr_output_data_section_asm_op;\n   data_section->unnamed.callback = avr_output_data_section_asm_op;\n   bss_section->unnamed.callback = avr_output_bss_section_asm_op;\n }\n@@ -10032,9 +10034,13 @@ avr_asm_named_section (const char *name, unsigned int flags, tree decl)\n \n   if (!avr_need_copy_data_p)\n     avr_need_copy_data_p = (STR_PREFIX_P (name, \".data\")\n-                            || STR_PREFIX_P (name, \".rodata\")\n                             || STR_PREFIX_P (name, \".gnu.linkonce.d\"));\n \n+  if (!avr_need_copy_data_p\n+      && 0 == avr_arch->flash_pm_offset)\n+    avr_need_copy_data_p = (STR_PREFIX_P (name, \".rodata\")\n+                            || STR_PREFIX_P (name, \".gnu.linkonce.r\"));\n+\n   if (!avr_need_clear_bss_p)\n     avr_need_clear_bss_p = STR_PREFIX_P (name, \".bss\");\n \n@@ -10201,7 +10207,7 @@ avr_encode_section_info (tree decl, rtx rtl, int new_decl_p)\n \n       if (progmem_p)\n         {\n-          // Tag symbols for later addition of 0x4000 (AVR_TINY_PM_OFFSET).\n+          // Tag symbols for addition of 0x4000 (avr_arch->flash_pm_offset).\n           SYMBOL_REF_FLAGS (sym) |= AVR_SYMBOL_FLAG_TINY_PM;\n         }\n "}, {"sha": "3158887fc01eba8ee28db248a6e2003f1f5d3941", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "patch": "@@ -60,7 +60,9 @@ enum\n \n #define TARGET_CPU_CPP_BUILTINS()\tavr_cpu_cpp_builtins (pfile)\n \n-#define AVR_HAVE_JMP_CALL (avr_arch->have_jmp_call)\n+#define AVR_SHORT_CALLS (TARGET_SHORT_CALLS                             \\\n+                         && avr_arch == &avr_arch_types[ARCH_AVRXMEGA3])\n+#define AVR_HAVE_JMP_CALL (avr_arch->have_jmp_call && ! AVR_SHORT_CALLS)\n #define AVR_HAVE_MUL (avr_arch->have_mul)\n #define AVR_HAVE_MOVW (avr_arch->have_movw_lpmx)\n #define AVR_HAVE_LPM (!AVR_TINY)\n@@ -74,8 +76,6 @@ enum\n                         || avr_arch->have_rampd)\n #define AVR_HAVE_EIJMP_EICALL (avr_arch->have_eijmp_eicall)\n \n-#define AVR_TINY_PM_OFFSET (0x4000)\n-\n /* Handling of 8-bit SP versus 16-bit SP is as follows:\n \n FIXME: DRIVER_SELF_SPECS has changed."}, {"sha": "1efb1c063b6eae5297a549491cb7ccb7962ded0d", "filename": "gcc/config/avr/avr.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Favr.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Favr.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.opt?ref=3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "patch": "@@ -44,6 +44,10 @@ Target Report Undocumented Mask(ALL_DEBUG)\n mlog=\n Target RejectNegative Joined Undocumented Var(avr_log_details)\n \n+mshort-calls\n+Target Report RejectNegative Mask(SHORT_CALLS)\n+Use RJMP / RCALL even though CALL / JMP are available.\n+\n mint8\n Target Report Mask(INT8)\n Use an 8-bit 'int' type."}, {"sha": "a25ac6f9e50005192d0ed0f2efd7a924b4843507", "filename": "gcc/config/avr/gen-avr-mmcu-specs.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-specs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-specs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-specs.c?ref=3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "patch": "@@ -113,6 +113,7 @@ static void\n print_mcu (const avr_mcu_t *mcu)\n {\n   const char *sp8_spec;\n+  const char *rcall_spec;\n   const avr_mcu_t *arch_mcu;\n   const avr_arch_t *arch;\n   enum avr_arch_id arch_id = mcu->arch_id;\n@@ -134,6 +135,7 @@ print_mcu (const avr_mcu_t *mcu)\n   bool errata_skip = 0 != (mcu->dev_attribute & AVR_ERRATA_SKIP);\n   bool rmw = 0 != (mcu->dev_attribute & AVR_ISA_RMW);\n   bool sp8 = 0 != (mcu->dev_attribute & AVR_SHORT_SP);\n+  bool rcall = (mcu->dev_attribute & AVR_ISA_RCALL);\n   bool is_arch = NULL == mcu->macro;\n   bool is_device = ! is_arch;\n \n@@ -150,13 +152,25 @@ print_mcu (const avr_mcu_t *mcu)\n       sp8_spec = sp8 ? \"-msp8\" :\"%<msp8\";\n     }\n \n+  if (is_arch\n+      && ARCH_AVRXMEGA3 == arch_id)\n+    {\n+      // Leave \"avrxmega3\" alone.  This architectures is the only one\n+      // that mixes devices with and without JMP / CALL.\n+      rcall_spec = \"\";\n+    }\n+  else\n+    {\n+      rcall_spec = rcall ? \"-mshort-calls\" : \"%<mshort-calls\";\n+    }\n+\n   fprintf (f, \"#\\n\"\n            \"# Auto-generated specs for AVR \");\n   if (is_arch)\n     fprintf (f, \"core architecture %s\\n\", arch->name);\n   else\n-    fprintf (f, \"device %s (core %s, %d-bit SP)\\n\",\n-             mcu->name, arch->name, sp8 ? 8 : 16);\n+    fprintf (f, \"device %s (core %s, %d-bit SP%s)\\n\", mcu->name,\n+\t\t\t arch->name, sp8 ? 8 : 16, rcall ? \", short-calls\" : \"\");\n   fprintf (f, \"%s\\n\", header);\n \n   if (is_device)\n@@ -255,6 +269,7 @@ print_mcu (const avr_mcu_t *mcu)\n     {\n       fprintf (f, \"*self_spec:\\n\");\n       fprintf (f, \"\\t%%{!mmcu=avr*: %%<mmcu=* -mmcu=%s} \", arch->name);\n+      fprintf (f, \"%s \", rcall_spec);\n       fprintf (f, \"%s\\n\\n\", sp8_spec);\n \n #if defined (WITH_AVRLIBC)"}, {"sha": "e657e558cae80493ed6804eccb597171004834be", "filename": "gcc/config/avr/genmultilib.awk", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Fgenmultilib.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Fgenmultilib.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fgenmultilib.awk?ref=3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "patch": "@@ -35,6 +35,9 @@ BEGIN {\n     dir_tiny = \"tiny-stack\"\n     opt_tiny = \"msp8\"\n \n+    dir_rcall = \"short-calls\"\n+    opt_rcall = \"mshort-calls\"\n+\n     #    awk Variable         Makefile Variable  \n     #  ------------------------------------------\n     #    m_options     <->    MULTILIB_OPTIONS\n@@ -116,6 +119,8 @@ BEGIN {\n     {\n       if (dev_attribute[i] == \"AVR_SHORT_SP\")\n         opts = opts \"/\" opt_tiny\n+      if (dev_attribute[i] == \"AVR_ISA_RCALL\")\n+        opts = opts \"/\" opt_rcall\n     }\n \n     if (!have[opts])\n@@ -140,7 +145,7 @@ END {\n \n     # Intended Target: ./gcc/config/avr/t-multilib\n \n-    print m_options  \" \" opt_tiny\n-    print m_dirnames \" \" dir_tiny\n+    print m_options  \" \" opt_tiny \" \" opt_rcall\n+    print m_dirnames \" \" dir_tiny \" \" dir_rcall\n     print m_required\n }"}, {"sha": "6a6eebc49138733304e88bc970a0738f6493b61b", "filename": "gcc/config/avr/t-multilib", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Ft-multilib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfig%2Favr%2Ft-multilib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Ft-multilib?ref=3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "patch": "@@ -21,9 +21,9 @@\n # along with GCC; see the file COPYING3.  If not see\n # <http://www.gnu.org/licenses/>.\n \n-MULTILIB_OPTIONS = mmcu=avr2/mmcu=avr25/mmcu=avr3/mmcu=avr31/mmcu=avr35/mmcu=avr4/mmcu=avr5/mmcu=avr51/mmcu=avr6/mmcu=avrxmega2/mmcu=avrxmega4/mmcu=avrxmega5/mmcu=avrxmega6/mmcu=avrxmega7/mmcu=avrtiny msp8\n+MULTILIB_OPTIONS = mmcu=avr2/mmcu=avr25/mmcu=avr3/mmcu=avr31/mmcu=avr35/mmcu=avr4/mmcu=avr5/mmcu=avr51/mmcu=avr6/mmcu=avrxmega2/mmcu=avrxmega3/mmcu=avrxmega4/mmcu=avrxmega5/mmcu=avrxmega6/mmcu=avrxmega7/mmcu=avrtiny msp8 mshort-calls\n \n-MULTILIB_DIRNAMES = avr2 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega2 avrxmega4 avrxmega5 avrxmega6 avrxmega7 avrtiny tiny-stack\n+MULTILIB_DIRNAMES = avr2 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega2 avrxmega3 avrxmega4 avrxmega5 avrxmega6 avrxmega7 avrtiny tiny-stack short-calls\n \n MULTILIB_REQUIRED = \\\n \tmsp8 \\\n@@ -37,6 +37,8 @@ MULTILIB_REQUIRED = \\\n \tmmcu=avr51 \\\n \tmmcu=avr6 \\\n \tmmcu=avrxmega2 \\\n+\tmmcu=avrxmega3/mshort-calls \\\n+\tmmcu=avrxmega3 \\\n \tmmcu=avrxmega4 \\\n \tmmcu=avrxmega5 \\\n \tmmcu=avrxmega6 \\"}, {"sha": "cc542ac4da58fa839beb0fc5de4fb04bce298ea5", "filename": "gcc/configure", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "patch": "@@ -24819,6 +24819,61 @@ $as_echo \"#define HAVE_AS_AVR_MRMW_OPTION 1\" >>confdefs.h\n \n fi\n \n+\n+    # Check how default linker description file implements .rodata for\n+    # avrxmega3 (PR21472).  avr-gcc assumes .rodata is *not* loaded to\n+    # RAM so avr-gcc skips __do_copy_data for .rodata objects.\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking binutils for avrxmega3 .rodata support\" >&5\n+$as_echo_n \"checking binutils for avrxmega3 .rodata support... \" >&6; }\n+    cat > conftest.s <<EOF\n+        .section .rodata,\"a\",@progbits\n+        .global xxvaryy\n+    ;; avr-nm should print \"... R xxvaryy\", not \"... D xxvaryy\".\n+    xxvaryy:\n+        .word 1\n+EOF\n+    rm -f conftest.nm\n+    { ac_try='$gcc_cv_as -mmcu=avrxmega3 conftest.s -o conftest.o'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    { ac_try='$gcc_cv_ld -mavrxmega3 conftest.o -o conftest.elf'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    { ac_try='$gcc_cv_nm conftest.elf > conftest.nm'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    if test -f conftest.nm\n+    then\n+\tif grep ' R xxvaryy' conftest.nm > /dev/null; then\n+\t    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n+$as_echo \"yes\" >&6; }\n+\t    rm -f conftest.s conftest.o conftest.elf conftest.nm\n+\telse\n+\t    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no: avrxmega3 .rodata located in RAM\" >&5\n+$as_echo \"no: avrxmega3 .rodata located in RAM\" >&6; }\n+\t    echo \"$as_me: nm output was\" >&5\n+\t    cat conftest.nm >&5\n+\t    rm -f conftest.s conftest.o conftest.elf conftest.nm\n+\t    avr_ld_ver=\"`$gcc_cv_ld -v | sed -e 's:^.* ::'`\"\n+\t    as_fn_error \"support for avrxmega3 needs Binutils 2.29 or higher (have $avr_ld_ver)\" \"$LINENO\" 5\n+\tfi\n+    else\n+\t{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: test failed\" >&5\n+$as_echo \"test failed\" >&6; }\n+\techo \"$as_me: failed program was\" >&5\n+\tcat conftest.s >&5\n+\trm -f conftest.s conftest.o conftest.elf\n+\tas_fn_error \"see \\`config.log' for details\" \"$LINENO\" 5\n+    fi\n     ;;\n \n   cris-*-*)"}, {"sha": "b54f797b4b9ca856811f8da901f566c397ceeaba", "filename": "gcc/configure.ac", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "patch": "@@ -3816,6 +3816,42 @@ AS_HELP_STRING([--disable-fix-cortex-a53-843419],\n       [-mrmw], [.text],,\n       [AC_DEFINE(HAVE_AS_AVR_MRMW_OPTION, 1,\n \t\t[Define if your avr assembler supports -mrmw option.])])\n+\n+    # Check how default linker description file implements .rodata for\n+    # avrxmega3 (PR21472).  avr-gcc assumes .rodata is *not* loaded to\n+    # RAM so avr-gcc skips __do_copy_data for .rodata objects.\n+    AC_MSG_CHECKING(binutils for avrxmega3 .rodata support)\n+    cat > conftest.s <<EOF\n+        .section .rodata,\"a\",@progbits\n+        .global xxvaryy\n+    ;; avr-nm should print \"... R xxvaryy\", not \"... D xxvaryy\".\n+    xxvaryy:\n+        .word 1\n+EOF\n+    rm -f conftest.nm\n+    AC_TRY_COMMAND([$gcc_cv_as -mmcu=avrxmega3 conftest.s -o conftest.o])\n+    AC_TRY_COMMAND([$gcc_cv_ld -mavrxmega3 conftest.o -o conftest.elf])\n+    AC_TRY_COMMAND([$gcc_cv_nm conftest.elf > conftest.nm])\n+    if test -f conftest.nm\n+    then\n+\tif grep ' R xxvaryy' conftest.nm > /dev/null; then\n+\t    AC_MSG_RESULT(yes)\n+\t    rm -f conftest.s conftest.o conftest.elf conftest.nm\n+\telse\n+\t    AC_MSG_RESULT(no: avrxmega3 .rodata located in RAM)\n+\t    echo \"$as_me: nm output was\" >&AS_MESSAGE_LOG_FD\n+\t    cat conftest.nm >&AS_MESSAGE_LOG_FD\n+\t    rm -f conftest.s conftest.o conftest.elf conftest.nm\n+\t    avr_ld_ver=\"`$gcc_cv_ld -v | sed -e 's:^.* ::'`\"\n+\t    AC_MSG_ERROR([[support for avrxmega3 needs Binutils 2.29 or higher (have $avr_ld_ver)]])\n+\tfi\n+    else\n+\tAC_MSG_RESULT(test failed)\n+\techo \"$as_me: failed program was\" >&AS_MESSAGE_LOG_FD\n+\tcat conftest.s >&AS_MESSAGE_LOG_FD\n+\trm -f conftest.s conftest.o conftest.elf\n+\tAC_MSG_ERROR([[see `config.log' for details]])\n+    fi\n     ;;\n \n   cris-*-*)"}, {"sha": "15fd414f790f3484d54870c60da95ed4079e28ab", "filename": "gcc/doc/avr-mmcu.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fdoc%2Favr-mmcu.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fdoc%2Favr-mmcu.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Favr-mmcu.texi?ref=3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "patch": "@@ -52,6 +52,10 @@\n ``XMEGA'' devices with more than 8@tie{}KiB and up to 64@tie{}KiB of program memory.\n @*@var{mcu}@tie{}= @code{atxmega16a4}, @code{atxmega16a4u}, @code{atxmega16c4}, @code{atxmega16d4}, @code{atxmega16e5}, @code{atxmega32a4}, @code{atxmega32a4u}, @code{atxmega32c3}, @code{atxmega32c4}, @code{atxmega32d3}, @code{atxmega32d4}, @code{atxmega32e5}, @code{atxmega8e5}.\n \n+@item avrxmega3\n+``XMEGA'' devices with up to 64@tie{}KiB of combined program memory and RAM, and with program memory visible in the RAM address space.\n+@*@var{mcu}@tie{}= @code{attiny1614}, @code{attiny1616}, @code{attiny1617}, @code{attiny212}, @code{attiny214}, @code{attiny3214}, @code{attiny3216}, @code{attiny3217}, @code{attiny412}, @code{attiny414}, @code{attiny416}, @code{attiny417}, @code{attiny814}, @code{attiny816}, @code{attiny817}.\n+\n @item avrxmega4\n ``XMEGA'' devices with more than 64@tie{}KiB and up to 128@tie{}KiB of program memory.\n @*@var{mcu}@tie{}= @code{atxmega64a3}, @code{atxmega64a3u}, @code{atxmega64a4u}, @code{atxmega64b1}, @code{atxmega64b3}, @code{atxmega64c3}, @code{atxmega64d3}, @code{atxmega64d4}."}, {"sha": "ef1ae73954c4e92490d1e1cdad02c17abdea6b33", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "patch": "@@ -1312,11 +1312,24 @@ in order to put read-only data into the flash memory and access that\n data by means of the special instructions @code{LPM} or @code{ELPM}\n needed to read from flash.\n \n-Per default, any data including read-only data is located in RAM\n-(the generic address space) so that non-generic address spaces are\n-needed to locate read-only data in flash memory\n-@emph{and} to generate the right instructions to access this data\n-without using (inline) assembler code.\n+Devices belonging to @code{avrtiny} and @code{avrxmega3} can access\n+flash memory by means of @code{LD*} instructions because the flash\n+memory is mapped into the RAM address space.  There is @emph{no need}\n+for language extensions like @code{__flash} or attribute\n+@ref{AVR Variable Attributes,,@code{progmem}}.\n+The default linker description files for these devices cater for that\n+feature and @code{.rodata} stays in flash: The compiler just generates\n+@code{LD*} instructions, and the linker script adds core specific\n+offsets to all @code{.rodata} symbols: @code{0x4000} in the case of\n+@code{avrtiny} and @code{0x8000} in the case of @code{avrxmega3}.\n+See @ref{AVR Options} for a list of respective devices.\n+\n+For devices not in @code{avrtiny} or @code{avrxmega3},\n+any data including read-only data is located in RAM (the generic\n+address space) because flash memory is not visible in the RAM address\n+space.  In order to locate read-only data in flash memory @emph{and}\n+to generate the right instructions to access this data without\n+using (inline) assembler code, special address spaces are needed.\n \n @table @code\n @item __flash\n@@ -1447,14 +1460,11 @@ extern const __memx char foo;\n const __memx void *pfoo = &foo;\n @end smallexample\n \n-@noindent\n-Such code requires at least binutils 2.23, see\n-@w{@uref{https://sourceware.org/PR13503,PR13503}}.\n-\n @item\n On the reduced Tiny devices like ATtiny40, no address spaces are supported.\n-Data can be put into and read from flash memory by means of\n-attribute @code{progmem}, see @ref{AVR Variable Attributes}.\n+Just use vanilla C / C++ code without overhead as outlined above.\n+Attribute @code{progmem} is supported but works differently,\n+see @ref{AVR Variable Attributes}.\n \n @end itemize\n \n@@ -5936,6 +5946,19 @@ normally resides in the data memory (RAM).\n See also the @ref{AVR Named Address Spaces} section for\n an alternate way to locate and access data in flash memory.\n \n+@item @bullet{}@tie{} AVR cores with flash memory visible in the RAM address range:\n+On such devices, there is no need for attribute @code{progmem} or\n+@ref{AVR Named Address Spaces,,@code{__flash}} qualifier at all.\n+Just use standard C / C++.  The compiler will generate @code{LD*}\n+instructions.  As flash memory is visible in the RAM address range,\n+and the default linker script does @emph{not} locate @code{.rodata} in\n+RAM, no special features are needed in order not to waste RAM for\n+read-only data or to read from flash.  You might even get slightly better\n+performance by\n+avoiding @code{progmem} and @code{__flash}.  This applies to devices from\n+families @code{avrtiny} and @code{avrxmega3}, see @ref{AVR Options} for\n+an overview.\n+\n @item @bullet{}@tie{}Reduced AVR Tiny cores like ATtiny40:\n The compiler adds @code{0x4000}\n to the addresses of objects and declarations in @code{progmem} and locates\n@@ -5957,28 +5980,7 @@ int read_var (int i)\n @end smallexample\n \n Please notice that on these devices, there is no need for @code{progmem}\n-at all.  Just use an appropriate linker description file like outlined below.\n-\n-@smallexample\n-  .text :\n-  @{ ...\n-  @} > text\n-  /* Leave .rodata in flash and add an offset of 0x4000 to all\n-     addresses so that respective objects can be accessed by\n-     LD instructions and open coded C/C++.  This means there\n-     is no need for progmem in the source and no overhead by\n-     read-only data in RAM.  */\n-  .rodata ADDR(.text) + SIZEOF (.text) + 0x4000 :\n-  @{\n-    *(.rodata)\n-    *(.rodata*)\n-    *(.gnu.linkonce.r*)\n-  @} AT> text\n-  /* No more need to put .rodata into .data:\n-     Removed all .rodata entries from .data.  */\n-  .data :\n-  @{ ...\n-@end smallexample\n+at all.\n \n @end table\n "}, {"sha": "653bc076759203c6b6399f5f54d4153824fdc294", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3266ddb36a000a6d3fbad3541ffb67ba980e5a67/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3266ddb36a000a6d3fbad3541ffb67ba980e5a67", "patch": "@@ -662,7 +662,7 @@ Objective-C and Objective-C++ Dialects}.\n -mbranch-cost=@var{cost} @gol\n -mcall-prologues  -mint8  -mn_flash=@var{size}  -mno-interrupts @gol\n -mrelax  -mrmw  -mstrict-X  -mtiny-stack  -mfract-convert-truncate @gol\n--nodevicelib @gol\n+-mshort-calls  -nodevicelib @gol\n -Waddr-space-convert  -Wmisspelled-isr}\n \n @emph{Blackfin Options}\n@@ -15637,6 +15637,15 @@ section on @code{EIND} and linker stubs below.\n Assume that the device supports the Read-Modify-Write\n instructions @code{XCH}, @code{LAC}, @code{LAS} and @code{LAT}.\n \n+@item -mshort-calls\n+@opindex mshort-calls\n+\n+Assume that @code{RJMP} and @code{RCALL} can target the whole\n+program memory.\n+\n+This option is used internally for multilib selection.  It is\n+not an optimization option, and you don't need to set it by hand.\n+\n @item -msp8\n @opindex msp8\n Treat the stack pointer register as an 8-bit register,\n@@ -15897,10 +15906,12 @@ for @var{mcu}=@code{avr2}, @code{avr25}, @code{avr3}, @code{avr31},\n \n respectively and\n \n-@code{100}, @code{102}, @code{104},\n+@code{100},\n+@code{102}, @code{103}, @code{104},\n @code{105}, @code{106}, @code{107}\n \n-for @var{mcu}=@code{avrtiny}, @code{avrxmega2}, @code{avrxmega4},\n+for @var{mcu}=@code{avrtiny},\n+@code{avrxmega2}, @code{avrxmega3}, @code{avrxmega4},\n @code{avrxmega5}, @code{avrxmega6}, @code{avrxmega7}, respectively.\n If @var{mcu} specifies a device, this built-in macro is set\n accordingly. For example, with @option{-mmcu=atmega8} the macro is\n@@ -15952,7 +15963,7 @@ The device has a hardware multiplier.\n \n @item __AVR_HAVE_JMP_CALL__\n The device has the @code{JMP} and @code{CALL} instructions.\n-This is the case for devices with at least 16@tie{}KiB of program\n+This is the case for devices with more than 8@tie{}KiB of program\n memory.\n \n @item __AVR_HAVE_EIJMP_EICALL__\n@@ -16009,6 +16020,21 @@ or @code{STS}. This offset depends on the device architecture and has\n to be subtracted from the RAM address in order to get the\n respective I/O@tie{}address.\n \n+@item __AVR_SHORT_CALLS__\n+The @option{-mshort-calls} command line option is set.\n+\n+@item __AVR_PM_BASE_ADDRESS__=@var{addr}\n+Some devices support reading from flash memory by means of @code{LD*}\n+instructions.  The flash memory is seen in the data address space\n+at an offset of @code{__AVR_PM_BASE_ADDRESS__}.  If this macro\n+is not defined, this feature is not available.  If defined,\n+the address space is linear and there is no need to put\n+@code{.rodata} into RAM.  This is handled by the default linker\n+description file, and is currently available for\n+@code{avrtiny} and @code{avrxmega3}.  Even more convenient,\n+there is no need to use address spaces like @code{__flash} or\n+features like attribute @code{progmem} and @code{pgm_read_*}.\n+\n @item __WITH_AVRLIBC__\n The compiler is configured to be used together with AVR-Libc.\n See the @option{--with-avrlibc} configure option."}]}