{"sha": "d9e80f4944deb243a8771917236d49c434c029ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDllODBmNDk0NGRlYjI0M2E4NzcxOTE3MjM2ZDQ5YzQzNGMwMjllZg==", "commit": {"author": {"name": "Alan Lawrence", "email": "alan.lawrence@arm.com", "date": "2014-11-24T15:15:20Z"}, "committer": {"name": "Alan Lawrence", "email": "alalaw01@gcc.gnu.org", "date": "2014-11-24T15:15:20Z"}, "message": "[AArch64]Tidy up aarch64_simd_expand_args\n\n       * config/aarch64/aarch64-builtins.c (aarch64_simd_expand_args): \n        Refactor by combining switch statements and make arrays into scalars.\n\nFrom-SVN: r218021", "tree": {"sha": "524793fb7ca18684134d40d6c7cd94c5dc62f584", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/524793fb7ca18684134d40d6c7cd94c5dc62f584"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9e80f4944deb243a8771917236d49c434c029ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9e80f4944deb243a8771917236d49c434c029ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9e80f4944deb243a8771917236d49c434c029ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9e80f4944deb243a8771917236d49c434c029ef/comments", "author": null, "committer": null, "parents": [{"sha": "cf6abd9d9f23b871e5d93be826b988da1a43edf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf6abd9d9f23b871e5d93be826b988da1a43edf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf6abd9d9f23b871e5d93be826b988da1a43edf1"}], "stats": {"total": 131, "additions": 57, "deletions": 74}, "files": [{"sha": "f1171a7d7cb30fcec0ea64acc226119bc3c89dfe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e80f4944deb243a8771917236d49c434c029ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e80f4944deb243a8771917236d49c434c029ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9e80f4944deb243a8771917236d49c434c029ef", "patch": "@@ -1,3 +1,8 @@\n+2014-11-24  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\t* config/aarch64/aarch64-builtins.c (aarch64_simd_expand_args):\n+\tRefactor by combining switch statements and make arrays into scalars.\n+\n 2014-11-24  David Edelsohn  <dje.gcc@gmail.com>\n \n \tPR c++/58561"}, {"sha": "db6d6c17b0f9fd73f7b399ea3b95eb165cef4691", "filename": "gcc/config/aarch64/aarch64-builtins.c", "status": "modified", "additions": 52, "deletions": 74, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e80f4944deb243a8771917236d49c434c029ef/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e80f4944deb243a8771917236d49c434c029ef/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c?ref=d9e80f4944deb243a8771917236d49c434c029ef", "patch": "@@ -867,60 +867,61 @@ aarch64_simd_expand_args (rtx target, int icode, int have_retval,\n \t\t\t  tree exp, builtin_simd_arg *args)\n {\n   rtx pat;\n-  tree arg[SIMD_MAX_BUILTIN_ARGS];\n-  rtx op[SIMD_MAX_BUILTIN_ARGS];\n-  machine_mode tmode = insn_data[icode].operand[0].mode;\n-  machine_mode mode[SIMD_MAX_BUILTIN_ARGS];\n-  int argc = 0;\n+  rtx op[SIMD_MAX_BUILTIN_ARGS + 1]; /* First element for result operand.  */\n+  int opc = 0;\n \n-  if (have_retval\n-      && (!target\n+  if (have_retval)\n+    {\n+      machine_mode tmode = insn_data[icode].operand[0].mode;\n+      if (!target\n \t  || GET_MODE (target) != tmode\n-\t  || !(*insn_data[icode].operand[0].predicate) (target, tmode)))\n-    target = gen_reg_rtx (tmode);\n+\t  || !(*insn_data[icode].operand[0].predicate) (target, tmode))\n+\ttarget = gen_reg_rtx (tmode);\n+      op[opc++] = target;\n+    }\n \n   for (;;)\n     {\n-      builtin_simd_arg thisarg = args[argc];\n+      builtin_simd_arg thisarg = args[opc - have_retval];\n \n       if (thisarg == SIMD_ARG_STOP)\n \tbreak;\n       else\n \t{\n-\t  arg[argc] = CALL_EXPR_ARG (exp, argc);\n-\t  op[argc] = expand_normal (arg[argc]);\n-\t  mode[argc] = insn_data[icode].operand[argc + have_retval].mode;\n+\t  tree arg = CALL_EXPR_ARG (exp, opc - have_retval);\n+\t  enum machine_mode mode = insn_data[icode].operand[opc].mode;\n+\t  op[opc] = expand_normal (arg);\n \n \t  switch (thisarg)\n \t    {\n \t    case SIMD_ARG_COPY_TO_REG:\n-\t      if (POINTER_TYPE_P (TREE_TYPE (arg[argc])))\n-\t\top[argc] = convert_memory_address (Pmode, op[argc]);\n-\t      /*gcc_assert (GET_MODE (op[argc]) == mode[argc]); */\n-\t      if (!(*insn_data[icode].operand[argc + have_retval].predicate)\n-\t\t  (op[argc], mode[argc]))\n-\t\top[argc] = copy_to_mode_reg (mode[argc], op[argc]);\n+\t      if (POINTER_TYPE_P (TREE_TYPE (arg)))\n+\t\top[opc] = convert_memory_address (Pmode, op[opc]);\n+\t      /*gcc_assert (GET_MODE (op[opc]) == mode); */\n+\t      if (!(*insn_data[icode].operand[opc].predicate)\n+\t\t  (op[opc], mode))\n+\t\top[opc] = copy_to_mode_reg (mode, op[opc]);\n \t      break;\n \n \t    case SIMD_ARG_LANE_INDEX:\n \t      /* Must be a previous operand into which this is an index.  */\n-\t      gcc_assert (argc > 0);\n-\t      if (CONST_INT_P (op[argc]))\n+\t      gcc_assert (opc > 0);\n+\t      if (CONST_INT_P (op[opc]))\n \t\t{\n-\t\t  enum machine_mode vmode = mode[argc - 1];\n-\t\t  aarch64_simd_lane_bounds (op[argc],\n+\t\t  machine_mode vmode = insn_data[icode].operand[opc - 1].mode;\n+\t\t  aarch64_simd_lane_bounds (op[opc],\n \t\t\t\t\t    0, GET_MODE_NUNITS (vmode), exp);\n \t\t  /* Keep to GCC-vector-extension lane indices in the RTL.  */\n-\t\t  op[argc] = GEN_INT (ENDIAN_LANE_N (vmode, INTVAL (op[argc])));\n+\t\t  op[opc] = GEN_INT (ENDIAN_LANE_N (vmode, INTVAL (op[opc])));\n \t\t}\n \t      /* Fall through - if the lane index isn't a constant then\n \t\t the next case will error.  */\n \t    case SIMD_ARG_CONSTANT:\n-\t      if (!(*insn_data[icode].operand[argc + have_retval].predicate)\n-\t\t  (op[argc], mode[argc]))\n+\t      if (!(*insn_data[icode].operand[opc].predicate)\n+\t\t  (op[opc], mode))\n \t      {\n \t\terror_at (EXPR_LOCATION (exp), \"incompatible type for argument %d, \"\n-\t\t       \"expected %<const int%>\", argc + 1);\n+\t\t       \"expected %<const int%>\", opc + 1);\n \t\treturn const0_rtx;\n \t      }\n \t      break;\n@@ -929,62 +930,39 @@ aarch64_simd_expand_args (rtx target, int icode, int have_retval,\n \t      gcc_unreachable ();\n \t    }\n \n-\t  argc++;\n+\t  opc++;\n \t}\n     }\n \n-  if (have_retval)\n-    switch (argc)\n-      {\n-      case 1:\n-\tpat = GEN_FCN (icode) (target, op[0]);\n-\tbreak;\n-\n-      case 2:\n-\tpat = GEN_FCN (icode) (target, op[0], op[1]);\n-\tbreak;\n-\n-      case 3:\n-\tpat = GEN_FCN (icode) (target, op[0], op[1], op[2]);\n-\tbreak;\n-\n-      case 4:\n-\tpat = GEN_FCN (icode) (target, op[0], op[1], op[2], op[3]);\n-\tbreak;\n-\n-      case 5:\n-\tpat = GEN_FCN (icode) (target, op[0], op[1], op[2], op[3], op[4]);\n-\tbreak;\n+  switch (opc)\n+    {\n+    case 1:\n+      pat = GEN_FCN (icode) (op[0]);\n+      break;\n \n-      default:\n-\tgcc_unreachable ();\n-      }\n-  else\n-    switch (argc)\n-      {\n-      case 1:\n-\tpat = GEN_FCN (icode) (op[0]);\n-\tbreak;\n+    case 2:\n+      pat = GEN_FCN (icode) (op[0], op[1]);\n+      break;\n \n-      case 2:\n-\tpat = GEN_FCN (icode) (op[0], op[1]);\n-\tbreak;\n+    case 3:\n+      pat = GEN_FCN (icode) (op[0], op[1], op[2]);\n+      break;\n \n-      case 3:\n-\tpat = GEN_FCN (icode) (op[0], op[1], op[2]);\n-\tbreak;\n+    case 4:\n+      pat = GEN_FCN (icode) (op[0], op[1], op[2], op[3]);\n+      break;\n \n-      case 4:\n-\tpat = GEN_FCN (icode) (op[0], op[1], op[2], op[3]);\n-\tbreak;\n+    case 5:\n+      pat = GEN_FCN (icode) (op[0], op[1], op[2], op[3], op[4]);\n+      break;\n \n-      case 5:\n-\tpat = GEN_FCN (icode) (op[0], op[1], op[2], op[3], op[4]);\n-\tbreak;\n+    case 6:\n+      pat = GEN_FCN (icode) (op[0], op[1], op[2], op[3], op[4], op[5]);\n+      break;\n \n-      default:\n-\tgcc_unreachable ();\n-      }\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   if (!pat)\n     return NULL_RTX;"}]}