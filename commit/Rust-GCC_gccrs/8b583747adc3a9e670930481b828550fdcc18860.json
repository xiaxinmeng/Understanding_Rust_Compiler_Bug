{"sha": "8b583747adc3a9e670930481b828550fdcc18860", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI1ODM3NDdhZGMzYTllNjcwOTMwNDgxYjgyODU1MGZkY2MxODg2MA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2002-07-20T00:31:15Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2002-07-20T00:31:15Z"}, "message": "re PR rtl-optimization/7130 (miscompiled code for gcc-3.1 on powerpc-unknown-linux-gnu with -funroll-all-loops)\n\n\tPR optimization/7130\n\t* loop.h (struct loop_info): Add \"preconditioned\".\n\t* unroll.c (unroll_loop): Set it.\n\t* doloop.c (doloop_modify_runtime): Correct count for unrolled loops.\n\nFrom-SVN: r55598", "tree": {"sha": "94eedd6796f702b3e750b75344a9180da4a76c79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94eedd6796f702b3e750b75344a9180da4a76c79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b583747adc3a9e670930481b828550fdcc18860", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b583747adc3a9e670930481b828550fdcc18860", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b583747adc3a9e670930481b828550fdcc18860", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b583747adc3a9e670930481b828550fdcc18860/comments", "author": null, "committer": null, "parents": [{"sha": "0dc36574afc7846defc8751c3e19e4c994e0de4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dc36574afc7846defc8751c3e19e4c994e0de4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dc36574afc7846defc8751c3e19e4c994e0de4a"}], "stats": {"total": 43, "additions": 32, "deletions": 11}, "files": [{"sha": "8fd107b810741389c0e8ef9955744826f745560d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b583747adc3a9e670930481b828550fdcc18860/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b583747adc3a9e670930481b828550fdcc18860/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b583747adc3a9e670930481b828550fdcc18860", "patch": "@@ -1,3 +1,10 @@\n+2002-07-20  Alan Modra  <amodra@bigpond.net.au>\n+\n+\tPR optimization/7130\n+\t* loop.h (struct loop_info): Add \"preconditioned\".\n+\t* unroll.c (unroll_loop): Set it.\n+\t* doloop.c (doloop_modify_runtime): Correct count for unrolled loops.\n+\n 2002-07-19  Zack Weinberg  <zack@codesourcery.com>\n \n \t* rtl.def (CODE_LABEL): Remove slot 8."}, {"sha": "9bddb92ed23d11c4efb0fa369b561aff0662149a", "filename": "gcc/doloop.c", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b583747adc3a9e670930481b828550fdcc18860/gcc%2Fdoloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b583747adc3a9e670930481b828550fdcc18860/gcc%2Fdoloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoloop.c?ref=8b583747adc3a9e670930481b828550fdcc18860", "patch": "@@ -552,6 +552,7 @@ doloop_modify_runtime (loop, iterations_max,\n {\n   const struct loop_info *loop_info = LOOP_INFO (loop);\n   HOST_WIDE_INT abs_inc;\n+  HOST_WIDE_INT abs_loop_inc;\n   int neg_inc;\n   rtx diff;\n   rtx sequence;\n@@ -595,13 +596,18 @@ doloop_modify_runtime (loop, iterations_max,\n      except in cases where the loop never terminates.  So we don't\n      need to use this more costly calculation.\n \n-     If the loop has been unrolled, then the loop body has been\n-     preconditioned to iterate a multiple of unroll_number times.  If\n-     abs_inc is != 1, the full calculation is\n+     If the loop has been unrolled, the full calculation is\n \n-       t1 = abs_inc * unroll_number;\n-       n = abs (final - initial) / t1;\n-       n += (abs (final - initial) % t1) > t1 - abs_inc;\n+       t1 = abs_inc * unroll_number;\t\tincrement per loop\n+       n = abs (final - initial) / t1;\t\tfull loops\n+       n += (abs (final - initial) % t1) != 0;\tpartial loop\n+\n+     However, in certain cases the unrolled loop will be preconditioned\n+     by emitting copies of the loop body with conditional branches,\n+     so that the unrolled loop is always a full loop and thus needs\n+     no exit tests.  In this case we don't want to add the partial\n+     loop count.  As above, when t1 is a power of two we don't need to\n+     worry about overflow.\n \n      The division and modulo operations can be avoided by requiring\n      that the increment is a power of 2 (precondition_loop_p enforces\n@@ -667,20 +673,22 @@ doloop_modify_runtime (loop, iterations_max,\n \t}\n     }\n \n-  if (abs_inc * loop_info->unroll_number != 1)\n+  abs_loop_inc = abs_inc * loop_info->unroll_number;\n+  if (abs_loop_inc != 1)\n     {\n       int shift_count;\n \n-      shift_count = exact_log2 (abs_inc * loop_info->unroll_number);\n+      shift_count = exact_log2 (abs_loop_inc);\n       if (shift_count < 0)\n \tabort ();\n \n-      if (abs_inc != 1)\n+      if (!loop_info->preconditioned)\n \tdiff = expand_simple_binop (GET_MODE (diff), PLUS,\n-\t\t\t\t    diff, GEN_INT (abs_inc - 1),\n+\t\t\t\t    diff, GEN_INT (abs_loop_inc - 1),\n \t\t\t\t    diff, 1, OPTAB_LIB_WIDEN);\n \n-      /* (abs (final - initial) + abs_inc - 1) / (abs_inc * unroll_number)  */\n+      /* (abs (final - initial) + abs_inc * unroll_number - 1)\n+\t / (abs_inc * unroll_number)  */\n       diff = expand_simple_binop (GET_MODE (diff), LSHIFTRT,\n \t\t\t\t  diff, GEN_INT (shift_count),\n \t\t\t\t  diff, 1, OPTAB_LIB_WIDEN);"}, {"sha": "631352fee6d23861b3642e57c18ea713e84d9c7a", "filename": "gcc/loop.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b583747adc3a9e670930481b828550fdcc18860/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b583747adc3a9e670930481b828550fdcc18860/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=8b583747adc3a9e670930481b828550fdcc18860", "patch": "@@ -316,6 +316,9 @@ struct loop_info\n   int has_multiple_exit_targets;\n   /* Nonzero if there is an indirect jump in the current function.  */\n   int has_indirect_jump;\n+  /* Whether loop unrolling has emitted copies of the loop body so\n+     that the main loop needs no exit tests.  */\n+  int preconditioned;\n   /* Register or constant initial loop value.  */\n   rtx initial_value;\n   /* Register or constant value used for comparison test.  */"}, {"sha": "c8201ed6336361b153f76f80a250b61efc89ef5d", "filename": "gcc/unroll.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b583747adc3a9e670930481b828550fdcc18860/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b583747adc3a9e670930481b828550fdcc18860/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=8b583747adc3a9e670930481b828550fdcc18860", "patch": "@@ -1135,6 +1135,9 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n   /* Keep track of the unroll factor for the loop.  */\n   loop_info->unroll_number = unroll_number;\n \n+  /* And whether the loop has been preconditioned.  */\n+  loop_info->preconditioned = loop_preconditioned;\n+\n   /* For each biv and giv, determine whether it can be safely split into\n      a different variable for each unrolled copy of the loop body.\n      We precalculate and save this info here, since computing it is"}]}