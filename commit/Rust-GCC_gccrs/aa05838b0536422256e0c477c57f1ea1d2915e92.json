{"sha": "aa05838b0536422256e0c477c57f1ea1d2915e92", "node_id": "C_kwDOANBUbNoAKGFhMDU4MzhiMDUzNjQyMjI1NmUwYzQ3N2M1N2YxZWExZDI5MTVlOTI", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-10-07T16:55:32Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-10-13T15:28:47Z"}, "message": "Add equivalence iterator to relation oracle.\n\nInstead of looping over an exposed equivalence bitmap, provide iterators\nto loop over equivalences, partial equivalences, or both.\n\n\t* gimple-range-cache.cc (ranger_cache::fill_block_cache): Use\n\titerator.\n\t* value-relation.cc\n\t  (equiv_relation_iterator::equiv_relation_iterator): New.\n\t(equiv_relation_iterator::next): New.\n\t(equiv_relation_iterator::get_name): New.\n\t* value-relation.h (class relation_oracle): Privatize some methods.\n\t(class equiv_relation_iterator): New.\n\t(FOR_EACH_EQUIVALENCE): New.\n\t(FOR_EACH_PARTIAL_EQUIV): New.\n\t(FOR_EACH_PARTIAL_AND_FULL_EQUIV): New.", "tree": {"sha": "01f8fed672546f602e1e5db683ef1d1e00b7febe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01f8fed672546f602e1e5db683ef1d1e00b7febe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa05838b0536422256e0c477c57f1ea1d2915e92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa05838b0536422256e0c477c57f1ea1d2915e92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa05838b0536422256e0c477c57f1ea1d2915e92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa05838b0536422256e0c477c57f1ea1d2915e92/comments", "author": null, "committer": null, "parents": [{"sha": "b5563410ea613ff2b2d7c6fa1847cfcb1ff91efb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5563410ea613ff2b2d7c6fa1847cfcb1ff91efb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5563410ea613ff2b2d7c6fa1847cfcb1ff91efb"}], "stats": {"total": 129, "additions": 118, "deletions": 11}, "files": [{"sha": "8c80ba6cd1421a7b001c056ddfa0fb458f27879c", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa05838b0536422256e0c477c57f1ea1d2915e92/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa05838b0536422256e0c477c57f1ea1d2915e92/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=aa05838b0536422256e0c477c57f1ea1d2915e92", "patch": "@@ -1220,15 +1220,9 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n       // See if any equivalences can refine it.\n       if (m_oracle)\n \t{\n-\t  unsigned i;\n-\t  bitmap_iterator bi;\n-\t  // Query equivalences in read-only mode.\n-\t  const_bitmap equiv = m_oracle->equiv_set (name, bb);\n-\t  EXECUTE_IF_SET_IN_BITMAP (equiv, 0, i, bi)\n+\t  tree equiv_name;\n+\t  FOR_EACH_EQUIVALENCE (m_oracle, bb, name, equiv_name)\n \t    {\n-\t      if (i == SSA_NAME_VERSION (name))\n-\t\tcontinue;\n-\t      tree equiv_name = ssa_name (i);\n \t      basic_block equiv_bb = gimple_bb (SSA_NAME_DEF_STMT (equiv_name));\n \n \t      // Check if the equiv has any ranges calculated."}, {"sha": "50fc190a36b23abb6e204007c758d8fd6fa444c5", "filename": "gcc/value-relation.cc", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa05838b0536422256e0c477c57f1ea1d2915e92/gcc%2Fvalue-relation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa05838b0536422256e0c477c57f1ea1d2915e92/gcc%2Fvalue-relation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.cc?ref=aa05838b0536422256e0c477c57f1ea1d2915e92", "patch": "@@ -1641,3 +1641,81 @@ path_oracle::dump (FILE *f) const\n       fprintf (f, \"\\n\");\n     }\n }\n+\n+// ------------------------------------------------------------------------\n+//  EQUIV iterator.  Although we have bitmap iterators, don't expose that it\n+//  is currently a bitmap.  Use an export iterator to hide future changes.\n+\n+// Construct a basic iterator over an equivalence bitmap.\n+\n+equiv_relation_iterator::equiv_relation_iterator (relation_oracle *oracle,\n+\t\t\t\t\t\t  basic_block bb, tree name,\n+\t\t\t\t\t\t  bool full, bool partial)\n+{\n+  m_name = name;\n+  m_oracle = oracle;\n+  m_pe = partial ? oracle->partial_equiv_set (name) : NULL;\n+  m_bm = NULL;\n+  if (full)\n+    m_bm = oracle->equiv_set (name, bb);\n+  if (!m_bm && m_pe)\n+    m_bm = m_pe->members;\n+  if (m_bm)\n+    bmp_iter_set_init (&m_bi, m_bm, 1, &m_y);\n+}\n+\n+// Move to the next export bitmap spot.\n+\n+void\n+equiv_relation_iterator::next ()\n+{\n+  bmp_iter_next (&m_bi, &m_y);\n+}\n+\n+// Fetch the name of the next export in the export list.  Return NULL if\n+// iteration is done.\n+\n+tree\n+equiv_relation_iterator::get_name (relation_kind *rel)\n+{\n+  if (!m_bm)\n+    return NULL_TREE;\n+\n+  while (bmp_iter_set (&m_bi, &m_y))\n+    {\n+      // Do not return self.\n+      tree t = ssa_name (m_y);\n+      if (t && t != m_name)\n+\t{\n+\t  relation_kind k = VREL_EQ;\n+\t  if (m_pe && m_bm == m_pe->members)\n+\t    {\n+\t      const pe_slice *equiv_pe = m_oracle->partial_equiv_set (t);\n+\t      if (equiv_pe && equiv_pe->members == m_pe->members)\n+\t\tk = pe_min (m_pe->code, equiv_pe->code);\n+\t      else\n+\t\tk = VREL_VARYING;\n+\t    }\n+\t  if (relation_equiv_p (k))\n+\t    {\n+\t      if (rel)\n+\t\t*rel = k;\n+\t      return t;\n+\t    }\n+\t}\n+      next ();\n+    }\n+\n+  // Process partial equivs after full equivs if both were requested.\n+  if (m_pe && m_bm != m_pe->members)\n+    {\n+      m_bm = m_pe->members;\n+      if (m_bm)\n+\t{\n+\t  // Recursively call back to process First PE.\n+\t  bmp_iter_set_init (&m_bi, m_bm, 1, &m_y);\n+\t  return get_name (rel);\n+\t}\n+    }\n+  return NULL_TREE;\n+}"}, {"sha": "a3bbe1e8157b8af4f6fe560bab7fcb1242ff9895", "filename": "gcc/value-relation.h", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa05838b0536422256e0c477c57f1ea1d2915e92/gcc%2Fvalue-relation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa05838b0536422256e0c477c57f1ea1d2915e92/gcc%2Fvalue-relation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.h?ref=aa05838b0536422256e0c477c57f1ea1d2915e92", "patch": "@@ -100,9 +100,6 @@ class relation_oracle\n   // register a relation between 2 ssa names on an edge.\n   void register_edge (edge, relation_kind, tree, tree);\n \n-  // Return equivalency set for an SSA name in a basic block.\n-  virtual const_bitmap equiv_set (tree, basic_block) = 0;\n-  virtual const class pe_slice *partial_equiv_set (tree) { return NULL; }\n   // register a relation between 2 ssa names in a basic block.\n   virtual void register_relation (basic_block, relation_kind, tree, tree) = 0;\n   // Query for a relation between two ssa names in a basic block.\n@@ -115,6 +112,11 @@ class relation_oracle\n   virtual void dump (FILE *) const = 0;\n   void debug () const;\n protected:\n+  friend class equiv_relation_iterator;\n+  // Return equivalency set for an SSA name in a basic block.\n+  virtual const_bitmap equiv_set (tree, basic_block) = 0;\n+  // Return partial equivalency record for an SSA name.\n+  virtual const class pe_slice *partial_equiv_set (tree) { return NULL; }\n   void valid_equivs (bitmap b, const_bitmap equivs, basic_block bb);\n   // Query for a relation between two equivalency sets in a basic block.\n   virtual relation_kind query_relation (basic_block, const_bitmap,\n@@ -281,6 +283,39 @@ class path_oracle : public relation_oracle\n   struct obstack m_chain_obstack;\n };\n \n+// Used to assist with iterating over the equivalence list.\n+class equiv_relation_iterator {\n+public:\n+  equiv_relation_iterator (relation_oracle *oracle, basic_block bb, tree name,\n+\t\t\t   bool full = true, bool partial = false);\n+  void next ();\n+  tree get_name (relation_kind *rel = NULL);\n+protected:\n+  relation_oracle *m_oracle;\n+  const_bitmap m_bm;\n+  const pe_slice *m_pe;\n+  bitmap_iterator m_bi;\n+  unsigned m_y;\n+  tree m_name;\n+};\n+\n+#define FOR_EACH_EQUIVALENCE(oracle, bb, name, equiv_name)\t\t\\\n+  for (equiv_relation_iterator iter (oracle, bb, name, true, false);\t\\\n+       ((equiv_name) = iter.get_name ());\t\t\t\t\\\n+       iter.next ())\n+\n+#define FOR_EACH_PARTIAL_EQUIV(oracle, bb, name, equiv_name, equiv_rel)\t\\\n+  for (equiv_relation_iterator iter (oracle, bb, name, false, true);\t\\\n+       ((equiv_name) = iter.get_name (&equiv_rel));\t\t\t\\\n+       iter.next ())\n+\n+#define FOR_EACH_PARTIAL_AND_FULL_EQUIV(oracle, bb, name, equiv_name, \t\\\n+\t\t\t\t\t\t      equiv_rel)\t\\\n+  for (equiv_relation_iterator iter (oracle, bb, name, true, true);\t\\\n+       ((equiv_name) = iter.get_name (&equiv_rel));\t\t\t\\\n+       iter.next ())\n+\n+\n // The value-relation class is used to encapsulate the represention of an\n // individual relation between 2 ssa-names, and to facilitate operating on\n // the relation."}]}