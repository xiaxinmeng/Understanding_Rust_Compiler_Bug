{"sha": "b1e7c6fce15b8ad222f265df2537701407fd289e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFlN2M2ZmNlMTViOGFkMjIyZjI2NWRmMjUzNzcwMTQwN2ZkMjg5ZQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-10-22T17:42:03Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-10-22T17:42:03Z"}, "message": "libstdc++: Reduce header dependencies in and on <memory>\n\nBy moving std::make_obj_using_allocator and the related \"utility\nfunctions for uses-allocator construction\" to a new header, we can avoid\nincluding the whole of <memory> in <scoped_allocator> and\n<memory_resource>.\n\nIn order to simplify the implementation of those utility functions they\nnow use concepts unconditionally. They are no longer defined if\n__cpp_concepts is not defined. To simplify the code that uses those\nfunctions I've introduced a __cpp_lib_make_obj_using_allocator feature\ntest macro (not specified in the standard, which might be an oversight).\nThat allows the code in <memory_resource> and <scoped_allocator> to\ncheck the feature test macro to decide whether to use the new utilities,\nor fall back to the C++17 code.\n\nAt the same time, this reshuffles some of the headers included by\n<memory> so that they are (mostly?) self-contained. It should no longer\nbe necessary to include other headers before <bits/shared_ptr.h> when\nother parts of the library want to use std::shared_ptr without including\nthe whole of <memory>.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/Makefile.am: Add new header.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/shared_ptr.h: Include <iosfwd>.\n\t* include/bits/shared_ptr_base.h: Include required headers here\n\tdirectly, instead of in <memory>.\n\t* include/bits/uses_allocator_args.h: New file. Move utility\n\tfunctions for uses-allocator construction from <memory> to here.\n\tOnly define the utility functions when concepts are available.\n\t(__cpp_lib_make_obj_using_allocator): Define non-standard\n\tfeature test macro.\n\t* include/std/condition_variable: Remove unused headers.\n\t* include/std/future: Likewise.\n\t* include/std/memory: Remove headers that are not needed\n\tdirectly, and are now inclkuded where they're needed. Include\n\tnew <bits/uses_allocator_args.h> header.\n\t* include/std/memory_resource: Include only the necessary\n\theaders. Use new feature test macro to detect support for the\n\tutility functions.\n\t* include/std/scoped_allocator: Likewise.\n\t* include/std/version (__cpp_lib_make_obj_using_allocator):\n\tDefine.", "tree": {"sha": "bc07e74fd4675e1cd057e0dc7eaa2112cf2214e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc07e74fd4675e1cd057e0dc7eaa2112cf2214e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1e7c6fce15b8ad222f265df2537701407fd289e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1e7c6fce15b8ad222f265df2537701407fd289e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1e7c6fce15b8ad222f265df2537701407fd289e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1e7c6fce15b8ad222f265df2537701407fd289e/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d667beea36ba90bd47f1dd5f4a92a8d43a8ff207", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d667beea36ba90bd47f1dd5f4a92a8d43a8ff207", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d667beea36ba90bd47f1dd5f4a92a8d43a8ff207"}], "stats": {"total": 520, "additions": 278, "deletions": 242}, "files": [{"sha": "c90ac555e153e4bce4f91cd14448c30e89d38388", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=b1e7c6fce15b8ad222f265df2537701407fd289e", "patch": "@@ -222,6 +222,7 @@ bits_headers = \\\n \t${bits_srcdir}/unordered_map.h \\\n \t${bits_srcdir}/unordered_set.h \\\n \t${bits_srcdir}/uses_allocator.h \\\n+\t${bits_srcdir}/uses_allocator_args.h \\\n \t${bits_srcdir}/valarray_array.h \\\n \t${bits_srcdir}/valarray_array.tcc \\\n \t${bits_srcdir}/valarray_before.h \\"}, {"sha": "aa751f62c4fe01da17bfe6bd3fd434ec920e7898", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=b1e7c6fce15b8ad222f265df2537701407fd289e", "patch": "@@ -568,6 +568,7 @@ bits_headers = \\\n \t${bits_srcdir}/unordered_map.h \\\n \t${bits_srcdir}/unordered_set.h \\\n \t${bits_srcdir}/uses_allocator.h \\\n+\t${bits_srcdir}/uses_allocator_args.h \\\n \t${bits_srcdir}/valarray_array.h \\\n \t${bits_srcdir}/valarray_array.tcc \\\n \t${bits_srcdir}/valarray_before.h \\"}, {"sha": "92394c6a9e6fbaf99092c450e4ec0f2d0a549e6a", "filename": "libstdc++-v3/include/bits/shared_ptr.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h?ref=b1e7c6fce15b8ad222f265df2537701407fd289e", "patch": "@@ -49,6 +49,7 @@\n #ifndef _SHARED_PTR_H\n #define _SHARED_PTR_H 1\n \n+#include <iosfwd>           \t  // std::basic_ostream\n #include <bits/shared_ptr_base.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)"}, {"sha": "a9e1c9bb1d5a2a70640cd494409a1c4f8486e0c2", "filename": "libstdc++-v3/include/bits/shared_ptr_base.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h?ref=b1e7c6fce15b8ad222f265df2537701407fd289e", "patch": "@@ -51,9 +51,15 @@\n \n #include <typeinfo>\n #include <bits/allocated_ptr.h>\n+#include <bits/allocator.h>\n+#include <bits/exception_defines.h>\n+#include <bits/functional_hash.h>\n #include <bits/refwrap.h>\n-#include <bits/stl_function.h>\n+#include <bits/stl_function.h>  // std::less\n+#include <bits/unique_ptr.h>\n #include <ext/aligned_buffer.h>\n+#include <ext/atomicity.h>\n+#include <ext/concurrence.h>\n #if __cplusplus > 201703L\n # include <compare>\n #endif"}, {"sha": "2f10c8b174520f77c86f8ef66d7c4955423e95b6", "filename": "libstdc++-v3/include/bits/uses_allocator_args.h", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fuses_allocator_args.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fuses_allocator_args.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fuses_allocator_args.h?ref=b1e7c6fce15b8ad222f265df2537701407fd289e", "patch": "@@ -0,0 +1,227 @@\n+// Utility functions for uses-allocator construction -*- C++ -*-\n+\n+// Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/*\n+ * Copyright (c) 1997-1999\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+/** @file include/bits/uses_allocator_args.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{memory}\n+ */\n+\n+#ifndef _USES_ALLOCATOR_ARGS\n+#define _USES_ALLOCATOR_ARGS 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus > 201703L && __cpp_concepts\n+\n+#include <new>\t\t\t// for placement operator new\n+#include <tuple>\t\t// for tuple, make_tuple, make_from_tuple\n+#include <bits/stl_construct.h> // construct_at\n+#include <bits/stl_pair.h>      // pair\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  template<typename _Tp>\n+    inline constexpr bool __is_pair = false;\n+  template<typename _Tp, typename _Up>\n+    inline constexpr bool __is_pair<pair<_Tp, _Up>> = true;\n+  template<typename _Tp, typename _Up>\n+    inline constexpr bool __is_pair<const pair<_Tp, _Up>> = true;\n+\n+  template<typename _Tp>\n+    concept _Std_pair = __is_pair<_Tp>;\n+\n+/** @addtogroup allocators\n+ *  @{\n+ */\n+\n+// Not specified by C++20, used internally\n+#define __cpp_lib_make_obj_using_allocator 201811L\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc& __a,\n+\t\t\t\t     _Args&&... __args) noexcept\n+    requires (! _Std_pair<_Tp>)\n+    {\n+      if constexpr (uses_allocator_v<remove_cv_t<_Tp>, _Alloc>)\n+\t{\n+\t  if constexpr (is_constructible_v<_Tp, allocator_arg_t,\n+\t\t\t\t\t   const _Alloc&, _Args...>)\n+\t    {\n+\t      return tuple<allocator_arg_t, const _Alloc&, _Args&&...>(\n+\t\t  allocator_arg, __a, std::forward<_Args>(__args)...);\n+\t    }\n+\t  else\n+\t    {\n+\t      static_assert(is_constructible_v<_Tp, _Args..., const _Alloc&>,\n+\t\t  \"construction with an allocator must be possible\"\n+\t\t  \" if uses_allocator is true\");\n+\n+\t      return tuple<_Args&&..., const _Alloc&>(\n+\t\t  std::forward<_Args>(__args)..., __a);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  static_assert(is_constructible_v<_Tp, _Args...>);\n+\n+\t  return tuple<_Args&&...>(std::forward<_Args>(__args)...);\n+\t}\n+    }\n+\n+  template<_Std_pair _Tp, typename _Alloc, typename _Tuple1, typename _Tuple2>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc& __a, piecewise_construct_t,\n+\t\t\t\t     _Tuple1&& __x, _Tuple2&& __y) noexcept;\n+\n+  template<_Std_pair _Tp, typename _Alloc>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc&) noexcept;\n+\n+  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc&, _Up&&, _Vp&&) noexcept;\n+\n+  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc&,\n+\t\t\t\t     const pair<_Up, _Vp>&) noexcept;\n+\n+  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc&, pair<_Up, _Vp>&&) noexcept;\n+\n+  template<_Std_pair _Tp, typename _Alloc, typename _Tuple1, typename _Tuple2>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc& __a, piecewise_construct_t,\n+\t\t\t\t     _Tuple1&& __x, _Tuple2&& __y) noexcept\n+    {\n+      using _Tp1 = typename _Tp::first_type;\n+      using _Tp2 = typename _Tp::second_type;\n+\n+      return std::make_tuple(piecewise_construct,\n+\t  std::apply([&__a](auto&&... __args1) {\n+\t      return std::uses_allocator_construction_args<_Tp1>(\n+\t\t  __a, std::forward<decltype(__args1)>(__args1)...);\n+\t  }, std::forward<_Tuple1>(__x)),\n+\t  std::apply([&__a](auto&&... __args2) {\n+\t      return std::uses_allocator_construction_args<_Tp2>(\n+\t\t  __a, std::forward<decltype(__args2)>(__args2)...);\n+\t  }, std::forward<_Tuple2>(__y)));\n+    }\n+\n+  template<_Std_pair _Tp, typename _Alloc>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc& __a) noexcept\n+    {\n+      using _Tp1 = typename _Tp::first_type;\n+      using _Tp2 = typename _Tp::second_type;\n+\n+      return std::make_tuple(piecewise_construct,\n+\t  std::uses_allocator_construction_args<_Tp1>(__a),\n+\t  std::uses_allocator_construction_args<_Tp2>(__a));\n+    }\n+\n+  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc& __a, _Up&& __u, _Vp&& __v)\n+      noexcept\n+    {\n+      using _Tp1 = typename _Tp::first_type;\n+      using _Tp2 = typename _Tp::second_type;\n+\n+      return std::make_tuple(piecewise_construct,\n+\t  std::uses_allocator_construction_args<_Tp1>(__a,\n+\t    std::forward<_Up>(__u)),\n+\t  std::uses_allocator_construction_args<_Tp2>(__a,\n+\t    std::forward<_Vp>(__v)));\n+    }\n+\n+  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc& __a,\n+\t\t\t\t     const pair<_Up, _Vp>& __pr) noexcept\n+    {\n+      using _Tp1 = typename _Tp::first_type;\n+      using _Tp2 = typename _Tp::second_type;\n+\n+      return std::make_tuple(piecewise_construct,\n+\t  std::uses_allocator_construction_args<_Tp1>(__a, __pr.first),\n+\t  std::uses_allocator_construction_args<_Tp2>(__a, __pr.second));\n+    }\n+\n+  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc& __a,\n+\t\t\t\t     pair<_Up, _Vp>&& __pr) noexcept\n+    {\n+      using _Tp1 = typename _Tp::first_type;\n+      using _Tp2 = typename _Tp::second_type;\n+\n+      return std::make_tuple(piecewise_construct,\n+\t  std::uses_allocator_construction_args<_Tp1>(__a,\n+\t    std::move(__pr).first),\n+\t  std::uses_allocator_construction_args<_Tp2>(__a,\n+\t    std::move(__pr).second));\n+    }\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    inline _Tp\n+    make_obj_using_allocator(const _Alloc& __a, _Args&&... __args)\n+    {\n+      return std::make_from_tuple<_Tp>(\n+\t  std::uses_allocator_construction_args<_Tp>(__a,\n+\t    std::forward<_Args>(__args)...));\n+    }\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    inline _Tp*\n+    uninitialized_construct_using_allocator(_Tp* __p, const _Alloc& __a,\n+\t\t\t\t\t    _Args&&... __args)\n+    {\n+      return std::apply([&](auto&&... __xs) {\n+\treturn std::construct_at(__p, std::forward<decltype(__xs)>(__xs)...);\n+      }, std::uses_allocator_construction_args<_Tp>(__a,\n+\tstd::forward<_Args>(__args)...));\n+    }\n+// @}\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+#endif // C++20\n+#endif // _USES_ALLOCATOR_ARGS"}, {"sha": "7406fde6e4b40c8f8bf9e7c4d6dc4a99a8c941df", "filename": "libstdc++-v3/include/std/condition_variable", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable?ref=b1e7c6fce15b8ad222f265df2537701407fd289e", "patch": "@@ -39,10 +39,7 @@\n \n #include <bits/std_mutex.h>\n #include <bits/unique_lock.h>\n-#include <ext/concurrence.h>\n #include <bits/alloc_traits.h>\n-#include <bits/allocator.h>\n-#include <bits/unique_ptr.h>\n #include <bits/shared_ptr.h>\n #include <bits/cxxabi_forced.h>\n "}, {"sha": "3c2aaa1fab1994fd672377d96472b1094bda7fba", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=b1e7c6fce15b8ad222f265df2537701407fd289e", "patch": "@@ -35,19 +35,18 @@\n # include <bits/c++0x_warning.h>\n #else\n \n-#include <mutex>\n+#include <mutex>\t      // call_once\n #include <thread>\n-#include <condition_variable>\n+#include <condition_variable> // __at_thread_exit_elt\n #include <system_error>\n #include <atomic>\n+#include <bits/allocated_ptr.h>\n #include <bits/atomic_futex.h>\n-#include <bits/functexcept.h>\n #include <bits/invoke.h>\n #include <bits/unique_ptr.h>\n #include <bits/shared_ptr.h>\n #include <bits/std_function.h>\n #include <bits/uses_allocator.h>\n-#include <bits/allocated_ptr.h>\n #include <ext/aligned_buffer.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)"}, {"sha": "41ba74dd36f5879ac7707bebcef61530161f9b2c", "filename": "libstdc++-v3/include/std/memory", "status": "modified", "additions": 9, "deletions": 218, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory?ref=b1e7c6fce15b8ad222f265df2537701407fd289e", "patch": "@@ -66,38 +66,28 @@\n #include <bits/stl_uninitialized.h>\n #include <bits/stl_tempbuf.h>\n #include <bits/stl_raw_storage_iter.h>\n-#include <bits/ranges_uninitialized.h>\n \n #if __cplusplus >= 201103L\n-#  include <exception>        \t  // std::exception\n-#  include <typeinfo>         \t  // std::type_info in get_deleter\n-#  include <iosfwd>           \t  // std::basic_ostream\n-#  include <ext/atomicity.h>\n-#  include <ext/concurrence.h>\n+#  include <type_traits>\n #  include <bits/align.h>\n-#  include <bits/functexcept.h>\n-#  include <bits/stl_function.h>  // std::less\n #  include <bits/uses_allocator.h>\n #  include <bits/alloc_traits.h>\n-#  include <type_traits>\n #  include <debug/debug.h>\n #  include <bits/unique_ptr.h>\n #  include <bits/shared_ptr.h>\n #  include <bits/shared_ptr_atomic.h>\n-#  if _GLIBCXX_USE_DEPRECATED\n-#    include <backward/auto_ptr.h>\n-#  endif\n-#else\n+#endif\n+\n+#if __cplusplus < 201103L || _GLIBCXX_USE_DEPRECATED\n #  include <backward/auto_ptr.h>\n #endif\n \n-#if __cplusplus >= 201103L\n-#include <cstdint>\n #if __cplusplus > 201703L\n-# include <bit>\t\t\t// for has_single_bit\n-# include <new>\t\t\t// for placement operator new\n-# include <tuple>\t\t// for tuple, make_tuple, make_from_tuple\n+#  include <bits/ranges_uninitialized.h>\n+#  include <bits/uses_allocator_args.h>\n #endif\n+\n+#if __cplusplus >= 201103L\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -140,210 +130,11 @@ inline pointer_safety\n get_pointer_safety() noexcept { return pointer_safety::relaxed; }\n // @}\n \n-#if __cplusplus > 201703L\n-  template<typename _Tp>\n-    struct __is_pair : false_type { };\n-  template<typename _Tp, typename _Up>\n-    struct __is_pair<pair<_Tp, _Up>> : true_type { };\n-  template<typename _Tp, typename _Up>\n-    struct __is_pair<const pair<_Tp, _Up>> : true_type { };\n-\n-/** @addtogroup allocators\n- *  @{\n- */\n-  template<typename _Tp, typename __ = _Require<__not_<__is_pair<_Tp>>>,\n-\t   typename _Alloc, typename... _Args>\n-    constexpr auto\n-    __uses_alloc_args(const _Alloc& __a, _Args&&... __args) noexcept\n-    {\n-      if constexpr (uses_allocator_v<remove_cv_t<_Tp>, _Alloc>)\n-\t{\n-\t  if constexpr (is_constructible_v<_Tp, allocator_arg_t,\n-\t\t\t\t\t   const _Alloc&, _Args...>)\n-\t    {\n-\t      return tuple<allocator_arg_t, const _Alloc&, _Args&&...>(\n-\t\t  allocator_arg, __a, std::forward<_Args>(__args)...);\n-\t    }\n-\t  else\n-\t    {\n-\t      static_assert(is_constructible_v<_Tp, _Args..., const _Alloc&>,\n-\t\t  \"construction with an allocator must be possible\"\n-\t\t  \" if uses_allocator is true\");\n-\n-\t      return tuple<_Args&&..., const _Alloc&>(\n-\t\t  std::forward<_Args>(__args)..., __a);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  static_assert(is_constructible_v<_Tp, _Args...>);\n-\n-\t  return tuple<_Args&&...>(std::forward<_Args>(__args)...);\n-\t}\n-    }\n-\n-#if __cpp_concepts\n-  template<typename _Tp>\n-    concept _Std_pair = __is_pair<_Tp>::value;\n-#endif\n-\n-// This is a temporary workaround until -fconcepts is implied by -std=gnu++2a\n-#if __cpp_concepts\n-# define _GLIBCXX_STD_PAIR_CONSTRAINT(T) _Std_pair T\n-# define _GLIBCXX_STD_PAIR_CONSTRAINT_(T) _Std_pair T\n-#else\n-# define _GLIBCXX_STD_PAIR_CONSTRAINT(T) \\\n-      typename T, typename __ = _Require<__is_pair<T>>\n-# define _GLIBCXX_STD_PAIR_CONSTRAINT_(T) typename T, typename\n-#endif\n-\n-  template<typename _Tp,\n-#if ! __cpp_concepts\n-\t   typename __ = _Require<__not_<__is_pair<_Tp>>>,\n-#endif\n-\t   typename _Alloc, typename... _Args>\n-    constexpr auto\n-    uses_allocator_construction_args(const _Alloc& __a,\n-\t\t\t\t     _Args&&... __args) noexcept\n-#if __cpp_concepts\n-    requires (! _Std_pair<_Tp>)\n-#endif\n-    {\n-      return std::__uses_alloc_args<_Tp>(__a, std::forward<_Args>(__args)...);\n-    }\n-\n-  template<_GLIBCXX_STD_PAIR_CONSTRAINT(_Tp), typename _Alloc,\n-\t   typename _Tuple1, typename _Tuple2>\n-    constexpr auto\n-    uses_allocator_construction_args(const _Alloc& __a, piecewise_construct_t,\n-\t\t\t\t     _Tuple1&& __x, _Tuple2&& __y) noexcept;\n-\n-  template<_GLIBCXX_STD_PAIR_CONSTRAINT(_Tp), typename _Alloc>\n-    constexpr auto\n-    uses_allocator_construction_args(const _Alloc&) noexcept;\n-\n-  template<_GLIBCXX_STD_PAIR_CONSTRAINT(_Tp), typename _Alloc,\n-\t   typename _Up, typename _Vp>\n-    constexpr auto\n-    uses_allocator_construction_args(const _Alloc&, _Up&&, _Vp&&) noexcept;\n-\n-  template<_GLIBCXX_STD_PAIR_CONSTRAINT(_Tp), typename _Alloc,\n-\t   typename _Up, typename _Vp>\n-    constexpr auto\n-    uses_allocator_construction_args(const _Alloc&,\n-\t\t\t\t     const pair<_Up, _Vp>&) noexcept;\n-\n-  template<_GLIBCXX_STD_PAIR_CONSTRAINT(_Tp), typename _Alloc,\n-\t   typename _Up, typename _Vp>\n-    constexpr auto\n-    uses_allocator_construction_args(const _Alloc&, pair<_Up, _Vp>&&) noexcept;\n-\n-  template<_GLIBCXX_STD_PAIR_CONSTRAINT_(_Tp), typename _Alloc,\n-\t   typename _Tuple1, typename _Tuple2>\n-    constexpr auto\n-    uses_allocator_construction_args(const _Alloc& __a, piecewise_construct_t,\n-\t\t\t\t     _Tuple1&& __x, _Tuple2&& __y) noexcept\n-    {\n-      using _Tp1 = typename _Tp::first_type;\n-      using _Tp2 = typename _Tp::second_type;\n-\n-      return std::make_tuple(piecewise_construct,\n-\t  std::apply([&__a](auto&&... __args1) {\n-\t      return std::uses_allocator_construction_args<_Tp1>(\n-\t\t  __a, std::forward<decltype(__args1)>(__args1)...);\n-\t  }, std::forward<_Tuple1>(__x)),\n-\t  std::apply([&__a](auto&&... __args2) {\n-\t      return std::uses_allocator_construction_args<_Tp2>(\n-\t\t  __a, std::forward<decltype(__args2)>(__args2)...);\n-\t  }, std::forward<_Tuple2>(__y)));\n-    }\n-\n-  template<_GLIBCXX_STD_PAIR_CONSTRAINT_(_Tp), typename _Alloc>\n-    constexpr auto\n-    uses_allocator_construction_args(const _Alloc& __a) noexcept\n-    {\n-      using _Tp1 = typename _Tp::first_type;\n-      using _Tp2 = typename _Tp::second_type;\n-\n-      return std::make_tuple(piecewise_construct,\n-\t  std::uses_allocator_construction_args<_Tp1>(__a),\n-\t  std::uses_allocator_construction_args<_Tp2>(__a));\n-    }\n-\n-  template<_GLIBCXX_STD_PAIR_CONSTRAINT_(_Tp), typename _Alloc,\n-\t   typename _Up, typename _Vp>\n-    constexpr auto\n-    uses_allocator_construction_args(const _Alloc& __a, _Up&& __u, _Vp&& __v)\n-      noexcept\n-    {\n-      using _Tp1 = typename _Tp::first_type;\n-      using _Tp2 = typename _Tp::second_type;\n-\n-      return std::make_tuple(piecewise_construct,\n-\t  std::uses_allocator_construction_args<_Tp1>(__a,\n-\t    std::forward<_Up>(__u)),\n-\t  std::uses_allocator_construction_args<_Tp2>(__a,\n-\t    std::forward<_Vp>(__v)));\n-    }\n-\n-  template<_GLIBCXX_STD_PAIR_CONSTRAINT_(_Tp), typename _Alloc,\n-\t   typename _Up, typename _Vp>\n-    constexpr auto\n-    uses_allocator_construction_args(const _Alloc& __a,\n-\t\t\t\t     const pair<_Up, _Vp>& __pr) noexcept\n-    {\n-      using _Tp1 = typename _Tp::first_type;\n-      using _Tp2 = typename _Tp::second_type;\n-\n-      return std::make_tuple(piecewise_construct,\n-\t  std::uses_allocator_construction_args<_Tp1>(__a, __pr.first),\n-\t  std::uses_allocator_construction_args<_Tp2>(__a, __pr.second));\n-    }\n-\n-  template<_GLIBCXX_STD_PAIR_CONSTRAINT_(_Tp), typename _Alloc,\n-\t   typename _Up, typename _Vp>\n-    constexpr auto\n-    uses_allocator_construction_args(const _Alloc& __a,\n-\t\t\t\t     pair<_Up, _Vp>&& __pr) noexcept\n-    {\n-      using _Tp1 = typename _Tp::first_type;\n-      using _Tp2 = typename _Tp::second_type;\n-\n-      return std::make_tuple(piecewise_construct,\n-\t  std::uses_allocator_construction_args<_Tp1>(__a,\n-\t    std::move(__pr).first),\n-\t  std::uses_allocator_construction_args<_Tp2>(__a,\n-\t    std::move(__pr).second));\n-    }\n-\n-  template<typename _Tp, typename _Alloc, typename... _Args>\n-    inline _Tp\n-    make_obj_using_allocator(const _Alloc& __a, _Args&&... __args)\n-    {\n-      return std::make_from_tuple<_Tp>(\n-\t  std::uses_allocator_construction_args<_Tp>(__a,\n-\t    std::forward<_Args>(__args)...));\n-    }\n-\n-  template<typename _Tp, typename _Alloc, typename... _Args>\n-    inline _Tp*\n-    uninitialized_construct_using_allocator(_Tp* __p, const _Alloc& __a,\n-\t\t\t\t\t    _Args&&... __args)\n-    {\n-      return std::apply([&](auto&&... __xs) {\n-\treturn std::construct_at(__p, std::forward<decltype(__xs)>(__xs)...);\n-      }, std::uses_allocator_construction_args<_Tp>(__a,\n-\tstd::forward<_Args>(__args)...));\n-    }\n-// @}\n-\n-#endif // C++2a\n-\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n #endif // C++11\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n // Parallel STL algorithms\n # if _PSTL_EXECUTION_POLICIES_DEFINED\n // If <execution> has already been included, pull in implementations"}, {"sha": "350799ee3821386102cf3b9822c3d2bf5b01c162", "filename": "libstdc++-v3/include/std/memory_resource", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource?ref=b1e7c6fce15b8ad222f265df2537701407fd289e", "patch": "@@ -33,23 +33,28 @@\n \n #if __cplusplus >= 201703L\n \n-#include <memory>\t\t\t// align, allocator_arg_t, __uses_alloc\n-#include <utility>\t\t\t// pair, index_sequence\n #include <vector>\t\t\t// vector\n #include <cstddef>\t\t\t// size_t, max_align_t, byte\n #include <shared_mutex>\t\t\t// shared_mutex\n-#include <bits/functexcept.h>\n+#include <bits/align.h>\t\t\t// align\n+#include <bits/functexcept.h>\t\t// __throw_bad_array_new_length\n+#include <bits/uses_allocator.h>\t// __use_alloc\n+#include <bits/uses_allocator_args.h>\t// uninitialized_construct_using_alloc\n #include <ext/numeric_traits.h>\n #include <debug/assertions.h>\n \n+#if ! __cpp_lib_make_obj_using_allocator\n+# include <utility>\t\t\t// pair, index_sequence\n+#endif\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n namespace pmr\n {\n #ifdef _GLIBCXX_HAS_GTHREADS\n   // Header and all contents are present.\n-# define __cpp_lib_memory_resource 201603\n+# define __cpp_lib_memory_resource 201603L\n #else\n   // The pmr::synchronized_pool_resource type is missing.\n # define __cpp_lib_memory_resource 1\n@@ -231,7 +236,7 @@ namespace pmr\n \t}\n #endif // C++2a\n \n-#if __cplusplus == 201703L\n+#if ! __cpp_lib_make_obj_using_allocator\n       template<typename _Tp1, typename... _Args>\n \t__attribute__((__nonnull__))\n \ttypename __not_pair<_Tp1>::type\n@@ -304,7 +309,7 @@ namespace pmr\n \t\t\t  forward_as_tuple(std::forward<_Up>(__pr.first)),\n \t\t\t  forward_as_tuple(std::forward<_Vp>(__pr.second)));\n \t}\n-#else\n+#else // make_obj_using_allocator\n       template<typename _Tp1, typename... _Args>\n \t__attribute__((__nonnull__))\n \tvoid\n@@ -334,6 +339,7 @@ namespace pmr\n       using __uses_alloc1_ = __uses_alloc1<polymorphic_allocator>;\n       using __uses_alloc2_ = __uses_alloc2<polymorphic_allocator>;\n \n+#if ! __cpp_lib_make_obj_using_allocator\n       template<typename _Ind, typename... _Args>\n \tstatic tuple<_Args&&...>\n \t_S_construct_p(__uses_alloc0, _Ind, tuple<_Args...>& __t)\n@@ -354,6 +360,7 @@ namespace pmr\n \t_S_construct_p(__uses_alloc2_ __ua, index_sequence<_Ind...>,\n \t\t       tuple<_Args...>& __t)\n \t{ return { std::get<_Ind>(std::move(__t))..., *__ua._M_a }; }\n+#endif\n \n       memory_resource* _M_resource;\n     };"}, {"sha": "5f2fa5fac966aee4a72b0c290a8256e1e4c5acc4", "filename": "libstdc++-v3/include/std/scoped_allocator", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fscoped_allocator", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fscoped_allocator", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fscoped_allocator?ref=b1e7c6fce15b8ad222f265df2537701407fd289e", "patch": "@@ -36,10 +36,13 @@\n # include <bits/c++0x_warning.h>\n #else\n \n-#include <memory>\n-#include <utility>\n #include <tuple>\n #include <bits/alloc_traits.h>\n+#include <bits/stl_pair.h>\n+#include <bits/uses_allocator.h>\n+#if __cplusplus > 201703L\n+# include <bits/uses_allocator_args.h>\n+#endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -194,7 +197,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tusing __outermost_alloc_traits\n \t  = allocator_traits<typename __outermost_type<_Alloc>::type>;\n \n-#if __cplusplus <= 201703\n+#if ! __cpp_lib_make_obj_using_allocator\n       template<typename _Tp, typename... _Args>\n         void\n         _M_construct(__uses_alloc0, _Tp* __p, _Args&&... __args)\n@@ -226,7 +229,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t       std::forward<_Args>(__args)...,\n \t\t\t       inner_allocator());\n         }\n-#endif // C++17\n+#endif // ! make_obj_using_allocator\n \n       template<typename _Alloc>\n         static _Alloc\n@@ -364,7 +367,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       size_type max_size() const\n       { return __traits::max_size(outer_allocator()); }\n \n-#if __cplusplus <= 201703\n+#if ! __cpp_lib_make_obj_using_allocator\n       template<typename _Tp, typename... _Args>\n \ttypename __not_pair<_Tp>::type\n \tconstruct(_Tp* __p, _Args&&... __args)\n@@ -427,7 +430,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t    std::forward_as_tuple(std::forward<_Up>(__x.first)),\n \t\t    std::forward_as_tuple(std::forward<_Vp>(__x.second)));\n \t}\n-#else // C++2a\n+#else // make_obj_using_allocator\n       template<typename _Tp, typename... _Args>\n \t__attribute__((__nonnull__))\n \tvoid\n@@ -441,7 +444,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  uses_allocator_construction_args<_Tp>(inner_allocator(),\n \t    std::forward<_Args>(__args)...));\n \t}\n-#endif // C++2a\n+#endif\n \n       template<typename _Tp>\n         void destroy(_Tp* __p)\n@@ -464,7 +467,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                  const scoped_allocator_adaptor<_OutA2, _InA...>& __b) noexcept;\n \n     private:\n-#if __cplusplus <= 201703L\n+#if ! __cpp_lib_make_obj_using_allocator\n       template<typename _Ind, typename... _Args>\n \ttuple<_Args&&...>\n \t_M_construct_p(__uses_alloc0, _Ind, tuple<_Args...>& __t)\n@@ -487,7 +490,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{\n \t  return { std::get<_Ind>(std::move(__t))..., inner_allocator() };\n \t}\n-#endif // C++17\n+#endif // ! make_obj_using_allocator\n     };\n \n   /// @related std::scoped_allocator_adaptor"}, {"sha": "9c16f2c4e703af36eab115abd2c848a9c3e88cc0", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1e7c6fce15b8ad222f265df2537701407fd289e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=b1e7c6fce15b8ad222f265df2537701407fd289e", "patch": "@@ -144,7 +144,7 @@\n #define __cpp_lib_map_try_emplace 201411\n #define __cpp_lib_math_special_functions 201603L\n #ifdef _GLIBCXX_HAS_GTHREADS\n-# define __cpp_lib_memory_resource 201603\n+# define __cpp_lib_memory_resource 201603L\n #else\n # define __cpp_lib_memory_resource 1\n #endif\n@@ -217,6 +217,9 @@\n # define __cpp_lib_jthread 201911L\n #endif\n #define __cpp_lib_list_remove_return_type 201806L\n+#if __cpp_lib_concepts\n+# define __cpp_lib_make_obj_using_allocator 201811L\n+#endif\n #define __cpp_lib_math_constants 201907L\n #define __cpp_lib_polymorphic_allocator 201902L\n #if __cpp_lib_concepts"}]}