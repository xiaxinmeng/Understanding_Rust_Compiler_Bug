{"sha": "5c1a2e639a26f1582318ac6f547a8819ea7c6034", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMxYTJlNjM5YTI2ZjE1ODIzMThhYzZmNTQ3YTg4MTllYTdjNjAzNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-11-02T16:34:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-11-02T16:34:16Z"}, "message": "Move constant folds for maths functions to new file\n\nThe new routines operate on the built-in enum rather than on tree decls.\nThe idea is to extend this to handle internal functions too, with a\ncombined enum for both.\n\nThe patch also moves fold_fma too, with the same prototype.  The long-term\nplan is to replace FMA_EXPR with an internal function, for consistency\nwith the way that things like SQRT will be handled.\n\nTested on x86_64-linux-gnu, arm-linux-gnueabi and aarch64-linux-gnu.\n\ngcc/\n\t* builtins.h (fold_fma): Move to fold-const-call.h.\n\t* builtins.c: Include fold-const-call.h.\n\t(mathfn_built_in_2): New function, split out from...\n\t(mathfn_built_in_1): ...here.\n\t(do_real_to_int_conversion, fold_const_builtin_pow)\n\t(fold_const_builtin_logb, fold_const_builtin_significand)\n\t(fold_const_builtin_load_exponent, do_mpfr_arg1, do_mpfr_arg2)\n\t(do_mpfr_arg3, do_mpfr_sincos, do_mpfr_bessel_n, do_mpc_arg1): Delete.\n\t(fold_builtin_sincos): Use fold_const_call to handle constants.\n\t(fold_builtin_1, fold_builtin_2, fold_builtin_3): Add explicit\n\tchecks for ERROR_MARK.  Use fold_const_call to handle constant\n\tfolds for math functions.\n\t(fold_fma): Move to fold-const-call.c.\n\t* fold-const.c: Include fold-const-call.h.\n\t* Makefile.in (OBJS): Add fold-const-call.o.\n\t(PLUGIN_HEADERS): Add fold-const-call.h.\n\t* realmpfr.h (real_from_mpfr): Allow the format to be specified\n\tdirectly.\n\t* realmpfr.c (real_from_mpfr): Likewise.\n\t* fold-const-call.h, fold-const-call.c: New files.\n\nFrom-SVN: r229669", "tree": {"sha": "4ad1a84f126d5e19c09ab7325f6a810a7daf2032", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ad1a84f126d5e19c09ab7325f6a810a7daf2032"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c1a2e639a26f1582318ac6f547a8819ea7c6034", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c1a2e639a26f1582318ac6f547a8819ea7c6034", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c1a2e639a26f1582318ac6f547a8819ea7c6034", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c1a2e639a26f1582318ac6f547a8819ea7c6034/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6aadd15a4128d8afdca93be311449876cc2dc4d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aadd15a4128d8afdca93be311449876cc2dc4d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6aadd15a4128d8afdca93be311449876cc2dc4d5"}], "stats": {"total": 2557, "additions": 1467, "deletions": 1090}, "files": [{"sha": "f4569aaaacaccf32276c739dcb8f9f1a8c58014d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5c1a2e639a26f1582318ac6f547a8819ea7c6034", "patch": "@@ -1,3 +1,26 @@\n+2015-11-02  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* builtins.h (fold_fma): Move to fold-const-call.h.\n+\t* builtins.c: Include fold-const-call.h.\n+\t(mathfn_built_in_2): New function, split out from...\n+\t(mathfn_built_in_1): ...here.\n+\t(do_real_to_int_conversion, fold_const_builtin_pow)\n+\t(fold_const_builtin_logb, fold_const_builtin_significand)\n+\t(fold_const_builtin_load_exponent, do_mpfr_arg1, do_mpfr_arg2)\n+\t(do_mpfr_arg3, do_mpfr_sincos, do_mpfr_bessel_n, do_mpc_arg1): Delete.\n+\t(fold_builtin_sincos): Use fold_const_call to handle constants.\n+\t(fold_builtin_1, fold_builtin_2, fold_builtin_3): Add explicit\n+\tchecks for ERROR_MARK.  Use fold_const_call to handle constant\n+\tfolds for math functions.\n+\t(fold_fma): Move to fold-const-call.c.\n+\t* fold-const.c: Include fold-const-call.h.\n+\t* Makefile.in (OBJS): Add fold-const-call.o.\n+\t(PLUGIN_HEADERS): Add fold-const-call.h.\n+\t* realmpfr.h (real_from_mpfr): Allow the format to be specified\n+\tdirectly.\n+\t* realmpfr.c (real_from_mpfr): Likewise.\n+\t* fold-const-call.h, fold-const-call.c: New files.\n+\n 2015-11-02  Julian Brown  <julian@codesourcery.com>\n \n \t* config/arm/neon-testgen.ml (emit_epilogue): Remove extraneous"}, {"sha": "34d23565f8914cfdd4f13804797c8cfa3aa672cb", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5c1a2e639a26f1582318ac6f547a8819ea7c6034", "patch": "@@ -1260,6 +1260,7 @@ OBJS = \\\n \tfinal.o \\\n \tfixed-value.o \\\n \tfold-const.o \\\n+\tfold-const-call.o \\\n \tfunction.o \\\n \tfwprop.o \\\n \tgcse.o \\\n@@ -3273,10 +3274,10 @@ PLUGIN_HEADERS = $(TREE_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   prefix.h tree-inline.h $(GIMPLE_PRETTY_PRINT_H) realmpfr.h \\\n   $(IPA_PROP_H) $(TARGET_H) $(RTL_H) $(TM_P_H) $(CFGLOOP_H) $(EMIT_RTL_H) \\\n   version.h stringpool.h gimplify.h gimple-iterator.h gimple-ssa.h \\\n-  fold-const.h tree-cfg.h tree-into-ssa.h tree-ssanames.h print-tree.h \\\n-  varasm.h context.h tree-phinodes.h stor-layout.h ssa-iterators.h \\\n-  $(RESOURCE_H) tree-cfgcleanup.h attribs.h calls.h cfgexpand.h \\\n-  diagnostic-color.h gcc-symtab.h gimple-builder.h gimple-low.h \\\n+  fold-const.h fold-const-call.h tree-cfg.h tree-into-ssa.h tree-ssanames.h \\\n+  print-tree.h varasm.h context.h tree-phinodes.h stor-layout.h \\\n+  ssa-iterators.h $(RESOURCE_H) tree-cfgcleanup.h attribs.h calls.h \\\n+  cfgexpand.h diagnostic-color.h gcc-symtab.h gimple-builder.h gimple-low.h \\\n   gimple-walk.h gimplify-me.h pass_manager.h print-rtl.h stmt.h \\\n   tree-dfa.h tree-hasher.h tree-nested.h tree-object-size.h tree-outof-ssa.h \\\n   tree-parloops.h tree-ssa-address.h tree-ssa-coalesce.h tree-ssa-dom.h \\"}, {"sha": "8f0717c7e1b5498bc77d0f3bec9051205fb7dbbf", "filename": "gcc/builtins.c", "status": "modified", "additions": 134, "deletions": 1081, "changes": 1215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=5c1a2e639a26f1582318ac6f547a8819ea7c6034", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"alias.h\"\n #include \"fold-const.h\"\n+#include \"fold-const-call.h\"\n #include \"stor-layout.h\"\n #include \"calls.h\"\n #include \"varasm.h\"\n@@ -63,8 +64,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl-chkp.h\"\n \n \n-static tree do_mpc_arg1 (tree, tree, int (*)(mpc_ptr, mpc_srcptr, mpc_rnd_t));\n-\n struct target_builtins default_target_builtins;\n #if SWITCHABLE_TARGET\n struct target_builtins *this_target_builtins = &default_target_builtins;\n@@ -189,16 +188,6 @@ static unsigned HOST_WIDE_INT target_s;\n char target_percent_c[3];\n char target_percent_s[3];\n char target_percent_s_newline[4];\n-static tree do_mpfr_arg1 (tree, tree, int (*)(mpfr_ptr, mpfr_srcptr, mp_rnd_t),\n-\t\t\t  const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *, bool);\n-static tree do_mpfr_arg2 (tree, tree, tree,\n-\t\t\t  int (*)(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mp_rnd_t));\n-static tree do_mpfr_arg3 (tree, tree, tree, tree,\n-\t\t\t  int (*)(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_srcptr, mp_rnd_t));\n-static tree do_mpfr_sincos (tree, tree, tree);\n-static tree do_mpfr_bessel_n (tree, tree, tree,\n-\t\t\t      int (*)(mpfr_ptr, long, mpfr_srcptr, mp_rnd_t),\n-\t\t\t      const REAL_VALUE_TYPE *, bool);\n static tree do_mpfr_remquo (tree, tree, tree);\n static tree do_mpfr_lgamma_r (tree, tree, tree);\n static void expand_builtin_sync_synchronize (void);\n@@ -1795,15 +1784,16 @@ expand_builtin_classify_type (tree exp)\n   fcode = BUILT_IN_MATHFN##_R; fcodef = BUILT_IN_MATHFN##F_R ; \\\n   fcodel = BUILT_IN_MATHFN##L_R ; break;\n \n-/* Return mathematic function equivalent to FN but operating directly on TYPE,\n-   if available.  If IMPLICIT is true use the implicit builtin declaration,\n-   otherwise use the explicit declaration.  If we can't do the conversion,\n-   return zero.  */\n+/* Return a function equivalent to FN but operating on floating-point\n+   values of type TYPE, or END_BUILTINS if no such function exists.\n+   This is purely an operation on built-in function codes; it does not\n+   guarantee that the target actually has an implementation of the\n+   function.  */\n \n-static tree\n-mathfn_built_in_1 (tree type, enum built_in_function fn, bool implicit_p)\n+static built_in_function\n+mathfn_built_in_2 (tree type, built_in_function fn)\n {\n-  enum built_in_function fcode, fcodef, fcodel, fcode2;\n+  built_in_function fcode, fcodef, fcodel;\n \n   switch (fn)\n     {\n@@ -1896,16 +1886,29 @@ mathfn_built_in_1 (tree type, enum built_in_function fn, bool implicit_p)\n       CASE_MATHFN (BUILT_IN_YN)\n \n       default:\n-\treturn NULL_TREE;\n+\treturn END_BUILTINS;\n       }\n \n   if (TYPE_MAIN_VARIANT (type) == double_type_node)\n-    fcode2 = fcode;\n+    return fcode;\n   else if (TYPE_MAIN_VARIANT (type) == float_type_node)\n-    fcode2 = fcodef;\n+    return fcodef;\n   else if (TYPE_MAIN_VARIANT (type) == long_double_type_node)\n-    fcode2 = fcodel;\n+    return fcodel;\n   else\n+    return END_BUILTINS;\n+}\n+\n+/* Return mathematic function equivalent to FN but operating directly on TYPE,\n+   if available.  If IMPLICIT_P is true use the implicit builtin declaration,\n+   otherwise use the explicit declaration.  If we can't do the conversion,\n+   return null.  */\n+\n+static tree\n+mathfn_built_in_1 (tree type, enum built_in_function fn, bool implicit_p)\n+{\n+  built_in_function fcode2 = mathfn_built_in_2 (type, fn);\n+  if (fcode2 == END_BUILTINS)\n     return NULL_TREE;\n \n   if (implicit_p && !builtin_decl_implicit_p (fcode2))\n@@ -7262,35 +7265,6 @@ fold_builtin_strlen (location_t loc, tree type, tree arg)\n     }\n }\n \n-/* If ARG is a foldable constant real, use FN to round it to an integer\n-   value and try to represent the result in integer type ITYPE.  Return\n-   the value on success, otherwise return null.  */\n-\n-static tree\n-do_real_to_int_conversion (tree itype, tree arg,\n-\t\t\t   void (*fn) (REAL_VALUE_TYPE *, format_helper,\n-\t\t\t\t       const REAL_VALUE_TYPE *))\n-{\n-  if (TREE_CODE (arg) != REAL_CST || TREE_OVERFLOW (arg))\n-    return NULL_TREE;\n-\n-  const REAL_VALUE_TYPE *value = TREE_REAL_CST_PTR (arg);\n-  if (!real_isfinite (value))\n-    return NULL_TREE;\n-\n-  tree ftype = TREE_TYPE (arg);\n-  REAL_VALUE_TYPE rounded;\n-  fn (&rounded, TYPE_MODE (ftype), value);\n-\n-  bool fail = false;\n-  wide_int ival = real_to_integer (&rounded, &fail, TYPE_PRECISION (itype));\n-  if (fail)\n-    return NULL_TREE;\n-\n-  return wide_int_to_tree (itype, ival);\n-}\n-\n-\n /* Fold a call to __builtin_inf or __builtin_huge_val.  */\n \n static tree\n@@ -7340,7 +7314,7 @@ fold_builtin_sincos (location_t loc,\n \t\t     tree arg0, tree arg1, tree arg2)\n {\n   tree type;\n-  tree res, fn, call;\n+  tree fndecl, call = NULL_TREE;\n \n   if (!validate_arg (arg0, REAL_TYPE)\n       || !validate_arg (arg1, POINTER_TYPE)\n@@ -7350,26 +7324,33 @@ fold_builtin_sincos (location_t loc,\n   type = TREE_TYPE (arg0);\n \n   /* Calculate the result when the argument is a constant.  */\n-  if ((res = do_mpfr_sincos (arg0, arg1, arg2)))\n-    return res;\n-\n-  /* Canonicalize sincos to cexpi.  */\n-  if (!targetm.libc_has_function (function_c99_math_complex))\n-    return NULL_TREE;\n-  fn = mathfn_built_in (type, BUILT_IN_CEXPI);\n-  if (!fn)\n+  built_in_function fn = mathfn_built_in_2 (type, BUILT_IN_CEXPI);\n+  if (fn == END_BUILTINS)\n     return NULL_TREE;\n \n-  call = build_call_expr_loc (loc, fn, 1, arg0);\n-  call = builtin_save_expr (call);\n+  /* Canonicalize sincos to cexpi.  */\n+  if (TREE_CODE (arg0) == REAL_CST)\n+    {\n+      tree complex_type = build_complex_type (type);\n+      call = fold_const_call (fn, complex_type, arg0);\n+    }\n+  if (!call)\n+    {\n+      if (!targetm.libc_has_function (function_c99_math_complex)\n+\t  || !builtin_decl_implicit_p (fn))\n+\treturn NULL_TREE;\n+      fndecl = builtin_decl_explicit (fn);\n+      call = build_call_expr_loc (loc, fndecl, 1, arg0);\n+      call = builtin_save_expr (call);\n+    }\n \n   return build2 (COMPOUND_EXPR, void_type_node,\n \t\t build2 (MODIFY_EXPR, void_type_node,\n \t\t\t build_fold_indirect_ref_loc (loc, arg1),\n-\t\t\t build1 (IMAGPART_EXPR, type, call)),\n+\t\t\t fold_build1_loc (loc, IMAGPART_EXPR, type, call)),\n \t\t build2 (MODIFY_EXPR, void_type_node,\n \t\t\t build_fold_indirect_ref_loc (loc, arg2),\n-\t\t\t build1 (REALPART_EXPR, type, call)));\n+\t\t\t fold_build1_loc (loc, REALPART_EXPR, type, call)));\n }\n \n /* Fold function call to builtin ffs, clz, ctz, popcount and parity\n@@ -7465,49 +7446,6 @@ fold_builtin_bswap (tree fndecl, tree arg)\n   return NULL_TREE;\n }\n \n-/* Fold a builtin function call to pow, powf, or powl.  Return\n-   NULL_TREE if no simplification can be made.  */\n-static tree\n-fold_const_builtin_pow (tree arg0, tree arg1, tree type)\n-{\n-  tree res;\n-\n-  if (!validate_arg (arg0, REAL_TYPE)\n-       || !validate_arg (arg1, REAL_TYPE))\n-    return NULL_TREE;\n-\n-  /* Calculate the result when the argument is a constant.  */\n-  if ((res = do_mpfr_arg2 (arg0, arg1, type, mpfr_pow)))\n-    return res;\n-\n-  /* Check for an integer exponent.  */\n-  if (TREE_CODE (arg0) == REAL_CST\n-      && !TREE_OVERFLOW (arg0)\n-      && TREE_CODE (arg1) == REAL_CST\n-      && !TREE_OVERFLOW (arg1))\n-    {\n-      REAL_VALUE_TYPE cint1;\n-      const REAL_VALUE_TYPE *c0 = TREE_REAL_CST_PTR (arg0);\n-      const REAL_VALUE_TYPE *c1 = TREE_REAL_CST_PTR (arg1);\n-      HOST_WIDE_INT n1 = real_to_integer (c1);\n-      real_from_integer (&cint1, VOIDmode, n1, SIGNED);\n-      /* Attempt to evaluate pow at compile-time, unless this should\n-\t raise an exception.  */\n-      if (real_identical (c1, &cint1)\n-\t  && (n1 > 0\n-\t      || (!flag_trapping_math && !flag_errno_math)\n-\t      || !real_equal (c0, &dconst0)))\n-\t{\n-\t  REAL_VALUE_TYPE x;\n-\t  bool inexact = real_powi (&x, TYPE_MODE (type), c0, n1);\n-\t  if (flag_unsafe_math_optimizations || !inexact)\n-\t    return build_real (type, x);\n-\t}\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Fold function call to builtin memchr.  ARG1, ARG2 and LEN are the\n    arguments to the call, and TYPE is its return type.\n    Return NULL_TREE if no simplification can be made.  */\n@@ -7855,20 +7793,6 @@ fold_builtin_abs (location_t loc, tree arg, tree type)\n   return fold_build1_loc (loc, ABS_EXPR, type, arg);\n }\n \n-/* Fold a fma operation with arguments ARG[012].  */\n-\n-tree\n-fold_fma (location_t loc ATTRIBUTE_UNUSED,\n-\t  tree type, tree arg0, tree arg1, tree arg2)\n-{\n-  if (TREE_CODE (arg0) == REAL_CST\n-      && TREE_CODE (arg1) == REAL_CST\n-      && TREE_CODE (arg2) == REAL_CST)\n-    return do_mpfr_arg3 (arg0, arg1, arg2, type, mpfr_fma);\n-\n-  return NULL_TREE;\n-}\n-\n /* Fold a call to fma, fmaf, or fmal with arguments ARG[012].  */\n \n static tree\n@@ -7906,92 +7830,6 @@ fold_builtin_carg (location_t loc, tree arg, tree type)\n   return NULL_TREE;\n }\n \n-/* Fold a call to builtin logb/ilogb.  */\n-\n-static tree\n-fold_const_builtin_logb (location_t loc, tree arg, tree rettype)\n-{\n-  if (! validate_arg (arg, REAL_TYPE))\n-    return NULL_TREE;\n-\n-  if (TREE_CODE (arg) == REAL_CST && ! TREE_OVERFLOW (arg))\n-    {\n-      const REAL_VALUE_TYPE *const value = TREE_REAL_CST_PTR (arg);\n-\n-      switch (value->cl)\n-      {\n-      case rvc_nan:\n-      case rvc_inf:\n-\t/* If arg is Inf or NaN and we're logb, return it.  */\n-\tif (TREE_CODE (rettype) == REAL_TYPE)\n-\t  {\n-\t    /* For logb(-Inf) we have to return +Inf.  */\n-\t    if (real_isinf (value) && real_isneg (value))\n-\t      {\n-\t\tREAL_VALUE_TYPE tem;\n-\t\treal_inf (&tem);\n-\t\treturn build_real (rettype, tem);\n-\t      }\n-\t    return fold_convert_loc (loc, rettype, arg);\n-\t  }\n-\t/* Fall through... */\n-      case rvc_zero:\n-\t/* Zero may set errno and/or raise an exception for logb, also\n-\t   for ilogb we don't know FP_ILOGB0.  */\n-\treturn NULL_TREE;\n-      case rvc_normal:\n-\t/* For normal numbers, proceed iff radix == 2.  In GCC,\n-\t   normalized significands are in the range [0.5, 1.0).  We\n-\t   want the exponent as if they were [1.0, 2.0) so get the\n-\t   exponent and subtract 1.  */\n-\tif (REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (arg)))->b == 2)\n-\t  return fold_convert_loc (loc, rettype,\n-\t\t\t\t   build_int_cst (integer_type_node,\n-\t\t\t\t\t\t  REAL_EXP (value)-1));\n-\tbreak;\n-      }\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Fold a call to builtin significand, if radix == 2.  */\n-\n-static tree\n-fold_const_builtin_significand (location_t loc, tree arg, tree rettype)\n-{\n-  if (! validate_arg (arg, REAL_TYPE))\n-    return NULL_TREE;\n-\n-  if (TREE_CODE (arg) == REAL_CST && ! TREE_OVERFLOW (arg))\n-    {\n-      const REAL_VALUE_TYPE *const value = TREE_REAL_CST_PTR (arg);\n-\n-      switch (value->cl)\n-      {\n-      case rvc_zero:\n-      case rvc_nan:\n-      case rvc_inf:\n-\t/* If arg is +-0, +-Inf or +-NaN, then return it.  */\n-\treturn fold_convert_loc (loc, rettype, arg);\n-      case rvc_normal:\n-\t/* For normal numbers, proceed iff radix == 2.  */\n-\tif (REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (arg)))->b == 2)\n-\t  {\n-\t    REAL_VALUE_TYPE result = *value;\n-\t    /* In GCC, normalized significands are in the range [0.5,\n-\t       1.0).  We want them to be [1.0, 2.0) so set the\n-\t       exponent to 1.  */\n-\t    SET_REAL_EXP (&result, 1);\n-\t    return build_real (rettype, result);\n-\t  }\n-\tbreak;\n-      }\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Fold a call to builtin frexp, we can assume the base is 2.  */\n \n static tree\n@@ -8048,58 +7886,6 @@ fold_builtin_frexp (location_t loc, tree arg0, tree arg1, tree rettype)\n   return NULL_TREE;\n }\n \n-/* Fold a call to builtin ldexp or scalbn/scalbln.  If LDEXP is true\n-   then we can assume the base is two.  If it's false, then we have to\n-   check the mode of the TYPE parameter in certain cases.  */\n-\n-static tree\n-fold_const_builtin_load_exponent (tree arg0, tree arg1,\n-\t\t\t\t  tree type, bool ldexp)\n-{\n-  if (validate_arg (arg0, REAL_TYPE) && validate_arg (arg1, INTEGER_TYPE))\n-    {\n-      /* If both arguments are constant, then try to evaluate it.  */\n-      if ((ldexp || REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2)\n-\t  && TREE_CODE (arg0) == REAL_CST && !TREE_OVERFLOW (arg0)\n-\t  && tree_fits_shwi_p (arg1))\n-        {\n-\t  /* Bound the maximum adjustment to twice the range of the\n-\t     mode's valid exponents.  Use abs to ensure the range is\n-\t     positive as a sanity check.  */\n-\t  const long max_exp_adj = 2 *\n-\t    labs (REAL_MODE_FORMAT (TYPE_MODE (type))->emax\n-\t\t - REAL_MODE_FORMAT (TYPE_MODE (type))->emin);\n-\n-\t  /* Get the user-requested adjustment.  */\n-\t  const HOST_WIDE_INT req_exp_adj = tree_to_shwi (arg1);\n-\n-\t  /* The requested adjustment must be inside this range.  This\n-\t     is a preliminary cap to avoid things like overflow, we\n-\t     may still fail to compute the result for other reasons.  */\n-\t  if (-max_exp_adj < req_exp_adj && req_exp_adj < max_exp_adj)\n-\t    {\n-\t      REAL_VALUE_TYPE initial_result;\n-\n-\t      real_ldexp (&initial_result, &TREE_REAL_CST (arg0), req_exp_adj);\n-\n-\t      /* Ensure we didn't overflow.  */\n-\t      if (! real_isinf (&initial_result))\n-\t        {\n-\t\t  const REAL_VALUE_TYPE trunc_result\n-\t\t    = real_value_truncate (TYPE_MODE (type), initial_result);\n-\n-\t\t  /* Only proceed if the target mode can hold the\n-\t\t     resulting value.  */\n-\t\t  if (real_equal (&initial_result, &trunc_result))\n-\t\t    return build_real (type, trunc_result);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Fold a call to builtin modf.  */\n \n static tree\n@@ -8552,6 +8338,13 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0)\n {\n   tree type = TREE_TYPE (TREE_TYPE (fndecl));\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n+\n+  if (TREE_CODE (arg0) == ERROR_MARK)\n+    return NULL_TREE;\n+\n+  if (tree ret = fold_const_call (fcode, type, arg0))\n+    return ret;\n+\n   switch (fcode)\n     {\n     case BUILT_IN_CONSTANT_P:\n@@ -8603,520 +8396,113 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0)\n \treturn non_lvalue_loc (loc, fold_build1_loc (loc, IMAGPART_EXPR, type, arg0));\n     break;\n \n-    CASE_FLT_FN (BUILT_IN_CCOS):\n-      if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n-\treturn do_mpc_arg1 (arg0, type, mpc_cos);\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_CCOSH):\n-      if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n-\treturn do_mpc_arg1 (arg0, type, mpc_cosh);\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_CPROJ):\n-      if (TREE_CODE (arg0) == COMPLEX_CST\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n-\t{\n-\t  const REAL_VALUE_TYPE *real\n-\t    = TREE_REAL_CST_PTR (TREE_REALPART (arg0));\n-\t  const REAL_VALUE_TYPE *imag\n-\t    = TREE_REAL_CST_PTR (TREE_IMAGPART (arg0));\n-\n-\t  if (real_isinf (real) || real_isinf (imag))\n-\t    return build_complex_inf (type, imag->sign);\n-\t  else\n-\t    return arg0;\n-\t}\n-      break;\n+    CASE_FLT_FN (BUILT_IN_CARG):\n+      return fold_builtin_carg (loc, arg0, type);\n \n-    CASE_FLT_FN (BUILT_IN_CSIN):\n-      if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n-\treturn do_mpc_arg1 (arg0, type, mpc_sin);\n-    break;\n+    CASE_FLT_FN (BUILT_IN_NAN):\n+    case BUILT_IN_NAND32:\n+    case BUILT_IN_NAND64:\n+    case BUILT_IN_NAND128:\n+      return fold_builtin_nan (arg0, type, true);\n \n-    CASE_FLT_FN (BUILT_IN_CSINH):\n-      if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n-\treturn do_mpc_arg1 (arg0, type, mpc_sinh);\n-    break;\n+    CASE_FLT_FN (BUILT_IN_NANS):\n+      return fold_builtin_nan (arg0, type, false);\n \n-    CASE_FLT_FN (BUILT_IN_CTAN):\n-      if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n-\treturn do_mpc_arg1 (arg0, type, mpc_tan);\n-    break;\n+    case BUILT_IN_BSWAP16:\n+    case BUILT_IN_BSWAP32:\n+    case BUILT_IN_BSWAP64:\n+      return fold_builtin_bswap (fndecl, arg0);\n \n-    CASE_FLT_FN (BUILT_IN_CTANH):\n-      if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n-\treturn do_mpc_arg1 (arg0, type, mpc_tanh);\n-    break;\n+    CASE_INT_FN (BUILT_IN_FFS):\n+    CASE_INT_FN (BUILT_IN_CLZ):\n+    CASE_INT_FN (BUILT_IN_CTZ):\n+    CASE_INT_FN (BUILT_IN_CLRSB):\n+    CASE_INT_FN (BUILT_IN_POPCOUNT):\n+    CASE_INT_FN (BUILT_IN_PARITY):\n+      return fold_builtin_bitop (fndecl, arg0);\n \n-    CASE_FLT_FN (BUILT_IN_CLOG):\n-      if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n-\treturn do_mpc_arg1 (arg0, type, mpc_log);\n-    break;\n+    case BUILT_IN_ISASCII:\n+      return fold_builtin_isascii (loc, arg0);\n \n-    CASE_FLT_FN (BUILT_IN_CSQRT):\n-      if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n-\treturn do_mpc_arg1 (arg0, type, mpc_sqrt);\n-    break;\n+    case BUILT_IN_TOASCII:\n+      return fold_builtin_toascii (loc, arg0);\n \n-    CASE_FLT_FN (BUILT_IN_CASIN):\n-      if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n-\treturn do_mpc_arg1 (arg0, type, mpc_asin);\n-    break;\n+    case BUILT_IN_ISDIGIT:\n+      return fold_builtin_isdigit (loc, arg0);\n \n-    CASE_FLT_FN (BUILT_IN_CACOS):\n-      if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n-\treturn do_mpc_arg1 (arg0, type, mpc_acos);\n-    break;\n+    CASE_FLT_FN (BUILT_IN_FINITE):\n+    case BUILT_IN_FINITED32:\n+    case BUILT_IN_FINITED64:\n+    case BUILT_IN_FINITED128:\n+    case BUILT_IN_ISFINITE:\n+      {\n+\ttree ret = fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISFINITE);\n+\tif (ret)\n+\t  return ret;\n+\treturn fold_builtin_interclass_mathfn (loc, fndecl, arg0);\n+      }\n \n-    CASE_FLT_FN (BUILT_IN_CATAN):\n-      if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n-\treturn do_mpc_arg1 (arg0, type, mpc_atan);\n-    break;\n+    CASE_FLT_FN (BUILT_IN_ISINF):\n+    case BUILT_IN_ISINFD32:\n+    case BUILT_IN_ISINFD64:\n+    case BUILT_IN_ISINFD128:\n+      {\n+\ttree ret = fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISINF);\n+\tif (ret)\n+\t  return ret;\n+\treturn fold_builtin_interclass_mathfn (loc, fndecl, arg0);\n+      }\n \n-    CASE_FLT_FN (BUILT_IN_CASINH):\n-      if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n-\treturn do_mpc_arg1 (arg0, type, mpc_asinh);\n-    break;\n+    case BUILT_IN_ISNORMAL:\n+      return fold_builtin_interclass_mathfn (loc, fndecl, arg0);\n \n-    CASE_FLT_FN (BUILT_IN_CACOSH):\n-      if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n-\treturn do_mpc_arg1 (arg0, type, mpc_acosh);\n-    break;\n+    case BUILT_IN_ISINF_SIGN:\n+      return fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISINF_SIGN);\n \n-    CASE_FLT_FN (BUILT_IN_CATANH):\n-      if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n-\treturn do_mpc_arg1 (arg0, type, mpc_atanh);\n-    break;\n+    CASE_FLT_FN (BUILT_IN_ISNAN):\n+    case BUILT_IN_ISNAND32:\n+    case BUILT_IN_ISNAND64:\n+    case BUILT_IN_ISNAND128:\n+      return fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISNAN);\n \n-    CASE_FLT_FN (BUILT_IN_CABS):\n-      if (TREE_CODE (arg0) == COMPLEX_CST\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n-        return do_mpfr_arg2 (TREE_REALPART (arg0), TREE_IMAGPART (arg0),\n-\t\t\t     type, mpfr_hypot);\n+    case BUILT_IN_FREE:\n+      if (integer_zerop (arg0))\n+\treturn build_empty_stmt (loc);\n       break;\n \n-    CASE_FLT_FN (BUILT_IN_CARG):\n-      return fold_builtin_carg (loc, arg0, type);\n-\n-    CASE_FLT_FN (BUILT_IN_SQRT):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_sqrt, &dconst0, NULL, true);\n+    default:\n       break;\n+    }\n \n-    CASE_FLT_FN (BUILT_IN_CBRT):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_cbrt, NULL, NULL, 0);\n-      break;\n+  return NULL_TREE;\n \n-    CASE_FLT_FN (BUILT_IN_ASIN):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_asin,\n-\t\t\t     &dconstm1, &dconst1, true);\n-    break;\n+}\n \n-    CASE_FLT_FN (BUILT_IN_ACOS):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_acos,\n-\t\t\t     &dconstm1, &dconst1, true);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_ATAN):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_atan, NULL, NULL, 0);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_ASINH):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_asinh, NULL, NULL, 0);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_ACOSH):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_acosh,\n-\t\t\t     &dconst1, NULL, true);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_ATANH):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_atanh,\n-\t\t\t     &dconstm1, &dconst1, false);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_SIN):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_sin, NULL, NULL, 0);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_COS):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_cos, NULL, NULL, 0);\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_TAN):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_tan, NULL, NULL, 0);\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_CEXP):\n-      if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n-\treturn do_mpc_arg1 (arg0, type, mpc_exp);\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_CEXPI):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_sincos (arg0, NULL_TREE, NULL_TREE);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_SINH):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_sinh, NULL, NULL, 0);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_COSH):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_cosh, NULL, NULL, 0);\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_TANH):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_tanh, NULL, NULL, 0);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_ERF):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_erf, NULL, NULL, 0);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_ERFC):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_erfc, NULL, NULL, 0);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_TGAMMA):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_gamma, NULL, NULL, 0);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_EXP):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_exp, NULL, NULL, 0);\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_EXP2):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_exp2, NULL, NULL, 0);\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_EXP10):\n-    CASE_FLT_FN (BUILT_IN_POW10):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_exp10, NULL, NULL, 0);\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_EXPM1):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_expm1, NULL, NULL, 0);\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_LOG):\n-      if (validate_arg (arg0, REAL_TYPE))\n-        return do_mpfr_arg1 (arg0, type, mpfr_log, &dconst0, NULL, false);\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_LOG2):\n-      if (validate_arg (arg0, REAL_TYPE))\n-        return do_mpfr_arg1 (arg0, type, mpfr_log2, &dconst0, NULL, false);\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_LOG10):\n-      if (validate_arg (arg0, REAL_TYPE))\n-        return do_mpfr_arg1 (arg0, type, mpfr_log10, &dconst0, NULL, false);\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_LOG1P):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_log1p,\n-\t\t\t     &dconstm1, NULL, false);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_J0):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_j0,\n-\t\t\t     NULL, NULL, 0);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_J1):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_j1,\n-\t\t\t     NULL, NULL, 0);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_Y0):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_y0,\n-\t\t\t     &dconst0, NULL, false);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_Y1):\n-      if (validate_arg (arg0, REAL_TYPE))\n-\treturn do_mpfr_arg1 (arg0, type, mpfr_y1,\n-\t\t\t     &dconst0, NULL, false);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_NAN):\n-    case BUILT_IN_NAND32:\n-    case BUILT_IN_NAND64:\n-    case BUILT_IN_NAND128:\n-      return fold_builtin_nan (arg0, type, true);\n-\n-    CASE_FLT_FN (BUILT_IN_NANS):\n-      return fold_builtin_nan (arg0, type, false);\n-\n-    CASE_FLT_FN (BUILT_IN_FLOOR):\n-      if (TREE_CODE (arg0) == REAL_CST && !TREE_OVERFLOW (arg0))\n-\t{\n-\t  REAL_VALUE_TYPE x = TREE_REAL_CST (arg0);\n-\t  if (!REAL_VALUE_ISNAN (x) || !flag_errno_math)\n-\t    {\n-\t      tree type = TREE_TYPE (TREE_TYPE (fndecl));\n-\t      REAL_VALUE_TYPE r;\n-\t      real_floor (&r, TYPE_MODE (type), &x);\n-\t      return build_real (type, r);\n-\t    }\n-\t}\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_CEIL):\n-      if (TREE_CODE (arg0) == REAL_CST && !TREE_OVERFLOW (arg0))\n-\t{\n-\t  REAL_VALUE_TYPE x = TREE_REAL_CST (arg0);\n-\t  if (!REAL_VALUE_ISNAN (x) || !flag_errno_math)\n-\t    {\n-\t      tree type = TREE_TYPE (TREE_TYPE (fndecl));\n-\t      REAL_VALUE_TYPE r;\n-\t      real_ceil (&r, TYPE_MODE (type), &x);\n-\t      return build_real (type, r);\n-\t    }\n-\t}\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_TRUNC):\n-      if (TREE_CODE (arg0) == REAL_CST && !TREE_OVERFLOW (arg0))\n-\t{\n-\t  REAL_VALUE_TYPE x = TREE_REAL_CST (arg0);\n-\t  REAL_VALUE_TYPE r;\n-\t  real_trunc (&r, TYPE_MODE (type), &x);\n-\t  return build_real (type, r);\n-\t}\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_ROUND):\n-      if (TREE_CODE (arg0) == REAL_CST && !TREE_OVERFLOW (arg0))\n-\t{\n-\t  REAL_VALUE_TYPE x = TREE_REAL_CST (arg0);\n-\t  if (!REAL_VALUE_ISNAN (x) || !flag_errno_math)\n-\t    {\n-\t      tree type = TREE_TYPE (TREE_TYPE (fndecl));\n-\t      REAL_VALUE_TYPE r;\n-\t      real_round (&r, TYPE_MODE (type), &x);\n-\t      return build_real (type, r);\n-\t    }\n-\t}\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_ICEIL):\n-    CASE_FLT_FN (BUILT_IN_LCEIL):\n-    CASE_FLT_FN (BUILT_IN_LLCEIL):\n-      return do_real_to_int_conversion (type, arg0, real_ceil);\n-\n-    CASE_FLT_FN (BUILT_IN_LFLOOR):\n-    CASE_FLT_FN (BUILT_IN_IFLOOR):\n-    CASE_FLT_FN (BUILT_IN_LLFLOOR):\n-      return do_real_to_int_conversion (type, arg0, real_floor);\n-\n-    CASE_FLT_FN (BUILT_IN_IROUND):\n-    CASE_FLT_FN (BUILT_IN_LROUND):\n-    CASE_FLT_FN (BUILT_IN_LLROUND):\n-      return do_real_to_int_conversion (type, arg0, real_round);\n-\n-    CASE_FLT_FN (BUILT_IN_IRINT):\n-    CASE_FLT_FN (BUILT_IN_LRINT):\n-    CASE_FLT_FN (BUILT_IN_LLRINT):\n-      /* Not yet folded to a constant.  */\n-      return NULL_TREE;\n-\n-    case BUILT_IN_BSWAP16:\n-    case BUILT_IN_BSWAP32:\n-    case BUILT_IN_BSWAP64:\n-      return fold_builtin_bswap (fndecl, arg0);\n-\n-    CASE_INT_FN (BUILT_IN_FFS):\n-    CASE_INT_FN (BUILT_IN_CLZ):\n-    CASE_INT_FN (BUILT_IN_CTZ):\n-    CASE_INT_FN (BUILT_IN_CLRSB):\n-    CASE_INT_FN (BUILT_IN_POPCOUNT):\n-    CASE_INT_FN (BUILT_IN_PARITY):\n-      return fold_builtin_bitop (fndecl, arg0);\n-\n-    CASE_FLT_FN (BUILT_IN_SIGNBIT):\n-      if (TREE_CODE (arg0) == REAL_CST && !TREE_OVERFLOW (arg0))\n-\treturn (REAL_VALUE_NEGATIVE (TREE_REAL_CST (arg0))\n-\t\t? build_one_cst (type)\n-\t\t: build_zero_cst (type));\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_SIGNIFICAND):\n-      return fold_const_builtin_significand (loc, arg0, type);\n-\n-    CASE_FLT_FN (BUILT_IN_ILOGB):\n-    CASE_FLT_FN (BUILT_IN_LOGB):\n-      return fold_const_builtin_logb (loc, arg0, type);\n-\n-    case BUILT_IN_ISASCII:\n-      return fold_builtin_isascii (loc, arg0);\n-\n-    case BUILT_IN_TOASCII:\n-      return fold_builtin_toascii (loc, arg0);\n-\n-    case BUILT_IN_ISDIGIT:\n-      return fold_builtin_isdigit (loc, arg0);\n-\n-    CASE_FLT_FN (BUILT_IN_FINITE):\n-    case BUILT_IN_FINITED32:\n-    case BUILT_IN_FINITED64:\n-    case BUILT_IN_FINITED128:\n-    case BUILT_IN_ISFINITE:\n-      {\n-\ttree ret = fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISFINITE);\n-\tif (ret)\n-\t  return ret;\n-\treturn fold_builtin_interclass_mathfn (loc, fndecl, arg0);\n-      }\n-\n-    CASE_FLT_FN (BUILT_IN_ISINF):\n-    case BUILT_IN_ISINFD32:\n-    case BUILT_IN_ISINFD64:\n-    case BUILT_IN_ISINFD128:\n-      {\n-\ttree ret = fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISINF);\n-\tif (ret)\n-\t  return ret;\n-\treturn fold_builtin_interclass_mathfn (loc, fndecl, arg0);\n-      }\n-\n-    case BUILT_IN_ISNORMAL:\n-      return fold_builtin_interclass_mathfn (loc, fndecl, arg0);\n-\n-    case BUILT_IN_ISINF_SIGN:\n-      return fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISINF_SIGN);\n-\n-    CASE_FLT_FN (BUILT_IN_ISNAN):\n-    case BUILT_IN_ISNAND32:\n-    case BUILT_IN_ISNAND64:\n-    case BUILT_IN_ISNAND128:\n-      return fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISNAN);\n-\n-    case BUILT_IN_FREE:\n-      if (integer_zerop (arg0))\n-\treturn build_empty_stmt (loc);\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  return NULL_TREE;\n-\n-}\n-\n-/* Fold a call to built-in function FNDECL with 2 arguments, ARG0 and ARG1.\n-   This function returns NULL_TREE if no simplification was possible.  */\n+/* Fold a call to built-in function FNDECL with 2 arguments, ARG0 and ARG1.\n+   This function returns NULL_TREE if no simplification was possible.  */\n \n static tree\n fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1)\n {\n   tree type = TREE_TYPE (TREE_TYPE (fndecl));\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n \n-  switch (fcode)\n-    {\n-    CASE_FLT_FN (BUILT_IN_JN):\n-      if (validate_arg (arg0, INTEGER_TYPE)\n-\t  && validate_arg (arg1, REAL_TYPE))\n-\treturn do_mpfr_bessel_n (arg0, arg1, type, mpfr_jn, NULL, 0);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_YN):\n-      if (validate_arg (arg0, INTEGER_TYPE)\n-\t  && validate_arg (arg1, REAL_TYPE))\n-\treturn do_mpfr_bessel_n (arg0, arg1, type, mpfr_yn,\n-\t\t\t\t &dconst0, false);\n-    break;\n+  if (TREE_CODE (arg0) == ERROR_MARK\n+      || TREE_CODE (arg1) == ERROR_MARK)\n+    return NULL_TREE;\n \n-    CASE_FLT_FN (BUILT_IN_DREM):\n-    CASE_FLT_FN (BUILT_IN_REMAINDER):\n-      if (validate_arg (arg0, REAL_TYPE)\n-          && validate_arg (arg1, REAL_TYPE))\n-        return do_mpfr_arg2 (arg0, arg1, type, mpfr_remainder);\n-    break;\n+  if (tree ret = fold_const_call (fcode, type, arg0, arg1))\n+    return ret;\n \n+  switch (fcode)\n+    {\n     CASE_FLT_FN_REENT (BUILT_IN_GAMMA): /* GAMMA_R */\n     CASE_FLT_FN_REENT (BUILT_IN_LGAMMA): /* LGAMMA_R */\n       if (validate_arg (arg0, REAL_TYPE)\n \t  && validate_arg (arg1, POINTER_TYPE))\n \treturn do_mpfr_lgamma_r (arg0, arg1, type);\n     break;\n \n-    CASE_FLT_FN (BUILT_IN_ATAN2):\n-      if (validate_arg (arg0, REAL_TYPE)\n-\t  && validate_arg (arg1, REAL_TYPE))\n-\treturn do_mpfr_arg2 (arg0, arg1, type, mpfr_atan2);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_FDIM):\n-      if (validate_arg (arg0, REAL_TYPE)\n-\t  && validate_arg (arg1, REAL_TYPE))\n-\treturn do_mpfr_arg2 (arg0, arg1, type, mpfr_dim);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_HYPOT):\n-      if (validate_arg (arg0, REAL_TYPE)\n-\t  && validate_arg (arg1, REAL_TYPE))\n-\treturn do_mpfr_arg2 (arg0, arg1, type, mpfr_hypot);\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_CPOW):\n-      if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE\n-\t  && validate_arg (arg1, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg1))) == REAL_TYPE)\n-\treturn do_mpc_arg2 (arg0, arg1, type, /*do_nonfinite=*/ 0, mpc_pow);\n-    break;\n-\n-    CASE_FLT_FN (BUILT_IN_LDEXP):\n-      return fold_const_builtin_load_exponent (arg0, arg1, type,\n-\t\t\t\t\t       /*ldexp=*/true);\n-    CASE_FLT_FN (BUILT_IN_SCALBN):\n-    CASE_FLT_FN (BUILT_IN_SCALBLN):\n-      return fold_const_builtin_load_exponent (arg0, arg1, type,\n-\t\t\t\t\t       /*ldexp=*/false);\n-\n     CASE_FLT_FN (BUILT_IN_FREXP):\n       return fold_builtin_frexp (loc, arg0, arg1, type);\n \n@@ -9149,43 +8535,6 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1)\n     case BUILT_IN_EXPECT:\n       return fold_builtin_expect (loc, arg0, arg1, NULL_TREE);\n \n-    CASE_FLT_FN (BUILT_IN_POW):\n-      return fold_const_builtin_pow (arg0, arg1, type);\n-\n-    CASE_FLT_FN (BUILT_IN_POWI):\n-      if (TREE_CODE (arg0) == REAL_CST\n-\t  && !TREE_OVERFLOW (arg0)\n-\t  && tree_fits_shwi_p (arg1))\n-\t{\n-\t  HOST_WIDE_INT c = tree_to_shwi (arg1);\n-\t  REAL_VALUE_TYPE x;\n-\t  real_powi (&x, TYPE_MODE (type), TREE_REAL_CST_PTR (arg0), c);\n-\t  return build_real (type, x);\n-\t}\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_COPYSIGN):\n-      if (TREE_CODE (arg0) == REAL_CST\n-\t  && TREE_CODE (arg1) == REAL_CST\n-\t  && !TREE_OVERFLOW (arg0)\n-\t  && !TREE_OVERFLOW (arg1))\n-\t{\n-\t  REAL_VALUE_TYPE c1 = TREE_REAL_CST (arg0);\n-\t  real_copysign (&c1, TREE_REAL_CST_PTR (arg1));\n-\t  return build_real (type, c1);\n-\t}\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_FMIN):\n-      if (validate_arg (arg0, REAL_TYPE) && validate_arg (arg1, REAL_TYPE))\n-\treturn do_mpfr_arg2 (arg0, arg1, type, mpfr_min);\n-      break;\n-\n-    CASE_FLT_FN (BUILT_IN_FMAX):\n-      if (validate_arg (arg0, REAL_TYPE) && validate_arg (arg1, REAL_TYPE))\n-\treturn do_mpfr_arg2 (arg0, arg1, type, mpfr_max);\n-      break;\n-\n     case BUILT_IN_ISGREATER:\n       return fold_builtin_unordered_cmp (loc, fndecl,\n \t\t\t\t\t arg0, arg1, UNLE_EXPR, LE_EXPR);\n@@ -9235,15 +8584,22 @@ fold_builtin_3 (location_t loc, tree fndecl,\n {\n   tree type = TREE_TYPE (TREE_TYPE (fndecl));\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n+\n+  if (TREE_CODE (arg0) == ERROR_MARK\n+      || TREE_CODE (arg1) == ERROR_MARK\n+      || TREE_CODE (arg2) == ERROR_MARK)\n+    return NULL_TREE;\n+\n+  if (tree ret = fold_const_call (fcode, type, arg0, arg1, arg2))\n+    return ret;\n+\n   switch (fcode)\n     {\n \n     CASE_FLT_FN (BUILT_IN_SINCOS):\n       return fold_builtin_sincos (loc, arg0, arg1, arg2);\n \n     CASE_FLT_FN (BUILT_IN_FMA):\n-      if (tree tem = fold_fma (loc, type, arg0, arg1, arg2))\n-\treturn tem;\n       return fold_builtin_fma (loc, arg0, arg1, arg2, type);\n \n     CASE_FLT_FN (BUILT_IN_REMQUO):\n@@ -10559,264 +9915,6 @@ do_mpc_ckconv (mpc_srcptr m, tree type, int inexact, int force_convert)\n   return NULL_TREE;\n }\n \n-/* If argument ARG is a REAL_CST, call the one-argument mpfr function\n-   FUNC on it and return the resulting value as a tree with type TYPE.\n-   If MIN and/or MAX are not NULL, then the supplied ARG must be\n-   within those bounds.  If INCLUSIVE is true, then MIN/MAX are\n-   acceptable values, otherwise they are not.  The mpfr precision is\n-   set to the precision of TYPE.  We assume that function FUNC returns\n-   zero if the result could be calculated exactly within the requested\n-   precision.  */\n-\n-static tree\n-do_mpfr_arg1 (tree arg, tree type, int (*func)(mpfr_ptr, mpfr_srcptr, mp_rnd_t),\n-\t      const REAL_VALUE_TYPE *min, const REAL_VALUE_TYPE *max,\n-\t      bool inclusive)\n-{\n-  tree result = NULL_TREE;\n-\n-  STRIP_NOPS (arg);\n-\n-  /* To proceed, MPFR must exactly represent the target floating point\n-     format, which only happens when the target base equals two.  */\n-  if (REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2\n-      && TREE_CODE (arg) == REAL_CST && !TREE_OVERFLOW (arg))\n-    {\n-      const REAL_VALUE_TYPE *const ra = &TREE_REAL_CST (arg);\n-\n-      if (real_isfinite (ra)\n-\t  && (!min || real_compare (inclusive ? GE_EXPR: GT_EXPR , ra, min))\n-\t  && (!max || real_compare (inclusive ? LE_EXPR: LT_EXPR , ra, max)))\n-        {\n-\t  const struct real_format *fmt = REAL_MODE_FORMAT (TYPE_MODE (type));\n-\t  const int prec = fmt->p;\n-\t  const mp_rnd_t rnd = fmt->round_towards_zero? GMP_RNDZ : GMP_RNDN;\n-\t  int inexact;\n-\t  mpfr_t m;\n-\n-\t  mpfr_init2 (m, prec);\n-\t  mpfr_from_real (m, ra, GMP_RNDN);\n-\t  mpfr_clear_flags ();\n-\t  inexact = func (m, m, rnd);\n-\t  result = do_mpfr_ckconv (m, type, inexact);\n-\t  mpfr_clear (m);\n-\t}\n-    }\n-\n-  return result;\n-}\n-\n-/* If argument ARG is a REAL_CST, call the two-argument mpfr function\n-   FUNC on it and return the resulting value as a tree with type TYPE.\n-   The mpfr precision is set to the precision of TYPE.  We assume that\n-   function FUNC returns zero if the result could be calculated\n-   exactly within the requested precision.  */\n-\n-static tree\n-do_mpfr_arg2 (tree arg1, tree arg2, tree type,\n-\t      int (*func)(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mp_rnd_t))\n-{\n-  tree result = NULL_TREE;\n-\n-  STRIP_NOPS (arg1);\n-  STRIP_NOPS (arg2);\n-\n-  /* To proceed, MPFR must exactly represent the target floating point\n-     format, which only happens when the target base equals two.  */\n-  if (REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2\n-      && TREE_CODE (arg1) == REAL_CST && !TREE_OVERFLOW (arg1)\n-      && TREE_CODE (arg2) == REAL_CST && !TREE_OVERFLOW (arg2))\n-    {\n-      const REAL_VALUE_TYPE *const ra1 = &TREE_REAL_CST (arg1);\n-      const REAL_VALUE_TYPE *const ra2 = &TREE_REAL_CST (arg2);\n-\n-      if (real_isfinite (ra1) && real_isfinite (ra2))\n-        {\n-\t  const struct real_format *fmt = REAL_MODE_FORMAT (TYPE_MODE (type));\n-\t  const int prec = fmt->p;\n-\t  const mp_rnd_t rnd = fmt->round_towards_zero? GMP_RNDZ : GMP_RNDN;\n-\t  int inexact;\n-\t  mpfr_t m1, m2;\n-\n-\t  mpfr_inits2 (prec, m1, m2, NULL);\n-\t  mpfr_from_real (m1, ra1, GMP_RNDN);\n-\t  mpfr_from_real (m2, ra2, GMP_RNDN);\n-\t  mpfr_clear_flags ();\n-\t  inexact = func (m1, m1, m2, rnd);\n-\t  result = do_mpfr_ckconv (m1, type, inexact);\n-\t  mpfr_clears (m1, m2, NULL);\n-\t}\n-    }\n-\n-  return result;\n-}\n-\n-/* If argument ARG is a REAL_CST, call the three-argument mpfr function\n-   FUNC on it and return the resulting value as a tree with type TYPE.\n-   The mpfr precision is set to the precision of TYPE.  We assume that\n-   function FUNC returns zero if the result could be calculated\n-   exactly within the requested precision.  */\n-\n-static tree\n-do_mpfr_arg3 (tree arg1, tree arg2, tree arg3, tree type,\n-\t      int (*func)(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_srcptr, mp_rnd_t))\n-{\n-  tree result = NULL_TREE;\n-\n-  STRIP_NOPS (arg1);\n-  STRIP_NOPS (arg2);\n-  STRIP_NOPS (arg3);\n-\n-  /* To proceed, MPFR must exactly represent the target floating point\n-     format, which only happens when the target base equals two.  */\n-  if (REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2\n-      && TREE_CODE (arg1) == REAL_CST && !TREE_OVERFLOW (arg1)\n-      && TREE_CODE (arg2) == REAL_CST && !TREE_OVERFLOW (arg2)\n-      && TREE_CODE (arg3) == REAL_CST && !TREE_OVERFLOW (arg3))\n-    {\n-      const REAL_VALUE_TYPE *const ra1 = &TREE_REAL_CST (arg1);\n-      const REAL_VALUE_TYPE *const ra2 = &TREE_REAL_CST (arg2);\n-      const REAL_VALUE_TYPE *const ra3 = &TREE_REAL_CST (arg3);\n-\n-      if (real_isfinite (ra1) && real_isfinite (ra2) && real_isfinite (ra3))\n-        {\n-\t  const struct real_format *fmt = REAL_MODE_FORMAT (TYPE_MODE (type));\n-\t  const int prec = fmt->p;\n-\t  const mp_rnd_t rnd = fmt->round_towards_zero? GMP_RNDZ : GMP_RNDN;\n-\t  int inexact;\n-\t  mpfr_t m1, m2, m3;\n-\n-\t  mpfr_inits2 (prec, m1, m2, m3, NULL);\n-\t  mpfr_from_real (m1, ra1, GMP_RNDN);\n-\t  mpfr_from_real (m2, ra2, GMP_RNDN);\n-\t  mpfr_from_real (m3, ra3, GMP_RNDN);\n-\t  mpfr_clear_flags ();\n-\t  inexact = func (m1, m1, m2, m3, rnd);\n-\t  result = do_mpfr_ckconv (m1, type, inexact);\n-\t  mpfr_clears (m1, m2, m3, NULL);\n-\t}\n-    }\n-\n-  return result;\n-}\n-\n-/* If argument ARG is a REAL_CST, call mpfr_sin_cos() on it and set\n-   the pointers *(ARG_SINP) and *(ARG_COSP) to the resulting values.\n-   If ARG_SINP and ARG_COSP are NULL then the result is returned\n-   as a complex value.\n-   The type is taken from the type of ARG and is used for setting the\n-   precision of the calculation and results.  */\n-\n-static tree\n-do_mpfr_sincos (tree arg, tree arg_sinp, tree arg_cosp)\n-{\n-  tree const type = TREE_TYPE (arg);\n-  tree result = NULL_TREE;\n-\n-  STRIP_NOPS (arg);\n-\n-  /* To proceed, MPFR must exactly represent the target floating point\n-     format, which only happens when the target base equals two.  */\n-  if (REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2\n-      && TREE_CODE (arg) == REAL_CST\n-      && !TREE_OVERFLOW (arg))\n-    {\n-      const REAL_VALUE_TYPE *const ra = &TREE_REAL_CST (arg);\n-\n-      if (real_isfinite (ra))\n-        {\n-\t  const struct real_format *fmt = REAL_MODE_FORMAT (TYPE_MODE (type));\n-\t  const int prec = fmt->p;\n-\t  const mp_rnd_t rnd = fmt->round_towards_zero? GMP_RNDZ : GMP_RNDN;\n-\t  tree result_s, result_c;\n-\t  int inexact;\n-\t  mpfr_t m, ms, mc;\n-\n-\t  mpfr_inits2 (prec, m, ms, mc, NULL);\n-\t  mpfr_from_real (m, ra, GMP_RNDN);\n-\t  mpfr_clear_flags ();\n-\t  inexact = mpfr_sin_cos (ms, mc, m, rnd);\n-\t  result_s = do_mpfr_ckconv (ms, type, inexact);\n-\t  result_c = do_mpfr_ckconv (mc, type, inexact);\n-\t  mpfr_clears (m, ms, mc, NULL);\n-\t  if (result_s && result_c)\n-\t    {\n-\t      /* If we are to return in a complex value do so.  */\n-\t      if (!arg_sinp && !arg_cosp)\n-\t\treturn build_complex (build_complex_type (type),\n-\t\t\t\t      result_c, result_s);\n-\n-\t      /* Dereference the sin/cos pointer arguments.  */\n-\t      arg_sinp = build_fold_indirect_ref (arg_sinp);\n-\t      arg_cosp = build_fold_indirect_ref (arg_cosp);\n-\t      /* Proceed if valid pointer type were passed in.  */\n-\t      if (TYPE_MAIN_VARIANT (TREE_TYPE (arg_sinp)) == TYPE_MAIN_VARIANT (type)\n-\t\t  && TYPE_MAIN_VARIANT (TREE_TYPE (arg_cosp)) == TYPE_MAIN_VARIANT (type))\n-\t        {\n-\t\t  /* Set the values. */\n-\t\t  result_s = fold_build2 (MODIFY_EXPR, type, arg_sinp,\n-\t\t      \t\t\t  result_s);\n-\t\t  TREE_SIDE_EFFECTS (result_s) = 1;\n-\t\t  result_c = fold_build2 (MODIFY_EXPR, type, arg_cosp,\n-\t\t      \t\t\t  result_c);\n-\t\t  TREE_SIDE_EFFECTS (result_c) = 1;\n-\t\t  /* Combine the assignments into a compound expr.  */\n-\t\t  result = non_lvalue (fold_build2 (COMPOUND_EXPR, type,\n-\t\t\t\t\t\t    result_s, result_c));\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  return result;\n-}\n-\n-/* If argument ARG1 is an INTEGER_CST and ARG2 is a REAL_CST, call the\n-   two-argument mpfr order N Bessel function FUNC on them and return\n-   the resulting value as a tree with type TYPE.  The mpfr precision\n-   is set to the precision of TYPE.  We assume that function FUNC\n-   returns zero if the result could be calculated exactly within the\n-   requested precision.  */\n-static tree\n-do_mpfr_bessel_n (tree arg1, tree arg2, tree type,\n-\t\t  int (*func)(mpfr_ptr, long, mpfr_srcptr, mp_rnd_t),\n-\t\t  const REAL_VALUE_TYPE *min, bool inclusive)\n-{\n-  tree result = NULL_TREE;\n-\n-  STRIP_NOPS (arg1);\n-  STRIP_NOPS (arg2);\n-\n-  /* To proceed, MPFR must exactly represent the target floating point\n-     format, which only happens when the target base equals two.  */\n-  if (REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2\n-      && tree_fits_shwi_p (arg1)\n-      && TREE_CODE (arg2) == REAL_CST && !TREE_OVERFLOW (arg2))\n-    {\n-      const HOST_WIDE_INT n = tree_to_shwi (arg1);\n-      const REAL_VALUE_TYPE *const ra = &TREE_REAL_CST (arg2);\n-\n-      if (n == (long)n\n-\t  && real_isfinite (ra)\n-\t  && (!min || real_compare (inclusive ? GE_EXPR: GT_EXPR , ra, min)))\n-        {\n-\t  const struct real_format *fmt = REAL_MODE_FORMAT (TYPE_MODE (type));\n-\t  const int prec = fmt->p;\n-\t  const mp_rnd_t rnd = fmt->round_towards_zero? GMP_RNDZ : GMP_RNDN;\n-\t  int inexact;\n-\t  mpfr_t m;\n-\n-\t  mpfr_init2 (m, prec);\n-\t  mpfr_from_real (m, ra, GMP_RNDN);\n-\t  mpfr_clear_flags ();\n-\t  inexact = func (m, n, m, rnd);\n-\t  result = do_mpfr_ckconv (m, type, inexact);\n-\t  mpfr_clear (m);\n-\t}\n-    }\n-\n-  return result;\n-}\n-\n /* If arguments ARG0 and ARG1 are REAL_CSTs, call mpfr_remquo() to set\n    the pointer *(ARG_QUO) and return the result.  The type is taken\n    from the type of ARG0 and is used for setting the precision of the\n@@ -10956,51 +10054,6 @@ do_mpfr_lgamma_r (tree arg, tree arg_sg, tree type)\n   return result;\n }\n \n-/* If argument ARG is a COMPLEX_CST, call the one-argument mpc\n-   function FUNC on it and return the resulting value as a tree with\n-   type TYPE.  The mpfr precision is set to the precision of TYPE.  We\n-   assume that function FUNC returns zero if the result could be\n-   calculated exactly within the requested precision.  */\n-\n-static tree\n-do_mpc_arg1 (tree arg, tree type, int (*func)(mpc_ptr, mpc_srcptr, mpc_rnd_t))\n-{\n-  tree result = NULL_TREE;\n-\n-  STRIP_NOPS (arg);\n-\n-  /* To proceed, MPFR must exactly represent the target floating point\n-     format, which only happens when the target base equals two.  */\n-  if (TREE_CODE (arg) == COMPLEX_CST && !TREE_OVERFLOW (arg)\n-      && TREE_CODE (TREE_TYPE (TREE_TYPE (arg))) == REAL_TYPE\n-      && REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (TREE_TYPE (arg))))->b == 2)\n-    {\n-      const REAL_VALUE_TYPE *const re = TREE_REAL_CST_PTR (TREE_REALPART (arg));\n-      const REAL_VALUE_TYPE *const im = TREE_REAL_CST_PTR (TREE_IMAGPART (arg));\n-\n-      if (real_isfinite (re) && real_isfinite (im))\n-        {\n-\t  const struct real_format *const fmt =\n-\t    REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (type)));\n-\t  const int prec = fmt->p;\n-\t  const mp_rnd_t rnd = fmt->round_towards_zero ? GMP_RNDZ : GMP_RNDN;\n-\t  const mpc_rnd_t crnd = fmt->round_towards_zero ? MPC_RNDZZ : MPC_RNDNN;\n-\t  int inexact;\n-\t  mpc_t m;\n-\n-\t  mpc_init2 (m, prec);\n-\t  mpfr_from_real (mpc_realref (m), re, rnd);\n-\t  mpfr_from_real (mpc_imagref (m), im, rnd);\n-\t  mpfr_clear_flags ();\n-\t  inexact = func (m, m, crnd);\n-\t  result = do_mpc_ckconv (m, type, inexact, /*force_convert=*/ 0);\n-\t  mpc_clear (m);\n-\t}\n-    }\n-\n-  return result;\n-}\n-\n /* If arguments ARG0 and ARG1 are a COMPLEX_CST, call the two-argument\n    mpc function FUNC on it and return the resulting value as a tree\n    with type TYPE.  The mpfr precision is set to the precision of"}, {"sha": "cce9e7507a287a58590e62162c4fde03815013bb", "filename": "gcc/builtins.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=5c1a2e639a26f1582318ac6f547a8819ea7c6034", "patch": "@@ -73,7 +73,6 @@ extern rtx expand_builtin (tree, rtx, rtx, machine_mode, int);\n extern rtx expand_builtin_with_bounds (tree, rtx, rtx, machine_mode, int);\n extern enum built_in_function builtin_mathfn_code (const_tree);\n extern tree fold_builtin_expect (location_t, tree, tree, tree);\n-extern tree fold_fma (location_t, tree, tree, tree, tree);\n extern bool avoid_folding_inline_builtin (tree);\n extern tree fold_call_expr (location_t, tree, bool);\n extern tree fold_builtin_call_array (location_t, tree, tree, int, tree *);"}, {"sha": "5af2c635313ee564e347c848651d733b211c8dfc", "filename": "gcc/fold-const-call.c", "status": "added", "additions": 1259, "deletions": 0, "changes": 1259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2Ffold-const-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2Ffold-const-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.c?ref=5c1a2e639a26f1582318ac6f547a8819ea7c6034", "patch": "@@ -0,0 +1,1259 @@\n+/* Constant folding for calls to built-in and internal functions.\n+   Copyright (C) 1988-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"realmpfr.h\"\n+#include \"tree.h\"\n+#include \"stor-layout.h\"\n+#include \"options.h\"\n+#include \"fold-const-call.h\"\n+\n+/* Functions that test for certain constant types, abstracting away the\n+   decision about whether to check for overflow.  */\n+\n+static inline bool\n+integer_cst_p (tree t)\n+{\n+  return TREE_CODE (t) == INTEGER_CST && !TREE_OVERFLOW (t);\n+}\n+\n+static inline bool\n+real_cst_p (tree t)\n+{\n+  return TREE_CODE (t) == REAL_CST && !TREE_OVERFLOW (t);\n+}\n+\n+static inline bool\n+complex_cst_p (tree t)\n+{\n+  return TREE_CODE (t) == COMPLEX_CST;\n+}\n+\n+/* M is the result of trying to constant-fold an expression (starting\n+   with clear MPFR flags) and INEXACT says whether the result in M is\n+   exact or inexact.  Return true if M can be used as a constant-folded\n+   result in format FORMAT, storing the value in *RESULT if so.  */\n+\n+static bool\n+do_mpfr_ckconv (real_value *result, mpfr_srcptr m, bool inexact,\n+\t\tconst real_format *format)\n+{\n+  /* Proceed iff we get a normal number, i.e. not NaN or Inf and no\n+     overflow/underflow occurred.  If -frounding-math, proceed iff the\n+     result of calling FUNC was exact.  */\n+  if (!mpfr_number_p (m)\n+      || mpfr_overflow_p ()\n+      || mpfr_underflow_p ()\n+      || (flag_rounding_math && inexact))\n+    return false;\n+\n+  REAL_VALUE_TYPE tmp;\n+  real_from_mpfr (&tmp, m, format, GMP_RNDN);\n+\n+  /* Proceed iff GCC's REAL_VALUE_TYPE can hold the MPFR values.\n+     If the REAL_VALUE_TYPE is zero but the mpft_t is not, then we\n+     underflowed in the conversion.  */\n+  if (!real_isfinite (&tmp)\n+      || ((tmp.cl == rvc_zero) != (mpfr_zero_p (m) != 0)))\n+    return false;\n+\n+  real_convert (result, format, &tmp);\n+  return real_identical (result, &tmp);\n+}\n+\n+/* Try to evaluate:\n+\n+      *RESULT = f (*ARG)\n+\n+   in format FORMAT, given that FUNC is the MPFR implementation of f.\n+   Return true on success.  */\n+\n+static bool\n+do_mpfr_arg1 (real_value *result,\n+\t      int (*func) (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t),\n+\t      const real_value *arg, const real_format *format)\n+{\n+  /* To proceed, MPFR must exactly represent the target floating point\n+     format, which only happens when the target base equals two.  */\n+  if (format->b != 2 || !real_isfinite (arg))\n+    return false;\n+\n+  int prec = format->p;\n+  mp_rnd_t rnd = format->round_towards_zero ? GMP_RNDZ : GMP_RNDN;\n+  mpfr_t m;\n+\n+  mpfr_init2 (m, prec);\n+  mpfr_from_real (m, arg, GMP_RNDN);\n+  mpfr_clear_flags ();\n+  bool inexact = func (m, m, rnd);\n+  bool ok = do_mpfr_ckconv (result, m, inexact, format);\n+  mpfr_clear (m);\n+\n+  return ok;\n+}\n+\n+/* Try to evaluate:\n+\n+      *RESULT_SIN = sin (*ARG);\n+      *RESULT_COS = cos (*ARG);\n+\n+   for format FORMAT.  Return true on success.  */\n+\n+static bool\n+do_mpfr_sincos (real_value *result_sin, real_value *result_cos,\n+\t\tconst real_value *arg, const real_format *format)\n+{\n+  /* To proceed, MPFR must exactly represent the target floating point\n+     format, which only happens when the target base equals two.  */\n+  if (format->b != 2 || !real_isfinite (arg))\n+    return false;\n+\n+  int prec = format->p;\n+  mp_rnd_t rnd = format->round_towards_zero ? GMP_RNDZ : GMP_RNDN;\n+  mpfr_t m, ms, mc;\n+\n+  mpfr_inits2 (prec, m, ms, mc, NULL);\n+  mpfr_from_real (m, arg, GMP_RNDN);\n+  mpfr_clear_flags ();\n+  bool inexact = mpfr_sin_cos (ms, mc, m, rnd);\n+  bool ok = (do_mpfr_ckconv (result_sin, ms, inexact, format)\n+\t     && do_mpfr_ckconv (result_cos, mc, inexact, format));\n+  mpfr_clears (m, ms, mc, NULL);\n+\n+  return ok;\n+}\n+\n+/* Try to evaluate:\n+\n+      *RESULT = f (*ARG0, *ARG1)\n+\n+   in format FORMAT, given that FUNC is the MPFR implementation of f.\n+   Return true on success.  */\n+\n+static bool\n+do_mpfr_arg2 (real_value *result,\n+\t      int (*func) (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t),\n+\t      const real_value *arg0, const real_value *arg1,\n+\t      const real_format *format)\n+{\n+  /* To proceed, MPFR must exactly represent the target floating point\n+     format, which only happens when the target base equals two.  */\n+  if (format->b != 2 || !real_isfinite (arg0) || !real_isfinite (arg1))\n+    return false;\n+\n+  int prec = format->p;\n+  mp_rnd_t rnd = format->round_towards_zero ? GMP_RNDZ : GMP_RNDN;\n+  mpfr_t m0, m1;\n+\n+  mpfr_inits2 (prec, m0, m1, NULL);\n+  mpfr_from_real (m0, arg0, GMP_RNDN);\n+  mpfr_from_real (m1, arg1, GMP_RNDN);\n+  mpfr_clear_flags ();\n+  bool inexact = func (m0, m0, m1, rnd);\n+  bool ok = do_mpfr_ckconv (result, m0, inexact, format);\n+  mpfr_clears (m0, m1, NULL);\n+\n+  return ok;\n+}\n+\n+/* Try to evaluate:\n+\n+      *RESULT = f (ARG0, *ARG1)\n+\n+   in format FORMAT, given that FUNC is the MPFR implementation of f.\n+   Return true on success.  */\n+\n+static bool\n+do_mpfr_arg2 (real_value *result,\n+\t      int (*func) (mpfr_ptr, long, mpfr_srcptr, mp_rnd_t),\n+\t      const wide_int_ref &arg0, const real_value *arg1,\n+\t      const real_format *format)\n+{\n+  if (format->b != 2 || !real_isfinite (arg1))\n+    return false;\n+\n+  int prec = format->p;\n+  mp_rnd_t rnd = format->round_towards_zero ? GMP_RNDZ : GMP_RNDN;\n+  mpfr_t m;\n+\n+  mpfr_init2 (m, prec);\n+  mpfr_from_real (m, arg1, GMP_RNDN);\n+  mpfr_clear_flags ();\n+  bool inexact = func (m, arg0.to_shwi (), m, rnd);\n+  bool ok = do_mpfr_ckconv (result, m, inexact, format);\n+  mpfr_clear (m);\n+\n+  return ok;\n+}\n+\n+/* Try to evaluate:\n+\n+      *RESULT = f (*ARG0, *ARG1, *ARG2)\n+\n+   in format FORMAT, given that FUNC is the MPFR implementation of f.\n+   Return true on success.  */\n+\n+static bool\n+do_mpfr_arg3 (real_value *result,\n+\t      int (*func) (mpfr_ptr, mpfr_srcptr, mpfr_srcptr,\n+\t\t\t   mpfr_srcptr, mpfr_rnd_t),\n+\t      const real_value *arg0, const real_value *arg1,\n+\t      const real_value *arg2, const real_format *format)\n+{\n+  /* To proceed, MPFR must exactly represent the target floating point\n+     format, which only happens when the target base equals two.  */\n+  if (format->b != 2\n+      || !real_isfinite (arg0)\n+      || !real_isfinite (arg1)\n+      || !real_isfinite (arg2))\n+    return false;\n+\n+  int prec = format->p;\n+  mp_rnd_t rnd = format->round_towards_zero ? GMP_RNDZ : GMP_RNDN;\n+  mpfr_t m0, m1, m2;\n+\n+  mpfr_inits2 (prec, m0, m1, m2, NULL);\n+  mpfr_from_real (m0, arg0, GMP_RNDN);\n+  mpfr_from_real (m1, arg1, GMP_RNDN);\n+  mpfr_from_real (m2, arg2, GMP_RNDN);\n+  mpfr_clear_flags ();\n+  bool inexact = func (m0, m0, m1, m2, rnd);\n+  bool ok = do_mpfr_ckconv (result, m0, inexact, format);\n+  mpfr_clears (m0, m1, m2, NULL);\n+\n+  return ok;\n+}\n+\n+/* M is the result of trying to constant-fold an expression (starting\n+   with clear MPFR flags) and INEXACT says whether the result in M is\n+   exact or inexact.  Return true if M can be used as a constant-folded\n+   result in which the real and imaginary parts have format FORMAT.\n+   Store those parts in *RESULT_REAL and *RESULT_IMAG if so.  */\n+\n+static bool\n+do_mpc_ckconv (real_value *result_real, real_value *result_imag,\n+\t       mpc_srcptr m, bool inexact, const real_format *format)\n+{\n+  /* Proceed iff we get a normal number, i.e. not NaN or Inf and no\n+     overflow/underflow occurred.  If -frounding-math, proceed iff the\n+     result of calling FUNC was exact.  */\n+  if (!mpfr_number_p (mpc_realref (m))\n+      || !mpfr_number_p (mpc_imagref (m))\n+      || mpfr_overflow_p ()\n+      || mpfr_underflow_p ()\n+      || (flag_rounding_math && inexact))\n+    return false;\n+\n+  REAL_VALUE_TYPE tmp_real, tmp_imag;\n+  real_from_mpfr (&tmp_real, mpc_realref (m), format, GMP_RNDN);\n+  real_from_mpfr (&tmp_imag, mpc_imagref (m), format, GMP_RNDN);\n+\n+  /* Proceed iff GCC's REAL_VALUE_TYPE can hold the MPFR values.\n+     If the REAL_VALUE_TYPE is zero but the mpft_t is not, then we\n+     underflowed in the conversion.  */\n+  if (!real_isfinite (&tmp_real)\n+      || !real_isfinite (&tmp_imag)\n+      || (tmp_real.cl == rvc_zero) != (mpfr_zero_p (mpc_realref (m)) != 0)\n+      || (tmp_imag.cl == rvc_zero) != (mpfr_zero_p (mpc_imagref (m)) != 0))\n+    return false;\n+\n+  real_convert (result_real, format, &tmp_real);\n+  real_convert (result_imag, format, &tmp_imag);\n+\n+  return (real_identical (result_real, &tmp_real)\n+\t  && real_identical (result_imag, &tmp_imag));\n+}\n+\n+/* Try to evaluate:\n+\n+      RESULT = f (ARG)\n+\n+   in format FORMAT, given that FUNC is the mpc implementation of f.\n+   Return true on success.  Both RESULT and ARG are represented as\n+   real and imaginary pairs.  */\n+\n+static bool\n+do_mpc_arg1 (real_value *result_real, real_value *result_imag,\n+\t     int (*func) (mpc_ptr, mpc_srcptr, mpc_rnd_t),\n+\t     const real_value *arg_real, const real_value *arg_imag,\n+\t     const real_format *format)\n+{\n+  /* To proceed, MPFR must exactly represent the target floating point\n+     format, which only happens when the target base equals two.  */\n+  if (format->b != 2\n+      || !real_isfinite (arg_real)\n+      || !real_isfinite (arg_imag))\n+    return false;\n+\n+  int prec = format->p;\n+  mpc_rnd_t crnd = format->round_towards_zero ? MPC_RNDZZ : MPC_RNDNN;\n+  mpc_t m;\n+\n+  mpc_init2 (m, prec);\n+  mpfr_from_real (mpc_realref (m), arg_real, GMP_RNDN);\n+  mpfr_from_real (mpc_imagref (m), arg_imag, GMP_RNDN);\n+  mpfr_clear_flags ();\n+  bool inexact = func (m, m, crnd);\n+  bool ok = do_mpc_ckconv (result_real, result_imag, m, inexact, format);\n+  mpc_clear (m);\n+\n+  return ok;\n+}\n+\n+/* Try to evaluate:\n+\n+      RESULT = f (ARG0, ARG1)\n+\n+   in format FORMAT, given that FUNC is the mpc implementation of f.\n+   Return true on success.  RESULT, ARG0 and ARG1 are represented as\n+   real and imaginary pairs.  */\n+\n+static bool\n+do_mpc_arg2 (real_value *result_real, real_value *result_imag,\n+\t     int (*func)(mpc_ptr, mpc_srcptr, mpc_srcptr, mpc_rnd_t),\n+\t     const real_value *arg0_real, const real_value *arg0_imag,\n+\t     const real_value *arg1_real, const real_value *arg1_imag,\n+\t     const real_format *format)\n+{\n+  if (!real_isfinite (arg0_real)\n+      || !real_isfinite (arg0_imag)\n+      || !real_isfinite (arg1_real)\n+      || !real_isfinite (arg1_imag))\n+    return false;\n+\n+  int prec = format->p;\n+  mpc_rnd_t crnd = format->round_towards_zero ? MPC_RNDZZ : MPC_RNDNN;\n+  mpc_t m0, m1;\n+\n+  mpc_init2 (m0, prec);\n+  mpc_init2 (m1, prec);\n+  mpfr_from_real (mpc_realref (m0), arg0_real, GMP_RNDN);\n+  mpfr_from_real (mpc_imagref (m0), arg0_imag, GMP_RNDN);\n+  mpfr_from_real (mpc_realref (m1), arg1_real, GMP_RNDN);\n+  mpfr_from_real (mpc_imagref (m1), arg1_imag, GMP_RNDN);\n+  mpfr_clear_flags ();\n+  bool inexact = func (m0, m0, m1, crnd);\n+  bool ok = do_mpc_ckconv (result_real, result_imag, m0, inexact, format);\n+  mpc_clear (m0);\n+  mpc_clear (m1);\n+\n+  return ok;\n+}\n+\n+/* Try to evaluate:\n+\n+      *RESULT = logb (*ARG)\n+\n+   in format FORMAT.  Return true on success.  */\n+\n+static bool\n+fold_const_logb (real_value *result, const real_value *arg,\n+\t\t const real_format *format)\n+{\n+  switch (arg->cl)\n+    {\n+    case rvc_nan:\n+      /* If arg is +-NaN, then return it.  */\n+      *result = *arg;\n+      return true;\n+\n+    case rvc_inf:\n+      /* If arg is +-Inf, then return +Inf.  */\n+      *result = *arg;\n+      result->sign = 0;\n+      return true;\n+\n+    case rvc_zero:\n+      /* Zero may set errno and/or raise an exception.  */\n+      return false;\n+\n+    case rvc_normal:\n+      /* For normal numbers, proceed iff radix == 2.  In GCC,\n+\t normalized significands are in the range [0.5, 1.0).  We\n+\t want the exponent as if they were [1.0, 2.0) so get the\n+\t exponent and subtract 1.  */\n+      if (format->b == 2)\n+\t{\n+\t  real_from_integer (result, format, REAL_EXP (arg) - 1, SIGNED);\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+  gcc_unreachable ();\n+}\n+\n+/* Try to evaluate:\n+\n+      *RESULT = significand (*ARG)\n+\n+   in format FORMAT.  Return true on success.  */\n+\n+static bool\n+fold_const_significand (real_value *result, const real_value *arg,\n+\t\t\tconst real_format *format)\n+{\n+  switch (arg->cl)\n+    {\n+    case rvc_zero:\n+    case rvc_nan:\n+    case rvc_inf:\n+      /* If arg is +-0, +-Inf or +-NaN, then return it.  */\n+      *result = *arg;\n+      return true;\n+\n+    case rvc_normal:\n+      /* For normal numbers, proceed iff radix == 2.  */\n+      if (format->b == 2)\n+\t{\n+\t  *result = *arg;\n+\t  /* In GCC, normalized significands are in the range [0.5, 1.0).\n+\t     We want them to be [1.0, 2.0) so set the exponent to 1.  */\n+\t  SET_REAL_EXP (result, 1);\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+  gcc_unreachable ();\n+}\n+\n+/* Try to evaluate:\n+\n+      *RESULT = f (*ARG)\n+\n+   where FORMAT is the format of *ARG and PRECISION is the number of\n+   significant bits in the result.  Return true on success.  */\n+\n+static bool\n+fold_const_conversion (wide_int *result,\n+\t\t       void (*fn) (real_value *, format_helper,\n+\t\t\t\t   const real_value *),\n+\t\t       const real_value *arg, unsigned int precision,\n+\t\t       const real_format *format)\n+{\n+  if (!real_isfinite (arg))\n+    return false;\n+\n+  real_value rounded;\n+  fn (&rounded, format, arg);\n+\n+  bool fail = false;\n+  *result = real_to_integer (&rounded, &fail, precision);\n+  return !fail;\n+}\n+\n+/* Try to evaluate:\n+\n+      *RESULT = pow (*ARG0, *ARG1)\n+\n+   in format FORMAT.  Return true on success.  */\n+\n+static bool\n+fold_const_pow (real_value *result, const real_value *arg0,\n+\t\tconst real_value *arg1, const real_format *format)\n+{\n+  if (do_mpfr_arg2 (result, mpfr_pow, arg0, arg1, format))\n+    return true;\n+\n+  /* Check for an integer exponent.  */\n+  REAL_VALUE_TYPE cint1;\n+  HOST_WIDE_INT n1 = real_to_integer (arg1);\n+  real_from_integer (&cint1, VOIDmode, n1, SIGNED);\n+  /* Attempt to evaluate pow at compile-time, unless this should\n+     raise an exception.  */\n+  if (real_identical (arg1, &cint1)\n+      && (n1 > 0\n+\t  || (!flag_trapping_math && !flag_errno_math)\n+\t  || !real_equal (arg0, &dconst0)))\n+    {\n+      bool inexact = real_powi (result, format, arg0, n1);\n+      if (flag_unsafe_math_optimizations || !inexact)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Try to evaluate:\n+\n+      *RESULT = ldexp (*ARG0, ARG1)\n+\n+   in format FORMAT.  Return true on success.  */\n+\n+static bool\n+fold_const_builtin_load_exponent (real_value *result, const real_value *arg0,\n+\t\t\t\t  const wide_int_ref &arg1,\n+\t\t\t\t  const real_format *format)\n+{\n+  /* Bound the maximum adjustment to twice the range of the\n+     mode's valid exponents.  Use abs to ensure the range is\n+     positive as a sanity check.  */\n+  int max_exp_adj = 2 * labs (format->emax - format->emin);\n+\n+  /* The requested adjustment must be inside this range.  This\n+     is a preliminary cap to avoid things like overflow, we\n+     may still fail to compute the result for other reasons.  */\n+  if (wi::les_p (arg1, -max_exp_adj) || wi::ges_p (arg1, max_exp_adj))\n+    return false;\n+\n+  REAL_VALUE_TYPE initial_result;\n+  real_ldexp (&initial_result, arg0, arg1.to_shwi ());\n+\n+  /* Ensure we didn't overflow.  */\n+  if (real_isinf (&initial_result))\n+    return false;\n+\n+  /* Only proceed if the target mode can hold the\n+     resulting value.  */\n+  *result = real_value_truncate (format, initial_result);\n+  return real_equal (&initial_result, result);\n+}\n+\n+/* Try to evaluate:\n+\n+      *RESULT = FN (*ARG)\n+\n+   in format FORMAT.  Return true on success.  */\n+\n+static bool\n+fold_const_call_ss (real_value *result, built_in_function fn,\n+\t\t    const real_value *arg, const real_format *format)\n+{\n+  switch (fn)\n+    {\n+    CASE_FLT_FN (BUILT_IN_SQRT):\n+      return (real_compare (GE_EXPR, arg, &dconst0)\n+\t      && do_mpfr_arg1 (result, mpfr_sqrt, arg, format));\n+\n+    CASE_FLT_FN (BUILT_IN_CBRT):\n+      return do_mpfr_arg1 (result, mpfr_cbrt, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_ASIN):\n+      return (real_compare (GE_EXPR, arg, &dconstm1)\n+\t      && real_compare (LE_EXPR, arg, &dconst1)\n+\t      && do_mpfr_arg1 (result, mpfr_asin, arg, format));\n+\n+    CASE_FLT_FN (BUILT_IN_ACOS):\n+      return (real_compare (GE_EXPR, arg, &dconstm1)\n+\t      && real_compare (LE_EXPR, arg, &dconst1)\n+\t      && do_mpfr_arg1 (result, mpfr_acos, arg, format));\n+\n+    CASE_FLT_FN (BUILT_IN_ATAN):\n+      return do_mpfr_arg1 (result, mpfr_atan, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_ASINH):\n+      return do_mpfr_arg1 (result, mpfr_asinh, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_ACOSH):\n+      return (real_compare (GE_EXPR, arg, &dconst1)\n+\t      && do_mpfr_arg1 (result, mpfr_acosh, arg, format));\n+\n+    CASE_FLT_FN (BUILT_IN_ATANH):\n+      return (real_compare (GE_EXPR, arg, &dconstm1)\n+\t      && real_compare (LE_EXPR, arg, &dconst1)\n+\t      && do_mpfr_arg1 (result, mpfr_atanh, arg, format));\n+\n+    CASE_FLT_FN (BUILT_IN_SIN):\n+      return do_mpfr_arg1 (result, mpfr_sin, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_COS):\n+      return do_mpfr_arg1 (result, mpfr_cos, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_TAN):\n+      return do_mpfr_arg1 (result, mpfr_tan, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_SINH):\n+      return do_mpfr_arg1 (result, mpfr_sinh, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_COSH):\n+      return do_mpfr_arg1 (result, mpfr_cosh, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_TANH):\n+      return do_mpfr_arg1 (result, mpfr_tanh, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_ERF):\n+      return do_mpfr_arg1 (result, mpfr_erf, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_ERFC):\n+      return do_mpfr_arg1 (result, mpfr_erfc, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_TGAMMA):\n+      return do_mpfr_arg1 (result, mpfr_gamma, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_EXP):\n+      return do_mpfr_arg1 (result, mpfr_exp, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_EXP2):\n+      return do_mpfr_arg1 (result, mpfr_exp2, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_EXP10):\n+    CASE_FLT_FN (BUILT_IN_POW10):\n+      return do_mpfr_arg1 (result, mpfr_exp10, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_EXPM1):\n+      return do_mpfr_arg1 (result, mpfr_expm1, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_LOG):\n+      return (real_compare (GT_EXPR, arg, &dconst0)\n+\t      && do_mpfr_arg1 (result, mpfr_log, arg, format));\n+\n+    CASE_FLT_FN (BUILT_IN_LOG2):\n+      return (real_compare (GT_EXPR, arg, &dconst0)\n+\t      && do_mpfr_arg1 (result, mpfr_log2, arg, format));\n+\n+    CASE_FLT_FN (BUILT_IN_LOG10):\n+      return (real_compare (GT_EXPR, arg, &dconst0)\n+\t      && do_mpfr_arg1 (result, mpfr_log10, arg, format));\n+\n+    CASE_FLT_FN (BUILT_IN_LOG1P):\n+      return (real_compare (GT_EXPR, arg, &dconstm1)\n+\t      && do_mpfr_arg1 (result, mpfr_log1p, arg, format));\n+\n+    CASE_FLT_FN (BUILT_IN_J0):\n+      return do_mpfr_arg1 (result, mpfr_j0, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_J1):\n+      return do_mpfr_arg1 (result, mpfr_j1, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_Y0):\n+      return (real_compare (GT_EXPR, arg, &dconst0)\n+\t      && do_mpfr_arg1 (result, mpfr_y0, arg, format));\n+\n+    CASE_FLT_FN (BUILT_IN_Y1):\n+      return (real_compare (GT_EXPR, arg, &dconst0)\n+\t      && do_mpfr_arg1 (result, mpfr_y1, arg, format));\n+\n+    CASE_FLT_FN (BUILT_IN_FLOOR):\n+      if (!REAL_VALUE_ISNAN (*arg) || !flag_errno_math)\n+\t{\n+\t  real_floor (result, format, arg);\n+\t  return true;\n+\t}\n+      return false;\n+\n+    CASE_FLT_FN (BUILT_IN_CEIL):\n+      if (!REAL_VALUE_ISNAN (*arg) || !flag_errno_math)\n+\t{\n+\t  real_ceil (result, format, arg);\n+\t  return true;\n+\t}\n+      return false;\n+\n+    CASE_FLT_FN (BUILT_IN_TRUNC):\n+      real_trunc (result, format, arg);\n+      return true;\n+\n+    CASE_FLT_FN (BUILT_IN_ROUND):\n+      if (!REAL_VALUE_ISNAN (*arg) || !flag_errno_math)\n+\t{\n+\t  real_round (result, format, arg);\n+\t  return true;\n+\t}\n+      return false;\n+\n+    CASE_FLT_FN (BUILT_IN_LOGB):\n+      return fold_const_logb (result, arg, format);\n+\n+    CASE_FLT_FN (BUILT_IN_SIGNIFICAND):\n+      return fold_const_significand (result, arg, format);\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Try to evaluate:\n+\n+      *RESULT = FN (*ARG)\n+\n+   where FORMAT is the format of ARG and PRECISION is the number of\n+   significant bits in the result.  Return true on success.  */\n+\n+static bool\n+fold_const_call_ss (wide_int *result, built_in_function fn,\n+\t\t    const real_value *arg, unsigned int precision,\n+\t\t    const real_format *format)\n+{\n+  switch (fn)\n+    {\n+    CASE_FLT_FN (BUILT_IN_SIGNBIT):\n+      if (real_isneg (arg))\n+\t*result = wi::one (precision);\n+      else\n+\t*result = wi::zero (precision);\n+      return true;\n+\n+    CASE_FLT_FN (BUILT_IN_ILOGB):\n+      /* For ilogb we don't know FP_ILOGB0, so only handle normal values.\n+\t Proceed iff radix == 2.  In GCC, normalized significands are in\n+\t the range [0.5, 1.0).  We want the exponent as if they were\n+\t [1.0, 2.0) so get the exponent and subtract 1.  */\n+      if (arg->cl == rvc_normal && format->b == 2)\n+\t{\n+\t  *result = wi::shwi (REAL_EXP (arg) - 1, precision);\n+\t  return true;\n+\t}\n+      return false;\n+\n+    CASE_FLT_FN (BUILT_IN_ICEIL):\n+    CASE_FLT_FN (BUILT_IN_LCEIL):\n+    CASE_FLT_FN (BUILT_IN_LLCEIL):\n+      return fold_const_conversion (result, real_ceil, arg,\n+\t\t\t\t    precision, format);\n+\n+    CASE_FLT_FN (BUILT_IN_LFLOOR):\n+    CASE_FLT_FN (BUILT_IN_IFLOOR):\n+    CASE_FLT_FN (BUILT_IN_LLFLOOR):\n+      return fold_const_conversion (result, real_floor, arg,\n+\t\t\t\t    precision, format);\n+\n+    CASE_FLT_FN (BUILT_IN_IROUND):\n+    CASE_FLT_FN (BUILT_IN_LROUND):\n+    CASE_FLT_FN (BUILT_IN_LLROUND):\n+      return fold_const_conversion (result, real_round, arg,\n+\t\t\t\t    precision, format);\n+\n+    CASE_FLT_FN (BUILT_IN_IRINT):\n+    CASE_FLT_FN (BUILT_IN_LRINT):\n+    CASE_FLT_FN (BUILT_IN_LLRINT):\n+      /* Not yet folded to a constant.  */\n+      return false;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Try to evaluate:\n+\n+      RESULT = FN (*ARG)\n+\n+   where FORMAT is the format of ARG and of the real and imaginary parts\n+   of RESULT, passed as RESULT_REAL and RESULT_IMAG respectively.  Return\n+   true on success.  */\n+\n+static bool\n+fold_const_call_cs (real_value *result_real, real_value *result_imag,\n+\t\t    built_in_function fn, const real_value *arg,\n+\t\t    const real_format *format)\n+{\n+  switch (fn)\n+    {\n+    CASE_FLT_FN (BUILT_IN_CEXPI):\n+      /* cexpi(x+yi) = cos(x)+sin(y)*i.  */\n+      return do_mpfr_sincos (result_imag, result_real, arg, format);\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Try to evaluate:\n+\n+      *RESULT = fn (ARG)\n+\n+   where FORMAT is the format of RESULT and of the real and imaginary parts\n+   of ARG, passed as ARG_REAL and ARG_IMAG respectively.  Return true on\n+   success.  */\n+\n+static bool\n+fold_const_call_sc (real_value *result, built_in_function fn,\n+\t\t    const real_value *arg_real, const real_value *arg_imag,\n+\t\t    const real_format *format)\n+{\n+  switch (fn)\n+    {\n+    CASE_FLT_FN (BUILT_IN_CABS):\n+      return do_mpfr_arg2 (result, mpfr_hypot, arg_real, arg_imag, format);\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Try to evaluate:\n+\n+      RESULT = fn (ARG)\n+\n+   where FORMAT is the format of the real and imaginary parts of RESULT\n+   (RESULT_REAL and RESULT_IMAG) and of ARG (ARG_REAL and ARG_IMAG).\n+   Return true on success.  */\n+\n+static bool\n+fold_const_call_cc (real_value *result_real, real_value *result_imag,\n+\t\t    built_in_function fn, const real_value *arg_real,\n+\t\t    const real_value *arg_imag, const real_format *format)\n+{\n+  switch (fn)\n+    {\n+    CASE_FLT_FN (BUILT_IN_CCOS):\n+      return do_mpc_arg1 (result_real, result_imag, mpc_cos,\n+\t\t\t  arg_real, arg_imag, format);\n+\n+    CASE_FLT_FN (BUILT_IN_CCOSH):\n+      return do_mpc_arg1 (result_real, result_imag, mpc_cosh,\n+\t\t\t  arg_real, arg_imag, format);\n+\n+    CASE_FLT_FN (BUILT_IN_CPROJ):\n+      if (real_isinf (arg_real) || real_isinf (arg_imag))\n+\t{\n+\t  real_inf (result_real);\n+\t  *result_imag = dconst0;\n+\t  result_imag->sign = arg_imag->sign;\n+\t}\n+      else\n+\t{\n+\t  *result_real = *arg_real;\n+\t  *result_imag = *arg_imag;\n+\t}\n+      return true;\n+\n+    CASE_FLT_FN (BUILT_IN_CSIN):\n+      return do_mpc_arg1 (result_real, result_imag, mpc_sin,\n+\t\t\t  arg_real, arg_imag, format);\n+\n+    CASE_FLT_FN (BUILT_IN_CSINH):\n+      return do_mpc_arg1 (result_real, result_imag, mpc_sinh,\n+\t\t\t  arg_real, arg_imag, format);\n+\n+    CASE_FLT_FN (BUILT_IN_CTAN):\n+      return do_mpc_arg1 (result_real, result_imag, mpc_tan,\n+\t\t\t  arg_real, arg_imag, format);\n+\n+    CASE_FLT_FN (BUILT_IN_CTANH):\n+      return do_mpc_arg1 (result_real, result_imag, mpc_tanh,\n+\t\t\t  arg_real, arg_imag, format);\n+\n+    CASE_FLT_FN (BUILT_IN_CLOG):\n+      return do_mpc_arg1 (result_real, result_imag, mpc_log,\n+\t\t\t  arg_real, arg_imag, format);\n+\n+    CASE_FLT_FN (BUILT_IN_CSQRT):\n+      return do_mpc_arg1 (result_real, result_imag, mpc_sqrt,\n+\t\t\t  arg_real, arg_imag, format);\n+\n+    CASE_FLT_FN (BUILT_IN_CASIN):\n+      return do_mpc_arg1 (result_real, result_imag, mpc_asin,\n+\t\t\t  arg_real, arg_imag, format);\n+\n+    CASE_FLT_FN (BUILT_IN_CACOS):\n+      return do_mpc_arg1 (result_real, result_imag, mpc_acos,\n+\t\t\t  arg_real, arg_imag, format);\n+\n+    CASE_FLT_FN (BUILT_IN_CATAN):\n+      return do_mpc_arg1 (result_real, result_imag, mpc_atan,\n+\t\t\t  arg_real, arg_imag, format);\n+\n+    CASE_FLT_FN (BUILT_IN_CASINH):\n+      return do_mpc_arg1 (result_real, result_imag, mpc_asinh,\n+\t\t\t  arg_real, arg_imag, format);\n+\n+    CASE_FLT_FN (BUILT_IN_CACOSH):\n+      return do_mpc_arg1 (result_real, result_imag, mpc_acosh,\n+\t\t\t  arg_real, arg_imag, format);\n+\n+    CASE_FLT_FN (BUILT_IN_CATANH):\n+      return do_mpc_arg1 (result_real, result_imag, mpc_atanh,\n+\t\t\t  arg_real, arg_imag, format);\n+\n+    CASE_FLT_FN (BUILT_IN_CEXP):\n+      return do_mpc_arg1 (result_real, result_imag, mpc_exp,\n+\t\t\t  arg_real, arg_imag, format);\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Try to fold FN (ARG) to a constant.  Return the constant on success,\n+   otherwise return null.  TYPE is the type of the return value.  */\n+\n+tree\n+fold_const_call (built_in_function fn, tree type, tree arg)\n+{\n+  machine_mode mode = TYPE_MODE (type);\n+  machine_mode arg_mode = TYPE_MODE (TREE_TYPE (arg));\n+\n+  if (real_cst_p (arg))\n+    {\n+      gcc_checking_assert (SCALAR_FLOAT_MODE_P (arg_mode));\n+      if (mode == arg_mode)\n+\t{\n+\t  /* real -> real.  */\n+\t  REAL_VALUE_TYPE result;\n+\t  if (fold_const_call_ss (&result, fn, TREE_REAL_CST_PTR (arg),\n+\t\t\t\t  REAL_MODE_FORMAT (mode)))\n+\t    return build_real (type, result);\n+\t}\n+      else if (COMPLEX_MODE_P (mode)\n+\t       && GET_MODE_INNER (mode) == arg_mode)\n+\t{\n+\t  /* real -> complex real.  */\n+\t  REAL_VALUE_TYPE result_real, result_imag;\n+\t  if (fold_const_call_cs (&result_real, &result_imag, fn,\n+\t\t\t\t  TREE_REAL_CST_PTR (arg),\n+\t\t\t\t  REAL_MODE_FORMAT (arg_mode)))\n+\t    return build_complex (type,\n+\t\t\t\t  build_real (TREE_TYPE (type), result_real),\n+\t\t\t\t  build_real (TREE_TYPE (type), result_imag));\n+\t}\n+      else if (INTEGRAL_TYPE_P (type))\n+\t{\n+\t  /* real -> int.  */\n+\t  wide_int result;\n+\t  if (fold_const_call_ss (&result, fn,\n+\t\t\t\t  TREE_REAL_CST_PTR (arg),\n+\t\t\t\t  TYPE_PRECISION (type),\n+\t\t\t\t  REAL_MODE_FORMAT (arg_mode)))\n+\t    return wide_int_to_tree (type, result);\n+\t}\n+      return NULL_TREE;\n+    }\n+\n+  if (complex_cst_p (arg))\n+    {\n+      gcc_checking_assert (COMPLEX_MODE_P (arg_mode));\n+      machine_mode inner_mode = GET_MODE_INNER (arg_mode);\n+      tree argr = TREE_REALPART (arg);\n+      tree argi = TREE_IMAGPART (arg);\n+      if (mode == arg_mode\n+\t  && real_cst_p (argr)\n+\t  && real_cst_p (argi))\n+\t{\n+\t  /* complex real -> complex real.  */\n+\t  REAL_VALUE_TYPE result_real, result_imag;\n+\t  if (fold_const_call_cc (&result_real, &result_imag, fn,\n+\t\t\t\t  TREE_REAL_CST_PTR (argr),\n+\t\t\t\t  TREE_REAL_CST_PTR (argi),\n+\t\t\t\t  REAL_MODE_FORMAT (inner_mode)))\n+\t    return build_complex (type,\n+\t\t\t\t  build_real (TREE_TYPE (type), result_real),\n+\t\t\t\t  build_real (TREE_TYPE (type), result_imag));\n+\t}\n+      if (mode == inner_mode\n+\t  && real_cst_p (argr)\n+\t  && real_cst_p (argi))\n+\t{\n+\t  /* complex real -> real.  */\n+\t  REAL_VALUE_TYPE result;\n+\t  if (fold_const_call_sc (&result, fn,\n+\t\t\t\t  TREE_REAL_CST_PTR (argr),\n+\t\t\t\t  TREE_REAL_CST_PTR (argi),\n+\t\t\t\t  REAL_MODE_FORMAT (inner_mode)))\n+\t    return build_real (type, result);\n+\t}\n+      return NULL_TREE;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Try to evaluate:\n+\n+      *RESULT = FN (*ARG0, *ARG1)\n+\n+   in format FORMAT.  Return true on success.  */\n+\n+static bool\n+fold_const_call_sss (real_value *result, built_in_function fn,\n+\t\t     const real_value *arg0, const real_value *arg1,\n+\t\t     const real_format *format)\n+{\n+  switch (fn)\n+    {\n+    CASE_FLT_FN (BUILT_IN_DREM):\n+    CASE_FLT_FN (BUILT_IN_REMAINDER):\n+      return do_mpfr_arg2 (result, mpfr_remainder, arg0, arg1, format);\n+\n+    CASE_FLT_FN (BUILT_IN_ATAN2):\n+      return do_mpfr_arg2 (result, mpfr_atan2, arg0, arg1, format);\n+\n+    CASE_FLT_FN (BUILT_IN_FDIM):\n+      return do_mpfr_arg2 (result, mpfr_dim, arg0, arg1, format);\n+\n+    CASE_FLT_FN (BUILT_IN_HYPOT):\n+      return do_mpfr_arg2 (result, mpfr_hypot, arg0, arg1, format);\n+\n+    CASE_FLT_FN (BUILT_IN_COPYSIGN):\n+      *result = *arg0;\n+      real_copysign (result, arg1);\n+      return true;\n+\n+    CASE_FLT_FN (BUILT_IN_FMIN):\n+      return do_mpfr_arg2 (result, mpfr_min, arg0, arg1, format);\n+\n+    CASE_FLT_FN (BUILT_IN_FMAX):\n+      return do_mpfr_arg2 (result, mpfr_max, arg0, arg1, format);\n+\n+    CASE_FLT_FN (BUILT_IN_POW):\n+      return fold_const_pow (result, arg0, arg1, format);\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Try to evaluate:\n+\n+      *RESULT = FN (*ARG0, ARG1)\n+\n+   where FORMAT is the format of *RESULT and *ARG0.  Return true on\n+   success.  */\n+\n+static bool\n+fold_const_call_sss (real_value *result, built_in_function fn,\n+\t\t     const real_value *arg0, const wide_int_ref &arg1,\n+\t\t     const real_format *format)\n+{\n+  switch (fn)\n+    {\n+    CASE_FLT_FN (BUILT_IN_LDEXP):\n+      return fold_const_builtin_load_exponent (result, arg0, arg1, format);\n+\n+    CASE_FLT_FN (BUILT_IN_SCALBN):\n+    CASE_FLT_FN (BUILT_IN_SCALBLN):\n+      return (format->b == 2\n+\t      && fold_const_builtin_load_exponent (result, arg0, arg1,\n+\t\t\t\t\t\t   format));\n+\n+    CASE_FLT_FN (BUILT_IN_POWI):\n+      real_powi (result, format, arg0, arg1.to_shwi ());\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Try to evaluate:\n+\n+      *RESULT = FN (ARG0, *ARG1)\n+\n+   where FORMAT is the format of *RESULT and *ARG1.  Return true on\n+   success.  */\n+\n+static bool\n+fold_const_call_sss (real_value *result, built_in_function fn,\n+\t\t     const wide_int_ref &arg0, const real_value *arg1,\n+\t\t     const real_format *format)\n+{\n+  switch (fn)\n+    {\n+    CASE_FLT_FN (BUILT_IN_JN):\n+      return do_mpfr_arg2 (result, mpfr_jn, arg0, arg1, format);\n+\n+    CASE_FLT_FN (BUILT_IN_YN):\n+      return (real_compare (GT_EXPR, arg1, &dconst0)\n+\t      && do_mpfr_arg2 (result, mpfr_yn, arg0, arg1, format));\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Try to evaluate:\n+\n+      RESULT = fn (ARG0, ARG1)\n+\n+   where FORMAT is the format of the real and imaginary parts of RESULT\n+   (RESULT_REAL and RESULT_IMAG), of ARG0 (ARG0_REAL and ARG0_IMAG)\n+   and of ARG1 (ARG1_REAL and ARG1_IMAG).  Return true on success.  */\n+\n+static bool\n+fold_const_call_ccc (real_value *result_real, real_value *result_imag,\n+\t\t     built_in_function fn, const real_value *arg0_real,\n+\t\t     const real_value *arg0_imag, const real_value *arg1_real,\n+\t\t     const real_value *arg1_imag, const real_format *format)\n+{\n+  switch (fn)\n+    {\n+    CASE_FLT_FN (BUILT_IN_CPOW):\n+      return do_mpc_arg2 (result_real, result_imag, mpc_pow,\n+\t\t\t  arg0_real, arg0_imag, arg1_real, arg1_imag, format);\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Try to fold FN (ARG0, ARG1) to a constant.  Return the constant on success,\n+   otherwise return null.  TYPE is the type of the return value.  */\n+\n+tree\n+fold_const_call (built_in_function fn, tree type, tree arg0, tree arg1)\n+{\n+  machine_mode mode = TYPE_MODE (type);\n+  machine_mode arg0_mode = TYPE_MODE (TREE_TYPE (arg0));\n+  machine_mode arg1_mode = TYPE_MODE (TREE_TYPE (arg1));\n+\n+  if (arg0_mode == arg1_mode\n+      && real_cst_p (arg0)\n+      && real_cst_p (arg1))\n+    {\n+      gcc_checking_assert (SCALAR_FLOAT_MODE_P (arg0_mode));\n+      if (mode == arg0_mode)\n+\t{\n+\t  /* real, real -> real.  */\n+\t  REAL_VALUE_TYPE result;\n+\t  if (fold_const_call_sss (&result, fn, TREE_REAL_CST_PTR (arg0),\n+\t\t\t\t   TREE_REAL_CST_PTR (arg1),\n+\t\t\t\t   REAL_MODE_FORMAT (mode)))\n+\t    return build_real (type, result);\n+\t}\n+      return NULL_TREE;\n+    }\n+\n+  if (real_cst_p (arg0)\n+      && integer_cst_p (arg1))\n+    {\n+      gcc_checking_assert (SCALAR_FLOAT_MODE_P (arg0_mode));\n+      if (mode == arg0_mode)\n+\t{\n+\t  /* real, int -> real.  */\n+\t  REAL_VALUE_TYPE result;\n+\t  if (fold_const_call_sss (&result, fn, TREE_REAL_CST_PTR (arg0),\n+\t\t\t\t   arg1, REAL_MODE_FORMAT (mode)))\n+\t    return build_real (type, result);\n+\t}\n+      return NULL_TREE;\n+    }\n+\n+  if (integer_cst_p (arg0)\n+      && real_cst_p (arg1))\n+    {\n+      gcc_checking_assert (SCALAR_FLOAT_MODE_P (arg1_mode));\n+      if (mode == arg1_mode)\n+\t{\n+\t  /* int, real -> real.  */\n+\t  REAL_VALUE_TYPE result;\n+\t  if (fold_const_call_sss (&result, fn, arg0,\n+\t\t\t\t   TREE_REAL_CST_PTR (arg1),\n+\t\t\t\t   REAL_MODE_FORMAT (mode)))\n+\t    return build_real (type, result);\n+\t}\n+      return NULL_TREE;\n+    }\n+\n+  if (arg0_mode == arg1_mode\n+      && complex_cst_p (arg0)\n+      && complex_cst_p (arg1))\n+    {\n+      gcc_checking_assert (COMPLEX_MODE_P (arg0_mode));\n+      machine_mode inner_mode = GET_MODE_INNER (arg0_mode);\n+      tree arg0r = TREE_REALPART (arg0);\n+      tree arg0i = TREE_IMAGPART (arg0);\n+      tree arg1r = TREE_REALPART (arg1);\n+      tree arg1i = TREE_IMAGPART (arg1);\n+      if (mode == arg0_mode\n+\t  && real_cst_p (arg0r)\n+\t  && real_cst_p (arg0i)\n+\t  && real_cst_p (arg1r)\n+\t  && real_cst_p (arg1i))\n+\t{\n+\t  /* complex real, complex real -> complex real.  */\n+\t  REAL_VALUE_TYPE result_real, result_imag;\n+\t  if (fold_const_call_ccc (&result_real, &result_imag, fn,\n+\t\t\t\t   TREE_REAL_CST_PTR (arg0r),\n+\t\t\t\t   TREE_REAL_CST_PTR (arg0i),\n+\t\t\t\t   TREE_REAL_CST_PTR (arg1r),\n+\t\t\t\t   TREE_REAL_CST_PTR (arg1i),\n+\t\t\t\t   REAL_MODE_FORMAT (inner_mode)))\n+\t    return build_complex (type,\n+\t\t\t\t  build_real (TREE_TYPE (type), result_real),\n+\t\t\t\t  build_real (TREE_TYPE (type), result_imag));\n+\t}\n+      return NULL_TREE;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Try to evaluate:\n+\n+      *RESULT = FN (*ARG0, *ARG1, *ARG2)\n+\n+   in format FORMAT.  Return true on success.  */\n+\n+static bool\n+fold_const_call_ssss (real_value *result, built_in_function fn,\n+\t\t      const real_value *arg0, const real_value *arg1,\n+\t\t      const real_value *arg2, const real_format *format)\n+{\n+  switch (fn)\n+    {\n+    CASE_FLT_FN (BUILT_IN_FMA):\n+      return do_mpfr_arg3 (result, mpfr_fma, arg0, arg1, arg2, format);\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Try to fold FN (ARG0, ARG1, ARG2) to a constant.  Return the constant on\n+   success, otherwise return null.  TYPE is the type of the return value.  */\n+\n+tree\n+fold_const_call (built_in_function fn, tree type, tree arg0, tree arg1,\n+\t\t tree arg2)\n+{\n+  machine_mode mode = TYPE_MODE (type);\n+  machine_mode arg0_mode = TYPE_MODE (TREE_TYPE (arg0));\n+  machine_mode arg1_mode = TYPE_MODE (TREE_TYPE (arg1));\n+  machine_mode arg2_mode = TYPE_MODE (TREE_TYPE (arg2));\n+\n+  if (arg0_mode == arg1_mode\n+      && arg0_mode == arg2_mode\n+      && real_cst_p (arg0)\n+      && real_cst_p (arg1)\n+      && real_cst_p (arg2))\n+    {\n+      gcc_checking_assert (SCALAR_FLOAT_MODE_P (arg0_mode));\n+      if (mode == arg0_mode)\n+\t{\n+\t  /* real, real, real -> real.  */\n+\t  REAL_VALUE_TYPE result;\n+\t  if (fold_const_call_ssss (&result, fn, TREE_REAL_CST_PTR (arg0),\n+\t\t\t\t    TREE_REAL_CST_PTR (arg1),\n+\t\t\t\t    TREE_REAL_CST_PTR (arg2),\n+\t\t\t\t    REAL_MODE_FORMAT (mode)))\n+\t    return build_real (type, result);\n+\t}\n+      return NULL_TREE;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Fold a fma operation with arguments ARG[012].  */\n+\n+tree\n+fold_fma (location_t, tree type, tree arg0, tree arg1, tree arg2)\n+{\n+  REAL_VALUE_TYPE result;\n+  if (real_cst_p (arg0)\n+      && real_cst_p (arg1)\n+      && real_cst_p (arg2)\n+      && do_mpfr_arg3 (&result, mpfr_fma, TREE_REAL_CST_PTR (arg0),\n+\t\t       TREE_REAL_CST_PTR (arg1), TREE_REAL_CST_PTR (arg2),\n+\t\t       REAL_MODE_FORMAT (TYPE_MODE (type))))\n+    return build_real (type, result);\n+\n+  return NULL_TREE;\n+}"}, {"sha": "6befc9bc10d70f4a75e387ec67c3d65055d493a0", "filename": "gcc/fold-const-call.h", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2Ffold-const-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2Ffold-const-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.h?ref=5c1a2e639a26f1582318ac6f547a8819ea7c6034", "patch": "@@ -0,0 +1,28 @@\n+/* Fold calls to built-in and internal functions with constant arguments.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_FOLD_CONST_CALL_H\n+#define GCC_FOLD_CONST_CALL_H\n+\n+tree fold_const_call (built_in_function, tree, tree);\n+tree fold_const_call (built_in_function, tree, tree, tree);\n+tree fold_const_call (built_in_function, tree, tree, tree, tree);\n+tree fold_fma (location_t, tree, tree, tree, tree);\n+\n+#endif"}, {"sha": "ee9b34910df33f223a03674b8ce56cda1c14bd7a", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5c1a2e639a26f1582318ac6f547a8819ea7c6034", "patch": "@@ -57,6 +57,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"alias.h\"\n #include \"fold-const.h\"\n+#include \"fold-const-call.h\"\n #include \"stor-layout.h\"\n #include \"calls.h\"\n #include \"tree-iterator.h\""}, {"sha": "e5f10c8d9e80a1aa7ed5f6dcbbc573a6bb22c2bc", "filename": "gcc/realmpfr.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2Frealmpfr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2Frealmpfr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frealmpfr.c?ref=5c1a2e639a26f1582318ac6f547a8819ea7c6034", "patch": "@@ -54,11 +54,12 @@ mpfr_from_real (mpfr_ptr m, const REAL_VALUE_TYPE *r, mp_rnd_t rndmode)\n   gcc_assert (ret == 0);\n }\n \n-/* Convert from MPFR to REAL_VALUE_TYPE, for a given type TYPE and rounding\n-   mode RNDMODE.  TYPE is only relevant if M is a NaN.  */\n+/* Convert from MPFR to REAL_VALUE_TYPE, for a given format FORMAT and\n+   rounding mode RNDMODE.  FORMAT is only relevant if M is a NaN.  */\n \n void\n-real_from_mpfr (REAL_VALUE_TYPE *r, mpfr_srcptr m, tree type, mp_rnd_t rndmode)\n+real_from_mpfr (REAL_VALUE_TYPE *r, mpfr_srcptr m, const real_format *format,\n+\t\tmp_rnd_t rndmode)\n {\n   /* We use a string as an intermediate type.  */\n   char buf[128], *rstr;\n@@ -75,7 +76,7 @@ real_from_mpfr (REAL_VALUE_TYPE *r, mpfr_srcptr m, tree type, mp_rnd_t rndmode)\n \n   if (mpfr_nan_p (m))\n     {\n-      real_nan (r, \"\", 1, TYPE_MODE (type));\n+      real_nan (r, \"\", 1, format);\n       return;\n     }\n \n@@ -100,3 +101,13 @@ real_from_mpfr (REAL_VALUE_TYPE *r, mpfr_srcptr m, tree type, mp_rnd_t rndmode)\n   real_from_string (r, buf);\n }\n \n+/* Convert from MPFR to REAL_VALUE_TYPE, for a given type TYPE and rounding\n+   mode RNDMODE.  TYPE is only relevant if M is a NaN.  */\n+\n+void\n+real_from_mpfr (REAL_VALUE_TYPE *r, mpfr_srcptr m, tree type, mp_rnd_t rndmode)\n+{\n+  real_from_mpfr (r, m, type ? REAL_MODE_FORMAT (TYPE_MODE (type)) : NULL,\n+\t\t  rndmode);\n+}\n+"}, {"sha": "7e70db2500a0553f91109d72776bb494214650f6", "filename": "gcc/realmpfr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2Frealmpfr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1a2e639a26f1582318ac6f547a8819ea7c6034/gcc%2Frealmpfr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frealmpfr.h?ref=5c1a2e639a26f1582318ac6f547a8819ea7c6034", "patch": "@@ -28,6 +28,8 @@\n    responsible for initializing and clearing the MPFR parameter.  */\n \n extern void real_from_mpfr (REAL_VALUE_TYPE *, mpfr_srcptr, tree, mp_rnd_t);\n+extern void real_from_mpfr (REAL_VALUE_TYPE *, mpfr_srcptr,\n+\t\t\t    const real_format *, mp_rnd_t);\n extern void mpfr_from_real (mpfr_ptr, const REAL_VALUE_TYPE *, mp_rnd_t);\n \n #endif /* ! GCC_REALGMP_H */"}]}