{"sha": "664b4b1e0467168064ebb0d2fbcd75d3a3e87155", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY0YjRiMWUwNDY3MTY4MDY0ZWJiMGQyZmJjZDc1ZDNhM2U4NzE1NQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-29T04:54:53Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-29T04:54:53Z"}, "message": "(duplicate_decls): If have char *foo () and void *foo (...),\n\nmake just a pedwarn.  Add locals oldtype, newtype.\n\nNot that previous log entry was a mistake.\n\nFrom-SVN: r1333", "tree": {"sha": "b152cdc870ffd2a9d24c9d78b0f738d33230a718", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b152cdc870ffd2a9d24c9d78b0f738d33230a718"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/664b4b1e0467168064ebb0d2fbcd75d3a3e87155", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/664b4b1e0467168064ebb0d2fbcd75d3a3e87155", "html_url": "https://github.com/Rust-GCC/gccrs/commit/664b4b1e0467168064ebb0d2fbcd75d3a3e87155", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/664b4b1e0467168064ebb0d2fbcd75d3a3e87155/comments", "author": null, "committer": null, "parents": [{"sha": "944e5f7770b38d605bedabd5091376dea893684e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/944e5f7770b38d605bedabd5091376dea893684e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/944e5f7770b38d605bedabd5091376dea893684e"}], "stats": {"total": 61, "additions": 35, "deletions": 26}, "files": [{"sha": "c78d88873a651334d25455031d888d8c7f197df8", "filename": "gcc/c-decl.c", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/664b4b1e0467168064ebb0d2fbcd75d3a3e87155/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/664b4b1e0467168064ebb0d2fbcd75d3a3e87155/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=664b4b1e0467168064ebb0d2fbcd75d3a3e87155", "patch": "@@ -1116,9 +1116,11 @@ duplicate_decls (newdecl, olddecl)\n   int types_match = comptypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl));\n   int new_is_definition = (TREE_CODE (newdecl) == FUNCTION_DECL\n \t\t\t   && DECL_INITIAL (newdecl) != 0);\n+  tree oldtype = TREE_TYPE (olddecl);\n+  tree newtype = TREE_TYPE (newdecl);\n \n-  if (TREE_CODE (TREE_TYPE (newdecl)) == ERROR_MARK\n-      || TREE_CODE (TREE_TYPE (olddecl)) == ERROR_MARK)\n+  if (TREE_CODE (newtype) == ERROR_MARK\n+      || TREE_CODE (oldtype) == ERROR_MARK)\n     types_match = 0;\n \n   /* New decl is completely inconsistent with the old one =>\n@@ -1231,45 +1233,50 @@ duplicate_decls (newdecl, olddecl)\n   else if (!types_match\n \t   && TREE_CODE (olddecl) == FUNCTION_DECL\n \t   && TREE_CODE (newdecl) == FUNCTION_DECL\n-\t   && TREE_CODE (TREE_TYPE (olddecl)) == POINTER_TYPE\n-\t   && TREE_CODE (TREE_TYPE (newdecl)) == POINTER_TYPE\n-\t   && ((TREE_TYPE (TREE_TYPE (newdecl)) == void_type_node\n-\t\t&& TYPE_ARG_TYPES (TREE_TYPE (olddecl)) == 0\n-\t\t&& TREE_TYPE (TREE_TYPE (olddecl)) == char_type_node)\n+\t   && TREE_CODE (TREE_TYPE (oldtype)) == POINTER_TYPE\n+\t   && TREE_CODE (TREE_TYPE (newtype)) == POINTER_TYPE\n+\t   && ((TREE_TYPE (TREE_TYPE (newtype)) == void_type_node\n+\t\t&& TYPE_ARG_TYPES (oldtype) == 0\n+\t\t&& self_promoting_args_p (TYPE_ARG_TYPES (newtype))\n+\t\t&& TREE_TYPE (TREE_TYPE (oldtype)) == char_type_node)\n \t       ||\n-\t       (TREE_TYPE (TREE_TYPE (newdecl)) == char_type_node\n-\t\t&& TYPE_ARG_TYPES (TREE_TYPE (newdecl)) == 0\n-\t\t&& TREE_TYPE (TREE_TYPE (olddecl)) == void_type_node)))\n+\t       (TREE_TYPE (TREE_TYPE (newtype)) == char_type_node\n+\t\t&& TYPE_ARG_TYPES (newtype) == 0\n+\t\t&& self_promoting_args_p (TYPE_ARG_TYPES (oldtype))\n+\t\t&& TREE_TYPE (TREE_TYPE (oldtype)) == void_type_node)))\n     {\n       if (pedantic)\n \tpedwarn_with_decl (newdecl, \"conflicting types for `%s'\");\n+      /* Make sure we keep void * as ret type, not char *.  */\n+      if (TREE_TYPE (TREE_TYPE (oldtype)) == void_type_node)\n+\tTREE_TYPE (newdecl) = newtype = oldtype;\n     }\n   else if (!types_match\n \t   /* Permit char *foo (int, ...); followed by char *foo ();\n \t      if not pedantic.  */\n \t   && ! (TREE_CODE (olddecl) == FUNCTION_DECL\n \t\t && ! pedantic\n \t\t /* Return types must still match.  */\n-\t\t && comptypes (TREE_TYPE (TREE_TYPE (olddecl)),\n-\t\t\t       TREE_TYPE (TREE_TYPE (newdecl)))\n-\t\t && TYPE_ARG_TYPES (TREE_TYPE (newdecl)) == 0))\n+\t\t && comptypes (TREE_TYPE (oldtype),\n+\t\t\t       TREE_TYPE (newtype))\n+\t\t && TYPE_ARG_TYPES (newtype) == 0))\n     {\n       error_with_decl (newdecl, \"conflicting types for `%s'\");\n       /* Check for function type mismatch\n \t involving an empty arglist vs a nonempty one.  */\n       if (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t  && comptypes (TREE_TYPE (TREE_TYPE (olddecl)),\n-\t\t\tTREE_TYPE (TREE_TYPE (newdecl)))\n-\t  && ((TYPE_ARG_TYPES (TREE_TYPE (olddecl)) == 0\n+\t  && comptypes (TREE_TYPE (oldtype),\n+\t\t\tTREE_TYPE (newtype))\n+\t  && ((TYPE_ARG_TYPES (oldtype) == 0\n \t       && DECL_INITIAL (olddecl) == 0)\n \t      ||\n-\t      (TYPE_ARG_TYPES (TREE_TYPE (newdecl)) == 0\n+\t      (TYPE_ARG_TYPES (newtype) == 0\n \t       && DECL_INITIAL (newdecl) == 0)))\n \t{\n \t  /* Classify the problem further.  */\n-\t  register tree t = TYPE_ARG_TYPES (TREE_TYPE (olddecl));\n+\t  register tree t = TYPE_ARG_TYPES (oldtype);\n \t  if (t == 0)\n-\t    t = TYPE_ARG_TYPES (TREE_TYPE (newdecl));\n+\t    t = TYPE_ARG_TYPES (newtype);\n \t  for (; t; t = TREE_CHAIN (t))\n \t    {\n \t      register tree type = TREE_VALUE (t);\n@@ -1305,15 +1312,15 @@ duplicate_decls (newdecl, olddecl)\n \t}\n       else if (TREE_CODE (olddecl) == FUNCTION_DECL\n \t       && DECL_INITIAL (olddecl) != 0\n-\t       && TYPE_ARG_TYPES (TREE_TYPE (olddecl)) == 0\n-\t       && TYPE_ARG_TYPES (TREE_TYPE (newdecl)) != 0)\n+\t       && TYPE_ARG_TYPES (oldtype) == 0\n+\t       && TYPE_ARG_TYPES (newtype) != 0)\n \t{\n \t  register tree type, parm;\n \t  register int nargs;\n \t  /* Prototype decl follows defn w/o prototype.  */\n \n-\t  for (parm = TYPE_ACTUAL_ARG_TYPES (TREE_TYPE (olddecl)),\n-\t       type = TYPE_ARG_TYPES (TREE_TYPE (newdecl)),\n+\t  for (parm = TYPE_ACTUAL_ARG_TYPES (oldtype),\n+\t       type = TYPE_ARG_TYPES (newtype),\n \t       nargs = 1;\n \t       (TREE_VALUE (parm) != void_type_node\n \t\t|| TREE_VALUE (type) != void_type_node);\n@@ -1383,16 +1390,18 @@ duplicate_decls (newdecl, olddecl)\n     }\n \n   /* Copy all the DECL_... slots specified in the new decl\n-     except for any that we copy here from the old type.  */\n+     except for any that we copy here from the old type.\n+\n+     Past this point, we don't change OLDTYPE and NEWTYPE\n+     even if we change the types of NEWDECL and OLDDECL.  */\n \n   if (types_match)\n     {\n-      tree oldtype = TREE_TYPE (olddecl);\n       /* Merge the data types specified in the two decls.  */\n       if (TREE_CODE (newdecl) != FUNCTION_DECL || !DECL_BUILT_IN (olddecl))\n \tTREE_TYPE (newdecl)\n \t  = TREE_TYPE (olddecl)\n-\t    = common_type (TREE_TYPE (newdecl), TREE_TYPE (olddecl));\n+\t    = common_type (newtype, oldtype);\n \n       /* Lay the type out, unless already done.  */\n       if (oldtype != TREE_TYPE (newdecl))"}]}