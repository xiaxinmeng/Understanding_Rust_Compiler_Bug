{"sha": "c94843d2422bdf77e2f86fad0329838f36773b43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk0ODQzZDI0MjJiZGY3N2UyZjg2ZmFkMDMyOTgzOGYzNjc3M2I0Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:08:44Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:08:44Z"}, "message": "[4/77] Add FOR_EACH iterators for modes\n\nThe new iterators are:\n\n- FOR_EACH_MODE_IN_CLASS: iterate over all the modes in a mode class.\n\n- FOR_EACH_MODE_FROM: iterate over all the modes in a class,\n  starting at a given mode.\n\n- FOR_EACH_WIDER_MODE: iterate over all the modes in a class,\n  starting at the next widest mode after a given mode.\n\n- FOR_EACH_2XWIDER_MODE: same, but considering only modes that\n  are two times wider than the previous mode.\n\n- FOR_EACH_MODE_UNTIL: iterate over all the modes in a class until\n  a given mode is reached.\n\n- FOR_EACH_MODE: iterate over all the modes in a class between\n  two given modes, inclusive of the first but not the second.\n\nThese help with the stronger type checking added by later patches,\nsince every new mode will be in the same class as the previous one.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n            Alan Hayward  <alan.hayward@arm.com>\n            David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* machmode.h (mode_traits): New structure.\n\t(get_narrowest_mode): New function.\n\t(mode_iterator::start): Likewise.\n\t(mode_iterator::iterate_p): Likewise.\n\t(mode_iterator::get_wider): Likewise.\n\t(mode_iterator::get_known_wider): Likewise.\n\t(mode_iterator::get_2xwider): Likewise.\n\t(FOR_EACH_MODE_IN_CLASS): New mode iterator.\n\t(FOR_EACH_MODE): Likewise.\n\t(FOR_EACH_MODE_FROM): Likewise.\n\t(FOR_EACH_MODE_UNTIL): Likewise.\n\t(FOR_EACH_WIDER_MODE): Likewise.\n\t(FOR_EACH_2XWIDER_MODE): Likewise.\n\t* builtins.c (expand_builtin_strlen): Use new mode iterators.\n\t* combine.c (simplify_comparison): Likewise\n\t* config/i386/i386.c (type_natural_mode): Likewise.\n\t* cse.c (cse_insn): Likewise.\n\t* dse.c (find_shift_sequence): Likewise.\n\t* emit-rtl.c (init_derived_machine_modes): Likewise.\n\t(init_emit_once): Likewise.\n\t* explow.c (hard_function_value): Likewise.\n\t* expmed.c (extract_fixed_bit_field_1): Likewise.\n\t(extract_bit_field_1): Likewise.\n\t(expand_divmod): Likewise.\n\t(emit_store_flag_1): Likewise.\n\t* expr.c (init_expr_target): Likewise.\n\t(convert_move): Likewise.\n\t(alignment_for_piecewise_move): Likewise.\n\t(widest_int_mode_for_size): Likewise.\n\t(emit_block_move_via_movmem): Likewise.\n\t(copy_blkmode_to_reg): Likewise.\n\t(set_storage_via_setmem): Likewise.\n\t(compress_float_constant): Likewise.\n\t* omp-low.c (omp_clause_aligned_alignment): Likewise.\n\t* optabs-query.c (get_best_extraction_insn): Likewise.\n\t* optabs.c (expand_binop): Likewise.\n\t(expand_twoval_unop): Likewise.\n\t(expand_twoval_binop): Likewise.\n\t(widen_leading): Likewise.\n\t(widen_bswap): Likewise.\n\t(expand_parity): Likewise.\n\t(expand_unop): Likewise.\n\t(prepare_cmp_insn): Likewise.\n\t(prepare_float_lib_cmp): Likewise.\n\t(expand_float): Likewise.\n\t(expand_fix): Likewise.\n\t(expand_sfix_optab): Likewise.\n\t* postreload.c (move2add_use_add2_insn): Likewise.\n\t* reg-stack.c (reg_to_stack): Likewise.\n\t* reginfo.c (choose_hard_reg_mode): Likewise.\n\t* rtlanal.c (init_num_sign_bit_copies_in_rep): Likewise.\n\t* stor-layout.c (mode_for_size): Likewise.\n\t(smallest_mode_for_size): Likewise.\n\t(mode_for_vector): Likewise.\n\t(finish_bitfield_representative): Likewise.\n\t* tree-ssa-math-opts.c (target_supports_divmod_p): Likewise.\n\t* tree-vect-generic.c (type_for_widest_vector_mode): Likewise.\n\t* tree-vect-stmts.c (vectorizable_conversion): Likewise.\n\t* var-tracking.c (prepare_call_arguments): Likewise.\n\ngcc/ada/\n\t* gcc-interface/misc.c (fp_prec_to_size): Use new mode iterators.\n\t(fp_size_to_prec): Likewise.\n\ngcc/c-family/\n\t* c-common.c (c_common_fixed_point_type_for_size): Use new mode\n\titerators.\n\t* c-cppbuiltin.c (c_cpp_builtins): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251455", "tree": {"sha": "8b8124bc4e42d00aabe44407a57a8b8faa945a60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b8124bc4e42d00aabe44407a57a8b8faa945a60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c94843d2422bdf77e2f86fad0329838f36773b43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c94843d2422bdf77e2f86fad0329838f36773b43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c94843d2422bdf77e2f86fad0329838f36773b43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c94843d2422bdf77e2f86fad0329838f36773b43/comments", "author": null, "committer": null, "parents": [{"sha": "b77d1a175f94eb49f62a02c4a54fe617e1cd3363", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b77d1a175f94eb49f62a02c4a54fe617e1cd3363", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b77d1a175f94eb49f62a02c4a54fe617e1cd3363"}], "stats": {"total": 720, "additions": 420, "deletions": 300}, "files": [{"sha": "7742722c1f43a5682b46392f47c4c85b3e9ed429", "filename": "gcc/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -1,3 +1,67 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+            Alan Hayward  <alan.hayward@arm.com>\n+            David Sherwood  <david.sherwood@arm.com>\n+\n+\t* machmode.h (mode_traits): New structure.\n+\t(get_narrowest_mode): New function.\n+\t(mode_iterator::start): Likewise.\n+\t(mode_iterator::iterate_p): Likewise.\n+\t(mode_iterator::get_wider): Likewise.\n+\t(mode_iterator::get_known_wider): Likewise.\n+\t(mode_iterator::get_2xwider): Likewise.\n+\t(FOR_EACH_MODE_IN_CLASS): New mode iterator.\n+\t(FOR_EACH_MODE): Likewise.\n+\t(FOR_EACH_MODE_FROM): Likewise.\n+\t(FOR_EACH_MODE_UNTIL): Likewise.\n+\t(FOR_EACH_WIDER_MODE): Likewise.\n+\t(FOR_EACH_2XWIDER_MODE): Likewise.\n+\t* builtins.c (expand_builtin_strlen): Use new mode iterators.\n+\t* combine.c (simplify_comparison): Likewise\n+\t* config/i386/i386.c (type_natural_mode): Likewise.\n+\t* cse.c (cse_insn): Likewise.\n+\t* dse.c (find_shift_sequence): Likewise.\n+\t* emit-rtl.c (init_derived_machine_modes): Likewise.\n+\t(init_emit_once): Likewise.\n+\t* explow.c (hard_function_value): Likewise.\n+\t* expmed.c (extract_fixed_bit_field_1): Likewise.\n+\t(extract_bit_field_1): Likewise.\n+\t(expand_divmod): Likewise.\n+\t(emit_store_flag_1): Likewise.\n+\t* expr.c (init_expr_target): Likewise.\n+\t(convert_move): Likewise.\n+\t(alignment_for_piecewise_move): Likewise.\n+\t(widest_int_mode_for_size): Likewise.\n+\t(emit_block_move_via_movmem): Likewise.\n+\t(copy_blkmode_to_reg): Likewise.\n+\t(set_storage_via_setmem): Likewise.\n+\t(compress_float_constant): Likewise.\n+\t* omp-low.c (omp_clause_aligned_alignment): Likewise.\n+\t* optabs-query.c (get_best_extraction_insn): Likewise.\n+\t* optabs.c (expand_binop): Likewise.\n+\t(expand_twoval_unop): Likewise.\n+\t(expand_twoval_binop): Likewise.\n+\t(widen_leading): Likewise.\n+\t(widen_bswap): Likewise.\n+\t(expand_parity): Likewise.\n+\t(expand_unop): Likewise.\n+\t(prepare_cmp_insn): Likewise.\n+\t(prepare_float_lib_cmp): Likewise.\n+\t(expand_float): Likewise.\n+\t(expand_fix): Likewise.\n+\t(expand_sfix_optab): Likewise.\n+\t* postreload.c (move2add_use_add2_insn): Likewise.\n+\t* reg-stack.c (reg_to_stack): Likewise.\n+\t* reginfo.c (choose_hard_reg_mode): Likewise.\n+\t* rtlanal.c (init_num_sign_bit_copies_in_rep): Likewise.\n+\t* stor-layout.c (mode_for_size): Likewise.\n+\t(smallest_mode_for_size): Likewise.\n+\t(mode_for_vector): Likewise.\n+\t(finish_bitfield_representative): Likewise.\n+\t* tree-ssa-math-opts.c (target_supports_divmod_p): Likewise.\n+\t* tree-vect-generic.c (type_for_widest_vector_mode): Likewise.\n+\t* tree-vect-stmts.c (vectorizable_conversion): Likewise.\n+\t* var-tracking.c (prepare_call_arguments): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "4f7d2bd5ef9553a0b0bd2a29475684aa2fffa0a2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -1,3 +1,10 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+            Alan Hayward  <alan.hayward@arm.com>\n+            David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc-interface/misc.c (fp_prec_to_size): Use new mode iterators.\n+\t(fp_size_to_prec): Likewise.\n+\n 2017-08-29  Martin Liska  <mliska@suse.cz>\n \n \tPR other/39851"}, {"sha": "eaacabd5dcfb6a33993e41ad23bed229c69e233c", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -1313,8 +1313,7 @@ fp_prec_to_size (int prec)\n {\n   machine_mode mode;\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_FLOAT)\n     if (GET_MODE_PRECISION (mode) == prec)\n       return GET_MODE_BITSIZE (mode);\n \n@@ -1328,8 +1327,7 @@ fp_size_to_prec (int size)\n {\n   machine_mode mode;\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_FLOAT)\n     if (GET_MODE_BITSIZE (mode) == size)\n       return GET_MODE_PRECISION (mode);\n "}, {"sha": "2f361bfde4b4b25e6ff755ae2638fc02f8290ec0", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -2792,7 +2792,7 @@ expand_builtin_strlen (tree exp, rtx target,\n       tree src = CALL_EXPR_ARG (exp, 0);\n       rtx src_reg;\n       rtx_insn *before_strlen;\n-      machine_mode insn_mode = target_mode;\n+      machine_mode insn_mode;\n       enum insn_code icode = CODE_FOR_nothing;\n       unsigned int align;\n \n@@ -2820,13 +2820,11 @@ expand_builtin_strlen (tree exp, rtx target,\n \treturn NULL_RTX;\n \n       /* Bail out if we can't compute strlen in the right mode.  */\n-      while (insn_mode != VOIDmode)\n+      FOR_EACH_MODE_FROM (insn_mode, target_mode)\n \t{\n \t  icode = optab_handler (strlen_optab, insn_mode);\n \t  if (icode != CODE_FOR_nothing)\n \t    break;\n-\n-\t  insn_mode = GET_MODE_WIDER_MODE (insn_mode);\n \t}\n       if (insn_mode == VOIDmode)\n \treturn NULL_RTX;"}, {"sha": "44857d6197bccc3e6107acb0ff925be8c070a663", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -1,3 +1,11 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+            Alan Hayward  <alan.hayward@arm.com>\n+            David Sherwood  <david.sherwood@arm.com>\n+\n+\t* c-common.c (c_common_fixed_point_type_for_size): Use new mode\n+\titerators.\n+\t* c-cppbuiltin.c (c_cpp_builtins): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "b4ee2ed2bc825436141f47375bf61c69f98cc0d4", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -2149,13 +2149,14 @@ tree\n c_common_fixed_point_type_for_size (unsigned int ibit, unsigned int fbit,\n \t\t\t\t    int unsignedp, int satp)\n {\n-  machine_mode mode;\n+  enum mode_class mclass;\n   if (ibit == 0)\n-    mode = unsignedp ? UQQmode : QQmode;\n+    mclass = unsignedp ? MODE_UFRACT : MODE_FRACT;\n   else\n-    mode = unsignedp ? UHAmode : HAmode;\n+    mclass = unsignedp ? MODE_UACCUM : MODE_ACCUM;\n \n-  for (; mode != VOIDmode; mode = GET_MODE_WIDER_MODE (mode))\n+  machine_mode mode;\n+  FOR_EACH_MODE_IN_CLASS (mode, mclass)\n     if (GET_MODE_IBIT (mode) >= ibit && GET_MODE_FBIT (mode) >= fbit)\n       break;\n "}, {"sha": "4f397a18f4595d6ac921242cefa51965c82cfcf0", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -1186,9 +1186,8 @@ c_cpp_builtins (cpp_reader *pfile)\n   if (flag_building_libgcc)\n     {\n       /* Properties of floating-point modes for libgcc2.c.  */\n-      for (machine_mode mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n-\t   mode != VOIDmode;\n-\t   mode = GET_MODE_WIDER_MODE (mode))\n+      machine_mode mode;\n+      FOR_EACH_MODE_IN_CLASS (mode, MODE_FLOAT)\n \t{\n \t  const char *name = GET_MODE_NAME (mode);\n \t  char *macro_name"}, {"sha": "46212c5ea8455e26303af5d494fe7cb2652e6b81", "filename": "gcc/combine.c", "status": "modified", "additions": 73, "deletions": 69, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -11830,9 +11830,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t    }\n \n \t  else if (c0 == c1)\n-\t    for (tmode = GET_CLASS_NARROWEST_MODE\n-\t\t (GET_MODE_CLASS (GET_MODE (op0)));\n-\t\t tmode != GET_MODE (op0); tmode = GET_MODE_WIDER_MODE (tmode))\n+\t    FOR_EACH_MODE_UNTIL (tmode, GET_MODE (op0))\n \t      if ((unsigned HOST_WIDE_INT) c0 == GET_MODE_MASK (tmode))\n \t\t{\n \t\t  op0 = gen_lowpart_or_truncate (tmode, inner_op0);\n@@ -12704,75 +12702,81 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n   if (mode != VOIDmode && GET_MODE_CLASS (mode) == MODE_INT\n       && GET_MODE_SIZE (mode) < UNITS_PER_WORD\n       && ! have_insn_for (COMPARE, mode))\n-    for (tmode = GET_MODE_WIDER_MODE (mode);\n-\t (tmode != VOIDmode && HWI_COMPUTABLE_MODE_P (tmode));\n-\t tmode = GET_MODE_WIDER_MODE (tmode))\n-      if (have_insn_for (COMPARE, tmode))\n-\t{\n-\t  int zero_extended;\n-\n-\t  /* If this is a test for negative, we can make an explicit\n-\t     test of the sign bit.  Test this first so we can use\n-\t     a paradoxical subreg to extend OP0.  */\n+    FOR_EACH_WIDER_MODE (tmode, mode)\n+      {\n+\tif (!HWI_COMPUTABLE_MODE_P (tmode))\n+\t  break;\n+\tif (have_insn_for (COMPARE, tmode))\n+\t  {\n+\t    int zero_extended;\n \n-\t  if (op1 == const0_rtx && (code == LT || code == GE)\n-\t      && HWI_COMPUTABLE_MODE_P (mode))\n-\t    {\n-\t      unsigned HOST_WIDE_INT sign\n-\t\t= HOST_WIDE_INT_1U << (GET_MODE_BITSIZE (mode) - 1);\n-\t      op0 = simplify_gen_binary (AND, tmode,\n-\t\t\t\t\t gen_lowpart (tmode, op0),\n-\t\t\t\t\t gen_int_mode (sign, tmode));\n-\t      code = (code == LT) ? NE : EQ;\n-\t      break;\n-\t    }\n+\t    /* If this is a test for negative, we can make an explicit\n+\t       test of the sign bit.  Test this first so we can use\n+\t       a paradoxical subreg to extend OP0.  */\n \n-\t  /* If the only nonzero bits in OP0 and OP1 are those in the\n-\t     narrower mode and this is an equality or unsigned comparison,\n-\t     we can use the wider mode.  Similarly for sign-extended\n-\t     values, in which case it is true for all comparisons.  */\n-\t  zero_extended = ((code == EQ || code == NE\n-\t\t\t    || code == GEU || code == GTU\n-\t\t\t    || code == LEU || code == LTU)\n-\t\t\t   && (nonzero_bits (op0, tmode)\n-\t\t\t       & ~GET_MODE_MASK (mode)) == 0\n-\t\t\t   && ((CONST_INT_P (op1)\n-\t\t\t\t|| (nonzero_bits (op1, tmode)\n-\t\t\t\t    & ~GET_MODE_MASK (mode)) == 0)));\n-\n-\t  if (zero_extended\n-\t      || ((num_sign_bit_copies (op0, tmode)\n-\t\t   > (unsigned int) (GET_MODE_PRECISION (tmode)\n-\t\t\t\t     - GET_MODE_PRECISION (mode)))\n-\t\t  && (num_sign_bit_copies (op1, tmode)\n-\t\t      > (unsigned int) (GET_MODE_PRECISION (tmode)\n-\t\t\t\t\t- GET_MODE_PRECISION (mode)))))\n-\t    {\n-\t      /* If OP0 is an AND and we don't have an AND in MODE either,\n-\t\t make a new AND in the proper mode.  */\n-\t      if (GET_CODE (op0) == AND\n-\t\t  && !have_insn_for (AND, mode))\n+\t    if (op1 == const0_rtx && (code == LT || code == GE)\n+\t\t&& HWI_COMPUTABLE_MODE_P (mode))\n+\t      {\n+\t\tunsigned HOST_WIDE_INT sign\n+\t\t  = HOST_WIDE_INT_1U << (GET_MODE_BITSIZE (mode) - 1);\n \t\top0 = simplify_gen_binary (AND, tmode,\n-\t\t\t\t\t   gen_lowpart (tmode,\n-\t\t\t\t\t\t\tXEXP (op0, 0)),\n-\t\t\t\t\t   gen_lowpart (tmode,\n-\t\t\t\t\t\t\tXEXP (op0, 1)));\n-\t      else\n-\t\t{\n-\t\t  if (zero_extended)\n-\t\t    {\n-\t\t      op0 = simplify_gen_unary (ZERO_EXTEND, tmode, op0, mode);\n-\t\t      op1 = simplify_gen_unary (ZERO_EXTEND, tmode, op1, mode);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      op0 = simplify_gen_unary (SIGN_EXTEND, tmode, op0, mode);\n-\t\t      op1 = simplify_gen_unary (SIGN_EXTEND, tmode, op1, mode);\n-\t\t    }\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n+\t\t\t\t\t   gen_lowpart (tmode, op0),\n+\t\t\t\t\t   gen_int_mode (sign, tmode));\n+\t\tcode = (code == LT) ? NE : EQ;\n+\t\tbreak;\n+\t      }\n+\n+\t    /* If the only nonzero bits in OP0 and OP1 are those in the\n+\t       narrower mode and this is an equality or unsigned comparison,\n+\t       we can use the wider mode.  Similarly for sign-extended\n+\t       values, in which case it is true for all comparisons.  */\n+\t    zero_extended = ((code == EQ || code == NE\n+\t\t\t      || code == GEU || code == GTU\n+\t\t\t      || code == LEU || code == LTU)\n+\t\t\t     && (nonzero_bits (op0, tmode)\n+\t\t\t\t & ~GET_MODE_MASK (mode)) == 0\n+\t\t\t     && ((CONST_INT_P (op1)\n+\t\t\t\t  || (nonzero_bits (op1, tmode)\n+\t\t\t\t      & ~GET_MODE_MASK (mode)) == 0)));\n+\n+\t    if (zero_extended\n+\t\t|| ((num_sign_bit_copies (op0, tmode)\n+\t\t     > (unsigned int) (GET_MODE_PRECISION (tmode)\n+\t\t\t\t       - GET_MODE_PRECISION (mode)))\n+\t\t    && (num_sign_bit_copies (op1, tmode)\n+\t\t\t> (unsigned int) (GET_MODE_PRECISION (tmode)\n+\t\t\t\t\t  - GET_MODE_PRECISION (mode)))))\n+\t      {\n+\t\t/* If OP0 is an AND and we don't have an AND in MODE either,\n+\t\t   make a new AND in the proper mode.  */\n+\t\tif (GET_CODE (op0) == AND\n+\t\t    && !have_insn_for (AND, mode))\n+\t\t  op0 = simplify_gen_binary (AND, tmode,\n+\t\t\t\t\t     gen_lowpart (tmode,\n+\t\t\t\t\t\t\t  XEXP (op0, 0)),\n+\t\t\t\t\t     gen_lowpart (tmode,\n+\t\t\t\t\t\t\t  XEXP (op0, 1)));\n+\t\telse\n+\t\t  {\n+\t\t    if (zero_extended)\n+\t\t      {\n+\t\t\top0 = simplify_gen_unary (ZERO_EXTEND, tmode,\n+\t\t\t\t\t\t  op0, mode);\n+\t\t\top1 = simplify_gen_unary (ZERO_EXTEND, tmode,\n+\t\t\t\t\t\t  op1, mode);\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\top0 = simplify_gen_unary (SIGN_EXTEND, tmode,\n+\t\t\t\t\t\t  op0, mode);\n+\t\t\top1 = simplify_gen_unary (SIGN_EXTEND, tmode,\n+\t\t\t\t\t\t  op1, mode);\n+\t\t      }\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n \n   /* We may have changed the comparison operands.  Re-canonicalize.  */\n   if (swap_commutative_operands_p (op0, op1))"}, {"sha": "f087bce291ba1cb015aeccea4b61e4afca6ba956", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -9110,7 +9110,7 @@ type_natural_mode (const_tree type, const CUMULATIVE_ARGS *cum,\n \t    mode = MIN_MODE_VECTOR_INT;\n \n \t  /* Get the mode which has this inner mode and number of units.  */\n-\t  for (; mode != VOIDmode; mode = GET_MODE_WIDER_MODE (mode))\n+\t  FOR_EACH_MODE_FROM (mode, mode)\n \t    if (GET_MODE_NUNITS (mode) == TYPE_VECTOR_SUBPARTS (type)\n \t\t&& GET_MODE_INNER (mode) == innermode)\n \t      {"}, {"sha": "58572e6a093a78c2247c7ef28479ac67a488f24e", "filename": "gcc/cse.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -4845,12 +4845,11 @@ cse_insn (rtx_insn *insn)\n \t{\n \t  machine_mode wider_mode;\n \n-\t  for (wider_mode = GET_MODE_WIDER_MODE (mode);\n-\t       wider_mode != VOIDmode\n-\t       && GET_MODE_PRECISION (wider_mode) <= BITS_PER_WORD\n-\t       && src_related == 0;\n-\t       wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+\t  FOR_EACH_WIDER_MODE (wider_mode, mode)\n \t    {\n+\t      if (GET_MODE_PRECISION (wider_mode) > BITS_PER_WORD)\n+\t\tbreak;\n+\n \t      struct table_elt *const_elt\n \t\t= lookup (src_const, HASH (src_const, wider_mode), wider_mode);\n \n@@ -4864,6 +4863,9 @@ cse_insn (rtx_insn *insn)\n \t\t    src_related = gen_lowpart (mode, const_elt->exp);\n \t\t    break;\n \t\t  }\n+\n+\t      if (src_related != 0)\n+\t\tbreak;\n \t    }\n \t}\n \n@@ -4880,10 +4882,11 @@ cse_insn (rtx_insn *insn)\n \t  machine_mode tmode;\n \t  rtx new_and = gen_rtx_AND (VOIDmode, NULL_RTX, XEXP (src, 1));\n \n-\t  for (tmode = GET_MODE_WIDER_MODE (mode);\n-\t       GET_MODE_SIZE (tmode) <= UNITS_PER_WORD;\n-\t       tmode = GET_MODE_WIDER_MODE (tmode))\n+\t  FOR_EACH_WIDER_MODE (tmode, mode)\n \t    {\n+\t      if (GET_MODE_SIZE (tmode) > UNITS_PER_WORD)\n+\t\tbreak;\n+\n \t      rtx inner = gen_lowpart (tmode, XEXP (src, 0));\n \t      struct table_elt *larger_elt;\n \n@@ -4930,12 +4933,13 @@ cse_insn (rtx_insn *insn)\n \t  PUT_CODE (memory_extend_rtx, extend_op);\n \t  XEXP (memory_extend_rtx, 0) = src;\n \n-\t  for (tmode = GET_MODE_WIDER_MODE (mode);\n-\t       GET_MODE_SIZE (tmode) <= UNITS_PER_WORD;\n-\t       tmode = GET_MODE_WIDER_MODE (tmode))\n+\t  FOR_EACH_WIDER_MODE (tmode, mode)\n \t    {\n \t      struct table_elt *larger_elt;\n \n+\t      if (GET_MODE_SIZE (tmode) > UNITS_PER_WORD)\n+\t\tbreak;\n+\n \t      PUT_MODE (memory_extend_rtx, tmode);\n \t      larger_elt = lookup (memory_extend_rtx,\n \t\t\t\t   HASH (memory_extend_rtx, tmode), tmode);"}, {"sha": "937e6eabd624d8770582d07c0c8d3071fd0da241", "filename": "gcc/dse.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -1583,15 +1583,17 @@ find_shift_sequence (int access_size,\n      justify the value we want to read but is available in one insn on\n      the machine.  */\n \n-  for (new_mode = smallest_mode_for_size (access_size * BITS_PER_UNIT,\n-\t\t\t\t\t  MODE_INT);\n-       GET_MODE_BITSIZE (new_mode) <= BITS_PER_WORD;\n-       new_mode = GET_MODE_WIDER_MODE (new_mode))\n+  FOR_EACH_MODE_FROM (new_mode,\n+\t\t      smallest_mode_for_size (access_size * BITS_PER_UNIT,\n+\t\t\t\t\t      MODE_INT))\n     {\n       rtx target, new_reg, new_lhs;\n       rtx_insn *shift_seq, *insn;\n       int cost;\n \n+      if (GET_MODE_BITSIZE (new_mode) > BITS_PER_WORD)\n+\tbreak;\n+\n       /* If a constant was stored into memory, try to simplify it here,\n \t otherwise the cost of the shift might preclude this optimization\n \t e.g. at -Os, even when no actual shift will be needed.  */"}, {"sha": "3856ac02d4ea9baba511704ea4923c132e434be0", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 20, "deletions": 55, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -5867,9 +5867,8 @@ init_derived_machine_modes (void)\n   byte_mode = VOIDmode;\n   word_mode = VOIDmode;\n \n-  for (machine_mode mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  machine_mode mode;\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n     {\n       if (GET_MODE_BITSIZE (mode) == BITS_PER_UNIT\n \t  && byte_mode == VOIDmode)\n@@ -5951,23 +5950,17 @@ init_emit_once (void)\n       const REAL_VALUE_TYPE *const r =\n \t(i == 0 ? &dconst0 : i == 1 ? &dconst1 : &dconst2);\n \n-      for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n-\t   mode != VOIDmode;\n-\t   mode = GET_MODE_WIDER_MODE (mode))\n+      FOR_EACH_MODE_IN_CLASS (mode, MODE_FLOAT)\n \tconst_tiny_rtx[i][(int) mode] =\n \t  const_double_from_real_value (*r, mode);\n \n-      for (mode = GET_CLASS_NARROWEST_MODE (MODE_DECIMAL_FLOAT);\n-\t   mode != VOIDmode;\n-\t   mode = GET_MODE_WIDER_MODE (mode))\n+      FOR_EACH_MODE_IN_CLASS (mode, MODE_DECIMAL_FLOAT)\n \tconst_tiny_rtx[i][(int) mode] =\n \t  const_double_from_real_value (*r, mode);\n \n       const_tiny_rtx[i][(int) VOIDmode] = GEN_INT (i);\n \n-      for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t   mode != VOIDmode;\n-\t   mode = GET_MODE_WIDER_MODE (mode))\n+      FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n \tconst_tiny_rtx[i][(int) mode] = GEN_INT (i);\n \n       for (mode = MIN_MODE_PARTIAL_INT;\n@@ -5978,52 +5971,40 @@ init_emit_once (void)\n \n   const_tiny_rtx[3][(int) VOIDmode] = constm1_rtx;\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n     const_tiny_rtx[3][(int) mode] = constm1_rtx;\n \n   for (mode = MIN_MODE_PARTIAL_INT;\n        mode <= MAX_MODE_PARTIAL_INT;\n        mode = (machine_mode)((int)(mode) + 1))\n     const_tiny_rtx[3][(int) mode] = constm1_rtx;\n-      \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_COMPLEX_INT);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_COMPLEX_INT)\n     {\n       rtx inner = const_tiny_rtx[0][(int)GET_MODE_INNER (mode)];\n       const_tiny_rtx[0][(int) mode] = gen_rtx_CONCAT (mode, inner, inner);\n     }\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_COMPLEX_FLOAT);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_COMPLEX_FLOAT)\n     {\n       rtx inner = const_tiny_rtx[0][(int)GET_MODE_INNER (mode)];\n       const_tiny_rtx[0][(int) mode] = gen_rtx_CONCAT (mode, inner, inner);\n     }\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_INT);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_INT)\n     {\n       const_tiny_rtx[0][(int) mode] = gen_const_vector (mode, 0);\n       const_tiny_rtx[1][(int) mode] = gen_const_vector (mode, 1);\n       const_tiny_rtx[3][(int) mode] = gen_const_vector (mode, 3);\n     }\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_FLOAT);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_FLOAT)\n     {\n       const_tiny_rtx[0][(int) mode] = gen_const_vector (mode, 0);\n       const_tiny_rtx[1][(int) mode] = gen_const_vector (mode, 1);\n     }\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FRACT);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_FRACT)\n     {\n       FCONST0 (mode).data.high = 0;\n       FCONST0 (mode).data.low = 0;\n@@ -6032,9 +6013,7 @@ init_emit_once (void)\n \t\t\t\t      FCONST0 (mode), mode);\n     }\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_UFRACT);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_UFRACT)\n     {\n       FCONST0 (mode).data.high = 0;\n       FCONST0 (mode).data.low = 0;\n@@ -6043,9 +6022,7 @@ init_emit_once (void)\n \t\t\t\t      FCONST0 (mode), mode);\n     }\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_ACCUM);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_ACCUM)\n     {\n       FCONST0 (mode).data.high = 0;\n       FCONST0 (mode).data.low = 0;\n@@ -6065,9 +6042,7 @@ init_emit_once (void)\n \t\t\t\t      FCONST1 (mode), mode);\n     }\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_UACCUM);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_UACCUM)\n     {\n       FCONST0 (mode).data.high = 0;\n       FCONST0 (mode).data.low = 0;\n@@ -6087,31 +6062,23 @@ init_emit_once (void)\n \t\t\t\t      FCONST1 (mode), mode);\n     }\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_FRACT);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_FRACT)\n     {\n       const_tiny_rtx[0][(int) mode] = gen_const_vector (mode, 0);\n     }\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_UFRACT);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_UFRACT)\n     {\n       const_tiny_rtx[0][(int) mode] = gen_const_vector (mode, 0);\n     }\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_ACCUM);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_ACCUM)\n     {\n       const_tiny_rtx[0][(int) mode] = gen_const_vector (mode, 0);\n       const_tiny_rtx[1][(int) mode] = gen_const_vector (mode, 1);\n     }\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_UACCUM);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_UACCUM)\n     {\n       const_tiny_rtx[0][(int) mode] = gen_const_vector (mode, 0);\n       const_tiny_rtx[1][(int) mode] = gen_const_vector (mode, 1);\n@@ -6125,9 +6092,7 @@ init_emit_once (void)\n   if (STORE_FLAG_VALUE == 1)\n     const_tiny_rtx[1][(int) BImode] = const1_rtx;\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_POINTER_BOUNDS);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_POINTER_BOUNDS)\n     {\n       wide_int wi_zero = wi::zero (GET_MODE_PRECISION (mode));\n       const_tiny_rtx[0][mode] = immed_wide_int_const (wi_zero, mode);"}, {"sha": "72fb6828379b5b2733568f9fa2e50bdaaab51e32", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -1912,9 +1912,7 @@ hard_function_value (const_tree valtype, const_tree func, const_tree fntype,\n \t since the value of bytes will then be large enough that no\n \t mode will match anyway.  */\n \n-      for (tmpmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t   tmpmode != VOIDmode;\n-\t   tmpmode = GET_MODE_WIDER_MODE (tmpmode))\n+      FOR_EACH_MODE_IN_CLASS (tmpmode, MODE_INT)\n \t{\n \t  /* Have we found a large enough mode?  */\n \t  if (GET_MODE_SIZE (tmpmode) >= bytes)"}, {"sha": "0219e0dee7692f752f60f77c1021ceecb44ef123", "filename": "gcc/expmed.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -1635,7 +1635,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       else\n \tnew_mode = MIN_MODE_VECTOR_INT;\n \n-      for (; new_mode != VOIDmode ; new_mode = GET_MODE_WIDER_MODE (new_mode))\n+      FOR_EACH_MODE_FROM (new_mode, new_mode)\n \tif (GET_MODE_SIZE (new_mode) == GET_MODE_SIZE (GET_MODE (op0))\n \t    && GET_MODE_UNIT_SIZE (new_mode) == GET_MODE_SIZE (tmode)\n \t    && targetm.vector_mode_supported_p (new_mode))\n@@ -2081,8 +2081,7 @@ extract_fixed_bit_field_1 (machine_mode tmode, rtx op0,\n \n   /* Find the narrowest integer mode that contains the field.  */\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n     if (GET_MODE_BITSIZE (mode) >= bitsize + bitnum)\n       {\n \top0 = convert_to_mode (mode, op0, 0);\n@@ -4146,15 +4145,13 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n   optab2 = (op1_is_pow2 ? optab1\n \t    : (unsignedp ? udivmod_optab : sdivmod_optab));\n \n-  for (compute_mode = mode; compute_mode != VOIDmode;\n-       compute_mode = GET_MODE_WIDER_MODE (compute_mode))\n+  FOR_EACH_MODE_FROM (compute_mode, mode)\n     if (optab_handler (optab1, compute_mode) != CODE_FOR_nothing\n \t|| optab_handler (optab2, compute_mode) != CODE_FOR_nothing)\n       break;\n \n   if (compute_mode == VOIDmode)\n-    for (compute_mode = mode; compute_mode != VOIDmode;\n-\t compute_mode = GET_MODE_WIDER_MODE (compute_mode))\n+    FOR_EACH_MODE_FROM (compute_mode, mode)\n       if (optab_libfunc (optab1, compute_mode)\n \t  || optab_libfunc (optab2, compute_mode))\n \tbreak;\n@@ -5556,8 +5553,7 @@ emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n     }\n \n   mclass = GET_MODE_CLASS (mode);\n-  for (compare_mode = mode; compare_mode != VOIDmode;\n-       compare_mode = GET_MODE_WIDER_MODE (compare_mode))\n+  FOR_EACH_MODE_FROM (compare_mode, mode)\n     {\n      machine_mode optab_mode = mclass == MODE_CC ? CCmode : compare_mode;\n      icode = optab_handler (cstore_optab, optab_mode);"}, {"sha": "cbec00c64aef5e0cbb8f7ec8a977ccb90236917b", "filename": "gcc/expr.c", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -177,12 +177,10 @@ init_expr_target (void)\n \n   mem = gen_rtx_MEM (VOIDmode, gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1));\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_FLOAT)\n     {\n       machine_mode srcmode;\n-      for (srcmode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); srcmode != mode;\n-\t   srcmode = GET_MODE_WIDER_MODE (srcmode))\n+      FOR_EACH_MODE_UNTIL (srcmode, mode)\n \t{\n \t  enum insn_code ic;\n \n@@ -549,8 +547,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n \t  int shift_amount;\n \n \t  /* Search for a mode to convert via.  */\n-\t  for (intermediate = from_mode; intermediate != VOIDmode;\n-\t       intermediate = GET_MODE_WIDER_MODE (intermediate))\n+\t  FOR_EACH_MODE_FROM (intermediate, from_mode)\n \t    if (((can_extend_p (to_mode, intermediate, unsignedp)\n \t\t  != CODE_FOR_nothing)\n \t\t || (GET_MODE_SIZE (to_mode) < GET_MODE_SIZE (intermediate)\n@@ -702,12 +699,14 @@ alignment_for_piecewise_move (unsigned int max_pieces, unsigned int align)\n     {\n       machine_mode tmode, xmode;\n \n-      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT), xmode = tmode;\n-\t   tmode != VOIDmode;\n-\t   xmode = tmode, tmode = GET_MODE_WIDER_MODE (tmode))\n-\tif (GET_MODE_SIZE (tmode) > max_pieces\n-\t    || SLOW_UNALIGNED_ACCESS (tmode, align))\n-\t  break;\n+      xmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+      FOR_EACH_MODE_IN_CLASS (tmode, MODE_INT)\n+\t{\n+\t  if (GET_MODE_SIZE (tmode) > max_pieces\n+\t      || SLOW_UNALIGNED_ACCESS (tmode, align))\n+\t    break;\n+\t  xmode = tmode;\n+\t}\n \n       align = MAX (align, GET_MODE_ALIGNMENT (xmode));\n     }\n@@ -723,8 +722,7 @@ widest_int_mode_for_size (unsigned int size)\n {\n   machine_mode tmode, mode = VOIDmode;\n \n-  for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-       tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n+  FOR_EACH_MODE_IN_CLASS (tmode, MODE_INT)\n     if (GET_MODE_SIZE (tmode) < size)\n       mode = tmode;\n \n@@ -1728,8 +1726,7 @@ emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n      including more than one in the machine description unless\n      the more limited one has some advantage.  */\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n     {\n       enum insn_code code = direct_optab_handler (movmem_optab, mode);\n \n@@ -2790,9 +2787,7 @@ copy_blkmode_to_reg (machine_mode mode, tree src)\n     {\n       /* Find the smallest integer mode large enough to hold the\n \t entire structure.  */\n-      for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t   mode != VOIDmode;\n-\t   mode = GET_MODE_WIDER_MODE (mode))\n+      FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n \t/* Have we found a large enough mode?  */\n \tif (GET_MODE_SIZE (mode) >= bytes)\n \t  break;\n@@ -3048,8 +3043,7 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n \texpected_size = min_size;\n     }\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n     {\n       enum insn_code code = direct_optab_handler (setmem_optab, mode);\n \n@@ -3788,9 +3782,7 @@ compress_float_constant (rtx x, rtx y)\n   else\n     oldcost = set_src_cost (force_const_mem (dstmode, y), dstmode, speed);\n \n-  for (srcmode = GET_CLASS_NARROWEST_MODE (GET_MODE_CLASS (orig_srcmode));\n-       srcmode != orig_srcmode;\n-       srcmode = GET_MODE_WIDER_MODE (srcmode))\n+  FOR_EACH_MODE_UNTIL (srcmode, orig_srcmode)\n     {\n       enum insn_code ic;\n       rtx trunc_y;"}, {"sha": "c272888ebf14be1b85339634414190b5440d8956", "filename": "gcc/machmode.h", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -29,6 +29,44 @@ extern const unsigned short mode_unit_precision[NUM_MACHINE_MODES];\n extern const unsigned char mode_wider[NUM_MACHINE_MODES];\n extern const unsigned char mode_2xwider[NUM_MACHINE_MODES];\n \n+template<typename T>\n+struct mode_traits\n+{\n+  /* For use by the machmode support code only.\n+\n+     There are cases in which the machmode support code needs to forcibly\n+     convert a machine_mode to a specific mode class T, and in which the\n+     context guarantees that this is valid without the need for an assert.\n+     This can be done using:\n+\n+       return typename mode_traits<T>::from_int (mode);\n+\n+     when returning a T and:\n+\n+       res = T (typename mode_traits<T>::from_int (mode));\n+\n+     when assigning to a value RES that must be assignment-compatible\n+     with (but possibly not the same as) T.\n+\n+     Here we use an enum type distinct from machine_mode but with the\n+     same range as machine_mode.  T should have a constructor that\n+     accepts this enum type; it should not have a constructor that\n+     accepts machine_mode.\n+\n+     We use this somewhat indirect approach to avoid too many constructor\n+     calls when the compiler is built with -O0.  For example, even in\n+     unoptimized code, the return statement above would construct the\n+     returned T directly from the numerical value of MODE.  */\n+  enum from_int { dummy = MAX_MACHINE_MODE };\n+};\n+\n+template<>\n+struct mode_traits<machine_mode>\n+{\n+  /* machine_mode itself needs no conversion.  */\n+  typedef machine_mode from_int;\n+};\n+\n /* Get the name of mode MODE as a string.  */\n \n extern const char * const mode_name[NUM_MACHINE_MODES];\n@@ -395,6 +433,16 @@ extern const unsigned char class_narrowest_mode[MAX_MODE_CLASS];\n #define GET_CLASS_NARROWEST_MODE(CLASS) \\\n   ((machine_mode) class_narrowest_mode[CLASS])\n \n+/* Return the narrowest mode in T's class.  */\n+\n+template<typename T>\n+inline T\n+get_narrowest_mode (T mode)\n+{\n+  return typename mode_traits<T>::from_int\n+    (class_narrowest_mode[GET_MODE_CLASS (mode)]);\n+}\n+\n /* Define the integer modes whose sizes are BITS_PER_UNIT and BITS_PER_WORD\n    and the mode whose class is Pmode and whose size is POINTER_SIZE.  */\n \n@@ -425,4 +473,95 @@ struct int_n_data_t {\n extern bool int_n_enabled_p[NUM_INT_N_ENTS];\n extern const int_n_data_t int_n_data[NUM_INT_N_ENTS];\n \n+namespace mode_iterator\n+{\n+  /* Start mode iterator *ITER at the first mode in class MCLASS, if any.  */\n+\n+  inline void\n+  start (machine_mode *iter, enum mode_class mclass)\n+  {\n+    *iter = GET_CLASS_NARROWEST_MODE (mclass);\n+  }\n+\n+  /* Return true if mode iterator *ITER has not reached the end.  */\n+\n+  inline bool\n+  iterate_p (machine_mode *iter)\n+  {\n+    return *iter != E_VOIDmode;\n+  }\n+\n+  /* Set mode iterator *ITER to the next widest mode in the same class,\n+     if any.  */\n+\n+  inline void\n+  get_wider (machine_mode *iter)\n+  {\n+    *iter = GET_MODE_WIDER_MODE (*iter);\n+  }\n+\n+  /* Set mode iterator *ITER to the next widest mode in the same class.\n+     Such a mode is known to exist.  */\n+\n+  inline void\n+  get_known_wider (machine_mode *iter)\n+  {\n+    *iter = GET_MODE_WIDER_MODE (*iter);\n+    gcc_checking_assert (*iter != VOIDmode);\n+  }\n+\n+  /* Set mode iterator *ITER to the mode that is two times wider than the\n+     current one, if such a mode exists.  */\n+\n+  inline void\n+  get_2xwider (machine_mode *iter)\n+  {\n+    *iter = GET_MODE_2XWIDER_MODE (*iter);\n+  }\n+}\n+\n+/* Make ITERATOR iterate over all the modes in mode class CLASS,\n+   from narrowest to widest.  */\n+#define FOR_EACH_MODE_IN_CLASS(ITERATOR, CLASS)  \\\n+  for (mode_iterator::start (&(ITERATOR), CLASS); \\\n+       mode_iterator::iterate_p (&(ITERATOR)); \\\n+       mode_iterator::get_wider (&(ITERATOR)))\n+\n+/* Make ITERATOR iterate over all the modes in the range [START, END),\n+   in order of increasing width.  */\n+#define FOR_EACH_MODE(ITERATOR, START, END) \\\n+  for ((ITERATOR) = (START); \\\n+       (ITERATOR) != (END); \\\n+       mode_iterator::get_known_wider (&(ITERATOR)))\n+\n+/* Make ITERATOR iterate over START and all wider modes in the same\n+   class, in order of increasing width.  */\n+#define FOR_EACH_MODE_FROM(ITERATOR, START) \\\n+  for ((ITERATOR) = (START); \\\n+       mode_iterator::iterate_p (&(ITERATOR)); \\\n+       mode_iterator::get_wider (&(ITERATOR)))\n+\n+/* Make ITERATOR iterate over modes in the range [NARROWEST, END)\n+   in order of increasing width, where NARROWEST is the narrowest mode\n+   in END's class.  */\n+#define FOR_EACH_MODE_UNTIL(ITERATOR, END) \\\n+  FOR_EACH_MODE (ITERATOR, get_narrowest_mode (END), END)\n+\n+/* Make ITERATOR iterate over modes in the same class as MODE, in order\n+   of increasing width.  Start at the first mode wider than START,\n+   or don't iterate at all if there is no wider mode.  */\n+#define FOR_EACH_WIDER_MODE(ITERATOR, START) \\\n+  for ((ITERATOR) = (START), mode_iterator::get_wider (&(ITERATOR)); \\\n+       mode_iterator::iterate_p (&(ITERATOR)); \\\n+       mode_iterator::get_wider (&(ITERATOR)))\n+\n+/* Make ITERATOR iterate over modes in the same class as MODE, in order\n+   of increasing width, and with each mode being twice the width of the\n+   previous mode.  Start at the mode that is two times wider than START,\n+   or don't iterate at all if there is no such mode.  */\n+#define FOR_EACH_2XWIDER_MODE(ITERATOR, START) \\\n+  for ((ITERATOR) = (START), mode_iterator::get_2xwider (&(ITERATOR)); \\\n+       mode_iterator::iterate_p (&(ITERATOR)); \\\n+       mode_iterator::get_2xwider (&(ITERATOR)))\n+\n #endif /* not HAVE_MACHINE_MODES */"}, {"sha": "a36e5f9cbc04ae571da8ced5679835ce0c4f70b0", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -3449,9 +3449,7 @@ omp_clause_aligned_alignment (tree clause)\n   static enum mode_class classes[]\n     = { MODE_INT, MODE_VECTOR_INT, MODE_FLOAT, MODE_VECTOR_FLOAT };\n   for (int i = 0; i < 4; i += 2)\n-    for (mode = GET_CLASS_NARROWEST_MODE (classes[i]);\n-\t mode != VOIDmode;\n-\t mode = GET_MODE_WIDER_MODE (mode))\n+    FOR_EACH_MODE_IN_CLASS (mode, classes[i])\n       {\n \tvmode = targetm.vectorize.preferred_simd_mode (mode);\n \tif (GET_MODE_CLASS (vmode) != classes[i + 1])"}, {"sha": "ad22f07a395f186e850c20a69e6918cff6ba224d", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -194,21 +194,20 @@ get_best_extraction_insn (extraction_insn *insn,\n \t\t\t  machine_mode field_mode)\n {\n   machine_mode mode = smallest_mode_for_size (struct_bits, MODE_INT);\n-  while (mode != VOIDmode)\n+  FOR_EACH_MODE_FROM (mode, mode)\n     {\n       if (get_extraction_insn (insn, pattern, type, mode))\n \t{\n-\t  while (mode != VOIDmode\n-\t\t && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (field_mode)\n-\t\t && !TRULY_NOOP_TRUNCATION_MODES_P (insn->field_mode,\n-\t\t\t\t\t\t    field_mode))\n+\t  FOR_EACH_MODE_FROM (mode, mode)\n \t    {\n+\t      if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (field_mode)\n+\t\t  || TRULY_NOOP_TRUNCATION_MODES_P (insn->field_mode,\n+\t\t\t\t\t\t    field_mode))\n+\t\tbreak;\n \t      get_extraction_insn (insn, pattern, type, mode);\n-\t      mode = GET_MODE_WIDER_MODE (mode);\n \t    }\n \t  return true;\n \t}\n-      mode = GET_MODE_WIDER_MODE (mode);\n     }\n   return false;\n }"}, {"sha": "ce419d361dec49fd3cb486c85b1f231882b364a9", "filename": "gcc/optabs.c", "status": "modified", "additions": 21, "deletions": 53, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -1251,9 +1251,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n   if (CLASS_HAS_WIDER_MODES_P (mclass)\n       && methods != OPTAB_DIRECT && methods != OPTAB_LIB)\n-    for (wider_mode = GET_MODE_WIDER_MODE (mode);\n-\t wider_mode != VOIDmode;\n-\t wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+    FOR_EACH_WIDER_MODE (wider_mode, mode)\n       {\n \tif (optab_handler (binoptab, wider_mode) != CODE_FOR_nothing\n \t    || (binoptab == smul_optab\n@@ -1794,9 +1792,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n   if (CLASS_HAS_WIDER_MODES_P (mclass))\n     {\n-      for (wider_mode = GET_MODE_WIDER_MODE (mode);\n-\t   wider_mode != VOIDmode;\n-\t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+      FOR_EACH_WIDER_MODE (wider_mode, mode)\n \t{\n \t  if (find_widening_optab_handler (binoptab, wider_mode, mode, 1)\n \t\t  != CODE_FOR_nothing\n@@ -1952,9 +1948,7 @@ expand_twoval_unop (optab unoptab, rtx op0, rtx targ0, rtx targ1,\n \n   if (CLASS_HAS_WIDER_MODES_P (mclass))\n     {\n-      for (wider_mode = GET_MODE_WIDER_MODE (mode);\n-\t   wider_mode != VOIDmode;\n-\t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+      FOR_EACH_WIDER_MODE (wider_mode, mode)\n \t{\n \t  if (optab_handler (unoptab, wider_mode) != CODE_FOR_nothing)\n \t    {\n@@ -2035,9 +2029,7 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n \n   if (CLASS_HAS_WIDER_MODES_P (mclass))\n     {\n-      for (wider_mode = GET_MODE_WIDER_MODE (mode);\n-\t   wider_mode != VOIDmode;\n-\t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+      FOR_EACH_WIDER_MODE (wider_mode, mode)\n \t{\n \t  if (optab_handler (binoptab, wider_mode) != CODE_FOR_nothing)\n \t    {\n@@ -2139,9 +2131,7 @@ widen_leading (machine_mode mode, rtx op0, rtx target, optab unoptab)\n   if (CLASS_HAS_WIDER_MODES_P (mclass))\n     {\n       machine_mode wider_mode;\n-      for (wider_mode = GET_MODE_WIDER_MODE (mode);\n-\t   wider_mode != VOIDmode;\n-\t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+      FOR_EACH_WIDER_MODE (wider_mode, mode)\n \t{\n \t  if (optab_handler (unoptab, wider_mode) != CODE_FOR_nothing)\n \t    {\n@@ -2311,9 +2301,7 @@ widen_bswap (machine_mode mode, rtx op0, rtx target)\n   if (!CLASS_HAS_WIDER_MODES_P (mclass))\n     return NULL_RTX;\n \n-  for (wider_mode = GET_MODE_WIDER_MODE (mode);\n-       wider_mode != VOIDmode;\n-       wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+  FOR_EACH_WIDER_MODE (wider_mode, mode)\n     if (optab_handler (bswap_optab, wider_mode) != CODE_FOR_nothing)\n       goto found;\n   return NULL_RTX;\n@@ -2375,8 +2363,7 @@ expand_parity (machine_mode mode, rtx op0, rtx target)\n   if (CLASS_HAS_WIDER_MODES_P (mclass))\n     {\n       machine_mode wider_mode;\n-      for (wider_mode = mode; wider_mode != VOIDmode;\n-\t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+      FOR_EACH_MODE_FROM (wider_mode, mode)\n \t{\n \t  if (optab_handler (popcount_optab, wider_mode) != CODE_FOR_nothing)\n \t    {\n@@ -2828,9 +2815,7 @@ expand_unop (machine_mode mode, optab unoptab, rtx op0, rtx target,\n     }\n \n   if (CLASS_HAS_WIDER_MODES_P (mclass))\n-    for (wider_mode = GET_MODE_WIDER_MODE (mode);\n-\t wider_mode != VOIDmode;\n-\t wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+    FOR_EACH_WIDER_MODE (wider_mode, mode)\n       {\n \tif (optab_handler (unoptab, wider_mode) != CODE_FOR_nothing)\n \t  {\n@@ -2997,9 +2982,7 @@ expand_unop (machine_mode mode, optab unoptab, rtx op0, rtx target,\n \n   if (CLASS_HAS_WIDER_MODES_P (mclass))\n     {\n-      for (wider_mode = GET_MODE_WIDER_MODE (mode);\n-\t   wider_mode != VOIDmode;\n-\t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+      FOR_EACH_WIDER_MODE (wider_mode, mode)\n \t{\n \t  if (optab_handler (unoptab, wider_mode) != CODE_FOR_nothing\n \t      || optab_libfunc (unoptab, wider_mode))\n@@ -3800,9 +3783,7 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n \n       /* Try to use a memory block compare insn - either cmpstr\n \t or cmpmem will do.  */\n-      for (cmp_mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t   cmp_mode != VOIDmode;\n-\t   cmp_mode = GET_MODE_WIDER_MODE (cmp_mode))\n+      FOR_EACH_MODE_IN_CLASS (cmp_mode, MODE_INT)\n \t{\n \t  cmp_code = direct_optab_handler (cmpmem_optab, cmp_mode);\n \t  if (cmp_code == CODE_FOR_nothing)\n@@ -3864,9 +3845,8 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n \n   mclass = GET_MODE_CLASS (mode);\n   test = gen_rtx_fmt_ee (comparison, VOIDmode, x, y);\n-  cmp_mode = mode;\n-  do\n-   {\n+  FOR_EACH_MODE_FROM (cmp_mode, mode)\n+    {\n       enum insn_code icode;\n       icode = optab_handler (cbranch_optab, cmp_mode);\n       if (icode != CODE_FOR_nothing\n@@ -3890,9 +3870,7 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n \n       if (methods == OPTAB_DIRECT || !CLASS_HAS_WIDER_MODES_P (mclass))\n \tbreak;\n-      cmp_mode = GET_MODE_WIDER_MODE (cmp_mode);\n     }\n-  while (cmp_mode != VOIDmode);\n \n   if (methods != OPTAB_LIB_WIDEN)\n     goto fail;\n@@ -4075,9 +4053,7 @@ prepare_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison,\n   bool reversed_p = false;\n   cmp_mode = targetm.libgcc_cmp_return_mode ();\n \n-  for (mode = orig_mode;\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_FROM (mode, orig_mode)\n     {\n       if (code_to_optab (comparison)\n \t  && (libfunc = optab_libfunc (code_to_optab (comparison), mode)))\n@@ -4650,10 +4626,8 @@ expand_float (rtx to, rtx from, int unsignedp)\n      wider mode.  If the integer mode is wider than the mode of FROM,\n      we can do the conversion signed even if the input is unsigned.  */\n \n-  for (fmode = GET_MODE (to); fmode != VOIDmode;\n-       fmode = GET_MODE_WIDER_MODE (fmode))\n-    for (imode = GET_MODE (from); imode != VOIDmode;\n-\t imode = GET_MODE_WIDER_MODE (imode))\n+  FOR_EACH_MODE_FROM (fmode, GET_MODE (to))\n+    FOR_EACH_MODE_FROM (imode, GET_MODE (from))\n       {\n \tint doing_unsigned = unsignedp;\n \n@@ -4700,8 +4674,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n \t least as wide as the target.  Using FMODE will avoid rounding woes\n \t with unsigned values greater than the signed maximum value.  */\n \n-      for (fmode = GET_MODE (to);  fmode != VOIDmode;\n-\t   fmode = GET_MODE_WIDER_MODE (fmode))\n+      FOR_EACH_MODE_FROM (fmode, GET_MODE (to))\n \tif (GET_MODE_PRECISION (GET_MODE (from)) < GET_MODE_BITSIZE (fmode)\n \t    && can_float_p (fmode, GET_MODE (from), 0) != CODE_FOR_nothing)\n \t  break;\n@@ -4848,10 +4821,8 @@ expand_fix (rtx to, rtx from, int unsignedp)\n      this conversion.  If the integer mode is wider than the mode of TO,\n      we can do the conversion either signed or unsigned.  */\n \n-  for (fmode = GET_MODE (from); fmode != VOIDmode;\n-       fmode = GET_MODE_WIDER_MODE (fmode))\n-    for (imode = GET_MODE (to); imode != VOIDmode;\n-\t imode = GET_MODE_WIDER_MODE (imode))\n+  FOR_EACH_MODE_FROM (fmode, GET_MODE (from))\n+    FOR_EACH_MODE_FROM (imode, GET_MODE (to))\n       {\n \tint doing_unsigned = unsignedp;\n \n@@ -4911,8 +4882,7 @@ expand_fix (rtx to, rtx from, int unsignedp)\n      simply clears out that bit.  The rest is trivial.  */\n \n   if (unsignedp && GET_MODE_PRECISION (GET_MODE (to)) <= HOST_BITS_PER_WIDE_INT)\n-    for (fmode = GET_MODE (from); fmode != VOIDmode;\n-\t fmode = GET_MODE_WIDER_MODE (fmode))\n+    FOR_EACH_MODE_FROM (fmode, GET_MODE (from))\n       if (CODE_FOR_nothing != can_fix_p (GET_MODE (to), fmode, 0, &must_trunc)\n \t  && (!DECIMAL_FLOAT_MODE_P (fmode)\n \t      || GET_MODE_BITSIZE (fmode) > GET_MODE_PRECISION (GET_MODE (to))))\n@@ -5113,10 +5083,8 @@ expand_sfix_optab (rtx to, rtx from, convert_optab tab)\n      this conversion.  If the integer mode is wider than the mode of TO,\n      we can do the conversion either signed or unsigned.  */\n \n-  for (fmode = GET_MODE (from); fmode != VOIDmode;\n-       fmode = GET_MODE_WIDER_MODE (fmode))\n-    for (imode = GET_MODE (to); imode != VOIDmode;\n-\t imode = GET_MODE_WIDER_MODE (imode))\n+  FOR_EACH_MODE_FROM (fmode, GET_MODE (from))\n+    FOR_EACH_MODE_FROM (imode, GET_MODE (to))\n       {\n \ticode = convert_optab_handler (tab, imode, fmode);\n \tif (icode != CODE_FOR_nothing)"}, {"sha": "2c6d091a4b453dcffb170f9f1f30f66348b44059", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -1770,10 +1770,7 @@ move2add_use_add2_insn (rtx reg, rtx sym, rtx off, rtx_insn *insn)\n       else if (sym == NULL_RTX && GET_MODE (reg) != BImode)\n \t{\n \t  machine_mode narrow_mode;\n-\t  for (narrow_mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t       narrow_mode != VOIDmode\n-\t\t && narrow_mode != GET_MODE (reg);\n-\t       narrow_mode = GET_MODE_WIDER_MODE (narrow_mode))\n+\t  FOR_EACH_MODE_UNTIL (narrow_mode, GET_MODE (reg))\n \t    {\n \t      if (have_insn_for (STRICT_LOW_PART, narrow_mode)\n \t\t  && ((reg_offset[regno] & ~GET_MODE_MASK (narrow_mode))"}, {"sha": "f2381067f5e3885b342d0a6e6c661054ee511fc3", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -3315,13 +3315,9 @@ reg_to_stack (void)\n   for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n     {\n       machine_mode mode;\n-      for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n-\t   mode != VOIDmode;\n-\t   mode = GET_MODE_WIDER_MODE (mode))\n+      FOR_EACH_MODE_IN_CLASS (mode, MODE_FLOAT)\n \tFP_MODE_REG (i, mode) = gen_rtx_REG (mode, i);\n-      for (mode = GET_CLASS_NARROWEST_MODE (MODE_COMPLEX_FLOAT);\n-\t   mode != VOIDmode;\n-\t   mode = GET_MODE_WIDER_MODE (mode))\n+      FOR_EACH_MODE_IN_CLASS (mode, MODE_COMPLEX_FLOAT)\n \tFP_MODE_REG (i, mode) = gen_rtx_REG (mode, i);\n     }\n "}, {"sha": "4239fa3df4e215a5264ab15deb08bfdb57320b2f", "filename": "gcc/reginfo.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -632,36 +632,28 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n      held in REGNO.  If none, we look for the largest floating-point mode.\n      If we still didn't find a valid mode, try CCmode.  */\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n     if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n \t&& HARD_REGNO_MODE_OK (regno, mode)\n \t&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))\n \t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n       found_mode = mode;\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_FLOAT)\n     if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n \t&& HARD_REGNO_MODE_OK (regno, mode)\n \t&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))\n \t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n       found_mode = mode;\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_FLOAT);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_FLOAT)\n     if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n \t&& HARD_REGNO_MODE_OK (regno, mode)\n \t&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))\n \t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n       found_mode = mode;\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_INT);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_INT)\n     if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n \t&& HARD_REGNO_MODE_OK (regno, mode)\n \t&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))"}, {"sha": "735d86eda0b527da6f271adf86fa457bff1a8ffe", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -5663,10 +5663,8 @@ init_num_sign_bit_copies_in_rep (void)\n {\n   machine_mode mode, in_mode;\n \n-  for (in_mode = GET_CLASS_NARROWEST_MODE (MODE_INT); in_mode != VOIDmode;\n-       in_mode = GET_MODE_WIDER_MODE (mode))\n-    for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != in_mode;\n-\t mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (in_mode, MODE_INT)\n+    FOR_EACH_MODE_UNTIL (mode, in_mode)\n       {\n \tmachine_mode i;\n \n@@ -5677,7 +5675,7 @@ init_num_sign_bit_copies_in_rep (void)\n \n \t/* We are in in_mode.  Count how many bits outside of mode\n \t   have to be copies of the sign-bit.  */\n-\tfor (i = mode; i != in_mode; i = GET_MODE_WIDER_MODE (i))\n+\tFOR_EACH_MODE (i, mode, in_mode)\n \t  {\n \t    machine_mode wider = GET_MODE_WIDER_MODE (i);\n "}, {"sha": "b85c97de5c3ed954df3692a08f01204a6af94986", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -306,8 +306,7 @@ mode_for_size (unsigned int size, enum mode_class mclass, int limit)\n     return BLKmode;\n \n   /* Get the first mode which has this size, in the specified class.  */\n-  for (mode = GET_CLASS_NARROWEST_MODE (mclass); mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, mclass)\n     if (GET_MODE_PRECISION (mode) == size)\n       return mode;\n \n@@ -348,8 +347,7 @@ smallest_mode_for_size (unsigned int size, enum mode_class mclass)\n \n   /* Get the first mode which has at least this size, in the\n      specified class.  */\n-  for (mode = GET_CLASS_NARROWEST_MODE (mclass); mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, mclass)\n     if (GET_MODE_PRECISION (mode) >= size)\n       break;\n \n@@ -501,7 +499,7 @@ mode_for_vector (machine_mode innermode, unsigned nunits)\n \n   /* Do not check vector_mode_supported_p here.  We'll do that\n      later in vector_type_mode.  */\n-  for (; mode != VOIDmode ; mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_FROM (mode, mode)\n     if (GET_MODE_NUNITS (mode) == nunits\n \t&& GET_MODE_INNER (mode) == innermode)\n       break;\n@@ -1956,8 +1954,7 @@ finish_bitfield_representative (tree repr, tree field)\n   gcc_assert (maxbitsize % BITS_PER_UNIT == 0);\n \n   /* Find the smallest nice mode to use.  */\n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n     if (GET_MODE_BITSIZE (mode) >= bitsize)\n       break;\n   if (mode != VOIDmode"}, {"sha": "0b1c880ecefa47adaa4d29574d984f69f3420cac", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -3946,9 +3946,8 @@ target_supports_divmod_p (optab divmod_optab, optab div_optab, machine_mode mode\n     {\n       /* If optab_handler exists for div_optab, perhaps in a wider mode,\n \t we don't want to use the libfunc even if it exists for given mode.  */ \n-      for (machine_mode div_mode = mode;\n-\t   div_mode != VOIDmode;\n-\t   div_mode = GET_MODE_WIDER_MODE (div_mode))\n+      machine_mode div_mode;\n+      FOR_EACH_MODE_FROM (div_mode, mode)\n \tif (optab_handler (div_optab, div_mode) != CODE_FOR_nothing)\n \t  return false;\n "}, {"sha": "2415f9489d8c442dda8ea7c64347fc6798c033f2", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -1154,7 +1154,7 @@ type_for_widest_vector_mode (tree type, optab op)\n   else\n     mode = MIN_MODE_VECTOR_INT;\n \n-  for (; mode != VOIDmode; mode = GET_MODE_WIDER_MODE (mode))\n+  FOR_EACH_MODE_FROM (mode, mode)\n     if (GET_MODE_INNER (mode) == inner_mode\n         && GET_MODE_NUNITS (mode) > best_nunits\n \t&& optab_handler (op, mode) != CODE_FOR_nothing)"}, {"sha": "48ee5ba98b9860bcf2646ce317c503f5270d5224", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -4245,12 +4245,12 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      <= GET_MODE_SIZE (TYPE_MODE (rhs_type))))\n \tgoto unsupported;\n \n-      rhs_mode = TYPE_MODE (rhs_type);\n       fltsz = GET_MODE_SIZE (TYPE_MODE (lhs_type));\n-      for (rhs_mode = GET_MODE_2XWIDER_MODE (TYPE_MODE (rhs_type));\n-\t   rhs_mode != VOIDmode && GET_MODE_SIZE (rhs_mode) <= fltsz;\n-\t   rhs_mode = GET_MODE_2XWIDER_MODE (rhs_mode))\n+      FOR_EACH_2XWIDER_MODE (rhs_mode, TYPE_MODE (rhs_type))\n \t{\n+\t  if (GET_MODE_SIZE (rhs_mode) > fltsz)\n+\t    break;\n+\n \t  cvt_type\n \t    = build_nonstandard_integer_type (GET_MODE_BITSIZE (rhs_mode), 0);\n \t  cvt_type = get_same_sized_vectype (cvt_type, vectype_in);"}, {"sha": "b107ab491aaf072b3fef78a948f7dccfc2e689d3", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94843d2422bdf77e2f86fad0329838f36773b43/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=c94843d2422bdf77e2f86fad0329838f36773b43", "patch": "@@ -6306,13 +6306,14 @@ prepare_call_arguments (basic_block bb, rtx_insn *insn)\n \t    else if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT\n \t\t     || GET_MODE_CLASS (GET_MODE (x)) == MODE_PARTIAL_INT)\n \t      {\n-\t\tmachine_mode mode = GET_MODE (x);\n+\t\tmachine_mode mode;\n \n-\t\twhile ((mode = GET_MODE_WIDER_MODE (mode)) != VOIDmode\n-\t\t       && GET_MODE_BITSIZE (mode) <= BITS_PER_WORD)\n+\t\tFOR_EACH_WIDER_MODE (mode, GET_MODE (x))\n \t\t  {\n-\t\t    rtx reg = simplify_subreg (mode, x, GET_MODE (x), 0);\n+\t\t    if (GET_MODE_BITSIZE (mode) > BITS_PER_WORD)\n+\t\t      break;\n \n+\t\t    rtx reg = simplify_subreg (mode, x, GET_MODE (x), 0);\n \t\t    if (reg == NULL_RTX || !REG_P (reg))\n \t\t      continue;\n \t\t    val = cselib_lookup (reg, mode, 0, VOIDmode);"}]}