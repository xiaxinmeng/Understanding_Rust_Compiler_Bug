{"sha": "3e7b5313047f2d4cfce48c6d93b62350bfde4944", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U3YjUzMTMwNDdmMmQ0Y2ZjZTQ4YzZkOTNiNjIzNTBiZmRlNDk0NA==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-03-06T22:25:46Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-03-06T22:25:46Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r403", "tree": {"sha": "59d325b8b8356b69c554a80c2cbb2a8a89c68cbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59d325b8b8356b69c554a80c2cbb2a8a89c68cbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e7b5313047f2d4cfce48c6d93b62350bfde4944", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e7b5313047f2d4cfce48c6d93b62350bfde4944", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e7b5313047f2d4cfce48c6d93b62350bfde4944", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e7b5313047f2d4cfce48c6d93b62350bfde4944/comments", "author": null, "committer": null, "parents": [{"sha": "e5259eef1ac274c2ae118c74af53230968ddb1e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5259eef1ac274c2ae118c74af53230968ddb1e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5259eef1ac274c2ae118c74af53230968ddb1e4"}], "stats": {"total": 690, "additions": 514, "deletions": 176}, "files": [{"sha": "ea99a9485f1265d7181be2a32be8079a92f53a2b", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 514, "deletions": 176, "changes": 690, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e7b5313047f2d4cfce48c6d93b62350bfde4944/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e7b5313047f2d4cfce48c6d93b62350bfde4944/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=3e7b5313047f2d4cfce48c6d93b62350bfde4944", "patch": "@@ -21,7 +21,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* This program handles insn attribues and the DEFINE_DELAY and\n    DEFINE_FUNCTION_UNIT definitions.\n \n-   It produces a series of functions call `get_attr_...', one for each\n+   It produces a series of functions named `get_attr_...', one for each insn\n    attribute.  Each of these is given the rtx for an insn and returns a member\n    of the enum for the attribute.\n \n@@ -44,6 +44,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    changed are made.  The resulting lengths are saved for use by\n    `get_attr_length'.\n \n+   A special form of DEFINE_ATTR, where the expression for default value is a\n+   CONST expression, indicates an attribute that is constant for a given run\n+   of the compiler.  The subroutine generated for these attributes has no\n+   parameters as it does not depend on any particular insn.  Constant\n+   attributes are typically used to specify which variety of processor is\n+   used.\n+   \n    Internal attributes are defined to handle DEFINE_DELAY and\n    DEFINE_FUNCTION_UNIT.  Special routines are output for these cases.\n \n@@ -66,9 +73,18 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    optimization simplify them.\n \n    Once optimization is complete, any required routines and definitions\n-   will be written.  */\n+   will be written.\n+\n+   An optimization that is not yet implemented is to hoist the constant\n+   expressions entirely out of the routines and definitions that are written.\n+   A way to do this is to iterate over all possible combinations of values\n+   for constant attributes and generate a set of functions for that given\n+   combination.  An initialization function would be written that evaluates\n+   the attributes and installs the corresponding set of routines and\n+   definitions (each would be accessed through a pointer).  */\n \n #include <stdio.h>\n+#include \"gvarargs.h\"\n #include \"config.h\"\n #include \"rtl.h\"\n #include \"obstack.h\"\n@@ -133,6 +149,7 @@ struct attr_desc\n   char *name;\t\t\t/* Name of attribute. */\n   struct attr_desc *next;\t/* Next attribute. */\n   int is_numeric;\t\t/* Values of this attribute are numeric. */\n+  int is_const;\t\t\t/* Attribute value constant for each run.  */\n   int is_special;\t\t/* Don't call `write_attr_set'. */\n   struct attr_value *first_value; /* First value of this attribute. */\n   struct attr_value *default_val; /* Default value for this attribute. */\n@@ -224,11 +241,15 @@ static char *alternative_name = \"alternative\";\n \n rtx frame_pointer_rtx, stack_pointer_rtx, arg_pointer_rtx;\n \n+static rtx attr_rtx ();\n+static char *attr_printf ();\n+static char *attr_string ();\n static rtx check_attr_test ();\n static void check_attr_value ();\n static rtx convert_set_attr_alternative ();\n static rtx convert_set_attr ();\n static void check_defs ();\n+static rtx convert_const_symbol_ref ();\n static rtx make_canonical ();\n static struct attr_value *get_attr_value ();\n static void expand_delays ();\n@@ -283,7 +304,284 @@ char *xrealloc ();\n char *xmalloc ();\n static void fatal ();\n \f\n+/* Hash table for sharing RTL and strings.  */\n+\n+/* Each hash table slot is a bucket containing a chain of these structures.\n+   Strings are given negative hash codes; RTL expressions are given positive\n+   hash codes.  */\n+\n+struct attr_hash\n+{\n+  struct attr_hash *next;\t/* Next structure in the bucket.  */\n+  int hashcode;\t\t\t/* Hash code of this rtx or string.  */\n+  union\n+    {\n+      char *str;\t\t/* The string (negative hash codes) */\n+      rtx rtl;\t\t\t/* or the RTL recorded here.  */\n+    } u;\n+};\n+\n+/* Now here is the hash table.  When recording an RTL, it is added to\n+   the slot whose index is the hash code mod the table size.  Note\n+   that the hash table is used for several kinds of RTL (see attr_rtx)\n+   and for strings.  While all these live in the same table, they are\n+   completely independent, and the hash code is computed differently\n+   for each.  */\n+\n+#define RTL_HASH_SIZE 4093\n+struct attr_hash *attr_hash_table[RTL_HASH_SIZE];\n+\n+/* Here is how primitive or already-shared RTL's hash\n+   codes are made.  */\n+#define RTL_HASH(RTL) ((int) (RTL) & 0777777)\n+\n+/* Add an entry to the hash table for RTL with hash code HASHCODE.  */\n+\n+static void\n+attr_hash_add_rtx (hashcode, rtl)\n+     int hashcode;\n+     rtx rtl;\n+{\n+  register struct attr_hash *h;\n+\n+  h = (struct attr_hash *) xmalloc (sizeof (struct attr_hash));\n+  h->hashcode = hashcode;\n+  h->u.rtl = rtl;\n+  h->next = attr_hash_table[hashcode % RTL_HASH_SIZE];\n+  attr_hash_table[hashcode % RTL_HASH_SIZE] = h;\n+}\n+\n+/* Add an entry to the hash table for STRING with hash code HASHCODE.  */\n+\n+static void\n+attr_hash_add_string (hashcode, str)\n+     int hashcode;\n+     char *str;\n+{\n+  register struct attr_hash *h;\n+\n+  h = (struct attr_hash *) xmalloc (sizeof (struct attr_hash));\n+  h->hashcode = -hashcode;\n+  h->u.str = str;\n+  h->next = attr_hash_table[hashcode % RTL_HASH_SIZE];\n+  attr_hash_table[hashcode % RTL_HASH_SIZE] = h;\n+}\n+\n+/* Generate an RTL expression, but allow sharing.  Like gen_rtx, but the \n+   mode is not used:\n+\n+   rtx attr_rtx (code, [element1, ..., elementn])  */\n+\n+/*VARARGS1*/\n+static rtx\n+attr_rtx (va_alist)\n+     va_dcl\n+{\n+  va_list p;\n+  enum rtx_code code;\n+  register int i;\t\t/* Array indices...\t\t\t*/\n+  register char *fmt;\t\t/* Current rtx's format...\t\t*/\n+  register rtx rt_val;\t\t/* RTX to return to caller...\t\t*/\n+  int hashcode;\n+  register struct attr_hash *h;\n+\n+  va_start (p);\n+  code = va_arg (p, enum rtx_code);\n+\n+  /* For each of several cases, search the hash table for an existing entry.\n+     Use that entry if one is found; otherwise create a new RTL and add it\n+     to the table.  */\n+\n+  if (GET_RTX_CLASS (code) == '1')\n+    {\n+      rtx arg0 = va_arg (p, rtx);\n+\n+      hashcode = (code + RTL_HASH (arg0));\n+      for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n+\tif (h->hashcode == hashcode\n+\t    && GET_CODE (h->u.rtl) == code\n+\t    && XEXP (h->u.rtl, 0) == arg0)\n+\t  goto found;\n+\n+      if (h == 0)\n+\t{\n+\t  rt_val = rtx_alloc (code);\n+\t  XEXP (rt_val, 0) = arg0;\n+\t}\n+    }\n+  else if (GET_RTX_CLASS (code) == 'c'\n+\t   || GET_RTX_CLASS (code) == '2'\n+\t   || GET_RTX_CLASS (code) == '<')\n+    {\n+      rtx arg0 = va_arg (p, rtx);\n+      rtx arg1 = va_arg (p, rtx);\n+\n+      hashcode = (code + RTL_HASH (arg0) + RTL_HASH (arg1));\n+      for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n+\tif (h->hashcode == hashcode\n+\t    && GET_CODE (h->u.rtl) == code\n+\t    && XEXP (h->u.rtl, 0) == arg0\n+\t    && XEXP (h->u.rtl, 1) == arg1)\n+\t  goto found;\n+\n+      if (h == 0)\n+\t{\n+\t  rt_val = rtx_alloc (code);\n+\t  XEXP (rt_val, 0) = arg0;\n+\t  XEXP (rt_val, 1) = arg1;\n+\t}\n+    }\n+  else if (GET_RTX_LENGTH (code) == 1\n+\t   && GET_RTX_FORMAT (code)[0] == 's')\n+    {\n+      char * arg0 = va_arg (p, char *);\n+\n+      hashcode = (code + RTL_HASH (arg0));\n+      for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n+\tif (h->hashcode == hashcode\n+\t    && GET_CODE (h->u.rtl) == code\n+\t    && XSTR (h->u.rtl, 0) == arg0)\n+\t  goto found;\n+\n+      if (h == 0)\n+\t{\n+\t  rt_val = rtx_alloc (code);\n+\t  XSTR (rt_val, 0) = arg0;\n+\t}\n+    }\n+  else if (GET_RTX_LENGTH (code) == 2\n+\t   && GET_RTX_FORMAT (code)[0] == 's'\n+\t   && GET_RTX_FORMAT (code)[1] == 's')\n+    {\n+      char * arg0 = va_arg (p, char *);\n+      char * arg1 = va_arg (p, char *);\n+\n+      hashcode = (code + RTL_HASH (arg0) + RTL_HASH (arg1));\n+      for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n+\tif (h->hashcode == hashcode\n+\t    && GET_CODE (h->u.rtl) == code\n+\t    && XSTR (h->u.rtl, 0) == arg0\n+\t    && XSTR (h->u.rtl, 1) == arg1)\n+\t  goto found;\n+\n+      if (h == 0)\n+\t{\n+\t  rt_val = rtx_alloc (code);\n+\t  XSTR (rt_val, 0) = arg0;\n+\t  XSTR (rt_val, 1) = arg1;\n+\t}\n+    }\n+  else\n+    {\n+      rt_val = rtx_alloc (code);\t/* Allocate the storage space.  */\n+      \n+      fmt = GET_RTX_FORMAT (code);\t/* Find the right format...  */\n+      for (i = 0; i < GET_RTX_LENGTH (code); i++)\n+\t{\n+\t  switch (*fmt++)\n+\t    {\n+\t    case '0':\t\t/* Unused field.  */\n+\t      break;\n+\n+\t    case 'i':\t\t/* An integer?  */\n+\t      XINT (rt_val, i) = va_arg (p, int);\n+\t      break;\n+\n+\t    case 's':\t\t/* A string?  */\n+\t      XSTR (rt_val, i) = va_arg (p, char *);\n+\t      break;\n+\n+\t    case 'e':\t\t/* An expression?  */\n+\t    case 'u':\t\t/* An insn?  Same except when printing.  */\n+\t      XEXP (rt_val, i) = va_arg (p, rtx);\n+\t      break;\n+\n+\t    case 'E':\t\t/* An RTX vector?  */\n+\t      XVEC (rt_val, i) = va_arg (p, rtvec);\n+\t      break;\n+\n+\t    default:\n+\t      abort();\n+\t    }\n+\t}\n+      va_end (p);\n+      return rt_val;\n+    }\n+\n+  va_end (p);\n+  attr_hash_add_rtx (hashcode, rt_val);\n+  return rt_val;\n+\n+ found:\n+  va_end (p);\n+  return h->u.rtl;\n+}\n+\n+/* Create a new string printed with the printf line arguments into a space\n+   of at most LEN bytes:\n+\n+   rtx attr_printf (len, format, [arg1, ..., argn])  */\n+\n+/*VARARGS2*/\n+static char *\n+attr_printf (va_alist)\n+     va_dcl\n+{\n+  va_list p;\n+  register int len;\n+  register char *fmt;\n+  register char *str;\n+\n+  /* Print the string into a temporary location.  */\n+  va_start (p);\n+  len = va_arg (p, int);\n+  str = (char *) alloca (len);\n+  fmt = va_arg (p, char *);\n+  vsprintf (str, fmt, p);\n+  va_end (p);\n+\n+  return attr_string (str, strlen (str));\n+}\n+\n+/* Return a permanent (possibly shared) copy of a string STR (not assumed\n+   to be null terminated) with LEN bytes.  */\n+\n+static char *\n+attr_string (str, len)\n+     char *str;\n+     int len;\n+{\n+  register struct attr_hash *h;\n+  int hashcode;\n+  int i;\n+  register char *new_str;\n+\n+  /* Compute the hash code.  */\n+  hashcode = (len + 1) * 613 + (unsigned)str[0];\n+  for (i = 1; i <= len; i += 2)\n+    hashcode = ((hashcode * 613) + (unsigned)str[i]);\n+  if (hashcode < 0)\n+    hashcode = -hashcode;\n+\n+  /* Search the table for the string.  */\n+  for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n+    if (h->hashcode == -hashcode\n+\t&& !strcmp (h->u.str, str))\n+      return h->u.str;\t\t\t/* <-- return if found.  */\n+\n+  /* Not found; create a permanent copy and add it to the hash table.  */\n+  new_str = (char *) xmalloc (len + 1);\n+  bcopy (str, new_str, len);\n+  new_str[len] = '\\0';\n+  attr_hash_add_string (hashcode, new_str);\n+\n+  return new_str;\t\t\t/* Return the new string.  */\n+}\n+\f\n /* Given a test expression for an attribute, ensure it is validly formed.\n+   IS_CONST indicates whether the expression is constant for each compiler\n+   run (a constant expression may not test any particular insn).\n+\n    Convert (eq_attr \"att\" \"a1,a2\") to (ior (eq_attr ... ) (eq_attrq ..))\n    and (eq_attr \"att\" \"!a1\") to (not (eq_attr \"att\" \"a1\")).  Do the latter\n    test first so that (eq_attr \"att\" \"!a1,a2,a3\") works as expected.\n@@ -295,8 +593,9 @@ static void fatal ();\n    Return the new expression, if any.   */\n \n static rtx\n-check_attr_test (exp)\n+check_attr_test (exp, is_const)\n      rtx exp;\n+     int is_const;\n {\n   struct attr_desc *attr;\n   struct attr_value *av;\n@@ -308,13 +607,11 @@ check_attr_test (exp)\n     case EQ_ATTR:\n       /* Handle negation test.  */\n       if (XSTR (exp, 1)[0] == '!')\n-\t{\n-\t  XSTR(exp, 1) = &XSTR(exp, 1)[1];\n-\t  newexp = rtx_alloc (NOT);\n-\t  XEXP (newexp, 0) = exp;\n-\n-\t  return check_attr_test (newexp);\n-\t}\n+\treturn check_attr_test (attr_rtx (NOT,\n+\t\t\t\t\t  attr_rtx (EQ_ATTR,\n+\t\t\t\t\t\t    XSTR (exp, 0),\n+\t\t\t\t\t\t    &XSTR(exp, 1)[1])),\n+\t\t\t\tis_const);\n \n       else if (n_comma_elts (XSTR (exp, 1)) == 1)\n \t{\n@@ -332,6 +629,10 @@ check_attr_test (exp)\n \t\tfatal (\"Unknown attribute `%s' in EQ_ATTR\", XEXP (exp, 0));\n \t    }\n \n+\t  if (is_const && ! attr->is_const)\n+\t    fatal (\"Constant expression uses insn attribute `%s' in EQ_ATTR\",\n+\t\t   XEXP (exp, 0));\n+\n \t  XSTR (exp, 0) = attr->name;\n \n \t  if (attr->is_numeric)\n@@ -360,13 +661,11 @@ check_attr_test (exp)\n \t  name_ptr = XSTR (exp, 1);\n \t  while ((p = next_comma_elt (&name_ptr)) != NULL)\n \t    {\n-\t      newexp = rtx_alloc (EQ_ATTR);\n-\t      XSTR (newexp, 0) = XSTR (exp, 0);\n-\t      XSTR (newexp, 1) = p;\n+\t      newexp = attr_rtx (EQ_ATTR, XSTR (exp, 0), p);\n \t      orexp = insert_right_side (IOR, orexp, newexp, -2);\n \t    }\n \n-\t  return check_attr_test (orexp);\n+\t  return check_attr_test (orexp, is_const);\n \t}\n       break;\n \n@@ -379,22 +678,34 @@ check_attr_test (exp)\n \n     case IOR:\n     case AND:\n-      XEXP (exp, 0) = check_attr_test (XEXP (exp, 0));\n-      XEXP (exp, 1) = check_attr_test (XEXP (exp, 1));\n+      XEXP (exp, 0) = check_attr_test (XEXP (exp, 0), is_const);\n+      XEXP (exp, 1) = check_attr_test (XEXP (exp, 1), is_const);\n       break;\n \n     case NOT:\n-      XEXP (exp, 0) = check_attr_test (XEXP (exp, 0));\n+      XEXP (exp, 0) = check_attr_test (XEXP (exp, 0), is_const);\n       break;\n \n     case MATCH_OPERAND:\n+      if (is_const)\n+\tfatal (\"RTL operator \\\"%s\\\" not valid in constant attribute test\",\n+\t       GET_RTX_NAME (MATCH_OPERAND));\n+\n     case LE:  case LT:  case GT:  case GE:\n     case LEU: case LTU: case GTU: case GEU:\n     case NE:  case EQ:\n       /* These cases can't be simplified.  */\n       RTX_UNCHANGING_P (exp) = 1;\n       break;\n \n+    case SYMBOL_REF:\n+      if (is_const)\n+\t{\n+\t  /* These cases are valid for constant attributes, but can't be\n+\t     simplified.  */\n+\t  RTX_UNCHANGING_P (exp) = 1;\n+\t  break;\n+\t}\n     default:\n       fatal (\"RTL operator \\\"%s\\\" not valid in attribute test\",\n \t     GET_RTX_NAME (GET_CODE (exp)));\n@@ -454,7 +765,8 @@ check_attr_value (exp, attr)\n       return;\n \n     case IF_THEN_ELSE:\n-      XEXP (exp, 0) = check_attr_test (XEXP (exp, 0));\n+      XEXP (exp, 0) = check_attr_test (XEXP (exp, 0),\n+\t\t\t\t       attr ? attr->is_const : 0);\n       check_attr_value (XEXP (exp, 1), attr);\n       check_attr_value (XEXP (exp, 2), attr);\n       return;\n@@ -465,13 +777,21 @@ check_attr_value (exp, attr)\n \n       for (i = 0; i < XVECLEN (exp, 0); i += 2)\n \t{\n-\t  XVECEXP (exp, 0, i) = check_attr_test (XVECEXP (exp, 0, i));\n+\t  XVECEXP (exp, 0, i) = check_attr_test (XVECEXP (exp, 0, i),\n+\t\t\t\t\t\t attr ? attr->is_const : 0);\n \t  check_attr_value (XVECEXP (exp, 0, i + 1), attr);\n \t}\n \n       check_attr_value (XEXP (exp, 1), attr);\n       return;\n \n+    case SYMBOL_REF:\n+      if (attr && attr->is_const)\n+\t/* A constant SYMBOL_REF is valid as a constant attribute test and\n+\t   is expanded later by make_canonical into a COND.  */\n+\treturn;\n+      /* Otherwise, fall through... */\n+\n     default:\n       fatal (\"Illegal operation `%s' for attribute value\",\n \t     GET_RTX_NAME (GET_CODE (exp)));\n@@ -502,21 +822,19 @@ convert_set_attr_alternative (exp, num_alt, insn_code, insn_index)\n \n   for (i = 0; i < num_alt - 1; i++)\n     {\n+      char *p;\n+      p = attr_printf (3, \"%d\", i);\n+\n+      /* Sharing this EQ_ATTR rtl causes trouble.  */   \n       XVECEXP (condexp, 0, 2 * i) = rtx_alloc (EQ_ATTR);\n       XSTR (XVECEXP (condexp, 0, 2 * i), 0) = alternative_name;\n-      XSTR (XVECEXP (condexp, 0, 2 * i), 1) = (char *) xmalloc (3);\n-      sprintf (XSTR (XVECEXP (condexp, 0, 2 * i), 1), \"%d\", i);\n+      XSTR (XVECEXP (condexp, 0, 2 * i), 1) = p;\n       XVECEXP (condexp, 0, 2 * i + 1) = XVECEXP (exp, 1, i);\n     }\n \n   XEXP (condexp, 1) = XVECEXP (exp, 1, i);\n \n-  newexp = rtx_alloc (SET);\n-  XEXP (newexp, 0) = rtx_alloc (ATTR);\n-  XSTR (XEXP (newexp, 0), 0) = XSTR (exp, 0);\n-  XEXP (newexp, 1) = condexp;\n-\n-  return newexp;\n+  return attr_rtx (SET, attr_rtx (ATTR, XSTR (exp, 0)), condexp);\n }\n \f\n /* Given a SET_ATTR, convert to the appropriate SET.  If a comma-separated\n@@ -536,15 +854,9 @@ convert_set_attr (exp, num_alt, insn_code, insn_index)\n   /* See how many alternative specified.  */\n   n = n_comma_elts (XSTR (exp, 1));\n   if (n == 1)\n-    {\n-      newexp = rtx_alloc (SET);\n-      XEXP (newexp, 0) = rtx_alloc (ATTR);\n-      XSTR (XEXP (newexp, 0), 0) = XSTR (exp, 0);\n-      XEXP (newexp, 1) = rtx_alloc (CONST_STRING);\n-      XSTR (XEXP (newexp, 1), 0) = XSTR (exp, 1);\n-\n-      return newexp;\n-    }\n+    return attr_rtx (SET,\n+\t\t     attr_rtx (ATTR, XSTR (exp, 0)),\n+\t\t     attr_rtx (CONST_STRING, XSTR (exp, 1)));\n \n   newexp = rtx_alloc (SET_ATTR_ALTERNATIVE);\n   XSTR (newexp, 0) = XSTR (exp, 0);\n@@ -554,10 +866,7 @@ convert_set_attr (exp, num_alt, insn_code, insn_index)\n   name_ptr = XSTR (exp, 1);\n   n = 0;\n   while ((p = next_comma_elt (&name_ptr)) != NULL)\n-    {\n-      XVECEXP (newexp, 1, n) = rtx_alloc (CONST_STRING);\n-      XSTR (XVECEXP (newexp, 1, n++), 0) = p;\n-    }\n+    XVECEXP (newexp, 1, n++) = attr_rtx (CONST_STRING, p);\n \n   return convert_set_attr_alternative (newexp, num_alt, insn_code, insn_index);\n }\n@@ -616,6 +925,56 @@ check_defs ()\n     }\n }\n \f\n+/* Given a constant SYMBOL_REF expression, convert to a COND that\n+   explicitly tests each enumerated value.  */\n+\n+static rtx\n+convert_const_symbol_ref (exp, attr)\n+     rtx exp;\n+     struct attr_desc *attr;\n+{\n+  rtx condexp;\n+  struct attr_value *av;\n+  int i;\n+  int num_alt = 0;\n+\n+  for (av = attr->first_value; av; av = av->next)\n+    num_alt++;\n+\n+  /* Make a COND with all tests but the last, and in the original order.\n+     Select the last value via the default.  Note that the attr values\n+     are constructed in reverse order.  */\n+\n+  condexp = rtx_alloc (COND);\n+  XVEC (condexp, 0) = rtvec_alloc ((num_alt - 1) * 2);\n+  av = attr->first_value;\n+  XEXP (condexp, 1) = av->value;\n+\n+  for (i = num_alt - 2; av = av->next, i >= 0; i--)\n+    {\n+      char * p;\n+      rtx value;\n+\n+      XVECEXP (condexp, 0, 2 * i) = rtx_alloc (EQ);\n+      XEXP (XVECEXP (condexp, 0, 2 * i), 0) = exp;\n+      XEXP (XVECEXP (condexp, 0, 2 * i), 1) = value = rtx_alloc (SYMBOL_REF);\n+      RTX_UNCHANGING_P (value) = 1;\n+      XSTR (value, 0) = p = (char *) xmalloc (2\n+\t\t\t\t\t      + strlen (attr->name)\n+\t\t\t\t\t      + strlen (XSTR (av->value, 0)));\n+      strcpy (p, attr->name);\n+      strcat (p, \"_\");\n+      strcat (p, XSTR (av->value, 0));\n+      for (; *p != '\\0'; p++)\n+\tif (*p >= 'a' && *p <= 'z')\n+\t  *p -= 'a' - 'A';\n+\n+      XVECEXP (condexp, 0, 2 * i + 1) = av->value;\n+    }\n+\n+  return condexp;\n+}\n+\f\n /* Given a valid expression for an attribute value, remove any IF_THEN_ELSE\n    expressions by converting them into a COND.  This removes cases from this\n    program.  Also, replace an attribute value of \"*\" with the default attribute\n@@ -645,6 +1004,17 @@ make_canonical (attr, exp)\n \n       break;\n \n+    case SYMBOL_REF:\n+      if (!attr->is_const || RTX_UNCHANGING_P (exp))\n+\tbreak;\n+      RTX_UNCHANGING_P (exp) = 1;\n+      exp = convert_const_symbol_ref (exp, attr);\n+      check_attr_value (exp, attr);\n+      /* Goto COND case since this is now a COND.  Note that while the\n+         new expression is rescanned, all symbol_ref notes are mared as\n+\t unchanging.  */\n+      goto cond;\n+\n     case IF_THEN_ELSE:\n       newexp = rtx_alloc (COND);\n       XVEC (newexp, 0) = rtvec_alloc (2);\n@@ -657,6 +1027,7 @@ make_canonical (attr, exp)\n       /* Fall through to COND case since this is now a COND.  */\n \n     case COND:\n+    cond:\n       /* First, check for degenerate COND. */\n       if (XVECLEN (exp, 0) == 0)\n \treturn make_canonical (attr, XEXP (exp, 1));\n@@ -777,40 +1148,33 @@ expand_delays ()\n    {\n      for (i = 0; i < XVECLEN (delay->def, 1); i += 3)\n        {\n-\t newexp = rtx_alloc (IF_THEN_ELSE);\n \t condexp = XVECEXP (delay->def, 1, i);\n \t if (condexp == 0) condexp = false_rtx;\n-\t XEXP (newexp, 0) = condexp;\n-\t XEXP (newexp, 1) = make_numeric_value (1);\n-\t XEXP (newexp, 2) = make_numeric_value (0);\n+\t newexp = attr_rtx (IF_THEN_ELSE, condexp,\n+\t\t\t    make_numeric_value (1), make_numeric_value (0));\n \n-\t p = (char *) xmalloc (13);\n-\t sprintf (p, \"*delay_%d_%d\", delay->num, i / 3);\n+\t p = attr_printf (13, \"*delay_%d_%d\", delay->num, i / 3);\n \t make_internal_attr (p, newexp, 1);\n \n \t if (have_annul_true)\n \t   {\n-\t     newexp = rtx_alloc (IF_THEN_ELSE);\n \t     condexp = XVECEXP (delay->def, 1, i + 1);\n \t     if (condexp == 0) condexp = false_rtx;\n-\t     XEXP (newexp, 0) = condexp;\n-\t     XEXP (newexp, 1) = make_numeric_value (1);\n-\t     XEXP (newexp, 2) = make_numeric_value (0);\n-\t     p = (char *) xmalloc (18);\n-\t     sprintf (p, \"*annul_true_%d_%d\", delay->num, i / 3);\n+\t     newexp = attr_rtx (IF_THEN_ELSE, condexp,\n+\t\t\t\tmake_numeric_value (1),\n+\t\t\t\tmake_numeric_value (0));\n+\t     p = attr_printf (18, \"*annul_true_%d_%d\", delay->num, i / 3);\n \t     make_internal_attr (p, newexp, 1);\n \t   }\n \n \t if (have_annul_false)\n \t   {\n-\t     newexp = rtx_alloc (IF_THEN_ELSE);\n \t     condexp = XVECEXP (delay->def, 1, i + 2);\n \t     if (condexp == 0) condexp = false_rtx;\n-\t     XEXP (newexp, 0) = condexp;\n-\t     XEXP (newexp, 1) = make_numeric_value (1);\n-\t     XEXP (newexp, 2) = make_numeric_value (0);\n-\t     p = (char *) xmalloc (18);\n-\t     sprintf (p, \"*annul_false_%d_%d\", delay->num, i / 3);\n+\t     newexp = attr_rtx (IF_THEN_ELSE, condexp,\n+\t\t\t\tmake_numeric_value (1),\n+\t\t\t\tmake_numeric_value (0));\n+\t     p = attr_printf (18, \"*annul_false_%d_%d\", delay->num, i / 3);\n \t     make_internal_attr (p, newexp, 1);\n \t   }\n        }\n@@ -872,12 +1236,9 @@ operate_exp (op, left, right)\n       else if (GET_CODE (right) == IF_THEN_ELSE)\n \t{\n \t  /* Apply recursively to all values within.  */\n-\t  newexp = rtx_alloc (IF_THEN_ELSE);\n-\t  XEXP (newexp, 0) = XEXP (right, 0);\n-\t  XEXP (newexp, 1) = operate_exp (op, left, XEXP (right, 1));\n-\t  XEXP (newexp, 2) = operate_exp (op, left, XEXP (right, 2));\n-\n-\t  return newexp;\n+\t  return attr_rtx (IF_THEN_ELSE, XEXP (right, 0),\n+\t\t\t   operate_exp (op, left, XEXP (right, 1)),\n+\t\t\t   operate_exp (op, left, XEXP (right, 2)));\n \t}\n       else if (GET_CODE (right) == COND)\n \t{\n@@ -901,12 +1262,9 @@ operate_exp (op, left, right)\n   /* Otherwise, do recursion the other way.  */\n   else if (GET_CODE (left) == IF_THEN_ELSE)\n     {\n-      newexp = rtx_alloc (IF_THEN_ELSE);\n-      XEXP (newexp, 0) = XEXP (left, 0);\n-      XEXP (newexp, 1) = operate_exp (op, XEXP (left, 1), right);\n-      XEXP (newexp, 2) = operate_exp (op, XEXP (left, 2), right);\n-\n-      return newexp;\n+      return attr_rtx (IF_THEN_ELSE, XEXP (left, 0),\n+\t\t       operate_exp (op, XEXP (left, 1), right),\n+\t\t       operate_exp (op, XEXP (left, 2), right));\n     }\n \n   else if (GET_CODE (left) == COND)\n@@ -983,14 +1341,13 @@ expand_units ()\n \n       for (op = unit->ops; op; op = op->next)\n \t{\n-\t  str = (char *) xmalloc (strlen (unit->name) + 11);\n-\n \t  /* Validate the expressions we were given for the conditions\n \t     and busy cost.  Then make an attribute for use in the conflict\n \t     function.  */\n-\t  op->condexp = check_attr_test (op->condexp);\n+\t  op->condexp = check_attr_test (op->condexp, 0);\n \t  check_attr_value (op->busyexp, 0);\n-\t  sprintf (str, \"*%s_case_%d\", unit->name, op->num);\n+\t  str = attr_printf (strlen (unit->name) + 11, \"*%s_case_%d\",\n+\t\t\t     unit->name, op->num);\n \t  make_internal_attr (str, make_canonical (0, op->busyexp));\n \n \t  /* Make our adjustment to the two COND's being computed.  If we are\n@@ -1013,17 +1370,16 @@ expand_units ()\n \t}\n \n       /* Make an attribute for the case number and ready delay.  */\n-      str = (char *) xmalloc (strlen (unit->name) + 8);\n-      sprintf (str, \"*%s_cases\", unit->name);\n+      str = attr_printf (strlen (unit->name) + 8, \"*%s_cases\", unit->name);\n       make_internal_attr (str, caseexp, 1);\n \n-      str = (char *) xmalloc (strlen (unit->name) + 20);\n-      sprintf (str, \"*%s_unit_ready_cost\", unit->name);\n+      str = attr_printf (strlen (unit->name) + 20, \"*%s_unit_ready_cost\",\n+\t\t\t unit->name);\n       make_internal_attr (str, readyexp, 0);\n \n       /* Merge this function unit into the ready cost and unit mask\n \t attributes.  */\n-      XEXP (newexp, 0) = check_attr_test (unit->condexp);\n+      XEXP (newexp, 0) = check_attr_test (unit->condexp, 0);\n       XEXP (newexp, 1) = make_numeric_value (1 << unit->num);\n       unitsmask = operate_exp (OR_OP, unitsmask, newexp);\n \n@@ -1122,15 +1478,13 @@ substitute_address (exp, no_address_fn, address_fn)\n       if (address_used)\n \treturn (*address_fn) (exp);\n \n-      newexp = rtx_alloc (IF_THEN_ELSE);\n-      XEXP (newexp, 0) = substitute_address (XEXP (exp, 0),\n-\t\t\t\t\t     no_address_fn, address_fn);\n-      XEXP (newexp, 1) = substitute_address (XEXP (exp, 1),\n-\t\t\t\t\t     no_address_fn, address_fn);\n-      XEXP (newexp, 2) = substitute_address (XEXP (exp, 2),\n-\t\t\t\t\t     no_address_fn, address_fn);\n-\n-      return newexp;\n+      return attr_rtx (IF_THEN_ELSE,\n+\t\t       substitute_address (XEXP (exp, 0),\n+\t\t\t\t\t   no_address_fn, address_fn),\n+\t\t       substitute_address (XEXP (exp, 1),\n+\t\t\t\t\t   no_address_fn, address_fn),\n+\t\t       substitute_address (XEXP (exp, 2),\n+\t\t\t\t\t   no_address_fn, address_fn));\n     }\n \n   return (*no_address_fn) (exp);\n@@ -1177,6 +1531,7 @@ make_length_attrs ()\n   if (! length_attr->is_numeric)\n     fatal (\"length attribute must be numeric.\");\n \n+  length_attr->is_const = 0;\n   length_attr->is_special = 1;\n \n   /* Make each new attribute, in turn.  */\n@@ -1440,17 +1795,14 @@ insert_right_side (code, exp, term, insn_code, insn_index)\n   if (GET_CODE (exp) == code)\n     {\n       /* Make a copy of this expression and call recursively.  */\n-      newexp = rtx_alloc (code);\n-      XEXP (newexp, 0) = XEXP (exp, 0);\n-      XEXP (newexp, 1) = insert_right_side (code, XEXP (exp, 1),\n-\t\t\t\t\t    term, insn_code, insn_index);\n+      newexp = attr_rtx (code, XEXP (exp, 0),\n+\t\t\t insert_right_side (code, XEXP (exp, 1),\n+\t\t\t\t\t    term, insn_code, insn_index));\n     }\n   else\n     {\n       /* Insert the new term.  */\n-      newexp = rtx_alloc (code);\n-      XEXP (newexp, 0) = exp;\n-      XEXP (newexp, 1) = term;\n+      newexp = attr_rtx (code, exp, term);\n       }\n \n   return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n@@ -1501,12 +1853,9 @@ make_alternative_compare (mask)\n   for (i = 0; (mask & (1 << i)) == 0; i++)\n     ;\n \n-  alternative = (char *) xmalloc (3);\n-  sprintf (alternative, \"%d\", i);\n+  alternative = attr_printf (3, \"%d\", i);\n \n-  newexp = rtx_alloc (EQ_ATTR);\n-  XSTR (newexp, 0) = alternative_name;\n-  XSTR (newexp, 1) = alternative;\n+  newexp = attr_rtx (EQ_ATTR, alternative_name, alternative);\n   RTX_UNCHANGING_P (newexp) = 1;\n \n   return newexp;\n@@ -1566,8 +1915,7 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n \t\t\t\t     insn_code, insn_index);\n \n \t  /* Add this condition into the AND expression.  */\n-\t  newexp = rtx_alloc (NOT);\n-\t  XEXP (newexp, 0) = XVECEXP (value, 0, i);\n+\t  newexp = attr_rtx (NOT, XVECEXP (value, 0, i));\n \t  andexp = insert_right_side (AND, andexp, newexp,\n \t\t\t\t      insn_code, insn_index);\n \t}\n@@ -1624,9 +1972,7 @@ simplify_and_tree (exp, pterm, insn_code, insn_index)\n       right = simplify_and_tree (XEXP (exp, 1), pterm, insn_code, insn_index);\n       if (left != XEXP (exp, 0) || right != XEXP (exp, 1))\n \t{\n-\t  newexp = rtx_alloc (GET_CODE (exp));\n-\t  XEXP (newexp, 0) = left;\n-\t  XEXP (newexp, 1) = right;\n+\t  newexp = attr_rtx (GET_CODE (exp), left, right);\n \n \t  exp = SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n \t}\n@@ -1649,9 +1995,7 @@ simplify_and_tree (exp, pterm, insn_code, insn_index)\n \n       if (left != XEXP (exp, 0) || right != XEXP (exp, 1))\n \t{\n-\t  newexp = rtx_alloc (GET_CODE (exp));\n-\t  XEXP (newexp, 0) = left;\n-\t  XEXP (newexp, 1) = right;\n+\t  newexp = attr_rtx (GET_CODE (exp), left, right);\n \n \t  exp = SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n \t}\n@@ -1747,9 +2091,7 @@ simplify_or_tree (exp, pterm, insn_code, insn_index)\n       right = simplify_or_tree (XEXP (exp, 1), pterm, insn_code, insn_index);\n       if (left != XEXP (exp, 0) || right != XEXP (exp, 1))\n \t{\n-\t  newexp = rtx_alloc (GET_CODE (exp));\n-\t  XEXP (newexp, 0) = left;\n-\t  XEXP (newexp, 1) = right;\n+\t  newexp = attr_rtx (GET_CODE (exp), left, right);\n \n \t  exp = SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n \t}\n@@ -1772,9 +2114,7 @@ simplify_or_tree (exp, pterm, insn_code, insn_index)\n \n       if (left != XEXP (exp, 0) || right != XEXP (exp, 1))\n \t{\n-\t  newexp = rtx_alloc (GET_CODE (exp));\n-\t  XEXP (newexp, 0) = left;\n-\t  XEXP (newexp, 1) = right;\n+\t  newexp = attr_rtx (GET_CODE (exp), left, right);\n \n \t  exp = SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n \t}\n@@ -1843,12 +2183,9 @@ simplify_test_exp (exp, insn_code, insn_index)\n \t      right = tem;\n \t    }\n \n-\t  newexp = rtx_alloc (IOR);\n-\t  XEXP (newexp, 0) = rtx_alloc (AND);\n-\t  XEXP (newexp, 1) = rtx_alloc (AND);\n-\t  XEXP (XEXP (newexp, 0), 0) = XEXP (XEXP (newexp, 1), 0) = left;\n-\t  XEXP (XEXP (newexp, 0), 1) = XEXP (right, 0);\n-\t  XEXP (XEXP (newexp, 1), 1) = XEXP (right, 1);\n+\t  newexp = attr_rtx (IOR,\n+\t\t\t     attr_rtx (AND, left, XEXP (right, 0)),\n+\t\t\t     attr_rtx (AND, left, XEXP (right, 1)));\n \n \t  return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n \t}\n@@ -1895,19 +2232,15 @@ simplify_test_exp (exp, insn_code, insn_index)\n \t\t alternative and we have tested none of them!  */\n \t      left = make_alternative_compare (i);\n \t      right = simplify_and_tree (exp, &left, insn_code, insn_index);\n-\t      newexp = rtx_alloc (AND);\n-\t      XEXP (newexp, 0) = left;\n-\t      XEXP (newexp, 1) = right;\n+\t      newexp = attr_rtx (AND, left, right);\n \n \t      return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n \t    }\n \t}\n \n       if (left != XEXP (exp, 0) || right != XEXP (exp, 1))\n \t{\n-\t  newexp = rtx_alloc (AND);\n-\t  XEXP (newexp, 0) = left;\n-\t  XEXP (newexp, 1) = right;\n+\t  newexp = attr_rtx (AND, left, right);\n \t  return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n \t}\n       break;\n@@ -1937,15 +2270,11 @@ simplify_test_exp (exp, insn_code, insn_index)\n       else if (GET_CODE (left) == AND && GET_CODE (right) == AND\n \t  && rtx_equal_p (XEXP (left, 0), XEXP (right, 0)))\n \t{\n-\t  newexp = rtx_alloc (IOR);\n-\t  XEXP (newexp, 0) = XEXP (left, 1);\n-\t  XEXP (newexp, 1) = XEXP (right, 1);\n+\t  newexp = attr_rtx (IOR, XEXP (left, 1), XEXP (right, 1));\n \n \t  left = XEXP (left, 0);\n \t  right = newexp;\n-\t  newexp = rtx_alloc (AND);\n-\t  XEXP (newexp, 0) = left;\n-\t  XEXP (newexp, 1) = right;\n+\t  newexp = attr_rtx (AND, left, right);\n \t  return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n \t}\n \n@@ -1977,20 +2306,15 @@ simplify_test_exp (exp, insn_code, insn_index)\n \t\t alternative and we have tested none of them!  */\n \t      left = make_alternative_compare (i);\n \t      right = simplify_and_tree (exp, &left, insn_code, insn_index);\n-\t      newexp = rtx_alloc (IOR);\n-\t      XEXP (newexp, 0) = rtx_alloc (NOT);\n-\t      XEXP (XEXP (newexp, 0), 0) = left;\n-\t      XEXP (newexp, 1) = right;\n+\t      newexp = attr_rtx (IOR, attr_rtx (NOT, left), right);\n \n \t      return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n \t    }\n \t}\n \n       if (left != XEXP (exp, 0) || right != XEXP (exp, 1))\n \t{\n-\t  newexp = rtx_alloc (IOR);\n-\t  XEXP (newexp, 0) = left;\n-\t  XEXP (newexp, 1) = right;\n+\t  newexp = attr_rtx (IOR, left, right);\n \t  return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n \t}\n       break;\n@@ -2008,28 +2332,23 @@ simplify_test_exp (exp, insn_code, insn_index)\n       /* Try to apply De`Morgan's laws.  */\n       else if (GET_CODE (left) == IOR)\n \t{\n-\t  newexp = rtx_alloc (AND);\n-\t  XEXP (newexp, 0) = rtx_alloc (NOT);\n-\t  XEXP (XEXP (newexp, 0), 0) = XEXP (left, 0);\n-\t  XEXP (newexp, 1) = rtx_alloc (NOT);\n-\t  XEXP (XEXP (newexp, 1), 0) = XEXP (left, 1);\n+\t  newexp = attr_rtx (AND,\n+\t\t\t     attr_rtx (NOT, XEXP (left, 0)),\n+\t\t\t     attr_rtx (NOT, XEXP (left, 1)));\n \n \t  newexp = SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n \t}\n       else if (GET_CODE (left) == AND)\n \t{\n-\t  newexp = rtx_alloc (IOR);\n-\t  XEXP (newexp, 0) = rtx_alloc (NOT);\n-\t  XEXP (XEXP (newexp, 0), 0) = XEXP (left, 0);\n-\t  XEXP (newexp, 1) = rtx_alloc (NOT);\n-\t  XEXP (XEXP (newexp, 1), 0) = XEXP (left, 1);\n+\t  newexp = attr_rtx (IOR,\n+\t\t\t     attr_rtx (NOT, XEXP (left, 0)),\n+\t\t\t     attr_rtx (NOT, XEXP (left, 1)));\n \n \t  newexp = SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n \t}\n       else if (left != XEXP (exp, 0))\n \t{\n-\t  newexp = rtx_alloc (NOT);\n-\t  XEXP (newexp, 0) = left;\n+\t  newexp = attr_rtx (NOT, left);\n \t}\n       break;\n \n@@ -2117,8 +2436,7 @@ gen_attr (exp)\n       while ((p = next_comma_elt (&name_ptr)) != NULL)\n \t{\n \t  av = (struct attr_value *) xmalloc (sizeof (struct attr_value));\n-\t  av->value = rtx_alloc (CONST_STRING);\n-\t  XSTR (av->value, 0) = p;\n+\t  av->value = attr_rtx (CONST_STRING, p);\n \t  av->next = attr->first_value;\n \t  attr->first_value = av;\n \t  av->first_insn = NULL;\n@@ -2127,6 +2445,15 @@ gen_attr (exp)\n \t}\n     }\n \n+  if (GET_CODE (XEXP (exp, 2)) == CONST)\n+    {\n+      attr->is_const = 1;\n+      if (attr->is_numeric)\n+\tfatal (\"Constant attributes may not take numeric values\");\n+      /* Get rid of the CONST node.  It is allowed only at top-level.  */\n+      XEXP (exp, 2) = XEXP (XEXP (exp, 2), 0);\n+    }\n+\n   if (! strcmp (attr->name, \"length\") && ! attr->is_numeric)\n     fatal (\"`length' attribute must take numeric values\");\n \n@@ -2370,10 +2697,9 @@ gen_unit (def)\n       for (i = 0; i < XVECLEN (def, 6); i++)\n \torexp = insert_right_side (IOR, orexp, XVECEXP (def, 6, i), -2);\n \n-      op->busyexp = rtx_alloc (IF_THEN_ELSE);\n-      XEXP (op->busyexp, 0) = orexp;\n-      XEXP (op->busyexp, 1) = make_numeric_value (XINT (def, 5));\n-      XEXP (op->busyexp, 2) = make_numeric_value (0);\n+      op->busyexp = attr_rtx (IF_THEN_ELSE, orexp,\n+\t\t\t      make_numeric_value (XINT (def, 5)),\n+\t\t\t      make_numeric_value (0));\n     }\n   else\n     op->busyexp = make_numeric_value (XINT (def, 5));\n@@ -2646,8 +2972,11 @@ walk_attr_value (exp)\n   switch (code)\n     {\n     case SYMBOL_REF:\n-      /* Since this is an arbitrary expression, it can look at anything. */\n-      must_extract = must_constrain = 1;\n+      if (! RTX_UNCHANGING_P (exp))\n+\t/* Since this is an arbitrary expression, it can look at anything.\n+\t   However, constant expressions do not depend on any particular\n+\t   insn.  */\n+\tmust_extract = must_constrain = 1;\n       return;\n \n     case MATCH_OPERAND:\n@@ -2704,8 +3033,22 @@ write_attr_get (attr)\n      the subroutine to use, instead of `get_attr_...'.  */\n   if (attr->name[0] == '*')\n     printf (\"%s (insn)\\n\", &attr->name[1]);\n-  else\n+  else if (attr->is_const == 0)\n     printf (\"get_attr_%s (insn)\\n\", attr->name);\n+  else\n+    {\n+      printf (\"get_attr_%s ()\\n\", attr->name);\n+      printf (\"{\\n\");\n+\n+      for (av = attr->first_value; av; av = av->next)\n+\tif (av->num_insns != 0)\n+\t  write_attr_set (attr, 2, av->value, \"return\", \";\",\n+\t\t\t  true_rtx, av->first_insn->insn_code,\n+\t\t\t  av->first_insn->insn_index);\n+\n+      printf (\"}\\n\\n\");\n+      return;\n+    }\n   printf (\"     rtx insn;\\n\");\n   printf (\"{\\n\");\n   printf (\"  switch (recog_memoized (insn))\\n\");\n@@ -2791,8 +3134,7 @@ write_attr_set (attr, indent, value, prefix, suffix, known_true,\n \t  testexp = eliminate_known_true (our_known_true,\n \t\t\t\t\t  XVECEXP (value, 0, i),\n \t\t\t\t\t  insn_code, insn_index);\n-\t  newexp = rtx_alloc (NOT);\n-\t  XEXP (newexp, 0) = testexp;\n+\t  newexp = attr_rtx (NOT, testexp);\n \t  newexp  = insert_right_side (AND, our_known_true, newexp,\n \t\t\t\t       insn_code, insn_index);\n \n@@ -3123,7 +3465,7 @@ write_function_unit_info ()\n     {\n       /* See if only one case exists and if there is a constant value for\n \t that case.  If so, we don't need a function.  */\n-      str = (char *) xmalloc (strlen (unit->name) + 10);\n+      str = (char *) alloca (strlen (unit->name) + 10);\n       sprintf (str, \"*%s_cases\", unit->name);\n       attr = find_attr (str, 0);\n       if (! attr) abort ();\n@@ -3282,11 +3624,9 @@ next_comma_elt (pstr)\n   for (p = *pstr; *p != ',' && *p != '\\0'; p++)\n     ;\n \n-  out_str = (char *) xmalloc (p - *pstr + 1);\n-  for (p = out_str; **pstr != ',' && **pstr != '\\0'; (*pstr)++)\n-    *p++ = **pstr;\n+  out_str = attr_string (*pstr, p - *pstr);\n+  *pstr = p;\n \n-  *p++ = '\\0';\n   if (**pstr == ',')\n     (*pstr)++;\n \n@@ -3327,7 +3667,7 @@ find_attr (name, create)\n   attr = (struct attr_desc *) xmalloc (sizeof (struct attr_desc));\n   attr->name = new_name;\n   attr->first_value = attr->default_val = NULL;\n-  attr->is_numeric = attr->is_special = 0;\n+  attr->is_numeric = attr->is_const = attr->is_special = 0;\n   attr->next = attrs;\n   attrs = attr;\n \n@@ -3349,6 +3689,7 @@ make_internal_attr (name, value, special)\n     abort ();\n \n   attr->is_numeric = 1;\n+  attr->is_const = 0;\n   attr->is_special = special;\n   attr->default_val = get_attr_value (value, attr, -2);\n }\n@@ -3404,17 +3745,16 @@ make_numeric_value (n)\n {\n   static rtx int_values[20];\n   rtx exp;\n+  char *p;\n \n   if (n < 0)\n     abort ();\n \n   if (n < 20 && int_values[n])\n     return int_values[n];\n \n-  exp = rtx_alloc (CONST_STRING);\n-  XSTR (exp, 0) = (char *) xmalloc ((n < 1000 ? 4\n-\t\t\t\t     : HOST_BITS_PER_INT * 3 / 10 + 3));\n-  sprintf (XSTR (exp, 0), \"%d\", n);\n+  p = attr_printf ((n < 1000 ? 4 : HOST_BITS_PER_INT * 3 / 10 + 3), \"%d\", n);\n+  exp = attr_rtx (CONST_STRING, p);\n \n   if (n < 20)\n     int_values[n] = exp;\n@@ -3492,10 +3832,8 @@ main (argc, argv)\n   init_rtl ();\n \n   /* Set up true and false rtx's */\n-  true_rtx = rtx_alloc (CONST_INT);\n-  false_rtx = rtx_alloc (CONST_INT);\n-  XINT (true_rtx, 0) = 1;\n-  XINT (false_rtx, 0) = 0;\n+  true_rtx = attr_rtx (CONST_INT, 1);\n+  false_rtx = attr_rtx (CONST_INT, 0);\n   RTX_UNCHANGING_P (true_rtx) = RTX_UNCHANGING_P (false_rtx) = 1;\n \n   printf (\"/* Generated automatically by the program `genattrtab'\\n\\"}]}