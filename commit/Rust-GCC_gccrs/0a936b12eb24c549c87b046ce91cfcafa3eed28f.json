{"sha": "0a936b12eb24c549c87b046ce91cfcafa3eed28f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE5MzZiMTJlYjI0YzU0OWM4N2IwNDZjZTkxY2ZjYWZhM2VlZDI4Zg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-08-20T16:09:00Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-08-20T16:09:00Z"}, "message": "fold-const.c (round_up, round_down): Use build_int_cst.\n\n\t* fold-const.c (round_up, round_down): Use build_int_cst.\n\tOptimize common case.\n\nFrom-SVN: r86329", "tree": {"sha": "58d468965233da783869c90ceb03c1542341e79c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58d468965233da783869c90ceb03c1542341e79c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a936b12eb24c549c87b046ce91cfcafa3eed28f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a936b12eb24c549c87b046ce91cfcafa3eed28f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a936b12eb24c549c87b046ce91cfcafa3eed28f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a936b12eb24c549c87b046ce91cfcafa3eed28f/comments", "author": null, "committer": null, "parents": [{"sha": "dd8b67a1a87d69e5204da7bb0cb8dabaea839650", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd8b67a1a87d69e5204da7bb0cb8dabaea839650", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd8b67a1a87d69e5204da7bb0cb8dabaea839650"}], "stats": {"total": 60, "additions": 43, "deletions": 17}, "files": [{"sha": "eaadc038c3290240aac5af9cdf526d6f0c74c66d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a936b12eb24c549c87b046ce91cfcafa3eed28f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a936b12eb24c549c87b046ce91cfcafa3eed28f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a936b12eb24c549c87b046ce91cfcafa3eed28f", "patch": "@@ -1,11 +1,17 @@\n+2004-08-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* fold-const.c (round_up, round_down): Use build_int_cst.\n+\tOptimize common case.\n+\n 2004-08-20  Zack Weinberg  <zack@codesourcery.com>\n \t    John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n         * config/pa/pa-protos.h (readonly_data, one_only_readonly_data_section,\n \tone_only_data_section): Rename to som_readonly_data_section,\n \tsom_one_only_readonly_data_section and som_one_only_data_section.\n-        * config/pa/pa.c (ONE_ONLY_TEXT_SECTION_ASM_OP, NEW_TEXT_SECTION_ASM_OP,\n-\tDEFAULT_TEXT_SECTION_ASM_OP): Delete conditional defines.\n+        * config/pa/pa.c (ONE_ONLY_TEXT_SECTION_ASM_OP,\n+\tNEW_TEXT_SECTION_ASM_OP, DEFAULT_TEXT_SECTION_ASM_OP): Delete\n+\tconditional defines.\n \t(som_text_section_asm_op): Replace ONE_ONLY_TEXT_SECTION_ASM_OP,\n \tNEW_TEXT_SECTION_ASM_OP and DEFAULT_TEXT_SECTION_ASM_OP with actual\n \tstring values."}, {"sha": "e85ead88b32ec51ee1f805c7bd07818bce314f39", "filename": "gcc/fold-const.c", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a936b12eb24c549c87b046ce91cfcafa3eed28f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a936b12eb24c549c87b046ce91cfcafa3eed28f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=0a936b12eb24c549c87b046ce91cfcafa3eed28f", "patch": "@@ -10661,30 +10661,39 @@ fold_ignored_result (tree t)\n tree\n round_up (tree value, int divisor)\n {\n-  tree div, t;\n+  tree div = NULL_TREE;\n \n-  if (divisor == 0)\n+  if (divisor <= 0)\n     abort ();\n   if (divisor == 1)\n     return value;\n \n-  div = size_int_type (divisor, TREE_TYPE (value));\n-\n   /* See if VALUE is already a multiple of DIVISOR.  If so, we don't\n-     have to do anything.  */\n-  if (multiple_of_p (TREE_TYPE (value), value, div))\n-    return value;\n+     have to do anything.  Only do this when we are not given a const,\n+     because in that case, this check is more expensive than just\n+     doing it. */\n+  if (TREE_CODE (value) != INTEGER_CST)\n+    {\n+      div = size_int_type (divisor, TREE_TYPE (value));\n+\n+      if (multiple_of_p (TREE_TYPE (value), value, div))\n+\treturn value;\n+    }\n \n   /* If divisor is a power of two, simplify this to bit manipulation.  */\n   if (divisor == (divisor & -divisor))\n     {\n-      t = size_int_type (divisor - 1, TREE_TYPE (value));\n+      tree t;\n+      \n+      t = build_int_cst (TREE_TYPE (value), divisor - 1, 0);\n       value = size_binop (PLUS_EXPR, value, t);\n-      t = size_int_type (-divisor, TREE_TYPE (value));\n+      t = build_int_cst (TREE_TYPE (value), -divisor, -1);\n       value = size_binop (BIT_AND_EXPR, value, t);\n     }\n   else\n     {\n+      if (!div)\n+\tdiv = size_int_type (divisor, TREE_TYPE (value));\n       value = size_binop (CEIL_DIV_EXPR, value, div);\n       value = size_binop (MULT_EXPR, value, div);\n     }\n@@ -10697,28 +10706,39 @@ round_up (tree value, int divisor)\n tree\n round_down (tree value, int divisor)\n {\n-  tree div, t;\n+  tree div = NULL_TREE;\n \n-  if (divisor == 0)\n+  if (divisor <= 0)\n     abort ();\n   if (divisor == 1)\n     return value;\n \n   div = size_int_type (divisor, TREE_TYPE (value));\n \n   /* See if VALUE is already a multiple of DIVISOR.  If so, we don't\n-     have to do anything.  */\n-  if (multiple_of_p (TREE_TYPE (value), value, div))\n-    return value;\n+     have to do anything.  Only do this when we are not given a const,\n+     because in that case, this check is more expensive than just\n+     doing it. */\n+  if (TREE_CODE (value) != INTEGER_CST)\n+    {\n+      div = size_int_type (divisor, TREE_TYPE (value));\n+\n+      if (multiple_of_p (TREE_TYPE (value), value, div))\n+\treturn value;\n+    }\n \n   /* If divisor is a power of two, simplify this to bit manipulation.  */\n   if (divisor == (divisor & -divisor))\n     {\n-      t = size_int_type (-divisor, TREE_TYPE (value));\n+      tree t;\n+      \n+      t = build_int_cst (TREE_TYPE (value), -divisor, -1);\n       value = size_binop (BIT_AND_EXPR, value, t);\n     }\n   else\n     {\n+      if (!div)\n+\tdiv = size_int_type (divisor, TREE_TYPE (value));\n       value = size_binop (FLOOR_DIV_EXPR, value, div);\n       value = size_binop (MULT_EXPR, value, div);\n     }"}]}