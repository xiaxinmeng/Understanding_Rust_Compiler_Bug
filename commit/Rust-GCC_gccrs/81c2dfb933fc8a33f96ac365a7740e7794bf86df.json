{"sha": "81c2dfb933fc8a33f96ac365a7740e7794bf86df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFjMmRmYjkzM2ZjOGEzM2Y5NmFjMzY1YTc3NDBlNzc5NGJmODZkZg==", "commit": {"author": {"name": "Ian Bolton", "email": "ian.bolton@arm.com", "date": "2013-06-04T16:19:17Z"}, "committer": {"name": "Ian Bolton", "email": "ibolton@gcc.gnu.org", "date": "2013-06-04T16:19:17Z"}, "message": "AArch64 - Improve MOVI handling (4/5)\n\nFrom-SVN: r199657", "tree": {"sha": "9b8368dc4ca0bb008d136582722c34bcc2497230", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b8368dc4ca0bb008d136582722c34bcc2497230"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81c2dfb933fc8a33f96ac365a7740e7794bf86df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81c2dfb933fc8a33f96ac365a7740e7794bf86df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81c2dfb933fc8a33f96ac365a7740e7794bf86df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81c2dfb933fc8a33f96ac365a7740e7794bf86df/comments", "author": null, "committer": null, "parents": [{"sha": "48063b9d4147d72526d57ce12bb410edebf10d2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48063b9d4147d72526d57ce12bb410edebf10d2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48063b9d4147d72526d57ce12bb410edebf10d2c"}], "stats": {"total": 50, "additions": 28, "deletions": 22}, "files": [{"sha": "105a99b35cb806c7956b97775c37d6bbe5a6c103", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81c2dfb933fc8a33f96ac365a7740e7794bf86df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81c2dfb933fc8a33f96ac365a7740e7794bf86df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81c2dfb933fc8a33f96ac365a7740e7794bf86df", "patch": "@@ -1,3 +1,17 @@\n+2013-06-04  Ian Bolton  <ian.bolton@arm.com>\n+\n+\t* config/aarch64/aarch64.c (simd_immediate_info): Remove\n+\telement_char member.\n+\t(sizetochar): Return signed char.\n+\t(aarch64_simd_valid_immediate): Remove elchar and other\n+\tunnecessary variables.\n+\t(aarch64_output_simd_mov_immediate): Take rtx instead of &rtx.\n+\tCalculate element_char as required.\n+\t* config/aarch64/aarch64-protos.h: Update and move prototype\n+\tfor aarch64_output_simd_mov_immediate.\n+\t* config/aarch64/aarch64-simd.md (*aarch64_simd_mov<mode>):\n+\tUpdate arguments.\n+\n 2013-06-04  Ian Bolton  <ian.bolton@arm.com>\n \n \t* config/aarch64/aarch64.c (simd_immediate_info): Struct to hold"}, {"sha": "81b5b6a342741f5cd5d1a829ec7001ead682726c", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81c2dfb933fc8a33f96ac365a7740e7794bf86df/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81c2dfb933fc8a33f96ac365a7740e7794bf86df/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=81c2dfb933fc8a33f96ac365a7740e7794bf86df", "patch": "@@ -149,6 +149,7 @@ bool aarch64_legitimate_pic_operand_p (rtx);\n bool aarch64_move_imm (HOST_WIDE_INT, enum machine_mode);\n bool aarch64_mov_operand_p (rtx, enum aarch64_symbol_context,\n \t\t\t    enum machine_mode);\n+char *aarch64_output_simd_mov_immediate (rtx, enum machine_mode, unsigned);\n bool aarch64_pad_arg_upward (enum machine_mode, const_tree);\n bool aarch64_pad_reg_upward (enum machine_mode, const_tree, bool);\n bool aarch64_regno_ok_for_base_p (int, bool);\n@@ -259,6 +260,4 @@ extern void aarch64_split_combinev16qi (rtx operands[3]);\n extern void aarch64_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel);\n extern bool\n aarch64_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel);\n-\n-char* aarch64_output_simd_mov_immediate (rtx *, enum machine_mode, unsigned);\n #endif /* GCC_AARCH64_PROTOS_H */"}, {"sha": "e5990d4141e2e372bb6e425d34cf1030a8110b10", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81c2dfb933fc8a33f96ac365a7740e7794bf86df/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81c2dfb933fc8a33f96ac365a7740e7794bf86df/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=81c2dfb933fc8a33f96ac365a7740e7794bf86df", "patch": "@@ -409,7 +409,7 @@\n      case 4: return \"ins\\t%0.d[0], %1\";\n      case 5: return \"mov\\t%0, %1\";\n      case 6:\n-\treturn aarch64_output_simd_mov_immediate (&operands[1],\n+\treturn aarch64_output_simd_mov_immediate (operands[1],\n \t\t\t\t\t\t  <MODE>mode, 64);\n      default: gcc_unreachable ();\n      }\n@@ -440,7 +440,7 @@\n     case 5:\n \treturn \"#\";\n     case 6:\n-\treturn aarch64_output_simd_mov_immediate (&operands[1], <MODE>mode, 128);\n+\treturn aarch64_output_simd_mov_immediate (operands[1], <MODE>mode, 128);\n     default:\n \tgcc_unreachable ();\n     }"}, {"sha": "5b7cf27af1e6ececa133c1dc52a49af6c93498ec", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81c2dfb933fc8a33f96ac365a7740e7794bf86df/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81c2dfb933fc8a33f96ac365a7740e7794bf86df/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=81c2dfb933fc8a33f96ac365a7740e7794bf86df", "patch": "@@ -92,7 +92,6 @@ struct simd_immediate_info\n   rtx value;\n   int shift;\n   int element_width;\n-  unsigned char element_char;\n   bool mvn;\n };\n \n@@ -6103,7 +6102,7 @@ aarch64_mangle_type (const_tree type)\n }\n \n /* Return the equivalent letter for size.  */\n-static unsigned char\n+static char\n sizetochar (int size)\n {\n   switch (size)\n@@ -6164,7 +6163,6 @@ aarch64_simd_valid_immediate (rtx op, enum machine_mode mode, bool inverse,\n     {\t\t\t\t\t\t\t\\\n       immtype = (CLASS);\t\t\t\t\\\n       elsize = (ELSIZE);\t\t\t\t\\\n-      elchar = sizetochar (elsize);\t\t\t\\\n       eshift = (SHIFT);\t\t\t\t\t\\\n       emvn = (NEG);\t\t\t\t\t\\\n       break;\t\t\t\t\t\t\\\n@@ -6173,25 +6171,20 @@ aarch64_simd_valid_immediate (rtx op, enum machine_mode mode, bool inverse,\n   unsigned int i, elsize = 0, idx = 0, n_elts = CONST_VECTOR_NUNITS (op);\n   unsigned int innersize = GET_MODE_SIZE (GET_MODE_INNER (mode));\n   unsigned char bytes[16];\n-  unsigned char elchar = 0;\n   int immtype = -1, matches;\n   unsigned int invmask = inverse ? 0xff : 0;\n   int eshift, emvn;\n \n   if (GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n     {\n-      bool simd_imm_zero = aarch64_simd_imm_zero_p (op, mode);\n-      int elem_width = GET_MODE_BITSIZE (GET_MODE (CONST_VECTOR_ELT (op, 0)));\n-\n-      if (!(simd_imm_zero\n-\t    || aarch64_vect_float_const_representable_p (op)))\n+      if (! (aarch64_simd_imm_zero_p (op, mode)\n+\t     || aarch64_vect_float_const_representable_p (op)))\n \treturn false;\n \n       if (info)\n \t{\n \t  info->value = CONST_VECTOR_ELT (op, 0);\n-\t  info->element_width = elem_width;\n-\t  info->element_char = sizetochar (elem_width);\n+\t  info->element_width = GET_MODE_BITSIZE (GET_MODE (info->value));\n \t  info->mvn = false;\n \t  info->shift = 0;\n \t}\n@@ -6299,7 +6292,6 @@ aarch64_simd_valid_immediate (rtx op, enum machine_mode mode, bool inverse,\n   if (info)\n     {\n       info->element_width = elsize;\n-      info->element_char = elchar;\n       info->mvn = emvn != 0;\n       info->shift = eshift;\n \n@@ -7230,24 +7222,25 @@ aarch64_float_const_representable_p (rtx x)\n }\n \n char*\n-aarch64_output_simd_mov_immediate (rtx *const_vector,\n+aarch64_output_simd_mov_immediate (rtx const_vector,\n \t\t\t\t   enum machine_mode mode,\n \t\t\t\t   unsigned width)\n {\n   bool is_valid;\n   static char templ[40];\n   const char *mnemonic;\n   unsigned int lane_count = 0;\n+  char element_char;\n \n   struct simd_immediate_info info;\n \n   /* This will return true to show const_vector is legal for use as either\n      a AdvSIMD MOVI instruction (or, implicitly, MVNI) immediate.  It will\n      also update INFO to show how the immediate should be generated.  */\n-  is_valid = aarch64_simd_valid_immediate (*const_vector, mode, false, &info);\n+  is_valid = aarch64_simd_valid_immediate (const_vector, mode, false, &info);\n   gcc_assert (is_valid);\n \n-  gcc_assert (info.element_width != 0);\n+  element_char = sizetochar (info.element_width);\n   lane_count = width / info.element_width;\n \n   mode = GET_MODE_INNER (mode);\n@@ -7269,7 +7262,7 @@ aarch64_output_simd_mov_immediate (rtx *const_vector,\n \t    snprintf (templ, sizeof (templ), \"fmov\\t%%d0, %s\", float_buf);\n \t  else\n \t    snprintf (templ, sizeof (templ), \"fmov\\t%%0.%d%c, %s\",\n-\t\t      lane_count, info.element_char, float_buf);\n+\t\t      lane_count, element_char, float_buf);\n \t  return templ;\n \t}\n     }\n@@ -7281,11 +7274,11 @@ aarch64_output_simd_mov_immediate (rtx *const_vector,\n \t      mnemonic, UINTVAL (info.value));\n   else if (info.shift)\n     snprintf (templ, sizeof (templ), \"%s\\t%%0.%d%c, \" HOST_WIDE_INT_PRINT_HEX\n-\t      \", lsl %d\", mnemonic, lane_count, info.element_char,\n+\t      \", lsl %d\", mnemonic, lane_count, element_char,\n \t      UINTVAL (info.value), info.shift);\n   else\n     snprintf (templ, sizeof (templ), \"%s\\t%%0.%d%c, \" HOST_WIDE_INT_PRINT_HEX,\n-\t      mnemonic, lane_count, info.element_char, UINTVAL (info.value));\n+\t      mnemonic, lane_count, element_char, UINTVAL (info.value));\n   return templ;\n }\n "}]}