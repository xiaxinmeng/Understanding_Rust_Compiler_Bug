{"sha": "0cae8d31e7c7615774ef857f85a1fc84526ebc07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNhZThkMzFlN2M3NjE1Nzc0ZWY4NTdmODVhMWZjODQ1MjZlYmMwNw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2013-11-19T01:13:23Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2013-11-19T01:13:23Z"}, "message": "Eliminate n_basic_blocks macro\n\ngcc/\n\t* basic-block.h (n_basic_blocks_for_function): Rename macro to...\n\t(n_basic_blocks_for_fn): ...this.\n\n\t(n_basic_blocks): Eliminate macro as work towards making uses of\n\tcfun be explicit.\n\n\t* cfgloop.c (init_loops_structure): Update for renaming of\n\t\"n_basic_blocks_for_function\" to \"n_basic_blocks_for_fn\".\n\t* graph.c (draw_cfg_nodes_no_loops): Likewise.\n\t* ipa-utils.c (ipa_merge_profiles): Likewise.\n\t* lto-streamer-in.c (make_new_block): Likewise.\n\t* tree-cfg.c (init_empty_tree_cfg_for_function): Likewise.\n\t(dump_function_to_file): Likewise.\n\n\t* alias.c (init_alias_analysis): Replace usage of \"n_basic_blocks\"\n\tmacro with \"n_basic_blocks_for_fn (cfun)\".\n\t* bb-reorder.c (partition_hot_cold_basic_blocks): Likewise.\n\t(duplicate_computed_gotos): Likewise.\n\t(reorder_basic_blocks): Likewise.\n\t* bt-load.c (augment_live_range): Likewise.\n\t* cfg.c (expunge_block): Likewise.\n\t(compact_blocks): Likewise.\n\t* cfganal.c (single_pred_before_succ_order): Likewise.\n\t(compute_idf): Likewise.\n\t(flow_dfs_compute_reverse_init): Likewise.\n\t(pre_and_rev_post_order_compute): Likewise.\n\t(pre_and_rev_post_order_compute_fn): Likewise.\n\t(inverted_post_order_compute): Likewise.\n\t(post_order_compute): Likewise.\n\t(print_edge_list): Likewise.\n\t(find_unreachable_blocks): Likewise.\n\t(mark_dfs_back_edges): Likewise.\n\t* cfgcleanup.c (try_optimize_cfg): Likewise.\n\t(try_forward_edges): Likewise.\n\t* cfghooks.c (dump_flow_info): Likewise.\n\t* cfgloop.c (verify_loop_structure): Likewise.\n\t(get_loop_body): Likewise.\n\t(flow_loops_find): Likewise.\n\t* cfgloopmanip.c (add_loop): Likewise.\n\t(remove_path): Likewise.\n\t(find_path): Likewise.\n\t* cfgrtl.c (rtl_flow_call_edges_add): Likewise.\n\t(rtl_verify_bb_layout): Likewise.\n\t(entry_of_function): Likewise.\n\t(rtl_create_basic_block): Likewise.\n\t* coverage.c (coverage_compute_cfg_checksum): Likewise.\n\t* cprop.c (one_cprop_pass): Likewise.\n\t(is_too_expensive): Likewise.\n\t* df-core.c (df_compute_cfg_image): Likewise.\n\t(df_compact_blocks): Likewise.\n\t(df_worklist_dataflow_doublequeue): Likewise.\n\t* dominance.c (calculate_dominance_info): Likewise.\n\t(calc_dfs_tree): Likewise.\n\t(calc_dfs_tree_nonrec): Likewise.\n\t(init_dom_info): Likewise.\n\t* domwalk.c (cmp_bb_postorder): Likewise.\n\t* function.c (thread_prologue_and_epilogue_insns): Likewise.\n\t(generate_setjmp_warnings): Likewise.\n\t* fwprop.c (build_single_def_use_links): Likewise.\n\t* gcse.c (is_too_expensive): Likewise.\n\t(one_code_hoisting_pass): Likewise.\n\t(one_pre_gcse_pass): Likewise.\n\t* graphite.c (graphite_initialize): Likewise.\n\t* haifa-sched.c (haifa_sched_init): Likewise.\n\t* ipa-inline-analysis.c (estimate_function_body_sizes): Likewise.\n\t* ira.c (split_live_ranges_for_shrink_wrap): Likewise.\n\t* ira-build.c (ira_build): Likewise.\n\t* lcm.c (compute_nearerout): Likewise.\n\t(compute_available): Likewise.\n\t(compute_laterin): Likewise.\n\t(compute_antinout_edge): Likewise.\n\t* lra-lives.c (lra_create_live_ranges): Likewise.\n\t* lra.c (has_nonexceptional_receiver): Likewise.\n\t* mcf.c (create_fixup_graph): Likewise.\n\t* profile.c (branch_prob): Likewise.\n\t* reg-stack.c (convert_regs_2): Likewise.\n\t* regrename.c (regrename_analyze): Likewise.\n\t* reload1.c (has_nonexceptional_receiver): Likewise.\n\t* reorg.c (dbr_schedule): Likewise.\n\t* sched-deps.c (sched_deps_init): Likewise.\n\t* sched-ebb.c (schedule_ebbs): Likewise.\n\t* sched-rgn.c (extend_regions): Likewise.\n\t(schedule_insns): Likewise.\n\t(sched_rgn_init): Likewise.\n\t(extend_rgns): Likewise.\n\t(haifa_find_rgns): Likewise.\n\t* sel-sched-ir.c (recompute_rev_top_order): Likewise.\n\t(sel_recompute_toporder): Likewise.\n\t* sel-sched.c (run_selective_scheduling): Likewise.\n\t* store-motion.c (one_store_motion_pass): Likewise.\n\t(remove_reachable_equiv_notes): Likewise.\n\t* tracer.c (tracer): Likewise.\n\t(tail_duplicate): Likewise.\n\t* tree-cfg.c (gimple_flow_call_edges_add): Likewise.\n\t(dump_cfg_stats): Likewise.\n\t(gimple_dump_cfg): Likewise.\n\t(create_bb): Likewise.\n\t(build_gimple_cfg): Likewise.\n\t* tree-cfgcleanup.c (merge_phi_nodes): Likewise.\n\t* tree-inline.c (optimize_inline_calls): Likewise.\n\t(fold_marked_statements): Likewise.\n\t* tree-ssa-ifcombine.c (tree_ssa_ifcombine): Likewise.\n\t* tree-ssa-loop-ch.c (copy_loop_headers): Likewise.\n\t* tree-ssa-loop-im.c (analyze_memory_references): Likewise.\n\t* tree-ssa-loop-manip.c (compute_live_loop_exits): Likewise.\n\t* tree-ssa-math-opts.c (execute_cse_reciprocals): Likewise.\n\t* tree-ssa-phiopt.c (tree_ssa_phiopt_worker): Likewise.\n\t* tree-ssa-pre.c (do_pre): Likewise.\n\t(init_pre): Likewise.\n\t(compute_avail): Likewise.\n\t* tree-ssa-reassoc.c (init_reassoc): Likewise.\n\t* tree-ssa-sccvn.c (init_scc_vn): Likewise.\n\t* tree-ssa-tail-merge.c (alloc_cluster_vectors): Likewise.\n\t(init_worklist): Likewise.\n\t* tree-ssa-uncprop.c (associate_equivalences_with_edges): Likewise.\n\t* var-tracking.c (variable_tracking_main_1): Likewise.\n\t(vt_find_locations): Likewise.\n\t(vt_stack_adjustments): Likewise.\n\t* config/s390/s390.c (s390_optimize_nonescaping_tx): Likewise.\n\t* config/spu/spu.c (spu_machine_dependent_reorg): Likewise.\n\nFrom-SVN: r204995", "tree": {"sha": "8cef98dc40ed3f38669a1f1cd297fee1cf7b8c46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cef98dc40ed3f38669a1f1cd297fee1cf7b8c46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0cae8d31e7c7615774ef857f85a1fc84526ebc07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cae8d31e7c7615774ef857f85a1fc84526ebc07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cae8d31e7c7615774ef857f85a1fc84526ebc07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cae8d31e7c7615774ef857f85a1fc84526ebc07/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "49579c7e20da4cf0dc82bf1c8458bf4fc7a38007", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49579c7e20da4cf0dc82bf1c8458bf4fc7a38007"}], "stats": {"total": 481, "additions": 309, "deletions": 172}, "files": [{"sha": "9d560ed0a7a94b395a6a597012aa55d38a3271d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -1,3 +1,126 @@\n+2013-11-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* basic-block.h (n_basic_blocks_for_function): Rename macro to...\n+\t(n_basic_blocks_for_fn): ...this.\n+\n+\t(n_basic_blocks): Eliminate macro as work towards making uses of\n+\tcfun be explicit.\n+\n+\t* cfgloop.c (init_loops_structure): Update for renaming of\n+\t\"n_basic_blocks_for_function\" to \"n_basic_blocks_for_fn\".\n+\t* graph.c (draw_cfg_nodes_no_loops): Likewise.\n+\t* ipa-utils.c (ipa_merge_profiles): Likewise.\n+\t* lto-streamer-in.c (make_new_block): Likewise.\n+\t* tree-cfg.c (init_empty_tree_cfg_for_function): Likewise.\n+\t(dump_function_to_file): Likewise.\n+\n+\t* alias.c (init_alias_analysis): Replace usage of \"n_basic_blocks\"\n+\tmacro with \"n_basic_blocks_for_fn (cfun)\".\n+\t* bb-reorder.c (partition_hot_cold_basic_blocks): Likewise.\n+\t(duplicate_computed_gotos): Likewise.\n+\t(reorder_basic_blocks): Likewise.\n+\t* bt-load.c (augment_live_range): Likewise.\n+\t* cfg.c (expunge_block): Likewise.\n+\t(compact_blocks): Likewise.\n+\t* cfganal.c (single_pred_before_succ_order): Likewise.\n+\t(compute_idf): Likewise.\n+\t(flow_dfs_compute_reverse_init): Likewise.\n+\t(pre_and_rev_post_order_compute): Likewise.\n+\t(pre_and_rev_post_order_compute_fn): Likewise.\n+\t(inverted_post_order_compute): Likewise.\n+\t(post_order_compute): Likewise.\n+\t(print_edge_list): Likewise.\n+\t(find_unreachable_blocks): Likewise.\n+\t(mark_dfs_back_edges): Likewise.\n+\t* cfgcleanup.c (try_optimize_cfg): Likewise.\n+\t(try_forward_edges): Likewise.\n+\t* cfghooks.c (dump_flow_info): Likewise.\n+\t* cfgloop.c (verify_loop_structure): Likewise.\n+\t(get_loop_body): Likewise.\n+\t(flow_loops_find): Likewise.\n+\t* cfgloopmanip.c (add_loop): Likewise.\n+\t(remove_path): Likewise.\n+\t(find_path): Likewise.\n+\t* cfgrtl.c (rtl_flow_call_edges_add): Likewise.\n+\t(rtl_verify_bb_layout): Likewise.\n+\t(entry_of_function): Likewise.\n+\t(rtl_create_basic_block): Likewise.\n+\t* coverage.c (coverage_compute_cfg_checksum): Likewise.\n+\t* cprop.c (one_cprop_pass): Likewise.\n+\t(is_too_expensive): Likewise.\n+\t* df-core.c (df_compute_cfg_image): Likewise.\n+\t(df_compact_blocks): Likewise.\n+\t(df_worklist_dataflow_doublequeue): Likewise.\n+\t* dominance.c (calculate_dominance_info): Likewise.\n+\t(calc_dfs_tree): Likewise.\n+\t(calc_dfs_tree_nonrec): Likewise.\n+\t(init_dom_info): Likewise.\n+\t* domwalk.c (cmp_bb_postorder): Likewise.\n+\t* function.c (thread_prologue_and_epilogue_insns): Likewise.\n+\t(generate_setjmp_warnings): Likewise.\n+\t* fwprop.c (build_single_def_use_links): Likewise.\n+\t* gcse.c (is_too_expensive): Likewise.\n+\t(one_code_hoisting_pass): Likewise.\n+\t(one_pre_gcse_pass): Likewise.\n+\t* graphite.c (graphite_initialize): Likewise.\n+\t* haifa-sched.c (haifa_sched_init): Likewise.\n+\t* ipa-inline-analysis.c (estimate_function_body_sizes): Likewise.\n+\t* ira.c (split_live_ranges_for_shrink_wrap): Likewise.\n+\t* ira-build.c (ira_build): Likewise.\n+\t* lcm.c (compute_nearerout): Likewise.\n+\t(compute_available): Likewise.\n+\t(compute_laterin): Likewise.\n+\t(compute_antinout_edge): Likewise.\n+\t* lra-lives.c (lra_create_live_ranges): Likewise.\n+\t* lra.c (has_nonexceptional_receiver): Likewise.\n+\t* mcf.c (create_fixup_graph): Likewise.\n+\t* profile.c (branch_prob): Likewise.\n+\t* reg-stack.c (convert_regs_2): Likewise.\n+\t* regrename.c (regrename_analyze): Likewise.\n+\t* reload1.c (has_nonexceptional_receiver): Likewise.\n+\t* reorg.c (dbr_schedule): Likewise.\n+\t* sched-deps.c (sched_deps_init): Likewise.\n+\t* sched-ebb.c (schedule_ebbs): Likewise.\n+\t* sched-rgn.c (extend_regions): Likewise.\n+\t(schedule_insns): Likewise.\n+\t(sched_rgn_init): Likewise.\n+\t(extend_rgns): Likewise.\n+\t(haifa_find_rgns): Likewise.\n+\t* sel-sched-ir.c (recompute_rev_top_order): Likewise.\n+\t(sel_recompute_toporder): Likewise.\n+\t* sel-sched.c (run_selective_scheduling): Likewise.\n+\t* store-motion.c (one_store_motion_pass): Likewise.\n+\t(remove_reachable_equiv_notes): Likewise.\n+\t* tracer.c (tracer): Likewise.\n+\t(tail_duplicate): Likewise.\n+\t* tree-cfg.c (gimple_flow_call_edges_add): Likewise.\n+\t(dump_cfg_stats): Likewise.\n+\t(gimple_dump_cfg): Likewise.\n+\t(create_bb): Likewise.\n+\t(build_gimple_cfg): Likewise.\n+\t* tree-cfgcleanup.c (merge_phi_nodes): Likewise.\n+\t* tree-inline.c (optimize_inline_calls): Likewise.\n+\t(fold_marked_statements): Likewise.\n+\t* tree-ssa-ifcombine.c (tree_ssa_ifcombine): Likewise.\n+\t* tree-ssa-loop-ch.c (copy_loop_headers): Likewise.\n+\t* tree-ssa-loop-im.c (analyze_memory_references): Likewise.\n+\t* tree-ssa-loop-manip.c (compute_live_loop_exits): Likewise.\n+\t* tree-ssa-math-opts.c (execute_cse_reciprocals): Likewise.\n+\t* tree-ssa-phiopt.c (tree_ssa_phiopt_worker): Likewise.\n+\t* tree-ssa-pre.c (do_pre): Likewise.\n+\t(init_pre): Likewise.\n+\t(compute_avail): Likewise.\n+\t* tree-ssa-reassoc.c (init_reassoc): Likewise.\n+\t* tree-ssa-sccvn.c (init_scc_vn): Likewise.\n+\t* tree-ssa-tail-merge.c (alloc_cluster_vectors): Likewise.\n+\t(init_worklist): Likewise.\n+\t* tree-ssa-uncprop.c (associate_equivalences_with_edges): Likewise.\n+\t* var-tracking.c (variable_tracking_main_1): Likewise.\n+\t(vt_find_locations): Likewise.\n+\t(vt_stack_adjustments): Likewise.\n+\t* config/s390/s390.c (s390_optimize_nonescaping_tx): Likewise.\n+\t* config/spu/spu.c (spu_machine_dependent_reorg): Likewise.\n+\n 2013-11-18  Jan Hubicka  <jh@suse.cz>\n \n \t* profile.c (compute_branch_probabilities): Do not sanity check run_max."}, {"sha": "f0bb32bf32849b580a2d42a0e8de90315b2de4ce", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -2952,7 +2952,7 @@ init_alias_analysis (void)\n      The state of the arrays for the set chain in question does not matter\n      since the program has undefined behavior.  */\n \n-  rpo = XNEWVEC (int, n_basic_blocks);\n+  rpo = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n   rpo_cnt = pre_and_rev_post_order_compute (NULL, rpo, false);\n \n   pass = 0;"}, {"sha": "d247d4f4509018fee4416d357d72deec98723747", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -315,7 +315,7 @@ struct GTY(()) control_flow_graph {\n #define ENTRY_BLOCK_PTR_FOR_FUNCTION(FN)     ((FN)->cfg->x_entry_block_ptr)\n #define EXIT_BLOCK_PTR_FOR_FUNCTION(FN)\t     ((FN)->cfg->x_exit_block_ptr)\n #define basic_block_info_for_function(FN)    ((FN)->cfg->x_basic_block_info)\n-#define n_basic_blocks_for_function(FN)\t     ((FN)->cfg->x_n_basic_blocks)\n+#define n_basic_blocks_for_fn(FN)\t     ((FN)->cfg->x_n_basic_blocks)\n #define n_edges_for_function(FN)\t     ((FN)->cfg->x_n_edges)\n #define last_basic_block_for_function(FN)    ((FN)->cfg->x_last_basic_block)\n #define label_to_block_map_for_function(FN)  ((FN)->cfg->x_label_to_block_map)\n@@ -330,7 +330,6 @@ struct GTY(()) control_flow_graph {\n #define ENTRY_BLOCK_PTR\t\t(cfun->cfg->x_entry_block_ptr)\n #define EXIT_BLOCK_PTR\t\t(cfun->cfg->x_exit_block_ptr)\n #define basic_block_info\t(cfun->cfg->x_basic_block_info)\n-#define n_basic_blocks\t\t(cfun->cfg->x_n_basic_blocks)\n #define n_edges\t\t\t(cfun->cfg->x_n_edges)\n #define last_basic_block\t(cfun->cfg->x_last_basic_block)\n #define label_to_block_map\t(cfun->cfg->x_label_to_block_map)"}, {"sha": "45bf1289ec0772c9b8455a3e5487701cb2e88ca5", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -2220,7 +2220,7 @@ reorder_basic_blocks (void)\n \n   gcc_assert (current_ir_type () == IR_RTL_CFGLAYOUT);\n \n-  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n+  if (n_basic_blocks_for_fn (cfun) <= NUM_FIXED_BLOCKS + 1)\n     return;\n \n   set_edge_can_fallthru_flag ();\n@@ -2244,7 +2244,7 @@ reorder_basic_blocks (void)\n       bbd[i].node = NULL;\n     }\n \n-  traces = XNEWVEC (struct trace, n_basic_blocks);\n+  traces = XNEWVEC (struct trace, n_basic_blocks_for_fn (cfun));\n   n_traces = 0;\n   find_traces (&n_traces, traces);\n   connect_traces (n_traces, traces);\n@@ -2388,7 +2388,7 @@ duplicate_computed_gotos (void)\n   bitmap candidates;\n   int max_size;\n \n-  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n+  if (n_basic_blocks_for_fn (cfun) <= NUM_FIXED_BLOCKS + 1)\n     return 0;\n \n   clear_bb_flags ();\n@@ -2640,7 +2640,7 @@ partition_hot_cold_basic_blocks (void)\n {\n   vec<edge> crossing_edges;\n \n-  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n+  if (n_basic_blocks_for_fn (cfun) <= NUM_FIXED_BLOCKS + 1)\n     return 0;\n \n   df_set_flags (DF_DEFER_INSN_RESCAN);"}, {"sha": "348e40bdb46dc3cd1d399b21c3163f915c0a2d5a", "filename": "gcc/bt-load.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -900,7 +900,7 @@ augment_live_range (bitmap live_range, HARD_REG_SET *btrs_live_in_range,\n {\n   basic_block *worklist, *tos;\n \n-  tos = worklist = XNEWVEC (basic_block, n_basic_blocks + 1);\n+  tos = worklist = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun) + 1);\n \n   if (dominated_by_p (CDI_DOMINATORS, new_bb, head_bb))\n     {"}, {"sha": "10791a778a25cb3c0d287f0fd59e5268f7c2a60a", "filename": "gcc/cfg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -169,12 +169,12 @@ compact_blocks (void)\n \t  bb->index = i;\n \t  i++;\n \t}\n-      gcc_assert (i == n_basic_blocks);\n+      gcc_assert (i == n_basic_blocks_for_fn (cfun));\n \n       for (; i < last_basic_block; i++)\n \tSET_BASIC_BLOCK (i, NULL);\n     }\n-  last_basic_block = n_basic_blocks;\n+  last_basic_block = n_basic_blocks_for_fn (cfun);\n }\n \n /* Remove block B from the basic block array.  */\n@@ -184,7 +184,7 @@ expunge_block (basic_block b)\n {\n   unlink_block (b);\n   SET_BASIC_BLOCK (b->index, NULL);\n-  n_basic_blocks--;\n+  n_basic_blocks_for_fn (cfun)--;\n   /* We should be able to ggc_free here, but we are not.\n      The dead SSA_NAMES are left pointing to dead statements that are pointing\n      to dead basic blocks making garbage collector to die."}, {"sha": "1c90f8c5b7e7023adc3befb9c00a3eac71121caa", "filename": "gcc/cfganal.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -76,7 +76,7 @@ mark_dfs_back_edges (void)\n   post = XCNEWVEC (int, last_basic_block);\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = XNEWVEC (edge_iterator, n_basic_blocks + 1);\n+  stack = XNEWVEC (edge_iterator, n_basic_blocks_for_fn (cfun) + 1);\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -152,7 +152,7 @@ find_unreachable_blocks (void)\n   edge_iterator ei;\n   basic_block *tos, *worklist, bb;\n \n-  tos = worklist = XNEWVEC (basic_block, n_basic_blocks);\n+  tos = worklist = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n \n   /* Clear all the reachability flags.  */\n \n@@ -256,7 +256,7 @@ print_edge_list (FILE *f, struct edge_list *elist)\n   int x;\n \n   fprintf (f, \"Compressed edge list, %d BBs + entry & exit, and %d edges\\n\",\n-\t   n_basic_blocks, elist->num_edges);\n+\t   n_basic_blocks_for_fn (cfun), elist->num_edges);\n \n   for (x = 0; x < elist->num_edges; x++)\n     {\n@@ -609,7 +609,7 @@ post_order_compute (int *post_order, bool include_entry_exit,\n     post_order[post_order_num++] = EXIT_BLOCK;\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = XNEWVEC (edge_iterator, n_basic_blocks + 1);\n+  stack = XNEWVEC (edge_iterator, n_basic_blocks_for_fn (cfun) + 1);\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -667,7 +667,7 @@ post_order_compute (int *post_order, bool include_entry_exit,\n \n   /* Delete the unreachable blocks if some were found and we are\n      supposed to do it.  */\n-  if (delete_unreachable && (count != n_basic_blocks))\n+  if (delete_unreachable && (count != n_basic_blocks_for_fn (cfun)))\n     {\n       basic_block b;\n       basic_block next_bb;\n@@ -762,7 +762,7 @@ inverted_post_order_compute (int *post_order)\n   sbitmap visited;\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = XNEWVEC (edge_iterator, n_basic_blocks + 1);\n+  stack = XNEWVEC (edge_iterator, n_basic_blocks_for_fn (cfun) + 1);\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -898,11 +898,11 @@ pre_and_rev_post_order_compute_fn (struct function *fn,\n   edge_iterator *stack;\n   int sp;\n   int pre_order_num = 0;\n-  int rev_post_order_num = n_basic_blocks - 1;\n+  int rev_post_order_num = n_basic_blocks_for_fn (cfun) - 1;\n   sbitmap visited;\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = XNEWVEC (edge_iterator, n_basic_blocks + 1);\n+  stack = XNEWVEC (edge_iterator, n_basic_blocks_for_fn (cfun) + 1);\n   sp = 0;\n \n   if (include_entry_exit)\n@@ -1000,11 +1000,12 @@ pre_and_rev_post_order_compute (int *pre_order, int *rev_post_order,\n \t\t\t\t\t include_entry_exit);\n   if (include_entry_exit)\n     /* The number of nodes visited should be the number of blocks.  */\n-    gcc_assert (pre_order_num == n_basic_blocks);\n+    gcc_assert (pre_order_num == n_basic_blocks_for_fn (cfun));\n   else\n     /* The number of nodes visited should be the number of blocks minus\n        the entry and exit blocks which are not visited here.  */\n-    gcc_assert (pre_order_num == n_basic_blocks - NUM_FIXED_BLOCKS);\n+    gcc_assert (pre_order_num\n+\t\t== (n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS));\n \n   return pre_order_num;\n }\n@@ -1043,7 +1044,7 @@ static void\n flow_dfs_compute_reverse_init (depth_first_search_ds data)\n {\n   /* Allocate stack for back-tracking up CFG.  */\n-  data->stack = XNEWVEC (basic_block, n_basic_blocks);\n+  data->stack = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n   data->sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -1275,7 +1276,7 @@ compute_idf (bitmap def_blocks, bitmap_head *dfs)\n   bitmap phi_insertion_points;\n \n   /* Each block can appear at most twice on the work-stack.  */\n-  work_stack.create (2 * n_basic_blocks);\n+  work_stack.create (2 * n_basic_blocks_for_fn (cfun));\n   phi_insertion_points = BITMAP_ALLOC (NULL);\n \n   /* Seed the work list with all the blocks in DEF_BLOCKS.  We use\n@@ -1493,8 +1494,8 @@ basic_block *\n single_pred_before_succ_order (void)\n {\n   basic_block x, y;\n-  basic_block *order = XNEWVEC (basic_block, n_basic_blocks);\n-  unsigned n = n_basic_blocks - NUM_FIXED_BLOCKS;\n+  basic_block *order = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n+  unsigned n = n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS;\n   unsigned np, i;\n   sbitmap visited = sbitmap_alloc (last_basic_block);\n "}, {"sha": "a2192cbaf75fc0e10ef5e89db0b607d4e972c128", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -459,7 +459,7 @@ try_forward_edges (int mode, basic_block b)\n \t  && find_reg_note (BB_END (first), REG_CROSSING_JUMP, NULL_RTX))\n \treturn changed;\n \n-      while (counter < n_basic_blocks)\n+      while (counter < n_basic_blocks_for_fn (cfun))\n \t{\n \t  basic_block new_target = NULL;\n \t  bool new_target_threaded = false;\n@@ -472,7 +472,7 @@ try_forward_edges (int mode, basic_block b)\n \t      /* Bypass trivial infinite loops.  */\n \t      new_target = single_succ (target);\n \t      if (target == new_target)\n-\t\tcounter = n_basic_blocks;\n+\t\tcounter = n_basic_blocks_for_fn (cfun);\n \t      else if (!optimize)\n \t\t{\n \t\t  /* When not optimizing, ensure that edges or forwarder\n@@ -521,7 +521,8 @@ try_forward_edges (int mode, basic_block b)\n \t      if (t)\n \t\t{\n \t\t  if (!threaded_edges)\n-\t\t    threaded_edges = XNEWVEC (edge, n_basic_blocks);\n+\t\t    threaded_edges = XNEWVEC (edge,\n+\t\t\t\t\t      n_basic_blocks_for_fn (cfun));\n \t\t  else\n \t\t    {\n \t\t      int i;\n@@ -533,7 +534,7 @@ try_forward_edges (int mode, basic_block b)\n \t\t\t  break;\n \t\t      if (i < nthreaded_edges)\n \t\t\t{\n-\t\t\t  counter = n_basic_blocks;\n+\t\t\t  counter = n_basic_blocks_for_fn (cfun);\n \t\t\t  break;\n \t\t\t}\n \t\t    }\n@@ -542,7 +543,9 @@ try_forward_edges (int mode, basic_block b)\n \t\t  if (t->dest == b)\n \t\t    break;\n \n-\t\t  gcc_assert (nthreaded_edges < n_basic_blocks - NUM_FIXED_BLOCKS);\n+\t\t  gcc_assert (nthreaded_edges\n+\t\t\t      < (n_basic_blocks_for_fn (cfun)\n+\t\t\t\t - NUM_FIXED_BLOCKS));\n \t\t  threaded_edges[nthreaded_edges++] = t;\n \n \t\t  new_target = t->dest;\n@@ -558,7 +561,7 @@ try_forward_edges (int mode, basic_block b)\n \t  threaded |= new_target_threaded;\n \t}\n \n-      if (counter >= n_basic_blocks)\n+      if (counter >= n_basic_blocks_for_fn (cfun))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Infinite loop in BB %i.\\n\",\n@@ -2713,7 +2716,7 @@ try_optimize_cfg (int mode)\n \t\t  /* Note that forwarder_block_p true ensures that\n \t\t     there is a successor for this block.  */\n \t\t  && (single_succ_edge (b)->flags & EDGE_FALLTHRU)\n-\t\t  && n_basic_blocks > NUM_FIXED_BLOCKS + 1)\n+\t\t  && n_basic_blocks_for_fn (cfun) > NUM_FIXED_BLOCKS + 1)\n \t\t{\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file,"}, {"sha": "3016c54a9b10b7fa565d4a984b182a699a4daec0", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -323,7 +323,8 @@ dump_flow_info (FILE *file, int flags)\n {\n   basic_block bb;\n \n-  fprintf (file, \"\\n%d basic blocks, %d edges.\\n\", n_basic_blocks, n_edges);\n+  fprintf (file, \"\\n%d basic blocks, %d edges.\\n\", n_basic_blocks_for_fn (cfun),\n+\t   n_edges);\n   FOR_ALL_BB (bb)\n     dump_bb (file, bb, 0, flags);\n "}, {"sha": "20c58e4fa69995e1c225a710d4e499d87f8f0633", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -352,7 +352,7 @@ init_loops_structure (struct function *fn,\n \n   /* Dummy loop containing whole function.  */\n   root = alloc_loop ();\n-  root->num_nodes = n_basic_blocks_for_function (fn);\n+  root->num_nodes = n_basic_blocks_for_fn (fn);\n   root->latch = EXIT_BLOCK_PTR_FOR_FUNCTION (fn);\n   root->header = ENTRY_BLOCK_PTR_FOR_FUNCTION (fn);\n   ENTRY_BLOCK_PTR_FOR_FUNCTION (fn)->loop_father = root;\n@@ -422,21 +422,21 @@ flow_loops_find (struct loops *loops)\n \n   /* Taking care of this degenerate case makes the rest of\n      this code simpler.  */\n-  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n+  if (n_basic_blocks_for_fn (cfun) == NUM_FIXED_BLOCKS)\n     return loops;\n \n   /* The root loop node contains all basic-blocks.  */\n-  loops->tree_root->num_nodes = n_basic_blocks;\n+  loops->tree_root->num_nodes = n_basic_blocks_for_fn (cfun);\n \n   /* Compute depth first search order of the CFG so that outer\n      natural loops will be found before inner natural loops.  */\n-  rc_order = XNEWVEC (int, n_basic_blocks);\n+  rc_order = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n   pre_and_rev_post_order_compute (NULL, rc_order, false);\n \n   /* Gather all loop headers in reverse completion order and allocate\n      loop structures for loops that are not already present.  */\n   larray.create (loops->larray->length ());\n-  for (b = 0; b < n_basic_blocks - NUM_FIXED_BLOCKS; b++)\n+  for (b = 0; b < n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS; b++)\n     {\n       basic_block header = BASIC_BLOCK (rc_order[b]);\n       if (bb_loop_header_p (header))\n@@ -832,7 +832,7 @@ get_loop_body (const struct loop *loop)\n     {\n       /* There may be blocks unreachable from EXIT_BLOCK, hence we need to\n \t special-case the fake loop that contains the whole function.  */\n-      gcc_assert (loop->num_nodes == (unsigned) n_basic_blocks);\n+      gcc_assert (loop->num_nodes == (unsigned) n_basic_blocks_for_fn (cfun));\n       body[tv++] = loop->header;\n       body[tv++] = EXIT_BLOCK_PTR;\n       FOR_EACH_BB (bb)\n@@ -1368,7 +1368,7 @@ verify_loop_structure (void)\n   /* Check the recorded loop father and sizes of loops.  */\n   visited = sbitmap_alloc (last_basic_block);\n   bitmap_clear (visited);\n-  bbs = XNEWVEC (basic_block, n_basic_blocks);\n+  bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n   FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n       unsigned n;\n@@ -1380,7 +1380,7 @@ verify_loop_structure (void)\n \t  continue;\n \t}\n \n-      n = get_loop_body_with_size (loop, bbs, n_basic_blocks);\n+      n = get_loop_body_with_size (loop, bbs, n_basic_blocks_for_fn (cfun));\n       if (loop->num_nodes != n)\n \t{\n \t  error (\"size of loop %d should be %d, not %d\","}, {"sha": "c8f923b5fcaca3a376bcd08a912e22f559e09576", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -71,9 +71,9 @@ find_path (edge e, basic_block **bbs)\n   gcc_assert (EDGE_COUNT (e->dest->preds) <= 1);\n \n   /* Find bbs in the path.  */\n-  *bbs = XNEWVEC (basic_block, n_basic_blocks);\n+  *bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n   return dfs_enumerate_from (e->dest, 0, rpe_enum_p, *bbs,\n-\t\t\t     n_basic_blocks, e->dest);\n+\t\t\t     n_basic_blocks_for_fn (cfun), e->dest);\n }\n \n /* Fix placement of basic block BB inside loop hierarchy --\n@@ -343,7 +343,7 @@ remove_path (edge e)\n   nrem = find_path (e, &rem_bbs);\n \n   n_bord_bbs = 0;\n-  bord_bbs = XNEWVEC (basic_block, n_basic_blocks);\n+  bord_bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n   seen = sbitmap_alloc (last_basic_block);\n   bitmap_clear (seen);\n \n@@ -450,8 +450,8 @@ add_loop (struct loop *loop, struct loop *outer)\n   flow_loop_tree_node_add (outer, loop);\n \n   /* Find its nodes.  */\n-  bbs = XNEWVEC (basic_block, n_basic_blocks);\n-  n = get_loop_body_with_size (loop, bbs, n_basic_blocks);\n+  bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n+  n = get_loop_body_with_size (loop, bbs, n_basic_blocks_for_fn (cfun));\n \n   for (i = 0; i < n; i++)\n     {"}, {"sha": "c81d3a5503c08139d0ebde60c3c787fddbaa8ca9", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -361,7 +361,7 @@ rtl_create_basic_block (void *headp, void *endp, basic_block after)\n       vec_safe_grow_cleared (basic_block_info, new_size);\n     }\n \n-  n_basic_blocks++;\n+  n_basic_blocks_for_fn (cfun)++;\n \n   bb = create_basic_block_structure (head, end, NULL, after);\n   bb->aux = NULL;\n@@ -500,7 +500,7 @@ make_pass_free_cfg (gcc::context *ctxt)\n rtx\n entry_of_function (void)\n {\n-  return (n_basic_blocks > NUM_FIXED_BLOCKS ?\n+  return (n_basic_blocks_for_fn (cfun) > NUM_FIXED_BLOCKS ?\n \t  BB_HEAD (ENTRY_BLOCK_PTR->next_bb) : get_insns ());\n }\n \n@@ -2921,10 +2921,10 @@ rtl_verify_bb_layout (void)\n \tcurr_bb = NULL;\n     }\n \n-  if (num_bb_notes != n_basic_blocks - NUM_FIXED_BLOCKS)\n+  if (num_bb_notes != n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS)\n     internal_error\n       (\"number of bb notes in insn chain (%d) != n_basic_blocks (%d)\",\n-       num_bb_notes, n_basic_blocks);\n+       num_bb_notes, n_basic_blocks_for_fn (cfun));\n \n    return err;\n }\n@@ -4764,7 +4764,7 @@ rtl_flow_call_edges_add (sbitmap blocks)\n   int last_bb = last_basic_block;\n   bool check_last_block = false;\n \n-  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n+  if (n_basic_blocks_for_fn (cfun) == NUM_FIXED_BLOCKS)\n     return 0;\n \n   if (! blocks)"}, {"sha": "8519cd0452d4d8c45b9e148d91be17c21fc2e7c7", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -7964,7 +7964,7 @@ s390_optimize_nonescaping_tx (void)\n   if (!cfun->machine->tbegin_p)\n     return;\n \n-  for (bb_index = 0; bb_index < n_basic_blocks; bb_index++)\n+  for (bb_index = 0; bb_index < n_basic_blocks_for_fn (cfun); bb_index++)\n     {\n       bb = BASIC_BLOCK (bb_index);\n "}, {"sha": "55b934b6a5b67f4f0512746431565cde0cb92e5e", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -2470,13 +2470,13 @@ spu_machine_dependent_reorg (void)\n   compact_blocks ();\n \n   spu_bb_info =\n-    (struct spu_bb_info *) xcalloc (n_basic_blocks,\n+    (struct spu_bb_info *) xcalloc (n_basic_blocks_for_fn (cfun),\n \t\t\t\t    sizeof (struct spu_bb_info));\n \n   /* We need exact insn addresses and lengths.  */\n   shorten_branches (get_insns ());\n \n-  for (i = n_basic_blocks - 1; i >= 0; i--)\n+  for (i = n_basic_blocks_for_fn (cfun) - 1; i >= 0; i--)\n     {\n       bb = BASIC_BLOCK (i);\n       branch = 0;"}, {"sha": "3f4e334f078d20c9cb2a52e8c8d853291b297a89", "filename": "gcc/coverage.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -584,7 +584,7 @@ unsigned\n coverage_compute_cfg_checksum (void)\n {\n   basic_block bb;\n-  unsigned chksum = n_basic_blocks;\n+  unsigned chksum = n_basic_blocks_for_fn (cfun);\n \n   FOR_EACH_BB (bb)\n     {"}, {"sha": "78cfeba6fdd3a68d8923be5a83c4a5a6ce1d5732", "filename": "gcc/cprop.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -1729,24 +1729,25 @@ is_too_expensive (const char *pass)\n      which have a couple switch statements.  Rather than simply\n      threshold the number of blocks, uses something with a more\n      graceful degradation.  */\n-  if (n_edges > 20000 + n_basic_blocks * 4)\n+  if (n_edges > 20000 + n_basic_blocks_for_fn (cfun) * 4)\n     {\n       warning (OPT_Wdisabled_optimization,\n \t       \"%s: %d basic blocks and %d edges/basic block\",\n-\t       pass, n_basic_blocks, n_edges / n_basic_blocks);\n+\t       pass, n_basic_blocks_for_fn (cfun),\n+\t       n_edges / n_basic_blocks_for_fn (cfun));\n \n       return true;\n     }\n \n   /* If allocating memory for the cprop bitmap would take up too much\n      storage it's better just to disable the optimization.  */\n-  if ((n_basic_blocks\n+  if ((n_basic_blocks_for_fn (cfun)\n        * SBITMAP_SET_SIZE (max_reg_num ())\n        * sizeof (SBITMAP_ELT_TYPE)) > MAX_GCSE_MEMORY)\n     {\n       warning (OPT_Wdisabled_optimization,\n \t       \"%s: %d basic blocks and %d registers\",\n-\t       pass, n_basic_blocks, max_reg_num ());\n+\t       pass, n_basic_blocks_for_fn (cfun), max_reg_num ());\n \n       return true;\n     }\n@@ -1763,7 +1764,7 @@ one_cprop_pass (void)\n   int changed = 0;\n \n   /* Return if there's nothing to do, or it is too expensive.  */\n-  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1\n+  if (n_basic_blocks_for_fn (cfun) <= NUM_FIXED_BLOCKS + 1\n       || is_too_expensive (_ (\"const/copy propagation disabled\")))\n     return 0;\n \n@@ -1873,7 +1874,8 @@ one_cprop_pass (void)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"CPROP of %s, %d basic blocks, %d bytes needed, \",\n-\t       current_function_name (), n_basic_blocks, bytes_used);\n+\t       current_function_name (), n_basic_blocks_for_fn (cfun),\n+\t       bytes_used);\n       fprintf (dump_file, \"%d local const props, %d local copy props, \",\n \t       local_const_prop_count, local_copy_prop_count);\n       fprintf (dump_file, \"%d global const props, %d global copy props\\n\\n\","}, {"sha": "20d6c4e4fb5b38571783f091a639932fa9c9ab20", "filename": "gcc/df-core.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -1097,8 +1097,8 @@ df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n     fprintf (dump_file, \"df_worklist_dataflow_doublequeue:\"\n \t     \"n_basic_blocks %d n_edges %d\"\n \t     \" count %d (%5.2g)\\n\",\n-\t     n_basic_blocks, n_edges,\n-\t     dcount, dcount / (float)n_basic_blocks);\n+\t     n_basic_blocks_for_fn (cfun), n_edges,\n+\t     dcount, dcount / (float)n_basic_blocks_for_fn (cfun));\n }\n \n /* Worklist-based dataflow solver. It uses sbitmap as a worklist,\n@@ -1606,7 +1606,7 @@ df_compact_blocks (void)\n       i++;\n     }\n \n-  gcc_assert (i == n_basic_blocks);\n+  gcc_assert (i == n_basic_blocks_for_fn (cfun));\n \n   for (; i < last_basic_block; i++)\n     SET_BASIC_BLOCK (i, NULL);\n@@ -1714,7 +1714,7 @@ static int *\n df_compute_cfg_image (void)\n {\n   basic_block bb;\n-  int size = 2 + (2 * n_basic_blocks);\n+  int size = 2 + (2 * n_basic_blocks_for_fn (cfun));\n   int i;\n   int * map;\n "}, {"sha": "6530109485455f3c680bd58f5a3ec5929dd88dd9", "filename": "gcc/dominance.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -146,7 +146,7 @@ static void\n init_dom_info (struct dom_info *di, enum cdi_direction dir)\n {\n   /* We need memory for n_basic_blocks nodes.  */\n-  unsigned int num = n_basic_blocks;\n+  unsigned int num = n_basic_blocks_for_fn (cfun);\n   init_ar (di->dfs_parent, TBB, num, 0);\n   init_ar (di->path_min, TBB, num, i);\n   init_ar (di->key, TBB, num, i);\n@@ -233,7 +233,7 @@ calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb, bool reverse)\n   /* Ending block.  */\n   basic_block ex_block;\n \n-  stack = XNEWVEC (edge_iterator, n_basic_blocks + 1);\n+  stack = XNEWVEC (edge_iterator, n_basic_blocks_for_fn (cfun) + 1);\n   sp = 0;\n \n   /* Initialize our border blocks, and the first edge.  */\n@@ -394,7 +394,7 @@ calc_dfs_tree (struct dom_info *di, bool reverse)\n   di->nodes = di->dfsnum - 1;\n \n   /* This aborts e.g. when there is _no_ path from ENTRY to EXIT at all.  */\n-  gcc_assert (di->nodes == (unsigned int) n_basic_blocks - 1);\n+  gcc_assert (di->nodes == (unsigned int) n_basic_blocks_for_fn (cfun) - 1);\n }\n \n /* Compress the path from V to the root of its set and update path_min at the\n@@ -652,7 +652,7 @@ calculate_dominance_info (enum cdi_direction dir)\n \t{\n \t  b->dom[dir_index] = et_new_tree (b);\n \t}\n-      n_bbs_in_dom_tree[dir_index] = n_basic_blocks;\n+      n_bbs_in_dom_tree[dir_index] = n_basic_blocks_for_fn (cfun);\n \n       init_dom_info (&di, dir);\n       calc_dfs_tree (&di, reverse);"}, {"sha": "4c7354ecf92d791710d7d7e344808ffd7a47995c", "filename": "gcc/domwalk.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -150,13 +150,14 @@ void\n dom_walker::walk (basic_block bb)\n {\n   basic_block dest;\n-  basic_block *worklist = XNEWVEC (basic_block, n_basic_blocks * 2);\n+  basic_block *worklist = XNEWVEC (basic_block,\n+\t\t\t\t   n_basic_blocks_for_fn (cfun) * 2);\n   int sp = 0;\n   int *postorder, postorder_num;\n \n   if (m_dom_direction == CDI_DOMINATORS)\n     {\n-      postorder = XNEWVEC (int, n_basic_blocks);\n+      postorder = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n       postorder_num = inverted_post_order_compute (postorder);\n       bb_postorder = XNEWVEC (int, last_basic_block);\n       for (int i = 0; i < postorder_num; ++i)"}, {"sha": "724b969491729b2a1fb9b036cb034a931067675f", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -4028,7 +4028,7 @@ generate_setjmp_warnings (void)\n {\n   bitmap setjmp_crosses = regstat_get_setjmp_crosses ();\n \n-  if (n_basic_blocks == NUM_FIXED_BLOCKS\n+  if (n_basic_blocks_for_fn (cfun) == NUM_FIXED_BLOCKS\n       || bitmap_empty_p (setjmp_crosses))\n     return;\n \n@@ -6015,7 +6015,7 @@ thread_prologue_and_epilogue_insns (void)\n       /* Find the set of basic blocks that require a stack frame,\n \t and blocks that are too big to be duplicated.  */\n \n-      vec.create (n_basic_blocks);\n+      vec.create (n_basic_blocks_for_fn (cfun));\n \n       CLEAR_HARD_REG_SET (set_up_by_prologue.set);\n       add_to_hard_reg_set (&set_up_by_prologue.set, Pmode,"}, {"sha": "da40a6775593427e1f958238128b8b72cb11d7a0", "filename": "gcc/fwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -289,7 +289,7 @@ build_single_def_use_links (void)\n   reg_defs.create (max_reg_num ());\n   reg_defs.safe_grow_cleared (max_reg_num ());\n \n-  reg_defs_stack.create (n_basic_blocks * 10);\n+  reg_defs_stack.create (n_basic_blocks_for_fn (cfun) * 10);\n   local_md = BITMAP_ALLOC (NULL);\n   local_lr = BITMAP_ALLOC (NULL);\n "}, {"sha": "5ed99bdf169712af54edb5e4bbd5289a5c9cce9e", "filename": "gcc/gcse.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -2662,7 +2662,7 @@ one_pre_gcse_pass (void)\n   gcse_create_count = 0;\n \n   /* Return if there's nothing to do, or it is too expensive.  */\n-  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1\n+  if (n_basic_blocks_for_fn (cfun) <= NUM_FIXED_BLOCKS + 1\n       || is_too_expensive (_(\"PRE disabled\")))\n     return 0;\n \n@@ -2708,7 +2708,8 @@ one_pre_gcse_pass (void)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"PRE GCSE of %s, %d basic blocks, %d bytes needed, \",\n-\t       current_function_name (), n_basic_blocks, bytes_used);\n+\t       current_function_name (), n_basic_blocks_for_fn (cfun),\n+\t       bytes_used);\n       fprintf (dump_file, \"%d substs, %d insns created\\n\",\n \t       gcse_subst_count, gcse_create_count);\n     }\n@@ -3591,7 +3592,7 @@ one_code_hoisting_pass (void)\n   gcse_create_count = 0;\n \n   /* Return if there's nothing to do, or it is too expensive.  */\n-  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1\n+  if (n_basic_blocks_for_fn (cfun) <= NUM_FIXED_BLOCKS + 1\n       || is_too_expensive (_(\"GCSE disabled\")))\n     return 0;\n \n@@ -3642,7 +3643,8 @@ one_code_hoisting_pass (void)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"HOIST of %s, %d basic blocks, %d bytes needed, \",\n-\t       current_function_name (), n_basic_blocks, bytes_used);\n+\t       current_function_name (), n_basic_blocks_for_fn (cfun),\n+\t       bytes_used);\n       fprintf (dump_file, \"%d substs, %d insns created\\n\",\n \t       gcse_subst_count, gcse_create_count);\n     }\n@@ -4067,24 +4069,25 @@ is_too_expensive (const char *pass)\n      which have a couple switch statements.  Rather than simply\n      threshold the number of blocks, uses something with a more\n      graceful degradation.  */\n-  if (n_edges > 20000 + n_basic_blocks * 4)\n+  if (n_edges > 20000 + n_basic_blocks_for_fn (cfun) * 4)\n     {\n       warning (OPT_Wdisabled_optimization,\n \t       \"%s: %d basic blocks and %d edges/basic block\",\n-\t       pass, n_basic_blocks, n_edges / n_basic_blocks);\n+\t       pass, n_basic_blocks_for_fn (cfun),\n+\t       n_edges / n_basic_blocks_for_fn (cfun));\n \n       return true;\n     }\n \n   /* If allocating memory for the dataflow bitmaps would take up too much\n      storage it's better just to disable the optimization.  */\n-  if ((n_basic_blocks\n+  if ((n_basic_blocks_for_fn (cfun)\n        * SBITMAP_SET_SIZE (max_reg_num ())\n        * sizeof (SBITMAP_ELT_TYPE)) > MAX_GCSE_MEMORY)\n     {\n       warning (OPT_Wdisabled_optimization,\n \t       \"%s: %d basic blocks and %d registers\",\n-\t       pass, n_basic_blocks, max_reg_num ());\n+\t       pass, n_basic_blocks_for_fn (cfun), max_reg_num ());\n \n       return true;\n     }"}, {"sha": "1dc9dbc7734d0c4e91f3f7cd8c0ba8b6e8829f52", "filename": "gcc/graph.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -153,24 +153,24 @@ draw_cfg_node_succ_edges (pretty_printer *pp, int funcdef_no, basic_block bb)\n static void\n draw_cfg_nodes_no_loops (pretty_printer *pp, struct function *fun)\n {\n-  int *rpo = XNEWVEC (int, n_basic_blocks_for_function (fun));\n+  int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (fun));\n   int i, n;\n   sbitmap visited;\n \n   visited = sbitmap_alloc (last_basic_block);\n   bitmap_clear (visited);\n \n   n = pre_and_rev_post_order_compute_fn (fun, NULL, rpo, true);\n-  for (i = n_basic_blocks_for_function (fun) - n;\n-       i < n_basic_blocks_for_function (fun); i++)\n+  for (i = n_basic_blocks_for_fn (fun) - n;\n+       i < n_basic_blocks_for_fn (fun); i++)\n     {\n       basic_block bb = BASIC_BLOCK (rpo[i]);\n       draw_cfg_node (pp, fun->funcdef_no, bb);\n       bitmap_set_bit (visited, bb->index);\n     }\n   free (rpo);\n \n-  if (n != n_basic_blocks_for_function (fun))\n+  if (n != n_basic_blocks_for_fn (fun))\n     {\n       /* Some blocks are unreachable.  We still want to dump them.  */\n       basic_block bb;"}, {"sha": "f87aede8420637937125a750542a810a6f9b5856", "filename": "gcc/graphite.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -208,7 +208,8 @@ graphite_initialize (isl_ctx *ctx)\n   if (number_of_loops (cfun) <= 1\n       /* FIXME: This limit on the number of basic blocks of a function\n \t should be removed when the SCOP detection is faster.  */\n-      || n_basic_blocks > PARAM_VALUE (PARAM_GRAPHITE_MAX_BBS_PER_FUNCTION))\n+      || (n_basic_blocks_for_fn (cfun) >\n+\t  PARAM_VALUE (PARAM_GRAPHITE_MAX_BBS_PER_FUNCTION)))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tprint_global_statistics (dump_file);"}, {"sha": "beddc116ffb9d82983b64153286c7984554e0162", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -6754,7 +6754,7 @@ haifa_sched_init (void)\n      whole function.  */\n   {\n     bb_vec_t bbs;\n-    bbs.create (n_basic_blocks);\n+    bbs.create (n_basic_blocks_for_fn (cfun));\n     basic_block bb;\n \n     sched_init_bbs ();"}, {"sha": "a558dbc75ff0d3b0ac68e2566ac061cffcfb8885", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -2397,7 +2397,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   if (parms_info)\n     compute_bb_predicates (node, parms_info, info);\n   gcc_assert (cfun == my_function);\n-  order = XNEWVEC (int, n_basic_blocks);\n+  order = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n   nblocks = pre_and_rev_post_order_compute (NULL, order, false);\n   for (n = 0; n < nblocks; n++)\n     {"}, {"sha": "1aa239d3b7d258cc643a677776151152b4a4c930", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -700,8 +700,8 @@ ipa_merge_profiles (struct cgraph_node *dst,\n   cgraph_get_body (dst);\n   srccfun = DECL_STRUCT_FUNCTION (src->decl);\n   dstcfun = DECL_STRUCT_FUNCTION (dst->decl);\n-  if (n_basic_blocks_for_function (srccfun)\n-      != n_basic_blocks_for_function (dstcfun))\n+  if (n_basic_blocks_for_fn (srccfun)\n+      != n_basic_blocks_for_fn (dstcfun))\n     {\n       if (cgraph_dump_file)\n \tfprintf (cgraph_dump_file,"}, {"sha": "ca6f64d0637e2b3e5c9363f6df57217776122f44", "filename": "gcc/ira-build.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -3496,7 +3496,7 @@ ira_build (void)\n \t}\n       fprintf (ira_dump_file, \"  regions=%d, blocks=%d, points=%d\\n\",\n \t       current_loops == NULL ? 1 : number_of_loops (cfun),\n-\t       n_basic_blocks, ira_max_point);\n+\t       n_basic_blocks_for_fn (cfun), ira_max_point);\n       fprintf (ira_dump_file,\n \t       \"    allocnos=%d (big %d), copies=%d, conflicts=%d, ranges=%d\\n\",\n \t       ira_allocnos_num, nr_big, ira_copies_num, n, nr);"}, {"sha": "a813b02bef9c3a24fe9a9c01c841bf5688fff17d", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -4875,7 +4875,7 @@ split_live_ranges_for_shrink_wrap (void)\n \n   bitmap_initialize (&need_new, 0);\n   bitmap_initialize (&reachable, 0);\n-  queue.create (n_basic_blocks);\n+  queue.create (n_basic_blocks_for_fn (cfun));\n \n   FOR_EACH_BB (bb)\n     FOR_BB_INSNS (bb, insn)"}, {"sha": "6266d48500b3c27bf9ce98767b013f859050043f", "filename": "gcc/lcm.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -101,7 +101,7 @@ compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n-  qin = qout = worklist = XNEWVEC (basic_block, n_basic_blocks);\n+  qin = qout = worklist = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n \n   /* We want a maximal solution, so make an optimistic initialization of\n      ANTIN.  */\n@@ -116,8 +116,8 @@ compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n     }\n \n   qin = worklist;\n-  qend = &worklist[n_basic_blocks - NUM_FIXED_BLOCKS];\n-  qlen = n_basic_blocks - NUM_FIXED_BLOCKS;\n+  qend = &worklist[n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS];\n+  qlen = n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS;\n \n   /* Mark blocks which are predecessors of the exit block so that we\n      can easily identify them below.  */\n@@ -254,7 +254,7 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n   qin = qout = worklist\n-    = XNEWVEC (basic_block, n_basic_blocks);\n+    = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n \n   /* Initialize a mapping from each edge to its index.  */\n   for (i = 0; i < num_edges; i++)\n@@ -290,8 +290,8 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n   /* Note that we do not use the last allocated element for our queue,\n      as EXIT_BLOCK is never inserted into it. */\n   qin = worklist;\n-  qend = &worklist[n_basic_blocks - NUM_FIXED_BLOCKS];\n-  qlen = n_basic_blocks - NUM_FIXED_BLOCKS;\n+  qend = &worklist[n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS];\n+  qlen = n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS;\n \n   /* Iterate until the worklist is empty.  */\n   while (qlen)\n@@ -481,7 +481,7 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n   qin = qout = worklist =\n-    XNEWVEC (basic_block, n_basic_blocks - NUM_FIXED_BLOCKS);\n+    XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS);\n \n   /* We want a maximal solution.  */\n   bitmap_vector_ones (avout, last_basic_block);\n@@ -495,8 +495,8 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n     }\n \n   qin = worklist;\n-  qend = &worklist[n_basic_blocks - NUM_FIXED_BLOCKS];\n-  qlen = n_basic_blocks - NUM_FIXED_BLOCKS;\n+  qend = &worklist[n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS];\n+  qlen = n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS;\n \n   /* Mark blocks which are successors of the entry block so that we\n      can easily identify them below.  */\n@@ -610,7 +610,7 @@ compute_nearerout (struct edge_list *edge_list, sbitmap *farthest,\n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n-  tos = worklist = XNEWVEC (basic_block, n_basic_blocks + 1);\n+  tos = worklist = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun) + 1);\n \n   /* Initialize NEARER for each edge and build a mapping from an edge to\n      its index.  */"}, {"sha": "2839c5cf9401dd32133dfc0e6a4d6a64ef863bc3", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -998,7 +998,7 @@ lra_create_live_ranges (bool all_p)\n   lra_point_freq = point_freq_vec.address ();\n   int *post_order_rev_cfg = XNEWVEC (int, last_basic_block);\n   int n_blocks_inverted = inverted_post_order_compute (post_order_rev_cfg);\n-  lra_assert (n_blocks_inverted == n_basic_blocks);\n+  lra_assert (n_blocks_inverted == n_basic_blocks_for_fn (cfun));\n   for (i = n_blocks_inverted - 1; i >= 0; --i)\n     {\n       bb = BASIC_BLOCK (post_order_rev_cfg[i]);"}, {"sha": "3c8b71d949d4f834821f75be84c6900de09cdc86", "filename": "gcc/lra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -2059,7 +2059,7 @@ has_nonexceptional_receiver (void)\n     return true;\n \n   /* First determine which blocks can reach exit via normal paths.  */\n-  tos = worklist = XNEWVEC (basic_block, n_basic_blocks + 1);\n+  tos = worklist = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun) + 1);\n \n   FOR_EACH_BB (bb)\n     bb->flags &= ~BB_REACHABLE;"}, {"sha": "98cf28ff91758b57a6861699a69727748385c4c7", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -587,7 +587,7 @@ make_new_block (struct function *fn, unsigned int index)\n   basic_block bb = alloc_block ();\n   bb->index = index;\n   SET_BASIC_BLOCK_FOR_FUNCTION (fn, index, bb);\n-  n_basic_blocks_for_function (fn)++;\n+  n_basic_blocks_for_fn (fn)++;\n   return bb;\n }\n "}, {"sha": "e0e40d812766befc5e5470a5ab11336233574352", "filename": "gcc/mcf.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fmcf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fmcf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmcf.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -471,12 +471,12 @@ create_fixup_graph (fixup_graph_type *fixup_graph)\n   int fnum_edges;\n \n   /* Each basic_block will be split into 2 during vertex transformation.  */\n-  int fnum_vertices_after_transform =  2 * n_basic_blocks;\n-  int fnum_edges_after_transform = n_edges + n_basic_blocks;\n+  int fnum_vertices_after_transform =  2 * n_basic_blocks_for_fn (cfun);\n+  int fnum_edges_after_transform = n_edges + n_basic_blocks_for_fn (cfun);\n \n   /* Count the new SOURCE and EXIT vertices to be added.  */\n   int fmax_num_vertices =\n-    fnum_vertices_after_transform + n_edges + n_basic_blocks + 2;\n+    fnum_vertices_after_transform + n_edges + n_basic_blocks_for_fn (cfun) + 2;\n \n   /* In create_fixup_graph: Each basic block and edge can be split into 3\n      edges. Number of balance edges = n_basic_blocks. So after\n@@ -486,10 +486,10 @@ create_fixup_graph (fixup_graph_type *fixup_graph)\n      max_edges = 2 * (4 * n_basic_blocks + 3 * n_edges)\n      = 8 * n_basic_blocks + 6 * n_edges\n      < 8 * n_basic_blocks + 8 * n_edges.  */\n-  int fmax_num_edges = 8 * (n_basic_blocks + n_edges);\n+  int fmax_num_edges = 8 * (n_basic_blocks_for_fn (cfun) + n_edges);\n \n   /* Initial num of vertices in the fixup graph.  */\n-  fixup_graph->num_vertices = n_basic_blocks;\n+  fixup_graph->num_vertices = n_basic_blocks_for_fn (cfun);\n \n   /* Fixup graph vertex list.  */\n   fixup_graph->vertex_list =\n@@ -508,7 +508,8 @@ create_fixup_graph (fixup_graph_type *fixup_graph)\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     total_vertex_weight += bb->count;\n \n-  sqrt_avg_vertex_weight = mcf_sqrt (total_vertex_weight / n_basic_blocks);\n+  sqrt_avg_vertex_weight = mcf_sqrt (total_vertex_weight /\n+\t\t\t\t     n_basic_blocks_for_fn (cfun));\n \n   k_pos = K_POS (sqrt_avg_vertex_weight);\n   k_neg = K_NEG (sqrt_avg_vertex_weight);"}, {"sha": "1f1c2652b55776f67522ffc44982e7628bbab022", "filename": "gcc/profile.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -1177,9 +1177,9 @@ branch_prob (void)\n \tnum_instrumented++;\n     }\n \n-  total_num_blocks += n_basic_blocks;\n+  total_num_blocks += n_basic_blocks_for_fn (cfun);\n   if (dump_file)\n-    fprintf (dump_file, \"%d basic blocks\\n\", n_basic_blocks);\n+    fprintf (dump_file, \"%d basic blocks\\n\", n_basic_blocks_for_fn (cfun));\n \n   total_num_edges += num_edges;\n   if (dump_file)\n@@ -1208,7 +1208,7 @@ branch_prob (void)\n \n       /* Basic block flags */\n       offset = gcov_write_tag (GCOV_TAG_BLOCKS);\n-      for (i = 0; i != (unsigned) (n_basic_blocks); i++)\n+      for (i = 0; i != (unsigned) (n_basic_blocks_for_fn (cfun)); i++)\n \tgcov_write_unsigned (0);\n       gcov_write_length (offset);\n "}, {"sha": "3740934b826919e3afd6d03a2d6acdefee6621da", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -3080,7 +3080,7 @@ convert_regs_2 (basic_block block)\n      is only processed after all its predecessors.  The number of predecessors\n      of every block has already been computed.  */\n \n-  stack = XNEWVEC (basic_block, n_basic_blocks);\n+  stack = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n   sp = stack;\n \n   *sp++ = block;"}, {"sha": "5e86fa5a61ab4d5f1815638c0599bfbd5c31b975", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -672,7 +672,7 @@ regrename_analyze (bitmap bb_mask)\n   n_bbs = pre_and_rev_post_order_compute (NULL, inverse_postorder, false);\n \n   /* Gather some information about the blocks in this function.  */\n-  rename_info = XCNEWVEC (struct bb_rename_info, n_basic_blocks);\n+  rename_info = XCNEWVEC (struct bb_rename_info, n_basic_blocks_for_fn (cfun));\n   i = 0;\n   FOR_EACH_BB (bb)\n     {"}, {"sha": "66b5ff16b22cf3dc79cad7d9dce70c0a6788c578", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -611,7 +611,7 @@ has_nonexceptional_receiver (void)\n     return true;\n \n   /* First determine which blocks can reach exit via normal paths.  */\n-  tos = worklist = XNEWVEC (basic_block, n_basic_blocks + 1);\n+  tos = worklist = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun) + 1);\n \n   FOR_EACH_BB (bb)\n     bb->flags &= ~BB_REACHABLE;"}, {"sha": "dc20de46bee8c84088a473c97eba093495b6fca9", "filename": "gcc/reorg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -3643,7 +3643,7 @@ dbr_schedule (rtx first)\n \n   /* If the current function has no insns other than the prologue and\n      epilogue, then do not try to fill any delay slots.  */\n-  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n+  if (n_basic_blocks_for_fn (cfun) == NUM_FIXED_BLOCKS)\n     return;\n \n   /* Find the highest INSN_UID and allocate and initialize our map from"}, {"sha": "287b826cfc6d00fa43923f4362d15ee7c6b4ae2c", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -3963,7 +3963,7 @@ sched_deps_init (bool global_p)\n {\n   /* Average number of insns in the basic block.\n      '+ 1' is used to make it nonzero.  */\n-  int insns_in_block = sched_max_luid / n_basic_blocks + 1;\n+  int insns_in_block = sched_max_luid / n_basic_blocks_for_fn (cfun) + 1;\n \n   init_deps_data_vector ();\n "}, {"sha": "8d23e33f89e4a4323b0dade90c8d42bd6bb49e5e", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -625,7 +625,7 @@ schedule_ebbs (void)\n \n   /* Taking care of this degenerate case makes the rest of\n      this code simpler.  */\n-  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n+  if (n_basic_blocks_for_fn (cfun) == NUM_FIXED_BLOCKS)\n     return;\n \n   if (profile_info && flag_branch_probabilities)"}, {"sha": "20c29c50fc9a419e04d6c936ef5bb71d38173193", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -793,7 +793,7 @@ haifa_find_rgns (void)\n       /* Second traversal:find reducible inner loops and topologically sort\n \t block of each region.  */\n \n-      queue = XNEWVEC (int, n_basic_blocks);\n+      queue = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n \n       extend_regions_p = PARAM_VALUE (PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS) > 0;\n       if (extend_regions_p)\n@@ -1153,7 +1153,7 @@ void\n extend_rgns (int *degree, int *idxp, sbitmap header, int *loop_hdr)\n {\n   int *order, i, rescan = 0, idx = *idxp, iter = 0, max_iter, *max_hdr;\n-  int nblocks = n_basic_blocks - NUM_FIXED_BLOCKS;\n+  int nblocks = n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS;\n \n   max_iter = PARAM_VALUE (PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS);\n \n@@ -3115,7 +3115,7 @@ sched_rgn_init (bool single_blocks_p)\n \n   /* Compute regions for scheduling.  */\n   if (single_blocks_p\n-      || n_basic_blocks == NUM_FIXED_BLOCKS + 1\n+      || n_basic_blocks_for_fn (cfun) == NUM_FIXED_BLOCKS + 1\n       || !flag_schedule_interblock\n       || is_cfg_nonregular ())\n     {\n@@ -3139,7 +3139,7 @@ sched_rgn_init (bool single_blocks_p)\n \tfree_dominance_info (CDI_DOMINATORS);\n     }\n \n-  gcc_assert (0 < nr_regions && nr_regions <= n_basic_blocks);\n+  gcc_assert (0 < nr_regions && nr_regions <= n_basic_blocks_for_fn (cfun));\n \n   RGN_BLOCKS (nr_regions) = (RGN_BLOCKS (nr_regions - 1) +\n \t\t\t     RGN_NR_BLOCKS (nr_regions - 1));\n@@ -3375,7 +3375,7 @@ schedule_insns (void)\n \n   /* Taking care of this degenerate case makes the rest of\n      this code simpler.  */\n-  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n+  if (n_basic_blocks_for_fn (cfun) == NUM_FIXED_BLOCKS)\n     return;\n \n   rgn_setup_common_sched_info ();\n@@ -3421,8 +3421,8 @@ rgn_add_remove_insn (rtx insn, int remove_p)\n void\n extend_regions (void)\n {\n-  rgn_table = XRESIZEVEC (region, rgn_table, n_basic_blocks);\n-  rgn_bb_table = XRESIZEVEC (int, rgn_bb_table, n_basic_blocks);\n+  rgn_table = XRESIZEVEC (region, rgn_table, n_basic_blocks_for_fn (cfun));\n+  rgn_bb_table = XRESIZEVEC (int, rgn_bb_table, n_basic_blocks_for_fn (cfun));\n   block_to_bb = XRESIZEVEC (int, block_to_bb, last_basic_block);\n   containing_rgn = XRESIZEVEC (int, containing_rgn, last_basic_block);\n }"}, {"sha": "90bf1e2da1bbcc44429ef303a525fed328bff712", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -3649,7 +3649,7 @@ sel_recompute_toporder (void)\n   int i, n, rgn;\n   int *postorder, n_blocks;\n \n-  postorder = XALLOCAVEC (int, n_basic_blocks);\n+  postorder = XALLOCAVEC (int, n_basic_blocks_for_fn (cfun));\n   n_blocks = post_order_compute (postorder, false, false);\n \n   rgn = CONTAINING_RGN (BB_TO_BLOCK (0));\n@@ -4912,10 +4912,10 @@ recompute_rev_top_order (void)\n                                         rev_top_order_index_len);\n     }\n \n-  postorder = XNEWVEC (int, n_basic_blocks);\n+  postorder = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n \n   n_blocks = post_order_compute (postorder, true, false);\n-  gcc_assert (n_basic_blocks == n_blocks);\n+  gcc_assert (n_basic_blocks_for_fn (cfun) == n_blocks);\n \n   /* Build reverse function: for each basic block with BB->INDEX == K\n      rev_top_order_index[K] is it's reverse topological sort number.  */"}, {"sha": "c2d4185d6eca6e6487181e29f86001ddad15ca5c", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -7764,7 +7764,7 @@ run_selective_scheduling (void)\n {\n   int rgn;\n \n-  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n+  if (n_basic_blocks_for_fn (cfun) == NUM_FIXED_BLOCKS)\n     return;\n \n   sel_global_init ();"}, {"sha": "ffbeed2a07171eb01f67a21bbecabd52be97dad7", "filename": "gcc/store-motion.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -848,7 +848,7 @@ remove_reachable_equiv_notes (basic_block bb, struct st_expr *smexpr)\n   rtx last, insn, note;\n   rtx mem = smexpr->pattern;\n \n-  stack = XNEWVEC (edge_iterator, n_basic_blocks);\n+  stack = XNEWVEC (edge_iterator, n_basic_blocks_for_fn (cfun));\n   sp = 0;\n   ei = ei_start (bb->succs);\n \n@@ -1208,7 +1208,7 @@ one_store_motion_pass (void)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"STORE_MOTION of %s, %d basic blocks, \",\n-\t       current_function_name (), n_basic_blocks);\n+\t       current_function_name (), n_basic_blocks_for_fn (cfun));\n       fprintf (dump_file, \"%d insns deleted, %d insns created\\n\",\n \t       n_stores_deleted, n_stores_created);\n     }"}, {"sha": "1ff89c56b75871e87510c1c177877ee8b53c55a3", "filename": "gcc/tracer.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -227,7 +227,7 @@ static bool\n tail_duplicate (void)\n {\n   fibnode_t *blocks = XCNEWVEC (fibnode_t, last_basic_block);\n-  basic_block *trace = XNEWVEC (basic_block, n_basic_blocks);\n+  basic_block *trace = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n   int *counts = XNEWVEC (int, last_basic_block);\n   int ninsns = 0, nduplicated = 0;\n   gcov_type weighted_insns = 0, traced_insns = 0;\n@@ -371,7 +371,7 @@ tracer (void)\n {\n   bool changed;\n \n-  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n+  if (n_basic_blocks_for_fn (cfun) <= NUM_FIXED_BLOCKS + 1)\n     return 0;\n \n   mark_dfs_back_edges ();"}, {"sha": "751db306aabf162309a3128296c5a9d4430b2680", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -173,7 +173,7 @@ init_empty_tree_cfg_for_function (struct function *fn)\n   /* Initialize the basic block array.  */\n   init_flow (fn);\n   profile_status_for_function (fn) = PROFILE_ABSENT;\n-  n_basic_blocks_for_function (fn) = NUM_FIXED_BLOCKS;\n+  n_basic_blocks_for_fn (fn) = NUM_FIXED_BLOCKS;\n   last_basic_block_for_function (fn) = NUM_FIXED_BLOCKS;\n   vec_alloc (basic_block_info_for_function (fn), initial_cfg_capacity);\n   vec_safe_grow_cleared (basic_block_info_for_function (fn),\n@@ -230,12 +230,12 @@ build_gimple_cfg (gimple_seq seq)\n     factor_computed_gotos ();\n \n   /* Make sure there is always at least one block, even if it's empty.  */\n-  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n+  if (n_basic_blocks_for_fn (cfun) == NUM_FIXED_BLOCKS)\n     create_empty_bb (ENTRY_BLOCK_PTR);\n \n   /* Adjust the size of the array.  */\n-  if (basic_block_info->length () < (size_t) n_basic_blocks)\n-    vec_safe_grow_cleared (basic_block_info, n_basic_blocks);\n+  if (basic_block_info->length () < (size_t) n_basic_blocks_for_fn (cfun))\n+    vec_safe_grow_cleared (basic_block_info, n_basic_blocks_for_fn (cfun));\n \n   /* To speed up statement iterator walks, we first purge dead labels.  */\n   cleanup_dead_labels ();\n@@ -605,7 +605,7 @@ create_bb (void *h, void *e, basic_block after)\n   /* Add the newly created block to the array.  */\n   SET_BASIC_BLOCK (last_basic_block, bb);\n \n-  n_basic_blocks++;\n+  n_basic_blocks_for_fn (cfun)++;\n   last_basic_block++;\n \n   return bb;\n@@ -2103,7 +2103,7 @@ gimple_dump_cfg (FILE *file, int flags)\n     {\n       dump_function_header (file, current_function_decl, flags);\n       fprintf (file, \";; \\n%d basic blocks, %d edges, last basic block %d.\\n\\n\",\n-\t       n_basic_blocks, n_edges, last_basic_block);\n+\t       n_basic_blocks_for_fn (cfun), n_edges, last_basic_block);\n \n       brief_dump_cfg (file, flags | TDF_COMMENT);\n       fprintf (file, \"\\n\");\n@@ -2138,9 +2138,9 @@ dump_cfg_stats (FILE *file)\n   fprintf (file, fmt_str, \"\", \"  instances  \", \"used \");\n   fprintf (file, \"---------------------------------------------------------\\n\");\n \n-  size = n_basic_blocks * sizeof (struct basic_block_def);\n+  size = n_basic_blocks_for_fn (cfun) * sizeof (struct basic_block_def);\n   total += size;\n-  fprintf (file, fmt_str_1, \"Basic blocks\", n_basic_blocks,\n+  fprintf (file, fmt_str_1, \"Basic blocks\", n_basic_blocks_for_fn (cfun),\n \t   SCALE (size), LABEL (size));\n \n   num_edges = 0;\n@@ -7028,7 +7028,7 @@ dump_function_to_file (tree fndecl, FILE *file, int flags)\n       if (!ignore_topmost_bind)\n \tfprintf (file, \"{\\n\");\n \n-      if (any_var && n_basic_blocks_for_function (fun))\n+      if (any_var && n_basic_blocks_for_fn (fun))\n \tfprintf (file, \"\\n\");\n \n       FOR_EACH_BB_FN (bb, fun)\n@@ -7406,7 +7406,7 @@ gimple_flow_call_edges_add (sbitmap blocks)\n   int last_bb = last_basic_block;\n   bool check_last_block = false;\n \n-  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n+  if (n_basic_blocks_for_fn (cfun) == NUM_FIXED_BLOCKS)\n     return 0;\n \n   if (! blocks)"}, {"sha": "0d4c63d425968725415cfa6330f0684136267f21", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -905,7 +905,7 @@ remove_forwarder_block_with_phi (basic_block bb)\n static unsigned int\n merge_phi_nodes (void)\n {\n-  basic_block *worklist = XNEWVEC (basic_block, n_basic_blocks);\n+  basic_block *worklist = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n   basic_block *current = worklist;\n   basic_block bb;\n "}, {"sha": "d0eb27ba12c3a2466ad17007ca2c6472ca326711", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -4425,7 +4425,7 @@ gimple_expand_calls_inline (basic_block bb, copy_body_data *id)\n static void\n fold_marked_statements (int first, struct pointer_set_t *statements)\n {\n-  for (; first < n_basic_blocks; first++)\n+  for (; first < n_basic_blocks_for_fn (cfun); first++)\n     if (BASIC_BLOCK (first))\n       {\n         gimple_stmt_iterator gsi;\n@@ -4513,7 +4513,7 @@ optimize_inline_calls (tree fn)\n {\n   copy_body_data id;\n   basic_block bb;\n-  int last = n_basic_blocks;\n+  int last = n_basic_blocks_for_fn (cfun);\n   struct gimplify_ctx gctx;\n   bool inlined_p = false;\n "}, {"sha": "8ce4871e025d0af42ae7dcf519d7a1ebb082c63c", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -679,7 +679,7 @@ tree_ssa_ifcombine (void)\n      inner ones, and also that we do not try to visit a removed\n      block.  This is opposite of PHI-OPT, because we cascade the\n      combining rather than cascading PHIs. */\n-  for (i = n_basic_blocks - NUM_FIXED_BLOCKS - 1; i >= 0; i--)\n+  for (i = n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS - 1; i >= 0; i--)\n     {\n       basic_block bb = bbs[i];\n       gimple stmt = last_stmt (bb);"}, {"sha": "138c0a7a0fb2ad78eba6a3f5784aad2206c5c0c7", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -146,9 +146,9 @@ copy_loop_headers (void)\n       return 0;\n     }\n \n-  bbs = XNEWVEC (basic_block, n_basic_blocks);\n-  copied_bbs = XNEWVEC (basic_block, n_basic_blocks);\n-  bbs_size = n_basic_blocks;\n+  bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n+  copied_bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n+  bbs_size = n_basic_blocks_for_fn (cfun);\n \n   FOR_EACH_LOOP (li, loop, 0)\n     {"}, {"sha": "7f29ea2053c064c0d113fa52678b1d2dae45c5cb", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -1595,7 +1595,7 @@ analyze_memory_references (void)\n   /* Collect all basic-blocks in loops and sort them after their\n      loops postorder.  */\n   i = 0;\n-  bbs = XNEWVEC (basic_block, n_basic_blocks - NUM_FIXED_BLOCKS);\n+  bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS);\n   FOR_EACH_BB (bb)\n     if (bb->loop_father != current_loops->tree_root)\n       bbs[i++] = bb;"}, {"sha": "31db43a2c050019777c102bba27ccbd1d6435925", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -194,7 +194,7 @@ compute_live_loop_exits (bitmap live_exits, bitmap use_blocks,\n   /* Normally the work list size is bounded by the number of basic\n      blocks in the largest loop.  We don't know this number, but we\n      can be fairly sure that it will be relatively small.  */\n-  worklist.create (MAX (8, n_basic_blocks / 128));\n+  worklist.create (MAX (8, n_basic_blocks_for_fn (cfun) / 128));\n \n   EXECUTE_IF_SET_IN_BITMAP (use_blocks, 0, i, bi)\n     {"}, {"sha": "0c5dbb17aa5fba437e397ce1f3ab137d83665a8e", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -512,7 +512,7 @@ execute_cse_reciprocals (void)\n \n   occ_pool = create_alloc_pool (\"dominators for recip\",\n \t\t\t\tsizeof (struct occurrence),\n-\t\t\t\tn_basic_blocks / 3 + 1);\n+\t\t\t\tn_basic_blocks_for_fn (cfun) / 3 + 1);\n \n   memset (&reciprocal_stats, 0, sizeof (reciprocal_stats));\n   calculate_dominance_info (CDI_DOMINATORS);"}, {"sha": "a0d739881d61345fcd1617787104e88e9673976d", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -338,7 +338,7 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n      outer ones, and also that we do not try to visit a removed\n      block.  */\n   bb_order = single_pred_before_succ_order ();\n-  n = n_basic_blocks - NUM_FIXED_BLOCKS;\n+  n = n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS;\n \n   for (i = 0; i < n; i++)\n     {"}, {"sha": "6ab1b10d330f9f6fb2f8c43348c9c60359247b6b", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -3724,7 +3724,7 @@ compute_avail (void)\n     }\n \n   /* Allocate the worklist.  */\n-  worklist = XNEWVEC (basic_block, n_basic_blocks);\n+  worklist = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n \n   /* Seed the algorithm by putting the dominator children of the entry\n      block on the worklist.  */\n@@ -4655,7 +4655,7 @@ init_pre (void)\n   connect_infinite_loops_to_exit ();\n   memset (&pre_stats, 0, sizeof (pre_stats));\n \n-  postorder = XNEWVEC (int, n_basic_blocks);\n+  postorder = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n   postorder_num = inverted_post_order_compute (postorder);\n \n   alloc_aux_for_blocks (sizeof (struct bb_bitmap_sets));\n@@ -4731,7 +4731,7 @@ do_pre (void)\n      fixed, don't run it when he have an incredibly large number of\n      bb's.  If we aren't going to run insert, there is no point in\n      computing ANTIC, either, even though it's plenty fast.  */\n-  if (n_basic_blocks < 4000)\n+  if (n_basic_blocks_for_fn (cfun) < 4000)\n     {\n       compute_antic ();\n       insert ();"}, {"sha": "709b1c1ba635643489319c97cc891305fb8637d8", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -4537,7 +4537,7 @@ init_reassoc (void)\n {\n   int i;\n   long rank = 2;\n-  int *bbs = XNEWVEC (int, n_basic_blocks - NUM_FIXED_BLOCKS);\n+  int *bbs = XNEWVEC (int, n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS);\n \n   /* Find the loops, so that we can prevent moving calculations in\n      them.  */\n@@ -4567,7 +4567,7 @@ init_reassoc (void)\n     }\n \n   /* Set up rank for each BB  */\n-  for (i = 0; i < n_basic_blocks - NUM_FIXED_BLOCKS; i++)\n+  for (i = 0; i < n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS; i++)\n     bb_rank[bbs[i]] = ++rank  << 16;\n \n   free (bbs);"}, {"sha": "786cfaa0988c3e072e6e9961129c08e95f30953a", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -3981,13 +3981,14 @@ init_scc_vn (void)\n   shared_lookup_phiargs.create (0);\n   shared_lookup_references.create (0);\n   rpo_numbers = XNEWVEC (int, last_basic_block);\n-  rpo_numbers_temp = XNEWVEC (int, n_basic_blocks - NUM_FIXED_BLOCKS);\n+  rpo_numbers_temp =\n+    XNEWVEC (int, n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS);\n   pre_and_rev_post_order_compute (NULL, rpo_numbers_temp, false);\n \n   /* RPO numbers is an array of rpo ordering, rpo[i] = bb means that\n      the i'th block in RPO order is bb.  We want to map bb's to RPO\n      numbers, so we need to rearrange this array.  */\n-  for (j = 0; j < n_basic_blocks - NUM_FIXED_BLOCKS; j++)\n+  for (j = 0; j < n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS; j++)\n     rpo_numbers[rpo_numbers_temp[j]] = j;\n \n   XDELETE (rpo_numbers_temp);"}, {"sha": "79be216569346123cdc68229e0e17eecaa626ff4", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -763,11 +763,11 @@ static void\n init_worklist (void)\n {\n   alloc_aux_for_blocks (sizeof (struct aux_bb_info));\n-  same_succ_htab.create (n_basic_blocks);\n+  same_succ_htab.create (n_basic_blocks_for_fn (cfun));\n   same_succ_edge_flags = XCNEWVEC (int, last_basic_block);\n   deleted_bbs = BITMAP_ALLOC (NULL);\n   deleted_bb_preds = BITMAP_ALLOC (NULL);\n-  worklist.create (n_basic_blocks);\n+  worklist.create (n_basic_blocks_for_fn (cfun));\n   find_same_succ ();\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -995,7 +995,7 @@ static vec<bb_cluster> all_clusters;\n static void\n alloc_cluster_vectors (void)\n {\n-  all_clusters.create (n_basic_blocks);\n+  all_clusters.create (n_basic_blocks_for_fn (cfun));\n }\n \n /* Reset all cluster vectors.  */"}, {"sha": "e4b39986363505d717207dc7e7f9489d9dd01691", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -193,7 +193,7 @@ associate_equivalences_with_edges (void)\n \n \t      /* Now walk over the blocks to determine which ones were\n \t\t marked as being reached by a useful case label.  */\n-\t      for (i = 0; i < n_basic_blocks; i++)\n+\t      for (i = 0; i < n_basic_blocks_for_fn (cfun); i++)\n \t\t{\n \t\t  tree node = info[i];\n "}, {"sha": "fc3fc93ca5b4b1310105400ee67dcc3433f98b16", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cae8d31e7c7615774ef857f85a1fc84526ebc07/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=0cae8d31e7c7615774ef857f85a1fc84526ebc07", "patch": "@@ -838,7 +838,7 @@ vt_stack_adjustments (void)\n   VTI (ENTRY_BLOCK_PTR)->out.stack_adjust = INCOMING_FRAME_SP_OFFSET;\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = XNEWVEC (edge_iterator, n_basic_blocks + 1);\n+  stack = XNEWVEC (edge_iterator, n_basic_blocks_for_fn (cfun) + 1);\n   sp = 0;\n \n   /* Push the first edge on to the stack.  */\n@@ -6904,10 +6904,10 @@ vt_find_locations (void)\n   timevar_push (TV_VAR_TRACKING_DATAFLOW);\n   /* Compute reverse completion order of depth first search of the CFG\n      so that the data-flow runs faster.  */\n-  rc_order = XNEWVEC (int, n_basic_blocks - NUM_FIXED_BLOCKS);\n+  rc_order = XNEWVEC (int, n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS);\n   bb_order = XNEWVEC (int, last_basic_block);\n   pre_and_rev_post_order_compute (NULL, rc_order, false);\n-  for (i = 0; i < n_basic_blocks - NUM_FIXED_BLOCKS; i++)\n+  for (i = 0; i < n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS; i++)\n     bb_order[rc_order[i]] = i;\n   free (rc_order);\n \n@@ -10157,7 +10157,8 @@ variable_tracking_main_1 (void)\n       return 0;\n     }\n \n-  if (n_basic_blocks > 500 && n_edges / n_basic_blocks >= 20)\n+  if (n_basic_blocks_for_fn (cfun) > 500 &&\n+      n_edges / n_basic_blocks_for_fn (cfun) >= 20)\n     {\n       vt_debug_insns_local (true);\n       return 0;"}]}