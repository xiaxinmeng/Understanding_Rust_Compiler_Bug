{"sha": "153305b05c2e5965f24a64ead19b97eb95c148bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUzMzA1YjA1YzJlNTk2NWYyNGE2NGVhZDE5Yjk3ZWI5NWMxNDhiYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-02-17T14:13:09Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchell@gcc.gnu.org", "date": "1998-02-17T14:13:09Z"}, "message": "parse.y (initdcl0_innards): New grammar symbol.\n\n\t* parse.y (initdcl0_innards): New grammar symbol.\n\t(nomods_initdecls, nomods_initdcl0): Change type from itype to\n\tnone, since the resulting value is never used.\n\t(parse_decl): New function.\n\t(datadef): Remove redundant actions.\n\t(initdcl0, notype_initdcl0, nomods_initdcl0): Use initdcl0_innards.\n\t* parse.c: Regenerated.\n\nFrom-SVN: r18034", "tree": {"sha": "5d7393e6c8d9093f69ba59501683d968275bf9c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d7393e6c8d9093f69ba59501683d968275bf9c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/153305b05c2e5965f24a64ead19b97eb95c148bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/153305b05c2e5965f24a64ead19b97eb95c148bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/153305b05c2e5965f24a64ead19b97eb95c148bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/153305b05c2e5965f24a64ead19b97eb95c148bc/comments", "author": null, "committer": null, "parents": [{"sha": "feb60352fb581f0703adf017f3af3e7b955b8168", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feb60352fb581f0703adf017f3af3e7b955b8168", "html_url": "https://github.com/Rust-GCC/gccrs/commit/feb60352fb581f0703adf017f3af3e7b955b8168"}], "stats": {"total": 7679, "additions": 3836, "deletions": 3843}, "files": [{"sha": "f7de85484a812a51c71f19764fd8effa093b003c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/153305b05c2e5965f24a64ead19b97eb95c148bc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/153305b05c2e5965f24a64ead19b97eb95c148bc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=153305b05c2e5965f24a64ead19b97eb95c148bc", "patch": "@@ -1,3 +1,13 @@\n+Tue Feb 17 14:07:52 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* parse.y (initdcl0_innards): New grammar symbol.\n+\t(nomods_initdecls, nomods_initdcl0): Change type from itype to\n+\tnone, since the resulting value is never used.\n+\t(parse_decl): New function.\n+\t(datadef): Remove redundant actions.\n+\t(initdcl0, notype_initdcl0, nomods_initdcl0): Use initdcl0_innards.\n+\t* parse.c: Regenerated.\n+\t\n Tue Feb 17 11:54:16 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* parse.y (simple_stmt): Use getdecls() to check for decl.\n@@ -48,12 +58,22 @@ Thu Feb 12 12:46:51 1998  Benjamin Kosnik  <bkoz@rhino.cygnus.com>\n \n \t* decl.c (shadow_tag): Give error for typedef-ing built-in types.\n \n+Wed Feb 11 23:28:05 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* call.c (reference_binding): Use comptypes when comparing\n+\tTYPE_MAIN_VARIANTS to handle non-canonical array/index types.\n+\n Wed Feb 11 16:42:04 1998  Mark Mitchell  <mmitchell@usa.net>\n \n \t* tree.c (is_overloaded_fn): Use really_overloaded_fn.\n \t(really_overloaded_fn): Move check here from is_overloaded_fn. \n \t(get_first_fn): Use really_overloaded_fn and is_overloaded_fn.\n \n+Wed Feb 11 15:54:18 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* typeck.c (build_ptrmemfunc): Type-check pointer-to-member\n+\tconversions.\n+\n Mon Feb  9 22:23:31 1998  Mark Mitchell  <mmitchell@usa.net>\n \n \t* cp-tree.h (push_template_decl): Return the decl passed in, or an"}, {"sha": "94ba1939ecc1b26c61250e80d62d38ce52dae409", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 3754, "deletions": 3756, "changes": 7510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/153305b05c2e5965f24a64ead19b97eb95c148bc/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/153305b05c2e5965f24a64ead19b97eb95c148bc/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=153305b05c2e5965f24a64ead19b97eb95c148bc"}, {"sha": "9059dba8377f65d00ed6db3ac2296f5c6cf16f9b", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 62, "deletions": 87, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/153305b05c2e5965f24a64ead19b97eb95c148bc/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/153305b05c2e5965f24a64ead19b97eb95c148bc/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=153305b05c2e5965f24a64ead19b97eb95c148bc", "patch": "@@ -256,7 +256,7 @@ empty_parms ()\n %type <itype> new delete\n /* %type <ttype> primary_no_id */\n %type <ttype> nonmomentary_expr maybe_parmlist\n-%type <itype> initdcl0 notype_initdcl0 member_init_list\n+%type <itype> initdcl0 notype_initdcl0 member_init_list initdcl0_innards\n %type <ttype> template_header template_parm_list template_parm\n %type <ttype> template_type_parm template_template_parm\n %type <code>  template_close_bracket\n@@ -266,7 +266,6 @@ empty_parms ()\n %type <ttype> type_name nested_name_specifier nested_type ptr_to_mem\n %type <ttype> complete_type_name notype_identifier nonnested_type\n %type <ttype> complex_type_name nested_name_specifier_1\n-%type <itype> nomods_initdecls nomods_initdcl0\n %type <ttype> new_initializer new_placement\n %type <ttype> using_decl .poplevel\n %type <ttype> typename_sub typename_sub0 typename_sub1 typename_sub2\n@@ -305,6 +304,33 @@ static tree current_aggr;\n #define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n extern void yyprint\t\t\tPROTO((FILE *, int, YYSTYPE));\n extern tree combine_strings\t\tPROTO((tree));\n+\n+static int\n+parse_decl(declarator, specs_attrs, attributes, initialized, decl)\n+  tree declarator;\n+  tree specs_attrs;\n+  tree attributes;\n+  int initialized;\n+  tree* decl;\n+{\n+  int  sm;\n+\n+  split_specs_attrs (specs_attrs, &current_declspecs, &prefix_attributes);\n+  if (current_declspecs\n+      && TREE_CODE (current_declspecs) != TREE_LIST)\n+    current_declspecs = get_decl_list (current_declspecs);\n+  if (have_extern_spec && !used_extern_spec)\n+    {\n+      current_declspecs = decl_tree_cons (NULL_TREE, \n+\t\t\t\t\t  get_identifier (\"extern\"), \n+\t\t\t\t\t  current_declspecs);\n+      used_extern_spec = 1;\n+    }\n+  sm = suspend_momentary ();\n+  *decl = start_decl (declarator, current_declspecs, initialized);\n+  cplus_decl_attributes (*decl, attributes, prefix_attributes);\n+  return sm;\n+}\n %}\n \f\n %%\n@@ -540,7 +566,6 @@ template_def:\n \n datadef:\n \t  nomods_initdecls ';'\n-\t\t{}\n \t| declmods notype_initdecls ';'\n \t\t{}\n \t| typed_declspecs initdecls ';'\n@@ -2014,47 +2039,6 @@ maybeasm:\n \t\t{ if (TREE_CHAIN ($3)) $3 = combine_strings ($3); $$ = $3; }\n \t;\n \n-initdcl0:\n-\t  declarator maybeasm maybe_attribute '='\n-\t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n-\t\t\t\t     &prefix_attributes);\n-\t\t  if (current_declspecs\n-\t\t      && TREE_CODE (current_declspecs) != TREE_LIST)\n-\t\t    current_declspecs = get_decl_list (current_declspecs);\n-\t\t  if (have_extern_spec && !used_extern_spec)\n-\t\t    {\n-\t\t      current_declspecs = decl_tree_cons\n-\t\t\t(NULL_TREE, get_identifier (\"extern\"), \n-\t\t\t current_declspecs);\n-\t\t      used_extern_spec = 1;\n-\t\t    }\n-\t\t  $<itype>4 = suspend_momentary ();\n-\t\t  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1);\n-\t\t  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes); }\n-\t  init\n-/* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ cp_finish_decl ($<ttype>5, $6, $2, 1, LOOKUP_ONLYCONVERTING);\n-\t\t  $$ = $<itype>4; }\n-\t| declarator maybeasm maybe_attribute\n-\t\t{ tree d;\n-\t\t  split_specs_attrs ($<ttype>0, &current_declspecs,\n-\t\t\t\t     &prefix_attributes);\n-\t\t  if (current_declspecs\n-\t\t      && TREE_CODE (current_declspecs) != TREE_LIST)\n-\t\t    current_declspecs = get_decl_list (current_declspecs);\n-\t\t  if (have_extern_spec && !used_extern_spec)\n-\t\t    {\n-\t\t      current_declspecs = decl_tree_cons\n-\t\t\t(NULL_TREE, get_identifier (\"extern\"), \n-\t\t\t current_declspecs);\n-\t\t      used_extern_spec = 1;\n-\t\t    }\n-\t\t  $$ = suspend_momentary ();\n-\t\t  d = start_decl ($<ttype>1, current_declspecs, 0);\n-\t\t  cplus_decl_attributes (d, $3, prefix_attributes);\n-\t\t  cp_finish_decl (d, NULL_TREE, $2, 1, 0); }\n-\t;\n-\n initdcl:\n \t  declarator maybeasm maybe_attribute '='\n \t\t{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1);\n@@ -2068,54 +2052,45 @@ initdcl:\n \t\t  cp_finish_decl ($<ttype>$, NULL_TREE, $2, 1, 0); }\n \t;\n \n-notype_initdcl0:\n-\t  notype_declarator maybeasm maybe_attribute '='\n-\t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n-\t\t\t\t     &prefix_attributes);\n-\t\t  $<itype>4 = suspend_momentary ();\n-\t\t  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1);\n-\t\t  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes); }\n+        /* This rule assumes a certain configuration of the parser\n+\t   stack.  In particular, $0, the element directly before the\n+\t   beginning of this rule on the stack, must be a declarator,\n+\t   or notype_declarator.  And, $-1 must be some declmods, or\n+\t   declspecs.  */\n+initdcl0_innards:\n+\t  maybeasm maybe_attribute '='\n+\t\t{ $<itype>3 = parse_decl ($<ttype>0, $<ttype>-1, \n+\t\t\t\t\t   $2, 1, &$<ttype>$); }\n+          /* Note how the declaration of the variable is in effect\n+\t     while its init is parsed! */ \n \t  init\n-/* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ cp_finish_decl ($<ttype>5, $6, $2, 1, LOOKUP_ONLYCONVERTING);\n-\t\t  $$ = $<itype>4; }\n-\t| notype_declarator maybeasm maybe_attribute\n+\t\t{ cp_finish_decl ($<ttype>4, $5, $1, 1, LOOKUP_ONLYCONVERTING);\n+\t\t  $$ = $<itype>3; }\n+\t| maybeasm maybe_attribute\n \t\t{ tree d;\n-\t\t  split_specs_attrs ($<ttype>0, &current_declspecs,\n-\t\t\t\t     &prefix_attributes);\n-\t\t  $$ = suspend_momentary ();\n-\t\t  d = start_decl ($<ttype>1, current_declspecs, 0);\n-\t\t  cplus_decl_attributes (d, $3, prefix_attributes);\n-\t\t  cp_finish_decl (d, NULL_TREE, $2, 1, 0); }\n-\t;\n-\n+\t\t  $$ = parse_decl ($<ttype>0, $<ttype>-1, $2, 0, &d);\n+\t\t  cp_finish_decl (d, NULL_TREE, $1, 1, 0); }\n+  \t;\n+  \n+initdcl0:\n+\t  declarator initdcl0_innards\n+            { $$ = $2; }\n+  \n+notype_initdcl0:\n+          notype_declarator initdcl0_innards\n+            { $$ = $2; }\n+        ;\n+  \n nomods_initdcl0:\n-\t  notype_declarator maybeasm maybe_attribute '='\n-\t\t{ current_declspecs = NULL_TREE;\n-\t\t  prefix_attributes = NULL_TREE;\n-\t\t  $<itype>4 = suspend_momentary ();\n-\t\t  $<ttype>$ = start_decl ($1, current_declspecs, 1);\n-\t\t  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes); }\n-\t  init\n-/* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ cp_finish_decl ($<ttype>5, $6, $2, 1, LOOKUP_ONLYCONVERTING);\n-\t\t  $$ = $<itype>4; }\n-\t| notype_declarator maybeasm maybe_attribute\n-\t\t{ tree d;\n-\t\t  current_declspecs = NULL_TREE;\n-\t\t  prefix_attributes = NULL_TREE;\n-\t\t  $$ = suspend_momentary ();\n-\t\t  d = start_decl ($1, current_declspecs, 0);\n-\t\t  cplus_decl_attributes (d, $3, prefix_attributes);\n-\t\t  cp_finish_decl (d, NULL_TREE, $2, 1, 0); }\n+          notype_declarator \n+            { /* Set things up as initdcl0_innards expects.  */\n+\t      $<ttype>$ = $1; \n+              $1 = NULL_TREE; }\n+          initdcl0_innards \n+            {}\n \t| constructor_declarator maybeasm maybe_attribute\n \t\t{ tree d;\n-\t\t  current_declspecs = NULL_TREE;\n-\t\t  prefix_attributes = NULL_TREE;\n-\t\t  $$ = suspend_momentary ();\n-\t\t  d = start_decl ($1, current_declspecs, 0);\n-\t\t  cplus_decl_attributes (d, $3, prefix_attributes);\n-\t\t  cp_finish_decl (d, NULL_TREE, $2, 1, 0); }\n+\t\t  parse_decl($1, NULL_TREE, $3, 0, &d); }\n \t;\n \n /* the * rules are dummies to accept the Apollo extended syntax"}]}