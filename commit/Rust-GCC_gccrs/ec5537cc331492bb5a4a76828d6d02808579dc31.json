{"sha": "ec5537cc331492bb5a4a76828d6d02808579dc31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM1NTM3Y2MzMzE0OTJiYjVhNGE3NjgyOGQ2ZDAyODA4NTc5ZGMzMQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2005-06-27T16:35:49Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2005-06-27T16:35:49Z"}, "message": "re PR libstdc++/22102 ([DR233] Implement resolution of DR 233)\n\n2005-06-27  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/22102\n\t* include/bits/stl_tree.h (insert_unique(iterator, const _Val&),\n\tinsert_equal((iterator, const _Val&)): Reimplement to check both\n\tbefore and after, as per the algorithm \"ignore hint if wrong\" of\n\tISO paper N1780.\n\nFrom-SVN: r101355", "tree": {"sha": "0772f753c98c880b135912b09e20119104c06d0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0772f753c98c880b135912b09e20119104c06d0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec5537cc331492bb5a4a76828d6d02808579dc31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec5537cc331492bb5a4a76828d6d02808579dc31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec5537cc331492bb5a4a76828d6d02808579dc31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec5537cc331492bb5a4a76828d6d02808579dc31/comments", "author": null, "committer": null, "parents": [{"sha": "fd1e17264b0e1b9adaf0cd2302b2f33a2e036b0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd1e17264b0e1b9adaf0cd2302b2f33a2e036b0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd1e17264b0e1b9adaf0cd2302b2f33a2e036b0c"}], "stats": {"total": 83, "additions": 65, "deletions": 18}, "files": [{"sha": "45b0fc5a5c7c87f2b07744476b5c92c81560ee11", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5537cc331492bb5a4a76828d6d02808579dc31/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5537cc331492bb5a4a76828d6d02808579dc31/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ec5537cc331492bb5a4a76828d6d02808579dc31", "patch": "@@ -1,3 +1,11 @@\n+2005-06-27  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/22102\n+\t* include/bits/stl_tree.h (insert_unique(iterator, const _Val&),\n+\tinsert_equal((iterator, const _Val&)): Reimplement to check both\n+\tbefore and after, as per the algorithm \"ignore hint if wrong\" of\n+\tISO paper N1780.\n+\n 2005-06-27  Benjamin Kosnik  <bkoz@redhat.com>\n \t    Ami Tavory  <pbassoc@gmail.com>\n \t"}, {"sha": "91f9f906b3cf132a7ddb7d2e82444c7977bc5710", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5537cc331492bb5a4a76828d6d02808579dc31/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5537cc331492bb5a4a76828d6d02808579dc31/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=ec5537cc331492bb5a4a76828d6d02808579dc31", "patch": "@@ -893,8 +893,8 @@ namespace std\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     insert_unique(iterator __position, const _Val& __v)\n     {\n-      if (__position._M_node == _M_end()\n-\t  || __position._M_node == _M_rightmost())\n+      // end()\n+      if (__position._M_node == _M_end())\n \t{\n \t  if (size() > 0\n \t      && _M_impl._M_key_compare(_S_key(_M_rightmost()), \n@@ -903,24 +903,45 @@ namespace std\n \t  else\n \t    return insert_unique(__v).first;\n \t}\n-      else\n+      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),\n+\t\t\t\t      _S_key(__position._M_node)))\n \t{\n+\t  // First, try before...\n+\t  iterator __before = __position;\n+\t  if (__position._M_node == _M_leftmost()) // begin()\n+\t    return _M_insert(_M_leftmost(), _M_leftmost(), __v);\n+\t  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), \n+\t\t\t\t\t  _KeyOfValue()(__v)))\n+\t    {\n+\t      if (_S_right(__before._M_node) == 0)\n+\t\treturn _M_insert(0, __before._M_node, __v);\n+\t      else\n+\t\treturn _M_insert(__position._M_node,\n+\t\t\t\t __position._M_node, __v);\n+\t    }\n+\t  else\n+\t    return insert_unique(__v).first;\n+\t}\n+      else if (_M_impl._M_key_compare(_S_key(__position._M_node),\n+\t\t\t\t      _KeyOfValue()(__v)))\n+\t{\n+\t  // ... then try after.\n \t  iterator __after = __position;\n-\t  ++__after;\n-\t  if (_M_impl._M_key_compare(_S_key(__position._M_node), \n-\t\t\t\t     _KeyOfValue()(__v))\n-\t      && _M_impl._M_key_compare(_KeyOfValue()(__v),\n-\t\t\t\t\t_S_key(__after._M_node)))\n+\t  if (__position._M_node == _M_rightmost())\n+\t    return _M_insert(0, _M_rightmost(), __v);\n+\t  else if (_M_impl._M_key_compare(_KeyOfValue()(__v),\n+\t\t\t\t\t  _S_key((++__after)._M_node)))\n \t    {\n \t      if (_S_right(__position._M_node) == 0)\n \t\treturn _M_insert(0, __position._M_node, __v);\n \t      else\n \t\treturn _M_insert(__after._M_node, __after._M_node, __v);\n-\t      // First argument just needs to be non-null.\n \t    }\n \t  else\n \t    return insert_unique(__v).first;\n \t}\n+      else\n+\treturn __position; // Equivalent keys.\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -929,30 +950,48 @@ namespace std\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     insert_equal(iterator __position, const _Val& __v)\n     {\n-      if (__position._M_node == _M_end()\n-\t  || __position._M_node == _M_rightmost())\n+      // end()\n+      if (__position._M_node == _M_end())\n \t{\n \t  if (size() > 0\n-\t      && !_M_impl._M_key_compare(_KeyOfValue()(__v), \n+\t      && !_M_impl._M_key_compare(_KeyOfValue()(__v),\n \t\t\t\t\t _S_key(_M_rightmost())))\n \t    return _M_insert(0, _M_rightmost(), __v);\n \t  else\n \t    return insert_equal(__v);\n \t}\n+      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),\n+\t\t\t\t       _KeyOfValue()(__v)))\n+\t{\n+\t  // First, try before...\n+\t  iterator __before = __position;\n+\t  if (__position._M_node == _M_leftmost()) // begin()\n+\t    return _M_insert(_M_leftmost(), _M_leftmost(), __v);\n+\t  else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),\n+\t\t\t\t\t   _S_key((--__before)._M_node)))\n+\t    {\n+\t      if (_S_right(__before._M_node) == 0)\n+\t\treturn _M_insert(0, __before._M_node, __v);\n+\t      else\n+\t\treturn _M_insert(__position._M_node,\n+\t\t\t\t __position._M_node, __v);\n+\t    }\n+\t  else\n+\t    return insert_equal(__v);\n+\t}\n       else\n \t{\n+\t  // ... then try after.  \n \t  iterator __after = __position;\n-\t  ++__after;\n-\t  if (!_M_impl._M_key_compare(_KeyOfValue()(__v), \n-\t\t\t\t      _S_key(__position._M_node))\n-\t      && !_M_impl._M_key_compare(_S_key(__after._M_node),\n-\t\t\t\t\t _KeyOfValue()(__v)))\n+\t  if (__position._M_node == _M_rightmost())\n+\t    return _M_insert(0, _M_rightmost(), __v);\n+\t  else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),\n+\t\t\t\t\t   _KeyOfValue()(__v)))\n \t    {\n \t      if (_S_right(__position._M_node) == 0)\n \t\treturn _M_insert(0, __position._M_node, __v);\n \t      else\n \t\treturn _M_insert(__after._M_node, __after._M_node, __v);\n-\t      // First argument just needs to be non-null.\n \t    }\n \t  else\n \t    return insert_equal(__v);"}]}