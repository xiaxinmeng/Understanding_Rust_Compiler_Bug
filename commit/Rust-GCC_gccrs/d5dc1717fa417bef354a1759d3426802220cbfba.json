{"sha": "d5dc1717fa417bef354a1759d3426802220cbfba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVkYzE3MTdmYTQxN2JlZjM1NGExNzU5ZDM0MjY4MDIyMjBjYmZiYQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenth@gcc.gnu.org", "date": "2005-06-02T22:05:13Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2005-06-02T22:05:13Z"}, "message": "tree-ssa-loop-ivopts.c (build_addr_strip_iref): Remove.\n\n2005-06-03  Richard Guenther  <rguenth@gcc.gnu.org>\n\n\t* tree-ssa-loop-ivopts.c (build_addr_strip_iref): Remove.\n\t(find_interesting_uses_address): Use build_fold_addr_expr instead.\n\t(strip_offset_1): Likewise.\n\t(tree_to_aff_combination): Likewise.\n\nFrom-SVN: r100519", "tree": {"sha": "6cd4509b34a9c48491236112d638189abd4ab478", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cd4509b34a9c48491236112d638189abd4ab478"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5dc1717fa417bef354a1759d3426802220cbfba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5dc1717fa417bef354a1759d3426802220cbfba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5dc1717fa417bef354a1759d3426802220cbfba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5dc1717fa417bef354a1759d3426802220cbfba/comments", "author": null, "committer": null, "parents": [{"sha": "4e9cd9d8aa3ccfe72fecce5f2ab4419c6028d52d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e9cd9d8aa3ccfe72fecce5f2ab4419c6028d52d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e9cd9d8aa3ccfe72fecce5f2ab4419c6028d52d"}], "stats": {"total": 32, "additions": 10, "deletions": 22}, "files": [{"sha": "1cae64e34425051e6bb5e4f84176b3a7f55bacb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc1717fa417bef354a1759d3426802220cbfba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc1717fa417bef354a1759d3426802220cbfba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d5dc1717fa417bef354a1759d3426802220cbfba", "patch": "@@ -1,3 +1,10 @@\n+2005-06-03  Richard Guenther  <rguenth@gcc.gnu.org>\n+\n+\t* tree-ssa-loop-ivopts.c (build_addr_strip_iref): Remove.\n+\t(find_interesting_uses_address): Use build_fold_addr_expr instead.\n+\t(strip_offset_1): Likewise.\n+\t(tree_to_aff_combination): Likewise.\n+\n 2005-06-02  DJ Delorie  <dj@redhat.com>\n \n \t* convert.c (convert_to_pointer): Avoid recursion if no conversion"}, {"sha": "81bec044c5f87c6fe65fe7dd67343c0d8ec5e65c", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc1717fa417bef354a1759d3426802220cbfba/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc1717fa417bef354a1759d3426802220cbfba/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=d5dc1717fa417bef354a1759d3426802220cbfba", "patch": "@@ -1511,25 +1511,6 @@ may_be_unaligned_p (tree ref)\n   return false;\n }\n \n-/* Builds ADDR_EXPR of object OBJ.  If OBJ is an INDIRECT_REF, the indirect_ref\n-   is stripped instead.  */\n-\n-static tree\n-build_addr_strip_iref (tree obj)\n-{\n-  tree type;\n-\n-  if (TREE_CODE (obj) == INDIRECT_REF)\n-    {\n-      type = build_pointer_type (TREE_TYPE (obj));\n-      obj = fold_convert (type, TREE_OPERAND (obj, 0));\n-    }\n-  else\n-    obj = build_addr (obj, current_function_decl);\n-\n-  return obj;\n-}\n-\n /* Finds addresses in *OP_P inside STMT.  */\n \n static void\n@@ -1564,7 +1545,7 @@ find_interesting_uses_address (struct ivopts_data *data, tree stmt, tree *op_p)\n   gcc_assert (TREE_CODE (base) != ALIGN_INDIRECT_REF);\n   gcc_assert (TREE_CODE (base) != MISALIGNED_INDIRECT_REF);\n \n-  base = build_addr_strip_iref (base);\n+  base = build_fold_addr_expr (base);\n \n   civ = alloc_iv (base, step);\n   record_use (data, op_p, civ, stmt, USE_ADDRESS);\n@@ -1857,7 +1838,7 @@ strip_offset_1 (tree expr, bool inside_addr, bool top_compref,\n       if (op0 == TREE_OPERAND (expr, 0))\n \treturn orig_expr;\n \n-      expr = build_addr_strip_iref (op0);\n+      expr = build_fold_addr_expr (op0);\n       return fold_convert (orig_type, expr);\n \n     case INDIRECT_REF:\n@@ -2845,7 +2826,7 @@ tree_to_aff_combination (tree expr, tree type,\n       if (bitpos % BITS_PER_UNIT != 0)\n \tbreak;\n       aff_combination_const (comb, type, bitpos / BITS_PER_UNIT);\n-      core = build_addr_strip_iref (core);\n+      core = build_fold_addr_expr (core);\n       if (TREE_CODE (core) == ADDR_EXPR)\n \taff_combination_add_elt (comb, core, 1);\n       else"}]}