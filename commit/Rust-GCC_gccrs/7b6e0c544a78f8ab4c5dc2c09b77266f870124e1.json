{"sha": "7b6e0c544a78f8ab4c5dc2c09b77266f870124e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I2ZTBjNTQ0YTc4ZjhhYjRjNWRjMmMwOWI3NzI2NmY4NzAxMjRlMQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2014-12-15T19:51:31Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2014-12-15T19:51:31Z"}, "message": "ira-int.h (ira_prohibited_class_mode_regs): Remove.\n\n2014-12-15  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* ira-int.h (ira_prohibited_class_mode_regs): Remove.\n\t(struct target_ira_int): Move x_ira_prohibited_class_mode_regs to\n\t...\n\t* ira.h (struct target_ira_int): ... here.\n\t(ira_prohibited_class_mode_regs): Define.\n\t* lra-constraints.c (process_alt_operands): Add one more condition\n\tto refuse alternative when reload pseudo of given class can not\n\thold value of given mode.\n\nFrom-SVN: r218760", "tree": {"sha": "750014302b6c2aa69719a56bb900622d8fc084ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/750014302b6c2aa69719a56bb900622d8fc084ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b6e0c544a78f8ab4c5dc2c09b77266f870124e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b6e0c544a78f8ab4c5dc2c09b77266f870124e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b6e0c544a78f8ab4c5dc2c09b77266f870124e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b6e0c544a78f8ab4c5dc2c09b77266f870124e1/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2405e0ea00fea38ed86fade3d10fb728ba1ff0f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2405e0ea00fea38ed86fade3d10fb728ba1ff0f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2405e0ea00fea38ed86fade3d10fb728ba1ff0f6"}], "stats": {"total": 47, "additions": 33, "deletions": 14}, "files": [{"sha": "8276d646c5d8a881a432099f4b86d6678f35bceb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6e0c544a78f8ab4c5dc2c09b77266f870124e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6e0c544a78f8ab4c5dc2c09b77266f870124e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b6e0c544a78f8ab4c5dc2c09b77266f870124e1", "patch": "@@ -1,3 +1,14 @@\n+2014-12-15  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* ira-int.h (ira_prohibited_class_mode_regs): Remove.\n+\t(struct target_ira_int): Move x_ira_prohibited_class_mode_regs to\n+\t...\n+\t* ira.h (struct target_ira_int): ... here.\n+\t(ira_prohibited_class_mode_regs): Define.\n+\t* lra-constraints.c (process_alt_operands): Add one more condition\n+\tto refuse alternative when reload pseudo of given class can not\n+\thold value of given mode.\n+\n 2014-12-15  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/64312"}, {"sha": "0799b1e0fefc13cd17af65528b5389fdf07aafc2", "filename": "gcc/ira-int.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6e0c544a78f8ab4c5dc2c09b77266f870124e1/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6e0c544a78f8ab4c5dc2c09b77266f870124e1/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=7b6e0c544a78f8ab4c5dc2c09b77266f870124e1", "patch": "@@ -843,11 +843,6 @@ struct target_ira_int {\n      unavailable for the allocation.  */\n   short x_ira_class_hard_reg_index[N_REG_CLASSES][FIRST_PSEUDO_REGISTER];\n \n-  /* Array whose values are hard regset of hard registers available for\n-     the allocation of given register class whose HARD_REGNO_MODE_OK\n-     values for given mode are zero.  */\n-  HARD_REG_SET x_ira_prohibited_class_mode_regs[N_REG_CLASSES][NUM_MACHINE_MODES];\n-\n   /* Index [CL][M] contains R if R appears somewhere in a register of the form:\n \n          (reg:M R'), R' not in x_ira_prohibited_class_mode_regs[CL][M]\n@@ -939,8 +934,6 @@ extern struct target_ira_int *this_target_ira_int;\n   (this_target_ira_int->x_ira_non_ordered_class_hard_regs)\n #define ira_class_hard_reg_index \\\n   (this_target_ira_int->x_ira_class_hard_reg_index)\n-#define ira_prohibited_class_mode_regs \\\n-  (this_target_ira_int->x_ira_prohibited_class_mode_regs)\n #define ira_useful_class_mode_regs \\\n   (this_target_ira_int->x_ira_useful_class_mode_regs)\n #define ira_important_classes_num \\"}, {"sha": "2fa8d6db902dde776695a170df5dca9f55429c7c", "filename": "gcc/ira.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6e0c544a78f8ab4c5dc2c09b77266f870124e1/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6e0c544a78f8ab4c5dc2c09b77266f870124e1/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=7b6e0c544a78f8ab4c5dc2c09b77266f870124e1", "patch": "@@ -110,6 +110,11 @@ struct target_ira\n   /* Function specific hard registers can not be used for the register\n      allocation.  */\n   HARD_REG_SET x_ira_no_alloc_regs;\n+\n+  /* Array whose values are hard regset of hard registers available for\n+     the allocation of given register class whose HARD_REGNO_MODE_OK\n+     values for given mode are zero.  */\n+  HARD_REG_SET x_ira_prohibited_class_mode_regs[N_REG_CLASSES][NUM_MACHINE_MODES];\n };\n \n extern struct target_ira default_target_ira;\n@@ -155,6 +160,8 @@ extern struct target_ira *this_target_ira;\n   (this_target_ira->x_ira_class_singleton)\n #define ira_no_alloc_regs \\\n   (this_target_ira->x_ira_no_alloc_regs)\n+#define ira_prohibited_class_mode_regs \\\n+  (this_target_ira->x_ira_prohibited_class_mode_regs)\n \n /* Major structure describing equivalence info for a pseudo.  */\n struct ira_reg_equiv_s"}, {"sha": "a108b84c1200dd76c456555b2eddd20842100777", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6e0c544a78f8ab4c5dc2c09b77266f870124e1/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6e0c544a78f8ab4c5dc2c09b77266f870124e1/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=7b6e0c544a78f8ab4c5dc2c09b77266f870124e1", "patch": "@@ -2269,17 +2269,25 @@ process_alt_operands (int only_alternative)\n \n \t      /* Alternative loses if it required class pseudo can not\n \t\t hold value of required mode.  Such insns can be\n-\t\t described by insn definitions with mode iterators.\n-\t\t Don't use ira_prohibited_class_mode_regs here as it\n-\t\t is common practice for constraints to use a class\n-\t\t which does not have actually enough regs to hold the\n-\t\t value (e.g. x86 AREG for mode requiring more one\n-\t\t general reg).  */\n+\t\t described by insn definitions with mode iterators.  */\n \t      if (GET_MODE (*curr_id->operand_loc[nop]) != VOIDmode\n \t\t  && ! hard_reg_set_empty_p (this_alternative_set)\n+\t\t  /* It is common practice for constraints to use a\n+\t\t     class which does not have actually enough regs to\n+\t\t     hold the value (e.g. x86 AREG for mode requiring\n+\t\t     more one general reg).  Therefore we have 2\n+\t\t     conditions to check that the reload pseudo can\n+\t\t     not hold the mode value.  */\n \t\t  && ! HARD_REGNO_MODE_OK (ira_class_hard_regs\n \t\t\t\t\t   [this_alternative][0],\n-\t\t\t\t\t   GET_MODE (*curr_id->operand_loc[nop])))\n+\t\t\t\t\t   GET_MODE (*curr_id->operand_loc[nop]))\n+\t\t  /* The above condition is not enough as the first\n+\t\t     reg in ira_class_hard_regs can be not aligned for\n+\t\t     multi-words mode values.  */\n+\t\t  && hard_reg_set_subset_p (this_alternative_set,\n+\t\t\t\t\t    ira_prohibited_class_mode_regs\n+\t\t\t\t\t    [this_alternative]\n+\t\t\t\t\t    [GET_MODE (*curr_id->operand_loc[nop])]))\n \t\t{\n \t\t  if (lra_dump_file != NULL)\n \t\t    fprintf"}]}