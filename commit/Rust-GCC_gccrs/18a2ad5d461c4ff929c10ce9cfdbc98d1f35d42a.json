{"sha": "18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThhMmFkNWQ0NjFjNGZmOTI5YzEwY2U5Y2ZkYmM5OGQxZjM1ZDQyYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-12-05T11:06:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-12-05T11:06:35Z"}, "message": "[multiple changes]\n\n2012-12-05  Yannick Moy  <moy@adacore.com>\n\n\t* urealp.ads: Minor rewording.\n\n2012-12-05  Yannick Moy  <moy@adacore.com>\n\n\t* aspects.ads (No_Duplicates_Allowed): Forbid use of duplicate\n\tContract_Cases aspects.\n\t* sem_prag.adb (Analyze_Pragma/Pragma_Contract_Case): Rename\n\tPOST_CASE into CONTRACT_CASE in both grammar and code, to be\n\tconsistent with current language definition.  Issue a more precise\n\terror message when the pragma duplicates another pragma or aspect.\n\n2012-12-05  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Add processing\n\tfor attribute Update.\n\t(Expand_Update_Attribute): New routine.\n\t* par-ch4.adb (P_Name): The sole expression of attribute Update\n\tis an aggregate, parse it accordingly.\n\t* sem_attr.adb (Analyze_Attribute): Verify the legality of\n\tattribute Update.\n\t(Eval_Attribute): Attribute Update does not\n\tneed evaluation because it is never static.\n\t* snames.ads-tmpl: Add Name_Update to the list of special names\n\trecognized by the compiler. Add an Attribute_Id for Update.\n\n2012-12-05  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_util.adb (Remove_Side_Effects): For purposes of removing\n\tside effects, qualified expressions do not receive a special\n\ttreatment, even though in Ada 2012 they are defined  as object\n\treferences.\n\n2012-12-05  Thomas Quinot  <quinot@adacore.com>\n\n\t* par-ch3.adb: Minor reformatting.\n\nFrom-SVN: r194207", "tree": {"sha": "c448c3a9f6e68c17eab8c44f8b4d4f9a81a7b3a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c448c3a9f6e68c17eab8c44f8b4d4f9a81a7b3a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/comments", "author": null, "committer": null, "parents": [{"sha": "baad98300aff8149553e5f09871be690bd5cacb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baad98300aff8149553e5f09871be690bd5cacb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/baad98300aff8149553e5f09871be690bd5cacb9"}], "stats": {"total": 674, "additions": 556, "deletions": 118}, "files": [{"sha": "7a46c4d11cbf8b667d962fba015cfca1d43ea3da", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a", "patch": "@@ -1,3 +1,41 @@\n+2012-12-05  Yannick Moy  <moy@adacore.com>\n+\n+\t* urealp.ads: Minor rewording.\n+\n+2012-12-05  Yannick Moy  <moy@adacore.com>\n+\n+\t* aspects.ads (No_Duplicates_Allowed): Forbid use of duplicate\n+\tContract_Cases aspects.\n+\t* sem_prag.adb (Analyze_Pragma/Pragma_Contract_Case): Rename\n+\tPOST_CASE into CONTRACT_CASE in both grammar and code, to be\n+\tconsistent with current language definition.  Issue a more precise\n+\terror message when the pragma duplicates another pragma or aspect.\n+\n+2012-12-05  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): Add processing\n+\tfor attribute Update.\n+\t(Expand_Update_Attribute): New routine.\n+\t* par-ch4.adb (P_Name): The sole expression of attribute Update\n+\tis an aggregate, parse it accordingly.\n+\t* sem_attr.adb (Analyze_Attribute): Verify the legality of\n+\tattribute Update.\n+\t(Eval_Attribute): Attribute Update does not\n+\tneed evaluation because it is never static.\n+\t* snames.ads-tmpl: Add Name_Update to the list of special names\n+\trecognized by the compiler. Add an Attribute_Id for Update.\n+\n+2012-12-05  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_util.adb (Remove_Side_Effects): For purposes of removing\n+\tside effects, qualified expressions do not receive a special\n+\ttreatment, even though in Ada 2012 they are defined  as object\n+\treferences.\n+\n+2012-12-05  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* par-ch3.adb: Minor reformatting.\n+\n 2012-12-05  Thomas Quinot  <quinot@adacore.com>\n \n \t* exp_dist.adb (Build_From_Any_Call, Build_To_Any_Call,"}, {"sha": "d896de8bc3e73552186eb92984660a98c3465a00", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a", "patch": "@@ -257,7 +257,6 @@ package Aspects is\n \n    No_Duplicates_Allowed : constant array (Aspect_Id) of Boolean :=\n                              (Aspect_Contract_Case  => False,\n-                              Aspect_Contract_Cases => False,\n                               Aspect_Test_Case      => False,\n                               others                => True);\n "}, {"sha": "2fa944b7d6f59e6aebacccd79543b49efac1a021", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a", "patch": "@@ -140,6 +140,9 @@ package body Exp_Attr is\n    --  Handles expansion of Pred or Succ attributes for case of non-real\n    --  operand with overflow checking required.\n \n+   procedure Expand_Update_Attribute (N : Node_Id);\n+   --  Handle the expansion of attribute Update\n+\n    function Get_Index_Subtype (N : Node_Id) return Entity_Id;\n    --  Used for Last, Last, and Length, when the prefix is an array type.\n    --  Obtains the corresponding index subtype.\n@@ -5237,6 +5240,13 @@ package body Exp_Attr is\n          Analyze_And_Resolve (N, Typ);\n       end UET_Address;\n \n+      ------------\n+      -- Update --\n+      ------------\n+\n+      when Attribute_Update =>\n+         Expand_Update_Attribute (N);\n+\n       ---------------\n       -- VADS_Size --\n       ---------------\n@@ -6160,6 +6170,197 @@ package body Exp_Attr is\n       end if;\n    end Expand_Pred_Succ;\n \n+   -----------------------------\n+   -- Expand_Update_Attribute --\n+   -----------------------------\n+\n+   procedure Expand_Update_Attribute (N : Node_Id) is\n+      procedure Process_Component_Or_Element_Update\n+        (Temp : Entity_Id;\n+         Comp : Node_Id;\n+         Expr : Node_Id;\n+         Typ  : Entity_Id);\n+      --  Generate the statements necessary to update a single component or an\n+      --  element of the prefix. The code is inserted before the attribute N.\n+      --  Temp denotes the entity of the anonymous object created to reflect\n+      --  the changes in values. Comp is the component/index expression to be\n+      --  updated. Expr is an expression yielding the new value of Comp. Typ\n+      --  is the type of the prefix of attribute Update.\n+\n+      procedure Process_Range_Update\n+        (Temp : Entity_Id;\n+         Comp : Node_Id;\n+         Expr : Node_Id);\n+      --  Generate the statements necessary to update a slice of the prefix.\n+      --  The code is inserted before the attribute N. Temp denotes the entity\n+      --  of the anonymous object created to reflect the changes in values.\n+      --  Comp is range of the slice to be updated. Expr is an expression\n+      --  yielding the new value of Comp.\n+\n+      -----------------------------------------\n+      -- Process_Component_Or_Element_Update --\n+      -----------------------------------------\n+\n+      procedure Process_Component_Or_Element_Update\n+        (Temp : Entity_Id;\n+         Comp : Node_Id;\n+         Expr : Node_Id;\n+         Typ  : Entity_Id)\n+      is\n+         Loc   : constant Source_Ptr := Sloc (Comp);\n+         Exprs : List_Id;\n+         LHS   : Node_Id;\n+\n+      begin\n+         --  An array element may be modified by the following relations\n+         --  depending on the number of dimensions:\n+\n+         --     1 => Expr           --  one dimensional update\n+         --    (1, ..., N) => Expr  --  multi dimensional update\n+\n+         --  The above forms are converted in assignment statements where the\n+         --  left hand side is an indexed component:\n+\n+         --    Temp (1) := Expr;          --  one dimensional update\n+         --    Temp (1, ..., N) := Expr;  --  multi dimensional update\n+\n+         if Is_Array_Type (Typ) then\n+\n+            --  The index expressions of a multi dimensional array update\n+            --  appear as an aggregate.\n+\n+            if Nkind (Comp) = N_Aggregate then\n+               Exprs := New_Copy_List_Tree (Expressions (Comp));\n+            else\n+               Exprs := New_List (Relocate_Node (Comp));\n+            end if;\n+\n+            LHS :=\n+              Make_Indexed_Component (Loc,\n+                Prefix      => New_Reference_To (Temp, Loc),\n+                Expressions => Exprs);\n+\n+         --  A record component update appears in the following form:\n+\n+         --    Comp => Expr\n+\n+         --  The above relation is transformed into an assignment statement\n+         --  where the left hand side is a selected component:\n+\n+         --    Temp.Comp := Expr;\n+\n+         else pragma Assert (Is_Record_Type (Typ));\n+            LHS :=\n+              Make_Selected_Component (Loc,\n+                Prefix        => New_Reference_To (Temp, Loc),\n+                Selector_Name => Relocate_Node (Comp));\n+         end if;\n+\n+         Insert_Action (N,\n+           Make_Assignment_Statement (Loc,\n+             Name       => LHS,\n+             Expression => Relocate_Node (Expr)));\n+      end Process_Component_Or_Element_Update;\n+\n+      --------------------------\n+      -- Process_Range_Update --\n+      --------------------------\n+\n+      procedure Process_Range_Update\n+        (Temp : Entity_Id;\n+         Comp : Node_Id;\n+         Expr : Node_Id)\n+      is\n+         Loc   : constant Source_Ptr := Sloc (Comp);\n+         Index : Entity_Id;\n+\n+      begin\n+         --  A range update appears as\n+\n+         --    (Low .. High => Expr)\n+\n+         --  The above construct is transformed into a loop that iterates over\n+         --  the given range and modifies the corresponding array values to the\n+         --  value of Expr:\n+\n+         --    for Index in Low .. High loop\n+         --       Temp (Index) := Expr;\n+         --    end loop;\n+\n+         Index := Make_Temporary (Loc, 'I');\n+\n+         Insert_Action (N,\n+           Make_Loop_Statement (Loc,\n+             Iteration_Scheme =>\n+               Make_Iteration_Scheme (Loc,\n+                 Loop_Parameter_Specification =>\n+                   Make_Loop_Parameter_Specification (Loc,\n+                     Defining_Identifier         => Index,\n+                     Discrete_Subtype_Definition => Relocate_Node (Comp))),\n+\n+             Statements       => New_List (\n+               Make_Assignment_Statement (Loc,\n+                 Name       =>\n+                   Make_Indexed_Component (Loc,\n+                     Prefix      => New_Reference_To (Temp, Loc),\n+                     Expressions => New_List (New_Reference_To (Index, Loc))),\n+                 Expression => Relocate_Node (Expr))),\n+\n+             End_Label        => Empty));\n+      end Process_Range_Update;\n+\n+      --  Local variables\n+\n+      Aggr  : constant Node_Id := First (Expressions (N));\n+      Loc   : constant Source_Ptr := Sloc (N);\n+      Pref  : constant Node_Id := Prefix (N);\n+      Typ   : constant Entity_Id := Etype (Pref);\n+      Assoc : Node_Id;\n+      Comp  : Node_Id;\n+      Expr  : Node_Id;\n+      Temp  : Entity_Id;\n+\n+   --  Start of processing for Expand_Update_Attribute\n+\n+   begin\n+      --  Create the anonymous object that stores the value of the prefix and\n+      --  reflects subsequent changes in value. Generate:\n+\n+      --    Temp : <type of Pref> := Pref;\n+\n+      Temp := Make_Temporary (Loc, 'T');\n+\n+      Insert_Action (N,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Temp,\n+          Object_Definition   => New_Reference_To (Typ, Loc),\n+          Expression          => Relocate_Node (Pref)));\n+\n+      --  Process the update aggregate\n+\n+      Assoc := First (Component_Associations (Aggr));\n+      while Present (Assoc) loop\n+         Comp := First (Choices (Assoc));\n+         Expr := Expression (Assoc);\n+         while Present (Comp) loop\n+            if Nkind (Comp) = N_Range then\n+               Process_Range_Update (Temp, Comp, Expr);\n+            else\n+               Process_Component_Or_Element_Update (Temp, Comp, Expr, Typ);\n+            end if;\n+\n+            Next (Comp);\n+         end loop;\n+\n+         Next (Assoc);\n+      end loop;\n+\n+      --  The attribute is replaced by a reference to the anonymous object\n+\n+      Rewrite (N, New_Reference_To (Temp, Loc));\n+      Analyze (N);\n+   end Expand_Update_Attribute;\n+\n    -------------------\n    -- Find_Fat_Info --\n    -------------------"}, {"sha": "3a9f81db0fc589ed674954110653d0097ccb8d3c", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 77, "deletions": 72, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a", "patch": "@@ -1107,14 +1107,14 @@ package body Exp_Util is\n          Temps (J) := T;\n \n          Append_To (Decls,\n-            Make_Object_Declaration (Loc,\n-               Defining_Identifier => T,\n-               Object_Definition => New_Occurrence_Of (Standard_String, Loc),\n-               Expression =>\n-                 Make_Attribute_Reference (Loc,\n-                   Attribute_Name => Name_Image,\n-                   Prefix         => New_Occurrence_Of (Etype (Indx), Loc),\n-                   Expressions    => New_List (New_Copy_Tree (Val)))));\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => T,\n+             Object_Definition   => New_Occurrence_Of (Standard_String, Loc),\n+             Expression          =>\n+               Make_Attribute_Reference (Loc,\n+                 Attribute_Name => Name_Image,\n+                 Prefix         => New_Occurrence_Of (Etype (Indx), Loc),\n+                 Expressions    => New_List (New_Copy_Tree (Val)))));\n \n          Next_Index (Indx);\n          Next (Val);\n@@ -1126,120 +1126,120 @@ package body Exp_Util is\n         Make_Op_Add (Loc,\n           Left_Opnd => Sum,\n           Right_Opnd =>\n-           Make_Attribute_Reference (Loc,\n-             Attribute_Name => Name_Length,\n-             Prefix =>\n-               New_Occurrence_Of (Pref, Loc),\n-             Expressions => New_List (Make_Integer_Literal (Loc, 1))));\n+            Make_Attribute_Reference (Loc,\n+              Attribute_Name => Name_Length,\n+              Prefix         => New_Occurrence_Of (Pref, Loc),\n+              Expressions    => New_List (Make_Integer_Literal (Loc, 1))));\n \n       for J in 1 .. Dims loop\n          Sum :=\n-            Make_Op_Add (Loc,\n-             Left_Opnd => Sum,\n+           Make_Op_Add (Loc,\n+             Left_Opnd  => Sum,\n              Right_Opnd =>\n-              Make_Attribute_Reference (Loc,\n-                Attribute_Name => Name_Length,\n-                Prefix =>\n+               Make_Attribute_Reference (Loc,\n+                 Attribute_Name => Name_Length,\n+                 Prefix         =>\n                   New_Occurrence_Of (Temps (J), Loc),\n-                Expressions => New_List (Make_Integer_Literal (Loc, 1))));\n+                Expressions     => New_List (Make_Integer_Literal (Loc, 1))));\n       end loop;\n \n       Build_Task_Image_Prefix (Loc, Len, Res, Pos, Pref, Sum, Decls, Stats);\n \n       Set_Character_Literal_Name (Char_Code (Character'Pos ('(')));\n \n       Append_To (Stats,\n-         Make_Assignment_Statement (Loc,\n-           Name => Make_Indexed_Component (Loc,\n-              Prefix => New_Occurrence_Of (Res, Loc),\n+        Make_Assignment_Statement (Loc,\n+          Name       =>\n+            Make_Indexed_Component (Loc,\n+              Prefix      => New_Occurrence_Of (Res, Loc),\n               Expressions => New_List (New_Occurrence_Of (Pos, Loc))),\n-           Expression =>\n-             Make_Character_Literal (Loc,\n-               Chars => Name_Find,\n-               Char_Literal_Value =>\n-                 UI_From_Int (Character'Pos ('(')))));\n+          Expression =>\n+            Make_Character_Literal (Loc,\n+              Chars              => Name_Find,\n+              Char_Literal_Value => UI_From_Int (Character'Pos ('(')))));\n \n       Append_To (Stats,\n-         Make_Assignment_Statement (Loc,\n-            Name => New_Occurrence_Of (Pos, Loc),\n-            Expression =>\n-              Make_Op_Add (Loc,\n-                Left_Opnd => New_Occurrence_Of (Pos, Loc),\n-                Right_Opnd => Make_Integer_Literal (Loc, 1))));\n+        Make_Assignment_Statement (Loc,\n+          Name       => New_Occurrence_Of (Pos, Loc),\n+          Expression =>\n+            Make_Op_Add (Loc,\n+              Left_Opnd  => New_Occurrence_Of (Pos, Loc),\n+              Right_Opnd => Make_Integer_Literal (Loc, 1))));\n \n       for J in 1 .. Dims loop\n \n          Append_To (Stats,\n-            Make_Assignment_Statement (Loc,\n-              Name => Make_Slice (Loc,\n-                 Prefix => New_Occurrence_Of (Res, Loc),\n+           Make_Assignment_Statement (Loc,\n+             Name =>\n+               Make_Slice (Loc,\n+                 Prefix          => New_Occurrence_Of (Res, Loc),\n                  Discrete_Range  =>\n                    Make_Range (Loc,\n-                      Low_Bound => New_Occurrence_Of  (Pos, Loc),\n-                      High_Bound => Make_Op_Subtract (Loc,\n-                        Left_Opnd =>\n-                          Make_Op_Add (Loc,\n-                            Left_Opnd => New_Occurrence_Of (Pos, Loc),\n-                            Right_Opnd =>\n-                              Make_Attribute_Reference (Loc,\n-                                Attribute_Name => Name_Length,\n-                                Prefix =>\n-                                  New_Occurrence_Of (Temps (J), Loc),\n-                                Expressions =>\n-                                  New_List (Make_Integer_Literal (Loc, 1)))),\n+                     Low_Bound  => New_Occurrence_Of  (Pos, Loc),\n+                     High_Bound =>\n+                       Make_Op_Subtract (Loc,\n+                         Left_Opnd  =>\n+                           Make_Op_Add (Loc,\n+                             Left_Opnd  => New_Occurrence_Of (Pos, Loc),\n+                             Right_Opnd =>\n+                               Make_Attribute_Reference (Loc,\n+                                 Attribute_Name => Name_Length,\n+                                 Prefix         =>\n+                                   New_Occurrence_Of (Temps (J), Loc),\n+                                 Expressions    =>\n+                                   New_List (Make_Integer_Literal (Loc, 1)))),\n                          Right_Opnd => Make_Integer_Literal (Loc, 1)))),\n \n               Expression => New_Occurrence_Of (Temps (J), Loc)));\n \n          if J < Dims then\n             Append_To (Stats,\n                Make_Assignment_Statement (Loc,\n-                  Name => New_Occurrence_Of (Pos, Loc),\n+                  Name       => New_Occurrence_Of (Pos, Loc),\n                   Expression =>\n                     Make_Op_Add (Loc,\n-                      Left_Opnd => New_Occurrence_Of (Pos, Loc),\n+                      Left_Opnd  => New_Occurrence_Of (Pos, Loc),\n                       Right_Opnd =>\n                         Make_Attribute_Reference (Loc,\n                           Attribute_Name => Name_Length,\n-                            Prefix => New_Occurrence_Of (Temps (J), Loc),\n-                            Expressions =>\n-                              New_List (Make_Integer_Literal (Loc, 1))))));\n+                          Prefix         => New_Occurrence_Of (Temps (J), Loc),\n+                          Expressions    =>\n+                            New_List (Make_Integer_Literal (Loc, 1))))));\n \n             Set_Character_Literal_Name (Char_Code (Character'Pos (',')));\n \n             Append_To (Stats,\n-               Make_Assignment_Statement (Loc,\n-                 Name => Make_Indexed_Component (Loc,\n-                    Prefix => New_Occurrence_Of (Res, Loc),\n-                    Expressions => New_List (New_Occurrence_Of (Pos, Loc))),\n-                 Expression =>\n-                   Make_Character_Literal (Loc,\n-                     Chars => Name_Find,\n-                     Char_Literal_Value =>\n-                       UI_From_Int (Character'Pos (',')))));\n+              Make_Assignment_Statement (Loc,\n+                Name => Make_Indexed_Component (Loc,\n+                   Prefix => New_Occurrence_Of (Res, Loc),\n+                   Expressions => New_List (New_Occurrence_Of (Pos, Loc))),\n+                Expression =>\n+                  Make_Character_Literal (Loc,\n+                    Chars              => Name_Find,\n+                    Char_Literal_Value => UI_From_Int (Character'Pos (',')))));\n \n             Append_To (Stats,\n               Make_Assignment_Statement (Loc,\n-                Name => New_Occurrence_Of (Pos, Loc),\n+                Name         => New_Occurrence_Of (Pos, Loc),\n                   Expression =>\n                     Make_Op_Add (Loc,\n-                      Left_Opnd => New_Occurrence_Of (Pos, Loc),\n+                      Left_Opnd  => New_Occurrence_Of (Pos, Loc),\n                       Right_Opnd => Make_Integer_Literal (Loc, 1))));\n          end if;\n       end loop;\n \n       Set_Character_Literal_Name (Char_Code (Character'Pos (')')));\n \n       Append_To (Stats,\n-         Make_Assignment_Statement (Loc,\n-           Name => Make_Indexed_Component (Loc,\n-              Prefix => New_Occurrence_Of (Res, Loc),\n+        Make_Assignment_Statement (Loc,\n+          Name        =>\n+            Make_Indexed_Component (Loc,\n+              Prefix      => New_Occurrence_Of (Res, Loc),\n               Expressions => New_List (New_Occurrence_Of (Len, Loc))),\n            Expression =>\n              Make_Character_Literal (Loc,\n-               Chars => Name_Find,\n-               Char_Literal_Value =>\n-                 UI_From_Int (Character'Pos (')')))));\n+               Chars              => Name_Find,\n+               Char_Literal_Value => UI_From_Int (Character'Pos (')')))));\n       return Build_Task_Image_Function (Loc, Decls, Stats, Res);\n    end Build_Task_Array_Image;\n \n@@ -6842,15 +6842,20 @@ package body Exp_Util is\n          end if;\n \n       --  For expressions that denote objects, we can use a renaming scheme.\n-      --  This is needed for correctness in the case of a volatile object of a\n-      --  non-volatile type because the Make_Reference call of the \"default\"\n+      --  This is needed for correctness in the case of a volatile object of\n+      --  a non-volatile type because the Make_Reference call of the \"default\"\n       --  approach would generate an illegal access value (an access value\n       --  cannot designate such an object - see Analyze_Reference). We skip\n       --  using this scheme if we have an object of a volatile type and we do\n       --  not have Name_Req set true (see comments above for Side_Effect_Free).\n \n+      --  In Ada 2012 a qualified expression is an object, but for purposes of\n+      --  removing side effects it still need to be transformed into a separate\n+      --  declaration, particularly if the expression is an aggregate.\n+\n       elsif Is_Object_Reference (Exp)\n         and then Nkind (Exp) /= N_Function_Call\n+        and then Nkind (Exp) /= N_Qualified_Expression\n         and then (Name_Req or else not Treat_As_Volatile (Exp_Type))\n       then\n          Def_Id := Make_Temporary (Loc, 'R', Exp);"}, {"sha": "eae388ba7aedcb7fed6ce8c95e7ac53a21a83f48", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a", "patch": "@@ -935,7 +935,7 @@ package body Ch3 is\n \n    --  SUBTYPE_DECLARATION ::=\n    --    subtype DEFINING_IDENTIFIER is [NULL_EXCLUSION] SUBTYPE_INDICATION\n-   --    {ASPECT_SPECIFICATIONS];\n+   --      [ASPECT_SPECIFICATIONS];\n \n    --  The caller has checked that the initial token is SUBTYPE\n "}, {"sha": "8107c89096c9419cf319631ea5bedb437eca2f8a", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a", "patch": "@@ -510,26 +510,36 @@ package body Ch4 is\n                 Is_Parameterless_Attribute (Get_Attribute_Id (Attr_Name))\n             then\n                Set_Expressions (Name_Node, New_List);\n-               Scan; -- past left paren\n \n-               loop\n-                  declare\n-                     Expr : constant Node_Id := P_Expression_If_OK;\n+               --  Attribute Update contains an array or record association\n+               --  list which provides new values for various components or\n+               --  elements. The list is parsed as an aggregate.\n \n-                  begin\n-                     if Token = Tok_Arrow then\n-                        Error_Msg_SC\n-                          (\"named parameters not permitted for attributes\");\n-                        Scan; -- past junk arrow\n+               if Attr_Name = Name_Update then\n+                  Append (P_Aggregate, Expressions (Name_Node));\n \n-                     else\n-                        Append (Expr, Expressions (Name_Node));\n-                        exit when not Comma_Present;\n-                     end if;\n-                  end;\n-               end loop;\n+               else\n+                  Scan; -- past left paren\n+\n+                  loop\n+                     declare\n+                        Expr : constant Node_Id := P_Expression_If_OK;\n+\n+                     begin\n+                        if Token = Tok_Arrow then\n+                           Error_Msg_SC\n+                             (\"named parameters not permitted for attributes\");\n+                           Scan; -- past junk arrow\n+\n+                        else\n+                           Append (Expr, Expressions (Name_Node));\n+                           exit when not Comma_Present;\n+                        end if;\n+                     end;\n+                  end loop;\n \n-               T_Right_Paren;\n+                  T_Right_Paren;\n+               end if;\n             end if;\n \n             goto Scan_Name_Extension;"}, {"sha": "aa61f85e723b1c84ee3c7519842c5a6692a69525", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a", "patch": "@@ -5516,6 +5516,164 @@ package body Sem_Attr is\n \n          Analyze_Access_Attribute;\n \n+      ------------\n+      -- Update --\n+      ------------\n+\n+      when Attribute_Update => Update : declare\n+         Comps : Elist_Id := No_Elist;\n+\n+         procedure Check_Component_Reference\n+           (Comp : Entity_Id;\n+            Typ  : Entity_Id);\n+         --  Comp is a record component (possibly a discriminant) and Typ is a\n+         --  record type. Determine whether Comp is a legal component of Typ.\n+         --  Emit an error if Comp mentions a discriminant or is not a unique\n+         --  component reference in the update aggregate.\n+\n+         -------------------------------\n+         -- Check_Component_Reference --\n+         -------------------------------\n+\n+         procedure Check_Component_Reference\n+           (Comp : Entity_Id;\n+            Typ  : Entity_Id)\n+         is\n+            Comp_Name : constant Name_Id := Chars (Comp);\n+\n+            function Is_Duplicate_Component return Boolean;\n+            --  Determine whether component Comp already appears in list Comps\n+\n+            ----------------------------\n+            -- Is_Duplicate_Component --\n+            ----------------------------\n+\n+            function Is_Duplicate_Component return Boolean is\n+               Comp_Elmt : Elmt_Id;\n+\n+            begin\n+               if Present (Comps) then\n+                  Comp_Elmt := First_Elmt (Comps);\n+                  while Present (Comp_Elmt) loop\n+                     if Chars (Node (Comp_Elmt)) = Comp_Name then\n+                        return True;\n+                     end if;\n+\n+                     Next_Elmt (Comp_Elmt);\n+                  end loop;\n+               end if;\n+\n+               return False;\n+            end Is_Duplicate_Component;\n+\n+            --  Local variables\n+\n+            Comp_Or_Discr : Entity_Id;\n+\n+         --  Start of processing for Check_Component_Reference\n+\n+         begin\n+            --  Find the discriminant or component whose name corresponds to\n+            --  Comp. A simple character comparison is sufficient because all\n+            --  visible names within a record type are unique.\n+\n+            Comp_Or_Discr := First_Entity (Typ);\n+            while Present (Comp_Or_Discr) loop\n+               if Chars (Comp_Or_Discr) = Comp_Name then\n+                  exit;\n+               end if;\n+\n+               Comp_Or_Discr := Next_Entity (Comp_Or_Discr);\n+            end loop;\n+\n+            --  Diagnose possible erroneous references\n+\n+            if Present (Comp_Or_Discr) then\n+               if Ekind (Comp_Or_Discr) = E_Discriminant then\n+                  Error_Attr\n+                    (\"attribute % may not modify record discriminants\", Comp);\n+\n+               else pragma Assert (Ekind (Comp_Or_Discr) = E_Component);\n+                  if Is_Duplicate_Component then\n+                     Error_Msg_NE (\"component & already updated\", Comp, Comp);\n+\n+                  --  Mark this component as processed\n+\n+                  else\n+                     if No (Comps) then\n+                        Comps := New_Elmt_List;\n+                     end if;\n+\n+                     Append_Elmt (Comp, Comps);\n+                  end if;\n+               end if;\n+\n+            --  The update aggregate mentions an entity that does not belong to\n+            --  the record type.\n+\n+            else\n+               Error_Msg_NE\n+                 (\"& is not a component of aggregate subtype\", Comp, Comp);\n+            end if;\n+         end Check_Component_Reference;\n+\n+         --  Local variables\n+\n+         Assoc : Node_Id;\n+         Comp  : Node_Id;\n+\n+      --  Start of processing for Update\n+\n+      begin\n+         S14_Attribute;\n+         Check_E1;\n+\n+         if not Is_Object_Reference (P) then\n+            Error_Attr_P (\"prefix of attribute % must denote an object\");\n+\n+         elsif not Is_Array_Type (P_Type)\n+           and then not Is_Record_Type (P_Type)\n+         then\n+            Error_Attr_P (\"prefix of attribute % must be a record or array\");\n+\n+         elsif Is_Immutably_Limited_Type (P_Type) then\n+            Error_Attr (\"prefix of attribute % cannot be limited\", N);\n+\n+         elsif Nkind (E1) /= N_Aggregate then\n+            Error_Attr (\"attribute % requires component association list\", N);\n+         end if;\n+\n+         --  Inspect the update aggregate, looking at all the associations and\n+         --  choices. Perform the following checks:\n+\n+         --    1) Legality of \"others\" in all cases\n+         --    2) Component legality for records\n+\n+         --  The remaining checks are performed on the expanded attribute\n+\n+         Assoc := First (Component_Associations (E1));\n+         while Present (Assoc) loop\n+            Comp := First (Choices (Assoc));\n+            while Present (Comp) loop\n+               if Nkind (Comp) = N_Others_Choice then\n+                  Error_Attr\n+                    (\"others choice not allowed in attribute %\", Comp);\n+\n+               elsif Is_Record_Type (P_Type) then\n+                  Check_Component_Reference (Comp, P_Type);\n+               end if;\n+\n+               Next (Comp);\n+            end loop;\n+\n+            Next (Assoc);\n+         end loop;\n+\n+         --  The type of attribute Update is that of the prefix\n+\n+         Set_Etype (N, P_Type);\n+      end Update;\n+\n       ---------\n       -- Val --\n       ---------\n@@ -8210,6 +8368,15 @@ package body Sem_Attr is\n          Static := True;\n       end Unconstrained_Array;\n \n+      --  Attribute Update is never static\n+\n+      ------------\n+      -- Update --\n+      ------------\n+\n+      when Attribute_Update =>\n+         null;\n+\n       ---------------\n       -- VADS_Size --\n       ---------------"}, {"sha": "ec7f3b95d979cdcadde57753acbef2f815fa2efe", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a", "patch": "@@ -7761,11 +7761,11 @@ package body Sem_Prag is\n          -- Contract_Cases --\n          --------------------\n \n-         --  pragma Contract_Cases (POST_CASE_LIST);\n+         --  pragma Contract_Cases (CONTRACT_CASE_LIST);\n \n-         --  POST_CASE_LIST ::= POST_CASE {, POST_CASE}\n+         --  CONTRACT_CASE_LIST ::= CONTRACT_CASE {, CONTRACT_CASE}\n \n-         --  POST_CASE ::= CASE_GUARD => CONSEQUENCE\n+         --  CONTRACT_CASE ::= CASE_GUARD => CONSEQUENCE\n \n          --  CASE_GUARD ::= boolean_EXPRESSION | others\n \n@@ -7786,11 +7786,22 @@ package body Sem_Prag is\n                CTC  : Node_Id;\n \n             begin\n+               Check_Duplicate_Pragma (Subp);\n                CTC := Spec_CTC_List (Contract (Subp));\n                while Present (CTC) loop\n                   if Chars (Pragma_Identifier (CTC)) = Pname then\n-                     Error_Pragma (\"pragma % already in use\");\n-                     return;\n+                     Error_Msg_Name_1 := Pname;\n+                     Error_Msg_Sloc := Sloc (CTC);\n+\n+                     if From_Aspect_Specification (CTC) then\n+                        Error_Msg_NE\n+                          (\"aspect% for & previously given#\", N, Subp);\n+                     else\n+                        Error_Msg_NE\n+                          (\"pragma% for & duplicates pragma#\", N, Subp);\n+                     end if;\n+\n+                     raise Pragma_Exit;\n                   end if;\n \n                   CTC := Next_Pragma (CTC);\n@@ -7804,12 +7815,12 @@ package body Sem_Prag is\n \n             --  Local variables\n \n-            Case_Guard  : Node_Id;\n-            Decl        : Node_Id;\n-            Extra       : Node_Id;\n-            Others_Seen : Boolean := False;\n-            Post_Case   : Node_Id;\n-            Subp_Decl   : Node_Id;\n+            Case_Guard    : Node_Id;\n+            Decl          : Node_Id;\n+            Extra         : Node_Id;\n+            Others_Seen   : Boolean := False;\n+            Contract_Case : Node_Id;\n+            Subp_Decl     : Node_Id;\n \n          --  Start of processing for Contract_Cases\n \n@@ -7866,30 +7877,32 @@ package body Sem_Prag is\n                end if;\n             end loop;\n \n-            --  All post cases must appear as an aggregate\n+            --  All contract cases must appear as an aggregate\n \n             if Nkind (Expression (Arg1)) /= N_Aggregate then\n                Error_Pragma (\"wrong syntax for pragma %\");\n                return;\n             end if;\n \n-            --  Verify the legality of individual post cases\n+            --  Verify the legality of individual contract cases\n \n-            Post_Case := First (Component_Associations (Expression (Arg1)));\n-            while Present (Post_Case) loop\n-               if Nkind (Post_Case) /= N_Component_Association then\n-                  Error_Pragma_Arg (\"wrong syntax in post case\", Post_Case);\n+            Contract_Case :=\n+              First (Component_Associations (Expression (Arg1)));\n+            while Present (Contract_Case) loop\n+               if Nkind (Contract_Case) /= N_Component_Association then\n+                  Error_Pragma_Arg\n+                    (\"wrong syntax in contract case\", Contract_Case);\n                   return;\n                end if;\n \n-               Case_Guard := First (Choices (Post_Case));\n+               Case_Guard := First (Choices (Contract_Case));\n \n-               --  Each post case must have exactly on case guard\n+               --  Each contract case must have exactly on case guard\n \n                Extra := Next (Case_Guard);\n                if Present (Extra) then\n                   Error_Pragma_Arg\n-                    (\"post case may have only one case guard\", Extra);\n+                    (\"contract case may have only one case guard\", Extra);\n                   return;\n                end if;\n \n@@ -7911,7 +7924,7 @@ package body Sem_Prag is\n                   return;\n                end if;\n \n-               Next (Post_Case);\n+               Next (Contract_Case);\n             end loop;\n \n             Chain_Contract_Cases (Subp_Decl);\n@@ -11517,10 +11530,12 @@ package body Sem_Prag is\n \n             Preanalyze_And_Resolve (Expression (Arg1), Any_Boolean);\n \n-            --  Transform pagma Loop_Invariant into an equivalent pragma Check.\n+            --  Transform pragma Loop_Invariant into equivalent pragma Check\n             --  Generate:\n             --    pragma Check (Loop_Invaraint, Arg1);\n \n+            --  Seems completely wrong to hijack pragma Check this way ???\n+\n             Rewrite (N,\n               Make_Pragma (Loc,\n                 Chars                        => Name_Check,"}, {"sha": "cc269a1446c7d378a2e48f38fc47b1f5f92727fe", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a", "patch": "@@ -901,6 +901,7 @@ package Snames is\n    Name_Unconstrained_Array            : constant Name_Id := N + $;\n    Name_Universal_Literal_String       : constant Name_Id := N + $; -- GNAT\n    Name_Unrestricted_Access            : constant Name_Id := N + $; -- GNAT\n+   Name_Update                         : constant Name_Id := N + $; -- GNAT\n    Name_VADS_Size                      : constant Name_Id := N + $; -- GNAT\n    Name_Val                            : constant Name_Id := N + $;\n    Name_Valid                          : constant Name_Id := N + $;\n@@ -1512,6 +1513,7 @@ package Snames is\n       Attribute_Unconstrained_Array,\n       Attribute_Universal_Literal_String,\n       Attribute_Unrestricted_Access,\n+      Attribute_Update,\n       Attribute_VADS_Size,\n       Attribute_Val,\n       Attribute_Valid,"}, {"sha": "54fe8ffe14d71430e666d8b4f2e8f164ec66322c", "filename": "gcc/ada/urealp.ads", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Furealp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a/gcc%2Fada%2Furealp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Furealp.ads?ref=18a2ad5d461c4ff929c10ce9cfdbc98d1f35d42a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -53,12 +53,13 @@ package Urealp is\n    --    a real base (Nat, either zero, or in the range 2 .. 16)\n    --    a sign flag (Boolean), set if negative\n \n-   --  If the base is zero, then the absolute value of the Ureal is simply\n-   --  numerator/denominator. If the base is non-zero, then the absolute\n-   --  value is num / (rbase ** den).\n+   --  Negative numbers are represented by the sign flag being True.\n \n-   --  Negative numbers are represented by the sign of the numerator being\n-   --  negative. The denominator is always positive.\n+   --  If the base is zero, then the absolute value of the Ureal is simply\n+   --  numerator/denominator, where denominator is positive. If the base is\n+   --  non-zero, then the absolute value is numerator / (base ** denominator).\n+   --  In that case, since base is positive, (base ** denominator) is also\n+   --  positive, even when denominator is negative or null.\n \n    --  A normalized Ureal value has base = 0, and numerator/denominator\n    --  reduced to lowest terms, with zero itself being represented as 0/1."}]}