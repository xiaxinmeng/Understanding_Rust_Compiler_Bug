{"sha": "076b460557487a225815e3870405e67a3f149a0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc2YjQ2MDU1NzQ4N2EyMjU4MTVlMzg3MDQwNWU2N2EzZjE0OWEwYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-03-18T08:46:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-03-18T08:46:44Z"}, "message": "re PR c/56113 (out of memory when compiling a function with many goto labels (50k > ))\n\n2013-03-18  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/56113\n\t* domwalk.c (bb_postorder): New global static.\n\t(cmp_bb_postorder): New function.\n\t(walk_dominator_tree): Replace scheme imposing an order for\n\tvisiting dominator sons by one sorting them at the time they\n\tare pushed on the stack.\n\nFrom-SVN: r196769", "tree": {"sha": "cb0a79a83ddf2a01474c77e8594517a946eac6f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb0a79a83ddf2a01474c77e8594517a946eac6f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/076b460557487a225815e3870405e67a3f149a0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/076b460557487a225815e3870405e67a3f149a0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/076b460557487a225815e3870405e67a3f149a0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/076b460557487a225815e3870405e67a3f149a0c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bdb01696ea15de8003a178f12b4cbc87655acd2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb01696ea15de8003a178f12b4cbc87655acd2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdb01696ea15de8003a178f12b4cbc87655acd2d"}], "stats": {"total": 91, "additions": 52, "deletions": 39}, "files": [{"sha": "631ee729e629f7de74247191e6f708f9054f184d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076b460557487a225815e3870405e67a3f149a0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076b460557487a225815e3870405e67a3f149a0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=076b460557487a225815e3870405e67a3f149a0c", "patch": "@@ -1,3 +1,12 @@\n+2013-03-18  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/56113\n+\t* domwalk.c (bb_postorder): New global static.\n+\t(cmp_bb_postorder): New function.\n+\t(walk_dominator_tree): Replace scheme imposing an order for\n+\tvisiting dominator sons by one sorting them at the time they\n+\tare pushed on the stack.\n+\n 2013-03-18  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/39326"}, {"sha": "8c1ddc69490764651fe7f65871b7d7d150706b10", "filename": "gcc/domwalk.c", "status": "modified", "additions": 43, "deletions": 39, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076b460557487a225815e3870405e67a3f149a0c/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076b460557487a225815e3870405e67a3f149a0c/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=076b460557487a225815e3870405e67a3f149a0c", "patch": "@@ -128,6 +128,21 @@ along with GCC; see the file COPYING3.  If not see\n     which is currently an abstraction over walking tree statements.  Thus\n     the dominator walker is currently only useful for trees.  */\n \n+static int *bb_postorder;\n+\n+static int\n+cmp_bb_postorder (const void *a, const void *b)\n+{\n+  basic_block bb1 = *(basic_block *)const_cast<void *>(a);\n+  basic_block bb2 = *(basic_block *)const_cast<void *>(b);\n+  if (bb1->index == bb2->index)\n+    return 0;\n+  /* Place higher completion number first (pop off lower number first).  */\n+  if (bb_postorder[bb1->index] > bb_postorder[bb2->index])\n+    return -1;\n+  return 1;\n+}\n+\n /* Recursively walk the dominator tree.\n \n    WALK_DATA contains a set of callbacks to perform pass-specific\n@@ -143,9 +158,17 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n   basic_block dest;\n   basic_block *worklist = XNEWVEC (basic_block, n_basic_blocks * 2);\n   int sp = 0;\n-  sbitmap visited = sbitmap_alloc (last_basic_block + 1);\n-  bitmap_clear (visited);\n-  bitmap_set_bit (visited, ENTRY_BLOCK_PTR->index);\n+  int *postorder, postorder_num;\n+\n+  if (walk_data->dom_direction == CDI_DOMINATORS)\n+    {\n+      postorder = XNEWVEC (int, n_basic_blocks);\n+      postorder_num = inverted_post_order_compute (postorder);\n+      bb_postorder = XNEWVEC (int, last_basic_block);\n+      for (int i = 0; i < postorder_num; ++i)\n+\tbb_postorder[postorder[i]] = i;\n+      free (postorder);\n+    }\n \n   while (true)\n     {\n@@ -186,16 +209,25 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n \t  if (walk_data->before_dom_children)\n \t    (*walk_data->before_dom_children) (walk_data, bb);\n \n-\t  bitmap_set_bit (visited, bb->index);\n-\n \t  /* Mark the current BB to be popped out of the recursion stack\n \t     once children are processed.  */\n \t  worklist[sp++] = bb;\n \t  worklist[sp++] = NULL;\n \n+\t  int saved_sp = sp;\n \t  for (dest = first_dom_son (walk_data->dom_direction, bb);\n \t       dest; dest = next_dom_son (walk_data->dom_direction, dest))\n \t    worklist[sp++] = dest;\n+\t  if (walk_data->dom_direction == CDI_DOMINATORS)\n+\t    switch (sp - saved_sp)\n+\t      {\n+\t      case 0:\n+\t      case 1:\n+\t\tbreak;\n+\t      default:\n+\t\tqsort (&worklist[saved_sp], sp - saved_sp,\n+\t\t       sizeof (basic_block), cmp_bb_postorder);\n+\t      }\n \t}\n       /* NULL is used to mark pop operations in the recursion stack.  */\n       while (sp > 0 && !worklist[sp - 1])\n@@ -217,44 +249,16 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n \t    }\n \t}\n       if (sp)\n-\t{\n-\t  int spp;\n-\t  spp = sp - 1;\n-\t  if (walk_data->dom_direction == CDI_DOMINATORS)\n-\t    /* Find the dominator son that has all its predecessors\n-\t       visited and continue with that.  */\n-\t    while (1)\n-\t      {\n-\t\tedge_iterator ei;\n-\t\tedge e;\n-\t\tbool found = true;\n-\t\tbb = worklist[spp];\n-\t\tFOR_EACH_EDGE (e, ei, bb->preds)\n-\t\t  {\n-\t\t    if (!dominated_by_p (CDI_DOMINATORS, e->src, e->dest)\n-\t\t\t&& !bitmap_bit_p (visited, e->src->index))\n-\t\t      {\n-\t\t\tfound = false;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  }\n-\t\tif (found)\n-\t\t  break;\n-\t\t/* If we didn't find a dom child with all visited\n-\t\t   predecessors just use the candidate we were checking.\n-\t\t   This happens for candidates in irreducible loops.  */\n-\t\tif (!worklist[spp - 1])\n-\t\t  break;\n-\t\t--spp;\n-\t      }\n-\t  bb = worklist[spp];\n-\t  worklist[spp] = worklist[--sp];\n-\t}\n+\tbb = worklist[--sp];\n       else\n \tbreak;\n     }\n+  if (walk_data->dom_direction == CDI_DOMINATORS)\n+    {\n+      free (bb_postorder);\n+      bb_postorder = NULL;\n+    }\n   free (worklist);\n-  sbitmap_free (visited);\n }\n \n void"}]}