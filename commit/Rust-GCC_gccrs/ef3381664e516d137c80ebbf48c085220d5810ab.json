{"sha": "ef3381664e516d137c80ebbf48c085220d5810ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYzMzgxNjY0ZTUxNmQxMzdjODBlYmJmNDhjMDg1MjIwZDU4MTBhYg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2005-09-12T17:42:53Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-09-12T17:42:53Z"}, "message": "* Imported zlib 1.2.3; merged local changes.\n\nFrom-SVN: r104184", "tree": {"sha": "afad186af73219e6bb1a8cb8eac61485fb4eec97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afad186af73219e6bb1a8cb8eac61485fb4eec97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef3381664e516d137c80ebbf48c085220d5810ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3381664e516d137c80ebbf48c085220d5810ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef3381664e516d137c80ebbf48c085220d5810ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3381664e516d137c80ebbf48c085220d5810ab/comments", "author": null, "committer": null, "parents": [{"sha": "3ec980b182de950223663d4a3ef65177fa887501", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ec980b182de950223663d4a3ef65177fa887501", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ec980b182de950223663d4a3ef65177fa887501"}], "stats": {"total": 3043, "additions": 1668, "deletions": 1375}, "files": [{"sha": "17bfeab99cfa97edddd91d11525064b9d3b80b90", "filename": "zlib/ChangeLog", "status": "modified", "additions": 134, "deletions": 1, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FChangeLog?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,6 +1,139 @@\n \n                 ChangeLog file for zlib\n \n+Changes in 1.2.3 (18 July 2005)\n+- Apply security vulnerability fixes to contrib/infback9 as well\n+- Clean up some text files (carriage returns, trailing space)\n+- Update testzlib, vstudio, masmx64, and masmx86 in contrib [Vollant]\n+\n+Changes in 1.2.2.4 (11 July 2005)\n+- Add inflatePrime() function for starting inflation at bit boundary\n+- Avoid some Visual C warnings in deflate.c\n+- Avoid more silly Visual C warnings in inflate.c and inftrees.c for 64-bit\n+  compile\n+- Fix some spelling errors in comments [Betts]\n+- Correct inflateInit2() error return documentation in zlib.h\n+- Added zran.c example of compressed data random access to examples\n+  directory, shows use of inflatePrime()\n+- Fix cast for assignments to strm->state in inflate.c and infback.c\n+- Fix zlibCompileFlags() in zutil.c to use 1L for long shifts [Oberhumer]\n+- Move declarations of gf2 functions to right place in crc32.c [Oberhumer]\n+- Add cast in trees.c t avoid a warning [Oberhumer]\n+- Avoid some warnings in fitblk.c, gun.c, gzjoin.c in examples [Oberhumer]\n+- Update make_vms.com [Zinser]\n+- Initialize state->write in inflateReset() since copied in inflate_fast()\n+- Be more strict on incomplete code sets in inflate_table() and increase\n+  ENOUGH and MAXD -- this repairs a possible security vulnerability for\n+  invalid inflate input.  Thanks to Tavis Ormandy and Markus Oberhumer for\n+  discovering the vulnerability and providing test cases.\n+- Add ia64 support to configure for HP-UX [Smith]\n+- Add error return to gzread() for format or i/o error [Levin]\n+- Use malloc.h for OS/2 [Necasek]\n+\n+Changes in 1.2.2.3 (27 May 2005)\n+- Replace 1U constants in inflate.c and inftrees.c for 64-bit compile\n+- Typecast fread() return values in gzio.c [Vollant]\n+- Remove trailing space in minigzip.c outmode (VC++ can't deal with it)\n+- Fix crc check bug in gzread() after gzungetc() [Heiner]\n+- Add the deflateTune() function to adjust internal compression parameters\n+- Add a fast gzip decompressor, gun.c, to examples (use of inflateBack)\n+- Remove an incorrect assertion in examples/zpipe.c\n+- Add C++ wrapper in infback9.h [Donais]\n+- Fix bug in inflateCopy() when decoding fixed codes\n+- Note in zlib.h how much deflateSetDictionary() actually uses\n+- Remove USE_DICT_HEAD in deflate.c (would mess up inflate if used)\n+- Add _WIN32_WCE to define WIN32 in zconf.in.h [Spencer]\n+- Don't include stderr.h or errno.h for _WIN32_WCE in zutil.h [Spencer]\n+- Add gzdirect() function to indicate transparent reads\n+- Update contrib/minizip [Vollant]\n+- Fix compilation of deflate.c when both ASMV and FASTEST [Oberhumer]\n+- Add casts in crc32.c to avoid warnings [Oberhumer]\n+- Add contrib/masmx64 [Vollant]\n+- Update contrib/asm586, asm686, masmx86, testzlib, vstudio [Vollant]\n+\n+Changes in 1.2.2.2 (30 December 2004)\n+- Replace structure assignments in deflate.c and inflate.c with zmemcpy to\n+  avoid implicit memcpy calls (portability for no-library compilation)\n+- Increase sprintf() buffer size in gzdopen() to allow for large numbers\n+- Add INFLATE_STRICT to check distances against zlib header\n+- Improve WinCE errno handling and comments [Chang]\n+- Remove comment about no gzip header processing in FAQ\n+- Add Z_FIXED strategy option to deflateInit2() to force fixed trees\n+- Add updated make_vms.com [Coghlan], update README\n+- Create a new \"examples\" directory, move gzappend.c there, add zpipe.c,\n+  fitblk.c, gzlog.[ch], gzjoin.c, and zlib_how.html.\n+- Add FAQ entry and comments in deflate.c on uninitialized memory access\n+- Add Solaris 9 make options in configure [Gilbert]\n+- Allow strerror() usage in gzio.c for STDC\n+- Fix DecompressBuf in contrib/delphi/ZLib.pas [ManChesTer]\n+- Update contrib/masmx86/inffas32.asm and gvmat32.asm [Vollant]\n+- Use z_off_t for adler32_combine() and crc32_combine() lengths\n+- Make adler32() much faster for small len\n+- Use OS_CODE in deflate() default gzip header\n+\n+Changes in 1.2.2.1 (31 October 2004)\n+- Allow inflateSetDictionary() call for raw inflate\n+- Fix inflate header crc check bug for file names and comments\n+- Add deflateSetHeader() and gz_header structure for custom gzip headers\n+- Add inflateGetheader() to retrieve gzip headers\n+- Add crc32_combine() and adler32_combine() functions\n+- Add alloc_func, free_func, in_func, out_func to Z_PREFIX list\n+- Use zstreamp consistently in zlib.h (inflate_back functions)\n+- Remove GUNZIP condition from definition of inflate_mode in inflate.h\n+  and in contrib/inflate86/inffast.S [Truta, Anderson]\n+- Add support for AMD64 in contrib/inflate86/inffas86.c [Anderson]\n+- Update projects/README.projects and projects/visualc6 [Truta]\n+- Update win32/DLL_FAQ.txt [Truta]\n+- Avoid warning under NO_GZCOMPRESS in gzio.c; fix typo [Truta]\n+- Deprecate Z_ASCII; use Z_TEXT instead [Truta]\n+- Use a new algorithm for setting strm->data_type in trees.c [Truta]\n+- Do not define an exit() prototype in zutil.c unless DEBUG defined\n+- Remove prototype of exit() from zutil.c, example.c, minigzip.c [Truta]\n+- Add comment in zlib.h for Z_NO_FLUSH parameter to deflate()\n+- Fix Darwin build version identification [Peterson]\n+\n+Changes in 1.2.2 (3 October 2004)\n+- Update zlib.h comments on gzip in-memory processing\n+- Set adler to 1 in inflateReset() to support Java test suite [Walles]\n+- Add contrib/dotzlib [Ravn]\n+- Update win32/DLL_FAQ.txt [Truta]\n+- Update contrib/minizip [Vollant]\n+- Move contrib/visual-basic.txt to old/ [Truta]\n+- Fix assembler builds in projects/visualc6/ [Truta]\n+\n+Changes in 1.2.1.2 (9 September 2004)\n+- Update INDEX file\n+- Fix trees.c to update strm->data_type (no one ever noticed!)\n+- Fix bug in error case in inflate.c, infback.c, and infback9.c [Brown]\n+- Add \"volatile\" to crc table flag declaration (for DYNAMIC_CRC_TABLE)\n+- Add limited multitasking protection to DYNAMIC_CRC_TABLE\n+- Add NO_vsnprintf for VMS in zutil.h [Mozilla]\n+- Don't declare strerror() under VMS [Mozilla]\n+- Add comment to DYNAMIC_CRC_TABLE to use get_crc_table() to initialize\n+- Update contrib/ada [Anisimkov]\n+- Update contrib/minizip [Vollant]\n+- Fix configure to not hardcode directories for Darwin [Peterson]\n+- Fix gzio.c to not return error on empty files [Brown]\n+- Fix indentation; update version in contrib/delphi/ZLib.pas and\n+  contrib/pascal/zlibpas.pas [Truta]\n+- Update mkasm.bat in contrib/masmx86 [Truta]\n+- Update contrib/untgz [Truta]\n+- Add projects/README.projects [Truta]\n+- Add project for MS Visual C++ 6.0 in projects/visualc6 [Cadieux, Truta]\n+- Update win32/DLL_FAQ.txt [Truta]\n+- Update list of Z_PREFIX symbols in zconf.h [Randers-Pehrson, Truta]\n+- Remove an unnecessary assignment to curr in inftrees.c [Truta]\n+- Add OS/2 to exe builds in configure [Poltorak]\n+- Remove err dummy parameter in zlib.h [Kientzle]\n+\n+Changes in 1.2.1.1 (9 January 2004)\n+- Update email address in README\n+- Several FAQ updates\n+- Fix a big fat bug in inftrees.c that prevented decoding valid\n+  dynamic blocks with only literals and no distance codes --\n+  Thanks to \"Hot Emu\" for the bug report and sample file\n+- Add a note to puff.c on no distance codes case.\n+\n Changes in 1.2.1 (17 November 2003)\n - Remove a tab in contrib/gzappend/gzappend.c\n - Update some interfaces in contrib for new zlib functions\n@@ -407,7 +540,7 @@ Changes in 1.0.7 (20 Jan 1998)\n Changes in 1.0.6 (19 Jan 1998)\n - add functions gzprintf, gzputc, gzgetc, gztell, gzeof, gzseek, gzrewind and\n   gzsetparams (thanks to Roland Giersig and Kevin Ruland for some of this code)\n-- Fix a deflate bug occuring only with compression level 0 (thanks to\n+- Fix a deflate bug occurring only with compression level 0 (thanks to\n   Andy Buckler for finding this one).\n - In minigzip, pass transparently also the first byte for .Z files.\n - return Z_BUF_ERROR instead of Z_OK if output buffer full in uncompress()"}, {"sha": "d56c4d5204d36ef4c1441150f4df87e15a145000", "filename": "zlib/ChangeLog.gcj", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2FChangeLog.gcj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2FChangeLog.gcj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FChangeLog.gcj?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,3 +1,7 @@\n+2005-06-14  Tom Tromey  <tromey@redhat.com>\n+\n+\t* Imported zlib 1.2.3; merged local changes.\n+\n 2005-06-14  Tom Tromey  <tromey@redhat.com>\n \n \tPR libgcj/19877:"}, {"sha": "441d910daa1818203b7ed7dd0be1ed269ba5e6d4", "filename": "zlib/FAQ", "status": "modified", "additions": 64, "deletions": 40, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2FFAQ", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2FFAQ", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FFAQ?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -21,18 +21,18 @@ The lastest zlib FAQ is at http://www.gzip.org/zlib/zlib_faq.html\n  3. Where can I get a Visual Basic interface to zlib?\n \n     See\n-        * http://www.winimage.com/zLibDll/\n         * http://www.dogma.net/markn/articles/zlibtool/zlibtool.htm\n         * contrib/visual-basic.txt in the zlib distribution\n+        * win32/DLL_FAQ.txt in the zlib distribution\n \n- 4. compress() returns Z_BUF_ERROR\n+ 4. compress() returns Z_BUF_ERROR.\n \n     Make sure that before the call of compress, the length of the compressed\n     buffer is equal to the total size of the compressed buffer and not\n     zero. For Visual Basic, check that this parameter is passed by reference\n     (\"as any\"), not by value (\"as long\").\n \n- 5. deflate() or inflate() returns Z_BUF_ERROR\n+ 5. deflate() or inflate() returns Z_BUF_ERROR.\n \n     Before making the call, make sure that avail_in and avail_out are not\n     zero. When setting the parameter flush equal to Z_FINISH, also make sure\n@@ -47,8 +47,8 @@ The lastest zlib FAQ is at http://www.gzip.org/zlib/zlib_faq.html\n \n     It's in zlib.h for the moment, and Francis S. Lin has converted it to a\n     web page zlib.html. Volunteers to transform this to Unix-style man pages,\n-    please contact Jean-loup Gailly (jloup@gzip.org). Examples of zlib usage\n-    are in the files example.c and minigzip.c.\n+    please contact us (zlib@gzip.org). Examples of zlib usage are in the files\n+    example.c and minigzip.c.\n \n  7. Why don't you use GNU autoconf or libtool or ...?\n \n@@ -77,7 +77,8 @@ The lastest zlib FAQ is at http://www.gzip.org/zlib/zlib_faq.html\n \n 11. Can zlib handle .zip archives?\n \n-    See the directory contrib/minizip in the zlib distribution.\n+    Not by itself, no.  See the directory contrib/minizip in the zlib\n+    distribution.\n \n 12. Can zlib handle .Z files?\n \n@@ -92,48 +93,62 @@ The lastest zlib FAQ is at http://www.gzip.org/zlib/zlib_faq.html\n \n 14. How do I install a shared zlib library on Unix?\n \n+    After the above, then:\n+\n     make install\n \n     However, many flavors of Unix come with a shared zlib already installed.\n     Before going to the trouble of compiling a shared version of zlib and\n     trying to install it, you may want to check if it's already there! If you\n     can #include <zlib.h>, it's there. The -lz option will probably link to it.\n \n-15. I have a question about OttoPDF\n+15. I have a question about OttoPDF.\n \n     We are not the authors of OttoPDF. The real author is on the OttoPDF web\n-    site Joel Hainley jhainley@myndkryme.com.\n+    site: Joel Hainley, jhainley@myndkryme.com.\n+\n+16. Can zlib decode Flate data in an Adobe PDF file?\n+\n+    Yes. See http://www.fastio.com/ (ClibPDF), or http://www.pdflib.com/ .\n+    To modify PDF forms, see http://sourceforge.net/projects/acroformtool/ .\n+\n+17. Why am I getting this \"register_frame_info not found\" error on Solaris?\n+\n+    After installing zlib 1.1.4 on Solaris 2.6, running applications using zlib\n+    generates an error such as:\n \n-16. Why does gzip give an error on a file I make with compress/deflate?\n+        ld.so.1: rpm: fatal: relocation error: file /usr/local/lib/libz.so:\n+        symbol __register_frame_info: referenced symbol not found\n+\n+    The symbol __register_frame_info is not part of zlib, it is generated by\n+    the C compiler (cc or gcc). You must recompile applications using zlib\n+    which have this problem. This problem is specific to Solaris. See\n+    http://www.sunfreeware.com for Solaris versions of zlib and applications\n+    using zlib.\n+\n+18. Why does gzip give an error on a file I make with compress/deflate?\n \n     The compress and deflate functions produce data in the zlib format, which\n     is different and incompatible with the gzip format. The gz* functions in\n     zlib on the other hand use the gzip format. Both the zlib and gzip\n     formats use the same compressed data format internally, but have different\n     headers and trailers around the compressed data.\n \n-17. Ok, so why are there two different formats?\n+19. Ok, so why are there two different formats?\n \n     The gzip format was designed to retain the directory information about\n     a single file, such as the name and last modification date. The zlib\n     format on the other hand was designed for in-memory and communication\n     channel applications, and has a much more compact header and trailer and\n     uses a faster integrity check than gzip.\n \n-18. Well that's nice, but how do I make a gzip file in memory?\n+20. Well that's nice, but how do I make a gzip file in memory?\n \n     You can request that deflate write the gzip format instead of the zlib\n     format using deflateInit2(). You can also request that inflate decode\n     the gzip format using inflateInit2(). Read zlib.h for more details.\n \n-    Note that you cannot specify special gzip header contents (e.g. a file\n-    name or modification date), nor will inflate tell you what was in the\n-    gzip header. If you need to customize the header or see what's in it,\n-    you can use the raw deflate and inflate operations and the crc32()\n-    function and roll your own gzip encoding and decoding. Read the gzip\n-    RFC 1952 for details of the header and trailer format.\n-\n-19. Is zlib thread-safe?\n+21. Is zlib thread-safe?\n \n     Yes. However any library routines that zlib uses and any application-\n     provided memory allocation routines must also be thread-safe. zlib's gz*\n@@ -144,15 +159,15 @@ The lastest zlib FAQ is at http://www.gzip.org/zlib/zlib_faq.html\n     Of course, you should only operate on any given zlib or gzip stream from a\n     single thread at a time.\n \n-20. Can I use zlib in my commercial application?\n+22. Can I use zlib in my commercial application?\n \n     Yes. Please read the license in zlib.h.\n \n-21. Is zlib under the GNU license?\n+23. Is zlib under the GNU license?\n \n     No. Please read the license in zlib.h.\n \n-22. The license says that altered source versions must be \"plainly marked\". So\n+24. The license says that altered source versions must be \"plainly marked\". So\n     what exactly do I need to do to meet that requirement?\n \n     You need to change the ZLIB_VERSION and ZLIB_VERNUM #defines in zlib.h. In\n@@ -175,52 +190,52 @@ The lastest zlib FAQ is at http://www.gzip.org/zlib/zlib_faq.html\n     ZLIB_VERSION and ZLIB_VERNUM and note the origin and nature of the changes\n     in zlib.h as you would for a full source distribution.\n \n-23. Will zlib work on a big-endian or little-endian architecture, and can I\n+25. Will zlib work on a big-endian or little-endian architecture, and can I\n     exchange compressed data between them?\n \n     Yes and yes.\n \n-24. Will zlib work on a 64-bit machine?\n+26. Will zlib work on a 64-bit machine?\n \n     It should. It has been tested on 64-bit machines, and has no dependence\n     on any data types being limited to 32-bits in length. If you have any\n     difficulties, please provide a complete problem report to zlib@gzip.org\n \n-25. Will zlib decompress data from the PKWare Data Compression Library?\n+27. Will zlib decompress data from the PKWare Data Compression Library?\n \n     No. The PKWare DCL uses a completely different compressed data format\n     than does PKZIP and zlib. However, you can look in zlib's contrib/blast\n     directory for a possible solution to your problem.\n \n-26. Can I access data randomly in a compressed stream?\n+28. Can I access data randomly in a compressed stream?\n \n     No, not without some preparation. If when compressing you periodically\n     use Z_FULL_FLUSH, carefully write all the pending data at those points,\n     and keep an index of those locations, then you can start decompression\n     at those points. You have to be careful to not use Z_FULL_FLUSH too\n     often, since it can significantly degrade compression.\n \n-27. Does zlib work on MVS, OS/390, CICS, etc.?\n+29. Does zlib work on MVS, OS/390, CICS, etc.?\n \n     We don't know for sure. We have heard occasional reports of success on\n     these systems. If you do use it on one of these, please provide us with\n     a report, instructions, and patches that we can reference when we get\n     these questions. Thanks.\n \n-28. Is there some simpler, easier to read version of inflate I can look at\n+30. Is there some simpler, easier to read version of inflate I can look at\n     to understand the deflate format?\n \n     First off, you should read RFC 1951. Second, yes. Look in zlib's\n     contrib/puff directory.\n \n-29. Does zlib infringe on any patents?\n+31. Does zlib infringe on any patents?\n \n     As far as we know, no. In fact, that was originally the whole point behind\n     zlib. Look here for some more information:\n \n     http://www.gzip.org/#faq11\n \n-30. Can zlib work with greater than 4 GB of data?\n+32. Can zlib work with greater than 4 GB of data?\n \n     Yes. inflate() and deflate() will process any amount of data correctly.\n     Each call of inflate() or deflate() is limited to input and output chunks\n@@ -238,7 +253,7 @@ The lastest zlib FAQ is at http://www.gzip.org/zlib/zlib_faq.html\n     only if the compiler's \"long\" type is 32 bits. If the compiler's \"long\"\n     type is 64 bits, then the limit is 16 exabytes.\n \n-31. Does zlib have any security vulnerabilities?\n+33. Does zlib have any security vulnerabilities?\n \n     The only one that we are aware of is potentially in gzprintf(). If zlib\n     is compiled to use sprintf() or vsprintf(), then there is no protection\n@@ -258,35 +273,44 @@ The lastest zlib FAQ is at http://www.gzip.org/zlib/zlib_faq.html\n     Note that you should be using the most recent version of zlib. Versions\n     1.1.3 and before were subject to a double-free vulnerability.\n \n-32. Is there a Java version of zlib?\n+34. Is there a Java version of zlib?\n \n     Probably what you want is to use zlib in Java. zlib is already included\n     as part of the Java SDK in the java.util.zip package. If you really want\n     a version of zlib written in the Java language, look on the zlib home\n     page for links: http://www.zlib.org/\n \n-33. I get this or that compiler or source-code scanner warning when I crank it\n-    up to maximally-pendantic. Can't you guys write proper code?\n+35. I get this or that compiler or source-code scanner warning when I crank it\n+    up to maximally-pedantic. Can't you guys write proper code?\n \n     Many years ago, we gave up attempting to avoid warnings on every compiler\n     in the universe. It just got to be a waste of time, and some compilers\n     were downright silly. So now, we simply make sure that the code always\n     works.\n \n-34. Will zlib read the (insert any ancient or arcane format here) compressed\n+36. Valgrind (or some similar memory access checker) says that deflate is\n+    performing a conditional jump that depends on an uninitialized value.\n+    Isn't that a bug?\n+\n+    No.  That is intentional for performance reasons, and the output of\n+    deflate is not affected.  This only started showing up recently since\n+    zlib 1.2.x uses malloc() by default for allocations, whereas earlier\n+    versions used calloc(), which zeros out the allocated memory.\n+\n+37. Will zlib read the (insert any ancient or arcane format here) compressed\n     data format?\n \n     Probably not. Look in the comp.compression FAQ for pointers to various\n     formats and associated software.\n \n-35. How can I encrypt/decrypt zip files with zlib?\n+38. How can I encrypt/decrypt zip files with zlib?\n \n     zlib doesn't support encryption. The original PKZIP encryption is very weak\n     and can be broken with freely available programs. To get strong encryption,\n-    use gpg ( http://www.gnupg.org/ ) which already includes zlib compression.\n+    use GnuPG, http://www.gnupg.org/ , which already includes zlib compression.\n     For PKZIP compatible \"encryption\", look at http://www.info-zip.org/\n \n-36. What's the difference between the \"gzip\" and \"deflate\" HTTP 1.1 encodings?\n+39. What's the difference between the \"gzip\" and \"deflate\" HTTP 1.1 encodings?\n \n     \"gzip\" is the gzip format, and \"deflate\" is the zlib format. They should\n     probably have called the second one \"zlib\" instead to avoid confusion\n@@ -302,14 +326,14 @@ The lastest zlib FAQ is at http://www.gzip.org/zlib/zlib_faq.html\n \n     Bottom line: use the gzip format for HTTP 1.1 encoding.\n \n-37. Does zlib support the new \"Deflate64\" format introduced by PKWare?\n+40. Does zlib support the new \"Deflate64\" format introduced by PKWare?\n \n     No. PKWare has apparently decided to keep that format proprietary, since\n     they have not documented it as they have previous compression formats.\n     In any case, the compression improvements are so modest compared to other\n     more modern approaches, that it's not worth the effort to implement.\n \n-38. Can you please sign these lengthy legal documents and fax them back to us\n+41. Can you please sign these lengthy legal documents and fax them back to us\n     so that we can use your software in our product?\n \n     No. Go away. Shoo."}, {"sha": "0587e5902bd155878ce6a11adbedd5c34630d7a3", "filename": "zlib/INDEX", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2FINDEX", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2FINDEX", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FINDEX?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -8,9 +8,12 @@ algorithm.txt   description of the (de)compression algorithm\n configure       configure script for Unix\n zconf.in.h      template for zconf.h (used by configure)\n \n+amiga/          makefiles for Amiga SAS C\n+as400/          makefiles for IBM AS/400\n msdos/          makefiles for MSDOS\n old/            makefiles for various architectures and zlib documentation\n                 files that have not yet been updated for zlib 1.2.x\n+projects/       projects for various Integrated Development Environments\n qnx/            makefiles for QNX\n win32/          makefiles for Windows\n "}, {"sha": "0f171029d207be6872180c8f164e3aefb791e2e4", "filename": "zlib/README", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FREADME?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -3,7 +3,7 @@ shipped with GCC as convenience.\n \n ZLIB DATA COMPRESSION LIBRARY\n \n-zlib 1.2.1 is a general purpose data compression library.  All the code is\n+zlib 1.2.3 is a general purpose data compression library.  All the code is\n thread safe.  The data format used by the zlib library is described by RFCs\n (Request for Comments) 1950 to 1952 in the files\n http://www.ietf.org/rfc/rfc1950.txt (zlib format), rfc1951.txt (deflate format)\n@@ -19,9 +19,8 @@ minigzip.c.\n \n To compile all files and run the test program, follow the instructions given at\n the top of Makefile. In short \"make test; make install\" should work for most\n-machines. For Unix: \"./configure; make test; make install\" For MSDOS, use one\n-of the special makefiles such as Makefile.msc. For VMS, use Make_vms.com or\n-descrip.mms.\n+machines. For Unix: \"./configure; make test; make install\". For MSDOS, use one\n+of the special makefiles such as Makefile.msc. For VMS, use make_vms.com.\n \n Questions about zlib should be sent to <zlib@gzip.org>, or to Gilles Vollant\n <info@winimage.com> for the Windows DLL version. The zlib home page is\n@@ -37,7 +36,7 @@ Mark Nelson <markn@ieee.org> wrote an article about zlib for the Jan. 1997\n issue of  Dr. Dobb's Journal; a copy of the article is available in\n http://dogma.net/markn/articles/zlibtool/zlibtool.htm\n \n-The changes made in version 1.2.1 are documented in the file ChangeLog.\n+The changes made in version 1.2.3 are documented in the file ChangeLog.\n \n Unsupported third party contributions are provided in directory \"contrib\".\n \n@@ -49,7 +48,7 @@ A Perl interface to zlib written by Paul Marquess <pmqs@cpan.org> is in the\n CPAN (Comprehensive Perl Archive Network) sites\n http://www.cpan.org/modules/by-module/Compress/\n \n-A Python interface to zlib written by A.M. Kuchling <amk@magnet.com> is\n+A Python interface to zlib written by A.M. Kuchling <amk@amk.ca> is\n available in Python 1.5 and later versions, see\n http://www.python.org/doc/lib/module-zlib.html\n \n@@ -96,7 +95,7 @@ Acknowledgments:\n \n Copyright notice:\n \n- (C) 1995-2003 Jean-loup Gailly and Mark Adler\n+ (C) 1995-2004 Jean-loup Gailly and Mark Adler\n \n   This software is provided 'as-is', without any express or implied\n   warranty.  In no event will the authors be held liable for any damages"}, {"sha": "2aec85141311d8c7d429d8c420dea093e1cdd0e0", "filename": "zlib/adler32.c", "status": "modified", "additions": 93, "deletions": 18, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fadler32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fadler32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fadler32.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* adler32.c -- compute the Adler-32 checksum of a data stream\n- * Copyright (C) 1995-2003 Mark Adler\n+ * Copyright (C) 1995-2004 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -12,12 +12,13 @@\n #define NMAX 5552\n /* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */\n \n-#define DO1(buf,i)  {s1 += buf[i]; s2 += s1;}\n+#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}\n #define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);\n #define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);\n #define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);\n #define DO16(buf)   DO8(buf,0); DO8(buf,8);\n \n+/* use NO_DIVIDE if your processor does not do division in hardware */\n #ifdef NO_DIVIDE\n #  define MOD(a) \\\n     do { \\\n@@ -39,8 +40,17 @@\n         if (a >= (BASE << 1)) a -= (BASE << 1); \\\n         if (a >= BASE) a -= BASE; \\\n     } while (0)\n+#  define MOD4(a) \\\n+    do { \\\n+        if (a >= (BASE << 4)) a -= (BASE << 4); \\\n+        if (a >= (BASE << 3)) a -= (BASE << 3); \\\n+        if (a >= (BASE << 2)) a -= (BASE << 2); \\\n+        if (a >= (BASE << 1)) a -= (BASE << 1); \\\n+        if (a >= BASE) a -= BASE; \\\n+    } while (0)\n #else\n #  define MOD(a) a %= BASE\n+#  define MOD4(a) a %= BASE\n #endif\n \n /* ========================================================================= */\n@@ -49,26 +59,91 @@ uLong ZEXPORT adler32(adler, buf, len)\n     const Bytef *buf;\n     uInt len;\n {\n-    unsigned long s1 = adler & 0xffff;\n-    unsigned long s2 = (adler >> 16) & 0xffff;\n-    int k;\n+    unsigned long sum2;\n+    unsigned n;\n+\n+    /* split Adler-32 into component sums */\n+    sum2 = (adler >> 16) & 0xffff;\n+    adler &= 0xffff;\n+\n+    /* in case user likes doing a byte at a time, keep it fast */\n+    if (len == 1) {\n+        adler += buf[0];\n+        if (adler >= BASE)\n+            adler -= BASE;\n+        sum2 += adler;\n+        if (sum2 >= BASE)\n+            sum2 -= BASE;\n+        return adler | (sum2 << 16);\n+    }\n \n-    if (buf == Z_NULL) return 1L;\n+    /* initial Adler-32 value (deferred check for len == 1 speed) */\n+    if (buf == Z_NULL)\n+        return 1L;\n \n-    while (len > 0) {\n-        k = len < NMAX ? (int)len : NMAX;\n-        len -= k;\n-        while (k >= 16) {\n+    /* in case short lengths are provided, keep it somewhat fast */\n+    if (len < 16) {\n+        while (len--) {\n+            adler += *buf++;\n+            sum2 += adler;\n+        }\n+        if (adler >= BASE)\n+            adler -= BASE;\n+        MOD4(sum2);             /* only added so many BASE's */\n+        return adler | (sum2 << 16);\n+    }\n+\n+    /* do length NMAX blocks -- requires just one modulo operation */\n+    while (len >= NMAX) {\n+        len -= NMAX;\n+        n = NMAX / 16;          /* NMAX is divisible by 16 */\n+        do {\n+            DO16(buf);          /* 16 sums unrolled */\n+            buf += 16;\n+        } while (--n);\n+        MOD(adler);\n+        MOD(sum2);\n+    }\n+\n+    /* do remaining bytes (less than NMAX, still just one modulo) */\n+    if (len) {                  /* avoid modulos if none remaining */\n+        while (len >= 16) {\n+            len -= 16;\n             DO16(buf);\n             buf += 16;\n-            k -= 16;\n         }\n-        if (k != 0) do {\n-            s1 += *buf++;\n-            s2 += s1;\n-        } while (--k);\n-        MOD(s1);\n-        MOD(s2);\n+        while (len--) {\n+            adler += *buf++;\n+            sum2 += adler;\n+        }\n+        MOD(adler);\n+        MOD(sum2);\n     }\n-    return (s2 << 16) | s1;\n+\n+    /* return recombined sums */\n+    return adler | (sum2 << 16);\n+}\n+\n+/* ========================================================================= */\n+uLong ZEXPORT adler32_combine(adler1, adler2, len2)\n+    uLong adler1;\n+    uLong adler2;\n+    z_off_t len2;\n+{\n+    unsigned long sum1;\n+    unsigned long sum2;\n+    unsigned rem;\n+\n+    /* the derivation of this formula is left as an exercise for the reader */\n+    rem = (unsigned)(len2 % BASE);\n+    sum1 = adler1 & 0xffff;\n+    sum2 = rem * sum1;\n+    MOD(sum2);\n+    sum1 += (adler2 & 0xffff) + BASE - 1;\n+    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;\n+    if (sum1 > BASE) sum1 -= BASE;\n+    if (sum1 > BASE) sum1 -= BASE;\n+    if (sum2 > (BASE << 1)) sum2 -= (BASE << 1);\n+    if (sum2 > BASE) sum2 -= BASE;\n+    return sum1 | (sum2 << 16);\n }"}, {"sha": "296ef48a22b01e2795a6d359ad56907434df1a38", "filename": "zlib/amiga/Makefile.sas", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Famiga%2FMakefile.sas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Famiga%2FMakefile.sas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Famiga%2FMakefile.sas?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -23,7 +23,7 @@ all: SCOPTIONS example minigzip\n check: test\n test: all\n \texample\n-\techo hello world | minigzip | minigzip -d \n+\techo hello world | minigzip | minigzip -d\n \n install: z.lib\n \tcopy clone zlib.h zconf.h INCLUDE:"}, {"sha": "08f276718fa6c7b10f03945473c71679c8c70d24", "filename": "zlib/compress.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcompress.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcompress.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcompress.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* compress.c -- compress a memory buffer\n- * Copyright (C) 1995-2002 Jean-loup Gailly.\n+ * Copyright (C) 1995-2003 Jean-loup Gailly.\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n "}, {"sha": "20afc621541f7402725eb06c5873dee9d8aef556", "filename": "zlib/contrib/README.contrib", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2FREADME.contrib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2FREADME.contrib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2FREADME.contrib?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -19,8 +19,8 @@ blast/      by Mark Adler <madler@alumni.caltech.edu>\n delphi/     by Cosmin Truta <cosmint@cs.ubbcluj.ro>\n         Support for Delphi and C++ Builder\n \n-gzappend/   by Mark Adler <madler@alumni.caltech.edu>\n-        append to a gzip file -- illustrates the use of Z_BLOCK\n+dotzlib/    by Henrik Ravn <henrik@ravn.com>\n+        Support for Microsoft .Net and Visual C++ .Net\n \n infback9/   by Mark Adler <madler@alumni.caltech.edu>\n         Unsupported diffs to infback to decode the deflate64 format\n@@ -42,6 +42,10 @@ masm686/    by Dan Higdon <hdan@kinesoft.com>\n             and Chuck Walbourn <chuckw@kinesoft.com>\n         asm code for Pentium Pro/PII, using the MASM syntax\n \n+masmx64/    by Gilles Vollant <info@winimage.com>\n+\tx86 64-bit (AMD64 and Intel EM64t) code for x64 assembler to\n+\treplace longest_match() and inflate_fast()\n+\n masmx86/    by Gilles Vollant <info@winimage.com>\n         x86 asm code to replace longest_match() and inflate_fast(),\n         for Visual C++ and MASM\n@@ -60,11 +64,8 @@ puff/       by Mark Adler <madler@alumni.caltech.edu>\n testzlib/   by Gilles Vollant <info@winimage.com>\n         Example of the use of zlib\n \n-untgz/      by \"Pedro A. Aranda Guti\\irrez\" <paag@tid.es>\n+untgz/      by Pedro A. Aranda Gutierrez <paag@tid.es>\n         A very simple tar.gz file extractor using zlib\n \n-visual-basic.txt by Carlos Rios <c_rios@sonda.cl>\n-        How to use compress(), uncompress() and the gz* functions from VB\n-\n vstudio/    by Gilles Vollant <info@winimage.com>\n-        Building zlib with Visual Studio .NET\n+        Building a minizip-enhanced zlib with Microsoft Visual Studio"}, {"sha": "0368b35fe3aa93c1d3cb09d0de3c1cfecca8867c", "filename": "zlib/contrib/asm586/match.S", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fasm586%2Fmatch.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fasm586%2Fmatch.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm586%2Fmatch.S?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -45,19 +45,29 @@\n  * program to crash horribly, without so much as a warning at\n  * compile time. Sigh.)\n  */\n-#define\tdsWSize\t\t\t36\n-#define\tdsWMask\t\t\t44\n-#define\tdsWindow\t\t48\n-#define\tdsPrev\t\t\t56\n-#define\tdsMatchLen\t\t88\n-#define\tdsPrevMatch\t\t92\n-#define\tdsStrStart\t\t100\n-#define\tdsMatchStart\t\t104\n-#define\tdsLookahead\t\t108\n-#define\tdsPrevLen\t\t112\n-#define\tdsMaxChainLen\t\t116\n-#define\tdsGoodMatch\t\t132\n-#define\tdsNiceMatch\t\t136\n+\n+/* All the +zlib1222add offsets are due to the addition of fields\n+ *  in zlib in the deflate_state structure since the asm code was first written\n+ * (if you compile with zlib 1.0.4 or older, use \"zlib1222add equ (-4)\").\n+ * (if you compile with zlib between 1.0.5 and 1.2.2.1, use \"zlib1222add equ 0\").\n+ * if you compile with zlib 1.2.2.2 or later , use \"zlib1222add equ 8\").\n+ */\n+\n+#define zlib1222add\t\t(8)\n+\n+#define\tdsWSize\t\t\t(36+zlib1222add)\n+#define\tdsWMask\t\t\t(44+zlib1222add)\n+#define\tdsWindow\t\t(48+zlib1222add)\n+#define\tdsPrev\t\t\t(56+zlib1222add)\n+#define\tdsMatchLen\t\t(88+zlib1222add)\n+#define\tdsPrevMatch\t\t(92+zlib1222add)\n+#define\tdsStrStart\t\t(100+zlib1222add)\n+#define\tdsMatchStart\t\t(104+zlib1222add)\n+#define\tdsLookahead\t\t(108+zlib1222add)\n+#define\tdsPrevLen\t\t(112+zlib1222add)\n+#define\tdsMaxChainLen\t\t(116+zlib1222add)\n+#define\tdsGoodMatch\t\t(132+zlib1222add)\n+#define\tdsNiceMatch\t\t(136+zlib1222add)\n \n \n .file \"match.S\""}, {"sha": "5c3e9ee367182e20a19fcaac74a0a4a472ee6ff7", "filename": "zlib/contrib/asm686/match.S", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fasm686%2Fmatch.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fasm686%2Fmatch.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm686%2Fmatch.S?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -38,26 +38,28 @@\n #define\tdeflatestate\t\t56\t/* the function arguments\t*/\n #define\tcurmatch\t\t60\n \n-/* Offsets for fields in the deflate_state structure. These numbers\n- * are calculated from the definition of deflate_state, with the\n- * assumption that the compiler will dword-align the fields. (Thus,\n- * changing the definition of deflate_state could easily cause this\n- * program to crash horribly, without so much as a warning at\n- * compile time. Sigh.)\n+/* All the +zlib1222add offsets are due to the addition of fields\n+ *  in zlib in the deflate_state structure since the asm code was first written\n+ * (if you compile with zlib 1.0.4 or older, use \"zlib1222add equ (-4)\").\n+ * (if you compile with zlib between 1.0.5 and 1.2.2.1, use \"zlib1222add equ 0\").\n+ * if you compile with zlib 1.2.2.2 or later , use \"zlib1222add equ 8\").\n  */\n-#define\tdsWSize\t\t\t36\n-#define\tdsWMask\t\t\t44\n-#define\tdsWindow\t\t48\n-#define\tdsPrev\t\t\t56\n-#define\tdsMatchLen\t\t88\n-#define\tdsPrevMatch\t\t92\n-#define\tdsStrStart\t\t100\n-#define\tdsMatchStart\t\t104\n-#define\tdsLookahead\t\t108\n-#define\tdsPrevLen\t\t112\n-#define\tdsMaxChainLen\t\t116\n-#define\tdsGoodMatch\t\t132\n-#define\tdsNiceMatch\t\t136\n+\n+#define zlib1222add\t\t(8)\n+\n+#define\tdsWSize\t\t\t(36+zlib1222add)\n+#define\tdsWMask\t\t\t(44+zlib1222add)\n+#define\tdsWindow\t\t(48+zlib1222add)\n+#define\tdsPrev\t\t\t(56+zlib1222add)\n+#define\tdsMatchLen\t\t(88+zlib1222add)\n+#define\tdsPrevMatch\t\t(92+zlib1222add)\n+#define\tdsStrStart\t\t(100+zlib1222add)\n+#define\tdsMatchStart\t\t(104+zlib1222add)\n+#define\tdsLookahead\t\t(108+zlib1222add)\n+#define\tdsPrevLen\t\t(112+zlib1222add)\n+#define\tdsMaxChainLen\t\t(116+zlib1222add)\n+#define\tdsGoodMatch\t\t(132+zlib1222add)\n+#define\tdsNiceMatch\t\t(136+zlib1222add)\n \n \n .file \"match.S\""}, {"sha": "f2e9e4ffd522b39ed02e0f4430fff31c6475b356", "filename": "zlib/contrib/gzappend/gzappend.c", "status": "removed", "additions": 0, "deletions": 500, "changes": 500, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fgzappend%2Fgzappend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fgzappend%2Fgzappend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fgzappend%2Fgzappend.c?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,500 +0,0 @@\n-/* gzappend -- command to append to a gzip file\n-\n-  Copyright (C) 2003 Mark Adler, all rights reserved\n-  version 1.1, 4 Nov 2003\n-\n-  This software is provided 'as-is', without any express or implied\n-  warranty.  In no event will the author be held liable for any damages\n-  arising from the use of this software.\n-\n-  Permission is granted to anyone to use this software for any purpose,\n-  including commercial applications, and to alter it and redistribute it\n-  freely, subject to the following restrictions:\n-\n-  1. The origin of this software must not be misrepresented; you must not\n-     claim that you wrote the original software. If you use this software\n-     in a product, an acknowledgment in the product documentation would be\n-     appreciated but is not required.\n-  2. Altered source versions must be plainly marked as such, and must not be\n-     misrepresented as being the original software.\n-  3. This notice may not be removed or altered from any source distribution.\n-\n-  Mark Adler    madler@alumni.caltech.edu\n- */\n-\n-/*\n- * Change history:\n- *\n- * 1.0  19 Oct 2003     - First version\n- * 1.1   4 Nov 2003     - Expand and clarify some comments and notes\n- *                      - Add version and copyright to help\n- *                      - Send help to stdout instead of stderr\n- *                      - Add some preemptive typecasts\n- *                      - Add L to constants in lseek() calls\n- *                      - Remove some debugging information in error messages\n- *                      - Use new data_type definition for zlib 1.2.1\n- *                      - Simplfy and unify file operations\n- *                      - Finish off gzip file in gztack()\n- *                      - Use deflatePrime() instead of adding empty blocks\n- *                      - Keep gzip file clean on appended file read errors\n- *                      - Use in-place rotate instead of auxiliary buffer\n- *                        (Why you ask?  Because it was fun to write!)\n- */\n-\n-/*\n-   gzappend takes a gzip file and appends to it, compressing files from the\n-   command line or data from stdin.  The gzip file is written to directly, to\n-   avoid copying that file, in case it's large.  Note that this results in the\n-   unfriendly behavior that if gzappend fails, the gzip file is corrupted.\n-\n-   This program was written to illustrate the use of the new Z_BLOCK option of\n-   zlib 1.2.1's inflate() function.  This option returns from inflate() at each\n-   block boundary to facilitate locating and modifying the last block bit at\n-   the start of the final deflate block.  Also whether using Z_BLOCK or not,\n-   another required feature of zlib 1.2.1 is that inflate() now provides the\n-   number of unusued bits in the last input byte used.  gzappend will not work\n-   with versions of zlib earlier than 1.2.1.\n-\n-   gzappend first decompresses the gzip file internally, discarding all but\n-   the last 32K of uncompressed data, and noting the location of the last block\n-   bit and the number of unused bits in the last byte of the compressed data.\n-   The gzip trailer containing the CRC-32 and length of the uncompressed data\n-   is verified.  This trailer will be later overwritten.\n-\n-   Then the last block bit is cleared by seeking back in the file and rewriting\n-   the byte that contains it.  Seeking forward, the last byte of the compressed\n-   data is saved along with the number of unused bits to initialize deflate.\n-\n-   A deflate process is initialized, using the last 32K of the uncompressed\n-   data from the gzip file to initialize the dictionary.  If the total\n-   uncompressed data was less than 32K, then all of it is used to initialize\n-   the dictionary.  The deflate output bit buffer is also initialized with the\n-   last bits from the original deflate stream.  From here on, the data to\n-   append is simply compressed using deflate, and written to the gzip file.\n-   When that is complete, the new CRC-32 and uncompressed length are written\n-   as the trailer of the gzip file.\n- */\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <fcntl.h>\n-#include <unistd.h>\n-#include \"zlib.h\"\n-\n-#define local static\n-#define LGCHUNK 14\n-#define CHUNK (1U << LGCHUNK)\n-#define DSIZE 32768U\n-\n-/* print an error message and terminate with extreme prejudice */\n-local void bye(char *msg1, char *msg2)\n-{\n-    fprintf(stderr, \"gzappend error: %s%s\\n\", msg1, msg2);\n-    exit(1);\n-}\n-\n-/* return the greatest common divisor of a and b using Euclid's algorithm,\n-   modified to be fast when one argument much greater than the other, and\n-   coded to avoid unnecessary swapping */\n-local unsigned gcd(unsigned a, unsigned b)\n-{\n-    unsigned c;\n-\n-    while (a && b)\n-        if (a > b) {\n-            c = b;\n-            while (a - c >= c)\n-                c <<= 1;\n-            a -= c;\n-        }\n-        else {\n-            c = a;\n-            while (b - c >= c)\n-                c <<= 1;\n-            b -= c;\n-        }\n-    return a + b;\n-}\n-\n-/* rotate list[0..len-1] left by rot positions, in place */\n-local void rotate(unsigned char *list, unsigned len, unsigned rot)\n-{\n-    unsigned char tmp;\n-    unsigned cycles;\n-    unsigned char *start, *last, *to, *from;\n-\n-    /* normalize rot and handle degenerate cases */\n-    if (len < 2) return;\n-    if (rot >= len) rot %= len;\n-    if (rot == 0) return;\n-\n-    /* pointer to last entry in list */\n-    last = list + (len - 1);\n-\n-    /* do simple left shift by one */\n-    if (rot == 1) {\n-        tmp = *list;\n-        memcpy(list, list + 1, len - 1);\n-        *last = tmp;\n-        return;\n-    }\n-\n-    /* do simple right shift by one */\n-    if (rot == len - 1) {\n-        tmp = *last;\n-        memmove(list + 1, list, len - 1);\n-        *list = tmp;\n-        return;\n-    }\n-\n-    /* otherwise do rotate as a set of cycles in place */\n-    cycles = gcd(len, rot);             /* number of cycles */\n-    do {\n-        start = from = list + cycles;   /* start index is arbitrary */\n-        tmp = *from;                    /* save entry to be overwritten */\n-        for (;;) {\n-            to = from;                  /* next step in cycle */\n-            from += rot;                /* go right rot positions */\n-            if (from > last) from -= len;   /* (pointer better not wrap) */\n-            if (from == start) break;   /* all but one shifted */\n-            *to = *from;                /* shift left */\n-        }\n-        *to = tmp;                      /* complete the circle */\n-    } while (--cycles);\n-}\n-\n-/* structure for gzip file read operations */\n-typedef struct {\n-    int fd;                     /* file descriptor */\n-    int size;                   /* 1 << size is bytes in buf */\n-    unsigned left;              /* bytes available at next */\n-    unsigned char *buf;         /* buffer */\n-    unsigned char *next;        /* next byte in buffer */\n-    char *name;                 /* file name for error messages */\n-} file;\n-\n-/* reload buffer */\n-local int readin(file *in)\n-{\n-    int len;\n-\n-    len = read(in->fd, in->buf, 1 << in->size);\n-    if (len == -1) bye(\"error reading \", in->name);\n-    in->left = (unsigned)len;\n-    in->next = in->buf;\n-    return len;\n-}\n-\n-/* read from file in, exit if end-of-file */\n-local int readmore(file *in)\n-{\n-    if (readin(in) == 0) bye(\"unexpected end of \", in->name);\n-    return 0;\n-}\n-\n-#define read1(in) (in->left == 0 ? readmore(in) : 0, \\\n-                   in->left--, *(in->next)++)\n-\n-/* skip over n bytes of in */\n-local void skip(file *in, unsigned n)\n-{\n-    unsigned bypass;\n-\n-    if (n > in->left) {\n-        n -= in->left;\n-        bypass = n & ~((1U << in->size) - 1);\n-        if (bypass) {\n-            if (lseek(in->fd, (off_t)bypass, SEEK_CUR) == -1)\n-                bye(\"seeking \", in->name);\n-            n -= bypass;\n-        }\n-        readmore(in);\n-        if (n > in->left)\n-            bye(\"unexpected end of \", in->name);\n-    }\n-    in->left -= n;\n-    in->next += n;\n-}\n-\n-/* read a four-byte unsigned integer, little-endian, from in */\n-unsigned long read4(file *in)\n-{\n-    unsigned long val;\n-\n-    val = read1(in);\n-    val += (unsigned)read1(in) << 8;\n-    val += (unsigned long)read1(in) << 16;\n-    val += (unsigned long)read1(in) << 24;\n-    return val;\n-}\n-\n-/* skip over gzip header */\n-local void gzheader(file *in)\n-{\n-    int flags;\n-    unsigned n;\n-\n-    if (read1(in) != 31 || read1(in) != 139) bye(in->name, \" not a gzip file\");\n-    if (read1(in) != 8) bye(\"unknown compression method in\", in->name);\n-    flags = read1(in);\n-    if (flags & 0xe0) bye(\"unknown header flags set in\", in->name);\n-    skip(in, 6);\n-    if (flags & 4) {\n-        n = read1(in);\n-        n += (unsigned)(read1(in)) << 8;\n-        skip(in, n);\n-    }\n-    if (flags & 8) while (read1(in) != 0) ;\n-    if (flags & 16) while (read1(in) != 0) ;\n-    if (flags & 2) skip(in, 2);\n-}\n-\n-/* decompress gzip file \"name\", return strm with a deflate stream ready to\n-   continue compression of the data in the gzip file, and return a file\n-   descriptor pointing to where to write the compressed data -- the deflate\n-   stream is initialized to compress using level \"level\" */\n-local int gzscan(char *name, z_stream *strm, int level)\n-{\n-    int ret, lastbit, left, full;\n-    unsigned have;\n-    unsigned long crc, tot;\n-    unsigned char *window;\n-    off_t lastoff, end;\n-    file gz;\n-\n-    /* open gzip file */\n-    gz.name = name;\n-    gz.fd = open(name, O_RDWR, 0);\n-    if (gz.fd == -1) bye(\"cannot open \", name);\n-    gz.buf = malloc(CHUNK);\n-    if (gz.buf == NULL) bye(\"out of memory\", \"\");\n-    gz.size = LGCHUNK;\n-    gz.left = 0;\n-\n-    /* skip gzip header */\n-    gzheader(&gz);\n-\n-    /* prepare to decompress */\n-    window = malloc(DSIZE);\n-    if (window == NULL) bye(\"out of memory\", \"\");\n-    strm->zalloc = Z_NULL;\n-    strm->zfree = Z_NULL;\n-    strm->opaque = Z_NULL;\n-    ret = inflateInit2(strm, -15);\n-    if (ret != Z_OK) bye(\"out of memory\", \" or library mismatch\");\n-\n-    /* decompress the deflate stream, saving append information */\n-    lastbit = 0;\n-    lastoff = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;\n-    left = 0;\n-    strm->avail_in = gz.left;\n-    strm->next_in = gz.next;\n-    crc = crc32(0L, Z_NULL, 0);\n-    have = full = 0;\n-    do {\n-        /* if needed, get more input */\n-        if (strm->avail_in == 0) {\n-            readmore(&gz);\n-            strm->avail_in = gz.left;\n-            strm->next_in = gz.next;\n-        }\n-\n-        /* set up output to next available section of sliding window */\n-        strm->avail_out = DSIZE - have;\n-        strm->next_out = window + have;\n-\n-        /* inflate and check for errors */\n-        ret = inflate(strm, Z_BLOCK);\n-        if (ret == Z_STREAM_ERROR) bye(\"internal stream error!\", \"\");\n-        if (ret == Z_MEM_ERROR) bye(\"out of memory\", \"\");\n-        if (ret == Z_DATA_ERROR)\n-            bye(\"invalid compressed data--format violated in\", name);\n-\n-        /* update crc and sliding window pointer */\n-        crc = crc32(crc, window + have, DSIZE - have - strm->avail_out);\n-        if (strm->avail_out)\n-            have = DSIZE - strm->avail_out;\n-        else {\n-            have = 0;\n-            full = 1;\n-        }\n-\n-        /* process end of block */\n-        if (strm->data_type & 128) {\n-            if (strm->data_type & 64)\n-                left = strm->data_type & 0x1f;\n-            else {\n-                lastbit = strm->data_type & 0x1f;\n-                lastoff = lseek(gz.fd, 0L, SEEK_CUR) - strm->avail_in;\n-            }\n-        }\n-    } while (ret != Z_STREAM_END);\n-    inflateEnd(strm);\n-    gz.left = strm->avail_in;\n-    gz.next = strm->next_in;\n-\n-    /* save the location of the end of the compressed data */\n-    end = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;\n-\n-    /* check gzip trailer and save total for deflate */\n-    if (crc != read4(&gz))\n-        bye(\"invalid compressed data--crc mismatch in \", name);\n-    tot = strm->total_out;\n-    if ((tot & 0xffffffffUL) != read4(&gz))\n-        bye(\"invalid compressed data--length mismatch in\", name);\n-\n-    /* if not at end of file, warn */\n-    if (gz.left || readin(&gz))\n-        fprintf(stderr,\n-            \"gzappend warning: junk at end of gzip file overwritten\\n\");\n-\n-    /* clear last block bit */\n-    lseek(gz.fd, lastoff - (lastbit != 0), SEEK_SET);\n-    if (read(gz.fd, gz.buf, 1) != 1) bye(\"reading after seek on \", name);\n-    *gz.buf = (unsigned char)(*gz.buf ^ (1 << ((8 - lastbit) & 7)));\n-    lseek(gz.fd, -1L, SEEK_CUR);\n-    if (write(gz.fd, gz.buf, 1) != 1) bye(\"writing after seek to \", name);\n-\n-    /* if window wrapped, build dictionary from window by rotating */\n-    if (full) {\n-        rotate(window, DSIZE, have);\n-        have = DSIZE;\n-    }\n-\n-    /* set up deflate stream with window, crc, total_in, and leftover bits */\n-    ret = deflateInit2(strm, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY);\n-    if (ret != Z_OK) bye(\"out of memory\", \"\");\n-    deflateSetDictionary(strm, window, have);\n-    strm->adler = crc;\n-    strm->total_in = tot;\n-    if (left) {\n-        lseek(gz.fd, --end, SEEK_SET);\n-        if (read(gz.fd, gz.buf, 1) != 1) bye(\"reading after seek on \", name);\n-        deflatePrime(strm, 8 - left, *gz.buf);\n-    }\n-    lseek(gz.fd, end, SEEK_SET);\n-\n-    /* clean up and return */\n-    free(window);\n-    free(gz.buf);\n-    return gz.fd;\n-}\n-\n-/* append file \"name\" to gzip file gd using deflate stream strm -- if last\n-   is true, then finish off the deflate stream at the end */\n-local void gztack(char *name, int gd, z_stream *strm, int last)\n-{\n-    int fd, len, ret;\n-    unsigned left;\n-    unsigned char *in, *out;\n-\n-    /* open file to compress and append */\n-    fd = 0;\n-    if (name != NULL) {\n-        fd = open(name, O_RDONLY, 0);\n-        if (fd == -1)\n-            fprintf(stderr, \"gzappend warning: %s not found, skipping ...\\n\",\n-                    name);\n-    }\n-\n-    /* allocate buffers */\n-    in = fd == -1 ? NULL : malloc(CHUNK);\n-    out = malloc(CHUNK);\n-    if (out == NULL) bye(\"out of memory\", \"\");\n-\n-    /* compress input file and append to gzip file */\n-    do {\n-        /* get more input */\n-        len = fd == -1 ? 0 : read(fd, in, CHUNK);\n-        if (len == -1) {\n-            fprintf(stderr,\n-                    \"gzappend warning: error reading %s, skipping rest ...\\n\",\n-                    name);\n-            len = 0;\n-        }\n-        strm->avail_in = (unsigned)len;\n-        strm->next_in = in;\n-        if (len) strm->adler = crc32(strm->adler, in, (unsigned)len);\n-\n-        /* compress and write all available output */\n-        do {\n-            strm->avail_out = CHUNK;\n-            strm->next_out = out;\n-            ret = deflate(strm, last && len == 0 ? Z_FINISH : Z_NO_FLUSH);\n-            left = CHUNK - strm->avail_out;\n-            while (left) {\n-                len = write(gd, out + CHUNK - strm->avail_out - left, left);\n-                if (len == -1) bye(\"writing gzip file\", \"\");\n-                left -= (unsigned)len;\n-            }\n-        } while (strm->avail_out == 0 && ret != Z_STREAM_END);\n-    } while (len != 0);\n-\n-    /* write trailer after last entry */\n-    if (last) {\n-        deflateEnd(strm);\n-        out[0] = (unsigned char)(strm->adler);\n-        out[1] = (unsigned char)(strm->adler >> 8);\n-        out[2] = (unsigned char)(strm->adler >> 16);\n-        out[3] = (unsigned char)(strm->adler >> 24);\n-        out[4] = (unsigned char)(strm->total_in);\n-        out[5] = (unsigned char)(strm->total_in >> 8);\n-        out[6] = (unsigned char)(strm->total_in >> 16);\n-        out[7] = (unsigned char)(strm->total_in >> 24);\n-        len = 8;\n-        do {\n-            ret = write(gd, out + 8 - len, len);\n-            if (ret == -1) bye(\"writing gzip file\", \"\");\n-            len -= ret;\n-        } while (len);\n-        close(gd);\n-    }\n-\n-    /* clean up and return */\n-    free(out);\n-    if (in != NULL) free(in);\n-    if (fd > 0) close(fd);\n-}\n-\n-/* process the compression level option if present, scan the gzip file, and\n-   append the specified files, or append the data from stdin if no other file\n-   names are provided on the command line -- the gzip file must be writable\n-   and seekable */\n-int main(int argc, char **argv)\n-{\n-    int gd, level;\n-    z_stream strm;\n-\n-    /* ignore command name */\n-    argv++;\n-\n-    /* provide usage if no arguments */\n-    if (*argv == NULL) {\n-        printf(\"gzappend 1.1 (4 Nov 2003) Copyright (C) 2003 Mark Adler\\n\");\n-        printf(\n-            \"usage: gzappend [-level] file.gz [ addthis [ andthis ... ]]\\n\");\n-        return 0;\n-    }\n-\n-    /* set compression level */\n-    level = Z_DEFAULT_COMPRESSION;\n-    if (argv[0][0] == '-') {\n-        if (argv[0][1] < '0' || argv[0][1] > '9' || argv[0][2] != 0)\n-            bye(\"invalid compression level\", \"\");\n-        level = argv[0][1] - '0';\n-        if (*++argv == NULL) bye(\"no gzip file name after options\", \"\");\n-    }\n-\n-    /* prepare to append to gzip file */\n-    gd = gzscan(*argv++, &strm, level);\n-\n-    /* append files on command line, or from stdin if none */\n-    if (*argv == NULL)\n-        gztack(NULL, gd, &strm, 1);\n-    else\n-        do {\n-            gztack(*argv, gd, &strm, argv[1] == NULL);\n-        } while (*++argv != NULL);\n-    return 0;\n-}"}, {"sha": "50ca6a9e0f32f0a000f796f5d5d60fd36a36014d", "filename": "zlib/contrib/minizip/ChangeLogUnzip", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fminizip%2FChangeLogUnzip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fminizip%2FChangeLogUnzip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2FChangeLogUnzip?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,3 +1,15 @@\n+Change in 1.01e (12 feb 05)\n+- Fix in zipOpen2 for globalcomment (Rolf Kalbermatter)\n+- Fix possible memory leak in unzip.c (Zoran Stevanovic)\n+\n+Change in 1.01b (20 may 04)\n+- Integrate patch from Debian package (submited by Mark Brown)\n+- Add tools mztools from Xavier Roche\n+\n+Change in 1.01 (8 may 04)\n+- fix buffer overrun risk in unzip.c (Xavier Roche)\n+- fix a minor buffer insecurity in minizip.c (Mike Whittaker)\n+\n Change in 1.00: (10 sept 03)\n - rename to 1.00\n - cosmetic code change"}, {"sha": "f599938884eb7e470d430857e362024d30c2e6b2", "filename": "zlib/contrib/minizip/miniunz.c", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fminizip%2Fminiunz.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fminizip%2Fminiunz.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fminiunz.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,3 +1,11 @@\n+/*\n+   miniunz.c\n+   Version 1.01e, February 12th, 2005\n+\n+   Copyright (C) 1998-2005 Gilles Vollant\n+*/\n+\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n@@ -27,7 +35,7 @@\n   mini unzip, demo of unzip package\n \n   usage :\n-  Usage : miniunz [-exvlo] file.zip [file_to_extract]\n+  Usage : miniunz [-exvlo] file.zip [file_to_extract] [-d extractdir]\n \n   list the file in the zipfile, and print the content of FILE_ID.ZIP or README.TXT\n     if it exists\n@@ -140,17 +148,18 @@ int makedir (newdir)\n \n void do_banner()\n {\n-    printf(\"MiniUnz 1.00, demo of zLib + Unz package written by Gilles Vollant\\n\");\n+    printf(\"MiniUnz 1.01b, demo of zLib + Unz package written by Gilles Vollant\\n\");\n     printf(\"more info at http://www.winimage.com/zLibDll/unzip.html\\n\\n\");\n }\n \n void do_help()\n {\n-    printf(\"Usage : miniunz [-e] [-x] [-v] [-l] [-o] [-p password] file.zip [file_to_extr.]\\n\\n\" \\\n+    printf(\"Usage : miniunz [-e] [-x] [-v] [-l] [-o] [-p password] file.zip [file_to_extr.] [-d extractdir]\\n\\n\" \\\n            \"  -e  Extract without pathname (junk paths)\\n\" \\\n            \"  -x  Extract with pathname\\n\" \\\n            \"  -v  list files\\n\" \\\n            \"  -l  list files\\n\" \\\n+           \"  -d  directory to extract into\\n\" \\\n            \"  -o  overwrite files without prompting\\n\" \\\n            \"  -p  extract crypted file using password\\n\\n\");\n }\n@@ -304,8 +313,14 @@ int do_extract_currentfile(uf,popt_extract_without_path,popt_overwrite,password)\n                 do\n                 {\n                     char answer[128];\n-                    printf(\"The file %s exist. Overwrite ? [y]es, [n]o, [A]ll: \",write_filename);\n-                    scanf(\"%1s\",answer);\n+                    int ret;\n+\n+                    printf(\"The file %s exists. Overwrite ? [y]es, [n]o, [A]ll: \",write_filename);\n+                    ret = scanf(\"%1s\",answer);\n+                    if (ret != 1) \n+                    {\n+                       exit(EXIT_FAILURE);\n+                    }\n                     rep = answer[0] ;\n                     if ((rep>='a') && (rep<='z'))\n                         rep -= 0x20;\n@@ -459,6 +474,8 @@ int main(argc,argv)\n     int opt_do_extract=1;\n     int opt_do_extract_withoutpath=0;\n     int opt_overwrite=0;\n+    int opt_extractdir=0;\n+    const char *dirname=NULL;\n     unzFile uf=NULL;\n \n     do_banner();\n@@ -488,6 +505,12 @@ int main(argc,argv)\n                         opt_do_extract = opt_do_extract_withoutpath = 1;\n                     if ((c=='o') || (c=='O'))\n                         opt_overwrite=1;\n+                    if ((c=='d') || (c=='D'))\n+                    {\n+                        opt_extractdir=1;\n+                        dirname=argv[i+1];\n+                    }\n+\n                     if (((c=='p') || (c=='P')) && (i+1<argc))\n                     {\n                         password=argv[i+1];\n@@ -499,7 +522,7 @@ int main(argc,argv)\n             {\n                 if (zipfilename == NULL)\n                     zipfilename = argv[i];\n-                else if (filename_to_extract==NULL)\n+                else if ((filename_to_extract==NULL) && (!opt_extractdir))\n                         filename_to_extract = argv[i] ;\n             }\n         }\n@@ -544,6 +567,12 @@ int main(argc,argv)\n         return do_list(uf);\n     else if (opt_do_extract==1)\n     {\n+        if (opt_extractdir && chdir(dirname)) \n+        {\n+          printf(\"Error changing into %s, aborting\\n\", dirname);\n+          exit(-1);\n+        }\n+\n         if (filename_to_extract == NULL)\n             return do_extract(uf,opt_do_extract_withoutpath,opt_overwrite,password);\n         else"}, {"sha": "f2dfecd8b1217499eb136cd43227f929415a3282", "filename": "zlib/contrib/minizip/minizip.c", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fminizip%2Fminizip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fminizip%2Fminizip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fminizip.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,3 +1,10 @@\n+/*\n+   minizip.c\n+   Version 1.01e, February 12th, 2005\n+\n+   Copyright (C) 1998-2005 Gilles Vollant\n+*/\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n@@ -53,8 +60,8 @@ uLong filetime(f, tmzip, dt)\n #else\n #ifdef unix\n uLong filetime(f, tmzip, dt)\n-    char *f;                /* name of file to get info on */\n-    tm_zip *tmzip;             /* return value: access, modific. and creation times */\n+    char *f;               /* name of file to get info on */\n+    tm_zip *tmzip;         /* return value: access, modific. and creation times */\n     uLong *dt;             /* dostime */\n {\n   int ret=0;\n@@ -66,6 +73,8 @@ uLong filetime(f, tmzip, dt)\n   {\n     char name[MAXFILENAME+1];\n     int len = strlen(f);\n+    if (len > MAXFILENAME)\n+      len = MAXFILENAME;\n \n     strncpy(name, f,MAXFILENAME-1);\n     /* strncpy doesnt append the trailing NULL, of the string is too long. */\n@@ -120,7 +129,7 @@ int check_exist_file(filename)\n \n void do_banner()\n {\n-    printf(\"MiniZip 1.00, demo of zLib + Zip package written by Gilles Vollant\\n\");\n+    printf(\"MiniZip 1.01b, demo of zLib + Zip package written by Gilles Vollant\\n\");\n     printf(\"more info at http://www.winimage.com/zLibDll/unzip.html\\n\\n\");\n }\n \n@@ -269,8 +278,13 @@ int main(argc,argv)\n                 do\n                 {\n                     char answer[128];\n-                    printf(\"The file %s exist. Overwrite ? [y]es, [n]o, [a]ppend : \",filename_try);\n-                    scanf(\"%1s\",answer);\n+                    int ret;\n+                    printf(\"The file %s exists. Overwrite ? [y]es, [n]o, [a]ppend : \",filename_try);\n+                    ret = scanf(\"%1s\",answer);\n+                    if (ret != 1)\n+                    {\n+                       exit(EXIT_FAILURE);\n+                    }\n                     rep = answer[0] ;\n                     if ((rep>='a') && (rep<='z'))\n                         rep -= 0x20;\n@@ -305,7 +319,12 @@ int main(argc,argv)\n \n         for (i=zipfilenamearg+1;(i<argc) && (err==ZIP_OK);i++)\n         {\n-            if (((*(argv[i]))!='-') && ((*(argv[i]))!='/'))\n+            if (!((((*(argv[i]))=='-') || ((*(argv[i]))=='/')) &&\n+                  ((argv[i][1]=='o') || (argv[i][1]=='O') ||\n+                   (argv[i][1]=='a') || (argv[i][1]=='A') ||\n+                   (argv[i][1]=='p') || (argv[i][1]=='P') ||\n+                   ((argv[i][1]>='0') || (argv[i][1]<='9'))) &&\n+                  (strlen(argv[i]) == 2)))\n             {\n                 FILE * fin;\n                 int size_read;\n@@ -390,7 +409,11 @@ int main(argc,argv)\n         errclose = zipClose(zf,NULL);\n         if (errclose != ZIP_OK)\n             printf(\"error in closing %s\\n\",filename_try);\n-   }\n+    }\n+    else\n+    {\n+       do_help();\n+    }\n \n     free(buf);\n     return 0;"}, {"sha": "9ad4766d8db3e70080cc34ebe04f7c54449709a0", "filename": "zlib/contrib/minizip/unzip.c", "status": "modified", "additions": 59, "deletions": 7, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fminizip%2Funzip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fminizip%2Funzip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Funzip.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,7 +1,7 @@\n /* unzip.c -- IO for uncompress .zip files using zlib\n-   Version 1.00, September 10th, 2003\n+   Version 1.01e, February 12th, 2005\n \n-   Copyright (C) 1998-2003 Gilles Vollant\n+   Copyright (C) 1998-2005 Gilles Vollant\n \n    Read unzip.h for more info\n */\n@@ -88,7 +88,7 @@ woven in by Terry Thorsen 1/2003.\n \n \n const char unz_copyright[] =\n-   \" unzip 1.00 Copyright 1998-2003 Gilles Vollant - http://www.winimage.com/zLibDll\";\n+   \" unzip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll\";\n \n /* unz_file_info_interntal contain internal info about a file in zipfile*/\n typedef struct unz_file_info_internal_s\n@@ -798,7 +798,8 @@ extern int ZEXPORT unzGoToNextFile (file)\n     s=(unz_s*)file;\n     if (!s->current_file_ok)\n         return UNZ_END_OF_LIST_OF_FILE;\n-    if (s->num_file+1==s->gi.number_entry)\n+    if (s->gi.number_entry != 0xffff)    /* 2^16 files overflow hack */\n+      if (s->num_file+1==s->gi.number_entry)\n         return UNZ_END_OF_LIST_OF_FILE;\n \n     s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +\n@@ -1136,7 +1137,10 @@ extern int ZEXPORT unzOpenCurrentFile3 (file, method, level, raw, password)\n       if (err == Z_OK)\n         pfile_in_zip_read_info->stream_initialised=1;\n       else\n+      {\n+        TRYFREE(pfile_in_zip_read_info);\n         return err;\n+      }\n         /* windowBits is passed < 0 to tell that there is no zlib header.\n          * Note that in this case inflate *requires* an extra \"dummy\" byte\n          * after the compressed stream in order to complete decompression and\n@@ -1244,9 +1248,17 @@ extern int ZEXPORT unzReadCurrentFile  (file, buf, len)\n \n     pfile_in_zip_read_info->stream.avail_out = (uInt)len;\n \n-    if (len>pfile_in_zip_read_info->rest_read_uncompressed)\n+    if ((len>pfile_in_zip_read_info->rest_read_uncompressed) &&\n+        (!(pfile_in_zip_read_info->raw)))\n+        pfile_in_zip_read_info->stream.avail_out =\n+            (uInt)pfile_in_zip_read_info->rest_read_uncompressed;\n+\n+    if ((len>pfile_in_zip_read_info->rest_read_compressed+\n+           pfile_in_zip_read_info->stream.avail_in) &&\n+         (pfile_in_zip_read_info->raw))\n         pfile_in_zip_read_info->stream.avail_out =\n-          (uInt)pfile_in_zip_read_info->rest_read_uncompressed;\n+            (uInt)pfile_in_zip_read_info->rest_read_compressed+\n+            pfile_in_zip_read_info->stream.avail_in;\n \n     while (pfile_in_zip_read_info->stream.avail_out>0)\n     {\n@@ -1339,6 +1351,9 @@ extern int ZEXPORT unzReadCurrentFile  (file, buf, len)\n             */\n             err=inflate(&pfile_in_zip_read_info->stream,flush);\n \n+            if ((err>=0) && (pfile_in_zip_read_info->stream.msg!=NULL))\n+              err = Z_DATA_ERROR;\n+\n             uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;\n             uOutThis = uTotalOutAfter-uTotalOutBefore;\n \n@@ -1461,7 +1476,7 @@ extern int ZEXPORT unzGetLocalExtrafield (file,buf,len)\n \n     if (ZREAD(pfile_in_zip_read_info->z_filefunc,\n               pfile_in_zip_read_info->filestream,\n-              buf,size_to_read)!=size_to_read)\n+              buf,read_now)!=read_now)\n         return UNZ_ERRNO;\n \n     return (int)read_now;\n@@ -1544,3 +1559,40 @@ extern int ZEXPORT unzGetGlobalComment (file, szComment, uSizeBuf)\n         *(szComment+s->gi.size_comment)='\\0';\n     return (int)uReadThis;\n }\n+\n+/* Additions by RX '2004 */\n+extern uLong ZEXPORT unzGetOffset (file)\n+    unzFile file;\n+{\n+    unz_s* s;\n+\n+    if (file==NULL)\n+          return UNZ_PARAMERROR;\n+    s=(unz_s*)file;\n+    if (!s->current_file_ok)\n+      return 0;\n+    if (s->gi.number_entry != 0 && s->gi.number_entry != 0xffff)\n+      if (s->num_file==s->gi.number_entry)\n+         return 0;\n+    return s->pos_in_central_dir;\n+}\n+\n+extern int ZEXPORT unzSetOffset (file, pos)\n+        unzFile file;\n+        uLong pos;\n+{\n+    unz_s* s;\n+    int err;\n+\n+    if (file==NULL)\n+        return UNZ_PARAMERROR;\n+    s=(unz_s*)file;\n+\n+    s->pos_in_central_dir = pos;\n+    s->num_file = s->gi.number_entry;      /* hack */\n+    err = unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n+                                              &s->cur_file_info_internal,\n+                                              NULL,0,NULL,0,NULL,0);\n+    s->current_file_ok = (err == UNZ_OK);\n+    return err;\n+}"}, {"sha": "b247937c8078a94447eb2f047a01590b1aee3381", "filename": "zlib/contrib/minizip/unzip.h", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fminizip%2Funzip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fminizip%2Funzip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Funzip.h?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,11 +1,13 @@\n /* unzip.h -- IO for uncompress .zip files using zlib\n-   Version 1.00, September 10th, 2003\n+   Version 1.01e, February 12th, 2005\n \n-   Copyright (C) 1998-2003 Gilles Vollant\n+   Copyright (C) 1998-2005 Gilles Vollant\n \n    This unzip package allow extract file from .ZIP file, compatible with PKZip 2.04g\n      WinZip, InfoZip tools and compatible.\n-   Encryption and multi volume ZipFile (span) are not supported.\n+\n+   Multi volume ZipFile (span) are not supported.\n+   Encryption compatible with pkzip 2.04g only supported\n    Old compressions used by old PKZip 1.x are not supported\n \n \n@@ -335,6 +337,16 @@ extern int ZEXPORT unzGetLocalExtrafield OF((unzFile file,\n     the error code\n */\n \n+/***************************************************************************/\n+\n+/* Get the current file offset */\n+extern uLong ZEXPORT unzGetOffset (unzFile file);\n+\n+/* Set the current file offset */\n+extern int ZEXPORT unzSetOffset (unzFile file, uLong pos);\n+\n+\n+\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "7fbe0027437e794f14fd1f1d4287970d46573103", "filename": "zlib/contrib/minizip/zip.c", "status": "modified", "additions": 60, "deletions": 11, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fminizip%2Fzip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fminizip%2Fzip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fzip.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,7 +1,10 @@\n /* zip.c -- IO on .zip files using zlib\n-   Version 1.00, September 10th, 2003\n+   Version 1.01e, February 12th, 2005\n \n-   Copyright (C) 1998-2003 Gilles Vollant\n+   27 Dec 2004 Rolf Kalbermatter\n+   Modification to zipOpen2 to support globalComment retrieval.\n+\n+   Copyright (C) 1998-2005 Gilles Vollant\n \n    Read zip.h for more info\n */\n@@ -77,7 +80,7 @@\n #endif\n #endif\n const char zip_copyright[] =\n-   \" zip 1.00 Copyright 1998-2003 Gilles Vollant - http://www.winimage.com/zLibDll\";\n+   \" zip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll\";\n \n \n #define SIZEDATA_INDATABLOCK (4096-(4*4))\n@@ -143,6 +146,9 @@ typedef struct\n     uLong begin_pos;            /* position of the beginning of the zipfile */\n     uLong add_position_when_writting_offset;\n     uLong number_entry;\n+#ifndef NO_ADDFILEINEXISTINGZIP\n+    char *globalcomment;\n+#endif\n } zip_internal;\n \n \n@@ -265,10 +271,19 @@ local int ziplocal_putValue (pzlib_filefunc_def, filestream, x, nbByte)\n {\n     unsigned char buf[4];\n     int n;\n-    for (n = 0; n < nbByte; n++) {\n+    for (n = 0; n < nbByte; n++)\n+    {\n         buf[n] = (unsigned char)(x & 0xff);\n         x >>= 8;\n     }\n+    if (x != 0)\n+      {     /* data overflow - hack for ZIP64 (X Roche) */\n+      for (n = 0; n < nbByte; n++)\n+        {\n+          buf[n] = 0xff;\n+        }\n+      }\n+\n     if (ZWRITE(*pzlib_filefunc_def,filestream,buf,nbByte)!=(uLong)nbByte)\n         return ZIP_ERRNO;\n     else\n@@ -287,7 +302,16 @@ local void ziplocal_putValue_inmemory (dest, x, nbByte)\n         buf[n] = (unsigned char)(x & 0xff);\n         x >>= 8;\n     }\n+\n+    if (x != 0)\n+    {     /* data overflow - hack for ZIP64 */\n+       for (n = 0; n < nbByte; n++)\n+       {\n+          buf[n] = 0xff;\n+       }\n+    }\n }\n+\n /****************************************************************************/\n \n \n@@ -514,6 +538,7 @@ extern zipFile ZEXPORT zipOpen2 (pathname, append, globalcomment, pzlib_filefunc\n \n     /* now we add file in a zipfile */\n #    ifndef NO_ADDFILEINEXISTINGZIP\n+    ziinit.globalcomment = NULL;\n     if (append == APPEND_STATUS_ADDINZIP)\n     {\n         uLong byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/\n@@ -574,7 +599,7 @@ extern zipFile ZEXPORT zipOpen2 (pathname, append, globalcomment, pzlib_filefunc\n         if (ziplocal_getLong(&ziinit.z_filefunc, ziinit.filestream,&offset_central_dir)!=ZIP_OK)\n             err=ZIP_ERRNO;\n \n-        /* zipfile comment length */\n+        /* zipfile global comment length */\n         if (ziplocal_getShort(&ziinit.z_filefunc, ziinit.filestream,&size_comment)!=ZIP_OK)\n             err=ZIP_ERRNO;\n \n@@ -588,9 +613,19 @@ extern zipFile ZEXPORT zipOpen2 (pathname, append, globalcomment, pzlib_filefunc\n             return NULL;\n         }\n \n+        if (size_comment>0)\n+        {\n+            ziinit.globalcomment = ALLOC(size_comment+1);\n+            if (ziinit.globalcomment)\n+            {\n+               size_comment = ZREAD(ziinit.z_filefunc, ziinit.filestream,ziinit.globalcomment,size_comment);\n+               ziinit.globalcomment[size_comment]=0;\n+            }\n+        }\n+\n         byte_before_the_zipfile = central_pos -\n                                 (offset_central_dir+size_central_dir);\n-        ziinit.add_position_when_writting_offset = byte_before_the_zipfile ;\n+        ziinit.add_position_when_writting_offset = byte_before_the_zipfile;\n \n         {\n             uLong size_central_dir_to_read = size_central_dir;\n@@ -623,10 +658,18 @@ extern zipFile ZEXPORT zipOpen2 (pathname, append, globalcomment, pzlib_filefunc\n                   offset_central_dir+byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)\n             err=ZIP_ERRNO;\n     }\n+\n+    if (globalcomment)\n+    {\n+      *globalcomment = ziinit.globalcomment;\n+    }\n #    endif /* !NO_ADDFILEINEXISTINGZIP*/\n \n     if (err != ZIP_OK)\n     {\n+#    ifndef NO_ADDFILEINEXISTINGZIP\n+        TRYFREE(ziinit.globalcomment);\n+#    endif /* !NO_ADDFILEINEXISTINGZIP*/\n         TRYFREE(zi);\n         return NULL;\n     }\n@@ -699,9 +742,9 @@ extern int ZEXPORT zipOpenNewFileInZip3 (file, filename, zipfi,\n     if (comment==NULL)\n         size_comment = 0;\n     else\n-        size_comment = strlen(comment);\n+        size_comment = (uInt)strlen(comment);\n \n-    size_filename = strlen(filename);\n+    size_filename = (uInt)strlen(filename);\n \n     if (zipfi == NULL)\n         zi->ci.dosDate = 0;\n@@ -1094,7 +1137,7 @@ extern int ZEXPORT zipClose (file, global_comment)\n     zip_internal* zi;\n     int err = 0;\n     uLong size_centraldir = 0;\n-    uLong centraldir_pos_inzip ;\n+    uLong centraldir_pos_inzip;\n     uInt size_global_comment;\n     if (file == NULL)\n         return ZIP_PARAMERROR;\n@@ -1105,11 +1148,14 @@ extern int ZEXPORT zipClose (file, global_comment)\n         err = zipCloseFileInZip (file);\n     }\n \n+#ifndef NO_ADDFILEINEXISTINGZIP\n+    if (global_comment==NULL)\n+        global_comment = zi->globalcomment;\n+#endif\n     if (global_comment==NULL)\n         size_global_comment = 0;\n     else\n-        size_global_comment = strlen(global_comment);\n-\n+        size_global_comment = (uInt)strlen(global_comment);\n \n     centraldir_pos_inzip = ZTELL(zi->z_filefunc,zi->filestream);\n     if (err==ZIP_OK)\n@@ -1164,6 +1210,9 @@ extern int ZEXPORT zipClose (file, global_comment)\n         if (err == ZIP_OK)\n             err = ZIP_ERRNO;\n \n+#ifndef NO_ADDFILEINEXISTINGZIP\n+    TRYFREE(zi->globalcomment);\n+#endif\n     TRYFREE(zi);\n \n     return err;"}, {"sha": "acacce83b9b548feca8c6a314a1a6c4ebeb9102a", "filename": "zlib/contrib/minizip/zip.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fminizip%2Fzip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fminizip%2Fzip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fzip.h?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,11 +1,12 @@\n /* zip.h -- IO for compress .zip files using zlib\n-   Version 1.00, September 10th, 2003\n+   Version 1.01e, February 12th, 2005\n \n-   Copyright (C) 1998-2003 Gilles Vollant\n+   Copyright (C) 1998-2005 Gilles Vollant\n \n    This unzip package allow creates .ZIP file, compatible with PKZip 2.04g\n      WinZip, InfoZip tools and compatible.\n-   Encryption and multi volume ZipFile (span) are not supported.\n+   Multi volume ZipFile (span) are not supported.\n+   Encryption compatible with pkzip 2.04g only supported\n    Old compressions used by old PKZip 1.x are not supported\n \n   For uncompress .zip file, look at unzip.h\n@@ -212,7 +213,6 @@ extern int ZEXPORT zipCloseFileInZip OF((zipFile file));\n   Close the current file in the zipfile\n */\n \n-\n extern int ZEXPORT zipCloseFileInZipRaw OF((zipFile file,\n                                             uLong uncompressed_size,\n                                             uLong crc32));"}, {"sha": "86da7163d16ef033906f7ec22d14bf248a814af1", "filename": "zlib/contrib/testzlib/testzlib.sln", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.sln", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.sln", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.sln?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,21 +0,0 @@\n-Microsoft Visual Studio Solution File, Format Version 7.00\r\n-Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"testzlib\", \"testzlib.vcproj\", \"{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}\"\r\n-EndProject\r\n-Global\r\n-\tGlobalSection(SolutionConfiguration) = preSolution\r\n-\t\tConfigName.0 = Debug\r\n-\t\tConfigName.1 = Release\r\n-\tEndGlobalSection\r\n-\tGlobalSection(ProjectDependencies) = postSolution\r\n-\tEndGlobalSection\r\n-\tGlobalSection(ProjectConfiguration) = postSolution\r\n-\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug.ActiveCfg = Debug|Win32\r\n-\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug.Build.0 = Debug|Win32\r\n-\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release.ActiveCfg = Release|Win32\r\n-\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release.Build.0 = Release|Win32\r\n-\tEndGlobalSection\r\n-\tGlobalSection(ExtensibilityGlobals) = postSolution\r\n-\tEndGlobalSection\r\n-\tGlobalSection(ExtensibilityAddIns) = postSolution\r\n-\tEndGlobalSection\r\n-EndGlobal\r"}, {"sha": "bd9b39bb9d785e1252ba5a20e811832b68f5ee78", "filename": "zlib/contrib/testzlib/testzlib.vcproj", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.vcproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.vcproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.vcproj?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,124 +0,0 @@\n-<?xml version=\"1.0\" encoding = \"Windows-1252\"?>\r\n-<VisualStudioProject\r\n-\tProjectType=\"Visual C++\"\r\n-\tVersion=\"7.00\"\r\n-\tName=\"testzlib\"\r\n-\tProjectGUID=\"{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}\"\r\n-\tKeyword=\"Win32Proj\">\r\n-\t<Platforms>\r\n-\t\t<Platform\r\n-\t\t\tName=\"Win32\"/>\r\n-\t</Platforms>\r\n-\t<Configurations>\r\n-\t\t<Configuration\r\n-\t\t\tName=\"Debug|Win32\"\r\n-\t\t\tOutputDirectory=\"Debug\"\r\n-\t\t\tIntermediateDirectory=\"Debug\"\r\n-\t\t\tConfigurationType=\"1\"\r\n-\t\t\tCharacterSet=\"2\">\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCCLCompilerTool\"\r\n-\t\t\t\tOptimization=\"0\"\r\n-\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE\"\r\n-\t\t\t\tMinimalRebuild=\"TRUE\"\r\n-\t\t\t\tBasicRuntimeChecks=\"3\"\r\n-\t\t\t\tRuntimeLibrary=\"5\"\r\n-\t\t\t\tUsePrecompiledHeader=\"0\"\r\n-\t\t\t\tWarningLevel=\"3\"\r\n-\t\t\t\tDetect64BitPortabilityProblems=\"TRUE\"\r\n-\t\t\t\tDebugInformationFormat=\"4\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCLinkerTool\"\r\n-\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n-\t\t\t\tLinkIncremental=\"2\"\r\n-\t\t\t\tGenerateDebugInformation=\"TRUE\"\r\n-\t\t\t\tProgramDatabaseFile=\"$(OutDir)/testzlib.pdb\"\r\n-\t\t\t\tSubSystem=\"1\"\r\n-\t\t\t\tTargetMachine=\"1\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCMIDLTool\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCResourceCompilerTool\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCWebDeploymentTool\"/>\r\n-\t\t</Configuration>\r\n-\t\t<Configuration\r\n-\t\t\tName=\"Release|Win32\"\r\n-\t\t\tOutputDirectory=\"Release\"\r\n-\t\t\tIntermediateDirectory=\"Release\"\r\n-\t\t\tConfigurationType=\"1\"\r\n-\t\t\tCharacterSet=\"2\">\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCCLCompilerTool\"\r\n-\t\t\t\tOptimization=\"2\"\r\n-\t\t\t\tInlineFunctionExpansion=\"1\"\r\n-\t\t\t\tOmitFramePointers=\"TRUE\"\r\n-\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE\"\r\n-\t\t\t\tStringPooling=\"TRUE\"\r\n-\t\t\t\tRuntimeLibrary=\"4\"\r\n-\t\t\t\tEnableFunctionLevelLinking=\"TRUE\"\r\n-\t\t\t\tUsePrecompiledHeader=\"0\"\r\n-\t\t\t\tWarningLevel=\"3\"\r\n-\t\t\t\tDetect64BitPortabilityProblems=\"TRUE\"\r\n-\t\t\t\tDebugInformationFormat=\"3\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCLinkerTool\"\r\n-\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n-\t\t\t\tLinkIncremental=\"1\"\r\n-\t\t\t\tGenerateDebugInformation=\"TRUE\"\r\n-\t\t\t\tSubSystem=\"1\"\r\n-\t\t\t\tOptimizeReferences=\"2\"\r\n-\t\t\t\tEnableCOMDATFolding=\"2\"\r\n-\t\t\t\tOptimizeForWindows98=\"1\"\r\n-\t\t\t\tTargetMachine=\"1\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCMIDLTool\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCResourceCompilerTool\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n-\t\t\t<Tool\r\n-\t\t\t\tName=\"VCWebDeploymentTool\"/>\r\n-\t\t</Configuration>\r\n-\t</Configurations>\r\n-\t<Files>\r\n-\t\t<Filter\r\n-\t\t\tName=\"Source Files\"\r\n-\t\t\tFilter=\"cpp;c;cxx;def;odl;idl;hpj;bat;asm\">\r\n-\t\t\t<File\r\n-\t\t\t\tRelativePath=\"testzlib.c\">\r\n-\t\t\t</File>\r\n-\t\t</Filter>\r\n-\t\t<Filter\r\n-\t\t\tName=\"Header Files\"\r\n-\t\t\tFilter=\"h;hpp;hxx;hm;inl;inc\">\r\n-\t\t</Filter>\r\n-\t\t<Filter\r\n-\t\t\tName=\"Resource Files\"\r\n-\t\t\tFilter=\"rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe\">\r\n-\t\t</Filter>\r\n-\t\t<File\r\n-\t\t\tRelativePath=\"zlibwapi.lib\">\r\n-\t\t</File>\r\n-\t</Files>\r\n-\t<Globals>\r\n-\t</Globals>\r\n-</VisualStudioProject>\r"}, {"sha": "2c391e5986753de7b6d9eeccfe919d543698925f", "filename": "zlib/contrib/untgz/untgz.c", "status": "modified", "additions": 120, "deletions": 15, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Funtgz%2Funtgz.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Funtgz%2Funtgz.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Funtgz%2Funtgz.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,7 +1,7 @@\n /*\n  * untgz.c -- Display contents and extract files from a gzip'd TAR file\n  *\n- * written by \"Pedro A. Aranda Guti\\irrez\" <paag@tid.es>\n+ * written by Pedro A. Aranda Gutierrez <paag@tid.es>\n  * adaptation to Unix by Jean-loup Gailly <jloup@gzip.org>\n  * various fixes by Cosmin Truta <cosmint@cs.ubbcluj.ro>\n  */\n@@ -15,10 +15,10 @@\n #include \"zlib.h\"\n \n #ifdef unix\n-# include <unistd.h>\n+#  include <unistd.h>\n #else\n-# include <direct.h>\n-# include <io.h>\n+#  include <direct.h>\n+#  include <io.h>\n #endif\n \n #ifdef WIN32\n@@ -28,8 +28,9 @@\n #  endif\n #  define mkdir(dirname,mode)   _mkdir(dirname)\n #  ifdef _MSC_VER\n-#    define strdup(str)         _strdup(str)\n #    define access(path,mode)   _access(path,mode)\n+#    define chmod(path,mode)    _chmod(path,mode)\n+#    define strdup(str)         _strdup(str)\n #  endif\n #else\n #  include <utime.h>\n@@ -48,7 +49,21 @@\n #define FIFOTYPE '6'            /* FIFO special */\n #define CONTTYPE '7'            /* reserved */\n \n-#define BLOCKSIZE 512\n+/* GNU tar extensions */\n+\n+#define GNUTYPE_DUMPDIR  'D'    /* file names from dumped directory */\n+#define GNUTYPE_LONGLINK 'K'    /* long link name */\n+#define GNUTYPE_LONGNAME 'L'    /* long file name */\n+#define GNUTYPE_MULTIVOL 'M'    /* continuation of file from another volume */\n+#define GNUTYPE_NAMES    'N'    /* file name that does not fit into main hdr */\n+#define GNUTYPE_SPARSE   'S'    /* sparse file */\n+#define GNUTYPE_VOLHDR   'V'    /* tape/volume header */\n+\n+\n+/* tar header */\n+\n+#define BLOCKSIZE     512\n+#define SHORTNAMESIZE 100\n \n struct tar_header\n {                               /* byte offset */\n@@ -71,11 +86,20 @@ struct tar_header\n                                 /* 500 */\n };\n \n-union tar_buffer {\n+union tar_buffer\n+{\n   char               buffer[BLOCKSIZE];\n   struct tar_header  header;\n };\n \n+struct attr_item\n+{\n+  struct attr_item  *next;\n+  char              *fname;\n+  int                mode;\n+  time_t             time;\n+};\n+\n enum { TGZ_EXTRACT, TGZ_LIST, TGZ_INVALID };\n \n char *TGZfname          OF((const char *));\n@@ -84,6 +108,9 @@ void TGZnotfound        OF((const char *));\n int getoct              OF((char *, int));\n char *strtime           OF((time_t *));\n int setfiletime         OF((char *, time_t));\n+void push_attr          OF((struct attr_item **, char *, int, time_t));\n+void restore_attr       OF((struct attr_item **));\n+\n int ExprMatch           OF((char *, char *));\n \n int makedir             OF((char *));\n@@ -221,7 +248,42 @@ int setfiletime (char *fname,time_t ftime)\n }\n \n \n-/* regular expression matching */\n+/* push file attributes */\n+\n+void push_attr(struct attr_item **list,char *fname,int mode,time_t time)\n+{\n+  struct attr_item *item;\n+\n+  item = (struct attr_item *)malloc(sizeof(struct attr_item));\n+  if (item == NULL)\n+    error(\"Out of memory\");\n+  item->fname = strdup(fname);\n+  item->mode  = mode;\n+  item->time  = time;\n+  item->next  = *list;\n+  *list       = item;\n+}\n+\n+\n+/* restore file attributes */\n+\n+void restore_attr(struct attr_item **list)\n+{\n+  struct attr_item *item, *prev;\n+\n+  for (item = *list; item != NULL; )\n+    {\n+      setfiletime(item->fname,item->time);\n+      chmod(item->fname,item->mode);\n+      prev = item;\n+      item = item->next;\n+      free(prev);\n+    }\n+  *list = NULL;\n+}\n+\n+\n+/* match regular expression */\n \n #define ISSPECIAL(c) (((c) == '*') || ((c) == '/'))\n \n@@ -332,6 +394,7 @@ int tar (gzFile in,int action,int arg,int argc,char **argv)\n   char   fname[BLOCKSIZE];\n   int    tarmode;\n   time_t tartime;\n+  struct attr_item *attributes = NULL;\n \n   if (action == TGZ_LIST)\n     printf(\"    date      time     size                       file\\n\"\n@@ -354,14 +417,15 @@ int tar (gzFile in,int action,int arg,int argc,char **argv)\n       /*\n        * If we have to get a tar header\n        */\n-      if (getheader == 1)\n+      if (getheader >= 1)\n         {\n           /*\n            * if we met the end of the tar\n            * or the end-of-tar block,\n            * we are done\n            */\n-          if ((len == 0) || (buffer.header.name[0] == 0)) break;\n+          if (len == 0 || buffer.header.name[0] == 0)\n+            break;\n \n           tarmode = getoct(buffer.header.mode,8);\n           tartime = (time_t)getoct(buffer.header.mtime,12);\n@@ -371,8 +435,25 @@ int tar (gzFile in,int action,int arg,int argc,char **argv)\n               action = TGZ_INVALID;\n             }\n \n-          strcpy(fname,buffer.header.name);\n+          if (getheader == 1)\n+            {\n+              strncpy(fname,buffer.header.name,SHORTNAMESIZE);\n+              if (fname[SHORTNAMESIZE-1] != 0)\n+                  fname[SHORTNAMESIZE] = 0;\n+            }\n+          else\n+            {\n+              /*\n+               * The file name is longer than SHORTNAMESIZE\n+               */\n+              if (strncmp(fname,buffer.header.name,SHORTNAMESIZE-1) != 0)\n+                  error(\"bad long name\");\n+              getheader = 1;\n+            }\n \n+          /*\n+           * Act according to the type flag\n+           */\n           switch (buffer.header.typeflag)\n             {\n             case DIRTYPE:\n@@ -381,7 +462,7 @@ int tar (gzFile in,int action,int arg,int argc,char **argv)\n               if (action == TGZ_EXTRACT)\n                 {\n                   makedir(fname);\n-                  setfiletime(fname,tartime);\n+                  push_attr(&attributes,fname,tarmode,tartime);\n                 }\n               break;\n             case REGTYPE:\n@@ -419,6 +500,24 @@ int tar (gzFile in,int action,int arg,int argc,char **argv)\n                 }\n               getheader = 0;\n               break;\n+            case GNUTYPE_LONGLINK:\n+            case GNUTYPE_LONGNAME:\n+              remaining = getoct(buffer.header.size,12);\n+              if (remaining < 0 || remaining >= BLOCKSIZE)\n+                {\n+                  action = TGZ_INVALID;\n+                  break;\n+                }\n+              len = gzread(in, fname, BLOCKSIZE);\n+              if (len < 0)\n+                error(gzerror(in, &err));\n+              if (fname[BLOCKSIZE-1] != 0 || (int)strlen(fname) > remaining)\n+                {\n+                  action = TGZ_INVALID;\n+                  break;\n+                }\n+              getheader = 2;\n+              break;\n             default:\n               if (action == TGZ_LIST)\n                 printf(\" %s     <---> %s\\n\",strtime(&tartime),fname);\n@@ -433,7 +532,8 @@ int tar (gzFile in,int action,int arg,int argc,char **argv)\n             {\n               if (fwrite(&buffer,sizeof(char),bytes,outfile) != bytes)\n                 {\n-                  fprintf(stderr,\"%s: Error writing %s -- skipping\\n\",prog,fname);\n+                  fprintf(stderr,\n+                    \"%s: Error writing %s -- skipping\\n\",prog,fname);\n                   fclose(outfile);\n                   outfile = NULL;\n                   remove(fname);\n@@ -450,7 +550,7 @@ int tar (gzFile in,int action,int arg,int argc,char **argv)\n               fclose(outfile);\n               outfile = NULL;\n               if (action != TGZ_INVALID)\n-                setfiletime(fname,tartime);\n+                push_attr(&attributes,fname,tarmode,tartime);\n             }\n         }\n \n@@ -464,6 +564,11 @@ int tar (gzFile in,int action,int arg,int argc,char **argv)\n         }\n     }\n \n+  /*\n+   * Restore file modes and time stamps\n+   */\n+  restore_attr(&attributes);\n+\n   if (gzclose(in) != Z_OK)\n     error(\"failed gzclose\");\n \n@@ -475,7 +580,7 @@ int tar (gzFile in,int action,int arg,int argc,char **argv)\n \n void help(int exitval)\n {\n-  printf(\"untgz version 0.2\\n\"\n+  printf(\"untgz version 0.2.1\\n\"\n          \"  using zlib version %s\\n\\n\",\n          zlibVersion());\n   printf(\"Usage: untgz file.tgz            extract all files\\n\""}, {"sha": "57efe58124eed661c2ff5827258772ab97a44bdc", "filename": "zlib/contrib/visual-basic.txt", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fvisual-basic.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fcontrib%2Fvisual-basic.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvisual-basic.txt?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,160 +0,0 @@\n-See below some functions declarations for Visual Basic.\n-\n-Frequently Asked Question:\n-\n-Q: Each time I use the compress function I get the -5 error (not enough\n-   room in the output buffer).\n-\n-A: Make sure that the length of the compressed buffer is passed by\n-   reference (\"as any\"), not by value (\"as long\"). Also check that\n-   before the call of compress this length is equal to the total size of\n-   the compressed buffer and not zero.\n-\n-\n-From: \"Jon Caruana\" <jon-net@usa.net>\n-Subject: Re: How to port zlib declares to vb?\n-Date: Mon, 28 Oct 1996 18:33:03 -0600\n-\n-Got the answer! (I haven't had time to check this but it's what I got, and\n-looks correct):\n-\n-He has the following routines working:\n-        compress\n-        uncompress\n-        gzopen\n-        gzwrite\n-        gzread\n-        gzclose\n-\n-Declares follow: (Quoted from Carlos Rios <c_rios@sonda.cl>, in Vb4 form)\n-\n-#If Win16 Then   'Use Win16 calls.\n-Declare Function compress Lib \"ZLIB.DLL\" (ByVal compr As\n-        String, comprLen As Any, ByVal buf As String, ByVal buflen\n-        As Long) As Integer\n-Declare Function uncompress Lib \"ZLIB.DLL\" (ByVal uncompr\n-        As String, uncomprLen As Any, ByVal compr As String, ByVal\n-        lcompr As Long) As Integer\n-Declare Function gzopen Lib \"ZLIB.DLL\" (ByVal filePath As\n-        String, ByVal mode As String) As Long\n-Declare Function gzread Lib \"ZLIB.DLL\" (ByVal file As\n-        Long, ByVal uncompr As String, ByVal uncomprLen As Integer)\n-        As Integer\n-Declare Function gzwrite Lib \"ZLIB.DLL\" (ByVal file As\n-        Long, ByVal uncompr As String, ByVal uncomprLen As Integer)\n-        As Integer\n-Declare Function gzclose Lib \"ZLIB.DLL\" (ByVal file As\n-        Long) As Integer\n-#Else\n-Declare Function compress Lib \"ZLIB32.DLL\"\n-        (ByVal compr As String, comprLen As Any, ByVal buf As\n-        String, ByVal buflen As Long) As Integer\n-Declare Function uncompress Lib \"ZLIB32.DLL\"\n-        (ByVal uncompr As String, uncomprLen As Any, ByVal compr As\n-        String, ByVal lcompr As Long) As Long\n-Declare Function gzopen Lib \"ZLIB32.DLL\"\n-        (ByVal file As String, ByVal mode As String) As Long\n-Declare Function gzread Lib \"ZLIB32.DLL\"\n-        (ByVal file As Long, ByVal uncompr As String, ByVal\n-        uncomprLen As Long) As Long\n-Declare Function gzwrite Lib \"ZLIB32.DLL\"\n-        (ByVal file As Long, ByVal uncompr As String, ByVal\n-        uncomprLen As Long) As Long\n-Declare Function gzclose Lib \"ZLIB32.DLL\"\n-        (ByVal file As Long) As Long\n-#End If\n-\n--Jon Caruana\n-jon-net@usa.net\n-Microsoft Sitebuilder Network Level 1 Member - HTML Writer's Guild Member\n-\n-\n-Here is another example from Michael <michael_borgsys@hotmail.com> that he\n-says conforms to the VB guidelines, and that solves the problem of not\n-knowing the uncompressed size by storing it at the end of the file:\n-\n-'Calling the functions:\n-'bracket meaning: <parameter> [optional] {Range of possible values}\n-'Call subCompressFile(<path with filename to compress> [, <path with\n-filename to write to>, [level of compression {1..9}]])\n-'Call subUncompressFile(<path with filename to compress>)\n-\n-Option Explicit\n-Private lngpvtPcnSml As Long 'Stores value for 'lngPercentSmaller'\n-Private Const SUCCESS As Long = 0\n-Private Const strFilExt As String = \".cpr\"\n-Private Declare Function lngfncCpr Lib \"zlib.dll\" Alias \"compress2\" (ByRef\n-dest As Any, ByRef destLen As Any, ByRef src As Any, ByVal srcLen As Long,\n-ByVal level As Integer) As Long\n-Private Declare Function lngfncUcp Lib \"zlib.dll\" Alias \"uncompress\" (ByRef\n-dest As Any, ByRef destLen As Any, ByRef src As Any, ByVal srcLen As Long)\n-As Long\n-\n-Public Sub subCompressFile(ByVal strargOriFilPth As String, Optional ByVal\n-strargCprFilPth As String, Optional ByVal intLvl As Integer = 9)\n-    Dim strCprPth As String\n-    Dim lngOriSiz As Long\n-    Dim lngCprSiz As Long\n-    Dim bytaryOri() As Byte\n-    Dim bytaryCpr() As Byte\n-    lngOriSiz = FileLen(strargOriFilPth)\n-    ReDim bytaryOri(lngOriSiz - 1)\n-    Open strargOriFilPth For Binary Access Read As #1\n-        Get #1, , bytaryOri()\n-    Close #1\n-    strCprPth = IIf(strargCprFilPth = \"\", strargOriFilPth, strargCprFilPth)\n-'Select file path and name\n-    strCprPth = strCprPth & IIf(Right(strCprPth, Len(strFilExt)) =\n-strFilExt, \"\", strFilExt) 'Add file extension if not exists\n-    lngCprSiz = (lngOriSiz * 1.01) + 12 'Compression needs temporary a bit\n-more space then original file size\n-    ReDim bytaryCpr(lngCprSiz - 1)\n-    If lngfncCpr(bytaryCpr(0), lngCprSiz, bytaryOri(0), lngOriSiz, intLvl) =\n-SUCCESS Then\n-        lngpvtPcnSml = (1# - (lngCprSiz / lngOriSiz)) * 100\n-        ReDim Preserve bytaryCpr(lngCprSiz - 1)\n-        Open strCprPth For Binary Access Write As #1\n-            Put #1, , bytaryCpr()\n-            Put #1, , lngOriSiz 'Add the the original size value to the end\n-(last 4 bytes)\n-        Close #1\n-    Else\n-        MsgBox \"Compression error\"\n-    End If\n-    Erase bytaryCpr\n-    Erase bytaryOri\n-End Sub\n-\n-Public Sub subUncompressFile(ByVal strargFilPth As String)\n-    Dim bytaryCpr() As Byte\n-    Dim bytaryOri() As Byte\n-    Dim lngOriSiz As Long\n-    Dim lngCprSiz As Long\n-    Dim strOriPth As String\n-    lngCprSiz = FileLen(strargFilPth)\n-    ReDim bytaryCpr(lngCprSiz - 1)\n-    Open strargFilPth For Binary Access Read As #1\n-        Get #1, , bytaryCpr()\n-    Close #1\n-    'Read the original file size value:\n-    lngOriSiz = bytaryCpr(lngCprSiz - 1) * (2 ^ 24) _\n-              + bytaryCpr(lngCprSiz - 2) * (2 ^ 16) _\n-              + bytaryCpr(lngCprSiz - 3) * (2 ^ 8) _\n-              + bytaryCpr(lngCprSiz - 4)\n-    ReDim Preserve bytaryCpr(lngCprSiz - 5) 'Cut of the original size value\n-    ReDim bytaryOri(lngOriSiz - 1)\n-    If lngfncUcp(bytaryOri(0), lngOriSiz, bytaryCpr(0), lngCprSiz) = SUCCESS\n-Then\n-        strOriPth = Left(strargFilPth, Len(strargFilPth) - Len(strFilExt))\n-        Open strOriPth For Binary Access Write As #1\n-            Put #1, , bytaryOri()\n-        Close #1\n-    Else\n-        MsgBox \"Uncompression error\"\n-    End If\n-    Erase bytaryCpr\n-    Erase bytaryOri\n-End Sub\n-Public Property Get lngPercentSmaller() As Long\n-    lngPercentSmaller = lngpvtPcnSml\n-End Property"}, {"sha": "a40e71541f384290000fe86b79347c2da292843a", "filename": "zlib/contrib/vstudio/vc7/zlibvc.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.def?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n \r\n-VERSION\t\t1.21\r\n+VERSION\t\t1.23\r\n \r\n HEAPSIZE\t1048576,8192\r\n \r"}, {"sha": "0a85d9925e9e46c29b07b6c87aa05ed3d3388c8b", "filename": "zlib/crc32.c", "status": "modified", "additions": 145, "deletions": 33, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcrc32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fcrc32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcrc32.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,16 +1,24 @@\n /* crc32.c -- compute the CRC-32 of a data stream\n- * Copyright (C) 1995-2003 Mark Adler\n+ * Copyright (C) 1995-2005 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  *\n  * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster\n  * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing\n  * tables for updating the shift register in one step with three exclusive-ors\n- * instead of four steps with four exclusive-ors.  This results about a factor\n- * of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.\n+ * instead of four steps with four exclusive-ors.  This results in about a\n+ * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.\n  */\n \n /* @(#) $Id: crc32.c,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */\n \n+/*\n+  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore\n+  protection on the static variables used to control the first-use generation\n+  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should\n+  first call get_crc_table() to initialize the tables before allowing more than\n+  one thread to use crc32().\n+ */\n+\n #ifdef MAKECRCH\n #  include <stdio.h>\n #  ifndef DYNAMIC_CRC_TABLE\n@@ -56,15 +64,19 @@\n #  define TBLS 1\n #endif /* BYFOUR */\n \n+/* Local functions for crc concatenation */\n+local unsigned long gf2_matrix_times OF((unsigned long *mat,\n+                                         unsigned long vec));\n+local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));\n+\n #ifdef DYNAMIC_CRC_TABLE\n \n-local int crc_table_empty = 1;\n+local volatile int crc_table_empty = 1;\n local unsigned long FAR crc_table[TBLS][256];\n local void make_crc_table OF((void));\n #ifdef MAKECRCH\n    local void write_table OF((FILE *, const unsigned long FAR *));\n #endif /* MAKECRCH */\n-\n /*\n   Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:\n   x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.\n@@ -95,38 +107,51 @@ local void make_crc_table()\n {\n     unsigned long c;\n     int n, k;\n-    unsigned long poly;            /* polynomial exclusive-or pattern */\n+    unsigned long poly;                 /* polynomial exclusive-or pattern */\n     /* terms of polynomial defining this crc (except x^32): */\n+    static volatile int first = 1;      /* flag to limit concurrent making */\n     static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n \n-    /* make exclusive-or pattern from polynomial (0xedb88320UL) */\n-    poly = 0UL;\n-    for (n = 0; n < sizeof(p)/sizeof(unsigned char); n++)\n-        poly |= 1UL << (31 - p[n]);\n-\n-    /* generate a crc for every 8-bit value */\n-    for (n = 0; n < 256; n++) {\n-        c = (unsigned long)n;\n-        for (k = 0; k < 8; k++)\n-            c = c & 1 ? poly ^ (c >> 1) : c >> 1;\n-        crc_table[0][n] = c;\n-    }\n+    /* See if another task is already doing this (not thread-safe, but better\n+       than nothing -- significantly reduces duration of vulnerability in\n+       case the advice about DYNAMIC_CRC_TABLE is ignored) */\n+    if (first) {\n+        first = 0;\n+\n+        /* make exclusive-or pattern from polynomial (0xedb88320UL) */\n+        poly = 0UL;\n+        for (n = 0; n < sizeof(p)/sizeof(unsigned char); n++)\n+            poly |= 1UL << (31 - p[n]);\n+\n+        /* generate a crc for every 8-bit value */\n+        for (n = 0; n < 256; n++) {\n+            c = (unsigned long)n;\n+            for (k = 0; k < 8; k++)\n+                c = c & 1 ? poly ^ (c >> 1) : c >> 1;\n+            crc_table[0][n] = c;\n+        }\n \n #ifdef BYFOUR\n-    /* generate crc for each value followed by one, two, and three zeros, and\n-       then the byte reversal of those as well as the first table */\n-    for (n = 0; n < 256; n++) {\n-        c = crc_table[0][n];\n-        crc_table[4][n] = REV(c);\n-        for (k = 1; k < 4; k++) {\n-            c = crc_table[0][c & 0xff] ^ (c >> 8);\n-            crc_table[k][n] = c;\n-            crc_table[k + 4][n] = REV(c);\n+        /* generate crc for each value followed by one, two, and three zeros,\n+           and then the byte reversal of those as well as the first table */\n+        for (n = 0; n < 256; n++) {\n+            c = crc_table[0][n];\n+            crc_table[4][n] = REV(c);\n+            for (k = 1; k < 4; k++) {\n+                c = crc_table[0][c & 0xff] ^ (c >> 8);\n+                crc_table[k][n] = c;\n+                crc_table[k + 4][n] = REV(c);\n+            }\n         }\n-    }\n #endif /* BYFOUR */\n \n-  crc_table_empty = 0;\n+        crc_table_empty = 0;\n+    }\n+    else {      /* not first */\n+        /* wait for the other guy to finish (not efficient, but rare) */\n+        while (crc_table_empty)\n+            ;\n+    }\n \n #ifdef MAKECRCH\n     /* write out CRC tables to crc32.h */\n@@ -180,9 +205,10 @@ local void write_table(out, table)\n const unsigned long FAR * ZEXPORT get_crc_table()\n {\n #ifdef DYNAMIC_CRC_TABLE\n-  if (crc_table_empty) make_crc_table();\n+    if (crc_table_empty)\n+        make_crc_table();\n #endif /* DYNAMIC_CRC_TABLE */\n-  return (const unsigned long FAR *)crc_table;\n+    return (const unsigned long FAR *)crc_table;\n }\n \n /* ========================================================================= */\n@@ -248,7 +274,7 @@ local unsigned long crc32_little(crc, buf, len)\n         len--;\n     }\n \n-    buf4 = (const u4 FAR *)buf;\n+    buf4 = (const u4 FAR *)(const void FAR *)buf;\n     while (len >= 32) {\n         DOLIT32;\n         len -= 32;\n@@ -288,7 +314,7 @@ local unsigned long crc32_big(crc, buf, len)\n         len--;\n     }\n \n-    buf4 = (const u4 FAR *)buf;\n+    buf4 = (const u4 FAR *)(const void FAR *)buf;\n     buf4--;\n     while (len >= 32) {\n         DOBIG32;\n@@ -309,3 +335,89 @@ local unsigned long crc32_big(crc, buf, len)\n }\n \n #endif /* BYFOUR */\n+\n+#define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */\n+\n+/* ========================================================================= */\n+local unsigned long gf2_matrix_times(mat, vec)\n+    unsigned long *mat;\n+    unsigned long vec;\n+{\n+    unsigned long sum;\n+\n+    sum = 0;\n+    while (vec) {\n+        if (vec & 1)\n+            sum ^= *mat;\n+        vec >>= 1;\n+        mat++;\n+    }\n+    return sum;\n+}\n+\n+/* ========================================================================= */\n+local void gf2_matrix_square(square, mat)\n+    unsigned long *square;\n+    unsigned long *mat;\n+{\n+    int n;\n+\n+    for (n = 0; n < GF2_DIM; n++)\n+        square[n] = gf2_matrix_times(mat, mat[n]);\n+}\n+\n+/* ========================================================================= */\n+uLong ZEXPORT crc32_combine(crc1, crc2, len2)\n+    uLong crc1;\n+    uLong crc2;\n+    z_off_t len2;\n+{\n+    int n;\n+    unsigned long row;\n+    unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */\n+    unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */\n+\n+    /* degenerate case */\n+    if (len2 == 0)\n+        return crc1;\n+\n+    /* put operator for one zero bit in odd */\n+    odd[0] = 0xedb88320L;           /* CRC-32 polynomial */\n+    row = 1;\n+    for (n = 1; n < GF2_DIM; n++) {\n+        odd[n] = row;\n+        row <<= 1;\n+    }\n+\n+    /* put operator for two zero bits in even */\n+    gf2_matrix_square(even, odd);\n+\n+    /* put operator for four zero bits in odd */\n+    gf2_matrix_square(odd, even);\n+\n+    /* apply len2 zeros to crc1 (first square will put the operator for one\n+       zero byte, eight zero bits, in even) */\n+    do {\n+        /* apply zeros operator for this bit of len2 */\n+        gf2_matrix_square(even, odd);\n+        if (len2 & 1)\n+            crc1 = gf2_matrix_times(even, crc1);\n+        len2 >>= 1;\n+\n+        /* if no more bits set, then done */\n+        if (len2 == 0)\n+            break;\n+\n+        /* another iteration of the loop with odd and even swapped */\n+        gf2_matrix_square(odd, even);\n+        if (len2 & 1)\n+            crc1 = gf2_matrix_times(odd, crc1);\n+        len2 >>= 1;\n+\n+        /* if no more bits set, then done */\n+    } while (len2 != 0);\n+\n+    /* return combined crc */\n+    crc1 ^= crc2;\n+    return crc1;\n+}"}, {"sha": "1febd40adb240443a58cb5d872dd14c5aee90490", "filename": "zlib/deflate.c", "status": "modified", "additions": 258, "deletions": 24, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fdeflate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fdeflate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fdeflate.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* deflate.c -- compress data using the deflation algorithm\n- * Copyright (C) 1995-2003 Jean-loup Gailly.\n+ * Copyright (C) 1995-2005 Jean-loup Gailly.\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -52,7 +52,7 @@\n #include \"deflate.h\"\n \n const char deflate_copyright[] =\n-   \" deflate 1.2.1 Copyright 1995-2003 Jean-loup Gailly \";\n+   \" deflate 1.2.3 Copyright 1995-2005 Jean-loup Gailly \";\n /*\n   If you use the zlib library in a product, an acknowledgment is welcome\n   in the documentation of your product. If for some reason you cannot\n@@ -264,7 +264,7 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,\n #endif\n     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||\n         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n-        strategy < 0 || strategy > Z_RLE) {\n+        strategy < 0 || strategy > Z_FIXED) {\n         return Z_STREAM_ERROR;\n     }\n     if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */\n@@ -274,6 +274,7 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,\n     s->strm = strm;\n \n     s->wrap = wrap;\n+    s->gzhead = Z_NULL;\n     s->w_bits = windowBits;\n     s->w_size = 1 << s->w_bits;\n     s->w_mask = s->w_size - 1;\n@@ -333,9 +334,7 @@ int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)\n     if (length < MIN_MATCH) return Z_OK;\n     if (length > MAX_DIST(s)) {\n         length = MAX_DIST(s);\n-#ifndef USE_DICT_HEAD\n         dictionary += dictLength - length; /* use the tail of the dictionary */\n-#endif\n     }\n     zmemcpy(s->window, dictionary, length);\n     s->strstart = length;\n@@ -390,6 +389,17 @@ int ZEXPORT deflateReset (strm)\n     return Z_OK;\n }\n \n+/* ========================================================================= */\n+int ZEXPORT deflateSetHeader (strm, head)\n+    z_streamp strm;\n+    gz_headerp head;\n+{\n+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n+    if (strm->state->wrap != 2) return Z_STREAM_ERROR;\n+    strm->state->gzhead = head;\n+    return Z_OK;\n+}\n+\n /* ========================================================================= */\n int ZEXPORT deflatePrime (strm, bits, value)\n     z_streamp strm;\n@@ -420,7 +430,7 @@ int ZEXPORT deflateParams(strm, level, strategy)\n #else\n     if (level == Z_DEFAULT_COMPRESSION) level = 6;\n #endif\n-    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_RLE) {\n+    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {\n         return Z_STREAM_ERROR;\n     }\n     func = configuration_table[s->level].func;\n@@ -440,6 +450,25 @@ int ZEXPORT deflateParams(strm, level, strategy)\n     return err;\n }\n \n+/* ========================================================================= */\n+int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)\n+    z_streamp strm;\n+    int good_length;\n+    int max_lazy;\n+    int nice_length;\n+    int max_chain;\n+{\n+    deflate_state *s;\n+\n+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n+    s = strm->state;\n+    s->good_match = good_length;\n+    s->max_lazy_match = max_lazy;\n+    s->nice_match = nice_length;\n+    s->max_chain_length = max_chain;\n+    return Z_OK;\n+}\n+\n /* =========================================================================\n  * For the default windowBits of 15 and memLevel of 8, this function returns\n  * a close to exact, as well as small, upper bound on the compressed size.\n@@ -548,20 +577,47 @@ int ZEXPORT deflate (strm, flush)\n     if (s->status == INIT_STATE) {\n #ifdef GZIP\n         if (s->wrap == 2) {\n+            strm->adler = crc32(0L, Z_NULL, 0);\n             put_byte(s, 31);\n             put_byte(s, 139);\n             put_byte(s, 8);\n-            put_byte(s, 0);\n-            put_byte(s, 0);\n-            put_byte(s, 0);\n-            put_byte(s, 0);\n-            put_byte(s, 0);\n-            put_byte(s, s->level == 9 ? 2 :\n-                        (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?\n-                         4 : 0));\n-            put_byte(s, 255);\n-            s->status = BUSY_STATE;\n-            strm->adler = crc32(0L, Z_NULL, 0);\n+            if (s->gzhead == NULL) {\n+                put_byte(s, 0);\n+                put_byte(s, 0);\n+                put_byte(s, 0);\n+                put_byte(s, 0);\n+                put_byte(s, 0);\n+                put_byte(s, s->level == 9 ? 2 :\n+                            (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?\n+                             4 : 0));\n+                put_byte(s, OS_CODE);\n+                s->status = BUSY_STATE;\n+            }\n+            else {\n+                put_byte(s, (s->gzhead->text ? 1 : 0) +\n+                            (s->gzhead->hcrc ? 2 : 0) +\n+                            (s->gzhead->extra == Z_NULL ? 0 : 4) +\n+                            (s->gzhead->name == Z_NULL ? 0 : 8) +\n+                            (s->gzhead->comment == Z_NULL ? 0 : 16)\n+                        );\n+                put_byte(s, (Byte)(s->gzhead->time & 0xff));\n+                put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));\n+                put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));\n+                put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));\n+                put_byte(s, s->level == 9 ? 2 :\n+                            (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?\n+                             4 : 0));\n+                put_byte(s, s->gzhead->os & 0xff);\n+                if (s->gzhead->extra != NULL) {\n+                    put_byte(s, s->gzhead->extra_len & 0xff);\n+                    put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);\n+                }\n+                if (s->gzhead->hcrc)\n+                    strm->adler = crc32(strm->adler, s->pending_buf,\n+                                        s->pending);\n+                s->gzindex = 0;\n+                s->status = EXTRA_STATE;\n+            }\n         }\n         else\n #endif\n@@ -592,6 +648,110 @@ int ZEXPORT deflate (strm, flush)\n             strm->adler = adler32(0L, Z_NULL, 0);\n         }\n     }\n+#ifdef GZIP\n+    if (s->status == EXTRA_STATE) {\n+        if (s->gzhead->extra != NULL) {\n+            uInt beg = s->pending;  /* start of bytes to update crc */\n+\n+            while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {\n+                if (s->pending == s->pending_buf_size) {\n+                    if (s->gzhead->hcrc && s->pending > beg)\n+                        strm->adler = crc32(strm->adler, s->pending_buf + beg,\n+                                            s->pending - beg);\n+                    flush_pending(strm);\n+                    beg = s->pending;\n+                    if (s->pending == s->pending_buf_size)\n+                        break;\n+                }\n+                put_byte(s, s->gzhead->extra[s->gzindex]);\n+                s->gzindex++;\n+            }\n+            if (s->gzhead->hcrc && s->pending > beg)\n+                strm->adler = crc32(strm->adler, s->pending_buf + beg,\n+                                    s->pending - beg);\n+            if (s->gzindex == s->gzhead->extra_len) {\n+                s->gzindex = 0;\n+                s->status = NAME_STATE;\n+            }\n+        }\n+        else\n+            s->status = NAME_STATE;\n+    }\n+    if (s->status == NAME_STATE) {\n+        if (s->gzhead->name != NULL) {\n+            uInt beg = s->pending;  /* start of bytes to update crc */\n+            int val;\n+\n+            do {\n+                if (s->pending == s->pending_buf_size) {\n+                    if (s->gzhead->hcrc && s->pending > beg)\n+                        strm->adler = crc32(strm->adler, s->pending_buf + beg,\n+                                            s->pending - beg);\n+                    flush_pending(strm);\n+                    beg = s->pending;\n+                    if (s->pending == s->pending_buf_size) {\n+                        val = 1;\n+                        break;\n+                    }\n+                }\n+                val = s->gzhead->name[s->gzindex++];\n+                put_byte(s, val);\n+            } while (val != 0);\n+            if (s->gzhead->hcrc && s->pending > beg)\n+                strm->adler = crc32(strm->adler, s->pending_buf + beg,\n+                                    s->pending - beg);\n+            if (val == 0) {\n+                s->gzindex = 0;\n+                s->status = COMMENT_STATE;\n+            }\n+        }\n+        else\n+            s->status = COMMENT_STATE;\n+    }\n+    if (s->status == COMMENT_STATE) {\n+        if (s->gzhead->comment != NULL) {\n+            uInt beg = s->pending;  /* start of bytes to update crc */\n+            int val;\n+\n+            do {\n+                if (s->pending == s->pending_buf_size) {\n+                    if (s->gzhead->hcrc && s->pending > beg)\n+                        strm->adler = crc32(strm->adler, s->pending_buf + beg,\n+                                            s->pending - beg);\n+                    flush_pending(strm);\n+                    beg = s->pending;\n+                    if (s->pending == s->pending_buf_size) {\n+                        val = 1;\n+                        break;\n+                    }\n+                }\n+                val = s->gzhead->comment[s->gzindex++];\n+                put_byte(s, val);\n+            } while (val != 0);\n+            if (s->gzhead->hcrc && s->pending > beg)\n+                strm->adler = crc32(strm->adler, s->pending_buf + beg,\n+                                    s->pending - beg);\n+            if (val == 0)\n+                s->status = HCRC_STATE;\n+        }\n+        else\n+            s->status = HCRC_STATE;\n+    }\n+    if (s->status == HCRC_STATE) {\n+        if (s->gzhead->hcrc) {\n+            if (s->pending + 2 > s->pending_buf_size)\n+                flush_pending(strm);\n+            if (s->pending + 2 <= s->pending_buf_size) {\n+                put_byte(s, (Byte)(strm->adler & 0xff));\n+                put_byte(s, (Byte)((strm->adler >> 8) & 0xff));\n+                strm->adler = crc32(0L, Z_NULL, 0);\n+                s->status = BUSY_STATE;\n+            }\n+        }\n+        else\n+            s->status = BUSY_STATE;\n+    }\n+#endif\n \n     /* Flush as much pending output as possible */\n     if (s->pending != 0) {\n@@ -704,7 +864,12 @@ int ZEXPORT deflateEnd (strm)\n     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n \n     status = strm->state->status;\n-    if (status != INIT_STATE && status != BUSY_STATE &&\n+    if (status != INIT_STATE &&\n+        status != EXTRA_STATE &&\n+        status != NAME_STATE &&\n+        status != COMMENT_STATE &&\n+        status != HCRC_STATE &&\n+        status != BUSY_STATE &&\n         status != FINISH_STATE) {\n       return Z_STREAM_ERROR;\n     }\n@@ -744,12 +909,12 @@ int ZEXPORT deflateCopy (dest, source)\n \n     ss = source->state;\n \n-    *dest = *source;\n+    zmemcpy(dest, source, sizeof(z_stream));\n \n     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));\n     if (ds == Z_NULL) return Z_MEM_ERROR;\n     dest->state = (struct internal_state FAR *) ds;\n-    *ds = *ss;\n+    zmemcpy(ds, ss, sizeof(deflate_state));\n     ds->strm = dest;\n \n     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n@@ -838,9 +1003,11 @@ local void lm_init (s)\n     s->match_length = s->prev_length = MIN_MATCH-1;\n     s->match_available = 0;\n     s->ins_h = 0;\n+#ifndef FASTEST\n #ifdef ASMV\n     match_init(); /* initialize the asm code */\n #endif\n+#endif\n }\n \n #ifndef FASTEST\n@@ -909,7 +1076,12 @@ local uInt longest_match(s, cur_match)\n         match = s->window + cur_match;\n \n         /* Skip to next match if the match length cannot increase\n-         * or if the match length is less than 2:\n+         * or if the match length is less than 2.  Note that the checks below\n+         * for insufficient lookahead only occur occasionally for performance\n+         * reasons.  Therefore uninitialized memory will be accessed, and\n+         * conditional jumps will be made that depend on those values.\n+         * However the length of the match is limited to the lookahead, so\n+         * the output of deflate is not affected by the uninitialized values.\n          */\n #if (defined(UNALIGNED_OK) && MAX_MATCH == 258)\n         /* This code assumes sizeof(unsigned short) == 2. Do not use\n@@ -1131,6 +1303,7 @@ local void fill_window(s)\n                later. (Using level 0 permanently is not an optimal usage of\n                zlib, so we don't care about this pathological case.)\n              */\n+            /* %%% avoid this when Z_RLE */\n             n = s->hash_size;\n             p = &s->head[n];\n             do {\n@@ -1309,12 +1482,12 @@ local block_state deflate_fast(s, flush)\n              * of the string with itself at the start of the input file).\n              */\n #ifdef FASTEST\n-            if ((s->strategy < Z_HUFFMAN_ONLY) ||\n+            if ((s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) ||\n                 (s->strategy == Z_RLE && s->strstart - hash_head == 1)) {\n                 s->match_length = longest_match_fast (s, hash_head);\n             }\n #else\n-            if (s->strategy < Z_HUFFMAN_ONLY) {\n+            if (s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) {\n                 s->match_length = longest_match (s, hash_head);\n             } else if (s->strategy == Z_RLE && s->strstart - hash_head == 1) {\n                 s->match_length = longest_match_fast (s, hash_head);\n@@ -1418,7 +1591,7 @@ local block_state deflate_slow(s, flush)\n              * of window index 0 (in particular we have to avoid a match\n              * of the string with itself at the start of the input file).\n              */\n-            if (s->strategy < Z_HUFFMAN_ONLY) {\n+            if (s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) {\n                 s->match_length = longest_match (s, hash_head);\n             } else if (s->strategy == Z_RLE && s->strstart - hash_head == 1) {\n                 s->match_length = longest_match_fast (s, hash_head);\n@@ -1500,3 +1673,64 @@ local block_state deflate_slow(s, flush)\n     return flush == Z_FINISH ? finish_done : block_done;\n }\n #endif /* FASTEST */\n+\n+#if 0\n+/* ===========================================================================\n+ * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n+ * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n+ * deflate switches away from Z_RLE.)\n+ */\n+local block_state deflate_rle(s, flush)\n+    deflate_state *s;\n+    int flush;\n+{\n+    int bflush;         /* set if current block must be flushed */\n+    uInt run;           /* length of run */\n+    uInt max;           /* maximum length of run */\n+    uInt prev;          /* byte at distance one to match */\n+    Bytef *scan;        /* scan for end of run */\n+\n+    for (;;) {\n+        /* Make sure that we always have enough lookahead, except\n+         * at the end of the input file. We need MAX_MATCH bytes\n+         * for the longest encodable run.\n+         */\n+        if (s->lookahead < MAX_MATCH) {\n+            fill_window(s);\n+            if (s->lookahead < MAX_MATCH && flush == Z_NO_FLUSH) {\n+                return need_more;\n+            }\n+            if (s->lookahead == 0) break; /* flush the current block */\n+        }\n+\n+        /* See how many times the previous byte repeats */\n+        run = 0;\n+        if (s->strstart > 0) {      /* if there is a previous byte, that is */\n+            max = s->lookahead < MAX_MATCH ? s->lookahead : MAX_MATCH;\n+            scan = s->window + s->strstart - 1;\n+            prev = *scan++;\n+            do {\n+                if (*scan++ != prev)\n+                    break;\n+            } while (++run < max);\n+        }\n+\n+        /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n+        if (run >= MIN_MATCH) {\n+            check_match(s, s->strstart, s->strstart - 1, run);\n+            _tr_tally_dist(s, 1, run - MIN_MATCH, bflush);\n+            s->lookahead -= run;\n+            s->strstart += run;\n+        } else {\n+            /* No match, output a literal byte */\n+            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n+            _tr_tally_lit (s, s->window[s->strstart], bflush);\n+            s->lookahead--;\n+            s->strstart++;\n+        }\n+        if (bflush) FLUSH_BLOCK(s, 0);\n+    }\n+    FLUSH_BLOCK(s, flush == Z_FINISH);\n+    return flush == Z_FINISH ? finish_done : block_done;\n+}\n+#endif"}, {"sha": "b056f027ef6c2118e387a5ebeba7080f09be2a2c", "filename": "zlib/deflate.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fdeflate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fdeflate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fdeflate.h?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* deflate.h -- internal compression state\n- * Copyright (C) 1995-2002 Jean-loup Gailly\n+ * Copyright (C) 1995-2004 Jean-loup Gailly\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -49,6 +49,10 @@\n /* All codes must not exceed MAX_BITS bits */\n \n #define INIT_STATE    42\n+#define EXTRA_STATE   69\n+#define NAME_STATE    73\n+#define COMMENT_STATE 91\n+#define HCRC_STATE   103\n #define BUSY_STATE   113\n #define FINISH_STATE 666\n /* Stream status */\n@@ -93,9 +97,10 @@ typedef struct internal_state {\n     Bytef *pending_buf;  /* output still pending */\n     ulg   pending_buf_size; /* size of pending_buf */\n     Bytef *pending_out;  /* next pending byte to output to the stream */\n-    int   pending;       /* nb of bytes in the pending buffer */\n+    uInt   pending;      /* nb of bytes in the pending buffer */\n     int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */\n-    Byte  data_type;     /* UNKNOWN, BINARY or ASCII */\n+    gz_headerp  gzhead;  /* gzip header information to write */\n+    uInt   gzindex;      /* where in extra, name, or comment */\n     Byte  method;        /* STORED (for zip only) or DEFLATED */\n     int   last_flush;    /* value of flush param for previous deflate call */\n "}, {"sha": "7d7342d4aa821d199797722cd743e71e126d94f3", "filename": "zlib/example.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fexample.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fexample.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fexample.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* example.c -- usage example of the zlib compression library\n- * Copyright (C) 1995-2003 Jean-loup Gailly.\n+ * Copyright (C) 1995-2004 Jean-loup Gailly.\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -11,8 +11,6 @@\n #ifdef STDC\n #  include <string.h>\n #  include <stdlib.h>\n-#else\n-   extern void exit  OF((int));\n #endif\n \n #if defined(VMS) || defined(RISCOS)"}, {"sha": "a35877440f50e6983b887805061d517d9f5a98a7", "filename": "zlib/gzio.c", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fgzio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fgzio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fgzio.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* gzio.c -- IO on .gz files\n- * Copyright (C) 1995-2003 Jean-loup Gailly.\n+ * Copyright (C) 1995-2005 Jean-loup Gailly.\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  *\n  * Compile this file with -DNO_GZCOMPRESS to avoid the compression code.\n@@ -11,7 +11,7 @@\n \n #include \"zutil.h\"\n \n-#ifdef NO_DEFLATE       /* for compatiblity with old definition */\n+#ifdef NO_DEFLATE       /* for compatibility with old definition */\n #  define NO_GZCOMPRESS\n #endif\n \n@@ -220,7 +220,7 @@ gzFile ZEXPORT gzdopen (fd, mode)\n     int fd;\n     const char *mode;\n {\n-    char name[20];\n+    char name[46];      /* allow for up to 128-bit integers */\n \n     if (fd < 0) return (gzFile)Z_NULL;\n     sprintf(name, \"<fd:%d>\", fd); /* for debugging */\n@@ -264,7 +264,7 @@ local int get_byte(s)\n     if (s->z_eof) return EOF;\n     if (s->stream.avail_in == 0) {\n         errno = 0;\n-        s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);\n+        s->stream.avail_in = (uInt)fread(s->inbuf, 1, Z_BUFSIZE, s->file);\n         if (s->stream.avail_in == 0) {\n             s->z_eof = 1;\n             if (ferror(s->file)) s->z_err = Z_ERRNO;\n@@ -300,7 +300,7 @@ local void check_header(s)\n     if (len < 2) {\n         if (len) s->inbuf[0] = s->stream.next_in[0];\n         errno = 0;\n-        len = fread(s->inbuf + len, 1, Z_BUFSIZE >> len, s->file);\n+        len = (uInt)fread(s->inbuf + len, 1, Z_BUFSIZE >> len, s->file);\n         if (len == 0 && ferror(s->file)) s->z_err = Z_ERRNO;\n         s->stream.avail_in += len;\n         s->stream.next_in = s->inbuf;\n@@ -415,6 +415,7 @@ int ZEXPORT gzread (file, buf, len)\n         s->stream.avail_out--;\n         s->back = EOF;\n         s->out++;\n+        start++;\n         if (s->last) {\n             s->z_err = Z_STREAM_END;\n             return 1;\n@@ -436,8 +437,8 @@ int ZEXPORT gzread (file, buf, len)\n                 s->stream.avail_in  -= n;\n             }\n             if (s->stream.avail_out > 0) {\n-                s->stream.avail_out -= fread(next_out, 1, s->stream.avail_out,\n-                                             s->file);\n+                s->stream.avail_out -=\n+                    (uInt)fread(next_out, 1, s->stream.avail_out, s->file);\n             }\n             len -= s->stream.avail_out;\n             s->in  += len;\n@@ -448,7 +449,7 @@ int ZEXPORT gzread (file, buf, len)\n         if (s->stream.avail_in == 0 && !s->z_eof) {\n \n             errno = 0;\n-            s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);\n+            s->stream.avail_in = (uInt)fread(s->inbuf, 1, Z_BUFSIZE, s->file);\n             if (s->stream.avail_in == 0) {\n                 s->z_eof = 1;\n                 if (ferror(s->file)) {\n@@ -488,6 +489,9 @@ int ZEXPORT gzread (file, buf, len)\n     }\n     s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));\n \n+    if (len == s->stream.avail_out &&\n+        (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO))\n+        return -1;\n     return (int)(len - s->stream.avail_out);\n }\n \n@@ -898,6 +902,18 @@ int ZEXPORT gzeof (file)\n     return s->z_err == Z_STREAM_END;\n }\n \n+/* ===========================================================================\n+     Returns 1 if reading and doing so transparently, otherwise zero.\n+*/\n+int ZEXPORT gzdirect (file)\n+    gzFile file;\n+{\n+    gz_stream *s = (gz_stream*)file;\n+\n+    if (s == NULL || s->mode != 'r') return 0;\n+    return s->transparent;\n+}\n+\n /* ===========================================================================\n    Outputs a long in LSB order to the given file\n */\n@@ -937,7 +953,6 @@ local uLong getLong (s)\n int ZEXPORT gzclose (file)\n     gzFile file;\n {\n-    int err;\n     gz_stream *s = (gz_stream*)file;\n \n     if (s == NULL) return Z_STREAM_ERROR;\n@@ -946,8 +961,8 @@ int ZEXPORT gzclose (file)\n #ifdef NO_GZCOMPRESS\n         return Z_STREAM_ERROR;\n #else\n-        err = do_flush (file, Z_FINISH);\n-        if (err != Z_OK) return destroy((gz_stream*)file);\n+        if (do_flush (file, Z_FINISH) != Z_OK)\n+            return destroy((gz_stream*)file);\n \n         putLong (s->file, s->crc);\n         putLong (s->file, (uLong)(s->in & 0xffffffff));\n@@ -956,10 +971,16 @@ int ZEXPORT gzclose (file)\n     return destroy((gz_stream*)file);\n }\n \n+#ifdef STDC\n+#  define zstrerror(errnum) strerror(errnum)\n+#else\n+#  define zstrerror(errnum) \"\"\n+#endif\n+\n /* ===========================================================================\n-     Returns the error message for the last error which occured on the\n+     Returns the error message for the last error which occurred on the\n    given compressed file. errnum is set to zlib error number. If an\n-   error occured in the file system and not in the compression library,\n+   error occurred in the file system and not in the compression library,\n    errnum is set to Z_ERRNO and the application may consult errno\n    to get the exact error code.\n */"}, {"sha": "455dbc9ee8432fcb01ecf425b9df81d22471e17c", "filename": "zlib/infback.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Finfback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Finfback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finfback.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* infback.c -- inflate using a call-back interface\n- * Copyright (C) 1995-2003 Mark Adler\n+ * Copyright (C) 1995-2005 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -26,7 +26,7 @@ local void fixedtables OF((struct inflate_state FAR *state));\n    window and output buffer that is 2**windowBits bytes.\n  */\n int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)\n-z_stream FAR *strm;\n+z_streamp strm;\n int windowBits;\n unsigned char FAR *window;\n const char *version;\n@@ -50,7 +50,8 @@ int stream_size;\n                                                sizeof(struct inflate_state));\n     if (state == Z_NULL) return Z_MEM_ERROR;\n     Tracev((stderr, \"inflate: allocated\\n\"));\n-    strm->state = (voidpf)state;\n+    strm->state = (struct internal_state FAR *)state;\n+    state->dmax = 32768U;\n     state->wbits = windowBits;\n     state->wsize = 1U << windowBits;\n     state->window = window;\n@@ -238,7 +239,7 @@ struct inflate_state FAR *state;\n    are not correct, i.e. strm is Z_NULL or the state was not initialized.\n  */\n int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)\n-z_stream FAR *strm;\n+z_streamp strm;\n in_func in;\n void FAR *in_desc;\n out_func out;\n@@ -434,6 +435,9 @@ void FAR *out_desc;\n                 }\n             }\n \n+            /* handle error breaks in while */\n+            if (state->mode == BAD) break;\n+\n             /* build code tables */\n             state->next = state->codes;\n             state->lencode = (code const FAR *)(state->next);\n@@ -608,7 +612,7 @@ void FAR *out_desc;\n }\n \n int ZEXPORT inflateBackEnd(strm)\n-z_stream FAR *strm;\n+z_streamp strm;\n {\n     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)\n         return Z_STREAM_ERROR;"}, {"sha": "bbee92ed1e6bd3683d4d497bdf639dd1b05e98bc", "filename": "zlib/inffast.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Finffast.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Finffast.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finffast.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* inffast.c -- fast decoding\n- * Copyright (C) 1995-2003 Mark Adler\n+ * Copyright (C) 1995-2004 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -19,7 +19,7 @@\n    - none\n    No measurable difference:\n    - Pentium III (Anderson)\n-   - 68060 (Nikl)\n+   - M68060 (Nikl)\n  */\n #ifdef POSTINC\n #  define OFF 0\n@@ -74,6 +74,9 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */\n     unsigned char FAR *out;     /* local strm->next_out */\n     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */\n     unsigned char FAR *end;     /* while out < end, enough space available */\n+#ifdef INFLATE_STRICT\n+    unsigned dmax;              /* maximum distance from zlib header */\n+#endif\n     unsigned wsize;             /* window size or zero if not using window */\n     unsigned whave;             /* valid bytes in the window */\n     unsigned write;             /* window write index */\n@@ -98,6 +101,9 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */\n     out = strm->next_out - OFF;\n     beg = out - (start - strm->avail_out);\n     end = out + (strm->avail_out - 257);\n+#ifdef INFLATE_STRICT\n+    dmax = state->dmax;\n+#endif\n     wsize = state->wsize;\n     whave = state->whave;\n     write = state->write;\n@@ -167,6 +173,13 @@ unsigned start;         /* inflate()'s starting value for strm->avail_out */\n                     }\n                 }\n                 dist += (unsigned)hold & ((1U << op) - 1);\n+#ifdef INFLATE_STRICT\n+                if (dist > dmax) {\n+                    strm->msg = (char *)\"invalid distance too far back\";\n+                    state->mode = BAD;\n+                    break;\n+                }\n+#endif\n                 hold >>= op;\n                 bits -= op;\n                 Tracevv((stderr, \"inflate:         distance %u\\n\", dist));"}, {"sha": "792fdee8e9c72bf3a62ead549577ba5cdd473e61", "filename": "zlib/inflate.c", "status": "modified", "additions": 114, "deletions": 16, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Finflate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Finflate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finflate.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* inflate.c -- zlib decompression\n- * Copyright (C) 1995-2003 Mark Adler\n+ * Copyright (C) 1995-2005 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -109,18 +109,38 @@ z_streamp strm;\n     state = (struct inflate_state FAR *)strm->state;\n     strm->total_in = strm->total_out = state->total = 0;\n     strm->msg = Z_NULL;\n+    strm->adler = 1;        /* to support ill-conceived Java test suite */\n     state->mode = HEAD;\n     state->last = 0;\n     state->havedict = 0;\n+    state->dmax = 32768U;\n+    state->head = Z_NULL;\n     state->wsize = 0;\n     state->whave = 0;\n+    state->write = 0;\n     state->hold = 0;\n     state->bits = 0;\n     state->lencode = state->distcode = state->next = state->codes;\n     Tracev((stderr, \"inflate: reset\\n\"));\n     return Z_OK;\n }\n \n+int ZEXPORT inflatePrime(strm, bits, value)\n+z_streamp strm;\n+int bits;\n+int value;\n+{\n+    struct inflate_state FAR *state;\n+\n+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n+    state = (struct inflate_state FAR *)strm->state;\n+    if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;\n+    value &= (1L << bits) - 1;\n+    state->hold += value << state->bits;\n+    state->bits += bits;\n+    return Z_OK;\n+}\n+\n int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)\n z_streamp strm;\n int windowBits;\n@@ -143,7 +163,7 @@ int stream_size;\n             ZALLOC(strm, 1, sizeof(struct inflate_state));\n     if (state == Z_NULL) return Z_MEM_ERROR;\n     Tracev((stderr, \"inflate: allocated\\n\"));\n-    strm->state = (voidpf)state;\n+    strm->state = (struct internal_state FAR *)state;\n     if (windowBits < 0) {\n         state->wrap = 0;\n         windowBits = -windowBits;\n@@ -581,6 +601,8 @@ int flush;\n                 break;\n             }\n             state->flags = 0;           /* expect zlib header */\n+            if (state->head != Z_NULL)\n+                state->head->done = -1;\n             if (!(state->wrap & 1) ||   /* check if zlib header allowed */\n #else\n             if (\n@@ -596,11 +618,13 @@ int flush;\n                 break;\n             }\n             DROPBITS(4);\n-            if (BITS(4) + 8 > state->wbits) {\n+            len = BITS(4) + 8;\n+            if (len > state->wbits) {\n                 strm->msg = (char *)\"invalid window size\";\n                 state->mode = BAD;\n                 break;\n             }\n+            state->dmax = 1U << len;\n             Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n             strm->adler = state->check = adler32(0L, Z_NULL, 0);\n             state->mode = hold & 0x200 ? DICTID : TYPE;\n@@ -620,32 +644,51 @@ int flush;\n                 state->mode = BAD;\n                 break;\n             }\n+            if (state->head != Z_NULL)\n+                state->head->text = (int)((hold >> 8) & 1);\n             if (state->flags & 0x0200) CRC2(state->check, hold);\n             INITBITS();\n             state->mode = TIME;\n         case TIME:\n             NEEDBITS(32);\n+            if (state->head != Z_NULL)\n+                state->head->time = hold;\n             if (state->flags & 0x0200) CRC4(state->check, hold);\n             INITBITS();\n             state->mode = OS;\n         case OS:\n             NEEDBITS(16);\n+            if (state->head != Z_NULL) {\n+                state->head->xflags = (int)(hold & 0xff);\n+                state->head->os = (int)(hold >> 8);\n+            }\n             if (state->flags & 0x0200) CRC2(state->check, hold);\n             INITBITS();\n             state->mode = EXLEN;\n         case EXLEN:\n             if (state->flags & 0x0400) {\n                 NEEDBITS(16);\n                 state->length = (unsigned)(hold);\n+                if (state->head != Z_NULL)\n+                    state->head->extra_len = (unsigned)hold;\n                 if (state->flags & 0x0200) CRC2(state->check, hold);\n                 INITBITS();\n             }\n+            else if (state->head != Z_NULL)\n+                state->head->extra = Z_NULL;\n             state->mode = EXTRA;\n         case EXTRA:\n             if (state->flags & 0x0400) {\n                 copy = state->length;\n                 if (copy > have) copy = have;\n                 if (copy) {\n+                    if (state->head != Z_NULL &&\n+                        state->head->extra != Z_NULL) {\n+                        len = state->head->extra_len - state->length;\n+                        zmemcpy(state->head->extra + len, next,\n+                                len + copy > state->head->extra_max ?\n+                                state->head->extra_max - len : copy);\n+                    }\n                     if (state->flags & 0x0200)\n                         state->check = crc32(state->check, next, copy);\n                     have -= copy;\n@@ -654,34 +697,48 @@ int flush;\n                 }\n                 if (state->length) goto inf_leave;\n             }\n+            state->length = 0;\n             state->mode = NAME;\n         case NAME:\n             if (state->flags & 0x0800) {\n                 if (have == 0) goto inf_leave;\n                 copy = 0;\n                 do {\n                     len = (unsigned)(next[copy++]);\n+                    if (state->head != Z_NULL &&\n+                            state->head->name != Z_NULL &&\n+                            state->length < state->head->name_max)\n+                        state->head->name[state->length++] = len;\n                 } while (len && copy < have);\n-                if (state->flags & 0x02000)\n+                if (state->flags & 0x0200)\n                     state->check = crc32(state->check, next, copy);\n                 have -= copy;\n                 next += copy;\n                 if (len) goto inf_leave;\n             }\n+            else if (state->head != Z_NULL)\n+                state->head->name = Z_NULL;\n+            state->length = 0;\n             state->mode = COMMENT;\n         case COMMENT:\n             if (state->flags & 0x1000) {\n                 if (have == 0) goto inf_leave;\n                 copy = 0;\n                 do {\n                     len = (unsigned)(next[copy++]);\n+                    if (state->head != Z_NULL &&\n+                            state->head->comment != Z_NULL &&\n+                            state->length < state->head->comm_max)\n+                        state->head->comment[state->length++] = len;\n                 } while (len && copy < have);\n-                if (state->flags & 0x02000)\n+                if (state->flags & 0x0200)\n                     state->check = crc32(state->check, next, copy);\n                 have -= copy;\n                 next += copy;\n                 if (len) goto inf_leave;\n             }\n+            else if (state->head != Z_NULL)\n+                state->head->comment = Z_NULL;\n             state->mode = HCRC;\n         case HCRC:\n             if (state->flags & 0x0200) {\n@@ -693,6 +750,10 @@ int flush;\n                 }\n                 INITBITS();\n             }\n+            if (state->head != Z_NULL) {\n+                state->head->hcrc = (int)((state->flags >> 9) & 1);\n+                state->head->done = 1;\n+            }\n             strm->adler = state->check = crc32(0L, Z_NULL, 0);\n             state->mode = TYPE;\n             break;\n@@ -861,6 +922,9 @@ int flush;\n                 }\n             }\n \n+            /* handle error breaks in while */\n+            if (state->mode == BAD) break;\n+\n             /* build code tables */\n             state->next = state->codes;\n             state->lencode = (code const FAR *)(state->next);\n@@ -965,6 +1029,13 @@ int flush;\n                 state->offset += BITS(state->extra);\n                 DROPBITS(state->extra);\n             }\n+#ifdef INFLATE_STRICT\n+            if (state->offset > state->dmax) {\n+                strm->msg = (char *)\"invalid distance too far back\";\n+                state->mode = BAD;\n+                break;\n+            }\n+#endif\n             if (state->offset > state->whave + out - left) {\n                 strm->msg = (char *)\"invalid distance too far back\";\n                 state->mode = BAD;\n@@ -1106,12 +1177,16 @@ uInt dictLength;\n     /* check state */\n     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n     state = (struct inflate_state FAR *)strm->state;\n-    if (state->mode != DICT) return Z_STREAM_ERROR;\n+    if (state->wrap != 0 && state->mode != DICT)\n+        return Z_STREAM_ERROR;\n \n     /* check for correct dictionary id */\n-    id = adler32(0L, Z_NULL, 0);\n-    id = adler32(id, dictionary, dictLength);\n-    if (id != state->check) return Z_DATA_ERROR;\n+    if (state->mode == DICT) {\n+        id = adler32(0L, Z_NULL, 0);\n+        id = adler32(id, dictionary, dictLength);\n+        if (id != state->check)\n+            return Z_DATA_ERROR;\n+    }\n \n     /* copy dictionary to window */\n     if (updatewindow(strm, strm->avail_out)) {\n@@ -1133,6 +1208,23 @@ uInt dictLength;\n     return Z_OK;\n }\n \n+int ZEXPORT inflateGetHeader(strm, head)\n+z_streamp strm;\n+gz_headerp head;\n+{\n+    struct inflate_state FAR *state;\n+\n+    /* check state */\n+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n+    state = (struct inflate_state FAR *)strm->state;\n+    if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;\n+\n+    /* save header structure */\n+    state->head = head;\n+    head->done = 0;\n+    return Z_OK;\n+}\n+\n /*\n    Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found\n    or when out of input.  When called, *have is the number of pattern bytes\n@@ -1235,6 +1327,7 @@ z_streamp source;\n     struct inflate_state FAR *state;\n     struct inflate_state FAR *copy;\n     unsigned char FAR *window;\n+    unsigned wsize;\n \n     /* check input */\n     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||\n@@ -1257,14 +1350,19 @@ z_streamp source;\n     }\n \n     /* copy state */\n-    *dest = *source;\n-    *copy = *state;\n-    copy->lencode = copy->codes + (state->lencode - state->codes);\n-    copy->distcode = copy->codes + (state->distcode - state->codes);\n+    zmemcpy(dest, source, sizeof(z_stream));\n+    zmemcpy(copy, state, sizeof(struct inflate_state));\n+    if (state->lencode >= state->codes &&\n+        state->lencode <= state->codes + ENOUGH - 1) {\n+        copy->lencode = copy->codes + (state->lencode - state->codes);\n+        copy->distcode = copy->codes + (state->distcode - state->codes);\n+    }\n     copy->next = copy->codes + (state->next - state->codes);\n-    if (window != Z_NULL)\n-        zmemcpy(window, state->window, 1U << state->wbits);\n+    if (window != Z_NULL) {\n+        wsize = 1U << state->wbits;\n+        zmemcpy(window, state->window, wsize);\n+    }\n     copy->window = window;\n-    dest->state = (voidpf)copy;\n+    dest->state = (struct internal_state FAR *)copy;\n     return Z_OK;\n }"}, {"sha": "07bd3e78a7c7e763f2dbb939320b01a9897df019", "filename": "zlib/inflate.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Finflate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Finflate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finflate.h?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* inflate.h -- internal inflate state definition\n- * Copyright (C) 1995-2003 Mark Adler\n+ * Copyright (C) 1995-2004 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -19,7 +19,6 @@\n /* Possible inflate modes between inflate() calls */\n typedef enum {\n     HEAD,       /* i: waiting for magic header */\n-#ifdef GUNZIP\n     FLAGS,      /* i: waiting for method and flags (gzip) */\n     TIME,       /* i: waiting for modification time (gzip) */\n     OS,         /* i: waiting for extra flags and operating system (gzip) */\n@@ -28,7 +27,6 @@ typedef enum {\n     NAME,       /* i: waiting for end of file name (gzip) */\n     COMMENT,    /* i: waiting for end of comment (gzip) */\n     HCRC,       /* i: waiting for header crc (gzip) */\n-#endif\n     DICTID,     /* i: waiting for dictionary check value */\n     DICT,       /* waiting for inflateSetDictionary() call */\n         TYPE,       /* i: waiting for type bits, including last-flag bit */\n@@ -45,9 +43,7 @@ typedef enum {\n             MATCH,      /* o: waiting for output space to copy string */\n             LIT,        /* o: waiting for output space to write literal */\n     CHECK,      /* i: waiting for 32-bit check value */\n-#ifdef GUNZIP\n     LENGTH,     /* i: waiting for 32-bit length (gzip) */\n-#endif\n     DONE,       /* finished check, done -- remain here until reset */\n     BAD,        /* got a data error -- remain here until reset */\n     MEM,        /* got an inflate() memory error -- remain here until reset */\n@@ -84,8 +80,10 @@ struct inflate_state {\n     int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip */\n     int havedict;               /* true if dictionary provided */\n     int flags;                  /* gzip header method and flags (0 if zlib) */\n+    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */\n     unsigned long check;        /* protected copy of check value */\n     unsigned long total;        /* protected copy of output count */\n+    gz_headerp head;            /* where to save gzip header information */\n         /* sliding window */\n     unsigned wbits;             /* log base 2 of requested window size */\n     unsigned wsize;             /* window size or zero if not using window */"}, {"sha": "8a9c13ff03d874f03d0ad132c5ab19cfe3a53add", "filename": "zlib/inftrees.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Finftrees.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Finftrees.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finftrees.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* inftrees.c -- generate Huffman trees for efficient decoding\n- * Copyright (C) 1995-2003 Mark Adler\n+ * Copyright (C) 1995-2005 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -9,7 +9,7 @@\n #define MAXBITS 15\n \n const char inflate_copyright[] =\n-   \" inflate 1.2.1 Copyright 1995-2003 Mark Adler \";\n+   \" inflate 1.2.3 Copyright 1995-2005 Mark Adler \";\n /*\n   If you use the zlib library in a product, an acknowledgment is welcome\n   in the documentation of your product. If for some reason you cannot\n@@ -62,7 +62,7 @@ unsigned short FAR *work;\n         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n     static const unsigned short lext[31] = { /* Length codes 257..285 extra */\n         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n-        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 76, 66};\n+        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 201, 196};\n     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */\n         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n@@ -114,7 +114,15 @@ unsigned short FAR *work;\n     for (max = MAXBITS; max >= 1; max--)\n         if (count[max] != 0) break;\n     if (root > max) root = max;\n-    if (max == 0) return -1;            /* no codes! */\n+    if (max == 0) {                     /* no symbols to code at all */\n+        this.op = (unsigned char)64;    /* invalid code marker */\n+        this.bits = (unsigned char)1;\n+        this.val = (unsigned short)0;\n+        *(*table)++ = this;             /* make a table to force an error */\n+        *(*table)++ = this;\n+        *bits = 1;\n+        return 0;     /* no symbols, but wait for decoding to report error */\n+    }\n     for (min = 1; min <= MAXBITS; min++)\n         if (count[min] != 0) break;\n     if (root < min) root = min;\n@@ -126,7 +134,7 @@ unsigned short FAR *work;\n         left -= count[len];\n         if (left < 0) return -1;        /* over-subscribed */\n     }\n-    if (left > 0 && (type == CODES || (codes - count[0] != 1)))\n+    if (left > 0 && (type == CODES || max != 1))\n         return -1;                      /* incomplete set */\n \n     /* generate offsets into symbol table for each length for sorting */\n@@ -224,6 +232,7 @@ unsigned short FAR *work;\n         /* replicate for those indices with low len bits equal to huff */\n         incr = 1U << (len - drop);\n         fill = 1U << curr;\n+        min = fill;                 /* save offset to next table */\n         do {\n             fill -= incr;\n             next[(huff >> drop) + fill] = this;\n@@ -254,7 +263,7 @@ unsigned short FAR *work;\n                 drop = root;\n \n             /* increment past last table */\n-            next += 1U << curr;\n+            next += min;            /* here min is 1 << curr */\n \n             /* determine length of next table */\n             curr = len - drop;\n@@ -295,7 +304,6 @@ unsigned short FAR *work;\n             drop = 0;\n             len = root;\n             next = *table;\n-            curr = root;\n             this.bits = (unsigned char)len;\n         }\n "}, {"sha": "b1104c87e76907a2105183fa8a904f01de8356c6", "filename": "zlib/inftrees.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Finftrees.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Finftrees.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finftrees.h?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* inftrees.h -- header to use inftrees.c\n- * Copyright (C) 1995-2003 Mark Adler\n+ * Copyright (C) 1995-2005 Mark Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -36,12 +36,12 @@ typedef struct {\n  */\n \n /* Maximum size of dynamic tree.  The maximum found in a long but non-\n-   exhaustive search was 1004 code structures (850 for length/literals\n-   and 154 for distances, the latter actually the result of an\n+   exhaustive search was 1444 code structures (852 for length/literals\n+   and 592 for distances, the latter actually the result of an\n    exhaustive search).  The true maximum is not known, but the value\n    below is more than safe. */\n-#define ENOUGH 1440\n-#define MAXD 154\n+#define ENOUGH 2048\n+#define MAXD 592\n \n /* Type of code to build for inftable() */\n typedef enum {"}, {"sha": "0f57171c472996663e65ffbb6f5733e1a52d9e76", "filename": "zlib/minigzip.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fminigzip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fminigzip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fminigzip.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* minigzip.c -- simulate gzip using the zlib compression library\n- * Copyright (C) 1995-2002 Jean-loup Gailly.\n+ * Copyright (C) 1995-2005 Jean-loup Gailly.\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -21,8 +21,6 @@\n #ifdef STDC\n #  include <string.h>\n #  include <stdlib.h>\n-#else\n-   extern void exit  OF((int));\n #endif\n \n #ifdef USE_MMAP\n@@ -297,6 +295,8 @@ int main(argc, argv)\n         break;\n       argc--, argv++;\n     }\n+    if (outmode[3] == ' ')\n+        outmode[3] = 0;\n     if (argc == 0) {\n         SET_BINARY_MODE(stdin);\n         SET_BINARY_MODE(stdout);"}, {"sha": "4fe301303f00db1b02e72b02d0473b0c7e4c4292", "filename": "zlib/old/Make_vms.com", "status": "removed", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fold%2FMake_vms.com", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec980b182de950223663d4a3ef65177fa887501/zlib%2Fold%2FMake_vms.com", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2FMake_vms.com?ref=3ec980b182de950223663d4a3ef65177fa887501", "patch": "@@ -1,115 +0,0 @@\n-$! make libz under VMS\n-$! written by Martin P.J. Zinser <m.zinser@gsi.de>\n-$!\n-$! Look for the compiler used\n-$!\n-$ ccopt = \"\"\n-$ if f$getsyi(\"HW_MODEL\").ge.1024\n-$ then\n-$  ccopt = \"/prefix=all\"+ccopt\n-$  comp  = \"__decc__=1\"\n-$  if f$trnlnm(\"SYS\").eqs.\"\" then define sys sys$library:\n-$ else\n-$  if f$search(\"SYS$SYSTEM:DECC$COMPILER.EXE\").eqs.\"\"\n-$   then\n-$    comp  = \"__vaxc__=1\"\n-$    if f$trnlnm(\"SYS\").eqs.\"\" then define sys sys$library:\n-$   else\n-$    if f$trnlnm(\"SYS\").eqs.\"\" then define sys decc$library_include:\n-$    ccopt = \"/decc/prefix=all\"+ccopt\n-$    comp  = \"__decc__=1\"\n-$  endif\n-$ endif\n-$!\n-$! Build the thing plain or with mms\n-$!\n-$ write sys$output \"Compiling Zlib sources ...\"\n-$ if f$search(\"SYS$SYSTEM:MMS.EXE\").eqs.\"\"\n-$  then\n-$   dele example.obj;*,minigzip.obj;*\n-$   CALL MAKE adler32.OBJ \"CC ''CCOPT' adler32\" -\n-                adler32.c zlib.h zconf.h\n-$   CALL MAKE compress.OBJ \"CC ''CCOPT' compress\" -\n-                compress.c zlib.h zconf.h\n-$   CALL MAKE crc32.OBJ \"CC ''CCOPT' crc32\" -\n-                crc32.c zlib.h zconf.h\n-$   CALL MAKE deflate.OBJ \"CC ''CCOPT' deflate\" -\n-                deflate.c deflate.h zutil.h zlib.h zconf.h\n-$   CALL MAKE gzio.OBJ \"CC ''CCOPT' gzio\" -\n-                gzio.c zutil.h zlib.h zconf.h\n-$   CALL MAKE infblock.OBJ \"CC ''CCOPT' infblock\" -\n-                infblock.c zutil.h zlib.h zconf.h infblock.h\n-$   CALL MAKE infcodes.OBJ \"CC ''CCOPT' infcodes\" -\n-                infcodes.c zutil.h zlib.h zconf.h inftrees.h\n-$   CALL MAKE inffast.OBJ \"CC ''CCOPT' inffast\" -\n-                inffast.c zutil.h zlib.h zconf.h inffast.h\n-$   CALL MAKE inflate.OBJ \"CC ''CCOPT' inflate\" -\n-                inflate.c zutil.h zlib.h zconf.h infblock.h\n-$   CALL MAKE inftrees.OBJ \"CC ''CCOPT' inftrees\" -\n-                inftrees.c zutil.h zlib.h zconf.h inftrees.h\n-$   CALL MAKE infutil.OBJ \"CC ''CCOPT' infutil\" -\n-                infutil.c zutil.h zlib.h zconf.h inftrees.h infutil.h\n-$   CALL MAKE trees.OBJ \"CC ''CCOPT' trees\" -\n-                trees.c deflate.h zutil.h zlib.h zconf.h\n-$   CALL MAKE uncompr.OBJ \"CC ''CCOPT' uncompr\" -\n-                uncompr.c zlib.h zconf.h\n-$   CALL MAKE zutil.OBJ \"CC ''CCOPT' zutil\" -\n-                zutil.c zutil.h zlib.h zconf.h\n-$   write sys$output \"Building Zlib ...\"\n-$   CALL MAKE libz.OLB \"lib/crea libz.olb *.obj\" *.OBJ\n-$   write sys$output \"Building example...\"\n-$   CALL MAKE example.OBJ \"CC ''CCOPT' example\" -\n-                example.c zlib.h zconf.h\n-$   call make example.exe \"LINK example,libz.olb/lib\" example.obj libz.olb\n-$   write sys$output \"Building minigzip...\"\n-$   CALL MAKE minigzip.OBJ \"CC ''CCOPT' minigzip\" -\n-                minigzip.c zlib.h zconf.h\n-$   call make minigzip.exe -\n-                \"LINK minigzip,libz.olb/lib,x11vms:xvmsutils.olb/lib\" -\n-                minigzip.obj libz.olb\n-$  else\n-$   mms/macro=('comp')\n-$  endif\n-$ write sys$output \"Zlib build completed\"\n-$ exit\n-$!\n-$!\n-$MAKE: SUBROUTINE   !SUBROUTINE TO CHECK DEPENDENCIES\n-$ V = 'F$Verify(0)\n-$! P1 = What we are trying to make\n-$! P2 = Command to make it\n-$! P3 - P8  What it depends on\n-$\n-$ If F$Search(P1) .Eqs. \"\" Then Goto Makeit\n-$ Time = F$CvTime(F$File(P1,\"RDT\"))\n-$arg=3\n-$Loop:\n-$       Argument = P'arg\n-$       If Argument .Eqs. \"\" Then Goto Exit\n-$       El=0\n-$Loop2:\n-$       File = F$Element(El,\" \",Argument)\n-$       If File .Eqs. \" \" Then Goto Endl\n-$       AFile = \"\"\n-$Loop3:\n-$       OFile = AFile\n-$       AFile = F$Search(File)\n-$       If AFile .Eqs. \"\" .Or. AFile .Eqs. OFile Then Goto NextEl\n-$       If F$CvTime(F$File(AFile,\"RDT\")) .Ges. Time Then Goto Makeit\n-$       Goto Loop3\n-$NextEL:\n-$       El = El + 1\n-$       Goto Loop2\n-$EndL:\n-$ arg=arg+1\n-$ If arg .Le. 8 Then Goto Loop\n-$ Goto Exit\n-$\n-$Makeit:\n-$ VV=F$VERIFY(0)\n-$ write sys$output P2\n-$ 'P2\n-$ VV='F$Verify(VV)\n-$Exit:\n-$ If V Then Set Verify\n-$ENDSUBROUTINE"}, {"sha": "91eef7e1c1167466fffbdb30bd6651c55db4d15f", "filename": "zlib/trees.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Ftrees.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Ftrees.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Ftrees.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* trees.c -- output deflated data using Huffman coding\n- * Copyright (C) 1995-2003 Jean-loup Gailly\n+ * Copyright (C) 1995-2005 Jean-loup Gailly\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -555,7 +555,7 @@ local void gen_bitlen(s, desc)\n         while (n != 0) {\n             m = s->heap[--h];\n             if (m > max_code) continue;\n-            if (tree[m].Len != (unsigned) bits) {\n+            if ((unsigned) tree[m].Len != (unsigned) bits) {\n                 Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n                 s->opt_len += ((long)bits - (long)tree[m].Len)\n                               *(long)tree[m].Freq;\n@@ -930,8 +930,9 @@ void _tr_flush_block(s, buf, stored_len, eof)\n     /* Build the Huffman trees unless a stored block is forced */\n     if (s->level > 0) {\n \n-         /* Check if the file is ascii or binary */\n-        if (s->data_type == Z_UNKNOWN) set_data_type(s);\n+        /* Check if the file is binary or text */\n+        if (stored_len > 0 && s->strm->data_type == Z_UNKNOWN)\n+            set_data_type(s);\n \n         /* Construct the literal and distance trees */\n         build_tree(s, (tree_desc *)(&(s->l_desc)));\n@@ -982,7 +983,7 @@ void _tr_flush_block(s, buf, stored_len, eof)\n #ifdef FORCE_STATIC\n     } else if (static_lenb >= 0) { /* force static trees */\n #else\n-    } else if (static_lenb == opt_lenb) {\n+    } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {\n #endif\n         send_bits(s, (STATIC_TREES<<1)+eof, 3);\n         compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);\n@@ -1117,21 +1118,24 @@ local void compress_block(s, ltree, dtree)\n }\n \n /* ===========================================================================\n- * Set the data type to ASCII or BINARY, using a crude approximation:\n- * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.\n- * IN assertion: the fields freq of dyn_ltree are set and the total of all\n- * frequencies does not exceed 64K (to fit in an int on 16 bit machines).\n+ * Set the data type to BINARY or TEXT, using a crude approximation:\n+ * set it to Z_TEXT if all symbols are either printable characters (33 to 255)\n+ * or white spaces (9 to 13, or 32); or set it to Z_BINARY otherwise.\n+ * IN assertion: the fields Freq of dyn_ltree are set.\n  */\n local void set_data_type(s)\n     deflate_state *s;\n {\n-    int n = 0;\n-    unsigned ascii_freq = 0;\n-    unsigned bin_freq = 0;\n-    while (n < 7)        bin_freq += s->dyn_ltree[n++].Freq;\n-    while (n < 128)    ascii_freq += s->dyn_ltree[n++].Freq;\n-    while (n < LITERALS) bin_freq += s->dyn_ltree[n++].Freq;\n-    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);\n+    int n;\n+\n+    for (n = 0; n < 9; n++)\n+        if (s->dyn_ltree[n].Freq != 0)\n+            break;\n+    if (n == 9)\n+        for (n = 14; n < 32; n++)\n+            if (s->dyn_ltree[n].Freq != 0)\n+                break;\n+    s->strm->data_type = (n == 32) ? Z_TEXT : Z_BINARY;\n }\n \n /* ==========================================================================="}, {"sha": "05fc80178621388135f3ade96daef85758a75041", "filename": "zlib/zconf.h", "status": "modified", "additions": 51, "deletions": 42, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fzconf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fzconf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzconf.h?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* zconf.h -- configuration of the zlib compression library\n- * Copyright (C) 1995-2003 Jean-loup Gailly.\n+ * Copyright (C) 1995-2005 Jean-loup Gailly.\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -13,43 +13,50 @@\n  * compile with -DZ_PREFIX. The \"standard\" zlib should be compiled without it.\n  */\n #ifdef Z_PREFIX\n-#  define deflateInit_  z_deflateInit_\n-#  define deflate       z_deflate\n-#  define deflateEnd    z_deflateEnd\n-#  define inflateInit_  z_inflateInit_\n-#  define inflate       z_inflate\n-#  define inflateEnd    z_inflateEnd\n-#  define deflateInit2_ z_deflateInit2_\n-#  define deflateSetDictionary z_deflateSetDictionary\n-#  define deflateCopy   z_deflateCopy\n-#  define deflateReset  z_deflateReset\n-#  define deflatePrime  z_deflatePrime\n-#  define deflateParams z_deflateParams\n-#  define deflateBound  z_deflateBound\n-#  define inflateInit2_ z_inflateInit2_\n-#  define inflateSetDictionary z_inflateSetDictionary\n-#  define inflateSync   z_inflateSync\n-#  define inflateSyncPoint z_inflateSyncPoint\n-#  define inflateCopy   z_inflateCopy\n-#  define inflateReset  z_inflateReset\n-#  define compress      z_compress\n-#  define compress2     z_compress2\n-#  define compressBound z_compressBound\n-#  define uncompress    z_uncompress\n-#  define adler32       z_adler32\n-#  define crc32         z_crc32\n-#  define get_crc_table z_get_crc_table\n+#  define deflateInit_          z_deflateInit_\n+#  define deflate               z_deflate\n+#  define deflateEnd            z_deflateEnd\n+#  define inflateInit_          z_inflateInit_\n+#  define inflate               z_inflate\n+#  define inflateEnd            z_inflateEnd\n+#  define deflateInit2_         z_deflateInit2_\n+#  define deflateSetDictionary  z_deflateSetDictionary\n+#  define deflateCopy           z_deflateCopy\n+#  define deflateReset          z_deflateReset\n+#  define deflateParams         z_deflateParams\n+#  define deflateBound          z_deflateBound\n+#  define deflatePrime          z_deflatePrime\n+#  define inflateInit2_         z_inflateInit2_\n+#  define inflateSetDictionary  z_inflateSetDictionary\n+#  define inflateSync           z_inflateSync\n+#  define inflateSyncPoint      z_inflateSyncPoint\n+#  define inflateCopy           z_inflateCopy\n+#  define inflateReset          z_inflateReset\n+#  define inflateBack           z_inflateBack\n+#  define inflateBackEnd        z_inflateBackEnd\n+#  define compress              z_compress\n+#  define compress2             z_compress2\n+#  define compressBound         z_compressBound\n+#  define uncompress            z_uncompress\n+#  define adler32               z_adler32\n+#  define crc32                 z_crc32\n+#  define get_crc_table         z_get_crc_table\n+#  define zError                z_zError\n \n-#  define Byte          z_Byte\n-#  define uInt          z_uInt\n-#  define uLong         z_uLong\n-#  define Bytef         z_Bytef\n-#  define charf         z_charf\n-#  define intf          z_intf\n-#  define uIntf         z_uIntf\n-#  define uLongf        z_uLongf\n-#  define voidpf        z_voidpf\n-#  define voidp         z_voidp\n+#  define alloc_func            z_alloc_func\n+#  define free_func             z_free_func\n+#  define in_func               z_in_func\n+#  define out_func              z_out_func\n+#  define Byte                  z_Byte\n+#  define uInt                  z_uInt\n+#  define uLong                 z_uLong\n+#  define Bytef                 z_Bytef\n+#  define charf                 z_charf\n+#  define intf                  z_intf\n+#  define uIntf                 z_uIntf\n+#  define uLongf                z_uLongf\n+#  define voidpf                z_voidpf\n+#  define voidp                 z_voidp\n #endif\n \n #if defined(__MSDOS__) && !defined(MSDOS)\n@@ -61,8 +68,10 @@\n #if defined(_WINDOWS) && !defined(WINDOWS)\n #  define WINDOWS\n #endif\n-#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)\n-#  define WIN32\n+#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)\n+#  ifndef WIN32\n+#    define WIN32\n+#  endif\n #endif\n #if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)\n #  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)\n@@ -281,19 +290,19 @@ typedef uLong FAR uLongf;\n #  ifdef VMS\n #    include <unixio.h>   /* for off_t */\n #  endif\n-#  define z_off_t  off_t\n+#  define z_off_t off_t\n #endif\n #ifndef SEEK_SET\n #  define SEEK_SET        0       /* Seek from beginning of file.  */\n #  define SEEK_CUR        1       /* Seek from current position.  */\n #  define SEEK_END        2       /* Set file pointer to EOF plus \"offset\" */\n #endif\n #ifndef z_off_t\n-#  define  z_off_t long\n+#  define z_off_t long\n #endif\n \n #if defined(__OS400__)\n-#define NO_vsnprintf\n+#  define NO_vsnprintf\n #endif\n \n #if defined(__MVS__)"}, {"sha": "03a9431c8be2b44f2b1159308454a0f9c628597c", "filename": "zlib/zconf.in.h", "status": "modified", "additions": 51, "deletions": 42, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fzconf.in.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fzconf.in.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzconf.in.h?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* zconf.h -- configuration of the zlib compression library\n- * Copyright (C) 1995-2003 Jean-loup Gailly.\n+ * Copyright (C) 1995-2005 Jean-loup Gailly.\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -13,43 +13,50 @@\n  * compile with -DZ_PREFIX. The \"standard\" zlib should be compiled without it.\n  */\n #ifdef Z_PREFIX\n-#  define deflateInit_  z_deflateInit_\n-#  define deflate       z_deflate\n-#  define deflateEnd    z_deflateEnd\n-#  define inflateInit_  z_inflateInit_\n-#  define inflate       z_inflate\n-#  define inflateEnd    z_inflateEnd\n-#  define deflateInit2_ z_deflateInit2_\n-#  define deflateSetDictionary z_deflateSetDictionary\n-#  define deflateCopy   z_deflateCopy\n-#  define deflateReset  z_deflateReset\n-#  define deflatePrime  z_deflatePrime\n-#  define deflateParams z_deflateParams\n-#  define deflateBound  z_deflateBound\n-#  define inflateInit2_ z_inflateInit2_\n-#  define inflateSetDictionary z_inflateSetDictionary\n-#  define inflateSync   z_inflateSync\n-#  define inflateSyncPoint z_inflateSyncPoint\n-#  define inflateCopy   z_inflateCopy\n-#  define inflateReset  z_inflateReset\n-#  define compress      z_compress\n-#  define compress2     z_compress2\n-#  define compressBound z_compressBound\n-#  define uncompress    z_uncompress\n-#  define adler32       z_adler32\n-#  define crc32         z_crc32\n-#  define get_crc_table z_get_crc_table\n+#  define deflateInit_          z_deflateInit_\n+#  define deflate               z_deflate\n+#  define deflateEnd            z_deflateEnd\n+#  define inflateInit_          z_inflateInit_\n+#  define inflate               z_inflate\n+#  define inflateEnd            z_inflateEnd\n+#  define deflateInit2_         z_deflateInit2_\n+#  define deflateSetDictionary  z_deflateSetDictionary\n+#  define deflateCopy           z_deflateCopy\n+#  define deflateReset          z_deflateReset\n+#  define deflateParams         z_deflateParams\n+#  define deflateBound          z_deflateBound\n+#  define deflatePrime          z_deflatePrime\n+#  define inflateInit2_         z_inflateInit2_\n+#  define inflateSetDictionary  z_inflateSetDictionary\n+#  define inflateSync           z_inflateSync\n+#  define inflateSyncPoint      z_inflateSyncPoint\n+#  define inflateCopy           z_inflateCopy\n+#  define inflateReset          z_inflateReset\n+#  define inflateBack           z_inflateBack\n+#  define inflateBackEnd        z_inflateBackEnd\n+#  define compress              z_compress\n+#  define compress2             z_compress2\n+#  define compressBound         z_compressBound\n+#  define uncompress            z_uncompress\n+#  define adler32               z_adler32\n+#  define crc32                 z_crc32\n+#  define get_crc_table         z_get_crc_table\n+#  define zError                z_zError\n \n-#  define Byte          z_Byte\n-#  define uInt          z_uInt\n-#  define uLong         z_uLong\n-#  define Bytef         z_Bytef\n-#  define charf         z_charf\n-#  define intf          z_intf\n-#  define uIntf         z_uIntf\n-#  define uLongf        z_uLongf\n-#  define voidpf        z_voidpf\n-#  define voidp         z_voidp\n+#  define alloc_func            z_alloc_func\n+#  define free_func             z_free_func\n+#  define in_func               z_in_func\n+#  define out_func              z_out_func\n+#  define Byte                  z_Byte\n+#  define uInt                  z_uInt\n+#  define uLong                 z_uLong\n+#  define Bytef                 z_Bytef\n+#  define charf                 z_charf\n+#  define intf                  z_intf\n+#  define uIntf                 z_uIntf\n+#  define uLongf                z_uLongf\n+#  define voidpf                z_voidpf\n+#  define voidp                 z_voidp\n #endif\n \n #if defined(__MSDOS__) && !defined(MSDOS)\n@@ -61,8 +68,10 @@\n #if defined(_WINDOWS) && !defined(WINDOWS)\n #  define WINDOWS\n #endif\n-#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)\n-#  define WIN32\n+#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)\n+#  ifndef WIN32\n+#    define WIN32\n+#  endif\n #endif\n #if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)\n #  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)\n@@ -281,19 +290,19 @@ typedef uLong FAR uLongf;\n #  ifdef VMS\n #    include <unixio.h>   /* for off_t */\n #  endif\n-#  define z_off_t  off_t\n+#  define z_off_t off_t\n #endif\n #ifndef SEEK_SET\n #  define SEEK_SET        0       /* Seek from beginning of file.  */\n #  define SEEK_CUR        1       /* Seek from current position.  */\n #  define SEEK_END        2       /* Set file pointer to EOF plus \"offset\" */\n #endif\n #ifndef z_off_t\n-#  define  z_off_t long\n+#  define z_off_t long\n #endif\n \n #if defined(__OS400__)\n-#define NO_vsnprintf\n+#  define NO_vsnprintf\n #endif\n \n #if defined(__MVS__)"}, {"sha": "90b8162870fdd5aa5354c12f087c5497e01d3bac", "filename": "zlib/zlib.3", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fzlib.3", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fzlib.3", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzlib.3?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,4 +1,4 @@\n-.TH ZLIB 3 \"17 November 2003\"\n+.TH ZLIB 3 \"18 July 2005\"\n .SH NAME\n zlib \\- compression/decompression library\n .SH SYNOPSIS\n@@ -133,8 +133,8 @@ before asking for help.\n Send questions and/or comments to zlib@gzip.org,\n or (for the Windows DLL version) to Gilles Vollant (info@winimage.com).\n .SH AUTHORS\n-Version 1.2.1\n-Copyright (C) 1995-2003 Jean-loup Gailly (jloup@gzip.org)\n+Version 1.2.3\n+Copyright (C) 1995-2005 Jean-loup Gailly (jloup@gzip.org)\n and Mark Adler (madler@alumni.caltech.edu).\n .LP\n This software is provided \"as-is,\""}, {"sha": "022817927ce3d6b1abe5ac57bff70e7de5291ae0", "filename": "zlib/zlib.h", "status": "modified", "additions": 203, "deletions": 46, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fzlib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fzlib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzlib.h?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,7 +1,7 @@\n /* zlib.h -- interface of the 'zlib' general purpose compression library\n-  version 1.2.1, November 17th, 2003\n+  version 1.2.3, July 18th, 2005\n \n-  Copyright (C) 1995-2003 Jean-loup Gailly and Mark Adler\n+  Copyright (C) 1995-2005 Jean-loup Gailly and Mark Adler\n \n   This software is provided 'as-is', without any express or implied\n   warranty.  In no event will the authors be held liable for any damages\n@@ -37,8 +37,8 @@\n extern \"C\" {\n #endif\n \n-#define ZLIB_VERSION \"1.2.1\"\n-#define ZLIB_VERNUM 0x1210\n+#define ZLIB_VERSION \"1.2.3\"\n+#define ZLIB_VERNUM 0x1230\n \n /*\n      The 'zlib' compression library provides in-memory compression and\n@@ -53,24 +53,22 @@ extern \"C\" {\n   application must provide more input and/or consume the output\n   (providing more output space) before each call.\n \n-     The compressed data format used by the in-memory functions is the zlib\n-  format, which is a zlib wrapper documented in RFC 1950, wrapped around a\n-  deflate stream, which is itself documented in RFC 1951.\n+     The compressed data format used by default by the in-memory functions is\n+  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped\n+  around a deflate stream, which is itself documented in RFC 1951.\n \n      The library also supports reading and writing files in gzip (.gz) format\n   with an interface similar to that of stdio using the functions that start\n   with \"gz\".  The gzip format is different from the zlib format.  gzip is a\n   gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.\n \n+     This library can optionally read and write gzip streams in memory as well.\n+\n      The zlib format was designed to be compact and fast for use in memory\n   and on communications channels.  The gzip format was designed for single-\n   file compression on file systems, has a larger header than zlib to maintain\n   directory information, and uses a different, slower check method than zlib.\n \n-     This library does not provide any functions to write gzip files in memory.\n-  However such functions could be easily written using zlib's deflate function,\n-  the documentation in the gzip RFC, and the examples in gzio.c.\n-\n      The library does not install any signal handler. The decoder checks\n   the consistency of the compressed data, so the library should never\n   crash even in case of corrupted input.\n@@ -97,13 +95,36 @@ typedef struct z_stream_s {\n     free_func  zfree;   /* used to free the internal state */\n     voidpf     opaque;  /* private data object passed to zalloc and zfree */\n \n-    int     data_type;  /* best guess about the data type: ascii or binary */\n+    int     data_type;  /* best guess about the data type: binary or text */\n     uLong   adler;      /* adler32 value of the uncompressed data */\n     uLong   reserved;   /* reserved for future use */\n } z_stream;\n \n typedef z_stream FAR *z_streamp;\n \n+/*\n+     gzip header information passed to and from zlib routines.  See RFC 1952\n+  for more details on the meanings of these fields.\n+*/\n+typedef struct gz_header_s {\n+    int     text;       /* true if compressed data believed to be text */\n+    uLong   time;       /* modification time */\n+    int     xflags;     /* extra flags (not used when writing a gzip file) */\n+    int     os;         /* operating system */\n+    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */\n+    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */\n+    uInt    extra_max;  /* space at extra (only when reading header) */\n+    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */\n+    uInt    name_max;   /* space at name (only when reading header) */\n+    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */\n+    uInt    comm_max;   /* space at comment (only when reading header) */\n+    int     hcrc;       /* true if there was or will be a header crc */\n+    int     done;       /* true when done reading gzip header (not used\n+                           when writing a gzip file) */\n+} gz_header;\n+\n+typedef gz_header FAR *gz_headerp;\n+\n /*\n    The application must update next_in and avail_in when avail_in has\n    dropped to zero. It must update next_out and avail_out when avail_out\n@@ -168,11 +189,13 @@ typedef z_stream FAR *z_streamp;\n #define Z_FILTERED            1\n #define Z_HUFFMAN_ONLY        2\n #define Z_RLE                 3\n+#define Z_FIXED               4\n #define Z_DEFAULT_STRATEGY    0\n /* compression strategy; see deflateInit2() below for details */\n \n #define Z_BINARY   0\n-#define Z_ASCII    1\n+#define Z_TEXT     1\n+#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */\n #define Z_UNKNOWN  2\n /* Possible values of the data_type field (though see inflate()) */\n \n@@ -246,6 +269,10 @@ ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));\n   and with zero avail_out, it must be called again after making room in the\n   output buffer because there might be more output pending.\n \n+    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to\n+  decide how much data to accumualte before producing output, in order to\n+  maximize compression.\n+\n     If the parameter flush is set to Z_SYNC_FLUSH, all pending output is\n   flushed to the output buffer and the output is aligned on a byte boundary, so\n   that the decompressor can get all input data available so far. (In particular\n@@ -257,7 +284,7 @@ ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));\n   Z_SYNC_FLUSH, and the compression state is reset so that decompression can\n   restart from this point if previous compressed data has been damaged or if\n   random access is desired. Using Z_FULL_FLUSH too often can seriously degrade\n-  the compression.\n+  compression.\n \n     If deflate returns with avail_out == 0, this function must be called again\n   with the same value of the flush parameter and more output space (updated\n@@ -282,8 +309,8 @@ ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));\n     deflate() sets strm->adler to the adler32 checksum of all input read\n   so far (that is, total_in bytes).\n \n-    deflate() may update data_type if it can make a good guess about\n-  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered\n+    deflate() may update strm->data_type if it can make a good guess about\n+  the input data type (Z_BINARY or Z_TEXT). In doubt, the data is considered\n   binary. This field is only for information purposes and does not affect\n   the compression algorithm in any manner.\n \n@@ -365,11 +392,11 @@ ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));\n     The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,\n   Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much\n   output as possible to the output buffer. Z_BLOCK requests that inflate() stop\n-  if and when it get to the next deflate block boundary. When decoding the zlib\n-  or gzip format, this will cause inflate() to return immediately after the\n-  header and before the first block. When doing a raw inflate, inflate() will\n-  go ahead and process the first block, and will return when it gets to the end\n-  of that block, or when it runs out of data.\n+  if and when it gets to the next deflate block boundary. When decoding the\n+  zlib or gzip format, this will cause inflate() to return immediately after\n+  the header and before the first block. When doing a raw inflate, inflate()\n+  will go ahead and process the first block, and will return when it gets to\n+  the end of that block, or when it runs out of data.\n \n     The Z_BLOCK option assists in appending to or combining deflate streams.\n   Also to assist in this, on return inflate() will set strm->data_type to the\n@@ -401,7 +428,7 @@ ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));\n   because Z_BLOCK is used.\n \n      If a preset dictionary is needed after this call (see inflateSetDictionary\n-  below), inflate sets strm-adler to the adler32 checksum of the dictionary\n+  below), inflate sets strm->adler to the adler32 checksum of the dictionary\n   chosen by the compressor and returns Z_NEED_DICT; otherwise it sets\n   strm->adler to the adler32 checksum of all output produced so far (that is,\n   total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described\n@@ -478,7 +505,8 @@ ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,\n    16 to windowBits to write a simple gzip header and trailer around the\n    compressed data instead of a zlib wrapper. The gzip header will have no\n    file name, no extra data, no comment, no modification time (set to zero),\n-   no header crc, and the operating system will be set to 255 (unknown).\n+   no header crc, and the operating system will be set to 255 (unknown).  If a\n+   gzip stream is being written, strm->adler is a crc32 instead of an adler32.\n \n      The memLevel parameter specifies how much memory should be allocated\n    for the internal compression state. memLevel=1 uses minimum memory but\n@@ -497,7 +525,9 @@ ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,\n    Z_DEFAULT and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as fast as\n    Z_HUFFMAN_ONLY, but give better compression for PNG image data. The strategy\n    parameter only affects the compression ratio but not the correctness of the\n-   compressed output even if it is not set appropriately.\n+   compressed output even if it is not set appropriately.  Z_FIXED prevents the\n+   use of dynamic Huffman codes, allowing for a simpler decoder for special\n+   applications.\n \n       deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n    memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid\n@@ -526,7 +556,9 @@ ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,\n    deflateInit or deflateInit2, a part of the dictionary may in effect be\n    discarded, for example if the dictionary is larger than the window size in\n    deflate or deflate2. Thus the strings most likely to be useful should be\n-   put at the end of the dictionary, not at the front.\n+   put at the end of the dictionary, not at the front. In addition, the\n+   current implementation of deflate will use at most the window size minus\n+   262 bytes of the provided dictionary.\n \n      Upon return of this function, strm->adler is set to the adler32 value\n    of the dictionary; the decompressor may later use this value to determine\n@@ -592,6 +624,23 @@ ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,\n    if strm->avail_out was zero.\n */\n \n+ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,\n+                                    int good_length,\n+                                    int max_lazy,\n+                                    int nice_length,\n+                                    int max_chain));\n+/*\n+     Fine tune deflate's internal compression parameters.  This should only be\n+   used by someone who understands the algorithm used by zlib's deflate for\n+   searching for the best matching string, and even then only by the most\n+   fanatic optimizer trying to squeeze out the last compressed bit for their\n+   specific input data.  Read the deflate.c source code for the meaning of the\n+   max_lazy, good_length, nice_length, and max_chain parameters.\n+\n+     deflateTune() can be called after deflateInit() or deflateInit2(), and\n+   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.\n+ */\n+\n ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,\n                                        uLong sourceLen));\n /*\n@@ -617,6 +666,30 @@ ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,\n    stream state was inconsistent.\n */\n \n+ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,\n+                                         gz_headerp head));\n+/*\n+      deflateSetHeader() provides gzip header information for when a gzip\n+   stream is requested by deflateInit2().  deflateSetHeader() may be called\n+   after deflateInit2() or deflateReset() and before the first call of\n+   deflate().  The text, time, os, extra field, name, and comment information\n+   in the provided gz_header structure are written to the gzip header (xflag is\n+   ignored -- the extra flags are set according to the compression level).  The\n+   caller must assure that, if not Z_NULL, name and comment are terminated with\n+   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are\n+   available there.  If hcrc is true, a gzip header crc is included.  Note that\n+   the current versions of the command-line version of gzip (up through version\n+   1.3.x) do not support header crc's, and will report that it is a \"multi-part\n+   gzip file\" and give up.\n+\n+      If deflateSetHeader is not used, the default gzip header has text false,\n+   the time set to zero, and os set to 255, with no extra, name, or comment\n+   fields.  The gzip header is returned to the default state by deflateReset().\n+\n+      deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source\n+   stream state was inconsistent.\n+*/\n+\n /*\n ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,\n                                      int  windowBits));\n@@ -649,26 +722,30 @@ ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,\n      windowBits can also be greater than 15 for optional gzip decoding. Add\n    32 to windowBits to enable zlib and gzip decoding with automatic header\n    detection, or add 16 to decode only the gzip format (the zlib format will\n-   return a Z_DATA_ERROR).\n+   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is\n+   a crc32 instead of an adler32.\n \n      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n-   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative\n-   memLevel). msg is set to null if there is no error message.  inflateInit2\n-   does not perform any decompression apart from reading the zlib header if\n-   present: this will be done by inflate(). (So next_in and avail_in may be\n-   modified, but next_out and avail_out are unchanged.)\n+   memory, Z_STREAM_ERROR if a parameter is invalid (such as a null strm). msg\n+   is set to null if there is no error message.  inflateInit2 does not perform\n+   any decompression apart from reading the zlib header if present: this will\n+   be done by inflate(). (So next_in and avail_in may be modified, but next_out\n+   and avail_out are unchanged.)\n */\n \n ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,\n                                              const Bytef *dictionary,\n                                              uInt  dictLength));\n /*\n      Initializes the decompression dictionary from the given uncompressed byte\n-   sequence. This function must be called immediately after a call of inflate\n-   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor\n-   can be determined from the adler32 value returned by this call of\n-   inflate. The compressor and decompressor must use exactly the same\n-   dictionary (see deflateSetDictionary).\n+   sequence. This function must be called immediately after a call of inflate,\n+   if that call returned Z_NEED_DICT. The dictionary chosen by the compressor\n+   can be determined from the adler32 value returned by that call of inflate.\n+   The compressor and decompressor must use exactly the same dictionary (see\n+   deflateSetDictionary).  For raw inflate, this function can be called\n+   immediately after inflateInit2() or inflateReset() and before any call of\n+   inflate() to set the dictionary.  The application must insure that the\n+   dictionary that was used for compression is provided.\n \n      inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a\n    parameter is invalid (such as NULL dictionary) or the stream state is\n@@ -719,8 +796,64 @@ ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));\n    stream state was inconsistent (such as zalloc or state being NULL).\n */\n \n+ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,\n+                                     int bits,\n+                                     int value));\n+/*\n+     This function inserts bits in the inflate input stream.  The intent is\n+  that this function is used to start inflating at a bit position in the\n+  middle of a byte.  The provided bits will be used before any bytes are used\n+  from next_in.  This function should only be used with raw inflate, and\n+  should be used before the first inflate() call after inflateInit2() or\n+  inflateReset().  bits must be less than or equal to 16, and that many of the\n+  least significant bits of value will be inserted in the input.\n+\n+      inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source\n+   stream state was inconsistent.\n+*/\n+\n+ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,\n+                                         gz_headerp head));\n /*\n-ZEXTERN int ZEXPORT inflateBackInit OF((z_stream FAR *strm, int windowBits,\n+      inflateGetHeader() requests that gzip header information be stored in the\n+   provided gz_header structure.  inflateGetHeader() may be called after\n+   inflateInit2() or inflateReset(), and before the first call of inflate().\n+   As inflate() processes the gzip stream, head->done is zero until the header\n+   is completed, at which time head->done is set to one.  If a zlib stream is\n+   being decoded, then head->done is set to -1 to indicate that there will be\n+   no gzip header information forthcoming.  Note that Z_BLOCK can be used to\n+   force inflate() to return immediately after header processing is complete\n+   and before any actual data is decompressed.\n+\n+      The text, time, xflags, and os fields are filled in with the gzip header\n+   contents.  hcrc is set to true if there is a header CRC.  (The header CRC\n+   was valid if done is set to one.)  If extra is not Z_NULL, then extra_max\n+   contains the maximum number of bytes to write to extra.  Once done is true,\n+   extra_len contains the actual extra field length, and extra contains the\n+   extra field, or that field truncated if extra_max is less than extra_len.\n+   If name is not Z_NULL, then up to name_max characters are written there,\n+   terminated with a zero unless the length is greater than name_max.  If\n+   comment is not Z_NULL, then up to comm_max characters are written there,\n+   terminated with a zero unless the length is greater than comm_max.  When\n+   any of extra, name, or comment are not Z_NULL and the respective field is\n+   not present in the header, then that field is set to Z_NULL to signal its\n+   absence.  This allows the use of deflateSetHeader() with the returned\n+   structure to duplicate the header.  However if those fields are set to\n+   allocated memory, then the application will need to save those pointers\n+   elsewhere so that they can be eventually freed.\n+\n+      If inflateGetHeader is not used, then the header information is simply\n+   discarded.  The header is always checked for validity, including the header\n+   CRC if present.  inflateReset() will reset the process to discard the header\n+   information.  The application would need to call inflateGetHeader() again to\n+   retrieve the header from the next gzip stream.\n+\n+      inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source\n+   stream state was inconsistent.\n+*/\n+\n+/*\n+ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,\n                                         unsigned char FAR *window));\n \n      Initialize the internal stream state for decompression using inflateBack()\n@@ -744,7 +877,7 @@ ZEXTERN int ZEXPORT inflateBackInit OF((z_stream FAR *strm, int windowBits,\n typedef unsigned (*in_func) OF((void FAR *, unsigned char FAR * FAR *));\n typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));\n \n-ZEXTERN int ZEXPORT inflateBack OF((z_stream FAR *strm,\n+ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,\n                                     in_func in, void FAR *in_desc,\n                                     out_func out, void FAR *out_desc));\n /*\n@@ -813,7 +946,7 @@ ZEXTERN int ZEXPORT inflateBack OF((z_stream FAR *strm,\n    that inflateBack() cannot return Z_OK.\n */\n \n-ZEXTERN int ZEXPORT inflateBackEnd OF((z_stream FAR *strm));\n+ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));\n /*\n      All memory allocated by inflateBackInit() is freed.\n \n@@ -1087,6 +1220,12 @@ ZEXTERN int ZEXPORT gzeof OF((gzFile file));\n    input stream, otherwise zero.\n */\n \n+ZEXTERN int ZEXPORT gzdirect OF((gzFile file));\n+/*\n+     Returns 1 if file is being read directly without decompression, otherwise\n+   zero.\n+*/\n+\n ZEXTERN int ZEXPORT    gzclose OF((gzFile file));\n /*\n      Flushes all pending output if necessary, closes the compressed file\n@@ -1119,7 +1258,6 @@ ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));\n */\n \n ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));\n-\n /*\n      Update a running Adler-32 checksum with the bytes buf[0..len-1] and\n    return the updated checksum. If buf is NULL, this function returns\n@@ -1135,12 +1273,21 @@ ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));\n      if (adler != original_adler) error();\n */\n \n+ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,\n+                                          z_off_t len2));\n+/*\n+     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1\n+   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for\n+   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of\n+   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.\n+*/\n+\n ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));\n /*\n-     Update a running crc with the bytes buf[0..len-1] and return the updated\n-   crc. If buf is NULL, this function returns the required initial value\n-   for the crc. Pre- and post-conditioning (one's complement) is performed\n-   within this function so it shouldn't be done by the application.\n+     Update a running CRC-32 with the bytes buf[0..len-1] and return the\n+   updated CRC-32. If buf is NULL, this function returns the required initial\n+   value for the for the crc. Pre- and post-conditioning (one's complement) is\n+   performed within this function so it shouldn't be done by the application.\n    Usage example:\n \n      uLong crc = crc32(0L, Z_NULL, 0);\n@@ -1151,6 +1298,16 @@ ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));\n      if (crc != original_crc) error();\n */\n \n+ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));\n+\n+/*\n+     Combine two CRC-32 check values into one.  For two sequences of bytes,\n+   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were\n+   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32\n+   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and\n+   len2.\n+*/\n+\n \n                         /* various hacks, don't look :) */\n \n@@ -1167,7 +1324,7 @@ ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,\n                                       int stream_size));\n ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,\n                                       const char *version, int stream_size));\n-ZEXTERN int ZEXPORT inflateBackInit_ OF((z_stream FAR *strm, int windowBits,\n+ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,\n                                          unsigned char FAR *window,\n                                          const char *version,\n                                          int stream_size));\n@@ -1189,7 +1346,7 @@ ZEXTERN int ZEXPORT inflateBackInit_ OF((z_stream FAR *strm, int windowBits,\n     struct internal_state {int dummy;}; /* hack for buggy compilers */\n #endif\n \n-ZEXTERN const char   * ZEXPORT zError           OF((int err));\n+ZEXTERN const char   * ZEXPORT zError           OF((int));\n ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));\n ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));\n "}, {"sha": "04730f8bffb17ef5cae2f7f0eb78e2b17566726f", "filename": "zlib/zutil.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fzutil.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fzutil.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzutil.c?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* zutil.c -- target dependent utility functions for the compression library\n- * Copyright (C) 1995-2003 Jean-loup Gailly.\n+ * Copyright (C) 1995-2005 Jean-loup Gailly.\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -11,10 +11,6 @@\n struct internal_state      {int dummy;}; /* for buggy compilers */\n #endif\n \n-#ifndef STDC\n-extern void exit OF((int));\n-#endif\n-\n const char * const z_errmsg[10] = {\n \"need dictionary\",     /* Z_NEED_DICT       2  */\n \"stream end\",          /* Z_STREAM_END      1  */\n@@ -78,38 +74,38 @@ uLong ZEXPORT zlibCompileFlags()\n     flags += 1 << 13;\n #endif\n #ifdef NO_GZCOMPRESS\n-    flags += 1 << 16;\n+    flags += 1L << 16;\n #endif\n #ifdef NO_GZIP\n-    flags += 1 << 17;\n+    flags += 1L << 17;\n #endif\n #ifdef PKZIP_BUG_WORKAROUND\n-    flags += 1 << 20;\n+    flags += 1L << 20;\n #endif\n #ifdef FASTEST\n-    flags += 1 << 21;\n+    flags += 1L << 21;\n #endif\n #ifdef STDC\n #  ifdef NO_vsnprintf\n-        flags += 1 << 25;\n+        flags += 1L << 25;\n #    ifdef HAS_vsprintf_void\n-        flags += 1 << 26;\n+        flags += 1L << 26;\n #    endif\n #  else\n #    ifdef HAS_vsnprintf_void\n-        flags += 1 << 26;\n+        flags += 1L << 26;\n #    endif\n #  endif\n #else\n-        flags += 1 << 24;\n+        flags += 1L << 24;\n #  ifdef NO_snprintf\n-        flags += 1 << 25;\n+        flags += 1L << 25;\n #    ifdef HAS_sprintf_void\n-        flags += 1 << 26;\n+        flags += 1L << 26;\n #    endif\n #  else\n #    ifdef HAS_snprintf_void\n-        flags += 1 << 26;\n+        flags += 1L << 26;\n #    endif\n #  endif\n #endif\n@@ -141,7 +137,10 @@ const char * ZEXPORT zError(err)\n }\n \n #if defined(_WIN32_WCE)\n-    /* does not exist on WCE */\n+    /* The Microsoft C Run-Time Library for Windows CE doesn't have\n+     * errno.  We define it as a global variable to simplify porting.\n+     * Its value is always 0 and should not be used.\n+     */\n     int errno = 0;\n #endif\n "}, {"sha": "3880b085d8ba05bb2f1f54d03b3e54d57bcc6e46", "filename": "zlib/zutil.h", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fzutil.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3381664e516d137c80ebbf48c085220d5810ab/zlib%2Fzutil.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzutil.h?ref=ef3381664e516d137c80ebbf48c085220d5810ab", "patch": "@@ -1,5 +1,5 @@\n /* zutil.h -- internal interface and configuration of the compression library\n- * Copyright (C) 1995-2003 Jean-loup Gailly.\n+ * Copyright (C) 1995-2005 Jean-loup Gailly.\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -17,14 +17,26 @@\n #include \"zlib.h\"\n \n #ifdef STDC\n-#  include <stddef.h>\n+#  ifndef _WIN32_WCE\n+#    include <stddef.h>\n+#  endif\n #  include <string.h>\n #  include <stdlib.h>\n #endif\n #ifdef NO_ERRNO_H\n+#   ifdef _WIN32_WCE\n+      /* The Microsoft C Run-Time Library for Windows CE doesn't have\n+       * errno.  We define it as a global variable to simplify porting.\n+       * Its value is always 0 and should not be used.  We rename it to\n+       * avoid conflict with other libraries that use the same workaround.\n+       */\n+#     define errno z_errno\n+#   endif\n     extern int errno;\n #else\n-#   include <errno.h>\n+#  ifndef _WIN32_WCE\n+#    include <errno.h>\n+#  endif\n #endif\n \n #ifndef local\n@@ -105,6 +117,9 @@ extern const char * const z_errmsg[10]; /* indexed by 2-zlib_error */\n \n #ifdef OS2\n #  define OS_CODE  0x06\n+#  ifdef M_I86\n+     #include <malloc.h>\n+#  endif\n #endif\n \n #if defined(MACOS) || defined(TARGET_OS_MAC)\n@@ -189,12 +204,8 @@ extern const char * const z_errmsg[10]; /* indexed by 2-zlib_error */\n #    define NO_vsnprintf\n #  endif\n #endif\n-\n-#ifdef HAVE_STRERROR\n-   extern char *strerror OF((int));\n-#  define zstrerror(errnum) strerror(errnum)\n-#else\n-#  define zstrerror(errnum) \"\"\n+#ifdef VMS\n+#  define NO_vsnprintf\n #endif\n \n #if defined(pyr)"}]}