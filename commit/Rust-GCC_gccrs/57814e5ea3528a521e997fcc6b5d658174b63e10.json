{"sha": "57814e5ea3528a521e997fcc6b5d658174b63e10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc4MTRlNWVhMzUyOGE1MjFlOTk3ZmNjNmI1ZDY1ODE3NGI2M2UxMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2000-11-29T18:24:50Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2000-11-29T18:24:50Z"}, "message": "expr.h (store_by_pieces): Add prototype.\n\n\t* expr.h (store_by_pieces): Add prototype.\n\t(can_store_by_pieces): Likewise.\n\t* expr.c (struct store_by_pieces): Renamed from clear_by_pieces.\n\t(can_store_by_pieces): New.\n\t(store_by_pieces): New.\n\t(clear_by_pieces): New.\n\t(clear_by_pieces_1): New.\n\t(store_by_pieces_1): Renamed from clear_by_pieces, handle storing\n\tarbitrary compiler generated constants into memory block.\n\t(store_by_pieces_2): Renamed from clear_by_pieces_1, likewise.\n\t* builtins.c (c_readstr): New.\n\t(builtin_memcpy_read_str): New.\n\t(expand_builtin_memcpy): If src is string constant and\n\temit_block_move would move it by pieces, compute integer constants\n\tfrom the string and store it into memory block instead.\n\t(builtin_strncpy_read_str): New.\n\t(expand_builtin_strncpy): If N is not constant zero and c_strlen does\n\tnot return INTEGER_CST, don't optimize.\n\tIf N is larger than strlen(src) + 1, try to copy the string\n\tincluding padding with store_by_pieces.\n\t(expand_builtin_strcmp): If both arguments have side effects, don't\n\toptimize.\n\t(expand_builtin_fputs): If STR has side effects, don't optimize.\n\n\t* gcc.c-torture/execute/string-opt-5.c: Add some strcmp and strncpy\n\ttests.\n\t* gcc.c-torture/execute/string-opt-6.c: New test.\n\nFrom-SVN: r37851", "tree": {"sha": "f0f32075fb72921dd130201ceba23d250949163a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0f32075fb72921dd130201ceba23d250949163a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57814e5ea3528a521e997fcc6b5d658174b63e10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57814e5ea3528a521e997fcc6b5d658174b63e10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57814e5ea3528a521e997fcc6b5d658174b63e10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57814e5ea3528a521e997fcc6b5d658174b63e10/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3632e1eaba7b8ccb91377e70657618d7b5cd2c39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3632e1eaba7b8ccb91377e70657618d7b5cd2c39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3632e1eaba7b8ccb91377e70657618d7b5cd2c39"}], "stats": {"total": 473, "additions": 426, "deletions": 47}, "files": [{"sha": "be3164c4414af4d071b1124e2d576ed245097e6a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57814e5ea3528a521e997fcc6b5d658174b63e10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57814e5ea3528a521e997fcc6b5d658174b63e10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57814e5ea3528a521e997fcc6b5d658174b63e10", "patch": "@@ -1,3 +1,29 @@\n+2000-11-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* expr.h (store_by_pieces): Add prototype.\n+\t(can_store_by_pieces): Likewise.\n+\t* expr.c (struct store_by_pieces): Renamed from clear_by_pieces.\n+\t(can_store_by_pieces): New.\n+\t(store_by_pieces): New.\n+\t(clear_by_pieces): New.\n+\t(clear_by_pieces_1): New.\n+\t(store_by_pieces_1): Renamed from clear_by_pieces, handle storing\n+\tarbitrary compiler generated constants into memory block.\n+\t(store_by_pieces_2): Renamed from clear_by_pieces_1, likewise.\n+\t* builtins.c (c_readstr): New.\n+\t(builtin_memcpy_read_str): New.\n+\t(expand_builtin_memcpy): If src is string constant and\n+\temit_block_move would move it by pieces, compute integer constants\n+\tfrom the string and store it into memory block instead.\n+\t(builtin_strncpy_read_str): New.\n+\t(expand_builtin_strncpy): If N is not constant zero and c_strlen does\n+\tnot return INTEGER_CST, don't optimize.\n+\tIf N is larger than strlen(src) + 1, try to copy the string\n+\tincluding padding with store_by_pieces.\n+\t(expand_builtin_strcmp): If both arguments have side effects, don't\n+\toptimize.\n+\t(expand_builtin_fputs): If STR has side effects, don't optimize.\n+\n 2000-11-29  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.md (sibcall, sibcall_value, sibcall_insn, sibcall_value_insn):"}, {"sha": "07d10adf446bc7e7fa477ab57d2a71e16939fd4e", "filename": "gcc/builtins.c", "status": "modified", "additions": 128, "deletions": 8, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57814e5ea3528a521e997fcc6b5d658174b63e10/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57814e5ea3528a521e997fcc6b5d658174b63e10/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=57814e5ea3528a521e997fcc6b5d658174b63e10", "patch": "@@ -81,6 +81,8 @@ tree (*lang_type_promotes_to) PARAMS ((tree));\n static int get_pointer_alignment\tPARAMS ((tree, unsigned));\n static tree c_strlen\t\t\tPARAMS ((tree));\n static const char *c_getstr\t\tPARAMS ((tree));\n+static rtx c_readstr\t\t\tPARAMS ((const char *,\n+\t\t\t\t\t\t enum machine_mode));\n static rtx get_memory_rtx\t\tPARAMS ((tree));\n static int apply_args_size\t\tPARAMS ((void));\n static int apply_result_size\t\tPARAMS ((void));\n@@ -106,8 +108,12 @@ static rtx expand_builtin_strcmp\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_strncmp\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n+static rtx builtin_memcpy_read_str\tPARAMS ((PTR, HOST_WIDE_INT,\n+\t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_memcpy\tPARAMS ((tree));\n static rtx expand_builtin_strcpy\tPARAMS ((tree));\n+static rtx builtin_strncpy_read_str\tPARAMS ((PTR, HOST_WIDE_INT,\n+\t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_strncpy\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_memset\tPARAMS ((tree));\n@@ -308,6 +314,41 @@ c_getstr (src)\n   return ptr + offset;\n }\n \n+/* Return a CONST_INT or CONST_DOUBLE corresponding to target\n+   reading GET_MODE_BITSIZE (MODE) bits from string constant\n+   STR.  */\n+static rtx\n+c_readstr (str, mode)\n+     const char *str;\n+     enum machine_mode mode;\n+{\n+  HOST_WIDE_INT c[2];\n+  HOST_WIDE_INT ch;\n+  unsigned int i, j;\n+\n+  if (GET_MODE_CLASS (mode) != MODE_INT)\n+    abort ();\n+  c[0] = 0;\n+  c[1] = 0;\n+  ch = 1;\n+  for (i = 0; i < GET_MODE_SIZE (mode); i++)\n+    {\n+      j = i;\n+      if (WORDS_BIG_ENDIAN)\n+\tj = GET_MODE_SIZE (mode) - i - 1;\n+      if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN\n+\t  && GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+\tj = j + UNITS_PER_WORD - 2 * (j % UNITS_PER_WORD) - 1;\n+      j *= BITS_PER_UNIT;\n+      if (j > 2 * HOST_BITS_PER_WIDE_INT)\n+\tabort ();\n+      if (ch)\n+\tch = (unsigned char) str[i];\n+      c[j / HOST_BITS_PER_WIDE_INT] |= ch << (j % HOST_BITS_PER_WIDE_INT);\n+    }\n+  return immed_double_const (c[0], c[1], mode);\n+}\n+\n /* Given TEM, a pointer to a stack frame, follow the dynamic chain COUNT\n    times to get the address of either a higher stack frame, or a return\n    address located within it (depending on FNDECL_CODE).  */\n@@ -1685,6 +1726,24 @@ expand_builtin_strpbrk (arglist, target, mode)\n     }\n }\n \n+/* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)\n+   bytes from constant string DATA + OFFSET and return it as target\n+   constant.  */\n+\n+static rtx\n+builtin_memcpy_read_str (data, offset, mode)\n+     PTR data;\n+     HOST_WIDE_INT offset;\n+     enum machine_mode mode;\n+{\n+  const char *str = (const char *) data;\n+\n+  if (offset + GET_MODE_SIZE (mode) > strlen (str) + 1)\n+    abort ();  /* Attempt to read past the end of constant string.  */\n+\n+  return c_readstr (str + offset, mode);\n+}\n+\n /* Expand a call to the memcpy builtin, with arguments in ARGLIST.  */\n static rtx\n expand_builtin_memcpy (arglist)\n@@ -1706,6 +1765,7 @@ expand_builtin_memcpy (arglist)\n       tree dest = TREE_VALUE (arglist);\n       tree src = TREE_VALUE (TREE_CHAIN (arglist));\n       tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      const char *src_str;\n \n       int src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n       int dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n@@ -1717,8 +1777,26 @@ expand_builtin_memcpy (arglist)\n \treturn 0;\n \n       dest_mem = get_memory_rtx (dest);\n-      src_mem = get_memory_rtx (src);\n       len_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n+      src_str = c_getstr (src);\n+\n+      /* If SRC is a string constant and block move would be done\n+\t by pieces, we can avoid loading the string from memory\n+\t and only stored the computed constants.  */\n+      if (src_str\n+\t  && !current_function_check_memory_usage\n+\t  && GET_CODE (len_rtx) == CONST_INT\n+\t  && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n+\t  && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n+\t\t\t\t  (PTR) src_str, dest_align))\n+\t{\n+\t  store_by_pieces (dest_mem, INTVAL (len_rtx),\n+\t\t\t   builtin_memcpy_read_str,\n+\t\t\t   (PTR) src_str, dest_align);\n+\t  return force_operand (XEXP (dest_mem, 0), NULL_RTX);\n+\t}\n+\n+      src_mem = get_memory_rtx (src);\n \n       /* Just copy the rights of SRC to the rights of DEST.  */\n       if (current_function_check_memory_usage)\n@@ -1774,6 +1852,24 @@ expand_builtin_strcpy (exp)\n   return result;\n }\n \n+/* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)\n+   bytes from constant string DATA + OFFSET and return it as target\n+   constant.  */\n+\n+static rtx\n+builtin_strncpy_read_str (data, offset, mode)\n+     PTR data;\n+     HOST_WIDE_INT offset;\n+     enum machine_mode mode;\n+{\n+  const char *str = (const char *) data;\n+\n+  if ((unsigned HOST_WIDE_INT) offset > strlen (str))\n+    return const0_rtx;\n+\n+  return c_readstr (str + offset, mode);\n+}\n+\n /* Expand expression EXP, which is a call to the strncpy builtin.  Return 0\n    if we failed the caller should emit a normal call.  */\n \n@@ -1814,17 +1910,35 @@ expand_builtin_strncpy (arglist, target, mode)\n \t  return expand_expr (TREE_VALUE (arglist), target, mode,\n \t\t\t      EXPAND_NORMAL);\n \t}\n-      \n+\n       /* Now, we must be passed a constant src ptr parameter.  */\n-      if (slen == 0)\n+      if (slen == 0 || TREE_CODE (slen) != INTEGER_CST)\n \treturn 0;\n \n       slen = size_binop (PLUS_EXPR, slen, ssize_int (1));\n \n       /* We're required to pad with trailing zeros if the requested\n-         len is greater than strlen(s2)+1, so in that case punt.  */\n+         len is greater than strlen(s2)+1.  In that case try to\n+\t use store_by_pieces, if it fails, punt.  */\n       if (tree_int_cst_lt (slen, len))\n-\treturn 0;\n+\t{\n+\t  tree dest = TREE_VALUE (arglist);\n+\t  int dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+\t  const char *p = c_getstr (TREE_VALUE (TREE_CHAIN (arglist)));\n+\t  rtx dest_mem;\n+\n+\t  if (!p || !dest_align || TREE_INT_CST_HIGH (len)\n+\t      || !can_store_by_pieces (TREE_INT_CST_LOW (len),\n+\t\t\t\t       builtin_strncpy_read_str,\n+\t\t\t\t       (PTR) p, dest_align))\n+\t    return 0;\n+\n+\t  dest_mem = get_memory_rtx (dest);\n+\t  store_by_pieces (dest_mem, TREE_INT_CST_LOW (len),\n+\t\t\t   builtin_strncpy_read_str,\n+\t\t\t   (PTR) p, dest_align);\n+\t  return force_operand (XEXP (dest_mem, 0), NULL_RTX);\n+\t}\n       \n       /* OK transform into builtin memcpy.  */\n       return expand_builtin_memcpy (arglist);\n@@ -2081,7 +2195,8 @@ expand_builtin_strcmp (exp, target, mode)\n     /* If we don't have a constant length for the first, use the length\n        of the second, if we know it.  We don't require a constant for\n        this case; some cost analysis could be done if both are available\n-       but neither is constant.  For now, assume they're equally cheap.\n+       but neither is constant.  For now, assume they're equally cheap\n+       unless one has side effects.\n \n        If both strings have constant lengths, use the smaller.  This\n        could arise if optimization results in strcpy being called with\n@@ -2091,7 +2206,7 @@ expand_builtin_strcmp (exp, target, mode)\n \n     if (!len || TREE_CODE (len) != INTEGER_CST)\n       {\n-\tif (len2)\n+\tif (len2 && !TREE_SIDE_EFFECTS (len2))\n \t  len = len2;\n \telse if (len == 0)\n \t  return 0;\n@@ -2100,6 +2215,10 @@ expand_builtin_strcmp (exp, target, mode)\n \t     && tree_int_cst_lt (len2, len))\n       len = len2;\n \n+    /* If both arguments have side effects, we cannot optimize.  */\n+    if (TREE_SIDE_EFFECTS (len))\n+      return 0;\n+\n     chainon (arglist, build_tree_list (NULL_TREE, len));\n     result = expand_builtin_memcmp (exp, arglist, target);\n     if (! result)\n@@ -2760,7 +2879,8 @@ expand_builtin_fputs (arglist, ignore)\n \n   /* Get the length of the string passed to fputs.  If the length\n      can't be determined, punt.  */\n-  if (!(len = c_strlen (TREE_VALUE (arglist))))\n+  if (!(len = c_strlen (TREE_VALUE (arglist)))\n+      || TREE_CODE (len) != INTEGER_CST)\n     return 0;\n \n   switch (compare_tree_int (len, 1))"}, {"sha": "e520c6df7b4459e1fdc5357e0de3285ff19c3d0d", "filename": "gcc/expr.c", "status": "modified", "additions": 173, "deletions": 38, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57814e5ea3528a521e997fcc6b5d658174b63e10/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57814e5ea3528a521e997fcc6b5d658174b63e10/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=57814e5ea3528a521e997fcc6b5d658174b63e10", "patch": "@@ -127,17 +127,19 @@ struct move_by_pieces\n   int reverse;\n };\n \n-/* This structure is used by clear_by_pieces to describe the clear to\n+/* This structure is used by store_by_pieces to describe the clear to\n    be performed.  */\n \n-struct clear_by_pieces\n+struct store_by_pieces\n {\n   rtx to;\n   rtx to_addr;\n   int autinc_to;\n   int explicit_inc_to;\n   unsigned HOST_WIDE_INT len;\n   HOST_WIDE_INT offset;\n+  rtx (*constfun) PARAMS ((PTR, HOST_WIDE_INT, enum machine_mode));\n+  PTR constfundata;\n   int reverse;\n };\n \n@@ -151,11 +153,15 @@ static unsigned HOST_WIDE_INT move_by_pieces_ninsns\n \t\t\t\t\t unsigned int));\n static void move_by_pieces_1\tPARAMS ((rtx (*) (rtx, ...), enum machine_mode,\n \t\t\t\t\t struct move_by_pieces *));\n+static rtx clear_by_pieces_1\tPARAMS ((PTR, HOST_WIDE_INT,\n+\t\t\t\t\t enum machine_mode));\n static void clear_by_pieces\tPARAMS ((rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t\t unsigned int));\n-static void clear_by_pieces_1\tPARAMS ((rtx (*) (rtx, ...),\n+static void store_by_pieces_1\tPARAMS ((struct store_by_pieces *,\n+\t\t\t\t\t unsigned int));\n+static void store_by_pieces_2\tPARAMS ((rtx (*) (rtx, ...),\n \t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t struct clear_by_pieces *));\n+\t\t\t\t\t struct store_by_pieces *));\n static rtx get_subtarget\tPARAMS ((rtx));\n static int is_zeros_p\t\tPARAMS ((tree));\n static int mostly_zeros_p\tPARAMS ((tree));\n@@ -2249,6 +2255,105 @@ use_group_regs (call_fusage, regs)\n     }\n }\n \f\n+\n+int\n+can_store_by_pieces (len, constfun, constfundata, align)\n+     unsigned HOST_WIDE_INT len;\n+     rtx (*constfun) PARAMS ((PTR, HOST_WIDE_INT, enum machine_mode));\n+     PTR constfundata;\n+     unsigned int align;\n+{\n+  unsigned HOST_WIDE_INT max_size = MOVE_MAX_PIECES + 1, l;\n+  HOST_WIDE_INT offset = 0;\n+  enum machine_mode mode, tmode;\n+  enum insn_code icode;\n+  int reverse;\n+  rtx cst;\n+\n+  if (! MOVE_BY_PIECES_P (len, align))\n+    return 0;\n+\n+  if (! SLOW_UNALIGNED_ACCESS (word_mode, align)\n+      || align > MOVE_MAX * BITS_PER_UNIT || align >= BIGGEST_ALIGNMENT)\n+    align = MOVE_MAX * BITS_PER_UNIT;\n+\n+  /* We would first store what we can in the largest integer mode, then go to\n+     successively smaller modes.  */\n+\n+  for (reverse = 0;\n+       reverse <= (HAVE_PRE_DECREMENT || HAVE_POST_DECREMENT);\n+       reverse++)\n+    {\n+      l = len;\n+      mode = VOIDmode;\n+      while (max_size > 1)\n+\t{\n+\t  for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t       tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n+\t    if (GET_MODE_SIZE (tmode) < max_size)\n+\t      mode = tmode;\n+\n+\t  if (mode == VOIDmode)\n+\t    break;\n+\n+\t  icode = mov_optab->handlers[(int) mode].insn_code;\n+\t  if (icode != CODE_FOR_nothing\n+\t      && align >= GET_MODE_ALIGNMENT (mode))\n+\t    {\n+\t      unsigned int size = GET_MODE_SIZE (mode);\n+\n+\t      while (l >= size)\n+\t\t{\n+\t\t  if (reverse)\n+\t\t    offset -= size;\n+\n+\t\t  cst = (*constfun) (constfundata, offset, mode);\n+\t\t  if (!LEGITIMATE_CONSTANT_P (cst))\n+\t\t    return 0;\n+\n+\t\t  if (!reverse)\n+\t\t    offset += size;\n+\n+\t\t  l -= size;\n+\t\t}\n+\t    }\n+\n+\t  max_size = GET_MODE_SIZE (mode);\n+\t}\n+\n+      /* The code above should have handled everything.  */\n+      if (l != 0)\n+\tabort ();\n+    }\n+\n+  return 1;\n+}\n+\n+/* Generate several move instructions to store LEN bytes generated by\n+   CONSTFUN to block TO.  (A MEM rtx with BLKmode).  CONSTFUNDATA is a\n+   pointer which will be passed as argument in every CONSTFUN call.\n+   ALIGN is maximum alignment we can assume.  */\n+\n+void\n+store_by_pieces (to, len, constfun, constfundata, align)\n+     rtx to;\n+     unsigned HOST_WIDE_INT len;\n+     rtx (*constfun) PARAMS ((PTR, HOST_WIDE_INT, enum machine_mode));\n+     PTR constfundata;\n+     unsigned int align;\n+{\n+  struct store_by_pieces data;\n+\n+  if (! MOVE_BY_PIECES_P (len, align))\n+    abort ();\n+  to = protect_from_queue (to, 1);\n+  data.constfun = constfun;\n+  data.constfundata = constfundata;\n+  data.len = len;\n+  data.to = to;\n+  store_by_pieces_1 (&data, align);\n+}\n+\n /* Generate several move instructions to clear LEN bytes of block TO.  (A MEM\n    rtx with BLKmode).  The caller must pass TO through protect_from_queue\n    before calling. ALIGN is maximum alignment we can assume.  */\n@@ -2259,62 +2364,90 @@ clear_by_pieces (to, len, align)\n      unsigned HOST_WIDE_INT len;\n      unsigned int align;\n {\n-  struct clear_by_pieces data;\n-  rtx to_addr = XEXP (to, 0);\n+  struct store_by_pieces data;\n+\n+  data.constfun = clear_by_pieces_1;\n+  data.constfundata = NULL_PTR;\n+  data.len = len;\n+  data.to = to;\n+  store_by_pieces_1 (&data, align);\n+}\n+\n+/* Callback routine for clear_by_pieces.\n+   Return const0_rtx unconditionally.  */\n+\n+static rtx\n+clear_by_pieces_1 (data, offset, mode)\n+     PTR data ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT offset ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return const0_rtx;\n+}\n+\n+/* Subroutine of clear_by_pieces and store_by_pieces.\n+   Generate several move instructions to store LEN bytes of block TO.  (A MEM\n+   rtx with BLKmode).  The caller must pass TO through protect_from_queue\n+   before calling.  ALIGN is maximum alignment we can assume.  */\n+\n+static void\n+store_by_pieces_1 (data, align)\n+     struct store_by_pieces *data;\n+     unsigned int align;\n+{\n+  rtx to_addr = XEXP (data->to, 0);\n   unsigned HOST_WIDE_INT max_size = MOVE_MAX_PIECES + 1;\n   enum machine_mode mode = VOIDmode, tmode;\n   enum insn_code icode;\n \n-  data.offset = 0;\n-  data.to_addr = to_addr;\n-  data.to = to;\n-  data.autinc_to\n+  data->offset = 0;\n+  data->to_addr = to_addr;\n+  data->autinc_to\n     = (GET_CODE (to_addr) == PRE_INC || GET_CODE (to_addr) == PRE_DEC\n        || GET_CODE (to_addr) == POST_INC || GET_CODE (to_addr) == POST_DEC);\n \n-  data.explicit_inc_to = 0;\n-  data.reverse\n+  data->explicit_inc_to = 0;\n+  data->reverse\n     = (GET_CODE (to_addr) == PRE_DEC || GET_CODE (to_addr) == POST_DEC);\n-  if (data.reverse)\n-    data.offset = len;\n-  data.len = len;\n+  if (data->reverse)\n+    data->offset = data->len;\n \n-  /* If copying requires more than two move insns,\n+  /* If storing requires more than two move insns,\n      copy addresses to registers (to make displacements shorter)\n      and use post-increment if available.  */\n-  if (!data.autinc_to\n-      && move_by_pieces_ninsns (len, align) > 2)\n+  if (!data->autinc_to\n+      && move_by_pieces_ninsns (data->len, align) > 2)\n     {\n       /* Determine the main mode we'll be using.  */\n       for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n \t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n \tif (GET_MODE_SIZE (tmode) < max_size)\n \t  mode = tmode;\n \n-      if (USE_STORE_PRE_DECREMENT (mode) && data.reverse && ! data.autinc_to)\n+      if (USE_STORE_PRE_DECREMENT (mode) && data->reverse && ! data->autinc_to)\n \t{\n-\t  data.to_addr = copy_addr_to_reg (plus_constant (to_addr, len));\n-\t  data.autinc_to = 1;\n-\t  data.explicit_inc_to = -1;\n+\t  data->to_addr = copy_addr_to_reg (plus_constant (to_addr, data->len));\n+\t  data->autinc_to = 1;\n+\t  data->explicit_inc_to = -1;\n \t}\n \n-      if (USE_STORE_POST_INCREMENT (mode) && ! data.reverse\n-\t  && ! data.autinc_to)\n+      if (USE_STORE_POST_INCREMENT (mode) && ! data->reverse\n+\t  && ! data->autinc_to)\n \t{\n-\t  data.to_addr = copy_addr_to_reg (to_addr);\n-\t  data.autinc_to = 1;\n-\t  data.explicit_inc_to = 1;\n+\t  data->to_addr = copy_addr_to_reg (to_addr);\n+\t  data->autinc_to = 1;\n+\t  data->explicit_inc_to = 1;\n \t}\n \n-      if ( !data.autinc_to && CONSTANT_P (to_addr))\n-\tdata.to_addr = copy_addr_to_reg (to_addr);\n+      if ( !data->autinc_to && CONSTANT_P (to_addr))\n+\tdata->to_addr = copy_addr_to_reg (to_addr);\n     }\n \n   if (! SLOW_UNALIGNED_ACCESS (word_mode, align)\n       || align > MOVE_MAX * BITS_PER_UNIT || align >= BIGGEST_ALIGNMENT)\n     align = MOVE_MAX * BITS_PER_UNIT;\n \n-  /* First move what we can in the largest integer mode, then go to\n+  /* First store what we can in the largest integer mode, then go to\n      successively smaller modes.  */\n \n   while (max_size > 1)\n@@ -2329,28 +2462,28 @@ clear_by_pieces (to, len, align)\n \n       icode = mov_optab->handlers[(int) mode].insn_code;\n       if (icode != CODE_FOR_nothing && align >= GET_MODE_ALIGNMENT (mode))\n-\tclear_by_pieces_1 (GEN_FCN (icode), mode, &data);\n+\tstore_by_pieces_2 (GEN_FCN (icode), mode, data);\n \n       max_size = GET_MODE_SIZE (mode);\n     }\n \n   /* The code above should have handled everything.  */\n-  if (data.len != 0)\n+  if (data->len != 0)\n     abort ();\n }\n \n-/* Subroutine of clear_by_pieces.  Clear as many bytes as appropriate\n+/* Subroutine of store_by_pieces_1.  Store as many bytes as appropriate\n    with move instructions for mode MODE.  GENFUN is the gen_... function\n    to make a move insn for that mode.  DATA has all the other info.  */\n \n static void\n-clear_by_pieces_1 (genfun, mode, data)\n+store_by_pieces_2 (genfun, mode, data)\n      rtx (*genfun) PARAMS ((rtx, ...));\n      enum machine_mode mode;\n-     struct clear_by_pieces *data;\n+     struct store_by_pieces *data;\n {\n   unsigned int size = GET_MODE_SIZE (mode);\n-  rtx to1;\n+  rtx to1, cst;\n \n   while (data->len >= size)\n     {\n@@ -2367,9 +2500,11 @@ clear_by_pieces_1 (genfun, mode, data)\n \t\t\t      plus_constant (data->to_addr, data->offset));\n \n       if (HAVE_PRE_DECREMENT && data->explicit_inc_to < 0)\n-\temit_insn (gen_add2_insn (data->to_addr, GEN_INT (-size)));\n+\temit_insn (gen_add2_insn (data->to_addr,\n+\t\t\t\t  GEN_INT (-(HOST_WIDE_INT) size)));\n \n-      emit_insn ((*genfun) (to1, const0_rtx));\n+      cst = (*data->constfun) (data->constfundata, data->offset, mode);\n+      emit_insn ((*genfun) (to1, cst));\n \n       if (HAVE_POST_INCREMENT && data->explicit_inc_to > 0)\n \temit_insn (gen_add2_insn (data->to_addr, GEN_INT (size)));"}, {"sha": "74af2d9957fec1857d1db33da387d5cbe5975e75", "filename": "gcc/expr.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57814e5ea3528a521e997fcc6b5d658174b63e10/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57814e5ea3528a521e997fcc6b5d658174b63e10/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=57814e5ea3528a521e997fcc6b5d658174b63e10", "patch": "@@ -1010,6 +1010,25 @@ extern void use_group_regs PARAMS ((rtx *, rtx));\n    alignment.  */\n extern rtx clear_storage PARAMS ((rtx, rtx, unsigned int));\n \n+/* Return non-zero if it is desirable to store LEN bytes generated by\n+   CONSTFUN with several move instructions by store_by_pieces\n+   function.  CONSTFUNDATA is a pointer which will be passed as argument\n+   in every CONSTFUN call.\n+   ALIGN is maximum alignment we can assume.  */\n+extern int can_store_by_pieces PARAMS ((unsigned HOST_WIDE_INT,\n+\t\t\t\t\trtx (*) (PTR, HOST_WIDE_INT,\n+\t\t\t\t\t\t enum machine_mode),\n+\t\t\t\t\tPTR, unsigned int));\n+\n+/* Generate several move instructions to store LEN bytes generated by\n+   CONSTFUN to block TO.  (A MEM rtx with BLKmode).  CONSTFUNDATA is a\n+   pointer which will be passed as argument in every CONSTFUN call.\n+   ALIGN is maximum alignment we can assume.  */\n+extern void store_by_pieces PARAMS ((rtx, unsigned HOST_WIDE_INT,\n+\t\t\t\t     rtx (*) (PTR, HOST_WIDE_INT,\n+\t\t\t\t\t      enum machine_mode),\n+\t\t\t\t     PTR, unsigned int));\n+\n /* Emit insns to set X from Y.  */\n extern rtx emit_move_insn PARAMS ((rtx, rtx));\n "}, {"sha": "d957093118e3a5b86802182f9f97544008343ac9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57814e5ea3528a521e997fcc6b5d658174b63e10/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57814e5ea3528a521e997fcc6b5d658174b63e10/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=57814e5ea3528a521e997fcc6b5d658174b63e10", "patch": "@@ -1,3 +1,9 @@\n+2000-11-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.c-torture/execute/string-opt-5.c: Add some strcmp and strncpy\n+\ttests.\n+\t* gcc.c-torture/execute/string-opt-6.c: New test.\n+\n 2000-11-28  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* gcc.dg/noncompile/940510-1.c: Update to test c89 functionality."}, {"sha": "108c3ed4773889d7efdbb187bfee8824bae7f703", "filename": "gcc/testsuite/gcc.c-torture/execute/string-opt-5.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57814e5ea3528a521e997fcc6b5d658174b63e10/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57814e5ea3528a521e997fcc6b5d658174b63e10/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-5.c?ref=57814e5ea3528a521e997fcc6b5d658174b63e10", "patch": "@@ -1,6 +1,7 @@\n /* Copyright (C) 2000  Free Software Foundation.\n \n-   Ensure builtin strlen, strcmp, strchr and strrchr perform correctly.\n+   Ensure builtin strlen, strcmp, strchr, strrchr and strncpy\n+   perform correctly.\n \n    Written by Jakub Jelinek, 11/7/2000.  */\n \n@@ -9,13 +10,18 @@ extern __SIZE_TYPE__ strlen (const char *);\n extern int strcmp (const char *, const char *);\n extern char *strchr (const char *, int);\n extern char *strrchr (const char *, int);\n+extern char *strncpy (char *, const char *, __SIZE_TYPE__);\n+extern void *memset (void *, int, __SIZE_TYPE__);\n+extern int memcmp (const void *, const void *, __SIZE_TYPE__);\n \n int x = 6;\n+int y = 1;\n char *bar = \"hi world\";\n \n int main()\n {\n   const char *const foo = \"hello world\";\n+  char dst [64];\n \n   if (strlen (bar) != 8)\n     abort ();\n@@ -53,6 +59,27 @@ int main()\n     abort ();\n   if (strrchr (bar, 'o') != bar + 4)\n     abort ();\n+  if (strcmp (foo + (x++ & 1), \"ello world\" + (--y & 1)))\n+    abort ();\n+  if (x != 6 || y != 0)\n+    abort ();\n+  dst[5] = ' ';\n+  dst[6] = '\\0';\n+  x = 5;\n+  y = 1;\n+  if (strncpy (dst + 1, foo + (x++ & 3), 4) != dst + 1\n+      || x != 6\n+      || strcmp (dst + 1, \"ello \"))\n+    abort ();\n+  memset (dst, ' ', sizeof dst);\n+  if (strncpy (dst + (++x & 1), (y++ & 3) + \"foo\", 10) != dst + 1\n+      || x != 7\n+      || y != 2\n+      || memcmp (dst, \" oo\\0\\0\\0\\0\\0\\0\\0\\0 \", 12))\n+    abort ();\n+  memset (dst, ' ', sizeof dst);\n+  if (strncpy (dst, \"hello\", 8) != dst || memcmp (dst, \"hello\\0\\0\\0 \", 9))\n+    abort();\n \n   return 0;\n }"}, {"sha": "781d96f1dcf6a59032495f36851efefe386efd81", "filename": "gcc/testsuite/gcc.c-torture/execute/string-opt-6.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57814e5ea3528a521e997fcc6b5d658174b63e10/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57814e5ea3528a521e997fcc6b5d658174b63e10/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-6.c?ref=57814e5ea3528a521e997fcc6b5d658174b63e10", "patch": "@@ -0,0 +1,46 @@\n+/* Copyright (C) 2000  Free Software Foundation.\n+\n+   Ensure builtin memcpy and strcpy perform correctly.\n+\n+   Written by Jakub Jelinek, 11/24/2000.  */\n+\n+extern void abort (void);\n+extern char *strcpy (char *, const char *);\n+typedef __SIZE_TYPE__ size_t;\n+extern void *memcpy (void *, const void *, size_t);\n+extern int memcmp (const void *, const void *, size_t);\n+\n+char p[32] = \"\";\n+\n+int main()\n+{\n+  if (strcpy (p, \"abcde\") != p || memcmp (p, \"abcde\", 6))\n+    abort ();\n+  if (strcpy (p + 16, \"vwxyz\" + 1) != p + 16 || memcmp (p + 16, \"wxyz\", 5))\n+    abort ();\n+  if (strcpy (p + 1, \"\") != p + 1 || memcmp (p, \"a\\0cde\", 6))\n+    abort ();  \n+  if (strcpy (p + 3, \"fghij\") != p + 3 || memcmp (p, \"a\\0cfghij\", 9))\n+    abort ();\n+  if (memcpy (p, \"ABCDE\", 6) != p || memcmp (p, \"ABCDE\", 6))\n+    abort ();\n+  if (memcpy (p + 16, \"VWX\" + 1, 2) != p + 16 || memcmp (p + 16, \"WXyz\", 5))\n+    abort ();\n+  if (memcpy (p + 1, \"\", 1) != p + 1 || memcmp (p, \"A\\0CDE\", 6))\n+    abort ();  \n+  if (memcpy (p + 3, \"FGHI\", 4) != p + 3 || memcmp (p, \"A\\0CFGHIj\", 9))\n+    abort ();\n+\n+  return 0;\n+}\n+\n+#ifdef __OPTIMIZE__\n+/* When optimizing, all the above cases should be transformed into\n+   something else.  So any remaining calls to the original function\n+   should abort.  */\n+static char *\n+strcpy (char *d, const char *s)\n+{\n+  abort ();\n+}\n+#endif"}]}