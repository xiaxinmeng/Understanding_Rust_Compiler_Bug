{"sha": "e7f23f0645d60bad0ce49f0983f18f4e5d01a93e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdmMjNmMDY0NWQ2MGJhZDBjZTQ5ZjA5ODNmMThmNGU1ZDAxYTkzZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-10T12:20:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-10T12:20:55Z"}, "message": "[multiple changes]\n\n2013-10-10  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb: Add an entry for Aspect_Refined_Post in table\n\tCanonical_Aspect.\n\t* aspects.ads: Add an entry for Aspect_Refined_Post in tables\n\tAspect_Id, Aspect_Argument, Aspect_Names, Aspect_Delay,\n\tAspect_On_Body_Or_Stub_OK. Update the comment on the use of\n\ttable Aspect_On_Body_Or_Stub_OK.\n\t* par-prag.adb: Add pragma Refined_Post to the list of pragmas\n\tthat do not require special processing by the parser.\n\t* sem_attr.adb (Analyze_Attribute): Add special analysis for\n\tattributes 'Old and 'Result when code generation is disabled and\n\tthey appear in aspect/pragma Refined_Post.\n\t(In_Refined_Post): New routine.\n\t* sem_ch6.adb (Analyze_Expression_Function): Move various\n\taspects and/or pragmas that apply to an expression function to the\n\tcorresponding spec or body.\n\t(Collect_Body_Postconditions): New routine.\n\t(Process_PPCs): Use routine Collect_Body_Postconditions\n\tto gather all postcondition pragmas.\n\t* sem_ch10.adb (Analyze_Proper_Body): Use routine\n\tRelocate_Pragmas_To_Body to move all source pragmas that follow\n\ta body stub to the proper body.\n\t(Move_Stub_Pragmas_To_Body): Removed.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add processing\n\tfor aspect Refined_Post.\n\t(Check_Aspect_At_Freeze_Point): Aspect\n\tRefined_Post does not need delayed processing at the freeze point.\n\t* sem_prag.adb: Add an entry for pragma Refined_Post in\n\ttable Sig_Flags.\n\t(Analyze_Pragma): Add processing for pragma\n\tRefined_Post. Update the processing of pragma Refined_Pre\n\tto use common routine Analyze_Refined_Pre_Post.\n\t(Analyze_Refined_Pre_Post): New routine.\n\t(Relocate_Pragmas_To_Body): New routine.\n\t* sem_prag.ads: Table Pragma_On_Stub_OK is now known as\n\tPragma_On_Body_Or_Stub_OK. Update the comment on usage of\n\ttable Pragma_On_Body_Or_Stub_OK.\n\t(Relocate_Pragmas_To_Body): New routine.\n\t* snames.ads-tmpl: Add new predefined name for Refined_Post. Add\n\tnew Pragma_Id for Refined_Post.\n\n2013-10-10  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch3.adb (Expand_N_Variant_Part): Now null, expansion of\n\tlast choice to others is moved to Freeze_Record_Type.\n\t* freeze.adb (Freeze_Record_Type): Expand last variant to others\n\tif necessary (moved here from Expand_N_Variant_Part\n\nFrom-SVN: r203359", "tree": {"sha": "f3223132b6647adb05476ee992f818a4de61b3cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3223132b6647adb05476ee992f818a4de61b3cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/comments", "author": null, "committer": null, "parents": [{"sha": "15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15918371923d3e31a9f74c46fbe94e7e1e6d76e6"}], "stats": {"total": 912, "additions": 632, "deletions": 280}, "files": [{"sha": "74d518b78939b0d93945641d76b7afde60766ce8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e7f23f0645d60bad0ce49f0983f18f4e5d01a93e", "patch": "@@ -1,3 +1,52 @@\n+2013-10-10  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb: Add an entry for Aspect_Refined_Post in table\n+\tCanonical_Aspect.\n+\t* aspects.ads: Add an entry for Aspect_Refined_Post in tables\n+\tAspect_Id, Aspect_Argument, Aspect_Names, Aspect_Delay,\n+\tAspect_On_Body_Or_Stub_OK. Update the comment on the use of\n+\ttable Aspect_On_Body_Or_Stub_OK.\n+\t* par-prag.adb: Add pragma Refined_Post to the list of pragmas\n+\tthat do not require special processing by the parser.\n+\t* sem_attr.adb (Analyze_Attribute): Add special analysis for\n+\tattributes 'Old and 'Result when code generation is disabled and\n+\tthey appear in aspect/pragma Refined_Post.\n+\t(In_Refined_Post): New routine.\n+\t* sem_ch6.adb (Analyze_Expression_Function): Move various\n+\taspects and/or pragmas that apply to an expression function to the\n+\tcorresponding spec or body.\n+\t(Collect_Body_Postconditions): New routine.\n+\t(Process_PPCs): Use routine Collect_Body_Postconditions\n+\tto gather all postcondition pragmas.\n+\t* sem_ch10.adb (Analyze_Proper_Body): Use routine\n+\tRelocate_Pragmas_To_Body to move all source pragmas that follow\n+\ta body stub to the proper body.\n+\t(Move_Stub_Pragmas_To_Body): Removed.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add processing\n+\tfor aspect Refined_Post.\n+\t(Check_Aspect_At_Freeze_Point): Aspect\n+\tRefined_Post does not need delayed processing at the freeze point.\n+\t* sem_prag.adb: Add an entry for pragma Refined_Post in\n+\ttable Sig_Flags.\n+\t(Analyze_Pragma): Add processing for pragma\n+\tRefined_Post. Update the processing of pragma Refined_Pre\n+\tto use common routine Analyze_Refined_Pre_Post.\n+\t(Analyze_Refined_Pre_Post): New routine.\n+\t(Relocate_Pragmas_To_Body): New routine.\n+\t* sem_prag.ads: Table Pragma_On_Stub_OK is now known as\n+\tPragma_On_Body_Or_Stub_OK. Update the comment on usage of\n+\ttable Pragma_On_Body_Or_Stub_OK.\n+\t(Relocate_Pragmas_To_Body): New routine.\n+\t* snames.ads-tmpl: Add new predefined name for Refined_Post. Add\n+\tnew Pragma_Id for Refined_Post.\n+\n+2013-10-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Variant_Part): Now null, expansion of\n+\tlast choice to others is moved to Freeze_Record_Type.\n+\t* freeze.adb (Freeze_Record_Type): Expand last variant to others\n+\tif necessary (moved here from Expand_N_Variant_Part\n+\n 2013-10-10  Robert Dewar  <dewar@adacore.com>\n \n \t* lib-xref-spark_specific.adb, par-ch13.adb, sem_prag.adb, sem_prag.ads,"}, {"sha": "638fdbedc2994cd34e314fb17a5127bc55ff8478", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=e7f23f0645d60bad0ce49f0983f18f4e5d01a93e", "patch": "@@ -466,6 +466,7 @@ package body Aspects is\n     Aspect_Pure_05                      => Aspect_Pure_05,\n     Aspect_Pure_12                      => Aspect_Pure_12,\n     Aspect_Pure_Function                => Aspect_Pure_Function,\n+    Aspect_Refined_Post                 => Aspect_Refined_Post,\n     Aspect_Refined_Pre                  => Aspect_Refined_Pre,\n     Aspect_Remote_Access_Type           => Aspect_Remote_Access_Type,\n     Aspect_Remote_Call_Interface        => Aspect_Remote_Call_Interface,"}, {"sha": "d2f5d6939a67d6226553e735aa0af6904dbac6ca", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=e7f23f0645d60bad0ce49f0983f18f4e5d01a93e", "patch": "@@ -111,6 +111,7 @@ package Aspects is\n       Aspect_Predicate,                     -- GNAT\n       Aspect_Priority,\n       Aspect_Read,\n+      Aspect_Refined_Post,                  -- GNAT\n       Aspect_Refined_Pre,                   -- GNAT\n       Aspect_Relative_Deadline,\n       Aspect_Scalar_Storage_Order,          -- GNAT\n@@ -320,6 +321,7 @@ package Aspects is\n       Aspect_Predicate               => Expression,\n       Aspect_Priority                => Expression,\n       Aspect_Read                    => Name,\n+      Aspect_Refined_Post            => Expression,\n       Aspect_Refined_Pre             => Expression,\n       Aspect_Relative_Deadline       => Expression,\n       Aspect_Scalar_Storage_Order    => Expression,\n@@ -417,6 +419,7 @@ package Aspects is\n       Aspect_Pure_12                      => Name_Pure_12,\n       Aspect_Pure_Function                => Name_Pure_Function,\n       Aspect_Read                         => Name_Read,\n+      Aspect_Refined_Post                 => Name_Refined_Post,\n       Aspect_Refined_Pre                  => Name_Refined_Pre,\n       Aspect_Relative_Deadline            => Name_Relative_Deadline,\n       Aspect_Remote_Access_Type           => Name_Remote_Access_Type,\n@@ -639,6 +642,7 @@ package Aspects is\n       Aspect_Convention                   => Never_Delay,\n       Aspect_Dimension                    => Never_Delay,\n       Aspect_Dimension_System             => Never_Delay,\n+      Aspect_Refined_Post                 => Never_Delay,\n       Aspect_Refined_Pre                  => Never_Delay,\n       Aspect_SPARK_Mode                   => Never_Delay,\n       Aspect_Synchronization              => Never_Delay,\n@@ -695,8 +699,12 @@ package Aspects is\n    --    package P with SPARK_Mode ...;\n    --    package body P with SPARK_Mode is ...;\n \n+   --  The table should be synchronized with Pragma_On_Body_Or_Stub_OK in unit\n+   --  Sem_Prag if the aspects below are implemented by a pragma.\n+\n    Aspect_On_Body_Or_Stub_OK : constant array (Aspect_Id) of Boolean :=\n-     (Aspect_Refined_Pre                  => True,\n+     (Aspect_Refined_Post                 => True,\n+      Aspect_Refined_Pre                  => True,\n       Aspect_SPARK_Mode                   => True,\n       Aspect_Warnings                     => True,\n       others                              => False);"}, {"sha": "98ad0e21cf2064413efd985dd60ce3cf9c8190a0", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=e7f23f0645d60bad0ce49f0983f18f4e5d01a93e", "patch": "@@ -5846,31 +5846,18 @@ package body Exp_Ch3 is\n    -- Expand_N_Variant_Part --\n    ---------------------------\n \n-   procedure Expand_N_Variant_Part (N : Node_Id) is\n-      Last_Var    : constant Node_Id := Last_Non_Pragma (Variants (N));\n-      Others_Node : Node_Id;\n+   --  Note: this procedure no longer has any effect. It used to be that we\n+   --  would replace the choices in the last variant by a when others, and\n+   --  also expanded static predicates in variant choices here, but both of\n+   --  those activities were being done too early, since we can't check the\n+   --  choices until the statically predicated subtypes are frozen, which can\n+   --  happen as late as the free point of the record, and we can't change the\n+   --  last choice to an others before checking the choices, which is now done\n+   --  at the freeze point of the record.\n \n+   procedure Expand_N_Variant_Part (N : Node_Id) is\n    begin\n-      --  If the last variant does not contain the Others choice, replace it\n-      --  with an N_Others_Choice node since Gigi always wants an Others. Note\n-      --  that we do not bother to call Analyze on the modified variant part,\n-      --  since its only effect would be to compute the Others_Discrete_Choices\n-      --  node laboriously, and of course we already know the list of choices\n-      --  corresponding to the others choice (it's the list we're replacing!)\n-\n-      if Nkind (First (Discrete_Choices (Last_Var))) /= N_Others_Choice then\n-         Others_Node := Make_Others_Choice (Sloc (Last_Var));\n-         Set_Others_Discrete_Choices\n-           (Others_Node, Discrete_Choices (Last_Var));\n-         Set_Discrete_Choices (Last_Var, New_List (Others_Node));\n-      end if;\n-\n-      --  We have one more expansion activity, which is to deal with static\n-      --  predicates in the variant choices. But we have to defer that to\n-      --  the freeze point, because the statically predicated subtype won't\n-      --  be fully processed till then, so this expansion activity is carried\n-      --  out in Freeze_Record_Type.\n-\n+      null;\n    end Expand_N_Variant_Part;\n \n    ---------------------------------"}, {"sha": "e8a2d9fb52bc837077e57f9a888323ca46bd5d09", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=e7f23f0645d60bad0ce49f0983f18f4e5d01a93e", "patch": "@@ -2639,7 +2639,7 @@ package body Freeze is\n             C : Node_Id;\n             V : Node_Id;\n \n-            Others_Present            : Boolean;\n+            Others_Present : Boolean;\n             pragma Warnings (Off, Others_Present);\n             --  Indicates others present, not used in this case\n \n@@ -2748,12 +2748,38 @@ package body Freeze is\n                end if;\n             end if;\n \n-            --  If we have a variant part, check choices\n+            --  Case of variant part present\n \n             if Present (C) and then Present (Variant_Part (C)) then\n                V := Variant_Part (C);\n+\n+               --  Check choices\n+\n                Check_Choices\n                  (V, Variants (V), Etype (Name (V)), Others_Present);\n+\n+               --  If the last variant does not contain the Others choice,\n+               --  replace it with an N_Others_Choice node since Gigi always\n+               --  wants an Others. Note that we do not bother to call Analyze\n+               --  on the modified variant part, since its only effect would be\n+               --  to compute the Others_Discrete_Choices node laboriously, and\n+               --  of course we already know the list of choices corresponding\n+               --  to the others choice (it's the list we're replacing!)\n+\n+               declare\n+                  Last_Var    : constant Node_Id :=\n+                                  Last_Non_Pragma (Variants (V));\n+                  Others_Node : Node_Id;\n+               begin\n+                  if Nkind (First (Discrete_Choices (Last_Var))) /=\n+                                                            N_Others_Choice\n+                  then\n+                     Others_Node := Make_Others_Choice (Sloc (Last_Var));\n+                     Set_Others_Discrete_Choices\n+                       (Others_Node, Discrete_Choices (Last_Var));\n+                     Set_Discrete_Choices (Last_Var, New_List (Others_Node));\n+                  end if;\n+               end;\n             end if;\n          end Check_Variant_Part;\n       end Freeze_Record_Type;"}, {"sha": "85ebe3bdeb7115a79d9e0a4f84d15cd88516a490", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=e7f23f0645d60bad0ce49f0983f18f4e5d01a93e", "patch": "@@ -1250,6 +1250,7 @@ begin\n            Pragma_Pure_12                        |\n            Pragma_Pure_Function                  |\n            Pragma_Queuing_Policy                 |\n+           Pragma_Refined_Post                   |\n            Pragma_Refined_Pre                    |\n            Pragma_Relative_Deadline              |\n            Pragma_Remote_Access_Type             |"}, {"sha": "91079a836f289fa04b7918769b81e8b4ef6b4001", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 121, "deletions": 13, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=e7f23f0645d60bad0ce49f0983f18f4e5d01a93e", "patch": "@@ -303,10 +303,6 @@ package body Sem_Attr is\n       --  Verify that prefix of attribute N is a float type and that\n       --  two attribute expressions are present\n \n-      procedure Legal_Formal_Attribute;\n-      --  Common processing for attributes Definite and Has_Discriminants.\n-      --  Checks that prefix is generic indefinite formal type.\n-\n       procedure Check_SPARK_Restriction_On_Attribute;\n       --  Issue an error in formal mode because attribute N is allowed\n \n@@ -377,6 +373,14 @@ package body Sem_Attr is\n       pragma No_Return (Error_Attr);\n       --  Like Error_Attr, but error is posted at the start of the prefix\n \n+      function In_Refined_Post return Boolean;\n+      --  Determine whether the current attribute appears in pragma\n+      --  Refined_Post.\n+\n+      procedure Legal_Formal_Attribute;\n+      --  Common processing for attributes Definite and Has_Discriminants.\n+      --  Checks that prefix is generic indefinite formal type.\n+\n       procedure Standard_Attribute (Val : Int);\n       --  Used to process attributes whose prefix is package Standard which\n       --  yield values of type Universal_Integer. The attribute reference\n@@ -1927,6 +1931,60 @@ package body Sem_Attr is\n          Error_Attr;\n       end Error_Attr_P;\n \n+      ---------------------\n+      -- In_Refined_Post --\n+      ---------------------\n+\n+      function In_Refined_Post return Boolean is\n+         function Is_Refined_Post (Prag : Node_Id) return Boolean;\n+         --  Determine whether Prag denotes one of the incarnations of pragma\n+         --  Refined_Post (either as is or pragma Check (Refined_Post, ...).\n+\n+         ---------------------\n+         -- Is_Refined_Post --\n+         ---------------------\n+\n+         function Is_Refined_Post (Prag : Node_Id) return Boolean is\n+            Args : constant List_Id := Pragma_Argument_Associations (Prag);\n+            Nam  : constant Name_Id := Pragma_Name (Prag);\n+\n+         begin\n+            if Nam = Name_Refined_Post then\n+               return True;\n+\n+            elsif Nam = Name_Check then\n+               pragma Assert (Present (Args));\n+\n+               return Chars (Expression (First (Args))) = Name_Refined_Post;\n+            end if;\n+\n+            return False;\n+         end Is_Refined_Post;\n+\n+         --  Local variables\n+\n+         Stmt : Node_Id;\n+\n+      --  Start of processing for In_Refined_Post\n+\n+      begin\n+         Stmt := Parent (N);\n+         while Present (Stmt) loop\n+            if Nkind (Stmt) = N_Pragma and then Is_Refined_Post (Stmt) then\n+               return True;\n+\n+            --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Stmt) then\n+               exit;\n+            end if;\n+\n+            Stmt := Parent (Stmt);\n+         end loop;\n+\n+         return False;\n+      end In_Refined_Post;\n+\n       ----------------------------\n       -- Legal_Formal_Attribute --\n       ----------------------------\n@@ -4281,7 +4339,32 @@ package body Sem_Attr is\n                Error_Attr (\"% attribute can only appear in postcondition\", P);\n             end if;\n \n-         --  Body case, where we must be inside a generated _Postcondition\n+         --  Check the legality of attribute 'Old when it appears inside pragma\n+         --  Refined_Post. These specialized checks are required only when code\n+         --  generation is disabled. In the general case pragma Refined_Post is\n+         --  transformed into pragma Check by Process_PPCs which in turn is\n+         --  relocated to procedure _Postconditions. From then on the legality\n+         --  of 'Old is determined as usual.\n+\n+         elsif not Expander_Active and then In_Refined_Post then\n+            Preanalyze_And_Resolve (P);\n+            P_Type := Etype (P);\n+            Set_Etype (N, P_Type);\n+\n+            if Is_Limited_Type (P_Type) then\n+               Error_Attr (\"attribute % cannot apply to limited objects\", P);\n+            end if;\n+\n+            if Is_Entity_Name (P)\n+              and then Is_Constant_Object (Entity (P))\n+            then\n+               Error_Msg_N\n+                 (\"??attribute Old applied to constant has no effect\", P);\n+            end if;\n+\n+            return;\n+\n+         --  Body case, where we must be inside a generated _Postconditions\n          --  procedure, or else the attribute use is definitely misplaced. The\n          --  postcondition itself may have generated transient scopes, and is\n          --  not necessarily the current one.\n@@ -4302,8 +4385,8 @@ package body Sem_Attr is\n \n          --  If the attribute reference is generated for a Requires clause,\n          --  then no expressions follow. Otherwise it is a primary, in which\n-         --  case, if expressions follow, the attribute reference must be\n-         --  an indexable object, so rewrite the node accordingly.\n+         --  case, if expressions follow, the attribute reference must be an\n+         --  indexable object, so rewrite the node accordingly.\n \n          if Present (E1) then\n             Rewrite (N,\n@@ -4320,8 +4403,8 @@ package body Sem_Attr is\n \n          Check_E0;\n \n-         --  Prefix has not been analyzed yet, and its full analysis will\n-         --  take place during expansion (see below).\n+         --  Prefix has not been analyzed yet, and its full analysis will take\n+         --  place during expansion (see below).\n \n          Preanalyze_And_Resolve (P);\n          P_Type := Etype (P);\n@@ -4725,7 +4808,32 @@ package body Sem_Attr is\n                Set_Is_Overloaded (P, False);\n             end if;\n \n-         --  Body case, where we must be inside a generated _Postcondition\n+         --  Check the legality of attribute 'Result when it appears inside\n+         --  pragma Refined_Post. These specialized checks are required only\n+         --  when code generation is disabled. In the general case pragma\n+         --  Refined_Post is transformed into pragma Check by Process_PPCs\n+         --  which in turn is relocated to procedure _Postconditions. From\n+         --  then on the legality of 'Result is determined as usual.\n+\n+         elsif not Expander_Active and then In_Refined_Post then\n+            PS := Current_Scope;\n+\n+            --  The prefix denotes the proper related function\n+\n+            if Is_Entity_Name (P)\n+              and then Ekind (Entity (P)) = E_Function\n+              and then Entity (P) = PS\n+            then\n+               null;\n+\n+            else\n+               Error_Msg_Name_2 := Chars (PS);\n+               Error_Attr (\"incorrect prefix for % attribute, expected %\", P);\n+            end if;\n+\n+            Set_Etype (N, Etype (PS));\n+\n+         --  Body case, where we must be inside a generated _Postconditions\n          --  procedure, and the prefix must be on the scope stack, or else the\n          --  attribute use is definitely misplaced. The postcondition itself\n          --  may have generated transient scopes, and is not necessarily the\n@@ -4763,9 +4871,9 @@ package body Sem_Attr is\n                   null;\n \n                else\n-                  Error_Msg_NE\n-                    (\"incorrect prefix for % attribute, expected &\", P, PS);\n-                  Error_Attr;\n+                  Error_Msg_Name_2 := Chars (PS);\n+                  Error_Attr\n+                    (\"incorrect prefix for % attribute, expected %\", P);\n                end if;\n \n                Rewrite (N, Make_Identifier (Sloc (N), Name_uResult));"}, {"sha": "8d64964ac784bc2dd5663d59ce0bc15cd436e8d9", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 3, "deletions": 76, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=e7f23f0645d60bad0ce49f0983f18f4e5d01a93e", "patch": "@@ -1596,85 +1596,12 @@ package body Sem_Ch10 is\n       Subunit_Name : constant Unit_Name_Type := Get_Unit_Name (N);\n       Unum         : Unit_Number_Type;\n \n-      procedure Move_Stub_Pragmas_To_Body (Bod : Node_Id);\n-      --  Relocate all pragmas that apply to a subprogram body stub to the\n-      --  declarations of proper body Bod.\n-      --  Should we do this for the reamining body stub kinds???\n-\n       procedure Optional_Subunit;\n       --  This procedure is called when the main unit is a stub, or when we\n       --  are not generating code. In such a case, we analyze the subunit if\n       --  present, which is user-friendly and in fact required for ASIS, but\n       --  we don't complain if the subunit is missing.\n \n-      -------------------------------\n-      -- Move_Stub_Pragmas_To_Body --\n-      -------------------------------\n-\n-      procedure Move_Stub_Pragmas_To_Body (Bod : Node_Id) is\n-         procedure Move_Pragma (Prag : Node_Id);\n-         --  Relocate one pragma to the declarations of Bod\n-\n-         -----------------\n-         -- Move_Pragma --\n-         -----------------\n-\n-         procedure Move_Pragma (Prag : Node_Id) is\n-            Decls : List_Id := Declarations (Bod);\n-\n-         begin\n-            if No (Decls) then\n-               Decls := New_List;\n-               Set_Declarations (Bod, Decls);\n-            end if;\n-\n-            --  Unhook the pragma from its current list\n-\n-            Remove (Prag);\n-            Prepend (Prag, Decls);\n-         end Move_Pragma;\n-\n-         --  Local variables\n-\n-         Next_Stmt : Node_Id;\n-         Stmt      : Node_Id;\n-\n-      --  Start of processing for Move_Stub_Pragmas_To_Body\n-\n-      begin\n-         pragma Assert (Nkind (N) = N_Subprogram_Body_Stub);\n-\n-         --  Perform a bit of a lookahead - peek at any subsequent source\n-         --  pragmas while skipping internally generated code.\n-\n-         Stmt := Next (N);\n-         while Present (Stmt) loop\n-            Next_Stmt := Next (Stmt);\n-\n-            --  Move a source pragma that applies to a subprogram stub to the\n-            --  declarations of the proper body.\n-\n-            if Comes_From_Source (Stmt)\n-              and then Nkind (Stmt) = N_Pragma\n-              and then Pragma_On_Stub_OK (Get_Pragma_Id (Stmt))\n-            then\n-               Move_Pragma (Stmt);\n-\n-            --  Skip internally generated code\n-\n-            elsif not Comes_From_Source (Stmt) then\n-               null;\n-\n-            --  No valid pragmas are available for relocation\n-\n-            else\n-               exit;\n-            end if;\n-\n-            Stmt := Next_Stmt;\n-         end loop;\n-      end Move_Stub_Pragmas_To_Body;\n-\n       ----------------------\n       -- Optional_Subunit --\n       ----------------------\n@@ -1932,11 +1859,11 @@ package body Sem_Ch10 is\n \n                      Move_Or_Merge_Aspects (From => N, To => Prop_Body);\n \n-                     --  Propagate all source pragmas associated with a\n-                     --  subprogram body stub to the proper body.\n+                     --  Move all source pragmas that follow the body stub and\n+                     --  apply to it to the declarations of the proper body.\n \n                      if Nkind (N) = N_Subprogram_Body_Stub then\n-                        Move_Stub_Pragmas_To_Body (Prop_Body);\n+                        Relocate_Pragmas_To_Body (N, Target_Body => Prop_Body);\n                      end if;\n \n                      --  Analyze the unit if semantics active"}, {"sha": "7f6c9acb94366cb2a20d8538f10ed98e6586436c", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=e7f23f0645d60bad0ce49f0983f18f4e5d01a93e", "patch": "@@ -1928,6 +1928,15 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_SPARK_Mode);\n \n+               --  Refined_Post\n+\n+               when Aspect_Refined_Post =>\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Refined_Post);\n+\n                --  Refined_Pre\n \n                when Aspect_Refined_Pre =>\n@@ -7788,6 +7797,7 @@ package body Sem_Ch13 is\n               Aspect_Postcondition        |\n               Aspect_Pre                  |\n               Aspect_Precondition         |\n+              Aspect_Refined_Post         |\n               Aspect_Refined_Pre          |\n               Aspect_SPARK_Mode           |\n               Aspect_Test_Case            =>"}, {"sha": "e313f3518d81add5d940ac71865748894977e8a9", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 85, "deletions": 43, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=e7f23f0645d60bad0ce49f0983f18f4e5d01a93e", "patch": "@@ -349,15 +349,25 @@ package body Sem_Ch6 is\n             Make_Handled_Sequence_Of_Statements (LocX,\n               Statements => New_List (Ret)));\n \n+      --  If the expression completes a generic subprogram, we must create a\n+      --  separate node for the body, because at instantiation the original\n+      --  node of the generic copy must be a generic subprogram body, and\n+      --  cannot be a expression function. Otherwise we just rewrite the\n+      --  expression with the non-generic body.\n+\n       if Present (Prev) and then Ekind (Prev) = E_Generic_Function then\n+         Insert_After (N, New_Body);\n \n-         --  If the expression completes a generic subprogram, we must create a\n-         --  separate node for the body, because at instantiation the original\n-         --  node of the generic copy must be a generic subprogram body, and\n-         --  cannot be a expression function. Otherwise we just rewrite the\n-         --  expression with the non-generic body.\n+         --  Propagate any aspects or pragmas that apply to the expression\n+         --  function to the proper body when the expression function acts\n+         --  as a completion.\n+\n+         if Has_Aspects (N) then\n+            Move_Aspects (N, To => New_Body);\n+         end if;\n+\n+         Relocate_Pragmas_To_Body (New_Body);\n \n-         Insert_After (N, New_Body);\n          Rewrite (N, Make_Null_Statement (Loc));\n          Set_Has_Completion (Prev, False);\n          Analyze (N);\n@@ -371,6 +381,12 @@ package body Sem_Ch6 is\n \n          Generate_Reference (Prev, Defining_Entity (N), 'b', Force => True);\n          Rewrite (N, New_Body);\n+\n+         --  Propagate any pragmas that apply to the expression function to the\n+         --  proper body when the expression function acts as a completion.\n+         --  Aspects are automatically transfered because of node rewriting.\n+\n+         Relocate_Pragmas_To_Body (N);\n          Analyze (N);\n \n          --  Prev is the previous entity with the same name, but it is can\n@@ -11274,6 +11290,11 @@ package body Sem_Ch6 is\n       --  under the same visibility conditions as for other invariant checks,\n       --  the type invariant must be applied to the returned value.\n \n+      procedure Collect_Body_Postconditions (Post_Nam : Name_Id);\n+      --  Examine the declarations of the body, looking for pragmas with name\n+      --  Post_Nam. Parameter Post_Nam must denote either Name_Postcondition or\n+      --  Name_Refined_Post. Chain any relevant postconditions to Plist.\n+\n       function Grab_PPC (Pspec : Entity_Id := Empty) return Node_Id;\n       --  Prag contains an analyzed precondition or postcondition pragma. This\n       --  function copies the pragma, changes it to the corresponding Check\n@@ -11365,6 +11386,60 @@ package body Sem_Ch6 is\n          end if;\n       end Check_Access_Invariants;\n \n+      ---------------------------------\n+      -- Collect_Body_Postconditions --\n+      ---------------------------------\n+\n+      procedure Collect_Body_Postconditions (Post_Nam : Name_Id) is\n+         Next_Prag : Node_Id;\n+\n+      begin\n+         pragma Assert\n+           (Nam_In (Post_Nam, Name_Postcondition, Name_Refined_Post));\n+\n+         Prag := First (Declarations (N));\n+         while Present (Prag) loop\n+            Next_Prag := Next (Prag);\n+\n+            if Nkind (Prag) = N_Pragma then\n+\n+               --  Capture postcondition pragmas\n+\n+               if Pragma_Name (Prag) = Post_Nam then\n+                  Analyze (Prag);\n+\n+                  --  All Refined_Post pragmas must be relocated to the body\n+                  --  of the generated _Postconditions routine, otherwise they\n+                  --  will be duplicated twice - once in the declarations of\n+                  --  the body and once in _Postconditions.\n+\n+                  if Pragma_Name (Prag) = Name_Refined_Post then\n+                     Remove (Prag);\n+                  end if;\n+\n+                  --  If expansion is disabled, as in a generic unit, save\n+                  --  pragma for later expansion.\n+\n+                  if not Expander_Active then\n+                     Prepend (Grab_PPC, Declarations (N));\n+                  else\n+                     Append_Enabled_Item (Grab_PPC, Plist);\n+                  end if;\n+               end if;\n+\n+            --  Skip internally generated code\n+\n+            elsif not Comes_From_Source (Prag) then\n+               null;\n+\n+            else\n+               exit;\n+            end if;\n+\n+            Prag := Next_Prag;\n+         end loop;\n+      end Collect_Body_Postconditions;\n+\n       --------------\n       -- Grab_PPC --\n       --------------\n@@ -11791,6 +11866,8 @@ package body Sem_Ch6 is\n \n       --     procedure _postconditions [(_Result : resulttype)] is\n       --     begin\n+      --        pragma Check (Refined_Post, condition);\n+      --        pragma Check (Refined_Post, condition);\n       --        pragma Check (Postcondition, condition [,message]);\n       --        pragma Check (Postcondition, condition [,message]);\n       --        ...\n@@ -11801,43 +11878,8 @@ package body Sem_Ch6 is\n \n       --  First we deal with the postconditions in the body\n \n-      if Is_Non_Empty_List (Declarations (N)) then\n-\n-         --  Loop through declarations\n-\n-         Prag := First (Declarations (N));\n-         while Present (Prag) loop\n-            if Nkind (Prag) = N_Pragma then\n-\n-               --  Capture postcondition pragmas\n-\n-               if Pragma_Name (Prag) = Name_Postcondition then\n-                  Analyze (Prag);\n-\n-                  --  If expansion is disabled, as in a generic unit, save\n-                  --  pragma for later expansion.\n-\n-                  if not Expander_Active then\n-                     Prepend (Grab_PPC, Declarations (N));\n-                  else\n-                     Append_Enabled_Item (Grab_PPC, Plist);\n-                  end if;\n-               end if;\n-\n-               Next (Prag);\n-\n-            --  Not a pragma, if comes from source, then end scan\n-\n-            elsif Comes_From_Source (Prag) then\n-               exit;\n-\n-            --  Skip stuff not coming from source\n-\n-            else\n-               Next (Prag);\n-            end if;\n-         end loop;\n-      end if;\n+      Collect_Body_Postconditions (Name_Refined_Post);\n+      Collect_Body_Postconditions (Name_Postcondition);\n \n       --  Now deal with any postconditions from the spec\n "}, {"sha": "d8c32ddf99625a67a7712b54526153f9685e6159", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 297, "deletions": 119, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=e7f23f0645d60bad0ce49f0983f18f4e5d01a93e", "patch": "@@ -1922,6 +1922,16 @@ package body Sem_Prag is\n       --  In Ada 95 or 05 mode, these are implementation defined pragmas, so\n       --  should be caught by the No_Implementation_Pragmas restriction.\n \n+      procedure Analyze_Refined_Pre_Post\n+        (Body_Decl : out Node_Id;\n+         Spec_Id   : out Entity_Id;\n+         Legal     : out Boolean);\n+      --  Subsidiary routine to the analysis of pragmas Refined_Pre and\n+      --  Refined_Post. Body_Decl is the declaration of the subprogram body\n+      --  [stub] subject to the pragma. Spec_Id is the corresponding spec of\n+      --  the subprogram body [stub]. Flag Legal denotes whether the pragma\n+      --  passes all legality rules.\n+\n       procedure Check_Ada_83_Warning;\n       --  Issues a warning message for the current pragma if operating in Ada\n       --  83 mode (used for language pragmas that are not a standard part of\n@@ -2448,6 +2458,129 @@ package body Sem_Prag is\n          end if;\n       end Ada_2012_Pragma;\n \n+      ------------------------------\n+      -- Analyze_Refined_Pre_Post --\n+      ------------------------------\n+\n+      procedure Analyze_Refined_Pre_Post\n+        (Body_Decl : out Node_Id;\n+         Spec_Id   : out Entity_Id;\n+         Legal     : out Boolean)\n+      is\n+         Pack_Spec : Node_Id;\n+         Spec_Decl : Node_Id;\n+         Stmt      : Node_Id;\n+\n+      begin\n+         --  Assume that the pragma is illegal\n+\n+         Body_Decl := Parent (N);\n+         Spec_Id   := Empty;\n+         Legal     := False;\n+\n+         GNAT_Pragma;\n+         Check_Arg_Count (1);\n+         Check_No_Identifiers;\n+\n+         --  Verify the placement of the pragma and check for duplicates\n+\n+         Stmt := Prev (N);\n+         while Present (Stmt) loop\n+\n+            --  Skip prior pragmas, but check for duplicates\n+\n+            if Nkind (Stmt) = N_Pragma then\n+               if Pragma_Name (Stmt) = Pname then\n+                  Error_Msg_Name_1 := Pname;\n+                  Error_Msg_Sloc   := Sloc (Stmt);\n+                  Error_Msg_N (\"pragma % duplicates pragma declared #\", N);\n+               end if;\n+\n+            --  Emit an error when the pragma applies to an expression function\n+            --  that does not act as a completion.\n+\n+            elsif Nkind (Stmt) = N_Subprogram_Declaration\n+              and then Nkind (Original_Node (Stmt)) = N_Expression_Function\n+              and then not\n+                Has_Completion (Defining_Unit_Name (Specification (Stmt)))\n+            then\n+               Error_Pragma\n+                 (\"pragma % cannot apply to a stand alone expression \"\n+                  & \"function\");\n+               return;\n+\n+            --  The pragma applies to a subprogram body stub\n+\n+            elsif Nkind (Stmt) = N_Subprogram_Body_Stub then\n+               Body_Decl := Stmt;\n+               exit;\n+\n+            --  Skip internally generated code\n+\n+            elsif not Comes_From_Source (Stmt) then\n+               null;\n+\n+            --  The pragma does not apply to a legal construct, issue an error\n+            --  and stop the analysis.\n+\n+            else\n+               Pragma_Misplaced;\n+               return;\n+            end if;\n+\n+            Stmt := Prev (Stmt);\n+         end loop;\n+\n+         --  Pragma Refined_Pre/Post must apply to a subprogram body [stub]\n+\n+         if not Nkind_In (Body_Decl, N_Subprogram_Body,\n+                                     N_Subprogram_Body_Stub)\n+         then\n+            Pragma_Misplaced;\n+            return;\n+         end if;\n+\n+         --  The body [stub] must not act as a spec, in other words it has to\n+         --  be paired with a corresponding spec.\n+\n+         if Nkind (Body_Decl) = N_Subprogram_Body then\n+            Spec_Id := Corresponding_Spec (Body_Decl);\n+         else\n+            Spec_Id := Corresponding_Spec_Of_Stub (Body_Decl);\n+         end if;\n+\n+         if No (Spec_Id) then\n+            Error_Pragma (\"pragma % cannot apply to a stand alone body\");\n+            return;\n+         end if;\n+\n+         --  Refined_Pre/Post may only apply to the body [stub] of a subprogram\n+         --  declared in the visible part of a package. Retrieve the context of\n+         --  the subprogram declaration.\n+\n+         Spec_Decl := Parent (Parent (Spec_Id));\n+\n+         pragma Assert\n+           (Nkind_In (Spec_Decl, N_Abstract_Subprogram_Declaration,\n+                                 N_Generic_Subprogram_Declaration,\n+                                 N_Subprogram_Declaration));\n+\n+         Pack_Spec := Parent (Spec_Decl);\n+\n+         if Nkind (Pack_Spec) /= N_Package_Specification\n+           or else List_Containing (Spec_Decl) /=\n+                     Visible_Declarations (Pack_Spec)\n+         then\n+            Error_Pragma\n+              (\"pragma % must apply to the body of a visible subprogram\");\n+            return;\n+         end if;\n+\n+         --  If we get here, the placement and legality of the pragma is OK\n+\n+         Legal := True;\n+      end Analyze_Refined_Pre_Post;\n+\n       --------------------------\n       -- Check_Ada_83_Warning --\n       --------------------------\n@@ -15933,145 +16066,79 @@ package body Sem_Prag is\n          when Pragma_Rational =>\n             Set_Rational_Profile;\n \n-         -----------------\n-         -- Refined_Pre --\n-         -----------------\n+         ------------------\n+         -- Refined_Post --\n+         ------------------\n \n-         --  pragma Refined_Pre (boolean_EXPRESSION);\n+         --  pragma Refined_Post (boolean_EXPRESSION);\n \n-         when Pragma_Refined_Pre => Refined_Pre : declare\n-            Body_Decl : Node_Id := Parent (N);\n-            Pack_Spec : Node_Id;\n-            Restore   : Boolean := False;\n-            Spec_Decl : Node_Id;\n+         when Pragma_Refined_Post => Refined_Post : declare\n+            Body_Decl : Node_Id;\n+            Legal     : Boolean;\n             Spec_Id   : Entity_Id;\n-            Stmt      : Node_Id;\n \n          begin\n-            GNAT_Pragma;\n-            Check_Arg_Count (1);\n-            Check_No_Identifiers;\n-\n-            --  Verify the placement of the pragma and check for duplicates\n-\n-            Stmt := Prev (N);\n-            while Present (Stmt) loop\n-\n-               --  Skip prior pragmas, but check for duplicates\n-\n-               if Nkind (Stmt) = N_Pragma then\n-                  if Pragma_Name (Stmt) = Pname then\n-                     Error_Msg_Name_1 := Pname;\n-                     Error_Msg_Sloc   := Sloc (Stmt);\n-                     Error_Msg_N (\"pragma % duplicates pragma declared #\", N);\n-                  end if;\n-\n-               --  The pragma applies to a subprogram body stub\n-\n-               elsif Nkind (Stmt) = N_Subprogram_Body_Stub then\n-                  Body_Decl := Stmt;\n-                  exit;\n-\n-               --  The pragma applies to an expression function that does not\n-               --  act as a completion of a previous function declaration.\n-\n-               elsif Nkind (Stmt) = N_Subprogram_Declaration\n-                 and then Nkind (Original_Node (Stmt)) = N_Expression_Function\n-                 and then not\n-                   Has_Completion (Defining_Unit_Name (Specification (Stmt)))\n-               then\n-                  Error_Pragma (\"pragma % cannot apply to a stand alone body\");\n-                  return;\n-\n-               --  Skip internally generated code\n-\n-               elsif not Comes_From_Source (Stmt) then\n-                  null;\n-\n-               --  The pragma does not apply to a legal construct, issue an\n-               --  error and stop the analysis.\n-\n-               else\n-                  Pragma_Misplaced;\n-                  return;\n-               end if;\n+            --  Verify the legal placement of the pragma. The pragma is left\n+            --  intentionally semi-analyzed. Process_PPCs does the remaining\n+            --  analysis of the expression when Refined_Post is converted into\n+            --  pragma Check.\n \n-               Stmt := Prev (Stmt);\n-            end loop;\n-\n-            --  Pragma Refined_Pre must apply to a subprogram body [stub]\n-\n-            if not Nkind_In (Body_Decl, N_Subprogram_Body,\n-                                        N_Subprogram_Body_Stub)\n-            then\n-               Pragma_Misplaced;\n-               return;\n-            end if;\n-\n-            --  The body [stub] must not act as a spec\n+            Analyze_Refined_Pre_Post (Body_Decl, Spec_Id, Legal);\n \n-            if Nkind (Body_Decl) = N_Subprogram_Body then\n-               Spec_Id := Corresponding_Spec (Body_Decl);\n-            else\n-               Spec_Id := Corresponding_Spec_Of_Stub (Body_Decl);\n-            end if;\n+            --  Analyze the expression when code generation is disabled because\n+            --  the contract of the related subprogram will never be processed.\n \n-            if No (Spec_Id) then\n-               Error_Pragma (\"pragma % cannot apply to a stand alone body\");\n-               return;\n+            if Legal and then not Expander_Active then\n+               Analyze_And_Resolve (Get_Pragma_Arg (Arg1), Standard_Boolean);\n             end if;\n+         end Refined_Post;\n \n-            --  Refined_Pre may only apply to the body [stub] of a subprogram\n-            --  declared in the visible part of a package. Retrieve the context\n-            --  of the subprogram declaration.\n-\n-            Spec_Decl := Parent (Parent (Spec_Id));\n+         -----------------\n+         -- Refined_Pre --\n+         -----------------\n \n-            pragma Assert\n-              (Nkind_In (Spec_Decl, N_Abstract_Subprogram_Declaration,\n-                                    N_Generic_Subprogram_Declaration,\n-                                    N_Subprogram_Declaration));\n+         --  pragma Refined_Pre (boolean_EXPRESSION);\n \n-            Pack_Spec := Parent (Spec_Decl);\n+         when Pragma_Refined_Pre => Refined_Pre : declare\n+            Body_Decl : Node_Id;\n+            Legal     : Boolean;\n+            Restore   : Boolean := False;\n+            Spec_Id   : Entity_Id;\n \n-            if Nkind (Pack_Spec) /= N_Package_Specification\n-              or else List_Containing (Spec_Decl) /=\n-                        Visible_Declarations (Pack_Spec)\n-            then\n-               Error_Pragma\n-                 (\"pragma % must apply to the body of a visible subprogram\");\n-            end if;\n+         begin\n+            Analyze_Refined_Pre_Post (Body_Decl, Spec_Id, Legal);\n \n-            --  When the pragma applies to a subprogram stub without a proper\n-            --  body, we have to restore the visibility of the stub and its\n-            --  formals to perform analysis.\n+            if Legal then\n+               pragma Assert (Present (Body_Decl));\n+               pragma Assert (Present (Spec_Id));\n \n-            if Nkind (Body_Decl) = N_Subprogram_Body_Stub\n-              and then No (Library_Unit (Body_Decl))\n-              and then Current_Scope /= Spec_Id\n-            then\n-               Restore := True;\n-               Push_Scope (Spec_Id);\n-               Install_Formals (Spec_Id);\n-            end if;\n+               if Nkind (Body_Decl) = N_Subprogram_Body_Stub\n+                 and then No (Library_Unit (Body_Decl))\n+                 and then Current_Scope /= Spec_Id\n+               then\n+                  Restore := True;\n+                  Push_Scope (Spec_Id);\n+                  Install_Formals (Spec_Id);\n+               end if;\n \n-            --  Convert pragma Refined_Pre into pragma Check. The analysis of\n-            --  the generated pragma will take care of the expression.\n+               --  Convert pragma Refined_Pre into pragma Check. The analysis\n+               --  of the generated pragma will take care of the expression.\n \n-            Rewrite (N,\n-              Make_Pragma (Loc,\n-                Chars                        => Name_Check,\n-                Pragma_Argument_Associations => New_List (\n-                  Make_Pragma_Argument_Association (Loc,\n-                    Expression => Make_Identifier (Loc, Pname)),\n+               Rewrite (N,\n+                 Make_Pragma (Loc,\n+                   Chars                        => Name_Check,\n+                   Pragma_Argument_Associations => New_List (\n+                     Make_Pragma_Argument_Association (Loc,\n+                       Expression => Make_Identifier (Loc, Pname)),\n \n-                  Make_Pragma_Argument_Association (Sloc (Arg1),\n-                    Expression => Relocate_Node (Get_Pragma_Arg (Arg1))))));\n+                     Make_Pragma_Argument_Association (Sloc (Arg1),\n+                       Expression => Relocate_Node (Get_Pragma_Arg (Arg1))))));\n \n-            Analyze (N);\n+               Analyze (N);\n \n-            if Restore then\n-               Pop_Scope;\n+               if Restore then\n+                  Pop_Scope;\n+               end if;\n             end if;\n          end Refined_Pre;\n \n@@ -19158,6 +19225,7 @@ package body Sem_Prag is\n       Pragma_Queuing_Policy                 => -1,\n       Pragma_Rational                       => -1,\n       Pragma_Ravenscar                      => -1,\n+      Pragma_Refined_Post                   => -1,\n       Pragma_Refined_Pre                    => -1,\n       Pragma_Relative_Deadline              => -1,\n       Pragma_Remote_Access_Type             => -1,\n@@ -19593,6 +19661,116 @@ package body Sem_Prag is\n \n    end Process_Compilation_Unit_Pragmas;\n \n+   ------------------------------\n+   -- Relocate_Pragmas_To_Body --\n+   ------------------------------\n+\n+   procedure Relocate_Pragmas_To_Body\n+     (Subp_Body   : Node_Id;\n+      Target_Body : Node_Id := Empty)\n+   is\n+      procedure Relocate_Pragma (Prag : Node_Id);\n+      --  Remove a single pragma from its current list and add it to the\n+      --  declarations of the proper body (either Subp_Body or Target_Body).\n+\n+      ---------------------\n+      -- Relocate_Pragma --\n+      ---------------------\n+\n+      procedure Relocate_Pragma (Prag : Node_Id) is\n+         Decls  : List_Id;\n+         Target : Node_Id;\n+\n+      begin\n+         --  When subprogram stubs or expression functions are involves, the\n+         --  destination declaration list belongs to the proper body.\n+\n+         if Present (Target_Body) then\n+            Target := Target_Body;\n+         else\n+            Target := Subp_Body;\n+         end if;\n+\n+         Decls := Declarations (Target);\n+\n+         if No (Decls) then\n+            Decls := New_List;\n+            Set_Declarations (Target, Decls);\n+         end if;\n+\n+         --  Unhook the pragma from its current list\n+\n+         Remove  (Prag);\n+         Prepend (Prag, Decls);\n+      end Relocate_Pragma;\n+\n+      --  Local variables\n+\n+      Body_Id   : constant Entity_Id :=\n+                    Defining_Unit_Name (Specification (Subp_Body));\n+      Next_Stmt : Node_Id;\n+      Stmt      : Node_Id;\n+\n+   --  Start of processing for Relocate_Pragmas_To_Body\n+\n+   begin\n+      --  Do not process a body that comes from a separate unit as no construct\n+      --  can possibly follow it.\n+\n+      if not Is_List_Member (Subp_Body) then\n+         return;\n+\n+      --  Do not relocate pragmas that follow a stub if the stub does not have\n+      --  a proper body.\n+\n+      elsif Nkind (Subp_Body) = N_Subprogram_Body_Stub\n+        and then No (Target_Body)\n+      then\n+         return;\n+\n+      --  Do not process internally generated routine _Postconditions\n+\n+      elsif Ekind (Body_Id) = E_Procedure\n+        and then Chars (Body_Id) = Name_uPostconditions\n+      then\n+         return;\n+      end if;\n+\n+      --  Look at what is following the body. We are interested in certain kind\n+      --  of pragmas (either from source or byproducts of expansion) that can\n+      --  apply to a body [stub].\n+\n+      Stmt := Next (Subp_Body);\n+      while Present (Stmt) loop\n+\n+         --  Preserve the following statement for iteration purposes due to a\n+         --  possible relocation of a pragma.\n+\n+         Next_Stmt := Next (Stmt);\n+\n+         --  Move a candidate pragma following the body to the declarations of\n+         --  the body.\n+\n+         if Nkind (Stmt) = N_Pragma\n+           and then Pragma_On_Body_Or_Stub_OK (Get_Pragma_Id (Stmt))\n+         then\n+            Relocate_Pragma (Stmt);\n+\n+         --  Skip internally generated code\n+\n+         elsif not Comes_From_Source (Stmt) then\n+            null;\n+\n+         --  No candidate pragmas are available for relocation\n+\n+         else\n+            exit;\n+         end if;\n+\n+         Stmt := Next_Stmt;\n+      end loop;\n+   end Relocate_Pragmas_To_Body;\n+\n    ----------------------------\n    -- Rewrite_Assertion_Kind --\n    ----------------------------"}, {"sha": "492eb9f779f83417e6d0d65169b29c626d5d03ae", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=e7f23f0645d60bad0ce49f0983f18f4e5d01a93e", "patch": "@@ -33,11 +33,15 @@ with Types;  use Types;\n package Sem_Prag is\n \n    --  The following table lists all the implementation-defined pragmas that\n-   --  may apply to a body stub (no language defined pragmas apply).\n+   --  may apply to a body stub (no language defined pragmas apply). The table\n+   --  should be synchronized with Aspect_On_Body_Or_Stub_OK in unit Aspects if\n+   --  the pragmas below implement an aspect.\n \n-   Pragma_On_Stub_OK : constant array (Pragma_Id) of Boolean :=\n-     (Pragma_Refined_Pre  => True,\n+   Pragma_On_Body_Or_Stub_OK : constant array (Pragma_Id) of Boolean :=\n+     (Pragma_Refined_Post => True,\n+      Pragma_Refined_Pre  => True,\n       Pragma_SPARK_Mode   => True,\n+      Pragma_Warnings     => True,\n       others              => False);\n \n    -----------------\n@@ -164,6 +168,15 @@ package Sem_Prag is\n    --  Suppress_All at this stage, since it can appear after the unit instead\n    --  of before (actually we allow it to appear anywhere).\n \n+   procedure Relocate_Pragmas_To_Body\n+     (Subp_Body   : Node_Id;\n+      Target_Body : Node_Id := Empty);\n+   --  Resocate all pragmas that follow and apply to subprogram body Subp_Body\n+   --  to its own declaration list. Candidate pragmas are classified in table\n+   --  Pragma_On_Body_Or_Stub_OK. If Target_Body is set, the pragma are moved\n+   --  to the declarations of Target_Body. This formal should be set when\n+   --  dealing with subprogram body stubs or expression functions.\n+\n    procedure Set_Encoded_Interface_Name (E : Entity_Id; S : Node_Id);\n    --  This routine is used to set an encoded interface name. The node S is an\n    --  N_String_Literal node for the external name to be set, and E is an"}, {"sha": "d32f5065dfc9efb72962b998a969aa31e230d9bd", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f23f0645d60bad0ce49f0983f18f4e5d01a93e/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=e7f23f0645d60bad0ce49f0983f18f4e5d01a93e", "patch": "@@ -580,6 +580,7 @@ package Snames is\n    Name_Pure_05                        : constant Name_Id := N + $; -- GNAT\n    Name_Pure_12                        : constant Name_Id := N + $; -- GNAT\n    Name_Pure_Function                  : constant Name_Id := N + $; -- GNAT\n+   Name_Refined_Post                   : constant Name_Id := N + $; -- GNAT\n    Name_Refined_Pre                    : constant Name_Id := N + $; -- GNAT\n    Name_Relative_Deadline              : constant Name_Id := N + $; -- Ada 05\n    Name_Remote_Access_Type             : constant Name_Id := N + $; -- GNAT\n@@ -1861,6 +1862,7 @@ package Snames is\n       Pragma_Pure_05,\n       Pragma_Pure_12,\n       Pragma_Pure_Function,\n+      Pragma_Refined_Post,\n       Pragma_Refined_Pre,\n       Pragma_Relative_Deadline,\n       Pragma_Remote_Access_Type,"}]}