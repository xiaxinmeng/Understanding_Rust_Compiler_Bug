{"sha": "aee46bbdf8a9fa9576f6a2d0224dff1cd4a344bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVlNDZiYmRmOGE5ZmE5NTc2ZjZhMmQwMjI0ZGZmMWNkNGEzNDRiYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-07-26T03:43:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-07-26T03:43:40Z"}, "message": "tree-ssa-live.c: Include debug.h and flags.h.\n\n\n\t* tree-ssa-live.c: Include debug.h and flags.h.\n\t(mark_scope_block_unused): New function.\n\t(remove_unused_scope_block_p): New function.\n\t(remove_unused_locals): Remove unused blocks too.\n\nFrom-SVN: r126947", "tree": {"sha": "36d1d3a6aa1c1aecf769e6afe46ff085c67c64b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36d1d3a6aa1c1aecf769e6afe46ff085c67c64b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aee46bbdf8a9fa9576f6a2d0224dff1cd4a344bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aee46bbdf8a9fa9576f6a2d0224dff1cd4a344bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aee46bbdf8a9fa9576f6a2d0224dff1cd4a344bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aee46bbdf8a9fa9576f6a2d0224dff1cd4a344bb/comments", "author": null, "committer": null, "parents": [{"sha": "e13642b658d72c7fbc88c23b1cee6f01f57a3584", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e13642b658d72c7fbc88c23b1cee6f01f57a3584", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e13642b658d72c7fbc88c23b1cee6f01f57a3584"}], "stats": {"total": 122, "additions": 121, "deletions": 1}, "files": [{"sha": "3afc07702b58e52d785e61cfa85af65f23c58ee0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee46bbdf8a9fa9576f6a2d0224dff1cd4a344bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee46bbdf8a9fa9576f6a2d0224dff1cd4a344bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aee46bbdf8a9fa9576f6a2d0224dff1cd4a344bb", "patch": "@@ -1,3 +1,10 @@\n+2007-07-26  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-ssa-live.c: Include debug.h and flags.h.\n+\t(mark_scope_block_unused): New function.\n+\t(remove_unused_scope_block_p): New function.\n+\t(remove_unused_locals): Remove unused blocks too.\n+\n 2007-07-25  Ian Lance Taylor  <iant@google.com>\n \n \t* combine.c (combine_max_regno): Remove.  Remove all uses."}, {"sha": "2c8491c239ec7ed22dfe0886b8268e5c682f593d", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 114, "deletions": 1, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee46bbdf8a9fa9576f6a2d0224dff1cd4a344bb/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee46bbdf8a9fa9576f6a2d0224dff1cd4a344bb/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=aee46bbdf8a9fa9576f6a2d0224dff1cd4a344bb", "patch": "@@ -30,6 +30,8 @@ Boston, MA 02110-1301, USA.  */\n #include \"tree-dump.h\"\n #include \"tree-ssa-live.h\"\n #include \"toplev.h\"\n+#include \"debug.h\"\n+#include \"flags.h\"\n \n #ifdef ENABLE_CHECKING\n static void  verify_live_on_entry (tree_live_info_p);\n@@ -405,9 +407,15 @@ mark_all_vars_used_1 (tree *tp, int *walk_subtrees,\n \t\t      void *data ATTRIBUTE_UNUSED)\n {\n   tree t = *tp;\n+  enum tree_code_class c = TREE_CODE_CLASS (TREE_CODE (t));\n+  tree b;\n \n   if (TREE_CODE (t) == SSA_NAME)\n     t = SSA_NAME_VAR (t);\n+  if ((IS_EXPR_CODE_CLASS (c)\n+       || IS_GIMPLE_STMT_CODE_CLASS (c))\n+      && (b = TREE_BLOCK (t)) != NULL)\n+    TREE_USED (b) = true;\n \n   /* Ignore TREE_ORIGINAL for TARGET_MEM_REFS, as well as other\n      fields that do not contain vars.  */\n@@ -431,6 +439,110 @@ mark_all_vars_used_1 (tree *tp, int *walk_subtrees,\n   return NULL;\n }\n \n+/* Mark the scope block SCOPE and its subblocks unused when they can be\n+   possibly eliminated if dead.  */\n+\n+static void\n+mark_scope_block_unused (tree scope)\n+{\n+  tree t;\n+  TREE_USED (scope) = false;\n+  if (!(*debug_hooks->ignore_block) (scope))\n+    TREE_USED (scope) = true;\n+  for (t = BLOCK_SUBBLOCKS (scope); t ; t = BLOCK_CHAIN (t))\n+    mark_scope_block_unused (t);\n+}\n+\n+/* Look if the block is dead (by possibly eliminating its dead subblocks)\n+   and return true if so.  \n+   Block is declared dead if:\n+     1) No statements are associated with it.\n+     2) Declares no live variables\n+     3) All subblocks are dead\n+\tor there is precisely one subblocks and the block\n+\thas same abstract origin as outer block and declares\n+\tno variables, so it is pure wrapper.\n+   When we are not outputting full debug info, we also elliminate dead variables\n+   out of scope blocks to let them to be recycled by GGC and to save copying work\n+   done by the inliner.  */\n+\n+static bool\n+remove_unused_scope_block_p (tree scope)\n+{\n+  tree *t, *next;\n+  bool unused = !TREE_USED (scope);\n+  var_ann_t ann;\n+  int nsubblocks = 0;\n+\n+  for (t = &BLOCK_VARS (scope); *t; t = next)\n+    {\n+      next = &TREE_CHAIN (*t);\n+\n+      /* Debug info of nested function reffers to the block of the\n+\t function.  */\n+      if (TREE_CODE (*t) == FUNCTION_DECL)\n+\tunused = false;\n+\n+      /* When we are outputting debug info, we usually want to output\n+\t info about optimized-out variables in the scope blocks.\n+\t Exception are the scope blocks not containing any instructions\n+\t at all so user can't get into the scopes at first place.  */\n+      else if ((ann = var_ann (*t)) != NULL\n+\t\t&& ann->used)\n+\tunused = false;\n+\n+      /* When we are not doing full debug info, we however can keep around\n+\t only the used variables for cfgexpand's memory packing saving quite\n+\t a lot of memory.  */\n+      else if (debug_info_level != DINFO_LEVEL_NORMAL\n+\t       && debug_info_level != DINFO_LEVEL_VERBOSE)\n+\t{\n+\t  *t = TREE_CHAIN (*t);\n+\t  next = t;\n+\t}\n+    }\n+\n+  for (t = &BLOCK_SUBBLOCKS (scope); *t ;)\n+    if (remove_unused_scope_block_p (*t))\n+      {\n+\tif (BLOCK_SUBBLOCKS (*t))\n+\t  {\n+\t    tree next = BLOCK_CHAIN (*t);\n+\t    tree supercontext = BLOCK_SUPERCONTEXT (*t);\n+\t    *t = BLOCK_SUBBLOCKS (*t);\n+\t    gcc_assert (!BLOCK_CHAIN (*t));\n+\t    BLOCK_CHAIN (*t) = next;\n+\t    BLOCK_SUPERCONTEXT (*t) = supercontext;\n+\t    t = &BLOCK_CHAIN (*t);\n+\t    nsubblocks ++;\n+\t  }\n+\telse\n+          *t = BLOCK_CHAIN (*t);\n+      }\n+    else\n+      {\n+        t = &BLOCK_CHAIN (*t);\n+\tnsubblocks ++;\n+      }\n+   /* Outer scope is always used.  */\n+   if (!BLOCK_SUPERCONTEXT (scope)\n+       || TREE_CODE (BLOCK_SUPERCONTEXT (scope)) == FUNCTION_DECL)\n+     unused = false;\n+   /* If there are more than one live subblocks, it is used.  */\n+   else if (nsubblocks > 1)\n+     unused = false;\n+   /* When there is only one subblock, see if it is just wrapper we can\n+      ignore.  Wrappers are not declaring any variables and not changing\n+      abstract origin.  */\n+   else if (nsubblocks == 1\n+\t    && (BLOCK_VARS (scope)\n+\t\t|| ((debug_info_level == DINFO_LEVEL_NORMAL\n+\t\t     || debug_info_level == DINFO_LEVEL_VERBOSE)\n+\t\t    && ((BLOCK_ABSTRACT_ORIGIN (scope)\n+\t\t\t!= BLOCK_ABSTRACT_ORIGIN (BLOCK_SUPERCONTEXT (scope)))))))\n+     unused = false;\n+   return unused;\n+}\n \n /* Mark all VAR_DECLS under *EXPR_P as used, so that they won't be \n    eliminated during the tree->rtl conversion process.  */\n@@ -452,6 +564,7 @@ remove_unused_locals (void)\n   referenced_var_iterator rvi;\n   var_ann_t ann;\n \n+  mark_scope_block_unused (DECL_INITIAL (current_function_decl));\n   /* Assume all locals are unused.  */\n   FOR_EACH_REFERENCED_VAR (t, rvi)\n     var_ann (t)->used = false;\n@@ -498,7 +611,6 @@ remove_unused_locals (void)\n \t  *cell = TREE_CHAIN (*cell);\n \t  continue;\n \t}\n-\n       cell = &TREE_CHAIN (*cell);\n     }\n \n@@ -516,6 +628,7 @@ remove_unused_locals (void)\n \t&& !ann->symbol_mem_tag\n \t&& !TREE_ADDRESSABLE (t))\n       remove_referenced_var (t);\n+  remove_unused_scope_block_p (DECL_INITIAL (current_function_decl));\n }\n \n "}]}