{"sha": "4d4447b56b603b0786a0de3601ba45618dc6816c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ0NDQ3YjU2YjYwM2IwNzg2YTBkZTM2MDFiYTQ1NjE4ZGM2ODE2Yw==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@vnet.ibm.com", "date": "2007-11-19T19:50:47Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2007-11-19T19:50:47Z"}, "message": "rs6000.c (invalid_e500_subreg, [...]): Handle DDmode and TDmode similarly to DFmode and TFmode.\n\n\t* config/rs6000/rs6000.c (invalid_e500_subreg,\n\trs6000_legitimate_offset_address_p, legitimate_lo_sum_address_p,\n\trs6000_legitimize_address, rs6000_legitimize_reload_address,\n\trs6000_legitimate_address, function_arg_advance,\n\tspe_build_register_parallel, rs6000_spe_function_arg,\n\trs6000_split_multireg_move, spe_func_has_64bit_regs_p,\n\temit_frame_save, gen_frame_mem_offset, rs6000_function_value,\n\trs6000_libcall_value, rs6000_dwarf_register_span): Handle DDmode and\n\tTDmode similarly to DFmode and TFmode.\n\t* config/rs6000/rs6000.h (LOCAL_ALIGNMENT, MEMBER_TYPE_FORCES_BLK,\n\tDATA_ALIGNMENT, CLASS_MAX_NREGS, CANNOT_CHANGE_MODE_CLASS): Likewise.\n\n\t* gcc.dg/dfp/ddmode-ice.c: New test.\n\nFrom-SVN: r130296", "tree": {"sha": "1c7df14fbab5b725c586e97ae323f6834e6708ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c7df14fbab5b725c586e97ae323f6834e6708ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d4447b56b603b0786a0de3601ba45618dc6816c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d4447b56b603b0786a0de3601ba45618dc6816c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d4447b56b603b0786a0de3601ba45618dc6816c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d4447b56b603b0786a0de3601ba45618dc6816c/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b7cfd8a4e1ed9e51fe9fb3c1ccf65c8768d02d2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7cfd8a4e1ed9e51fe9fb3c1ccf65c8768d02d2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7cfd8a4e1ed9e51fe9fb3c1ccf65c8768d02d2f"}], "stats": {"total": 170, "additions": 131, "deletions": 39}, "files": [{"sha": "713450ccdd55d9a09d06e448708b5c7da2078f6d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d4447b56b603b0786a0de3601ba45618dc6816c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d4447b56b603b0786a0de3601ba45618dc6816c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d4447b56b603b0786a0de3601ba45618dc6816c", "patch": "@@ -1,3 +1,17 @@\n+2007-11-19  Peter Bergner  <bergner@vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (invalid_e500_subreg,\n+\trs6000_legitimate_offset_address_p, legitimate_lo_sum_address_p,\n+\trs6000_legitimize_address, rs6000_legitimize_reload_address,\n+\trs6000_legitimate_address, function_arg_advance,\n+\tspe_build_register_parallel, rs6000_spe_function_arg,\n+\trs6000_split_multireg_move, spe_func_has_64bit_regs_p,\n+\temit_frame_save, gen_frame_mem_offset, rs6000_function_value,\n+\trs6000_libcall_value, rs6000_dwarf_register_span): Handle DDmode and\n+\tTDmode similarly to DFmode and TFmode.\n+\t* config/rs6000/rs6000.h (LOCAL_ALIGNMENT, MEMBER_TYPE_FORCES_BLK,\n+\tDATA_ALIGNMENT, CLASS_MAX_NREGS, CANNOT_CHANGE_MODE_CLASS): Likewise.\n+\n 2007-11-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* stor-layout.c (lang_adjust_rli): Delete."}, {"sha": "15bebb12ee819014debbaf613a453274873e3a17", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 46, "deletions": 31, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d4447b56b603b0786a0de3601ba45618dc6816c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d4447b56b603b0786a0de3601ba45618dc6816c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=4d4447b56b603b0786a0de3601ba45618dc6816c", "patch": "@@ -3115,13 +3115,16 @@ invalid_e500_subreg (rtx op, enum machine_mode mode)\n \t  && (mode == SImode || mode == DImode || mode == TImode)\n \t  && REG_P (SUBREG_REG (op))\n \t  && (GET_MODE (SUBREG_REG (op)) == DFmode\n-\t      || GET_MODE (SUBREG_REG (op)) == TFmode))\n+\t      || GET_MODE (SUBREG_REG (op)) == TFmode\n+\t      || GET_MODE (SUBREG_REG (op)) == DDmode\n+\t      || GET_MODE (SUBREG_REG (op)) == TDmode))\n \treturn true;\n \n       /* Reject (subreg:DF (reg:DI)); likewise with subreg:TF and\n \t reg:TI.  */\n       if (GET_CODE (op) == SUBREG\n-\t  && (mode == DFmode || mode == TFmode)\n+\t  && (mode == DFmode || mode == TFmode\n+\t      || mode == DDmode || mode == TDmode)\n \t  && REG_P (SUBREG_REG (op))\n \t  && (GET_MODE (SUBREG_REG (op)) == DImode\n \t      || GET_MODE (SUBREG_REG (op)) == TImode))\n@@ -3390,12 +3393,12 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n       break;\n \n     case TFmode:\n+    case TDmode:\n       if (TARGET_E500_DOUBLE)\n \treturn (SPE_CONST_OFFSET_OK (offset)\n \t\t&& SPE_CONST_OFFSET_OK (offset + 8));\n \n     case TImode:\n-    case TDmode:\n       if (mode == TFmode || mode == TDmode || !TARGET_POWERPC64)\n \textra = 12;\n       else if (offset & 3)\n@@ -3474,6 +3477,7 @@ legitimate_lo_sum_address_p (enum machine_mode mode, rtx x, int strict)\n     return false;\n   /* Restrict addressing for DI because of our SUBREG hackery.  */\n   if (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n+\t\t\t     || mode == DDmode || mode == TDmode\n \t\t\t     || mode == DImode))\n     return false;\n   x = XEXP (x, 1);\n@@ -3488,7 +3492,8 @@ legitimate_lo_sum_address_p (enum machine_mode mode, rtx x, int strict)\n \treturn false;\n       if (GET_MODE_BITSIZE (mode) > 64\n \t  || (GET_MODE_BITSIZE (mode) > 32 && !TARGET_POWERPC64\n-\t      && !(TARGET_HARD_FLOAT && TARGET_FPRS && mode == DFmode)))\n+\t      && !(TARGET_HARD_FLOAT && TARGET_FPRS\n+\t\t   && (mode == DFmode || mode == DDmode))))\n \treturn false;\n \n       return CONSTANT_P (x);\n@@ -3610,7 +3615,8 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t   && CONSTANT_P (x)\n \t   && GET_MODE_NUNITS (mode) == 1\n \t   && (GET_MODE_BITSIZE (mode) <= 32\n-\t       || ((TARGET_HARD_FLOAT && TARGET_FPRS) && mode == DFmode)))\n+\t       || ((TARGET_HARD_FLOAT && TARGET_FPRS)\n+\t\t   && (mode == DFmode || mode == DDmode))))\n     {\n       rtx reg = gen_reg_rtx (Pmode);\n       emit_insn (gen_elf_high (reg, x));\n@@ -3624,7 +3630,8 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t   && GET_CODE (x) != CONST_INT\n \t   && GET_CODE (x) != CONST_DOUBLE\n \t   && CONSTANT_P (x)\n-\t   && ((TARGET_HARD_FLOAT && TARGET_FPRS) || mode != DFmode)\n+\t   && ((TARGET_HARD_FLOAT && TARGET_FPRS)\n+\t       || (mode != DFmode && mode != DDmode))\n \t   && mode != DImode\n \t   && mode != TImode)\n     {\n@@ -3980,6 +3987,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n       && !SPE_VECTOR_MODE (mode)\n       && !(TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n+\t\t\t\t  || mode == DDmode || mode == TDmode\n \t\t\t\t  || mode == DImode))\n       && !ALTIVEC_VECTOR_MODE (mode))\n     {\n@@ -4021,12 +4029,12 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n       && !flag_pic\n #endif\n       /* Don't do this for TFmode or TDmode, since the result isn't offsettable.\n-\t The same goes for DImode without 64-bit gprs and DFmode\n+\t The same goes for DImode without 64-bit gprs and DFmode and DDmode\n \t without fprs.  */\n       && mode != TFmode\n       && mode != TDmode\n       && (mode != DImode || TARGET_POWERPC64)\n-      && (mode != DFmode || TARGET_POWERPC64\n+      && ((mode != DFmode && mode != DDmode) || TARGET_POWERPC64\n \t  || (TARGET_FPRS && TARGET_HARD_FLOAT)))\n     {\n #if TARGET_MACHO\n@@ -4089,11 +4097,11 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n    refers to a constant pool entry of an address (or the sum of it\n    plus a constant), a short (16-bit signed) constant plus a register,\n    the sum of two registers, or a register indirect, possibly with an\n-   auto-increment.  For DFmode and DImode with a constant plus register,\n-   we must ensure that both words are addressable or PowerPC64 with offset\n-   word aligned.\n+   auto-increment.  For DFmode, DDmode and DImode with a constant plus\n+   register, we must ensure that both words are addressable or PowerPC64\n+   with offset word aligned.\n \n-   For modes spanning multiple registers (DFmode in 32-bit GPRs,\n+   For modes spanning multiple registers (DFmode and DDmode in 32-bit GPRs,\n    32-bit DImode, TImode, TFmode, TDmode), indexed addressing cannot be used\n    because adjacent memory cells are accessed by adding word-sized offsets\n    during assembly output.  */\n@@ -4118,8 +4126,8 @@ rs6000_legitimate_address (enum machine_mode mode, rtx x, int reg_ok_strict)\n       && mode != TFmode\n       && mode != TDmode\n       /* Restrict addressing for DI because of our SUBREG hackery.  */\n-      && !(TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n-\t\t\t\t  || mode == DImode))\n+      && !(TARGET_E500_DOUBLE\n+\t   && (mode == DFmode || mode == DDmode || mode == DImode))\n       && TARGET_UPDATE\n       && legitimate_indirect_address_p (XEXP (x, 0), reg_ok_strict))\n     return 1;\n@@ -4142,7 +4150,7 @@ rs6000_legitimate_address (enum machine_mode mode, rtx x, int reg_ok_strict)\n       && mode != TDmode\n       && ((TARGET_HARD_FLOAT && TARGET_FPRS)\n \t  || TARGET_POWERPC64\n-\t  || ((mode != DFmode || TARGET_E500_DOUBLE) && mode != TFmode))\n+\t  || ((mode != DFmode && mode != DDmode) || TARGET_E500_DOUBLE))\n       && (TARGET_POWERPC64 || mode != DImode)\n       && legitimate_indexed_address_p (x, reg_ok_strict))\n     return 1;\n@@ -4152,12 +4160,13 @@ rs6000_legitimate_address (enum machine_mode mode, rtx x, int reg_ok_strict)\n       && mode != TDmode\n       && ((TARGET_HARD_FLOAT && TARGET_FPRS)\n \t  || TARGET_POWERPC64\n-\t  || ((mode != DFmode || TARGET_E500_DOUBLE) && mode != TFmode))\n+\t  || ((mode != DFmode && mode != DDmode) || TARGET_E500_DOUBLE))\n       && (TARGET_POWERPC64 || mode != DImode)\n       && !ALTIVEC_VECTOR_MODE (mode)\n       && !SPE_VECTOR_MODE (mode)\n       /* Restrict addressing for DI because of our SUBREG hackery.  */\n-      && !(TARGET_E500_DOUBLE && (mode == DFmode || mode == DImode))\n+      && !(TARGET_E500_DOUBLE\n+\t   && (mode == DFmode || mode == DDmode || mode == DImode))\n       && TARGET_UPDATE\n       && legitimate_indirect_address_p (XEXP (x, 0), reg_ok_strict)\n       && (rs6000_legitimate_offset_address_p (mode, XEXP (x, 1), reg_ok_strict)\n@@ -5407,7 +5416,8 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t  else\n \t    {\n \t      cum->fregno = FP_ARG_V4_MAX_REG + 1;\n-\t      if (mode == DFmode || mode == TFmode || mode == DDmode || mode == TDmode)\n+\t      if (mode == DFmode || mode == TFmode\n+\t\t  || mode == DDmode || mode == TDmode)\n \t\tcum->words += cum->words & 1;\n \t      cum->words += rs6000_arg_size (mode, type);\n \t    }\n@@ -5490,12 +5500,14 @@ spe_build_register_parallel (enum machine_mode mode, int gregno)\n   switch (mode)\n     {\n     case DFmode:\n+    case DDmode:\n       r1 = gen_rtx_REG (DImode, gregno);\n       r1 = gen_rtx_EXPR_LIST (VOIDmode, r1, const0_rtx);\n       return gen_rtx_PARALLEL (mode, gen_rtvec (1, r1));\n \n     case DCmode:\n     case TFmode:\n+    case TDmode:\n       r1 = gen_rtx_REG (DImode, gregno);\n       r1 = gen_rtx_EXPR_LIST (VOIDmode, r1, const0_rtx);\n       r3 = gen_rtx_REG (DImode, gregno + 2);\n@@ -5527,13 +5539,14 @@ rs6000_spe_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n   /* On E500 v2, double arithmetic is done on the full 64-bit GPR, but\n      are passed and returned in a pair of GPRs for ABI compatibility.  */\n-  if (TARGET_E500_DOUBLE && (mode == DFmode || mode == DCmode\n-\t\t\t     || mode == TFmode || mode == TCmode))\n+  if (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n+\t\t\t     || mode == DDmode || mode == TDmode\n+\t\t\t     || mode == DCmode || mode == TCmode))\n     {\n       int n_words = rs6000_arg_size (mode, type);\n \n       /* Doubles go in an odd/even register pair (r5/r6, etc).  */\n-      if (mode == DFmode)\n+      if (mode == DFmode || mode == DDmode)\n \tgregno += (1 - gregno) & 1;\n \n       /* Multi-reg args are not split between registers and stack.  */\n@@ -13718,8 +13731,8 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n     reg_mode = DECIMAL_FLOAT_MODE_P (mode) ? DDmode : DFmode;\n   else if (ALTIVEC_REGNO_P (reg))\n     reg_mode = V16QImode;\n-  else if (TARGET_E500_DOUBLE && mode == TFmode)\n-    reg_mode = DFmode;\n+  else if (TARGET_E500_DOUBLE && (mode == TFmode || mode == TDmode))\n+    reg_mode = DECIMAL_FLOAT_MODE_P (mode) ? DDmode : DFmode;\n   else\n     reg_mode = word_mode;\n   reg_mode_size = GET_MODE_SIZE (reg_mode);\n@@ -14458,7 +14471,8 @@ spe_func_has_64bit_regs_p (void)\n \n \t      if (SPE_VECTOR_MODE (mode))\n \t\treturn true;\n-\t      if (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode))\n+\t      if (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n+\t\t\t\t\t || mode == DDmode || mode == TDmode))\n \t\treturn true;\n \t    }\n \t}\n@@ -15274,7 +15288,7 @@ emit_frame_save (rtx frame_reg, rtx frame_ptr, enum machine_mode mode,\n \n   /* Some cases that need register indexed addressing.  */\n   if ((TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n-      || (TARGET_E500_DOUBLE && mode == DFmode)\n+      || (TARGET_E500_DOUBLE && (mode == DFmode || mode == DDmode))\n       || (TARGET_SPE_ABI\n \t  && SPE_VECTOR_MODE (mode)\n \t  && !SPE_CONST_OFFSET_OK (offset)))\n@@ -15314,7 +15328,7 @@ gen_frame_mem_offset (enum machine_mode mode, rtx reg, int offset)\n   int_rtx = GEN_INT (offset);\n \n   if ((TARGET_SPE_ABI && SPE_VECTOR_MODE (mode))\n-      || (TARGET_E500_DOUBLE && mode == DFmode))\n+      || (TARGET_E500_DOUBLE && (mode == DFmode || mode == DDmode)))\n     {\n       offset_rtx = gen_rtx_REG (Pmode, FIXED_SCRATCH);\n       emit_move_insn (offset_rtx, int_rtx);\n@@ -21521,8 +21535,8 @@ rs6000_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED)\n \t   && ALTIVEC_VECTOR_MODE (mode))\n     regno = ALTIVEC_ARG_RETURN;\n   else if (TARGET_E500_DOUBLE && TARGET_HARD_FLOAT\n-\t   && (mode == DFmode || mode == DCmode\n-\t       || mode == TFmode || mode == TCmode))\n+\t   && (mode == DFmode || mode == DDmode || mode == DCmode\n+\t       || mode == TFmode || mode == TDmode || mode == TCmode))\n     return spe_build_register_parallel (mode, GP_ARG_RETURN);\n   else\n     regno = GP_ARG_RETURN;\n@@ -21583,8 +21597,8 @@ rs6000_libcall_value (enum machine_mode mode)\n   else if (COMPLEX_MODE_P (mode) && targetm.calls.split_complex_arg)\n     return rs6000_complex_function_value (mode);\n   else if (TARGET_E500_DOUBLE && TARGET_HARD_FLOAT\n-\t   && (mode == DFmode || mode == DCmode\n-\t       || mode == TFmode || mode == TCmode))\n+\t   && (mode == DFmode || mode == DDmode || mode == DCmode\n+\t       || mode == TFmode || mode == TDmode || mode == TCmode))\n     return spe_build_register_parallel (mode, GP_ARG_RETURN);\n   else\n     regno = GP_ARG_RETURN;\n@@ -21642,7 +21656,8 @@ rs6000_dwarf_register_span (rtx reg)\n \n   if (TARGET_SPE\n       && (SPE_VECTOR_MODE (GET_MODE (reg))\n-\t  || (TARGET_E500_DOUBLE && GET_MODE (reg) == DFmode)))\n+\t  || (TARGET_E500_DOUBLE\n+\t      && (GET_MODE (reg) == DFmode || GET_MODE (reg) == DDmode))))\n     ;\n   else\n     return NULL_RTX;"}, {"sha": "7fb2002be5c494df62f4c26ef85380bec85edcea", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d4447b56b603b0786a0de3601ba45618dc6816c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d4447b56b603b0786a0de3601ba45618dc6816c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=4d4447b56b603b0786a0de3601ba45618dc6816c", "patch": "@@ -559,7 +559,8 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n    that the object would ordinarily have.  */\n #define LOCAL_ALIGNMENT(TYPE, ALIGN)\t\t\t\t\\\n   ((TARGET_ALTIVEC && TREE_CODE (TYPE) == VECTOR_TYPE) ? 128 :\t\\\n-    (TARGET_E500_DOUBLE && TYPE_MODE (TYPE) == DFmode) ? 64 : \\\n+    (TARGET_E500_DOUBLE\t\t\t\t\t\t\\\n+     && (TYPE_MODE (TYPE) == DFmode || TYPE_MODE (TYPE) == DDmode)) ? 64 : \\\n     ((TARGET_SPE && TREE_CODE (TYPE) == VECTOR_TYPE \\\n      && SPE_VECTOR_MODE (TYPE_MODE (TYPE))) || (TARGET_PAIRED_FLOAT \\\n         && TREE_CODE (TYPE) == VECTOR_TYPE \\\n@@ -585,7 +586,7 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n    fit into 1, whereas DI still needs two.  */\n #define MEMBER_TYPE_FORCES_BLK(FIELD, MODE) \\\n   ((TARGET_SPE && TREE_CODE (TREE_TYPE (FIELD)) == VECTOR_TYPE) \\\n-   || (TARGET_E500_DOUBLE && (MODE) == DFmode))\n+   || (TARGET_E500_DOUBLE && ((MODE) == DFmode || (MODE) == DDmode)))\n \n /* A bit-field declared as `int' forces `int' alignment for the struct.  */\n #define PCC_BITFIELD_TYPE_MATTERS 1\n@@ -604,7 +605,8 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n #define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n   (TREE_CODE (TYPE) == VECTOR_TYPE ? ((TARGET_SPE_ABI \\\n    || TARGET_PAIRED_FLOAT) ? 64 : 128)\t\\\n-   : (TARGET_E500_DOUBLE && TYPE_MODE (TYPE) == DFmode) ? 64 \\\n+   : (TARGET_E500_DOUBLE\t\t\t\\\n+      && (TYPE_MODE (TYPE) == DFmode || TYPE_MODE (TYPE) == DDmode)) ? 64 \\\n    : TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n    && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n    && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n@@ -1178,7 +1180,8 @@ enum reg_class\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n  (((CLASS) == FLOAT_REGS) \t\t\t\t\t\t\\\n   ? ((GET_MODE_SIZE (MODE) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD) \\\n-  : (TARGET_E500_DOUBLE && (CLASS) == GENERAL_REGS && (MODE) == DFmode) \\\n+  : (TARGET_E500_DOUBLE && (CLASS) == GENERAL_REGS\t\t\t\\\n+     && ((MODE) == DFmode || (MODE) == DDmode))\t\t\t\t\\\n   ? 1                                                                   \\\n   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n@@ -1192,6 +1195,8 @@ enum reg_class\n    : (((TARGET_E500_DOUBLE\t\t\t\t\t\t\\\n \t&& ((((TO) == DFmode) + ((FROM) == DFmode)) == 1\t\t\\\n \t    || (((TO) == TFmode) + ((FROM) == TFmode)) == 1\t\t\\\n+\t    || (((TO) == DDmode) + ((FROM) == DDmode)) == 1\t\t\\\n+\t    || (((TO) == TDmode) + ((FROM) == TDmode)) == 1\t\t\\\n \t    || (((TO) == DImode) + ((FROM) == DImode)) == 1))\t\t\\\n        || (TARGET_SPE\t\t\t\t\t\t\t\\\n \t   && (SPE_VECTOR_MODE (FROM) + SPE_VECTOR_MODE (TO)) == 1))\t\\\n@@ -1717,11 +1722,11 @@ typedef struct rs6000_args\n    refers to a constant pool entry of an address (or the sum of it\n    plus a constant), a short (16-bit signed) constant plus a register,\n    the sum of two registers, or a register indirect, possibly with an\n-   auto-increment.  For DFmode and DImode with a constant plus register,\n-   we must ensure that both words are addressable or PowerPC64 with offset\n-   word aligned.\n+   auto-increment.  For DFmode, DDmode and DImode with a constant plus\n+   register, we must ensure that both words are addressable or PowerPC64\n+   with offset word aligned.\n \n-   For modes spanning multiple registers (DFmode in 32-bit GPRs,\n+   For modes spanning multiple registers (DFmode and DDmode in 32-bit GPRs,\n    32-bit DImode, TImode), indexed addressing cannot be used because\n    adjacent memory cells are accessed by adding word-sized offsets\n    during assembly output.  */"}, {"sha": "9284fb7b4adf2f3fd63dff60cf22f7af25557a67", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d4447b56b603b0786a0de3601ba45618dc6816c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d4447b56b603b0786a0de3601ba45618dc6816c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4d4447b56b603b0786a0de3601ba45618dc6816c", "patch": "@@ -1,3 +1,7 @@\n+2007-11-19  Peter Bergner  <bergner@vnet.ibm.com>\n+\n+\t* gcc.dg/dfp/ddmode-ice.c: New test.\n+\n 2007-11-19  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR tree-optimization/34036"}, {"sha": "979dabe11e29c984fb1bcbf1ff8a8195bf4e8421", "filename": "gcc/testsuite/gcc.dg/dfp/ddmode-ice.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d4447b56b603b0786a0de3601ba45618dc6816c/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fddmode-ice.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d4447b56b603b0786a0de3601ba45618dc6816c/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fddmode-ice.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fddmode-ice.c?ref=4d4447b56b603b0786a0de3601ba45618dc6816c", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99 -O1\" } */\n+\n+/* This used to result in an ICE.  */\n+\n+_Decimal64 y[258][258];\n+_Decimal64 dd[258][258];\n+_Decimal64 ry[258][258];\n+_Decimal64\n+foo (void)\n+{\n+  int i;\n+  int j;\n+  int m;\n+  int im;\n+  int jm;\n+  int ip;\n+  int jp;\n+  int i2m;\n+  int i1p;\n+  _Decimal64 a;\n+  _Decimal64 b;\n+  _Decimal64 c;\n+  _Decimal64 qi;\n+  _Decimal64 qj;\n+  _Decimal64 xx;\n+  _Decimal64 yx;\n+  _Decimal64 xy;\n+  _Decimal64 yy;\n+  _Decimal64 rel;\n+  _Decimal64 qxx;\n+  _Decimal64 qyy;\n+  _Decimal64 qxy;\n+  do\n+    {\n+      jp = j + 1;\n+      for (i = i1p; i <= i2m; i++)\n+\t{\n+\t  ip = i + 1;\n+\t  yx = y[ip][j] - y[im][j];\n+\t  yy = y[i][jp] - y[i][jm];\n+\t  a = 0.25dd * (xy * xy + yy * yy);\n+\t  b = 0.25dd * (xx * xx + yx * yx);\n+\t  c = 0.125dd * (xx * xy + yx * yy);\n+\t  qj = 0.0dd;\n+\t  dd[i][m] = b + a * rel + b;\n+\t  qxx = y[ip][j] - 2.0dd * y[i][j] + y[im][j];\n+\t  qyy = y[i][jp] - 2.0dd * y[i][j] + y[i][jm];\n+\t  qxy = y[ip][jp] - y[ip][jm] - y[im][jp] + y[im][jm];\n+\t  ry[i][m] = a * qxx + b * qyy - c * qxy + yx * qi + yy * qj;\n+\t}\n+    }\n+  while (1);\n+}"}]}