{"sha": "b4557008c45c0a44ae848c71d31ce4ed6316d043", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ1NTcwMDhjNDVjMGE0NGFlODQ4YzcxZDMxY2U0ZWQ2MzE2ZDA0Mw==", "commit": {"author": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2016-05-26T13:28:25Z"}, "committer": {"name": "Chung-Lin Tang", "email": "cltang@gcc.gnu.org", "date": "2016-05-26T13:28:25Z"}, "message": "oacc-plugin.h (GOMP_PLUGIN_async_unmap_vars): Add int parameter.\n\n2016-05-26  Chung-Lin Tang  <cltang@codesourcery.com>\n\n\tlibgomp/\n\t* oacc-plugin.h (GOMP_PLUGIN_async_unmap_vars): Add int parameter.\n\t* oacc-plugin.c (GOMP_PLUGIN_async_unmap_vars): Add 'int async'\n\tparameter, use to set async stream around call to gomp_unmap_vars,\n\tcall gomp_unmap_vars() with 'do_copyfrom' set to true.\n\t* plugin/plugin-nvptx.c (struct ptx_event): Add 'int val' field.\n\t(event_gc): Adjust event handling loop, collect PTX_EVT_ASYNC_CLEANUP\n\tevents and call GOMP_PLUGIN_async_unmap_vars() for each of them.\n\t(event_add): Add int parameter, initialize 'val' field when\n\tadding new ptx_event struct.\n\t(nvptx_evec): Adjust event_add() call arguments.\n\t(nvptx_host2dev): Likewise.\n\t(nvptx_dev2host): Likewise.\n\t(nvptx_wait_async): Likewise.\n\t(nvptx_wait_all_async): Likewise.\n\t(GOMP_OFFLOAD_openacc_register_async_cleanup): Add async parameter,\n\tpass to event_add() call.\n\t* oacc-host.c (host_openacc_register_async_cleanup): Add 'int async'\n\tparameter.\n\t* oacc-mem.c (gomp_acc_remove_pointer): Adjust async case to\n\tcall openacc.register_async_cleanup_func() hook.\n\t* oacc-parallel.c (GOACC_parallel_keyed): Likewise.\n\t* target.c (gomp_copy_from_async): Delete function.\n\t(gomp_map_vars): Remove async_refcount.\n\t(gomp_unmap_vars): Likewise.\n\t(gomp_load_image_to_device): Likewise.\n\t(omp_target_associate_ptr): Likewise.\n\t* libgomp.h (struct splay_tree_key_s): Remove async_refcount.\n\t(acc_dispatch_t.register_async_cleanup_func): Add int parameter.\n\t(gomp_copy_from_async): Remove.\n\nFrom-SVN: r236772", "tree": {"sha": "3365daa7be29239a387036e220df6e9b23275aa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3365daa7be29239a387036e220df6e9b23275aa4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4557008c45c0a44ae848c71d31ce4ed6316d043", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4557008c45c0a44ae848c71d31ce4ed6316d043", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4557008c45c0a44ae848c71d31ce4ed6316d043", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4557008c45c0a44ae848c71d31ce4ed6316d043/comments", "author": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e79136e41af698ccdaec62ed842b4785162dde09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e79136e41af698ccdaec62ed842b4785162dde09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e79136e41af698ccdaec62ed842b4785162dde09"}], "stats": {"total": 149, "additions": 77, "deletions": 72}, "files": [{"sha": "b4ae304dabb99700f45f65cf18b553481b429c7b", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=b4557008c45c0a44ae848c71d31ce4ed6316d043", "patch": "@@ -1,3 +1,35 @@\n+2016-05-26  Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* oacc-plugin.h (GOMP_PLUGIN_async_unmap_vars): Add int parameter.\n+\t* oacc-plugin.c (GOMP_PLUGIN_async_unmap_vars): Add 'int async'\n+\tparameter, use to set async stream around call to gomp_unmap_vars,\n+\tcall gomp_unmap_vars() with 'do_copyfrom' set to true.\n+\t* plugin/plugin-nvptx.c (struct ptx_event): Add 'int val' field.\n+\t(event_gc): Adjust event handling loop, collect PTX_EVT_ASYNC_CLEANUP\n+\tevents and call GOMP_PLUGIN_async_unmap_vars() for each of them.\n+\t(event_add): Add int parameter, initialize 'val' field when\n+\tadding new ptx_event struct.\n+\t(nvptx_evec): Adjust event_add() call arguments.\n+\t(nvptx_host2dev): Likewise.\n+\t(nvptx_dev2host): Likewise.\n+\t(nvptx_wait_async): Likewise.\n+\t(nvptx_wait_all_async): Likewise.\n+\t(GOMP_OFFLOAD_openacc_register_async_cleanup): Add async parameter,\n+\tpass to event_add() call.\n+\t* oacc-host.c (host_openacc_register_async_cleanup): Add 'int async'\n+\tparameter.\n+\t* oacc-mem.c (gomp_acc_remove_pointer): Adjust async case to\n+\tcall openacc.register_async_cleanup_func() hook.\n+\t* oacc-parallel.c (GOACC_parallel_keyed): Likewise.\n+\t* target.c (gomp_copy_from_async): Delete function.\n+\t(gomp_map_vars): Remove async_refcount.\n+\t(gomp_unmap_vars): Likewise.\n+\t(gomp_load_image_to_device): Likewise.\n+\t(omp_target_associate_ptr): Likewise.\n+\t* libgomp.h (struct splay_tree_key_s): Remove async_refcount.\n+\t(acc_dispatch_t.register_async_cleanup_func): Add int parameter.\n+\t(gomp_copy_from_async): Remove.\n+\n 2016-05-26  Chung-Lin Tang  <cltang@codesourcery.com>\n \n \t* target.c (gomp_device_copy): New function."}, {"sha": "7b2671ba49ddb0ca721e8bc670014fd8e495e13c", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=b4557008c45c0a44ae848c71d31ce4ed6316d043", "patch": "@@ -835,8 +835,6 @@ struct splay_tree_key_s {\n   uintptr_t tgt_offset;\n   /* Reference count.  */\n   uintptr_t refcount;\n-  /* Asynchronous reference count.  */\n-  uintptr_t async_refcount;\n   /* Pointer to the original mapping of \"omp declare target link\" object.  */\n   splay_tree_key link_key;\n };\n@@ -872,7 +870,7 @@ typedef struct acc_dispatch_t\n \t\t     unsigned *, void *);\n \n   /* Async cleanup callback registration.  */\n-  void (*register_async_cleanup_func) (void *);\n+  void (*register_async_cleanup_func) (void *, int);\n \n   /* Asynchronous routines.  */\n   int (*async_test_func) (int);\n@@ -977,7 +975,6 @@ extern struct target_mem_desc *gomp_map_vars (struct gomp_device_descr *,\n \t\t\t\t\t      size_t, void **, void **,\n \t\t\t\t\t      size_t *, void *, bool,\n \t\t\t\t\t      enum gomp_map_vars_kind);\n-extern void gomp_copy_from_async (struct target_mem_desc *);\n extern void gomp_unmap_vars (struct target_mem_desc *, bool);\n extern void gomp_init_device (struct gomp_device_descr *);\n extern void gomp_free_memmap (struct splay_tree_s *);"}, {"sha": "fd3a672e4a5576e6e9f133ed6d7a5d7f7a7e2828", "filename": "libgomp/oacc-host.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2Foacc-host.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2Foacc-host.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-host.c?ref=b4557008c45c0a44ae848c71d31ce4ed6316d043", "patch": "@@ -148,7 +148,8 @@ host_openacc_exec (void (*fn) (void *),\n }\n \n static void\n-host_openacc_register_async_cleanup (void *targ_mem_desc __attribute__ ((unused)))\n+host_openacc_register_async_cleanup (void *targ_mem_desc __attribute__ ((unused)),\n+\t\t\t\t     int async __attribute__ ((unused)))\n {\n }\n "}, {"sha": "bd4b62b006e8ad573e220e8e8589aaa4e5809fcb", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=b4557008c45c0a44ae848c71d31ce4ed6316d043", "patch": "@@ -704,10 +704,7 @@ gomp_acc_remove_pointer (void *h, bool force_copyfrom, int async, int mapnum)\n   if (async < acc_async_noval)\n     gomp_unmap_vars (t, true);\n   else\n-    {\n-      gomp_copy_from_async (t);\n-      acc_dev->openacc.register_async_cleanup_func (t);\n-    }\n+    t->device_descr->openacc.register_async_cleanup_func (t, async);\n \n   gomp_debug (0, \"  %s: mappings restored\\n\", __FUNCTION__);\n }"}, {"sha": "ecdd75adcb81f978dfa09859a042b73c02e9d561", "filename": "libgomp/oacc-parallel.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2Foacc-parallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2Foacc-parallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-parallel.c?ref=b4557008c45c0a44ae848c71d31ce4ed6316d043", "patch": "@@ -186,10 +186,7 @@ GOACC_parallel_keyed (int device, void (*fn) (void *),\n   if (async < acc_async_noval)\n     gomp_unmap_vars (tgt, true);\n   else\n-    {\n-      gomp_copy_from_async (tgt);\n-      acc_dev->openacc.register_async_cleanup_func (tgt);\n-    }\n+    tgt->device_descr->openacc.register_async_cleanup_func (tgt, async);\n \n   acc_dev->openacc.async_set_async_func (acc_async_sync);\n }"}, {"sha": "889d86c8c7a87fd7cb3638202b69dc7e59398669", "filename": "libgomp/oacc-plugin.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2Foacc-plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2Foacc-plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-plugin.c?ref=b4557008c45c0a44ae848c71d31ce4ed6316d043", "patch": "@@ -31,11 +31,14 @@\n #include \"oacc-int.h\"\n \n void\n-GOMP_PLUGIN_async_unmap_vars (void *ptr)\n+GOMP_PLUGIN_async_unmap_vars (void *ptr, int async)\n {\n   struct target_mem_desc *tgt = ptr;\n+  struct gomp_device_descr *devicep = tgt->device_descr;\n \n-  gomp_unmap_vars (tgt, false);\n+  devicep->openacc.async_set_async_func (async);\n+  gomp_unmap_vars (tgt, true);\n+  devicep->openacc.async_set_async_func (acc_async_sync);\n }\n \n /* Return the target-specific part of the TLS data for the current thread.  */"}, {"sha": "57fced5a6e455e8bdc183e6f078bca10c1bc04be", "filename": "libgomp/oacc-plugin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2Foacc-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2Foacc-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-plugin.h?ref=b4557008c45c0a44ae848c71d31ce4ed6316d043", "patch": "@@ -27,7 +27,7 @@\n #ifndef OACC_PLUGIN_H\n #define OACC_PLUGIN_H 1\n \n-extern void GOMP_PLUGIN_async_unmap_vars (void *);\n+extern void GOMP_PLUGIN_async_unmap_vars (void *, int);\n extern void *GOMP_PLUGIN_acc_thread (void);\n \n #endif"}, {"sha": "327500c01aa72bfbcbb6d47d11acfeb3451e4d87", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=b4557008c45c0a44ae848c71d31ce4ed6316d043", "patch": "@@ -329,6 +329,7 @@ struct ptx_event\n   int type;\n   void *addr;\n   int ord;\n+  int val;\n \n   struct ptx_event *next;\n };\n@@ -789,6 +790,7 @@ static void\n event_gc (bool memmap_lockable)\n {\n   struct ptx_event *ptx_event = ptx_events;\n+  struct ptx_event *async_cleanups = NULL;\n   struct nvptx_thread *nvthd = nvptx_thread ();\n \n   pthread_mutex_lock (&ptx_event_lock);\n@@ -806,6 +808,7 @@ event_gc (bool memmap_lockable)\n       r = cuEventQuery (*e->evt);\n       if (r == CUDA_SUCCESS)\n \t{\n+\t  bool append_async = false;\n \t  CUevent *te;\n \n \t  te = e->evt;\n@@ -830,14 +833,15 @@ event_gc (bool memmap_lockable)\n \t\tif (!memmap_lockable)\n \t\t  continue;\n \n-\t\tGOMP_PLUGIN_async_unmap_vars (e->addr);\n+\t\tappend_async = true;\n \t      }\n \t      break;\n \t    }\n \n \t  cuEventDestroy (*te);\n \t  free ((void *)te);\n \n+\t  /* Unlink 'e' from ptx_events list.  */\n \t  if (ptx_events == e)\n \t    ptx_events = ptx_events->next;\n \t  else\n@@ -848,15 +852,31 @@ event_gc (bool memmap_lockable)\n \t      e_->next = e_->next->next;\n \t    }\n \n-\t  free (e);\n+\t  if (append_async)\n+\t    {\n+\t      e->next = async_cleanups;\n+\t      async_cleanups = e;\n+\t    }\n+\t  else\n+\t    free (e);\n \t}\n     }\n \n   pthread_mutex_unlock (&ptx_event_lock);\n+\n+  /* We have to do these here, after ptx_event_lock is released.  */\n+  while (async_cleanups)\n+    {\n+      struct ptx_event *e = async_cleanups;\n+      async_cleanups = async_cleanups->next;\n+\n+      GOMP_PLUGIN_async_unmap_vars (e->addr, e->val);\n+      free (e);\n+    }\n }\n \n static void\n-event_add (enum ptx_event_type type, CUevent *e, void *h)\n+event_add (enum ptx_event_type type, CUevent *e, void *h, int val)\n {\n   struct ptx_event *ptx_event;\n   struct nvptx_thread *nvthd = nvptx_thread ();\n@@ -869,6 +889,7 @@ event_add (enum ptx_event_type type, CUevent *e, void *h)\n   ptx_event->evt = e;\n   ptx_event->addr = h;\n   ptx_event->ord = nvthd->ptx_dev->ord;\n+  ptx_event->val = val;\n \n   pthread_mutex_lock (&ptx_event_lock);\n \n@@ -975,7 +996,7 @@ nvptx_exec (void (*fn), size_t mapnum, void **hostaddrs, void **devaddrs,\n \n       CUDA_CALL_ASSERT (cuEventRecord, *e, dev_str->stream);\n \n-      event_add (PTX_EVT_KNL, e, (void *)dev_str);\n+      event_add (PTX_EVT_KNL, e, (void *)dev_str, 0);\n     }\n #else\n   r = cuCtxSynchronize ();\n@@ -1071,7 +1092,7 @@ nvptx_host2dev (void *d, const void *h, size_t s)\n       CUDA_CALL (cuMemcpyHtoDAsync,\n \t\t (CUdeviceptr) d, h, s, nvthd->current_stream->stream);\n       CUDA_CALL (cuEventRecord, *e, nvthd->current_stream->stream);\n-      event_add (PTX_EVT_MEM, e, (void *)h);\n+      event_add (PTX_EVT_MEM, e, (void *)h, 0);\n     }\n   else\n #endif\n@@ -1127,7 +1148,7 @@ nvptx_dev2host (void *h, const void *d, size_t s)\n       CUDA_CALL (cuMemcpyDtoHAsync,\n \t\t h, (CUdeviceptr) d, s, nvthd->current_stream->stream);\n       CUDA_CALL (cuEventRecord, *e, nvthd->current_stream->stream);\n-      event_add (PTX_EVT_MEM, e, (void *)h);\n+      event_add (PTX_EVT_MEM, e, (void *)h, 0);\n     }\n   else\n #endif\n@@ -1240,7 +1261,7 @@ nvptx_wait_async (int async1, int async2)\n \n   CUDA_CALL_ASSERT (cuEventRecord, *e, s1->stream);\n \n-  event_add (PTX_EVT_SYNC, e, NULL);\n+  event_add (PTX_EVT_SYNC, e, NULL, 0);\n \n   CUDA_CALL_ASSERT (cuStreamWaitEvent, s2->stream, *e, 0);\n }\n@@ -1313,7 +1334,7 @@ nvptx_wait_all_async (int async)\n       /* Record an event on the waited-for stream.  */\n       CUDA_CALL_ASSERT (cuEventRecord, *e, other_stream->stream);\n \n-      event_add (PTX_EVT_SYNC, e, NULL);\n+      event_add (PTX_EVT_SYNC, e, NULL, 0);\n \n       CUDA_CALL_ASSERT (cuStreamWaitEvent, waiting_stream->stream, *e, 0);\n    }\n@@ -1646,14 +1667,14 @@ GOMP_OFFLOAD_openacc_parallel (void (*fn) (void *), size_t mapnum,\n }\n \n void\n-GOMP_OFFLOAD_openacc_register_async_cleanup (void *targ_mem_desc)\n+GOMP_OFFLOAD_openacc_register_async_cleanup (void *targ_mem_desc, int async)\n {\n   struct nvptx_thread *nvthd = nvptx_thread ();\n   CUevent *e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));\n \n   CUDA_CALL_ASSERT (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n   CUDA_CALL_ASSERT (cuEventRecord, *e, nvthd->current_stream->stream);\n-  event_add (PTX_EVT_ASYNC_CLEANUP, e, targ_mem_desc);\n+  event_add (PTX_EVT_ASYNC_CLEANUP, e, targ_mem_desc, async);\n }\n \n int"}, {"sha": "48b9ab8e0767a537ddcb624137abbe619a0b786c", "filename": "libgomp/target.c", "status": "modified", "additions": 3, "deletions": 46, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4557008c45c0a44ae848c71d31ce4ed6316d043/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=b4557008c45c0a44ae848c71d31ce4ed6316d043", "patch": "@@ -707,7 +707,6 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\ttgt->list[i].offset = 0;\n \t\ttgt->list[i].length = k->host_end - k->host_start;\n \t\tk->refcount = 1;\n-\t\tk->async_refcount = 0;\n \t\ttgt->refcount++;\n \t\tarray->left = NULL;\n \t\tarray->right = NULL;\n@@ -854,43 +853,9 @@ gomp_unmap_tgt (struct target_mem_desc *tgt)\n   free (tgt);\n }\n \n-/* Decrease the refcount for a set of mapped variables, and queue asychronous\n-   copies from the device back to the host after any work that has been issued.\n-   Because the regions are still \"live\", increment an asynchronous reference\n-   count to indicate that they should not be unmapped from host-side data\n-   structures until the asynchronous copy has completed.  */\n-\n-attribute_hidden void\n-gomp_copy_from_async (struct target_mem_desc *tgt)\n-{\n-  struct gomp_device_descr *devicep = tgt->device_descr;\n-  size_t i;\n-\n-  gomp_mutex_lock (&devicep->lock);\n-\n-  for (i = 0; i < tgt->list_count; i++)\n-    if (tgt->list[i].key == NULL)\n-      ;\n-    else if (tgt->list[i].key->refcount > 1)\n-      {\n-\ttgt->list[i].key->refcount--;\n-\ttgt->list[i].key->async_refcount++;\n-      }\n-    else\n-      {\n-\tsplay_tree_key k = tgt->list[i].key;\n-\tif (tgt->list[i].copy_from)\n-\t  gomp_copy_dev2host (devicep, (void *) k->host_start,\n-\t\t\t      (void *) (k->tgt->tgt_start + k->tgt_offset),\n-\t\t\t      k->host_end - k->host_start);\n-      }\n-\n-  gomp_mutex_unlock (&devicep->lock);\n-}\n-\n /* Unmap variables described by TGT.  If DO_COPYFROM is true, copy relevant\n    variables back from device to host: if it is false, it is assumed that this\n-   has been done already, i.e. by gomp_copy_from_async above.  */\n+   has been done already.  */\n \n attribute_hidden void\n gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)\n@@ -924,13 +889,8 @@ gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)\n \tk->refcount--;\n       else if (k->refcount == 1)\n \t{\n-\t  if (k->async_refcount > 0)\n-\t    k->async_refcount--;\n-\t  else\n-\t    {\n-\t      k->refcount--;\n-\t      do_unmap = true;\n-\t    }\n+\t  k->refcount--;\n+\t  do_unmap = true;\n \t}\n \n       if ((do_unmap && do_copyfrom && tgt->list[i].copy_from)\n@@ -1076,7 +1036,6 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n       k->tgt = tgt;\n       k->tgt_offset = target_table[i].start;\n       k->refcount = REFCOUNT_INFINITY;\n-      k->async_refcount = 0;\n       k->link_key = NULL;\n       array->left = NULL;\n       array->right = NULL;\n@@ -1109,7 +1068,6 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n       k->tgt = tgt;\n       k->tgt_offset = target_var->start;\n       k->refcount = target_size & link_bit ? REFCOUNT_LINK : REFCOUNT_INFINITY;\n-      k->async_refcount = 0;\n       k->link_key = NULL;\n       array->left = NULL;\n       array->right = NULL;\n@@ -2332,7 +2290,6 @@ omp_target_associate_ptr (void *host_ptr, void *device_ptr, size_t size,\n       k->tgt = tgt;\n       k->tgt_offset = (uintptr_t) device_ptr + device_offset;\n       k->refcount = REFCOUNT_INFINITY;\n-      k->async_refcount = 0;\n       array->left = NULL;\n       array->right = NULL;\n       splay_tree_insert (&devicep->mem_map, array);"}]}