{"sha": "3c01e5dffbd8ec9480e84f055869b5977d7c4396", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MwMWU1ZGZmYmQ4ZWM5NDgwZTg0ZjA1NTg2OWI1OTc3ZDdjNDM5Ng==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-06-27T03:03:55Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-06-27T03:03:55Z"}, "message": "cp-tree.h (cp_cv_quals): New type.\n\n\t* cp-tree.h (cp_cv_quals): New type.\n\t(cp_declarator): Use it instead of \"tree\" as appropriate.\n\t(grok_method_quals): Adjust prototype.\n\t(grokclassfn): Likewise.\n\t(do_friend): Likewise.\n\t* decl.c (grokfndecl): Use cp_cv_quals, not tree.\n\t(grokdeclarator): Likewise.\n\t* decl2.c (grok_method_quals): Likewise.\n\t(grokclassfn): Likewise.\n\t* friend.c (do_friend): Likewise.\n\t* method.c (implicitly_declare_fn): Adjust call to grokclassfn.\n\t* parser.c (make_call_declarator): Use cp_cv_quals, not tree.\n\t(make_pointer_declarator): Likewise.\n\t(make_reference_declarator): Likewise.\n\t(make_ptrmem_declarator): Likewise.\n\t(cp_parser_ptr_operator): Likewise.\n\t(cp_parser_cv_qualifier_seq_opt): Likewise.\n\t(cp_parser_cv_qualifier_opt): Remove.\n\t(cp_parser_new_declarator_opt): Adjust call to\n\tcp_parser_ptr_operator.\n\t(cp_parser_conversion_declaration_opt): Likewise.\n\t(cp_parser_declarator): Use cp_cv_quals, not tree.\n\t(cp_parser_direct_declarator): Likewise.\n\nFrom-SVN: r83729", "tree": {"sha": "f25fb279892e6b2a46ef55fac1e66d9a3a38c238", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f25fb279892e6b2a46ef55fac1e66d9a3a38c238"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c01e5dffbd8ec9480e84f055869b5977d7c4396", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c01e5dffbd8ec9480e84f055869b5977d7c4396", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c01e5dffbd8ec9480e84f055869b5977d7c4396", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c01e5dffbd8ec9480e84f055869b5977d7c4396/comments", "author": null, "committer": null, "parents": [{"sha": "808fd801de9700471d99876e2ff4be467b8096f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/808fd801de9700471d99876e2ff4be467b8096f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/808fd801de9700471d99876e2ff4be467b8096f2"}], "stats": {"total": 333, "additions": 148, "deletions": 185}, "files": [{"sha": "77aeeb08070bd2675d0486a2b6f655d5dad64816", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c01e5dffbd8ec9480e84f055869b5977d7c4396/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c01e5dffbd8ec9480e84f055869b5977d7c4396/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3c01e5dffbd8ec9480e84f055869b5977d7c4396", "patch": "@@ -1,3 +1,29 @@\n+2004-06-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (cp_cv_quals): New type.\n+\t(cp_declarator): Use it instead of \"tree\" as appropriate.\n+\t(grok_method_quals): Adjust prototype.\n+\t(grokclassfn): Likewise.\n+\t(do_friend): Likewise.\n+\t* decl.c (grokfndecl): Use cp_cv_quals, not tree.\n+\t(grokdeclarator): Likewise.\n+\t* decl2.c (grok_method_quals): Likewise.\n+\t(grokclassfn): Likewise.\n+\t* friend.c (do_friend): Likewise.\n+\t* method.c (implicitly_declare_fn): Adjust call to grokclassfn.\n+\t* parser.c (make_call_declarator): Use cp_cv_quals, not tree.\n+\t(make_pointer_declarator): Likewise.\n+\t(make_reference_declarator): Likewise.\n+\t(make_ptrmem_declarator): Likewise.\n+\t(cp_parser_ptr_operator): Likewise.\n+\t(cp_parser_cv_qualifier_seq_opt): Likewise.\n+\t(cp_parser_cv_qualifier_opt): Remove.\n+\t(cp_parser_new_declarator_opt): Adjust call to\n+\tcp_parser_ptr_operator.\n+\t(cp_parser_conversion_declaration_opt): Likewise.\n+\t(cp_parser_declarator): Use cp_cv_quals, not tree.\n+\t(cp_parser_direct_declarator): Likewise.\n+\n 2004-06-26  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* call.c, cp-tree.h, cxx-pretty-print.c, decl.c, decl2.c:"}, {"sha": "54bb0e3bb20b987863969f6635bc35e975d4c2f9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c01e5dffbd8ec9480e84f055869b5977d7c4396/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c01e5dffbd8ec9480e84f055869b5977d7c4396/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3c01e5dffbd8ec9480e84f055869b5977d7c4396", "patch": "@@ -3503,6 +3503,11 @@ extern GTY(()) operator_name_info_t operator_name_info\n extern GTY(()) operator_name_info_t assignment_operator_name_info\n   [(int) LAST_CPLUS_TREE_CODE];\n \n+/* A type-qualifier, or bitmask therefore, using the TYPE_QUAL\n+   constants.  */\n+\n+typedef int cp_cv_quals;\n+\n /* A storage class.  */\n \n typedef enum cp_storage_class {\n@@ -3628,7 +3633,7 @@ struct cp_declarator {\n       /* The parameters to the function.  */\n       cp_parameter_declarator *parameters;\n       /* The cv-qualifiers for the function.  */\n-      tree qualifiers;\n+      cp_cv_quals qualifiers;\n       /* The exception-specification for the function.  */\n       tree exception_specification;\n     } function;\n@@ -3640,7 +3645,7 @@ struct cp_declarator {\n     /* For cdk_pointer, cdk_reference, and cdk_ptrmem.  */\n     struct {\n       /* The cv-qualifiers for the pointer.  */\n-      tree qualifiers;\n+      cp_cv_quals qualifiers;\n       /* For cdk_ptrmem, the class type containing the member.  */\n       tree class_type;\n     } pointer;\n@@ -3866,10 +3871,10 @@ extern bool have_extern_spec;\n \n /* in decl2.c */\n extern bool check_java_method (tree);\n-extern int grok_method_quals (tree, tree, tree);\n+extern cp_cv_quals grok_method_quals (tree, tree, cp_cv_quals);\n extern void maybe_retrofit_in_chrg (tree);\n extern void maybe_make_one_only\t(tree);\n-extern void grokclassfn\t(tree, tree, enum overload_flags, tree);\n+extern void grokclassfn\t(tree, tree, enum overload_flags, cp_cv_quals);\n extern tree grok_array_decl (tree, tree);\n extern tree delete_sanity (tree, tree, bool, int);\n extern tree check_classfn (tree, tree, tree);\n@@ -3941,7 +3946,7 @@ extern tree cplus_expand_constant               (tree);\n extern int is_friend\t\t\t\t(tree, tree);\n extern void make_friend_class\t\t\t(tree, tree, bool);\n extern void add_friend                          (tree, tree, bool);\n-extern tree do_friend\t\t\t\t(tree, tree, tree, tree, enum overload_flags, tree, int);\n+extern tree do_friend\t\t\t\t(tree, tree, tree, tree, enum overload_flags, cp_cv_quals, int);\n \n /* in init.c */\n extern tree expand_member_init\t\t\t(tree);"}, {"sha": "838f22bd55af2f423368d792f7cfe843878296d0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 20, "deletions": 58, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c01e5dffbd8ec9480e84f055869b5977d7c4396/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c01e5dffbd8ec9480e84f055869b5977d7c4396/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3c01e5dffbd8ec9480e84f055869b5977d7c4396", "patch": "@@ -62,7 +62,7 @@ static int unary_op_p (enum tree_code);\n static void push_local_name (tree);\n static tree grok_reference_init (tree, tree, tree, tree *);\n static tree grokfndecl (tree, tree, tree, tree, tree, int,\n-\t\t\tenum overload_flags, tree,\n+\t\t\tenum overload_flags, cp_cv_quals,\n \t\t\ttree, int, int, int, int, int, int, tree);\n static tree grokvardecl (tree, tree, cp_decl_specifier_seq *, int, int, tree);\n static void record_unknown_type (tree, const char *);\n@@ -5424,7 +5424,7 @@ grokfndecl (tree ctype,\n             tree orig_declarator,\n             int virtualp,\n             enum overload_flags flags,\n-            tree quals, \n+\t    cp_cv_quals quals,\n             tree raises,\n             int check, \n             int friendp, \n@@ -5544,11 +5544,11 @@ grokfndecl (tree ctype,\n     DECL_INLINE (decl) = 1;\n \n   DECL_EXTERNAL (decl) = 1;\n-  if (quals != NULL_TREE && TREE_CODE (type) == FUNCTION_TYPE)\n+  if (quals && TREE_CODE (type) == FUNCTION_TYPE)\n     {\n-      error (\"%smember function `%D' cannot have `%T' method qualifier\",\n-\t\t(ctype ? \"static \" : \"non-\"), decl, TREE_VALUE (quals));\n-      quals = NULL_TREE;\n+      error (\"%smember function `%D' cannot have cv-qualifier\",\n+\t     (ctype ? \"static \" : \"non-\"), decl);\n+      quals = TYPE_UNQUALIFIED;\n     }\n \n   if (IDENTIFIER_OPNAME_P (DECL_NAME (decl)))\n@@ -6287,7 +6287,7 @@ grokdeclarator (const cp_declarator *declarator,\n   tree dname = NULL_TREE;\n   tree ctor_return_type = NULL_TREE;\n   enum overload_flags flags = NO_SPECIAL;\n-  tree quals = NULL_TREE;\n+  cp_cv_quals quals = TYPE_UNQUALIFIED;\n   tree raises = NULL_TREE;\n   int template_count = 0;\n   tree returned_attrs = NULL_TREE;\n@@ -6546,7 +6546,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t} \n       else if (declspecs->specs[(int)ds] > 1)\n \t{\n-\t  static const char *decl_spec_names[] = {\n+\t  static const char *const decl_spec_names[] = {\n \t    \"signed\",\n \t    \"unsigned\",\n \t    \"short\",\n@@ -7049,9 +7049,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t      error (\"destructor cannot be static member function\");\n \t\t    if (quals)\n \t\t      {\n-\t\t\terror (\"destructors may not be `%E'\",\n-\t\t\t\t  TREE_VALUE (quals));\n-\t\t\tquals = NULL_TREE;\n+\t\t\terror (\"destructors may not be cv-qualified\");\n+\t\t\tquals = TYPE_UNQUALIFIED;\n \t\t      }\n \t\t    if (decl_context == FIELD)\n \t\t      {\n@@ -7078,9 +7077,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t      }\n \t\t    if (quals)\n \t\t      {\n-\t\t\terror (\"constructors may not be `%E'\",\n-                               TREE_VALUE (quals));\n-\t\t\tquals = NULL_TREE;\n+\t\t\terror (\"constructors may not be cv-qualified\");\n+\t\t\tquals = TYPE_UNQUALIFIED;\n \t\t      }\n \t\t    if (decl_context == FIELD)\n \t\t      {\n@@ -7163,7 +7161,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t      grok_method_quals (declarator->u.pointer.class_type, \n \t\t\t\t dummy, quals);\n \t      type = TREE_TYPE (dummy);\n-\t      quals = NULL_TREE;\n+\t      quals = TYPE_UNQUALIFIED;\n \t    }\n \n \t  if (declarator->kind == cdk_reference)\n@@ -7184,45 +7182,9 @@ grokdeclarator (const cp_declarator *declarator,\n \n \t  if (declarator->u.pointer.qualifiers)\n \t    {\n-\t      tree typemodlist;\n-\t      int erred = 0;\n-\t      int constp = 0;\n-\t      int volatilep = 0;\n-\t      int restrictp = 0;\n-\t      \n-\t      for (typemodlist = declarator->u.pointer.qualifiers; typemodlist;\n-\t\t   typemodlist = TREE_CHAIN (typemodlist))\n-\t\t{\n-\t\t  tree qualifier = TREE_VALUE (typemodlist);\n-\n-\t\t  if (qualifier == ridpointers[(int) RID_CONST])\n-\t\t    {\n-\t\t      constp++;\n-\t\t      type_quals |= TYPE_QUAL_CONST;\n-\t\t    }\n-\t\t  else if (qualifier == ridpointers[(int) RID_VOLATILE])\n-\t\t    {\n-\t\t      volatilep++;\n-\t\t      type_quals |= TYPE_QUAL_VOLATILE;\n-\t\t    }\n-\t\t  else if (qualifier == ridpointers[(int) RID_RESTRICT])\n-\t\t    {\n-\t\t      restrictp++;\n-\t\t      type_quals |= TYPE_QUAL_RESTRICT;\n-\t\t    }\n-\t\t  else if (!erred)\n-\t\t    {\n-\t\t      erred = 1;\n-\t\t      error (\"invalid type modifier within pointer declarator\");\n-\t\t    }\n-\t\t}\n-\t      if (constp > 1)\n-\t\tpedwarn (\"duplicate `const'\");\n-\t      if (volatilep > 1)\n-\t\tpedwarn (\"duplicate `volatile'\");\n-\t      if (restrictp > 1)\n-\t\tpedwarn (\"duplicate `restrict'\");\n-\t      type = cp_build_qualified_type (type, type_quals);\n+\t      type \n+\t\t= cp_build_qualified_type (type, \n+\t\t\t\t\t   declarator->u.pointer.qualifiers);\n \t      type_quals = cp_type_quals (type);\n \t    }\n \t  ctype = NULL_TREE;\n@@ -7488,7 +7450,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  || (typedef_decl && C_TYPEDEF_EXPLICITLY_SIGNED (typedef_decl)))\n \tC_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;\n \n-      bad_specifiers (decl, \"type\", virtualp, quals != NULL_TREE,\n+      bad_specifiers (decl, \"type\", virtualp, quals != TYPE_UNQUALIFIED, \n \t\t      inlinep, friendp, raises != NULL_TREE);\n \n       return decl;\n@@ -7654,7 +7616,7 @@ grokdeclarator (const cp_declarator *declarator,\n       {\n \tdecl = cp_build_parm_decl (unqualified_id, type);\n \n-\tbad_specifiers (decl, \"parameter\", virtualp, quals != NULL_TREE,\n+\tbad_specifiers (decl, \"parameter\", virtualp, quals != TYPE_UNQUALIFIED,\n \t\t\tinlinep, friendp, raises != NULL_TREE);\n       }\n     else if (decl_context == FIELD)\n@@ -7908,7 +7870,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  }\n \t      }\n \n-\t    bad_specifiers (decl, \"field\", virtualp, quals != NULL_TREE,\n+\t    bad_specifiers (decl, \"field\", virtualp, quals != TYPE_UNQUALIFIED,\n \t\t\t    inlinep, friendp, raises != NULL_TREE);\n \t  }\n       }\n@@ -8009,7 +7971,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t    initialized,\n \t\t\t    (type_quals & TYPE_QUAL_CONST) != 0,\n \t\t\t    ctype ? ctype : in_namespace);\n-\tbad_specifiers (decl, \"variable\", virtualp, quals != NULL_TREE,\n+\tbad_specifiers (decl, \"variable\", virtualp, quals != TYPE_UNQUALIFIED,\n \t\t\tinlinep, friendp, raises != NULL_TREE);\n \n \tif (ctype)"}, {"sha": "2214e8d3656a7c6a5d6d127f7e63dfdf9423e3d8", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c01e5dffbd8ec9480e84f055869b5977d7c4396/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c01e5dffbd8ec9480e84f055869b5977d7c4396/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=3c01e5dffbd8ec9480e84f055869b5977d7c4396", "patch": "@@ -118,31 +118,15 @@ tree static_dtors;\n    TYPE_UNQUALIFIED will be an extension.  */\n \n int\n-grok_method_quals (tree ctype, tree function, tree quals)\n+grok_method_quals (tree ctype, tree function, cp_cv_quals quals)\n {\n   tree fntype = TREE_TYPE (function);\n   tree raises = TYPE_RAISES_EXCEPTIONS (fntype);\n   int type_quals = TYPE_UNQUALIFIED;\n-  int dup_quals = TYPE_UNQUALIFIED;\n   int this_quals = TYPE_UNQUALIFIED;\n \n-  while (quals)\n-    {\n-      int tq = cp_type_qual_from_rid (TREE_VALUE (quals));\n-      \n-      if ((type_quals | this_quals) & tq)\n-\tdup_quals |= tq;\n-      else if (tq & TYPE_QUAL_RESTRICT)\n-        this_quals |= tq;\n-      else\n-\ttype_quals |= tq;\n-      quals = TREE_CHAIN (quals);\n-    } \n-\n-  if (dup_quals != TYPE_UNQUALIFIED)\n-    error (\"duplicate type qualifiers in %s declaration\",\n-\t      TREE_CODE (function) == FUNCTION_DECL \n-\t      ? \"member function\" : \"type\");\n+  type_quals = quals & ~TYPE_QUAL_RESTRICT;\n+  this_quals = quals & TYPE_QUAL_RESTRICT;\n \n   ctype = cp_build_qualified_type (ctype, type_quals);\n   fntype = build_method_type_directly (ctype, TREE_TYPE (fntype),\n@@ -281,10 +265,11 @@ maybe_retrofit_in_chrg (tree fn)\n    QUALS are the qualifiers for the this pointer.  */\n \n void\n-grokclassfn (tree ctype, tree function, enum overload_flags flags, tree quals)\n+grokclassfn (tree ctype, tree function, enum overload_flags flags, \n+\t     cp_cv_quals quals)\n {\n   tree fn_name = DECL_NAME (function);\n-  int this_quals = TYPE_UNQUALIFIED;\n+  cp_cv_quals this_quals = TYPE_UNQUALIFIED;\n \n   /* Even within an `extern \"C\"' block, members get C++ linkage.  See\n      [dcl.link] for details.  */"}, {"sha": "faf558c42451079a8591c10e35f44c52676ff794", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c01e5dffbd8ec9480e84f055869b5977d7c4396/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c01e5dffbd8ec9480e84f055869b5977d7c4396/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=3c01e5dffbd8ec9480e84f055869b5977d7c4396", "patch": "@@ -325,7 +325,8 @@ make_friend_class (tree type, tree friend_type, bool complain)\n \n tree\n do_friend (tree ctype, tree declarator, tree decl,\n-\t   tree attrlist, enum overload_flags flags, tree quals,\n+\t   tree attrlist, enum overload_flags flags, \n+\t   cp_cv_quals quals,\n \t   int funcdef_flag)\n {\n   /* Every decl that gets here is a friend of something.  */"}, {"sha": "adda8da26bcaaa0044a609c1c8b9a1b44fe8bd87", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c01e5dffbd8ec9480e84f055869b5977d7c4396/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c01e5dffbd8ec9480e84f055869b5977d7c4396/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=3c01e5dffbd8ec9480e84f055869b5977d7c4396", "patch": "@@ -1020,7 +1020,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n     }\n \n   grokclassfn (type, fn, kind == sfk_destructor ? DTOR_FLAG : NO_SPECIAL,\n-\t       /*quals=*/NULL_TREE);\n+\t       TYPE_UNQUALIFIED);\n   grok_special_member_properties (fn);\n   cp_finish_decl (fn, /*init=*/NULL_TREE, /*asmspec_tree=*/NULL_TREE,\n \t\t  /*flags=*/LOOKUP_ONLYCONVERTING);"}, {"sha": "1b989dbe283626464c71233511748de345b3fa17", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 83, "deletions": 99, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c01e5dffbd8ec9480e84f055869b5977d7c4396/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c01e5dffbd8ec9480e84f055869b5977d7c4396/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=3c01e5dffbd8ec9480e84f055869b5977d7c4396", "patch": "@@ -1019,17 +1019,17 @@ clear_decl_specs (cp_decl_specifier_seq *decl_specs)\n static cp_declarator *make_id_declarator \n   (tree);\n static cp_declarator *make_call_declarator\t\n-  (cp_declarator *, cp_parameter_declarator *, tree, tree);\n+  (cp_declarator *, cp_parameter_declarator *, cp_cv_quals, tree);\n static cp_declarator *make_array_declarator\t\n   (cp_declarator *, tree);\n static cp_declarator *make_pointer_declarator\t\n-  (tree, cp_declarator *);\n+  (cp_cv_quals, cp_declarator *);\n static cp_declarator *make_reference_declarator\t\n-  (tree, cp_declarator *);\n+  (cp_cv_quals, cp_declarator *);\n static cp_parameter_declarator *make_parameter_declarator \n   (cp_decl_specifier_seq *, cp_declarator *, tree);\n static cp_declarator *make_ptrmem_declarator\t\n-  (tree, tree, cp_declarator *);\n+  (cp_cv_quals, tree, cp_declarator *);\n \n cp_declarator *cp_error_declarator;\n \n@@ -1080,7 +1080,7 @@ make_id_declarator (tree id)\n    type, represented as identifiers.  */\n \n cp_declarator *\n-make_pointer_declarator (tree cv_qualifiers, cp_declarator *target)\n+make_pointer_declarator (cp_cv_quals cv_qualifiers, cp_declarator *target)\n {\n   cp_declarator *declarator;\n \n@@ -1095,7 +1095,7 @@ make_pointer_declarator (tree cv_qualifiers, cp_declarator *target)\n /* Like make_pointer_declarator -- but for references.  */\n \n cp_declarator *\n-make_reference_declarator (tree cv_qualifiers, cp_declarator *target)\n+make_reference_declarator (cp_cv_quals cv_qualifiers, cp_declarator *target)\n {\n   cp_declarator *declarator;\n \n@@ -1111,7 +1111,7 @@ make_reference_declarator (tree cv_qualifiers, cp_declarator *target)\n    member of CLASS_TYPE.  */\n \n cp_declarator *\n-make_ptrmem_declarator (tree cv_qualifiers, tree class_type,\n+make_ptrmem_declarator (cp_cv_quals cv_qualifiers, tree class_type,\n \t\t\tcp_declarator *pointee)\n {\n   cp_declarator *declarator;\n@@ -1132,7 +1132,7 @@ make_ptrmem_declarator (tree cv_qualifiers, tree class_type,\n cp_declarator *\n make_call_declarator (cp_declarator *target, \n \t\t      cp_parameter_declarator *parms,\n-\t\t      tree cv_qualifiers, \n+\t\t      cp_cv_quals cv_qualifiers,\n                       tree exception_specification)\n {\n   cp_declarator *declarator;\n@@ -1693,10 +1693,8 @@ static cp_declarator *cp_parser_declarator\n static cp_declarator *cp_parser_direct_declarator\n   (cp_parser *, cp_parser_declarator_kind, int *);\n static enum tree_code cp_parser_ptr_operator\n-  (cp_parser *, tree *, tree *);\n-static tree cp_parser_cv_qualifier_seq_opt\n-  (cp_parser *);\n-static tree cp_parser_cv_qualifier_opt\n+  (cp_parser *, tree *, cp_cv_quals *);\n+static cp_cv_quals cp_parser_cv_qualifier_seq_opt\n   (cp_parser *);\n static tree cp_parser_declarator_id\n   (cp_parser *);\n@@ -4956,12 +4954,12 @@ cp_parser_new_declarator_opt (cp_parser* parser)\n {\n   enum tree_code code;\n   tree type;\n-  tree cv_qualifier_seq;\n+  cp_cv_quals cv_quals;\n \n   /* We don't know if there's a ptr-operator next, or not.  */\n   cp_parser_parse_tentatively (parser);\n   /* Look for a ptr-operator.  */\n-  code = cp_parser_ptr_operator (parser, &type, &cv_qualifier_seq);\n+  code = cp_parser_ptr_operator (parser, &type, &cv_quals);\n   /* If that worked, look for more new-declarators.  */\n   if (cp_parser_parse_definitely (parser))\n     {\n@@ -4972,15 +4970,11 @@ cp_parser_new_declarator_opt (cp_parser* parser)\n \n       /* Create the representation of the declarator.  */\n       if (type)\n-\tdeclarator = make_ptrmem_declarator (cv_qualifier_seq,\n-\t\t\t\t\t     type,\n-\t\t\t\t\t     declarator);\n+\tdeclarator = make_ptrmem_declarator (cv_quals, type, declarator);\n       else if (code == INDIRECT_REF)\n-\tdeclarator = make_pointer_declarator (cv_qualifier_seq,\n-\t\t\t\t\t      declarator);\n+\tdeclarator = make_pointer_declarator (cv_quals, declarator);\n       else\n-\tdeclarator = make_reference_declarator (cv_qualifier_seq,\n-\t\t\t\t\t\tdeclarator);\n+\tdeclarator = make_reference_declarator (cv_quals, declarator);\n \n       return declarator;\n     }\n@@ -7570,13 +7564,12 @@ cp_parser_conversion_declarator_opt (cp_parser* parser)\n {\n   enum tree_code code;\n   tree class_type;\n-  tree cv_qualifier_seq;\n+  cp_cv_quals cv_quals;\n \n   /* We don't know if there's a ptr-operator next, or not.  */\n   cp_parser_parse_tentatively (parser);\n   /* Try the ptr-operator.  */\n-  code = cp_parser_ptr_operator (parser, &class_type,\n-\t\t\t\t &cv_qualifier_seq);\n+  code = cp_parser_ptr_operator (parser, &class_type, &cv_quals);\n   /* If it worked, look for more conversion-declarators.  */\n   if (cp_parser_parse_definitely (parser))\n     {\n@@ -7587,15 +7580,12 @@ cp_parser_conversion_declarator_opt (cp_parser* parser)\n       \n       /* Create the representation of the declarator.  */\n       if (class_type)\n-\tdeclarator = make_ptrmem_declarator (cv_qualifier_seq,\n-\t\t\t\t\t     class_type,\n+\tdeclarator = make_ptrmem_declarator (cv_quals, class_type,\n \t\t\t\t\t     declarator);\n       else if (code == INDIRECT_REF)\n-\tdeclarator = make_pointer_declarator (cv_qualifier_seq,\n-\t\t\t\t\t      declarator);\n+\tdeclarator = make_pointer_declarator (cv_quals, declarator);\n       else\n-\tdeclarator = make_reference_declarator (cv_qualifier_seq,\n-\t\t\t\t\t\tdeclarator);\n+\tdeclarator = make_reference_declarator (cv_quals, declarator);\n       \n       return declarator;\n    }\n@@ -10779,7 +10769,7 @@ cp_parser_declarator (cp_parser* parser,\n   cp_token *token;\n   cp_declarator *declarator;\n   enum tree_code code;\n-  tree cv_qualifier_seq;\n+  cp_cv_quals cv_quals;\n   tree class_type;\n   tree attributes = NULL_TREE;\n \n@@ -10799,7 +10789,7 @@ cp_parser_declarator (cp_parser* parser,\n   /* Parse the ptr-operator.  */\n   code = cp_parser_ptr_operator (parser,\n \t\t\t\t &class_type,\n-\t\t\t\t &cv_qualifier_seq);\n+\t\t\t\t &cv_quals);\n   /* If that worked, then we have a ptr-operator.  */\n   if (cp_parser_parse_definitely (parser))\n     {\n@@ -10825,15 +10815,13 @@ cp_parser_declarator (cp_parser* parser,\n \n       /* Build the representation of the ptr-operator.  */\n       if (class_type)\n-\tdeclarator = make_ptrmem_declarator (cv_qualifier_seq,\n+\tdeclarator = make_ptrmem_declarator (cv_quals,\n \t\t\t\t\t     class_type,\n \t\t\t\t\t     declarator);\n       else if (code == INDIRECT_REF)\n-\tdeclarator = make_pointer_declarator (cv_qualifier_seq,\n-\t\t\t\t\t      declarator);\n+\tdeclarator = make_pointer_declarator (cv_quals, declarator);\n       else\n-\tdeclarator = make_reference_declarator (cv_qualifier_seq,\n-\t\t\t\t\t\tdeclarator);\n+\tdeclarator = make_reference_declarator (cv_quals, declarator);\n     }\n   /* Everything else is a direct-declarator.  */\n   else\n@@ -10968,7 +10956,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t     \t exception-specification.  */\n \t      if (cp_parser_parse_definitely (parser))\n \t\t{\n-\t\t  tree cv_qualifiers;\n+\t\t  cp_cv_quals cv_quals;\n \t\t  tree exception_specification;\n \n \t\t  if (ctor_dtor_or_conv_p)\n@@ -10978,15 +10966,15 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n \n \t\t  /* Parse the cv-qualifier-seq.  */\n-\t\t  cv_qualifiers = cp_parser_cv_qualifier_seq_opt (parser);\n+\t\t  cv_quals = cp_parser_cv_qualifier_seq_opt (parser);\n \t\t  /* And the exception-specification.  */\n \t\t  exception_specification\n \t\t    = cp_parser_exception_specification_opt (parser);\n \n \t\t  /* Create the function-declarator.  */\n \t\t  declarator = make_call_declarator (declarator,\n \t\t\t\t\t\t     params,\n-\t\t\t\t\t\t     cv_qualifiers,\n+\t\t\t\t\t\t     cv_quals,\n \t\t\t\t\t\t     exception_specification);\n \t\t  /* Any subsequent parameter lists are to do with\n \t \t     return type, so are not those of the declared\n@@ -11226,25 +11214,25 @@ cp_parser_direct_declarator (cp_parser* parser,\n    ptr-operator:\n      & cv-qualifier-seq [opt]\n \n-   Returns INDIRECT_REF if a pointer, or pointer-to-member, was\n-   used.  Returns ADDR_EXPR if a reference was used.  In the\n-   case of a pointer-to-member, *TYPE is filled in with the\n-   TYPE containing the member.  *CV_QUALIFIER_SEQ is filled in\n-   with the cv-qualifier-seq, or NULL_TREE, if there are no\n-   cv-qualifiers.  Returns ERROR_MARK if an error occurred.  */\n+   Returns INDIRECT_REF if a pointer, or pointer-to-member, was used.\n+   Returns ADDR_EXPR if a reference was used.  In the case of a\n+   pointer-to-member, *TYPE is filled in with the TYPE containing the\n+   member.  *CV_QUALS is filled in with the cv-qualifier-seq, or\n+   TYPE_UNQUALIFIED, if there are no cv-qualifiers.  Returns\n+   ERROR_MARK if an error occurred.  */\n \n static enum tree_code\n cp_parser_ptr_operator (cp_parser* parser,\n                         tree* type,\n-                        tree* cv_qualifier_seq)\n+\t\t\tcp_cv_quals *cv_quals)\n {\n   enum tree_code code = ERROR_MARK;\n   cp_token *token;\n \n   /* Assume that it's not a pointer-to-member.  */\n   *type = NULL_TREE;\n   /* And that there are no cv-qualifiers.  */\n-  *cv_qualifier_seq = NULL_TREE;\n+  *cv_quals = TYPE_UNQUALIFIED;\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -11263,7 +11251,7 @@ cp_parser_ptr_operator (cp_parser* parser,\n \t enforced during semantic analysis.  */\n       if (code == INDIRECT_REF\n \t  || cp_parser_allow_gnu_extensions_p (parser))\n-\t*cv_qualifier_seq = cp_parser_cv_qualifier_seq_opt (parser);\n+\t*cv_quals = cp_parser_cv_qualifier_seq_opt (parser);\n     }\n   else\n     {\n@@ -11293,7 +11281,7 @@ cp_parser_ptr_operator (cp_parser* parser,\n \t  /* Indicate that the `*' operator was used.  */\n \t  code = INDIRECT_REF;\n \t  /* Look for the optional cv-qualifier-seq.  */\n-\t  *cv_qualifier_seq = cp_parser_cv_qualifier_seq_opt (parser);\n+\t  *cv_quals = cp_parser_cv_qualifier_seq_opt (parser);\n \t}\n       /* If that didn't work we don't have a ptr-operator.  */\n       if (!cp_parser_parse_definitely (parser))\n@@ -11308,69 +11296,65 @@ cp_parser_ptr_operator (cp_parser* parser,\n    cv-qualifier-seq:\n      cv-qualifier cv-qualifier-seq [opt]\n \n-   Returns a TREE_LIST.  The TREE_VALUE of each node is the\n-   representation of a cv-qualifier.  */\n-\n-static tree\n-cp_parser_cv_qualifier_seq_opt (cp_parser* parser)\n-{\n-  tree cv_qualifiers = NULL_TREE;\n-\n-  while (true)\n-    {\n-      tree cv_qualifier;\n-\n-      /* Look for the next cv-qualifier.  */\n-      cv_qualifier = cp_parser_cv_qualifier_opt (parser);\n-      /* If we didn't find one, we're done.  */\n-      if (!cv_qualifier)\n-\tbreak;\n-\n-      /* Add this cv-qualifier to the list.  */\n-      cv_qualifiers\n-\t= tree_cons (NULL_TREE, cv_qualifier, cv_qualifiers);\n-    }\n-\n-  /* We built up the list in reverse order.  */\n-  return nreverse (cv_qualifiers);\n-}\n-\n-/* Parse an (optional) cv-qualifier.\n-\n    cv-qualifier:\n      const\n      volatile\n \n    GNU Extension:\n \n    cv-qualifier:\n-     __restrict__ */\n+     __restrict__ \n \n-static tree\n-cp_parser_cv_qualifier_opt (cp_parser* parser)\n+   Returns a bitmask representing the cv-qualifiers.  */\n+\n+static cp_cv_quals\n+cp_parser_cv_qualifier_seq_opt (cp_parser* parser)\n {\n-  cp_token *token;\n-  tree cv_qualifier = NULL_TREE;\n+  cp_cv_quals cv_quals = TYPE_UNQUALIFIED;\n \n-  /* Peek at the next token.  */\n-  token = cp_lexer_peek_token (parser->lexer);\n-  /* See if it's a cv-qualifier.  */\n-  switch (token->keyword)\n+  while (true)\n     {\n-    case RID_CONST:\n-    case RID_VOLATILE:\n-    case RID_RESTRICT:\n-      /* Save the value of the token.  */\n-      cv_qualifier = token->value;\n-      /* Consume the token.  */\n-      cp_lexer_consume_token (parser->lexer);\n-      break;\n+      cp_token *token;\n+      cp_cv_quals cv_qualifier;\n+      \n+      /* Peek at the next token.  */\n+      token = cp_lexer_peek_token (parser->lexer);\n+      /* See if it's a cv-qualifier.  */\n+      switch (token->keyword)\n+\t{\n+\tcase RID_CONST:\n+\t  cv_qualifier = TYPE_QUAL_CONST;\n+\t  break;\n+\t  \n+\tcase RID_VOLATILE:\n+\t  cv_qualifier = TYPE_QUAL_VOLATILE;\n+\t  break;\n+\t  \n+\tcase RID_RESTRICT:\n+\t  cv_qualifier = TYPE_QUAL_RESTRICT;\n+\t  break;\n+\t  \n+\tdefault:\n+\t  cv_qualifier = TYPE_UNQUALIFIED;\n+\t  break;\n+\t}\n+      \n+      if (!cv_qualifier)\n+\tbreak;\n \n-    default:\n-      break;\n+      if (cv_quals & cv_qualifier)\n+\t{\n+\t  error (\"duplicate cv-qualifier\");\n+\t  cp_lexer_purge_token (parser->lexer);\n+\t}\n+      else\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  cv_quals |= cv_qualifier;\n+\t}\n     }\n \n-  return cv_qualifier;\n+  return cv_quals;\n }\n \n /* Parse a declarator-id."}]}