{"sha": "f884cd2fea62eebe71b422e1c97e550958dd42ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg4NGNkMmZlYTYyZWViZTcxYjQyMmUxYzk3ZTU1MDk1OGRkNDJhZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-16T10:36:20Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-16T10:36:20Z"}, "message": "Extend can_duplicate_and_interleave_p to mixed-size vectors\n\nThis patch makes can_duplicate_and_interleave_p cope with mixtures of\nvector sizes, by using queries based on get_vectype_for_scalar_type\ninstead of directly querying GET_MODE_SIZE (vinfo->vector_mode).\n\nint_mode_for_size is now the first check we do for a candidate mode,\nso it seemed better to restrict it to MAX_FIXED_MODE_SIZE.  This avoids\nunnecessary work and avoids trying to create scalar types that the\ntarget might not support.\n\n2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (can_duplicate_and_interleave_p): Take an\n\telement type rather than an element mode.\n\t* tree-vect-slp.c (can_duplicate_and_interleave_p): Likewise.\n\tUse get_vectype_for_scalar_type to query the natural types\n\tfor a given element type rather than basing everything on\n\tGET_MODE_SIZE (vinfo->vector_mode).  Limit int_mode_for_size\n\tquery to MAX_FIXED_MODE_SIZE.\n\t(duplicate_and_interleave): Update call accordingly.\n\t* tree-vect-loop.c (vectorizable_reduction): Likewise.\n\nFrom-SVN: r278335", "tree": {"sha": "ef31abcde95dea1776d82c4551525b79d39e9687", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef31abcde95dea1776d82c4551525b79d39e9687"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f884cd2fea62eebe71b422e1c97e550958dd42ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f884cd2fea62eebe71b422e1c97e550958dd42ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f884cd2fea62eebe71b422e1c97e550958dd42ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f884cd2fea62eebe71b422e1c97e550958dd42ae/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b75f56d4b7951c60a656396dddd4a65787b95bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b75f56d4b7951c60a656396dddd4a65787b95bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b75f56d4b7951c60a656396dddd4a65787b95bc"}], "stats": {"total": 51, "additions": 36, "deletions": 15}, "files": [{"sha": "7d48dbc69a60392b6e0a0680194cf8934858c192", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f884cd2fea62eebe71b422e1c97e550958dd42ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f884cd2fea62eebe71b422e1c97e550958dd42ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f884cd2fea62eebe71b422e1c97e550958dd42ae", "patch": "@@ -1,3 +1,15 @@\n+2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (can_duplicate_and_interleave_p): Take an\n+\telement type rather than an element mode.\n+\t* tree-vect-slp.c (can_duplicate_and_interleave_p): Likewise.\n+\tUse get_vectype_for_scalar_type to query the natural types\n+\tfor a given element type rather than basing everything on\n+\tGET_MODE_SIZE (vinfo->vector_mode).  Limit int_mode_for_size\n+\tquery to MAX_FIXED_MODE_SIZE.\n+\t(duplicate_and_interleave): Update call accordingly.\n+\t* tree-vect-loop.c (vectorizable_reduction): Likewise.\n+\n 2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (vect_get_vector_types_for_stmt): Take an"}, {"sha": "37290fa475dad8950fd314f67c818633bc18d20d", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f884cd2fea62eebe71b422e1c97e550958dd42ae/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f884cd2fea62eebe71b422e1c97e550958dd42ae/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=f884cd2fea62eebe71b422e1c97e550958dd42ae", "patch": "@@ -6365,10 +6365,9 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n \t that value needs to be repeated for every instance of the\n \t statement within the initial vector.  */\n       unsigned int group_size = SLP_INSTANCE_GROUP_SIZE (slp_node_instance);\n-      scalar_mode elt_mode = SCALAR_TYPE_MODE (TREE_TYPE (vectype_out));\n       if (!neutral_op\n \t  && !can_duplicate_and_interleave_p (loop_vinfo, group_size,\n-\t\t\t\t\t      elt_mode))\n+\t\t\t\t\t      TREE_TYPE (vectype_out)))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,"}, {"sha": "50f317fc63780531e1def25b14f0de95df100e22", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f884cd2fea62eebe71b422e1c97e550958dd42ae/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f884cd2fea62eebe71b422e1c97e550958dd42ae/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=f884cd2fea62eebe71b422e1c97e550958dd42ae", "patch": "@@ -264,34 +264,45 @@ vect_get_place_in_interleaving_chain (stmt_vec_info stmt_info,\n   return -1;\n }\n \n-/* Check whether it is possible to load COUNT elements of type ELT_MODE\n+/* Check whether it is possible to load COUNT elements of type ELT_TYPE\n    using the method implemented by duplicate_and_interleave.  Return true\n    if so, returning the number of intermediate vectors in *NVECTORS_OUT\n    (if nonnull) and the type of each intermediate vector in *VECTOR_TYPE_OUT\n    (if nonnull).  */\n \n bool\n can_duplicate_and_interleave_p (vec_info *vinfo, unsigned int count,\n-\t\t\t\tmachine_mode elt_mode,\n-\t\t\t\tunsigned int *nvectors_out,\n+\t\t\t\ttree elt_type, unsigned int *nvectors_out,\n \t\t\t\ttree *vector_type_out,\n \t\t\t\ttree *permutes)\n {\n-  poly_int64 elt_bytes = count * GET_MODE_SIZE (elt_mode);\n-  poly_int64 nelts;\n+  tree base_vector_type = get_vectype_for_scalar_type (vinfo, elt_type, count);\n+  if (!base_vector_type || !VECTOR_MODE_P (TYPE_MODE (base_vector_type)))\n+    return false;\n+\n+  machine_mode base_vector_mode = TYPE_MODE (base_vector_type);\n+  poly_int64 elt_bytes = count * GET_MODE_UNIT_SIZE (base_vector_mode);\n   unsigned int nvectors = 1;\n   for (;;)\n     {\n       scalar_int_mode int_mode;\n       poly_int64 elt_bits = elt_bytes * BITS_PER_UNIT;\n-      if (multiple_p (GET_MODE_SIZE (vinfo->vector_mode), elt_bytes, &nelts)\n-\t  && int_mode_for_size (elt_bits, 0).exists (&int_mode))\n+      if (int_mode_for_size (elt_bits, 1).exists (&int_mode))\n \t{\n+\t  /* Get the natural vector type for this SLP group size.  */\n \t  tree int_type = build_nonstandard_integer_type\n \t    (GET_MODE_BITSIZE (int_mode), 1);\n-\t  tree vector_type = build_vector_type (int_type, nelts);\n-\t  if (VECTOR_MODE_P (TYPE_MODE (vector_type)))\n+\t  tree vector_type\n+\t    = get_vectype_for_scalar_type (vinfo, int_type, count);\n+\t  if (vector_type\n+\t      && VECTOR_MODE_P (TYPE_MODE (vector_type))\n+\t      && known_eq (GET_MODE_SIZE (TYPE_MODE (vector_type)),\n+\t\t\t   GET_MODE_SIZE (base_vector_mode)))\n \t    {\n+\t      /* Try fusing consecutive sequences of COUNT / NVECTORS elements\n+\t\t together into elements of type INT_TYPE and using the result\n+\t\t to build NVECTORS vectors.  */\n+\t      poly_uint64 nelts = GET_MODE_NUNITS (TYPE_MODE (vector_type));\n \t      vec_perm_builder sel1 (nelts, 2, 3);\n \t      vec_perm_builder sel2 (nelts, 2, 3);\n \t      poly_int64 half_nelts = exact_div (nelts, 2);\n@@ -491,7 +502,7 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \t      && !GET_MODE_SIZE (vinfo->vector_mode).is_constant ()\n \t      && (TREE_CODE (type) == BOOLEAN_TYPE\n \t\t  || !can_duplicate_and_interleave_p (vinfo, stmts.length (),\n-\t\t\t\t\t\t      TYPE_MODE (type))))\n+\t\t\t\t\t\t      type)))\n \t    {\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -3552,7 +3563,7 @@ duplicate_and_interleave (vec_info *vinfo, gimple_seq *seq, tree vector_type,\n   unsigned int nvectors = 1;\n   tree new_vector_type;\n   tree permutes[2];\n-  if (!can_duplicate_and_interleave_p (vinfo, nelts, TYPE_MODE (element_type),\n+  if (!can_duplicate_and_interleave_p (vinfo, nelts, element_type,\n \t\t\t\t       &nvectors, &new_vector_type,\n \t\t\t\t       permutes))\n     gcc_unreachable ();"}, {"sha": "fd88084554d811f7da7e56dcb3db2e7ffe89d24c", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f884cd2fea62eebe71b422e1c97e550958dd42ae/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f884cd2fea62eebe71b422e1c97e550958dd42ae/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f884cd2fea62eebe71b422e1c97e550958dd42ae", "patch": "@@ -1795,8 +1795,7 @@ extern void vect_get_slp_defs (slp_tree, vec<vec<tree> > *, unsigned n = -1U);\n extern bool vect_slp_bb (basic_block);\n extern stmt_vec_info vect_find_last_scalar_stmt_in_slp (slp_tree);\n extern bool is_simple_and_all_uses_invariant (stmt_vec_info, loop_vec_info);\n-extern bool can_duplicate_and_interleave_p (vec_info *, unsigned int,\n-\t\t\t\t\t    machine_mode,\n+extern bool can_duplicate_and_interleave_p (vec_info *, unsigned int, tree,\n \t\t\t\t\t    unsigned int * = NULL,\n \t\t\t\t\t    tree * = NULL, tree * = NULL);\n extern void duplicate_and_interleave (vec_info *, gimple_seq *, tree,"}]}