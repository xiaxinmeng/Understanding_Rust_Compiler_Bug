{"sha": "8677664e02258772068ad1fe4672943c998bace8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY3NzY2NGUwMjI1ODc3MjA2OGFkMWZlNDY3Mjk0M2M5OThiYWNlOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-06-11T16:59:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-06-11T16:59:17Z"}, "message": "common.md: New file.\n\ngcc/\n\t* common.md: New file.\n\t* doc/md.texi: Update description of generic, machine-independent\n\tconstraints.\n\t* config/s390/constraints.md (e): Delete.\n\t* Makefile.in (md_file): Include common.md.\n\t* config/m32c/t-m32c (md_file): Likewise.\n\t* genpreds.c (general_mem): New array.\n\t(generic_constraint_letters): Remove constraints now defined by\n\tcommon.md.\n\t(add_constraint): Map TARGET_MEM_CONSTRAINT to general_mem.\n\tAllow the first character to be '<' or '>' as well.\n\t* genoutput.c (general_mem): New array.\n\t(indep_constraints): Remove constraints now defined by common.md.\n\t(note_constraint): Map TARGET_MEM_CONSTRAINT to general_mem.\n\tRemove special handling of 'm'.\n\t* ira-costs.c (record_reg_classes): Remove special handling of\n\tconstraints now defined by common.md.\n\t* ira.c (ira_setup_alts, ira_get_dup_out_num): Likewise.\n\t* ira-lives.c (single_reg_class): Likewise.\n\t(ira_implicitly_set_insn_hard_regs): Likewise.\n\t* lra-constraints.c (reg_class_from_constraints): Likewise.\n\t(process_alt_operands, process_address, curr_insn_transform): Likewise.\n\t* postreload.c (reload_cse_simplify_operands): Likewise.\n\t* reload.c (push_secondary_reload, scratch_reload_class)\n\t(find_reloads, alternative_allows_const_pool_ref): Likewise.\n\t* reload1.c (maybe_fix_stack_asms): Likewise.\n\t* targhooks.c (default_secondary_reload): Likewise.\n\t* stmt.c (parse_output_constraint): Likewise.\n\t* recog.c (preprocess_constraints): Likewise.\n\t(constrain_operands, peep2_find_free_register): Likewise.\n\t(asm_operand_ok): Likewise, but add a comment saying why 'o'\n\tmust be handled specially.\n\nFrom-SVN: r211475", "tree": {"sha": "ebbbc6a5c16fb2f71c030dc719d566bd7b2d0538", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebbbc6a5c16fb2f71c030dc719d566bd7b2d0538"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8677664e02258772068ad1fe4672943c998bace8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8677664e02258772068ad1fe4672943c998bace8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8677664e02258772068ad1fe4672943c998bace8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8677664e02258772068ad1fe4672943c998bace8/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7fd308cffa3775f62d69b63bc9b1cefced10d817", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fd308cffa3775f62d69b63bc9b1cefced10d817", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fd308cffa3775f62d69b63bc9b1cefced10d817"}], "stats": {"total": 906, "additions": 209, "deletions": 697}, "files": [{"sha": "b07492d7fbdf7939769e4c9700326087e1e9abe9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -1,3 +1,38 @@\n+2014-06-11  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* common.md: New file.\n+\t* doc/md.texi: Update description of generic, machine-independent\n+\tconstraints.\n+\t* config/s390/constraints.md (e): Delete.\n+\t* Makefile.in (md_file): Include common.md.\n+\t* config/m32c/t-m32c (md_file): Likewise.\n+\t* genpreds.c (general_mem): New array.\n+\t(generic_constraint_letters): Remove constraints now defined by\n+\tcommon.md.\n+\t(add_constraint): Map TARGET_MEM_CONSTRAINT to general_mem.\n+\tAllow the first character to be '<' or '>' as well.\n+\t* genoutput.c (general_mem): New array.\n+\t(indep_constraints): Remove constraints now defined by common.md.\n+\t(note_constraint): Map TARGET_MEM_CONSTRAINT to general_mem.\n+\tRemove special handling of 'm'.\n+\t* ira-costs.c (record_reg_classes): Remove special handling of\n+\tconstraints now defined by common.md.\n+\t* ira.c (ira_setup_alts, ira_get_dup_out_num): Likewise.\n+\t* ira-lives.c (single_reg_class): Likewise.\n+\t(ira_implicitly_set_insn_hard_regs): Likewise.\n+\t* lra-constraints.c (reg_class_from_constraints): Likewise.\n+\t(process_alt_operands, process_address, curr_insn_transform): Likewise.\n+\t* postreload.c (reload_cse_simplify_operands): Likewise.\n+\t* reload.c (push_secondary_reload, scratch_reload_class)\n+\t(find_reloads, alternative_allows_const_pool_ref): Likewise.\n+\t* reload1.c (maybe_fix_stack_asms): Likewise.\n+\t* targhooks.c (default_secondary_reload): Likewise.\n+\t* stmt.c (parse_output_constraint): Likewise.\n+\t* recog.c (preprocess_constraints): Likewise.\n+\t(constrain_operands, peep2_find_free_register): Likewise.\n+\t(asm_operand_ok): Likewise, but add a comment saying why 'o'\n+\tmust be handled specially.\n+\n 2014-06-11  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* system.h (CONST_DOUBLE_OK_FOR_CONSTRAINT_P): Poison."}, {"sha": "5587b75d62a39d6fe43d41c56947c92dec9d5ff9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -491,7 +491,7 @@ out_file=$(srcdir)/config/@out_file@\n out_object_file=@out_object_file@\n common_out_file=$(srcdir)/common/config/@common_out_file@\n common_out_object_file=@common_out_object_file@\n-md_file=$(srcdir)/config/@md_file@\n+md_file=$(srcdir)/common.md $(srcdir)/config/@md_file@\n tm_file_list=@tm_file_list@\n tm_include_list=@tm_include_list@\n tm_defines=@tm_defines@"}, {"sha": "23abea154cbb707167af4c4e1cbbda3683856bc5", "filename": "gcc/common.md", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fcommon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fcommon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.md?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -0,0 +1,95 @@\n+;; Common GCC machine description file, shared by all targets.\n+;; Copyright (C) 2014 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  */\n+\n+(define_register_constraint \"r\" \"GENERAL_REGS\"\n+  \"Matches any general register.\")\n+\n+(define_memory_constraint \"TARGET_MEM_CONSTRAINT\"\n+  \"Matches any valid memory.\"\n+  (and (match_code \"mem\")\n+       (match_test \"memory_address_addr_space_p (GET_MODE (op), XEXP (op, 0),\n+\t\t\t\t\t\t MEM_ADDR_SPACE (op))\")))\n+\n+(define_memory_constraint \"o\"\n+  \"Matches an offsettable memory reference.\"\n+  (and (match_code \"mem\")\n+       (match_test \"offsettable_nonstrict_memref_p (op)\")))\n+\n+;; \"V\" matches TARGET_MEM_CONSTRAINTs that are rejected by \"o\".\n+;; This means that it is not a memory constraint in the usual sense,\n+;; since reloading the address into a base register would make the\n+;; address offsettable.\n+(define_constraint \"V\"\n+  \"Matches a non-offsettable memory reference.\"\n+  (and (match_code \"mem\")\n+       (match_test \"memory_address_addr_space_p (GET_MODE (op), XEXP (op, 0),\n+\t\t\t\t\t\t MEM_ADDR_SPACE (op))\")\n+       (not (match_test \"offsettable_nonstrict_memref_p (op)\"))))\n+\n+;; Like \"V\", this is not a memory constraint, since reloading the address\n+;; into a base register would cause it not to match.\n+(define_constraint \"<\"\n+  \"Matches a pre-dec or post-dec operand.\"\n+  (and (match_code \"mem\")\n+       (ior (match_test \"GET_CODE (XEXP (op, 0)) == PRE_DEC\")\n+       \t    (match_test \"GET_CODE (XEXP (op, 0)) == POST_DEC\"))))\n+\n+;; See the comment for \"<\".\n+(define_constraint \">\"\n+  \"Matches a pre-inc or post-inc operand.\"\n+  (and (match_code \"mem\")\n+       (ior (match_test \"GET_CODE (XEXP (op, 0)) == PRE_INC\")\n+       \t    (match_test \"GET_CODE (XEXP (op, 0)) == POST_INC\"))))\n+\n+(define_address_constraint \"p\"\n+  \"Matches a general address.\"\n+  (match_test \"address_operand (op, VOIDmode)\"))\n+\n+(define_constraint \"i\"\n+  \"Matches a general integer constant.\"\n+  (and (match_test \"CONSTANT_P (op)\")\n+       (match_test \"!flag_pic || LEGITIMATE_PIC_OPERAND_P (op)\")))\n+\n+(define_constraint \"s\"\n+  \"Matches a symbolic integer constant.\"\n+  (and (match_test \"CONSTANT_P (op)\")\n+       (match_test \"!CONST_SCALAR_INT_P (op)\")\n+       (match_test \"!flag_pic || LEGITIMATE_PIC_OPERAND_P (op)\")))\n+\n+(define_constraint \"n\"\n+  \"Matches a non-symbolic integer constant.\"\n+  (and (match_test \"CONST_SCALAR_INT_P (op)\")\n+       (match_test \"!flag_pic || LEGITIMATE_PIC_OPERAND_P (op)\")))\n+\n+(define_constraint \"E\"\n+  \"Matches a floating-point constant.\"\n+  (ior (match_test \"CONST_DOUBLE_AS_FLOAT_P (op)\")\n+       (match_test \"GET_CODE (op) == CONST_VECTOR\n+\t\t    && GET_MODE_CLASS (GET_MODE (op)) == MODE_VECTOR_FLOAT\")))\n+\n+;; There is no longer a distinction between \"E\" and \"F\".\n+(define_constraint \"F\"\n+  \"Matches a floating-point constant.\"\n+  (ior (match_test \"CONST_DOUBLE_AS_FLOAT_P (op)\")\n+       (match_test \"GET_CODE (op) == CONST_VECTOR\n+\t\t    && GET_MODE_CLASS (GET_MODE (op)) == MODE_VECTOR_FLOAT\")))\n+\n+(define_constraint \"X\"\n+  \"Matches anything.\"\n+  (match_test \"true\"))"}, {"sha": "00162e9a89aa4303a7cf5fb2fe9d46335a7d283b", "filename": "gcc/config/m32c/t-m32c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fconfig%2Fm32c%2Ft-m32c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fconfig%2Fm32c%2Ft-m32c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Ft-m32c?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -20,7 +20,7 @@\n \n # target-specific files\n \n-md_file = md\n+md_file = $(srcdir)/common.md md\n \n MD_FILES = m32c constraints predicates addsub bitops blkmov cond jump minmax mov muldiv prologue shift\n "}, {"sha": "6af3dc80e8bf2a2e6c4767d01de1da6c8698e602", "filename": "gcc/config/s390/constraints.md", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fconfig%2Fs390%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fconfig%2Fs390%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fconstraints.md?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -406,14 +406,6 @@\n                && s390_check_symref_alignment (XEXP (op, 0),\n                                                GET_MODE_SIZE (GET_MODE (op)))\"))\n \n-(define_memory_constraint \"e\"\n-  \"Matches all memory references available on the current architecture\n-level.  This constraint will never be used and using it in an inline\n-assembly is *always* a bug since there is no instruction accepting all\n-those addresses.  It just serves as a placeholder for a generic memory\n-constraint.\"\n-  (match_test \"strict_memory_address_p (GET_MODE (op), op)\"))\n-\n ; This defines 'm' as normal memory constraint.  This is only possible\n ; since the standard memory constraint is re-defined in s390.h using\n ; the TARGET_MEM_CONSTRAINT macro."}, {"sha": "e17ffca01af6f390437a51d77f4293dfee524a89", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -4355,16 +4355,8 @@ Use this for constraints that should not appear in @code{asm} statements.\n It is occasionally useful to test a constraint from C code rather than\n implicitly via the constraint string in a @code{match_operand}.  The\n generated file @file{tm_p.h} declares a few interfaces for working\n-with machine-specific constraints.  None of these interfaces work with\n-the generic constraints described in @ref{Simple Constraints}.  This\n-may change in the future.\n-\n-@strong{Warning:} @file{tm_p.h} may declare other functions that\n-operate on constraints, besides the ones documented here.  Do not use\n-those functions from machine-dependent code.  They exist to implement\n-the old constraint interface that machine-independent components of\n-the compiler still expect.  They will change or disappear in the\n-future.\n+with constraints.  At present these are defined for all constraints\n+except @code{g} (which is equivalent to @code{general_operand}).\n \n Some valid constraint names are not valid C identifiers, so there is a\n mangling scheme for referring to them from C@.  Constraint names that\n@@ -4391,17 +4383,14 @@ the variable @var{m} is a mangled constraint name (usually as part of\n a larger identifier).\n \n @deftp Enum constraint_num\n-For each machine-specific constraint, there is a corresponding\n+For each constraint except @code{g}, there is a corresponding\n enumeration constant: @samp{CONSTRAINT_} plus the mangled name of the\n constraint.  Functions that take an @code{enum constraint_num} as an\n argument expect one of these constants.\n-\n-Machine-independent constraints do not have associated constants.\n-This may change in the future.\n @end deftp\n \n @deftypefun {inline bool} satisfies_constraint_@var{m} (rtx @var{exp})\n-For each machine-specific, non-register constraint @var{m}, there is\n+For each non-register constraint @var{m} except @code{g}, there is\n one of these functions; it returns @code{true} if @var{exp} satisfies the\n constraint.  These functions are only visible if @file{rtl.h} was included\n before @file{tm_p.h}."}, {"sha": "7489d383bbcb8071e4e0298d4bb383e0bdb78cfc", "filename": "gcc/genoutput.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -98,6 +98,8 @@ along with GCC; see the file COPYING3.  If not see\n \n #define MAX_MAX_OPERANDS 40\n \n+static char general_mem[] = { TARGET_MEM_CONSTRAINT, 0 };\n+\n static int n_occurrences\t\t(int, const char *);\n static const char *strip_whitespace\t(const char *);\n \n@@ -205,10 +207,9 @@ struct constraint_data\n   const char name[1];\n };\n \n-/* This is a complete list (unlike the one in genpreds.c) of constraint\n-   letters and modifiers with machine-independent meaning.  The only\n-   omission is digits, as these are handled specially.  */\n-static const char indep_constraints[] = \",=+%*?!#&<>EFVXgimnoprs\";\n+/* All machine-independent constraint characters (except digits) that\n+   are handled outside the define*_constraint mechanism.  */\n+static const char indep_constraints[] = \",=+%*?!#&g\";\n \n static struct constraint_data *\n constraints_by_letter_table[1 << CHAR_BIT];\n@@ -1151,13 +1152,13 @@ static void\n note_constraint (rtx exp, int lineno)\n {\n   const char *name = XSTR (exp, 0);\n-  unsigned int namelen = strlen (name);\n   struct constraint_data **iter, **slot, *new_cdata;\n \n-  /* The 'm' constraint is special here since that constraint letter\n-     can be overridden by the back end by defining the\n-     TARGET_MEM_CONSTRAINT macro.  */\n-  if (strchr (indep_constraints, name[0]) && name[0] != 'm')\n+  if (strcmp (name, \"TARGET_MEM_CONSTRAINT\") == 0)\n+    name = general_mem;\n+  unsigned int namelen = strlen (name);\n+\n+  if (strchr (indep_constraints, name[0]))\n     {\n       if (name[1] == '\\0')\n \terror_with_line (lineno, \"constraint letter '%s' cannot be \""}, {"sha": "b14a4ac104b331fb4688716b45cda63f2b04c045", "filename": "gcc/genpreds.c", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -30,6 +30,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"read-md.h\"\n #include \"gensupport.h\"\n \n+static char general_mem[] = { TARGET_MEM_CONSTRAINT, 0 };\n+\n /* Given a predicate expression EXP, from form NAME at line LINENO,\n    verify that it does not contain any RTL constructs which are not\n    valid in predicate definitions.  Returns true if EXP is\n@@ -659,12 +661,9 @@ static struct constraint_data **last_constraint_ptr = &first_constraint;\n #define FOR_ALL_CONSTRAINTS(iter_) \\\n   for (iter_ = first_constraint; iter_; iter_ = iter_->next_textual)\n \n-/* These letters, and all names beginning with them, are reserved for\n-   generic constraints.\n-   The 'm' constraint is not mentioned here since that constraint\n-   letter can be overridden by the back end by defining the\n-   TARGET_MEM_CONSTRAINT macro.  */\n-static const char generic_constraint_letters[] = \"EFVXginoprs\";\n+/* Contraint letters that have a special meaning and that cannot be used\n+   in define*_constraints.  */\n+static const char generic_constraint_letters[] = \"g\";\n \n /* Machine-independent code expects that constraints with these\n    (initial) letters will allow only (a subset of all) CONST_INTs.  */\n@@ -735,19 +734,12 @@ add_constraint (const char *name, const char *regclass,\n   bool is_const_dbl;\n   size_t namelen;\n \n+  if (strcmp (name, \"TARGET_MEM_CONSTRAINT\") == 0)\n+    name = general_mem;\n+\n   if (exp && validate_exp (exp, name, lineno))\n     return;\n \n-  if (!ISALPHA (name[0]) && name[0] != '_')\n-    {\n-      if (name[1] == '\\0')\n-\terror_with_line (lineno, \"constraint name '%s' is not \"\n-\t\t\t \"a letter or underscore\", name);\n-      else\n-\terror_with_line (lineno, \"constraint name '%s' does not begin \"\n-\t\t\t \"with a letter or underscore\", name);\n-      return;\n-    }\n   for (p = name; *p; p++)\n     if (!ISALNUM (*p))\n       {"}, {"sha": "5716c2a22d95368910c1583789ff42b3943834e3", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -645,81 +645,13 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t    {\n \t      switch (c)\n \t\t{\n-\t\tcase ',':\n-\t\t  break;\n \t\tcase '*':\n \t\t  /* Ignore the next letter for this pass.  */\n \t\t  c = *++p;\n \t\t  break;\n \n \t\tcase '?':\n \t\t  alt_cost += 2;\n-\t\tcase '!':  case '#':  case '&':\n-\t\tcase '0':  case '1':  case '2':  case '3':  case '4':\n-\t\tcase '5':  case '6':  case '7':  case '8':  case '9':\n-\t\t  break;\n-\n-\t\tcase 'p':\n-\t\t  allows_addr = 1;\n-\t\t  win = address_operand (op, GET_MODE (op));\n-\t\t  /* We know this operand is an address, so we want it\n-\t\t     to be allocated to a register that can be the\n-\t\t     base of an address, i.e. BASE_REG_CLASS.  */\n-\t\t  classes[i]\n-\t\t    = ira_reg_class_subunion[classes[i]]\n-\t\t      [base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n-\t\t\t\t       ADDRESS, SCRATCH)];\n-\t\t  break;\n-\n-\t\tcase 'm':  case 'o':  case 'V':\n-\t\t  /* It doesn't seem worth distinguishing between\n-\t\t     offsettable and non-offsettable addresses\n-\t\t     here.  */\n-\t\t  insn_allows_mem[i] = allows_mem[i] = 1;\n-\t\t  if (MEM_P (op))\n-\t\t    win = 1;\n-\t\t  break;\n-\n-\t\tcase '<':\n-\t\t  if (MEM_P (op)\n-\t\t      && (GET_CODE (XEXP (op, 0)) == PRE_DEC\n-\t\t\t  || GET_CODE (XEXP (op, 0)) == POST_DEC))\n-\t\t    win = 1;\n-\t\t  break;\n-\n-\t\tcase '>':\n-\t\t  if (MEM_P (op)\n-\t\t      && (GET_CODE (XEXP (op, 0)) == PRE_INC\n-\t\t\t  || GET_CODE (XEXP (op, 0)) == POST_INC))\n-\t\t    win = 1;\n-\t\t  break;\n-\n-\t\tcase 'E':\n-\t\tcase 'F':\n-\t\t  if (CONST_DOUBLE_AS_FLOAT_P (op) \n-\t\t      || (GET_CODE (op) == CONST_VECTOR\n-\t\t\t  && (GET_MODE_CLASS (GET_MODE (op))\n-\t\t\t      == MODE_VECTOR_FLOAT)))\n-\t\t    win = 1;\n-\t\t  break;\n-\n-\t\tcase 's':\n-\t\t  if (CONST_SCALAR_INT_P (op)) \n-\t\t    break;\n-\n-\t\tcase 'i':\n-\t\t  if (CONSTANT_P (op)\n-\t\t      && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op)))\n-\t\t    win = 1;\n-\t\t  break;\n-\n-\t\tcase 'n':\n-\t\t  if (CONST_SCALAR_INT_P (op)) \n-\t\t    win = 1;\n-\t\t  break;\n-\n-\t\tcase 'X':\n-\t\t  win = 1;\n \t\t  break;\n \n \t\tcase 'g':\n@@ -728,7 +660,6 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t\t  && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op))))\n \t\t    win = 1;\n \t\t  insn_allows_mem[i] = allows_mem[i] = 1;\n-\t\tcase 'r':\n \t\t  classes[i] = ira_reg_class_subunion[classes[i]][GENERAL_REGS];\n \t\t  break;\n "}, {"sha": "601613bc995543ed9bfd6c5e035671f066d72262", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 15, "deletions": 82, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -771,60 +771,10 @@ single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n     else if (enabled & 1)\n       switch (c)\n \t{\n-\tcase ' ':\n-\tcase '\\t':\n-\tcase '=':\n-\tcase '+':\n-\tcase '*':\n-\tcase '&':\n-\tcase '%':\n-\tcase '!':\n-\tcase '?':\n-\t  break;\n-\tcase 'i':\n-\t  if (CONSTANT_P (op)\n-\t      || (equiv_const != NULL_RTX && CONSTANT_P (equiv_const)))\n-\t    return NO_REGS;\n-\t  break;\n-\n-\tcase 'n':\n-\t  if (CONST_SCALAR_INT_P (op)\n-\t      || (equiv_const != NULL_RTX && CONST_SCALAR_INT_P (equiv_const)))\n-\t    return NO_REGS;\n-\t  break;\n-\n-\tcase 's':\n-\t  if ((CONSTANT_P (op) && !CONST_SCALAR_INT_P (op))\n-\t      || (equiv_const != NULL_RTX\n-\t\t  && CONSTANT_P (equiv_const)\n-\t\t  && !CONST_SCALAR_INT_P (equiv_const)))\n-\t    return NO_REGS;\n-\t  break;\n-\n-\tcase 'E':\n-\tcase 'F':\n-\t  if (CONST_DOUBLE_AS_FLOAT_P (op) \n-\t      || (GET_CODE (op) == CONST_VECTOR\n-\t\t  && GET_MODE_CLASS (GET_MODE (op)) == MODE_VECTOR_FLOAT)\n-\t      || (equiv_const != NULL_RTX\n-\t\t  && (CONST_DOUBLE_AS_FLOAT_P (equiv_const)\n-\t\t      || (GET_CODE (equiv_const) == CONST_VECTOR\n-\t\t\t  && (GET_MODE_CLASS (GET_MODE (equiv_const))\n-\t\t\t      == MODE_VECTOR_FLOAT)))))\n-\t    return NO_REGS;\n-\t  break;\n+\tcase 'g':\n+\t  return NO_REGS;\n \n-\tcase 'I': case 'J': case 'K': case 'L': case 'M': case 'N':\n-\tcase 'O': case 'P':\n-\tcase 'G': case 'H':\n-\tcase 'r':\n-\tcase 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n-\tcase 'h': case 'j': case 'k': case 'l':\n-\tcase 'q': case 't': case 'u':\n-\tcase 'v': case 'w': case 'x': case 'y': case 'z':\n-\tcase 'A': case 'B': case 'C': case 'D':\n-\tcase 'Q': case 'R': case 'S': case 'T': case 'U':\n-\tcase 'W': case 'Y': case 'Z':\n+\tdefault:\n \t  /* ??? Is this the best way to handle memory constraints?  */\n \t  cn = lookup_constraint (constraints);\n \t  if (insn_extra_memory_constraint (cn)\n@@ -835,9 +785,7 @@ single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n \t\t  && CONSTANT_P (equiv_const)\n \t\t  && constraint_satisfied_p (equiv_const, cn)))\n \t    return NO_REGS;\n-\t  next_cl = (c == 'r'\n-\t\t     ? GENERAL_REGS\n-\t\t     : reg_class_for_constraint (cn));\n+\t  next_cl = reg_class_for_constraint (cn);\n \t  if (next_cl == NO_REGS)\n \t    break;\n \t  if (cl == NO_REGS\n@@ -860,9 +808,6 @@ single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n \t    return NO_REGS;\n \t  cl = next_cl;\n \t  break;\n-\n-\tdefault:\n-\t  return NO_REGS;\n \t}\n   return cl;\n }\n@@ -913,29 +858,17 @@ ira_implicitly_set_insn_hard_regs (HARD_REG_SET *set)\n \t    else if (c == ',')\n \t      enabled >>= 1;\n \t    else if (enabled & 1)\n-\t      switch (c)\n-\t\t{\n-\t\tcase 'r':\n-\t\tcase 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n-\t\tcase 'h': case 'j': case 'k': case 'l':\n-\t\tcase 'q': case 't': case 'u':\n-\t\tcase 'v': case 'w': case 'x': case 'y': case 'z':\n-\t\tcase 'A': case 'B': case 'C': case 'D':\n-\t\tcase 'Q': case 'R': case 'S': case 'T': case 'U':\n-\t\tcase 'W': case 'Y': case 'Z':\n-\t\t  cl = (c == 'r'\n-\t\t\t? GENERAL_REGS\n-\t\t\t: reg_class_for_constraint (lookup_constraint (p)));\n-\t\t  if (cl != NO_REGS)\n-\t\t    {\n-\t\t      /* There is no register pressure problem if all of the\n-\t\t\t regs in this class are fixed.  */\n-\t\t      int regno = ira_class_singleton[cl][mode];\n-\t\t      if (regno >= 0)\n-\t\t\tadd_to_hard_reg_set (set, mode, regno);\n-\t\t    }\n-\t\t  break;\n-\t\t}\n+\t      {\n+\t\tcl = reg_class_for_constraint (lookup_constraint (p));\n+\t\tif (cl != NO_REGS)\n+\t\t  {\n+\t\t    /* There is no register pressure problem if all of the\n+\t\t       regs in this class are fixed.  */\n+\t\t    int regno = ira_class_singleton[cl][mode];\n+\t\t    if (regno >= 0)\n+\t\t      add_to_hard_reg_set (set, mode, regno);\n+\t\t  }\n+\t      }\n \t}\n     }\n }"}, {"sha": "034c4cc8c2eea9d4ccb789ed558ad723d17efcb1", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 67, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -1835,9 +1835,6 @@ ira_setup_alts (rtx insn, HARD_REG_SET &alts)\n \t\t    len = 0;\n \t\t    break;\n \t\t  \n-\t\t  case '?':  case '!': case '*':  case '=':  case '+':\n-\t\t    break;\n-\t\t    \n \t\t  case '%':\n \t\t    /* We only support one commutative marker, the\n \t\t       first one.  We already set commutative\n@@ -1846,63 +1843,12 @@ ira_setup_alts (rtx insn, HARD_REG_SET &alts)\n \t\t      commutative = nop;\n \t\t    break;\n \n-\t\t  case '&':\n-\t\t    break;\n-\t\t    \n \t\t  case '0':  case '1':  case '2':  case '3':  case '4':\n \t\t  case '5':  case '6':  case '7':  case '8':  case '9':\n \t\t    goto op_success;\n \t\t    break;\n \t\t    \n-\t\t  case 'p':\n \t\t  case 'g':\n-\t\t  case 'X':\n-\t\t  case TARGET_MEM_CONSTRAINT:\n-\t\t    goto op_success;\n-\t\t    break;\n-\t\t    \n-\t\t  case '<':\n-\t\t    if (MEM_P (op)\n-\t\t\t&& (GET_CODE (XEXP (op, 0)) == PRE_DEC\n-\t\t\t    || GET_CODE (XEXP (op, 0)) == POST_DEC))\n-\t\t    goto op_success;\n-\t\t    break;\n-\t\t    \n-\t\t  case '>':\n-\t\t    if (MEM_P (op)\n-\t\t      && (GET_CODE (XEXP (op, 0)) == PRE_INC\n-\t\t\t  || GET_CODE (XEXP (op, 0)) == POST_INC))\n-\t\t      goto op_success;\n-\t\t    break;\n-\t\t    \n-\t\t  case 'E':\n-\t\t  case 'F':\n-\t\t    if (CONST_DOUBLE_AS_FLOAT_P (op)\n-\t\t\t|| (GET_CODE (op) == CONST_VECTOR\n-\t\t\t    && GET_MODE_CLASS (GET_MODE (op)) == MODE_VECTOR_FLOAT))\n-\t\t      goto op_success;\n-\t\t    break;\n-\t\t    \n-\t\t  case 's':\n-\t\t    if (CONST_SCALAR_INT_P (op))\n-\t\t      break;\n-\t\t  case 'i':\n-\t\t    if (CONSTANT_P (op))\n-\t\t      goto op_success;\n-\t\t    break;\n-\t\t    \n-\t\t  case 'n':\n-\t\t    if (CONST_SCALAR_INT_P (op))\n-\t\t      goto op_success;\n-\t\t    break;\n-\t\t    \n-\t\t  case 'V':\n-\t\t    if (MEM_P (op) && ! offsettable_memref_p (op))\n-\t\t      goto op_success;\n-\t\t    break;\n-\t\t    \n-\t\t  case 'o':\n-\t\t  case 'r':\n \t\t    goto op_success;\n \t\t    break;\n \t\t    \n@@ -1992,21 +1938,9 @@ ira_get_dup_out_num (int op_num, HARD_REG_SET &alts)\n \t  else if (! ignore_p)\n \t    switch (c)\n \t      {\n-\t      case 'X':\n-\t      case 'p':\n \t      case 'g':\n \t\tgoto fail;\n-\t      case 'r':\n-\t\tif (!targetm.class_likely_spilled_p (GENERAL_REGS))\n-\t\t  goto fail;\n-\t\tbreak;\n-\t      case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n-\t      case 'h': case 'j': case 'k': case 'l':\n-\t      case 'q': case 't': case 'u':\n-\t      case 'v': case 'w': case 'x': case 'y': case 'z':\n-\t      case 'A': case 'B': case 'C': case 'D':\n-\t      case 'Q': case 'R': case 'S': case 'T': case 'U':\n-\t      case 'W': case 'Y': case 'Z':\n+\t      default:\n \t\t{\n \t\t  enum constraint_num cn = lookup_constraint (str);\n \t\t  enum reg_class cl = reg_class_for_constraint (cn);"}, {"sha": "ab8fe3453c4582949c337550302d508eaaaab48d", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 2, "deletions": 116, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -968,14 +968,7 @@ reg_class_from_constraints (const char *p)\n       case ',':\n \treturn op_class;\n \n-      case 'p':\n-\top_class = (reg_class_subunion\n-\t\t    [op_class][base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n-\t\t\t\t\t       ADDRESS, SCRATCH)]);\n-\tbreak;\n-\n       case 'g':\n-      case 'r':\n \top_class = reg_class_subunion[op_class][GENERAL_REGS];\n \tbreak;\n \n@@ -1768,15 +1761,6 @@ process_alt_operands (int only_alternative)\n \t\t  c = '\\0';\n \t\t  break;\n \n-\t\tcase '=':  case '+': case '?': case '*': case '!':\n-\t\tcase ' ': case '\\t':\n-\t\t  break;\n-\n-\t\tcase '%':\n-\t\t  /* We only support one commutative marker, the first\n-\t\t     one.  We already set commutative above.  */\n-\t\t  break;\n-\n \t\tcase '&':\n \t\t  early_clobber_p = true;\n \t\t  break;\n@@ -1909,105 +1893,11 @@ process_alt_operands (int only_alternative)\n \t\t    break;\n \t\t  }\n \n-\t\tcase 'p':\n-\t\t  cl = base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n-\t\t\t\t       ADDRESS, SCRATCH);\n-\t\t  this_alternative = reg_class_subunion[this_alternative][cl];\n-\t\t  IOR_HARD_REG_SET (this_alternative_set,\n-\t\t\t\t    reg_class_contents[cl]);\n-\t\t  if (costly_p)\n-\t\t    {\n-\t\t      this_costly_alternative\n-\t\t\t= reg_class_subunion[this_costly_alternative][cl];\n-\t\t      IOR_HARD_REG_SET (this_costly_alternative_set,\n-\t\t\t\t\treg_class_contents[cl]);\n-\t\t    }\n-\t\t  win = true;\n-\t\t  badop = false;\n-\t\t  break;\n-\n-\t\tcase TARGET_MEM_CONSTRAINT:\n-\t\t  if (MEM_P (op) || spilled_pseudo_p (op))\n-\t\t    win = true;\n-\t\t  /* We can put constant or pseudo value into memory\n-\t\t     to satisfy the constraint.  */\n-\t\t  if (CONST_POOL_OK_P (mode, op) || REG_P (op))\n-\t\t    badop = false;\n-\t\t  constmemok = true;\n-\t\t  break;\n-\n-\t\tcase '<':\n-\t\t  if (MEM_P (op)\n-\t\t      && (GET_CODE (XEXP (op, 0)) == PRE_DEC\n-\t\t\t  || GET_CODE (XEXP (op, 0)) == POST_DEC))\n-\t\t    win = true;\n-\t\t  break;\n-\n-\t\tcase '>':\n-\t\t  if (MEM_P (op)\n-\t\t      && (GET_CODE (XEXP (op, 0)) == PRE_INC\n-\t\t\t  || GET_CODE (XEXP (op, 0)) == POST_INC))\n-\t\t    win = true;\n-\t\t  break;\n-\n-\t\t  /* Memory op whose address is not offsettable.  */\n-\t\tcase 'V':\n-\t\t  if (MEM_P (op)\n-\t\t      && ! offsettable_nonstrict_memref_p (op))\n-\t\t    win = true;\n-\t\t  break;\n-\n-\t\t  /* Memory operand whose address is offsettable.  */\n-\t\tcase 'o':\n-\t\t  if ((MEM_P (op)\n-\t\t       && offsettable_nonstrict_memref_p (op))\n-\t\t      || spilled_pseudo_p (op))\n-\t\t    win = true;\n-\t\t  /* We can put constant or pseudo value into memory\n-\t\t     or make memory address offsetable to satisfy the\n-\t\t     constraint.  */\n-\t\t  if (CONST_POOL_OK_P (mode, op) || MEM_P (op) || REG_P (op))\n-\t\t    badop = false;\n-\t\t  constmemok = true;\n-\t\t  offmemok = true;\n-\t\t  break;\n-\n-\t\tcase 'E':\n-\t\tcase 'F':\n-\t\t  if (GET_CODE (op) == CONST_DOUBLE\n-\t\t      || (GET_CODE (op) == CONST_VECTOR\n-\t\t\t  && (GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)))\n-\t\t    win = true;\n-\t\t  break;\n-\n-\t\tcase 's':\n-\t\t  if (CONST_SCALAR_INT_P (op))\n-\t\t    break;\n-\n-\t\tcase 'i':\n-\t\t  if (general_constant_p (op))\n-\t\t    win = true;\n-\t\t  break;\n-\n-\t\tcase 'n':\n-\t\t  if (CONST_SCALAR_INT_P (op))\n-\t\t    win = true;\n-\t\t  break;\n-\n-\t\tcase 'X':\n-\t\t  /* This constraint should be excluded by the fast\n-\t\t     track.  */\n-\t\t  gcc_unreachable ();\n-\t\t  break;\n-\n \t\tcase 'g':\n \t\t  if (MEM_P (op)\n \t\t      || general_constant_p (op)\n \t\t      || spilled_pseudo_p (op))\n \t\t    win = true;\n-\t\t  /* Drop through into 'r' case.  */\n-\n-\t\tcase 'r':\n \t\t  cl = GENERAL_REGS;\n \t\t  goto reg;\n \n@@ -2821,8 +2711,7 @@ process_address_1 (int nop, rtx *before, rtx *after)\n   enum constraint_num cn = lookup_constraint (constraint);\n   bool change_p;\n \n-  if (constraint[0] == 'p'\n-      || insn_extra_address_constraint (cn))\n+  if (insn_extra_address_constraint (cn))\n     decompose_lea_address (&ad, curr_id->operand_loc[nop]);\n   else if (MEM_P (op))\n     decompose_mem_address (&ad, op);\n@@ -2853,8 +2742,7 @@ process_address_1 (int nop, rtx *before, rtx *after)\n \n   /* Target hooks sometimes don't treat extra-constraint addresses as\n      legitimate address_operands, so handle them specially.  */\n-  if (constraint[0] != 'p'\n-      && insn_extra_address_constraint (cn)\n+  if (insn_extra_address_constraint (cn)\n       && satisfies_address_constraint_p (&ad, cn))\n     return change_p;\n \n@@ -3576,8 +3464,6 @@ curr_insn_transform (void)\n \t\t (c = *constraint) && c != ',' && c != '#';\n \t\t constraint += CONSTRAINT_LEN (c, constraint))\n \t      {\n-\t\tif (c == TARGET_MEM_CONSTRAINT || c == 'o')\n-\t\t  break;\n \t\tenum constraint_num cn = lookup_constraint (constraint);\n \t\tif (insn_extra_memory_constraint (cn)\n \t\t    && satisfies_memory_constraint_p (tem, cn))"}, {"sha": "9d716498be48462d410cbe0ade87b78a833b8420", "filename": "gcc/postreload.c", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -553,22 +553,8 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \n \t      switch (c)\n \t\t{\n-\t\tcase '=':  case '+':  case '?':\n-\t\tcase '#':  case '&':  case '!':\n-\t\tcase '*':  case '%':\n-\t\tcase '0':  case '1':  case '2':  case '3':  case '4':\n-\t\tcase '5':  case '6':  case '7':  case '8':  case '9':\n-\t\tcase '<':  case '>':  case 'V':  case 'o':\n-\t\tcase 'E':  case 'F':  case 'G':  case 'H':\n-\t\tcase 's':  case 'i':  case 'n':\n-\t\tcase 'I':  case 'J':  case 'K':  case 'L':\n-\t\tcase 'M':  case 'N':  case 'O':  case 'P':\n-\t\tcase 'p':  case 'X':  case TARGET_MEM_CONSTRAINT:\n-\t\t  /* These don't say anything we care about.  */\n-\t\t  break;\n-\n-\t\tcase 'g': case 'r':\n-\t\t  rclass = reg_class_subunion[(int) rclass][(int) GENERAL_REGS];\n+\t\tcase 'g':\n+\t\t  rclass = reg_class_subunion[rclass][GENERAL_REGS];\n \t\t  break;\n \n \t\tdefault:"}, {"sha": "8d10a4f4112fb678484b9f3965028a95db8c29a9", "filename": "gcc/recog.c", "status": "modified", "additions": 27, "deletions": 207, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -1737,15 +1737,6 @@ asm_operand_ok (rtx op, const char *constraint, const char **constraints)\n \tcase ',':\n \t  constraint++;\n \t  continue;\n-\tcase '=':\n-\tcase '+':\n-\tcase '*':\n-\tcase '%':\n-\tcase '!':\n-\tcase '#':\n-\tcase '&':\n-\tcase '?':\n-\t  break;\n \n \tcase '0': case '1': case '2': case '3': case '4':\n \tcase '5': case '6': case '7': case '8': case '9':\n@@ -1774,98 +1765,47 @@ asm_operand_ok (rtx op, const char *constraint, const char **constraints)\n \t    }\n \t  continue;\n \n-\tcase 'p':\n-\t  if (address_operand (op, VOIDmode))\n-\t    result = 1;\n-\t  break;\n-\n-\tcase TARGET_MEM_CONSTRAINT:\n-\tcase 'V': /* non-offsettable */\n-\t  if (memory_operand (op, VOIDmode))\n-\t    result = 1;\n-\t  break;\n+\t  /* The rest of the compiler assumes that reloading the address\n+\t     of a MEM into a register will make it fit an 'o' constraint.\n+\t     That is, if it sees a MEM operand for an 'o' constraint,\n+\t     it assumes that (mem (base-reg)) will fit.\n \n+\t     That assumption fails on targets that don't have offsettable\n+\t     addresses at all.  We therefore need to treat 'o' asm\n+\t     constraints as a special case and only accept operands that\n+\t     are already offsettable, thus proving that at least one\n+\t     offsettable address exists.  */\n \tcase 'o': /* offsettable */\n \t  if (offsettable_nonstrict_memref_p (op))\n \t    result = 1;\n \t  break;\n \n-\tcase '<':\n-\t  /* ??? Before auto-inc-dec, auto inc/dec insns are not supposed to exist,\n-\t     excepting those that expand_call created.  Further, on some\n-\t     machines which do not have generalized auto inc/dec, an inc/dec\n-\t     is not a memory_operand.\n-\n-\t     Match any memory and hope things are resolved after reload.  */\n-\n-\t  if (MEM_P (op)\n-\t      && (1\n-\t\t  || GET_CODE (XEXP (op, 0)) == PRE_DEC\n-\t\t  || GET_CODE (XEXP (op, 0)) == POST_DEC))\n-\t    result = 1;\n-#ifdef AUTO_INC_DEC\n-\t  incdec_ok = true;\n-#endif\n-\t  break;\n-\n-\tcase '>':\n-\t  if (MEM_P (op)\n-\t      && (1\n-\t\t  || GET_CODE (XEXP (op, 0)) == PRE_INC\n-\t\t  || GET_CODE (XEXP (op, 0)) == POST_INC))\n-\t    result = 1;\n-#ifdef AUTO_INC_DEC\n-\t  incdec_ok = true;\n-#endif\n-\t  break;\n-\n-\tcase 'E':\n-\tcase 'F':\n-\t  if (CONST_DOUBLE_AS_FLOAT_P (op) \n-\t      || (GET_CODE (op) == CONST_VECTOR\n-\t\t  && GET_MODE_CLASS (GET_MODE (op)) == MODE_VECTOR_FLOAT))\n-\t    result = 1;\n-\t  break;\n-\n-\tcase 's':\n-\t  if (CONST_SCALAR_INT_P (op))\n-\t    break;\n-\t  /* Fall through.  */\n-\n-\tcase 'i':\n-\t  if (CONSTANT_P (op) && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op)))\n-\t    result = 1;\n-\t  break;\n-\n-\tcase 'n':\n-\t  if (CONST_SCALAR_INT_P (op))\n-\t    result = 1;\n-\t  break;\n-\n-\tcase 'X':\n-\t  result = 1;\n-\t  break;\n-\n \tcase 'g':\n \t  if (general_operand (op, VOIDmode))\n \t    result = 1;\n \t  break;\n \n-\tcase 'r':\n-\treg:\n-\t  if (!result\n-\t      && GET_MODE (op) != BLKmode\n-\t      && register_operand (op, VOIDmode))\n-\t    result = 1;\n-\t  break;\n+#ifdef AUTO_INC_DEC\n+\tcase '<':\n+\tcase '>':\n+\t  /* ??? Before auto-inc-dec, auto inc/dec insns are not supposed\n+\t     to exist, excepting those that expand_call created.  Further,\n+\t     on some machines which do not have generalized auto inc/dec,\n+\t     an inc/dec is not a memory_operand.\n \n+\t     Match any memory and hope things are resolved after reload.  */\n+\t  incdec_ok = true;\n+#endif\n \tdefault:\n \t  cn = lookup_constraint (constraint);\n \t  switch (get_constraint_type (cn))\n \t    {\n \t    case CT_REGISTER:\n-\t      if (reg_class_for_constraint (cn) != NO_REGS)\n-\t\tgoto reg;\n+\t      if (!result\n+\t\t  && reg_class_for_constraint (cn) != NO_REGS\n+\t\t  && GET_MODE (op) != BLKmode\n+\t\t  && register_operand (op, VOIDmode))\n+\t\tresult = 1;\n \t      break;\n \n \t    case CT_CONST_INT:\n@@ -2339,14 +2279,6 @@ preprocess_constraints (int n_operands, int n_alternatives,\n \n \t      switch (c)\n \t\t{\n-\t\tcase '=': case '+': case '*': case '%':\n-\t\tcase 'E': case 'F': case 'G': case 'H':\n-\t\tcase 's': case 'i': case 'n':\n-\t\tcase 'I': case 'J': case 'K': case 'L':\n-\t\tcase 'M': case 'N': case 'O': case 'P':\n-\t\t  /* These don't say anything we care about.  */\n-\t\t  break;\n-\n \t\tcase '?':\n \t\t  op_alt[i].reject += 6;\n \t\t  break;\n@@ -2367,22 +2299,11 @@ preprocess_constraints (int n_operands, int n_alternatives,\n \t\t  }\n \t\t  continue;\n \n-\t\tcase TARGET_MEM_CONSTRAINT:\n-\t\t  op_alt[i].memory_ok = 1;\n-\t\t  break;\n \t\tcase 'X':\n \t\t  op_alt[i].anything_ok = 1;\n \t\t  break;\n \n-\t\tcase 'p':\n-\t\t  op_alt[i].is_address = 1;\n-\t\t  op_alt[i].cl = reg_class_subunion[(int) op_alt[i].cl]\n-\t\t      [(int) base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n-\t\t\t\t\t     ADDRESS, SCRATCH)];\n-\t\t  break;\n-\n \t\tcase 'g':\n-\t\tcase 'r':\n \t\t  op_alt[i].cl =\n \t\t   reg_class_subunion[(int) op_alt[i].cl][(int) GENERAL_REGS];\n \t\t  break;\n@@ -2592,10 +2513,6 @@ constrain_operands (int strict)\n \t\tc = '\\0';\n \t\tbreak;\n \n-\t      case '?':  case '!': case '*':  case '%':\n-\t      case '=':  case '+':\n-\t\tbreak;\n-\n \t      case '#':\n \t\t/* Ignore rest of this alternative as far as\n \t\t   constraint checking is concerned.  */\n@@ -2695,106 +2612,10 @@ constrain_operands (int strict)\n \t\t  win = 1;\n \t\tbreak;\n \n-\t      case 'X':\n-\t\t/* This is used for a MATCH_SCRATCH in the cases when\n-\t\t   we don't actually need anything.  So anything goes\n-\t\t   any time.  */\n-\t\twin = 1;\n-\t\tbreak;\n-\n-\t      case TARGET_MEM_CONSTRAINT:\n-\t\t/* Memory operands must be valid, to the extent\n-\t\t   required by STRICT.  */\n-\t\tif (MEM_P (op))\n-\t\t  {\n-\t\t    if (strict > 0\n-\t\t\t&& !strict_memory_address_addr_space_p\n-\t\t\t     (GET_MODE (op), XEXP (op, 0),\n-\t\t\t      MEM_ADDR_SPACE (op)))\n-\t\t      break;\n-\t\t    if (strict == 0\n-\t\t\t&& !memory_address_addr_space_p\n-\t\t\t     (GET_MODE (op), XEXP (op, 0),\n-\t\t\t      MEM_ADDR_SPACE (op)))\n-\t\t      break;\n-\t\t    win = 1;\n-\t\t  }\n-\t\t/* Before reload, accept what reload can turn into mem.  */\n-\t\telse if (strict < 0 && CONSTANT_P (op))\n-\t\t  win = 1;\n-\t\t/* During reload, accept a pseudo  */\n-\t\telse if (reload_in_progress && REG_P (op)\n-\t\t\t && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      case '<':\n-\t\tif (MEM_P (op)\n-\t\t    && (GET_CODE (XEXP (op, 0)) == PRE_DEC\n-\t\t\t|| GET_CODE (XEXP (op, 0)) == POST_DEC))\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      case '>':\n-\t\tif (MEM_P (op)\n-\t\t    && (GET_CODE (XEXP (op, 0)) == PRE_INC\n-\t\t\t|| GET_CODE (XEXP (op, 0)) == POST_INC))\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      case 'E':\n-\t      case 'F':\n-\t\tif (CONST_DOUBLE_AS_FLOAT_P (op)\n-\t\t    || (GET_CODE (op) == CONST_VECTOR\n-\t\t\t&& GET_MODE_CLASS (GET_MODE (op)) == MODE_VECTOR_FLOAT))\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      case 's':\n-\t\tif (CONST_SCALAR_INT_P (op))\n-\t\t  break;\n-\t      case 'i':\n-\t\tif (CONSTANT_P (op))\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      case 'n':\n-\t\tif (CONST_SCALAR_INT_P (op))\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      case 'V':\n-\t\tif (MEM_P (op)\n-\t\t    && ((strict > 0 && ! offsettable_memref_p (op))\n-\t\t\t|| (strict < 0\n-\t\t\t    && !(CONSTANT_P (op) || MEM_P (op)))\n-\t\t\t|| (reload_in_progress\n-\t\t\t    && !(REG_P (op)\n-\t\t\t\t && REGNO (op) >= FIRST_PSEUDO_REGISTER))))\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      case 'o':\n-\t\tif ((strict > 0 && offsettable_memref_p (op))\n-\t\t    || (strict == 0 && offsettable_nonstrict_memref_p (op))\n-\t\t    /* Before reload, accept what reload can handle.  */\n-\t\t    || (strict < 0\n-\t\t\t&& (CONSTANT_P (op) || MEM_P (op)))\n-\t\t    /* During reload, accept a pseudo  */\n-\t\t    || (reload_in_progress && REG_P (op)\n-\t\t\t&& REGNO (op) >= FIRST_PSEUDO_REGISTER))\n-\t\t  win = 1;\n-\t\tbreak;\n-\n \t      default:\n \t\t{\n-\t\t  enum reg_class cl;\n-\t\t  enum constraint_num cn = (c == 'r'\n-\t\t\t\t\t    ? CONSTRAINT__UNKNOWN\n-\t\t\t\t\t    : lookup_constraint (p));\n-\n-\t\t  cl = (c == 'r'\n-\t\t\t? GENERAL_REGS : reg_class_for_constraint (cn));\n+\t\t  enum constraint_num cn = lookup_constraint (p);\n+\t\t  enum reg_class cl = reg_class_for_constraint (cn);\n \t\t  if (cl != NO_REGS)\n \t\t    {\n \t\t      if (strict < 0\n@@ -3227,8 +3048,7 @@ peep2_find_free_register (int from, int to, const char *class_str,\n       from = peep2_buf_position (from + 1);\n     }\n \n-  cl = (class_str[0] == 'r' ? GENERAL_REGS\n-\t: reg_class_for_constraint (lookup_constraint (class_str)));\n+  cl = reg_class_for_constraint (lookup_constraint (class_str));\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {"}, {"sha": "e55968e4882d146a332fe0d466ab372e99af8b1d", "filename": "gcc/reload.c", "status": "modified", "additions": 4, "deletions": 48, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -328,7 +328,6 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n   enum reload_type secondary_type;\n   int s_reload, t_reload = -1;\n   const char *scratch_constraint;\n-  char letter;\n   secondary_reload_info sri;\n \n   if (type == RELOAD_FOR_INPUT_ADDRESS\n@@ -399,10 +398,8 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n       scratch_constraint++;\n       if (*scratch_constraint == '&')\n \tscratch_constraint++;\n-      letter = *scratch_constraint;\n-      scratch_class = (letter == 'r' ? GENERAL_REGS\n-\t\t       : (reg_class_for_constraint\n-\t\t\t  (lookup_constraint (scratch_constraint))));\n+      scratch_class = (reg_class_for_constraint\n+\t\t       (lookup_constraint (scratch_constraint)));\n \n       rclass = scratch_class;\n       mode = insn_data[(int) icode].operand[2].mode;\n@@ -548,7 +545,6 @@ enum reg_class\n scratch_reload_class (enum insn_code icode)\n {\n   const char *scratch_constraint;\n-  char scratch_letter;\n   enum reg_class rclass;\n \n   gcc_assert (insn_data[(int) icode].n_operands == 3);\n@@ -557,9 +553,6 @@ scratch_reload_class (enum insn_code icode)\n   scratch_constraint++;\n   if (*scratch_constraint == '&')\n     scratch_constraint++;\n-  scratch_letter = *scratch_constraint;\n-  if (scratch_letter == 'r')\n-    return GENERAL_REGS;\n   rclass = reg_class_for_constraint (lookup_constraint (scratch_constraint));\n   gcc_assert (rclass != NO_REGS);\n   return rclass;\n@@ -2850,9 +2843,8 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n       if (*constraints[i] == 0)\n \t/* Ignore things like match_operator operands.  */\n \t;\n-      else if (constraints[i][0] == 'p'\n-\t       || (insn_extra_address_constraint\n-\t\t   (lookup_constraint (constraints[i]))))\n+      else if (insn_extra_address_constraint\n+\t       (lookup_constraint (constraints[i])))\n \t{\n \t  address_operand_reloaded[i]\n \t    = find_reloads_address (recog_data.operand_mode[i], (rtx*) 0,\n@@ -3209,14 +3201,6 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t    c = '\\0';\n \t\t    break;\n \n-\t\t  case '=':  case '+':  case '*':\n-\t\t    break;\n-\n-\t\t  case '%':\n-\t\t    /* We only support one commutative marker, the first\n-\t\t       one.  We already set commutative above.  */\n-\t\t    break;\n-\n \t\t  case '?':\n \t\t    reject += 6;\n \t\t    break;\n@@ -3425,29 +3409,6 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t    earlyclobber = 1, this_earlyclobber = 1;\n \t\t    break;\n \n-\t\t  case 'E':\n-\t\t  case 'F':\n-\t\t    if (CONST_DOUBLE_AS_FLOAT_P (operand)\n-\t\t\t|| (GET_CODE (operand) == CONST_VECTOR\n-\t\t\t    && (GET_MODE_CLASS (GET_MODE (operand))\n-\t\t\t\t== MODE_VECTOR_FLOAT)))\n-\t\t      win = 1;\n-\t\t    break;\n-\n-\t\t  case 's':\n-\t\t    if (CONST_SCALAR_INT_P (operand))\n-\t\t      break;\n-\t\t  case 'i':\n-\t\t    if (CONSTANT_P (operand)\n-\t\t\t&& (! flag_pic || LEGITIMATE_PIC_OPERAND_P (operand)))\n-\t\t      win = 1;\n-\t\t    break;\n-\n-\t\t  case 'n':\n-\t\t    if (CONST_SCALAR_INT_P (operand))\n-\t\t      win = 1;\n-\t\t    break;\n-\n \t\t  case 'X':\n \t\t    force_reload = 0;\n \t\t    win = 1;\n@@ -3468,9 +3429,6 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t\t    || (REGNO (operand) >= FIRST_PSEUDO_REGISTER\n \t\t\t\t&& reg_renumber[REGNO (operand)] < 0)))\n \t\t      win = 1;\n-\t\t    /* Drop through into 'r' case.  */\n-\n-\t\t  case 'r':\n \t\t    cl = GENERAL_REGS;\n \t\t    goto reg;\n \n@@ -4677,8 +4635,6 @@ alternative_allows_const_pool_ref (rtx mem ATTRIBUTE_UNUSED,\n   for (; (c = *constraint) && c != ',' && c != '#';\n        constraint += CONSTRAINT_LEN (c, constraint))\n     {\n-      if (c == TARGET_MEM_CONSTRAINT || c == 'o')\n-\treturn true;\n       enum constraint_num cn = lookup_constraint (constraint);\n       if (insn_extra_memory_constraint (cn)\n \t  && (mem == NULL || constraint_satisfied_p (mem, cn)))"}, {"sha": "25adf446e1d824c8666a9e818d8d5a63bf0c899f", "filename": "gcc/reload1.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -1417,22 +1417,7 @@ maybe_fix_stack_asms (void)\n \n \t      switch (c)\n \t\t{\n-\t\tcase '=': case '+': case '*': case '%': case '?': case '!':\n-\t\tcase '0': case '1': case '2': case '3': case '4': case '<':\n-\t\tcase '>': case 'V': case 'o': case '&': case 'E': case 'F':\n-\t\tcase 's': case 'i': case 'n': case 'X': case 'I': case 'J':\n-\t\tcase 'K': case 'L': case 'M': case 'N': case 'O': case 'P':\n-\t\tcase TARGET_MEM_CONSTRAINT:\n-\t\t  break;\n-\n-\t\tcase 'p':\n-\t\t  cls = (int) reg_class_subunion[cls]\n-\t\t      [(int) base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n-\t\t\t\t\t     ADDRESS, SCRATCH)];\n-\t\t  break;\n-\n \t\tcase 'g':\n-\t\tcase 'r':\n \t\t  cls = (int) reg_class_subunion[cls][(int) GENERAL_REGS];\n \t\t  break;\n "}, {"sha": "0aae085aa892e3d1ef06e4261f438063cc3ff46e", "filename": "gcc/stmt.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -286,10 +286,6 @@ parse_output_constraint (const char **constraint_p, int operand_num,\n \t  }\n \tbreak;\n \n-      case 'V':  case TARGET_MEM_CONSTRAINT:  case 'o':\n-\t*allows_mem = true;\n-\tbreak;\n-\n       case '?':  case '!':  case '*':  case '&':  case '#':\n       case 'E':  case 'F':  case 'G':  case 'H':\n       case 's':  case 'i':  case 'n':\n@@ -315,10 +311,6 @@ parse_output_constraint (const char **constraint_p, int operand_num,\n \t*allows_mem = true;\n \tbreak;\n \n-      case 'p': case 'r':\n-\t*allows_reg = true;\n-\tbreak;\n-\n       default:\n \tif (!ISALPHA (*p))\n \t  break;\n@@ -383,10 +375,6 @@ parse_input_constraint (const char **constraint_p, int input_num,\n \t  }\n \tbreak;\n \n-      case 'V':  case TARGET_MEM_CONSTRAINT:  case 'o':\n-\t*allows_mem = true;\n-\tbreak;\n-\n       case '<':  case '>':\n       case '?':  case '!':  case '*':  case '#':\n       case 'E':  case 'F':  case 'G':  case 'H':\n@@ -437,10 +425,6 @@ parse_input_constraint (const char **constraint_p, int input_num,\n \t}\n \t/* Fall through.  */\n \n-      case 'p':  case 'r':\n-\t*allows_reg = true;\n-\tbreak;\n-\n       case 'g':  case 'X':\n \t*allows_reg = true;\n \t*allows_mem = true;"}, {"sha": "0f27a5a6176af0a913655397a67375ae6efee7d6", "filename": "gcc/targhooks.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8677664e02258772068ad1fe4672943c998bace8/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8677664e02258772068ad1fe4672943c998bace8/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=8677664e02258772068ad1fe4672943c998bace8", "patch": "@@ -919,7 +919,6 @@ default_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED,\n       else if (icode != CODE_FOR_nothing)\n \t{\n \t  const char *insn_constraint, *scratch_constraint;\n-\t  char insn_letter, scratch_letter;\n \t  enum reg_class insn_class, scratch_class;\n \n \t  gcc_assert (insn_data[(int) icode].n_operands == 3);\n@@ -933,11 +932,8 @@ default_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED,\n \t\t  gcc_assert (*insn_constraint == '=');\n \t\t  insn_constraint++;\n \t\t}\n-\t      insn_letter = *insn_constraint;\n-\t      insn_class\n-\t\t= (insn_letter == 'r' ? GENERAL_REGS\n-\t\t   : (reg_class_for_constraint\n-\t\t      (lookup_constraint (insn_constraint))));\n+\t      insn_class = (reg_class_for_constraint\n+\t\t\t    (lookup_constraint (insn_constraint)));\n \t      gcc_assert (insn_class != NO_REGS);\n \t    }\n \n@@ -951,11 +947,8 @@ default_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED,\n \t  scratch_constraint++;\n \t  if (*scratch_constraint == '&')\n \t    scratch_constraint++;\n-\t  scratch_letter = *scratch_constraint;\n-\t  scratch_class\n-\t    = (scratch_letter == 'r' ? GENERAL_REGS\n-\t       : (reg_class_for_constraint\n-\t\t  (lookup_constraint (scratch_constraint))));\n+\t  scratch_class = (reg_class_for_constraint\n+\t\t\t   (lookup_constraint (scratch_constraint)));\n \n \t  if (reg_class_subset_p (reload_class, insn_class))\n \t    {"}]}