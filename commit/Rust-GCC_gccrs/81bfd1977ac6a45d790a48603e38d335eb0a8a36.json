{"sha": "81bfd1977ac6a45d790a48603e38d335eb0a8a36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFiZmQxOTc3YWM2YTQ1ZDc5MGE0ODYwM2UzOGQzMzVlYjBhOGEzNg==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2012-01-26T15:50:33Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2012-01-26T15:50:33Z"}, "message": "re PR tree-optimization/46590 (long compile time with -O2 and many loops)\n\n\tPR tree-optimization/46590\n\t* cfgexpand.c: Revert last change (r183305).\n\t* gimplify.c (gimplify_bind_expr): Add clobbers for all non-gimple\n\tregs.\n\t* tree-eh.c (cleanup_empty_eh): Try to optimize clobbers before\n\tchecking for emptiness.\n\nFrom-SVN: r183566", "tree": {"sha": "808bb0980b8187c2584ca18d2cc1712638bdbd79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/808bb0980b8187c2584ca18d2cc1712638bdbd79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81bfd1977ac6a45d790a48603e38d335eb0a8a36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81bfd1977ac6a45d790a48603e38d335eb0a8a36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81bfd1977ac6a45d790a48603e38d335eb0a8a36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81bfd1977ac6a45d790a48603e38d335eb0a8a36/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bfb676c121bba67c943f211af349c836d04226bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfb676c121bba67c943f211af349c836d04226bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfb676c121bba67c943f211af349c836d04226bc"}], "stats": {"total": 64, "additions": 34, "deletions": 30}, "files": [{"sha": "f9a3880fd802bd3011634e6779091549519fd63f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81bfd1977ac6a45d790a48603e38d335eb0a8a36/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81bfd1977ac6a45d790a48603e38d335eb0a8a36/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81bfd1977ac6a45d790a48603e38d335eb0a8a36", "patch": "@@ -1,3 +1,12 @@\n+2012-01-26  Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/46590\n+\t* cfgexpand.c: Revert last change (r183305).\n+\t* gimplify.c (gimplify_bind_expr): Add clobbers for all non-gimple\n+\tregs.\n+\t* tree-eh.c (cleanup_empty_eh): Try to optimize clobbers before\n+\tchecking for emptiness.\n+\n 2012-01-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/51895"}, {"sha": "bde15f696839640412f3c4b577638ab5ec6f6ffc", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81bfd1977ac6a45d790a48603e38d335eb0a8a36/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81bfd1977ac6a45d790a48603e38d335eb0a8a36/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=81bfd1977ac6a45d790a48603e38d335eb0a8a36", "patch": "@@ -440,12 +440,11 @@ visit_conflict (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n \n /* Helper routine for add_scope_conflicts, calculating the active partitions\n    at the end of BB, leaving the result in WORK.  We're called to generate\n-   conflicts when OLD_CONFLICTS is non-null, otherwise we're just tracking\n-   liveness.  If we generate conflicts then OLD_CONFLICTS stores the bits\n-   for which we generated conflicts already.  */\n+   conflicts when FOR_CONFLICT is true, otherwise we're just tracking\n+   liveness.  */\n \n static void\n-add_scope_conflicts_1 (basic_block bb, bitmap work, bitmap old_conflicts)\n+add_scope_conflicts_1 (basic_block bb, bitmap work, bool for_conflict)\n {\n   edge e;\n   edge_iterator ei;\n@@ -482,35 +481,24 @@ add_scope_conflicts_1 (basic_block bb, bitmap work, bitmap old_conflicts)\n \t}\n       else if (!is_gimple_debug (stmt))\n \t{\n-\t  if (old_conflicts\n+\t  if (for_conflict\n \t      && visit == visit_op)\n \t    {\n \t      /* If this is the first real instruction in this BB we need\n \t         to add conflicts for everything live at this point now.\n \t\t Unlike classical liveness for named objects we can't\n \t\t rely on seeing a def/use of the names we're interested in.\n \t\t There might merely be indirect loads/stores.  We'd not add any\n-\t\t conflicts for such partitions.  We know that we generated\n-\t\t conflicts between all partitions in old_conflicts already,\n-\t\t so we need to generate only the new ones, avoiding to\n-\t\t repeatedly pay the O(N^2) cost for each basic block.  */\n+\t\t conflicts for such partitions.  */\n \t      bitmap_iterator bi;\n \t      unsigned i;\n-\n-\t      EXECUTE_IF_AND_COMPL_IN_BITMAP (work, old_conflicts, 0, i, bi)\n+\t      EXECUTE_IF_SET_IN_BITMAP (work, 0, i, bi)\n \t\t{\n \t\t  unsigned j;\n \t\t  bitmap_iterator bj;\n-\t\t  /* First the conflicts between new and old_conflicts.  */\n-\t\t  EXECUTE_IF_SET_IN_BITMAP (old_conflicts, 0, j, bj)\n-\t\t    add_stack_var_conflict (i, j);\n-\t\t  /* Then the conflicts between only the new members.  */\n-\t\t  EXECUTE_IF_AND_COMPL_IN_BITMAP (work, old_conflicts, i + 1,\n-\t\t\t\t\t\t  j, bj)\n+\t\t  EXECUTE_IF_SET_IN_BITMAP (work, i + 1, j, bj)\n \t\t    add_stack_var_conflict (i, j);\n \t\t}\n-\t      /* And remember for the next basic block.  */\n-\t      bitmap_ior_into (old_conflicts, work);\n \t      visit = visit_conflict;\n \t    }\n \t  walk_stmt_load_store_addr_ops (stmt, work, visit, visit, visit);\n@@ -527,7 +515,6 @@ add_scope_conflicts (void)\n   basic_block bb;\n   bool changed;\n   bitmap work = BITMAP_ALLOC (NULL);\n-  bitmap old_conflicts;\n \n   /* We approximate the live range of a stack variable by taking the first\n      mention of its name as starting point(s), and by the end-of-scope\n@@ -549,18 +536,15 @@ add_scope_conflicts (void)\n       FOR_EACH_BB (bb)\n \t{\n \t  bitmap active = (bitmap)bb->aux;\n-\t  add_scope_conflicts_1 (bb, work, NULL);\n+\t  add_scope_conflicts_1 (bb, work, false);\n \t  if (bitmap_ior_into (active, work))\n \t    changed = true;\n \t}\n     }\n \n-  old_conflicts = BITMAP_ALLOC (NULL);\n-\n   FOR_EACH_BB (bb)\n-    add_scope_conflicts_1 (bb, work, old_conflicts);\n+    add_scope_conflicts_1 (bb, work, true);\n \n-  BITMAP_FREE (old_conflicts);\n   BITMAP_FREE (work);\n   FOR_ALL_BB (bb)\n     BITMAP_FREE (bb->aux);"}, {"sha": "782adc34cafb185db16c71bb9615684f1342fb49", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81bfd1977ac6a45d790a48603e38d335eb0a8a36/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81bfd1977ac6a45d790a48603e38d335eb0a8a36/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=81bfd1977ac6a45d790a48603e38d335eb0a8a36", "patch": "@@ -1231,7 +1231,7 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n \t  && !DECL_HAS_VALUE_EXPR_P (t)\n \t  /* Only care for variables that have to be in memory.  Others\n \t     will be rewritten into SSA names, hence moved to the top-level.  */\n-\t  && needs_to_live_in_memory (t))\n+\t  && !is_gimple_reg (t))\n \t{\n \t  tree clobber = build_constructor (TREE_TYPE (t), NULL);\n \t  TREE_THIS_VOLATILE (clobber) = 1;"}, {"sha": "521e2f7f44a451fe2a3ce583e05892708a41bcef", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81bfd1977ac6a45d790a48603e38d335eb0a8a36/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81bfd1977ac6a45d790a48603e38d335eb0a8a36/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=81bfd1977ac6a45d790a48603e38d335eb0a8a36", "patch": "@@ -4056,6 +4056,7 @@ cleanup_empty_eh (eh_landing_pad lp)\n   edge_iterator ei;\n   edge e, e_out;\n   bool has_non_eh_pred;\n+  bool ret = false;\n   int new_lp_nr;\n \n   /* There can be zero or one edges out of BB.  This is the quickest test.  */\n@@ -4070,6 +4071,16 @@ cleanup_empty_eh (eh_landing_pad lp)\n     default:\n       return false;\n     }\n+\n+  resx = last_stmt (bb);\n+  if (resx && is_gimple_resx (resx))\n+    {\n+      if (stmt_can_throw_external (resx))\n+\toptimize_clobbers (bb);\n+      else if (sink_clobbers (bb))\n+\tret = true;\n+    }\n+\n   gsi = gsi_after_labels (bb);\n \n   /* Make sure to skip debug statements.  */\n@@ -4081,9 +4092,9 @@ cleanup_empty_eh (eh_landing_pad lp)\n     {\n       /* For the degenerate case of an infinite loop bail out.  */\n       if (infinite_empty_loop_p (e_out))\n-\treturn false;\n+\treturn ret;\n \n-      return cleanup_empty_eh_unsplit (bb, e_out, lp);\n+      return ret | cleanup_empty_eh_unsplit (bb, e_out, lp);\n     }\n \n   /* The block should consist only of a single RESX statement, modulo a\n@@ -4096,7 +4107,7 @@ cleanup_empty_eh (eh_landing_pad lp)\n       resx = gsi_stmt (gsi);\n     }\n   if (!is_gimple_resx (resx))\n-    return false;\n+    return ret;\n   gcc_assert (gsi_one_before_end_p (gsi));\n \n   /* Determine if there are non-EH edges, or resx edges into the handler.  */\n@@ -4172,7 +4183,7 @@ cleanup_empty_eh (eh_landing_pad lp)\n       return true;\n     }\n \n-  return false;\n+  return ret;\n \n  succeed:\n   if (dump_file && (dump_flags & TDF_DETAILS))"}]}