{"sha": "dbf23a7900dfa15dd4b6cc681c3310ca17276d6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJmMjNhNzkwMGRmYTE1ZGQ0YjZjYzY4MWMzMzEwY2ExNzI3NmQ2YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-04-22T12:46:07Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-04-22T12:46:07Z"}, "message": "machmode.h (bitwise_mode_for_mode): Declare.\n\ngcc/\n\t* machmode.h (bitwise_mode_for_mode): Declare.\n\t* stor-layout.h (bitwise_type_for_mode): Likewise.\n\t* stor-layout.c (bitwise_mode_for_mode): New function.\n\t(bitwise_type_for_mode): Likewise.\n\t* builtins.c (fold_builtin_memory_op): Use it instead of\n\tint_mode_for_mode and build_nonstandard_integer_type.\n\ngcc/testsuite/\n\t* gcc.dg/memcpy-5.c: New test.\n\nFrom-SVN: r209622", "tree": {"sha": "6254ef8bed13933fcdfb55163f89625f1932c652", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6254ef8bed13933fcdfb55163f89625f1932c652"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d9f069ab4f645085b7d439e166b7501b9fb6ce8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9f069ab4f645085b7d439e166b7501b9fb6ce8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9f069ab4f645085b7d439e166b7501b9fb6ce8a"}], "stats": {"total": 133, "additions": 113, "deletions": 20}, "files": [{"sha": "3a46e6f66b8e853275dcba32f8cb953e343a50f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dbf23a7900dfa15dd4b6cc681c3310ca17276d6a", "patch": "@@ -1,3 +1,12 @@\n+2014-04-22  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* machmode.h (bitwise_mode_for_mode): Declare.\n+\t* stor-layout.h (bitwise_type_for_mode): Likewise.\n+\t* stor-layout.c (bitwise_mode_for_mode): New function.\n+\t(bitwise_type_for_mode): Likewise.\n+\t* builtins.c (fold_builtin_memory_op): Use it instead of\n+\tint_mode_for_mode and build_nonstandard_integer_type.\n+\n 2014-04-22  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config.gcc (enable_obsolete): Remove *-*-solaris2.9*."}, {"sha": "42e4af263ab1a111127e8e40ae7b2b075bb3373b", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=dbf23a7900dfa15dd4b6cc681c3310ca17276d6a", "patch": "@@ -8921,29 +8921,11 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n       if (FLOAT_MODE_P (TYPE_MODE (desttype))\n \t  || TREE_CODE (desttype) == BOOLEAN_TYPE\n \t  || TREE_CODE (desttype) == ENUMERAL_TYPE)\n-\t{\n-\t  /* A more suitable int_mode_for_mode would return a vector\n-\t     integer mode for a vector float mode or a integer complex\n-\t     mode for a float complex mode if there isn't a regular\n-\t     integer mode covering the mode of desttype.  */\n-\t  enum machine_mode mode = int_mode_for_mode (TYPE_MODE (desttype));\n-\t  if (mode == BLKmode)\n-\t    desttype = NULL_TREE;\n-\t  else\n-\t    desttype = build_nonstandard_integer_type (GET_MODE_BITSIZE (mode),\n-\t\t\t\t\t\t       1);\n-\t}\n+\tdesttype = bitwise_type_for_mode (TYPE_MODE (desttype));\n       if (FLOAT_MODE_P (TYPE_MODE (srctype))\n \t  || TREE_CODE (srctype) == BOOLEAN_TYPE\n \t  || TREE_CODE (srctype) == ENUMERAL_TYPE)\n-\t{\n-\t  enum machine_mode mode = int_mode_for_mode (TYPE_MODE (srctype));\n-\t  if (mode == BLKmode)\n-\t    srctype = NULL_TREE;\n-\t  else\n-\t    srctype = build_nonstandard_integer_type (GET_MODE_BITSIZE (mode),\n-\t\t\t\t\t\t      1);\n-\t}\n+\tsrctype = bitwise_type_for_mode (TYPE_MODE (srctype));\n       if (!srctype)\n \tsrctype = desttype;\n       if (!desttype)"}, {"sha": "8d6ea187b4dc535a355d23e2aaf87ec0e9f039a3", "filename": "gcc/machmode.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=dbf23a7900dfa15dd4b6cc681c3310ca17276d6a", "patch": "@@ -271,6 +271,8 @@ extern enum machine_mode smallest_mode_for_size (unsigned int,\n \n extern enum machine_mode int_mode_for_mode (enum machine_mode);\n \n+extern enum machine_mode bitwise_mode_for_mode (enum machine_mode);\n+\n /* Return a mode that is suitable for representing a vector,\n    or BLKmode on failure.  */\n "}, {"sha": "4f99fa3469aafab0369f057f9b268c108c8bd18a", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=dbf23a7900dfa15dd4b6cc681c3310ca17276d6a", "patch": "@@ -403,6 +403,73 @@ int_mode_for_mode (enum machine_mode mode)\n   return mode;\n }\n \n+/* Find a mode that can be used for efficient bitwise operations on MODE.\n+   Return BLKmode if no such mode exists.  */\n+\n+enum machine_mode\n+bitwise_mode_for_mode (enum machine_mode mode)\n+{\n+  /* Quick exit if we already have a suitable mode.  */\n+  unsigned int bitsize = GET_MODE_BITSIZE (mode);\n+  if (SCALAR_INT_MODE_P (mode) && bitsize <= MAX_FIXED_MODE_SIZE)\n+    return mode;\n+\n+  /* Reuse the sanity checks from int_mode_for_mode.  */\n+  gcc_checking_assert ((int_mode_for_mode (mode), true));\n+\n+  /* Try to replace complex modes with complex modes.  In general we\n+     expect both components to be processed independently, so we only\n+     care whether there is a register for the inner mode.  */\n+  if (COMPLEX_MODE_P (mode))\n+    {\n+      enum machine_mode trial = mode;\n+      if (GET_MODE_CLASS (mode) != MODE_COMPLEX_INT)\n+\ttrial = mode_for_size (bitsize, MODE_COMPLEX_INT, false);\n+      if (trial != BLKmode\n+\t  && have_regs_of_mode[GET_MODE_INNER (trial)])\n+\treturn trial;\n+    }\n+\n+  /* Try to replace vector modes with vector modes.  Also try using vector\n+     modes if an integer mode would be too big.  */\n+  if (VECTOR_MODE_P (mode) || bitsize > MAX_FIXED_MODE_SIZE)\n+    {\n+      enum machine_mode trial = mode;\n+      if (GET_MODE_CLASS (mode) != MODE_VECTOR_INT)\n+\ttrial = mode_for_size (bitsize, MODE_VECTOR_INT, 0);\n+      if (trial != BLKmode\n+\t  && have_regs_of_mode[trial]\n+\t  && targetm.vector_mode_supported_p (trial))\n+\treturn trial;\n+    }\n+\n+  /* Otherwise fall back on integers while honoring MAX_FIXED_MODE_SIZE.  */\n+  return mode_for_size (bitsize, MODE_INT, true);\n+}\n+\n+/* Find a type that can be used for efficient bitwise operations on MODE.\n+   Return null if no such mode exists.  */\n+\n+tree\n+bitwise_type_for_mode (enum machine_mode mode)\n+{\n+  mode = bitwise_mode_for_mode (mode);\n+  if (mode == BLKmode)\n+    return NULL_TREE;\n+\n+  unsigned int inner_size = GET_MODE_UNIT_BITSIZE (mode);\n+  tree inner_type = build_nonstandard_integer_type (inner_size, true);\n+\n+  if (VECTOR_MODE_P (mode))\n+    return build_vector_type_for_mode (inner_type, mode);\n+\n+  if (COMPLEX_MODE_P (mode))\n+    return build_complex_type (inner_type);\n+\n+  gcc_checking_assert (GET_MODE_INNER (mode) == VOIDmode);\n+  return inner_type;\n+}\n+\n /* Find a mode that is suitable for representing a vector with\n    NUNITS elements of mode INNERMODE.  Returns BLKmode if there\n    is no suitable mode.  */"}, {"sha": "e2f800d3b7601f35ea725833f84abf532d6a4517", "filename": "gcc/stor-layout.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a/gcc%2Fstor-layout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a/gcc%2Fstor-layout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.h?ref=dbf23a7900dfa15dd4b6cc681c3310ca17276d6a", "patch": "@@ -98,6 +98,8 @@ extern tree make_unsigned_type (int);\n    mode_for_size, but is passed a tree.  */\n extern enum machine_mode mode_for_size_tree (const_tree, enum mode_class, int);\n \n+extern tree bitwise_type_for_mode (enum machine_mode);\n+\n /* Given a VAR_DECL, PARM_DECL or RESULT_DECL, clears the results of\n    a previous call to layout_decl and calls it again.  */\n extern void relayout_decl (tree);"}, {"sha": "53f5e27d946bdfbc0e14a8ff034f47e3d32fecd3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dbf23a7900dfa15dd4b6cc681c3310ca17276d6a", "patch": "@@ -1,3 +1,7 @@\n+2014-04-22  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* gcc.dg/memcpy-5.c: New test.\n+\n 2014-04-22  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* gcc.c-torture/compile/pr28865.c: Remove dg-xfail-if."}, {"sha": "dc5afed1907129c4403681a4ba8ffa8aaf03d202", "filename": "gcc/testsuite/gcc.dg/memcpy-5.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf23a7900dfa15dd4b6cc681c3310ca17276d6a/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-5.c?ref=dbf23a7900dfa15dd4b6cc681c3310ca17276d6a", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+extern void *memcpy (void *, const void *, __SIZE_TYPE__);\n+\n+#define TEST(NAME, TYPE) \\\n+  TYPE NAME##x; \\\n+  char NAME##y[sizeof (NAME##x)] __attribute__((aligned (__alignof__ (NAME##x)))); \\\n+  void NAME (void) { memcpy (&NAME##x, &NAME##y, sizeof (NAME##x)); }\n+\n+TEST (f, float);\n+TEST (d, double);\n+TEST (ld, long double);\n+TEST (cf, _Complex float);\n+TEST (cd, _Complex double);\n+TEST (cld, _Complex long double);\n+TEST (d8f, float __attribute__((vector_size (8))));\n+TEST (d16f, float __attribute__((vector_size (16))));\n+TEST (d32f, float __attribute__((vector_size (32))));\n+TEST (d64f, float __attribute__((vector_size (64))));\n+TEST (d128f, float __attribute__((vector_size (128))));\n+TEST (d16d, double __attribute__((vector_size (16))));\n+TEST (d32d, double __attribute__((vector_size (32))));\n+TEST (d64d, double __attribute__((vector_size (64))));\n+TEST (d128d, double __attribute__((vector_size (128))));\n+\n+/* { dg-final { scan-tree-dump-not \"memcpy\" \"optimized\" { target x86_64-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}]}