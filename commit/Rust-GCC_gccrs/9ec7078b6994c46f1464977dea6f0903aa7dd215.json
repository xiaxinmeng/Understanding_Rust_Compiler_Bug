{"sha": "9ec7078b6994c46f1464977dea6f0903aa7dd215", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVjNzA3OGI2OTk0YzQ2ZjE0NjQ5NzdkZWE2ZjA5MDNhYTdkZDIxNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-10T14:04:07Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-10T14:04:07Z"}, "message": "(reload_secondary_{reload,icode}): Deleted.\n\n(reload_secondary_{in,out}_{reload,icode}): New variables.\n(MATCHES, MERGABLE_RELOADS, MERGE_TO_OTHER): Move to front of file.\n(push_secondary_reload): New function, from find_secondary_reload.\n(find_secondary_relaod): Deleted.\n(push_reload): Call push_secondary_reload.\n(combine_reloads): Use new vars for secondary reloads and icodes.\n\nFrom-SVN: r6522", "tree": {"sha": "3cd82d96d5b5289692bbeb0b0f61cac2d11e6ffa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cd82d96d5b5289692bbeb0b0f61cac2d11e6ffa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ec7078b6994c46f1464977dea6f0903aa7dd215", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ec7078b6994c46f1464977dea6f0903aa7dd215", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ec7078b6994c46f1464977dea6f0903aa7dd215", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ec7078b6994c46f1464977dea6f0903aa7dd215/comments", "author": null, "committer": null, "parents": [{"sha": "b3338715f9a14fc2518ff6c9a4d7ead5407c323a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3338715f9a14fc2518ff6c9a4d7ead5407c323a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3338715f9a14fc2518ff6c9a4d7ead5407c323a"}], "stats": {"total": 564, "additions": 246, "deletions": 318}, "files": [{"sha": "b3a21c8b36bbe427851a2b148027073a68b298a7", "filename": "gcc/reload.c", "status": "modified", "additions": 246, "deletions": 318, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ec7078b6994c46f1464977dea6f0903aa7dd215/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ec7078b6994c46f1464977dea6f0903aa7dd215/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=9ec7078b6994c46f1464977dea6f0903aa7dd215", "patch": "@@ -141,11 +141,15 @@ a register with any other reload.  */\n \t\t\t   for addressing a non-reloaded mem ref,\n \t\t\t   or for unspecified purposes (i.e., more than one\n \t\t\t   of the above).\n-   reload_secondary_reload int, gives the reload number of a secondary\n-\t\t\t   reload, when needed; otherwise -1\n    reload_secondary_p\t  int, 1 if this is a secondary register for one\n-\t\t\t  or more reloads.\n-   reload_secondary_icode enum insn_code, if a secondary reload is required,\n+\t\t\t   or more reloads.\n+   reload_secondary_in_reload\n+   reload_secondary_out_reload\n+   \t\t\t  int, gives the reload number of a secondary\n+\t\t\t   reload, when needed; otherwise -1\n+   reload_secondary_in_icode\n+   reload_secondary_out_icode\n+\t\t\t  enum insn_code, if a secondary reload is required,\n \t\t\t   gives the INSN_CODE that uses the secondary\n \t\t\t   reload as a scratch register, or CODE_FOR_nothing\n \t\t\t   if the secondary reload register is to be an\n@@ -164,9 +168,11 @@ rtx reload_in_reg[MAX_RELOADS];\n char reload_nocombine[MAX_RELOADS];\n int reload_opnum[MAX_RELOADS];\n enum reload_type reload_when_needed[MAX_RELOADS];\n-int reload_secondary_reload[MAX_RELOADS];\n int reload_secondary_p[MAX_RELOADS];\n-enum insn_code reload_secondary_icode[MAX_RELOADS];\n+int reload_secondary_in_reload[MAX_RELOADS];\n+int reload_secondary_out_reload[MAX_RELOADS];\n+enum insn_code reload_secondary_in_icode[MAX_RELOADS];\n+enum insn_code reload_secondary_out_icode[MAX_RELOADS];\n \n /* All the \"earlyclobber\" operands of the current insn\n    are recorded here.  */\n@@ -254,13 +260,34 @@ static int subst_reg_equivs_changed;\n    operand, which can be different for that from the input operand.  */\n static int output_reloadnum;\n \n-static enum reg_class find_secondary_reload PROTO((rtx, enum reg_class,\n-\t\t\t\t\t\t   enum machine_mode, int,\n-\t\t\t\t\t\t   enum insn_code *,\n-\t\t\t\t\t\t   enum machine_mode *,\n-\t\t\t\t\t\t   enum reg_class *,\n-\t\t\t\t\t\t   enum insn_code *,\n-\t\t\t\t\t\t   enum machine_mode *));\n+  /* Compare two RTX's.  */\n+#define MATCHES(x, y) \\\n+ (x == y || (x != 0 && (GET_CODE (x) == REG\t\t\t\t\\\n+\t\t\t? GET_CODE (y) == REG && REGNO (x) == REGNO (y)\t\\\n+\t\t\t: rtx_equal_p (x, y) && ! side_effects_p (x))))\n+\n+  /* Indicates if two reloads purposes are for similar enough things that we\n+     can merge their reloads.  */\n+#define MERGABLE_RELOADS(when1, when2, op1, op2) \\\n+  ((when1) == RELOAD_OTHER || (when2) == RELOAD_OTHER\t\\\n+   || ((when1) == (when2) && (op1) == (op2))\t\t\\\n+   || ((when1) == RELOAD_FOR_INPUT && (when2) == RELOAD_FOR_INPUT) \\\n+   || ((when1) == RELOAD_FOR_OPERAND_ADDRESS\t\t\\\n+       && (when2) == RELOAD_FOR_OPERAND_ADDRESS)\t\\\n+   || ((when1) == RELOAD_FOR_OTHER_ADDRESS\t\t\\\n+       && (when2) == RELOAD_FOR_OTHER_ADDRESS))\n+\n+  /* Nonzero if these two reload purposes produce RELOAD_OTHER when merged.  */\n+#define MERGE_TO_OTHER(when1, when2, op1, op2) \\\n+  ((when1) != (when2)\t\t\t\t\t\\\n+   || ! ((op1) == (op2)\t\t\t\t\t\\\n+\t || (when1) == RELOAD_FOR_INPUT\t\t\t\\\n+\t || (when1) == RELOAD_FOR_OPERAND_ADDRESS\t\\\n+\t || (when1) == RELOAD_FOR_OTHER_ADDRESS))\n+\n+static int push_secondary_reload PROTO((int, rtx, int, int, enum reg_class,\n+\t\t\t\t\tenum machine_mode, enum reload_type,\n+\t\t\t\t\tenum insn_code *));\n static int push_reload\t\tPROTO((rtx, rtx, rtx *, rtx *, enum reg_class,\n \t\t\t\t       enum machine_mode, enum machine_mode,\n \t\t\t\t       int, int, int, enum reload_type));\n@@ -291,40 +318,37 @@ static int find_inc_amount\tPROTO((rtx, rtx));\n \n /* Determine if any secondary reloads are needed for loading (if IN_P is\n    non-zero) or storing (if IN_P is zero) X to or from a reload register of\n-   register class RELOAD_CLASS in mode RELOAD_MODE.\n-\n-   Return the register class of a secondary reload register, or NO_REGS if\n-   none.  *PMODE is set to the mode that the register is required in.\n-   If the reload register is needed as a scratch register instead of an\n-   intermediate register, *PICODE is set to the insn_code of the insn to be\n-   used to load or store the primary reload register; otherwise *PICODE\n-   is set to CODE_FOR_nothing.\n-\n-   In some cases (such as storing MQ into an external memory location on\n-   the RT), both an intermediate register and a scratch register.  In that\n-   case, *PICODE is set to CODE_FOR_nothing, the class for the intermediate\n-   register is returned, and the *PTERTIARY_... variables are set to describe\n-   the scratch register.  */\n-\n-static enum reg_class\n-find_secondary_reload (x, reload_class, reload_mode, in_p, picode, pmode,\n-\t\t      ptertiary_class, ptertiary_icode, ptertiary_mode)\n+   register class RELOAD_CLASS in mode RELOAD_MODE.  If secondary reloads\n+   are needed, push them.\n+\n+   Return the reload number of the secondary reload we made, or -1 if\n+   we didn't need one.  *PICODE is set to the insn_code to use if we do\n+   need a secondary reload.  */\n+\n+static int\n+push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n+\t\t       type, picode)\n+     int in_p;\n      rtx x;\n+     int opnum;\n+     int optional;\n      enum reg_class reload_class;\n      enum machine_mode reload_mode;\n-     int in_p;\n+     enum reload_type type;\n      enum insn_code *picode;\n-     enum machine_mode *pmode;\n-     enum reg_class *ptertiary_class;\n-     enum insn_code *ptertiary_icode;\n-     enum machine_mode *ptertiary_mode;\n {\n   enum reg_class class = NO_REGS;\n   enum machine_mode mode = reload_mode;\n   enum insn_code icode = CODE_FOR_nothing;\n   enum reg_class t_class = NO_REGS;\n   enum machine_mode t_mode = VOIDmode;\n   enum insn_code t_icode = CODE_FOR_nothing;\n+  enum reload_type secondary_type\n+    = in_p ? RELOAD_FOR_INPUT_ADDRESS : RELOAD_FOR_OUTPUT_ADDRESS;\n+  int i;\n+  int s_reload, t_reload = -1;\n+\n+  *picode = CODE_FOR_nothing;\n \n   /* If X is a pseudo-register that has an equivalent MEM (actually, if it\n      is still a pseudo-register by now, it *must* have an equivalent MEM\n@@ -346,10 +370,9 @@ find_secondary_reload (x, reload_class, reload_mode, in_p, picode, pmode,\n     class = SECONDARY_OUTPUT_RELOAD_CLASS (reload_class, reload_mode, x);\n #endif\n \n-  /* If we don't need any secondary registers, go away; the rest of the\n-     values won't be used.  */\n+  /* If we don't need any secondary registers, done.  */\n   if (class == NO_REGS)\n-    return NO_REGS;\n+    return -1;\n \n   /* Get a possible insn to use.  If the predicate doesn't accept X, don't\n      use the insn.  */\n@@ -401,13 +424,165 @@ find_secondary_reload (x, reload_class, reload_mode, in_p, picode, pmode,\n \t}\n     }\n \n-  *pmode = mode;\n-  *picode = icode;\n-  *ptertiary_class = t_class;\n-  *ptertiary_mode = t_mode;\n-  *ptertiary_icode = t_icode;\n+  /* This case isn't valid, so fail.  Reload is allowed to use the same\n+     register for RELOAD_FOR_INPUT_ADDRESS and RELOAD_FOR_INPUT reloads, but\n+     in the case of a secondary register, we actually need two different\n+     registers for correct code.  We fail here to prevent the possibility of\n+     silently generating incorrect code later.\n+\n+     The convention is that secondary input reloads are valid only if the\n+     secondary_class is different from class.  If you have such a case, you\n+     can not use secondary reloads, you must work around the problem some\n+     other way.\n+\n+     Allow this when MODE is not reload_mode and assume that the generated\n+     code handles this case (it does on the Alpha, which is the only place\n+     this currently happens).  */\n+\n+  if (in_p && class == reload_class && mode == reload_mode)\n+    abort ();\n+\n+  /* If we need a tertiary reload, see if we have one we can reuse or else\n+     make a new one.  */\n+\n+  if (t_class != NO_REGS)\n+    {\n+      for (t_reload = 0; t_reload < n_reloads; t_reload++)\n+\tif (reload_secondary_p[t_reload]\n+\t    && (reg_class_subset_p (t_class, reload_reg_class[t_reload])\n+\t\t|| reg_class_subset_p (reload_reg_class[t_reload], t_class))\n+\t    && ((in_p && reload_inmode[t_reload] == t_mode)\n+\t\t|| (! in_p && reload_outmode[t_reload] == t_mode))\n+\t    && ((in_p && (reload_secondary_in_icode[t_reload]\n+\t\t\t  == CODE_FOR_nothing))\n+\t\t|| (! in_p &&(reload_secondary_out_icode[t_reload]\n+\t\t\t      == CODE_FOR_nothing)))\n+\t    && (reg_class_size[(int) t_class] == 1\n+#ifdef SMALL_REGISTER_CLASSES\n+\t\t|| 1\n+#endif\n+\t\t)\n+\t    && MERGABLE_RELOADS (secondary_type,\n+\t\t\t\t reload_when_needed[t_reload],\n+\t\t\t\t opnum, reload_opnum[t_reload]))\n+\t  {\n+\t    if (in_p)\n+\t      reload_inmode[t_reload] = t_mode;\n+\t    if (! in_p)\n+\t      reload_outmode[t_reload] = t_mode;\n+\n+\t    if (reg_class_subset_p (t_class, reload_reg_class[t_reload]))\n+\t      reload_reg_class[t_reload] = t_class;\n+\n+\t    reload_opnum[t_reload] = MIN (reload_opnum[t_reload], opnum);\n+\t    reload_optional[t_reload] &= optional;\n+\t    reload_secondary_p[t_reload] = 1;\n+\t    if (MERGE_TO_OTHER (secondary_type, reload_when_needed[t_reload],\n+\t\t\t\topnum, reload_opnum[t_reload]))\n+\t      reload_when_needed[t_reload] = RELOAD_OTHER;\n+\t  }\n+\n+      if (t_reload == n_reloads)\n+\t{\n+\t  /* We need to make a new tertiary reload for this register class.  */\n+\t  reload_in[t_reload] = reload_out[t_reload] = 0;\n+\t  reload_reg_class[t_reload] = t_class;\n+\t  reload_inmode[t_reload] = in_p ? t_mode : VOIDmode;\n+\t  reload_outmode[t_reload] = ! in_p ? t_mode : VOIDmode;\n+\t  reload_reg_rtx[t_reload] = 0;\n+\t  reload_optional[t_reload] = optional;\n+\t  reload_inc[t_reload] = 0;\n+\t  /* Maybe we could combine these, but it seems too tricky.  */\n+\t  reload_nocombine[t_reload] = 1;\n+\t  reload_in_reg[t_reload] = 0;\n+\t  reload_opnum[t_reload] = opnum;\n+\t  reload_when_needed[t_reload] = secondary_type;\n+\t  reload_secondary_in_reload[t_reload] = -1;\n+\t  reload_secondary_out_reload[t_reload] = -1;\n+\t  reload_secondary_in_icode[t_reload] = CODE_FOR_nothing;\n+\t  reload_secondary_out_icode[t_reload] = CODE_FOR_nothing;\n+\t  reload_secondary_p[t_reload] = 1;\n+\n+\t  n_reloads++;\n+\t}\n+    }\n \n-  return class;\n+  /* See if we can reuse an existing secondary reload.  */\n+  for (s_reload = 0; s_reload < n_reloads; s_reload++)\n+    if (reload_secondary_p[s_reload]\n+\t&& (reg_class_subset_p (class, reload_reg_class[s_reload])\n+\t    || reg_class_subset_p (reload_reg_class[s_reload], class))\n+\t&& ((in_p && reload_inmode[s_reload] == mode)\n+\t    || (! in_p && reload_outmode[s_reload] == mode))\n+\t&& ((in_p && reload_secondary_in_reload[s_reload] == t_reload)\n+\t    || (! in_p && reload_secondary_out_reload[s_reload] == t_reload))\n+\t&& ((in_p && reload_secondary_in_icode[s_reload] == t_icode)\n+\t    || (! in_p && reload_secondary_out_icode[s_reload] == t_icode))\n+\t&& (reg_class_size[(int) class] == 1\n+#ifdef SMALL_REGISTER_CLASSES\n+\t    || 1\n+#endif\n+\t    )\n+\t&& MERGABLE_RELOADS (secondary_type, reload_when_needed[s_reload],\n+\t\t\t     opnum, reload_opnum[s_reload]))\n+      {\n+\tif (in_p)\n+\t  reload_inmode[s_reload] = mode;\n+\tif (! in_p)\n+\t  reload_outmode[s_reload] = mode;\n+\n+\tif (reg_class_subset_p (class, reload_reg_class[s_reload]))\n+\t  reload_reg_class[s_reload] = class;\n+\n+\treload_opnum[s_reload] = MIN (reload_opnum[s_reload], opnum);\n+\treload_optional[s_reload] &= optional;\n+\treload_secondary_p[s_reload] = 1;\n+\tif (MERGE_TO_OTHER (secondary_type, reload_when_needed[s_reload],\n+\t\t\t    opnum, reload_opnum[s_reload]))\n+\t  reload_when_needed[s_reload] = RELOAD_OTHER;\n+      }\n+\n+  if (s_reload == n_reloads)\n+    {\n+      /* We need to make a new secondary reload for this register class.  */\n+      reload_in[s_reload] = reload_out[s_reload] = 0;\n+      reload_reg_class[s_reload] = class;\n+\n+      reload_inmode[s_reload] = in_p ? mode : VOIDmode;\n+      reload_outmode[s_reload] = ! in_p ? mode : VOIDmode;\n+      reload_reg_rtx[s_reload] = 0;\n+      reload_optional[s_reload] = optional;\n+      reload_inc[s_reload] = 0;\n+      /* Maybe we could combine these, but it seems too tricky.  */\n+      reload_nocombine[s_reload] = 1;\n+      reload_in_reg[s_reload] = 0;\n+      reload_opnum[s_reload] = opnum;\n+      reload_when_needed[s_reload] = secondary_type;\n+      reload_secondary_in_reload[s_reload] = in_p ? t_reload : -1;\n+      reload_secondary_out_reload[s_reload] = ! in_p ? t_reload : -1;\n+      reload_secondary_in_icode[s_reload] = in_p ? t_icode : CODE_FOR_nothing; \n+      reload_secondary_out_icode[s_reload]\n+\t= ! in_p ? t_icode : CODE_FOR_nothing;\n+      reload_secondary_p[s_reload] = 1;\n+\n+      n_reloads++;\n+\n+#ifdef SECONDARY_MEMORY_NEEDED\n+      /* If we need a memory location to copy between the two reload regs,\n+\t set it up now.  */\n+\n+      if (in_p && icode == CODE_FOR_nothing\n+\t  && SECONDARY_MEMORY_NEEDED (class, reload_class, reload_mode))\n+\tget_secondary_mem (x, reload_mode, opnum, type);\n+\n+      if (! in_p && icode == CODE_FOR_nothing\n+\t  && SECONDARY_MEMORY_NEEDED (reload_class, class, reload_mode))\n+\tget_secondary_mem (x, reload_mode, opnum, type);\n+#endif\n+    }\n+\n+  *picode = icode;\n+  return s_reload;\n }\n #endif /* HAVE_SECONDARY_RELOADS */\n \f\n@@ -541,33 +716,8 @@ push_reload (in, out, inloc, outloc, class,\n   register int i;\n   int dont_share = 0;\n   rtx *in_subreg_loc = 0, *out_subreg_loc = 0;\n-  int secondary_reload = -1;\n-  enum insn_code secondary_icode = CODE_FOR_nothing;\n-\n-  /* Compare two RTX's.  */\n-#define MATCHES(x, y) \\\n- (x == y || (x != 0 && (GET_CODE (x) == REG\t\t\t\t\\\n-\t\t\t? GET_CODE (y) == REG && REGNO (x) == REGNO (y)\t\\\n-\t\t\t: rtx_equal_p (x, y) && ! side_effects_p (x))))\n-\n-  /* Indicates if two reloads purposes are for similar enough things that we\n-     can merge their reloads.  */\n-#define MERGABLE_RELOADS(when1, when2, op1, op2) \\\n-  ((when1) == RELOAD_OTHER || (when2) == RELOAD_OTHER\t\\\n-   || ((when1) == (when2) && (op1) == (op2))\t\t\\\n-   || ((when1) == RELOAD_FOR_INPUT && (when2) == RELOAD_FOR_INPUT) \\\n-   || ((when1) == RELOAD_FOR_OPERAND_ADDRESS\t\t\\\n-       && (when2) == RELOAD_FOR_OPERAND_ADDRESS)\t\\\n-   || ((when1) == RELOAD_FOR_OTHER_ADDRESS\t\t\\\n-       && (when2) == RELOAD_FOR_OTHER_ADDRESS))\n-\n-  /* Nonzero if these two reload purposes produce RELOAD_OTHER when merged.  */\n-#define MERGE_TO_OTHER(when1, when2, op1, op2) \\\n-  ((when1) != (when2)\t\t\t\t\t\\\n-   || ! ((op1) == (op2)\t\t\t\t\t\\\n-\t || (when1) == RELOAD_FOR_INPUT\t\t\t\\\n-\t || (when1) == RELOAD_FOR_OPERAND_ADDRESS\t\\\n-\t || (when1) == RELOAD_FOR_OTHER_ADDRESS))\n+  int secondary_in_reload = -1, secondary_out_reload = -1;\n+  enum insn_code secondary_in_icode, secondary_out_icode;\n \n   /* INMODE and/or OUTMODE could be VOIDmode if no mode\n      has been specified for the operand.  In that case,\n@@ -932,255 +1082,28 @@ push_reload (in, out, inloc, outloc, class,\n \n   if (i == n_reloads)\n     {\n-#ifdef HAVE_SECONDARY_RELOADS\n-      enum reg_class secondary_class = NO_REGS;\n-      enum reg_class secondary_out_class = NO_REGS;\n-      enum machine_mode secondary_mode = inmode;\n-      enum machine_mode secondary_out_mode = outmode;\n-      enum insn_code secondary_icode;\n-      enum insn_code secondary_out_icode = CODE_FOR_nothing;\n-      enum reg_class tertiary_class = NO_REGS;\n-      enum reg_class tertiary_out_class = NO_REGS;\n-      enum machine_mode tertiary_mode;\n-      enum machine_mode tertiary_out_mode;\n-      enum insn_code tertiary_icode;\n-      enum insn_code tertiary_out_icode = CODE_FOR_nothing;\n-      int tertiary_reload = -1;\n-\n-      /* See if we need a secondary reload register to move between\n-\t CLASS and IN or CLASS and OUT.  Get the modes and icodes to\n-\t use for each of them if so.  */\n+      /* See if we need a secondary reload register to move between CLASS\n+\t and IN or CLASS and OUT.  Get the icode and push any required reloads\n+\t needed for each of them if so.  */\n \n #ifdef SECONDARY_INPUT_RELOAD_CLASS\n       if (in != 0)\n-\tsecondary_class\n-\t  = find_secondary_reload (in, class, inmode, 1, &secondary_icode,\n-\t\t\t\t   &secondary_mode, &tertiary_class,\n-\t\t\t\t   &tertiary_icode, &tertiary_mode);\n+\tsecondary_in_reload\n+\t  = push_secondary_reload (1, in, opnum, optional, class, inmode, type,\n+\t\t\t\t   &secondary_in_icode);\n #endif\n \n #ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n       if (out != 0 && GET_CODE (out) != SCRATCH)\n-\tsecondary_out_class\n-\t  = find_secondary_reload (out, class, outmode, 0,\n-\t\t\t\t   &secondary_out_icode, &secondary_out_mode,\n-\t\t\t\t   &tertiary_out_class, &tertiary_out_icode,\n-\t\t\t\t   &tertiary_out_mode);\n-#endif\n-\n-      /* We can only record one secondary and one tertiary reload.  If both\n-\t IN and OUT need secondary reloads, we can only make an in-out\n-\t reload if neither need an insn and if the classes are compatible.\n-\t If they aren't, all we can do is abort since making two separate\n-\t reloads is invalid.  */\n-\n-      if (secondary_class != NO_REGS && secondary_out_class != NO_REGS\n-\t  && reg_class_subset_p (secondary_out_class, secondary_class))\n-\tsecondary_class = secondary_out_class;\n-\n-      if (secondary_class != NO_REGS && secondary_out_class != NO_REGS\n-\t  && (! reg_class_subset_p (secondary_class, secondary_out_class)\n-\t      || secondary_icode != CODE_FOR_nothing\n-\t      || secondary_out_icode != CODE_FOR_nothing))\n-\tabort ();\n-\n-      /* If we need a secondary reload for OUT but not IN, copy the\n-\t information.  */\n-      if (secondary_class == NO_REGS && secondary_out_class != NO_REGS)\n-\t{\n-\t  secondary_class = secondary_out_class;\n-\t  secondary_icode = secondary_out_icode;\n-\t  tertiary_class = tertiary_out_class;\n-\t  tertiary_icode = tertiary_out_icode;\n-\t  tertiary_mode = tertiary_out_mode;\n-\t}\n-\n-      if (secondary_class != NO_REGS)\n-\t{\n-\t  /* Secondary reloads don't conflict as badly as the primary object\n-\t     being reload.  Specifically, we can always treat them as\n-\t     being for an input or output address and hence allowed to be\n-\t     reused in the same manner such address components could be\n-\t     reused.  This is used as the reload_type for our secondary\n-\t     reloads.  */\n-\n-\t  enum reload_type secondary_type\n-\t    = (type == RELOAD_FOR_INPUT ? RELOAD_FOR_INPUT_ADDRESS\n-\t       : type == RELOAD_FOR_OUTPUT ? RELOAD_FOR_OUTPUT_ADDRESS\n-\t       : type);\n-\n-\t  /* This case isn't valid, so fail.  Reload is allowed to use the\n-\t     same register for RELOAD_FOR_INPUT_ADDRESS and RELOAD_FOR_INPUT\n-\t     reloads, but in the case of a secondary register, we actually\n-\t     need two different registers for correct code.  We fail here\n-\t     to prevent the possibility of silently generating incorrect code\n-\t     later.\n-\n-\t     The convention is that secondary input reloads are valid only if\n-\t     the secondary_class is different from class.  If you have such\n-\t     a case, you can not use secondary reloads, you must work around\n-\t     the problem some other way.\n-\n-\t     Allow this when secondary_mode is not inmode and assume that\n-\t     the generated code handles this case (it does on the Alpha, which\n-\t     is the only place this currently happens).  */\n-\n-\t  if (type == RELOAD_FOR_INPUT && secondary_class == class\n-\t      && secondary_mode == inmode)\n-\t    abort ();\n-\n-\t  /* If we need a tertiary reload, see if we have one we can reuse\n-\t     or else make one.  */\n-\n-\t  if (tertiary_class != NO_REGS)\n-\t    {\n-\t      for (tertiary_reload = 0; tertiary_reload < n_reloads;\n-\t\t   tertiary_reload++)\n-\t\tif (reload_secondary_p[tertiary_reload]\n-\t\t    && (reg_class_subset_p (tertiary_class,\n-\t\t\t\t\t    reload_reg_class[tertiary_reload])\n-\t\t\t|| reg_class_subset_p (reload_reg_class[tertiary_reload],\n-\t\t\t\t\t       tertiary_class))\n-\t\t    && ((reload_inmode[tertiary_reload] == tertiary_mode)\n-\t\t\t|| reload_inmode[tertiary_reload] == VOIDmode)\n-\t\t    && ((reload_outmode[tertiary_reload] == tertiary_mode)\n-\t\t\t|| reload_outmode[tertiary_reload] == VOIDmode)\n-\t\t    && (reload_secondary_icode[tertiary_reload]\n-\t\t\t== CODE_FOR_nothing)\n-\t\t    && (reg_class_size[(int) tertiary_class] == 1\n-#ifdef SMALL_REGISTER_CLASSES\n-\t\t\t|| 1\n-#endif\n-\t\t\t)\n-\t\t    && MERGABLE_RELOADS (secondary_type,\n-\t\t\t\t\t reload_when_needed[tertiary_reload],\n-\t\t\t\t\t opnum, reload_opnum[tertiary_reload]))\n-\t\t  {\n-\t\t    if (tertiary_mode != VOIDmode)\n-\t\t      reload_inmode[tertiary_reload] = tertiary_mode;\n-\t\t    if (tertiary_out_mode != VOIDmode)\n-\t\t      reload_outmode[tertiary_reload] = tertiary_mode;\n-\t\t    if (reg_class_subset_p (tertiary_class,\n-\t\t\t\t\t    reload_reg_class[tertiary_reload]))\n-\t\t      reload_reg_class[tertiary_reload] = tertiary_class;\n-\t\t    if (MERGE_TO_OTHER (secondary_type,\n-\t\t\t\t\treload_when_needed[tertiary_reload],\n-\t\t\t\t\topnum,\n-\t\t\t\t\treload_opnum[tertiary_reload]))\n-\t\t      reload_when_needed[tertiary_reload] = RELOAD_OTHER;\n-\t\t    reload_opnum[tertiary_reload]\n-\t\t      = MIN (reload_opnum[tertiary_reload], opnum);\n-\t\t    reload_optional[tertiary_reload] &= optional;\n-\t\t    reload_secondary_p[tertiary_reload] = 1;\n-\t\t  }\n-\n-\t      if (tertiary_reload == n_reloads)\n-\t\t{\n-\t\t  /* We need to make a new tertiary reload for this register\n-\t\t     class.  */\n-\t\t  reload_in[tertiary_reload] = reload_out[tertiary_reload] = 0;\n-\t\t  reload_reg_class[tertiary_reload] = tertiary_class;\n-\t\t  reload_inmode[tertiary_reload] = tertiary_mode;\n-\t\t  reload_outmode[tertiary_reload] = tertiary_mode;\n-\t\t  reload_reg_rtx[tertiary_reload] = 0;\n-\t\t  reload_optional[tertiary_reload] = optional;\n-\t\t  reload_inc[tertiary_reload] = 0;\n-\t\t  /* Maybe we could combine these, but it seems too tricky.  */\n-\t\t  reload_nocombine[tertiary_reload] = 1;\n-\t\t  reload_in_reg[tertiary_reload] = 0;\n-\t\t  reload_opnum[tertiary_reload] = opnum;\n-\t\t  reload_when_needed[tertiary_reload] = secondary_type;\n-\t\t  reload_secondary_reload[tertiary_reload] = -1;\n-\t\t  reload_secondary_icode[tertiary_reload] = CODE_FOR_nothing;\n-\t\t  reload_secondary_p[tertiary_reload] = 1;\n-\n-\t\t  n_reloads++;\n-\t\t  i = n_reloads;\n-\t\t}\n-\t    }\n-\n-\t  /* See if we can reuse an existing secondary reload.  */\n-\t  for (secondary_reload = 0; secondary_reload < n_reloads;\n-\t       secondary_reload++)\n-\t    if (reload_secondary_p[secondary_reload]\n-\t\t&& (reg_class_subset_p (secondary_class,\n-\t\t\t\t\treload_reg_class[secondary_reload])\n-\t\t    || reg_class_subset_p (reload_reg_class[secondary_reload],\n-\t\t\t\t\t   secondary_class))\n-\t\t&& ((reload_inmode[secondary_reload] == secondary_mode)\n-\t\t    || reload_inmode[secondary_reload] == VOIDmode)\n-\t\t&& ((reload_outmode[secondary_reload] == secondary_out_mode)\n-\t\t    || reload_outmode[secondary_reload] == VOIDmode)\n-\t\t&& reload_secondary_reload[secondary_reload] == tertiary_reload\n-\t\t&& reload_secondary_icode[secondary_reload] == tertiary_icode\n-\t\t&& (reg_class_size[(int) secondary_class] == 1\n-#ifdef SMALL_REGISTER_CLASSES\n-\t\t    || 1\n-#endif\n-\t\t    )\n-\t\t&& MERGABLE_RELOADS (secondary_type,\n-\t\t\t\t     reload_when_needed[secondary_reload],\n-\t\t\t\t     opnum, reload_opnum[secondary_reload]))\n-\t      {\n-\t\tif (secondary_mode != VOIDmode)\n-\t\t  reload_inmode[secondary_reload] = secondary_mode;\n-\t\tif (secondary_out_mode != VOIDmode)\n-\t\t  reload_outmode[secondary_reload] = secondary_out_mode;\n-\t\tif (reg_class_subset_p (secondary_class,\n-\t\t\t\t\treload_reg_class[secondary_reload]))\n-\t\t  reload_reg_class[secondary_reload] = secondary_class;\n-\t\tif (MERGE_TO_OTHER (secondary_type,\n-\t\t\t\t    reload_when_needed[secondary_reload],\n-\t\t\t\t    opnum, reload_opnum[secondary_reload]))\n-\t\t  reload_when_needed[secondary_reload] = RELOAD_OTHER;\n-\t\treload_opnum[secondary_reload]\n-\t\t  = MIN (reload_opnum[secondary_reload], opnum);\n-\t\treload_optional[secondary_reload] &= optional;\n-\t\treload_secondary_p[secondary_reload] = 1;\n-\t      }\n-\n-\t  if (secondary_reload == n_reloads)\n-\t    {\n-\t      /* We need to make a new secondary reload for this register\n-\t\t class.  */\n-\t      reload_in[secondary_reload] = reload_out[secondary_reload] = 0;\n-\t      reload_reg_class[secondary_reload] = secondary_class;\n-\t      reload_inmode[secondary_reload] = secondary_mode;\n-\t      reload_outmode[secondary_reload] = secondary_out_mode;\n-\t      reload_reg_rtx[secondary_reload] = 0;\n-\t      reload_optional[secondary_reload] = optional;\n-\t      reload_inc[secondary_reload] = 0;\n-\t      /* Maybe we could combine these, but it seems too tricky.  */\n-\t      reload_nocombine[secondary_reload] = 1;\n-\t      reload_in_reg[secondary_reload] = 0;\n-\t      reload_opnum[secondary_reload] = opnum;\n-\t      reload_when_needed[secondary_reload] = secondary_type;\n-\t      reload_secondary_reload[secondary_reload] = tertiary_reload;\n-\t      reload_secondary_icode[secondary_reload] = tertiary_icode;\n-\t      reload_secondary_p[secondary_reload] = 1;\n-\n-\t      n_reloads++;\n-\t      i = n_reloads;\n-\n-#ifdef SECONDARY_MEMORY_NEEDED\n-\t      /* If we need a memory location to copy between the two\n-\t\t reload regs, set it up now.  */\n-\n-\t      if (in != 0 && secondary_icode == CODE_FOR_nothing\n-\t\t  && SECONDARY_MEMORY_NEEDED (secondary_class, class, inmode))\n-\t\tget_secondary_mem (in, inmode, opnum, type);\n-\n-\t      if (out != 0 && secondary_icode == CODE_FOR_nothing\n-\t\t  && SECONDARY_MEMORY_NEEDED (class, secondary_class, outmode))\n-\t\tget_secondary_mem (out, outmode, opnum, type);\n-#endif\n-\t    }\n-\t}\n+\tsecondary_out_reload\n+\t  = push_secondary_reload (0, out, opnum, optional, class, outmode,\n+\t\t\t\t   type, &secondary_out_icode);\n #endif\n \n       /* We found no existing reload suitable for re-use.\n \t So add an additional reload.  */\n \n+      i = n_reloads;\n       reload_in[i] = in;\n       reload_out[i] = out;\n       reload_reg_class[i] = class;\n@@ -1193,8 +1116,10 @@ push_reload (in, out, inloc, outloc, class,\n       reload_in_reg[i] = inloc ? *inloc : 0;\n       reload_opnum[i] = opnum;\n       reload_when_needed[i] = type;\n-      reload_secondary_reload[i] = secondary_reload;\n-      reload_secondary_icode[i] = secondary_icode;\n+      reload_secondary_in_reload[i] = secondary_in_reload;\n+      reload_secondary_out_reload[i] = secondary_out_reload;\n+      reload_secondary_in_icode[i] = secondary_in_icode;\n+      reload_secondary_out_icode[i] = secondary_out_icode;\n       reload_secondary_p[i] = 0;\n \n       n_reloads++;\n@@ -1470,12 +1395,9 @@ combine_reloads ()\n \t\t\t\treload_outmode[output_reload]))\n \t&& reload_inc[i] == 0\n \t&& reload_reg_rtx[i] == 0\n-\t/* Don't combine two reloads with different secondary reloads. */\n-\t&& (reload_secondary_reload[i] == reload_secondary_reload[output_reload]\n-\t    || reload_secondary_reload[i] == -1\n-\t    || reload_secondary_reload[output_reload] == -1)\n #ifdef SECONDARY_MEMORY_NEEDED\n-\t/* Likewise for different secondary memory locations.  */\n+\t/* Don't combine two reloads with different secondary\n+\t   memory locations.  */\n \t&& (secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[i]] == 0\n \t    || secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[output_reload]] == 0\n \t    || rtx_equal_p (secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[i]],\n@@ -1524,8 +1446,14 @@ combine_reloads ()\n \t/* The combined reload is needed for the entire insn.  */\n \treload_when_needed[i] = RELOAD_OTHER;\n \t/* If the output reload had a secondary reload, copy it. */\n-\tif (reload_secondary_reload[output_reload] != -1)\n-\t  reload_secondary_reload[i] = reload_secondary_reload[output_reload];\n+\tif (reload_secondary_out_reload[output_reload] != -1)\n+\t  {\n+\t    reload_secondary_out_reload[i]\n+\t      = reload_secondary_out_reload[output_reload];\n+\t    reload_secondary_out_icode[i]\n+\t      = reload_secondary_out_icode[output_reload];\n+\t  }\n+\n #ifdef SECONDARY_MEMORY_NEEDED\n \t/* Copy any secondary MEM.  */\n \tif (secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[output_reload]] != 0)"}]}