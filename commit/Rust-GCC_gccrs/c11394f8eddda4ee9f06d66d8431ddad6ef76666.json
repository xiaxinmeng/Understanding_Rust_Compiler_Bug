{"sha": "c11394f8eddda4ee9f06d66d8431ddad6ef76666", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzExMzk0ZjhlZGRkYTRlZTlmMDZkNjZkODQzMWRkYWQ2ZWY3NjY2Ng==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-05-29T20:26:41Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-05-29T20:26:41Z"}, "message": "re PR target/52941 (SH Target: Add support for movco.l / movli.l atomics on SH4A)\n\n\tPR target/52941\n\t* config/sh/predicates.md (atomic_arith_operand,\n\tatomic_logical_operand): New predicates.\n\t* config/sh/sh.c (sh_option_override): Check atomic options.\n\t* config/sh/sh.h (TARGET_ANY_ATOMIC, UNSUPPORTED_ATOMIC_OPTIONS,\n\tUNSUPPORTED_HARD_ATOMIC_CPU): New macros.\n\t(DRIVER_SELF_SPECS): Use UNSUPPORTED_ATOMIC_OPTIONS and\n\tUNSUPPORTED_HARD_ATOMIC_CPU.\n\t* config/sh/sync.md: Update description comments.\n\t(I12): New mode iterator.\n\t(fetchop_predicate, fetchop_constraint): New code attributes.\n\t(atomic_compare_and_swapsi_hard, atomic_compare_and_swap<mode>_hard,\n\tatomic_exchangesi_hard, atomic_exchange<mode>_hard,\n\tatomic_fetch_<fetchop_name>si_hard,\n\tatomic_fetch_<fetchop_name><mode>_hard,\n\tatomic_fetch_nandsi_hard, atomic_fetch_nand<mode>_hard,\n\tatomic_<fetchop_name>_fetchsi_hard,\n\tatomic_<fetchop_name>_fetch<mode>_hard,\n\tatomic_nand_fetchsi_hard, atomic_nand_fetch<mode>_hard,\n\tatomic_test_and_set_hard): New insns.\n\t(atomic_compare_and_swap<mode>_soft, atomic_exchange<mode>_soft,\n\tatomic_fetch_<fetchop_name><mode>_soft, atomic_fetch_nand<mode>_soft,\n\tatomic_<fetchop_name>_fetch<mode>_soft, atomic_nand_fetch<mode>_soft,\n\tatomic_test_and_set_soft): Use same formatting for the first line of\n\tthe asm block as in new insns above.\n\t(atomic_compare_and_swap<mode>, atomic_exchange<mode>,\n\tatomic_fetch_<fetchop_name><mode>, atomic_<fetchop_name>_fetch<mode>,\n\tatomic_test_and_set): Integrate new *_hard insns into expanders.\n\t* config/sh/sh.opt (mhard-atomic): New option.\n\t* doc/invoke.texi (SH Options): Document it.\n\nFrom-SVN: r187987", "tree": {"sha": "76356e565c5926add00d238c3ec6c9fe0bd95e27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76356e565c5926add00d238c3ec6c9fe0bd95e27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c11394f8eddda4ee9f06d66d8431ddad6ef76666", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c11394f8eddda4ee9f06d66d8431ddad6ef76666", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c11394f8eddda4ee9f06d66d8431ddad6ef76666", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c11394f8eddda4ee9f06d66d8431ddad6ef76666/comments", "author": null, "committer": null, "parents": [{"sha": "556861b25c68086638d9ffe35c3a0ee61f00312f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/556861b25c68086638d9ffe35c3a0ee61f00312f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/556861b25c68086638d9ffe35c3a0ee61f00312f"}], "stats": {"total": 637, "additions": 580, "deletions": 57}, "files": [{"sha": "26382f61cabca5e22a618a5d6a41eb686ad90645", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11394f8eddda4ee9f06d66d8431ddad6ef76666/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11394f8eddda4ee9f06d66d8431ddad6ef76666/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c11394f8eddda4ee9f06d66d8431ddad6ef76666", "patch": "@@ -1,3 +1,36 @@\n+2012-05-29  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/52941\n+\t* config/sh/predicates.md (atomic_arith_operand,\n+\tatomic_logical_operand): New predicates.\n+\t* config/sh/sh.c (sh_option_override): Check atomic options.\n+\t* config/sh/sh.h (TARGET_ANY_ATOMIC, UNSUPPORTED_ATOMIC_OPTIONS,\n+\tUNSUPPORTED_HARD_ATOMIC_CPU): New macros.\n+\t(DRIVER_SELF_SPECS): Use UNSUPPORTED_ATOMIC_OPTIONS and\n+\tUNSUPPORTED_HARD_ATOMIC_CPU.\n+\t* config/sh/sync.md: Update description comments.\n+\t(I12): New mode iterator.\n+\t(fetchop_predicate, fetchop_constraint): New code attributes.\n+\t(atomic_compare_and_swapsi_hard, atomic_compare_and_swap<mode>_hard,\n+\tatomic_exchangesi_hard, atomic_exchange<mode>_hard,\n+\tatomic_fetch_<fetchop_name>si_hard,\n+\tatomic_fetch_<fetchop_name><mode>_hard,\n+\tatomic_fetch_nandsi_hard, atomic_fetch_nand<mode>_hard,\n+\tatomic_<fetchop_name>_fetchsi_hard,\n+\tatomic_<fetchop_name>_fetch<mode>_hard,\n+\tatomic_nand_fetchsi_hard, atomic_nand_fetch<mode>_hard,\n+\tatomic_test_and_set_hard): New insns.\n+\t(atomic_compare_and_swap<mode>_soft, atomic_exchange<mode>_soft,\n+\tatomic_fetch_<fetchop_name><mode>_soft, atomic_fetch_nand<mode>_soft,\n+\tatomic_<fetchop_name>_fetch<mode>_soft, atomic_nand_fetch<mode>_soft,\n+\tatomic_test_and_set_soft): Use same formatting for the first line of\n+\tthe asm block as in new insns above.\n+\t(atomic_compare_and_swap<mode>, atomic_exchange<mode>,\n+\tatomic_fetch_<fetchop_name><mode>, atomic_<fetchop_name>_fetch<mode>,\n+\tatomic_test_and_set): Integrate new *_hard insns into expanders.\n+\t* config/sh/sh.opt (mhard-atomic): New option.\n+\t* doc/invoke.texi (SH Options): Document it.\n+\n 2012-05-29  Meador Inge  <meadori@codesourcery.com>\n \n \t* c-decl.c (c_push_function_context): Always create a new language"}, {"sha": "f75675ec0964cb74f5b82364c0f56d785a408032", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11394f8eddda4ee9f06d66d8431ddad6ef76666/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11394f8eddda4ee9f06d66d8431ddad6ef76666/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=c11394f8eddda4ee9f06d66d8431ddad6ef76666", "patch": "@@ -879,3 +879,22 @@\n     }\n   return 0;\n })\n+\n+;; The atomic_* operand predicates are used for the atomic patterns.\n+;; Depending on the particular pattern some operands can be immediate\n+;; values.  Using these predicates avoids the usage of 'force_reg' in the\n+;; expanders.\n+(define_predicate \"atomic_arith_operand\"\n+  (ior (match_code \"subreg,reg\")\n+       (and (match_test \"satisfies_constraint_I08 (op)\")\n+\t    (match_test \"mode != QImode\")\n+\t    (match_test \"mode != HImode\")\n+\t    (match_test \"TARGET_SH4A_ARCH\"))))\n+\n+(define_predicate \"atomic_logical_operand\"\n+  (ior (match_code \"subreg,reg\")\n+       (and (match_test \"satisfies_constraint_K08 (op)\")\n+\t    (match_test \"mode != QImode\")\n+\t    (match_test \"mode != HImode\")\n+\t    (match_test \"TARGET_SH4A_ARCH\"))))\n+"}, {"sha": "3c9a7e9398cfb48da0903f82878f33d134041409", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11394f8eddda4ee9f06d66d8431ddad6ef76666/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11394f8eddda4ee9f06d66d8431ddad6ef76666/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=c11394f8eddda4ee9f06d66d8431ddad6ef76666", "patch": "@@ -882,6 +882,14 @@ sh_option_override (void)\n   /* This target defaults to strict volatile bitfields.  */\n   if (flag_strict_volatile_bitfields < 0 && abi_version_at_least(2))\n     flag_strict_volatile_bitfields = 1;\n+\n+  /* Make sure that only one atomic mode is selected and that the selection\n+     is valid for the current target CPU.  */\n+  if (TARGET_SOFT_ATOMIC && TARGET_HARD_ATOMIC)\n+    error (\"-msoft-atomic and -mhard-atomic cannot be used at the same time\");\n+  if (TARGET_HARD_ATOMIC && ! TARGET_SH4A_ARCH)\n+    error (\"-mhard-atomic is only available for SH4A targets\");\n+\n }\n \f\n /* Print the operand address in x to the stream.  */"}, {"sha": "b5f20f90558aad74fa93c5f19422a5e4c35ec674", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11394f8eddda4ee9f06d66d8431ddad6ef76666/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11394f8eddda4ee9f06d66d8431ddad6ef76666/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=c11394f8eddda4ee9f06d66d8431ddad6ef76666", "patch": "@@ -172,6 +172,9 @@ do { \\\n   (TARGET_SH1 && ! TARGET_SH2E && ! TARGET_SH5 \\\n    && ! (TARGET_HITACHI || sh_attr_renesas_p (FUN_DECL)))\n \n+/* Nonzero if either soft or hard atomics are enabled.  */\n+#define TARGET_ANY_ATOMIC (TARGET_SOFT_ATOMIC | TARGET_HARD_ATOMIC)\n+\n #ifndef TARGET_CPU_DEFAULT\n #define TARGET_CPU_DEFAULT SELECT_SH1\n #define SUPPORT_SH1 1\n@@ -433,7 +436,20 @@ do { \\\n \"%{m2a*:%eSH2a does not support little-endian}}\"\n #endif\n \n-#define DRIVER_SELF_SPECS UNSUPPORTED_SH2A\n+#define UNSUPPORTED_ATOMIC_OPTIONS \\\n+\"%{msoft-atomic:%{mhard-atomic:%e-msoft-atomic and -mhard-atomic cannot be \\\n+used at the same time}}\"\n+\n+#if TARGET_CPU_DEFAULT & MASK_SH4A\n+#define UNSUPPORTED_HARD_ATOMIC_CPU \"\"\n+#else\n+#define UNSUPPORTED_HARD_ATOMIC_CPU \\\n+\"%{!m4a*:%{mhard-atomic:%e-mhard-atomic is only available for SH4A targets}}\"\n+#endif\n+\n+#undef DRIVER_SELF_SPECS\n+#define DRIVER_SELF_SPECS UNSUPPORTED_SH2A, UNSUPPORTED_ATOMIC_OPTIONS,\\\n+\t\t\t  UNSUPPORTED_HARD_ATOMIC_CPU\n \n #define ASSEMBLER_DIALECT assembler_dialect\n "}, {"sha": "6a78d04ed109c71ad9b72906b9150e83c75cae1e", "filename": "gcc/config/sh/sh.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11394f8eddda4ee9f06d66d8431ddad6ef76666/gcc%2Fconfig%2Fsh%2Fsh.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11394f8eddda4ee9f06d66d8431ddad6ef76666/gcc%2Fconfig%2Fsh%2Fsh.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.opt?ref=c11394f8eddda4ee9f06d66d8431ddad6ef76666", "patch": "@@ -321,7 +321,11 @@ Follow Renesas (formerly Hitachi) / SuperH calling conventions\n \n msoft-atomic\n Target Report Var(TARGET_SOFT_ATOMIC)\n-Use software atomic sequences supported by kernel\n+Use gUSA software atomic sequences\n+\n+mhard-atomic\n+Target Report Var(TARGET_HARD_ATOMIC)\n+Use hardware atomic sequences\n \n menable-tas\n Target Report RejectNegative Var(TARGET_ENABLE_TAS)"}, {"sha": "79cd765d87f2be1395d18da18157a025e9199d78", "filename": "gcc/config/sh/sync.md", "status": "modified", "additions": 484, "deletions": 53, "changes": 537, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11394f8eddda4ee9f06d66d8431ddad6ef76666/gcc%2Fconfig%2Fsh%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11394f8eddda4ee9f06d66d8431ddad6ef76666/gcc%2Fconfig%2Fsh%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsync.md?ref=c11394f8eddda4ee9f06d66d8431ddad6ef76666", "patch": "@@ -21,10 +21,42 @@\n ;;\n ;; Atomic integer operations for the Renesas / SuperH SH CPUs.\n ;;\n+;; On SH CPUs atomic integer operations can be done either in 'software' or\n+;; in 'hardware', where true hardware support was introduced with the SH4A.\n+;; In addition to that all SH CPUs support the 'tas.b' instruction, which\n+;; can be optionally used to implement the 'atomic_test_and_set' builtin.\n+;;\n+;; tas.b atomic_test_and_set (-menable-tas)\n+;;\n+;; Depending on the particular hardware configuration, usage of the 'tas.b'\n+;; instruction might be undesired or even unsafe.  Thus, it has to be\n+;; enabled by the user explicitely.  If it is not enabled, the\n+;; 'atomic_test_and_set' builtin is implemented either with hardware or with\n+;; software atomics, depending on which is enabled.  It is also possible to\n+;; enable the 'tas.b' instruction only, without enabling support for the \n+;; other atomic operations.\n+;;\n+;;\n+;; Hardware Atomics (-mhard-atomic, SH4A only)\n+;;\n+;; Hardware atomics implement all atomic operations using the 'movli.l' and\n+;; 'movco.l' instructions that are availble on SH4A.  On multi-core hardware\n+;; configurations hardware atomics is the only safe mode.\n+;; However, it can also be safely used on single-core configurations.\n+;; Since these instructions operate on SImode memory only, QImode and HImode\n+;; have to be emulated with SImode and subreg masking, which results in\n+;; larger code.\n+;;\n+;;\n+;; Software Atomics (-msoft-atomic)\n+;;\n ;; On single-core systems there can only be one execution context running\n ;; at a given point in time.  This allows the usage of rewindable atomic\n ;; sequences, which effectively emulate locked-load / conditional-store\n-;; operations.\n+;; operations.  This requires complementary support in the interrupt / \n+;; exception handling code (e.g. kernel) and does not work safely on multi-\n+;; core configurations.\n+;;\n ;; When an execution context is interrupted while it is an atomic\n ;; sequence, the interrupted context's PC is rewound to the beginning of\n ;; the atomic sequence by the interrupt / exception handling code, before\n@@ -79,15 +111,16 @@\n ;; For correct operation the atomic sequences must not be rewound after\n ;; they have passed the write-back instruction.\n ;;\n-;; The current implementation is limited to QImode, HImode and SImode \n+;; The current atomic support is limited to QImode, HImode and SImode \n ;; atomic operations.  DImode operations could also be implemented but\n ;; would require some ABI modifications to support multiple-instruction\n ;; write-back.  This is because SH1/SH2/SH3/SH4 does not have a DImode\n ;; store instruction.  DImode stores must be split into two SImode stores.\n ;;\n-;; For some operations it would be possible to use insns with an immediate\n-;; operand such as add #imm,Rn.  However, since the original value before\n-;; the operation also needs to be available, this is not so handy.\n+;; On single-core SH4A CPUs software atomic aware interrupt / exception code\n+;; is actually compatible with user code that utilizes hardware atomics.\n+;; Since SImode hardware atomic sequences are more compact on SH4A they are\n+;; always used, regardless of the selected atomic mode.\n \n (define_c_enum \"unspec\" [\n   UNSPEC_ATOMIC\n@@ -100,6 +133,7 @@\n ])\n \n (define_mode_iterator I124 [QI HI SI])\n+(define_mode_iterator I12 [QI HI])\n \n (define_mode_attr i124suffix [(QI \"b\") (HI \"w\") (SI \"l\")])\n (define_mode_attr i124extend_insn [(QI \"exts.b\") (HI \"exts.w\") (SI \"mov\")])\n@@ -108,23 +142,42 @@\n (define_code_attr fetchop_name\n   [(plus \"add\") (minus \"sub\") (ior \"or\") (xor \"xor\") (and \"and\")])\n \n+(define_code_attr fetchop_predicate\n+  [(plus \"atomic_arith_operand\") (minus \"register_operand\")\n+   (ior \"atomic_logical_operand\") (xor \"atomic_logical_operand\")\n+   (and \"atomic_logical_operand\")])\n+\n+(define_code_attr fetchop_constraint\n+  [(plus \"rI08\") (minus \"r\") (ior \"rK08\") (xor \"rK08\") (and \"rK08\")])\n+\n+;;------------------------------------------------------------------------------\n+;; comapre and swap\n+\n (define_expand \"atomic_compare_and_swap<mode>\"\n   [(match_operand:SI 0 \"register_operand\" \"\")\t\t;; bool success output\n    (match_operand:I124 1 \"register_operand\" \"\")\t\t;; oldval output\n    (match_operand:I124 2 \"memory_operand\" \"\")\t\t;; memory\n-   (match_operand:I124 3 \"register_operand\" \"\")\t\t;; expected input\n-   (match_operand:I124 4 \"register_operand\" \"\")\t\t;; newval input\n+   (match_operand:I124 3 \"atomic_arith_operand\" \"\")\t;; expected input\n+   (match_operand:I124 4 \"atomic_arith_operand\" \"\")\t;; newval input\n    (match_operand:SI 5 \"const_int_operand\" \"\")\t\t;; is_weak\n    (match_operand:SI 6 \"const_int_operand\" \"\")\t\t;; success model\n    (match_operand:SI 7 \"const_int_operand\" \"\")]\t\t;; failure model\n-  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ANY_ATOMIC && !TARGET_SHMEDIA\"\n {\n-  rtx addr;\n+  rtx addr = force_reg (Pmode, XEXP (operands[2], 0));\n+  rtx old_val = gen_lowpart (SImode, operands[1]);\n+  rtx exp_val = operands[3];\n+  rtx new_val = operands[4];\n+  rtx atomic_insn;\n+\n+  if (TARGET_HARD_ATOMIC || (TARGET_SH4A_ARCH && <MODE>mode == SImode))\n+      atomic_insn = gen_atomic_compare_and_swap<mode>_hard (old_val, addr,\n+\t\t\t\t\t\t\t    exp_val, new_val);\n+  else\n+      atomic_insn = gen_atomic_compare_and_swap<mode>_soft (old_val, addr,\n+\t\t\t\t\t\t\t    exp_val, new_val);\n+  emit_insn (atomic_insn);\n \n-  addr = force_reg (Pmode, XEXP (operands[2], 0));\n-  emit_insn (gen_atomic_compare_and_swap<mode>_soft\n-\t     (gen_lowpart (SImode, operands[1]), addr, operands[3],\n-\t      operands[4]));\n   if (<MODE>mode == QImode)\n     emit_insn (gen_zero_extendqisi2 (gen_lowpart (SImode, operands[1]),\n \t\t\t\t     operands[1]));\n@@ -135,6 +188,67 @@\n   DONE;\n })\n \n+(define_insn \"atomic_compare_and_swapsi_hard\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(unspec_volatile:SI\n+\t  [(mem:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t   (match_operand:SI 2 \"arith_operand\" \"rI08\")\n+\t   (match_operand:SI 3 \"arith_operand\" \"rI08\")]\n+\t  UNSPECV_CMPXCHG_1))\n+   (set (mem:SI (match_dup 1))\n+\t(unspec_volatile:SI [(const_int 0)] UNSPECV_CMPXCHG_2))\n+   (set (reg:SI T_REG)\n+\t(unspec_volatile:SI [(const_int 0)] UNSPECV_CMPXCHG_3))\n+   (clobber (reg:SI R0_REG))]\n+  \"TARGET_ANY_ATOMIC && TARGET_SH4A_ARCH\"\n+{\n+  return \"\\r0:\tmovli.l\t@%1,r0\"\t\t\"\\n\"\n+\t \"\tcmp/eq\t%2,r0\"\t\t\"\\n\"\n+\t \"\tbf{.|/}s\t0f\"\t\"\\n\"\n+\t \"\tmov\tr0,%0\"\t\t\"\\n\"\n+\t \"\tmov\t%3,r0\"\t\t\"\\n\"\n+\t \"\tmovco.l\tr0,@%1\"\t\t\"\\n\"\n+\t \"\tbf\t0b\"\t\t\"\\n\"\n+\t \"0:\";\n+}\n+  [(set_attr \"length\" \"14\")])\n+\n+(define_insn \"atomic_compare_and_swap<mode>_hard\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(unspec_volatile:SI\n+\t  [(mem:I12 (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t   (match_operand:I12 2 \"register_operand\" \"r\")\n+\t   (match_operand:I12 3 \"register_operand\" \"r\")]\n+\t  UNSPECV_CMPXCHG_1))\n+   (set (mem:I12 (match_dup 1))\n+\t(unspec_volatile:I12 [(const_int 0)] UNSPECV_CMPXCHG_2))\n+   (set (reg:SI T_REG)\n+\t(unspec_volatile:SI [(const_int 0)] UNSPECV_CMPXCHG_3))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (match_scratch:SI 4 \"=&r\"))\n+   (clobber (match_scratch:SI 5 \"=&r\"))\n+   (clobber (match_scratch:SI 6 \"=1\"))]\n+  \"TARGET_HARD_ATOMIC && TARGET_SH4A_ARCH\"\n+{\n+  return \"\\r\tmov\t#-4,%5\"\t\t\t\"\\n\"\n+\t \"\t<i124extend_insn>\t%2,%4\"\t\"\\n\"\n+\t \"\tand\t%1,%5\"\t\t\t\"\\n\"\n+\t \"\txor\t%5,%1\"\t\t\t\"\\n\"\n+\t \"\tadd\tr15,%1\"\t\t\t\"\\n\"\n+\t \"\tadd\t#-4,%1\"\t\t\t\"\\n\"\n+\t \"0:\tmovli.l\t@%5,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@-r15\"\t\t\"\\n\"\n+\t \"\tmov.<i124suffix>\t@%1,%0\"\t\"\\n\"\n+\t \"\tmov.<i124suffix>\t%3,@%1\" \"\\n\"\n+\t \"\tcmp/eq\t%4,%0\"\t\t\t\"\\n\"\n+\t \"\tbf{.|/}s\t0f\"\t\t\"\\n\"\n+\t \"\tmov.l\t@r15+,r0\"\t\t\"\\n\"\n+\t \"\tmovco.l\tr0,@%5\"\t\t\t\"\\n\"\n+\t \"\tbf\t0b\"\t\t\t\"\\n\"\n+\t \"0:\";\n+}\n+  [(set_attr \"length\" \"30\")])\n+\n (define_insn \"atomic_compare_and_swap<mode>_soft\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&u\")\n \t(unspec_volatile:SI\n@@ -151,7 +265,7 @@\n    (clobber (reg:SI R1_REG))]\n   \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n {\n-  return \"mova\t1f,r0\"\t\t\t\t\"\\n\"\n+  return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n \t \"\t<i124extend_insn>\t%2,%4\"\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\tr15,r1\"\t\t\t\"\\n\"\n@@ -164,16 +278,27 @@\n }\n   [(set_attr \"length\" \"20\")])\n \n+;;------------------------------------------------------------------------------\n+;; read - write - return old value\n+\n (define_expand \"atomic_exchange<mode>\"\n   [(match_operand:I124 0 \"register_operand\" \"\")\t\t;; oldval output\n    (match_operand:I124 1 \"memory_operand\" \"\")\t\t;; memory\n-   (match_operand:I124 2 \"register_operand\" \"\")\t\t;; newval input\n+   (match_operand:I124 2 \"atomic_arith_operand\" \"\")\t;; newval input\n    (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t;; memory model\n-  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ANY_ATOMIC && !TARGET_SHMEDIA\"\n {\n   rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n-  emit_insn (gen_atomic_exchange<mode>_soft\n-\t     (operands[0], addr, operands[2]));\n+  rtx val = operands[2];\n+  rtx atomic_insn;\n+\n+  if (TARGET_HARD_ATOMIC || (TARGET_SH4A_ARCH && <MODE>mode == SImode))\n+      atomic_insn = gen_atomic_exchange<mode>_hard (operands[0], addr, val);\n+  else\n+      atomic_insn = gen_atomic_exchange<mode>_soft (operands[0], addr, val);\n+\n+  emit_insn (atomic_insn);\n+\n   if (<MODE>mode == QImode)\n     emit_insn (gen_zero_extendqisi2 (gen_lowpart (SImode, operands[0]),\n \t\t\t\t     operands[0]));\n@@ -183,6 +308,49 @@\n   DONE;\n })\n \n+(define_insn \"atomic_exchangesi_hard\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(mem:SI (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (mem:SI (match_dup 1))\n+\t(unspec:SI\n+\t  [(match_operand:SI 2 \"arith_operand\" \"rI08\")] UNSPEC_ATOMIC))\n+   (clobber (reg:SI R0_REG))]\n+  \"TARGET_ANY_ATOMIC && TARGET_SH4A_ARCH\"\n+{\n+  return \"\\r0:\tmovli.l\t@%1,r0\"\t\t\"\\n\"\n+\t \"\tmov\tr0,%0\"\t\t\"\\n\"\n+\t \"\tmov\t%2,r0\"\t\t\"\\n\"\n+\t \"\tmovco.l r0,@%1\"\t\t\"\\n\"\n+\t \"\tbf\t0b\";\n+}\n+  [(set_attr \"length\" \"10\")])\n+\n+(define_insn \"atomic_exchange<mode>_hard\"\n+  [(set (match_operand:I12 0 \"register_operand\" \"=&r\")\n+\t(mem:I12 (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (mem:I12 (match_dup 1))\n+\t(unspec:I12\n+\t  [(match_operand:I12 2 \"register_operand\" \"r\")] UNSPEC_ATOMIC))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (match_scratch:SI 3 \"=&r\"))\n+   (clobber (match_scratch:SI 4 \"=1\"))]\n+  \"TARGET_HARD_ATOMIC && TARGET_SH4A_ARCH\"\n+{\n+  return \"\\r\tmov\t#-4,%3\"\t\t\t\"\\n\"\n+\t \"\tand\t%1,%3\"\t\t\t\"\\n\"\n+\t \"\txor\t%3,%1\"\t\t\t\"\\n\"\n+\t \"\tadd\tr15,%1\"\t\t\t\"\\n\"\n+\t \"\tadd\t#-4,%1\"\t\t\t\"\\n\"\n+\t \"0:\tmovli.l\t@%3,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@-r15\"\t\t\"\\n\"\n+\t \"\tmov.<i124suffix>\t@%1,%0\"\t\"\\n\"\n+\t \"\tmov.<i124suffix>\t%2,@%1\" \"\\n\"\n+\t \"\tmov.l\t@r15+,r0\"\t\t\"\\n\"\n+\t \"\tmovco.l\tr0,@%3\"\t\t\t\"\\n\"\n+\t \"\tbf\t0b\";\n+}\n+  [(set_attr \"length\" \"24\")])\n+\n (define_insn \"atomic_exchange<mode>_soft\"\n   [(set (match_operand:I124 0 \"register_operand\" \"=&u\")\n \t(mem:I124 (match_operand:SI 1 \"register_operand\" \"u\")))\n@@ -193,7 +361,7 @@\n    (clobber (reg:SI R1_REG))]\n   \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n {\n-  return \"mova\t1f,r0\"\t\t\t\t\"\\n\"\n+  return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\tr15,r1\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r15\"\t\t\"\\n\"\n@@ -203,22 +371,32 @@\n }\n   [(set_attr \"length\" \"14\")])\n \n+;;------------------------------------------------------------------------------\n+;; read - add|sub|or|and|xor|nand - write - return old value\n+\n (define_expand \"atomic_fetch_<fetchop_name><mode>\"\n   [(set (match_operand:I124 0 \"register_operand\" \"\")\n \t(match_operand:I124 1 \"memory_operand\" \"\"))\n    (set (match_dup 1)\n \t(unspec:I124\n \t  [(FETCHOP:I124 (match_dup 1)\n-\t     (match_operand:I124 2 \"register_operand\" \"\"))]\n+\t     (match_operand:I124 2 \"<fetchop_predicate>\" \"\"))]\n \t  UNSPEC_ATOMIC))\n    (match_operand:SI 3 \"const_int_operand\" \"\")]\n-  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ANY_ATOMIC && !TARGET_SHMEDIA\"\n {\n-  rtx addr;\n+  rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n+  rtx atomic_insn;\n+\n+  if (TARGET_HARD_ATOMIC || (TARGET_SH4A_ARCH && <MODE>mode == SImode))\n+    atomic_insn = gen_atomic_fetch_<fetchop_name><mode>_hard (operands[0], addr,\n+\t\t\t\t\t\t\t      operands[2]);\n+  else\n+      atomic_insn = gen_atomic_fetch_<fetchop_name><mode>_soft (operands[0],\n+\t\t\t\t\t\t\t\taddr,\n+\t\t\t\t\t\t\t\toperands[2]);\n+  emit_insn (atomic_insn);\n \n-  addr = force_reg (Pmode, XEXP (operands[1], 0));\n-  emit_insn (gen_atomic_fetch_<fetchop_name><mode>_soft\n-\t     (operands[0], addr, operands[2]));\n   if (<MODE>mode == QImode)\n     emit_insn (gen_zero_extendqisi2 (gen_lowpart (SImode, operands[0]),\n \t\t\t\t     operands[0]));\n@@ -228,6 +406,55 @@\n   DONE;\n })\n \n+(define_insn \"atomic_fetch_<fetchop_name>si_hard\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(mem:SI (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (mem:SI (match_dup 1))\n+\t(unspec:SI\n+\t  [(FETCHOP:SI (mem:SI (match_dup 1))\n+\t     (match_operand:SI 2 \"<fetchop_predicate>\" \"<fetchop_constraint>\"))]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (reg:SI R0_REG))]\n+  \"TARGET_ANY_ATOMIC && TARGET_SH4A_ARCH\"\n+{\n+  return \"\\r0:\tmovli.l\t@%1,r0\"\t\t\"\\n\"\n+\t \"\tmov\tr0,%0\"\t\t\"\\n\"\n+\t \"\t<fetchop_name>\t%2,r0\"\t\"\\n\"\n+\t \"\tmovco.l\tr0,@%1\"\t\t\"\\n\"\n+\t \"\tbf\t0b\";\n+}\n+  [(set_attr \"length\" \"10\")])\n+\n+(define_insn \"atomic_fetch_<fetchop_name><mode>_hard\"\n+  [(set (match_operand:I12 0 \"register_operand\" \"=&r\")\n+\t(mem:I12 (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (mem:I12 (match_dup 1))\n+\t(unspec:I12\n+\t  [(FETCHOP:I12 (mem:I12 (match_dup 1))\n+\t     (match_operand:I12 2 \"<fetchop_predicate>\" \"<fetchop_constraint>\"))]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (match_scratch:SI 3 \"=&r\"))\n+   (clobber (match_scratch:SI 4 \"=1\"))]\n+  \"TARGET_HARD_ATOMIC && TARGET_SH4A_ARCH\"\n+{\n+  return \"\\r\tmov\t#-4,%3\"\t\t\t\"\\n\"\n+\t \"\tand\t%1,%3\"\t\t\t\"\\n\"\n+\t \"\txor\t%3,%1\"\t\t\t\"\\n\"\n+\t \"\tadd\tr15,%1\"\t\t\t\"\\n\"\n+\t \"\tadd\t#-4,%1\"\t\t\t\"\\n\"\n+\t \"0:\tmovli.l\t@%3,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@-r15\"\t\t\"\\n\"\n+\t \"\tmov.<i124suffix>\t@%1,r0\"\t\"\\n\"\n+\t \"\tmov\tr0,%0\"\t\t\t\"\\n\"\n+\t \"\t<fetchop_name>\t%2,r0\"\t\t\"\\n\"\n+\t \"\tmov.<i124suffix>\tr0,@%1\"\t\"\\n\"\n+\t \"\tmov.l\t@r15+,r0\"\t\t\"\\n\"\n+\t \"\tmovco.l\tr0,@%3\"\t\t\t\"\\n\"\n+\t \"\tbf\t0b\";\n+}\n+  [(set_attr \"length\" \"28\")])\n+\n (define_insn \"atomic_fetch_<fetchop_name><mode>_soft\"\n   [(set (match_operand:I124 0 \"register_operand\" \"=&u\")\n \t(mem:I124 (match_operand:SI 1 \"register_operand\" \"u\")))\n@@ -241,7 +468,7 @@\n    (clobber (reg:SI R1_REG))]\n   \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n {\n-  return \"mova\t1f,r0\"\t\t\t\t\"\\n\"\n+  return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\tr15,r1\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r15\"\t\t\"\\n\"\n@@ -259,16 +486,23 @@\n    (set (match_dup 1)\n \t(unspec:I124\n \t  [(not:I124 (and:I124 (match_dup 1)\n-\t     (match_operand:I124 2 \"register_operand\" \"\")))]\n+\t\t     (match_operand:I124 2 \"atomic_logical_operand\" \"\")))]\n \t  UNSPEC_ATOMIC))\n    (match_operand:SI 3 \"const_int_operand\" \"\")]\n-  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ANY_ATOMIC && !TARGET_SHMEDIA\"\n {\n-  rtx addr;\n+  rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n+  rtx atomic_insn;\n+\n+  if (TARGET_HARD_ATOMIC || (TARGET_SH4A_ARCH && <MODE>mode == SImode))\n+    atomic_insn = gen_atomic_fetch_nand<mode>_hard (operands[0], addr,\n+\t\t\t\t\t\t    operands[2]);\n+  else\n+    atomic_insn = gen_atomic_fetch_nand<mode>_soft (operands[0], addr,\n+\t\t\t\t\t\t    operands[2]);\n+\n+  emit_insn (atomic_insn);\n \n-  addr = force_reg (Pmode, XEXP (operands[1], 0));\n-  emit_insn (gen_atomic_fetch_nand<mode>_soft\n-\t     (operands[0], addr, operands[2]));\n   if (<MODE>mode == QImode)\n     emit_insn (gen_zero_extendqisi2 (gen_lowpart (SImode, operands[0]),\n \t\t\t\t     operands[0]));\n@@ -278,6 +512,57 @@\n   DONE;\n })\n \n+(define_insn \"atomic_fetch_nandsi_hard\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(mem:SI (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (mem:SI (match_dup 1))\n+\t(unspec:SI\n+\t  [(not:SI (and:SI (mem:SI (match_dup 1))\n+\t\t   (match_operand:SI 2 \"logical_operand\" \"rK08\")))]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (reg:SI R0_REG))]\n+  \"TARGET_ANY_ATOMIC && TARGET_SH4A_ARCH\"\n+{\n+  return \"\\r0:\tmovli.l\t@%1,r0\"\t\t\"\\n\"\n+\t \"\tmov\tr0,%0\"\t\t\"\\n\"\n+\t \"\tand\t%2,r0\"\t\t\"\\n\"\n+\t \"\tnot\tr0,r0\"\t\t\"\\n\"\n+\t \"\tmovco.l\tr0,@%1\"\t\t\"\\n\"\n+\t \"\tbf\t0b\";\n+}\n+  [(set_attr \"length\" \"12\")])\n+\n+(define_insn \"atomic_fetch_nand<mode>_hard\"\n+  [(set (match_operand:I12 0 \"register_operand\" \"=&r\")\n+\t(mem:I12 (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (mem:I12 (match_dup 1))\n+\t(unspec:I12\n+\t  [(not:I12 (and:I12 (mem:I12 (match_dup 1))\n+\t\t    (match_operand:I12 2 \"logical_operand\" \"rK08\")))]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (match_scratch:SI 3 \"=&r\"))\n+   (clobber (match_scratch:SI 4 \"=1\"))]\n+  \"TARGET_HARD_ATOMIC && TARGET_SH4A_ARCH\"\n+{\n+  return \"\\r\tmov\t#-4,%3\"\t\t\t\"\\n\"\n+\t \"\tand\t%1,%3\"\t\t\t\"\\n\"\n+\t \"\txor\t%3,%1\"\t\t\t\"\\n\"\n+\t \"\tadd\tr15,%1\"\t\t\t\"\\n\"\n+\t \"\tadd\t#-4,%1\"\t\t\t\"\\n\"\n+\t \"0:\tmovli.l\t@%3,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@-r15\"\t\t\"\\n\"\n+\t \"\tmov.<i124suffix>\t@%1,r0\"\t\"\\n\"\n+\t \"\tmov\tr0,%0\"\t\t\t\"\\n\"\n+\t \"\tand\t%2,r0\"\t\t\t\"\\n\"\n+\t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.<i124suffix>\tr0,@%1\"\t\"\\n\"\n+\t \"\tmov.l\t@r15+,r0\"\t\t\"\\n\"\n+\t \"\tmovco.l\tr0,@%3\"\t\t\t\"\\n\"\n+\t \"\tbf\t0b\";\n+}\n+  [(set_attr \"length\" \"30\")])\n+\n (define_insn \"atomic_fetch_nand<mode>_soft\"\n   [(set (match_operand:I124 0 \"register_operand\" \"=&u\")\n \t(mem:I124 (match_operand:SI 1 \"register_operand\" \"u\")))\n@@ -291,7 +576,7 @@\n    (clobber (reg:SI R1_REG))]\n   \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n {\n-  return \"mova\t1f,r0\"\t\t\t\t\"\\n\"\n+  return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n \t \"\tmov\tr15,r1\"\t\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r15\"\t\t\"\\n\"\n@@ -304,23 +589,32 @@\n }\n   [(set_attr \"length\" \"20\")])\n \n+;;------------------------------------------------------------------------------\n+;; read - add|sub|or|and|xor|nand - write - return new value\n+\n (define_expand \"atomic_<fetchop_name>_fetch<mode>\"\n   [(set (match_operand:I124 0 \"register_operand\" \"\")\n \t(FETCHOP:I124\n \t  (match_operand:I124 1 \"memory_operand\" \"\")\n-\t  (match_operand:I124 2 \"register_operand\" \"\")))\n+\t  (match_operand:I124 2 \"<fetchop_predicate>\" \"\")))\n    (set (match_dup 1)\n \t(unspec:I124\n \t  [(FETCHOP:I124 (match_dup 1) (match_dup 2))]\n \t  UNSPEC_ATOMIC))\n    (match_operand:SI 3 \"const_int_operand\" \"\")]\n-  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ANY_ATOMIC && !TARGET_SHMEDIA\"\n {\n-  rtx addr;\n+  rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n+  rtx atomic_insn;\n+\n+  if (TARGET_HARD_ATOMIC || (TARGET_SH4A_ARCH && <MODE>mode == SImode))\n+    atomic_insn = gen_atomic_<fetchop_name>_fetch<mode>_hard (operands[0], addr,\n+\t\t\t\t\t\t\t      operands[2]);\n+  else\n+    atomic_insn = gen_atomic_<fetchop_name>_fetch<mode>_soft (operands[0], addr,\n+\t\t\t\t\t\t\t      operands[2]);\n+  emit_insn (atomic_insn);\n \n-  addr = force_reg (Pmode, XEXP (operands[1], 0));\n-  emit_insn (gen_atomic_<fetchop_name>_fetch<mode>_soft\n-\t     (operands[0], addr, operands[2]));\n   if (<MODE>mode == QImode)\n     emit_insn (gen_zero_extendqisi2 (gen_lowpart (SImode, operands[0]),\n \t\t\t\t     operands[0]));\n@@ -330,6 +624,56 @@\n   DONE;\n })\n \n+(define_insn \"atomic_<fetchop_name>_fetchsi_hard\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&z\")\n+\t(FETCHOP:SI\n+\t  (mem:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t  (match_operand:SI 2 \"<fetchop_predicate>\" \"<fetchop_constraint>\")))\n+   (set (mem:SI (match_dup 1))\n+\t(unspec:SI\n+\t  [(FETCHOP:SI (mem:SI (match_dup 1)) (match_dup 2))]\n+\t  UNSPEC_ATOMIC))]\n+  \"TARGET_ANY_ATOMIC && TARGET_SH4A_ARCH\"\n+{\n+  return \"\\r0:\tmovli.l\t@%1,%0\"\t\t\"\\n\"\n+\t \"\t<fetchop_name>\t%2,%0\"\t\"\\n\"\n+\t \"\tmovco.l\t%0,@%1\"\t\t\"\\n\"\n+\t \"\tbf\t0b\";\n+}\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_insn \"atomic_<fetchop_name>_fetch<mode>_hard\"\n+  [(set (match_operand:I12 0 \"register_operand\" \"=&r\")\n+\t(FETCHOP:I12\n+\t  (mem:I12 (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t  (match_operand:I12 2 \"<fetchop_predicate>\" \"<fetchop_constraint>\")))\n+   (set (mem:I12 (match_dup 1))\n+\t(unspec:I12\n+\t  [(FETCHOP:I12 (mem:I12 (match_dup 1)) (match_dup 2))]\n+\t  UNSPEC_ATOMIC))\n+\n+   (clobber (reg:SI R0_REG))\n+   (clobber (match_scratch:SI 3 \"=&r\"))\n+   (clobber (match_scratch:SI 4 \"=1\"))]\n+  \"TARGET_HARD_ATOMIC && TARGET_SH4A_ARCH\"\n+{\n+  return \"\\r\tmov\t#-4,%3\"\t\t\t\"\\n\"\n+\t \"\tand\t%1,%3\"\t\t\t\"\\n\"\n+\t \"\txor\t%3,%1\"\t\t\t\"\\n\"\n+\t \"\tadd\tr15,%1\"\t\t\t\"\\n\"\n+\t \"\tadd\t#-4,%1\"\t\t\t\"\\n\"\n+\t \"0:\tmovli.l\t@%3,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@-r15\"\t\t\"\\n\"\n+\t \"\tmov.<i124suffix>\t@%1,r0\"\t\"\\n\"\n+\t \"\t<fetchop_name>\t%2,r0\"\t\t\"\\n\"\n+\t \"\tmov.<i124suffix>\tr0,@%1\"\t\"\\n\"\n+\t \"\tmov\tr0,%0\"\t\t\t\"\\n\"\n+\t \"\tmov.l\t@r15+,r0\"\t\t\"\\n\"\n+\t \"\tmovco.l\tr0,@%3\"\t\t\t\"\\n\"\n+\t \"\tbf\t0b\";\n+}\n+  [(set_attr \"length\" \"28\")])\n+\n (define_insn \"atomic_<fetchop_name>_fetch<mode>_soft\"\n   [(set (match_operand:I124 0 \"register_operand\" \"=&u\")\n \t(FETCHOP:I124\n@@ -343,7 +687,7 @@\n    (clobber (reg:SI R1_REG))]\n   \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n {\n-  return \"mova\t1f,r0\"\t\t\t\t\"\\n\"\n+  return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n \t \"\tmov\tr15,r1\"\t\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r15\"\t\t\"\\n\"\n@@ -358,19 +702,25 @@\n   [(set (match_operand:I124 0 \"register_operand\" \"\")\n \t(not:I124 (and:I124\n \t  (match_operand:I124 1 \"memory_operand\" \"\")\n-\t  (match_operand:I124 2 \"register_operand\" \"\"))))\n+\t  (match_operand:I124 2 \"atomic_logical_operand\" \"\"))))\n    (set (match_dup 1)\n \t(unspec:I124\n \t  [(not:I124 (and:I124 (match_dup 1) (match_dup 2)))]\n \t  UNSPEC_ATOMIC))\n    (match_operand:SI 3 \"const_int_operand\" \"\")]\n-  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+  \"TARGET_ANY_ATOMIC && !TARGET_SHMEDIA\"\n {\n-  rtx addr;\n+  rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n+  rtx atomic_insn;\n+\n+  if (TARGET_HARD_ATOMIC || (TARGET_SH4A_ARCH && <MODE>mode == SImode))\n+    atomic_insn = gen_atomic_nand_fetch<mode>_hard (operands[0], addr,\n+\t\t\t\t\t\t    operands[2]);\n+  else\n+    atomic_insn = gen_atomic_nand_fetch<mode>_soft (operands[0], addr,\n+\t\t\t\t\t\t    operands[2]);\n+  emit_insn (atomic_insn);\n \n-  addr = force_reg (Pmode, XEXP (operands[1], 0));\n-  emit_insn (gen_atomic_nand_fetch<mode>_soft\n-\t     (operands[0], addr, operands[2]));\n   if (<MODE>mode == QImode)\n     emit_insn (gen_zero_extendqisi2 (gen_lowpart (SImode, operands[0]),\n \t\t\t\t     operands[0]));\n@@ -380,6 +730,54 @@\n   DONE;\n })\n \n+(define_insn \"atomic_nand_fetchsi_hard\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&z\")\n+\t(not:SI (and:SI (mem:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t\t(match_operand:SI 2 \"logical_operand\" \"rK08\"))))\n+   (set (mem:SI (match_dup 1))\n+\t(unspec:SI\n+\t  [(not:SI (and:SI (mem:SI (match_dup 1)) (match_dup 2)))]\n+\t  UNSPEC_ATOMIC))]\n+  \"TARGET_ANY_ATOMIC && TARGET_SH4A_ARCH\"\n+{\n+  return \"\\r0:\tmovli.l\t@%1,%0\"\t\t\"\\n\"\n+\t \"\tand\t%2,%0\"\t\t\"\\n\"\n+\t \"\tnot\t%0,%0\"\t\t\"\\n\"\n+\t \"\tmovco.l\t%0,@%1\"\t\t\"\\n\"\n+\t \"\tbf\t0b\";\n+}\n+  [(set_attr \"length\" \"10\")])\n+\n+(define_insn \"atomic_nand_fetch<mode>_hard\"\n+  [(set (match_operand:I12 0 \"register_operand\" \"=&r\")\n+\t(not:I12 (and:I12 (mem:I12 (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t\t  (match_operand:I12 2 \"logical_operand\" \"rK08\"))))\n+   (set (mem:I12 (match_dup 1))\n+\t(unspec:I12\n+\t  [(not:I12 (and:I12 (mem:I12 (match_dup 1)) (match_dup 2)))]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (match_scratch:SI 3 \"=&r\"))\n+   (clobber (match_scratch:SI 4 \"=1\"))]\n+  \"TARGET_HARD_ATOMIC && TARGET_SH4A_ARCH\"\n+{\n+  return \"\\r\tmov\t#-4,%3\"\t\t\t\"\\n\"\n+\t \"\tand\t%1,%3\"\t\t\t\"\\n\"\n+\t \"\txor\t%3,%1\"\t\t\t\"\\n\"\n+\t \"\tadd\tr15,%1\"\t\t\t\"\\n\"\n+\t \"\tadd\t#-4,%1\"\t\t\t\"\\n\"\n+\t \"0:\tmovli.l\t@%3,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@-r15\"\t\t\"\\n\"\n+\t \"\tmov.<i124suffix>\t@%1,r0\"\t\"\\n\"\n+\t \"\tand\t%2,r0\"\t\t\t\"\\n\"\n+\t \"\tnot\tr0,%0\"\t\t\t\"\\n\"\n+\t \"\tmov.<i124suffix>\t%0,@%1\"\t\"\\n\"\n+\t \"\tmov.l\t@r15+,r0\"\t\t\"\\n\"\n+\t \"\tmovco.l\tr0,@%3\"\t\t\t\"\\n\"\n+\t \"\tbf\t0b\";\n+}\n+  [(set_attr \"length\" \"28\")])\n+\n (define_insn \"atomic_nand_fetch<mode>_soft\"\n   [(set (match_operand:I124 0 \"register_operand\" \"=&u\")\n \t(not:I124 (and:I124\n@@ -393,7 +791,7 @@\n    (clobber (reg:SI R1_REG))]\n   \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n {\n-  return \"mova\t1f,r0\"\t\t\t\t\"\\n\"\n+  return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\tr15,r1\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r15\"\t\t\"\\n\"\n@@ -405,23 +803,28 @@\n }\n   [(set_attr \"length\" \"18\")])\n \n+;;------------------------------------------------------------------------------\n+;; read - test against zero - or with 0x80 - write - return test result\n+\n (define_expand \"atomic_test_and_set\"\n   [(match_operand:SI 0 \"register_operand\" \"\")\t\t;; bool result output\n    (match_operand:QI 1 \"memory_operand\" \"\")\t\t;; memory\n    (match_operand:SI 2 \"const_int_operand\" \"\")]\t\t;; model\n-  \"(TARGET_SOFT_ATOMIC || TARGET_ENABLE_TAS) && !TARGET_SHMEDIA\"\n+  \"(TARGET_ANY_ATOMIC || TARGET_ENABLE_TAS) && !TARGET_SHMEDIA\"\n {\n   rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n \n   if (TARGET_ENABLE_TAS)\n     emit_insn (gen_tasb (addr));\n   else\n     {\n-      rtx val;\n-\n-      val = gen_int_mode (targetm.atomic_test_and_set_trueval, QImode);\n+      rtx val = gen_int_mode (targetm.atomic_test_and_set_trueval, QImode);\n       val = force_reg (QImode, val);\n-      emit_insn (gen_atomic_test_and_set_soft (addr, val));\n+\n+      if (TARGET_HARD_ATOMIC)\n+\t  emit_insn (gen_atomic_test_and_set_hard (addr, val));\n+      else\n+\t  emit_insn (gen_atomic_test_and_set_soft (addr, val));\n     }\n \n   /* The result of the test op is the inverse of what we are\n@@ -452,7 +855,7 @@\n    (clobber (reg:SI R1_REG))]\n   \"TARGET_SOFT_ATOMIC && !TARGET_ENABLE_TAS && !TARGET_SHMEDIA\"\n {\n-  return \"mova\t1f,r0\"\t\t\t\"\\n\"\n+  return \"\\r\tmova\t1f,r0\"\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\"\\n\"\n \t \"\tmov\tr15,r1\"\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r15\"\t\"\\n\"\n@@ -463,3 +866,31 @@\n }\n   [(set_attr \"length\" \"16\")])\n \n+(define_insn \"atomic_test_and_set_hard\"\n+  [(set (reg:SI T_REG)\n+\t(eq:SI (mem:QI (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t       (const_int 0)))\n+   (set (mem:QI (match_dup 0))\n+\t(unspec:QI [(match_operand:QI 1 \"register_operand\" \"r\")] UNSPEC_ATOMIC))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (match_scratch:SI 2 \"=&r\"))\n+   (clobber (match_scratch:SI 3 \"=&r\"))\n+   (clobber (match_scratch:SI 4 \"=0\"))]\n+  \"TARGET_HARD_ATOMIC && !TARGET_ENABLE_TAS && TARGET_SH4A_ARCH\"\n+{\n+  return \"\\r\tmov\t#-4,%2\"\t\t\"\\n\"\n+\t \"\tand\t%0,%2\"\t\t\"\\n\"\n+\t \"\txor\t%2,%0\"\t\t\"\\n\"\n+\t \"\tadd\tr15,%0\"\t\t\"\\n\"\n+\t \"\tadd\t#-4,%0\"\t\t\"\\n\"\n+\t \"0:\tmovli.l\t@%2,r0\"\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@-r15\"\t\"\\n\"\n+\t \"\tmov.b\t@%0,%3\"\t\t\"\\n\"\n+\t \"\tmov.b\t%1,@%0\"\t\t\"\\n\"\n+\t \"\tmov.l\t@r15+,r0\"\t\"\\n\"\n+\t \"\tmovco.l\tr0,@%2\"\t\t\"\\n\"\n+\t \"\tbf\t0b\"\t\t\"\\n\"\n+\t \"\ttst\t%3,%3\";\n+}\n+  [(set_attr \"length\" \"26\")])\n+"}, {"sha": "efab5168d4202e659d511ef847d4b62f0b08ffa9", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11394f8eddda4ee9f06d66d8431ddad6ef76666/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11394f8eddda4ee9f06d66d8431ddad6ef76666/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c11394f8eddda4ee9f06d66d8431ddad6ef76666", "patch": "@@ -884,7 +884,7 @@ See RS/6000 and PowerPC Options.\n -mprefergot  -musermode -multcost=@var{number} -mdiv=@var{strategy} @gol\n -mdivsi3_libfunc=@var{name} -mfixed-range=@var{register-range} @gol\n -mindexed-addressing -mgettrcost=@var{number} -mpt-fixed @gol\n--maccumulate-outgoing-args -minvalid-symbols -msoft-atomic @gol\n+-maccumulate-outgoing-args -minvalid-symbols -msoft-atomic -mhard-atomic @gol\n -mbranch-cost=@var{num} -mcbranchdi -mcmpeqdi -mfused-madd -mpretend-cmove @gol\n -menable-tas}\n \n@@ -18054,10 +18054,22 @@ which is incompatible with the SH ABI@.\n Generate GNU/Linux compatible gUSA software atomic sequences for the atomic\n built-in functions.  The generated atomic sequences require support from the \n interrupt / exception handling code of the system and are only suitable for\n-single-core systems.  They will not perform correctly on multi-core systems.\n+single-core systems.  They will not operate correctly on multi-core systems.\n This option is enabled by default when the target is @code{sh-*-linux*}.\n+When the target is SH4A, this option will also partially utilize the hardware\n+atomic instructions @code{movli.l} and @code{movco.l} to create more\n+efficient code.\n For details on the atomic built-in functions see @ref{__atomic Builtins}.\n \n+@item -mhard-atomic\n+@opindex hard-atomic\n+Generate hardware atomic sequences for the atomic built-in functions.  This\n+is only available on SH4A and is suitable for multi-core systems.  Code\n+compiled with this option will also be compatible with gUSA aware\n+interrupt / exception handling systems.  In contrast to the\n+@option{-msoft-atomic} option this will only use the instructions\n+@code{movli.l} and @code{movco.l} to create atomic sequences.\n+\n @item -menable-tas\n @opindex menable-tas\n Generate the @code{tas.b} opcode for @code{__atomic_test_and_set}."}]}