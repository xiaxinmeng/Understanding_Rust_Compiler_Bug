{"sha": "051d8245886f5f133fad42d38b9d4ce12afd1394", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUxZDgyNDU4ODZmNWYxMzNmYWQ0MmQzOGI5ZDRjZTEyYWZkMTM5NA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-06T06:18:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-06T06:18:15Z"}, "message": "ia64.c (rtx_needs_barrier): Handle CONST_VECTOR and VEC_SELECT.\n\n        * config/ia64/ia64.c (rtx_needs_barrier): Handle CONST_VECTOR\n        and VEC_SELECT.\n        * config/ia64/vect.md (mulv8qi3): Re-implement with mix_[rl].\n        (mulv4hi3): Set itanium_class mmmul.\n        (fpack_sfxf, fpack_xfsf, fpack_xfxf): Remove.\n\nFrom-SVN: r92987", "tree": {"sha": "8d103dbf6344ce53612014171f97098266de9edd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d103dbf6344ce53612014171f97098266de9edd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/051d8245886f5f133fad42d38b9d4ce12afd1394", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051d8245886f5f133fad42d38b9d4ce12afd1394", "html_url": "https://github.com/Rust-GCC/gccrs/commit/051d8245886f5f133fad42d38b9d4ce12afd1394", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051d8245886f5f133fad42d38b9d4ce12afd1394/comments", "author": null, "committer": null, "parents": [{"sha": "8f98556f0151b9a45553a49d876b55f76017d0d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f98556f0151b9a45553a49d876b55f76017d0d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f98556f0151b9a45553a49d876b55f76017d0d9"}], "stats": {"total": 157, "additions": 83, "deletions": 74}, "files": [{"sha": "48586a2b245551e186475952ace434c153fc8e9c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051d8245886f5f133fad42d38b9d4ce12afd1394/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051d8245886f5f133fad42d38b9d4ce12afd1394/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=051d8245886f5f133fad42d38b9d4ce12afd1394", "patch": "@@ -1,3 +1,12 @@\n+2005-01-05  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/ia64/ia64.c (rtx_needs_barrier): Handle CONST_VECTOR\n+\tand VEC_SELECT.\n+\t* config/ia64/vect.md (mulv8qi3): Re-implement with mix_[rl].\n+\t(mulv4hi3): Set itanium_class mmmul.\n+\t(fpack_sfxf, fpack_xfsf, fpack_xfxf): Remove.\n+\t(fpack): Rename from fpack_sfsf.\n+\n 2005-01-05  Richard Henderson  <rth@redhat.com>\n \n \tPR rtl-opt/10692"}, {"sha": "ce5d8aaa88be0fa627371b8b943b1cf41240dc18", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051d8245886f5f133fad42d38b9d4ce12afd1394/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051d8245886f5f133fad42d38b9d4ce12afd1394/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=051d8245886f5f133fad42d38b9d4ce12afd1394", "patch": "@@ -5198,17 +5198,27 @@ rtx_needs_barrier (rtx x, struct reg_flags flags, int pred)\n       for (i = XVECLEN (x, 0) - 1; i >= 0; --i)\n \t{\n \t  rtx pat = XVECEXP (x, 0, i);\n-\t  if (GET_CODE (pat) == SET)\n+\t  switch (GET_CODE (pat))\n \t    {\n+\t    case SET:\n \t      update_set_flags (pat, &new_flags, &pred, &cond);\n-\t      need_barrier |= set_src_needs_barrier (pat, new_flags, pred, cond);\n+\t      need_barrier |= set_src_needs_barrier (pat, new_flags,\n+\t\t\t\t\t\t     pred, cond);\n+\t      break;\n+\n+\t    case USE:\n+\t    case CALL:\n+\t    case ASM_OPERANDS:\n+\t      need_barrier |= rtx_needs_barrier (pat, flags, pred);\n+\t      break;\n+\n+\t    case CLOBBER:\n+\t    case RETURN:\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n \t    }\n-\t  else if (GET_CODE (pat) == USE\n-\t\t   || GET_CODE (pat) == CALL\n-\t\t   || GET_CODE (pat) == ASM_OPERANDS)\n-\t    need_barrier |= rtx_needs_barrier (pat, flags, pred);\n-\t  else if (GET_CODE (pat) != CLOBBER && GET_CODE (pat) != RETURN)\n-\t    abort ();\n \t}\n       for (i = XVECLEN (x, 0) - 1; i >= 0; --i)\n \t{\n@@ -5246,7 +5256,7 @@ rtx_needs_barrier (rtx x, struct reg_flags flags, int pred)\n       need_barrier = rtx_needs_barrier (XEXP (x, 0), new_flags, pred);\n       break;\n \n-    case CONST_INT:   case CONST_DOUBLE:\n+    case CONST_INT:   case CONST_DOUBLE:  case CONST_VECTOR:\n     case SYMBOL_REF:  case LABEL_REF:     case CONST:\n       break;\n \n@@ -5290,6 +5300,14 @@ rtx_needs_barrier (rtx x, struct reg_flags flags, int pred)\n       need_barrier = rtx_needs_barrier (XEXP (x, 0), flags, pred);\n       break;\n \n+    case VEC_SELECT:\n+      /* VEC_SELECT's second argument is a PARALLEL with integers that\n+\t describe the elements selected.  On ia64, those integers are\n+\t always constants.  Avoid walking the PARALLEL so that we don't\n+\t get confused with \"normal\" parallels and abort.  */\n+      need_barrier = rtx_needs_barrier (XEXP (x, 0), flags, pred);\n+      break;\n+\n     case UNSPEC:\n       switch (XINT (x, 1))\n \t{"}, {"sha": "12729a90e433304d273497f331f107298bbc66bc", "filename": "gcc/config/ia64/vect.md", "status": "modified", "additions": 25, "deletions": 65, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051d8245886f5f133fad42d38b9d4ce12afd1394/gcc%2Fconfig%2Fia64%2Fvect.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051d8245886f5f133fad42d38b9d4ce12afd1394/gcc%2Fconfig%2Fia64%2Fvect.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fvect.md?ref=051d8245886f5f133fad42d38b9d4ce12afd1394", "patch": "@@ -172,43 +172,35 @@\n \t\t   (match_operand:V8QI 2 \"gr_register_operand\" \"r\")))]\n   \"\"\n {\n-  rtx l1, h1, l2, h2, lm, hm, lz, hz;\n+  rtx r1, l1, r2, l2, rm, lm;\n \n+  r1 = gen_reg_rtx (V4HImode);\n   l1 = gen_reg_rtx (V4HImode);\n-  h1 = gen_reg_rtx (V4HImode);\n+  r2 = gen_reg_rtx (V4HImode);\n   l2 = gen_reg_rtx (V4HImode);\n-  h2 = gen_reg_rtx (V4HImode);\n-\n-  /* Zero-extend the QImode elements into two words of HImode elements.  */\n-  emit_insn (gen_unpack1_l (gen_lowpart (V8QImode, l1),\n-\t\t\t    operands[1], CONST0_RTX (V8QImode)));\n-  emit_insn (gen_unpack1_l (gen_lowpart (V8QImode, l2),\n-\t\t\t    operands[2], CONST0_RTX (V8QImode)));\n-  emit_insn (gen_unpack1_h (gen_lowpart (V8QImode, h1),\n-\t\t\t    operands[1], CONST0_RTX (V8QImode)));\n-  emit_insn (gen_unpack1_h (gen_lowpart (V8QImode, h2),\n-\t\t\t    operands[2], CONST0_RTX (V8QImode)));\n+\n+  /* Zero-extend the QImode elements into two words of HImode elements\n+     by interleaving them with zero bytes.  */\n+  emit_insn (gen_mix1_r (gen_lowpart (V8QImode, r1),\n+                         operands[1], CONST0_RTX (V8QImode)));\n+  emit_insn (gen_mix1_r (gen_lowpart (V8QImode, r2),\n+                         operands[2], CONST0_RTX (V8QImode)));\n+  emit_insn (gen_mix1_l (gen_lowpart (V8QImode, l1),\n+                         operands[1], CONST0_RTX (V8QImode)));\n+  emit_insn (gen_mix1_l (gen_lowpart (V8QImode, l2),\n+                         operands[2], CONST0_RTX (V8QImode)));\n \n   /* Multiply.  */\n+  rm = gen_reg_rtx (V4HImode);\n   lm = gen_reg_rtx (V4HImode);\n-  hm = gen_reg_rtx (V4HImode);\n+  emit_insn (gen_mulv4hi3 (rm, r1, r2));\n   emit_insn (gen_mulv4hi3 (lm, l1, l2));\n-  emit_insn (gen_mulv4hi3 (hm, h1, h2));\n-\n-  /* Zap the high order bytes of the HImode elements.  There are several\n-     ways that this could be done.  On Itanium2, there's 1 cycle latency\n-     moving between the ALU units and the PALU units, so using AND would\n-     be 3 cycles latency into the eventual pack insn, whereas using MIX\n-     is only 2 cycles.  */\n-  lz = gen_reg_rtx (V4HImode);\n-  hz = gen_reg_rtx (V4HImode);\n-  emit_insn (gen_mix1_r (gen_lowpart (V8QImode, lz),\n-\t\t\t gen_lowpart (V8QImode, lm), CONST0_RTX (V8QImode)));\n-  emit_insn (gen_mix1_r (gen_lowpart (V8QImode, lz),\n-\t\t\t gen_lowpart (V8QImode, lm), CONST0_RTX (V8QImode)));\n-\n-  /* Repack the HImode elements as QImode elements.  */\n-  emit_insn (gen_pack2_sss (operands[0], lz, hz));\n+\n+  /* Zap the high order bytes of the HImode elements by overwriting those\n+     in one part with the low order bytes of the other.  */\n+  emit_insn (gen_mix1_r (operands[0],\n+                         gen_lowpart (V8QImode, rm),\n+                         gen_lowpart (V8QImode, lm)));\n   DONE;\n })\n \n@@ -218,7 +210,7 @@\n \t\t   (match_operand:V4HI 2 \"gr_register_operand\" \"r\")))]\n   \"\"\n   \"pmpyshr2 %0 = %1, %2, 0\"\n-  [(set_attr \"itanium_class\" \"mmalua\")])\n+  [(set_attr \"itanium_class\" \"mmmul\")])\n \n (define_expand \"umax<mode>3\"\n   [(set (match_operand:VECINT 0 \"gr_register_operand\" \"\")\n@@ -450,7 +442,7 @@\n   \"mix1.r %0 = %r2, %r1\"\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_insn \"*mix1_l\"\n+(define_insn \"mix1_l\"\n   [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V8QI\n \t  (vec_concat:V16QI\n@@ -948,7 +940,7 @@\n   DONE;\n })\n \n-(define_insn \"*fpack_sfsf\"\n+(define_insn \"*fpack\"\n   [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n \t(vec_concat:V2SF\n \t  (match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"fG\")\n@@ -957,38 +949,6 @@\n   \"fpack %0 = %F2, %F1\"\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n-(define_insn \"*fpack_sfxf\"\n-  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n-\t(vec_concat:V2SF\n-\t  (match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"fG\")\n-\t  (float_truncate:SF\n-\t    (match_operand 2 \"fr_register_operand\" \"f\"))))]\n-  \"GET_MODE (operands[2]) == DFmode || GET_MODE (operands[2]) == XFmode\"\n-  \"fpack %0 = %2, %F1\"\n-  [(set_attr \"itanium_class\" \"fmisc\")])\n-\n-(define_insn \"*fpack_xfsf\"\n-  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n-\t(vec_concat:V2SF\n-\t  (float_truncate:SF\n-\t    (match_operand 1 \"fr_register_operand\" \"f\"))\n-\t  (match_operand:SF 2 \"fr_reg_or_fp01_operand\" \"fG\")))]\n-  \"GET_MODE (operands[1]) == DFmode || GET_MODE (operands[1]) == XFmode\"\n-  \"fpack %0 = %F2, %1\"\n-  [(set_attr \"itanium_class\" \"fmisc\")])\n-\n-(define_insn \"*fpack_xfxf\"\n-  [(set (match_operand:V2SF 0 \"fr_register_operand\" \"=f\")\n-\t(vec_concat:V2SF\n-\t  (float_truncate:SF\n-\t    (match_operand 1 \"fr_register_operand\" \"f\"))\n-\t  (float_truncate:SF\n-\t    (match_operand 2 \"fr_register_operand\" \"f\"))))]\n-  \"(GET_MODE (operands[1]) == DFmode || GET_MODE (operands[1]) == XFmode)\n-   && (GET_MODE (operands[2]) == DFmode || GET_MODE (operands[2]) == XFmode)\"\n-  \"fpack %0 = %2, %1\"\n-  [(set_attr \"itanium_class\" \"fmisc\")])\n-\n ;; Missing operations\n ;; fprcpa\n ;; fpsqrta"}, {"sha": "ca4aabc43b1f14e8d39e78178884138b1eda58e5", "filename": "gcc/testsuite/gcc.c-torture/execute/simd-6.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051d8245886f5f133fad42d38b9d4ce12afd1394/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fsimd-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051d8245886f5f133fad42d38b9d4ce12afd1394/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fsimd-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fsimd-6.c?ref=051d8245886f5f133fad42d38b9d4ce12afd1394", "patch": "@@ -0,0 +1,22 @@\n+extern void abort (void);\n+extern int memcmp (const void *, const void *, __SIZE_TYPE__);\n+\n+typedef unsigned char v8qi __attribute__((vector_size(8)));\n+\n+v8qi foo(v8qi x, v8qi y)\n+{\n+  return x * y;\n+}\n+\n+int main()\n+{\n+  v8qi a = { 1, 2, 3, 4, 5, 6, 7, 8 };\n+  v8qi b = { 3, 3, 3, 3, 3, 3, 3, 3 };\n+  v8qi c = { 3, 6, 9, 12, 15, 18, 21, 24 };\n+  v8qi r;\n+\n+  r = foo (a, b);\n+  if (memcmp (&r, &c, 8) != 0)\n+    abort ();\n+  return 0;\n+}"}]}