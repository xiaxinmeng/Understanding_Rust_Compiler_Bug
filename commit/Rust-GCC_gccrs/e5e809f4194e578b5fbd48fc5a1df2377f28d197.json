{"sha": "e5e809f4194e578b5fbd48fc5a1df2377f28d197", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVlODA5ZjQxOTRlNTc4YjVmYmQ0OGZjNWExZGYyMzc3ZjI4ZDE5Nw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-04T13:32:39Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-04T13:32:39Z"}, "message": "* Check in merge from gcc2.  See ChangeLog.11 and ChangeLog.12\n        for details.\n\n        * haifa-sched.c: Mirror recent changes from gcc2.\n\nFrom-SVN: r18984", "tree": {"sha": "6743f11e58bd7a933b08900d973d89026cd11c43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6743f11e58bd7a933b08900d973d89026cd11c43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5e809f4194e578b5fbd48fc5a1df2377f28d197", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e809f4194e578b5fbd48fc5a1df2377f28d197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5e809f4194e578b5fbd48fc5a1df2377f28d197", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e809f4194e578b5fbd48fc5a1df2377f28d197/comments", "author": null, "committer": null, "parents": [{"sha": "31031eddacda46a500b2390f52cd4474bcaf84ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31031eddacda46a500b2390f52cd4474bcaf84ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31031eddacda46a500b2390f52cd4474bcaf84ca"}], "stats": {"total": 5752, "additions": 3634, "deletions": 2118}, "files": [{"sha": "542ef82df62a90e3d22909a2b01bcafe3f30c9f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,3 +1,10 @@\n+Sat Apr  4 10:23:41 1998  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* Check in merge from gcc2.  See ChangeLog.11 and ChangeLog.12\n+\tfor details.\n+\n+\t* haifa-sched.c: Mirror recent changes from gcc2.\n+\n Fri Apr  3 00:17:01 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* Makefile.in (insn*.o): Depend on system.h."}, {"sha": "c244bb65eb563ab7f901b0f46a59c2478df88800", "filename": "gcc/ChangeLog.11", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2FChangeLog.11", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2FChangeLog.11", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.11?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,42 +1,3 @@\n-Wed Jan  7 18:02:42 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n-\n-\t* Version 2.8.0 released.\n-\n-Wed Jan  7 17:54:41 1998  J. Kean Johnston  <jkj@sco.com>\n-\n-\t* i386/sco5.h ({END,START}FILE_SPEC): Link with correct crtbegin.o\n-\tand crtend.o when using -static.\n-\n-Wed Jan  7 17:49:14 1998  Jan Christiaan van Winkel <Jan.Christiaan.van.Winkel@ATComputing.nl>\n-\n-\t* cppexp.c (gansidecl.h): Include.\n-\n-Wed Jan  7 17:45:07 1998  Tristan Gingold  <gingold@puccini.enst.fr>\n-\n-\t* expr.c (get_push_address): Use copy_to_reg instead of force_operand.\n-\t(emit_push_insn): Avoid null pointer deference if aggregate has no\n-\ttypes.\n-\t(expand_expr): Avoid finite but useless recursion.\n-\t(expand_builtin): Fix typo in calling function.\n-\t* function.c (assign_parms): Avoid useless call to chkr_set_right.\n-\n-Wed Jan  7 17:31:13 1998  Christian Iseli  <Christian.Iseli@lslsun.epfl.ch>\n-\n-\t* combine.c (force_to_mode): Return if operand is a CLOBBER.\n-\n-Wed Jan  7 17:23:24 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n-\n-\t* x-rs6000 (INSTALL): Remove.\n-\n-\t* jump.c (jump_optimize): Don't use a hard reg as an operand\n-\tof a conditional move if small register classes.\n-\n-Wed Jan  7 17:09:28 1998  Jim Wilson  <wilson@cygnus.com>\n-\n-\t* cse.c (max_insn_uid): New variable.\n-\t(cse_around_loop): Use it.\n-\t(cse_main): Set it.\n-\n Wed Dec 31 18:40:26 1997  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* stmt.c (expand_asm_operands): Treat ASM with no outputs as volatile."}, {"sha": "a7585f71090e0817b7ddc26c69bc70bca317f771", "filename": "gcc/ChangeLog.12", "status": "added", "additions": 999, "deletions": 0, "changes": 999, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2FChangeLog.12", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2FChangeLog.12", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.12?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -0,0 +1,999 @@\n+Mon Mar 30 13:56:30 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* mips/ultrix.h (SUBTARGET_CPP_SPEC): Define.\n+\n+Wed Mar 25 16:09:01 1998  Michael Meissner  <meissner@cygnus.com>\n+\n+\t* rs6000.h (FUNCTION_ARG_PADDING): Cast result to be enum\n+\tdirection.\n+\t(function_arg_padding): Declare.\n+\n+\t* rs6000.c: Include stdlib.h if we have it.\n+\t(function_arg_padding): Change return type to int, cast enum's to\n+\tint.\n+\n+\t(From Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>)\n+\t* rs6000.c (rs6000_override_options): Change type of `i', `j' and\n+\t`ptt_size' from int to size_t.\n+\t(rs6000_file_start): Likewise for `i'.\n+\t(rs6000_replace_regno): Add default case in enumeration switch.\n+\t(output_epilog): Remove unused variable `i'.\n+\t(rs6000_longcall_ref): Remove unused variables `len', `p', `reg1'\n+\tand `reg2'.\n+ \n+\t* rs6000.h (ADDITIONAL_REGISTER_NAMES): Add missing braces around\n+\tinitializer.\n+\t(get_issue_rate, non_logical_cint_operand): Add prototype.\n+\t(rs6000_output_load_toc_table): Ditto.\n+ \n+\t* rs6000.md (udivmodsi4): Add explicit braces to avoid ambiguous\n+\t`else'.\n+ \n+Wed Mar 25 02:39:01 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* configure.in (i[[34567]]86-*-solaris2*, powerpcle-*-solaris2*,\n+\tsparc-*-solaris2*): Use fixinc.svr4 if Solaris 2.0 through 2.4.\n+\n+Mon Mar 23 07:27:19 1998  Philippe De Muyter  <phdm@macqel.be>\n+\n+\t* m68k.md (ashldi_const): Allow shift count in range ]32,63].\n+\t(ashldi3): Allow constant shift count in range ]32,63].\n+\t(ashrdi_const, ashrid3, lshrdi_const, lshrdi3): Likewise.\n+\n+\t* m68k.md (zero_extend[qh]idi2, iordi_zext): New patterns.\n+\t(zero_extendsidi2): Avoid useless copy.\n+\t(iorsi_zexthi_ashl16): Avoid \"0\" constraint for operand 2.\n+\t(iorsi_zext): New name for old unnamed pattern; indentation fixes.\n+\n+Mon Mar 23 07:12:05 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* final.c (only_leaf_regs_used): If pic_offset_table_rtx used,\n+\tmake sure it is a permitted register.\n+\n+Sun Mar 22 06:57:04 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expmed.c (extract_bit_field): Don't confuse SUBREG_WORD with\n+\tendian adjustment in SUBREG case.\n+\tDon't abort if can't make SUBREG needed for extv/extzv.\n+\n+Sat Mar 21 08:02:17 1998  Richard Gorton  <gorton@amt.tay1.dec.com>\n+\n+        * alpha.md (zero_extendqi[hsd]i2): Use \"and\", not \"zapnot\".\n+\n+Sat Mar 21 07:47:04 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* unroll.c (verify_addresses): Use validate_replace_rtx.\n+\t(find_splittable_givs): If invalid address, show nothing same_insn.\n+\n+Fri Mar 20 10:24:12 1998  Philippe De Muyter  <phdm@macqel.be>\n+\n+\t* fold-const.c (fold, case CONVERT_EXPR): Replace sign-extension of\n+\ta zero-extended value by a single zero-extension.\n+\n+Thu Mar 19 14:59:32 1998  Andrew Pochinsky  <avp@ctp.mit.edu>\n+\n+\t* sparc.h (ASM_OUTPUT_LOOP_ALIGN): Fix error in last change.\n+\n+Thu Mar 19 14:48:35 1998  Michael Meissner  <meissner@cygnus.com>\n+\n+\t* gcc.c (default_arg): Don't wander off the end of allocated memory.\n+\n+\t* rs6000/sysv4.h (RELATIVE_PREFIX_NOT_LINKDIR): Undef for System V\n+\tand EABI.\n+\n+Thu Mar 19 06:17:59 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* Makefile.in (toplev.o): Depend on Makefile.\n+\n+Wed Mar 18 17:40:09 1998  Michael P. Hayes  <michaelh@ongaonga.chch.cri.nz>\n+\n+\t* expr.c (convert_move): Add [QH]Imode/P[QH]Imode conversions.\n+\t* machmode.def (PQImode, PHImode): New modes.\n+\n+Wed Mar 18 17:11:18 1998  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>\n+\n+\t* m68k.md (movsf+1): Optimize moving a CONST_DOUBLE zero.\n+\n+Wed Mar 18 17:07:54 1998  Ken Raeburn  <raeburn@cygnus.com>\n+\n+\t* regclass.c (init_reg_sets): Delete init of reg-move cost tables.\n+\t(init_reg_sets_1): Put it here.\n+\n+Wed Mar 18 16:43:11 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* i960.md (tablejump): Handle flag_pic.\n+\n+\t* profile.c (branch_prob): If see computed goto, call fatal.\n+\n+\t* calls.c (expand_call): Fix typos in n_named_args computation.\n+\n+Wed Mar 18 05:54:25 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* fold-const.c (operand_equal_for_comparison_p): See if equal\n+\twhen nop conversions are removed.\n+\n+\t* expr.c (expand_expr, case COND_EXPR): If have conditional move,\n+\tdon't use ORIGINAL_TARGET unless REG.\n+\n+\t* function.c (fixup_var_refs_insns): Also delete insn storing pseudo\n+\tback into arg list.\n+\n+\t* combine.c (gen_binary): Don't make AND that does nothing.\n+\t(simplify_comparison, case AND): Commute AND and SUBREG.\n+\t* i386.h (CONST_CONSTS, case CONST_INT): One-byte integers are cost 0.\n+\n+Mon Mar 16 15:57:17 1998  Geoffrey Keating  <geoffk@ozemail.com.au>\n+\n+\t* rs6000.c (small_data_operand): Ensure any address referenced\n+\trelative to small data area is inside SDA.\n+\n+Sun Mar 15 16:01:19 1998  Andrew Pochinsky  <avp@ctp.mit.edu>\n+\n+\t* sparc.h (ASM_OUTPUT_LOOP_ALIGN): Write nop's.\n+\n+Sun Mar 15 15:53:39 1998  Philippe De Muyter  <phdm@macqel.be>\n+\n+\t* libgcc2.c (exit): Don't call __bb_exit_func if HAVE_ATEXIT.\n+\n+Sun Mar 15 15:44:41 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* cccp.c: Fix bugs relating to NUL in input file name,\n+\te.g. with `#line 2 \"x\\0y\"'.\n+\t(PRINTF_PROTO_4): New macro.\n+\t(struct {file_buf,definition,if_stack}): New member nominal_fname_len.\n+\t(main, expand_to_temp_buffer): Store length of input file names.\n+\t(finclude, create_definition, do_line, conditional_skip): Likewise.\n+\t(skip_if_group, macroexpand): Likewise.\n+\t(make_{definition,undef,assertion}): Likewise.\n+\t(special_symbol, do_include): Use stored length of input file names.\n+\t(do_define, do_elif, do_else, output_line_directive, verror): Likewise.\n+\t(error_from_errno, vwarning, verror_with_line): Likewise.\n+\t(vwarning_with_line, pedwarn_with_file_and_line): Likewise.\n+\t(print_containing_files): Likewise.\n+\t(do_line): Fix off-by-1 problem: 1 too many bytes were being allocated.\n+\t(quote_string, pedwarn_with_file_and_line): New arg specifies length.\n+\tAll callers changed.\n+\n+Sun Mar 15 15:38:16 1998  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>\n+\n+\t* c-typeck.c: Collect pending initializers in AVL tree instead of list.\n+\t(add_pending_init, pending_init_member): New functions.\n+\t(output_init_element): Use them.\n+\t(output_pending_init_elements): Rewritten to exploit AVL order.\n+\n+Sun Mar 15 05:10:49 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* gnu.h (GNU_CPP_PREDEFINES): Deleted; not valid in traditional C.\n+\t* {i386,mips}/gnu.h (CPP_PREDEFINES): Don't call GNU_CPP_PREDEFINES.\n+\n+\t* flow.c (insn_dead_p): A CLOBBER of a dead pseudo is dead.\n+\n+\t* alpha.h (REG_ALLOC_ORDER): Put $f1 after other nonsaved.\n+\n+\t* sparc.c (sparc_type_code): Fix error in previous change.\n+\n+Sat Mar 14 05:45:21 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* i386/xm-aix.h, i386/xm-osf.h (i386/xm-i386.h): Don't include.\n+\t(USG): Don't define.\n+\t* i386/xm-isc.h (i386/xm-sysv3.h): Don't include.\n+\t* i386/xm-sco.h (i386/xm-sysv3.h): Likewise.\n+\t(BROKEN_LDEXP, SMALL_ARG_MAX, NO_SYS_SIGLIST): Don't define.\n+\t* m68k/xm-3b1.h (m68k/xm-m68k.h): Don't include.\n+\t(USG): Don't define.\n+\t* m68k/xm-atari.h (m68k/xm-m68kv.h): Don't include.\n+\t(HAVE_VPRINTF, FULL_PROTOTYPES): Don't define.\n+\t* m68k/xm-crds.h (m68k/xm-m68k.h): Don't include.\n+\t(USE_C_ALLOCA, unos, USG): Don't define.\n+\t* m68k/xm-mot3300.h (m68k/xm-m68k.h): Don't include.\n+\t(USE_C_ALLOCA, NO_SYS_SIGLIST): Don't define.\n+\t* m68k/xm-plexus.h (m68k/xm-m68k.h): Don't include.\n+\t(USE_C_ALLOCA, USG): Don't define.\n+\t* m88k/xm-sysv3.h (m88k/xm-m88k.h): Don't include.\n+\t* m68k/xm-next.h (m68k/xm-m68k.h): Don't include.\n+\t* ns32k/xm-pc532-min.h (ns32k/xm-ns32k.h): Don't include.\n+\t(USG): Don't define.\n+\t* rs6000/xm-mach.h: Don't include xm-rs6000.h.\n+\t* rs6000/xm-cygwin32.h (rs6000/xm-rs6000.h): Don't include.\n+\t(NO_STAB_H): Don't define.\n+\t* sparc/xm-linux.h (xm-linux.h): Don't include.\n+\t* sparc/xm-sol2.h (sparc/xm-sysv4.h): Don't include.\n+\t* a29k/xm-unix.h, alpha/xm-linux.h, arm/xm-linux.h: Deleted.\n+\t* arm/xm-netbsd.h, i386/xm-bsd386.h, i386/xm-gnu.h: Deleted.\n+\t* i386/xm-linux.h, i386/xm-sun.h, i386/xm-sysv3.h: Deleted.\n+\t* i386/xm-winnt.h,  m68k/xm-altos3068.h, m68k/xm-amix.h: Deleted.\n+\t* m68k/xm-amix.h, m68k/xm-hp320.h, m68k/xm-linux.h: Deleted.\n+\t* m68k/xm-m68kv.h, mips/xm-iris5.h, ns32k/xm-genix.h: Deleted.\n+\t* sparc/xm-pbd.h, vax/xm-vaxv.h, xm-svr3.h, xm-linux.h: Deleted.\n+\t* configure.in: Reflect above changes.\n+\n+\t* xm-siglist.h, xm-alloca.h: New files.\n+\t* i386/xm-sysv4.h (i386/xm-i386.h, xm-svr4.h): Don't include.\n+\t(USE_C_ALLOCA, SMALL_ARG_MAX): Don't define.\n+\t* i386/xm-sco5.h (i386/xm-sysv3.h): Don't include.\n+\t(SYS_SIGLIST_DECLARED, USE_C_ALLOCA): Don't define.\n+\t* rs6000/xm-sysv4.h, sparc/xm-sysv4.h: Don't include xm-svr4.h.\n+\t* xm-svr4.h, i386/xm-dgux.h, mips/xm-news.h, mips/xm-sysv4.h: Deleted.\n+\t* configure.in: Reflect above changes.\n+\n+\t* configure.in ({,host_,build_}xm_defines): New variables.\n+\tSet to USG instead of including xm-usg.h.\n+\tWrite #define lines in config.h files from xm_defines vars.\n+\t* xm-usg.h: Deleted.\n+\n+Fri Mar 13 07:10:59 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* calls.c (expand_call): Fix typo in previous change.\n+\n+\t* sparc.c (sparc_type_code): Avoid infinite loop when have\n+\tpointer to array of same pointer.\n+\t(sparc_type_code, case REAL_TYPE): Process subtypes here too.\n+\n+\t* mips/bsd-4.h, mips/iris3.h, mips/news{4,5}.h: Don't include mips.h.\n+\t* mips/news5.h, mips/osfrose.h, mips/svr{3,4}-4.h: Likewise.\n+\t* mips/ultrix.h: Likewise.\n+\t* mips/cross64.h: Don't include iris6.h.\n+\t* mips/ecoff.h: Don't include mips.h or gofast.h.\n+\t* mips/elforion.h: Don't include elf64.h.\n+\t* mips/iris4.h: Don't include iris3.h.\n+\t* mips/iris4loser.h: Don't include iris4.h.\n+\t* mips/iris5gas.h: Don't include iris5.h.\n+\t* mips/elflorion.h, mips/nws3250v4.h, mips/xm-iris{3,4}.h: Deleted.\n+\t* mips/xm-nws3250v4.h, mips/xm-sysv.h: Deleted.\n+\t* mips/rtems64.h: Don't include elflorion.h.\n+\t* mips/sni-gas.h: Don't include sni-svr4.h.\n+\t* mips/svr4-t.h: Don't include svr4-5.h.\n+\t* mips/dec-osf1.h: Also include mips.h.\n+\t* mips/ecoffl.h, mips/elf.h: Also include mips.h and gofast.h.\n+\t* mips/iris5.h: Also include iris3.h and mips.h.\n+\t* xm-usg.h: New file.\n+\t* mips/xm-iris5.h: Don't include xm-mips.h; don't define USG.\n+\t* mips/xm-news.h, mips/xm-sysv4.h: Don't include xm-sysv.h.\n+\t* configure.in: Reflect above changes.\n+\n+Thu Mar 12 07:18:48 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.h (STRICT_ARGUMENT_NAMING): Provide default value of 0.\n+\t* calls.c (expand_call): Use value of STRICT_ARGUMENT_NAMING.\n+\t* function.c (assign_parm): Likewise.\n+\t* mips/abi64.h (STRICT_ARGUMENT_NAMING): Return 0 for ABI_32.\n+\t* sparc.h (STRICT_ARGUMENT_NAMING): Only nonzero for V9.\n+\n+\t* calls.c (expand_call, expand_library_call{,_value}, store_one_arg):\n+\tRework handling of REG_PARM_STACK_SPACE to treat return value of\n+\tzero as if macro not defined; add new arg to emit_push_insn.\n+\t* expr.c (emit_push_insn): New arg, REG_PARM_STACK_SPACE.\n+\t* expr.h (emit_push_insn): Likewise.\n+\t* mips/abi64.h (REG_PARM_STACK_SPACE): Define.\n+\n+Wed Mar 11 06:58:13 1998  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>\n+\n+\t* m68k.h (CONST_OK_FOR_LETTER_P, case 'M'): Correct range check.\n+\n+Wed Mar 11 06:15:52 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.c (emit_push_insn): Use loop to find movstr patterns\n+\tinstead of explicit tests.\n+\n+\t* Makefile.in (extraclean): Don't delete install1.texi.\n+\n+Tue Mar 10 14:27:51 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* combine.c (make_field_assignment): Don't get confused if OTHER\n+\thas VOIDmode and don't do anything if DEST is wider than a host word.\n+\n+\t* vax.c (check_float_value): Cast bcopy args to char *.\n+\n+Tue Mar 10 13:56:12 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* mips/abi64.h (LONG_MAX_SPEC): Check MIPS_ABI_DEFAULT and\n+\tTARGET_DEFAULT and define __LONG_MAX__ appropriately.\n+\tAdd support for -mabi=X, -mlong64, and -mgp{32,64} options.\n+\t* mips.c (mips_abi): Change type to int.\n+\t* mips.h (enum mips_abi_type): Delete.\n+\t(ABI_32, ABI_N32, ABI_64, ABI_EABI): Define as constants.\n+\t(mips_abi): Change type to int.\n+\n+Mon Mar  2 08:06:58 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* Version 2.8.1 released.\n+\n+\t* Makefile.in (mostlyclean): Remove duplicate deletion of temp\n+ \tfiles.  Delete more stamp files and [df]p-bit.c\n+\t(clean): Don't delete stamp files here.\n+\t(VERSION_DEP): New variable.\n+\t(distdir-finish): Pass a value of null for it.\n+\t(version.c): Use it.\n+\tAvoid broken pipe with cvs log.\n+\n+\t* objc/Make-lang.in (objc/runtime-info.h): Rename emptyfile to\n+ \ttmp-runtime and delete at end.\n+\n+Sun Mar  1 05:50:25 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* tree.c (build_reference_type): Handle obstacks like\n+ \tbuild_pointer_type.\n+\n+\t* Makefile.in (tmp-gcc.xtar): Renamed from gcc.xtar.\n+\t(gcc.xtar.gz): Deleted; merged with `dist'.\n+\t(diff): Create gcc-$(oldversion)-$(version).diff.\n+\t(distdir): Depend on distdir-cvs.\n+\t(distdir-cvs): New rule.\n+\t(distdir-start): Depend on version.c and TAGS.\n+\t(TAGS): Use tmp-tags instead of temp.\n+\t(dist): Create gcc-$(version).tar.gz.\n+\n+\t* varasm.c (compare_constant_1): Fix typo in previous change.\n+\n+\t* objc/Make-lang.in (objc-distdir): Properly rebuild objc-parse.c.\n+\n+Sat Feb 28 16:58:08 1998  Tristan Gingold  <gingold@rossini.enst.fr>\n+\n+\t* stmt.c (expand_decl): If -fcheck-memory-usage, put vars in memory.\n+\t* expr.c (get_memory_usage_from_modifier): Convert\n+\tEXPAND_{CONST_ADDRESS, INITIALIZER} to MEMORY_USE_DONT.\n+  \n+Sat Feb 28 08:13:43 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* i860/fx2800.h (DATA_ALIGNMENT): Use POINTER_TYPE_P.\n+\t* m68k/a-ux.h (FUNCTION_VALUE): Likewise.\n+\t* expr.c (get_pointer_alignment, compare, do_store_flag): Likewise.\n+ \t(expand_builtin): Likewise.\n+\t* fold-const.c (force_fit_type, fold_convert, fold): Likewise.\n+\t* function.c (assign_parms): Likewise.\n+\t* integrate.c (expand_inline_function): Likewise.\n+\t* sdbout.c (sdbout_field_types): Likewise.\n+\t* tree.c (integer_pow2p, tree_log2, valid_machine_attribute): Likewise.\n+\t* stmt.c (expand_decl): Likewise.\n+\t({,bc_}expand_decl_init): Also test for REFERENCE_TYPE.\n+\n+\t* configure.in (version_dep): New variable; if srcdir is CVS working\n+\tdirectory, set to ChangeLog.\n+\t(version): Supply default if no version.c.\n+\t* Makefile.in (version.c): New rule.\n+\n+\t* gcc.c (snapshot_warning): New function.\n+\t(main): Call it for snapshots.\n+\n+\t* dwarf2out.c (expand_builtin_dwarf_reg_size): If reg_raw_mode\n+\tnot valid for reg, use last size.  Also refine range assertion.\n+\n+Sat Feb 28 05:04:47 1998  Michael P. Hayes  <michaelh@ongaonga.chch.cri.nz>\n+\n+\t* enquire.c (cprop): Don't perform exhaustive search for char_min\n+\tand char_max when bits_per_byte > 16.\n+\n+Thu Feb 26 15:12:03 1998  Christopher Taylor <cit@ckshq.com>\n+\n+\t* fixincludes: Avoid using '0-~' in egrep.\n+\n+Thu Feb 26 08:04:05 1998  Tristan Gingold  <gingold@messiaen.enst.fr>\n+\n+\t* function.c (assign_parms): Call 'chkr_set_right' when DECL_RTL\n+\tis stack_parm.\n+\t* expr.c (get_memory_usage_from_modifier): Convert\n+\tEXPAND_{SUM, CONST_ADDRESS, INITIALIZER} to MEMORY_USE_RO.\n+\n+Thu Feb 26 07:33:53 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* c-lex.c (yylex): Don't munge errno before using it.\n+\t* cccp.c (error_from_errno, perror_with_name): Likewise.\n+\t* cpplib.c (cpp_error_from_errno): Likewise.\n+\t* gcc.c (pfatal_pexecute): Likewise.\n+\t* protoize.c (safe_write, find_file, process_aux_info_file): Likewise.\n+\t(rename_c_file, edit_file): Likewise.\n+\n+\t* c-lex.c (yylex): Remove unused variable exceeds_double.\n+\n+Thu Feb 26 07:05:14 1998  Michael P. Hayes  <michaelh@ongaonga.chch.cri.nz>\n+\n+\t* reorg.c (fill_slots_from_thread): Don't steal delay list from target\n+\tif condition code of jump conflicts with opposite_needed.\n+\n+Thu Feb 26 06:45:23 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* Makefile.in (distdir-start): Don't copy CVS subdirectory of config.\n+\n+\t* varasm.c ({compare,record}_constant_1, case CONSTRUCTOR):\n+\tHandle the case when we have TREE_PURPOSE values.\n+\n+Thu Feb 26 05:59:01 1998  Philippe De Muyter  <phdm@macqel.be>\n+\n+\t* fixincludes (sys/limits.h): Fix a nested comment problem with\n+\tHUGE_VAL definition on sysV68 R3V7.1.\n+\n+Wed Feb 25 21:09:38 1998  Philippe De Muyter  <phdm@macqel.be>\n+\n+\t* toplev.c (TICKS_PER_SECOND): Renamed from CLOCKS_PER_SECOND.\n+\n+Wed Feb 25 20:50:08 1998  Michael P. Hayes  <michaelh@ongaonga.chch.cri.nz>\n+\n+\t* reorg.c (fill_slots_from_thread): Mark resources referenced in\n+\topposite_needed thread.  Return delay_list even when cannot get\n+\tany more delay insns from end of subroutine.\n+\n+Wed Feb 25 19:50:01 1998  Mikael Pettersson <Mikael.Pettersson@sophia.inria.fr>\n+\n+\t* gcc.c (lookup_compiler): Remove redundant test.\n+\n+Wed Feb 25 07:24:22 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* vax.md (call insns): Second operand to CALL rtl is SImode.\n+\n+\t* configure.in (i[34567]86-*-mingw32): Support msv and crt suffix.\n+\t* i386/crtdll.h: New file.\n+\n+\t* sparc.c (pic_setup_code): If -O0, write USE of pic_offset_table_rtx.\n+\n+\t* expr.c (safe_from_p): Add new arg, TOP_P; all callers changed.\n+\n+Sat Feb 21 07:02:39 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* mips/iris5.h (DWARF2_UNWIND_INFO): Define to 0.\n+\t* mips/iris5gas.h (DWARF2_UNWIND_INFO): Define to 1.\n+\n+Fri Feb 20 08:27:46 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* sparc/sol2-sld.h: New file.\n+\t* configure.in (sparc-*-solaris2*): Use it when using system linker.\n+\t* toplev.c (main): Don't default to DWARF2_DEBUG with -ggdb \n+\tif LINKER_DOES_NOT_WORK_WITH_DWARF2 is defined.\n+\n+Fri Feb 20 08:21:49 1998  H.J. Lu  (hjl@gnu.org)\n+\n+\t* alpha/elf.h (STARTFILE_SPEC, ENDFILE_SPEC): Support shared library.\n+\t(LIB_SPEC, DEFAULT_VTABLE_THUNKS): Defined #ifndef USE_GNULIBC_1.\n+\t* sparc/linux.h (DEFAULT_VTABLE_THUNKS): Likewise.\n+\t(LIB_SPEC): Add -lc for -shared #ifndef USE_GNULIBC_1.\n+\t* linux.h (LIB_SPEC): Likewise.\n+\t* sparc/linux64.h (LIB_SPEC): Likewise; also updated for glibc 2.\n+\t(LIBGCC_SPEC): Removed.\n+\t(CPP_SUBTARGET_SPEC): Add %{pthread:-D_REENTRANT}.\n+\n+Fri Feb 20 05:22:12 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* Makefile.in (distdir-start): Add dependence on bi-parser.[ch].\n+\n+Thu Feb 19 18:07:11 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* m68k.h (TARGET_SWITCHES): For 68000, 68302, subtract MASK_68881.\n+\tFor 68303, 68332, cpu32, subtract MASK_68040_ONLY.\n+\n+Wed Feb 18 09:37:29 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* fixincludes (stdlib.h): Do not double-wrap the size_t typedef.\n+\n+Wed Feb 18 07:32:11 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* i960.c (emit_move_sequence): Handle unaligned stores to pseudos.\n+\t* i960.md (store_unaligned_[dt]i_reg): Handle register dest.\n+\t(store_unaligned_ti_reg): Likewise.\n+\n+\t* m68k.h (MACHINE_STATE_{SAVE,RESTORE} [MOTOROLA]): Add %# and %/;\n+\tadd : to make them into extended asms.\n+\n+Wed Feb 18 07:08:05 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* reg-stack.c (compare_for_stack_reg): Only handle FP conditional\n+\tmove as next insn specially.\n+\n+\t* reload.c (find_reloads): Always convert address reload for\n+\tnon-reloaded operand to RELOAD_FOR_OPERAND_ADDRESS.\n+\n+\t* emit-rtl.c (hard-reg-set.h): Include.\n+\t(get_lowpart_common): Don't make new REG for hard reg in a \n+\tclass that cannot change size.\n+\t* Makefile.in (emit-rtl.o): Depend on hard-reg-set.h.\n+\n+Sat Feb 14 09:59:00 1998  Richard Earnshaw (rearnsha@arm.com)\n+\n+\t* arm.md (movsfcc): Also validate operands[3] for hard float.\n+\t(movdfcc): Only accept fpu_add_operand for operands[3].8\n+\n+Sat Feb 14 09:32:34 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* dwarf2out.c (expand_builtin_dwarf_reg_size): New variable mode.\n+\tConvert CCmode to word_mode before calling GET_MODE_SIZE.\n+\n+Sat Feb 14 09:27:42 1998  David Edelsohn  <edelsohn@mhpcc.edu>\n+\n+\t* rs6000.h (MY_ISCOFF): Check for U803XTOCMAGIC.\n+\n+Sat Feb 14 08:29:43 1998  Arvind Sankar  <arvind@cse.iitb.ernet.in>\n+\n+\t* t-svr4 (TARGET_LIBGCC_CFLAGS): New definition.\n+\n+Sat Feb 14 07:45:16 1998  Ken Rose (rose@acm.org)\n+\n+        * reorg.c (fill_slots_from_thread): New parameter, delay_list.\n+\tAll callers changed.\n+\n+Sat Feb 14 07:14:02 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* reload.c (debug_reload): Properly output insn codes.\n+\n+\t* pa.c (emit_move_sequence): If in reload, call find_replacement.\n+\n+\t* gansidecl.h (bcopy, bzero, {,r}index): Don't define if IN_LIBGCC2.\n+\n+\t* combine.c (distribute_notes, case REG_DEAD): When seeing if place\n+\tto put new note sets register, use reg_bitfield_target_p, as in\n+\toriginal code.\n+\n+\t* gcc.c (process_command): If file is for linker, set lang to \"*\".\n+\t(lookup_compiler): Return 0 for language of \"*\".\n+\n+\t* sched.c (attach_deaths, case SUBREG): Fix error in last change.\n+\n+\t* i386.md (mov[sdx]fcc): Disable for now.\n+\t(mov[sd]fcc_1): Add earlyclobber for output on last alternative.\n+\n+Sat Feb 14 06:42:50 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* except.c (get_dynamic_handler_chain): Only make call once per func.\n+\t(expand_fixup_region_{start,end}): New functions.\n+\t(expand_eh_region_start_tree): Store cleanup into finalization here.\n+\t* stmt.c (expand_cleanups): Use new functions to protect fixups.\n+\n+\t* except.c (get_dynamic_handler_chain): Build up a FUNCTION_DECL.\n+\t* optabs.c (init_optabs): Don't init get_dynamic_handler_chain_libfunc.\n+\t* expr.h (get_dynamic_handler_chain_libfunc): Deleted.\n+\n+Sat Feb 14 06:34:41 1998  Peter Lawrence  <Peter.Lawrence@Eng.Sun.COM>\n+\n+\t* optabs.c (emit_conditional_move): Don't reverse condition for FP.\n+\n+Fri Feb 13 07:22:04 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* Makefile.in (mostlyclean): Only use s-* convention for stamp\n+\tfiles in main dir.\n+\n+\t* configure.in: Add support for i786 (Pentium II); same as i686.\n+\n+Thu Feb 12 20:16:35 1998  Michael Meissner  <meissner@cygnus.com>\n+\n+\t* rs6000.md: Replace gen_rtx (CONST_INT,...) with GEN_INT.\n+\n+Thu Feb 12 10:08:14 1998  John Hassey  <hassey@dg-rtp.dg.com>\n+\n+\t* configure.in (i[3456]86-dg-dgux*): Don't need fixincludes.\n+\n+Thu Feb 12 07:27:39 1998  Mumit Khan <khan@xraylith.wisc.edu>\n+\t\n+\t* i386/cygwin32.h (NO_IMPLICIT_EXTERN_C): Define.\n+\tabout system headers.\n+\t(LIB_SPEC): Add -ladvapi32 -lshell32.\n+\n+Thu Feb 12 07:19:31 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.c (expand_assignment): Fix typo in checking OFFSET.\n+\n+\t* gbl-ctors.h (atexit): Don't define unless needed.\n+\n+\t* combine.c (distribute_notes): Completely check for note operand being\n+\tonly partially set on potential note target; adjust what notes\n+\twe make in that case.\n+\n+\t* i386/xm-go32.h (HAVE_{BCOPY,BZERO,INDEX,RINDEX}): Deleted.\n+\n+Wed Feb 11 08:53:27 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* calls.c (emit_call_1): Size args now HOST_WIDE_INT.\n+\t(expand_call): struct_value_size now HOST_WIDE_INT.\n+\n+Tue Feb 10 09:04:39 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* integrate.c (initialize_for_inline): Ensure DECL_INCOMING_RTL\n+\tis always copied.\n+\n+Tue Feb 10 06:10:49 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* cccp.c (rescan): Fix bug with macro name appearing\n+\timmediately after L'x'.\n+\n+Mon Feb  9 20:45:32 1998  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>\n+\n+\t* c-common.c (format_char_info): Add new field zlen.\n+\t(print_char_table): Remove entry for 'Z' as a format character.\n+\tInitialize zlen field as appropriate.\n+\t(scan_char_table): Set zlen field to NULL in each entry.\n+\t(check_format_info): Recognize 'Z' as a length modifier, with a\n+\twarning in pedantic mode.\n+\tAvoid infinite loop when a repeated flag character is detected.\n+\n+Mon Feb  9 09:24:04 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* c-parse.in (primary): Minor wording fix in diagnostic.\n+\n+Mon Feb  9 07:50:19 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* c-decl.c (grokdeclarator): Remove warning on inline of varargs.\n+\n+\t* reload.c (find_reloads): Check for const_to_mem case before\n+\tchecking for invalid reload; use force_const_mem if no_input_reloads.\n+\n+\t* function.c (push_function_context_to): Call init_emit last.\n+\n+\t* protoize.c (my_link): Define as -1 in mingw32.\n+\t(link): Remove declaration.\n+\n+\t* rs6000.c (setup_incoming_varargs): Always set rs6000_sysv_varargs_p.\n+\n+\t* integrate.c (expand_inline_function): Clear label_map with bzero.\n+\n+\t* unroll.c (copy_loop_body, case JUMP_INSN): Correct error in last\n+\tchange: call single_set on COPY, not INSN.\n+\n+Sun Feb  8 08:07:37 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* msdos/top.sed, winnt/config-nt.sed: Change version number to 2.8.1.\n+\n+\t* configure.in (i[3456]86-*-sco3.2v5*): Use cpio for headers.\n+\n+Sat Feb  7 07:32:46 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* i386/mingw32.h (LIBGCC_SPEC, STARTFILE_SPEC, MATH_LIBRARY):\n+\tUse msvcrt, not crtdll.\n+\n+Fri Feb  6 20:32:06 1998  Geert Bosch  <bosch@gnat.com>\n+\n+\t* i386/xm-os2.h (EMX, USG, BSTRING, HAVE_{PUTENV,VPRINTF,STRERROR}):\n+\tDefine ifdef __EMX__.\n+\t(strcasecmp): Define to be stricmp if __EMX__.\n+\t(spawnv{,p}): Don't define if EMX.\n+\t(OBJECT_SUFFIX): Don't define if EMX.\n+\t(MKTEMP_EACH_FILE): Define.\n+\n+Fri Feb  6 16:37:29 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* objc/Make-lang.in (objc.stage1): Depend on stage1-start.\n+\t(objc.stage2, objc.stage3, objc.stage4): Likewise for the\n+\trespective stageN-start targets. \n+\t(objc/sendmsg.o): Depend on objc/runtime-info.h.\n+\n+Fri Feb  6 16:27:09 1998  Bernd Schmidt  <crux@Pool.Informatik.RWTH-Aachen.DE>\n+\n+\t* stmt.c (expand_asm_operands): Properly treat asm statement\n+\tstatements with no operands as volatile.\n+\n+Fri Feb  6 16:03:25 1998  Greg McGary  <gkm@gnu.org>\n+\n+\t* c-decl.c (pushdecl): Set DECL_ORIGINAL_TYPE once only.\n+\n+Fri Feb  6 15:57:36 1998  Mumit Khan <khan@xraylith.wisc.edu>\n+\n+\t* i386/cygwin32.h (STRIP_NAME_ENCODING): New macro.\n+\n+Fri Feb  6 15:50:42 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* libgcc2.c (__floatdi[xtds]f): Round properly even when rounding\n+\tlarge negative integer to plus or minus infinity.\n+\n+Fri Feb  6 15:45:16 1998  Philippe De Muyter  <phdm@macqel.be>\n+\n+\t* sdbout.c (plain_type_1): Return T_DOUBLE, not T_VOID, for\n+\tlong double #ifndef EXTENDED_SDB_BASIC_TYPES.\n+\n+Fri Feb  6 15:23:49 1998  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n+\n+\t* vax/ultrix.h (HAVE_ATEXIT): Define.\n+\t* x-vax: File deleted.\n+\n+Fri Feb  6 14:34:19 1998  Douglas Rupp <rupp@gnat.com>\n+\n+\t* gcc.c (process_command, case \"-dumpversion\"): Print spec_version.\n+\n+Fri Feb  6 11:01:13 1998  Josh Littlefield  <josh@american.com>\n+\n+\t* i386/gmon-sol2.c (internal_mcount): Do set-up when program starts\n+\tand install hook to do clean-up when it exits.\n+\t* i386/sol2-c1.asm (_mcount): Make a weak instead of global symbol.\n+\t* i386/sol2dbg.h (ASM_SPEC): Support Solaris bundled assembler's -V\n+\targument; pass -s argument to assembler.\n+\t\n+Fri Feb  6 09:13:21 1998  Jim Wilson  (wilson@cygnus.com)\n+\n+\t* function.c (assign_parms): New variable named_arg, with value\n+\tdepending on STRICT_ARGUMENT_NAMING.  Use instead of ! last_named.\n+\n+\t* crtstuff.c (__frame_dummy): New function for irix6.\n+\t(__do_global_ctors): Call __frame_dummy for irix6.\n+\t* mips/iris6.h (LINK_SPEC): Hide __frame_dummy too.\n+\n+Fri Feb  6 09:08:21 1998  Mike Stump  <mrs@wrs.com>\n+\n+\t* rtlanal.c (dead_or_set_regno_p): Ignore REG_DEAD notes after reload.\n+\t* genattrtab.c (reload_completed): Define.\n+\n+\t* configure.in (i960-wrs-vxworks): Same as i960-wrs-vxworks5*.\n+\n+Fri Feb  6 08:47:38 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* Makefile.in (diff): Add INSTALL, configure, and config.in;\n+\tremove objc-*.\n+\t* objc/config-lang.in (diff_excludes): Add objc-parse.[cy].\n+\n+\t* i386/xm-mingw32.h (link): Delete macro.\n+\n+\t* alpha.c (output_prolog): Write out frame sizes as longs and\n+\tprint too large sizes as zero.\n+\n+\t* function.c (combine_temp_slots): No need to allocate and free rtx.\n+\tDon't do anything if too many slots in the list.\n+\t(put_var_into_stack): Don't use ADDRESSOF if not optimizing.\n+\n+\t* function.c (purge_addressof_1): Force into mem if VOLATILE reference.\n+\n+\t* calls.c (expand_call): Show VAR_DECL made for structure return\n+\taddress is used; remove bogus set of MEM_IN_STRUCT_P.\n+\t* expr.c (expand_expr, case SAVE_EXPR, case TARGET_EXPR): Show used.\n+\t(expand_builtin, case BUILT_IN_LONGJMP): Show __dummy used.\n+\t* function.c (put_reg_into_stack): New arg USED_P; all callers changed.\n+\n+\t* expr.c (expand_expr, case SAVE_EXPR): assign_temp with KEEP of 3.\n+\t* function.c (var_temp_slot_level): New variable.\n+\t(push_function_context_to, pop_function_context_from): Save/restore\n+\tit and target_temp_slot_level.\n+\t(assign_stack_temp): Implement KEEP of 3.\n+\t(push_temp_slots_for_block): New function.\n+\t(init_temp_slots): Initialize var_temp_slot_level.\n+\t* function.h (struct function, fields {var,target}_temp_slot_level):\n+\tNew fields.\n+\t* stmt.c (expand_start_bindings): Call push_temp_slots_for_block.\n+\n+\t* function.c (struct temp_slot): SIZE, BASE_OFF_SET, and FULL_SIZE\n+\tnow HOST_WIDE_INT.\n+\t(assign_{,outer_}stack_local, assign_{,stack_}temp): Size arg is\n+\tnow HOST_WIDE_INT.\n+\t(assign_stack_temp): Do size computations in HOST_WIDE_INT.\n+\t(fixup_var_refs_1, optimize_bit_field, instantiate_decls): Likewise.\n+\t(instantiate_virtual_regs_1, fix_lexical_address): Likewise.\n+\t* rtl.h (assign_stack_{local,temp}): Size arg is HOST_WIDE_INT.\n+\t(assign_temp): Likewise.\n+\t* expr.h (struct args_size): Field CONSTANT is now HOST_WIDE_INT.\n+\n+\t* sched.c (attach_deaths, case REG): Don't check for REG_UNUSED.\n+\t(attach_deaths, case SUBREG, STRICT_LOW_PART, {ZERO,SIGN}_EXTRACT):\n+\tDon't pass set_p of 1 if partial assignment.\n+\n+\t* tree.h (size_in_bytes): Returns HOST_WIDE_INT.\n+\t* tree.c (size_in_bytes): Likewise.\n+\tTighen up logic some to avoid returning a bogus value instead of -1.\n+\n+\t* expr.c (get_inner_reference, case ARRAY_EXPR): Make WITH_RECORD_EXPR\n+\tjust for index.\n+\t(expand_expr, case PLACEHOLDER_EXPR): Refine search again; look\n+\tat each expression and look for pointer to type.\n+\n+\t* expr.c (safe_from_p, case ADDR_EXPR): If TREE_STATIC, no trampoline.\n+\t(expand_expr, case ADDR_EXPR): Likewise.\n+\n+\t* expr.c (emit_block_move): Use conservative range for movstr mode.\n+\n+\t* configure.in: See if \"cp -p\" works if \"ln -s\" doesn't; else \"cp\".\n+\n+\t* combine.c (try_combine.c): Pass elim_i2 and elim_i1 to\n+\tdistribute_notes for i3dest_killed REG_DEAD note.\n+\n+\t* configure.in (mips-dec-netbsd*): Remove bogus setting of prefix.\n+\n+\t* c-decl.c (duplicate_decls): Set DECL_IGNORED_P in newdecl if\n+\tdifferent bindings levels.\n+\n+\t* configure.in: Test ln -s by symlinking gcc.c.\n+\n+\t* configure.in (i[3456]86-dg-dgux): Add wildcard for version.\n+\n+\t* crtstuff.c (__do_global_ctors_aux): Switch back to text section\n+\tin proper place.\n+\n+\t* rtlanal.c (rtx_varies_p, case REG): pic_offset_table_rtx is fixed.\n+\t* genattrtab.c (pic_offset_table_rtx): Define (dummy).\n+\t* cse.c (set_nonvarying_address_components): Understand PIC refs.\n+\n+\t* loop.c (strength_reduce): When placing increment for auto-inc\n+\tcase, do comparison in loop order.\n+\n+\t* i860.c (output_delayed_branch): Add missing arg to recog.\n+\t(output_delay_insn): Add missing arg to constrain_operands.\n+\n+\t* configure.in: Truncate target after finished comparing it with host.\n+\n+\t* i386.h (MAX_FIXED_MODE_SIZE): Delete.\n+\n+\t* c-parse.in (expr_no_comma): Clarify undefined error.\n+\n+\t* prefix.c (get_key_value): Don't default to PREFIX here.\n+\t(translate_name): Remove bogus addition of \"$\" if getenv fails;\n+\tclean up application of default value of PREFIX.\n+\n+\t* fold-const.c (fold_convert): Call force_fit_type even if input\n+\talready overflows.\n+\n+Fri Feb  6 07:45:01 1998  Robert Hoehne <robert.hoehne@gmx.net>\n+\n+\t* i386/xm-go32.h (HAVE_{BCOPY,BZERO,BCMP,RINDEX,INDEX}): Define.\n+\n+        * gcc.c (main): Treat paths starting with '$' or DOS drives\n+\tas absolute in standard_startfile_prefix.\n+\n+Thu Feb  5 21:07:12 1998  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n+\n+\t* cpplib.c (IS_INCLUDE_DIRECTIVE_TYPE): Add casts from enum to int.\n+\t* cccp.c (IS_INCLUDE_DIRECTIVE_TYPE, handle_directive): Likewise.\n+\n+Thu Feb  5 19:00:44 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.c (expand_expr, case CONSTRUCTOR): Correct shift count\n+\twhen making signed bit field; use EXPAND_NORMAL, not 0.\n+\n+Thu Feb  5 17:42:43 1998  Manfred Hollstein  <manfred@s-direktnet.de>\n+\n+\t* libgcc2.c (__clear_insn_cache): On sysV68 enable the memctl\n+\tstuff only if MCT_TEXT is #define'd.\n+\n+Thu Feb  5 17:32:01 1998  Robert Hoehne  <robert.hoehne@gmx.net>\n+\n+\t* Makefile.in: Changed most stamp-* to s-*.\n+\n+Tue Feb  3 19:45:50 1998  James Hawtin <oolon@ankh.org>\n+\n+\t* i386/sol2.h (STARTFILE_SPEC, LIB_SPEC): Update -pg files.\n+\t* configure.in (i[3456]86-*-solaris2*): Add gcrt1.o and gmon.o\n+\tto extra_parts.\n+\n+Tue Feb  3 17:28:48 1998  Christopher C Chimelis <chris@classnet.med.miami.edu>\n+\n+\t* configure.in (alpha*-*-linux-gnu*): Add extra_parts for crtstuff.\n+\n+Tue Feb  3 17:18:19 1998  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (find_barrier): Fix one-too-many bug if fail to find barrier.\n+\n+\t* arm.c (arm_reload_in_hi): Handle cases where the MEM is too \n+\tcomplex for a simple offset.\n+\n+Tue Feb  3 16:14:21 1998  Robert Hoehne  <robert.hoehne@gmx.net>\n+\n+\t* i386/xm-go32.h (EXECUTABLE_SUFFIX): Define.\n+\n+\t* configure.in (i[3456]86-pc-msdosdjgpp*): New entry.\n+\n+Tue Feb  3 07:33:58 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* explow.c (probe_stack_range): Properly check for small\n+\tnumber of probes.\n+\n+\t* gcc.c (process_command, case 'V'): Validate arg.\n+\n+\t* configure.in (sbrk): Add check for needed declaration.\n+\t* acconfig.h (NEED_DECLARATION_SBRK): New entry.\n+\t* toplev.c (sbrk): Update declaration conditional.\n+\t* mips-tfile.c (sbrk, free): Likewise.\n+\n+\t* sparc/sysv4.h (DBX_REGISTER_NUMBER): Remove abort.\n+\n+\t* mips.c (mips_expand_prologue): Pass reg 25 to gen_loadgp.\n+\t* mips.md (loadgp): Add second operand for register number to add.\n+\t(builtin_setjmp_receiver): Pass new label and reg 31 to loadgp.\n+\n+\t* toplev.c: Include insn-codes.h, insn-config.h, and recog.h.\n+ \t(compile_file): Try to emit nop to separate gcc_compiled symbol.\n+\t* Makefile.in (toplev.o): Depends on insn-{codes,config}.h, recog.h.\n+\n+Tue Feb  3 06:58:46 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* integrate.c (get_label_from_map): New function.\n+\t(expand_inline_function): Use it.\n+\tInitialize label_map to NULL_RTX instead of gen_label_rtx.\n+\t(copy_rtx_and_substitute): Use get_label_from_map.\n+\t* integrate.h (get_label_from_map): New function.\n+\t(set_label_from_map): New macro.\n+\t* unroll.c (unroll_loop, copy_loop_body): Use them.\n+\t\n+Mon Feb  2 16:33:01 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* i386.md (mov{si,hi,sf,df,xf}cc{,_1}): Remove cases with branches.\n+\n+\t* rs6000/x-aix31 (INSTALL): Deleted.\n+\t* mips/x-dec-osf1, mips/x-osfrose, i386/x-osfrose: Likewise.\n+\t* arm/x-riscix: Likewise.\n+\n+\t* c-typeck.c (signed_or_unsigned_type): Properly handle pointer types.\n+\n+Mon Feb  2 15:33:58 1998  Michael P. Hayes  <michaelh@ongaonga.chch.cri.nz>\n+\n+\t* unroll.c (copy_loop_body):  Use single_set instead of\n+\tPATTERN to detect increment of an iv inside a PARALLEL.\n+\n+Fri Jan 16 20:29:50 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* toplev.c (<unistd.h>): New include.\n+\t(get_run_time): Prefer CLK_TCK (if available) to HZ, and\n+\tprefer sysconf (_SC_CLK_TCK) (if available) to CLK_TCK.\n+\t* configure.in (sysconf): Call AC_CHECK_FUNCS.\n+\n+Wed Jan 14 20:10:51 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* cccp.c: (rescan): Don't report line 0 as the possible real start\n+\tof an unterminated string constant.\n+\tDon't mishandle backslash-newlines that in are the output of\n+\ta macro expansion.  Properly skip // style comments between a function\n+\tmacro name and '(', as well as backslash-newlines in comments there.\n+\t(handle_directive): Handle / \\ newline * between # and directive name.\n+\tIn #include directives, \\ does not escape \".\n+\t(do_include): For `#include \"file', do not bother expanding into temp\n+\tbuffer.  When error encountered when expanding, do not try result.\n+\t(skip_if_group): When skipping an include directive, use include\n+\ttokenization, not normal tokenization.  Backslash-newline is still\n+\tspecial when skipping.  Handle * \\ newline / correctly in comments\n+\twhen skipping.\n+\t(skip_quoted_string): After \\ newline, set *backslash_newlines_p\n+\teven if count_newlines is 0.\n+\t(macroexpand): Newline space is not a special marker inside a string.\n+\t(macroexpand, macarg): Do not generate \\ddd for control characters\n+\twhen stringifying; the C Standard does not allow this.\n+\t(macarg1): New arg MACRO.  All callers changed.\n+\tDo not treat /*, //, or backslash-newline specially when processing\n+\tthe output of a macro.\n+\t(discard_comments): Don't go past limit if looking for end of comment.\n+\tDiscard backslash-newline properly when discarding comments.\n+\t(change_newlines): \\\" does not end a string.\n+\t(make_definition): Do not treat backslash-newline specially, as it\n+\thas already been removed before we get here.\n+\t\n+\t* profile.c (output_func_start_profiler): Don't fflush output\n+\tif -quiet.\n+\t* toplev.c (rest_of_compilation): Likewise.\n+\n+\t* i386/x-sco5 (CC): Remove trailing white space.\n+\t* x-convex (CCLIBFLAGS): Likewise.\n+\t* arm/t-semi (LIBGCC2_CFLAGS): Likewise.\n+\n+Wed Jan  7 18:02:42 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* Version 2.8.0 released.\n+\n+Wed Jan  7 17:54:41 1998  J. Kean Johnston  <jkj@sco.com>\n+\n+\t* i386/sco5.h ({END,START}FILE_SPEC): Link with correct crtbegin.o\n+\tand crtend.o when using -static.\n+\n+Wed Jan  7 17:49:14 1998  Jan Christiaan van Winkel <Jan.Christiaan.van.Winkel@ATComputing.nl>\n+\n+\t* cppexp.c (gansidecl.h): Include.\n+\n+Wed Jan  7 17:45:07 1998  Tristan Gingold  <gingold@puccini.enst.fr>\n+\n+\t* expr.c (get_push_address): Use copy_to_reg instead of force_operand.\n+\t(emit_push_insn): Avoid null pointer deference if aggregate has no\n+\ttypes.\n+\t(expand_expr): Avoid finite but useless recursion.\n+\t(expand_builtin): Fix typo in calling function.\n+\t* function.c (assign_parms): Avoid useless call to chkr_set_right.\n+\n+Wed Jan  7 17:31:13 1998  Christian Iseli  <Christian.Iseli@lslsun.epfl.ch>\n+\n+\t* combine.c (force_to_mode): Return if operand is a CLOBBER.\n+\n+Wed Jan  7 17:23:24 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* x-rs6000 (INSTALL): Remove.\n+\n+\t* jump.c (jump_optimize): Don't use a hard reg as an operand\n+\tof a conditional move if small register classes.\n+\n+Wed Jan  7 17:09:28 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* cse.c (max_insn_uid): New variable.\n+\t(cse_around_loop): Use it.\n+\t(cse_main): Set it.\n+\n+See ChangeLog.11 for earlier changes.\n+\f\n+Use a consistent time stamp format in ChangeLog entries.\n+Not everyone has Emacs 20 yet, so stick with Emacs 19 format for now.\n+\n+Local Variables:\n+add-log-time-format: current-time-string\n+End:"}, {"sha": "ea37a4eaeb921c16b060a7715d6c3eaa78c16fa7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 85, "deletions": 92, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n # Makefile for GNU C compiler.\n-#   Copyright (C) 1987, 88, 90-96, 1997 Free Software Foundation, Inc.\n+#   Copyright (C) 1987, 88, 90-97, 1998 Free Software Foundation, Inc.\n \n #This file is part of GNU CC.\n \n@@ -234,6 +234,8 @@ libsubdir = $(libdir)/gcc-lib/$(target_alias)/$(version)\n # Directory in which the compiler finds g++ includes.\n gxx_include_dir= @gxx_include_dir@\n # Directory in which the old g++ header files may be found.\n+# The reason we use $(libdir)/g++-include rather than using libsubdir\n+# is for compatibility with older versions of libg++.\n old_gxx_include_dir= $(libdir)/g++-include\n # Directory to search for site-specific includes.\n includedir = $(local_prefix)/include\n@@ -612,9 +614,9 @@ CCCP=cccp\n STAGESTUFF = *$(objext) insn-flags.h insn-config.h insn-codes.h \\\n  insn-output.c insn-recog.c insn-emit.c insn-extract.c insn-peep.c \\\n  insn-attr.h insn-attrtab.c insn-opinit.c genrtl.c genrtl.h \\\n- stamp-flags stamp-config stamp-codes stamp-mlib \\\n- stamp-output stamp-recog stamp-emit stamp-extract stamp-peep \\\n- stamp-attr stamp-attrtab stamp-opinit stamp-crt stamp-crtS stamp-crt0 \\\n+ s-flags s-config s-codes s-mlib \\\n+ s-output s-recog s-emit s-extract s-peep \\\n+ s-attr s-attrtab s-opinit s-crt s-crtS s-crt0 \\\n  genemit$(build_exeext) genoutput$(build_exeext) genrecog$(build_exeext) \\\n  genextract$(build_exeext) genflags$(build_exeext) gencodes$(build_exeext) \\\n  genconfig$(build_exeext) genpeep$(build_exeext) genattrtab$(build_exeext) \\\n@@ -1093,16 +1095,16 @@ libgcc.a: $(LIBGCC1) $(LIBGCC2)\n # Use the genmultilib shell script to generate the information the gcc\n # driver program needs to select the library directory based on the\n # switches.\n-multilib.h: stamp-mlib; @true\n-stamp-mlib: $(srcdir)/genmultilib Makefile\n+multilib.h: s-mlib; @true\n+s-mlib: $(srcdir)/genmultilib Makefile\n \t$(SHELL) $(srcdir)/genmultilib \\\n \t  \"$(MULTILIB_OPTIONS)\" \\\n \t  \"$(MULTILIB_DIRNAMES)\" \\\n \t  \"$(MULTILIB_MATCHES)\" \\\n \t  \"$(MULTILIB_EXCEPTIONS)\" \\\n \t  \"$(MULTILIB_EXTRA_OPTS)\" > tmp-mlib.h\n \t$(srcdir)/move-if-change tmp-mlib.h multilib.h\n-\ttouch stamp-mlib\n+\ttouch s-mlib\n \n # Build multiple copies of libgcc.a, one for each target switch.\n stmp-multilib: $(LIBGCC1) libgcc2.c libgcc2.ready $(CONFIG_H) \\\n@@ -1189,9 +1191,9 @@ $(T)crtend.o: crtstuff.c $(GCC_PASSES) $(CONFIG_H) \\\n \n # On some systems we also want to install versions of these files\n # compiled using PIC for use in shared libraries.\n-crtbeginS.o crtendS.o: stamp-crtS ; @true\n+crtbeginS.o crtendS.o: s-crtS ; @true\n \n-stamp-crtS: crtstuff.c $(GCC_PASSES) $(CONFIG_H) \\\n+s-crtS: crtstuff.c $(GCC_PASSES) $(CONFIG_H) \\\n   defaults.h frame.h gbl-ctors.h\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(CRTSTUFF_T_CFLAGS_S) \\\n \t  -DCRT_BEGIN -finhibit-size-directive -fno-inline-functions \\\n@@ -1200,18 +1202,18 @@ stamp-crtS: crtstuff.c $(GCC_PASSES) $(CONFIG_H) \\\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(CRTSTUFF_T_CFLAGS_S) \\\n \t  -DCRT_END -finhibit-size-directive -fno-inline-functions \\\n \t  -g0 -c $(srcdir)/crtstuff.c -o crtendS$(objext)\n-\ttouch stamp-crtS\n+\ttouch s-crtS\n \n # Compile the start modules crt0.o and mcrt0.o that are linked with every program\n-crt0.o: stamp-crt0 ; @true\n-mcrt0.o: stamp-crt0; @true\n+crt0.o: s-crt0 ; @true\n+mcrt0.o: s-crt0; @true\n \n-stamp-crt0:\t$(CRT0_S) $(MCRT0_S) $(GCC_PASSES) $(CONFIG_H)\n+s-crt0:\t$(CRT0_S) $(MCRT0_S) $(GCC_PASSES) $(CONFIG_H)\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(CRT0STUFF_T_CFLAGS) \\\n \t  -o crt0.o -c $(CRT0_S)\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(CRT0STUFF_T_CFLAGS) \\\n \t  -o mcrt0.o -c $(MCRT0_S)\n-\ttouch stamp-crt0\n+\ttouch s-crt0\n #\f\n # Compiling object files from source files.\n \n@@ -1274,9 +1276,9 @@ tlink.o: tlink.c $(DEMANGLE_H) hash.h $(CONFIG_H) system.h\n hash.o: hash.c hash.h system.h\n cplus-dem.o: cplus-dem.c $(DEMANGLE_H)\n \n-underscore.c: stamp-under ; @true\n+underscore.c: s-under ; @true\n \n-stamp-under: $(GCC_PASSES)\n+s-under: $(GCC_PASSES)\n \techo \"int xxy_us_dummy;\" >tmp-dum.c\n \t$(GCC_FOR_TARGET) -S tmp-dum.c\n \techo '/*WARNING: This file is automatically generated!*/' >tmp-under.c\n@@ -1287,7 +1289,7 @@ stamp-under: $(GCC_PASSES)\n \tfi\n \t$(srcdir)/move-if-change tmp-under.c underscore.c\n \t-rm -f tmp-dum.c tmp-dum.s\n-\ttouch stamp-under\n+\ttouch s-under\n \n # A file used by all variants of C.\n \n@@ -1327,6 +1329,7 @@ stor-layout.o : stor-layout.c $(CONFIG_H) system.h $(TREE_H) flags.h \\\n fold-const.o : fold-const.c $(CONFIG_H) system.h $(TREE_H) flags.h\n toplev.o : toplev.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) \\\n    flags.h input.h insn-attr.h xcoffout.h defaults.h output.h \\\n+   insn-codes.h insn-config.h recog.h Makefile \\\n    $(lang_options_files)\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(MAYBE_USE_COLLECT2) \\\n \t  -DTARGET_NAME=\\\"$(target_alias)\\\" \\\n@@ -1476,7 +1479,7 @@ alloca.o:\talloca.c\n # Each of the other insn-* files is handled by a similar pair of rules.\n \n # This causes an anomaly in the results of make -n\n-# because insn-* is older than stamp-*\n+# because insn-* is older than s-*\n # and thus make -n thinks that insn-* will be updated\n # and force recompilation of things that depend on it.\n # We use move-if-change precisely to avoid such recompilation.\n@@ -1488,84 +1491,84 @@ alloca.o:\talloca.c\n # versions of make which don't like empty commands (nothing after the\n # trailing `;'), we call true for each.\n \n-insn-config.h: stamp-config ; @true\n-stamp-config : $(md_file) genconfig $(srcdir)/move-if-change\n+insn-config.h: s-config ; @true\n+s-config : $(md_file) genconfig $(srcdir)/move-if-change\n \t./genconfig $(md_file) > tmp-config.h\n \t$(srcdir)/move-if-change tmp-config.h insn-config.h\n-\ttouch stamp-config\n+\ttouch s-config\n \n-insn-flags.h: stamp-flags ; @true\n-stamp-flags : $(md_file) genflags $(srcdir)/move-if-change\n+insn-flags.h: s-flags ; @true\n+s-flags : $(md_file) genflags $(srcdir)/move-if-change\n \t./genflags $(md_file) > tmp-flags.h\n \t$(srcdir)/move-if-change tmp-flags.h insn-flags.h\n-\ttouch stamp-flags\n+\ttouch s-flags\n \n-insn-codes.h: stamp-codes ; @true\n-stamp-codes : $(md_file) gencodes $(srcdir)/move-if-change\n+insn-codes.h: s-codes ; @true\n+s-codes : $(md_file) gencodes $(srcdir)/move-if-change\n \t./gencodes $(md_file) > tmp-codes.h\n \t$(srcdir)/move-if-change tmp-codes.h insn-codes.h\n-\ttouch stamp-codes\n+\ttouch s-codes\n \n insn-emit.o : insn-emit.c $(CONFIG_H) $(RTL_H) expr.h real.h output.h \\\n   insn-config.h insn-flags.h insn-codes.h system.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-emit.c\n \n-insn-emit.c: stamp-emit ; @true\n-stamp-emit : $(md_file) genemit $(srcdir)/move-if-change\n+insn-emit.c: s-emit ; @true\n+s-emit : $(md_file) genemit $(srcdir)/move-if-change\n \t./genemit $(md_file) > tmp-emit.c\n \t$(srcdir)/move-if-change tmp-emit.c insn-emit.c\n-\ttouch stamp-emit\n+\ttouch s-emit\n \n insn-recog.o : insn-recog.c $(CONFIG_H) $(RTL_H) insn-config.h $(RECOG_H) \\\n   real.h output.h flags.h system.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-recog.c\n \n-insn-recog.c: stamp-recog ; @true\n-stamp-recog : $(md_file) genrecog $(srcdir)/move-if-change\n+insn-recog.c: s-recog ; @true\n+s-recog : $(md_file) genrecog $(srcdir)/move-if-change\n \t./genrecog $(md_file) > tmp-recog.c\n \t$(srcdir)/move-if-change tmp-recog.c insn-recog.c\n-\ttouch stamp-recog\n+\ttouch s-recog\n \n insn-opinit.o : insn-opinit.c $(CONFIG_H) $(RTL_H) insn-codes.h insn-flags.h \\\n   insn-config.h flags.h $(RECOG_H) expr.h reload.h system.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-opinit.c\n \n-insn-opinit.c: stamp-opinit ; @true\n-stamp-opinit : $(md_file) genopinit $(srcdir)/move-if-change\n+insn-opinit.c: s-opinit ; @true\n+s-opinit : $(md_file) genopinit $(srcdir)/move-if-change\n \t./genopinit $(md_file) > tmp-opinit.c\n \t$(srcdir)/move-if-change tmp-opinit.c insn-opinit.c\n-\ttouch stamp-opinit\n+\ttouch s-opinit\n \n insn-extract.o : insn-extract.c $(CONFIG_H) $(RTL_H) system.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-extract.c\n \n-insn-extract.c: stamp-extract ; @true\n-stamp-extract : $(md_file) genextract $(srcdir)/move-if-change\n+insn-extract.c: s-extract ; @true\n+s-extract : $(md_file) genextract $(srcdir)/move-if-change\n \t./genextract $(md_file) > tmp-extract.c\n \t$(srcdir)/move-if-change tmp-extract.c insn-extract.c\n-\ttouch stamp-extract\n+\ttouch s-extract\n \n insn-peep.o : insn-peep.c $(CONFIG_H) $(RTL_H) regs.h output.h real.h system.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-peep.c\n \n-insn-peep.c: stamp-peep ; @true\n-stamp-peep : $(md_file) genpeep $(srcdir)/move-if-change\n+insn-peep.c: s-peep ; @true\n+s-peep : $(md_file) genpeep $(srcdir)/move-if-change\n \t./genpeep $(md_file) > tmp-peep.c\n \t$(srcdir)/move-if-change tmp-peep.c insn-peep.c\n-\ttouch stamp-peep\n+\ttouch s-peep\n \n insn-attrtab.o : insn-attrtab.c $(CONFIG_H) $(RTL_H) regs.h real.h output.h \\\n      insn-attr.h insn-config.h system.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-attrtab.c\n \n-insn-attr.h: stamp-attr ; @true\n-stamp-attr : $(md_file) genattr $(srcdir)/move-if-change\n+insn-attr.h: s-attr ; @true\n+s-attr : $(md_file) genattr $(srcdir)/move-if-change\n \t./genattr $(md_file) > tmp-attr.h\n \t$(srcdir)/move-if-change tmp-attr.h insn-attr.h\n-\ttouch stamp-attr\n+\ttouch s-attr\n \n-insn-attrtab.c: stamp-attrtab ; @true\n-stamp-attrtab : $(md_file) genattrtab $(srcdir)/move-if-change\n+insn-attrtab.c: s-attrtab ; @true\n+s-attrtab : $(md_file) genattrtab $(srcdir)/move-if-change\n \tif cmp -s $(PREMADE_ATTRTAB_MD) $(md_file);\t\\\n \tthen\t\t\t\t\t\\\n \t  echo Using $(PREMADE_ATTRTAB);\t\\\n@@ -1574,28 +1577,28 @@ stamp-attrtab : $(md_file) genattrtab $(srcdir)/move-if-change\n \t  ./genattrtab $(md_file) > tmp-attrtab.c;\t\\\n \tfi\n \t$(srcdir)/move-if-change tmp-attrtab.c insn-attrtab.c\n-\ttouch stamp-attrtab\n+\ttouch s-attrtab\n \n insn-output.o : insn-output.c $(CONFIG_H) $(RTL_H) regs.h real.h conditions.h \\\n     hard-reg-set.h insn-config.h insn-flags.h insn-attr.h output.h $(RECOG_H) \\\n     insn-codes.h system.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-output.c\n \n-insn-output.c: stamp-output ; @true\n-stamp-output : $(md_file) genoutput $(srcdir)/move-if-change\n+insn-output.c: s-output ; @true\n+s-output : $(md_file) genoutput $(srcdir)/move-if-change\n \t./genoutput $(md_file) > tmp-output.c\n \t$(srcdir)/move-if-change tmp-output.c insn-output.c\n-\ttouch stamp-output\n+\ttouch s-output\n \n genrtl.o : genrtl.c $(CONFIG_H) $(RTL_H)\n-genrtl.c genrtl.h : stamp-genrtl\n+genrtl.c genrtl.h : s-genrtl\n \t@true\t# force gnu make to recheck modification times.\n \n-stamp-genrtl: gengenrtl $(srcdir)/move-if-change $(RTL_BASE_H)\n+s-genrtl: gengenrtl $(srcdir)/move-if-change $(RTL_BASE_H)\n \t./gengenrtl tmp-genrtl.h tmp-genrtl.c\n \t$(srcdir)/move-if-change tmp-genrtl.h genrtl.h\n \t$(srcdir)/move-if-change tmp-genrtl.c genrtl.c\n-\ttouch stamp-genrtl\n+\ttouch s-genrtl\n \n #\f\n # Compile the programs that generate insn-* from the machine description.\n@@ -1754,8 +1757,6 @@ $(srcdir)/cexp.c: $(srcdir)/cexp.y\n \tcd $(srcdir); $(BISON) -o cexp.c cexp.y\n \n cccp.o: cccp.c $(CONFIG_H) pcp.h version.c config.status\n-# The reason we use $(libdir)/g++-include rather than using libsubdir\n-# is for compatibility with the current version of libg++.\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t  -DGCC_INCLUDE_DIR=\\\"$(libsubdir)/include\\\" \\\n \t  -DGPLUSPLUS_INCLUDE_DIR=\\\"$(gxx_include_dir)\\\" \\\n@@ -1875,7 +1876,7 @@ gcov$(exeext): gcov.o $(LIBDEPS)\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) gcov.o $(LIBS) -o $@\n #\f\n # Build the include directory.  The stamp files are stmp-* rather than\n-# stamp-* so that mostlyclean does not force the include directory to\n+# s-* so that mostlyclean does not force the include directory to\n # be rebuilt.\n \n # Build the include directory except for float.h (which depends upon\n@@ -2061,14 +2062,10 @@ mostlyclean: lang.mostlyclean\n # Delete the temp files made in the course of building libgcc.a.\n \t-rm -f tmplibgcc* tmpcopy xlimits.h libgcc1-test\n \tfor name in $(LIB1FUNCS); do rm -f $${name}.c; done\n-# Delete other temporary files.\n-\t-rm -f tmp-float.h tmp-gcc.xtar.gz\n-\t-rm -f tmp-foo1 tmp-foo2 tmp-proto.* tmp-unproto.1 tmp-SYSCALLS.s\n-\t-rm -f tmp-c-parse.y tmp-gperf.h\n-\t-rm -f tmp-specs t-float.h-cross tmp-xlimits.h\n-\t-rm -f tmp-fixtmp.c xsys-protos.hT\n-# Delete the stamp files.\n-\t-rm -f stamp-* tmp-*\n+# Delete other built files.\n+\t-rm -f t-float.h-cross xsys-protos.hT fp-bit.c dp-bit.c\n+# Delete the stamp and temporary files.\n+\t-rm -f s-* tmp-* stamp-* stmp-*\n \t-rm -f */stamp-* */tmp-*\n # Delete debugging dump files.\n \t-rm -f *.greg *.lreg *.combine *.flow *.cse *.jump *.rtl *.tree *.loop\n@@ -2106,8 +2103,7 @@ clean: mostlyclean lang.clean\n \t  rm -f md ; \\\n \tfi\n # Delete the include directory.\n-\t-rm -rf stmp-* include\n-\t-rm -f */stmp-*\n+\t-rm -rf include\n # Delete files used by the \"multilib\" facility (including libgcc subdirs).\n \t-rm -f multilib.h tmpmultilib*\n \t-if [ \"x$(MULTILIB_DIRNAMES)\" != x ] ; then \\\n@@ -2142,7 +2138,7 @@ extraclean: distclean lang.extraclean\n \t-rm -f *.dvi *.ps *.oaux *.d *.[zZ] *.gz\n \t-rm -f *.tar *.xtar *diff *.diff.* *.tar.* *.xtar.* *diffs\n \t-rm -f *lose config/*lose config/*/*lose\n-\t-rm -f *.s *.s[0-9] *.i install1.texi config/ChangeLog\n+\t-rm -f *.s *.s[0-9] *.i config/ChangeLog\n \t-rm -f */=* */\"#\"* */*~*\n \t-rm -f */patch* */*.orig */*.rej\n \t-rm -f */*.dvi */*.oaux */*.d */*.[zZ] */*.gz\n@@ -2516,32 +2512,29 @@ check-g77: testsuite/site.exp\n # Update the tags table.\n TAGS: force\n \tcd $(srcdir);\t\t\t\t\t\t\t\\\n-\tmkdir temp;\t\t\t\t\t\t\t\\\n-\tmv -f c-parse.[ch] cexp.c =*.[chy] temp;\t\t\\\n+\tmkdir tmp-tags;\t\t\t\t\t\t\t\\\n+\tmv -f c-parse.[ch] cexp.c =*.[chy] tmp-tags;\t\t\t\\\n \tetags *.y *.h *.c;\t\t\t\t\t\t\\\n-\tmv temp/* .;\t\t\t\t\t\t\t\\\n-\trmdir temp\n-\n-# Create the distribution tar file.\n-#dist: gcc-$(version).tar.gz\n-dist: gcc.xtar.gz\n+\tmv tmp-tags/* .;\t\t\t\t\t\t\\\n+\trmdir tmp-tags\n \n-gcc.xtar.gz: gcc.xtar\n-\tgzip --best < gcc.xtar > tmp-gcc.xtar.gz\n-\tmv tmp-gcc.xtar.gz gcc.xtar.gz\n+# Create the distribution tar.gz file.\n+dist: tmp-gcc.xtar\n+\tgzip --best < tmp-gcc.xtar > tmp-gcc.xtar.gz\n+\tmv tmp-gcc.xtar.gz gcc-$(version).tar.gz\n \n-#gcc-$(version).tar.gz: gcc-$(version).tar\n-#\tgzip < gcc-$(version).tar > gcc-$(version).tar.gz\n-\n-#gcc-$(version).tar:\n-gcc.xtar: distdir\n+tmp-gcc.xtar: distdir\n # Make the distribution.\n-\ttar -chf gcc.xtar gcc-$(version)\n+\ttar -chf tmp-gcc.xtar gcc-$(version)\n+\n+distdir-cvs: force\n+\tif [ -d $(srcdir)/CVS ]; then cvs -r update; fi\n \n # This target exists to do the initial work before the language specific\n # stuff gets done.\n distdir-start: doc $(srcdir)/INSTALL $(srcdir)/c-parse.y $(srcdir)/c-gperf.h \\\n-  $(srcdir)/c-parse.c $(srcdir)/cexp.c $(srcdir)/config.in\n+  $(srcdir)/c-parse.c $(srcdir)/cexp.c $(srcdir)/config.in \\\n+  $(srcdir)/bi-parser.h $(srcdir)/bi-parser.c $(srcdir)/version.c TAGS\n \t@if grep -s \"for version ${mainversion}\" gcc.texi > /dev/null; \\\n \tthen true; \\\n \telse echo \"You must update the version number in \\`gcc.texi'\"; sleep 10;\\\n@@ -2563,7 +2556,7 @@ distdir-start: doc $(srcdir)/INSTALL $(srcdir)/c-parse.y $(srcdir)/c-gperf.h \\\n \tdone\n \tcd config; \\\n \tfor file in *[0-9a-zA-Z+]; do \\\n-\t  if test -d $$file && test \"$$file\" != RCS; then \\\n+\t  if test -d $$file && test \"$$file\" != RCS && test \"$$file\" != CVS; then \\\n \t    mkdir ../tmp/config/$$file; \\\n \t    cd $$file; \\\n \t    for subfile in *[0-9a-zA-Z+]; do \\\n@@ -2590,21 +2583,21 @@ distdir-finish:\n # Get rid of everything we don't want in the distribution.  We'd want\n # this to use Makefile.in, but it doesn't have the `lang.foo' targets\n # expanded.\n-\tcd gcc-$(version); make extraclean\n+\tcd gcc-$(version); make extraclean VERSION_DEP=\n \n-distdir: distdir-start lang.distdir distdir-finish\n+distdir: distdir-cvs distdir-start lang.distdir distdir-finish\n \n # make diff oldversion=M.N \n # creates a diff file between an older distribution and this one.\n # The -P option assumes this is GNU diff.\n diff:\n \tdiff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h \\\n-\t  -x cexp.c -x objc-parse.y -x objc-parse.c \\\n-\t  -x TAGS \\\n+\t  -x cexp.c -x bi-parser.c -x bi-parser.h -x TAGS -x INSTALL \\\n+\t  -x configure -x config.in \\\n \t  -x \"gcc.??\" -x \"gcc.??s\" -x gcc.aux -x \"gcc.info*\" \\\n \t  -x \"cpp.??\" -x \"cpp.??s\" -x cpp.aux -x \"cpp.info*\" \\\n \t  $(LANG_DIFF_EXCLUDES) \\\n-\t  gcc-$(oldversion) gcc-$(version) > diffs\n+\t  gcc-$(oldversion) gcc-$(version) > gcc-$(oldversion)-$(version).diff\n \n bootstrap bootstrap-lean: force\n # Only build the C compiler for stage1, because that is the only one that"}, {"sha": "28950fa190f37dfe669b3ef5a9d1cf92946f8294", "filename": "gcc/NEWS", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FNEWS?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,14 @@\n Noteworthy changes in GCC for EGCS.\n \n+Noteworthy changes in GCC version 2.8.1\n+---------------------------------------\n+\n+Numerous bugs have been fixed and some minor performance\n+improvements (compilation speed) have been made.\n+\n+Noteworthy changes in GCC version 2.8.0\n+---------------------------------------\n+\n A major change in this release is the addition of a framework for\n exception handling, currently used by C++.  Many internal changes and\n optimization improvements have been made.  These increase the"}, {"sha": "6a32c164ff7d4d80507aa0ebb616f95e1e8dfc6c", "filename": "gcc/README.RS6000", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2FREADME.RS6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2FREADME.RS6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FREADME.RS6000?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -120,4 +120,3 @@ an assembler modified after October 16th, 1995 in order to build the GNU C\n compiler.  This is because the GNU C compiler wants to build a variant of its\n library, libgcc.a with the -mcpu=common switch to support building programs\n that can run on either the Power or PowerPC machines.\n-"}, {"sha": "ea5dc51034b9522ddfaac748368c0b93a7b066a4", "filename": "gcc/acconfig.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Facconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Facconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Facconfig.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -40,7 +40,7 @@\n /* Whether atol must be declared even if <stdlib.h> is included.  */\n #undef NEED_DECLARATION_ATOL\n \n-/* Whether sbrk must be declared even if <unistd.h> is included.  */\n+/* Whether sbrk must be declared even if <stdlib.h> is included.  */\n #undef NEED_DECLARATION_SBRK\n \n /* Whether abort must be declared even if <stdlib.h> is included.  */"}, {"sha": "2422741ccee43db3b2f5be300f5034d2cf0ee7d7", "filename": "gcc/c-common.c", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines shared by all languages that are variants of C.\n-   Copyright (C) 1992, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -975,37 +975,39 @@ typedef struct {\n   /* Type of argument if length modifier `L' is used.\n      If NULL, then this modifier is not allowed.  */\n   tree *bigllen;\n+  /* Type of argument if length modifier `Z' is used.\n+     If NULL, then this modifier is not allowed.  */\n+  tree *zlen;\n   /* List of other modifier characters allowed with these options.  */\n   char *flag_chars;\n } format_char_info;\n \n static format_char_info print_char_table[] = {\n-  { \"di\",\t0,\tT_I,\tT_I,\tT_L,\tT_LL,\tT_LL,\t\"-wp0 +\"\t},\n-  { \"oxX\",\t0,\tT_UI,\tT_UI,\tT_UL,\tT_ULL,\tT_ULL,\t\"-wp0#\"\t\t},\n-  { \"u\",\t0,\tT_UI,\tT_UI,\tT_UL,\tT_ULL,\tT_ULL,\t\"-wp0\"\t\t},\n-/* Two GNU extensions.  */\n-  { \"Z\",\t0,\tT_ST,\tNULL,\tNULL,\tNULL,\tNULL,\t\"-wp0\"\t\t},\n-  { \"m\",\t0,\tT_V,\tNULL,\tNULL,\tNULL,\tNULL,\t\"-wp\"\t\t},\n-  { \"feEgGaA\",\t0,\tT_D,\tNULL,\tNULL,\tNULL,\tT_LD,\t\"-wp0 +#\"\t},\n-  { \"c\",\t0,\tT_I,\tNULL,\tT_W,\tNULL,\tNULL,\t\"-w\"\t\t},\n-  { \"C\",\t0,\tT_W,\tNULL,\tNULL,\tNULL,\tNULL,\t\"-w\"\t\t},\n-  { \"s\",\t1,\tT_C,\tNULL,\tT_W,\tNULL,\tNULL,\t\"-wp\"\t\t},\n-  { \"S\",\t1,\tT_W,\tNULL,\tNULL,\tNULL,\tNULL,\t\"-wp\"\t\t},\n-  { \"p\",\t1,\tT_V,\tNULL,\tNULL,\tNULL,\tNULL,\t\"-w\"\t\t},\n-  { \"n\",\t1,\tT_I,\tT_S,\tT_L,\tT_LL,\tNULL,\t\"\"\t\t},\n+  { \"di\",\t0,\tT_I,\tT_I,\tT_L,\tT_LL,\tT_LL,\tT_ST,\t\"-wp0 +\"\t},\n+  { \"oxX\",\t0,\tT_UI,\tT_UI,\tT_UL,\tT_ULL,\tT_ULL,\tT_ST,\t\"-wp0#\"\t\t},\n+  { \"u\",\t0,\tT_UI,\tT_UI,\tT_UL,\tT_ULL,\tT_ULL,\tT_ST,\t\"-wp0\"\t\t},\n+/* A GNU extension.  */\n+  { \"m\",\t0,\tT_V,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"-wp\"\t\t},\n+  { \"feEgGaA\",\t0,\tT_D,\tNULL,\tNULL,\tNULL,\tT_LD,\tNULL,\t\"-wp0 +#\"\t},\n+  { \"c\",\t0,\tT_I,\tNULL,\tT_W,\tNULL,\tNULL,\tNULL,\t\"-w\"\t\t},\n+  { \"C\",\t0,\tT_W,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"-w\"\t\t},\n+  { \"s\",\t1,\tT_C,\tNULL,\tT_W,\tNULL,\tNULL,\tNULL,\t\"-wp\"\t\t},\n+  { \"S\",\t1,\tT_W,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"-wp\"\t\t},\n+  { \"p\",\t1,\tT_V,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"-w\"\t\t},\n+  { \"n\",\t1,\tT_I,\tT_S,\tT_L,\tT_LL,\tNULL,\tNULL,\t\"\"\t\t},\n   { NULL }\n };\n \n static format_char_info scan_char_table[] = {\n-  { \"di\",\t1,\tT_I,\tT_S,\tT_L,\tT_LL,\tT_LL,\t\"*\"\t},\n-  { \"ouxX\",\t1,\tT_UI,\tT_US,\tT_UL,\tT_ULL,\tT_ULL,\t\"*\"\t},\t\n-  { \"efgEGaA\",\t1,\tT_F,\tNULL,\tT_D,\tNULL,\tT_LD,\t\"*\"\t},\n-  { \"sc\",\t1,\tT_C,\tNULL,\tT_W,\tNULL,\tNULL,\t\"*a\"\t},\n-  { \"[\",\t1,\tT_C,\tNULL,\tNULL,\tNULL,\tNULL,\t\"*a\"\t},\n-  { \"C\",\t1,\tT_W,\tNULL,\tNULL,\tNULL,\tNULL,\t\"*\"\t},\n-  { \"S\",\t1,\tT_W,\tNULL,\tNULL,\tNULL,\tNULL,\t\"*\"\t},\n-  { \"p\",\t2,\tT_V,\tNULL,\tNULL,\tNULL,\tNULL,\t\"*\"\t},\n-  { \"n\",\t1,\tT_I,\tT_S,\tT_L,\tT_LL,\tNULL,\t\"\"\t},\n+  { \"di\",\t1,\tT_I,\tT_S,\tT_L,\tT_LL,\tT_LL,\tNULL,\t\"*\"\t},\n+  { \"ouxX\",\t1,\tT_UI,\tT_US,\tT_UL,\tT_ULL,\tT_ULL,\tNULL,\t\"*\"\t},\t\n+  { \"efgEGaA\",\t1,\tT_F,\tNULL,\tT_D,\tNULL,\tT_LD,\tNULL,\t\"*\"\t},\n+  { \"sc\",\t1,\tT_C,\tNULL,\tT_W,\tNULL,\tNULL,\tNULL,\t\"*a\"\t},\n+  { \"[\",\t1,\tT_C,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"*a\"\t},\n+  { \"C\",\t1,\tT_W,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"*\"\t},\n+  { \"S\",\t1,\tT_W,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"*\"\t},\n+  { \"p\",\t2,\tT_V,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"*\"\t},\n+  { \"n\",\t1,\tT_I,\tT_S,\tT_L,\tT_LL,\tNULL,\tNULL,\t\"\"\t},\n   { NULL }\n };\n \n@@ -1345,7 +1347,7 @@ check_format_info (info, params)\n \t      if (index (flag_chars, *format_chars) != 0)\n \t\t{\n \t\t  sprintf (message, \"repeated `%c' flag in format\",\n-\t\t\t   *format_chars);\n+\t\t\t   *format_chars++);\n \t\t  warning (message);\n \t\t}\n \t      else\n@@ -1453,6 +1455,12 @@ check_format_info (info, params)\n \t    pedwarn (\"ANSI C does not support the `%c' length modifier\",\n \t\t     length_char);\n \t}\n+      else if (*format_chars == 'Z')\n+\t{\n+\t  length_char = *format_chars++;\n+\t  if (pedantic)\n+\t    pedwarn (\"ANSI C does not support the `Z' length modifier\");\n+\t}\n       else\n \tlength_char = 0;\n       if (length_char == 'l' && *format_chars == 'l')\n@@ -1575,6 +1583,7 @@ check_format_info (info, params)\n \tcase 'l': wanted_type = fci->llen ? *(fci->llen) : 0; break;\n \tcase 'q': wanted_type = fci->qlen ? *(fci->qlen) : 0; break;\n \tcase 'L': wanted_type = fci->bigllen ? *(fci->bigllen) : 0; break;\n+\tcase 'Z': wanted_type = fci->zlen ? *fci->zlen : 0; break;\n \t}\n       if (wanted_type == 0\n \t  || (pedantic && length_char == 'L' && integral_format))"}, {"sha": "74ed9075d340632bee7fc5d133a0178c7ac2afd8", "filename": "gcc/c-decl.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1981,13 +1981,14 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n     }\n   if (different_binding_level)\n     {\n-      /* Don't output a duplicate symbol for this declaration.  */\n-      TREE_ASM_WRITTEN (newdecl) = 1;\n+      /* Don't output a duplicate symbol or debugging information for this\n+\t declaration.  */\n+      TREE_ASM_WRITTEN (newdecl) = DECL_IGNORED_P (newdecl) = 1;\n       return 0;\n     }\n \n   /* Copy most of the decl-specific fields of NEWDECL into OLDDECL.\n-     But preserve OLDdECL's DECL_UID.  */\n+     But preserve OLDDECL's DECL_UID.  */\n   {\n     register unsigned olddecl_uid = DECL_UID (olddecl);\n \n@@ -5163,9 +5164,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \n \t    if (! strcmp (IDENTIFIER_POINTER (declarator), \"main\"))\n \t      warning (\"cannot inline function `main'\");\n-\t    else if (last && (TYPE_MAIN_VARIANT (TREE_VALUE (last))\n-\t\t\t      != void_type_node))\n-\t      warning (\"inline declaration ignored for function with `...'\");\n \t    else\n \t      /* Assume that otherwise the function can be inlined.  */\n \t      DECL_INLINE (decl) = 1;"}, {"sha": "b20f82b85ff1caca41eaac6132b500ff389dac6e", "filename": "gcc/c-gperf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fc-gperf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fc-gperf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gperf.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* C code produced by gperf version 2.5 (GNU C++ version) */\n-/* Command-line: gperf -p -j1 -i 1 -g -o -t -G -N is_reserved_word -k1,3,$ ./c-parse.gperf  */\n+/* Command-line: gperf -p -j1 -i 1 -g -o -t -G -N is_reserved_word -k1,3,$ /puke/law/tmp/merge/egcs/gcc/c-parse.gperf  */\n /* Command-line: gperf -p -j1 -i 1 -g -o -t -N is_reserved_word -k1,3,$ c-parse.gperf  */ \n struct resword { char *name; short token; enum rid rid; };\n "}, {"sha": "99b21c0382f3e3c494e6b3956c7667dec212e9fb", "filename": "gcc/c-lex.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Lexical analyzer for C and Objective C.\n-   Copyright (C) 1987, 88, 89, 92, 94-96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92, 94-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1513,8 +1513,8 @@ yylex ()\n \tif (floatflag != NOT_FLOAT)\n \t  {\n \t    tree type = double_type_node;\n-\t    int exceeds_double = 0;\n \t    int imag = 0;\n+\t    int conversion_errno = 0;\n \t    REAL_VALUE_TYPE value;\n \t    jmp_buf handler;\n \n@@ -1543,7 +1543,6 @@ yylex ()\n \t      }\n \n \t    *p = 0;\n-\t    errno = 0;\n \n \t    /* Convert string to a double, checking for overflow.  */\n \t    if (setjmp (handler))\n@@ -1613,7 +1612,9 @@ yylex ()\n \t\t      error (\"both `f' and `l' in floating constant\");\n \n \t\t    type = float_type_node;\n+\t\t    errno = 0;\n \t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n+\t\t    conversion_errno = errno;\n \t\t    /* A diagnostic is required here by some ANSI C testsuites.\n \t\t       This is not pedwarn, become some people don't want\n \t\t       an error for this.  */\n@@ -1623,31 +1624,30 @@ yylex ()\n \t\telse if (lflag)\n \t\t  {\n \t\t    type = long_double_type_node;\n+\t\t    errno = 0;\n \t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n+\t\t    conversion_errno = errno;\n \t\t    if (REAL_VALUE_ISINF (value) && pedantic)\n \t\t      warning (\"floating point number exceeds range of `long double'\");\n \t\t  }\n \t\telse\n \t\t  {\n+\t\t    errno = 0;\n \t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n+\t\t    conversion_errno = errno;\n \t\t    if (REAL_VALUE_ISINF (value) && pedantic)\n \t\t      warning (\"floating point number exceeds range of `double'\");\n \t\t  }\n \n \t\tset_float_handler (NULL_PTR);\n \t    }\n #ifdef ERANGE\n-\t    if (errno == ERANGE && !flag_traditional && pedantic)\n-\t      {\n-  \t\t/* ERANGE is also reported for underflow,\n-  \t\t   so test the value to distinguish overflow from that.  */\n-\t\tif (REAL_VALUES_LESS (dconst1, value)\n-\t\t    || REAL_VALUES_LESS (value, dconstm1))\n-\t\t  {\n-\t\t    warning (\"floating point number exceeds range of `double'\");\n-\t\t    exceeds_double = 1;\n-\t\t  }\n-\t      }\n+\t    /* ERANGE is also reported for underflow,\n+\t       so test the value to distinguish overflow from that.  */\n+\t    if (conversion_errno == ERANGE && !flag_traditional && pedantic\n+\t\t&& (REAL_VALUES_LESS (dconst1, value)\n+\t\t    || REAL_VALUES_LESS (value, dconstm1)))\n+\t      warning (\"floating point number exceeds range of `double'\");\n #endif\n \n \t    /* If the result is not a number, assume it must have been"}, {"sha": "76e7ca9dcf19dff9a1c8576568cbf52008609004", "filename": "gcc/c-parse.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* YACC parser for C syntax and for Objective C.  -*-c-*-\n-   Copyright (C) 1987, 88, 89, 92-6, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "ac9138df39340ff02fa91f3550e83edee20fc4a2", "filename": "gcc/c-parse.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fc-parse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fc-parse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.y?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,6 +1,6 @@\n /*WARNING: This file is automatically generated!*/\n /* YACC parser for C syntax and for Objective C.  -*-c-*-\n-   Copyright (C) 1987, 88, 89, 92-6, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "2dc4693d14192cb5ac04584a360e4af4ce981394", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 355, "deletions": 59, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Build expressions with type checking for C compiler.\n-   Copyright (C) 1987, 88, 91-7, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 91-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -70,6 +70,8 @@ static tree digest_init\t\t\tPROTO((tree, tree, int, int));\n static void check_init_type_bitfields\tPROTO((tree));\n static void output_init_element\t\tPROTO((tree, tree, tree, int));\n static void output_pending_init_elements PROTO((int));\n+static void add_pending_init\t\tPROTO((tree, tree));\n+static int pending_init_member\t\tPROTO((tree));\n \f\n /* Do `exp = require_complete_type (exp);' to make sure exp\n    does not have an incomplete type.  (That includes void types.)  */\n@@ -785,7 +787,7 @@ signed_or_unsigned_type (unsignedp, type)\n      int unsignedp;\n      tree type;\n {\n-  if (! INTEGRAL_TYPE_P (type)\n+  if ((! INTEGRAL_TYPE_P (type) && ! POINTER_TYPE_P (type))\n       || TREE_UNSIGNED (type) == unsignedp)\n     return type;\n   if (TYPE_PRECISION (type) == TYPE_PRECISION (signed_char_type_node))\n@@ -5080,11 +5082,23 @@ static int constructor_erroneous;\n /* 1 if have called defer_addressed_constants.  */\n static int constructor_subconstants_deferred;\n \n-/* List of pending elements at this constructor level.\n+/* Structure for managing pending initializer elements, organized as an\n+   AVL tree.  */\n+\n+struct init_node\n+{\n+  struct init_node *left, *right;\n+  struct init_node *parent;\n+  int balance;\n+  tree purpose;\n+  tree value;\n+};\n+\n+/* Tree of pending elements at this constructor level.\n    These are elements encountered out of order\n    which belong at places we haven't reached yet in actually\n    writing the output.  */\n-static tree constructor_pending_elts;\n+static struct init_node *constructor_pending_elts;\n \n /* The SPELLING_DEPTH of this constructor.  */\n static int constructor_depth;\n@@ -5128,7 +5142,7 @@ struct constructor_stack\n   tree bit_index;\n   tree elements;\n   int offset;\n-  tree pending_elts;\n+  struct init_node *pending_elts;\n   int depth;\n   /* If nonzero, this value should replace the entire\n      constructor at this level.  */\n@@ -5871,6 +5885,251 @@ set_init_label (fieldname)\n     }\n }\n \f\n+/* Add a new initializer to the tree of pending initializers.  PURPOSE\n+   indentifies the initializer, either array index or field in a structure. \n+   VALUE is the value of that index or field.  */\n+\n+static void\n+add_pending_init (purpose, value)\n+     tree purpose, value;\n+{\n+  struct init_node *p, **q, *r;\n+\n+  q = &constructor_pending_elts;\n+  p = 0;\n+\n+  if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n+    {\n+      while (*q != 0)\n+\t{\n+\t  p = *q;\n+\t  if (tree_int_cst_lt (purpose, p->purpose))\n+\t    q = &p->left;\n+\t  else if (tree_int_cst_lt (p->purpose, purpose))\n+\t    q = &p->right;\n+\t  else\n+\t    abort ();\n+\t}\n+    }\n+  else\n+    {\n+      while (*q != NULL)\n+\t{\n+\t  p = *q;\n+\t  if (tree_int_cst_lt (DECL_FIELD_BITPOS (purpose),\n+\t\t\t       DECL_FIELD_BITPOS (p->purpose)))\n+\t    q = &p->left;\n+\t  else if (tree_int_cst_lt (DECL_FIELD_BITPOS (p->purpose),\n+\t\t\t\t    DECL_FIELD_BITPOS (purpose)))\n+\t    q = &p->right;\n+\t  else\n+\t    abort ();\n+\t}\n+    }\n+\n+  r = (struct init_node *) oballoc (sizeof (struct init_node));\n+  r->purpose = purpose;\n+  r->value = value;\n+\n+  *q = r;\n+  r->parent = p;\n+  r->left = 0;\n+  r->right = 0;\n+  r->balance = 0;\n+\n+  while (p)\n+    {\n+      struct init_node *s;\n+\n+      if (r == p->left)\n+\t{\n+\t  if (p->balance == 0)\n+\t    p->balance = -1;\n+\t  else if (p->balance < 0)\n+\t    {\n+\t      if (r->balance < 0)\n+\t\t{\n+\t\t  /* L rotation. */\n+\t\t  p->left = r->right;\n+\t\t  if (p->left)\n+\t\t    p->left->parent = p;\n+\t\t  r->right = p;\n+\n+\t\t  p->balance = 0;\n+\t\t  r->balance = 0;\n+\n+\t\t  s = p->parent;\n+\t\t  p->parent = r;\n+\t\t  r->parent = s;\n+\t\t  if (s)\n+\t\t    {\n+\t\t      if (s->left == p)\n+\t\t\ts->left = r;\n+\t\t      else\n+\t\t\ts->right = r;\n+\t\t    }\n+\t\t  else\n+\t\t    constructor_pending_elts = r;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* LR rotation. */\n+\t\t  struct init_node *t = r->right;\n+\n+\t\t  r->right = t->left;\n+\t\t  if (r->right)\n+\t\t    r->right->parent = r;\n+\t\t  t->left = r;\n+\n+\t\t  p->left = t->right;\n+\t\t  if (p->left)\n+\t\t    p->left->parent = p;\n+\t\t  t->right = p;\n+\n+\t\t  p->balance = t->balance < 0;\n+\t\t  r->balance = -(t->balance > 0);\n+\t\t  t->balance = 0;\n+\n+\t\t  s = p->parent;\n+\t\t  p->parent = t;\n+\t\t  r->parent = t;\n+\t\t  t->parent = s;\n+\t\t  if (s)\n+\t\t    {\n+\t\t      if (s->left == p)\n+\t\t\ts->left = t;\n+\t\t      else\n+\t\t\ts->right = t;\n+\t\t    }\n+\t\t  else\n+\t\t    constructor_pending_elts = t;\n+\t\t}\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* p->balance == +1; growth of left side balances the node.  */\n+\t      p->balance = 0;\n+\t      break;\n+\t    }\n+\t}\n+      else /* r == p->right */\n+\t{\n+\t  if (p->balance == 0)\n+\t    /* Growth propagation from right side.  */\n+\t    p->balance++;\n+\t  else if (p->balance > 0)\n+\t    {\n+\t      if (r->balance > 0)\n+\t\t{\n+\t\t  /* R rotation. */\n+\t\t  p->right = r->left;\n+\t\t  if (p->right)\n+\t\t    p->right->parent = p;\n+\t\t  r->left = p;\n+\n+\t\t  p->balance = 0;\n+\t\t  r->balance = 0;\n+\n+\t\t  s = p->parent;\n+\t\t  p->parent = r;\n+\t\t  r->parent = s;\n+\t\t  if (s)\n+\t\t    {\n+\t\t      if (s->left == p)\n+\t\t\ts->left = r;\n+\t\t      else\n+\t\t\ts->right = r;\n+\t\t    }\n+\t\t  else\n+\t\t    constructor_pending_elts = r;\n+\t\t}\n+\t      else /* r->balance == -1 */\n+\t\t{\n+\t\t  /* RL rotation */\n+\t\t  struct init_node *t = r->left;\n+\n+\t\t  r->left = t->right;\n+\t\t  if (r->left)\n+\t\t    r->left->parent = r;\n+\t\t  t->right = r;\n+\n+\t\t  p->right = t->left;\n+\t\t  if (p->right)\n+\t\t    p->right->parent = p;\n+\t\t  t->left = p;\n+\n+\t\t  r->balance = (t->balance < 0);\n+\t\t  p->balance = -(t->balance > 0);\n+\t\t  t->balance = 0;\n+\n+\t\t  s = p->parent;\n+\t\t  p->parent = t;\n+\t\t  r->parent = t;\n+\t\t  t->parent = s;\n+\t\t  if (s)\n+\t\t    {\n+\t\t      if (s->left == p)\n+\t\t\ts->left = t;\n+\t\t      else\n+\t\t\ts->right = t;\n+\t\t    }\n+\t\t  else\n+\t\t    constructor_pending_elts = t;\n+\t\t}\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* p->balance == -1; growth of right side balances the node. */\n+\t      p->balance = 0;\n+\t      break;\n+\t    }\n+\t}\n+\n+      r = p;\n+      p = p->parent;\n+    }\n+}\n+\n+/* Return nonzero if FIELD is equal to the index of a pending initializer.  */\n+\n+static int\n+pending_init_member (field)\n+     tree field;\n+{\n+  struct init_node *p;\n+\n+  p = constructor_pending_elts;\n+  if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n+    {\n+      while (p)\n+\t{\n+\t  if (tree_int_cst_equal (field, p->purpose))\n+\t    return 1;\n+\t  else if (tree_int_cst_lt (field, p->purpose))\n+\t    p = p->left;\n+\t  else\n+\t    p = p->right;\n+\t}\n+    }\n+  else\n+    {\n+      while (p)\n+\t{\n+\t  if (field == p->purpose)\n+\t    return 1;\n+\t  else if (tree_int_cst_lt (DECL_FIELD_BITPOS (field),\n+\t\t\t\t    DECL_FIELD_BITPOS (p->purpose)))\n+\t    p = p->left;\n+\t  else\n+\t    p = p->right;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n /* \"Output\" the next constructor element.\n    At top level, really output it to assembler code now.\n    Otherwise, collect it in a list from which we will make a CONSTRUCTOR.\n@@ -5929,25 +6188,10 @@ output_init_element (value, type, field, pending)\n   if (pending)\n     {\n       if (TREE_CODE (constructor_type) == RECORD_TYPE\n-\t  || TREE_CODE (constructor_type) == UNION_TYPE)\n+\t  || TREE_CODE (constructor_type) == UNION_TYPE\n+\t  || TREE_CODE (constructor_type) == ARRAY_TYPE)\n \t{\n-\t  if (purpose_member (field, constructor_pending_elts))\n-\t    {\n-\t      error_init (\"duplicate initializer%s\", \" for `%s'\", NULL);\n-\t      duplicate = 1;\n-\t    }\n-\t}\n-      if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n-\t{\n-\t  tree tail;\n-\t  for (tail = constructor_pending_elts; tail;\n-\t       tail = TREE_CHAIN (tail))\n-\t    if (TREE_PURPOSE (tail) != 0\n-\t\t&& TREE_CODE (TREE_PURPOSE (tail)) == INTEGER_CST\n-\t\t&& tree_int_cst_equal (TREE_PURPOSE (tail), constructor_index))\n-\t      break;\n-\n-\t  if (tail != 0)\n+\t  if (pending_init_member (field))\n \t    {\n \t      error_init (\"duplicate initializer%s\", \" for `%s'\", NULL);\n \t      duplicate = 1;\n@@ -5963,11 +6207,9 @@ output_init_element (value, type, field, pending)\n       if (! duplicate)\n \t/* The copy_node is needed in case field is actually\n \t   constructor_index, which is modified in place.  */\n-\tconstructor_pending_elts\n-\t  = tree_cons (copy_node (field),\n-\t\t       digest_init (type, value, require_constant_value, \n-\t\t\t\t    require_constant_elements),\n-\t\t       constructor_pending_elts);\n+\tadd_pending_init (copy_node (field),\n+\t\t\t  digest_init (type, value, require_constant_value, \n+\t\t\t\t       require_constant_elements));\n     }\n   else if (TREE_CODE (constructor_type) == RECORD_TYPE\n \t   && field != constructor_unfilled_fields)\n@@ -5976,11 +6218,9 @@ output_init_element (value, type, field, pending)\n \t no matter which field is specified, it can be initialized\n \t right away since it starts at the beginning of the union.  */\n       if (!duplicate)\n-\tconstructor_pending_elts\n-\t  = tree_cons (field,\n-\t\t       digest_init (type, value, require_constant_value, \n-\t\t\t\t    require_constant_elements),\n-\t\t       constructor_pending_elts);\n+\tadd_pending_init (field,\n+\t\t\t  digest_init (type, value, require_constant_value, \n+\t\t\t\t       require_constant_elements));\n     }\n   else\n     {\n@@ -6080,56 +6320,109 @@ static void\n output_pending_init_elements (all)\n      int all;\n {\n-  tree tail;\n+  struct init_node *elt = constructor_pending_elts;\n   tree next;\n \n  retry:\n \n-  /* Look thru the whole pending list.\n+  /* Look thru the whole pending tree.\n      If we find an element that should be output now,\n      output it.  Otherwise, set NEXT to the element\n      that comes first among those still pending.  */\n      \n   next = 0;\n-  for (tail = constructor_pending_elts; tail;\n-       tail = TREE_CHAIN (tail))\n+  while (elt)\n     {\n       if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n \t{\n-\t  if (tree_int_cst_equal (TREE_PURPOSE (tail),\n+\t  if (tree_int_cst_equal (elt->purpose,\n \t\t\t\t  constructor_unfilled_index))\n+\t    output_init_element (elt->value,\n+\t\t\t\t TREE_TYPE (constructor_type),\n+\t\t\t\t constructor_unfilled_index, 0);\n+\t  else if (tree_int_cst_lt (constructor_unfilled_index,\n+\t\t\t\t    elt->purpose))\n \t    {\n-\t      output_init_element (TREE_VALUE (tail),\n-\t\t\t\t   TREE_TYPE (constructor_type),\n-\t\t\t\t   constructor_unfilled_index, 0);\n-\t      goto retry;\n+\t      /* Advance to the next smaller node.  */\n+\t      if (elt->left)\n+\t\telt = elt->left;\n+\t      else\n+\t\t{\n+\t\t  /* We have reached the smallest node bigger than the\n+\t\t     current unfilled index.  Fill the space first.  */\n+\t\t  next = elt->purpose;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Advance to the next bigger node.  */\n+\t      if (elt->right)\n+\t\telt = elt->right;\n+\t      else\n+\t\t{\n+\t\t  /* We have reached the biggest node in a subtree.  Find\n+\t\t     the parent of it, which is the next bigger node.  */\n+\t\t  while (elt->parent && elt->parent->right == elt)\n+\t\t    elt = elt->parent;\n+\t\t  elt = elt->parent;\n+\t\t  if (elt && tree_int_cst_lt (constructor_unfilled_index,\n+\t\t\t\t\t      elt->purpose))\n+\t\t    {\n+\t\t      next = elt->purpose;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n \t    }\n-\t  else if (tree_int_cst_lt (TREE_PURPOSE (tail),\n-\t\t\t\t    constructor_unfilled_index))\n-\t    ;\n-\t  else if (next == 0\n-\t\t   || tree_int_cst_lt (TREE_PURPOSE (tail), next))\n-\t    next = TREE_PURPOSE (tail);\n \t}\n       else if (TREE_CODE (constructor_type) == RECORD_TYPE\n \t       || TREE_CODE (constructor_type) == UNION_TYPE)\n \t{\n-\t  if (TREE_PURPOSE (tail) == constructor_unfilled_fields)\n+\t  /* If the current record is complete we are done.  */\n+\t  if (constructor_unfilled_fields == 0)\n+\t    break;\n+\t  if (elt->purpose == constructor_unfilled_fields)\n \t    {\n-\t      output_init_element (TREE_VALUE (tail),\n+\t      output_init_element (elt->value,\n \t\t\t\t   TREE_TYPE (constructor_unfilled_fields),\n \t\t\t\t   constructor_unfilled_fields,\n \t\t\t\t   0);\n-\t      goto retry;\n \t    }\n-\t  else if (constructor_unfilled_fields == 0\n-\t\t   || tree_int_cst_lt (DECL_FIELD_BITPOS (TREE_PURPOSE (tail)),\n-\t\t\t\t       DECL_FIELD_BITPOS (constructor_unfilled_fields)))\n-\t    ;\n-\t  else if (next == 0\n-\t\t   || tree_int_cst_lt (DECL_FIELD_BITPOS (TREE_PURPOSE (tail)),\n-\t\t\t\t       DECL_FIELD_BITPOS (next)))\n-\t    next = TREE_PURPOSE (tail);\n+\t  else if (tree_int_cst_lt (DECL_FIELD_BITPOS (constructor_unfilled_fields),\n+\t\t\t\t    DECL_FIELD_BITPOS (elt->purpose)))\n+\t    {\n+\t      /* Advance to the next smaller node.  */\n+\t      if (elt->left)\n+\t\telt = elt->left;\n+\t      else\n+\t\t{\n+\t\t  /* We have reached the smallest node bigger than the\n+\t\t     current unfilled field.  Fill the space first.  */\n+\t\t  next = elt->purpose;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Advance to the next bigger node.  */\n+\t      if (elt->right)\n+\t\telt = elt->right;\n+\t      else\n+\t\t{\n+\t\t  /* We have reached the biggest node in a subtree.  Find\n+\t\t     the parent of it, which is the next bigger node.  */\n+\t\t  while (elt->parent && elt->parent->right == elt)\n+\t\t    elt = elt->parent;\n+\t\t  elt = elt->parent;\n+\t\t  if (elt\n+\t\t      && tree_int_cst_lt (DECL_FIELD_BITPOS (constructor_unfilled_fields),\n+\t\t\t\t\t  DECL_FIELD_BITPOS (elt->purpose)))\n+\t\t    {\n+\t\t      next = elt->purpose;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n     }\n \n@@ -6147,6 +6440,7 @@ output_pending_init_elements (all)\n       if (TREE_CODE (constructor_type) == RECORD_TYPE\n \t  || TREE_CODE (constructor_type) == UNION_TYPE)\n \t{\n+\t  tree tail;\n \t  /* Find the last field written out, if any.  */\n \t  for (tail = TYPE_FIELDS (constructor_type); tail;\n \t       tail = TREE_CHAIN (tail))\n@@ -6212,6 +6506,8 @@ output_pending_init_elements (all)\n \t}\n     }\n \n+  /* ELT now points to the node in the pending tree with the next\n+     initializer to output.  */\n   goto retry;\n }\n \f"}, {"sha": "2716caff6cbe0a61a754f6885eafc44e4a864d22", "filename": "gcc/calls.c", "status": "modified", "additions": 62, "deletions": 83, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -125,7 +125,8 @@ int stack_arg_under_construction;\n \n static int calls_function\tPROTO((tree, int));\n static int calls_function_1\tPROTO((tree, int));\n-static void emit_call_1\t\tPROTO((rtx, tree, tree, int, int, rtx, rtx,\n+static void emit_call_1\t\tPROTO((rtx, tree, tree, HOST_WIDE_INT,\n+\t\t\t\t       HOST_WIDE_INT, rtx, rtx,\n \t\t\t\t       int, rtx, int));\n static void store_one_arg\tPROTO ((struct arg_data *, rtx, int, int,\n \t\t\t\t\ttree, int));\n@@ -347,8 +348,8 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, struct_value_size,\n      rtx funexp;\n      tree fndecl;\n      tree funtype;\n-     int stack_size;\n-     int struct_value_size;\n+     HOST_WIDE_INT stack_size;\n+     HOST_WIDE_INT struct_value_size;\n      rtx next_arg_reg;\n      rtx valreg;\n      int old_inhibit_defer_pop;\n@@ -509,7 +510,7 @@ expand_call (exp, target, ignore)\n   /* Size of aggregate value wanted, or zero if none wanted\n      or if we are using the non-reentrant PCC calling convention\n      or expecting the value in registers.  */\n-  int struct_value_size = 0;\n+  HOST_WIDE_INT struct_value_size = 0;\n   /* Nonzero if called function returns an aggregate in memory PCC style,\n      by returning the address of where to find it.  */\n   int pcc_struct_value = 0;\n@@ -543,14 +544,10 @@ expand_call (exp, target, ignore)\n      So the entire argument block must then be preallocated (i.e., we\n      ignore PUSH_ROUNDING in that case).  */\n \n-#if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n-  int must_preallocate = 1;\n-#else\n #ifdef PUSH_ROUNDING\n   int must_preallocate = 0;\n #else\n   int must_preallocate = 1;\n-#endif\n #endif\n \n   /* Size of the stack reserved for parameter registers.  */\n@@ -662,6 +659,11 @@ expand_call (exp, target, ignore)\n #endif\n #endif\n \n+#if defined(PUSH_ROUNDING) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n+  if (reg_parm_stack_space > 0)\n+    must_preallocate = 1;\n+#endif\n+\n   /* Warn if this value is an aggregate type,\n      regardless of which calling convention we are using for it.  */\n   if (warn_aggregate_return && AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n@@ -712,8 +714,7 @@ expand_call (exp, target, ignore)\n \t    DECL_RTL (d) = assign_temp (TREE_TYPE (exp), 1, 0, 1);\n \t    mark_addressable (d);\n \t    structure_value_addr = XEXP (DECL_RTL (d), 0);\n-\t    MEM_IN_STRUCT_P (structure_value_addr)\n-\t      = AGGREGATE_TYPE_P (TREE_TYPE (exp));\n+\t    TREE_USED (d) = 1;\n \t    target = 0;\n \t  }\n       }\n@@ -771,18 +772,18 @@ expand_call (exp, target, ignore)\n \t\t     outgoing argument list in addition to the requested\n \t\t     space, but there is no way to ask for stack space such\n \t\t     that an argument list of a certain length can be\n-\t\t     safely constructed.  */\n+\t\t     safely constructed. \n \n-\t\t  int adjust = OUTGOING_ARGS_SIZE (DECL_SAVED_INSNS (fndecl));\n-#ifdef REG_PARM_STACK_SPACE\n-\t\t  /* Add the stack space reserved for register arguments\n-\t\t     in the inline function.  What is really needed is the\n+\t\t     Add the stack space reserved for register arguments, if\n+\t\t     any, in the inline function.  What is really needed is the\n \t\t     largest value of reg_parm_stack_space in the inline\n \t\t     function, but that is not available.  Using the current\n \t\t     value of reg_parm_stack_space is wrong, but gives\n \t\t     correct results on all supported machines.  */\n-\t\t  adjust += reg_parm_stack_space;\n-#endif\n+\n+\t\t  int adjust = (OUTGOING_ARGS_SIZE (DECL_SAVED_INSNS (fndecl))\n+\t\t\t\t+ reg_parm_stack_space);\n+\n \t\t  start_sequence ();\n \t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n \t\t  allocate_dynamic_stack_space (GEN_INT (adjust),\n@@ -965,11 +966,11 @@ expand_call (exp, target, ignore)\n \n   /* Compute number of named args.\n      Normally, don't include the last named arg if anonymous args follow.\n-     We do include the last named arg if STRICT_ARGUMENT_NAMING is defined.\n+     We do include the last named arg if STRICT_ARGUMENT_NAMING is nonzero.\n      (If no anonymous args follow, the result of list_length is actually\n      one too large.  This is harmless.)\n \n-     If SETUP_INCOMING_VARARGS is defined and STRICT_ARGUMENT_NAMING is not,\n+     If SETUP_INCOMING_VARARGS is defined and STRICT_ARGUMENT_NAMING is zero,\n      this machine will be able to place unnamed args that were passed in\n      registers into the stack.  So treat all args as named.  This allows the\n      insns emitting for a specific argument list to be independent of the\n@@ -978,18 +979,20 @@ expand_call (exp, target, ignore)\n      If SETUP_INCOMING_VARARGS is not defined, we do not have any reliable\n      way to pass unnamed args in registers, so we must force them into\n      memory.  */\n-#if !defined(SETUP_INCOMING_VARARGS) || defined(STRICT_ARGUMENT_NAMING)\n-  if (TYPE_ARG_TYPES (funtype) != 0)\n+\n+  if ((STRICT_ARGUMENT_NAMING\n+#ifndef SETUP_INCOMING_VARARGS\n+       || 1\n+#endif\n+       )\n+      && TYPE_ARG_TYPES (funtype) != 0)\n     n_named_args\n       = (list_length (TYPE_ARG_TYPES (funtype))\n-#ifndef STRICT_ARGUMENT_NAMING\n \t /* Don't include the last named arg.  */\n-\t - 1\n-#endif\n+\t - (STRICT_ARGUMENT_NAMING ? 0 : -1)\n \t /* Count the struct value address, if it is passed as a parm.  */\n \t + structure_value_addr_parm);\n   else\n-#endif\n     /* If we know nothing, treat all args as named.  */\n     n_named_args = num_actuals;\n \n@@ -1164,9 +1167,7 @@ expand_call (exp, target, ignore)\n \n       /* Compute the stack-size of this argument.  */\n       if (args[i].reg == 0 || args[i].partial != 0\n-#ifdef REG_PARM_STACK_SPACE\n \t  || reg_parm_stack_space > 0\n-#endif\n \t  || args[i].pass_on_stack)\n \tlocate_and_pad_parm (mode, type,\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n@@ -1181,14 +1182,12 @@ expand_call (exp, target, ignore)\n       args[i].slot_offset = args_size;\n #endif\n \n-#ifndef REG_PARM_STACK_SPACE\n       /* If a part of the arg was put into registers,\n \t don't include that part in the amount pushed.  */\n-      if (! args[i].pass_on_stack)\n+      if (reg_parm_stack_space == 0 && ! args[i].pass_on_stack)\n \targs[i].size.constant -= ((args[i].partial * UNITS_PER_WORD)\n \t\t\t\t  / (PARM_BOUNDARY / BITS_PER_UNIT)\n \t\t\t\t  * (PARM_BOUNDARY / BITS_PER_UNIT));\n-#endif\n       \n       /* Update ARGS_SIZE, the total stack space for args so far.  */\n \n@@ -1245,12 +1244,11 @@ expand_call (exp, target, ignore)\n \targs_size.var = round_up (args_size.var, STACK_BYTES);\n #endif\n \n-#ifdef REG_PARM_STACK_SPACE\n       if (reg_parm_stack_space > 0)\n \t{\n \t  args_size.var\n \t    = size_binop (MAX_EXPR, args_size.var,\n-\t\t\t  size_int (REG_PARM_STACK_SPACE (fndecl)));\n+\t\t\t  size_int (reg_parm_stack_space));\n \n #ifndef OUTGOING_REG_PARM_STACK_SPACE\n \t  /* The area corresponding to register parameters is not to count in\n@@ -1260,7 +1258,6 @@ expand_call (exp, target, ignore)\n \t\t\t  size_int (reg_parm_stack_space));\n #endif\n \t}\n-#endif\n     }\n   else\n     {\n@@ -1269,16 +1266,16 @@ expand_call (exp, target, ignore)\n \t\t\t     / STACK_BYTES) * STACK_BYTES);\n #endif\n \n-#ifdef REG_PARM_STACK_SPACE\n       args_size.constant = MAX (args_size.constant,\n \t\t\t\treg_parm_stack_space);\n+\n #ifdef MAYBE_REG_PARM_STACK_SPACE\n       if (reg_parm_stack_space == 0)\n \targs_size.constant = 0;\n #endif\n+\n #ifndef OUTGOING_REG_PARM_STACK_SPACE\n       args_size.constant -= reg_parm_stack_space;\n-#endif\n #endif\n     }\n \n@@ -1444,7 +1441,7 @@ expand_call (exp, target, ignore)\n \t     Another approach might be to try to reorder the argument\n \t     evaluations to avoid this conflicting stack usage.  */\n \n-#if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n+#ifndef OUTGOING_REG_PARM_STACK_SPACE\n \t  /* Since we will be writing into the entire argument area, the\n \t     map must be allocated for its entire size, not just the part that\n \t     is the responsibility of the caller.  */\n@@ -1516,7 +1513,7 @@ expand_call (exp, target, ignore)\n      to initialize an argument.  */\n   if (stack_arg_under_construction)\n     {\n-#if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n+#ifndef OUTGOING_REG_PARM_STACK_SPACE\n       rtx push_size = GEN_INT (reg_parm_stack_space + args_size.constant);\n #else\n       rtx push_size = GEN_INT (args_size.constant);\n@@ -1695,6 +1692,7 @@ expand_call (exp, target, ignore)\n       }\n \n #if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n+\n   /* The argument list is the property of the called routine and it\n      may clobber it.  If the fixed area has been used for previous\n      parameters, we must save and restore it.\n@@ -2322,6 +2320,7 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n   struct arg *argvec;\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n   rtx call_fusage = 0;\n+  int reg_parm_stack_space = 0;\n #if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n   /* Define the boundary of the register parm stack space that needs to be\n      save, if any.  */\n@@ -2337,7 +2336,6 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n \n #ifdef REG_PARM_STACK_SPACE\n   /* Size of the stack reserved for parameter registers.  */\n-  int reg_parm_stack_space = 0;\n #ifdef MAYBE_REG_PARM_STACK_SPACE\n   reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n #else\n@@ -2433,16 +2431,11 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n       if (argvec[count].size.var)\n \tabort ();\n \n-#ifndef REG_PARM_STACK_SPACE\n-      if (argvec[count].partial)\n+      if (reg_parm_stack_space == 0 && argvec[count].partial)\n \targvec[count].size.constant -= argvec[count].partial * UNITS_PER_WORD;\n-#endif\n \n       if (argvec[count].reg == 0 || argvec[count].partial != 0\n-#ifdef REG_PARM_STACK_SPACE\n-\t  || 1\n-#endif\n-\t  )\n+\t  || reg_parm_stack_space > 0)\n \targs_size.constant += argvec[count].size.constant;\n \n       FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree) 0, 1);\n@@ -2464,12 +2457,11 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n \t\t\t / STACK_BYTES) * STACK_BYTES);\n #endif\n \n-#ifdef REG_PARM_STACK_SPACE\n   args_size.constant = MAX (args_size.constant,\n \t\t\t    reg_parm_stack_space);\n+\n #ifndef OUTGOING_REG_PARM_STACK_SPACE\n   args_size.constant -= reg_parm_stack_space;\n-#endif\n #endif\n \n   if (args_size.constant > current_function_outgoing_args_size)\n@@ -2489,7 +2481,8 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n      evaluations to avoid this conflicting stack usage.  */\n \n   needed = args_size.constant;\n-#if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n+\n+#ifndef OUTGOING_REG_PARM_STACK_SPACE\n   /* Since we will be writing into the entire argument area, the\n      map must be allocated for its entire size, not just the part that\n      is the responsibility of the caller.  */\n@@ -2638,17 +2631,14 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n \n \t  for (i = lower_bound; i < upper_bound; i++)\n \t    if (stack_usage_map[i]\n-#ifdef REG_PARM_STACK_SPACE\n \t\t/* Don't store things in the fixed argument area at this point;\n \t\t   it has already been saved.  */\n-\t\t&& i > reg_parm_stack_space\n-#endif\n-\t\t)\n+\t\t&& i > reg_parm_stack_space)\n \t      break;\n \n \t  if (i != upper_bound)\n \t    {\n-\t      /* We need to make a save area.  See what mode we can make it.  */\n+\t      /* We need to make a save area.  See what mode we can make it. */\n \t      enum machine_mode save_mode\n \t\t= mode_for_size (argvec[argnum].size.constant * BITS_PER_UNIT,\n \t\t\t\t MODE_INT, 1);\n@@ -2661,7 +2651,8 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n \t    }\n #endif\n \t  emit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n-\t\t\t  argblock, GEN_INT (argvec[argnum].offset.constant));\n+\t\t\t  argblock, GEN_INT (argvec[argnum].offset.constant),\n+\t\t\t  reg_parm_stack_space);\n \n #ifdef ACCUMULATE_OUTGOING_ARGS\n \t  /* Now mark the segment we just used.  */\n@@ -2825,6 +2816,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n   int pcc_struct_value = 0;\n   int struct_value_size = 0;\n   int is_const;\n+  int reg_parm_stack_space = 0;\n #ifdef ACCUMULATE_OUTGOING_ARGS\n   int needed;\n #endif\n@@ -2838,7 +2830,6 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \n #ifdef ACCUMULATE_OUTGOING_ARGS\n   /* Size of the stack reserved for parameter registers.  */\n-  int reg_parm_stack_space = 0;\n   int initial_highest_arg_in_use = highest_outgoing_arg_in_use;\n   char *initial_stack_usage_map = stack_usage_map;\n #endif\n@@ -2938,10 +2929,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \n \n       if (argvec[count].reg == 0 || argvec[count].partial != 0\n-#ifdef REG_PARM_STACK_SPACE\n-\t  || 1\n-#endif\n-\t  )\n+\t  || reg_parm_stack_space > 0)\n \targs_size.constant += argvec[count].size.constant;\n \n       FUNCTION_ARG_ADVANCE (args_so_far, Pmode, (tree) 0, 1);\n@@ -3008,16 +2996,11 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n       if (argvec[count].size.var)\n \tabort ();\n \n-#ifndef REG_PARM_STACK_SPACE\n-      if (argvec[count].partial)\n+      if (reg_parm_stack_space == 0 && argvec[count].partial)\n \targvec[count].size.constant -= argvec[count].partial * UNITS_PER_WORD;\n-#endif\n \n       if (argvec[count].reg == 0 || argvec[count].partial != 0\n-#ifdef REG_PARM_STACK_SPACE\n-\t  || 1\n-#endif\n-\t  )\n+\t  || reg_parm_stack_space > 0)\n \targs_size.constant += argvec[count].size.constant;\n \n       FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree) 0, 1);\n@@ -3038,12 +3021,11 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \t\t\t / STACK_BYTES) * STACK_BYTES);\n #endif\n \n-#ifdef REG_PARM_STACK_SPACE\n   args_size.constant = MAX (args_size.constant,\n \t\t\t    reg_parm_stack_space);\n+\n #ifndef OUTGOING_REG_PARM_STACK_SPACE\n   args_size.constant -= reg_parm_stack_space;\n-#endif\n #endif\n \n   if (args_size.constant > current_function_outgoing_args_size)\n@@ -3063,7 +3045,8 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n      evaluations to avoid this conflicting stack usage.  */\n \n   needed = args_size.constant;\n-#if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n+\n+#ifndef OUTGOING_REG_PARM_STACK_SPACE\n   /* Since we will be writing into the entire argument area, the\n      map must be allocated for its entire size, not just the part that\n      is the responsibility of the caller.  */\n@@ -3212,17 +3195,14 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \n \t  for (i = lower_bound; i < upper_bound; i++)\n \t    if (stack_usage_map[i]\n-#ifdef REG_PARM_STACK_SPACE\n \t\t/* Don't store things in the fixed argument area at this point;\n \t\t   it has already been saved.  */\n-\t\t&& i > reg_parm_stack_space\n-#endif\n-\t\t)\n+\t\t&& i > reg_parm_stack_space)\n \t      break;\n \n \t  if (i != upper_bound)\n \t    {\n-\t      /* We need to make a save area.  See what mode we can make it.  */\n+\t      /* We need to make a save area.  See what mode we can make it. */\n \t      enum machine_mode save_mode\n \t\t= mode_for_size (argvec[argnum].size.constant * BITS_PER_UNIT,\n \t\t\t\t MODE_INT, 1);\n@@ -3236,7 +3216,8 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \t    }\n #endif\n \t  emit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n-\t\t\t  argblock, GEN_INT (argvec[argnum].offset.constant));\n+\t\t\t  argblock, GEN_INT (argvec[argnum].offset.constant),\n+\t\t\t  reg_parm_stack_space);\n \n #ifdef ACCUMULATE_OUTGOING_ARGS\n \t  /* Now mark the segment we just used.  */\n@@ -3491,12 +3472,9 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n \n       for (i = lower_bound; i < upper_bound; i++)\n \tif (stack_usage_map[i]\n-#ifdef REG_PARM_STACK_SPACE\n \t    /* Don't store things in the fixed argument area at this point;\n \t       it has already been saved.  */\n-\t    && i > reg_parm_stack_space\n-#endif\n-\t    )\n+\t    && i > reg_parm_stack_space)\n \t  break;\n \n       if (i != upper_bound)\n@@ -3642,9 +3620,9 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n \n       /* This isn't already where we want it on the stack, so put it there.\n \t This can either be done with push or copy insns.  */\n-      emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), NULL_RTX,\n-\t\t      0, partial, reg, used - size,\n-\t\t      argblock, ARGS_SIZE_RTX (arg->offset));\n+      emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), NULL_RTX, 0,\n+\t\t      partial, reg, used - size, argblock,\n+\t\t      ARGS_SIZE_RTX (arg->offset), reg_parm_stack_space);\n     }\n   else\n     {\n@@ -3676,7 +3654,8 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n \n       emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), size_rtx,\n \t\t      TYPE_ALIGN (TREE_TYPE (pval)) / BITS_PER_UNIT, partial,\n-\t\t      reg, excess, argblock, ARGS_SIZE_RTX (arg->offset));\n+\t\t      reg, excess, argblock, ARGS_SIZE_RTX (arg->offset),\n+\t\t      reg_parm_stack_space);\n     }\n \n "}, {"sha": "edaf5440b85a8dee5465cc3ff89bb25cbd592f73", "filename": "gcc/cccp.c", "status": "modified", "additions": 345, "deletions": 189, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* C Compatible Compiler Preprocessor (CCCP)\n-   Copyright (C) 1986, 87, 89, 92-96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1986, 87, 89, 92-97, 1998 Free Software Foundation, Inc.\n    Written by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n \n@@ -130,6 +130,7 @@ extern char *getenv ();\n #define PRINTF_PROTO_1(ARGS) PRINTF_PROTO(ARGS, 1, 2)\n #define PRINTF_PROTO_2(ARGS) PRINTF_PROTO(ARGS, 2, 3)\n #define PRINTF_PROTO_3(ARGS) PRINTF_PROTO(ARGS, 3, 4)\n+#define PRINTF_PROTO_4(ARGS) PRINTF_PROTO(ARGS, 4, 5)\n \n /* VMS-specific definitions */\n #ifdef VMS\n@@ -412,6 +413,8 @@ static struct file_buf {\n   char *fname;\n   /* Filename specified with #line directive.  */\n   char *nominal_fname;\n+  /* The length of nominal_fname, which may contain embedded NULs.  */\n+  size_t nominal_fname_len;\n   /* Include file description.  */\n   struct include_file *inc;\n   /* Record where in the search path this file was found.\n@@ -650,6 +653,7 @@ struct definition {\n   U_CHAR *expansion;\n   int line;\t\t\t/* Line number of definition */\n   char *file;\t\t\t/* File of definition */\n+  size_t file_len;\t\t/* Length of file (which can contain NULs) */\n   char rest_args;\t\t/* Nonzero if last arg. absorbs the rest */\n   struct reflist {\n     struct reflist *next;\n@@ -872,7 +876,8 @@ struct directive {\n   enum node_type type;\t\t/* Code which describes which directive.  */\n };\n \n-#define IS_INCLUDE_DIRECTIVE_TYPE(t) (T_INCLUDE <= (t) && (t) <= T_IMPORT)\n+#define IS_INCLUDE_DIRECTIVE_TYPE(t) \\\n+((int) T_INCLUDE <= (int) (t) && (int) (t) <= (int) T_IMPORT)\n \n /* These functions are declared to return int instead of void since they\n    are going to be placed in the table and some old compilers have trouble with\n@@ -954,6 +959,7 @@ static char *out_fname;\n struct if_stack {\n   struct if_stack *next;\t/* for chaining to the next stack frame */\n   char *fname;\t\t/* copied from input when frame is made */\n+  size_t fname_len;\t\t/* similarly */\n   int lineno;\t\t\t/* similarly */\n   int if_succeeded;\t\t/* true if a leg of this if-group\n \t\t\t\t    has been passed through rescan */\n@@ -1053,7 +1059,7 @@ static void validate_else PROTO((U_CHAR *, U_CHAR *));\n \n static U_CHAR *skip_to_end_of_comment PROTO((FILE_BUF *, int *, int));\n static U_CHAR *skip_quoted_string PROTO((U_CHAR *, U_CHAR *, int, int *, int *, int *));\n-static char *quote_string PROTO((char *, char *));\n+static char *quote_string PROTO((char *, char *, size_t));\n static U_CHAR *skip_paren_group PROTO((FILE_BUF *));\n \n /* Last arg to output_line_directive.  */\n@@ -1065,7 +1071,7 @@ static void macroexpand PROTO((HASHNODE *, FILE_BUF *));\n struct argdata;\n static char *macarg PROTO((struct argdata *, int));\n \n-static U_CHAR *macarg1 PROTO((U_CHAR *, U_CHAR *, int *, int *, int *, int));\n+static U_CHAR *macarg1 PROTO((U_CHAR *, U_CHAR *, struct hashnode *, int *, int *, int *, int));\n \n static int discard_comments PROTO((U_CHAR *, int, int));\n \n@@ -1083,7 +1089,7 @@ static void vwarning_with_line PROTO((int, char *, va_list));\n static void warning_with_line PRINTF_PROTO_2((int, char *, ...));\n void pedwarn PRINTF_PROTO_1((char *, ...));\n void pedwarn_with_line PRINTF_PROTO_2((int, char *, ...));\n-static void pedwarn_with_file_and_line PRINTF_PROTO_3((char *, int, char *, ...));\n+static void pedwarn_with_file_and_line PRINTF_PROTO_4((char *, size_t, int, char *, ...));\n \n static void print_containing_files PROTO((void));\n \n@@ -1726,6 +1732,7 @@ main (argc, argv)\n   if (in_fname == NULL)\n     in_fname = \"\";\n   fp->nominal_fname = fp->fname = in_fname;\n+  fp->nominal_fname_len = strlen (in_fname);\n   fp->lineno = 0;\n \n   /* In C++, wchar_t is a distinct basic type, and we can expect\n@@ -2147,6 +2154,7 @@ main (argc, argv)\n   if (fstat (f, &st) != 0)\n     pfatal_with_name (in_fname);\n   fp->nominal_fname = fp->fname = in_fname;\n+  fp->nominal_fname_len = strlen (in_fname);\n   fp->lineno = 1;\n   fp->system_header_p = 0;\n   /* JF all this is mine about reading pipes and ttys */\n@@ -2822,9 +2830,11 @@ do { ip = &instack[indepth];\t\t\\\n \n       /* Handle any pending identifier;\n \t but the L in L'...' or L\"...\" is not an identifier.  */\n-      if (ident_length\n-\t  && ! (ident_length == 1 && hash == HASHSTEP (0, 'L')))\n-\tgoto specialchar;\n+      if (ident_length) {\n+\tif (! (ident_length == 1 && hash == HASHSTEP (0, 'L')))\n+\t  goto specialchar;\n+\tident_length = hash = 0;\n+      }\n \n       start_line = ip->lineno;\n \n@@ -2843,9 +2853,11 @@ do { ip = &instack[indepth];\t\t\\\n \t  if (!traditional) {\n \t    error_with_line (line_for_error (start_line),\n \t\t\t     \"unterminated string or character constant\");\n-\t    error_with_line (multiline_string_line,\n-\t\t\t     \"possible real start of unterminated constant\");\n-\t    multiline_string_line = 0;\n+\t    if (multiline_string_line) {\n+\t      error_with_line (multiline_string_line,\n+\t\t\t       \"possible real start of unterminated constant\");\n+\t      multiline_string_line = 0;\n+\t    }\n \t  }\n \t  break;\n \t}\n@@ -2874,20 +2886,25 @@ do { ip = &instack[indepth];\t\t\\\n \t  break;\n \n \tcase '\\\\':\n-\t  if (ibp >= limit)\n-\t    break;\n \t  if (*ibp == '\\n') {\n-\t    /* Backslash newline is replaced by nothing at all,\n-\t       but keep the line counts correct.  */\n-\t    --obp;\n+\t    /* Backslash newline is replaced by nothing at all, but\n+\t       keep the line counts correct.  But if we are reading\n+\t       from a macro, keep the backslash newline, since backslash\n+\t       newlines have already been processed.  */\n+\t    if (ip->macro)\n+\t      *obp++ = '\\n';\n+\t    else\n+\t      --obp;\n \t    ++ibp;\n \t    ++ip->lineno;\n \t  } else {\n \t    /* ANSI stupidly requires that in \\\\ the second \\\n \t       is *not* prevented from combining with a newline.  */\n-\t    while (*ibp == '\\\\' && ibp[1] == '\\n') {\n-\t      ibp += 2;\n-\t      ++ip->lineno;\n+\t    if (!ip->macro) {\n+\t      while (*ibp == '\\\\' && ibp[1] == '\\n') {\n+\t\tibp += 2;\n+\t\t++ip->lineno;\n+\t      }\n \t    }\n \t    *obp++ = *ibp++;\n \t  }\n@@ -2904,14 +2921,13 @@ do { ip = &instack[indepth];\t\t\\\n       break;\n \n     case '/':\n+      if (ip->macro != 0)\n+\tgoto randomchar;\n       if (*ibp == '\\\\' && ibp[1] == '\\n')\n \tnewline_fix (ibp);\n-\n       if (*ibp != '*'\n \t  && !(cplusplus_comments && *ibp == '/'))\n \tgoto randomchar;\n-      if (ip->macro != 0)\n-\tgoto randomchar;\n       if (ident_length)\n \tgoto specialchar;\n \n@@ -3062,9 +3078,11 @@ do { ip = &instack[indepth];\t\t\\\n \n       if (ident_length == 0) {\n \tfor (;;) {\n-\t  while (ibp[0] == '\\\\' && ibp[1] == '\\n') {\n-\t    ++ip->lineno;\n-\t    ibp += 2;\n+\t  if (!ip->macro) {\n+\t    while (ibp[0] == '\\\\' && ibp[1] == '\\n') {\n+\t      ++ip->lineno;\n+\t      ibp += 2;\n+\t    }\n \t  }\n \t  c = *ibp++;\n \t  if (!is_idchar[c] && c != '.') {\n@@ -3075,9 +3093,11 @@ do { ip = &instack[indepth];\t\t\\\n \t  /* A sign can be part of a preprocessing number\n \t     if it follows an `e' or `p'.  */\n \t  if (c == 'e' || c == 'E' || c == 'p' || c == 'P') {\n-\t    while (ibp[0] == '\\\\' && ibp[1] == '\\n') {\n-\t      ++ip->lineno;\n-\t      ibp += 2;\n+\t    if (!ip->macro) {\n+\t      while (ibp[0] == '\\\\' && ibp[1] == '\\n') {\n+\t\t++ip->lineno;\n+\t\tibp += 2;\n+\t      }\n \t    }\n \t    if (*ibp == '+' || *ibp == '-') {\n \t      *obp++ = *ibp++;\n@@ -3337,35 +3357,6 @@ do { ip = &instack[indepth];\t\t\\\n \t\t      old_iln = ip->lineno;\n \t\t      old_oln = op->lineno;\n \t\t    }\n-\t\t    /* A comment: copy it unchanged or discard it.  */\n-\t\t    else if (*ibp == '/' && ibp[1] == '*') {\n-\t\t      if (put_out_comments) {\n-\t\t\t*obp++ = '/';\n-\t\t\t*obp++ = '*';\n-\t\t      } else if (! traditional) {\n-\t\t\t*obp++ = ' ';\n-\t\t      }\n-\t\t      ibp += 2;\n-\t\t      while (ibp + 1 != limit\n-\t\t\t     && !(ibp[0] == '*' && ibp[1] == '/')) {\n-\t\t\t/* We need not worry about newline-marks,\n-\t\t\t   since they are never found in comments.  */\n-\t\t\tif (*ibp == '\\n') {\n-\t\t\t  /* Newline in a file.  Count it.  */\n-\t\t\t  ++ip->lineno;\n-\t\t\t  ++op->lineno;\n-\t\t\t}\n-\t\t\tif (put_out_comments)\n-\t\t\t  *obp++ = *ibp++;\n-\t\t\telse\n-\t\t\t  ibp++;\n-\t\t      }\n-\t\t      ibp += 2;\n-\t\t      if (put_out_comments) {\n-\t\t\t*obp++ = '*';\n-\t\t\t*obp++ = '/';\n-\t\t      }\n-\t\t    }\n \t\t    else if (is_space[*ibp]) {\n \t\t      *obp++ = *ibp++;\n \t\t      if (ibp[-1] == '\\n') {\n@@ -3392,6 +3383,59 @@ do { ip = &instack[indepth];\t\t\\\n \t\t\t}\n \t\t      }\n \t\t    }\n+\t\t    else if (ip->macro)\n+\t\t      break;\n+\t\t    else if (*ibp == '/') {\n+\t\t      /* If a comment, copy it unchanged or discard it.  */\n+\t\t      if (ibp[1] == '\\\\' && ibp[2] == '\\n')\n+\t\t\tnewline_fix (ibp + 1);\n+\t\t      if (ibp[1] == '*') {\n+\t\t\tif (put_out_comments) {\n+\t\t\t  *obp++ = '/';\n+\t\t\t  *obp++ = '*';\n+\t\t\t} else if (! traditional) {\n+\t\t\t  *obp++ = ' ';\n+\t\t\t}\n+\t\t\tfor (ibp += 2; ibp < limit; ibp++) {\n+\t\t\t  /* We need not worry about newline-marks,\n+\t\t\t     since they are never found in comments.  */\n+\t\t\t  if (ibp[0] == '*') {\n+\t\t\t    if (ibp[1] == '\\\\' && ibp[2] == '\\n')\n+\t\t\t      newline_fix (ibp + 1);\n+\t\t\t    if (ibp[1] == '/') {\n+\t\t\t      ibp += 2;\n+\t\t\t      if (put_out_comments) {\n+\t\t\t\t*obp++ = '*';\n+\t\t\t\t*obp++ = '/';\n+\t\t\t      }\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t  }\n+\t\t\t  if (*ibp == '\\n') {\n+\t\t\t    /* Newline in a file.  Count it.  */\n+\t\t\t    ++ip->lineno;\n+\t\t\t    ++op->lineno;\n+\t\t\t  }\n+\t\t\t  if (put_out_comments)\n+\t\t\t    *obp++ = *ibp;\n+\t\t\t}\n+\t\t      } else if (ibp[1] == '/' && cplusplus_comments) {\n+\t\t\tif (put_out_comments) {\n+\t\t\t  *obp++ = '/';\n+\t\t\t  *obp++ = '/';\n+\t\t\t} else if (! traditional) {\n+\t\t\t  *obp++ = ' ';\n+\t\t\t}\n+\t\t\tfor (ibp += 2; *ibp != '\\n' || ibp[-1] == '\\\\'; ibp++)\n+\t\t\t  if (put_out_comments)\n+\t\t\t    *obp++ = *ibp;\n+\t\t      } else\n+\t\t\tbreak;\n+\t\t    }\n+\t\t    else if (ibp[0] == '\\\\' && ibp[1] == '\\n') {\n+\t\t      ibp += 2;\n+\t\t      ++ip->lineno;\n+\t\t    }\n \t\t    else break;\n \t\t  }\n \t\t  if (*ibp != '(') {\n@@ -3552,6 +3596,7 @@ expand_to_temp_buffer (buf, limit, output_marks, assertions)\n   ip = &instack[indepth];\n   ip->fname = 0;\n   ip->nominal_fname = 0;\n+  ip->nominal_fname_len = 0;\n   ip->inc = 0;\n   ip->system_header_p = 0;\n   ip->macro = 0;\n@@ -3618,8 +3663,11 @@ handle_directive (ip, op)\n       if (*bp != ' ' && *bp != '\\t' && pedantic)\n \tpedwarn (\"%s in preprocessing directive\", char_name[*bp]);\n       bp++;\n-    } else if (*bp == '/' && (bp[1] == '*'\n-\t\t\t      || (cplusplus_comments && bp[1] == '/'))) {\n+    } else if (*bp == '/') {\n+      if (bp[1] == '\\\\' && bp[2] == '\\n')\n+\tnewline_fix (bp + 1);\n+      if (! (bp[1] == '*' || (cplusplus_comments && bp[1] == '/')))\n+\tbreak;\n       ip->bufp = bp + 2;\n       skip_to_end_of_comment (ip, &ip->lineno, 0);\n       bp = ip->bufp;\n@@ -3737,8 +3785,25 @@ handle_directive (ip, op)\n \t  }\n \t  break;\n \n+\tcase '\"':\n+\t  /* \"...\" is special for #include.  */\n+\t  if (IS_INCLUDE_DIRECTIVE_TYPE (kt->type)) {\n+\t    while (bp < limit && *bp != '\\n') {\n+\t      if (*bp == '\"') {\n+\t\tbp++;\n+\t\tbreak;\n+\t      }\n+\t      if (*bp == '\\\\' && bp[1] == '\\n') {\n+\t\tip->lineno++;\n+\t\tcopy_directive = 1;\n+\t\tbp++;\n+\t      }\n+\t      bp++;\n+\t    }\n+\t    break;\n+\t  }\n+\t  /* Fall through.  */\n \tcase '\\'':\n-\tcase '\\\"':\n \t  bp = skip_quoted_string (bp - 1, limit, ip->lineno, &ip->lineno, &copy_directive, &unterminated);\n \t  /* Don't bother calling the directive if we already got an error\n \t     message due to unterminated string.  Skip everything and pretend\n@@ -3904,13 +3969,7 @@ handle_directive (ip, op)\n \t\t= skip_quoted_string (xp - 1, bp, ip->lineno,\n \t\t\t\t      NULL_PTR, NULL_PTR, NULL_PTR);\n \t      while (xp != bp1)\n-\t\tif (*xp == '\\\\') {\n-\t\t  if (*++xp != '\\n')\n-\t\t    *cp++ = '\\\\';\n-\t\t  else\n-\t\t    xp++;\n-\t\t} else\n-\t\t  *cp++ = *xp++;\n+\t\t*cp++ = *xp++;\n \t    }\n \t    break;\n \n@@ -3947,7 +4006,7 @@ handle_directive (ip, op)\n \t directives through.  */\n \n       if (!no_output && already_output == 0\n-\t  && (kt->type == T_DEFINE ? dump_names <= dump_macros\n+\t  && (kt->type == T_DEFINE ? (int) dump_names <= (int) dump_macros\n \t      : IS_INCLUDE_DIRECTIVE_TYPE (kt->type) ? dump_includes\n \t      : kt->type == T_PRAGMA)) {\n         int len;\n@@ -4047,16 +4106,14 @@ special_symbol (hp, op)\n   case T_FILE:\n   case T_BASE_FILE:\n     {\n-      char *string;\n-      if (hp->type == T_FILE)\n-\tstring = ip->nominal_fname;\n-      else\n-\tstring = instack[0].nominal_fname;\n+      FILE_BUF *p = hp->type == T_FILE ? ip : &instack[0];\n+      char *string = p->nominal_fname;\n \n       if (string)\n \t{\n-\t  buf = (char *) alloca (3 + 4 * strlen (string));\n-\t  quote_string (buf, string);\n+\t  size_t string_len = p->nominal_fname_len;\n+\t  buf = (char *) alloca (3 + 4 * string_len);\n+\t  quote_string (buf, string, string_len);\n \t}\n       else\n \tbuf = \"\\\"\\\"\";\n@@ -4274,10 +4331,15 @@ do_include (buf, limit, op, keyword)\n       FILE_BUF *fp;\n       /* Copy the operand text, concatenating the strings.  */\n       {\n-\twhile (fin != limit) {\n-\t  while (fin != limit && *fin != '\\\"')\n-\t    *fend++ = *fin++;\n-\t  fin++;\n+\tfor (;;) {\n+\t  for (;;) {\n+\t    if (fin == limit)\n+\t      goto invalid_include_file_name;\n+\t    *fend = *fin++;\n+\t    if (*fend == '\"')\n+\t      break;\n+\t    fend++;\n+\t  }\n \t  if (fin == limit)\n \t    break;\n \t  /* If not at the end, there had better be another string.  */\n@@ -4305,7 +4367,8 @@ do_include (buf, limit, op, keyword)\n \t    /* Found a named file.  Figure out dir of the file,\n \t       and put it in front of the search list.  */\n \t    dsp = ((struct file_name_list *)\n-\t\t   alloca (sizeof (struct file_name_list) + strlen (nam)));\n+\t\t   alloca (sizeof (struct file_name_list)\n+\t\t\t   + fp->nominal_fname_len));\n \t    strcpy (dsp->fname, nam);\n \t    simplify_filename (dsp->fname);\n \t    nam = base_name (dsp->fname);\n@@ -4360,16 +4423,18 @@ do_include (buf, limit, op, keyword)\n #endif\n \n   fail:\n-    if (retried) {\n-      error (\"`#%s' expects \\\"FILENAME\\\" or <FILENAME>\", keyword->name);\n-      return 0;\n-    } else {\n+    if (! retried) {\n       /* Expand buffer and then remove any newline markers.\n \t We can't just tell expand_to_temp_buffer to omit the markers,\n \t since it would put extra spaces in include file names.  */\n       FILE_BUF trybuf;\n       U_CHAR *src;\n+      int errors_before_expansion = errors;\n       trybuf = expand_to_temp_buffer (buf, limit, 1, 0);\n+      if (errors != errors_before_expansion) {\n+\tfree (trybuf.buf);\n+\tgoto invalid_include_file_name;\n+      }\n       src = trybuf.buf;\n       buf = (U_CHAR *) alloca (trybuf.bufp - trybuf.buf + 1);\n       limit = buf;\n@@ -4393,9 +4458,13 @@ do_include (buf, limit, op, keyword)\n       }\n       *limit = 0;\n       free (trybuf.buf);\n-      retried++;\n+      retried = 1;\n       goto get_filename;\n     }\n+\n+  invalid_include_file_name:\n+    error (\"`#%s' expects \\\"FILENAME\\\" or <FILENAME>\", keyword->name);\n+    return 0;\n   }\n \n   /* For #include_next, skip in the search path\n@@ -5049,6 +5118,7 @@ finclude (f, inc, op, system_header_p, dirptr)\n   fp = &instack[indepth + 1];\n   bzero ((char *) fp, sizeof (FILE_BUF));\n   fp->nominal_fname = fp->fname = fname;\n+  fp->nominal_fname_len = strlen (fname);\n   fp->inc = inc;\n   fp->length = 0;\n   fp->lineno = 1;\n@@ -5436,7 +5506,8 @@ write_output ()\n \t\t\t\t     line_directive_len *= 2);\n \tsprintf (line_directive, \"\\n# %d \", next_string->lineno);\n \tstrcpy (quote_string (line_directive + strlen (line_directive),\n-\t\t\t      (char *) next_string->filename),\n+\t\t\t      (char *) next_string->filename,\n+\t\t\t      strlen ((char *) next_string->filename)),\n \t\t\"\\n\");\n \tsafe_write (fileno (stdout), line_directive, strlen (line_directive));\n \tsafe_write (fileno (stdout),\n@@ -5518,6 +5589,7 @@ create_definition (buf, limit, op)\n   int sym_length;\t\t/* and how long it is */\n   int line = instack[indepth].lineno;\n   char *file = instack[indepth].nominal_fname;\n+  size_t file_len = instack[indepth].nominal_fname_len;\n   int rest_args = 0;\n \n   DEFINITION *defn;\n@@ -5667,6 +5739,7 @@ create_definition (buf, limit, op)\n \n   defn->line = line;\n   defn->file = file;\n+  defn->file_len = file_len;\n \n   /* OP is null if this is a predefinition */\n   defn->predefined = !op;\n@@ -5727,7 +5800,9 @@ do_define (buf, limit, op, keyword)\n \n \tpedwarn (\"`%.*s' redefined\", mdef.symlen, mdef.symnam);\n \tif (hp->type == T_MACRO)\n-\t  pedwarn_with_file_and_line (hp->value.defn->file, hp->value.defn->line,\n+\t  pedwarn_with_file_and_line (hp->value.defn->file,\n+\t\t\t\t      hp->value.defn->file_len,\n+\t\t\t\t      hp->value.defn->line,\n \t\t\t\t      \"this is the location of the previous definition\");\n       }\n       /* Replace the old definition.  */\n@@ -6640,7 +6715,7 @@ do_line (buf, limit, op, keyword)\n \tbreak;\n \n       case '\\\"':\n-\tp[-1] = 0;\n+\t*--p = 0;\n \tgoto fname_done;\n       }\n   fname_done:\n@@ -6686,6 +6761,7 @@ do_line (buf, limit, op, keyword)\n       if (hp->length == fname_length &&\n \t  bcmp (hp->value.cpval, fname, fname_length) == 0) {\n \tip->nominal_fname = hp->value.cpval;\n+\tip->nominal_fname_len = fname_length;\n \tbreak;\n       }\n     if (hp == 0) {\n@@ -6694,9 +6770,9 @@ do_line (buf, limit, op, keyword)\n       hp->next = *hash_bucket;\n       *hash_bucket = hp;\n \n-      hp->length = fname_length;\n       ip->nominal_fname = hp->value.cpval = ((char *) hp) + sizeof (HASHNODE);\n-      bcopy (fname, hp->value.cpval, fname_length);\n+      ip->nominal_fname_len = hp->length = fname_length;\n+      bcopy (fname, hp->value.cpval, fname_length + 1);\n     }\n   } else if (*bp) {\n     error (\"invalid format `#line' directive\");\n@@ -6965,9 +7041,13 @@ do_elif (buf, limit, op, keyword)\n     if (if_stack->type != T_IF && if_stack->type != T_ELIF) {\n       error (\"`#elif' after `#else'\");\n       fprintf (stderr, \" (matches line %d\", if_stack->lineno);\n-      if (if_stack->fname != NULL && ip->fname != NULL\n-\t  && strcmp (if_stack->fname, ip->nominal_fname) != 0)\n-\tfprintf (stderr, \", file %s\", if_stack->fname);\n+      if (! (if_stack->fname_len == ip->nominal_fname_len\n+\t     && !bcmp (if_stack->fname, ip->nominal_fname,\n+\t\t       if_stack->fname_len))) {\n+\tfprintf (stderr, \", file \");\n+\tfwrite (if_stack->fname, sizeof if_stack->fname[0],\n+\t\tif_stack->fname_len, stderr);\n+      }\n       fprintf (stderr, \")\\n\");\n     }\n     if_stack->type = T_ELIF;\n@@ -7127,6 +7207,7 @@ conditional_skip (ip, skip, type, control_macro, op)\n \n   temp = (IF_STACK_FRAME *) xcalloc (1, sizeof (IF_STACK_FRAME));\n   temp->fname = ip->nominal_fname;\n+  temp->fname_len = ip->nominal_fname_len;\n   temp->lineno = ip->lineno;\n   temp->next = if_stack;\n   temp->control_macro = control_macro;\n@@ -7163,6 +7244,7 @@ skip_if_group (ip, any, op)\n   /* Save info about where the group starts.  */\n   U_CHAR *beg_of_group = bp;\n   int beg_lineno = ip->lineno;\n+  int skipping_include_directive = 0;\n \n   if (output_conditionals && op != 0) {\n     char *ptr = \"#failed\\n\";\n@@ -7191,22 +7273,49 @@ skip_if_group (ip, any, op)\n \tbp = skip_to_end_of_comment (ip, &ip->lineno, 0);\n       }\n       break;\n+    case '<':\n+      if (skipping_include_directive) {\n+\twhile (bp < endb && *bp != '>' && *bp != '\\n') {\n+\t  if (*bp == '\\\\' && bp[1] == '\\n') {\n+\t    ip->lineno++;\n+\t    bp++;\n+\t  }\n+\t  bp++;\n+\t}\n+      }\n+      break;\n     case '\\\"':\n+      if (skipping_include_directive) {\n+\twhile (bp < endb && *bp != '\\n') {\n+\t  if (*bp == '\"') {\n+\t    bp++;\n+\t    break;\n+\t  }\n+\t  if (*bp == '\\\\' && bp[1] == '\\n') {\n+\t    ip->lineno++;\n+\t    bp++;\n+\t  }\n+\t  bp++;\n+\t}\n+\tbreak;\n+      }\n+      /* Fall through.  */\n     case '\\'':\n       bp = skip_quoted_string (bp - 1, endb, ip->lineno, &ip->lineno,\n \t\t\t       NULL_PTR, NULL_PTR);\n       break;\n     case '\\\\':\n-      /* Char after backslash loses its special meaning.  */\n-      if (bp < endb) {\n-\tif (*bp == '\\n')\n-\t  ++ip->lineno;\t\t/* But do update the line-count.  */\n+      /* Char after backslash loses its special meaning in some cases.  */\n+      if (*bp == '\\n') {\n+\t++ip->lineno;\n+\tbp++;\n+      } else if (traditional && bp < endb)\n \tbp++;\n-      }\n       break;\n     case '\\n':\n       ++ip->lineno;\n       beg_of_line = bp;\n+      skipping_include_directive = 0;\n       break;\n     case '%':\n       if (beg_of_line == 0 || traditional)\n@@ -7268,13 +7377,17 @@ skip_if_group (ip, any, op)\n \telse if (*bp == '\\\\' && bp[1] == '\\n')\n \t  bp += 2;\n \telse if (*bp == '/') {\n+\t  if (bp[1] == '\\\\' && bp[2] == '\\n')\n+\t    newline_fix (bp + 1);\n \t  if (bp[1] == '*') {\n \t    for (bp += 2; ; bp++) {\n \t      if (*bp == '\\n')\n \t\tip->lineno++;\n \t      else if (*bp == '*') {\n \t\tif (bp[-1] == '/' && warn_comments)\n \t\t  warning (\"`/*' within comment\");\n+\t\tif (bp[1] == '\\\\' && bp[2] == '\\n')\n+\t\t  newline_fix (bp + 1);\n \t\tif (bp[1] == '/')\n \t\t  break;\n \t      }\n@@ -7369,6 +7482,7 @@ skip_if_group (ip, any, op)\n \t    if_stack = temp;\n \t    temp->lineno = ip->lineno;\n \t    temp->fname = ip->nominal_fname;\n+\t    temp->fname_len = ip->nominal_fname_len;\n \t    temp->type = kt->type;\n \t    break;\n \t  case T_ELSE:\n@@ -7395,7 +7509,13 @@ skip_if_group (ip, any, op)\n \t    free (temp);\n \t    break;\n \n-\t   default:\n+\t  case T_INCLUDE:\n+\t  case T_INCLUDE_NEXT:\n+\t  case T_IMPORT:\n+\t    skipping_include_directive = 1;\n+\t    break;\n+\n+\t  default:\n \t    break;\n \t  }\n \t  break;\n@@ -7464,8 +7584,13 @@ do_else (buf, limit, op, keyword)\n     if (if_stack->type != T_IF && if_stack->type != T_ELIF) {\n       error (\"`#else' after `#else'\");\n       fprintf (stderr, \" (matches line %d\", if_stack->lineno);\n-      if (strcmp (if_stack->fname, ip->nominal_fname) != 0)\n-\tfprintf (stderr, \", file %s\", if_stack->fname);\n+      if (! (if_stack->fname_len == ip->nominal_fname_len\n+\t     && !bcmp (if_stack->fname, ip->nominal_fname,\n+\t\t       if_stack->fname_len))) {\n+\tfprintf (stderr, \", file \");\n+\tfwrite (if_stack->fname, sizeof if_stack->fname[0],\n+\t\tif_stack->fname_len, stderr);\n+      }\n       fprintf (stderr, \")\\n\");\n     }\n     if_stack->type = T_ELSE;\n@@ -7719,10 +7844,11 @@ skip_quoted_string (bp, limit, start_line, count_newlines, backslash_newlines_p,\n \t  ++*count_newlines;\n \tbp += 2;\n       }\n-      if (*bp == '\\n' && count_newlines) {\n+      if (*bp == '\\n') {\n \tif (backslash_newlines_p)\n \t  *backslash_newlines_p = 1;\n-\t++*count_newlines;\n+\tif (count_newlines)\n+\t  ++*count_newlines;\n       }\n       bp++;\n     } else if (c == '\\n') {\n@@ -7757,16 +7883,19 @@ skip_quoted_string (bp, limit, start_line, count_newlines, backslash_newlines_p,\n }\n \n /* Place into DST a quoted string representing the string SRC.\n+   SRCLEN is the length of SRC; SRC may contain null bytes.\n    Return the address of DST's terminating null.  */\n \n static char *\n-quote_string (dst, src)\n+quote_string (dst, src, srclen)\n      char *dst, *src;\n+     size_t srclen;\n {\n   U_CHAR c;\n+  char *srclim = src + srclen;\n \n   *dst++ = '\\\"';\n-  for (;;)\n+  while (src != srclim)\n     switch ((c = *src++))\n       {\n       default:\n@@ -7784,12 +7913,11 @@ quote_string (dst, src)\n \t*dst++ = '\\\\';\n \t*dst++ = c;\n \tbreak;\n-      \n-      case '\\0':\n-\t*dst++ = '\\\"';\n-\t*dst = '\\0';\n-\treturn dst;\n       }\n+      \n+  *dst++ = '\\\"';\n+  *dst = '\\0';\n+  return dst;\n }\n \n /* Skip across a group of balanced parens, starting from IP->bufp.\n@@ -7888,10 +8016,10 @@ output_line_directive (ip, op, conditional, file_change)\n     ip->bufp++;\n   }\n \n-  line_directive_buf = (char *) alloca (4 * strlen (ip->nominal_fname) + 100);\n+  line_directive_buf = (char *) alloca (4 * ip->nominal_fname_len + 100);\n   sprintf (line_directive_buf, \"# %d \", ip->lineno);\n   line_end = quote_string (line_directive_buf + strlen (line_directive_buf),\n-\t\t\t   ip->nominal_fname);\n+\t\t\t   ip->nominal_fname, ip->nominal_fname_len);\n   if (file_change != same_file) {\n     *line_end++ = ' ';\n     *line_end++ = file_change == enter_file ? '1' : '2';\n@@ -8156,29 +8284,30 @@ macroexpand (hp, op)\n \t  for (; i < arglen; i++) {\n \t    c = arg->raw[i];\n \n-\t    /* Special markers Newline Space\n-\t       generate nothing for a stringified argument.  */\n-\t    if (c == '\\n' && arg->raw[i+1] != '\\n') {\n-\t      i++;\n-\t      continue;\n-\t    }\n+\t    if (! in_string) {\n+\t      /* Special markers Newline Space\n+\t\t generate nothing for a stringified argument.  */\n+\t      if (c == '\\n' && arg->raw[i+1] != '\\n') {\n+\t\ti++;\n+\t\tcontinue;\n+\t      }\n \n-\t    /* Internal sequences of whitespace are replaced by one space\n-\t       except within an string or char token.  */\n-\t    if (! in_string\n-\t\t&& (c == '\\n' ? arg->raw[i+1] == '\\n' : is_space[c])) {\n-\t      while (1) {\n-\t\t/* Note that Newline Space does occur within whitespace\n-\t\t   sequences; consider it part of the sequence.  */\n-\t\tif (c == '\\n' && is_space[arg->raw[i+1]])\n-\t\t  i += 2;\n-\t\telse if (c != '\\n' && is_space[c])\n-\t\t  i++;\n-\t\telse break;\n-\t\tc = arg->raw[i];\n+\t      /* Internal sequences of whitespace are replaced by one space\n+\t\t except within an string or char token.  */\n+\t      if (c == '\\n' ? arg->raw[i+1] == '\\n' : is_space[c]) {\n+\t\twhile (1) {\n+\t\t  /* Note that Newline Space does occur within whitespace\n+\t\t     sequences; consider it part of the sequence.  */\n+\t\t  if (c == '\\n' && is_space[arg->raw[i+1]])\n+\t\t    i += 2;\n+\t\t  else if (c != '\\n' && is_space[c])\n+\t\t    i++;\n+\t\t  else break;\n+\t\t  c = arg->raw[i];\n+\t\t}\n+\t\ti--;\n+\t\tc = ' ';\n \t      }\n-\t      i--;\n-\t      c = ' ';\n \t    }\n \n \t    if (escaped)\n@@ -8196,12 +8325,10 @@ macroexpand (hp, op)\n \t    /* Escape these chars */\n \t    if (c == '\\\"' || (in_string && c == '\\\\'))\n \t      xbuf[totlen++] = '\\\\';\n-\t    if (isprint (c))\n-\t      xbuf[totlen++] = c;\n-\t    else {\n-\t      sprintf ((char *) &xbuf[totlen], \"\\\\%03o\", (unsigned int) c);\n-\t      totlen += 4;\n-\t    }\n+\t    /* We used to output e.g. \\008 for control characters here,\n+\t       but this doesn't conform to the C Standard.\n+\t       Just output the characters as-is.  */\n+\t    xbuf[totlen++] = c;\n \t  }\n \t  if (!traditional)\n \t    xbuf[totlen++] = '\\\"'; /* insert ending quote */\n@@ -8317,6 +8444,7 @@ macroexpand (hp, op)\n \n     ip2->fname = 0;\n     ip2->nominal_fname = 0;\n+    ip2->nominal_fname_len = 0;\n     ip2->inc = 0;\n     /* This may not be exactly correct, but will give much better error\n        messages for nested macro calls than using a line number of zero.  */\n@@ -8355,7 +8483,7 @@ macarg (argptr, rest_args)\n \n   /* Try to parse as much of the argument as exists at this\n      input stack level.  */\n-  U_CHAR *bp = macarg1 (ip->bufp, ip->buf + ip->length,\n+  U_CHAR *bp = macarg1 (ip->bufp, ip->buf + ip->length, ip->macro,\n \t\t\t&paren, &newlines, &comments, rest_args);\n \n   /* If we find the end of the argument at this level,\n@@ -8393,7 +8521,7 @@ macarg (argptr, rest_args)\n       ip = &instack[--indepth];\n       newlines = 0;\n       comments = 0;\n-      bp = macarg1 (ip->bufp, ip->buf + ip->length, &paren,\n+      bp = macarg1 (ip->bufp, ip->buf + ip->length, ip->macro, &paren,\n \t\t    &newlines, &comments, rest_args);\n       final_start = bufsize;\n       bufsize += bp - ip->bufp;\n@@ -8456,15 +8584,14 @@ macarg (argptr, rest_args)\n #endif\n       if (c == '\\\"' || c == '\\\\') /* escape these chars */\n \ttotlen++;\n-      else if (!isprint (c))\n-\ttotlen += 3;\n     }\n     argptr->stringified_length = totlen;\n   }\n   return result;\n }\n \f\n /* Scan text from START (inclusive) up to LIMIT (exclusive),\n+   taken from the expansion of MACRO,\n    counting parens in *DEPTHPTR,\n    and return if reach LIMIT\n    or before a `)' that would make *DEPTHPTR negative\n@@ -8478,9 +8605,10 @@ macarg (argptr, rest_args)\n    Set *COMMENTS to 1 if a comment is seen.  */\n \n static U_CHAR *\n-macarg1 (start, limit, depthptr, newlines, comments, rest_args)\n+macarg1 (start, limit, macro, depthptr, newlines, comments, rest_args)\n      U_CHAR *start;\n      register U_CHAR *limit;\n+     struct hashnode *macro;\n      int *depthptr, *newlines, *comments;\n      int rest_args;\n {\n@@ -8497,18 +8625,15 @@ macarg1 (start, limit, depthptr, newlines, comments, rest_args)\n       break;\n     case '\\\\':\n       /* Traditionally, backslash makes following char not special.  */\n-      if (bp + 1 < limit && traditional)\n-\t{\n-\t  bp++;\n-\t  /* But count source lines anyway.  */\n-\t  if (*bp == '\\n')\n-\t    ++*newlines;\n-\t}\n+      if (traditional && bp + 1 < limit && bp[1] != '\\n')\n+\tbp++;\n       break;\n     case '\\n':\n       ++*newlines;\n       break;\n     case '/':\n+      if (macro)\n+\tbreak;\n       if (bp[1] == '\\\\' && bp[2] == '\\n')\n \tnewline_fix (bp + 1);\n       if (bp[1] == '*') {\n@@ -8549,8 +8674,11 @@ macarg1 (start, limit, depthptr, newlines, comments, rest_args)\n \t    bp++;\n \t    if (*bp == '\\n')\n \t      ++*newlines;\n-\t    while (*bp == '\\\\' && bp[1] == '\\n') {\n-\t      bp += 2;\n+\t    if (!macro) {\n+\t      while (*bp == '\\\\' && bp[1] == '\\n') {\n+\t\tbp += 2;\n+\t\t++*newlines;\n+\t      }\n \t    }\n \t  } else if (*bp == '\\n') {\n \t    ++*newlines;\n@@ -8646,16 +8774,16 @@ discard_comments (start, length, newlines)\n \tobp--;\n       else\n \tobp[-1] = ' ';\n-      ibp++;\n-      while (ibp + 1 < limit) {\n-\tif (ibp[0] == '*'\n-\t    && ibp[1] == '\\\\' && ibp[2] == '\\n')\n-\t  newline_fix (ibp + 1);\n-\tif (ibp[0] == '*' && ibp[1] == '/')\n-\t  break;\n-\tibp++;\n+      while (++ibp < limit) {\n+\tif (ibp[0] == '*') {\n+\t  if (ibp[1] == '\\\\' && ibp[2] == '\\n')\n+\t    newline_fix (ibp + 1);\n+\t  if (ibp[1] == '/') {\n+\t    ibp += 2;\n+\t    break;\n+\t  }\n+\t}\n       }\n-      ibp += 2;\n       break;\n \n     case '\\'':\n@@ -8671,10 +8799,16 @@ discard_comments (start, length, newlines)\n \t    break;\n \t  if (c == '\\n' && quotec == '\\'')\n \t    break;\n-\t  if (c == '\\\\' && ibp < limit) {\n-\t    while (*ibp == '\\\\' && ibp[1] == '\\n')\n-\t      ibp += 2;\n-\t    *obp++ = *ibp++;\n+\t  if (c == '\\\\') {\n+\t    if (ibp < limit && *ibp == '\\n') {\n+\t      ibp++;\n+\t      obp--;\n+\t    } else {\n+\t      while (*ibp == '\\\\' && ibp[1] == '\\n')\n+\t\tibp += 2;\n+\t      if (ibp < limit)\n+\t\t*obp++ = *ibp++;\n+\t    }\n \t  }\n \t}\n       }\n@@ -8725,7 +8859,7 @@ change_newlines (start, length)\n \tint quotec = c;\n \twhile (ibp < limit) {\n \t  *obp++ = c = *ibp++;\n-\t  if (c == quotec)\n+\t  if (c == quotec && ibp[-2] != '\\\\')\n \t    break;\n \t  if (c == '\\n' && quotec == '\\'')\n \t    break;\n@@ -8799,8 +8933,11 @@ verror (msg, args)\n       break;\n     }\n \n-  if (ip != NULL)\n-    fprintf (stderr, \"%s:%d: \", ip->nominal_fname, ip->lineno);\n+  if (ip != NULL) {\n+    fwrite (ip->nominal_fname, sizeof ip->nominal_fname[0],\n+\t    ip->nominal_fname_len, stderr);\n+    fprintf (stderr, \":%d: \", ip->lineno);\n+  }\n   vfprintf (stderr, msg, args);\n   fprintf (stderr, \"\\n\");\n   errors++;\n@@ -8812,6 +8949,7 @@ static void\n error_from_errno (name)\n      char *name;\n {\n+  int e = errno;\n   int i;\n   FILE_BUF *ip = NULL;\n \n@@ -8823,10 +8961,13 @@ error_from_errno (name)\n       break;\n     }\n \n-  if (ip != NULL)\n-    fprintf (stderr, \"%s:%d: \", ip->nominal_fname, ip->lineno);\n+  if (ip != NULL) {\n+    fwrite (ip->nominal_fname, sizeof ip->nominal_fname[0],\n+\t    ip->nominal_fname_len, stderr);\n+    fprintf (stderr, \":%d: \", ip->lineno);\n+  }\n \n-  fprintf (stderr, \"%s: %s\\n\", name, my_strerror (errno));\n+  fprintf (stderr, \"%s: %s\\n\", name, my_strerror (e));\n \n   errors++;\n }\n@@ -8866,8 +9007,11 @@ vwarning (msg, args)\n       break;\n     }\n \n-  if (ip != NULL)\n-    fprintf (stderr, \"%s:%d: \", ip->nominal_fname, ip->lineno);\n+  if (ip != NULL) {\n+    fwrite (ip->nominal_fname, sizeof ip->nominal_fname[0],\n+\t    ip->nominal_fname_len, stderr);\n+    fprintf (stderr, \":%d: \", ip->lineno);\n+  }\n   fprintf (stderr, \"warning: \");\n   vfprintf (stderr, msg, args);\n   fprintf (stderr, \"\\n\");\n@@ -8906,8 +9050,11 @@ verror_with_line (line, msg, args)\n       break;\n     }\n \n-  if (ip != NULL)\n-    fprintf (stderr, \"%s:%d: \", ip->nominal_fname, line);\n+  if (ip != NULL) {\n+    fwrite (ip->nominal_fname, sizeof ip->nominal_fname[0],\n+\t    ip->nominal_fname_len, stderr);\n+    fprintf (stderr, \":%d: \", line);\n+  }\n   vfprintf (stderr, msg, args);\n   fprintf (stderr, \"\\n\");\n   errors++;\n@@ -8952,8 +9099,11 @@ vwarning_with_line (line, msg, args)\n       break;\n     }\n \n-  if (ip != NULL)\n-    fprintf (stderr, line ? \"%s:%d: \" : \"%s: \", ip->nominal_fname, line);\n+  if (ip != NULL) {\n+    fwrite (ip->nominal_fname, sizeof ip->nominal_fname[0],\n+\t    ip->nominal_fname_len, stderr);\n+    fprintf (stderr, line ? \":%d: \" : \": \", line);\n+  }\n   fprintf (stderr, \"warning: \");\n   vfprintf (stderr, msg, args);\n   fprintf (stderr, \"\\n\");\n@@ -8999,10 +9149,12 @@ pedwarn_with_line (line, PRINTF_ALIST (msg))\n \n static void\n #if defined (__STDC__) && defined (HAVE_VPRINTF)\n-pedwarn_with_file_and_line (char *file, int line, PRINTF_ALIST (msg))\n+pedwarn_with_file_and_line (char *file, size_t file_len, int line,\n+\t\t\t    PRINTF_ALIST (msg))\n #else\n-pedwarn_with_file_and_line (file, line, PRINTF_ALIST (msg))\n+pedwarn_with_file_and_line (file, file_len, line, PRINTF_ALIST (msg))\n      char *file;\n+     size_t file_len;\n      int line;\n      PRINTF_DCL (msg)\n #endif\n@@ -9011,8 +9163,10 @@ pedwarn_with_file_and_line (file, line, PRINTF_ALIST (msg))\n \n   if (!pedantic_errors && inhibit_warnings)\n     return;\n-  if (file != NULL)\n-    fprintf (stderr, \"%s:%d: \", file, line);\n+  if (file) {\n+    fwrite (file, sizeof file[0], file_len, stderr);\n+    fprintf (stderr, \":%d: \", line);\n+  }\n   if (pedantic_errors)\n     errors++;\n   if (!pedantic_errors)\n@@ -9059,7 +9213,10 @@ print_containing_files ()\n \tfprintf (stderr, \",\\n                \");\n       }\n \n-      fprintf (stderr, \" from %s:%d\", ip->nominal_fname, ip->lineno);\n+      fprintf (stderr, \" from \");\n+      fwrite (ip->nominal_fname, sizeof ip->nominal_fname[0],\n+\t      ip->nominal_fname_len, stderr);\n+      fprintf (stderr, \":%d\", ip->lineno);\n     }\n   if (! first)\n     fprintf (stderr, \":\\n\");\n@@ -9660,10 +9817,7 @@ make_definition (str, op)\n \tif (unterminated)\n \t  return;\n \twhile (p != p1)\n-\t  if (*p == '\\\\' && p[1] == '\\n')\n-\t    p += 2;\n-\t  else\n-\t    *q++ = *p++;\n+\t  *q++ = *p++;\n       } else if (*p == '\\\\' && p[1] == '\\n')\n \tp += 2;\n       /* Change newline chars into newline-markers.  */\n@@ -9681,6 +9835,7 @@ make_definition (str, op)\n   \n   ip = &instack[++indepth];\n   ip->nominal_fname = ip->fname = \"*Initialization*\";\n+  ip->nominal_fname_len = strlen (ip->nominal_fname);\n \n   ip->buf = ip->bufp = buf;\n   ip->length = strlen ((char *) buf);\n@@ -9710,6 +9865,7 @@ make_undef (str, op)\n \n   ip = &instack[++indepth];\n   ip->nominal_fname = ip->fname = \"*undef*\";\n+  ip->nominal_fname_len = strlen (ip->nominal_fname);\n \n   ip->buf = ip->bufp = (U_CHAR *) str;\n   ip->length = strlen (str);\n@@ -9766,6 +9922,7 @@ make_assertion (option, str)\n   \n   ip = &instack[++indepth];\n   ip->nominal_fname = ip->fname = \"*Initialization*\";\n+  ip->nominal_fname_len = strlen (ip->nominal_fname);\n \n   ip->buf = ip->bufp = buf;\n   ip->length = strlen ((char *) buf);\n@@ -10048,8 +10205,7 @@ static void\n perror_with_name (name)\n      char *name;\n {\n-  fprintf (stderr, \"%s: \", progname);\n-  fprintf (stderr, \"%s: %s\\n\", name, my_strerror (errno));\n+  fprintf (stderr, \"%s: %s: %s\\n\", progname, name, my_strerror (errno));\n   errors++;\n }\n "}, {"sha": "de021e09559cf70b7c136bf95a237cc985e287fe", "filename": "gcc/cexp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -433,7 +433,7 @@ static const short yycheck[] = {     4,\n     26,    27,    23,    24,    25,    26,    27,     0,     9\n };\n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/share/bison.simple\"\n+#line 3 \"/usr/cygnus/latest-940103/share/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -626,7 +626,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/usr/share/bison.simple\"\n+#line 196 \"/usr/cygnus/latest-940103/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -1207,7 +1207,7 @@ case 40:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/usr/share/bison.simple\"\n+#line 498 \"/usr/cygnus/latest-940103/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;"}, {"sha": "8a03a3ded67ada1aae76afcc833e8e9fd979785c", "filename": "gcc/combine.c", "status": "modified", "additions": 64, "deletions": 12, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -7072,8 +7072,8 @@ make_field_assignment (x)\n \n   pos = get_pos_from_mask ((~ c1) & GET_MODE_MASK (GET_MODE (dest)), &len);\n   if (pos < 0 || pos + len > GET_MODE_BITSIZE (GET_MODE (dest))\n-      || (GET_MODE_BITSIZE (GET_MODE (other)) <= HOST_BITS_PER_WIDE_INT\n-\t  && (c1 & nonzero_bits (other, GET_MODE (other))) != 0))\n+      || GET_MODE_BITSIZE (GET_MODE (dest)) > HOST_BITS_PER_WIDE_INT\n+      || (c1 & nonzero_bits (other, GET_MODE (dest))) != 0)\n     return x;\n \n   assign = make_extraction (VOIDmode, dest, pos, NULL_RTX, len, 1, 1, 0);\n@@ -9324,6 +9324,13 @@ gen_binary (code, mode, op0, op1)\n \t      && GET_RTX_CLASS (GET_CODE (op1)) != 'o')))\n     return gen_rtx_combine (code, mode, op1, op0);\n \n+  /* If we are turning off bits already known off in OP0, we need not do\n+     an AND.  */\n+  else if (code == AND && GET_CODE (op1) == CONST_INT\n+\t   && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t   && (nonzero_bits (op0, mode) & ~ INTVAL (op1)) == 0)\n+    return op0;\n+\n   return gen_rtx_combine (code, mode, op0, op1);\n }\n \n@@ -10127,6 +10134,32 @@ simplify_comparison (code, pop0, pop1)\n \t      op0 = gen_lowpart_for_combine (tmode, XEXP (op0, 0));\n \t      continue;\n \t    }\n+\n+\t  /* If this is (and:M1 (subreg:M2 X 0) (const_int C1)) where C1 fits\n+\t     in both M1 and M2 and the SUBREG is either paradoxical or\n+\t     represents the low part, permute the SUBREG and the AND and\n+\t     try again.  */\n+\t  if (GET_CODE (XEXP (op0, 0)) == SUBREG\n+\t      && ((mode_width\n+\t\t   >= GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (XEXP (op0, 0)))))\n+\t\t  || subreg_lowpart_p (XEXP (op0, 0)))\n+\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t      && mode_width <= HOST_BITS_PER_WIDE_INT\n+\t      && (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (XEXP (op0, 0))))\n+\t\t  <= HOST_BITS_PER_WIDE_INT)\n+\t      && (INTVAL (XEXP (op0, 1)) & ~ mask) == 0\n+\t      && 0 == (~ GET_MODE_MASK (GET_MODE (SUBREG_REG (XEXP (op0, 0))))\n+\t\t       & INTVAL (XEXP (op0, 1))))\n+\t\t       \n+\t    {\n+\t      op0\n+\t\t= gen_lowpart_for_combine\n+\t\t  (mode,\n+\t\t   gen_binary (AND, GET_MODE (SUBREG_REG (XEXP (op0, 0))),\n+\t\t\t       SUBREG_REG (XEXP (op0, 0)), XEXP (op0, 1)));\n+\t      continue;\n+\t    }\n+\n \t  break;\n \n \tcase ASHIFT:\n@@ -11459,15 +11492,21 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t  if (reg_set_p (XEXP (note, 0), PATTERN (tem)))\n \t\t    {\n \t\t      rtx set = single_set (tem);\n+\t\t      rtx inner_dest = 0;\n+\n+\t\t      if (set != 0)\n+\t\t\tfor (inner_dest = SET_DEST (set);\n+\t\t\t     GET_CODE (inner_dest) == STRICT_LOW_PART\n+\t\t\t     || GET_CODE (inner_dest) == SUBREG\n+\t\t\t     || GET_CODE (inner_dest) == ZERO_EXTRACT;\n+\t\t\t     inner_dest = XEXP (inner_dest, 0))\n+\t\t\t  ;\n \n \t\t      /* Verify that it was the set, and not a clobber that\n \t\t\t modified the register.  */\n \n \t\t      if (set != 0 && ! side_effects_p (SET_SRC (set))\n-\t\t\t  && (rtx_equal_p (XEXP (note, 0), SET_DEST (set))\n-\t\t\t      || (GET_CODE (SET_DEST (set)) == SUBREG\n-\t\t\t\t  && rtx_equal_p (XEXP (note, 0),\n-\t\t\t\t\t\t  XEXP (SET_DEST (set), 0)))))\n+\t\t\t  && rtx_equal_p (XEXP (note, 0), inner_dest))\n \t\t\t{\n \t\t\t  /* Move the notes and links of TEM elsewhere.\n \t\t\t     This might delete other dead insns recursively. \n@@ -11484,6 +11523,20 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t\t  NOTE_LINE_NUMBER (tem) = NOTE_INSN_DELETED;\n \t\t\t  NOTE_SOURCE_FILE (tem) = 0;\n \t\t\t}\n+\t\t      /* If the register is both set and used here, put the\n+\t\t\t REG_DEAD note here, but place a REG_UNUSED note\n+\t\t\t here too unless there already is one.  */\n+\t\t      else if (reg_referenced_p (XEXP (note, 0),\n+\t\t\t\t\t\t PATTERN (tem)))\n+\t\t\t{\n+\t\t\t  place = tem;\n+\n+\t\t\t  if (! find_regno_note (tem, REG_UNUSED,\n+\t\t\t\t\t\t REGNO (XEXP (note, 0))))\n+\t\t\t    REG_NOTES (tem)\n+\t\t\t      = gen_rtx (EXPR_LIST, REG_UNUSED, XEXP (note, 0),\n+\t\t\t\t\t REG_NOTES (tem));\n+\t\t\t}\n \t\t      else\n \t\t\t{\n \t\t\t  PUT_REG_NOTE_KIND (note, REG_UNUSED);\n@@ -11540,13 +11593,12 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t    }\n \n \t  /* If the register is set or already dead at PLACE, we needn't do\n-\t     anything with this note if it is still a REG_DEAD note.  \n+\t     anything with this note if it is still a REG_DEAD note.\n+\t     We can here if it is set at all, not if is it totally replace,\n+\t     which is what `dead_or_set_p' checks, so also check for it being\n+\t     set partially.  */\n+\n \n-\t     Note that we cannot use just `dead_or_set_p' here since we can\n-\t     convert an assignment to a register into a bit-field assignment.\n-\t     Therefore, we must also omit the note if the register is the \n-\t     target of a bitfield assignment.  */\n-\t     \n \t  if (place && REG_NOTE_KIND (note) == REG_DEAD)\n \t    {\n \t      int regno = REGNO (XEXP (note, 0));"}, {"sha": "8dc98e6e15f3281354f4ef8c7b9fb1813da16818", "filename": "gcc/config.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -41,7 +41,7 @@\n /* Whether atol must be declared even if <stdlib.h> is included.  */\n #undef NEED_DECLARATION_ATOL\n \n-/* Whether sbrk must be declared even if <unistd.h> is included.  */\n+/* Whether sbrk must be declared even if <stdlib.h> is included.  */\n #undef NEED_DECLARATION_SBRK\n \n /* Whether abort must be declared even if <stdlib.h> is included.  */\n@@ -101,6 +101,9 @@\n /* Define if you have the strtoul function.  */\n #undef HAVE_STRTOUL\n \n+/* Define if you have the sysconf function.  */\n+#undef HAVE_SYSCONF\n+\n /* Define if you have the vprintf function.  */\n #undef HAVE_VPRINTF\n "}, {"sha": "b491c9f5ce0539717619aa2709e50c174dd23afe", "filename": "gcc/config.sub", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig.sub", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig.sub", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.sub?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,6 +1,6 @@\n #! /bin/sh\n # Configuration validation subroutine script, version 1.1.\n-#   Copyright (C) 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n+#   Copyright (C) 1991, 92-97, 1998 Free Software Foundation, Inc.\n # This file is (in principle) common to ALL GNU software.\n # The presence of a machine in this file suggests that SOME GNU software\n # can handle that machine.  It does not imply ALL GNU software can.\n@@ -165,7 +165,7 @@ case $basic_machine in\n \t# We use `pc' rather than `unknown'\n \t# because (1) that's what they normally are, and\n \t# (2) the word \"unknown\" tends to confuse beginning users.\n-\ti[3456]86)\n+\ti[34567]86)\n \t  basic_machine=$basic_machine-pc\n \t  ;;\n \t# Object if more than one company name word.\n@@ -174,7 +174,7 @@ case $basic_machine in\n \t\texit 1\n \t\t;;\n \t# Recognize the basic CPU types with company name.\n-\tvax-* | tahoe-* | i[3456]86-* | i860-* | m32r-* | m68k-* | m68000-* \\\n+\tvax-* | tahoe-* | i[34567]86-* | i860-* | m32r-* | m68k-* | m68000-* \\\n \t      | m88k-* | sparc-* | ns32k-* | fx80-* | arc-* | arm-* | c[123]* \\\n \t      | mips-* | pyramid-* | tron-* | a29k-* | romp-* | rs6000-* \\\n \t      | power-* | none-* | 580-* | cray2-* | h8300-* | i960-* \\\n@@ -368,19 +368,19 @@ case $basic_machine in\n \t\tos=-mvs\n \t\t;;\n # I'm not sure what \"Sysv32\" means.  Should this be sysv3.2?\n-\ti[3456]86v32)\n+\ti[34567]86v32)\n \t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n \t\tos=-sysv32\n \t\t;;\n-\ti[3456]86v4*)\n+\ti[34567]86v4*)\n \t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n \t\tos=-sysv4\n \t\t;;\n-\ti[3456]86v)\n+\ti[34567]86v)\n \t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n \t\tos=-sysv\n \t\t;;\n-\ti[3456]86sol2)\n+\ti[34567]86sol2)\n \t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n \t\tos=-solaris2\n \t\t;;\n@@ -487,25 +487,23 @@ case $basic_machine in\n         pc532 | pc532-*)\n \t\tbasic_machine=ns32k-pc532\n \t\t;;\n-\tpentium | p5)\n-\t\tbasic_machine=i586-intel\n+\tpentium | p5 | k5 | nexen)\n+\t\tbasic_machine=i586-pc\n \t\t;;\n-\tpentiumpro | p6)\n-\t\tbasic_machine=i686-intel\n+\tpentiumpro | p6 | k6 | 6x86)\n+\t\tbasic_machine=i686-pc\n \t\t;;\n-\tpentium-* | p5-*)\n+\tpentiumii | pentium2)\n+\t\tbasic_machine=i786-pc\n+\t\t;;\n+\tpentium-* | p5-* | k5-* | nexen-*)\n \t\tbasic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`\n \t\t;;\n-\tpentiumpro-* | p6-*)\n+\tpentiumpro-* | p6-* | k6-* | 6x86-*)\n \t\tbasic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`\n \t\t;;\n-\tk5)\n-\t\t# We don't have specific support for AMD's K5 yet, so just call it a Pentium\n-\t\tbasic_machine=i586-amd\n-\t\t;;\n-\tnexen)\n-\t\t# We don't have specific support for Nexgen yet, so just call it a Pentium\n-\t\tbasic_machine=i586-nexgen\n+\tpentiumii-* | pentium2-*)\n+\t\tbasic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`\n \t\t;;\n \tpn)\n \t\tbasic_machine=pn-gould"}, {"sha": "d28847c44d937d711f1526f51d7c45700698c38b", "filename": "gcc/config/alpha/elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Falpha%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Falpha%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Felf.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for DEC Alpha w/ELF.\n-   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n    Contributed by Richard Henderson (rth@tamu.edu).\n \n This file is part of GNU CC."}, {"sha": "e8d5f8453f4124b40b0443de94d57fc93ad439ff", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Output routines for GCC for ARM/RISCiX.\n-   Copyright (C) 1991, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.\n    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n    and Martin Simmons (@harleqn.co.uk).\n    More major hacks by Richard Earnshaw (rwe11@cl.cam.ac.uk)\n@@ -3271,6 +3271,16 @@ arm_reload_in_hi (operands)\n   rtx base = find_replacement (&XEXP (operands[1], 0));\n \n   emit_insn (gen_zero_extendqisi2 (operands[2], gen_rtx (MEM, QImode, base)));\n+  /* Handle the case where the address is too complex to be offset by 1.  */\n+  if (GET_CODE (base) == MINUS\n+      || (GET_CODE (base) == PLUS && GET_CODE (XEXP (base, 1)) != CONST_INT))\n+    {\n+      rtx base_plus = gen_rtx (REG, SImode, REGNO (operands[0]));\n+\n+      emit_insn (gen_rtx (SET, VOIDmode, base_plus, base));\n+      base = base_plus;\n+    }\n+\n   emit_insn (gen_zero_extendqisi2 (gen_rtx (SUBREG, SImode, operands[0], 0),\n \t\t\t\t   gen_rtx (MEM, QImode, \n \t\t\t\t\t    plus_constant (base, 1))));\n@@ -3524,6 +3534,7 @@ find_barrier (from, max_count)\n {\n   int count = 0;\n   rtx found_barrier = 0;\n+  rtx last = from;\n \n   while (from && count < max_count)\n     {\n@@ -3537,11 +3548,12 @@ find_barrier (from, max_count)\n \t  && CONSTANT_POOL_ADDRESS_P (SET_SRC (PATTERN (from))))\n \t{\n \t  rtx src = SET_SRC (PATTERN (from));\n-\t  count += 2;\n+\t  count += 8;\n \t}\n       else\n \tcount += get_attr_length (from);\n \n+      last = from;\n       from = NEXT_INSN (from);\n     }\n \n@@ -3552,7 +3564,7 @@ find_barrier (from, max_count)\n       rtx label = gen_label_rtx ();\n \n       if (from)\n-\tfrom = PREV_INSN (from);\n+\tfrom = PREV_INSN (last);\n       else\n \tfrom = get_last_insn ();\n "}, {"sha": "ee4a9086ed75618e4c908a75ea840f00022038c7", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for Advanced RISC Machines' ARM for GNU compiler\n-;;  Copyright (C) 1991, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n+;;  Copyright (C) 1991, 93-97, 1998 Free Software Foundation, Inc.\n ;;  Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n ;;  and Martin Simmons (@harleqn.co.uk).\n ;;  More major hacks by Richard Earnshaw (rwe11@cl.cam.ac.uk)"}, {"sha": "61c1c37c529bc2cff3ae38e77d16111e4570a730", "filename": "gcc/config/arm/t-semi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Farm%2Ft-semi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Farm%2Ft-semi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-semi?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,6 +1,6 @@\n # Just for these, we omit the frame pointer since it makes such a big\n # difference.  It is then pointless adding debugging.\n-LIBGCC2_CFLAGS=-O2 -fomit-frame-pointer $(LIBGCC2_INCLUDES) $(GCC_CFLAGS) -g0 \n+LIBGCC2_CFLAGS=-O2 -fomit-frame-pointer $(LIBGCC2_INCLUDES) $(GCC_CFLAGS) -g0\n \n # Don't build enquire\n ENQUIRE="}, {"sha": "15963bdb2993a3e9c981ef62f5ac4004476e6813", "filename": "gcc/config/i386/cygwin32.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fcygwin32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fcygwin32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygwin32.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -21,7 +21,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA. */\n \n-\n #define YES_UNDERSCORES\n \n #define DBX_DEBUGGING_INFO \n@@ -150,10 +149,9 @@ do\t\t\t\t\t\t\t\t\t\\\n while (0)\n #endif\n \n-/* This macro gets just the user-specified name\n-   out of the string in a SYMBOL_REF.  Discard\n-   trailing @[NUM] encoded by ENCODE_SECTION_INFO. \n-   Do we need the stripping of leading '*'?  */\n+/* This macro gets just the user-specified name out of the string in a\n+   SYMBOL_REF.  Discard trailing @[NUM] encoded by ENCODE_SECTION_INFO.   */\n+\n #undef  STRIP_NAME_ENCODING\n #define STRIP_NAME_ENCODING(VAR,SYMBOL_NAME)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n@@ -172,7 +170,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n     (VAR) = _name;\t\t\t\t\t\t\t\\\n } while (0)\n       \n-\n /* Emit code to check the stack when allocating more that 4000\n    bytes in one go. */\n "}, {"sha": "971a5f880c2749fb588fb9dc15dc770cb061a747", "filename": "gcc/config/i386/gnu.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fgnu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fgnu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgnu.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -4,7 +4,8 @@\n #include <i386/linux.h>\n \n #undef CPP_PREDEFINES\n-#define CPP_PREDEFINES GNU_CPP_PREDEFINES(\"i386\")\n+#define CPP_PREDEFINES \"-Di386 -Acpu(i386) -Amachine(i386) \\\n+-Dunix -Asystem(unix)  -DMACH -Asystem(mach) -D__GNU__ -Asystem(gnu)\"\n \n #undef TARGET_VERSION\n #define TARGET_VERSION fprintf (stderr, \" (i386 GNU)\");"}, {"sha": "adab26d549ceb39c8f28680652fd6dac176b607b", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler for Intel X86\n    (386, 486, Pentium).\n-   Copyright (C) 1988, 92, 94-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 92, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -436,12 +436,6 @@ extern int ix86_arch;\n /* Required on the 386 since it doesn't have bitfield insns.  */\n #define PCC_BITFIELD_TYPE_MATTERS 1\n \n-/* An integer expression for the size in bits of the largest integer\n-   machine mode that should actually be used.  All integer machine modes of\n-   this size or smaller can be used for structures and unions with the\n-   appropriate sizes.  */\n-#define MAX_FIXED_MODE_SIZE 32\n-\n /* Maximum power of 2 that code can be aligned to.  */\n #define MAX_CODE_ALIGN\t6\t\t\t/* 64 byte alignment */\n \n@@ -1870,6 +1864,7 @@ while (0)\n \n #define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n   case CONST_INT:\t\t\t\t\t\t\\\n+    return (unsigned) INTVAL (RTX) < 256 ? 0 : 1;\t\t\\\n   case CONST:\t\t\t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\t\t\\\n   case SYMBOL_REF:\t\t\t\t\t\t\\"}, {"sha": "ea6a9c8a48758cfb78e5f2fcdee64d29512ceced", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 75, "deletions": 269, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n ; GCC machine description for Intel X86.\n-;; Copyright (C) 1988, 94-97, 1998 Free Software Foundation, Inc.\n+;; Copyright (C) 1988, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.\n ;; Mostly by William Schelter.\n \n ;; This file is part of GNU CC.\n@@ -7378,11 +7378,10 @@ byte_xor_operation:\n \n (define_expand \"movsicc\"\n   [(match_dup 4)\n-   (parallel [(set (match_operand 0 \"register_operand\" \"\")\n+   (set (match_operand 0 \"register_operand\" \"\")\n \t(if_then_else:SI (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"\")))\n-   (clobber (match_scratch:SI 4 \"=&r\"))])]\n+\t\t\t (match_operand:SI 2 \"nonimmediate_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_CMOVE\"\n   \"\n {\n@@ -7391,370 +7390,177 @@ byte_xor_operation:\n \n (define_expand \"movhicc\"\n   [(match_dup 4)\n-   (parallel [(set (match_operand 0 \"register_operand\" \"\")\n+   (set (match_operand 0 \"register_operand\" \"\")\n \t(if_then_else:HI (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:HI 2 \"general_operand\" \"\")\n-\t\t\t (match_operand:HI 3 \"general_operand\" \"\")))\n-   (clobber (match_scratch:SI 4 \"=&r\"))])]\n+\t\t\t (match_operand:HI 2 \"nonimmediate_operand\" \"\")\n+\t\t\t (match_operand:HI 3 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_CMOVE\"\n   \"\n {\n   operands[4] = i386_compare_gen (i386_compare_op0, i386_compare_op1);\n }\")\n \n (define_insn \"movsicc_1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,&r,rm\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,&r\")\n \t(if_then_else:SI (match_operator 1 \"comparison_operator\" \n-\t\t\t\t[(cc0) (const_int 0)])\n-\t\t      (match_operand:SI 2 \"general_operand\" \"rm,0,rm,g\")\n-\t\t      (match_operand:SI 3 \"general_operand\" \"0,rm,rm,g\")))\n-   (clobber (match_scratch:SI 4 \"X,X,X,=&r\"))]\n+\t\t\t\t\t [(cc0) (const_int 0)])\n+\t\t\t (match_operand:SI 2 \"nonimmediate_operand\" \"rm,0,rm\")\n+\t\t\t (match_operand:SI 3 \"nonimmediate_operand\" \"0,rm,rm\")))]\n   \"TARGET_CMOVE\"\n   \"*\n {\n-  if (which_alternative == 0)\n+  switch (which_alternative)\n     {\n+    case 0:\n       /* r <- cond ? arg : r */\n       output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n-    }\n-  else if (which_alternative == 1)\n-    {\n+      break;\n+\n+    case 1:\n       /* r <- cond ? r : arg */\n       output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n-    }\n-  else if (which_alternative == 2)\n-    {\n+      break;\n+\n+    case 2:\n       /* r <- cond ? arg1 : arg2 */\n       output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n       output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n+      break;\n     }\n-  else if (which_alternative == 3)\n-    {\n-      /* r <- cond ? arg1 : arg2 */\n-    rtx xops[3];\n-\n-    xops[0] = gen_label_rtx ();\n-    xops[1] = gen_label_rtx ();\n-    xops[2] = operands[1];\n-\n-    output_asm_insn (\\\"j%c2 %l0\\\", xops);\n-    if (! rtx_equal_p (operands[0], operands[2]))\n-       if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[2]) == MEM)\n-         {\n-           output_asm_insn (AS2 (mov%z2,%2,%4), operands);\n-           output_asm_insn (AS2 (mov%z2,%4,%0), operands);\n-         }\n-       else\n-      output_asm_insn (AS2 (mov%z0,%2,%0), operands);\n-    output_asm_insn (\\\"jmp %l1\\\", xops);\n-    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[0]));\n-    if (! rtx_equal_p (operands[0], operands[3]))\n-      {\n-        if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[3]) == MEM)\n-          {\n-            output_asm_insn (AS2 (mov%z3,%3,%4), operands);\n-            output_asm_insn (AS2 (mov%z3,%4,%0), operands);\n-          }\n-        else\n-      output_asm_insn (AS2 (mov%z0,%3,%0), operands);\n-      }\n-    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[1]));\n-    }  \n+\n   RET;\n }\")\n \n (define_insn \"movhicc_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,&r,rm\")\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,&r\")\n \t(if_then_else:HI (match_operator 1 \"comparison_operator\" \n-\t\t\t\t[(cc0) (const_int 0)])\n-\t\t      (match_operand:HI 2 \"general_operand\" \"rm,0,rm,g\")\n-\t\t      (match_operand:HI 3 \"general_operand\" \"0,rm,rm,g\")))\n-   (clobber (match_scratch:SI 4 \"X,X,X,=&r\"))]\n+\t\t\t\t\t [(cc0) (const_int 0)])\n+\t\t\t (match_operand:HI 2 \"nonimmediate_operand\" \"rm,0,rm\")\n+\t\t\t (match_operand:HI 3 \"nonimmediate_operand\" \"0,rm,rm\")))]\n   \"TARGET_CMOVE\"\n   \"*\n {\n-  if (which_alternative == 0)\n+  switch (which_alternative)\n     {\n+    case 0:\n       /* r <- cond ? arg : r */\n       output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n-    }\n-  else if (which_alternative == 1)\n-    {\n+      break;\n+\n+    case 1:\n       /* r <- cond ? r : arg */\n       output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n-    }\n-  else if (which_alternative == 2)\n-    {\n+      break;\n+\n+    case 2:\n       /* r <- cond ? arg1 : arg2 */\n       output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n       output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n+      break;\n     }\n-  else if (which_alternative == 3)\n-    {\n-      /* r <- cond ? arg1 : arg2 */\n-    rtx xops[3];\n-\n-    xops[0] = gen_label_rtx ();\n-    xops[1] = gen_label_rtx ();\n-    xops[2] = operands[1];\n-\n-    output_asm_insn (\\\"j%c2 %l0\\\", xops);\n-    if (! rtx_equal_p (operands[0], operands[2]))\n-       if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[2]) == MEM)\n-         {\n-           output_asm_insn (AS2 (mov%z2,%2,%4), operands);\n-           output_asm_insn (AS2 (mov%z2,%4,%0), operands);\n-         }\n-       else\n-      output_asm_insn (AS2 (mov%z0,%2,%0), operands);\n-    output_asm_insn (\\\"jmp %l1\\\", xops);\n-    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[0]));\n-    if (! rtx_equal_p (operands[0], operands[3]))\n-      {\n-        if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[3]) == MEM)\n-          {\n-            output_asm_insn (AS2 (mov%z3,%3,%4), operands);\n-            output_asm_insn (AS2 (mov%z3,%4,%0), operands);\n-          }\n-        else\n-      output_asm_insn (AS2 (mov%z0,%3,%0), operands);\n-      }\n-    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[1]));\n-    }  \n+\n   RET;\n }\")\n \n+;; We need to disable the FP forms of these since they do not support\n+;; memory as written, but no input reloads are permitted for insns\n+;; that use cc0.  Also, movxfcc is not present.\n+\n (define_expand \"movsfcc\"\n   [(match_dup 4)\n-   (set (match_operand 0 \"general_operand\" \"\")\n+   (set (match_operand 0 \"register_operand\" \"\")\n \t(if_then_else:SF (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:SF 2 \"general_operand\" \"\")\n-\t\t\t (match_operand:SF 3 \"general_operand\" \"\")))]\n-  \"TARGET_CMOVE\"\n+\t\t\t (match_operand:SF 2 \"register_operand\" \"\")\n+\t\t\t (match_operand:SF 3 \"register_operand\" \"\")))]\n+  \"0 && TARGET_CMOVE\"\n   \"\n {\n-  int i;\n-  \n-  for (i = 2; i <= 3; i++)\n-   {\n-     if ((reload_in_progress | reload_completed) == 0\n-       && CONSTANT_P (operands[i]))\n-       {\n-         operands[i] = force_const_mem (SFmode, operands[i]);\n-       }\n-     }\n   operands[4] = i386_compare_gen (i386_compare_op0, i386_compare_op1);\n }\")\n \n (define_expand \"movdfcc\"\n   [(match_dup 4)\n    (set (match_operand 0 \"register_operand\" \"t\")\n \t(if_then_else:DF (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:DF 2 \"general_operand\" \"\")\n-\t\t\t (match_operand:DF 3 \"general_operand\" \"\")))]\n-  \"TARGET_CMOVE\"\n+\t\t\t (match_operand:DF 2 \"register_operand\" \"\")\n+\t\t\t (match_operand:DF 3 \"register_operand\" \"\")))]\n+  \"0 && TARGET_CMOVE\"\n   \"\n {\n-  int i;\n-  \n-  for (i = 2; i <= 3; i++)\n-   {\n-     if ((reload_in_progress | reload_completed) == 0\n-       && CONSTANT_P (operands[i]))\n-       {\n-         operands[i] = force_const_mem (DFmode, operands[i]);\n-       }\n-     }\n   operands[4] = i386_compare_gen (i386_compare_op0, i386_compare_op1);\n }\")\n \n (define_expand \"movxfcc\"\n   [(match_dup 4)\n-   (set (match_operand 0 \"register_operand\" \"t\")\n+   (set (match_operand 0 \"register_operand\" \"\")\n \t(if_then_else:XF (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:XF 2 \"general_operand\" \"\")\n-\t\t\t (match_operand:XF 3 \"general_operand\" \"\")))]\n-  \"TARGET_CMOVE\"\n+\t\t\t (match_operand:XF 2 \"register_operand\" \"\")\n+\t\t\t (match_operand:XF 3 \"register_operand\" \"\")))]\n+  \"0 && TARGET_CMOVE\"\n   \"\n {\n-  int i;\n-  \n-  for (i = 2; i <= 3; i++)\n-   {\n-     if ((reload_in_progress | reload_completed) == 0\n-       && CONSTANT_P (operands[i]))\n-       {\n-         operands[i] = force_const_mem (XFmode, operands[i]);\n-       }\n-     }\n   operands[4] = i386_compare_gen (i386_compare_op0, i386_compare_op1);\n }\")\n \n (define_insn \"movsfcc_1\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=f,=f,=f,=f\")\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f,f,&f\")\n \t(if_then_else:SF (match_operator 1 \"comparison_operator\" \n-\t\t\t\t[(cc0) (const_int 0)])\n-\t\t      (match_operand:SF 2 \"general_operand\" \"0,f,f,fFm\")\n-\t\t      (match_operand:SF 3 \"general_operand\" \"f,0,f,fFm\")))]\n+\t\t\t\t\t [(cc0) (const_int 0)])\n+\t\t\t (match_operand:SF 2 \"register_operand\" \"0,f,f\")\n+\t\t\t (match_operand:SF 3 \"register_operand\" \"f,0,f\")))]\n   \"TARGET_CMOVE\"\n   \"*\n {\n-  if (which_alternative == 0)\n+  switch (which_alternative)\n     {\n+    case 0:\n       /* r <- cond ? arg : r */\n       output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n-    }\n-  else if (which_alternative == 1)\n-    {\n+      break;\n+\n+    case 1:\n       /* r <- cond ? r : arg */\n       output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n-    }\n-  else if (which_alternative == 2)\n-    {\n+      break;\n+\n+    case 2:\n       /* r <- cond ? r : arg */\n       output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n       output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n+      break;\n     }\n-  else if (which_alternative == 3)\n-    {\n-      /* r <- cond ? arg1 : arg2 */\n-      rtx xops[3];\n-\n-      xops[0] = gen_label_rtx ();\n-      xops[1] = gen_label_rtx ();\n-      xops[2] = operands[1];\n \n-      output_asm_insn (\\\"j%f2 %l0\\\", xops);\n-      if (STACK_REG_P (operands[2]) || GET_CODE (operands[2]) == MEM)\n-\toutput_asm_insn (AS1 (fld%z2,%y2), operands);\n-      else\n-        {\n-\t  operands[2] = XEXP (operands[2], 0);\n-\t  output_asm_insn (AS1 (fld%z2,%y2), operands);\n-        }\n-      output_asm_insn (\\\"jmp %l1\\\", xops);\n-      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[0]));\n-      if (STACK_REG_P (operands[3]) || GET_CODE (operands[0]) == MEM)\n-\t  output_asm_insn (AS1 (fld%z3,%y3), operands);\n-      else\n-\t{\n-\t  operands[3] = XEXP (operands[3], 0);\n-\t  output_asm_insn (AS1 (fld%z3,%y3), operands);\n-\t}\n-      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[1]));\n-}\n   RET;\n }\")\n \n (define_insn \"movdfcc_1\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=f,=f,=f,=f\")\n+  [(set (match_operand:DF 0 \"general_operand\" \"=f,f,&f\")\n \t(if_then_else:DF (match_operator 1 \"comparison_operator\" \n-\t\t\t\t[(cc0) (const_int 0)])\n-\t\t      (match_operand:DF 2 \"general_operand\" \"0,f,f,fFm\")\n-\t\t      (match_operand:DF 3 \"general_operand\" \"f,0,f,fFm\")))]\n+\t\t\t\t\t [(cc0) (const_int 0)])\n+\t\t\t (match_operand:DF 2 \"register_operand\" \"0,f,f\")\n+\t\t\t (match_operand:DF 3 \"register_operand\" \"f,0,f\")))]\n   \"TARGET_CMOVE\"\n   \"*\n {\n-  if (which_alternative == 0)\n+  switch (which_alternative)\n     {\n+    case 0:\n       /* r <- cond ? arg : r */\n       output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n-    }\n-  else if (which_alternative == 1)\n-    {\n-      /* r <- cond ? r : arg */\n-      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n-    }\n-  else if (which_alternative == 2)\n-    {\n-      /* r <- cond ? r : arg */\n-      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n-      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n-    }\n-  else if (which_alternative == 3)\n-    {\n-      /* r <- cond ? arg1 : arg2 */\n-      rtx xops[3];\n-\n-      xops[0] = gen_label_rtx ();\n-      xops[1] = gen_label_rtx ();\n-      xops[2] = operands[1];\n-\n-      output_asm_insn (\\\"j%f2 %l0\\\", xops);\n-      if (STACK_REG_P (operands[2]) || GET_CODE (operands[2]) == MEM)\n-\toutput_asm_insn (AS1 (fld%z2,%y2), operands);\n-      else\n-        {\n-\t  operands[2] = XEXP (operands[2], 0);\n-\t  output_asm_insn (AS1 (fld%z2,%y2), operands);\n-        }\n-      output_asm_insn (\\\"jmp %l1\\\", xops);\n-      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[0]));\n-      if (STACK_REG_P (operands[3]) || GET_CODE (operands[0]) == MEM)\n-\t  output_asm_insn (AS1 (fld%z3,%y3), operands);\n-      else\n-\t{\n-\t  operands[3] = XEXP (operands[3], 0);\n-\t  output_asm_insn (AS1 (fld%z3,%y3), operands);\n-\t}\n-      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[1]));\n-}\n-  RET;\n-}\")\n+      break;\n \n-(define_insn \"movxfcc_1\"\n-  [(set (match_operand:XF 0 \"register_operand\" \"=f,=f,=f,=f\")\n-\t(if_then_else:XF (match_operator 1 \"comparison_operator\" \n-\t\t\t\t[(cc0) (const_int 0)])\n-\t\t      (match_operand:XF 2 \"register_operand\" \"0,f,f,fFm\")\n-\t\t      (match_operand:XF 3 \"register_operand\" \"f,0,f,fFm\")))]\n-  \"TARGET_CMOVE\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    {\n-      /* r <- cond ? arg : r */\n-      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n-    }\n-  else if (which_alternative == 1)\n-    {\n+    case 1:\n       /* r <- cond ? r : arg */\n       output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n-    }\n-  else if (which_alternative == 2)\n-    {\n+      break;\n+\n+    case 2:\n       /* r <- cond ? r : arg */\n       output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n       output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n+      break;\n     }\n-  else if (which_alternative == 3)\n-    {\n-      /* r <- cond ? arg1 : arg2 */\n-      rtx xops[3];\n-\n-      xops[0] = gen_label_rtx ();\n-      xops[1] = gen_label_rtx ();\n-      xops[2] = operands[1];\n \n-      output_asm_insn (\\\"j%f2 %l0\\\", xops);\n-      if (STACK_REG_P (operands[2]) || GET_CODE (operands[2]) == MEM)\n-\toutput_asm_insn (AS1 (fld%z2,%y2), operands);\n-      else\n-        {\n-\t  operands[2] = XEXP (operands[2], 0);\n-\t  output_asm_insn (AS1 (fld%z2,%y2), operands);\n-        }\n-      output_asm_insn (\\\"jmp %l1\\\", xops);\n-      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[0]));\n-      if (STACK_REG_P (operands[3]) || GET_CODE (operands[0]) == MEM)\n-\t  output_asm_insn (AS1 (fld%z3,%y3), operands);\n-      else\n-\t{\n-\t  operands[3] = XEXP (operands[3], 0);\n-\t  output_asm_insn (AS1 (fld%z3,%y3), operands);\n-\t}\n-      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[1]));\n-}\n   RET;\n }\")\n "}, {"sha": "7c7a3bbc6faa3e30772c838d2b7eb074056b4b30", "filename": "gcc/config/i386/mingw32.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fmingw32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fmingw32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmingw32.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -2,7 +2,7 @@\n    hosting on Windows32, using GNU tools and the Windows32 API Library,\n    as distinct from winnt.h, which is used to build GCC for use with a\n    windows style library and tool set and uses the Microsoft tools.\n-   Copyright (C) 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -47,17 +47,17 @@ Boston, MA 02111-1307, USA. */\n \n /* Include in the mingw32 libraries with libgcc */\n #undef LIBGCC_SPEC\n-#define LIBGCC_SPEC \"-lmingw32 -lgcc -lmoldname -lcrtdll\"\n+#define LIBGCC_SPEC \"-lmingw32 -lgcc -lmoldname -lmsvcrt\"\n \n /* Specify a different entry point when linking a DLL */\n #undef LINK_SPEC\n #define LINK_SPEC \\\n \"%{mwindows:--subsystem windows} %{mdll:--dll -e _DllMainCRTStartup@12}\"\n \n #undef STARTFILE_SPEC\n-#define STARTFILE_SPEC \"%{mdll:dllcrt1%O%s} %{!mdll:crt1%O%s}\"\n+#define STARTFILE_SPEC \"%{mdll:dllcrt2%O%s} %{!mdll:crt2%O%s}\"\n \n-#define MATH_LIBRARY \"-lcrtdll\"\n+#define MATH_LIBRARY \"-lmsvcrt\"\n \n /* Output STRING, a string representing a filename, to FILE.  We canonicalize\n    it to be in MS-DOS format.  */"}, {"sha": "3cfd6b399926a917375265a341dfeeea2cf2086b", "filename": "gcc/config/i386/xm-go32.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fxm-go32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fxm-go32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxm-go32.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Configuration for GNU C-compiler for Intel 80386 running GO32.\n-   Copyright (C) 1988, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1996, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -33,4 +33,3 @@ Boston, MA 02111-1307, USA.  */\n #define DIR_SEPARATOR '\\\\'\n \n #define NO_SYS_SIGLIST 1\n-"}, {"sha": "38c9b6d06b061e26986d6012507c15bd796a321d", "filename": "gcc/config/i386/xm-mingw32.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fxm-mingw32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fxm-mingw32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxm-mingw32.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,6 +1,6 @@\n /* Configuration for GNU C-compiler for hosting on Windows32.\n    using GNU tools and the Windows32 API Library.\n-   Copyright (C) 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -34,7 +34,6 @@ Boston, MA 02111-1307, USA. */\n #endif\n \n #define NO_SYS_SIGLIST 1\n-#define link(a,b) -1\n #define environ _environ\n \n /* Even though we support \"/\", allow \"\\\" since everybody tests both.  */"}, {"sha": "6b22b1d549fd5230516a83e567523988c9b342d0", "filename": "gcc/config/i386/xm-sco5.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fxm-sco5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fxm-sco5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxm-sco5.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,18 +1,7 @@\n /* Configuration for GCC for Intel i386 running SCO.  */\n \n-#include \"i386/xm-sysv3.h\"\n-\n /* Big buffers improve performance.  */\n \n #define IO_BUFFER_SIZE (0x8000 - 1024)\n-/* OpenServer provides no sys_siglist,\n-   but does offer the same data under another name.  */\n-#define sys_siglist _sys_siglist\n-#undef SYS_SIGLIST_DECLARED\n-#define SYS_SIGLIST_DECLARED\n \n-/* If not compiled with GNU C, use the portable alloca.  */\n-#ifndef __GNUC__\n-#define USE_C_ALLOCA\n-#endif\n "}, {"sha": "1365064a5a64caa884878d63e49c8813ef2cbc34", "filename": "gcc/config/i386/xm-sysv4.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fxm-sysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi386%2Fxm-sysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxm-sysv4.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,16 +1,5 @@\n /* Configuration for GCC for Intel i386 running System V Release 4.  */\n \n-#include \"i386/xm-i386.h\"\n-#include \"xm-svr4.h\"\n-\n-/* If not compiled with GNU C, use the portable alloca.  */\n-#ifndef __GNUC__\n-#define USE_C_ALLOCA\n-#endif\n #ifdef __HIGHC__\n #include <alloca.h>\t\t/* for MetaWare High-C on NCR System 3000 */\n #endif\n-\n-/* Univel, at least, has a small ARG_MAX.  Defining this is harmless\n-   except for causing extra stat calls in the driver program.  */\n-#define SMALL_ARG_MAX"}, {"sha": "31dd07e07a4574a334588c2cbc6edc3622b0b86e", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Intel 860\n-   Copyright (C) 1989, 1991, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 1991, 1997, 1998 Free Software Foundation, Inc.\n    Derived from sparc.c.\n \n    Written by Richard Stallman (rms@ai.mit.edu).\n@@ -1435,7 +1435,8 @@ output_delayed_branch (template, operands, insn)\n       /* Now recognize the insn which we put in its delay slot.\n \t We must do this after outputting the branch insn,\n \t since operands may just be a pointer to `recog_operand'.  */\n-      INSN_CODE (delay_insn) = insn_code_number = recog (pat, delay_insn);\n+      INSN_CODE (delay_insn) = insn_code_number\n+\t= recog (pat, delay_insn, NULL_PTR);\n       if (insn_code_number == -1)\n \tabort ();\n \n@@ -1489,7 +1490,7 @@ output_delay_insn (delay_insn)\n     }\n \n #ifdef REGISTER_CONSTRAINTS\n-  if (! constrain_operands (insn_code_number))\n+  if (! constrain_operands (insn_code_number, 1))\n     abort ();\n #endif\n "}, {"sha": "11b2a21f9be29c27ff9ff69673c4bc678077c5ca", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on intel 80960.\n-   Copyright (C) 1992, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n    Contributed by Steven McGeady, Intel Corp.\n    Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n    Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n@@ -589,8 +589,13 @@ emit_move_sequence (operands, mode)\n      adding 4 to the memory address may not yield a valid insn.  */\n   /* ??? We don't always need the scratch, but that would complicate things.\n      Maybe later.  */\n+  /* ??? We must also handle stores to pseudos here, because the pseudo may be\n+     replaced with a MEM later.  This would be cleaner if we didn't have\n+     a separate pattern for unaligned DImode/TImode stores.  */\n   if (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n-      && GET_CODE (operands[0]) == MEM\n+      && (GET_CODE (operands[0]) == MEM\n+\t  || (GET_CODE (operands[0]) == REG\n+\t      && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))\n       && GET_CODE (operands[1]) == REG\n       && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n       && ! HARD_REGNO_MODE_OK (REGNO (operands[1]), mode))"}, {"sha": "43cb7ba5bee55080be4e37933153639e0f05bbf6", "filename": "gcc/config/i960/i960.md", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi960%2Fi960.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fi960%2Fi960.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.md?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for Intel 80960 chip for GNU C compiler\n-;;   Copyright (C) 1992, 1995 Free Software Foundation, Inc.\n+;;   Copyright (C) 1992, 1995, 1998 Free Software Foundation, Inc.\n ;;   Contributed by Steven McGeady, Intel Corp.\n ;;   Additional work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n ;;   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n@@ -867,17 +867,20 @@\n   [(set_attr \"type\" \"move,move,load,load,store\")])\n \n (define_insn \"*store_unaligned_di_reg\"\n-  [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n-\t(match_operand:DI 1 \"register_operand\" \"d\"))\n-   (clobber (match_scratch:SI 2 \"=&d\"))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d,m\")\n+\t(match_operand:DI 1 \"register_operand\" \"d,d\"))\n+   (clobber (match_scratch:SI 2 \"=X,&d\"))]\n   \"\"\n   \"*\n {\n+  if (which_alternative == 0)\n+    return i960_output_move_double (operands[0], operands[1]);\n+    \n   operands[3] = gen_rtx (MEM, word_mode, operands[2]);\n   operands[4] = adj_offsettable_operand (operands[3], UNITS_PER_WORD);\n   return \\\"lda\t%0,%2\\;st\t%1,%3\\;st\t%D1,%4\\\";\n }\"\n-  [(set_attr \"type\" \"store\")])\n+  [(set_attr \"type\" \"move,store\")])\n \n (define_expand \"movti\"\n   [(set (match_operand:TI 0 \"general_operand\" \"\")\n@@ -946,19 +949,22 @@\n   [(set_attr \"type\" \"move,move,load,load,store\")])\n \n (define_insn \"*store_unaligned_ti_reg\"\n-  [(set (match_operand:TI 0 \"memory_operand\" \"=m\")\n-\t(match_operand:TI 1 \"register_operand\" \"d\"))\n-   (clobber (match_scratch:SI 2 \"=&d\"))]\n+  [(set (match_operand:TI 0 \"general_operand\" \"=d,m\")\n+\t(match_operand:TI 1 \"register_operand\" \"d,d\"))\n+   (clobber (match_scratch:SI 2 \"=X,&d\"))]\n   \"\"\n   \"*\n {\n+  if (which_alternative == 0)\n+    return i960_output_move_quad (operands[0], operands[1]);\n+\n   operands[3] = gen_rtx (MEM, word_mode, operands[2]);\n   operands[4] = adj_offsettable_operand (operands[3], UNITS_PER_WORD);\n   operands[5] = adj_offsettable_operand (operands[4], UNITS_PER_WORD);\n   operands[6] = adj_offsettable_operand (operands[5], UNITS_PER_WORD);\n   return \\\"lda\t%0,%2\\;st\t%1,%3\\;st\t%D1,%4\\;st\t%E1,%5\\;st\t%F1,%6\\\";\n }\"\n-  [(set_attr \"type\" \"store\")])\n+  [(set_attr \"type\" \"move,store\")])\n \n (define_expand \"store_multiple\"\n   [(set (match_operand:SI 0 \"\" \"\")\t;;- dest\n@@ -2209,7 +2215,13 @@\n   [(set (pc) (match_operand:SI 0 \"register_operand\" \"d\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n-  \"bx\t(%0)\"\n+  \"*\n+{\n+  if (flag_pic)\n+    return \\\"bx\t%l1(%0)\\\";\n+  else\n+    return \\\"bx\t(%0)\\\";\n+}\"\n   [(set_attr \"type\" \"branch\")])\n \n ;;- jump to subroutine"}, {"sha": "b619d01cdf5eada557bd736144774a27cdf2eeee", "filename": "gcc/config/linux.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flinux.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,7 +1,7 @@\n /* Definitions for Linux-based GNU systems with ELF format\n-   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n    Contributed by Eric Youngdale.\n-   Modified for stabs-in-ELF by H.J. Lu.\n+   Modified for stabs-in-ELF by H.J. Lu (hjl@lucon.org).\n \n This file is part of GNU CC.\n "}, {"sha": "90a65849c59299c5c4c81b37e949eb508ffa9b25", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  Sun 68000/68020 version.\n-   Copyright (C) 1987, 88, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 93-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "881b2886c8643cf6e8a801547943ee48d3059423", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for GNU compiler, Motorola 68000 Version\n-;;  Copyright (C) 1987, 88, 93, 94, 95, 96, 97, 98 Free Software Foundation, Inc.\n+;;  Copyright (C) 1987, 88, 93-97, 1998 Free Software Foundation, Inc.\n \n ;; This file is part of GNU CC.\n "}, {"sha": "ea3b5589dbe046b2f58caed2f1a31c4f5c5bbc5a", "filename": "gcc/config/m68k/xm-mot3300.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fm68k%2Fxm-mot3300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fm68k%2Fxm-mot3300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fxm-mot3300.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -22,13 +22,8 @@ Boston, MA 02111-1307, USA.  */\n \n #define USG 1\n \n-#include \"m68k/xm-m68k.h\"\n-\n-#define NO_SYS_SIGLIST\n-\n /* do not use alloca from -lPW with cc, because function epilogues use %sp */\n #ifndef __GNUC__\n-#define USE_C_ALLOCA\n #ifdef __STDC__\n extern void *alloca ();\n #else"}, {"sha": "84110d7474dad121b630fd1f884206be34306267", "filename": "gcc/config/m88k/xm-sysv3.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fm88k%2Fxm-sysv3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fm88k%2Fxm-sysv3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fxm-sysv3.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -19,8 +19,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#include \"m88k/xm-m88k.h\"\n-\n #define R_OK 4\n #define W_OK 2\n #define X_OK 1"}, {"sha": "188939497ceb5da172674b7d83efe84851b7a6c4", "filename": "gcc/config/mips/abi64.h", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmips%2Fabi64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmips%2Fabi64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fabi64.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  64 bit ABI support.\n-   Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1995, 1996, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -63,16 +63,10 @@ Boston, MA 02111-1307, USA.  */\n #define MAX_ARGS_IN_REGISTERS\t(mips_abi == ABI_32 ? 4 : 8)\n \n #undef REG_PARM_STACK_SPACE\n-#if 0\n-/* ??? This is necessary in order for the ABI_32 support to work.  However,\n-   expr.c (emit_push_insn) has no support for a REG_PARM_STACK_SPACE\n-   definition that returns zero.  That would have to be fixed before this\n-   can be enabled.  */\n #define REG_PARM_STACK_SPACE(FNDECL) \t\t\t\t\t \\\n   (mips_abi == ABI_32\t\t\t\t\t\t\t \\\n    ? (MAX_ARGS_IN_REGISTERS*UNITS_PER_WORD) - FIRST_PARM_OFFSET (FNDECL) \\\n    : 0)\n-#endif\n \n #define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n   (! BYTES_BIG_ENDIAN\t\t\t\t\t\t\t\\\n@@ -184,8 +178,7 @@ extern struct rtx_def *mips_function_value ();\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n-/* ??? Should disable for mips_abi == ABI32.  */\n-#define STRICT_ARGUMENT_NAMING\n+#define STRICT_ARGUMENT_NAMING (mips_abi != ABI_32)\n \n /* A C expression that indicates when an argument must be passed by\n    reference.  If nonzero for an argument, a copy of that argument is"}, {"sha": "8da0ae6351ec64f30411ff981af04bdf33877c99", "filename": "gcc/config/mips/ecoff.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmips%2Fecoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmips%2Fecoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fecoff.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler.  MIPS version with\n    GOFAST floating point library.\n-   Copyright (C) 1994, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "334bd5b836367a0911fafcb4cca45c90047b478c", "filename": "gcc/config/mips/elf.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmips%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmips%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Felf.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -29,6 +29,8 @@ Boston, MA 02111-1307, USA.  */\n #endif\n \n /* Mostly like ECOFF.  */\n+#include \"mips/mips.h\"\n+#include \"gofast.h\"\n #include \"mips/ecoff.h\"\n \n /* We need to use .esize and .etype instead of .size and .type to"}, {"sha": "f81fe1c0fdab47ed91e44e74e8d54ea53070ad7b", "filename": "gcc/config/mips/iris5.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmips%2Firis5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmips%2Firis5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firis5.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  Iris version 5.\n-   Copyright (C) 1993, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1995, 1996, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -23,6 +23,8 @@ Boston, MA 02111-1307, USA.  */\n #endif\n #define ABICALLS_ASM_OP \".option pic2\"\n \n+#include \"mips/iris3.h\"\n+#include \"mips/mips.h\"\n #include \"mips/iris4.h\"\n \n /* Irix 5 doesn't use COFF, so disable special COFF handling in collect2.c.  */"}, {"sha": "f1c2c483f88875e613df26420bec09818180b5f6", "filename": "gcc/config/mips/iris5gas.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmips%2Firis5gas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmips%2Firis5gas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firis5gas.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,7 +1,5 @@\n /* Definitions of target machine for GNU compiler.  Irix version 5 with gas. */\n \n-#include \"mips/iris5.h\"\n-\n /* Enable debugging.  */\n #define DBX_DEBUGGING_INFO\n #define SDB_DEBUGGING_INFO"}, {"sha": "e2f03f92c96fe1415e1172a94bfad2e2e5e0f02a", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -5036,7 +5036,7 @@ mips_output_external (file, decl, name)\n #ifdef ASM_OUTPUT_UNDEF_FUNCTION\n   if (TREE_CODE (decl) == FUNCTION_DECL\n       /* ??? Don't include alloca, since gcc will always expand it\n-\t inline.  If we don't do this, libg++ fails to build.  */\n+\t inline.  If we don't do this, the C++ library fails to build.  */\n       && strcmp (name, \"alloca\")\n       /* ??? Don't include __builtin_next_arg, because then gcc will not\n \t bootstrap under Irix 5.1.  */\n@@ -6616,7 +6616,8 @@ mips_expand_prologue ()\n \t}\n \n       if (TARGET_ABICALLS && mips_abi != ABI_32)\n-\temit_insn (gen_loadgp (XEXP (DECL_RTL (current_function_decl), 0)));\n+\temit_insn (gen_loadgp (XEXP (DECL_RTL (current_function_decl), 0),\n+\t\t\t       gen_rtx (REG, DImode, 25)));\n     }\n \n   /* If we are profiling, make sure no instructions are scheduled before"}, {"sha": "e6a750f812edbb97ff3fa780ca2dc5cd07d544b5", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -5639,10 +5639,11 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_insn \"loadgp\"\n   [(set (reg:DI 28)\n-\t(unspec_volatile:DI [(match_operand:DI 0 \"address_operand\" \"\")] 2))\n+\t(unspec_volatile:DI [(match_operand:DI 0 \"address_operand\" \"\")\n+\t\t\t     (match_operand:DI 1 \"register_operand\" \"\")] 2))\n    (clobber (reg:DI 1))]\n   \"\"\n-  \"%[lui\\\\t$1,%%hi(%%neg(%%gp_rel(%a0)))\\\\n\\\\taddiu\\\\t$1,$1,%%lo(%%neg(%%gp_rel(%a0)))\\\\n\\\\tdaddu\\\\t$gp,$1,$25%]\"\n+  \"%[lui\\\\t$1,%%hi(%%neg(%%gp_rel(%a0)))\\\\n\\\\taddiu\\\\t$1,$1,%%lo(%%neg(%%gp_rel(%a0)))\\\\n\\\\tdaddu\\\\t$gp,$1,%1%]\"\n   [(set_attr \"type\"\t\"move\")\n    (set_attr \"mode\"\t\"DI\")\n    (set_attr \"length\"\t\"3\")])"}, {"sha": "42c7a65cb40f9ea3604035e5884a478da7ca0909", "filename": "gcc/config/mips/rtems64.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmips%2Frtems64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmips%2Frtems64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Frtems64.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for rtems targeting a MIPS ORION using ecoff.\n-   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n    Contributed by Joel Sherrill (joel@OARcorp.com).\n \n This file is part of GNU CC.\n@@ -19,8 +19,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#include \"mips/elforion.h\"\n-\n /* Specify predefined symbols in preprocessor.  */\n \n #undef CPP_PREDEFINES"}, {"sha": "64027f55355c9df11d8742aec0f0c7bd3a03e621", "filename": "gcc/config/msdos/top.sed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmsdos%2Ftop.sed", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fmsdos%2Ftop.sed", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsdos%2Ftop.sed?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -19,9 +19,9 @@ host_xm_file=config/i386/xm-dos.h\n /^xmake_file=/ d\n /^tmake_file=/ d\n /^version=/ c\\\n-version=2.8.0\n+version=2.8.1\n /^mainversion=/ c\\\n-mainversion=2.8.0\n+mainversion=2.8.1\n s/CC = cc/CC = gcc/\n s/:\\$/: \\$/g\n s/^\t\\ *\\.\\//\t/"}, {"sha": "d98662ad750d21bdb3670cf890fef30bbd010b1c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on IBM RS/6000.\n-   Copyright (C) 1991, 93-7, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n This file is part of GNU CC."}, {"sha": "7ac3cf60c9c6e3e7ad27ebd388472ade823405f7", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for IBM RS/6000.\n-   Copyright (C) 1992, 93-7, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n This file is part of GNU CC.\n@@ -2054,8 +2054,8 @@ typedef struct rs6000_args\n \n /* Define the magic numbers that we recognize as COFF.\n    AIX 4.3 adds U803XTOCMAGIC (0757) for 64-bit executables, but collect2.c\n-   does not include files in the correct order to conditionally define\n-   the symbolic name in this macro.  */\n+   does not include these files in the right order to conditionally define\n+   the value in the macro.  */\n \n #define MY_ISCOFF(magic) \\\n   ((magic) == U802WRMAGIC || (magic) == U802ROMAGIC \\"}, {"sha": "9f171fc9926d80a4380a3e1737f0345a7a3283d2", "filename": "gcc/config/rs6000/x-aix31", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Frs6000%2Fx-aix31", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Frs6000%2Fx-aix31", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fx-aix31?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,4 @@\n # configuration for IBM rs6000 running aix\n-\n # Show we need to use the C version of ALLOCA\n ALLOCA=alloca.o\n "}, {"sha": "ca548319c1094e7720eddae380d69e9fff42e770", "filename": "gcc/config/rs6000/xm-cygwin32.h", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Frs6000%2Fxm-cygwin32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Frs6000%2Fxm-cygwin32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxm-cygwin32.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,26 +1 @@\n-/* Configuration for GNU C-compiler for hosting on Windows NT.\n-   using a unix style C library.\n-   Copyright (C) 1995, 1997 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n-\n-\n-#define NO_STAB_H\n-\n-#include \"rs6000/xm-rs6000.h\"\n-\n #define EXECUTABLE_SUFFIX \".exe\""}, {"sha": "cf56eb4ad3384bacb88d7e1c79854e2380a4fd59", "filename": "gcc/config/rs6000/xm-sysv4.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Frs6000%2Fxm-sysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Frs6000%2Fxm-sysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxm-sysv4.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Configuration for GNU C-compiler for PowerPC running System V.4.\n-   Copyright (C) 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1998 Free Software Foundation, Inc.\n \n    Cloned from sparc/xm-sysv4.h by Michael Meissner (meissner@cygnus.com).\n \n@@ -48,8 +48,6 @@ Boston, MA 02111-1307, USA.  */\n \n #ifdef __linux__\n #include \"xm-linux.h\"\n-#else\n-#include \"xm-svr4.h\"\n #endif\n \n /* if not compiled with GNU C, use the C alloca and use only int bitfields. */"}, {"sha": "a5807ecc632a6d7bda012ad6fce0e46a287c3353", "filename": "gcc/config/sparc/linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fsparc%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fsparc%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for SPARC running Linux-based GNU systems with ELF.\n-   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n    Contributed by Eddie C. Dost (ecd@skynet.be)\n \n This file is part of GNU CC."}, {"sha": "b676e72a50fded66e0184075ba75222909b17f6e", "filename": "gcc/config/sparc/linux64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fsparc%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fsparc%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux64.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for 64-bit SPARC running Linux-based GNU systems with ELF.\n-   Copyright 1996, 1997 Free Software Foundation, Inc.\n+   Copyright 1996, 1997, 1998 Free Software Foundation, Inc.\n    Contributed by David S. Miller (davem@caip.rutgers.edu)\n \n This file is part of GNU CC."}, {"sha": "36ccb15095f808f374bc317320925b7574459d80", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1505,6 +1505,10 @@ pic_setup_code ()\n \n   start_sequence ();\n \n+  /* If -O0, show the PIC register remains live before this.  */\n+  if (obey_regdecls)\n+    emit_insn (gen_rtx (USE, VOIDmode, pic_offset_table_rtx));\n+    \n   l1 = gen_label_rtx ();\n \n   pic_pc_rtx = gen_rtx (CONST, Pmode,\n@@ -5124,42 +5128,33 @@ sparc_type_code (type)\n      register tree type;\n {\n   register unsigned long qualifiers = 0;\n-  register unsigned shift = 6;\n+  register unsigned shift;\n \n   /* Only the first 30 bits of the qualifier are valid.  We must refrain from\n      setting more, since some assemblers will give an error for this.  Also,\n      we must be careful to avoid shifts of 32 bits or more to avoid getting\n      unpredictable results.  */\n \n-  for (;;)\n+  for (shift = 6; shift < 30; shift += 2, type = TREE_TYPE (type))\n     {\n       switch (TREE_CODE (type))\n \t{\n \tcase ERROR_MARK:\n \t  return qualifiers;\n   \n \tcase ARRAY_TYPE:\n-\t  if (shift < 30)\n-\t    qualifiers |= (3 << shift);\n-\t  shift += 2;\n-\t  type = TREE_TYPE (type);\n+\t  qualifiers |= (3 << shift);\n \t  break;\n \n \tcase FUNCTION_TYPE:\n \tcase METHOD_TYPE:\n-\t  if (shift < 30)\n-\t    qualifiers |= (2 << shift);\n-\t  shift += 2;\n-\t  type = TREE_TYPE (type);\n+\t  qualifiers |= (2 << shift);\n \t  break;\n \n \tcase POINTER_TYPE:\n \tcase REFERENCE_TYPE:\n \tcase OFFSET_TYPE:\n-\t  if (shift < 30)\n-\t    qualifiers |= (1 << shift);\n-\t  shift += 2;\n-\t  type = TREE_TYPE (type);\n+\t  qualifiers |= (1 << shift);\n \t  break;\n \n \tcase RECORD_TYPE:\n@@ -5179,10 +5174,7 @@ sparc_type_code (type)\n \t  /* If this is a range type, consider it to be the underlying\n \t     type.  */\n \t  if (TREE_TYPE (type) != 0)\n-\t    {\n-\t      type = TREE_TYPE (type);\n-\t      break;\n-\t    }\n+\t    break;\n \n \t  /* Carefully distinguish all the standard types of C,\n \t     without messing up if the language is not C.  We do this by\n@@ -5208,6 +5200,11 @@ sparc_type_code (type)\n \t    return (qualifiers | (TREE_UNSIGNED (type) ? 15 : 5));\n   \n \tcase REAL_TYPE:\n+\t  /* If this is a range type, consider it to be the underlying\n+\t     type.  */\n+\t  if (TREE_TYPE (type) != 0)\n+\t    break;\n+\n \t  /* Carefully distinguish all the standard types of C,\n \t     without messing up if the language is not C.  */\n \n@@ -5234,6 +5231,8 @@ sparc_type_code (type)\n \t  abort ();\t\t/* Not a type! */\n         }\n     }\n+\n+  return qualifiers;\n }\n \f\n /* Nested function support.  */"}, {"sha": "1659e68b22edf7bfe04df79b7c421504b5a8c18f", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for Sun SPARC.\n-   Copyright (C) 1987, 88, 89, 92, 94-7, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92, 94-97, 1998 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com).\n    64 bit SPARC V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,\n    at Cygnus Support.\n@@ -2162,9 +2162,8 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n    is defined, then all arguments are treated as named.  Otherwise, all named\n    arguments except the last are treated as named.\n    For the v9 we want NAMED to mean what it says it means.  */\n-/* ??? This needn't be set for v8, but I don't want to make this runtime\n-   selectable if I don't have to.  */\n-#define STRICT_ARGUMENT_NAMING\n+\n+#define STRICT_ARGUMENT_NAMING TARGET_V9\n \n /* Generate RTL to flush the register windows so as to make arbitrary frames\n    available.  */"}, {"sha": "3a1a82d9fe98c356249b6018d4102284ad268e54", "filename": "gcc/config/sparc/sysv4.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsysv4.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,7 +1,6 @@\n /* Target definitions for GNU compiler for Sparc running System V.4\n-   Copyright (C) 1991, 1992, 1995, 1996, 1997 Free Software Foundation, Inc.\n-\n-   Written by Ron Guilmette (rfg@netcom.com).\n+   Copyright (C) 1991, 92, 95, 96, 97, 1998 Free Software Foundation, Inc.\n+   Contributed by Ron Guilmette (rfg@monkeys.com).\n \n This file is part of GNU CC.\n \n@@ -136,10 +135,7 @@ do { ASM_OUTPUT_ALIGN ((FILE), Pmode == SImode ? 2 : 3);\t\t\\\n    f0-f31\t\t32-63\t\t\t40-71\n */\n \n-#define DBX_REGISTER_NUMBER(REGNO)\t\t\t\t\t\\\n-  (((REGNO) < 32) ? (REGNO)\t\t\t\t\t\t\\\n-   : ((REGNO) < 63) ? ((REGNO) + 8)\t\t\t\t\t\\\n-   : (abort (), 0))\n+#define DBX_REGISTER_NUMBER(REGNO) ((REGNO) < 32 ? (REGNO) : (REGNO) + 8)\n \n /* A set of symbol definitions for assembly pseudo-ops which will\n    get us switched to various sections of interest.  These are used"}, {"sha": "691c7d167847ac8d3fd6ab4c12def42fded22dc8", "filename": "gcc/config/sparc/xm-linux.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fsparc%2Fxm-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fsparc%2Fxm-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fxm-linux.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -24,5 +24,3 @@ Boston, MA 02111-1307, USA.  */\n #include <stdlib.h>\n #include <string.h>\n #endif\n-\n-#include <xm-linux.h>"}, {"sha": "5613b086b57207a51d981e76c1aadb71dde7b4bd", "filename": "gcc/config/sparc/xm-sol2.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fsparc%2Fxm-sol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fsparc%2Fxm-sol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fxm-sol2.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,3 @@\n-#include \"sparc/xm-sysv4.h\"\n-\n /* If not compiled with GNU C, include the system's <alloca.h> header.  */\n #ifndef __GNUC__\n #include <alloca.h>"}, {"sha": "e6be0c3b0c8f3fb2b1d9e829f11346a1d59779c4", "filename": "gcc/config/t-svr4", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Ft-svr4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Ft-svr4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ft-svr4?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -2,8 +2,7 @@\n # crtstuff.c.  This is only really needed when we are going to use gcc/g++\n # to produce a shared library, but since we don't know ahead of time when\n # we will be doing that, we just always use -fPIC when compiling the\n-# routines in crtstuff.c.\n-# Similarly for TARGET_LIBGCC2_CFLAGS\n+# routines in crtstuff.c.  Likewise for libgcc2.c.\n \n CRTSTUFF_T_CFLAGS = -fPIC\n TARGET_LIBGCC2_CFLAGS = -fPIC"}, {"sha": "25ca7bcce5dfc23d94559c7bb2e55f88904e975b", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for GNU compiler, Vax Version\n-;;   Copyright (C) 1987, 88, 91, 94, 95, 1996 Free Software Foundation, Inc.\n+;;   Copyright (C) 1987, 88, 91, 94-96, 1998 Free Software Foundation, Inc.\n \n ;; This file is part of GNU CC.\n \n@@ -1837,9 +1837,12 @@\n \f\n ;; Note that operand 1 is total size of args, in bytes,\n ;; and what the call insn wants is the number of words.\n+;; It is used in the call instruction as a byte, but in the addl2 as\n+;; a word.  Since the only time we actually use it in the call instruction\n+;; is when it is a constant, SImode (for addl2) is the proper mode.\n (define_insn \"call_pop\"\n   [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n-\t (match_operand:QI 1 \"general_operand\" \"g\"))\n+\t (match_operand:SI 1 \"general_operand\" \"g\"))\n    (set (reg:SI 14) (plus:SI (reg:SI 14)\n \t\t\t     (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n   \"\"\n@@ -1854,7 +1857,7 @@\n (define_insn \"call_value_pop\"\n   [(set (match_operand 0 \"\" \"=g\")\n \t(call (match_operand:QI 1 \"memory_operand\" \"m\")\n-\t      (match_operand:QI 2 \"general_operand\" \"g\")))\n+\t      (match_operand:SI 2 \"general_operand\" \"g\")))\n    (set (reg:SI 14) (plus:SI (reg:SI 14)\n \t\t\t     (match_operand:SI 4 \"immediate_operand\" \"i\")))]\n   \"\"\n@@ -1870,7 +1873,7 @@\n ;; operands.  In that case, combine may simplify the adjustment of sp.\n (define_insn \"\"\n   [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n-\t (match_operand:QI 1 \"general_operand\" \"g\"))\n+\t (match_operand:SI 1 \"general_operand\" \"g\"))\n    (set (reg:SI 14) (reg:SI 14))]\n   \"\"\n   \"*\n@@ -1884,7 +1887,7 @@\n (define_insn \"\"\n   [(set (match_operand 0 \"\" \"=g\")\n \t(call (match_operand:QI 1 \"memory_operand\" \"m\")\n-\t      (match_operand:QI 2 \"general_operand\" \"g\")))\n+\t      (match_operand:SI 2 \"general_operand\" \"g\")))\n    (set (reg:SI 14) (reg:SI 14))]\n   \"\"\n   \"*"}, {"sha": "35c1665f05a39ed49226481d38a1a3582a9e6405", "filename": "gcc/config/vax/vms.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fvax%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fvax%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvms.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -304,9 +304,9 @@ const_section ()\t\t\t\t\t\\\n \n /* The following definitions are used in libgcc2.c with the __main\n    function.  The _SHR symbol is used when the sharable image library\n-   for libg++ is used - this is picked up automatically by the linker\n-   and this symbol points to the start of the __CTOR_LIST__ from libg++.\n-   If libg++ is not being used, then __CTOR_LIST_SHR__ occurs just after\n+   for the C++ library is used - this is picked up automatically by the linker\n+   and this symbol points to the start of __CTOR_LIST__ from the C++ library.\n+   If the C++ library is not used, then __CTOR_LIST_SHR__ occurs just after\n    __CTOR_LIST__, and essentially points to the same list as __CTOR_LIST.  */\n \n #ifdef L__main"}, {"sha": "9beceabf2ec8e9674adbb21862193a632dd88f57", "filename": "gcc/config/winnt/config-nt.sed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fwinnt%2Fconfig-nt.sed", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fconfig%2Fwinnt%2Fconfig-nt.sed", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwinnt%2Fconfig-nt.sed?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -13,7 +13,7 @@ s/$(srcdir)\\/c-gperf/c-gperf/g\n /^lang_specs_files=/ d\n /^lang_options_files=/ d\n /^version=/ c\\\n-version=2.8.0\n+version=2.8.1\n s/CC = cc/CC = cl/\n s/^SHELL =.*/SHELL =/\n s/CFLAGS = -g/CFLAGS =/"}, {"sha": "46bd0f329352e29467ef4dab141312dea2bb08ed", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1036,6 +1036,10 @@ Sat Feb  7 16:48:54 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* parse.y (nomods_initdcl0): Add constructor_declarator case.\n \n+Fri Feb  6 21:32:25 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* config-lang.in (diff_excludes): Use basename only.\n+\n Thu Feb  5 19:10:40 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* tinfo2.cc: Add tinfo for signed char.\n@@ -1937,6 +1941,8 @@ Wed Nov 26 01:11:24 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl2.c (delete_sanity): resolve_offset_ref.\n \n+\t* except.c: Call terminate without caching so many bits.\n+\n \t* except.c (expand_start_catch_block): Fix catching a reference\n \tto pointer.\n "}, {"sha": "192640c7c656ba7b8c1f48512dba5666af5c49d8", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,7 +1,7 @@\n /* Functions related to invoking methods and overloaded functions.\n-   Copyright (C) 1987, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 92-97, 1998 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) and\n-   hacked by Brendan Kehoe (brendan@cygnus.com).\n+   modified by Brendan Kehoe (brendan@cygnus.com).\n \n This file is part of GNU CC.\n "}, {"sha": "9b39d51ed87032d92b85619a64a04ee92b200bc9", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -32,7 +32,7 @@ compilers=\"cc1plus\\$(exeext)\"\n \n stagestuff=\"g++\\$(exeext) g++-cross\\$(exeext) cc1plus\\$(exeext)\"\n \n-diff_excludes=\"-x cp/parse.c -x cp/parse.h\"\n+diff_excludes=\"-x parse.c -x parse.h\"\n \n headers='$(CXX_EXTRA_HEADERS)'\n "}, {"sha": "32009a98f57893b6acd99af332ceb7ecb01b0f6f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,6 +1,6 @@\n-/* Process declarations and variables for C++ compiler.\n-   Copyright (C) 1988, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n-   Hacked by Michael Tiemann (tiemann@cygnus.com)\n+/* Process declarations and variables for C compiler.\n+   Copyright (C) 1988, 92-97, 1998 Free Software Foundation, Inc.\n+   Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n \n@@ -170,7 +170,6 @@ static void record_builtin_type PROTO((enum rid, char *, tree));\n static int member_function_or_else PROTO((tree, tree, char *));\n static void bad_specifiers PROTO((tree, char *, int, int, int, int,\n \t\t\t\t  int));\n-static tree make_implicit_typename PROTO((tree, tree));\n \n /* a node which has tree code ERROR_MARK, and whose type is itself.\n    All erroneous expressions are replaced with this node.  All functions"}, {"sha": "63593eece4f3dcd7e06cb0fd2313da92318efb9b", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Handle exceptional things in C++.\n-   Copyright (C) 1989, 92-96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 92-97, 1998 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann <tiemann@cygnus.com>\n    Rewritten by Mike Stump <mrs@cygnus.com>, based upon an\n    initial re-implementation courtesy Tad Hunt."}, {"sha": "8072e5c4549b8aa288c504ae9a0b4a3dc9f9337e", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n // Functions for Exception Support for -*- C++ -*-\n-// Copyright (C) 1994, 1995, 1996 Free Software Foundation\n+// Copyright (C) 1994, 1995, 1996, 1998 Free Software Foundation\n \n // This file is part of GNU CC.\n "}, {"sha": "952fe9cd03ba965cfcc33190005e557cde0975b5", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -3,7 +3,7 @@\n    Copyright (C) 1987, 89, 92-97, 1998 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n-   This file is part of GNU CC.\n+This file is part of GNU CC.\n    \n GNU CC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by"}, {"sha": "fb730e2ef23f1a2fedfa8166f2db37dafe087030", "filename": "gcc/cpp.texi", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpp.texi?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -934,7 +934,7 @@ to test whether a header is compiled by a C compiler or a C++ compiler.\n \n @item __STRICT_ANSI__\n @findex __STRICT_ANSI__\n-This macro is defined if and only if the @samp{-ansi} switch was\n+GNU C defines this macro if and only if the @samp{-ansi} switch was\n specified when GNU C was invoked.  Its definition is the null string.\n This macro exists primarily to direct certain GNU header files not to\n define certain traditional Unix constructs which are incompatible with\n@@ -956,48 +956,46 @@ the nesting level is zero.\n \n @item __VERSION__\n @findex __VERSION__\n-This macro expands to a string which describes the version number of\n+This macro expands to a string constant which describes the version number of\n GNU C@.  The string is normally a sequence of decimal numbers separated\n-by periods, such as @samp{\"2.6.0\"}.  The only reasonable use of this\n-macro is to incorporate it into a string constant.\n+by periods, such as @samp{\"2.6.0\"}.\n \n @item __OPTIMIZE__\n @findex __OPTIMIZE__\n-This macro is defined in optimizing compilations.  It causes certain\n-GNU header files to define alternative macro definitions for some\n-system library functions.  It is unwise to refer to or test the\n-definition of this macro unless you make very sure that programs will\n-execute with the same effect regardless.\n+GNU CC defines this macro in optimizing compilations.  It causes certain\n+GNU header files to define alternative macro definitions for some system\n+library functions.  You should not refer to or test the definition of\n+this macro unless you make very sure that programs will execute with the\n+same effect regardless.\n \n @item __CHAR_UNSIGNED__\n @findex __CHAR_UNSIGNED__\n-This macro is defined if and only if the data type @code{char} is\n-unsigned on the target machine.  It exists to cause the standard\n-header file @file{limits.h} to work correctly.  It is bad practice\n-to refer to this macro yourself; instead, refer to the standard\n-macros defined in @file{limits.h}.  The preprocessor uses\n-this macro to determine whether or not to sign-extend large character\n-constants written in octal; see @ref{#if Directive,,The @samp{#if} Directive}.\n+GNU C defines this macro if and only if the data type @code{char} is\n+unsigned on the target machine.  It exists to cause the standard header\n+file @file{limits.h} to work correctly.  You should not refer to this\n+macro yourself; instead, refer to the standard macros defined in\n+@file{limits.h}.  The preprocessor uses this macro to determine whether\n+or not to sign-extend large character constants written in octal; see\n+@ref{#if Directive,,The @samp{#if} Directive}.\n \n @item __REGISTER_PREFIX__\n @findex __REGISTER_PREFIX__\n-This macro expands to a string describing the prefix applied to cpu\n-registers in assembler code.  It can be used to write assembler code\n-that is usable in multiple environments.  For example, in the\n-@samp{m68k-aout} environment it expands to the string @samp{\"\"},\n-but in the @samp{m68k-coff} environment it expands to the string\n-@samp{\"%\"}.\n+This macro expands to a string (not a string constant) describing the\n+prefix applied to CPU registers in assembler code.  You can use it to\n+write assembler code that is usable in multiple environments.  For\n+example, in the @samp{m68k-aout} environment it expands to the null\n+string, but in the @samp{m68k-coff} environment it expands to the string\n+@samp{%}.\n \n @item __USER_LABEL_PREFIX__\n @findex __USER_LABEL_PREFIX__\n-This macro expands to a string describing the prefix applied to user\n-generated labels in assembler code.  It can be used to write assembler\n-code that is usable in multiple environments.  For example, in the\n-@samp{m68k-aout} environment it expands to the string @samp{\"_\"}, but in\n-the @samp{m68k-coff} environment it expands to the string @samp{\"\"}.\n-This does not work with the @samp{-mno-underscores} option that the\n-i386 OSF/rose and m88k targets provide nor with the @samp{-mcall*} options\n-of the rs6000 System V Release 4 target.\n+Similar to @code{__REGISTER_PREFIX__}, but describes the prefix applied\n+to user generated labels in assembler code.  For example, in the\n+@samp{m68k-aout} environment it expands to the string @samp{_}, but in\n+the @samp{m68k-coff} environment it expands to the null string.  This\n+does not work with the @samp{-mno-underscores} option that the i386\n+OSF/rose and m88k targets provide nor with the @samp{-mcall*} options of\n+the rs6000 System V Release 4 target.\n @end table\n \n @node Nonstandard Predefined,, Standard Predefined, Predefined\n@@ -2687,7 +2685,7 @@ Only the directories you have specified with @samp{-I} options\n @findex -nostdinc++\n Do not search for header files in the C++-specific standard directories,\n but do still search the other standard directories.\n-(This option is used when building libg++.)\n+(This option is used when building the C++ library.)\n \n @item -remap\n @findex -remap"}, {"sha": "bd689112333a14f65cd43a3bf020e91f7ab87ca3", "filename": "gcc/cpplib.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* CPP Library.\n-   Copyright (C) 1986, 87, 89, 92-7, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1986, 87, 89, 92-97, 1998 Free Software Foundation, Inc.\n    Contributed by Per Bothner, 1994-95.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n@@ -369,7 +369,8 @@ struct directive {\n   char command_reads_line;      /* One if rest of line is read by func.  */\n };\n \n-#define IS_INCLUDE_DIRECTIVE_TYPE(t) (T_INCLUDE <= (t) && (t) <= T_IMPORT)\n+#define IS_INCLUDE_DIRECTIVE_TYPE(t) \\\n+((int) T_INCLUDE <= (int) (t) && (int) (t) <= (int) T_IMPORT)\n \n /* Here is the actual list of #-directives, most-often-used first.\n    The initialize_builtins function assumes #define is the very first.  */\n@@ -7494,14 +7495,15 @@ cpp_error_from_errno (pfile, name)\n      cpp_reader *pfile;\n      char *name;\n {\n+  int e = errno;\n   cpp_buffer *ip = cpp_file_buffer (pfile);\n \n   cpp_print_containing_files (pfile);\n \n   if (ip != NULL)\n     cpp_file_line_for_message (ip->nominal_fname, ip->lineno, -1);\n \n-  cpp_message (pfile, 1, \"%s: %s\", name, my_strerror (errno));\n+  cpp_message (pfile, 1, \"%s: %s\", name, my_strerror (e));\n }\n \n void"}, {"sha": "e6238de5e9ba2c9354c56fbb0a5a1d09a4ddaf8c", "filename": "gcc/crtstuff.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcrtstuff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcrtstuff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcrtstuff.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,6 +1,6 @@\n /* Specialized bits of code needed to support construction and\n    destruction of file-scope objects in C++ code.\n-   Copyright (C) 1991, 94-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.\n    Contributed by Ron Guilmette (rfg@monkeys.com).\n \n This file is part of GNU CC.\n@@ -389,10 +389,13 @@ __do_global_ctors_aux ()\t/* prologue goes in .text section */\n   asm (INIT_SECTION_ASM_OP);\n   DO_GLOBAL_CTORS_BODY;\n   ON_EXIT (__do_global_dtors, 0);\n+}\t\t\t\t/* epilogue and body go in .init section */\n+\n #ifdef FORCE_INIT_SECTION_ALIGN\n-  FORCE_INIT_SECTION_ALIGN;\n+FORCE_INIT_SECTION_ALIGN;\n #endif\n-}\t\t\t\t/* epilogue and body go in .init section */\n+\n+asm (TEXT_SECTION_ASM_OP);\n \n #endif /* OBJECT_FORMAT_ELF */\n "}, {"sha": "990ef5f1700ed947783da61f677a3ae58c8832cf", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -2277,6 +2277,10 @@ set_nonvarying_address_components (addr, size, pbase, pstart, pend)\n   start = 0;\n   end = 0;\n \n+  if (flag_pic && GET_CODE (base) == PLUS\n+      && XEXP (base, 0) == pic_offset_table_rtx)\n+    base = XEXP (base, 1);\n+\n   /* Registers with nonvarying addresses usually have constant equivalents;\n      but the frame pointer register is also possible.  */\n   if (GET_CODE (base) == REG"}, {"sha": "9d431832975799f5dbe11e5cf9c0642e282e2afa", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Output Dwarf2 format symbol table information from the GNU C compiler.\n-   Copyright (C) 1992, 1993, 95-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93, 95, 96, 97, 1998 Free Software Foundation, Inc.\n    Contributed by Gary Funck (gary@intrepid.com).\n    Derived from DWARF 1 implementation of Ron Guilmette (rfg@monkeys.com).\n    Extensively modified by Jason Merrill (jason@cygnus.com).\n@@ -578,18 +578,26 @@ expand_builtin_dwarf_reg_size (reg_tree, target)\n \tcontinue;\n \n       mode = reg_raw_mode[i];\n+\n       /* CCmode is arbitrarily given a size of 4 bytes.  It is more useful\n \t to use the same size as word_mode, since that reduces the number\n \t of ranges we need.  It should not matter, since the result should\n \t never be used for a condition code register anyways.  */\n-      if (mode == CCmode)\n+      if (GET_MODE_CLASS (mode) == MODE_CC)\n \tmode = word_mode;\n+\n       size = GET_MODE_SIZE (mode);\n \n+      /* If this register is not valid in the specified mode and\n+\t we have a previous size, use that for the size of this\n+\t register to avoid making junk tiny ranges.  */\n+      if (! HARD_REGNO_MODE_OK (i, mode) && last_size != -1)\n+\tsize = last_size;\n+\n       if (size != last_size)\n \t{\n \t  ranges[n_ranges].beg = i;\n-\t  ranges[n_ranges].size = last_size = GET_MODE_SIZE (reg_raw_mode[i]);\n+\t  ranges[n_ranges].size = last_size = size;\n \t  ++n_ranges;\n \t  if (n_ranges >= 5)\n \t    abort ();"}, {"sha": "bb5ea0be604cbe6fa54e2085708c0528894336e6", "filename": "gcc/enquire.c", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fenquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fenquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fenquire.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1412,21 +1412,42 @@ int cprop() {\n \n \tc=0; char_max=0;\n \tc++;\n-\tif (setjmp(lab)==0) { /* Yields char_max */\n-\t\twhile (c>char_max) {\n-\t\t\tchar_max=c;\n-\t\t\tc++;\n-\t\t}\n+\tif (bits_per_byte <= 16) {\n+\t     if (setjmp(lab)==0) { /* Yields char_max */\n+\t\t  while (c>char_max) {\n+\t\t       char_max=c;\n+\t\t       c++;\n+\t\t  }\n+\t     } else {\n+\t\t  Vprintf(\"%sCharacter overflow generates a trap!%s\\n\",\n+\t\t\t  co, oc);\n+\t     }\n+\t     c=0; char_min=0;\n+\t     c--;\n+\t     if (setjmp(lab)==0) { /* Yields char_min */\n+\t\t  while (c<char_min) {\n+\t\t       char_min=c;\n+\t\t       c--;\n+\t\t  }\n+\t     }\n \t} else {\n-\t\tVprintf(\"%sCharacter overflow generates a trap!%s\\n\", co, oc);\n-\t}\n-\tc=0; char_min=0;\n-\tc--;\n-\tif (setjmp(lab)==0) { /* Yields char_min */\n-\t\twhile (c<char_min) {\n-\t\t\tchar_min=c;\n-\t\t\tc--;\n-\t\t}\n+\t     /* An exhaustive search here is impracticable ;-)  */\n+\t     c = (1 << (bits_per_byte - 1)) - 1;\n+\t     char_max = c;\n+\t     c++;\n+\t     if (c > char_max)\n+\t\t  char_max = ~0;\n+\t     c = 0;\n+\t     char_min = 0;\n+\t     c--;\n+\t     if (c < char_min) {\n+\t\t  c = (1 << (bits_per_byte - 1)) - 1;\n+\t\t  c = -c;\n+\t\t  char_min = c;\n+\t\t  c--;\n+\t\t  if (c < char_min)\n+\t\t       char_min = c;\n+\t     }\n \t}\n \tif (c_signed && char_min == 0) {\n \t\tVprintf(\"%sBEWARE! Chars are pseudo-unsigned:%s\\n\", co, oc);"}, {"sha": "1b4c41193c153d0027fa749d7bbc3bd61fd197fe", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Implements exception handling.\n-   Copyright (C) 1989, 92-96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 92-97, 1998 Free Software Foundation, Inc.\n    Contributed by Mike Stump <mrs@cygnus.com>.\n \n This file is part of GNU CC."}, {"sha": "cda07af7b2ecb8c982356bb1ffa94606feffc472", "filename": "gcc/explow.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for manipulating rtx's in semantically interesting ways.\n-   Copyright (C) 1987, 91, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 91, 94-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1366,7 +1366,8 @@ probe_stack_range (first, size)\n \n   /* If we have to generate explicit probes, see if we have a constant\n      small number of them to generate.  If so, that's the easy case.  */\n-  if (GET_CODE (size) == CONST_INT && INTVAL (size) < 10)\n+  if (GET_CODE (size) == CONST_INT\n+      && INTVAL (size) < 10 * STACK_CHECK_PROBE_INTERVAL)\n     {\n       HOST_WIDE_INT offset;\n "}, {"sha": "8f0ba07136401701381a14cdde0c2bd9832519c2", "filename": "gcc/expmed.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,6 +1,6 @@\n /* Medium-level subroutines: convert bit-field store and extract\n    and shifts, multiplies and divides to rtl instructions.\n-   Copyright (C) 1987, 88, 89, 92-6, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -907,6 +907,8 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \n       offset += SUBREG_WORD (op0);\n \n+      inner_size = MIN (inner_size, BITS_PER_WORD);\n+\n       if (BYTES_BIG_ENDIAN && (outer_size < inner_size))\n \t{\n \t  bitpos += inner_size - outer_size;\n@@ -1076,7 +1078,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t{\n \t  int xbitpos = bitpos, xoffset = offset;\n \t  rtx bitsize_rtx, bitpos_rtx;\n-\t  rtx last = get_last_insn();\n+\t  rtx last = get_last_insn ();\n \t  rtx xop0 = op0;\n \t  rtx xtarget = target;\n \t  rtx xspec_target = spec_target;\n@@ -1140,7 +1142,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t  /* If op0 is a register, we need it in MAXMODE (which is usually\n \t     SImode). to make it acceptable to the format of extzv.  */\n \t  if (GET_CODE (xop0) == SUBREG && GET_MODE (xop0) != maxmode)\n-\t    abort ();\n+\t    goto extzv_loses;\n \t  if (GET_CODE (xop0) == REG && GET_MODE (xop0) != maxmode)\n \t    xop0 = gen_rtx_SUBREG (maxmode, xop0, 0);\n \n@@ -1216,7 +1218,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t{\n \t  int xbitpos = bitpos, xoffset = offset;\n \t  rtx bitsize_rtx, bitpos_rtx;\n-\t  rtx last = get_last_insn();\n+\t  rtx last = get_last_insn ();\n \t  rtx xop0 = op0, xtarget = target;\n \t  rtx xspec_target = spec_target;\n \t  rtx xspec_target_subreg = spec_target_subreg;\n@@ -1274,7 +1276,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t  /* If op0 is a register, we need it in MAXMODE (which is usually\n \t     SImode) to make it acceptable to the format of extv.  */\n \t  if (GET_CODE (xop0) == SUBREG && GET_MODE (xop0) != maxmode)\n-\t    abort ();\n+\t    goto extv_loses;\n \t  if (GET_CODE (xop0) == REG && GET_MODE (xop0) != maxmode)\n \t    xop0 = gen_rtx_SUBREG (maxmode, xop0, 0);\n "}, {"sha": "2e79f00a3b168a484409647452c37c6f31d36958", "filename": "gcc/expr.c", "status": "modified", "additions": 182, "deletions": 145, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -169,7 +169,7 @@ static rtx store_field\t\tPROTO((rtx, int, int, enum machine_mode, tree,\n \t\t\t\t       enum machine_mode, int, int, int));\n static tree save_noncopied_parts PROTO((tree, tree));\n static tree init_noncopied_parts PROTO((tree, tree));\n-static int safe_from_p\t\tPROTO((rtx, tree));\n+static int safe_from_p\t\tPROTO((rtx, tree, int));\n static int fixed_type_p\t\tPROTO((tree));\n static rtx var_rtx\t\tPROTO((tree));\n static int get_pointer_alignment PROTO((tree, unsigned));\n@@ -930,6 +930,41 @@ convert_move (to, from, unsignedp)\n     }\n \n   /* Handle pointer conversion */\t\t\t/* SPEE 900220 */\n+  if (to_mode == PQImode)\n+    {\n+      if (from_mode != QImode)\n+\tfrom = convert_to_mode (QImode, from, unsignedp);\n+\n+#ifdef HAVE_truncqipqi2\n+      if (HAVE_truncqipqi2)\n+\t{\n+\t  emit_unop_insn (CODE_FOR_truncqipqi2, to, from, UNKNOWN);\n+\t  return;\n+\t}\n+#endif /* HAVE_truncqipqi2 */\n+      abort ();\n+    }\n+\n+  if (from_mode == PQImode)\n+    {\n+      if (to_mode != QImode)\n+\t{\n+\t  from = convert_to_mode (QImode, from, unsignedp);\n+\t  from_mode = QImode;\n+\t}\n+      else\n+\t{\n+#ifdef HAVE_extendpqiqi2\n+\t  if (HAVE_extendpqiqi2)\n+\t    {\n+\t      emit_unop_insn (CODE_FOR_extendpqiqi2, to, from, UNKNOWN);\n+\t      return;\n+\t    }\n+#endif /* HAVE_extendpqiqi2 */\n+\t  abort ();\n+\t}\n+    }\n+\n   if (to_mode == PSImode)\n     {\n       if (from_mode != SImode)\n@@ -1595,7 +1630,7 @@ emit_block_move (x, y, size, align)\n \t\t actual mode mask.  */\n \t      && ((GET_CODE (size) == CONST_INT\n \t\t   && ((unsigned HOST_WIDE_INT) INTVAL (size)\n-\t\t       <= GET_MODE_MASK (mode)))\n+\t\t       <= (GET_MODE_MASK (mode) >> 1)))\n \t\t  || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n \t      && (insn_operand_predicate[(int) code][0] == 0\n \t\t  || (*insn_operand_predicate[(int) code][0]) (x, BLKmode))\n@@ -2096,7 +2131,7 @@ clear_storage (object, size, align)\n \t\t     definitely be less than the actual mode mask.  */\n \t\t  && ((GET_CODE (size) == CONST_INT\n \t\t       && ((unsigned HOST_WIDE_INT) INTVAL (size)\n-\t\t\t   <= GET_MODE_MASK (mode)))\n+\t\t\t   <= (GET_MODE_MASK (mode) >> 1)))\n \t\t      || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n \t\t  && (insn_operand_predicate[(int) code][0] == 0\n \t\t      || (*insn_operand_predicate[(int) code][0]) (object,\n@@ -2418,11 +2453,15 @@ get_push_address (size)\n    to store the arg.  On machines with push insns, ARGS_ADDR is 0 when a\n    argument block has not been preallocated.\n \n-   ARGS_SO_FAR is the size of args previously pushed for this call.  */\n+   ARGS_SO_FAR is the size of args previously pushed for this call.\n+\n+   REG_PARM_STACK_SPACE is nonzero if functions require stack space\n+   for arguments passed in registers.  If nonzero, it will be the number\n+   of bytes required.  */\n \n void\n emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n-\t\targs_addr, args_so_far)\n+\t\targs_addr, args_so_far, reg_parm_stack_space)\n      register rtx x;\n      enum machine_mode mode;\n      tree type;\n@@ -2433,6 +2472,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n      int extra;\n      rtx args_addr;\n      rtx args_so_far;\n+     int reg_parm_stack_space;\n {\n   rtx xinner;\n   enum direction stack_direction\n@@ -2479,11 +2519,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t skip the part of stack space corresponding to the registers.\n \t Otherwise, start copying to the beginning of the stack space,\n \t by setting SKIP to 0.  */\n-#ifndef REG_PARM_STACK_SPACE\n-      skip = 0;\n-#else\n-      skip = used;\n-#endif\n+      skip = (reg_parm_stack_space == 0) ? 0 : used;\n \n #ifdef PUSH_ROUNDING\n       /* Do it with several push insns if that doesn't take lots of insns\n@@ -2598,75 +2634,54 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\t\t      INTVAL (size), align);\n \t      goto ret;\n \t    }\n-\t  /* Try the most limited insn first, because there's no point\n-\t     including more than one in the machine description unless\n-\t     the more limited one has some advantage.  */\n-#ifdef HAVE_movstrqi\n-\t  if (HAVE_movstrqi\n-\t      && GET_CODE (size) == CONST_INT\n-\t      && ((unsigned HOST_WIDE_INT) INTVAL (size)\n-\t\t  <= GET_MODE_MASK (QImode)))\n-\t    {\n-\t      rtx pat = gen_movstrqi (gen_rtx_MEM (BLKmode, temp),\n-\t\t\t\t      xinner, size, GEN_INT (align));\n-\t      if (pat != 0)\n-\t\t{\n-\t\t  emit_insn (pat);\n-\t\t  goto ret;\n-\t\t}\n-\t    }\n-#endif\n-#ifdef HAVE_movstrhi\n-\t  if (HAVE_movstrhi\n-\t      && GET_CODE (size) == CONST_INT\n-\t      && ((unsigned HOST_WIDE_INT) INTVAL (size)\n-\t\t  <= GET_MODE_MASK (HImode)))\n-\t    {\n-\t      rtx pat = gen_movstrhi (gen_rtx_MEM (BLKmode, temp),\n-\t\t\t\t      xinner, size, GEN_INT (align));\n-\t      if (pat != 0)\n-\t\t{\n-\t\t  emit_insn (pat);\n-\t\t  goto ret;\n-\t\t}\n-\t    }\n-#endif\n-#ifdef HAVE_movstrsi\n-\t  if (HAVE_movstrsi)\n-\t    {\n-\t      rtx pat = gen_movstrsi (gen_rtx_MEM (BLKmode, temp),\n-\t\t\t\t      xinner, size, GEN_INT (align));\n-\t      if (pat != 0)\n-\t\t{\n-\t\t  emit_insn (pat);\n-\t\t  goto ret;\n-\t\t}\n-\t    }\n-#endif\n-#ifdef HAVE_movstrdi\n-\t  if (HAVE_movstrdi)\n+\t  else\n \t    {\n-\t      rtx pat = gen_movstrdi (gen_rtx_MEM (BLKmode, temp),\n-\t\t\t\t      xinner, size, GEN_INT (align));\n-\t      if (pat != 0)\n+\t      rtx opalign = GEN_INT (align);\n+\t      enum machine_mode mode;\n+\t      rtx target = gen_rtx (MEM, BLKmode, temp);\n+\n+\t      for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t\t   mode != VOIDmode;\n+\t\t   mode = GET_MODE_WIDER_MODE (mode))\n \t\t{\n-\t\t  emit_insn (pat);\n-\t\t  goto ret;\n+\t\t  enum insn_code code = movstr_optab[(int) mode];\n+\n+\t\t  if (code != CODE_FOR_nothing\n+\t\t      && ((GET_CODE (size) == CONST_INT\n+\t\t\t   && ((unsigned HOST_WIDE_INT) INTVAL (size)\n+\t\t\t       <= (GET_MODE_MASK (mode) >> 1)))\n+\t\t\t  || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n+\t\t      && (insn_operand_predicate[(int) code][0] == 0\n+\t\t\t  || ((*insn_operand_predicate[(int) code][0])\n+\t\t\t      (target, BLKmode)))\n+\t\t      && (insn_operand_predicate[(int) code][1] == 0\n+\t\t\t  || ((*insn_operand_predicate[(int) code][1])\n+\t\t\t      (xinner, BLKmode)))\n+\t\t      && (insn_operand_predicate[(int) code][3] == 0\n+\t\t\t  || ((*insn_operand_predicate[(int) code][3])\n+\t\t\t      (opalign, VOIDmode))))\n+\t\t    {\n+\t\t      rtx op2 = convert_to_mode (mode, size, 1);\n+\t\t      rtx last = get_last_insn ();\n+\t\t      rtx pat;\n+\n+\t\t      if (insn_operand_predicate[(int) code][2] != 0\n+\t\t\t  && ! ((*insn_operand_predicate[(int) code][2])\n+\t\t\t\t(op2, mode)))\n+\t\t\top2 = copy_to_mode_reg (mode, op2);\n+\n+\t\t      pat = GEN_FCN ((int) code) (target, xinner,\n+\t\t\t\t\t\t  op2, opalign);\n+\t\t      if (pat)\n+\t\t\t{\n+\t\t\t  emit_insn (pat);\n+\t\t\t  goto ret;\n+\t\t\t}\n+\t\t      else\n+\t\t\tdelete_insns_since (last);\n+\t\t    }\n \t\t}\n \t    }\n-#endif\n-#ifdef HAVE_movstrti\n-  if (HAVE_movstrti)\n-    {\n-      rtx pat = gen_movstrti (gen_rtx (MEM, BLKmode, temp),\n-\t\t\t      xinner, size, GEN_INT (align));\n-      if (pat != 0)\n-\t{\n-\t  emit_insn (pat);\n-\t  goto ret;\n-\t}\n-    }\n-#endif\n \n #ifndef ACCUMULATE_OUTGOING_ARGS\n \t  /* If the source is referenced relative to the stack pointer,\n@@ -2732,11 +2747,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t skip the part of stack space corresponding to the registers.\n \t Otherwise, start copying to the beginning of the stack space,\n \t by setting SKIP to 0.  */\n-#ifndef REG_PARM_STACK_SPACE\n-      skip = 0;\n-#else\n-      skip = not_stack;\n-#endif\n+      skip = (reg_parm_stack_space == 0) ? 0 : not_stack;\n \n       if (CONSTANT_P (x) && ! LEGITIMATE_CONSTANT_P (x))\n \tx = validize_mem (force_const_mem (mode, x));\n@@ -2760,7 +2771,8 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\t\t  word_mode, NULL_TREE, NULL_RTX, align, 0, NULL_RTX,\n \t\t\t  0, args_addr,\n \t\t\t  GEN_INT (args_offset + ((i - not_stack + skip)\n-\t\t\t\t\t\t  * UNITS_PER_WORD)));\n+\t\t\t\t\t\t  * UNITS_PER_WORD)),\n+\t\t\t  reg_parm_stack_space);\n     }\n   else\n     {\n@@ -4389,12 +4401,12 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \t    *pbitpos += TREE_INT_CST_LOW (index);\n \t  else\n \t    {\n+\t      if (contains_placeholder_p (index))\n+\t\tindex = build (WITH_RECORD_EXPR, sizetype, index, exp);\n+\n \t      offset = size_binop (PLUS_EXPR, offset,\n-\t\t\t\t   convert (sizetype,\n-\t\t\t\t\t    size_binop (FLOOR_DIV_EXPR, index,\n-\t\t\t\t\t\t\tsize_int (BITS_PER_UNIT))));\n-\t      if (contains_placeholder_p (offset))\n-\t\toffset = build (WITH_RECORD_EXPR, sizetype, offset, exp);\n+\t\t\t\t   size_binop (FLOOR_DIV_EXPR, index,\n+\t\t\t\t\t       size_int (BITS_PER_UNIT)));\n \t    }\n \t}\n       else if (TREE_CODE (exp) != NON_LVALUE_EXPR\n@@ -4444,6 +4456,7 @@ get_memory_usage_from_modifier (modifier)\n   switch (modifier)\n     {\n     case EXPAND_NORMAL:\n+    case EXPAND_SUM:\n       return MEMORY_USE_RO;\n       break;\n     case EXPAND_MEMORY_USE_WO:\n@@ -4452,10 +4465,12 @@ get_memory_usage_from_modifier (modifier)\n     case EXPAND_MEMORY_USE_RW:\n       return MEMORY_USE_RW;\n       break;\n-    case EXPAND_INITIALIZER:\n     case EXPAND_MEMORY_USE_DONT:\n-    case EXPAND_SUM:\n+      /* EXPAND_CONST_ADDRESS and EXPAND_INITIALIZER are converted into\n+\t MEMORY_USE_DONT, because they are modifiers to a call of\n+\t expand_expr in the ADDR_EXPR case of expand_expr.  */\n     case EXPAND_CONST_ADDRESS:\n+    case EXPAND_INITIALIZER:\n       return MEMORY_USE_DONT;\n     case EXPAND_MEMORY_USE_BAD:\n     default:\n@@ -4599,12 +4614,15 @@ init_noncopied_parts (lhs, list)\n }\n \n /* Subroutine of expand_expr: return nonzero iff there is no way that\n-   EXP can reference X, which is being modified.  */\n+   EXP can reference X, which is being modified.  TOP_P is nonzero if this\n+   call is going to be used to determine whether we need a temporary\n+   for EXP, as opposed to a recursive call to this function.  */\n \n static int\n-safe_from_p (x, exp)\n+safe_from_p (x, exp, top_p)\n      rtx x;\n      tree exp;\n+     int top_p;\n {\n   rtx exp_rtl = 0;\n   int i, nops;\n@@ -4615,8 +4633,8 @@ safe_from_p (x, exp)\n \t (except for arrays that have TYPE_ARRAY_MAX_SIZE set).\n \t So we assume here that something at a higher level has prevented a\n \t clash.  This is somewhat bogus, but the best we can do.  Only\n-\t do this when X is BLKmode.  */\n-      || (TREE_TYPE (exp) != 0 && TYPE_SIZE (TREE_TYPE (exp)) != 0\n+\t do this when X is BLKmode and when we are at the top level.  */\n+      || (top_p && TREE_TYPE (exp) != 0 && TYPE_SIZE (TREE_TYPE (exp)) != 0\n \t  && TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) != INTEGER_CST\n \t  && (TREE_CODE (TREE_TYPE (exp)) != ARRAY_TYPE\n \t      || TYPE_ARRAY_MAX_SIZE (TREE_TYPE (exp)) == NULL_TREE\n@@ -4653,19 +4671,19 @@ safe_from_p (x, exp)\n     case 'x':\n       if (TREE_CODE (exp) == TREE_LIST)\n \treturn ((TREE_VALUE (exp) == 0\n-\t\t || safe_from_p (x, TREE_VALUE (exp)))\n+\t\t || safe_from_p (x, TREE_VALUE (exp), 0))\n \t\t&& (TREE_CHAIN (exp) == 0\n-\t\t    || safe_from_p (x, TREE_CHAIN (exp))));\n+\t\t    || safe_from_p (x, TREE_CHAIN (exp), 0)));\n       else\n \treturn 0;\n \n     case '1':\n-      return safe_from_p (x, TREE_OPERAND (exp, 0));\n+      return safe_from_p (x, TREE_OPERAND (exp, 0), 0);\n \n     case '2':\n     case '<':\n-      return (safe_from_p (x, TREE_OPERAND (exp, 0))\n-\t      && safe_from_p (x, TREE_OPERAND (exp, 1)));\n+      return (safe_from_p (x, TREE_OPERAND (exp, 0), 0)\n+\t      && safe_from_p (x, TREE_OPERAND (exp, 1), 0));\n \n     case 'e':\n     case 'r':\n@@ -4678,7 +4696,8 @@ safe_from_p (x, exp)\n \t{\n \tcase ADDR_EXPR:\n \t  return (staticp (TREE_OPERAND (exp, 0))\n-\t\t  || safe_from_p (x, TREE_OPERAND (exp, 0)));\n+\t\t  || safe_from_p (x, TREE_OPERAND (exp, 0), 0)\n+\t\t  || TREE_STATIC (exp));\n \n \tcase INDIRECT_REF:\n \t  if (GET_CODE (x) == MEM)\n@@ -4713,7 +4732,7 @@ safe_from_p (x, exp)\n \t  break;\n \n \tcase CLEANUP_POINT_EXPR:\n-\t  return safe_from_p (x, TREE_OPERAND (exp, 0));\n+\t  return safe_from_p (x, TREE_OPERAND (exp, 0), 0);\n \n \tcase SAVE_EXPR:\n \t  exp_rtl = SAVE_EXPR_RTL (exp);\n@@ -4722,7 +4741,7 @@ safe_from_p (x, exp)\n \tcase BIND_EXPR:\n \t  /* The only operand we look at is operand 1.  The rest aren't\n \t     part of the expression.  */\n-\t  return safe_from_p (x, TREE_OPERAND (exp, 1));\n+\t  return safe_from_p (x, TREE_OPERAND (exp, 1), 0);\n \n \tcase METHOD_CALL_EXPR:\n \t  /* This takes a rtx argument, but shouldn't appear here.  */\n@@ -4739,7 +4758,7 @@ safe_from_p (x, exp)\n       nops = tree_code_length[(int) TREE_CODE (exp)];\n       for (i = 0; i < nops; i++)\n \tif (TREE_OPERAND (exp, i) != 0\n-\t    && ! safe_from_p (x, TREE_OPERAND (exp, i)))\n+\t    && ! safe_from_p (x, TREE_OPERAND (exp, i), 0))\n \t  return 0;\n     }\n \n@@ -5190,7 +5209,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  if (mode == VOIDmode)\n \t    temp = const0_rtx;\n \t  else\n-\t    temp = assign_temp (type, 0, 0, 0);\n+\t    temp = assign_temp (type, 3, 0, 0);\n \n \t  SAVE_EXPR_RTL (exp) = temp;\n \t  if (!optimize && GET_CODE (temp) == REG)\n@@ -5215,6 +5234,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t EXPAND_MEMORY_USE_BAD);\n \t  else\n \t    store_expr (TREE_OPERAND (exp, 0), temp, 0);\n+\n+\t  TREE_USED (exp) = 1;\n \t}\n \n       /* If the mode of SAVE_EXPR_RTL does not match that of the expression, it\n@@ -5247,7 +5268,7 @@ expand_expr (exp, target, tmode, modifier)\n \ttree placeholder_expr;\n \n \t/* If there is an object on the head of the placeholder list,\n-\t   see if some object in its references is of type TYPE.  For\n+\t   see if some object in it of type TYPE or a pointer to it.  For\n \t   further information, see tree.def.  */\n \tfor (placeholder_expr = placeholder_list;\n \t     placeholder_expr != 0;\n@@ -5258,26 +5279,38 @@ expand_expr (exp, target, tmode, modifier)\n \t    tree old_list = placeholder_list;\n \t    tree elt;\n \n-\t    /* See if the object is the type that we want.  */\n-\t    if ((TYPE_MAIN_VARIANT (TREE_TYPE\n-\t\t\t\t    (TREE_PURPOSE (placeholder_expr)))\n-\t\t == need_type))\n-\t      object = TREE_PURPOSE (placeholder_expr);\n+\t    /* Find the outermost reference that is of the type we want.\n+\t       If none, see if any object has a type that is a pointer to \n+\t       the type we want.  */\n+\t    for (elt = TREE_PURPOSE (placeholder_expr);\n+\t\t elt != 0 && object == 0;\n+\t\t elt\n+\t\t = ((TREE_CODE (elt) == COMPOUND_EXPR\n+\t\t     || TREE_CODE (elt) == COND_EXPR)\n+\t\t    ? TREE_OPERAND (elt, 1)\n+\t\t    : (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n+\t\t       || TREE_CODE_CLASS (TREE_CODE (elt)) == '1'\n+\t\t       || TREE_CODE_CLASS (TREE_CODE (elt)) == '2'\n+\t\t       || TREE_CODE_CLASS (TREE_CODE (elt)) == 'e')\n+\t\t    ? TREE_OPERAND (elt, 0) : 0))\n+\t      if (TYPE_MAIN_VARIANT (TREE_TYPE (elt)) == need_type)\n+\t\tobject = elt;\n \n-\t    /* Find the outermost reference that is of the type we want.  */\n \t    for (elt = TREE_PURPOSE (placeholder_expr);\n-\t\t elt != 0 && object == 0\n-\t\t && (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n-\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '1'\n-\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '2'\n-\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == 'e');\n-\t\t elt = ((TREE_CODE (elt) == COMPOUND_EXPR\n-\t\t\t || TREE_CODE (elt) == COND_EXPR)\n-\t\t\t? TREE_OPERAND (elt, 1) : TREE_OPERAND (elt, 0)))\n-\t      if (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n-\t\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (elt, 0)))\n+\t\t elt != 0 && object == 0;\n+\t\t elt\n+\t\t = ((TREE_CODE (elt) == COMPOUND_EXPR\n+\t\t     || TREE_CODE (elt) == COND_EXPR)\n+\t\t    ? TREE_OPERAND (elt, 1)\n+\t\t    : (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n+\t\t       || TREE_CODE_CLASS (TREE_CODE (elt)) == '1'\n+\t\t       || TREE_CODE_CLASS (TREE_CODE (elt)) == '2'\n+\t\t       || TREE_CODE_CLASS (TREE_CODE (elt)) == 'e')\n+\t\t    ? TREE_OPERAND (elt, 0) : 0))\n+\t      if (POINTER_TYPE_P (TREE_TYPE (elt))\n+\t\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (elt)))\n \t\t      == need_type))\n-\t\tobject = TREE_OPERAND (elt, 0);\n+\t\tobject = build1 (INDIRECT_REF, need_type, elt);\n \n \t    if (object != 0)\n \t      {\n@@ -5387,7 +5420,7 @@ expand_expr (exp, target, tmode, modifier)\n \t all operands are constant, put it in memory as well.  */\n       else if ((TREE_STATIC (exp)\n \t\t&& ((mode == BLKmode\n-\t\t     && ! (target != 0 && safe_from_p (target, exp)))\n+\t\t     && ! (target != 0 && safe_from_p (target, exp, 1)))\n \t\t    || TREE_ADDRESSABLE (exp)\n \t\t    || (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n \t\t\t&& (move_by_pieces_ninsns\n@@ -5414,7 +5447,7 @@ expand_expr (exp, target, tmode, modifier)\n \t{\n \t  /* Handle calls that pass values in multiple non-contiguous\n \t     locations.  The Irix 6 ABI has examples of this.  */\n-\t  if (target == 0 || ! safe_from_p (target, exp)\n+\t  if (target == 0 || ! safe_from_p (target, exp, 1)\n \t      || GET_CODE (target) == PARALLEL)\n \t    {\n \t      if (mode != BLKmode && ! TREE_ADDRESSABLE (exp))\n@@ -5622,8 +5655,6 @@ expand_expr (exp, target, tmode, modifier)\n \t\tif (DECL_BIT_FIELD (TREE_PURPOSE (elt)))\n \t\t  {\n \t\t    int bitsize = DECL_FIELD_SIZE (TREE_PURPOSE (elt));\n-\t\t    enum machine_mode imode\n-\t\t      = TYPE_MODE (TREE_TYPE (TREE_PURPOSE (elt)));\n \n \t\t    if (TREE_UNSIGNED (TREE_TYPE (TREE_PURPOSE (elt))))\n \t\t      {\n@@ -5632,8 +5663,11 @@ expand_expr (exp, target, tmode, modifier)\n \t\t      }\n \t\t    else\n \t\t      {\n+\t\t\tenum machine_mode imode\n+\t\t\t  = TYPE_MODE (TREE_TYPE (TREE_PURPOSE (elt)));\n \t\t\ttree count\n-\t\t\t  = build_int_2 (imode - bitsize, 0);\n+\t\t\t  = build_int_2 (GET_MODE_BITSIZE (imode) - bitsize,\n+\t\t\t\t\t 0);\n \n \t\t\top0 = expand_shift (LSHIFT_EXPR, imode, op0, count,\n \t\t\t\t\t    target, 0);\n@@ -5673,7 +5707,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t!= INTEGER_CST)\n \t\t\t    ? target : NULL_RTX),\n \t\t\t   VOIDmode,\n-\t\t\t   modifier == EXPAND_INITIALIZER ? modifier : 0);\n+\t\t\t   modifier == EXPAND_INITIALIZER\n+\t\t\t   ? modifier : EXPAND_NORMAL);\n \n \t/* If this is a constant, put it into a register if it is a\n \t   legitimate constant and memory if it isn't.  */\n@@ -6166,7 +6201,7 @@ expand_expr (exp, target, tmode, modifier)\n \tgoto binop;\n \n       preexpand_calls (exp);\n-      if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1)))\n+      if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n \tsubtarget = 0;\n \n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, ro_modifier);\n@@ -6311,7 +6346,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t       GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))));\n \t}\n \n-      if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1)))\n+      if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n \tsubtarget = 0;\n \n       /* Check for multiplying things that have been extended\n@@ -6394,7 +6429,7 @@ expand_expr (exp, target, tmode, modifier)\n     case ROUND_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n       preexpand_calls (exp);\n-      if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1)))\n+      if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n \tsubtarget = 0;\n       /* Possible optimization: compute the dividend with EXPAND_SUM\n \t then if the divisor is constant can optimize the case\n@@ -6412,7 +6447,7 @@ expand_expr (exp, target, tmode, modifier)\n     case CEIL_MOD_EXPR:\n     case ROUND_MOD_EXPR:\n       preexpand_calls (exp);\n-      if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1)))\n+      if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n \tsubtarget = 0;\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n       op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n@@ -6464,12 +6499,12 @@ expand_expr (exp, target, tmode, modifier)\n \treturn op0;\n \n       return expand_abs (mode, op0, target, unsignedp,\n-\t\t\t safe_from_p (target, TREE_OPERAND (exp, 0)));\n+\t\t\t safe_from_p (target, TREE_OPERAND (exp, 0), 1));\n \n     case MAX_EXPR:\n     case MIN_EXPR:\n       target = original_target;\n-      if (target == 0 || ! safe_from_p (target, TREE_OPERAND (exp, 1))\n+      if (target == 0 || ! safe_from_p (target, TREE_OPERAND (exp, 1), 1)\n \t  || (GET_CODE (target) == MEM && MEM_VOLATILE_P (target))\n \t  || GET_MODE (target) != mode\n \t  || (GET_CODE (target) == REG\n@@ -6584,7 +6619,7 @@ expand_expr (exp, target, tmode, modifier)\n     case LROTATE_EXPR:\n     case RROTATE_EXPR:\n       preexpand_calls (exp);\n-      if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1)))\n+      if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n \tsubtarget = 0;\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n       return expand_shift (code, mode, op0, TREE_OPERAND (exp, 1), target,\n@@ -6632,7 +6667,7 @@ expand_expr (exp, target, tmode, modifier)\n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:\n       if (! ignore\n-\t  && (target == 0 || ! safe_from_p (target, exp)\n+\t  && (target == 0 || ! safe_from_p (target, exp, 1)\n \t      /* Make sure we don't have a hard reg (such as function's return\n \t\t value) live across basic blocks, if not optimizing.  */\n \t      || (!optimize && GET_CODE (target) == REG\n@@ -6760,7 +6795,7 @@ expand_expr (exp, target, tmode, modifier)\n \tif (ignore)\n \t  temp = 0;\n \telse if (original_target\n-\t\t && (safe_from_p (original_target, TREE_OPERAND (exp, 0))\n+\t\t && (safe_from_p (original_target, TREE_OPERAND (exp, 0), 1)\n \t\t     || (singleton && GET_CODE (original_target) == REG\n \t\t\t && REGNO (original_target) >= FIRST_PSEUDO_REGISTER\n \t\t\t && original_target == var_rtx (singleton)))\n@@ -6809,7 +6844,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t= invert_truthvalue (TREE_OPERAND (exp, 0));\n \n \t    result = do_store_flag (TREE_OPERAND (exp, 0),\n-\t\t\t\t    (safe_from_p (temp, singleton)\n+\t\t\t\t    (safe_from_p (temp, singleton, 1)\n \t\t\t\t     ? temp : NULL_RTX),\n \t\t\t\t    mode, BRANCH_COST <= 1);\n \n@@ -6819,7 +6854,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t\t\t  (TREE_OPERAND\n \t\t\t\t\t\t   (binary_op, 1)),\n \t\t\t\t\t\t  0),\n-\t\t\t\t     (safe_from_p (temp, singleton)\n+\t\t\t\t     (safe_from_p (temp, singleton, 1)\n \t\t\t\t      ? temp : NULL_RTX), 0);\n \n \t    if (result)\n@@ -6846,7 +6881,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t   if it is a hard register, because evaluating the condition\n \t\t   might clobber it.  */\n \t\tif ((binary_op\n-\t\t     && ! safe_from_p (temp, TREE_OPERAND (binary_op, 1)))\n+\t\t     && ! safe_from_p (temp, TREE_OPERAND (binary_op, 1), 1))\n \t\t    || (GET_CODE (temp) == REG\n \t\t\t&& REGNO (temp) < FIRST_PSEUDO_REGISTER))\n \t\t  temp = gen_reg_rtx (mode);\n@@ -6887,7 +6922,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t     TREE_OPERAND (exp, 1), 0)\n \t\t && (! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 0))\n \t\t     || TREE_CODE (TREE_OPERAND (exp, 1)) == SAVE_EXPR)\n-\t\t && safe_from_p (temp, TREE_OPERAND (exp, 2)))\n+\t\t && safe_from_p (temp, TREE_OPERAND (exp, 2), 1))\n \t  {\n \t    if (GET_CODE (temp) == REG && REGNO (temp) < FIRST_PSEUDO_REGISTER)\n \t      temp = gen_reg_rtx (mode);\n@@ -6905,7 +6940,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t     TREE_OPERAND (exp, 2), 0)\n \t\t && (! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 0))\n \t\t     || TREE_CODE (TREE_OPERAND (exp, 2)) == SAVE_EXPR)\n-\t\t && safe_from_p (temp, TREE_OPERAND (exp, 1)))\n+\t\t && safe_from_p (temp, TREE_OPERAND (exp, 1), 1))\n \t  {\n \t    if (GET_CODE (temp) == REG && REGNO (temp) < FIRST_PSEUDO_REGISTER)\n \t      temp = gen_reg_rtx (mode);\n@@ -7039,6 +7074,7 @@ expand_expr (exp, target, tmode, modifier)\n \t/* Mark it as expanded.  */\n \tTREE_OPERAND (exp, 1) = NULL_TREE;\n \n+\tTREE_USED (slot) = 1;\n \tstore_expr (exp1, target, 0);\n \n \texpand_decl_cleanup (NULL_TREE, cleanups);\n@@ -7153,7 +7189,8 @@ expand_expr (exp, target, tmode, modifier)\n       /* Are we taking the address of a nested function?  */\n       if (TREE_CODE (TREE_OPERAND (exp, 0)) == FUNCTION_DECL\n \t  && decl_function_context (TREE_OPERAND (exp, 0)) != 0\n-\t  && ! DECL_NO_STATIC_CHAIN (TREE_OPERAND (exp, 0)))\n+\t  && ! DECL_NO_STATIC_CHAIN (TREE_OPERAND (exp, 0))\n+\t  && ! TREE_STATIC (exp))\n \t{\n \t  op0 = trampoline_address (TREE_OPERAND (exp, 0));\n \t  op0 = force_operand (op0, target);\n@@ -7367,7 +7404,7 @@ expand_expr (exp, target, tmode, modifier)\n      from the optab already placed in `this_optab'.  */\n  binop:\n   preexpand_calls (exp);\n-  if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1)))\n+  if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n     subtarget = 0;\n   op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n   op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n@@ -8017,7 +8054,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n     case BUILT_IN_APPLY:\n       if (arglist == 0\n \t  /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n+\t  || ! POINTER_TYPE_P (TREE_TYPE (TREE_VALUE (arglist)))\n \t  || TREE_CHAIN (arglist) == 0\n \t  || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != POINTER_TYPE\n \t  || TREE_CHAIN (TREE_CHAIN (arglist)) == 0\n@@ -10600,7 +10637,7 @@ do_store_flag (exp, target, mode, only_cheap)\n \n       if (subtarget == 0 || GET_CODE (subtarget) != REG\n \t  || GET_MODE (subtarget) != operand_mode\n-\t  || ! safe_from_p (subtarget, inner))\n+\t  || ! safe_from_p (subtarget, inner, 1))\n \tsubtarget = 0;\n \n       op0 = expand_expr (inner, subtarget, VOIDmode, 0);\n@@ -10650,7 +10687,7 @@ do_store_flag (exp, target, mode, only_cheap)\n   preexpand_calls (exp);\n   if (subtarget == 0 || GET_CODE (subtarget) != REG\n       || GET_MODE (subtarget) != operand_mode\n-      || ! safe_from_p (subtarget, arg1))\n+      || ! safe_from_p (subtarget, arg1, 1))\n     subtarget = 0;\n \n   op0 = expand_expr (arg0, subtarget, VOIDmode, 0);"}, {"sha": "b19c170cc8bce840383f3c69e6eb43ad40acf56d", "filename": "gcc/expr.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for code generation pass of GNU compiler.\n-   Copyright (C) 1987, 91-96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 91-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -138,7 +138,7 @@ extern int target_temp_slot_level;\n \n struct args_size\n {\n-  int constant;\n+  HOST_WIDE_INT constant;\n   tree var;\n };\n #endif\n@@ -200,6 +200,11 @@ enum direction {none, upward, downward};  /* Value has this type.  */\n #define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\tPARM_BOUNDARY\n #endif\n \n+/* Provide a default value for STRICT_ARGUMENT_NAMING.  */\n+#ifndef STRICT_ARGUMENT_NAMING\n+#define STRICT_ARGUMENT_NAMING 0\n+#endif\n+\n /* Nonzero if we do not know how to pass TYPE solely in registers.\n    We cannot do so in the following cases:\n \n@@ -729,7 +734,7 @@ extern rtx gen_push_operand PROTO((void));\n #ifdef TREE_CODE\n /* Generate code to push something onto the stack, given its mode and type.  */\n extern void emit_push_insn PROTO((rtx, enum machine_mode, tree, rtx, int,\n-\t\t\t\t  int, rtx, int, rtx, rtx));\n+\t\t\t\t  int, rtx, int, rtx, rtx, int));\n \n /* Emit library call.  */\n extern void emit_library_call PVPROTO((rtx orgfun, int no_queue,"}, {"sha": "f7598b84d3c252e3ea70c5936006eb7059f91138", "filename": "gcc/extend.texi", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -2726,16 +2726,17 @@ In addition, operating systems on one type of cpu may differ in how they\n name the registers; then you would need additional conditionals.  For\n example, some 68000 operating systems call this register @code{%a5}.\n \n-Eventually there may be a way of asking the compiler to choose a register\n-automatically, but first we need to figure out how it should choose and\n-how to enable you to guide the choice.  No solution is evident.\n-\n Defining such a register variable does not reserve the register; it\n remains available for other uses in places where flow control determines\n the variable's value is not live.  However, these registers are made\n-unavailable for use in the reload pass.  I would not be surprised if\n-excessive use of this feature leaves the compiler too few available\n-registers to compile certain functions.\n+unavailable for use in the reload pass; excessive use of this feature\n+leaves the compiler too few available registers to compile certain\n+functions.\n+\n+This option does not guarantee that GNU CC will generate code that has\n+this variable in the register you specify at all times.  You may not\n+code an explicit reference to this register in an @code{asm} statement\n+and assume it will always refer to this variable.\n \n @node Alternate Keywords\n @section Alternate Keywords"}, {"sha": "12e39830784d0d4961d34f4850614cb0ba3cb2a1", "filename": "gcc/final.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Convert RTL to assembler code and output it, for GNU compiler.\n-   Copyright (C) 1987, 88, 89, 92-7, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -3825,11 +3825,16 @@ only_leaf_regs_used ()\n   int i;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      if ((regs_ever_live[i] || global_regs[i])\n-\t  && ! permitted_reg_in_leaf_functions[i])\n-\treturn 0;\n-    }\n+    if ((regs_ever_live[i] || global_regs[i])\n+\t&& ! permitted_reg_in_leaf_functions[i])\n+      return 0;\n+\n+  if (current_function_uses_pic_offset_table\n+      && pic_offset_table_rtx != 0\n+      && GET_CODE (pic_offset_table_rtx) == REG\n+      && ! permitted_reg_in_leaf_functions[REGNO (pic_offset_table_rtx)])\n+    return 0;\n+\n   return 1;\n }\n "}, {"sha": "08c857f73d57e00d3a29c1784f68f00732e3010d", "filename": "gcc/fixincludes", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ffixincludes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ffixincludes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixincludes?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -252,9 +252,10 @@ while [ $# != 0 ]; do\n # But the argument to egrep must be kept small, or many versions of egrep\n # won't be able to handle it.\n #\n-# We use the pattern [!-.0-~] instead of [^/ \t] to match a noncomment\n+# We use the pattern [!-.0-z{|}~] instead of [^/ \t] to match a noncomment\n # following #else or #endif because some buggy egreps think [^/] matches\n # newline, and they thus think `#else ' matches `#e[ndiflse]*[ \t]+[^/ \t]'.\n+# [!-.0-~] does not work properly on AIX 4.1.\n #\n # We use the pattern [^a-zA-Z0-9_][_a-ce-km-z][a-z0-9] to match an identifier\n # following #if or #elif that is not surrounded by __.  The `a-ce-km-z'\n@@ -263,7 +264,7 @@ while [ $# != 0 ]; do\n # identifiers below start with `d' or `l'.  It also greatly improves\n # performance, since many files contain lines of the form `#if ... defined ...'\n # or `#if lint'.\n-    if egrep '//|[ \t_]_IO|CTRL|^#define.NULL|^#e[nl][ds][ief]*[ \t]+[!-.0-~]|^#[el]*if.*[^a-zA-Z0-9_][_a-ce-km-zA-Z][a-zA-Z0-9]' $file >/dev/null; then\n+    if egrep '//|[ \t_]_IO|CTRL|^#define.NULL|^#e[nl][ds][ief]*[ \t]+[!-.0-z\\{\\|\\}\\~]|^#[el]*if.*[^a-zA-Z0-9_][_a-ce-km-zA-Z][a-zA-Z0-9]' $file >/dev/null; then\n       if [ -r $file ]; then\n \tcp $file $2/$file >/dev/null 2>&1\t\\\n \t|| echo \"Can't copy $file\"\n@@ -922,17 +923,21 @@ fi\n \n if [ -r ${LIB}/$file ]; then\n   echo Fixing $file\n+  if grep _GCC_SIZE_T ${LIB}/$file >/dev/null\n+  then size_t_pattern='<<< do not double-wrap the size_t typedef >>>'\n+  else size_t_pattern='typedef[ \ta-zA-Z_]*[ \t]size_t[ \t]*;'\n+  fi\n   sed -e 's/int\tabort/void\tabort/g' \\\n   -e 's/int\tfree/void\tfree/g' \\\n   -e 's/char[ \t]*\\*[ \t]*calloc/void \\*\tcalloc/g' \\\n   -e 's/char[ \t]*\\*[ \t]*malloc/void \\*\tmalloc/g' \\\n   -e 's/char[ \t]*\\*[ \t]*realloc/void \\*\trealloc/g' \\\n   -e 's/int[ \t][ \t]*exit/void\texit/g' \\\n-  -e '/typedef[ \ta-zA-Z_]*[ \t]size_t[ \t]*;/i\\\n+  -e \"/$size_t_pattern/\"'i\\\n #ifndef _GCC_SIZE_T\\\n #define _GCC_SIZE_T\n ' \\\n-  -e '/typedef[ \ta-zA-Z_]*[ \t]size_t[ \t]*;/a\\\n+  -e \"/$size_t_pattern/\"'a\\\n #endif\n ' \\\n       ${LIB}/$file > ${LIB}/${file}.sed\n@@ -1856,6 +1861,7 @@ fi\n # comment.  Fortunately, HP/UX already uses #ifndefs in limits.h; if\n # we find a #ifndef FLT_MIN we assume that all the required #ifndefs\n # are there, and we do not add them ourselves.\n+# Also fix a nested comment problem in sys/limits.h on Motorola sysV68 R3V7.1\n for file in limits.h sys/limits.h; do\n   if [ -r $file ] && [ ! -r ${LIB}/$file ]; then\n     mkdir ${LIB}/sys 2>/dev/null\n@@ -1905,6 +1911,7 @@ for file in limits.h sys/limits.h; do\n \t  -e '/[ \t]DBL_DIG[ \t]/a\\\n #endif\n '\\\n+\t  -e '/^\\(\\/\\*#define\tHUGE_VAL\t3\\.[0-9e+]* *\\)\\/\\*/s//\\1/'\\\n \t${LIB}/$file > ${LIB}/${file}.sed\n       rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file\n     fi\n@@ -2871,7 +2878,7 @@ if [ -r ${LIB}/$file ]; then\n fi\n \n # sys/lc_core.h on some versions of OSF1/4.x pollutes the namespace by\n-# defining regex.h related types.  This causes libg++ build and usage failures.\n+# defining regex.h types.  This causes C++ library build and usage failures.\n # Fixing this correctly requires checking and modifying 3 files.\n for file in reg_types.h regex.h sys/lc_core.h; do\n   if [ -r $file ] && [ ! -r ${LIB}/$file ]; then"}, {"sha": "a304a915d622d7ca9ba26164523ec47e660f9a8e", "filename": "gcc/flow.c", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1853,13 +1853,15 @@ insn_dead_p (x, needed, call_ok)\n      regset needed;\n      int call_ok;\n {\n-  register RTX_CODE code = GET_CODE (x);\n+  enum rtx_code code = GET_CODE (x);\n+\n   /* If setting something that's a reg or part of one,\n      see if that register's altered value will be live.  */\n \n   if (code == SET)\n     {\n-      register rtx r = SET_DEST (x);\n+      rtx r = SET_DEST (x);\n+\n       /* A SET that is a subroutine call cannot be dead.  */\n       if (! call_ok && GET_CODE (SET_SRC (x)) == CALL)\n \treturn 0;\n@@ -1873,15 +1875,13 @@ insn_dead_p (x, needed, call_ok)\n \t  && rtx_equal_p (r, last_mem_set))\n \treturn 1;\n \n-      while (GET_CODE (r) == SUBREG\n-\t     || GET_CODE (r) == STRICT_LOW_PART\n-\t     || GET_CODE (r) == ZERO_EXTRACT\n-\t     || GET_CODE (r) == SIGN_EXTRACT)\n+      while (GET_CODE (r) == SUBREG || GET_CODE (r) == STRICT_LOW_PART\n+\t     || GET_CODE (r) == ZERO_EXTRACT)\n \tr = SUBREG_REG (r);\n \n       if (GET_CODE (r) == REG)\n \t{\n-\t  register int regno = REGNO (r);\n+\t  int regno = REGNO (r);\n \n \t  /* Don't delete insns to set global regs.  */\n \t  if ((regno < FIRST_PSEUDO_REGISTER && global_regs[regno])\n@@ -1913,26 +1913,33 @@ insn_dead_p (x, needed, call_ok)\n \t  return 1;\n \t}\n     }\n+\n   /* If performing several activities,\n      insn is dead if each activity is individually dead.\n      Also, CLOBBERs and USEs can be ignored; a CLOBBER or USE\n      that's inside a PARALLEL doesn't make the insn worth keeping.  */\n   else if (code == PARALLEL)\n     {\n-      register int i = XVECLEN (x, 0);\n+      int i = XVECLEN (x, 0);\n+\n       for (i--; i >= 0; i--)\n-\t{\n-\t  rtx elt = XVECEXP (x, 0, i);\n-\t  if (!insn_dead_p (elt, needed, call_ok)\n-\t      && GET_CODE (elt) != CLOBBER\n-\t      && GET_CODE (elt) != USE)\n-\t    return 0;\n-\t}\n+\tif (GET_CODE (XVECEXP (x, 0, i)) != CLOBBER\n+\t    && GET_CODE (XVECEXP (x, 0, i)) != USE\n+\t    && ! insn_dead_p (XVECEXP (x, 0, i), needed, call_ok))\n+\t  return 0;\n+\n       return 1;\n     }\n-  /* We do not check CLOBBER or USE here.\n-     An insn consisting of just a CLOBBER or just a USE\n-     should not be deleted.  */\n+\n+  /* A CLOBBER of a pseudo-register that is dead serves no purpose.  That\n+     is not necessarily true for hard registers.  */\n+  else if (code == CLOBBER && GET_CODE (XEXP (x, 0)) == REG\n+\t   && REGNO (XEXP (x, 0)) >= FIRST_PSEUDO_REGISTER\n+\t   && ! REGNO_REG_SET_P (needed, REGNO (XEXP (x, 0))))\n+    return 1;\n+\n+  /* We do not check other CLOBBER or USE here.  An insn consisting of just\n+     a CLOBBER or just a USE should not be deleted.  */\n   return 0;\n }\n "}, {"sha": "648dc3b81b3f3755819d1fc09ee9447f48b2b8b9", "filename": "gcc/fold-const.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -176,7 +176,7 @@ force_fit_type (t, overflow)\n   low = TREE_INT_CST_LOW (t);\n   high = TREE_INT_CST_HIGH (t);\n \n-  if (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE)\n+  if (POINTER_TYPE_P (TREE_TYPE (t)))\n     prec = POINTER_SIZE;\n   else\n     prec = TYPE_PRECISION (TREE_TYPE (t));\n@@ -1499,7 +1499,7 @@ fold_convert (t, arg1)\n   register tree type = TREE_TYPE (t);\n   int overflow = 0;\n \n-  if (TREE_CODE (type) == POINTER_TYPE || INTEGRAL_TYPE_P (type))\n+  if (POINTER_TYPE_P (type) || INTEGRAL_TYPE_P (type))\n     {\n       if (TREE_CODE (arg1) == INTEGER_CST)\n \t{\n@@ -1519,12 +1519,12 @@ fold_convert (t, arg1)\n \t     if ARG1 is a too-large unsigned value and T is signed.\n \t     But don't indicate an overflow if converting a pointer.  */\n \t  TREE_OVERFLOW (t)\n-\t    = (TREE_OVERFLOW (arg1)\n-\t       || (force_fit_type (t,\n-\t\t\t\t  (TREE_INT_CST_HIGH (arg1) < 0\n-\t\t\t\t   && (TREE_UNSIGNED (type)\n-\t\t\t\t     < TREE_UNSIGNED (TREE_TYPE (arg1)))))\n-\t\t   && TREE_CODE (TREE_TYPE (arg1)) != POINTER_TYPE));\n+\t    = ((force_fit_type (t,\n+\t\t\t\t(TREE_INT_CST_HIGH (arg1) < 0\n+\t\t\t\t & (TREE_UNSIGNED (type)\n+\t\t\t\t    < TREE_UNSIGNED (TREE_TYPE (arg1)))))\n+\t\t&& ! POINTER_TYPE_P (TREE_TYPE (arg1)))\n+\t       || TREE_OVERFLOW (arg1));\n \t  TREE_CONSTANT_OVERFLOW (t)\n \t    = TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg1);\n \t}\n@@ -5128,7 +5128,7 @@ fold (expr)\n \t       if CONST+INCR overflows or if foo+incr might overflow.\n \t       This optimization is invalid for floating point due to rounding.\n \t       For pointer types we assume overflow doesn't happen.  */\n-\t    if (TREE_CODE (TREE_TYPE (varop)) == POINTER_TYPE\n+\t    if (POINTER_TYPE_P (TREE_TYPE (varop))\n \t\t|| (! FLOAT_TYPE_P (TREE_TYPE (varop))\n \t\t    && (code == EQ_EXPR || code == NE_EXPR)))\n \t      {\n@@ -5163,7 +5163,7 @@ fold (expr)\n \t  }\n \telse if (constop && TREE_CODE (varop) == POSTDECREMENT_EXPR)\n \t  {\n-\t    if (TREE_CODE (TREE_TYPE (varop)) == POINTER_TYPE\n+\t    if (POINTER_TYPE_P (TREE_TYPE (varop))\n \t\t|| (! FLOAT_TYPE_P (TREE_TYPE (varop))\n \t\t    && (code == EQ_EXPR || code == NE_EXPR)))\n \t      {\n@@ -5357,7 +5357,7 @@ fold (expr)\n       /* An unsigned comparison against 0 can be simplified.  */\n       if (integer_zerop (arg1)\n \t  && (INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n-\t      || TREE_CODE (TREE_TYPE (arg1)) == POINTER_TYPE)\n+\t      || POINTER_TYPE_P (TREE_TYPE (arg1)))\n \t  && TREE_UNSIGNED (TREE_TYPE (arg1)))\n \t{\n \t  switch (TREE_CODE (t))\n@@ -5392,7 +5392,7 @@ fold (expr)\n \t    && TREE_INT_CST_LOW (arg1) == ((HOST_WIDE_INT) 1 << (width - 1)) - 1\n \t    && TREE_INT_CST_HIGH (arg1) == 0\n \t    && (INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n-\t\t|| TREE_CODE (TREE_TYPE (arg1)) == POINTER_TYPE)\n+\t\t|| POINTER_TYPE_P (TREE_TYPE (arg1)))\n \t    && TREE_UNSIGNED (TREE_TYPE (arg1)))\n \t  {\n \t    switch (TREE_CODE (t))"}, {"sha": "873c430baf5f1eb6199935f3febd048f8010b839", "filename": "gcc/function.c", "status": "modified", "additions": 119, "deletions": 63, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -360,7 +360,7 @@ struct temp_slot\n      slot above.  May be an EXPR_LIST if multiple addresses exist.  */\n   rtx address;\n   /* The size, in units, of the slot.  */\n-  int size;\n+  HOST_WIDE_INT size;\n   /* The value of `sequence_rtl_expr' when this temporary is allocated.  */\n   tree rtl_expr;\n   /* Non-zero if this temporary is currently in use.  */\n@@ -373,10 +373,10 @@ struct temp_slot\n   int keep;\n   /* The offset of the slot from the frame_pointer, including extra space\n      for alignment.  This info is for combine_temp_slots.  */\n-  int base_offset;\n+  HOST_WIDE_INT base_offset;\n   /* The size of the slot, including extra space for alignment.  This\n      info is for combine_temp_slots.  */\n-  int full_size;\n+  HOST_WIDE_INT full_size;\n };\n \n /* List of all temporaries allocated, both available and in use.  */\n@@ -386,6 +386,10 @@ struct temp_slot *temp_slots;\n /* Current nesting level for temporaries.  */\n \n int temp_slot_level;\n+\n+/* Current nesting level for variables in a block.  */\n+\n+int var_temp_slot_level;\n \f\n /* This structure is used to record MEMs or pseudos used to replace VAR, any\n    SUBREGs of VAR, and any MEMs containing VAR as an address.  We need to\n@@ -404,7 +408,7 @@ struct fixup_replacement\n static struct temp_slot *find_temp_slot_from_address  PROTO((rtx));\n static void put_reg_into_stack\tPROTO((struct function *, rtx, tree,\n \t\t\t\t       enum machine_mode, enum machine_mode,\n-\t\t\t\t       int, int));\n+\t\t\t\t       int, int, int));\n static void fixup_var_refs\tPROTO((rtx, enum machine_mode, int));\n static struct fixup_replacement\n   *find_fixup_replacement\tPROTO((struct fixup_replacement **, rtx));\n@@ -448,9 +452,11 @@ find_function_data (decl)\n      tree decl;\n {\n   struct function *p;\n+\n   for (p = outer_function_chain; p; p = p->next)\n     if (p->decl == decl)\n       return p;\n+\n   abort ();\n }\n \n@@ -513,6 +519,8 @@ push_function_context_to (context)\n   p->function_call_count = function_call_count;\n   p->temp_slots = temp_slots;\n   p->temp_slot_level = temp_slot_level;\n+  p->target_temp_slot_level = target_temp_slot_level;\n+  p->var_temp_slot_level = var_temp_slot_level;\n   p->fixup_var_refs_queue = 0;\n   p->epilogue_delay_list = current_function_epilogue_delay_list;\n   p->args_info = current_function_args_info;\n@@ -523,9 +531,10 @@ push_function_context_to (context)\n   save_expr_status (p);\n   save_stmt_status (p);\n   save_varasm_status (p, context);\n-\n   if (save_machine_status)\n     (*save_machine_status) (p);\n+\n+  init_emit ();\n }\n \n void\n@@ -542,6 +551,7 @@ pop_function_context_from (context)\n      tree context;\n {\n   struct function *p = outer_function_chain;\n+  struct var_refs_queue *queue;\n \n   outer_function_chain = p->next;\n \n@@ -592,6 +602,8 @@ pop_function_context_from (context)\n   function_call_count = p->function_call_count;\n   temp_slots = p->temp_slots;\n   temp_slot_level = p->temp_slot_level;\n+  target_temp_slot_level = p->target_temp_slot_level;\n+  var_temp_slot_level = p->var_temp_slot_level;\n   current_function_epilogue_delay_list = p->epilogue_delay_list;\n   reg_renumber = 0;\n   current_function_args_info = p->args_info;\n@@ -608,11 +620,8 @@ pop_function_context_from (context)\n \n   /* Finish doing put_var_into_stack for any of our variables\n      which became addressable during the nested function.  */\n-  {\n-    struct var_refs_queue *queue = p->fixup_var_refs_queue;\n-    for (; queue; queue = queue->next)\n-      fixup_var_refs (queue->modified, queue->promoted_mode, queue->unsignedp);\n-  }\n+  for (queue = p->fixup_var_refs_queue; queue; queue = queue->next)\n+    fixup_var_refs (queue->modified, queue->promoted_mode, queue->unsignedp);\n \n   free (p);\n \n@@ -655,7 +664,7 @@ get_frame_size ()\n rtx\n assign_stack_local (mode, size, align)\n      enum machine_mode mode;\n-     int size;\n+     HOST_WIDE_INT size;\n      int align;\n {\n   register rtx x, addr;\n@@ -724,7 +733,7 @@ assign_stack_local (mode, size, align)\n rtx\n assign_outer_stack_local (mode, size, align, function)\n      enum machine_mode mode;\n-     int size;\n+     HOST_WIDE_INT size;\n      int align;\n      struct function *function;\n {\n@@ -792,13 +801,15 @@ assign_outer_stack_local (mode, size, align, function)\n \n    KEEP is 1 if this slot is to be retained after a call to\n    free_temp_slots.  Automatic variables for a block are allocated\n-   with this flag.  KEEP is 2, if we allocate a longer term temporary,\n-   whose lifetime is controlled by CLEANUP_POINT_EXPRs.  */\n+   with this flag.  KEEP is 2 if we allocate a longer term temporary,\n+   whose lifetime is controlled by CLEANUP_POINT_EXPRs.  KEEP is 3\n+   if we are to allocate something at an inner level to be treated as\n+   a variable in the block (e.g., a SAVE_EXPR).  */\n \n rtx\n assign_stack_temp (mode, size, keep)\n      enum machine_mode mode;\n-     int size;\n+     HOST_WIDE_INT size;\n      int keep;\n {\n   struct temp_slot *p, *best_p = 0;\n@@ -831,7 +842,7 @@ assign_stack_temp (mode, size, keep)\n       if (GET_MODE (best_p->slot) == BLKmode)\n \t{\n \t  int alignment = BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n-\t  int rounded_size = CEIL_ROUND (size, alignment);\n+\t  HOST_WIDE_INT rounded_size = CEIL_ROUND (size, alignment);\n \n \t  if (best_p->size - rounded_size >= alignment)\n \t    {\n@@ -862,11 +873,14 @@ assign_stack_temp (mode, size, keep)\n   /* If we still didn't find one, make a new temporary.  */\n   if (p == 0)\n     {\n-      int frame_offset_old = frame_offset;\n+      HOST_WIDE_INT frame_offset_old = frame_offset;\n+\n       p = (struct temp_slot *) oballoc (sizeof (struct temp_slot));\n+\n       /* If the temp slot mode doesn't indicate the alignment,\n \t use the largest possible, so no one will be disappointed.  */\n       p->slot = assign_stack_local (mode, size, mode == BLKmode ? -1 : 0);\n+\n       /* The following slot size computation is necessary because we don't\n \t know the actual size of the temporary slot until assign_stack_local\n \t has performed all the frame alignment and size rounding for the\n@@ -879,6 +893,7 @@ assign_stack_temp (mode, size, keep)\n #else\n       p->size = size;\n #endif\n+\n       /* Now define the fields used by combine_temp_slots.  */\n #ifdef FRAME_GROWS_DOWNWARD\n       p->base_offset = frame_offset;\n@@ -901,6 +916,11 @@ assign_stack_temp (mode, size, keep)\n       p->level = target_temp_slot_level;\n       p->keep = 0;\n     }\n+  else if (keep == 3)\n+    {\n+      p->level = var_temp_slot_level;\n+      p->keep = 0;\n+    }\n   else\n     {\n       p->level = temp_slot_level;\n@@ -933,7 +953,7 @@ assign_temp (type, keep, memory_required, dont_promote)\n \n   if (mode == BLKmode || memory_required)\n     {\n-      int size = int_size_in_bytes (type);\n+      HOST_WIDE_INT size = int_size_in_bytes (type);\n       rtx tmp;\n \n       /* Unfortunately, we don't yet know how to allocate variable-sized\n@@ -969,12 +989,19 @@ combine_temp_slots ()\n {\n   struct temp_slot *p, *q;\n   struct temp_slot *prev_p, *prev_q;\n-  /* Determine where to free back to after this function.  */\n-  rtx free_pointer = rtx_alloc (CONST_INT);\n+  int num_slots;\n+\n+  /* If there are a lot of temp slots, don't do anything unless \n+     high levels of optimizaton.  */\n+  if (! flag_expensive_optimizations)\n+    for (p = temp_slots, num_slots = 0; p; p = p->next, num_slots++)\n+      if (num_slots > 100 || (num_slots > 10 && optimize == 0))\n+\treturn;\n \n   for (p = temp_slots, prev_p = 0; p; p = prev_p ? prev_p->next : temp_slots)\n     {\n       int delete_p = 0;\n+\n       if (! p->in_use && GET_MODE (p->slot) == BLKmode)\n \tfor (q = p->next, prev_q = p; q; q = prev_q->next)\n \t  {\n@@ -1014,9 +1041,6 @@ combine_temp_slots ()\n       else\n \tprev_p = p;\n     }\n-\n-  /* Free all the RTL made by plus_constant.  */ \n-  rtx_free (free_pointer);\n }\n \f\n /* Find the temp slot corresponding to the object at address X.  */\n@@ -1032,6 +1056,7 @@ find_temp_slot_from_address (x)\n     {\n       if (! p->in_use)\n \tcontinue;\n+\n       else if (XEXP (p->slot, 0) == x\n \t       || p->address == x\n \t       || (GET_CODE (x) == PLUS\n@@ -1051,7 +1076,7 @@ find_temp_slot_from_address (x)\n }\n       \n /* Indicate that NEW is an alternate way of referring to the temp slot\n-   that previous was known by OLD.  */\n+   that previously was known by OLD.  */\n \n void\n update_temp_slot_address (old, new)\n@@ -1254,6 +1279,17 @@ push_temp_slots ()\n   temp_slot_level++;\n }\n \n+/* Likewise, but save the new level as the place to allocate variables\n+   for blocks.  */\n+\n+void\n+push_temp_slots_for_block ()\n+{\n+  push_temp_slots ();\n+\n+  var_temp_slot_level = temp_slot_level;\n+}\n+\n /* Pop a temporary nesting level.  All slots in use in the current level\n    are freed.  */\n \n@@ -1279,6 +1315,7 @@ init_temp_slots ()\n   /* We have not allocated any temporaries yet.  */\n   temp_slots = 0;\n   temp_slot_level = 0;\n+  var_temp_slot_level = 0;\n   target_temp_slot_level = 0;\n }\n \f\n@@ -1332,6 +1369,7 @@ put_var_into_stack (decl)\n \n   can_use_addressof\n     = (function == 0\n+       && optimize > 0\n        /* FIXME make it work for promoted modes too */\n        && decl_mode == promoted_mode\n #ifdef NON_SAVING_SETJMP\n@@ -1357,7 +1395,9 @@ put_var_into_stack (decl)\n       else\n \tput_reg_into_stack (function, reg, TREE_TYPE (decl),\n \t\t\t    promoted_mode, decl_mode,\n-\t\t\t    TREE_SIDE_EFFECTS (decl), 0);\n+\t\t\t    TREE_SIDE_EFFECTS (decl), 0,\n+\t\t\t    TREE_USED (decl)\n+\t\t\t    || DECL_INITIAL (decl) != 0);\n     }\n   else if (GET_CODE (reg) == CONCAT)\n     {\n@@ -1368,14 +1408,18 @@ put_var_into_stack (decl)\n #ifdef FRAME_GROWS_DOWNWARD\n       /* Since part 0 should have a lower address, do it second.  */\n       put_reg_into_stack (function, XEXP (reg, 1), part_type, part_mode,\n-\t\t\t  part_mode, TREE_SIDE_EFFECTS (decl), 0);\n+\t\t\t  part_mode, TREE_SIDE_EFFECTS (decl), 0,\n+\t\t\t  TREE_USED (decl) || DECL_INITIAL (decl) != 0);\n       put_reg_into_stack (function, XEXP (reg, 0), part_type, part_mode,\n-\t\t\t  part_mode, TREE_SIDE_EFFECTS (decl), 0);\n+\t\t\t  part_mode, TREE_SIDE_EFFECTS (decl), 0,\n+\t\t\t  TREE_USED (decl) || DECL_INITIAL (decl) != 0);\n #else\n       put_reg_into_stack (function, XEXP (reg, 0), part_type, part_mode,\n-\t\t\t  part_mode, TREE_SIDE_EFFECTS (decl), 0);\n+\t\t\t  part_mode, TREE_SIDE_EFFECTS (decl), 0,\n+\t\t\t  TREE_USED (decl) || DECL_INITIAL (decl) != 0);\n       put_reg_into_stack (function, XEXP (reg, 1), part_type, part_mode,\n-\t\t\t  part_mode, TREE_SIDE_EFFECTS (decl), 0);\n+\t\t\t  part_mode, TREE_SIDE_EFFECTS (decl), 0,\n+\t\t\t  TREE_USED (decl) || DECL_INITIAL (decl) != 0);\n #endif\n \n       /* Change the CONCAT into a combined MEM for both parts.  */\n@@ -1405,17 +1449,19 @@ put_var_into_stack (decl)\n    into the stack frame of FUNCTION (0 means the current function).\n    DECL_MODE is the machine mode of the user-level data type.\n    PROMOTED_MODE is the machine mode of the register.\n-   VOLATILE_P is nonzero if this is for a \"volatile\" decl.  */\n+   VOLATILE_P is nonzero if this is for a \"volatile\" decl.\n+   USED_P is nonzero if this reg might have already been used in an insn.  */\n \n static void\n put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n-\t\t    original_regno)\n+\t\t    original_regno, used_p)\n      struct function *function;\n      rtx reg;\n      tree type;\n      enum machine_mode promoted_mode, decl_mode;\n      int volatile_p;\n      int original_regno;\n+     int used_p;\n {\n   rtx new = 0;\n   int regno = original_regno;\n@@ -1454,7 +1500,8 @@ put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n \n   /* Now make sure that all refs to the variable, previously made\n      when it was a register, are fixed up to be valid again.  */\n-  if (function)\n+\n+  if (used_p && function != 0)\n     {\n       struct var_refs_queue *temp;\n \n@@ -1473,7 +1520,7 @@ put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n       function->fixup_var_refs_queue = temp;\n       pop_obstacks ();\n     }\n-  else\n+  else if (used_p)\n     /* Variable is local; fix it up now.  */\n     fixup_var_refs (reg, promoted_mode, TREE_UNSIGNED (type));\n }\n@@ -1561,7 +1608,9 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel)\n   while (insn)\n     {\n       rtx next = NEXT_INSN (insn);\n+      rtx set, prev, prev_set;\n       rtx note;\n+\n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t{\n \t  /* If this is a CLOBBER of VAR, delete it.\n@@ -1587,14 +1636,22 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel)\n \t    }\n \n \t  /* The insn to load VAR from a home in the arglist\n-\t     is now a no-op.  When we see it, just delete it.  */\n+\t     is now a no-op.  When we see it, just delete it.\n+\t     Similarly if this is storing VAR from a register from which\n+\t     it was loaded in the previous insn.  This will occur\n+\t     when an ADDRESSOF was made for an arglist slot.  */\n \t  else if (toplevel\n-\t\t   && GET_CODE (PATTERN (insn)) == SET\n-\t\t   && SET_DEST (PATTERN (insn)) == var\n+\t\t   && (set = single_set (insn)) != 0\n+\t\t   && SET_DEST (set) == var\n \t\t   /* If this represents the result of an insn group,\n \t\t      don't delete the insn.  */\n \t\t   && find_reg_note (insn, REG_RETVAL, NULL_RTX) == 0\n-\t\t   && rtx_equal_p (SET_SRC (PATTERN (insn)), var))\n+\t\t   && (rtx_equal_p (SET_SRC (set), var)\n+\t\t       || (GET_CODE (SET_SRC (set)) == REG\n+\t\t\t   && (prev = prev_nonnote_insn (insn)) != 0\n+\t\t\t   && (prev_set = single_set (prev)) != 0\n+\t\t\t   && SET_DEST (prev_set) == SET_SRC (set)\n+\t\t\t   && rtx_equal_p (SET_SRC (prev_set), var))))\n \t    {\n \t      /* In unoptimized compilation, we shouldn't call delete_insn\n \t\t except in jump.c doing warnings.  */\n@@ -1862,7 +1919,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t    {\n \t      enum machine_mode wanted_mode = VOIDmode;\n \t      enum machine_mode is_mode = GET_MODE (tem);\n-\t      int pos = INTVAL (XEXP (x, 2));\n+\t      HOST_WIDE_INT pos = INTVAL (XEXP (x, 2));\n \n #ifdef HAVE_extzv\n \t      if (GET_CODE (x) == ZERO_EXTRACT)\n@@ -1876,7 +1933,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t      if (wanted_mode != VOIDmode\n \t\t  && GET_MODE_SIZE (wanted_mode) < GET_MODE_SIZE (is_mode))\n \t\t{\n-\t\t  int offset = pos / BITS_PER_UNIT;\n+\t\t  HOST_WIDE_INT offset = pos / BITS_PER_UNIT;\n \t\t  rtx old_pos = XEXP (x, 2);\n \t\t  rtx newmem;\n \n@@ -2062,12 +2119,12 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t\tenum machine_mode wanted_mode\n \t\t  = insn_operand_mode[(int) CODE_FOR_insv][0];\n \t\tenum machine_mode is_mode = GET_MODE (tem);\n-\t\tint pos = INTVAL (XEXP (outerdest, 2));\n+\t\tHOST_WIDE_INT pos = INTVAL (XEXP (outerdest, 2));\n \n \t\t/* If we have a narrower mode, we can do something.  */\n \t\tif (GET_MODE_SIZE (wanted_mode) < GET_MODE_SIZE (is_mode))\n \t\t  {\n-\t\t    int offset = pos / BITS_PER_UNIT;\n+\t\t    HOST_WIDE_INT offset = pos / BITS_PER_UNIT;\n \t\t    rtx old_pos = XEXP (outerdest, 2);\n \t\t    rtx newmem;\n \n@@ -2472,7 +2529,7 @@ optimize_bit_field (body, insn, equiv_mem)\n \t     that we are now getting rid of,\n \t     and then for which byte of the word is wanted.  */\n \n-\t  register int offset = INTVAL (XEXP (bitfield, 2));\n+\t  HOST_WIDE_INT offset = INTVAL (XEXP (bitfield, 2));\n \t  rtx insns;\n \n \t  /* Adjust OFFSET to count bits from low-address byte.  */\n@@ -2638,7 +2695,9 @@ gen_mem_addressof (reg, decl)\n   MEM_VOLATILE_P (reg) = TREE_SIDE_EFFECTS (decl);\n   MEM_IN_STRUCT_P (reg) = AGGREGATE_TYPE_P (type);\n \n-  fixup_var_refs (reg, GET_MODE (reg), TREE_UNSIGNED (type));\n+  if (TREE_USED (decl) || DECL_INITIAL (decl) != 0)\n+    fixup_var_refs (reg, GET_MODE (reg), TREE_UNSIGNED (type));\n+\n   return reg;\n }\n \n@@ -2670,7 +2729,8 @@ put_addressof_into_stack (r)\n \n   put_reg_into_stack (0, reg, TREE_TYPE (decl), GET_MODE (reg),\n \t\t      DECL_MODE (decl), TREE_SIDE_EFFECTS (decl),\n-\t\t      ADDRESSOF_REGNO (r));\n+\t\t      ADDRESSOF_REGNO (r),\n+\t\t      TREE_USED (decl) || DECL_INITIAL (decl) != 0);\n }\n \n /* Helper function for purge_addressof.  See if the rtx expression at *LOC\n@@ -2721,9 +2781,16 @@ purge_addressof_1 (loc, insn, force)\n   else if (code == MEM && GET_CODE (XEXP (x, 0)) == ADDRESSOF && ! force)\n     {\n       rtx sub = XEXP (XEXP (x, 0), 0);\n+\n       if (GET_CODE (sub) == MEM)\n \tsub = gen_rtx_MEM (GET_MODE (x), copy_rtx (XEXP (sub, 0)));\n-      if (GET_CODE (sub) == REG && GET_MODE (x) != GET_MODE (sub))\n+\n+      if (GET_CODE (sub) == REG && MEM_VOLATILE_P (x))\n+\t{\n+\t  put_addressof_into_stack (XEXP (x, 0));\n+\t  return;\n+\t}\n+      else if (GET_CODE (sub) == REG && GET_MODE (x) != GET_MODE (sub))\n \t{\n \t  if (! BYTES_BIG_ENDIAN && ! WORDS_BIG_ENDIAN)\n \t    {\n@@ -2847,7 +2914,8 @@ instantiate_decls (fndecl, valid_only)\n   /* Process all parameters of the function.  */\n   for (decl = DECL_ARGUMENTS (fndecl); decl; decl = TREE_CHAIN (decl))\n     {\n-      int size = int_size_in_bytes (TREE_TYPE (decl));\n+      HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (decl));\n+\n       instantiate_decl (DECL_RTL (decl), size, valid_only);\t\n \n       /* If the parameter was promoted, then the incoming RTL mode may be\n@@ -2977,7 +3045,7 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n   rtx x;\n   RTX_CODE code;\n   rtx new = 0;\n-  int offset = 0;\n+  HOST_WIDE_INT offset;\n   rtx temp;\n   rtx seq;\n   int i, j;\n@@ -3652,17 +3720,7 @@ assign_parms (fndecl, second_time)\n       /* Set NAMED_ARG if this arg should be treated as a named arg.  For\n \t most machines, if this is a varargs/stdarg function, then we treat\n \t the last named arg as if it were anonymous too.  */\n-#ifdef STRICT_ARGUMENT_NAMING\n-      int named_arg = 1;\n-#else\n-      int named_arg = ! last_named;\n-#endif\n-      /* If this is a varargs function, then we want to treat the last named\n-\t argument as if it was an aggregate, because it might be accessed as\n-\t one by the va_arg macros.  This is necessary to make the aliasing\n-\t code handle this parm correctly.  */\n-      if (hide_last_arg && last_named)\n-\taggregate = 1;\n+      int named_arg = STRICT_ARGUMENT_NAMING ? 1 : ! last_named;\n \n       if (TREE_TYPE (parm) == error_mark_node\n \t  /* This can happen after weird syntax errors\n@@ -4269,7 +4327,7 @@ assign_parms (fndecl, second_time)\n \t    }\n \n \t  /* For pointer data type, suggest pointer register.  */\n-\t  if (TREE_CODE (TREE_TYPE (parm)) == POINTER_TYPE)\n+\t  if (POINTER_TYPE_P (TREE_TYPE (parm)))\n \t    mark_reg_pointer (parmreg,\n \t\t\t      (TYPE_ALIGN (TREE_TYPE (TREE_TYPE (parm)))\n \t\t\t       / BITS_PER_UNIT));\n@@ -4324,9 +4382,7 @@ assign_parms (fndecl, second_time)\n \t\temit_move_insn (validize_mem (stack_parm),\n \t\t\t\tvalidize_mem (entry_parm));\n \t    }\n-\t  if (flag_check_memory_usage\n-\t      && entry_parm != stack_parm\n-\t      && promoted_mode != nominal_mode)\n+\t  if (flag_check_memory_usage)\n \t    {\n \t      push_to_sequence (conversion_insns);\n \t      emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n@@ -4811,7 +4867,7 @@ fix_lexical_addr (addr, var)\n      tree var;\n {\n   rtx basereg;\n-  int displacement;\n+  HOST_WIDE_INT displacement;\n   tree context = decl_function_context (var);\n   struct function *fp;\n   rtx base = 0;"}, {"sha": "f90830b94f4092f257828560249ee520678f732f", "filename": "gcc/function.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Structure for saving state for a nested function.\n-   Copyright (C) 1989, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 92-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -108,6 +108,8 @@ struct function\n   int function_call_count;\n   struct temp_slot *temp_slots;\n   int temp_slot_level;\n+  int target_temp_slot_level;\n+  int var_temp_slot_level;\n   /* This slot is initialized as 0 and is added to\n      during the nested function.  */\n   struct var_refs_queue *fixup_var_refs_queue;"}, {"sha": "09a369afd4ec60f81db3bddfa1b3550150ed9cc5", "filename": "gcc/gansidecl.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fgansidecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fgansidecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgansidecl.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* ANSI and traditional C compatibility macros.\n-   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -77,6 +77,9 @@ Boston, MA 02111-1307, USA.  */\n \n #endif /* ! __STDC__ */\n \n+/* We don't have autoconf for libgcc2.c since it's a target, so don't\n+   define these functions, which aren't used there anyway.  */\n+#ifndef IN_LIBGCC2\n #ifndef bcopy\n # ifdef HAVE_BCOPY\n #  ifdef NEED_DECLARATION_BCOPY\n@@ -119,4 +122,6 @@ int bcmp ();\n # endif\n #endif\n \n+#endif /* IN_LIBGCC2 */\n+\n #endif /* ANSIDECL_H */"}, {"sha": "50e0e5676365eb72e9eeb72892b2a7e93b64bf21", "filename": "gcc/gbl-ctors.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fgbl-ctors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fgbl-ctors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgbl-ctors.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -2,7 +2,7 @@\n    for getting g++ file-scope static objects constructed.  This file\n    will get included either by libgcc2.c (for systems that don't support\n    a .init section) or by crtstuff.c (for those that do).\n-   Copyright (C) 1991, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 1995, 1996, 1998 Free Software Foundation, Inc.\n    Contributed by Ron Guilmette (rfg@segfault.us.com)\n \n This file is part of GNU CC.\n@@ -39,8 +39,6 @@ Boston, MA 02111-1307, USA.  */\n #ifdef HAVE_ATEXIT\n #if defined (WINNT) || defined (NEED_ATEXIT)\n extern int atexit (void (*) (void));\n-#else\n-extern void atexit (void (*) (void));\n #endif\n #define ON_EXIT(FUNC,ARG) atexit ((FUNC))\n #else"}, {"sha": "37d5ebc6cad227a4be061ea662d0b4ded63f3b30", "filename": "gcc/gcc.c", "status": "modified", "additions": 69, "deletions": 27, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -2527,7 +2527,7 @@ process_command (argc, argv)\n \t}\n       else if (! strcmp (argv[i], \"-dumpversion\"))\n \t{\n-\t  printf (\"%s\\n\", version_string);\n+\t  printf (\"%s\\n\", spec_version);\n \t  exit (0);\n \t}\n       else if (! strcmp (argv[i], \"-dumpmachine\"))\n@@ -2746,6 +2746,36 @@ process_command (argc, argv)\n \t\tspec_version = p + 1;\n \t      compiler_version = spec_version;\n \t      warn_std_ptr = &warn_std;\n+\n+\t      /* Validate the version number.  Use the same checks\n+\t\t done when inserting it into a spec.\n+\n+\t\t The format of the version string is\n+\t\t ([^0-9]*-)?[0-9]+[.][0-9]+([.][0-9]+)?([- ].*)?  */\n+\t      {\n+\t\tchar *v = compiler_version;\n+\n+\t\t/* Ignore leading non-digits.  i.e. \"foo-\" in \"foo-2.7.2\".  */\n+\t\twhile (! isdigit (*v))\n+\t\t  v++;\n+\n+\t\tif (v > compiler_version && v[-1] != '-')\n+\t\t  fatal (\"invalid version number format\");\n+\n+\t\t/* Set V after the first period.  */\n+\t\twhile (isdigit (*v))\n+\t\t  v++;\n+\n+\t\tif (*v != '.')\n+\t\t  fatal (\"invalid version number format\");\n+\n+\t\tv++;\n+\t\twhile (isdigit (*v))\n+\t\t  v++;\n+\n+\t\tif (*v != 0 && *v != ' ' && *v != '.' && *v != '-')\n+\t\t  fatal (\"invalid version number format\");\n+\t      }\n \t      break;\n \n \t    case 'c':\n@@ -2901,23 +2931,23 @@ process_command (argc, argv)\n \t  for (j = 4; argv[i][j]; j++)\n \t    if (argv[i][j] == ',')\n \t      {\n-\t\tinfiles[n_infiles].language = 0;\n+\t\tinfiles[n_infiles].language = \"*\";\n \t\tinfiles[n_infiles++].name\n \t\t  = save_string (argv[i] + prev, j - prev);\n \t\tprev = j + 1;\n \t      }\n \t  /* Record the part after the last comma.  */\n-\t  infiles[n_infiles].language = 0;\n+\t  infiles[n_infiles].language = \"*\";\n \t  infiles[n_infiles++].name = argv[i] + prev;\n \t}\n       else if (strcmp (argv[i], \"-Xlinker\") == 0)\n \t{\n-\t  infiles[n_infiles].language = 0;\n+\t  infiles[n_infiles].language = \"*\";\n \t  infiles[n_infiles++].name = argv[++i];\n \t}\n       else if (strncmp (argv[i], \"-l\", 2) == 0)\n \t{\n-\t  infiles[n_infiles].language = 0;\n+\t  infiles[n_infiles].language = \"*\";\n \t  infiles[n_infiles++].name = argv[i];\n \t}\n       else if (strcmp (argv[i], \"-specs\") == 0)\n@@ -4528,7 +4558,15 @@ main (argc, argv)\n \t as a unit.  If GCC_EXEC_PREFIX is defined, base\n \t standard_startfile_prefix on that as well.  */\n       if (*standard_startfile_prefix == '/'\n-\t  || *standard_startfile_prefix == DIR_SEPARATOR)\n+\t  || *standard_startfile_prefix == DIR_SEPARATOR\n+\t  || *standard_startfile_prefix == '$'\n+#ifdef __MSDOS__\n+\t  /* Check for disk name on MS-DOS-based systems.  */\n+          || (standard_startfile_prefix[1] == ':'\n+\t      && (standard_startfile_prefix[2] == DIR_SEPARATOR\n+\t\t  || standard_startfile_prefix[2] == '/'))\n+#endif\n+\t  )\n \tadd_prefix (&startfile_prefixes, standard_startfile_prefix, \"BINUTILS\",\n \t\t    0, 0, NULL_PTR);\n       else\n@@ -4796,7 +4834,7 @@ main (argc, argv)\n \n /* Find the proper compilation spec for the file name NAME,\n    whose length is LENGTH.  LANGUAGE is the specified language,\n-   or 0 if none specified.  */\n+   or 0 if this file is to be passed to the linker.  */\n \n static struct compiler *\n lookup_compiler (name, length, language)\n@@ -4806,43 +4844,44 @@ lookup_compiler (name, length, language)\n {\n   struct compiler *cp;\n \n-  /* Look for the language, if one is spec'd.  */\n+  /* If this was specified by the user to be a linker input, indicate that. */\n+  if (language != 0 && language[0] == '*')\n+    return 0;\n+\n+  /* Otherwise, look for the language, if one is spec'd.  */\n   if (language != 0)\n     {\n       for (cp = compilers + n_compilers - 1; cp >= compilers; cp--)\n-\t{\n-\t  if (language != 0)\n-\t    {\n-\t      if (cp->suffix[0] == '@'\n-\t\t  && !strcmp (cp->suffix + 1, language))\n-\t\treturn cp;\n-\t    }\n-\t}\n+\tif (cp->suffix[0] == '@' && !strcmp (cp->suffix + 1, language))\n+\t  return cp;\n+\n       error (\"language %s not recognized\", language);\n+      return 0;\n     }\n \n   /* Look for a suffix.  */\n   for (cp = compilers + n_compilers - 1; cp >= compilers; cp--)\n     {\n       if (/* The suffix `-' matches only the file name `-'.  */\n \t  (!strcmp (cp->suffix, \"-\") && !strcmp (name, \"-\"))\n-\t  ||\n-\t  (strlen (cp->suffix) < length\n-\t   /* See if the suffix matches the end of NAME.  */\n+\t  || (strlen (cp->suffix) < length\n+\t      /* See if the suffix matches the end of NAME.  */\n #ifdef OS2\n-\t   && (!strcmp (cp->suffix,\n-\t\t\tname + length - strlen (cp->suffix))\n-\t    || !strpbrk (cp->suffix, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n-\t     && !strcasecmp (cp->suffix,\n-\t\t\t  name + length - strlen (cp->suffix)))))\n+\t      && ((!strcmp (cp->suffix,\n+\t\t\t   name + length - strlen (cp->suffix))\n+\t\t   || !strpbrk (cp->suffix, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"))\n+\t\t  && !strcasecmp (cp->suffix,\n+\t\t\t\t  name + length - strlen (cp->suffix)))\n #else\n-\t   && !strcmp (cp->suffix,\n-\t\t       name + length - strlen (cp->suffix))))\n+\t      && !strcmp (cp->suffix,\n+\t\t\t  name + length - strlen (cp->suffix))\n #endif\n+\t ))\n \t{\n \t  if (cp->spec[0][0] == '@')\n \t    {\n \t      struct compiler *new;\n+\n \t      /* An alias entry maps a suffix to a language.\n \t\t Search for the language; pass 0 for NAME and LENGTH\n \t\t to avoid infinite recursion if language not found.\n@@ -4854,6 +4893,7 @@ lookup_compiler (name, length, language)\n \t\t     (char *) new->spec, sizeof new->spec);\n \t      return new;\n \t    }\n+\n \t  /* A non-alias entry: return it.  */\n \t  return cp;\n \t}\n@@ -4968,6 +5008,8 @@ pfatal_pexecute (errmsg_fmt, errmsg_arg)\n      char *errmsg_fmt;\n      char *errmsg_arg;\n {\n+  int save_errno = errno;\n+\n   if (errmsg_arg)\n     {\n       /* Space for trailing '\\0' is in %s.  */\n@@ -4976,7 +5018,7 @@ pfatal_pexecute (errmsg_fmt, errmsg_arg)\n       errmsg_fmt = msg;\n     }\n \n-  fatal (\"%s: %s\", errmsg_fmt, my_strerror (errno));\n+  fatal (\"%s: %s\", errmsg_fmt, my_strerror (save_errno));\n }\n \n /* More 'friendly' abort that prints the line and file."}, {"sha": "26e22faba29a8d807f7575c6458e67addf6e3897", "filename": "gcc/gcc.hlp", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fgcc.hlp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fgcc.hlp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.hlp?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -86,9 +86,6 @@\n  In the case of the sharable library, only one  library  needs  to  be\n  linked to.\n \n- If you need to link to libg++, it  is  easiest  to  use  the  command\n- procedure supplied with libg++ to link your program.\n-\n 2 /CASE_HACK\n \n    /[NO]CASE_HACK      D=/CASE_HACK"}, {"sha": "da2804ddc87b908fbd37772c87d7134483c9740a", "filename": "gcc/gcc.texi", "status": "modified", "additions": 126, "deletions": 217, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fgcc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fgcc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.texi?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -111,23 +111,21 @@ notice identical to this one except for the removal of this paragraph\n @end ignore\n Permission is granted to copy and distribute modified versions of this\n manual under the conditions for verbatim copying, provided also that the\n-sections entitled ``GNU General Public License,'' ``Funding for Free\n-Software,'' and ``Protect Your Freedom---Fight `Look And Feel'@w{}'' are\n-included exactly as in the original, and provided that the entire\n-resulting derived work is distributed under the terms of a permission\n-notice identical to this one.\n+sections entitled ``GNU General Public License'' and ``Funding for Free\n+Software'' are included exactly as in the original, and provided that \n+the entire resulting derived work is distributed under the terms of a \n+permission notice identical to this one.\n \n Permission is granted to copy and distribute translations of this manual\n into another language, under the above conditions for modified versions,\n-except that the sections entitled ``GNU General Public License,''\n-``Funding for Free Software,'' and ``Protect Your Freedom---Fight `Look\n-And Feel'@w{}'', and this permission notice, may be included in\n-translations approved by the Free Software Foundation instead of in the\n-original English.\n+except that the sections entitled ``GNU General Public License'' and\n+``Funding for Free Software'', and this permission notice, may be \n+included in translations approved by the Free Software Foundation \n+instead of in the original English.\n @end ifinfo\n \n @setchapternewpage odd\n-\n+@c @finalout\n @titlepage\n @ifset INTERNALS\n @ifset USING\n@@ -144,43 +142,41 @@ original English.\n @sp 2\n @center Richard M. Stallman\n @sp 3\n-@center Last updated 7 January 1998\n+@center Last updated 16 March 1998\n @sp 1\n-@c The version number appears three times more in this file.\n+@c The version number appears five times more in this file.\n \n @center for egcs-1.0\n @page\n @vskip 0pt plus 1filll\n-Copyright @copyright{} 1988, 89, 92, 93, 94, 95, 96 Free Software Foundation, Inc.\n+Copyright @copyright{} 1988, 89, 92, 93, 94, 95, 96, 98  Free Software Foundation, Inc.\n @sp 2\n For EGCS Version 1.0@*\n @sp 1\n Published by the Free Software Foundation @*\n 59 Temple Place - Suite 330@*\n Boston, MA 02111-1307, USA@*\n-Last printed November, 1995.@*\n+Last printed April, 1998.@*\n Printed copies are available for $50 each.@*\n-ISBN 1-882114-36-1\n+ISBN 1-882114-37-X\n @sp 1\n Permission is granted to make and distribute verbatim copies of\n this manual provided the copyright notice and this permission notice\n are preserved on all copies.\n \n Permission is granted to copy and distribute modified versions of this\n manual under the conditions for verbatim copying, provided also that the\n-sections entitled ``GNU General Public License,'' ``Funding for Free\n-Software,'' and ``Protect Your Freedom---Fight `Look And Feel'@w{}'' are\n-included exactly as in the original, and provided that the entire\n-resulting derived work is distributed under the terms of a permission\n-notice identical to this one.\n+sections entitled ``GNU General Public License'' and ``Funding for Free\n+Software'' are included exactly as in the original, and provided that \n+the entire resulting derived work is distributed under the terms of a \n+permission notice identical to this one.\n \n Permission is granted to copy and distribute translations of this manual\n into another language, under the above conditions for modified versions,\n-except that the sections entitled ``GNU General Public License,''\n-``Funding for Free Software,'' and ``Protect Your Freedom---Fight `Look\n-And Feel'@w{}'', and this permission notice, may be included in\n-translations approved by the Free Software Foundation instead of in the\n-original English.\n+except that the sections entitled ``GNU General Public License'' and\n+``Funding for Free Software'', and this permission notice, may be \n+included in translations approved by the Free Software Foundation \n+instead of in the original English.\n @end titlepage\n @page\n \n@@ -236,7 +232,7 @@ bugs.  It corresponds to EGCS version 1.0.\n @end ifset\n \n * Funding::         How to help assure funding for free software.\n-* Look and Feel::   Protect your freedom---fight ``look and feel''.\n+* GNU/Linux::       Linux and the GNU Project\n \n * Copying::         GNU General Public License says\n                      how you can copy and share GNU CC.\n@@ -1122,7 +1118,7 @@ the ordinary C compiler.  If you do so, you must specify the following\n options:\n \n @smallexample\n--L/usr/local/lib/gcc-lib/we32k-att-sysv/2.7.1 -lgcc -lc_s\n+-L/usr/local/lib/gcc-lib/we32k-att-sysv/2.8.1 -lgcc -lc_s\n @end smallexample\n \n The first specifies where to find the library @file{libgcc.a}\n@@ -3864,9 +3860,9 @@ procedure will build all combinations of compatible options.\n \n For example, if you set @code{MULTILIB_OPTIONS} to @samp{m68000/m68020\n msoft-float}, @file{Makefile} will build special versions of\n-@file{libgcc.a} using the sets of options @samp{-m68000}, @samp{-m68020},\n-@samp{-msoft-float}, @samp{-m68000 -msoft-float}, and @samp{-m68020\n--msoft-float}.\n+@file{libgcc.a} using the following sets of options:  @samp{-m68000},\n+@samp{-m68020}, @samp{-msoft-float}, @samp{-m68000 -msoft-float}, and \n+@samp{-m68020 -msoft-float}.\n \n @findex MULTILIB_DIRNAMES\n @item MULTILIB_DIRNAMES\n@@ -3877,7 +3873,7 @@ Write one element in @code{MULTILIB_DIRNAMES} for each element in\n default value will be @code{MULTILIB_OPTIONS}, with all slashes treated\n as spaces.\n \n-For example, if @code{MULTILIB_OPTIONS} is specified as @samp{m68000/m68020\n+For example, if @code{MULTILIB_OPTIONS} is set to @samp{m68000/m68020\n msoft-float}, then the default value of @code{MULTILIB_DIRNAMES} is\n @samp{m68000 m68020 msoft-float}.  You may specify a different value if\n you desire a different set of directory names.\n@@ -3992,191 +3988,104 @@ Verbatim copying and redistribution of this section is permitted\n without royalty; alteration is not permitted.\n @end display\n \n-@node Look and Feel\n-@unnumbered Protect Your Freedom---Fight ``Look And Feel''\n-@c the above chapter heading overflows onto the next line. --mew 1/26/93\n-\n-@quotation\n-@i{This section is a political message from the League for Programming\n-Freedom to the users of GNU CC.  We have included it here because the\n-issue of interface copyright is important to the GNU project.}\n-@end quotation\n-\n-Apple, Lotus, and now CDC have tried to create a new form of legal\n-monopoly: a copyright on a user interface.\n-\n-An interface is a kind of language---a set of conventions for\n-communication between two entities, human or machine.  Until a few years\n-ago, the law seemed clear: interfaces were outside the domain of\n-copyright, so programmers could program freely and implement whatever\n-interface the users demanded.  Imitating de-facto standard interfaces,\n-sometimes with improvements, was standard practice in the computer\n-field.  These improvements, if accepted by the users, caught on and\n-became the norm; in this way, much progress took place.\n-\n-Computer users, and most software developers, were happy with this state\n-of affairs.  However, large companies such as Apple and Lotus would\n-prefer a different system---one in which they can own interfaces and\n-thereby rid themselves of all serious competitors.  They hope that\n-interface copyright will give them, in effect, monopolies on major\n-classes of software.\n-\n-Other large companies such as IBM and Digital also favor interface\n-monopolies, for the same reason: if languages become property, they\n-expect to own many de-facto standard languages.  But Apple and Lotus are\n-the ones who have actually sued.  Apple's lawsuit was defeated, for\n-reasons only partly related to the general issue of interface copyright.\n-\n-Lotus won lawsuits against two small companies, which were thus put out\n-of business.  Then Lotus sued Borland; Lotus won in the trial court (no\n-surprise, since it was the same court that had ruled for Lotus twice\n-before), but the court of appeals ruled in favor of Borland, which was\n-assisted by a friend-of-the-court brief from the League for Programming\n-Freedom.\n-\n-Lotus appealed the case to the Supreme Court, which heard the case but\n-was unable to reach a decision.  This failure means that the appeals\n-court decision stands, in one portion of the United States, and may\n-influence the other appeals courts, but it does not set a nationwide\n-precedent.  The battle is not over, and it is not limited to the United\n-States.\n-\n-The battle is extending into other areas of software as well.  In 1995 a\n-company that produced a simulator for a CDC computer was shut down by a\n-copyright lawsuit, in which CDC charged that the simulator infringed the\n-copyright on the manuals for the computer.\n-\n-If the monopolists get their way, they will hobble the software field:\n-\n-@itemize @bullet\n-@item\n-Gratuitous incompatibilities will burden users.  Imagine if each car\n-manufacturer had to design a different way to start, stop, and steer a\n-car.\n-\n-@item\n-Users will be ``locked in'' to whichever interface they learn; then they\n-will be prisoners of one supplier, who will charge a monopolistic price.\n-\n-@item\n-Large companies have an unfair advantage wherever lawsuits become\n-commonplace.  Since they can afford to sue, they can intimidate smaller\n-developers with threats even when they don't really have a case.\n-\n-@item\n-Interface improvements will come slower, since incremental evolution\n-through creative partial imitation will no longer occur.\n-@end itemize\n-\n-If interface monopolies are accepted, other large companies are waiting\n-to grab theirs:\n-\n-@itemize @bullet\n-@item\n-Adobe is expected to claim a monopoly on the interfaces of various\n-popular application programs, if Lotus ultimately wins the case against\n-Borland.\n-\n-@item\n-Open Computing magazine reported a Microsoft vice president as threatening\n-to sue people who imitate the interface of Windows.\n-@end itemize\n-\n-Users invest a great deal of time and money in learning to use computer\n-interfaces.  Far more, in fact, than software developers invest in\n-developing @emph{and even implementing} the interfaces.  Whoever can own\n-an interface, has made its users into captives, and misappropriated\n-their investment.\n-\n-To protect our freedom from monopolies like these, a group of\n-programmers and users have formed a grass-roots political organization,\n-the League for Programming Freedom.\n-\n-The purpose of the League is to oppose monopolistic practices such as\n-interface copyright and software patents.  The League calls for a return\n-to the legal policies of the recent past, in which programmers could\n-program freely.  The League is not concerned with free software as an\n-issue, and is not affiliated with the Free Software Foundation.\n-\n-The League's activities include publicizing the issues, as is being done\n-here, and filing friend-of-the-court briefs on behalf of defendants sued\n-by monopolists.\n-\n-The League's membership rolls include Donald Knuth, the foremost\n-authority on algorithms, John McCarthy, inventor of Lisp, Marvin Minsky,\n-founder of the MIT Artificial Intelligence lab, Guy L. Steele, Jr.,\n-author of well-known books on Lisp and C, as well as Richard Stallman,\n-the developer of GNU CC.  Please join and add your name to the list.\n-Membership dues in the League are $42 per year for programmers, managers\n-and professionals; $10.50 for students; $21 for others.\n-\n-Activist members are especially important, but members who have no time\n-to give are also important.  Surveys at major ACM conferences have\n-indicated a vast majority of attendees agree with the League on both\n-issues (interface copyrights and software patents).  If just ten percent\n-of the programmers who agree with the League join the League, we will\n-probably triumph.\n-\n-To join, or for more information, send electronic mail to\n-the address @code{lpf@@uunet.uu.net} or write to:\n-\n-@display\n-League for Programming Freedom\n-1 Kendall Square #143\n-P.O. Box 9171\n-Cambridge, MA 02139\n-@end display\n-\n-In addition to joining the League, here are some suggestions from the\n-League for other things you can do to protect your freedom to write\n-programs:\n-\n-@itemize @bullet\n-@item\n-Tell your friends and colleagues about this issue and how it threatens\n-to ruin the computer industry.\n-\n-@item\n-Mention that you are a League member in your @file{.signature}, and\n-mention the League's email address for inquiries.\n-\n-@item\n-Ask the companies you consider working for or working with to make\n-statements against software monopolies, and give preference to those\n-that do.\n-\n-@item\n-When employers ask you to sign contracts giving them copyright on your\n-work, insist on a clause saying they will not claim the copyright covers\n-imitating the interface.\n-\n-@item\n-When employers ask you to sign contracts giving them patent rights,\n-insist on clauses saying they can use these rights only defensively.\n-Don't rely on ``company policy,'' since that can change at any time;\n-don't rely on an individual executive's private word, since that person\n-may be replaced.  Get a commitment just as binding as the commitment\n-they get from you.\n-\n-@item\n-Write to Congress to explain the importance of these issues.\n-\n-@display\n-House Subcommittee on Intellectual Property\n-2137 Rayburn Bldg\n-Washington, DC 20515\n-\n-Senate Subcommittee on Patents, Trademarks and Copyrights\n-United States Senate\n-Washington, DC 20510\n-@end display\n-\n-(These committees have received lots of mail already; let's give them\n-even more.)\n-@end itemize\n-\n-Democracy means nothing if you don't use it.  Stand up and be counted!\n-\n+@node GNU/Linux\n+@unnumbered Linux and the GNU Project\n+\n+Many computer users run a modified version of the GNU system every\n+day, without realizing it.  Through a peculiar turn of events, the\n+version of GNU which is widely used today is more often known as\n+``Linux'', and many users are not aware of the extent of its\n+connection with the GNU Project.\n+\n+There really is a Linux; it is a kernel, and these people are using\n+it.  But you can't use a kernel by itself; a kernel is useful only as\n+part of a whole system.  The system in which Linux is typically used\n+is a modified variant of the GNU system---in other words, a Linux-based\n+GNU system.\n+\n+Many users are not fully aware of the distinction between the kernel,\n+which is Linux, and the whole system, which they also call ``Linux''.\n+The ambiguous use of the name doesn't promote understanding.\n+\n+Programmers generally know that Linux is a kernel.  But since they\n+have generally heard the whole system called ``Linux'' as well, they\n+often envisage a history which fits that name.  For example, many\n+believe that once Linus Torvalds finished writing the kernel, his\n+friends looked around for other free software, and for no particular\n+reason most everything necessary to make a Unix-like system was\n+already available.\n+\n+What they found was no accident---it was the GNU system.  The available\n+free software added up to a complete system because the GNU Project\n+had been working since 1984 to make one.  The GNU Manifesto\n+had set forth the goal of developing a free Unix-like system, called \n+GNU.  By the time Linux was written, the system was almost finished.\n+\n+Most free software projects have the goal of developing a particular\n+program for a particular job.  For example, Linus Torvalds set out to\n+write a Unix-like kernel (Linux); Donald Knuth set out to write a text\n+formatter (TeX); Bob Scheifler set out to develop a window system (X\n+Windows).  It's natural to measure the contribution of this kind of\n+project by specific programs that came from the project.\n+\n+If we tried to measure the GNU Project's contribution in this way,\n+what would we conclude?  One CD-ROM vendor found that in their ``Linux\n+distribution'', GNU software was the largest single contingent, around\n+28% of the total source code, and this included some of the essential\n+major components without which there could be no system.  Linux itself\n+was about 3%.  So if you were going to pick a name for the system\n+based on who wrote the programs in the system, the most appropriate\n+single choice would be ``GNU''.\n+\n+But we don't think that is the right way to consider the question.\n+The GNU Project was not, is not, a project to develop specific\n+software packages.  It was not a project to develop a C compiler,\n+although we did.  It was not a project to develop a text editor,\n+although we developed one.  The GNU Project's aim was to develop\n+@emph{a complete free Unix-like system}.\n+\n+Many people have made major contributions to the free software in the\n+system, and they all deserve credit.  But the reason it is @emph{a\n+system}---and not just a collection of useful programs---is because the\n+GNU Project set out to make it one.  We wrote the programs that were\n+needed to make a @emph{complete} free system.  We wrote essential but\n+unexciting major components, such as the assembler and linker, because\n+you can't have a system without them.  A complete system needs more\n+than just programming tools, so we wrote other components as well,\n+such as the Bourne Again SHell, the PostScript interpreter\n+Ghostscript, and the GNU C library.\n+\n+By the early 90s we had put together the whole system aside from the\n+kernel (and we were also working on a kernel, the GNU Hurd, which runs\n+on top of Mach).  Developing this kernel has been a lot harder than we\n+expected, and we are still working on finishing it.\n+\n+Fortunately, you don't have to wait for it, because Linux is working\n+now.  When Linus Torvalds wrote Linux, he filled the last major gap.\n+People could then put Linux together with the GNU system to make a\n+complete free system: a Linux-based GNU system (or GNU/Linux system,\n+for short).\n+\n+Putting them together sounds simple, but it was not a trivial job.\n+The GNU C library (called glibc for short) needed substantial changes.\n+Integrating a complete system as a distribution that would work ``out\n+of the box'' was a big job, too.  It required addressing the issue of\n+how to install and boot the system---a problem we had not tackled,\n+because we hadn't yet reached that point.  The people who developed\n+the various system distributions made a substantial contribution.\n+\n+The GNU Project supports GNU/Linux systems as well as @emph{the}\n+GNU system---even with funds.  We funded the rewriting of the\n+Linux-related extensions to the GNU C library, so that now they are\n+well integrated, and the newest GNU/Linux systems use the current\n+library release with no changes.  We also funded an early stage of the\n+development of Debian GNU/Linux.\n+\n+We use Linux-based GNU systems today for most of our work, and we hope\n+you use them too.  But please don't confuse the public by using the\n+name ``Linux'' ambiguously.  Linux is the kernel, one of the essential\n+major components of the system.  The system as a whole is more or less\n+the GNU system.\n \n @node Copying\n @unnumbered GNU GENERAL PUBLIC LICENSE"}, {"sha": "d0b481ec9975925878626c7da68e7f81f74acb96", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -361,6 +361,7 @@ int optimize = 0;\n    They won't actually be used.  */\n \n struct _global_rtl global_rtl;\n+rtx pic_offset_table_rtx;\n \n static rtx attr_rtx\t\tPVPROTO((enum rtx_code, ...));\n #ifdef HAVE_VPRINTF"}, {"sha": "5f6882605d9bded094f5d2b547a1bf1a24cf855b", "filename": "gcc/install.texi", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finstall.texi?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -67,8 +67,8 @@ to specify a configuration when building a native compiler unless\n wrong.\n \n In those cases, specify the build machine's @dfn{configuration name}\n-with the @samp{--build} option; the host and target will default to be\n-the same as the build machine.  (If you are building a cross-compiler,\n+with the @samp{--host} option; the host and target will default to be\n+the same as the host machine.  (If you are building a cross-compiler,\n see @ref{Cross-Compiler}.)\n \n Here is an example:\n@@ -261,18 +261,19 @@ If you want to install its files somewhere else, specify\n is a directory name to use instead of @file{/usr/local} for all purposes\n with one exception: the directory @file{/usr/local/include} is searched\n for header files no matter where you install the compiler.  To override\n-this name, use the @code{--local-prefix} option below.\n+this name, use the @code{--with-local-prefix} option below.  The directory\n+you specify need not exist, but its parent directory must exist.\n \n @item\n-Specify @samp{--local-prefix=@var{dir}} if you want the compiler to\n+Specify @samp{--with-local-prefix=@var{dir}} if you want the compiler to\n search directory @file{@var{dir}/include} for locally installed header\n files @emph{instead} of @file{/usr/local/include}.\n \n-You should specify @samp{--local-prefix} @strong{only} if your site has\n+You should specify @samp{--with-local-prefix} @strong{only} if your site has\n a different convention (not @file{/usr/local}) for where to put\n site-specific files.\n \n-The default value for @samp{--local-prefix} is @file{/usr/local}\n+The default value for @samp{--with-local-prefix} is @file{/usr/local}\n regardless of the value of @samp{--prefix}.  Specifying @samp{--prefix}\n has no effect on which directory GNU CC searches for local header files.\n This may seem counterintuitive, but actually it is logical.\n@@ -283,8 +284,8 @@ any in that directory---are not part of GNU CC.  They are part of other\n programs---perhaps many others.  (GNU CC installs its own header files\n in another directory which is based on the @samp{--prefix} value.)\n \n-@strong{Do not} specify @file{/usr} as the @samp{--local-prefix}!  The\n-directory you use for @samp{--local-prefix} @strong{must not} contain\n+@strong{Do not} specify @file{/usr} as the @samp{--with-local-prefix}!  The\n+directory you use for @samp{--with-local-prefix} @strong{must not} contain\n any of the system's standard header files.  If it did contain them,\n certain programs would be miscompiled (including GNU Emacs, on certain\n targets), because this would override and nullify the header file\n@@ -507,11 +508,11 @@ This copies the files @file{cc1}, @file{cpp} and @file{libgcc.a} to\n files @file{cc1}, @file{cpp} and @file{libgcc.a} in the directory\n @file{/usr/local/lib/gcc-lib/@var{target}/@var{version}}, which is where\n the compiler driver program looks for them.  Here @var{target} is the\n-target machine type specified when you ran @file{configure}, and\n-@var{version} is the version number of GNU CC.  This naming scheme\n-permits various versions and/or cross-compilers to coexist.\n-It also copies the executables for compilers for other languages\n-(e.g., @file{cc1plus} for C++) to the same directory.\n+canonicalized form of target machine type specified when you ran\n+@file{configure}, and @var{version} is the version number of GNU CC.\n+This naming scheme permits various versions and/or cross-compilers to\n+coexist.  It also copies the executables for compilers for other\n+languages (e.g., @file{cc1plus} for C++) to the same directory.\n \n This also copies the driver program @file{xgcc} into\n @file{/usr/local/bin/gcc}, so that it appears in typical execution\n@@ -542,7 +543,13 @@ distribute a C runtime library, it also does not include a C++ runtime\n library.  All I/O functionality, special class libraries, etc., are\n provided by the C++ runtime library.\n \n-Here's one way to build and install a C++ runtime library for GNU CC:\n+The standard C++ runtime library for GNU CC is called @samp{libstdc++}.\n+An obsolescent library @samp{libg++} may also be available, but it's\n+necessary only for older software that hasn't been converted yet; if\n+you don't know whether you need @samp{libg++} then you probably don't\n+need it.\n+\n+Here's one way to build and install @samp{libstdc++} for GNU CC:\n \n @itemize @bullet\n @item\n@@ -856,9 +863,10 @@ particular configuration.\n AMD Am29050 used in a system running a variant of BSD Unix.\n \n @item decstation-*\n-DECstations can support three different personalities: Ultrix,\n-DEC OSF/1, and OSF/rose.  To configure GCC for these platforms\n-use the following configurations:\n+MIPS-based DECstations can support three different personalities:\n+Ultrix, DEC OSF/1, and OSF/rose.  (Alpha-based DECstation products have\n+a configuration name beginning with @samp{alpha-dec}.)  To configure GCC\n+for these platforms use the following configurations:\n \n @table @samp\n @item decstation-ultrix\n@@ -1109,7 +1117,7 @@ that configuration with + the @samp{--with-gnu-as} and @samp{--with-gnu-ld}\n options to @code{configure}.\n \n Note the C compiler that comes\n-with this system cannot compile GNU CC.  You can fine binaries of GNU CC\n+with this system cannot compile GNU CC.  You can find binaries of GNU CC\n for bootstrapping on @code{jagubox.gsfc.nasa.gov}.\n You will also a patched version of @file{/bin/ld} there that\n raises some of the arbitrary limits found in the original.\n@@ -1962,9 +1970,13 @@ To install the cross-compiler, use @samp{make install}, as usual.\n @cindex Sun installation\n @cindex installing GNU CC on the Sun\n \n-On Solaris (version 2.1), do not use the linker or other tools in\n+On Solaris, do not use the linker or other tools in\n @file{/usr/ucb} to build GNU CC.  Use @code{/usr/ccs/bin}.\n \n+If the assembler reports @samp{Error: misaligned data} when bootstrapping,\n+you are probably using an obsolete version of the GNU assembler.  Upgrade\n+to the latest version of GNU @code{binutils}, or use the Solaris assembler.\n+\n Make sure the environment variable @code{FLOAT_OPTION} is not set when\n you compile @file{libgcc.a}.  If this option were set to @code{f68881}\n when @file{libgcc.a} is compiled, the resulting code would demand to be"}, {"sha": "21c08b93401fb8b39da103cb7be5cd456f549fbb", "filename": "gcc/install1.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Finstall1.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Finstall1.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finstall1.texi?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,7 +1,7 @@\n @setfilename INSTALL\n @set INSTALLONLY\n \n-@c This file itself, install1.texi, does not apear in the GCC distribution.\n+@c This file itself, install1.texi, does not appear in the GCC distribution.\n @c The immediately following lines apply to the INSTALL file\n @c which is generated using this file.\n This file documents the installation of the GNU compiler."}, {"sha": "ea1acc4161bafbb7040ab5f5a5fea45a4d266620", "filename": "gcc/integrate.c", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -82,13 +82,13 @@ static void set_block_abstract_flags PROTO((tree, int));\n void set_decl_abstract_flags\tPROTO((tree, int));\n \f\n /* Returns the Ith entry in the label_map contained in MAP.  If the\n-   Ith entry has not yet been set, it is assumed to be a fresh label.\n-   Essentially, we use this function to perform a lazy initialization\n-   of label_map, thereby avoiding huge memory explosions when the\n-   label_map gets very large.  */\n+   Ith entry has not yet been set, return a fresh label.  This function\n+   performs a lazy initialization of label_map, thereby avoiding huge memory\n+   explosions when the label_map gets very large.  */\n+\n rtx\n get_label_from_map (map, i)\n-     struct inline_remap* map;\n+     struct inline_remap *map;\n      int i;\n {\n   rtx x = map->label_map[i];\n@@ -99,7 +99,6 @@ get_label_from_map (map, i)\n   return x;\n }\n \n-\n /* Zero if the current function (whose FUNCTION_DECL is FNDECL)\n    is safe and reasonable to integrate into other functions.\n    Nonzero means value is a warning message with a single %s\n@@ -116,9 +115,7 @@ function_cannot_inline_p (fndecl)\n   register tree parms;\n   rtx result;\n \n-  /* No inlines with varargs.  `grokdeclarator' gives a warning\n-     message about that if `inline' is specified.  This code\n-     it put in to catch the volunteers.  */\n+  /* No inlines with varargs.  */\n   if ((last && TREE_VALUE (last) != void_type_node)\n       || current_function_varargs)\n     return \"varargs function cannot be inline\";\n@@ -298,6 +295,7 @@ initialize_for_inline (fndecl, min_labelno, max_labelno, max_reg, copy)\n        parms = TREE_CHAIN (parms), i++)\n     {\n       rtx p = DECL_RTL (parms);\n+      int copied_incoming = 0;\n \n       /* If we have (mem (addressof (mem ...))), use the inner MEM since\n \t otherwise the copy_rtx call below will not unshare the MEM since\n@@ -320,7 +318,8 @@ initialize_for_inline (fndecl, min_labelno, max_labelno, max_reg, copy)\n \t\t  && GET_CODE (DECL_INCOMING_RTL (parms)) == MEM\n \t\t  && (XEXP (DECL_RTL (parms), 0)\n \t\t      == XEXP (DECL_INCOMING_RTL (parms), 0))))\n-\t    DECL_INCOMING_RTL (parms) = new;\n+\t    DECL_INCOMING_RTL (parms) = new, copied_incoming = 1;\n+\n \t  DECL_RTL (parms) = new;\n \t}\n \n@@ -342,6 +341,23 @@ initialize_for_inline (fndecl, min_labelno, max_labelno, max_reg, copy)\n       /* This flag is cleared later\n \t if the function ever modifies the value of the parm.  */\n       TREE_READONLY (parms) = 1;\n+\n+      /* Copy DECL_INCOMING_RTL if not done already.  This can\n+\t happen if DECL_RTL is a reg.  */\n+      if (copy && ! copied_incoming)\n+\t{\n+\t  p = DECL_INCOMING_RTL (parms);\n+\n+\t  /* If we have (mem (addressof (mem ...))), use the inner MEM since\n+\t     otherwise the copy_rtx call below will not unshare the MEM since\n+\t     it shares ADDRESSOF.  */\n+\t  if (GET_CODE (p) == MEM && GET_CODE (XEXP (p, 0)) == ADDRESSOF\n+\t      && GET_CODE (XEXP (XEXP (p, 0), 0)) == MEM)\n+\t    p = XEXP (XEXP (p, 0), 0);\n+\n+\t  if (GET_CODE (p) == MEM)\n+\t    DECL_INCOMING_RTL (parms) = copy_rtx (p);\n+\t}\n     }\n \n   /* Assume we start out in the insns that set up the parameters.  */\n@@ -1423,7 +1439,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \targ_vals[i] = copy_to_mode_reg (GET_MODE (loc), arg_vals[i]);\n \n       if (arg_vals[i] != 0 && GET_CODE (arg_vals[i]) == REG\n-\t  && TREE_CODE (TREE_TYPE (formal)) == POINTER_TYPE)\n+\t  && POINTER_TYPE_P (TREE_TYPE (formal)))\n \tmark_reg_pointer (arg_vals[i],\n \t\t\t  (TYPE_ALIGN (TREE_TYPE (TREE_TYPE (formal)))\n \t\t\t   / BITS_PER_UNIT));\n@@ -1790,9 +1806,10 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   pushlevel (0);\n   expand_start_bindings (0);\n \n-  /* Make new label equivalences for the labels in the called function.  */\n-  for (i = min_labelno; i < max_labelno; i++)\n-    map->label_map[i] = NULL_RTX;\n+  /* Initialize label_map.  get_label_from_map will actually make\n+     the labels.  */\n+  bzero ((char *) &map->label_map [min_labelno],\n+\t (max_labelno - min_labelno) * sizeof (rtx));\n \n   /* Perform postincrements before actually calling the function.  */\n   emit_queue ();\n@@ -1991,9 +2008,8 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t  break;\n \n \tcase CODE_LABEL:\n-\t  copy = \n-\t    emit_label (get_label_from_map(map,\n-\t\t\t\t\t   CODE_LABEL_NUMBER (insn)));\n+\t  copy = emit_label (get_label_from_map (map,\n+\t\t\t\t\t\t CODE_LABEL_NUMBER (insn)));\n \t  LABEL_NAME (copy) = LABEL_NAME (insn);\n \t  map->const_age++;\n \t  break;\n@@ -2012,12 +2028,14 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_FUNCTION_BEG\n \t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED)\n \t    {\n-\t      copy = emit_note (NOTE_SOURCE_FILE (insn), NOTE_LINE_NUMBER (insn));\n-\t      if (copy && (NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_BEG\n-\t\t\t   || NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_END))\n+\t      copy = emit_note (NOTE_SOURCE_FILE (insn),\n+\t\t\t\tNOTE_LINE_NUMBER (insn));\n+\t      if (copy\n+\t\t  && (NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_BEG\n+\t\t      || NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_END))\n \t\t{\n-\t\t  rtx label =\n-\t\t    get_label_from_map (map, NOTE_BLOCK_NUMBER (copy));\n+\t\t  rtx label\n+\t\t    = get_label_from_map (map, NOTE_BLOCK_NUMBER (copy));\n \n \t\t  /* We have to forward these both to match the new exception\n \t\t     region.  */"}, {"sha": "23e2e561d9446fce31c2f3557c7ecb71edd8e5e8", "filename": "gcc/integrate.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Function integration definitions for GNU C-Compiler\n-   Copyright (C) 1990, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1990, 1995, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -126,8 +126,7 @@ extern void mark_stores PROTO((rtx, rtx));\n extern rtx get_label_from_map PROTO((struct inline_remap *, int));\n \n /* Set the label indicated.  */\n-#define set_label_in_map(map, i, x) \\\n-  ((map)->label_map[i] = (x))\n+#define set_label_in_map(MAP, I, X) ((MAP)->label_map[I] = (X))\n \n /* Unfortunately, we need a global copy of const_equiv map for communication\n    with a function called from note_stores.  Be *very* careful that this"}, {"sha": "b9273ee5c5a512cda6384ac7fc4d73dc2f499a1d", "filename": "gcc/invoke.texi", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,4 +1,4 @@\n-@c Copyright (C) 1988,89,92-97,1998 Free Software Foundation, Inc.\n+@c Copyright (C) 1988,89,92,93,94,95,96,97,1998 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -103,9 +103,10 @@ in the following sections.\n @xref{C++ Dialect Options,,Options Controlling C++ Dialect}.\n @smallexample\n -fall-virtual  -fdollars-in-identifiers  -felide-constructors\n--fenum-int-equiv  -fexternal-templates  -ffor-scope  -fno-for-scope\n--fhandle-signatures  -fmemoize-lookups  -fname-mangling-version-@var{n}\n--fno-default-inline  -fno-gnu-keywords -fnonnull-objects -fguiding-decls\n+-fenum-int-equiv  -fexternal-templates  -ffor-scope  \n+-fno-for-scope  -fhandle-signatures  -fmemoize-lookups  \n+-fname-mangling-version-@var{n}  -fno-default-inline  \n+-fno-gnu-keywords -fnonnull-objects -fguiding-decls\n -foperator-names  -fstrict-prototype  -fthis-is-variable\n -ftemplate-depth-@var{n}  -nostdinc++  -traditional  +e@var{n}\n @end smallexample\n@@ -120,11 +121,11 @@ in the following sections.\n -Wid-clash-@var{len}  -Wimplicit -Wimplicit-int \n -Wimplicit-function-declarations -Wimport  -Winline\n -Wlarger-than-@var{len}  -Wmain  -Wmissing-declarations\n--Wmissing-prototypes  -Wnested-externs\n--Wno-import  -Wold-style-cast  -Woverloaded-virtual  -Wparentheses\n--Wpointer-arith  -Wredundant-decls  -Wreorder  -Wreturn-type  -Wshadow\n--Wsign-compare  -Wstrict-prototypes  -Wswitch  -Wsynth\n--Wtemplate-debugging  -Wtraditional  -Wtrigraphs\n+-Wmissing-prototypes  -Wnested-externs  -Wno-import  \n+-Wold-style-cast  -Woverloaded-virtual  -Wparentheses\n+-Wpointer-arith  -Wredundant-decls  -Wreorder  -Wreturn-type\n+-Wshadow  -Wsign-compare  -Wstrict-prototypes  -Wswitch\n+-Wsynth  -Wtemplate-debugging  -Wtraditional  -Wtrigraphs\n -Wundef  -Wuninitialized  -Wunused  -Wwrite-strings\n -Wunknown-pragmas\n @end smallexample\n@@ -205,8 +206,9 @@ in the following sections.\n @smallexample\n @emph{M680x0 Options}\n -m68000  -m68020  -m68020-40  -m68020-60  -m68030  -m68040\n--m68060  -mcpu32 -m5200  -m68881  -mbitfield  -mc68000  -mc68020  -mfpa\n--mnobitfield  -mrtd  -mshort  -msoft-float  -malign-int\n+-m68060  -mcpu32 -m5200  -m68881  -mbitfield  -mc68000  -mc68020  \n+-mfpa -mnobitfield  -mrtd  -mshort  -msoft-float  \n+-malign-int\n \n @emph{VAX Options}\n -mg  -mgnu  -munix\n@@ -332,14 +334,14 @@ in the following sections.\n -malign-functions=@var{num}\n \n @emph{HPPA Options}\n--mbig-switch  -mdisable-fpregs  -mdisable-indexing  -mfast-indirect-calls\n--mgas  -mjump-in-delay  -mlong-load-store  -mno-big-switch  -mno-disable-fpregs\n+-mbig-switch  -mdisable-fpregs  -mdisable-indexing  \n+-mfast-indirect-calls -mgas  -mjump-in-delay  \n+-mlong-load-store  -mno-big-switch  -mno-disable-fpregs\n -mno-disable-indexing  -mno-fast-indirect-calls  -mno-gas\n--mno-jump-in-delay\n--mno-long-load-store\n--mno-portable-runtime  -mno-soft-float  -mno-space  -mno-space-regs\n--msoft-float\n--mpa-risc-1-0  -mpa-risc-1-1  -mportable-runtime\n+-mno-jump-in-delay  -mno-long-load-store  \n+-mno-portable-runtime  -mno-soft-float  -mno-space  \n+-mno-space-regs  -msoft-float  -mpa-risc-1-0  \n+-mpa-risc-1-1  -mportable-runtime\n -mschedule=@var{list}  -mspace  -mspace-regs\n \n @emph{Intel 960 Options}\n@@ -564,8 +566,8 @@ compiler that understands the C++ language---and under some\n circumstances, you might want to compile programs from standard input,\n or otherwise without a suffix that flags them as C++ programs.\n @code{g++} is a program that calls GNU CC with the default language\n-set to C++, and automatically specifies linking against the GNU class\n-library libg++.\n+set to C++, and automatically specifies linking against the C++\n+library.\n @cindex @code{g++ 1.@var{xx}}\n @cindex @code{g++}, separate compiler\n @cindex @code{g++} older version\n@@ -766,8 +768,8 @@ rely on ANSI C features.  Some vendors are starting to ship systems with\n ANSI C header files and you cannot use @samp{-traditional} on such\n systems to compile files that include any system headers.\n \n-The @samp{-traditional} option also enables the @samp{-traditional-cpp}\n-option, which is described next.\n+The @samp{-traditional} option also enables @samp{-traditional-cpp},\n+which is described next.\n \n @item -traditional-cpp\n Attempt to support some aspects of traditional C preprocessors.\n@@ -1013,7 +1015,7 @@ Support virtual function calls for objects that exceed the size\n representable by a @samp{short int}.  Users should not use this flag by\n default; if you need to use it, the compiler will tell you so.  If you\n compile any of your code with this flag, you must compile @emph{all} of\n-your code with this flag (including libg++, if you use it).\n+your code with this flag (including the C++ library, if you use it).\n \n This flag is not useful when compiling with -fvtable-thunks.\n \n@@ -1145,7 +1147,7 @@ conforming programs must not rely on a maximum depth greater than 17.\n @item -nostdinc++\n Do not search for header files in the standard directories specific to\n C++, but do still search the other standard directories.  (This option\n-is used when building libg++.)\n+is used when building the C++ library.)\n \n @item -traditional\n For C++ programs (in addition to the effects that apply to both C and\n@@ -1266,7 +1268,8 @@ Warn when a declaration does not specify a type.\n Warn whenever a function is used before being declared.\n \n @item -Wimplicit\n-Same as @samp{-Wimplicit-int} @samp{-Wimplicit-function-declaration}.\n+Same as @samp{-Wimplicit-int} and @samp{-Wimplicit-function-}@*\n+@samp{declaration}.\n \n @item -Wmain\n Warn if the type of @samp{main} is suspicious.  @samp{main} should be a\n@@ -1507,7 +1510,7 @@ arguments.\n @item\n A comparison between signed and unsigned values could produce an\n incorrect result when the signed value is converted to unsigned.\n-(But do not warn if @samp{-Wno-sign-compare} is also specified.)\n+(But don't warn if @samp{-Wno-sign-compare} is also specified.)\n \n @item\n An aggregate has a partly bracketed initializer.\n@@ -2368,7 +2371,7 @@ After running a program compiled with @samp{-fprofile-arcs}\n guessing the path a branch might take.\n \n @ifset INTERNALS\n-With @samp{-fbranch-probabilities}, GNU CC puts a @samp{REG_EXEC_COUNT}\n+With @samp{-fbranch-probabilities}, GCC puts a @samp{REG_EXEC_COUNT}\n note on the first instruction of each basic block, and a\n @samp{REG_BR_PROB} note on each @samp{JUMP_INSN} and @samp{CALL_INSN}.\n These can be used to improve optimization.  Currently, they are only\n@@ -3229,7 +3232,7 @@ Set the instruction scheduling parameters for machine type\n option @samp{-mcpu=}@var{cpu_type} would.\n \n The same values for @samp{-mcpu=}@var{cpu_type} are used for\n-@samp{-mtune=}@var{cpu_type}, though the only useful values are those that\n+@samp{-mtune=}@*@var{cpu_type}, though the only useful values are those that\n select a particular cpu implementation: @samp{cypress}, @samp{supersparc},\n @samp{f930}, @samp{f934}, @samp{tsc701}, @samp{ultrasparc}.\n "}, {"sha": "dad2dca2101c23b4be54a6350e1be5f5fe7eb80f", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -935,17 +935,13 @@ XFtype\n __floatdixf (DItype u)\n {\n   XFtype d;\n-  SItype negate = 0;\n \n-  if (u < 0)\n-    u = -u, negate = 1;\n-\n-  d = (USItype) (u >> WORD_SIZE);\n+  d = (SItype) (u >> WORD_SIZE);\n   d *= HIGH_HALFWORD_COEFF;\n   d *= HIGH_HALFWORD_COEFF;\n   d += (USItype) (u & (HIGH_WORD_COEFF - 1));\n \n-  return (negate ? -d : d);\n+  return d;\n }\n #endif\n \n@@ -958,17 +954,13 @@ TFtype\n __floatditf (DItype u)\n {\n   TFtype d;\n-  SItype negate = 0;\n-\n-  if (u < 0)\n-    u = -u, negate = 1;\n \n-  d = (USItype) (u >> WORD_SIZE);\n+  d = (SItype) (u >> WORD_SIZE);\n   d *= HIGH_HALFWORD_COEFF;\n   d *= HIGH_HALFWORD_COEFF;\n   d += (USItype) (u & (HIGH_WORD_COEFF - 1));\n \n-  return (negate ? -d : d);\n+  return d;\n }\n #endif\n \n@@ -981,17 +973,13 @@ DFtype\n __floatdidf (DItype u)\n {\n   DFtype d;\n-  SItype negate = 0;\n \n-  if (u < 0)\n-    u = -u, negate = 1;\n-\n-  d = (USItype) (u >> WORD_SIZE);\n+  d = (SItype) (u >> WORD_SIZE);\n   d *= HIGH_HALFWORD_COEFF;\n   d *= HIGH_HALFWORD_COEFF;\n   d += (USItype) (u & (HIGH_WORD_COEFF - 1));\n \n-  return (negate ? -d : d);\n+  return d;\n }\n #endif\n \n@@ -1036,10 +1024,6 @@ __floatdisf (DItype u)\n      so that we don't lose any of the precision of the high word\n      while multiplying it.  */\n   DFtype f;\n-  SItype negate = 0;\n-\n-  if (u < 0)\n-    u = -u, negate = 1;\n \n   /* Protect against double-rounding error.\n      Represent any low-order bits, that might be truncated in DFmode,\n@@ -1051,18 +1035,19 @@ __floatdisf (DItype u)\n       && DF_SIZE > (DI_SIZE - DF_SIZE + SF_SIZE))\n     {\n #define REP_BIT ((USItype) 1 << (DI_SIZE - DF_SIZE))\n-      if (u >= ((UDItype) 1 << DF_SIZE))\n+      if (! (- ((UDItype) 1 << DF_SIZE) < u\n+\t     && u < ((UDItype) 1 << DF_SIZE)))\n \t{\n \t  if ((USItype) u & (REP_BIT - 1))\n \t    u |= REP_BIT;\n \t}\n     }\n-  f = (USItype) (u >> WORD_SIZE);\n+  f = (SItype) (u >> WORD_SIZE);\n   f *= HIGH_HALFWORD_COEFF;\n   f *= HIGH_HALFWORD_COEFF;\n   f += (USItype) (u & (HIGH_WORD_COEFF - 1));\n \n-  return (SFtype) (negate ? -f : f);\n+  return (SFtype) f;\n }\n #endif\n \n@@ -2988,9 +2973,9 @@ exit (int status)\n #endif /* No NEED_ATEXIT */\n #endif /* !defined (INIT_SECTION_ASM_OP) || !defined (OBJECT_FORMAT_ELF) */\n /* In gbl-ctors.h, ON_EXIT is defined if HAVE_ATEXIT is defined.  In\n-__bb_init_func and _bb_init_prg, __bb_exit_func is registered with ON_EXIT if\n-ON_EXIT is defined.  Thus we must not call __bb_exit_func here anymore if\n-HAVE_ATEXIT is defined. */\n+   __bb_init_func and _bb_init_prg, __bb_exit_func is registered with\n+   ON_EXIT if ON_EXIT is defined.  Thus we must not call __bb_exit_func here\n+   if HAVE_ATEXIT is defined. */\n #ifndef HAVE_ATEXIT\n #ifndef inhibit_libc\n   __bb_exit_func ();"}, {"sha": "d46ca6488348e877d34aa37c4759f2f9231465f1", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Perform various loop optimizations, including strength reduction.\n-   Copyright (C) 1987, 88, 89, 91-7, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 91-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "6517656e27124105b555491383f3f6132edaed41", "filename": "gcc/machmode.def", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,6 +1,6 @@\n /* This file contains the definitions and documentation for the\n    machine modes used in the the GNU compiler.\n-   Copyright (C) 1987, 1992, 1994, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1992, 1994, 1997, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -42,7 +42,7 @@ Boston, MA 02111-1307, USA.  */\n    Third argument states the kind of representation:\n    MODE_INT - integer\n    MODE_FLOAT - floating\n-   MODE_PARTIAL_INT - PSImode and PDImode\n+   MODE_PARTIAL_INT - PQImode, PHImode, PSImode and PDImode\n    MODE_CC - modes used for representing the condition code in a register\n    MODE_COMPLEX_INT, MODE_COMPLEX_FLOAT - complex number\n    MODE_RANDOM - anything else\n@@ -63,7 +63,9 @@ Boston, MA 02111-1307, USA.  */\n    as for example on CONST_INT RTL expressions.  */\n DEF_MACHMODE (VOIDmode, \"VOID\", MODE_RANDOM, 0, 0, VOIDmode)\n \n+DEF_MACHMODE (PQImode, \"PQI\", MODE_PARTIAL_INT, 1, 1, PHImode)\n DEF_MACHMODE (QImode, \"QI\", MODE_INT, 1, 1, HImode)\t\t/* int types */\n+DEF_MACHMODE (PHImode, \"PHI\", MODE_PARTIAL_INT, 2, 2, PSImode)\n DEF_MACHMODE (HImode, \"HI\", MODE_INT, 2, 2, SImode)\n /* Pointers on some machines use this type to distinguish them from ints.\n    Useful if a pointer is 4 bytes but has some bits that are not significant,"}, {"sha": "e9d4e83e637c825c87ed84b80f807a9f74eb8f8c", "filename": "gcc/md.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmd.texi?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1949,7 +1949,14 @@ The @samp{cmp@var{m}} patterns should be used instead.\n @item @samp{movstr@var{m}}\n Block move instruction.  The addresses of the destination and source\n strings are the first two operands, and both are in mode @code{Pmode}.\n+\n The number of bytes to move is the third operand, in mode @var{m}.\n+Usually, you specify @code{word_mode} for @var{m}.  However, if you can\n+generate better code knowing the range of valid lengths is smaller than\n+those representable in a full word, you should provide a pattern with a\n+mode corresponding to the range of values you can handle efficiently\n+(e.g., @code{QImode} for values in the range 0--127; note we avoid numbers\n+that appear negative) and also a pattern with @code{word_mode}.\n \n The fourth operand is the known shared alignment of the source and\n destination, in the form of a @code{const_int} rtx.  Thus, if the\n@@ -1969,7 +1976,8 @@ that the source and destination strings might overlap.\n @item @samp{clrstr@var{m}}\n Block clear instruction.  The addresses of the destination string is the\n first operand, in mode @code{Pmode}.  The number of bytes to clear is\n-the second operand, in mode @var{m}.\n+the second operand, in mode @var{m}.  See @samp{movstr@var{m}} for\n+a discussion of the choice of mode.\n \n The third operand is the known alignment of the destination, in the form\n of a @code{const_int} rtx.  Thus, if the compiler knows that the"}, {"sha": "8069ddb5597dfa5d459c85f097158b9dcc4773eb", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -2,8 +2,8 @@\n    contain debugging information specified by the GNU compiler\n    in the form of comments (the mips assembler does not support\n    assembly access to debug information).\n-   Copyright (C) 1991, 1993, 1994, 1995, 1997 Free Software Foundation, Inc.\n-   Contributed by Michael Meissner, meissner@osf.org\n+   Copyright (C) 1991, 93, 94, 95, 97, 1998 Free Software Foundation, Inc.\n+   Contributed by Michael Meissner (meissner@cygnus.com).\n    \n This file is part of GNU CC.\n \n@@ -1761,6 +1761,7 @@ extern char  *sbrk\t\t\t__proto((int));\n #ifdef NEED_DECLARATION_FREE\n extern void   free\t\t\t__proto((PTR_T));\n #endif\n+\n extern char  *mktemp\t\t\t__proto((char *));\n extern long   strtol\t\t\t__proto((const char *, char **, int));\n "}, {"sha": "4b41c9a1433fc8adbe1578cfe0b913e10e30563d", "filename": "gcc/objc/Make-lang.in", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fobjc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fobjc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FMake-lang.in?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n # Top level makefile fragment for GNU Objective-C\n-#   Copyright (C) 1997 Free Software Foundation, Inc.\n+#   Copyright (C) 1997, 1998 Free Software Foundation, Inc.\n \n #This file is part of GNU CC.\n \n@@ -130,7 +130,7 @@ objc/sarray.o: $(srcdir)/objc/sarray.c $(GCC_PASSES)\n objc/class.o: $(srcdir)/objc/class.c $(GCC_PASSES)\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n \t-c $(srcdir)/objc/class.c -o $@\n-objc/sendmsg.o: $(srcdir)/objc/sendmsg.c $(GCC_PASSES)\n+objc/sendmsg.o: $(srcdir)/objc/sendmsg.c $(GCC_PASSES) objc/runtime-info.h\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) -Iobjc \\\n \t-c $(srcdir)/objc/sendmsg.c -o $@\n objc/init.o: $(srcdir)/objc/init.c $(GCC_PASSES)\n@@ -209,10 +209,10 @@ libobjc.dll: libobjc_s.a objc/libobjc_entry.o\n \n # Platform generated information needed by ObjC runtime\n objc/runtime-info.h: cc1obj\n-\techo \"\" > emptyfile\n+\techo \"\" > tmp-runtime\n \techo \"/* This file is automatically generated */\" >$@\n-\t./cc1obj -print-objc-runtime-info emptyfile >>$@\n-\n+\t./cc1obj -print-objc-runtime-info tmp-runtime >>$@\n+\trm -f tmp-runtime\n #\f\n # Build hooks:\n \n@@ -301,9 +301,11 @@ objc.stage4: stage4-start\n \n # This target creates the files that can be rebuilt, but go in the\n # distribution anyway.  It then copies the files to the distdir directory.\n-objc.distdir:\n+# ??? Note that this should be fixed once the Makefile is fixed to do\n+# the build in the inner directory.\n+objc.distdir: $(srcdir)/objc/objc-parse.c\n \tmkdir tmp/objc\n-\tcd objc ; $(MAKE) $(FLAGS_TO_PASS) objc-parse.c\n+#\tcd objc ; $(MAKE) $(FLAGS_TO_PASS) objc-parse.c\n \tcd objc; \\\n \tfor file in *[0-9a-zA-Z+]; do \\\n \t  ln $$file ../tmp/objc >/dev/null 2>&1 || cp $$file ../tmp/objc; \\"}, {"sha": "cf3f3f708041041dcb9ad47e95d07679531e58d4", "filename": "gcc/objc/objc-parse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fobjc%2Fobjc-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fobjc%2Fobjc-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-parse.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1638,7 +1638,7 @@ static const short yycheck[] = {     9,\n     48,    49,    50,    51,    52\n };\n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/cygnus/latest-940103/share/bison.simple\"\n+#line 3 \"/usr/cygnus/progressive-97r2/share/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -1831,7 +1831,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/usr/cygnus/latest-940103/share/bison.simple\"\n+#line 196 \"/usr/cygnus/progressive-97r2/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -4911,7 +4911,7 @@ case 556:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/usr/cygnus/latest-940103/share/bison.simple\"\n+#line 498 \"/usr/cygnus/progressive-97r2/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;"}, {"sha": "807ad5a952c9a2489a77a2f45aceb10169837401", "filename": "gcc/objc/objc-parse.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fobjc%2Fobjc-parse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fobjc%2Fobjc-parse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-parse.y?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,6 +1,6 @@\n /*WARNING: This file is automatically generated!*/\n /* YACC parser for C syntax and for Objective C.  -*-c-*-\n-   Copyright (C) 1987, 88, 89, 92-6, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "e5b5d4fd6c9f89044af3b3728036447d684ddc52", "filename": "gcc/obstack.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fobstack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fobstack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobstack.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,7 +1,6 @@\n /* obstack.c - subroutines used implicitly by object stack macros\n    Copyright (C) 1988,89,90,91,92,93,94,96,97 Free Software Foundation, Inc.\n \n-   the C library, however.  The master source lives in /gd/gnu/lib.\n \n    NOTE: The canonical source of this file is maintained with the GNU C Library.\n    Bugs can be reported to bug-glibc@prep.ai.mit.edu."}, {"sha": "144998cbcc1426bedc7e713a1905a0065941670d", "filename": "gcc/obstack.h", "status": "modified", "additions": 83, "deletions": 90, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fobstack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fobstack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobstack.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,7 +1,6 @@\n /* obstack.h - object stack macros\n-   Copyright (C) 1988,89,90,91,92,93,94,96,97 Free Software Foundation, Inc.\n+   Copyright (C) 1988,89,90,91,92,93,94,96,97,98 Free Software Foundation, Inc.\n \n-   the C library, however.  The master source lives in /gd/gnu/lib.\n \n    NOTE: The canonical source of this file is maintained with the GNU C Library.\n    Bugs can be reported to bug-glibc@prep.ai.mit.edu.\n@@ -118,45 +117,39 @@ extern \"C\" {\n    may ignore the byte-within-word field of the pointer.  */\n \n #ifndef __PTR_TO_INT\n-#define __PTR_TO_INT(P) ((P) - (char *) 0)\n+# define __PTR_TO_INT(P) ((P) - (char *) 0)\n #endif\n \n #ifndef __INT_TO_PTR\n-#define __INT_TO_PTR(P) ((P) + (char *) 0)\n+# define __INT_TO_PTR(P) ((P) + (char *) 0)\n #endif\n \n-/* We need the type of the resulting object.  In ANSI C it is ptrdiff_t\n-   but in traditional C it is usually long.  If we are in ANSI C and\n-   don't already have ptrdiff_t get it.  */\n-\n-#if defined (__STDC__) && __STDC__ && ! defined (offsetof)\n-#if defined (__GNUC__) && defined (IN_GCC)\n-/* On Next machine, the system's stddef.h screws up if included\n-   after we have defined just ptrdiff_t, so include all of stddef.h.\n-   Otherwise, define just ptrdiff_t, which is all we need.  */\n-#ifndef __NeXT__\n-#define __need_ptrdiff_t\n-#endif\n-#endif\n+/* We need the type of the resulting object.  If __PTRDIFF_TYPE__ is\n+   defined, as with GNU C, use that; that way we don't pollute the\n+   namespace with <stddef.h>'s symbols.  Otherwise, if <stddef.h> is\n+   available, include it and use ptrdiff_t.  In traditional C, long is\n+   the best that we can do.  */\n \n-#include <stddef.h>\n-#endif\n-\n-#if defined (__STDC__) && __STDC__\n-#define PTR_INT_TYPE ptrdiff_t\n+#ifdef __PTRDIFF_TYPE__\n+# define PTR_INT_TYPE __PTRDIFF_TYPE__\n #else\n-#define PTR_INT_TYPE long\n+# ifdef HAVE_STDDEF_H\n+#  include <stddef.h>\n+#  define PTR_INT_TYPE ptrdiff_t\n+# else\n+#  define PTR_INT_TYPE long\n+# endif\n #endif\n \n-#if defined (_LIBC) || defined (HAVE_STRING_H)\n-#include <string.h>\n-#define _obstack_memcpy(To, From, N) memcpy ((To), (From), (N))\n-#else\n-#ifdef memcpy\n-#define _obstack_memcpy(To, From, N) memcpy ((To), (From), (N))\n+#if defined _LIBC || defined HAVE_STRING_H\n+# include <string.h>\n+# define _obstack_memcpy(To, From, N) memcpy ((To), (From), (N))\n #else\n-#define _obstack_memcpy(To, From, N) bcopy ((From), (To), (N))\n-#endif\n+# ifdef memcpy\n+#  define _obstack_memcpy(To, From, N) memcpy ((To), (From), (N))\n+# else\n+#  define _obstack_memcpy(To, From, N) bcopy ((From), (To), (N))\n+# endif\n #endif\n \n struct _obstack_chunk\t\t/* Lives at front of each chunk. */\n@@ -175,7 +168,7 @@ struct obstack\t\t/* control current object in current chunk */\n   char\t*chunk_limit;\t\t/* address of char after current chunk */\n   PTR_INT_TYPE temp;\t\t/* Temporary for some macros.  */\n   int   alignment_mask;\t\t/* Mask of alignment for each object. */\n-#if defined (__STDC__) && __STDC__\n+#if defined __STDC__ && __STDC__\n   /* These prototypes vary based on `use_extra_arg', and we use\n      casts to the prototypeless function type in all assignments,\n      but having prototypes here quiets -Wstrict-prototypes.  */\n@@ -199,7 +192,7 @@ struct obstack\t\t/* control current object in current chunk */\n \n /* Declare the external functions we use; they are in obstack.c.  */\n \n-#if defined (__STDC__) && __STDC__\n+#if defined __STDC__ && __STDC__\n extern void _obstack_newchunk (struct obstack *, int);\n extern void _obstack_free (struct obstack *, void *);\n extern int _obstack_begin (struct obstack *, int, int,\n@@ -216,7 +209,7 @@ extern int _obstack_begin_1 ();\n extern int _obstack_memory_used ();\n #endif\n \f\n-#if defined (__STDC__) && __STDC__\n+#if defined __STDC__ && __STDC__\n \n /* Do the function-declarations after the structs\n    but before defining the macros.  */\n@@ -264,7 +257,7 @@ int obstack_memory_used (struct obstack *obstack);\n /* Error handler called when `obstack_chunk_alloc' failed to allocate\n    more memory.  This can be set to a user defined function.  The\n    default action is to print a message and abort.  */\n-#if defined (__STDC__) && __STDC__\n+#if defined __STDC__ && __STDC__\n extern void (*obstack_alloc_failed_handler) (void);\n #else\n extern void (*obstack_alloc_failed_handler) ();\n@@ -293,53 +286,53 @@ extern int obstack_exit_failure;\n \n /* To prevent prototype warnings provide complete argument list in\n    standard C version.  */\n-#if defined (__STDC__) && __STDC__\n+#if defined __STDC__ && __STDC__\n \n-#define obstack_init(h) \\\n+# define obstack_init(h) \\\n   _obstack_begin ((h), 0, 0, \\\n \t\t  (void *(*) (long)) obstack_chunk_alloc, (void (*) (void *)) obstack_chunk_free)\n \n-#define obstack_begin(h, size) \\\n+# define obstack_begin(h, size) \\\n   _obstack_begin ((h), (size), 0, \\\n \t\t  (void *(*) (long)) obstack_chunk_alloc, (void (*) (void *)) obstack_chunk_free)\n \n-#define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \\\n+# define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \\\n   _obstack_begin ((h), (size), (alignment), \\\n \t\t    (void *(*) (long)) (chunkfun), (void (*) (void *)) (freefun))\n \n-#define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \\\n+# define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \\\n   _obstack_begin_1 ((h), (size), (alignment), \\\n \t\t    (void *(*) (void *, long)) (chunkfun), \\\n \t\t    (void (*) (void *, void *)) (freefun), (arg))\n \n-#define obstack_chunkfun(h, newchunkfun) \\\n+# define obstack_chunkfun(h, newchunkfun) \\\n   ((h) -> chunkfun = (struct _obstack_chunk *(*)(void *, long)) (newchunkfun))\n \n-#define obstack_freefun(h, newfreefun) \\\n+# define obstack_freefun(h, newfreefun) \\\n   ((h) -> freefun = (void (*)(void *, struct _obstack_chunk *)) (newfreefun))\n \n #else\n \n-#define obstack_init(h) \\\n+# define obstack_init(h) \\\n   _obstack_begin ((h), 0, 0, \\\n \t\t  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)\n \n-#define obstack_begin(h, size) \\\n+# define obstack_begin(h, size) \\\n   _obstack_begin ((h), (size), 0, \\\n \t\t  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)\n \n-#define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \\\n+# define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \\\n   _obstack_begin ((h), (size), (alignment), \\\n \t\t    (void *(*) ()) (chunkfun), (void (*) ()) (freefun))\n \n-#define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \\\n+# define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \\\n   _obstack_begin_1 ((h), (size), (alignment), \\\n \t\t    (void *(*) ()) (chunkfun), (void (*) ()) (freefun), (arg))\n \n-#define obstack_chunkfun(h, newchunkfun) \\\n+# define obstack_chunkfun(h, newchunkfun) \\\n   ((h) -> chunkfun = (struct _obstack_chunk *(*)()) (newchunkfun))\n \n-#define obstack_freefun(h, newfreefun) \\\n+# define obstack_freefun(h, newfreefun) \\\n   ((h) -> freefun = (void (*)()) (newfreefun))\n \n #endif\n@@ -350,43 +343,43 @@ extern int obstack_exit_failure;\n \n #define obstack_memory_used(h) _obstack_memory_used (h)\n \f\n-#if defined (__GNUC__) && defined (__STDC__) && __STDC__\n+#if defined __GNUC__ && defined __STDC__ && __STDC__\n /* NextStep 2.0 cc is really gcc 1.93 but it defines __GNUC__ = 2 and\n    does not implement __extension__.  But that compiler doesn't define\n    __GNUC_MINOR__.  */\n-#if __GNUC__ < 2 || (__NeXT__ && !__GNUC_MINOR__)\n-#define __extension__\n-#endif\n+# if __GNUC__ < 2 || (__NeXT__ && !__GNUC_MINOR__)\n+#  define __extension__\n+# endif\n \n /* For GNU C, if not -traditional,\n    we can define these macros to compute all args only once\n    without using a global variable.\n    Also, we can avoid using the `temp' slot, to make faster code.  */\n \n-#define obstack_object_size(OBSTACK)\t\t\t\t\t\\\n+# define obstack_object_size(OBSTACK)\t\t\t\t\t\\\n   __extension__\t\t\t\t\t\t\t\t\\\n   ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n      (unsigned) (__o->next_free - __o->object_base); })\n \n-#define obstack_room(OBSTACK)\t\t\t\t\t\t\\\n+# define obstack_room(OBSTACK)\t\t\t\t\t\t\\\n   __extension__\t\t\t\t\t\t\t\t\\\n   ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n      (unsigned) (__o->chunk_limit - __o->next_free); })\n \n-#define obstack_make_room(OBSTACK,length)\t\t\t\t\\\n+# define obstack_make_room(OBSTACK,length)\t\t\t\t\\\n __extension__\t\t\t\t\t\t\t\t\\\n ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n    int __len = (length);\t\t\t\t\t\t\\\n    if (__o->chunk_limit - __o->next_free < __len)\t\t\t\\\n      _obstack_newchunk (__o, __len);\t\t\t\t\t\\\n    (void) 0; })\n \n-#define obstack_empty_p(OBSTACK)\t\t\t\t\t\\\n+# define obstack_empty_p(OBSTACK)\t\t\t\t\t\\\n   __extension__\t\t\t\t\t\t\t\t\\\n   ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n      (__o->chunk->prev == 0 && __o->next_free - __o->chunk->contents == 0); })\n \n-#define obstack_grow(OBSTACK,where,length)\t\t\t\t\\\n+# define obstack_grow(OBSTACK,where,length)\t\t\t\t\\\n __extension__\t\t\t\t\t\t\t\t\\\n ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n    int __len = (length);\t\t\t\t\t\t\\\n@@ -396,7 +389,7 @@ __extension__\t\t\t\t\t\t\t\t\\\n    __o->next_free += __len;\t\t\t\t\t\t\\\n    (void) 0; })\n \n-#define obstack_grow0(OBSTACK,where,length)\t\t\t\t\\\n+# define obstack_grow0(OBSTACK,where,length)\t\t\t\t\\\n __extension__\t\t\t\t\t\t\t\t\\\n ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n    int __len = (length);\t\t\t\t\t\t\\\n@@ -407,7 +400,7 @@ __extension__\t\t\t\t\t\t\t\t\\\n    *(__o->next_free)++ = 0;\t\t\t\t\t\t\\\n    (void) 0; })\n \n-#define obstack_1grow(OBSTACK,datum)\t\t\t\t\t\\\n+# define obstack_1grow(OBSTACK,datum)\t\t\t\t\t\\\n __extension__\t\t\t\t\t\t\t\t\\\n ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n    if (__o->next_free + 1 > __o->chunk_limit)\t\t\t\t\\\n@@ -419,26 +412,26 @@ __extension__\t\t\t\t\t\t\t\t\\\n    and that the data added so far to the current object\n    shares that much alignment.  */\n \n-#define obstack_ptr_grow(OBSTACK,datum)\t\t\t\t\t\\\n+# define obstack_ptr_grow(OBSTACK,datum)\t\t\t\t\\\n __extension__\t\t\t\t\t\t\t\t\\\n ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n    if (__o->next_free + sizeof (void *) > __o->chunk_limit)\t\t\\\n      _obstack_newchunk (__o, sizeof (void *));\t\t\t\t\\\n    *((void **)__o->next_free)++ = ((void *)datum);\t\t\t\\\n    (void) 0; })\n \n-#define obstack_int_grow(OBSTACK,datum)\t\t\t\t\t\\\n+# define obstack_int_grow(OBSTACK,datum)\t\t\t\t\\\n __extension__\t\t\t\t\t\t\t\t\\\n ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n    if (__o->next_free + sizeof (int) > __o->chunk_limit)\t\t\\\n      _obstack_newchunk (__o, sizeof (int));\t\t\t\t\\\n    *((int *)__o->next_free)++ = ((int)datum);\t\t\t\t\\\n    (void) 0; })\n \n-#define obstack_ptr_grow_fast(h,aptr) (*((void **) (h)->next_free)++ = (void *)aptr)\n-#define obstack_int_grow_fast(h,aint) (*((int *) (h)->next_free)++ = (int) aint)\n+# define obstack_ptr_grow_fast(h,aptr) (*((void **) (h)->next_free)++ = (void *)aptr)\n+# define obstack_int_grow_fast(h,aint) (*((int *) (h)->next_free)++ = (int) aint)\n \n-#define obstack_blank(OBSTACK,length)\t\t\t\t\t\\\n+# define obstack_blank(OBSTACK,length)\t\t\t\t\t\\\n __extension__\t\t\t\t\t\t\t\t\\\n ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n    int __len = (length);\t\t\t\t\t\t\\\n@@ -447,27 +440,27 @@ __extension__\t\t\t\t\t\t\t\t\\\n    __o->next_free += __len;\t\t\t\t\t\t\\\n    (void) 0; })\n \n-#define obstack_alloc(OBSTACK,length)\t\t\t\t\t\\\n+# define obstack_alloc(OBSTACK,length)\t\t\t\t\t\\\n __extension__\t\t\t\t\t\t\t\t\\\n ({ struct obstack *__h = (OBSTACK);\t\t\t\t\t\\\n    obstack_blank (__h, (length));\t\t\t\t\t\\\n    obstack_finish (__h); })\n \n-#define obstack_copy(OBSTACK,where,length)\t\t\t\t\\\n+# define obstack_copy(OBSTACK,where,length)\t\t\t\t\\\n __extension__\t\t\t\t\t\t\t\t\\\n ({ struct obstack *__h = (OBSTACK);\t\t\t\t\t\\\n    obstack_grow (__h, (where), (length));\t\t\t\t\\\n    obstack_finish (__h); })\n \n-#define obstack_copy0(OBSTACK,where,length)\t\t\t\t\\\n+# define obstack_copy0(OBSTACK,where,length)\t\t\t\t\\\n __extension__\t\t\t\t\t\t\t\t\\\n ({ struct obstack *__h = (OBSTACK);\t\t\t\t\t\\\n    obstack_grow0 (__h, (where), (length));\t\t\t\t\\\n    obstack_finish (__h); })\n \n /* The local variable is named __o1 to avoid a name conflict\n    when obstack_blank is called.  */\n-#define obstack_finish(OBSTACK)  \t\t\t\t\t\\\n+# define obstack_finish(OBSTACK)  \t\t\t\t\t\\\n __extension__\t\t\t\t\t\t\t\t\\\n ({ struct obstack *__o1 = (OBSTACK);\t\t\t\t\t\\\n    void *value;\t\t\t\t\t\t\t\t\\\n@@ -483,7 +476,7 @@ __extension__\t\t\t\t\t\t\t\t\\\n    __o1->object_base = __o1->next_free;\t\t\t\t\t\\\n    value; })\n \n-#define obstack_free(OBSTACK, OBJ)\t\t\t\t\t\\\n+# define obstack_free(OBSTACK, OBJ)\t\t\t\t\t\\\n __extension__\t\t\t\t\t\t\t\t\\\n ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n    void *__obj = (OBJ);\t\t\t\t\t\t\t\\\n@@ -493,13 +486,13 @@ __extension__\t\t\t\t\t\t\t\t\\\n \f\n #else /* not __GNUC__ or not __STDC__ */\n \n-#define obstack_object_size(h) \\\n+# define obstack_object_size(h) \\\n  (unsigned) ((h)->next_free - (h)->object_base)\n \n-#define obstack_room(h)\t\t\\\n+# define obstack_room(h)\t\t\\\n  (unsigned) ((h)->chunk_limit - (h)->next_free)\n \n-#define obstack_empty_p(h) \\\n+# define obstack_empty_p(h) \\\n  ((h)->chunk->prev == 0 && (h)->next_free - (h)->chunk->contents == 0)\n \n /* Note that the call to _obstack_newchunk is enclosed in (..., 0)\n@@ -508,60 +501,60 @@ __extension__\t\t\t\t\t\t\t\t\\\n    Casting the third operand to void was tried before,\n    but some compilers won't accept it.  */\n \n-#define obstack_make_room(h,length)\t\t\t\t\t\\\n+# define obstack_make_room(h,length)\t\t\t\t\t\\\n ( (h)->temp = (length),\t\t\t\t\t\t\t\\\n   (((h)->next_free + (h)->temp > (h)->chunk_limit)\t\t\t\\\n    ? (_obstack_newchunk ((h), (h)->temp), 0) : 0))\n \n-#define obstack_grow(h,where,length)\t\t\t\t\t\\\n+# define obstack_grow(h,where,length)\t\t\t\t\t\\\n ( (h)->temp = (length),\t\t\t\t\t\t\t\\\n   (((h)->next_free + (h)->temp > (h)->chunk_limit)\t\t\t\\\n    ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),\t\t\t\\\n   _obstack_memcpy ((h)->next_free, (char *) (where), (h)->temp),\t\\\n   (h)->next_free += (h)->temp)\n \n-#define obstack_grow0(h,where,length)\t\t\t\t\t\\\n+# define obstack_grow0(h,where,length)\t\t\t\t\t\\\n ( (h)->temp = (length),\t\t\t\t\t\t\t\\\n   (((h)->next_free + (h)->temp + 1 > (h)->chunk_limit)\t\t\t\\\n    ? (_obstack_newchunk ((h), (h)->temp + 1), 0) : 0),\t\t\t\\\n   _obstack_memcpy ((h)->next_free, (char *) (where), (h)->temp),\t\\\n   (h)->next_free += (h)->temp,\t\t\t\t\t\t\\\n   *((h)->next_free)++ = 0)\n \n-#define obstack_1grow(h,datum)\t\t\t\t\t\t\\\n+# define obstack_1grow(h,datum)\t\t\t\t\t\t\\\n ( (((h)->next_free + 1 > (h)->chunk_limit)\t\t\t\t\\\n    ? (_obstack_newchunk ((h), 1), 0) : 0),\t\t\t\t\\\n   (*((h)->next_free)++ = (datum)))\n \n-#define obstack_ptr_grow(h,datum)\t\t\t\t\t\\\n+# define obstack_ptr_grow(h,datum)\t\t\t\t\t\\\n ( (((h)->next_free + sizeof (char *) > (h)->chunk_limit)\t\t\\\n    ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),\t\t\\\n   (*((char **) (((h)->next_free+=sizeof(char *))-sizeof(char *))) = ((char *) datum)))\n \n-#define obstack_int_grow(h,datum)\t\t\t\t\t\\\n+# define obstack_int_grow(h,datum)\t\t\t\t\t\\\n ( (((h)->next_free + sizeof (int) > (h)->chunk_limit)\t\t\t\\\n    ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),\t\t\t\\\n   (*((int *) (((h)->next_free+=sizeof(int))-sizeof(int))) = ((int) datum)))\n \n-#define obstack_ptr_grow_fast(h,aptr) (*((char **) (h)->next_free)++ = (char *) aptr)\n-#define obstack_int_grow_fast(h,aint) (*((int *) (h)->next_free)++ = (int) aint)\n+# define obstack_ptr_grow_fast(h,aptr) (*((char **) (h)->next_free)++ = (char *) aptr)\n+# define obstack_int_grow_fast(h,aint) (*((int *) (h)->next_free)++ = (int) aint)\n \n-#define obstack_blank(h,length)\t\t\t\t\t\t\\\n+# define obstack_blank(h,length)\t\t\t\t\t\\\n ( (h)->temp = (length),\t\t\t\t\t\t\t\\\n   (((h)->chunk_limit - (h)->next_free < (h)->temp)\t\t\t\\\n    ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),\t\t\t\\\n   ((h)->next_free += (h)->temp))\n \n-#define obstack_alloc(h,length)\t\t\t\t\t\t\\\n+# define obstack_alloc(h,length)\t\t\t\t\t\\\n  (obstack_blank ((h), (length)), obstack_finish ((h)))\n \n-#define obstack_copy(h,where,length)\t\t\t\t\t\\\n+# define obstack_copy(h,where,length)\t\t\t\t\t\\\n  (obstack_grow ((h), (where), (length)), obstack_finish ((h)))\n \n-#define obstack_copy0(h,where,length)\t\t\t\t\t\\\n+# define obstack_copy0(h,where,length)\t\t\t\t\t\\\n  (obstack_grow0 ((h), (where), (length)), obstack_finish ((h)))\n \n-#define obstack_finish(h)  \t\t\t\t\t\t\\\n+# define obstack_finish(h)  \t\t\t\t\t\t\\\n ( ((h)->next_free == (h)->object_base\t\t\t\t\t\\\n    ? (((h)->maybe_empty_object = 1), 0)\t\t\t\t\t\\\n    : 0),\t\t\t\t\t\t\t\t\\\n@@ -575,21 +568,21 @@ __extension__\t\t\t\t\t\t\t\t\\\n   (h)->object_base = (h)->next_free,\t\t\t\t\t\\\n   __INT_TO_PTR ((h)->temp))\n \n-#if defined (__STDC__) && __STDC__\n-#define obstack_free(h,obj)\t\t\t\t\t\t\\\n+# if defined __STDC__ && __STDC__\n+#  define obstack_free(h,obj)\t\t\t\t\t\t\\\n ( (h)->temp = (char *) (obj) - (char *) (h)->chunk,\t\t\t\\\n   (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\\\n    ? (int) ((h)->next_free = (h)->object_base\t\t\t\t\\\n \t    = (h)->temp + (char *) (h)->chunk)\t\t\t\t\\\n    : (((obstack_free) ((h), (h)->temp + (char *) (h)->chunk), 0), 0)))\n-#else\n-#define obstack_free(h,obj)\t\t\t\t\t\t\\\n+# else\n+#  define obstack_free(h,obj)\t\t\t\t\t\t\\\n ( (h)->temp = (char *) (obj) - (char *) (h)->chunk,\t\t\t\\\n   (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\\\n    ? (int) ((h)->next_free = (h)->object_base\t\t\t\t\\\n \t    = (h)->temp + (char *) (h)->chunk)\t\t\t\t\\\n    : (_obstack_free ((h), (h)->temp + (char *) (h)->chunk), 0)))\n-#endif\n+# endif\n \n #endif /* not __GNUC__ or not __STDC__ */\n "}, {"sha": "dd0c51c16f77c9c2c4e5f65da1995c92f2e67855", "filename": "gcc/optabs.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -3175,15 +3175,14 @@ emit_conditional_move (target, code, op0, op1, cmode, op2, op3, mode,\n   if (cmode == VOIDmode)\n     cmode = GET_MODE (op0);\n \n-  if ((CONSTANT_P (op2) && ! CONSTANT_P (op3))\n-      || (GET_CODE (op2) == CONST_INT && GET_CODE (op3) != CONST_INT))\n+  if (((CONSTANT_P (op2) && ! CONSTANT_P (op3))\n+       || (GET_CODE (op2) == CONST_INT && GET_CODE (op3) != CONST_INT))\n+      && (GET_MODE_CLASS (GET_MODE (op1)) != MODE_FLOAT\n+\t  || TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT || flag_fast_math))\n     {\n       tem = op2;\n       op2 = op3;\n       op3 = tem;\n-      /* ??? This may not be appropriate (consider IEEE).  Perhaps we should\n-\t call can_reverse_comparison_p here and bail out if necessary.\n-\t It's not clear whether we need to do this canonicalization though.  */\n       code = reverse_condition (code);\n     }\n "}, {"sha": "1c96c58e54ad741b8252957e218eb2c34628f497", "filename": "gcc/prefix.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fprefix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fprefix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprefix.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -240,7 +240,7 @@ translate_name (name)\n      char *name;\n {\n   char code = name[0];\n-  char *key, *prefix;\n+  char *key, *prefix = 0;\n   int keylen;\n \n   if (code != '@' && code != '$')\n@@ -268,11 +268,10 @@ translate_name (name)\n \tprefix = std_prefix;\n     }\n   else\n-    {\n-      prefix = getenv (key);\n-      if (prefix == 0)\n-\tprefix = concat (\"$\", key, NULL_PTR);\n-    }\n+    prefix = getenv (key);\n+\n+  if (prefix == 0)\n+    prefix = PREFIX;\n \n   /* Remove any trailing directory separator from what we got.  */\n   if (prefix[strlen (prefix) - 1] == '/'"}, {"sha": "bec6ca36d6aa22731a48aa13044aee998bd919e5", "filename": "gcc/profile.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Calculate branch probabilities, and basic block execution counts. \n-   Copyright (C) 1990, 91-94, 97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1990, 91-94, 96, 97, 1998 Free Software Foundation, Inc.\n    Contributed by James E. Wilson, UC Berkeley/Cygnus Support;\n    based on some ideas from Dain Samples of UC Berkeley.\n    Further mangling by Bob Manson, Cygnus Support.\n@@ -618,7 +618,7 @@ branch_prob (f, dump_file)\n     register int i;\n     int fall_through = 0;\n     struct adj_list *arcptr;\n-    int dest = NULL_RTX;\n+    int dest = 0;\n \n     /* Block 0 always falls through to block 1.  */\n     num_arcs = 0;\n@@ -1652,7 +1652,8 @@ output_func_start_profiler ()\n   /* Reset flag_inline_functions to its original value.  */\n   flag_inline_functions = save_flag_inline_functions;\n \n-  fflush (asm_out_file);\n+  if (! quiet_flag)\n+    fflush (asm_out_file);\n   current_function_decl = NULL_TREE;\n \n   assemble_constructor (IDENTIFIER_POINTER (DECL_NAME (fndecl)));"}, {"sha": "8efad717662b3ef415171e77723abd89d8fcf072", "filename": "gcc/protoize.c", "status": "modified", "additions": 59, "deletions": 29, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -128,7 +128,11 @@ extern char *version_string;\n \n #define my_access(file,flag)\taccess((char *)file, flag)\n #define my_stat(file,pkt)\tstat((char *)file, pkt)\n+#ifdef __MINGW32__\n+#define my_link(file1, file2)\t-1\n+#else\n #define my_link(file1, file2)\tlink((char *)file1, (char *)file2)\n+#endif\n #define my_unlink(file)\t\tunlink((char *)file)\n #define my_open(file, mode, flag)\topen((char *)file, mode, flag)\n #define my_chmod(file, mode)\tchmod((char *)file, mode)\n@@ -212,9 +216,6 @@ extern int atoi ();\n extern int puts ();\n extern int fputs ();\n extern int fputc ();\n-#if !defined(_WIN32)\n-extern int link ();\n-#endif\n extern int unlink ();\n extern int access ();\n \n@@ -844,12 +845,13 @@ safe_write (desc, ptr, len, out_fname)\n     int written = write (desc, ptr, len);\n     if (written < 0)\n       {\n+\tint errno_val = errno;\n #ifdef EINTR\n-\tif (errno == EINTR)\n+\tif (errno_val == EINTR)\n \t  continue;\n #endif\n \tfprintf (stderr, \"%s: error writing file `%s': %s\\n\",\n-\t\t pname, shortpath (NULL, out_fname), my_strerror(errno));\n+\t\t pname, shortpath (NULL, out_fname), my_strerror (errno_val));\n \treturn;\n       }\n     ptr += written;\n@@ -1540,8 +1542,10 @@ find_file (filename, do_not_stat)\n         {\n           if (my_stat (filename, &stat_buf) == -1)\n             {\n+\t      int errno_val = errno;\n               fprintf (stderr, \"%s: %s: can't get status: %s\\n\",\n-\t\t       pname, shortpath (NULL, filename), my_strerror(errno));\n+\t\t       pname, shortpath (NULL, filename),\n+\t\t       my_strerror (errno_val));\n               stat_buf.st_mtime = (time_t) -1;\n             }\n         }\n@@ -2231,9 +2235,10 @@ start_over: ;\n \t}\n       else\n \t{\n+\t  int errno_val = errno;\n \t  fprintf (stderr, \"%s: can't read aux info file `%s': %s\\n\",\n \t\t   pname, shortpath (NULL, aux_info_filename),\n-\t\t   my_strerror(errno));\n+\t\t   my_strerror (errno_val));\n \t  errors++;\n \t  return;\n \t}\n@@ -2259,9 +2264,10 @@ start_over: ;\n \t}\n       if (my_access (aux_info_filename, R_OK) == -1)\n \t{\n+\t  int errno_val = errno;\n \t  fprintf (stderr, \"%s: can't read aux info file `%s': %s\\n\",\n \t\t   pname, shortpath (NULL, aux_info_filename),\n-\t\t   my_strerror(errno));\n+\t\t   my_strerror (errno_val));\n \t  errors++;\n \t  return;\n \t}\n@@ -2274,9 +2280,10 @@ start_over: ;\n   \n     if (my_stat (aux_info_filename, &stat_buf) == -1)\n       {\n+\tint errno_val = errno;\n         fprintf (stderr, \"%s: can't get status of aux info file `%s': %s\\n\",\n \t\t pname, shortpath (NULL, aux_info_filename),\n-\t\t my_strerror(errno));\n+\t\t my_strerror (errno_val));\n         errors++;\n         return;\n       }\n@@ -2301,9 +2308,10 @@ start_over: ;\n \n \tif (my_stat (base_source_filename, &stat_buf) == -1)\n \t  {\n+\t    int errno_val = errno;\n \t    fprintf (stderr, \"%s: can't get status of aux info file `%s': %s\\n\",\n \t\t     pname, shortpath (NULL, base_source_filename),\n-\t\t     my_strerror(errno));\n+\t\t     my_strerror (errno_val));\n \t    errors++;\n \t    return;\n \t  }\n@@ -2322,9 +2330,10 @@ start_over: ;\n   \n     if ((aux_info_file = my_open (aux_info_filename, O_RDONLY, 0444 )) == -1)\n       {\n+\tint errno_val = errno;\n         fprintf (stderr, \"%s: can't open aux info file `%s' for reading: %s\\n\",\n \t\t pname, shortpath (NULL, aux_info_filename),\n-\t\t my_strerror(errno));\n+\t\t my_strerror (errno_val));\n         return;\n       }\n   \n@@ -2338,9 +2347,10 @@ start_over: ;\n   \n     if (safe_read (aux_info_file, aux_info_base, aux_info_size) != aux_info_size)\n       {\n+\tint errno_val = errno;\n         fprintf (stderr, \"%s: error reading aux info file `%s': %s\\n\",\n \t\t pname, shortpath (NULL, aux_info_filename),\n-\t\t my_strerror(errno));\n+\t\t my_strerror (errno_val));\n         free (aux_info_base);\n         close (aux_info_file);\n         return;\n@@ -2350,9 +2360,10 @@ start_over: ;\n   \n     if (close (aux_info_file))\n       {\n+\tint errno_val = errno;\n         fprintf (stderr, \"%s: error closing aux info file `%s': %s\\n\",\n \t\t pname, shortpath (NULL, aux_info_filename),\n-\t\t my_strerror(errno));\n+\t\t my_strerror (errno_val));\n         free (aux_info_base);\n         close (aux_info_file);\n         return;\n@@ -2364,9 +2375,12 @@ start_over: ;\n \n   if (must_create && !keep_it)\n     if (my_unlink (aux_info_filename) == -1)\n-      fprintf (stderr, \"%s: can't delete aux info file `%s': %s\\n\",\n-\t       pname, shortpath (NULL, aux_info_filename),\n-\t       my_strerror(errno));\n+      {\n+\tint errno_val = errno;\n+\tfprintf (stderr, \"%s: can't delete aux info file `%s': %s\\n\",\n+\t\t pname, shortpath (NULL, aux_info_filename),\n+\t\t my_strerror (errno_val));\n+      }\n \n   /* Save a pointer into the first line of the aux_info file which\n      contains the filename of the directory from which the compiler\n@@ -2430,9 +2444,10 @@ start_over: ;\n \t\txfree (aux_info_relocated_name);\n                 if (keep_it && my_unlink (aux_info_filename) == -1)\n                   {\n+\t\t    int errno_val = errno;\n                     fprintf (stderr, \"%s: can't delete file `%s': %s\\n\",\n \t\t\t     pname, shortpath (NULL, aux_info_filename),\n-\t\t\t     my_strerror(errno));\n+\t\t\t     my_strerror (errno_val));\n                     return;\n                   }\n \t\tmust_create = 1;\n@@ -2506,17 +2521,19 @@ rename_c_file (hp)\n \n   if (my_link (filename, new_filename) == -1)\n     {\n+      int errno_val = errno;\n       fprintf (stderr, \"%s: warning: can't link file `%s' to `%s': %s\\n\",\n \t       pname, shortpath (NULL, filename),\n-\t       shortpath (NULL, new_filename), my_strerror(errno));\n+\t       shortpath (NULL, new_filename), my_strerror (errno_val));\n       errors++;\n       return;\n     }\n \n   if (my_unlink (filename) == -1)\n     {\n+      int errno_val = errno;\n       fprintf (stderr, \"%s: warning: can't delete file `%s': %s\\n\",\n-\t       pname, shortpath (NULL, filename), my_strerror(errno));\n+\t       pname, shortpath (NULL, filename), my_strerror (errno_val));\n       errors++;\n       return;\n     }\n@@ -4213,8 +4230,10 @@ edit_file (hp)\n   /* The cast avoids an erroneous warning on AIX.  */\n   if (my_stat ((char *)convert_filename, &stat_buf) == -1)\n     {\n+      int errno_val = errno;\n       fprintf (stderr, \"%s: can't get status for file `%s': %s\\n\",\n-\t       pname, shortpath (NULL, convert_filename), my_strerror(errno));\n+\t       pname, shortpath (NULL, convert_filename),\n+\t       my_strerror (errno_val));\n       return;\n     }\n   orig_size = stat_buf.st_size;\n@@ -4247,9 +4266,10 @@ edit_file (hp)\n \n     if ((input_file = my_open (convert_filename, O_RDONLY, 0444)) == -1)\n       {\n+\tint errno_val = errno;\n         fprintf (stderr, \"%s: can't open file `%s' for reading: %s\\n\",\n \t\t pname, shortpath (NULL, convert_filename),\n-\t\t my_strerror(errno));\n+\t\t my_strerror (errno_val));\n         return;\n       }\n \n@@ -4259,10 +4279,11 @@ edit_file (hp)\n \n     if (safe_read (input_file, new_orig_text_base, orig_size) != orig_size)\n       {\n+\tint errno_val = errno;\n         close (input_file);\n         fprintf (stderr, \"\\n%s: error reading input file `%s': %s\\n\",\n \t\t pname, shortpath (NULL, convert_filename),\n-\t\t my_strerror(errno));\n+\t\t my_strerror (errno_val));\n         return;\n       }\n \n@@ -4293,9 +4314,10 @@ edit_file (hp)\n     strcat (clean_filename, \".clean\");\n     if ((clean_file = creat (clean_filename, 0666)) == -1)\n       {\n+\tint errno_val = errno;\n         fprintf (stderr, \"%s: can't create/open clean file `%s': %s\\n\",\n \t\t pname, shortpath (NULL, clean_filename),\n-\t\t my_strerror(errno));\n+\t\t my_strerror (errno_val));\n         return;\n       }\n   \n@@ -4390,7 +4412,8 @@ edit_file (hp)\n       strcat (new_filename, save_suffix);\n       if (my_link (convert_filename, new_filename) == -1)\n         {\n-          if (errno == EEXIST)\n+\t  int errno_val = errno;\n+\t  if (errno_val == EEXIST)\n             {\n               if (!quiet_flag)\n                 fprintf (stderr, \"%s: warning: file `%s' already saved in `%s'\\n\",\n@@ -4404,16 +4427,18 @@ edit_file (hp)\n \t\t       pname,\n \t\t       shortpath (NULL, convert_filename),\n \t\t       shortpath (NULL, new_filename),\n-\t\t       my_strerror(errno));\n+\t\t       my_strerror (errno_val));\n               return;\n             }\n         }\n     }\n \n   if (my_unlink (convert_filename) == -1)\n     {\n+      int errno_val = errno;\n       fprintf (stderr, \"%s: can't delete file `%s': %s\\n\",\n-\t       pname, shortpath (NULL, convert_filename), my_strerror(errno));\n+\t       pname, shortpath (NULL, convert_filename),\n+\t       my_strerror (errno_val));\n       return;\n     }\n \n@@ -4424,9 +4449,10 @@ edit_file (hp)\n   \n     if ((output_file = creat (convert_filename, 0666)) == -1)\n       {\n+\tint errno_val = errno;\n         fprintf (stderr, \"%s: can't create/open output file `%s': %s\\n\",\n \t\t pname, shortpath (NULL, convert_filename),\n-\t\t my_strerror(errno));\n+\t\t my_strerror (errno_val));\n         return;\n       }\n   \n@@ -4451,8 +4477,12 @@ edit_file (hp)\n \n   /* The cast avoids an erroneous warning on AIX.  */\n   if (my_chmod ((char *)convert_filename, stat_buf.st_mode) == -1)\n-    fprintf (stderr, \"%s: can't change mode of file `%s': %s\\n\",\n-\t     pname, shortpath (NULL, convert_filename), my_strerror(errno));\n+    {\n+      int errno_val = errno;\n+      fprintf (stderr, \"%s: can't change mode of file `%s': %s\\n\",\n+\t       pname, shortpath (NULL, convert_filename),\n+\t       my_strerror (errno_val));\n+    }\n \n   /* Note:  We would try to change the owner and group of the output file\n      to match those of the input file here, except that may not be a good"}, {"sha": "ab3ded66eb4a47bb9c37e3a614232450f1831167", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Register to Stack convert for GNU compiler.\n-   Copyright (C) 1992, 93-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1998,11 +1998,13 @@ compare_for_stack_reg (insn, regstack, pat)\n   src2 = get_true_reg (&XEXP (SET_SRC (pat), 1));\n   cc0_user = next_cc0_user (insn);\n \n-  /* If the insn that uses cc0 is a conditional move, then the destination\n+  /* If the insn that uses cc0 is an FP-conditional move, then the destination\n      must be the top of stack */\n   if (GET_CODE (PATTERN (cc0_user)) == SET\n       && SET_DEST (PATTERN (cc0_user)) != pc_rtx\n-      && GET_CODE (SET_SRC (PATTERN (cc0_user))) == IF_THEN_ELSE)\n+      && GET_CODE (SET_SRC (PATTERN (cc0_user))) == IF_THEN_ELSE\n+      && (GET_MODE_CLASS (GET_MODE (SET_DEST (PATTERN (cc0_user))))\n+\t  == MODE_FLOAT))\n     {\n       rtx *dest;\n       "}, {"sha": "333b1eae729d58b6222e3f334fb91112a72b8f5d", "filename": "gcc/reload.c", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Search an insn for pseudo regs that must be in hard regs and are not.\n-   Copyright (C) 1987, 88, 89, 92-7, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -3172,16 +3172,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t  && this_alternative_matches[i] < 0)\n \t\tbad = 1;\n \n-\t      /* Alternative loses if it requires a type of reload not\n-\t\t permitted for this insn.  We can always reload SCRATCH\n-\t\t and objects with a REG_UNUSED note.  */\n-\t      if (GET_CODE (operand) != SCRATCH\n-\t\t  && modified[i] != RELOAD_READ && no_output_reloads\n-\t\t  && ! find_reg_note (insn, REG_UNUSED, operand))\n-\t\tbad = 1;\n-\t      else if (modified[i] != RELOAD_WRITE && no_input_reloads)\n-\t\tbad = 1;\n-\n \t      /* If this is a constant that is reloaded into the desired\n \t\t class by copying it to memory first, count that as another\n \t\t reload.  This is consistent with other code and is\n@@ -3193,9 +3183,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      if (CONSTANT_P (operand)\n \t\t  /* force_const_mem does not accept HIGH.  */\n \t\t  && GET_CODE (operand) != HIGH\n-\t\t  && (PREFERRED_RELOAD_CLASS (operand,\n+\t\t  && ((PREFERRED_RELOAD_CLASS (operand,\n \t\t\t\t\t      (enum reg_class) this_alternative[i])\n-\t\t      == NO_REGS)\n+\t\t       == NO_REGS)\n+\t\t      || no_input_reloads)\n \t\t  && operand_mode[i] != VOIDmode)\n \t\t{\n \t\t  const_to_mem = 1;\n@@ -3215,6 +3206,18 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t      == NO_REGS))\n \t\tbad = 1;\n \n+\t      /* Alternative loses if it requires a type of reload not\n+\t\t permitted for this insn.  We can always reload SCRATCH\n+\t\t and objects with a REG_UNUSED note.  */\n+\t      else if (GET_CODE (operand) != SCRATCH\n+\t\t  && modified[i] != RELOAD_READ && no_output_reloads\n+\t\t  && ! find_reg_note (insn, REG_UNUSED, operand))\n+\t\tbad = 1;\n+\t      else if (modified[i] != RELOAD_WRITE && no_input_reloads\n+\t\t       && ! const_to_mem)\n+\t\tbad = 1;\n+\n+\n \t      /* We prefer to reload pseudos over reloading other things,\n \t\t since such reloads may be able to be eliminated later.\n \t\t If we are reloading a SCRATCH, we won't be generating any\n@@ -3540,9 +3543,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t&& CONSTANT_P (recog_operand[i])\n \t/* force_const_mem does not accept HIGH.  */\n \t&& GET_CODE (recog_operand[i]) != HIGH\n-\t&& (PREFERRED_RELOAD_CLASS (recog_operand[i],\n+\t&& ((PREFERRED_RELOAD_CLASS (recog_operand[i],\n \t\t\t\t    (enum reg_class) goal_alternative[i])\n-\t    == NO_REGS)\n+\t     == NO_REGS)\n+\t    || no_input_reloads)\n \t&& operand_mode[i] != VOIDmode)\n       {\n \t*recog_operand_loc[i] = recog_operand[i]\n@@ -3884,11 +3888,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\treload_when_needed[reload_secondary_out_reload[secondary_out_reload]] \n \t\t  = RELOAD_FOR_OPADDR_ADDR;\n \t    }\n-\t  if (reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS\n-\t      || reload_when_needed[i] == RELOAD_FOR_OUTADDR_ADDRESS)\n-\t    reload_when_needed[i] = RELOAD_FOR_OPADDR_ADDR;\n-\t  else\n-\t    reload_when_needed[i] = RELOAD_FOR_OPERAND_ADDRESS;\n+\n+\t  reload_when_needed[i] = RELOAD_FOR_OPERAND_ADDRESS;\n \t}\n \n       if ((reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n@@ -6297,12 +6298,14 @@ debug_reload_to_stream (f)\n       prefix = \"\\n\\t\";\n       if (reload_secondary_in_icode[r] != CODE_FOR_nothing)\n \t{\n-\t  fprintf (f, \"%ssecondary_in_icode = %s\", prefix, insn_name[r]);\n+\t  fprintf (stderr, \"%ssecondary_in_icode = %s\", prefix,\n+\t\t   insn_name[reload_secondary_in_icode[r]]);\n \t  prefix = \", \";\n \t}\n \n       if (reload_secondary_out_icode[r] != CODE_FOR_nothing)\n-\tfprintf (f, \"%ssecondary_out_icode = %s\", prefix, insn_name[r]);\n+\tfprintf (stderr, \"%ssecondary_out_icode = %s\", prefix,\n+\t\t insn_name[reload_secondary_out_icode[r]]);\n \n       fprintf (f, \"\\n\");\n     }"}, {"sha": "0d3d5b7201219b6ff41f0536d91996a3e1282ca8", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -754,10 +754,12 @@ extern rtx get_pool_constant\t\tPROTO((rtx));\n extern enum machine_mode get_pool_mode\tPROTO((rtx));\n extern int get_pool_offset\t\tPROTO((rtx));\n extern rtx simplify_subtraction\t\tPROTO((rtx));\n-extern rtx assign_stack_local\t\tPROTO((enum machine_mode, int, int));\n-extern rtx assign_stack_temp\t\tPROTO((enum machine_mode, int, int));\n-extern rtx assign_temp\t\t\tPROTO((union tree_node *, int,\n-\t\t\t\t\t       int, int));\n+extern rtx assign_stack_local\t\tPROTO((enum machine_mode,\n+\t\t\t\t\t       HOST_WIDE_INT, int));\n+extern rtx assign_stack_temp\t\tPROTO((enum machine_mode,\n+\t\t\t\t\t       HOST_WIDE_INT, int));\n+extern rtx assign_temp\t\t\tPROTO((union tree_node *,\n+\t\t\t\t\t       int, int, int));\n extern rtx protect_from_queue\t\tPROTO((rtx, int));\n extern void emit_queue\t\t\tPROTO((void));\n extern rtx emit_move_insn\t\tPROTO((rtx, rtx));"}, {"sha": "a715b8a8cf67ea9b23518a082dbce0235b0ff22d", "filename": "gcc/rtl.texi", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.texi?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,4 +1,4 @@\n-@c Copyright (C) 1988, 1989, 1992, 1994, 1997 Free Software Foundation, Inc.\n+@c Copyright (C) 1988, 89, 92, 94, 97, 1998 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -427,10 +427,12 @@ as @samp{/u}.\n @item INSN_FROM_TARGET_P (@var{insn})\n In an @code{insn} in a delay slot of a branch, indicates that the insn\n is from the target of the branch.  If the branch insn has\n-@code{INSN_ANNULLED_BRANCH_P} set, this insn should only be executed if\n-the branch is taken.  For annulled branches with this bit clear, the\n-insn should be executed only if the branch is not taken.  Stored in the\n-@code{in_struct} field and printed as @samp{/s}.\n+@code{INSN_ANNULLED_BRANCH_P} set, this insn will only be executed if\n+the branch is taken.  For annulled branches with\n+@code{INSN_FROM_TARGET_P} clear, the insn will be executed only if the\n+branch is not taken.  When @code{INSN_ANNULLED_BRANCH_P} is not set,\n+this insn will always be executed.  Stored in the @code{in_struct}\n+field and printed as @samp{/s}.\n \n @findex CONSTANT_POOL_ADDRESS_P \n @cindex @code{symbol_ref} and @samp{/u}"}, {"sha": "4d75e79086ad4abe547127f3af9c9a50bdb57414", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -103,7 +103,7 @@ rtx_varies_p (x)\n \t eliminated the frame and/or arg pointer and are using it\n \t for pseudos.  */\n       return ! (x == frame_pointer_rtx || x == hard_frame_pointer_rtx\n-\t\t|| x == arg_pointer_rtx);\n+\t\t|| x == arg_pointer_rtx || x == pic_offset_table_rtx);\n \n     case LO_SUM:\n       /* The operand 0 of a LO_SUM is considered constant"}, {"sha": "a44002e12a78ed8aea7e0e759c8da1567836e0c1", "filename": "gcc/sched.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -2343,12 +2343,7 @@ attach_deaths (x, insn, set_p)\n #endif\n \t\t&& regno != STACK_POINTER_REGNUM)\n \t      {\n-\t\t/* ??? It is perhaps a dead_or_set_p bug that it does\n-\t\t   not check for REG_UNUSED notes itself.  This is necessary\n-\t\t   for the case where the SET_DEST is a subreg of regno, as\n-\t\t   dead_or_set_p handles subregs specially.  */\n-\t\tif (! all_needed && ! dead_or_set_p (insn, x)\n-\t\t    && ! find_reg_note (insn, REG_UNUSED, x))\n+\t\tif (! all_needed && ! dead_or_set_p (insn, x))\n \t\t  {\n \t\t    /* Check for the case where the register dying partially\n \t\t       overlaps the register set by this insn.  */\n@@ -2406,17 +2401,20 @@ attach_deaths (x, insn, set_p)\n       return;\n \n     case SUBREG:\n+      attach_deaths (SUBREG_REG (x), insn,\n+\t\t     set_p && ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n+\t\t\t       <= UNITS_PER_WORD)\n+\t\t\t       || (GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n+\t\t\t\t   == GET_MODE_SIZE (GET_MODE ((x))))));\n+      return;\n+\n     case STRICT_LOW_PART:\n-      /* These two cases preserve the value of SET_P, so handle them\n-\t separately.  */\n-      attach_deaths (XEXP (x, 0), insn, set_p);\n+      attach_deaths (XEXP (x, 0), insn, 0);\n       return;\n \n     case ZERO_EXTRACT:\n     case SIGN_EXTRACT:\n-      /* This case preserves the value of SET_P for the first operand, but\n-\t clears it for the other two.  */\n-      attach_deaths (XEXP (x, 0), insn, set_p);\n+      attach_deaths (XEXP (x, 0), insn, 0);\n       attach_deaths (XEXP (x, 1), insn, 0);\n       attach_deaths (XEXP (x, 2), insn, 0);\n       return;"}, {"sha": "7aeb29edafda5ee19e7959fdeb18eae75a8839b1", "filename": "gcc/sdbout.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Output sdb-format symbol table information from GNU compiler.\n-   Copyright (C) 1988, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 92-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -574,6 +574,9 @@ plain_type_1 (type, level)\n #ifdef EXTENDED_SDB_BASIC_TYPES\n \tif (precision == LONG_DOUBLE_TYPE_SIZE)\n \t  return T_LNGDBL;\n+#else\n+\tif (precision == LONG_DOUBLE_TYPE_SIZE)\n+\t  return T_DOUBLE;\t/* better than nothing */\n #endif\n \treturn 0;\n       }\n@@ -1066,8 +1069,9 @@ sdbout_field_types (type)\n      tree type;\n {\n   tree tail;\n+\n   for (tail = TYPE_FIELDS (type); tail; tail = TREE_CHAIN (tail))\n-    if (TREE_CODE (TREE_TYPE (tail)) == POINTER_TYPE)\n+    if (POINTER_TYPE_P (TREE_TYPE (tail)))\n       sdbout_one_type (TREE_TYPE (TREE_TYPE (tail)));\n     else\n       sdbout_one_type (TREE_TYPE (tail));"}, {"sha": "48ea231e603e5f363c4590c0602d57525f8cbcd9", "filename": "gcc/stab.def", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fstab.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fstab.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstab.def?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,19 +1,21 @@\n /* Table of DBX symbol codes for the GNU system.\n-   Copyright (C) 1988 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n \n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 1, or (at your option)\n-   any later version.\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Library General Public License as\n+   published by the Free Software Foundation; either version 2 of the\n+   License, or (at your option) any later version.\n \n-   This program is distributed in the hope that it will be useful,\n+   The GNU C Library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n \n-   You should have received a copy of the GNU General Public License\n-   along with this program; if not, write to the Free Software\n-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+   You should have received a copy of the GNU Library General Public\n+   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n \n /* This contains contribution from Cygnus Support.  */\n \f"}, {"sha": "c436555434d827a13d370feb460215f035ab6302", "filename": "gcc/stmt.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Expands front end tree to back end RTL for GNU C-Compiler\n-   Copyright (C) 1987, 88, 89, 92-7, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1162,7 +1162,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   /* The insn we have emitted.  */\n   rtx insn;\n \n-  /* An ASM with no outputs needs to be treated as volatile.  */\n+  /* An ASM with no outputs needs to be treated as volatile, for now.  */\n   if (noutputs == 0)\n     vol = 1;\n \n@@ -3112,7 +3112,9 @@ expand_decl (decl)\n \t\t&& TREE_CODE (type) == REAL_TYPE)\n \t   && ! TREE_THIS_VOLATILE (decl)\n \t   && ! TREE_ADDRESSABLE (decl)\n-\t   && (DECL_REGISTER (decl) || ! obey_regdecls))\n+\t   && (DECL_REGISTER (decl) || ! obey_regdecls)\n+\t   /* if -fcheck-memory-usage, check all variables.  */\n+\t   && ! flag_check_memory_usage)\n     {\n       /* Automatic variable that can go in a register.  */\n       int unsignedp = TREE_UNSIGNED (type);\n@@ -3122,7 +3124,7 @@ expand_decl (decl)\n       DECL_RTL (decl) = gen_reg_rtx (reg_mode);\n       mark_user_reg (DECL_RTL (decl));\n \n-      if (TREE_CODE (type) == POINTER_TYPE)\n+      if (POINTER_TYPE_P (type))\n \tmark_reg_pointer (DECL_RTL (decl),\n \t\t\t  (TYPE_ALIGN (TREE_TYPE (TREE_TYPE (decl)))\n \t\t\t   / BITS_PER_UNIT));\n@@ -3276,8 +3278,9 @@ expand_decl_init (decl)\n   if (DECL_INITIAL (decl) == error_mark_node)\n     {\n       enum tree_code code = TREE_CODE (TREE_TYPE (decl));\n+\n       if (code == INTEGER_TYPE || code == REAL_TYPE || code == ENUMERAL_TYPE\n-\t  || code == POINTER_TYPE)\n+\t  || code == POINTER_TYPE || code == REFERENCE_TYPE)\n \texpand_assignment (decl, convert (TREE_TYPE (decl), integer_zero_node),\n \t\t\t   0, 0);\n       emit_queue ();\n@@ -3629,8 +3632,10 @@ expand_cleanups (list, dont_do, in_fixup, reachable)\n \n \t\t/* We may need to protect fixups with rethrow regions.  */\n \t\tint protect = (in_fixup && ! TREE_ADDRESSABLE (tail));\n+\n \t\tif (protect)\n \t\t  expand_fixup_region_start ();\n+\n \t\texpand_expr (TREE_VALUE (tail), const0_rtx, VOIDmode, 0);\n \t\tif (protect)\n \t\t  expand_fixup_region_end (TREE_VALUE (tail));"}, {"sha": "7aef13ad20af3dde7efe5e3d2e0035db1b688c5a", "filename": "gcc/texinfo.tex", "status": "modified", "additions": 165, "deletions": 138, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ftexinfo.tex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ftexinfo.tex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftexinfo.tex?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,32 +1,40 @@\n-%% TeX macros to handle Texinfo files.\n-%% $Id: texinfo.tex,v 1.1.1.2 1998/01/14 19:38:23 law Exp $\n-\n-%  Copyright (C) 1985, 86, 88, 90, 91, 92, 93,\n-%                94, 95, 96, 97 Free Software Foundation, Inc.\n-\n-%This texinfo.tex file is free software; you can redistribute it and/or\n-%modify it under the terms of the GNU General Public License as\n-%published by the Free Software Foundation; either version 2, or (at\n-%your option) any later version.\n-\n-%This texinfo.tex file is distributed in the hope that it will be\n-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty\n-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-%General Public License for more details.\n-\n-%You should have received a copy of the GNU General Public License\n-%along with this texinfo.tex file; see the file COPYING.  If not, write\n-%to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n-%Boston, MA 02111-1307, USA.\n-\n-\n-%In other words, you are welcome to use, share and improve this program.\n-%You are forbidden to forbid anyone else to use, share and improve\n-%what you give them.   Help stamp out software-hoarding!\n-\n-\n-% Send bug reports to bug-texinfo@prep.ai.mit.edu.\n-% Please include a *precise* test case in each bug report.\n+% texinfo.tex -- TeX macros to handle Texinfo files.\n+% $Id: texinfo.tex,v 1.5 1998/06/29 21:40:12 law Exp $\n+%\n+% Copyright (C) 1985, 86, 88, 90, 91, 92, 93, 94, 95, 96, 97, 98\n+% Free Software Foundation, Inc.\n+%\n+% This texinfo.tex file is free software; you can redistribute it and/or\n+% modify it under the terms of the GNU General Public License as\n+% published by the Free Software Foundation; either version 2, or (at\n+% your option) any later version.\n+%\n+% This texinfo.tex file is distributed in the hope that it will be\n+% useful, but WITHOUT ANY WARRANTY; without even the implied warranty\n+% of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+% General Public License for more details.\n+%\n+% You should have received a copy of the GNU General Public License\n+% along with this texinfo.tex file; see the file COPYING.  If not, write\n+% to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+% Boston, MA 02111-1307, USA.\n+%\n+% In other words, you are welcome to use, share and improve this program.\n+% You are forbidden to forbid anyone else to use, share and improve\n+% what you give them.   Help stamp out software-hoarding!\n+%\n+% Please try the latest version of texinfo.tex before submitting bug\n+% reports; you can get the latest version from:\n+% ftp://ftp.cs.umb.edu/pub/tex/texinfo.tex\n+% /home/gd/gnu/doc/texinfo.tex on the GNU machines.\n+% \n+% Send bug reports to bug-texinfo@gnu.org.\n+% Please include a precise test case in each bug report,\n+% including a complete document with which we can reproduce the problem.\n+% \n+% Texinfo macros (with @macro) are *not* supported by texinfo.tex.  You\n+% have to run makeinfo -E to expand macros first; the texi2dvi script\n+% does this.\n \n \n % Make it possible to create a .fmt file just by loading this file:\n@@ -36,7 +44,7 @@\n \n % This automatically updates the version number based on RCS.\n \\def\\deftexinfoversion$#1: #2 ${\\def\\texinfoversion{#2}}\n-\\deftexinfoversion$Revision: 1.1.1.2 $\n+\\deftexinfoversion$Revision: 1.5 $\n \\message{Loading texinfo package [Version \\texinfoversion]:}\n \n % If in a .fmt file, print the version number\n@@ -54,7 +62,8 @@\n \\let\\ptexdot=\\.\n \\let\\ptexdots=\\dots\n \\let\\ptexend=\\end\n-\\let\\ptexequiv = \\equiv\n+\\let\\ptexequiv=\\equiv\n+\\let\\ptexexclam=\\!\n \\let\\ptexi=\\i\n \\let\\ptexlbrace=\\{\n \\let\\ptexrbrace=\\}\n@@ -1278,6 +1287,10 @@\n %\n \\textfonts\n \n+% Define these so they can be easily changed for other fonts.\n+\\def\\angleleft{$\\langle$}\n+\\def\\angleright{$\\rangle$}\n+\n % Count depth in font-changes, for error checks\n \\newcount\\fontdepth \\fontdepth=0\n \n@@ -1315,15 +1328,15 @@\n   \\null\n }\n \\let\\ttfont=\\t\n-\\def\\samp #1{`\\tclose{#1}'\\null}\n+\\def\\samp#1{`\\tclose{#1}'\\null}\n \\setfont\\smallrm\\rmshape{8}{1000}\n \\font\\smallsy=cmsy9\n \\def\\key#1{{\\smallrm\\textfont2=\\smallsy \\leavevmode\\hbox{%\n-  \\raise0.4pt\\hbox{$\\langle$}\\kern-.08em\\vtop{%\n+  \\raise0.4pt\\hbox{\\angleleft}\\kern-.08em\\vtop{%\n     \\vbox{\\hrule\\kern-0.4pt\n-     \\hbox{\\raise0.4pt\\hbox{\\vphantom{$\\langle$}}#1}}%\n+     \\hbox{\\raise0.4pt\\hbox{\\vphantom{\\angleleft}}#1}}%\n     \\kern-0.4pt\\hrule}%\n-  \\kern-.06em\\raise0.4pt\\hbox{$\\rangle$}}}}\n+  \\kern-.06em\\raise0.4pt\\hbox{\\angleright}}}}\n % The old definition, with no lozenge:\n %\\def\\key #1{{\\ttsl \\nohyphenation \\uppercase{#1}}\\null}\n \\def\\ctrl #1{{\\tt \\rawbackslash \\hat}#1}\n@@ -1436,7 +1449,7 @@\n \n % rms does not like the angle brackets --karl, 17may97.\n % So now @email is just like @uref.\n-%\\def\\email#1{$\\langle${\\tt #1}$\\rangle$}\n+%\\def\\email#1{\\angleleft{\\tt #1}\\angleright}\n \\let\\email=\\uref\n \n % Check if we are currently using a typewriter font.  Since all the\n@@ -2058,10 +2071,7 @@\n % @multitablelinespace is space to leave between table items, baseline\n %                                                            to baseline.\n %   0pt means it depends on current normal line spacing.\n-\n-%%%%\n-% Dimensions\n-\n+%\n \\newskip\\multitableparskip\n \\newskip\\multitableparindent\n \\newdimen\\multitablecolspace\n@@ -2071,15 +2081,15 @@\n \\multitablecolspace=12pt\n \\multitablelinespace=0pt\n \n-%%%%\n % Macros used to set up halign preamble:\n+% \n \\let\\endsetuptable\\relax\n \\def\\xendsetuptable{\\endsetuptable}\n \\let\\columnfractions\\relax\n \\def\\xcolumnfractions{\\columnfractions}\n \\newif\\ifsetpercent\n \n-%% 2/1/96, to allow fractions to be given with more than one digit.\n+% 2/1/96, to allow fractions to be given with more than one digit.\n \\def\\pickupwholefraction#1 {\\global\\advance\\colcount by1 %\n \\expandafter\\xdef\\csname col\\the\\colcount\\endcsname{.#1\\hsize}%\n \\setuptable}\n@@ -2105,80 +2115,84 @@\n \\ifx\\go\\pickupwholefraction\\else\\let\\go\\setuptable\\fi%\n \\fi\\go}\n \n-%%%%\n % multitable syntax\n \\def\\tab{&\\hskip1sp\\relax} % 2/2/96\n                            % tiny skip here makes sure this column space is\n                            % maintained, even if it is never used.\n \n-\n-%%%%\n % @multitable ... @end multitable definitions:\n \n \\def\\multitable{\\parsearg\\dotable}\n-\n \\def\\dotable#1{\\bgroup\n-\\let\\item\\cr\n-\\tolerance=9500\n-\\hbadness=9500\n-\\setmultitablespacing\n-\\parskip=\\multitableparskip\n-\\parindent=\\multitableparindent\n-\\overfullrule=0pt\n-\\global\\colcount=0\\relax%\n-\\def\\Emultitable{\\global\\setpercentfalse\\global\\everycr{}\\cr\\egroup\\egroup}%\n- % To parse everything between @multitable and @item :\n-\\setuptable#1 \\endsetuptable\n- % Need to reset this to 0 after \\setuptable.\n-\\global\\colcount=0\\relax%\n- %\n- % This preamble sets up a generic column definition, which will\n- % be used as many times as user calls for columns.\n- % \\vtop will set a single line and will also let text wrap and\n- % continue for many paragraphs if desired.\n-\\halign\\bgroup&\\global\\advance\\colcount by 1\\relax%\n-\\multistrut\\vtop{\\hsize=\\expandafter\\csname col\\the\\colcount\\endcsname\n- % In order to keep entries from bumping into each other\n- % we will add a \\leftskip of \\multitablecolspace to all columns after\n- % the first one.\n- %  If a template has been used, we will add \\multitablecolspace\n- % to the width of each template entry.\n- %  If user has set preamble in terms of percent of \\hsize\n- % we will use that dimension as the width of the column, and\n- % the \\leftskip will keep entries from bumping into each other.\n- % Table will start at left margin and final column will justify at\n- % right margin.\n-\\ifnum\\colcount=1\n-\\else\n-  \\ifsetpercent\n+  \\vskip\\parskip\n+  \\let\\item\\crcr\n+  \\tolerance=9500\n+  \\hbadness=9500\n+  \\setmultitablespacing\n+  \\parskip=\\multitableparskip\n+  \\parindent=\\multitableparindent\n+  \\overfullrule=0pt\n+  \\global\\colcount=0\n+  \\def\\Emultitable{\\global\\setpercentfalse\\cr\\egroup\\egroup}%\n+  %\n+  % To parse everything between @multitable and @item:\n+  \\setuptable#1 \\endsetuptable\n+  %\n+  % \\everycr will reset column counter, \\colcount, at the end of\n+  % each line. Every column entry will cause \\colcount to advance by one.\n+  % The table preamble\n+  % looks at the current \\colcount to find the correct column width.\n+  \\everycr{\\noalign{%\n+  %\n+  % \\filbreak%% keeps underfull box messages off when table breaks over pages.\n+  % Maybe so, but it also creates really weird page breaks when the table\n+  % breaks over pages. Wouldn't \\vfil be better?  Wait until the problem\n+  % manifests itself, so it can be fixed for real --karl.\n+    \\global\\colcount=0\\relax}}%\n+  %\n+  % This preamble sets up a generic column definition, which will\n+  % be used as many times as user calls for columns.\n+  % \\vtop will set a single line and will also let text wrap and\n+  % continue for many paragraphs if desired.\n+  \\halign\\bgroup&\\global\\advance\\colcount by 1\\relax\n+    \\multistrut\\vtop{\\hsize=\\expandafter\\csname col\\the\\colcount\\endcsname\n+  %\n+  % In order to keep entries from bumping into each other\n+  % we will add a \\leftskip of \\multitablecolspace to all columns after\n+  % the first one.\n+  % \n+  % If a template has been used, we will add \\multitablecolspace\n+  % to the width of each template entry.\n+  % \n+  % If the user has set preamble in terms of percent of \\hsize we will\n+  % use that dimension as the width of the column, and the \\leftskip\n+  % will keep entries from bumping into each other.  Table will start at\n+  % left margin and final column will justify at right margin.\n+  % \n+  % Make sure we don't inherit \\rightskip from the outer environment.\n+  \\rightskip=0pt\n+  \\ifnum\\colcount=1\n+    % The first column will be indented with the surrounding text.\n+    \\advance\\hsize by\\leftskip\n   \\else\n-   % If user has <not> set preamble in terms of percent of \\hsize\n-   % we will advance \\hsize by \\multitablecolspace\n-  \\advance\\hsize by \\multitablecolspace\n+    \\ifsetpercent \\else\n+      % If user has not set preamble in terms of percent of \\hsize\n+      % we will advance \\hsize by \\multitablecolspace.\n+      \\advance\\hsize by \\multitablecolspace\n+    \\fi\n+   % In either case we will make \\leftskip=\\multitablecolspace:\n+  \\leftskip=\\multitablecolspace\n   \\fi\n- % In either case we will make \\leftskip=\\multitablecolspace:\n-\\leftskip=\\multitablecolspace\n-\\fi\n- % Ignoring space at the beginning and end avoids an occasional spurious\n- % blank line, when TeX decides to break the line at the space before the\n- % box from the multistrut, so the strut ends up on a line by itself.\n- % For example:\n- % @multitable @columnfractions .11 .89\n- % @item @code{#}\n- % @tab Legal holiday which is valid in major parts of the whole country.\n- % Is automatically provided with highlighting sequences respectively marking\n- % characters.\n- \\noindent\\ignorespaces##\\unskip\\multistrut}\\cr\n- % \\everycr will reset column counter, \\colcount, at the end of\n- % each line. Every column  entry will cause \\colcount to advance by one.\n- % The table preamble\n- % looks at the current \\colcount to find the correct column width.\n-\\global\\everycr{\\noalign{%\n-% \\filbreak%% keeps underfull box messages off when table breaks over pages.\n-% Maybe so, but it also creates really weird page breaks when the table\n-% breaks over pages Wouldn't \\vfil be better?  Wait until the problem\n-% manifests itself, so it can be fixed for real --karl.\n-\\global\\colcount=0\\relax}}\n+  % Ignoring space at the beginning and end avoids an occasional spurious\n+  % blank line, when TeX decides to break the line at the space before the\n+  % box from the multistrut, so the strut ends up on a line by itself.\n+  % For example:\n+  % @multitable @columnfractions .11 .89\n+  % @item @code{#}\n+  % @tab Legal holiday which is valid in major parts of the whole country.\n+  % Is automatically provided with highlighting sequences respectively marking\n+  % characters.\n+  \\noindent\\ignorespaces##\\unskip\\multistrut}\\cr\n }\n \n \\def\\setmultitablespacing{% test to see if user has set \\multitablelinespace.\n@@ -2525,6 +2539,11 @@\n   \\indexbreaks\n   %\n   % See if the index file exists and is nonempty.\n+  % Change catcode of @ here so that if the index file contains\n+  % \\initial {@}\n+  % as its first line, TeX doesn't complain about mismatched braces\n+  % (because it thinks @} is a control sequence).\n+  \\catcode`\\@ = 11\n   \\openin 1 \\jobname.#1s\n   \\ifeof 1\n     % \\enddoublecolumns gets confused if there is no text in the index,\n@@ -2546,7 +2565,6 @@\n       % to make right now.\n       \\def\\indexbackslash{\\rawbackslashxx}%\n       \\catcode`\\\\ = 0\n-      \\catcode`\\@ = 11\n       \\escapechar = `\\\\\n       \\begindoublecolumns\n       \\input \\jobname.#1s\n@@ -3442,11 +3460,12 @@\n % the index entries, but we want to suppress hyphenation here.  (We\n % can't do that in the \\entry macro, since index entries might consist\n % of hyphenated-identifiers-that-do-not-fit-on-a-line-and-nothing-else.)\n-%\n-% \\turnoffactive is for the sake of @\" used for umlauts.\n \\def\\tocentry#1#2{\\begingroup\n   \\vskip 0pt plus1pt % allow a little stretch for the sake of nice page breaks\n-  \\entry{\\turnoffactive #1}{\\turnoffactive #2}%\n+  % Do not use \\turnoffactive in these arguments.  Since the toc is\n+  % typeset in cmr, so characters such as _ would come out wrong; we\n+  % have to do the usual translation tricks.\n+  \\entry{#1}{#2}%\n \\endgroup}\n \n % Space between chapter (or whatever) number and the title.\n@@ -3512,30 +3531,35 @@\n % But \\@ or @@ will get a plain tex @ character.\n \n \\def\\tex{\\begingroup\n-\\catcode `\\\\=0 \\catcode `\\{=1 \\catcode `\\}=2\n-\\catcode `\\$=3 \\catcode `\\&=4 \\catcode `\\#=6\n-\\catcode `\\^=7 \\catcode `\\_=8 \\catcode `\\~=13 \\let~=\\tie\n-\\catcode `\\%=14\n-\\catcode 43=12 % plus\n-\\catcode`\\\"=12\n-\\catcode`\\==12\n-\\catcode`\\|=12\n-\\catcode`\\<=12\n-\\catcode`\\>=12\n-\\escapechar=`\\\\\n-%\n-\\let\\,=\\ptexcomma\n-\\let\\{=\\ptexlbrace\n-\\let\\}=\\ptexrbrace\n-\\let\\.=\\ptexdot\n-\\let\\*=\\ptexstar\n-\\let\\dots=\\ptexdots\n-\\def\\endldots{\\mathinner{\\ldots\\ldots\\ldots\\ldots}}%\n-\\def\\enddots{\\relax\\ifmmode\\endldots\\else$\\mathsurround=0pt \\endldots\\,$\\fi}%\n-\\def\\@{@}%\n-\\let\\bullet=\\ptexbullet\n-\\let\\b=\\ptexb \\let\\c=\\ptexc \\let\\i=\\ptexi \\let\\t=\\ptext\n-%\n+  \\catcode `\\\\=0 \\catcode `\\{=1 \\catcode `\\}=2\n+  \\catcode `\\$=3 \\catcode `\\&=4 \\catcode `\\#=6\n+  \\catcode `\\^=7 \\catcode `\\_=8 \\catcode `\\~=13 \\let~=\\tie\n+  \\catcode `\\%=14\n+  \\catcode 43=12 % plus\n+  \\catcode`\\\"=12\n+  \\catcode`\\==12\n+  \\catcode`\\|=12\n+  \\catcode`\\<=12\n+  \\catcode`\\>=12\n+  \\escapechar=`\\\\\n+  %\n+  \\let\\b=\\ptexb\n+  \\let\\bullet=\\ptexbullet\n+  \\let\\c=\\ptexc\n+  \\let\\,=\\ptexcomma\n+  \\let\\.=\\ptexdot\n+  \\let\\dots=\\ptexdots\n+  \\let\\equiv=\\ptexequiv\n+  \\let\\!=\\ptexexclam\n+  \\let\\i=\\ptexi\n+  \\let\\{=\\ptexlbrace\n+  \\let\\}=\\ptexrbrace\n+  \\let\\*=\\ptexstar\n+  \\let\\t=\\ptext\n+  %\n+  \\def\\endldots{\\mathinner{\\ldots\\ldots\\ldots\\ldots}}%\n+  \\def\\enddots{\\relax\\ifmmode\\endldots\\else$\\mathsurround=0pt \\endldots\\,$\\fi}%\n+  \\def\\@{@}%\n \\let\\Etex=\\endgroup}\n \n % Define @lisp ... @endlisp.\n@@ -4388,7 +4412,7 @@\n \\def\\refx#1#2{%\n   \\expandafter\\ifx\\csname X#1\\endcsname\\relax\n     % If not defined, say something at least.\n-    $\\langle$un\\-de\\-fined$\\rangle$%\n+    \\angleleft un\\-de\\-fined\\angleright\n     \\ifhavexrefs\n       \\message{\\linenumber Undefined cross reference `#1'.}%\n     \\else\n@@ -4405,10 +4429,13 @@\n }\n \n % This is the macro invoked by entries in the aux file.\n-\\def\\xrdef #1#2{{%\n-  \\catcode`\\'=\\other\n-  \\expandafter\\gdef\\csname X#1\\endcsname{#2}%\n-}}\n+% \n+\\def\\xrdef#1{\\begingroup\n+  % Reenable \\ as an escape while reading the second argument.\n+  \\catcode`\\\\ = 0\n+  \\afterassignment\\endgroup\n+  \\expandafter\\gdef\\csname X#1\\endcsname\n+}\n \n % Read the last existing aux file, if any.  No error if none exists.\n \\def\\readauxfile{\\begingroup"}, {"sha": "a5c2729299bc57dd585145568b2ca7009d9e9e39", "filename": "gcc/tm.texi", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,4 +1,4 @@\n-@c Copyright (C) 1988,89,92-97,1998 Free Software Foundation, Inc.\n+@c Copyright (C) 1988,89,92,93,94,96,97,1998 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -3672,15 +3672,18 @@ not generate any instructions in this case.\n \n @findex STRICT_ARGUMENT_NAMING\n @item STRICT_ARGUMENT_NAMING\n-Define this macro if the location where a function argument is passed\n-depends on whether or not it is a named argument.\n+Define this macro to be a nonzero value if the location where a function\n+argument is passed depends on whether or not it is a named argument.\n \n This macro controls how the @var{named} argument to @code{FUNCTION_ARG}\n-is set for varargs and stdarg functions.  With this macro defined,\n-the @var{named} argument is always true for named arguments, and false for\n-unnamed arguments.  If this is not defined, but @code{SETUP_INCOMING_VARARGS}\n-is defined, then all arguments are treated as named.  Otherwise, all named\n-arguments except the last are treated as named.\n+is set for varargs and stdarg functions.  If this macro returns a\n+nonzero value, the @var{named} argument is always true for named\n+arguments, and false for unnamed arguments.  If it returns a value of\n+zero, but @code{SETUP_INCOMING_VARARGS} is defined, then all arguments\n+are treated as named.  Otherwise, all named arguments except the last\n+are treated as named.\n+\n+You need not define this macro if it always returns zero.\n @end table\n \n @node Trampolines\n@@ -6058,7 +6061,7 @@ operands to @code{asm_fprintf}.\n \n Define the macros @code{REGISTER_PREFIX}, @code{LOCAL_LABEL_PREFIX},\n @code{USER_LABEL_PREFIX} and @code{IMMEDIATE_PREFIX} if you can express\n-the variations in assembly language syntax with that mechanism.  Define\n+the variations in assembler language syntax with that mechanism.  Define\n @code{ASSEMBLER_DIALECT} and use the @samp{@{option0|option1@}} syntax\n if the syntax variant are larger and involve such things as different\n opcodes or operand order.\n@@ -6344,20 +6347,19 @@ having address @var{x} (an RTL expression).  The nominal offset is\n \n @findex PREFERRED_DEBUGGING_TYPE\n @item PREFERRED_DEBUGGING_TYPE\n-A C expression that returns the type of debugging output GNU CC produces\n-when the user specifies @samp{-g} or @samp{-ggdb}.  Define this if you\n-have arranged for GNU CC to support more than one format of debugging\n-output.  Currently, the allowable values are @code{DBX_DEBUG},\n+A C expression that returns the type of debugging output GNU CC should\n+produce when the user specifies just @samp{-g}.  Define\n+this if you have arranged for GNU CC to support more than one format of\n+debugging output.  Currently, the allowable values are @code{DBX_DEBUG},\n @code{SDB_DEBUG}, @code{DWARF_DEBUG}, @code{DWARF2_DEBUG}, and\n @code{XCOFF_DEBUG}.\n \n-If the user specifies @samp{-ggdb}, then there are two special cases\n-where this macro's value is ignored and another value is substituted.\n-If @code{DWARF2_DEBUGGING_INFO} is defined and\n-@code{LINKER_DOES_NOT_WORK_WITH_DWARF2} is not defined, then\n-@code{DWARF2_DEBUG} is substituted.  Otherwise, if\n-@code{DBX_DEBUGGING_INFO} is defined, then @code{DBX_DEBUG} is\n-substituted.\n+When the user specifies @samp{-ggdb}, GNU CC normally also uses the\n+value of this macro to select the debugging output format, but with two\n+exceptions.  If @code{DWARF2_DEBUGGING_INFO} is defined and\n+@code{LINKER_DOES_NOT_WORK_WITH_DWARF2} is not defined, GNU CC uses the\n+value @code{DWARF2_DEBUG}.  Otherwise, if @code{DBX_DEBUGGING_INFO} is\n+defined, GNU CC uses @code{DBX_DEBUG}.\n \n The value of this macro only affects the default debugging output; the\n user can always get a specific type of output by using @samp{-gstabs},\n@@ -6690,10 +6692,10 @@ as appropriate from @code{FUNCTION_PROLOGUE} if you don't.\n \n @findex LINKER_DOES_NOT_WORK_WITH_DWARF2\n @item LINKER_DOES_NOT_WORK_WITH_DWARF2\n-Define this macro if the linker does not work with dwarf version 2.\n-Normally, if the user specifies only @samp{-ggdb}, then GNU CC will use\n-dwarf version 2 if available; this macro causes GNU CC to use the format\n-specified by @code{PREFERRED_DEBUGGING_TYPE} instead.\n+Define this macro if the linker does not work with Dwarf version 2.\n+Normally, if the user specifies only @samp{-ggdb} GNU CC will use Dwarf\n+version 2 if available; this macro disables this.  See the description\n+of the @code{PREFERRED_DEBUGGING_TYPE} macro for more details.\n \n @findex PUT_SDB_@dots{}\n @item PUT_SDB_@dots{}"}, {"sha": "d226950dfecc9836cf9d2adcdc56e6aa4fd58dad", "filename": "gcc/toplev.c", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -49,6 +49,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"flags.h\"\n #include \"insn-attr.h\"\n+#include \"insn-codes.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n #include \"defaults.h\"\n #include \"output.h\"\n #include \"except.h\"\n@@ -993,8 +996,17 @@ get_run_time ()\n #ifdef USG\n   {\n     struct tms tms;\n+#   if HAVE_SYSCONF && defined _SC_CLK_TCK\n+#    define TICKS_PER_SECOND sysconf (_SC_CLK_TCK) /* POSIX 1003.1-1996 */\n+#   else\n+#    ifdef CLK_TCK\n+#     define TICKS_PER_SECOND CLK_TCK /* POSIX 1003.1-1988; obsolescent */\n+#    else\n+#     define TICKS_PER_SECOND HZ /* traditional UNIX */\n+#    endif\n+#   endif\n     times (&tms);\n-    return (tms.tms_utime + tms.tms_stime) * (1000000 / HZ);\n+    return (tms.tms_utime + tms.tms_stime) * (1000000 / TICKS_PER_SECOND);\n   }\n #else\n #ifndef VMS\n@@ -2485,7 +2497,14 @@ compile_file (name)\n   /* Don't let the first function fall at the same address\n      as gcc_compiled., if profiling.  */\n   if (profile_flag || profile_block_flag)\n-    assemble_zeros (UNITS_PER_WORD);\n+    {\n+      /* It's best if we can write a nop here since some\n+\t assemblers don't tolerate zeros in the text section.  */\n+      if (insn_template[CODE_FOR_nop] != 0)\n+\toutput_asm_insn (insn_template[CODE_FOR_nop], NULL_PTR);\n+      else\n+\tassemble_zeros (UNITS_PER_WORD);\n+    }\n \n   /* If dbx symbol table desired, initialize writing it\n      and output the predefined types.  */\n@@ -3572,7 +3591,8 @@ rest_of_compilation (decl)\n \t     final (insns, asm_out_file, optimize, 0);\n \t     final_end_function (insns, asm_out_file, optimize);\n \t     assemble_end_function (decl, fnname);\n-\t     fflush (asm_out_file);\n+\t     if (! quiet_flag)\n+\t       fflush (asm_out_file);\n \n \t     /* Release all memory held by regsets now */\n \t     regset_release_memory ();"}, {"sha": "b6db322d667583a776665ce426f9a3eefcdd49f2", "filename": "gcc/tree.c", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1671,7 +1671,7 @@ integer_pow2p (expr)\n   if (TREE_CODE (expr) != INTEGER_CST || TREE_CONSTANT_OVERFLOW (expr))\n     return 0;\n \n-  prec = (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE\n+  prec = (POINTER_TYPE_P (TREE_TYPE (expr))\n \t  ? POINTER_SIZE : TYPE_PRECISION (TREE_TYPE (expr)));\n   high = TREE_INT_CST_HIGH (expr);\n   low = TREE_INT_CST_LOW (expr);\n@@ -1712,7 +1712,7 @@ tree_log2 (expr)\n   if (TREE_CODE (expr) == COMPLEX_CST)\n     return tree_log2 (TREE_REALPART (expr));\n \n-  prec = (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE\n+  prec = (POINTER_TYPE_P (TREE_TYPE (expr))\n \t  ? POINTER_SIZE : TYPE_PRECISION (TREE_TYPE (expr)));\n \n   high = TREE_INT_CST_HIGH (expr);\n@@ -2172,29 +2172,32 @@ size_in_bytes (type)\n   return t;\n }\n \n-/* Return the size of TYPE (in bytes) as an integer,\n-   or return -1 if the size can vary.  */\n+/* Return the size of TYPE (in bytes) as a wide integer\n+   or return -1 if the size can vary or is larger than an integer.  */\n \n-int\n+HOST_WIDE_INT\n int_size_in_bytes (type)\n      tree type;\n {\n-  unsigned int size;\n+  tree t;\n+\n   if (type == error_mark_node)\n     return 0;\n+\n   type = TYPE_MAIN_VARIANT (type);\n-  if (TYPE_SIZE (type) == 0)\n+  if (TYPE_SIZE (type) == 0\n+      || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n     return -1;\n-  if (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+\n+  if (TREE_INT_CST_HIGH (TYPE_SIZE (type)) == 0)\n+    return ((TREE_INT_CST_LOW (TYPE_SIZE (type)) + BITS_PER_UNIT - 1)\n+\t  / BITS_PER_UNIT);\n+\n+  t = size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type), size_int (BITS_PER_UNIT));\n+  if (TREE_CODE (t) != INTEGER_CST || TREE_INT_CST_HIGH (t) != 0)\n     return -1;\n-  if (TREE_INT_CST_HIGH (TYPE_SIZE (type)) != 0)\n-    {\n-      tree t = size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type),\n-\t\t\t   size_int (BITS_PER_UNIT));\n-      return TREE_INT_CST_LOW (t);\n-    }\n-  size = TREE_INT_CST_LOW (TYPE_SIZE (type));\n-  return (size + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n+\n+  return TREE_INT_CST_LOW (t);\n }\n \f\n /* Return, as a tree node, the number of elements for TYPE (which is an\n@@ -3357,7 +3360,7 @@ valid_machine_attribute (attr_name, attr_args, decl, type)\n \n   /* Handle putting a type attribute on pointer-to-function-type by putting\n      the attribute on the function type.  */\n-  else if (TREE_CODE (type) == POINTER_TYPE\n+  else if (POINTER_TYPE_P (type)\n \t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n \t   && VALID_MACHINE_TYPE_ATTRIBUTE (TREE_TYPE (type), type_attr_list,\n \t\t\t\t\t    attr_name, attr_args))\n@@ -4251,31 +4254,24 @@ build_reference_type (to_type)\n      tree to_type;\n {\n   register tree t = TYPE_REFERENCE_TO (to_type);\n-  register struct obstack *ambient_obstack = current_obstack;\n-  register struct obstack *ambient_saveable_obstack = saveable_obstack;\n \n   /* First, if we already have a type for pointers to TO_TYPE, use it.  */\n \n   if (t)\n     return t;\n \n-  /* We need a new one.  If TO_TYPE is permanent, make this permanent too.  */\n-  if (TREE_PERMANENT (to_type))\n-    {\n-      current_obstack = &permanent_obstack;\n-      saveable_obstack = &permanent_obstack;\n-    }\n-\n+  /* We need a new one.  Put this in the same obstack as TO_TYPE.   */\n+  push_obstacks (TYPE_OBSTACK (to_type), TYPE_OBSTACK (to_type));\n   t = make_node (REFERENCE_TYPE);\n+  pop_obstacks ();\n+\n   TREE_TYPE (t) = to_type;\n \n   /* Record this type as the pointer to TO_TYPE.  */\n   TYPE_REFERENCE_TO (to_type) = t;\n \n   layout_type (t);\n \n-  current_obstack = ambient_obstack;\n-  saveable_obstack = ambient_saveable_obstack;\n   return t;\n }\n "}, {"sha": "8fee5211230bbf66502230ce44310feaa526839d", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Front-end tree definitions for GNU compiler.\n-   Copyright (C) 1989, 93-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -204,7 +204,7 @@ struct tree_common\n    static_flag:\n \n        TREE_STATIC in\n-           VAR_DECL, FUNCTION_DECL, CONSTRUCTOR\n+           VAR_DECL, FUNCTION_DECL, CONSTRUCTOR, ADDR_EXPR\n        TREE_NO_UNUSED_WARNING in\n            CONVERT_EXPR, NOP_EXPR, COMPOUND_EXPR\n        TREE_VIA_VIRTUAL in\n@@ -253,7 +253,7 @@ struct tree_common\n    readonly_flag:\n \n        TREE_READONLY in\n-           VAR_DECL, PARM_DECL, FIELD_DECL, ..._REF\n+           all expressions\n        ITERATOR_BOUND_P in\n            VAR_DECL if iterator (C)\n        TYPE_READONLY in\n@@ -1179,8 +1179,7 @@ struct tree_decl\n   struct rtx_def *rtl;\t/* acts as link to register transfer language\n \t\t\t\t   (rtl) info */\n   /* For FUNCTION_DECLs: points to insn that constitutes its definition\n-     on the permanent obstack.  For any other kind of decl, this is the\n-     alignment.  */\n+     on the permanent obstack.  For FIELD_DECL, this is DECL_FIELD_SIZE.  */\n   union {\n     struct rtx_def *r;\n     HOST_WIDE_INT i;\n@@ -1415,7 +1414,7 @@ extern tree pedantic_non_lvalue\t\tPROTO((tree));\n \n extern tree convert\t\t\tPROTO((tree, tree));\n extern tree size_in_bytes\t\tPROTO((tree));\n-extern int int_size_in_bytes\t\tPROTO((tree));\n+extern HOST_WIDE_INT int_size_in_bytes\tPROTO((tree));\n extern tree size_binop\t\t\tPROTO((enum tree_code, tree, tree));\n extern tree size_int_wide\t\tPROTO((unsigned HOST_WIDE_INT,\n \t\t\t\t\t       unsigned HOST_WIDE_INT, int));"}, {"sha": "7e4483ea495130e951f37864bced86c078bc919c", "filename": "gcc/unroll.c", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Try to unroll loops, and split induction variables.\n-   Copyright (C) 1992, 93-95, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93, 94, 95, 97, 1998 Free Software Foundation, Inc.\n    Contributed by James E. Wilson, Cygnus Support/UC Berkeley.\n \n This file is part of GNU CC.\n@@ -1452,6 +1452,7 @@ init_reg_map (map, maxregnum)\n    to the iv.  This procedure reconstructs the pattern computing the iv;\n    verifying that all operands are of the proper form.\n \n+   PATTERN must be the result of single_set.\n    The return value is the amount that the giv is incremented by.  */\n \n static rtx\n@@ -1629,7 +1630,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n      rtx start_label, loop_end, insert_before, copy_notes_from;\n {\n   rtx insn, pattern;\n-  rtx tem, copy;\n+  rtx set, tem, copy;\n   int dest_reg_was_split, i;\n #ifdef HAVE_cc0\n   rtx cc0_insn = 0;\n@@ -1676,15 +1677,15 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t     Do this before splitting the giv, since that may map the\n \t     SET_DEST to a new register.  */\n \t  \n-\t  if (GET_CODE (pattern) == SET\n-\t      && GET_CODE (SET_DEST (pattern)) == REG\n-\t      && addr_combined_regs[REGNO (SET_DEST (pattern))])\n+\t  if ((set = single_set (insn))\n+\t      && GET_CODE (SET_DEST (set)) == REG\n+\t      && addr_combined_regs[REGNO (SET_DEST (set))])\n \t    {\n \t      struct iv_class *bl;\n \t      struct induction *v, *tv;\n-\t      int regno = REGNO (SET_DEST (pattern));\n+\t      int regno = REGNO (SET_DEST (set));\n \t      \n-\t      v = addr_combined_regs[REGNO (SET_DEST (pattern))];\n+\t      v = addr_combined_regs[REGNO (SET_DEST (set))];\n \t      bl = reg_biv_class[REGNO (v->src_reg)];\n \t      \n \t      /* Although the giv_inc amount is not needed here, we must call\n@@ -1693,7 +1694,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t we might accidentally delete insns generated immediately\n \t\t below by emit_unrolled_add.  */\n \n-\t      giv_inc = calculate_giv_inc (pattern, insn, regno);\n+\t      giv_inc = calculate_giv_inc (set, insn, regno);\n \n \t      /* Now find all address giv's that were combined with this\n \t\t giv 'v'.  */\n@@ -1767,21 +1768,21 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t  \n \t  dest_reg_was_split = 0;\n \t  \n-\t  if (GET_CODE (pattern) == SET\n-\t      && GET_CODE (SET_DEST (pattern)) == REG\n-\t      && splittable_regs[REGNO (SET_DEST (pattern))])\n+\t  if ((set = single_set (insn))\n+\t      && GET_CODE (SET_DEST (set)) == REG\n+\t      && splittable_regs[REGNO (SET_DEST (set))])\n \t    {\n-\t      int regno = REGNO (SET_DEST (pattern));\n+\t      int regno = REGNO (SET_DEST (set));\n \t      \n \t      dest_reg_was_split = 1;\n \t      \n \t      /* Compute the increment value for the giv, if it wasn't\n \t\t already computed above.  */\n \n \t      if (giv_inc == 0)\n-\t\tgiv_inc = calculate_giv_inc (pattern, insn, regno);\n-\t      giv_dest_reg = SET_DEST (pattern);\n-\t      giv_src_reg = SET_DEST (pattern);\n+\t\tgiv_inc = calculate_giv_inc (set, insn, regno);\n+\t      giv_dest_reg = SET_DEST (set);\n+\t      giv_src_reg = SET_DEST (set);\n \n \t      if (unroll_type == UNROLL_COMPLETELY)\n \t\t{\n@@ -1977,9 +1978,9 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \n \t      /* Can't use the label_map for every insn, since this may be\n \t\t the backward branch, and hence the label was not mapped.  */\n-\t      if (GET_CODE (pattern) == SET)\n+\t      if ((set = single_set (copy)))\n \t\t{\n-\t\t  tem = SET_SRC (pattern);\n+\t\t  tem = SET_SRC (set);\n \t\t  if (GET_CODE (tem) == LABEL_REF)\n \t\t    label = XEXP (tem, 0);\n \t\t  else if (GET_CODE (tem) == IF_THEN_ELSE)\n@@ -2651,9 +2652,10 @@ verify_addresses (v, giv_inc, unroll_number)\n   rtx last_addr = plus_constant (v->dest_reg,\n \t\t\t\t INTVAL (giv_inc) * (unroll_number - 1));\n \n-  /* First check to see if either address would fail.  */\n-  if (! validate_change (v->insn, v->location, v->dest_reg, 0)\n-      || ! validate_change (v->insn, v->location, last_addr, 0))\n+  /* First check to see if either address would fail.   Handle the fact\n+     that we have may have a match_dup.  */\n+  if (! validate_replace_rtx (*v->location, v->dest_reg, v->insn)\n+      || ! validate_replace_rtx (*v->location, last_addr, v->insn))\n     ret = 0;\n \n   /* Now put things back the way they were before.  This will always\n@@ -2940,6 +2942,10 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t  if (v->dest_reg == tem\n \t\t      && ! verify_addresses (v, giv_inc, unroll_number))\n \t\t    {\n+\t\t      for (v2 = v->next_iv; v2; v2 = v2->next_iv)\n+\t\t\tif (v2->same_insn == v)\n+\t\t\t  v2->same_insn = 0;\n+\n \t\t      if (loop_dump_stream)\n \t\t\tfprintf (loop_dump_stream,\n \t\t\t\t \"Invalid address for giv at insn %d\\n\",\n@@ -2986,6 +2992,10 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t     if the resulting address would be invalid.  */\n \t\t  if (! verify_addresses (v, giv_inc, unroll_number))\n \t\t    {\n+\t\t      for (v2 = v->next_iv; v2; v2 = v2->next_iv)\n+\t\t\tif (v2->same_insn == v)\n+\t\t\t  v2->same_insn = 0;\n+\n \t\t      if (loop_dump_stream)\n \t\t\tfprintf (loop_dump_stream,\n \t\t\t\t \"Invalid address for giv at insn %d\\n\","}, {"sha": "e4d1d0de4eba35d22f557bff87d08f43d5a86442", "filename": "gcc/varasm.c", "status": "modified", "additions": 66, "deletions": 5, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1,5 +1,5 @@\n /* Output variables, constants and external declarations, for GNU compiler.\n-   Copyright (C) 1987, 88, 89, 92-7, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -2434,14 +2434,21 @@ compare_constant_1 (exp, p)\n \t  register tree link;\n \t  int length = list_length (CONSTRUCTOR_ELTS (exp));\n \t  tree type;\n+\t  int have_purpose = 0;\n+\n+\t  for (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n+\t    if (TREE_PURPOSE (link))\n+\t      have_purpose = 1;\n \n \t  if (bcmp ((char *) &length, p, sizeof length))\n \t    return 0;\n \n \t  p += sizeof length;\n \n \t  /* For record constructors, insist that the types match.\n-\t     For arrays, just verify both constructors are for arrays.  */\n+\t     For arrays, just verify both constructors are for arrays. \n+\t     Then insist that either both or none have any TREE_PURPOSE\n+\t     values.  */\n \t  if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n \t    type = TREE_TYPE (exp);\n \t  else\n@@ -2452,10 +2459,16 @@ compare_constant_1 (exp, p)\n \n \t  p += sizeof type;\n \n+\t  if (bcmp ((char *) &have_purpose, p, sizeof have_purpose))\n+\t    return 0;\n+\n+\t  p += sizeof have_purpose;\n+\n \t  /* For arrays, insist that the size in bytes match.  */\n \t  if (TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE)\n \t    {\n-\t      int size = int_size_in_bytes (TREE_TYPE (exp));\n+\t      HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));\n+\n \t      if (bcmp ((char *) &size, p, sizeof size))\n \t\treturn 0;\n \n@@ -2473,6 +2486,30 @@ compare_constant_1 (exp, p)\n \t\t{\n \t\t  tree zero = 0;\n \n+\t\t  if (bcmp ((char *) &zero, p, sizeof zero))\n+\t\t    return 0;\n+\n+\t\t  p += sizeof zero;\n+\t\t}\n+\n+\t      if (TREE_PURPOSE (link)\n+\t\t  && TREE_CODE (TREE_PURPOSE (link)) == FIELD_DECL)\n+\t\t{\n+\t\t  if (bcmp ((char *) &TREE_PURPOSE (link), p,\n+\t\t\t    sizeof TREE_PURPOSE (link)))\n+\t\t    return 0;\n+\n+\t\t  p += sizeof TREE_PURPOSE (link);\n+\t\t}\n+\t      else if (TREE_PURPOSE (link))\n+\t\t{\n+\t\t  if ((p = compare_constant_1 (TREE_PURPOSE (link), p)) == 0)\n+\t\t    return 0;\n+\t\t}\n+\t      else if (have_purpose)\n+\t\t{\n+\t\t  int zero = 0;\n+\n \t\t  if (bcmp ((char *) &zero, p, sizeof zero))\n \t\t    return 0;\n \n@@ -2606,21 +2643,30 @@ record_constant_1 (exp)\n \t  register tree link;\n \t  int length = list_length (CONSTRUCTOR_ELTS (exp));\n \t  tree type;\n+\t  int have_purpose = 0;\n+\n+\t  for (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n+\t    if (TREE_PURPOSE (link))\n+\t      have_purpose = 1;\n \n \t  obstack_grow (&permanent_obstack, (char *) &length, sizeof length);\n \n \t  /* For record constructors, insist that the types match.\n-\t     For arrays, just verify both constructors are for arrays.  */\n+\t     For arrays, just verify both constructors are for arrays. \n+\t     Then insist that either both or none have any TREE_PURPOSE\n+\t     values.  */\n \t  if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n \t    type = TREE_TYPE (exp);\n \t  else\n \t    type = 0;\n \t  obstack_grow (&permanent_obstack, (char *) &type, sizeof type);\n+\t  obstack_grow (&permanent_obstack, (char *) &have_purpose,\n+\t\t\tsizeof have_purpose);\n \n \t  /* For arrays, insist that the size in bytes match.  */\n \t  if (TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE)\n \t    {\n-\t      int size = int_size_in_bytes (TREE_TYPE (exp));\n+\t      HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));\n \t      obstack_grow (&permanent_obstack, (char *) &size, sizeof size);\n \t    }\n \n@@ -2632,6 +2678,21 @@ record_constant_1 (exp)\n \t\t{\n \t\t  tree zero = 0;\n \n+\t\t  obstack_grow (&permanent_obstack,\n+\t\t\t\t(char *) &zero, sizeof zero);\n+\t\t}\n+\n+\t      if (TREE_PURPOSE (link)\n+\t\t  && TREE_CODE (TREE_PURPOSE (link)) == FIELD_DECL)\n+\t\tobstack_grow (&permanent_obstack,\n+\t\t\t      (char *) &TREE_PURPOSE (link),\n+\t\t\t      sizeof TREE_PURPOSE (link));\n+\t      else if (TREE_PURPOSE (link))\n+\t\trecord_constant_1 (TREE_PURPOSE (link));\n+\t      else if (have_purpose)\n+\t\t{\n+\t\t  int zero = 0;\n+\n \t\t  obstack_grow (&permanent_obstack,\n \t\t\t\t(char *) &zero, sizeof zero);\n \t\t}"}, {"sha": "0c9fb3af4061c87cc1f77e8203761bc1415a7171", "filename": "gcc/version.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e809f4194e578b5fbd48fc5a1df2377f28d197/gcc%2Fversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fversion.c?ref=e5e809f4194e578b5fbd48fc5a1df2377f28d197", "patch": "@@ -1 +1 @@\n-char *version_string = \"egcs-2.91.16 980328 (gcc-2.8.0 release)\";\n+char *version_string = \"egcs-2.91.17 980403 (gcc2 ss-980401 experimental)\";"}]}