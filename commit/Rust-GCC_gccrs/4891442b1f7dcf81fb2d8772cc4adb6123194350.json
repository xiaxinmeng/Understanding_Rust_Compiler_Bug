{"sha": "4891442b1f7dcf81fb2d8772cc4adb6123194350", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg5MTQ0MmIxZjdkY2Y4MWZiMmQ4NzcyY2M0YWRiNjEyMzE5NDM1MA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-12-22T15:51:07Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-12-22T15:51:07Z"}, "message": "* cfg.c, cfganal.c, cfgbuild.c: Reformatting and minor cleanups.\n\nFrom-SVN: r48270", "tree": {"sha": "17b1afe9dcf1bd5c9ede2a22dc8ff45733e7bf35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17b1afe9dcf1bd5c9ede2a22dc8ff45733e7bf35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4891442b1f7dcf81fb2d8772cc4adb6123194350", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4891442b1f7dcf81fb2d8772cc4adb6123194350", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4891442b1f7dcf81fb2d8772cc4adb6123194350", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4891442b1f7dcf81fb2d8772cc4adb6123194350/comments", "author": null, "committer": null, "parents": [{"sha": "bfdade77da046cd5d11e2b8096e0b33e6f927141", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfdade77da046cd5d11e2b8096e0b33e6f927141", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfdade77da046cd5d11e2b8096e0b33e6f927141"}], "stats": {"total": 358, "additions": 192, "deletions": 166}, "files": [{"sha": "bcc801277e960db575963f0fff86a033253f4c0c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4891442b1f7dcf81fb2d8772cc4adb6123194350/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4891442b1f7dcf81fb2d8772cc4adb6123194350/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4891442b1f7dcf81fb2d8772cc4adb6123194350", "patch": "@@ -1,6 +1,7 @@\n Sat Dec 22 08:59:50 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* predict.c: Reformatting and minor cleanups.\n+\t* cfg.c, cfganal.c, cfgbuild.c: Likewise.\n \n \t* expr.c (expand_expr, case ADDR_EXPR): Handling taking address of\n \tSAVE_EXPR."}, {"sha": "8adcef637b333acea6db478d5a17d3350744109d", "filename": "gcc/cfg.c", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4891442b1f7dcf81fb2d8772cc4adb6123194350/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4891442b1f7dcf81fb2d8772cc4adb6123194350/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=4891442b1f7dcf81fb2d8772cc4adb6123194350", "patch": "@@ -152,7 +152,7 @@ free_edge (e)\n      edge e;\n {\n   n_edges--;\n-  memset (e, 0, sizeof (*e));\n+  memset (e, 0, sizeof *e);\n   e->succ_next = first_deleted_edge;\n   first_deleted_edge = e;\n }\n@@ -177,6 +177,7 @@ clear_edges ()\n \t  free_edge (e);\n \t  e = next;\n \t}\n+\n       bb->succ = NULL;\n       bb->pred = NULL;\n     }\n@@ -189,6 +190,7 @@ clear_edges ()\n       free_edge (e);\n       e = next;\n     }\n+\n   EXIT_BLOCK_PTR->pred = NULL;\n   ENTRY_BLOCK_PTR->succ = NULL;\n \n@@ -211,8 +213,8 @@ alloc_block ()\n     }\n   else\n     {\n-      bb = (basic_block) obstack_alloc (&flow_obstack, sizeof (*bb));\n-      memset (bb, 0, sizeof (*bb));\n+      bb = (basic_block) obstack_alloc (&flow_obstack, sizeof *bb);\n+      memset (bb, 0, sizeof *bb);\n     }\n   return bb;\n }\n@@ -233,7 +235,7 @@ expunge_block (b)\n     }\n \n   /* Invalidate data to make bughunting easier.  */\n-  memset (b, 0, sizeof (*b));\n+  memset (b, 0, sizeof *b);\n   b->index = -3;\n   basic_block_info->num_elements--;\n   n_basic_blocks--;\n@@ -253,11 +255,10 @@ cached_make_edge (edge_cache, src, dst, flags)\n   int use_edge_cache;\n   edge e;\n \n-  /* Don't bother with edge cache for ENTRY or EXIT; there aren't that\n-     many edges to them, and we didn't allocate memory for it.  */\n+  /* Don't bother with edge cache for ENTRY or EXIT, if there aren't that\n+     many edges to them, or we didn't allocate memory for it.  */\n   use_edge_cache = (edge_cache\n-\t\t    && src != ENTRY_BLOCK_PTR\n-\t\t    && dst != EXIT_BLOCK_PTR);\n+\t\t    && src != ENTRY_BLOCK_PTR && dst != EXIT_BLOCK_PTR);\n \n   /* Make sure we don't add duplicate edges.  */\n   switch (use_edge_cache)\n@@ -289,8 +290,8 @@ cached_make_edge (edge_cache, src, dst, flags)\n     }\n   else\n     {\n-      e = (edge) obstack_alloc (&flow_obstack, sizeof (*e));\n-      memset (e, 0, sizeof (*e));\n+      e = (edge) obstack_alloc (&flow_obstack, sizeof *e);\n+      memset (e, 0, sizeof *e);\n     }\n   n_edges++;\n \n@@ -345,6 +346,7 @@ remove_edge (e)\n   edge last_succ = NULL;\n   edge tmp;\n   basic_block src, dest;\n+\n   src = e->src;\n   dest = e->dest;\n   for (tmp = src->succ; tmp && tmp != e; tmp = tmp->succ_next)\n@@ -398,10 +400,12 @@ redirect_edge_succ_nodup (e, new_succ)\n      basic_block new_succ;\n {\n   edge s;\n+\n   /* Check whether the edge is already present.  */\n   for (s = e->src->succ; s; s = s->succ_next)\n     if (s->dest == new_succ && s != e)\n       break;\n+\n   if (s)\n     {\n       s->flags |= e->flags;\n@@ -412,6 +416,7 @@ redirect_edge_succ_nodup (e, new_succ)\n     }\n   else\n     redirect_edge_succ (e, new_succ);\n+\n   return e;\n }\n \n@@ -427,6 +432,7 @@ redirect_edge_pred (e, new_pred)\n   /* Disconnect the edge from the old predecessor block.  */\n   for (pe = &e->src->succ; *pe != e; pe = &(*pe)->succ_next)\n     continue;\n+\n   *pe = (*pe)->succ_next;\n \n   /* Reconnect the edge to the new predecessor block.  */\n@@ -447,6 +453,7 @@ dump_flow_info (file)\n     if (REG_N_REFS (i))\n       {\n \tenum reg_class class, altclass;\n+\n \tfprintf (file, \"\\nRegister %d used %d times across %d insns\",\n \t\t i, REG_N_REFS (i), REG_LIVE_LENGTH (i));\n \tif (REG_BASIC_BLOCK (i) >= 0)\n@@ -464,6 +471,7 @@ dump_flow_info (file)\n \t  fprintf (file, \"; crosses %d calls\", REG_N_CALLS_CROSSED (i));\n \tif (PSEUDO_REGNO_BYTES (i) != UNITS_PER_WORD)\n \t  fprintf (file, \"; %d bytes\", PSEUDO_REGNO_BYTES (i));\n+\n \tclass = reg_preferred_class (i);\n \taltclass = reg_alternate_class (i);\n \tif (class != GENERAL_REGS || altclass != ALL_REGS)\n@@ -477,6 +485,7 @@ dump_flow_info (file)\n \t\t       reg_class_names[(int) class],\n \t\t       reg_class_names[(int) altclass]);\n \t  }\n+\n \tif (REG_POINTER (regno_reg_rtx[i]))\n \t  fprintf (file, \"; pointer\");\n \tfprintf (file, \".\\n\");\n@@ -488,9 +497,10 @@ dump_flow_info (file)\n       basic_block bb = BASIC_BLOCK (i);\n       edge e;\n \n-      fprintf (file, \"\\nBasic block %d: first insn %d, last %d, loop_depth %d, count \",\n-\t       i, INSN_UID (bb->head), INSN_UID (bb->end), bb->loop_depth);\n-      fprintf (file, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) bb->count);\n+      fprintf (file, \"\\nBasic block %d: first insn %d, last %d, \",\n+\t       i, INSN_UID (bb->head), INSN_UID (bb->end));\n+      fprintf (file, \"loop_depth %d, count \", bb->loop_depth);\n+      fprintf (file, HOST_WIDEST_INT_PRINT_DEC, bb->count);\n       fprintf (file, \", freq %i.\\n\", bb->frequency);\n \n       fprintf (file, \"Predecessors: \");\n@@ -540,19 +550,17 @@ dump_edge_info (file, e, do_succ)\n   if (e->count)\n     {\n       fprintf (file, \" count:\");\n-      fprintf (file, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) e->count);\n+      fprintf (file, HOST_WIDEST_INT_PRINT_DEC, e->count);\n     }\n \n   if (e->flags)\n     {\n-      static const char * const bitnames[] = {\n-\t\"fallthru\", \"ab\", \"abcall\", \"eh\", \"fake\", \"dfs_back\"\n-      };\n+      static const char * const bitnames[]\n+\t= {\"fallthru\", \"ab\", \"abcall\", \"eh\", \"fake\", \"dfs_back\"};\n       int comma = 0;\n       int i, flags = e->flags;\n \n-      fputc (' ', file);\n-      fputc ('(', file);\n+      fputs (\" (\", file);\n       for (i = 0; flags; i++)\n \tif (flags & (1 << i))\n \t  {\n@@ -566,11 +574,13 @@ dump_edge_info (file, e, do_succ)\n \t      fprintf (file, \"%d\", i);\n \t    comma = 1;\n \t  }\n+\n       fputc (')', file);\n     }\n }\n \f\n /* Simple routines to easily allocate AUX fields of basic blocks.  */\n+\n static struct obstack block_aux_obstack;\n static void *first_block_aux_obj = 0;\n static struct obstack edge_aux_obstack;\n@@ -605,15 +615,18 @@ alloc_aux_for_blocks (size)\n       gcc_obstack_init (&block_aux_obstack);\n       initialized = 1;\n     }\n+\n   /* Check whether AUX data are still allocated.  */\n   else if (first_block_aux_obj)\n     abort ();\n   first_block_aux_obj = (char *) obstack_alloc (&block_aux_obstack, 0);\n   if (size)\n     {\n       int i;\n+\n       for (i = 0; i < n_basic_blocks; i++)\n \talloc_aux_for_block (BASIC_BLOCK (i), size);\n+\n       alloc_aux_for_block (ENTRY_BLOCK_PTR, size);\n       alloc_aux_for_block (EXIT_BLOCK_PTR, size);\n     }\n@@ -628,6 +641,7 @@ clear_aux_for_blocks ()\n \n   for (i = 0; i < n_basic_blocks; i++)\n     BASIC_BLOCK (i)->aux = NULL;\n+\n   ENTRY_BLOCK_PTR->aux = NULL;\n   EXIT_BLOCK_PTR->aux = NULL;\n }\n@@ -675,9 +689,11 @@ alloc_aux_for_edges (size)\n       gcc_obstack_init (&edge_aux_obstack);\n       initialized = 1;\n     }\n+\n   /* Check whether AUX data are still allocated.  */\n   else if (first_edge_aux_obj)\n     abort ();\n+\n   first_edge_aux_obj = (char *) obstack_alloc (&edge_aux_obstack, 0);\n   if (size)\n     {\n@@ -691,6 +707,7 @@ alloc_aux_for_edges (size)\n \t    bb = BASIC_BLOCK (i);\n \t  else\n \t    bb = ENTRY_BLOCK_PTR;\n+\n \t  for (e = bb->succ; e; e = e->succ_next)\n \t    alloc_aux_for_edge (e, size);\n \t}\n@@ -713,6 +730,7 @@ clear_aux_for_edges ()\n \tbb = BASIC_BLOCK (i);\n       else\n \tbb = ENTRY_BLOCK_PTR;\n+\n       for (e = bb->succ; e; e = e->succ_next)\n \te->aux = NULL;\n     }"}, {"sha": "63286630614b52d27be2db6258760507e3a1ebf1", "filename": "gcc/cfganal.c", "status": "modified", "additions": 97, "deletions": 91, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4891442b1f7dcf81fb2d8772cc4adb6123194350/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4891442b1f7dcf81fb2d8772cc4adb6123194350/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=4891442b1f7dcf81fb2d8772cc4adb6123194350", "patch": "@@ -56,27 +56,28 @@ static bool need_fake_edge_p\t\tPARAMS ((rtx));\n \f\n /* Return true if the block has no effect and only forwards control flow to\n    its single destination.  */\n+\n bool\n forwarder_block_p (bb)\n      basic_block bb;\n {\n-  rtx insn = bb->head;\n+  rtx insn;\n+\n   if (bb == EXIT_BLOCK_PTR || bb == ENTRY_BLOCK_PTR\n       || !bb->succ || bb->succ->succ_next)\n     return false;\n \n-  while (insn != bb->end)\n-    {\n-      if (INSN_P (insn) && active_insn_p (insn))\n-\treturn false;\n-      insn = NEXT_INSN (insn);\n-    }\n+  for (insn = bb->head; insn != bb->end; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn) && active_insn_p (insn))\n+      return false;\n+\n   return (!INSN_P (insn)\n \t  || (GET_CODE (insn) == JUMP_INSN && simplejump_p (insn))\n \t  || !active_insn_p (insn));\n }\n \n /* Return nonzero if we can reach target from src by falling through.  */\n+\n bool\n can_fallthru (src, target)\n      basic_block src, target;\n@@ -86,6 +87,7 @@ can_fallthru (src, target)\n \n   if (src->index + 1 == target->index && !active_insn_p (insn2))\n     insn2 = next_active_insn (insn2);\n+\n   /* ??? Later we may add code to move jump tables offline.  */\n   return next_active_insn (insn) == insn2;\n }\n@@ -148,7 +150,6 @@ mark_dfs_back_edges ()\n \t  SET_BIT (visited, dest->index);\n \n \t  pre[dest->index] = prenum++;\n-\n \t  if (dest->succ)\n \t    {\n \t      /* Since the DEST node has been visited for the first\n@@ -235,17 +236,17 @@ flow_call_edges_add (blocks)\n     {\n       for (i = 0; i < n_basic_blocks; i++)\n \tbbs[bb_num++] = BASIC_BLOCK (i);\n+\n       check_last_block = true;\n     }\n+\n   else\n-    {\n-      EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i,\n-      {\n-\tbbs[bb_num++] = BASIC_BLOCK (i);\n-\tif (i == n_basic_blocks - 1)\n-\t  check_last_block = true;\n-      });\n-    }\n+    EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i,\n+\t\t\t       {\n+\t\t\t\t bbs[bb_num++] = BASIC_BLOCK (i);\n+\t\t\t\t if (i == n_basic_blocks - 1)\n+\t\t\t\t   check_last_block = true;\n+\t\t\t       });\n \n   /* In the last basic block, before epilogue generation, there will be\n      a fallthru edge to EXIT.  Special care is required if the last insn\n@@ -263,14 +264,15 @@ flow_call_edges_add (blocks)\n       && need_fake_edge_p (BASIC_BLOCK (n_basic_blocks - 1)->end))\n     {\n        edge e;\n+\n        for (e = BASIC_BLOCK (n_basic_blocks - 1)->succ; e; e = e->succ_next)\n \t if (e->dest == EXIT_BLOCK_PTR)\n \t    break;\n+\n        insert_insn_on_edge (gen_rtx_USE (VOIDmode, const0_rtx), e);\n        commit_edge_insertions ();\n     }\n \n-\n   /* Now add fake edges to the function exit for any non constant\n      calls since there is no way that we can determine if they will\n      return or not...  */\n@@ -289,9 +291,10 @@ flow_call_edges_add (blocks)\n \t      edge e;\n \n \t      /* The above condition should be enough to verify that there is\n-\t\t no edge to the exit block in CFG already.  Calling make_edge in\n-\t\t such case would make us to mark that edge as fake and remove it\n-\t\t later.  */\n+\t\t no edge to the exit block in CFG already.  Calling make_edge\n+\t\t in such case would make us to mark that edge as fake and\n+\t\t remove it later.  */\n+\n #ifdef ENABLE_CHECKING\n \t      if (insn == bb->end)\n \t\tfor (e = bb->succ; e; e = e->succ_next)\n@@ -307,6 +310,7 @@ flow_call_edges_add (blocks)\n \n \t      make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n \t    }\n+\n \t  if (insn == bb->head)\n \t    break;\n \t}\n@@ -318,6 +322,7 @@ flow_call_edges_add (blocks)\n   free (bbs);\n   return blocks_split;\n }\n+\n /* Find unreachable blocks.  An unreachable block will have 0 in\n    the reachable bit in block->flags.  A non-zero value indicates the\n    block is reachable.  */\n@@ -401,6 +406,7 @@ create_edge_list ()\n       for (e = bb->succ; e; e = e->succ_next)\n \tnum_edges++;\n     }\n+\n   /* Don't forget successors of the entry block.  */\n   for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n     num_edges++;\n@@ -414,22 +420,17 @@ create_edge_list ()\n \n   /* Follow successors of the entry block, and register these edges.  */\n   for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n-    {\n-      elist->index_to_edge[num_edges] = e;\n-      num_edges++;\n-    }\n+    elist->index_to_edge[num_edges++] = e;\n \n   for (x = 0; x < n_basic_blocks; x++)\n     {\n       basic_block bb = BASIC_BLOCK (x);\n \n       /* Follow all successors of blocks, and register these edges.  */\n       for (e = bb->succ; e; e = e->succ_next)\n-\t{\n-\t  elist->index_to_edge[num_edges] = e;\n-\t  num_edges++;\n-\t}\n+\telist->index_to_edge[num_edges++] = e;\n     }\n+\n   return elist;\n }\n \n@@ -454,6 +455,7 @@ print_edge_list (f, elist)\n      struct edge_list *elist;\n {\n   int x;\n+\n   fprintf (f, \"Compressed edge list, %d BBs + entry & exit, and %d edges\\n\",\n \t   elist->num_blocks - 2, elist->num_edges);\n \n@@ -498,6 +500,7 @@ verify_edge_list (f, elist)\n \t      fprintf (f, \"*p* No index for edge from %d to %d\\n\", pred, succ);\n \t      continue;\n \t    }\n+\n \t  if (INDEX_EDGE_PRED_BB (elist, index)->index != pred)\n \t    fprintf (f, \"*p* Pred for index %d should be %d not %d\\n\",\n \t\t     index, pred, INDEX_EDGE_PRED_BB (elist, index)->index);\n@@ -506,6 +509,7 @@ verify_edge_list (f, elist)\n \t\t     index, succ, INDEX_EDGE_SUCC_BB (elist, index)->index);\n \t}\n     }\n+\n   for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n     {\n       pred = e->src->index;\n@@ -516,13 +520,15 @@ verify_edge_list (f, elist)\n \t  fprintf (f, \"*p* No index for edge from %d to %d\\n\", pred, succ);\n \t  continue;\n \t}\n+\n       if (INDEX_EDGE_PRED_BB (elist, index)->index != pred)\n \tfprintf (f, \"*p* Pred for index %d should be %d not %d\\n\",\n \t\t index, pred, INDEX_EDGE_PRED_BB (elist, index)->index);\n       if (INDEX_EDGE_SUCC_BB (elist, index)->index != succ)\n \tfprintf (f, \"*p* Succ for index %d should be %d not %d\\n\",\n \t\t index, succ, INDEX_EDGE_SUCC_BB (elist, index)->index);\n     }\n+\n   /* We've verified that all the edges are in the list, no lets make sure\n      there are no spurious edges in the list.  */\n \n@@ -531,7 +537,6 @@ verify_edge_list (f, elist)\n       {\n \tbasic_block p = BASIC_BLOCK (pred);\n \tbasic_block s = BASIC_BLOCK (succ);\n-\n \tint found_edge = 0;\n \n \tfor (e = p->succ; e; e = e->succ_next)\n@@ -540,12 +545,14 @@ verify_edge_list (f, elist)\n \t      found_edge = 1;\n \t      break;\n \t    }\n+\n \tfor (e = s->pred; e; e = e->pred_next)\n \t  if (e->src == p)\n \t    {\n \t      found_edge = 1;\n \t      break;\n \t    }\n+\n \tif (EDGE_INDEX (elist, BASIC_BLOCK (pred), BASIC_BLOCK (succ))\n \t    == EDGE_INDEX_NO_EDGE && found_edge != 0)\n \t  fprintf (f, \"*** Edge (%d, %d) appears to not have an index\\n\",\n@@ -556,11 +563,11 @@ verify_edge_list (f, elist)\n \t\t   pred, succ, EDGE_INDEX (elist, BASIC_BLOCK (pred),\n \t\t\t\t\t   BASIC_BLOCK (succ)));\n       }\n+\n   for (succ = 0; succ < n_basic_blocks; succ++)\n     {\n       basic_block p = ENTRY_BLOCK_PTR;\n       basic_block s = BASIC_BLOCK (succ);\n-\n       int found_edge = 0;\n \n       for (e = p->succ; e; e = e->succ_next)\n@@ -569,12 +576,14 @@ verify_edge_list (f, elist)\n \t    found_edge = 1;\n \t    break;\n \t  }\n+\n       for (e = s->pred; e; e = e->pred_next)\n \tif (e->src == p)\n \t  {\n \t    found_edge = 1;\n \t    break;\n \t  }\n+\n       if (EDGE_INDEX (elist, ENTRY_BLOCK_PTR, BASIC_BLOCK (succ))\n \t  == EDGE_INDEX_NO_EDGE && found_edge != 0)\n \tfprintf (f, \"*** Edge (entry, %d) appears to not have an index\\n\",\n@@ -585,11 +594,11 @@ verify_edge_list (f, elist)\n \t\t succ, EDGE_INDEX (elist, ENTRY_BLOCK_PTR,\n \t\t\t\t   BASIC_BLOCK (succ)));\n     }\n+\n   for (pred = 0; pred < n_basic_blocks; pred++)\n     {\n       basic_block p = BASIC_BLOCK (pred);\n       basic_block s = EXIT_BLOCK_PTR;\n-\n       int found_edge = 0;\n \n       for (e = p->succ; e; e = e->succ_next)\n@@ -598,12 +607,14 @@ verify_edge_list (f, elist)\n \t    found_edge = 1;\n \t    break;\n \t  }\n+\n       for (e = s->pred; e; e = e->pred_next)\n \tif (e->src == p)\n \t  {\n \t    found_edge = 1;\n \t    break;\n \t  }\n+\n       if (EDGE_INDEX (elist, BASIC_BLOCK (pred), EXIT_BLOCK_PTR)\n \t  == EDGE_INDEX_NO_EDGE && found_edge != 0)\n \tfprintf (f, \"*** Edge (%d, exit) appears to not have an index\\n\",\n@@ -625,12 +636,12 @@ find_edge_index (edge_list, pred, succ)\n      basic_block pred, succ;\n {\n   int x;\n+\n   for (x = 0; x < NUM_EDGES (edge_list); x++)\n-    {\n-      if (INDEX_EDGE_PRED_BB (edge_list, x) == pred\n-\t  && INDEX_EDGE_SUCC_BB (edge_list, x) == succ)\n-\treturn x;\n-    }\n+    if (INDEX_EDGE_PRED_BB (edge_list, x) == pred\n+\t&& INDEX_EDGE_SUCC_BB (edge_list, x) == succ)\n+      return x;\n+\n   return (EDGE_INDEX_NO_EDGE);\n }\n \n@@ -670,6 +681,7 @@ flow_edge_list_print (str, edge_list, num_edges, file)\n   for (i = 0; i < num_edges; i++)\n     fprintf (file, \"%d->%d \", edge_list[i]->src->index,\n \t     edge_list[i]->dest->index);\n+\n   fputs (\"}\\n\", file);\n }\n \n@@ -683,9 +695,11 @@ remove_fake_successors (bb)\n      basic_block bb;\n {\n   edge e;\n+\n   for (e = bb->succ; e;)\n     {\n       edge tmp = e;\n+\n       e = e->succ_next;\n       if ((tmp->flags & EDGE_FAKE) == EDGE_FAKE)\n \tremove_edge (tmp);\n@@ -737,11 +751,10 @@ void\n connect_infinite_loops_to_exit ()\n {\n   basic_block unvisited_block;\n+  struct depth_first_search_dsS dfs_ds;\n \n   /* Perform depth-first search in the reverse graph to find nodes\n      reachable from the exit block.  */\n-  struct depth_first_search_dsS dfs_ds;\n-\n   flow_dfs_compute_reverse_init (&dfs_ds);\n   flow_dfs_compute_reverse_add_bb (&dfs_ds, EXIT_BLOCK_PTR);\n \n@@ -751,16 +764,17 @@ connect_infinite_loops_to_exit ()\n       unvisited_block = flow_dfs_compute_reverse_execute (&dfs_ds);\n       if (!unvisited_block)\n \tbreak;\n+\n       make_edge (unvisited_block, EXIT_BLOCK_PTR, EDGE_FAKE);\n       flow_dfs_compute_reverse_add_bb (&dfs_ds, unvisited_block);\n     }\n \n   flow_dfs_compute_reverse_finish (&dfs_ds);\n-\n   return;\n }\n \f\n /* Compute reverse top sort order */\n+\n void\n flow_reverse_top_sort_order_compute (rts_order)\n      int *rts_order;\n@@ -801,11 +815,9 @@ flow_reverse_top_sort_order_compute (rts_order)\n \t  SET_BIT (visited, dest->index);\n \n \t  if (dest->succ)\n-\t    {\n-\t      /* Since the DEST node has been visited for the first\n-\t\t time, check its successors.  */\n-\t      stack[sp++] = dest->succ;\n-\t    }\n+\t    /* Since the DEST node has been visited for the first\n+\t       time, check its successors.  */\n+\t    stack[sp++] = dest->succ;\n \t  else\n \t    rts_order[postnum++] = dest->index;\n \t}\n@@ -879,28 +891,21 @@ flow_depth_first_order_compute (dfs_order, rc_order)\n \t  dfsnum++;\n \n \t  if (dest->succ)\n-\t    {\n-\t      /* Since the DEST node has been visited for the first\n-\t\t time, check its successors.  */\n-\t      stack[sp++] = dest->succ;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* There are no successors for the DEST node so assign\n-\t\t its reverse completion number.  */\n-\t      if (rc_order)\n-\t\trc_order[rcnum--] = dest->index;\n-\t    }\n+\t    /* Since the DEST node has been visited for the first\n+\t       time, check its successors.  */\n+\t    stack[sp++] = dest->succ;\n+\t  else if (rc_order)\n+\t    /* There are no successors for the DEST node so assign\n+\t       its reverse completion number.  */\n+\t    rc_order[rcnum--] = dest->index;\n \t}\n       else\n \t{\n-\t  if (! e->succ_next && src != ENTRY_BLOCK_PTR)\n-\t    {\n-\t      /* There are no more successors for the SRC node\n-\t\t so assign its reverse completion number.  */\n-\t      if (rc_order)\n-\t\trc_order[rcnum--] = src->index;\n-\t    }\n+\t  if (! e->succ_next && src != ENTRY_BLOCK_PTR\n+\t      && rc_order)\n+\t    /* There are no more successors for the SRC node\n+\t       so assign its reverse completion number.  */\n+\t    rc_order[rcnum--] = src->index;\n \n \t  if (e->succ_next)\n \t    stack[sp - 1] = e->succ_next;\n@@ -920,10 +925,12 @@ flow_depth_first_order_compute (dfs_order, rc_order)\n   /* There are some nodes left in the CFG that are unreachable.  */\n   if (dfsnum < n_basic_blocks)\n     abort ();\n+\n   return dfsnum;\n }\n \n-struct dfst_node {\n+struct dfst_node\n+{\n     unsigned nnodes;\n     struct dfst_node **node;\n     struct dfst_node *up;\n@@ -958,17 +965,20 @@ flow_preorder_transversal_compute (pot_order)\n   sp = 0;\n \n   /* Allocate the tree.  */\n-  dfst\n-    = (struct dfst_node *) xcalloc (n_basic_blocks, sizeof (struct dfst_node));\n+  dfst = (struct dfst_node *) xcalloc (n_basic_blocks,\n+\t\t\t\t       sizeof (struct dfst_node));\n+\n   for (i = 0; i < n_basic_blocks; i++)\n     {\n       max_successors = 0;\n       for (e = BASIC_BLOCK (i)->succ; e; e = e->succ_next)\n \tmax_successors++;\n-      dfst[i].node = max_successors ? (struct dfst_node **)\n-\t\t\t\t      xcalloc (max_successors,\n-\t\t\t\t\t       sizeof (struct dfst_node *))\n-\t\t\t    : NULL;\n+\n+      dfst[i].node\n+\t= (max_successors\n+\t   ? (struct dfst_node **) xcalloc (max_successors,\n+\t\t\t\t\t    sizeof (struct dfst_node *))\n+\t   : NULL);\n     }\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -1005,19 +1015,15 @@ flow_preorder_transversal_compute (pot_order)\n \t    }\n \n \t  if (dest->succ)\n-\t    {\n-\t      /* Since the DEST node has been visited for the first\n-\t\t time, check its successors.  */\n-\t      stack[sp++] = dest->succ;\n-\t    }\n+\t    /* Since the DEST node has been visited for the first\n+\t       time, check its successors.  */\n+\t    stack[sp++] = dest->succ;\n \t}\n+\n+      else if (e->succ_next)\n+\tstack[sp - 1] = e->succ_next;\n       else\n-\t{\n-\t  if (e->succ_next)\n-\t    stack[sp - 1] = e->succ_next;\n-\t  else\n-\t    sp--;\n-\t}\n+\tsp--;\n     }\n \n   free (stack);\n@@ -1046,6 +1052,7 @@ flow_preorder_transversal_compute (pot_order)\n   for (i = 0; i < n_basic_blocks; i++)\n     if (dfst[i].node)\n       free (dfst[i].node);\n+\n   free (dfst);\n }\n \n@@ -1084,9 +1091,8 @@ flow_dfs_compute_reverse_init (data)\n      depth_first_search_ds data;\n {\n   /* Allocate stack for back-tracking up CFG.  */\n-  data->stack =\n-    (basic_block *) xmalloc ((n_basic_blocks - (INVALID_BLOCK + 1))\n-\t\t\t     * sizeof (basic_block));\n+  data->stack = (basic_block *) xmalloc ((n_basic_blocks - (INVALID_BLOCK + 1))\n+\t\t\t\t\t * sizeof (basic_block));\n   data->sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -1109,13 +1115,12 @@ flow_dfs_compute_reverse_add_bb (data, bb)\n {\n   data->stack[data->sp++] = bb;\n   SET_BIT (data->visited_blocks, bb->index - (INVALID_BLOCK + 1));\n-  return;\n }\n \n-/* Continue the depth-first search through the reverse graph starting\n-   with the block at the stack's top and ending when the stack is\n-   empty.  Visited nodes are marked.  Returns an unvisited basic\n-   block, or NULL if there is none available.  */\n+/* Continue the depth-first search through the reverse graph starting with the\n+   block at the stack's top and ending when the stack is empty.  Visited nodes\n+   are marked.  Returns an unvisited basic block, or NULL if there is none\n+   available.  */\n \n static basic_block\n flow_dfs_compute_reverse_execute (data)\n@@ -1128,6 +1133,7 @@ flow_dfs_compute_reverse_execute (data)\n   while (data->sp > 0)\n     {\n       bb = data->stack[--data->sp];\n+\n       /* Perform depth-first search on adjacent vertices.  */\n       for (e = bb->pred; e; e = e->pred_next)\n \tif (!TEST_BIT (data->visited_blocks,\n@@ -1136,9 +1142,10 @@ flow_dfs_compute_reverse_execute (data)\n     }\n \n   /* Determine if there are unvisited basic blocks.  */\n-  for (i = n_basic_blocks - (INVALID_BLOCK + 1); --i >= 0;)\n+  for (i = n_basic_blocks - (INVALID_BLOCK + 1); --i >= 0; )\n     if (!TEST_BIT (data->visited_blocks, i))\n       return BASIC_BLOCK (i + (INVALID_BLOCK + 1));\n+\n   return NULL;\n }\n \n@@ -1151,5 +1158,4 @@ flow_dfs_compute_reverse_finish (data)\n {\n   free (data->stack);\n   sbitmap_free (data->visited_blocks);\n-  return;\n }"}, {"sha": "136ec07dda75740f6d79be31c26d671f7cedfa4f", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 57, "deletions": 56, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4891442b1f7dcf81fb2d8772cc4adb6123194350/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4891442b1f7dcf81fb2d8772cc4adb6123194350/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=4891442b1f7dcf81fb2d8772cc4adb6123194350", "patch": "@@ -30,8 +30,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n      - CFG construction\n          find_basic_blocks\n      - Local CFG construction\n-         find_sub_basic_blocks\n- */\n+         find_sub_basic_blocks\t\t */\n \f\n #include \"config.h\"\n #include \"system.h\"\n@@ -46,8 +45,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"except.h\"\n #include \"toplev.h\"\n #include \"timevar.h\"\n-\n #include \"obstack.h\"\n+\n static int count_basic_blocks\t\tPARAMS ((rtx));\n static void find_basic_blocks_1\t\tPARAMS ((rtx));\n static rtx find_label_refs\t\tPARAMS ((rtx, rtx));\n@@ -59,7 +58,7 @@ static void find_bb_boundaries\t\tPARAMS ((basic_block));\n static void compute_outgoing_frequencies PARAMS ((basic_block));\n static bool inside_basic_block_p\tPARAMS ((rtx));\n static bool control_flow_insn_p\t\tPARAMS ((rtx));\n-\n+\f\n /* Return true if insn is something that should be contained inside basic\n    block.  */\n \n@@ -71,18 +70,14 @@ inside_basic_block_p (insn)\n     {\n     case CODE_LABEL:\n       /* Avoid creating of basic block for jumptables.  */\n-      if (NEXT_INSN (insn)\n-\t  && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n-\t  && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n-\t      || GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_DIFF_VEC))\n-\treturn false;\n-      return true;\n+      return (NEXT_INSN (insn) == 0\n+\t      || GET_CODE (NEXT_INSN (insn)) != JUMP_INSN\n+\t      || (GET_CODE (PATTERN (NEXT_INSN (insn))) != ADDR_VEC\n+\t\t  && GET_CODE (PATTERN (NEXT_INSN (insn))) != ADDR_DIFF_VEC));\n \n     case JUMP_INSN:\n-      if (GET_CODE (PATTERN (insn)) == ADDR_VEC\n-\t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n-\treturn false;\n-      return true;\n+      return (GET_CODE (PATTERN (insn)) != ADDR_VEC\n+\t      && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC);\n \n     case CALL_INSN:\n     case INSN:\n@@ -97,14 +92,15 @@ inside_basic_block_p (insn)\n     }\n }\n \n-/* Return true if INSN may cause control flow transfer, so \n-   it should be last in the basic block.  */\n+/* Return true if INSN may cause control flow transfer, so it should be last in\n+   the basic block.  */\n \n static bool\n control_flow_insn_p (insn)\n      rtx insn;\n {\n   rtx note;\n+\n   switch (GET_CODE (insn))\n     {\n       case NOTE:\n@@ -113,23 +109,20 @@ control_flow_insn_p (insn)\n \n       case JUMP_INSN:\n \t/* Jump insn always causes control transfer except for tablejumps.  */\n-\tif (GET_CODE (PATTERN (insn)) == ADDR_VEC\n-\t    || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n-\t  return false;\n-\treturn true;\n+\treturn (GET_CODE (PATTERN (insn)) != ADDR_VEC\n+\t\t&& GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC);\n \n       case CALL_INSN:\n \t/* Call insn may return to the nonlocal goto handler.  */\n-\tif (nonlocal_goto_handler_labels\n-\t    && ((note = find_reg_note (insn, REG_EH_REGION, NULL_RTX)) == 0\n-\t\t|| INTVAL (XEXP (note, 0)) >= 0))\n-\t  return true;\n-\t/* Or may trap.  */\n-\treturn can_throw_internal (insn);\n+\treturn ((nonlocal_goto_handler_labels\n+\t\t && (0 == (note = find_reg_note (insn, REG_EH_REGION,\n+\t\t\t\t\t\t NULL_RTX))\n+\t\t     || INTVAL (XEXP (note, 0)) >= 0))\n+\t\t/* Or may trap.  */\n+\t\t|| can_throw_internal (insn));\n \n       case INSN:\n-\treturn (flag_non_call_exceptions\n-\t\t&& can_throw_internal (insn));\n+\treturn (flag_non_call_exceptions && can_throw_internal (insn));\n \n       case BARRIER:\n \t/* It is nonsence to reach barrier when looking for the\n@@ -156,7 +149,6 @@ count_basic_blocks (f)\n     {\n       /* Code labels and barriers causes curent basic block to be\n          terminated at previous real insn.  */\n-\n       if ((GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == BARRIER)\n \t  && saw_insn)\n \tcount++, saw_insn = false;\n@@ -169,6 +161,7 @@ count_basic_blocks (f)\n       if (saw_insn && control_flow_insn_p (insn))\n \tcount++, saw_insn = false;\n     }\n+\n   if (saw_insn)\n     count++;\n \n@@ -185,6 +178,7 @@ count_basic_blocks (f)\n \n /* Scan a list of insns for labels referred to other than by jumps.\n    This is used to scan the alternatives of a call placeholder.  */\n+\n static rtx\n find_label_refs (f, lvl)\n      rtx f;\n@@ -263,7 +257,7 @@ make_eh_edge (edge_cache, src, insn)\n      basic_block src;\n      rtx insn;\n {\n-  int is_call = (GET_CODE (insn) == CALL_INSN ? EDGE_ABNORMAL_CALL : 0);\n+  int is_call = GET_CODE (insn) == CALL_INSN ? EDGE_ABNORMAL_CALL : 0;\n   rtx handlers, i;\n \n   handlers = reachable_handlers (insn);\n@@ -274,6 +268,7 @@ make_eh_edge (edge_cache, src, insn)\n \n   free_INSN_LIST_list (&handlers);\n }\n+\n /* Identify the edges between basic blocks MIN to MAX.\n \n    NONLOCAL_LABEL_LIST is a list of non-local labels in the function.  Blocks\n@@ -305,6 +300,7 @@ make_edges (label_value_list, min, max, update_p)\n \tfor (i = min; i <= max; ++i)\n \t  {\n \t    edge e;\n+\n \t    for (e = BASIC_BLOCK (i)->succ; e ; e = e->succ_next)\n \t      if (e->dest != EXIT_BLOCK_PTR)\n \t        SET_BIT (edge_cache[i], e->dest->index);\n@@ -313,7 +309,8 @@ make_edges (label_value_list, min, max, update_p)\n \n   /* By nature of the way these get numbered, block 0 is always the entry.  */\n   if (min == 0)\n-    cached_make_edge (edge_cache, ENTRY_BLOCK_PTR, BASIC_BLOCK (0), EDGE_FALLTHRU);\n+    cached_make_edge (edge_cache, ENTRY_BLOCK_PTR, BASIC_BLOCK (0),\n+\t\t      EDGE_FALLTHRU);\n \n   for (i = min; i <= max; ++i)\n     {\n@@ -322,8 +319,7 @@ make_edges (label_value_list, min, max, update_p)\n       enum rtx_code code;\n       int force_fallthru = 0;\n \n-      if (GET_CODE (bb->head) == CODE_LABEL\n-\t  && LABEL_ALTERNATE_NAME (bb->head))\n+      if (GET_CODE (bb->head) == CODE_LABEL && LABEL_ALTERNATE_NAME (bb->head))\n \tcached_make_edge (NULL, ENTRY_BLOCK_PTR, bb, 0);\n \n       /* Examine the last instruction of the block, and discover the\n@@ -408,21 +404,18 @@ make_edges (label_value_list, min, max, update_p)\n \t    }\n \t}\n \n-      /* If this is a sibling call insn, then this is in effect a\n-\t combined call and return, and so we need an edge to the\n-\t exit block.  No need to worry about EH edges, since we\n-\t wouldn't have created the sibling call in the first place.  */\n-\n+      /* If this is a sibling call insn, then this is in effect a combined call\n+\t and return, and so we need an edge to the exit block.  No need to\n+\t worry about EH edges, since we wouldn't have created the sibling call\n+\t in the first place.  */\n       if (code == CALL_INSN && SIBLING_CALL_P (insn))\n \tcached_make_edge (edge_cache, bb, EXIT_BLOCK_PTR,\n \t\t   EDGE_ABNORMAL | EDGE_ABNORMAL_CALL);\n \n       /* If this is a CALL_INSN, then mark it as reaching the active EH\n \t handler for this CALL_INSN.  If we're handling non-call\n \t exceptions then any insn can reach any of the active handlers.\n-\n \t Also mark the CALL_INSN as reaching any nonlocal goto handler.  */\n-\n       else if (code == CALL_INSN || flag_non_call_exceptions)\n \t{\n \t  /* Add any appropriate EH edges.  */\n@@ -432,14 +425,15 @@ make_edges (label_value_list, min, max, update_p)\n \t    {\n \t      /* ??? This could be made smarter: in some cases it's possible\n \t\t to tell that certain calls will not do a nonlocal goto.\n-\n \t\t For example, if the nested functions that do the nonlocal\n \t\t gotos do not have their addresses taken, then only calls to\n \t\t those functions or to other nested functions that use them\n \t\t could possibly do nonlocal gotos.  */\n+\n \t      /* We do know that a REG_EH_REGION note with a value less\n \t\t than 0 is guaranteed not to perform a non-local goto.  */\n \t      rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n+\n \t      if (!note || INTVAL (XEXP (note, 0)) >=  0)\n \t\tfor (x = nonlocal_goto_handler_labels; x; x = XEXP (x, 1))\n \t\t  make_label_edge (edge_cache, bb, XEXP (x, 0),\n@@ -457,7 +451,8 @@ make_edges (label_value_list, min, max, update_p)\n \t  if (GET_CODE (tmp) == NOTE)\n \t    tmp = next_nonnote_insn (tmp);\n \t  if (force_fallthru || insn == tmp)\n-\t    cached_make_edge (edge_cache, bb, BASIC_BLOCK (i + 1), EDGE_FALLTHRU);\n+\t    cached_make_edge (edge_cache, bb, BASIC_BLOCK (i + 1),\n+\t\t\t      EDGE_FALLTHRU);\n \t}\n     }\n \n@@ -501,12 +496,14 @@ find_basic_blocks_1 (f)\n \t  head = end = NULL_RTX;\n \t  bb_note = NULL_RTX;\n \t}\n+\n       if (inside_basic_block_p (insn))\n \t{\n \t  if (head == NULL_RTX)\n \t    head = insn;\n \t  end = insn;\n \t}\n+\n       if (head && control_flow_insn_p (insn))\n \t{\n \t  create_basic_block_structure (i++, head, end, bb_note);\n@@ -676,14 +673,10 @@ find_basic_blocks (f, nregs, file)\n }\n \f\n /* State of basic block as seen by find_sub_basic_blocks.  */\n-enum state\n-  {\n-    BLOCK_NEW = 0,\n-    BLOCK_ORIGINAL,\n-    BLOCK_TO_SPLIT\n-  };\n-#define STATE(bb) (enum state)(size_t)(bb)->aux\n-#define SET_STATE(bb, state) (bb)->aux = (void *) (size_t) (state)\n+enum state {BLOCK_NEW = 0, BLOCK_ORIGINAL, BLOCK_TO_SPLIT};\n+\n+#define STATE(BB) (enum state) ((size_t) (BB)->aux)\n+#define SET_STATE(BB, STATE) ((BB)->aux = (void *) (size_t) (STATE))\n \n /* Scan basic block BB for possible BB boundaries inside the block\n    and create new basic blocks in the progress.  */\n@@ -714,12 +707,14 @@ find_bb_boundaries (bb)\n \t  fallthru = split_block (bb, PREV_INSN (insn));\n \t  if (flow_transfer_insn)\n \t    bb->end = flow_transfer_insn;\n+\n \t  bb = fallthru->dest;\n \t  remove_edge (fallthru);\n \t  flow_transfer_insn = NULL_RTX;\n \t  if (LABEL_ALTERNATE_NAME (insn))\n \t    make_edge (ENTRY_BLOCK_PTR, bb, 0);\n \t}\n+\n       /* In case we've previously seen an insn that effects a control\n \t flow transfer, split the block.  */\n       if (flow_transfer_insn && inside_basic_block_p (insn))\n@@ -730,6 +725,7 @@ find_bb_boundaries (bb)\n \t  remove_edge (fallthru);\n \t  flow_transfer_insn = NULL_RTX;\n \t}\n+\n       if (control_flow_insn_p (insn))\n \tflow_transfer_insn = insn;\n       if (insn == end)\n@@ -757,15 +753,18 @@ compute_outgoing_frequencies (b)\n      basic_block b;\n {\n   edge e, f;\n+\n   if (b->succ && b->succ->succ_next && !b->succ->succ_next->succ_next)\n     {\n       rtx note = find_reg_note (b->end, REG_BR_PROB, NULL);\n       int probability;\n \n       if (!note)\n \treturn;\n+\n       probability = INTVAL (XEXP (find_reg_note (b->end,\n-\t\t\t\t\t\t REG_BR_PROB, NULL), 0));\n+\t\t\t\t\t\t REG_BR_PROB, NULL),\n+\t\t\t\t  0));\n       e = BRANCH_EDGE (b);\n       e->probability = probability;\n       e->count = ((b->count * probability + REG_BR_PROB_BASE / 2)\n@@ -774,6 +773,7 @@ compute_outgoing_frequencies (b)\n       f->probability = REG_BR_PROB_BASE - probability;\n       f->count = b->count - e->count;\n     }\n+\n   if (b->succ && !b->succ->succ_next)\n     {\n       e = b->succ;\n@@ -797,15 +797,13 @@ find_many_sub_basic_blocks (blocks)\n \t       TEST_BIT (blocks, i) ? BLOCK_TO_SPLIT : BLOCK_ORIGINAL);\n \n   for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      basic_block bb = BASIC_BLOCK (i);\n-      if (STATE (bb) == BLOCK_TO_SPLIT)\n-\tfind_bb_boundaries (bb);\n-    }\n+    if (STATE (BASIC_BLOCK (i)) == BLOCK_TO_SPLIT)\n+      find_bb_boundaries (BASIC_BLOCK (i));\n \n   for (i = 0; i < n_basic_blocks; i++)\n     if (STATE (BASIC_BLOCK (i)) != BLOCK_ORIGINAL)\n       break;\n+\n   min = max = i;\n   for (; i < n_basic_blocks; i++)\n     if (STATE (BASIC_BLOCK (i)) != BLOCK_ORIGINAL)\n@@ -834,8 +832,10 @@ find_many_sub_basic_blocks (blocks)\n \t      b->frequency += EDGE_FREQUENCY (e);\n \t    }\n \t}\n+\n       compute_outgoing_frequencies (b);\n     }\n+\n   for (i = 0; i < n_basic_blocks; i++)\n     SET_STATE (BASIC_BLOCK (i), 0);\n }\n@@ -876,6 +876,7 @@ find_sub_basic_blocks (bb)\n \t      b->frequency += EDGE_FREQUENCY (e);\n \t    }\n \t}\n+\n       compute_outgoing_frequencies (b);\n     }\n }"}]}