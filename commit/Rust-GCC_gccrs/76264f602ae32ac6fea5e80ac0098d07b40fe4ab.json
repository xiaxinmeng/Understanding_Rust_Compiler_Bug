{"sha": "76264f602ae32ac6fea5e80ac0098d07b40fe4ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYyNjRmNjAyYWUzMmFjNmZlYTVlODBhYzAwOThkMDdiNDBmZTRhYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-05T10:44:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-05T10:44:58Z"}, "message": "[multiple changes]\n\n2011-12-05  Bob Duff  <duff@adacore.com>\n\n\t* sem_ch4.adb: Minor comment fix.\n\n2011-12-05  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_ugn.texi: Add documentation for -gnatw.e.\n\n2011-12-05  Bob Duff  <duff@adacore.com>\n\n\t* treepr.adb (pn): Print something useful for\n\tElmt_Ids. Add Write_Eol to 'when others' case, so the output\n\twill be seen immediately in gdb.\n\n2011-12-05  Ed Schonberg  <schonberg@adacore.com>\n\n\t* lib-writ.adb (Output_Main_Program_Line): A generic subprogram\n\tis never a main program.\n\n2011-12-05  Thomas Quinot  <quinot@adacore.com>\n\n\t* par_sco.adb: Various minor adjustments to dominance markers\n\tgeneration.\n\n2011-12-05  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Expression_Function): If the function is\n\ta completion, generate a body reference for its defining entity,\n\tbefore rewriting the node as a body.\n\t* sem_util.adb (Defining_Entity): Add entry for expression\n\tfunction.\n\nFrom-SVN: r182006", "tree": {"sha": "c9a9215ce2eb42e4e990fdaa7c8f4d3a1ad9ff39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9a9215ce2eb42e4e990fdaa7c8f4d3a1ad9ff39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76264f602ae32ac6fea5e80ac0098d07b40fe4ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76264f602ae32ac6fea5e80ac0098d07b40fe4ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76264f602ae32ac6fea5e80ac0098d07b40fe4ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76264f602ae32ac6fea5e80ac0098d07b40fe4ab/comments", "author": null, "committer": null, "parents": [{"sha": "7f3d8f56e747b1a814c633a9ab160adf02b5d498", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f3d8f56e747b1a814c633a9ab160adf02b5d498", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f3d8f56e747b1a814c633a9ab160adf02b5d498"}], "stats": {"total": 178, "additions": 138, "deletions": 40}, "files": [{"sha": "f9977b6a37a4d26b35e9436f3c9b350476d50d18", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76264f602ae32ac6fea5e80ac0098d07b40fe4ab/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76264f602ae32ac6fea5e80ac0098d07b40fe4ab/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=76264f602ae32ac6fea5e80ac0098d07b40fe4ab", "patch": "@@ -1,3 +1,35 @@\n+2011-12-05  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_ch4.adb: Minor comment fix.\n+\n+2011-12-05  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_ugn.texi: Add documentation for -gnatw.e.\n+\n+2011-12-05  Bob Duff  <duff@adacore.com>\n+\n+\t* treepr.adb (pn): Print something useful for\n+\tElmt_Ids. Add Write_Eol to 'when others' case, so the output\n+\twill be seen immediately in gdb.\n+\n+2011-12-05  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* lib-writ.adb (Output_Main_Program_Line): A generic subprogram\n+\tis never a main program.\n+\n+2011-12-05  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* par_sco.adb: Various minor adjustments to dominance markers\n+\tgeneration.\n+\n+2011-12-05  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Expression_Function): If the function is\n+\ta completion, generate a body reference for its defining entity,\n+\tbefore rewriting the node as a body.\n+\t* sem_util.adb (Defining_Entity): Add entry for expression\n+\tfunction.\n+\n 2011-12-05  Bob Duff  <duff@adacore.com>\n \n \t* sem_ch3.adb (Derive_Progenitor_Subprograms): Add Ultimate_Alias"}, {"sha": "d42ac09cfc7540067918c85dfa4585868a56d02b", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76264f602ae32ac6fea5e80ac0098d07b40fe4ab/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76264f602ae32ac6fea5e80ac0098d07b40fe4ab/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=76264f602ae32ac6fea5e80ac0098d07b40fe4ab", "patch": "@@ -5242,7 +5242,12 @@ is the only -gnatw switch that affects the handling of style check messages.\n @cindex @option{-gnatw.e} (@command{gcc})\n @cindex Warnings, activate every optional warning\n This switch activates all optional warnings, including those which\n-are not activated by @code{-gnatwa}.\n+are not activated by @code{-gnatwa}. The use of this switch is not\n+recommended for normal use. If you turn this switch on, it is almost\n+certain that you will get large numbers of useless warnings. The\n+warnings that are excluded from @code{-gnatwa} are typically highly\n+specialized warnings that are suitable for use only in code that has\n+been specifically designed according to specialized coding rules.\n \n @item -gnatwf\n @emph{Activate warnings on unreferenced formals.}"}, {"sha": "2d67ea03ccdf2b6b5897f0ac8a57e1b9d4c72b4f", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76264f602ae32ac6fea5e80ac0098d07b40fe4ab/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76264f602ae32ac6fea5e80ac0098d07b40fe4ab/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=76264f602ae32ac6fea5e80ac0098d07b40fe4ab", "patch": "@@ -987,7 +987,17 @@ package body Lib.Writ is\n \n             S := Specification (U);\n \n-            if No (Parameter_Specifications (S)) then\n+            --  A generic subprogram is never a main program\n+\n+            if Nkind (U) = N_Subprogram_Body\n+              and then Present (Corresponding_Spec (U))\n+              and then\n+                Ekind_In (Corresponding_Spec (U),\n+                  E_Generic_Procedure, E_Generic_Function)\n+            then\n+               null;\n+\n+            elsif No (Parameter_Specifications (S)) then\n                if Nkind (S) = N_Procedure_Specification then\n                   Write_Info_Initiate ('M');\n                   Write_Info_Str (\" P\");"}, {"sha": "4f3a36e37ebb40ff7c0a8c4be35559419c830d51", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 70, "deletions": 35, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76264f602ae32ac6fea5e80ac0098d07b40fe4ab/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76264f602ae32ac6fea5e80ac0098d07b40fe4ab/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=76264f602ae32ac6fea5e80ac0098d07b40fe4ab", "patch": "@@ -149,7 +149,9 @@ package body Par_SCO is\n    procedure Traverse_Package_Body                (N : Node_Id);\n    procedure Traverse_Package_Declaration         (N : Node_Id);\n    procedure Traverse_Protected_Body              (N : Node_Id);\n-   procedure Traverse_Subprogram_Or_Task_Body     (N : Node_Id);\n+   procedure Traverse_Subprogram_Or_Task_Body\n+     (N : Node_Id;\n+      D : Dominant_Info := No_Dominant);\n    procedure Traverse_Subprogram_Declaration      (N : Node_Id);\n    --  Traverse the corresponding construct, generating SCO table entries\n \n@@ -1039,8 +1041,8 @@ package body Par_SCO is\n       Current_Dominant : Dominant_Info := D;\n       --  Dominance information for the current basic block\n \n-      Current_Condition : Node_Id;\n-      --  Last tested condition in current IF statement\n+      Current_Test : Node_Id;\n+      --  Conditional node (N_If_Statement or N_Elsiif being processed\n \n       N     : Node_Id;\n       Dummy : Source_Ptr;\n@@ -1273,15 +1275,20 @@ package body Par_SCO is\n                   declare\n                      Cond : constant Node_Id :=\n                               Condition (Entry_Body_Formal_Part (N));\n-\n+                     Inner_Dominant : Dominant_Info := No_Dominant;\n                   begin\n                      Set_Statement_Entry;\n \n                      if Present (Cond) then\n                         Process_Decisions_Defer (Cond, 'G');\n+\n+                        --  For an entry body with a barrier, the entry body\n+                        --  is dominanted by a True evaluation of the barrier.\n+\n+                        Inner_Dominant := ('T', N);\n                      end if;\n \n-                     Traverse_Subprogram_Or_Task_Body (N);\n+                     Traverse_Subprogram_Or_Task_Body (N, Inner_Dominant);\n                   end;\n \n                --  Protected body\n@@ -1299,7 +1306,15 @@ package body Par_SCO is\n                   Extend_Statement_Sequence (N, ' ');\n                   Process_Decisions_Defer (Condition (N), 'E');\n                   Set_Statement_Entry;\n-                  Current_Dominant := No_Dominant;\n+\n+                  --  If condition is present, then following statement is\n+                  --  only executed if the condition evaluates to False.\n+\n+                  if Present (Condition (N)) then\n+                     Current_Dominant := ('F', N);\n+                  else\n+                     Current_Dominant := No_Dominant;\n+                  end if;\n \n                --  Label, which breaks the current statement sequence, but the\n                --  label itself is not included in the next statement sequence,\n@@ -1324,41 +1339,57 @@ package body Par_SCO is\n                --  but we include the condition in the current sequence.\n \n                when N_If_Statement =>\n-                  Current_Condition := Condition (N);\n-                  Extend_Statement_Sequence (N, Current_Condition, 'I');\n-                  Process_Decisions_Defer (Current_Condition, 'I');\n+                  Current_Test := N;\n+                  Extend_Statement_Sequence (N, Condition (N), 'I');\n+                  Process_Decisions_Defer (Condition (N), 'I');\n                   Set_Statement_Entry;\n \n                   --  Now we traverse the statements in the THEN part\n \n                   Traverse_Declarations_Or_Statements\n                     (L => Then_Statements (N),\n-                     D => ('T', Current_Condition));\n+                     D => ('T', N));\n \n                   --  Loop through ELSIF parts if present\n \n                   if Present (Elsif_Parts (N)) then\n                      declare\n+                        Saved_Dominant : constant Dominant_Info :=\n+                                           Current_Dominant;\n                         Elif : Node_Id := First (Elsif_Parts (N));\n \n                      begin\n                         while Present (Elif) loop\n \n+                           --  An Elsif is executed only if the previous test\n+                           --  got a FALSE outcome.\n+\n+                           Current_Dominant := ('F', Current_Test);\n+\n+                           --  Now update current test information\n+\n+                           Current_Test := Elif;\n+\n                            --  We generate a statement sequence for the\n                            --  construct \"ELSIF condition\", so that we have\n                            --  a statement for the resulting decisions.\n \n-                           Current_Condition := Condition (Elif);\n                            Extend_Statement_Sequence\n-                             (Elif, Current_Condition, 'I');\n-                           Process_Decisions_Defer (Current_Condition, 'I');\n+                             (Elif, Condition (Elif), 'I');\n+                           Process_Decisions_Defer (Condition (Elif), 'I');\n                            Set_Statement_Entry;\n \n+                           --  An ELSIF part is never guaranteed to have\n+                           --  been executed, following statements are only\n+                           --  dominated by the initial IF statement.\n+\n+                           Current_Dominant := Saved_Dominant;\n+\n                            --  Traverse the statements in the ELSIF\n \n                            Traverse_Declarations_Or_Statements\n                              (L => Then_Statements (Elif),\n-                              D => ('T', Current_Condition));\n+                              D => ('T', Elif));\n                            Next (Elif);\n                         end loop;\n                      end;\n@@ -1368,7 +1399,7 @@ package body Par_SCO is\n \n                   Traverse_Declarations_Or_Statements\n                     (L => Else_Statements (N),\n-                     D => ('F', Current_Condition));\n+                     D => ('F', Current_Test));\n \n                --  Case statement, which breaks the current statement sequence,\n                --  but we include the expression in the current sequence.\n@@ -1433,16 +1464,16 @@ package body Par_SCO is\n                --  may not be executed as part of the current sequence.\n \n                when N_Loop_Statement =>\n-                  if Present (Iteration_Scheme (N)) then\n-\n-                     --  If iteration scheme present, extend the current\n-                     --  statement sequence to include the iteration scheme\n-                     --  and process any decisions it contains.\n+                  declare\n+                     ISC : constant Node_Id := Iteration_Scheme (N);\n+                     Inner_Dominant : Dominant_Info := No_Dominant;\n+                  begin\n+                     if Present (ISC) then\n \n-                     declare\n-                        ISC : constant Node_Id := Iteration_Scheme (N);\n+                        --  If iteration scheme present, extend the current\n+                        --  statement sequence to include the iteration scheme\n+                        --  and process any decisions it contains.\n \n-                     begin\n                         --  While statement\n \n                         if Present (Condition (ISC)) then\n@@ -1451,7 +1482,7 @@ package body Par_SCO is\n \n                            --  Set more specific dominant for inner statements\n \n-                           Current_Dominant := ('T', Condition (ISC));\n+                           Inner_Dominant := ('T', N);\n \n                         --  For statement\n \n@@ -1460,17 +1491,18 @@ package body Par_SCO is\n                            Process_Decisions_Defer\n                              (Loop_Parameter_Specification (ISC), 'X');\n                         end if;\n-                     end;\n-                  end if;\n+                     end if;\n \n-                  Set_Statement_Entry;\n-                  Traverse_Declarations_Or_Statements\n-                    (L => Statements (N),\n-                     D => Current_Dominant);\n+                     Set_Statement_Entry;\n \n-                  --  Reset current dominant\n+                     if Inner_Dominant = No_Dominant then\n+                        Inner_Dominant := Current_Dominant;\n+                     end if;\n \n-                  Current_Dominant := ('S', N);\n+                     Traverse_Declarations_Or_Statements\n+                       (L => Statements (N),\n+                        D => Inner_Dominant);\n+                  end;\n \n                --  Pragma\n \n@@ -1708,10 +1740,13 @@ package body Par_SCO is\n    -- Traverse_Subprogram_Or_Task_Body --\n    --------------------------------------\n \n-   procedure Traverse_Subprogram_Or_Task_Body (N : Node_Id) is\n+   procedure Traverse_Subprogram_Or_Task_Body\n+     (N : Node_Id;\n+      D : Dominant_Info := No_Dominant)\n+   is\n    begin\n-      Traverse_Declarations_Or_Statements (Declarations (N));\n-      Traverse_Handled_Statement_Sequence (Handled_Statement_Sequence (N));\n+      Traverse_Declarations_Or_Statements (Declarations (N), D);\n+      Traverse_Handled_Statement_Sequence (Handled_Statement_Sequence (N), D);\n    end Traverse_Subprogram_Or_Task_Body;\n \n    -------------------------------------"}, {"sha": "197b5757d4b539b8f54675f20ee0961ce6aea738", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76264f602ae32ac6fea5e80ac0098d07b40fe4ab/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76264f602ae32ac6fea5e80ac0098d07b40fe4ab/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=76264f602ae32ac6fea5e80ac0098d07b40fe4ab", "patch": "@@ -6233,7 +6233,7 @@ package body Sem_Ch4 is\n                   Remove_Interp (I);\n                   exit;\n \n-               --  In Ada 2005, this operation does not participate in Overload\n+               --  In Ada 2005, this operation does not participate in overload\n                --  resolution. If the operation is defined in a predefined\n                --  unit, it is one of the operations declared abstract in some\n                --  variants of System, and it must be removed as well."}, {"sha": "2cc899e934a223b5210706d23f0a520de9ea4065", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76264f602ae32ac6fea5e80ac0098d07b40fe4ab/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76264f602ae32ac6fea5e80ac0098d07b40fe4ab/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=76264f602ae32ac6fea5e80ac0098d07b40fe4ab", "patch": "@@ -331,6 +331,10 @@ package body Sem_Ch6 is\n         and then Comes_From_Source (Prev)\n       then\n          Set_Has_Completion (Prev, False);\n+\n+         --  For navigation purposes, indicate that the function is a body\n+\n+         Generate_Reference (Prev, Defining_Entity (N), 'b', Force => True);\n          Rewrite (N, New_Body);\n          Analyze (N);\n "}, {"sha": "8c90086d9a02f2b443c31b95427dbb0b56045e19", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76264f602ae32ac6fea5e80ac0098d07b40fe4ab/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76264f602ae32ac6fea5e80ac0098d07b40fe4ab/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=76264f602ae32ac6fea5e80ac0098d07b40fe4ab", "patch": "@@ -2467,7 +2467,8 @@ package body Sem_Util is\n            N_Subprogram_Body_Stub                   |\n            N_Generic_Subprogram_Declaration         |\n            N_Generic_Package_Declaration            |\n-           N_Formal_Subprogram_Declaration\n+           N_Formal_Subprogram_Declaration          |\n+           N_Expression_Function\n          =>\n             return Defining_Entity (Specification (N));\n "}, {"sha": "684cccdcc190d52fedfef0721a1e9ff80a946532", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76264f602ae32ac6fea5e80ac0098d07b40fe4ab/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76264f602ae32ac6fea5e80ac0098d07b40fe4ab/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=76264f602ae32ac6fea5e80ac0098d07b40fe4ab", "patch": "@@ -273,7 +273,17 @@ package body Treepr is\n          when Elist_Range =>\n             Print_Tree_Elist (Elist_Id (N));\n          when Elmt_Range =>\n-            raise Program_Error;\n+            declare\n+               Id : constant Elmt_Id := Elmt_Id (N);\n+            begin\n+               if No (Id) then\n+                  Write_Str (\"No_Elmt\");\n+                  Write_Eol;\n+               else\n+                  Write_Str (\"Elmt_Id --> \");\n+                  Print_Tree_Node (Node (Id));\n+               end if;\n+            end;\n          when Names_Range =>\n             Namet.wn (Name_Id (N));\n          when Strings_Range =>\n@@ -285,6 +295,7 @@ package body Treepr is\n          when others =>\n             Write_Str (\"Invalid Union_Id: \");\n             Write_Int (Int (N));\n+            Write_Eol;\n       end case;\n    end pn;\n "}]}