{"sha": "2e165c53deb61806019c4a72f006abaa1c2379b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUxNjVjNTNkZWI2MTgwNjAxOWM0YTcyZjAwNmFiYWExYzIzNzliMw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-10-10T22:02:12Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-10-10T22:02:12Z"}, "message": "lex.c (java_new_lexer): Initialize out_first and out_last fields.\n\n\t* lex.c (java_new_lexer): Initialize out_first and out_last\n\tfields.\n\t* lex.h (java_lexer): Added out_buffer, out_first, out_last.\n\nFrom-SVN: r36830", "tree": {"sha": "47943869eedfa993a7aba6e2b6e0474e725d44bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47943869eedfa993a7aba6e2b6e0474e725d44bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e165c53deb61806019c4a72f006abaa1c2379b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e165c53deb61806019c4a72f006abaa1c2379b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e165c53deb61806019c4a72f006abaa1c2379b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e165c53deb61806019c4a72f006abaa1c2379b3/comments", "author": null, "committer": null, "parents": [{"sha": "67e570ea48ad148b9f2d6a4c27f372c4c7532768", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67e570ea48ad148b9f2d6a4c27f372c4c7532768", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67e570ea48ad148b9f2d6a4c27f372c4c7532768"}], "stats": {"total": 162, "additions": 101, "deletions": 61}, "files": [{"sha": "99fa85432429dd7ad84d476cdf5875c739ed05f2", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e165c53deb61806019c4a72f006abaa1c2379b3/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e165c53deb61806019c4a72f006abaa1c2379b3/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=2e165c53deb61806019c4a72f006abaa1c2379b3", "patch": "@@ -1,3 +1,9 @@\n+2000-10-10  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* lex.c (java_new_lexer): Initialize out_first and out_last\n+\tfields.\n+\t* lex.h (java_lexer): Added out_buffer, out_first, out_last.\n+\n 2000-10-07  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \tPatch contributed by Corey Minyard."}, {"sha": "8fb6a15a6fd3f877271bddae6a827e8b88739188", "filename": "gcc/java/lex.c", "status": "modified", "additions": 81, "deletions": 61, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e165c53deb61806019c4a72f006abaa1c2379b3/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e165c53deb61806019c4a72f006abaa1c2379b3/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=2e165c53deb61806019c4a72f006abaa1c2379b3", "patch": "@@ -219,6 +219,8 @@ java_new_lexer (finput, encoding)\n     }\n   lex->first = -1;\n   lex->last = -1;\n+  lex->out_first = -1;\n+  lex->out_last = -1;\n #else /* HAVE_ICONV */\n   if (strcmp (encoding, DEFAULT_ENCODING))\n     enc_error = 1;\n@@ -253,81 +255,99 @@ java_read_char (lex)\n \n #ifdef HAVE_ICONV\n   {\n-    char out[2];\n-    size_t ir, inbytesleft, in_save, out_count;\n+    size_t ir, inbytesleft, in_save, out_count, out_save;\n     char *inp, *outp;\n+    unicode_t result;\n \n-    while (1)\n+    /* If there is data which has already been converted, use it.  */\n+    if (lex->out_first == -1 || lex->out_first >= lex->out_last)\n       {\n-\t/* See if we need to read more data.  If FIRST == 0 then the\n-\t   previous conversion attempt ended in the middle of a\n-\t   character at the end of the buffer.  Otherwise we only have\n-\t   to read if the buffer is empty.  */\n-\tif (lex->first == 0 || lex->first >= lex->last)\n-\t  {\n-\t    int r;\n+\tlex->out_first = 0;\n+\tlex->out_last = 0;\n \n-\t    if (lex->first >= lex->last)\n+\twhile (1)\n+\t  {\n+\t    /* See if we need to read more data.  If FIRST == 0 then\n+\t       the previous conversion attempt ended in the middle of\n+\t       a character at the end of the buffer.  Otherwise we\n+\t       only have to read if the buffer is empty.  */\n+\t    if (lex->first == 0 || lex->first >= lex->last)\n \t      {\n-\t\tlex->first = 0;\n-\t\tlex->last = 0;\n+\t\tint r;\n+\n+\t\tif (lex->first >= lex->last)\n+\t\t  {\n+\t\t    lex->first = 0;\n+\t\t    lex->last = 0;\n+\t\t  }\n+\t\tif (feof (lex->finput))\n+\t\t  return UEOF;\n+\t\tr = fread (&lex->buffer[lex->last], 1,\n+\t\t\t   sizeof (lex->buffer) - lex->last,\n+\t\t\t   lex->finput);\n+\t\tlex->last += r;\n \t      }\n-\t    if (feof (lex->finput))\n-\t      return UEOF;\n-\t    r = fread (&lex->buffer[lex->last], 1,\n-\t\t       sizeof (lex->buffer) - lex->last,\n-\t\t       lex->finput);\n-\t    lex->last += r;\n-\t  }\n \n-\tinbytesleft = lex->last - lex->first;\n-\n-\tif (inbytesleft == 0)\n-\t  {\n-\t    /* We've tried to read and there is nothing left.  */\n-\t    return UEOF;\n-\t  }\n+\t    inbytesleft = lex->last - lex->first;\n+\t    out_count = sizeof (lex->out_buffer) - lex->out_last;\n \n-\tin_save = inbytesleft;\n-\tout_count = 2;\n-\tinp = &lex->buffer[lex->first];\n-\toutp = out;\n-\tir = iconv (lex->handle, (const char **) &inp, &inbytesleft,\n-\t\t    &outp, &out_count);\n-\tlex->first += in_save - inbytesleft;\n-\n-\tif (out_count == 0)\n-\t  {\n-\t    /* Success.  We assume that UCS-2 is big-endian.  This\n-\t       appears to be an ok assumption.  */\n-\t    unicode_t result;\n-\t    result = (((unsigned char) out[0]) << 8) | (unsigned char) out[1];\n-\t    return result;\n-\t  }\n-\n-\tif (ir == (size_t) -1)\n-\t  {\n-\t    if (errno == EINVAL)\n+\t    if (inbytesleft == 0)\n \t      {\n-\t\t/* This is ok.  This means that the end of our buffer\n-\t\t   is in the middle of a character sequence.  We just\n-\t\t   move the valid part of the buffer to the beginning\n-\t\t   to force a read.  */\n-\t\t/* We use bcopy() because it should work for\n-\t\t   overlapping strings.  Use memmove() instead... */\n-\t\tbcopy (&lex->buffer[lex->first], &lex->buffer[0],\n-\t\t       lex->last - lex->first);\n-\t\tlex->last -= lex->first;\n-\t\tlex->first = 0;\n+\t\t/* We've tried to read and there is nothing left.  */\n+\t\treturn UEOF;\n \t      }\n-\t    else\n+\n+\t    in_save = inbytesleft;\n+\t    out_save = out_count;\n+\t    inp = &lex->buffer[lex->first];\n+\t    outp = &lex->out_buffer[lex->out_last];\n+\t    ir = iconv (lex->handle, (const char **) &inp, &inbytesleft,\n+\t\t\t&outp, &out_count);\n+\t    lex->first += in_save - inbytesleft;\n+\t    lex->out_last += out_save - out_count;\n+\n+\t    /* If we converted anything at all, move along.  */\n+\t    if (out_count != out_save)\n+\t      break;\n+\n+\t    if (ir == (size_t) -1)\n \t      {\n-\t\t/* A more serious error.  */\n-\t\tjava_lex_error (\"unrecognized character in input stream\", 0);\n-\t\treturn UEOF;\n+\t\tif (errno == EINVAL)\n+\t\t  {\n+\t\t    /* This is ok.  This means that the end of our buffer\n+\t\t       is in the middle of a character sequence.  We just\n+\t\t       move the valid part of the buffer to the beginning\n+\t\t       to force a read.  */\n+\t\t    /* We use bcopy() because it should work for\n+\t\t       overlapping strings.  Use memmove() instead... */\n+\t\t    bcopy (&lex->buffer[lex->first], &lex->buffer[0],\n+\t\t\t   lex->last - lex->first);\n+\t\t    lex->last -= lex->first;\n+\t\t    lex->first = 0;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* A more serious error.  */\n+\t\t    java_lex_error (\"unrecognized character in input stream\",\n+\t\t\t\t    0);\n+\t\t    return UEOF;\n+\t\t  }\n \t      }\n \t  }\n       }\n+\n+    if (lex->out_first == -1 || lex->out_first >= lex->out_last)\n+      {\n+\t/* Don't have any data.  */\n+\treturn UEOF;\n+      }\n+\n+    /* Success.  We assume that UCS-2 is big-endian.  This appears to\n+       be an ok assumption.  */\n+    result = ((((unsigned char) lex->out_buffer[lex->out_first]) << 8)\n+\t      | (unsigned char) lex->out_buffer[lex->out_first + 1]);\n+    lex->out_first += 2;\n+    return result;\n   }\n #else /* HAVE_ICONV */\n   {"}, {"sha": "71a030d2fefd50a04f9fe5794260542d98b039de", "filename": "gcc/java/lex.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e165c53deb61806019c4a72f006abaa1c2379b3/gcc%2Fjava%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e165c53deb61806019c4a72f006abaa1c2379b3/gcc%2Fjava%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.h?ref=2e165c53deb61806019c4a72f006abaa1c2379b3", "patch": "@@ -128,6 +128,20 @@ typedef struct java_lexer\n   /* Index of last valid character in buffer, plus one.  -1 if no\n      valid characters in buffer.  */\n   int last;\n+\n+  /* This is a buffer of characters already converted by iconv.  We\n+     use `char' here because we're assuming that iconv() converts to\n+     big-endian UCS-2, and then we convert it ourselves.  */\n+  char out_buffer[1024];\n+\n+  /* Index of first valid output character.  -1 if no valid\n+     characters.  */\n+  int out_first;\n+\n+  /* Index of last valid output character, plus one.  -1 if no valid\n+     characters.  */\n+  int out_last;\n+\n #endif /* HAVE_ICONV */\n } java_lexer;\n "}]}