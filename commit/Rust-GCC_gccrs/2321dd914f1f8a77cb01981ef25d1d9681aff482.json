{"sha": "2321dd914f1f8a77cb01981ef25d1d9681aff482", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjMyMWRkOTE0ZjFmOGE3N2NiMDE5ODFlZjI1ZDFkOTY4MWFmZjQ4Mg==", "commit": {"author": {"name": "Mikhail Maltsev", "email": "maltsevm@gmail.com", "date": "2015-08-22T03:20:13Z"}, "committer": {"name": "Mikhail Maltsev", "email": "miyuki@gcc.gnu.org", "date": "2015-08-22T03:20:13Z"}, "message": "Refactor dominance.c: define dom_info as C++ class\n\ngcc/\n\t* dominance.c (new_zero_array): Define.\n\t(dom_info): Redefine as class with proper encapsulation.\n\t(dom_info::m_n_basic_blocks, m_reverse, m_start_block, m_end_block):\n\tAdd new members.\n\t(dom_info::dom_info, ~dom_info): Define.  Use new/delete for memory\n\tallocations/deallocations.  Pass function as parameter (instead of\n\tusing cfun).\n\t(dom_info::get_idom): Define accessor method.\n\t(dom_info::calc_dfs_tree_nonrec, calc_dfs_tree, compress, eval,\n\tlink_roots, calc_idoms): Redefine as class members.  Do not use cfun.\n\t(calculate_dominance_info): Adjust to use dom_info class.\n\t(verify_dominators): Likewise.\n\nFrom-SVN: r227093", "tree": {"sha": "9f36c7ba32ec138d38747595ad4fbc7e565e0d8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f36c7ba32ec138d38747595ad4fbc7e565e0d8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2321dd914f1f8a77cb01981ef25d1d9681aff482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2321dd914f1f8a77cb01981ef25d1d9681aff482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2321dd914f1f8a77cb01981ef25d1d9681aff482", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2321dd914f1f8a77cb01981ef25d1d9681aff482/comments", "author": {"login": "miyuki", "id": 4668268, "node_id": "MDQ6VXNlcjQ2NjgyNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/4668268?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miyuki", "html_url": "https://github.com/miyuki", "followers_url": "https://api.github.com/users/miyuki/followers", "following_url": "https://api.github.com/users/miyuki/following{/other_user}", "gists_url": "https://api.github.com/users/miyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/miyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miyuki/subscriptions", "organizations_url": "https://api.github.com/users/miyuki/orgs", "repos_url": "https://api.github.com/users/miyuki/repos", "events_url": "https://api.github.com/users/miyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/miyuki/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "18e8c3cad5c822fc4fa3d5a1c91bf9be6c1458be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18e8c3cad5c822fc4fa3d5a1c91bf9be6c1458be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18e8c3cad5c822fc4fa3d5a1c91bf9be6c1458be"}], "stats": {"total": 580, "additions": 292, "deletions": 288}, "files": [{"sha": "71b37884d9eb3895a5860393df1f392db689872a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2321dd914f1f8a77cb01981ef25d1d9681aff482/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2321dd914f1f8a77cb01981ef25d1d9681aff482/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2321dd914f1f8a77cb01981ef25d1d9681aff482", "patch": "@@ -1,3 +1,18 @@\n+2015-08-22  Mikhail Maltsev <maltsevm@gmail.com>\n+\n+\t* dominance.c (new_zero_array): Define.\n+\t(dom_info): Redefine as class with proper encapsulation.\n+\t(dom_info::m_n_basic_blocks, m_reverse, m_start_block, m_end_block):\n+\tAdd new members.\n+\t(dom_info::dom_info, ~dom_info): Define.  Use new/delete for memory\n+\tallocations/deallocations.  Pass function as parameter (instead of\n+\tusing cfun).\n+\t(dom_info::get_idom): Define accessor method.\n+\t(dom_info::calc_dfs_tree_nonrec, calc_dfs_tree, compress, eval,\n+\tlink_roots, calc_idoms): Redefine as class members.  Do not use cfun.\n+\t(calculate_dominance_info): Adjust to use dom_info class.\n+\t(verify_dominators): Likewise.\n+\n 2015-08-21  Alexandre Oliva <aoliva@redhat.com>\n \n \t* print-rtl.c (print_rtx): Check the correct range for"}, {"sha": "09645be1a6152fa091650c8df6a211bf50344b65", "filename": "gcc/dominance.c", "status": "modified", "additions": 277, "deletions": 288, "changes": 565, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2321dd914f1f8a77cb01981ef25d1d9681aff482/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2321dd914f1f8a77cb01981ef25d1d9681aff482/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=2321dd914f1f8a77cb01981ef25d1d9681aff482", "patch": "@@ -53,222 +53,234 @@\n /* Type of Basic Block aka. TBB */\n typedef unsigned int TBB;\n \n-/* We work in a poor-mans object oriented fashion, and carry an instance of\n-   this structure through all our 'methods'.  It holds various arrays\n-   reflecting the (sub)structure of the flowgraph.  Most of them are of type\n-   TBB and are also indexed by TBB.  */\n+namespace {\n \n-struct dom_info\n+/* This class holds various arrays reflecting the (sub)structure of the\n+   flowgraph.  Most of them are of type TBB and are also indexed by TBB.  */\n+\n+class dom_info\n {\n+public:\n+  dom_info (function *, cdi_direction);\n+  ~dom_info ();\n+  void calc_dfs_tree ();\n+  void calc_idoms ();\n+\n+  inline basic_block get_idom (basic_block);\n+private:\n+  void calc_dfs_tree_nonrec (basic_block);\n+  void compress (TBB);\n+  TBB eval (TBB);\n+  void link_roots (TBB, TBB);\n+\n   /* The parent of a node in the DFS tree.  */\n-  TBB *dfs_parent;\n-  /* For a node x key[x] is roughly the node nearest to the root from which\n+  TBB *m_dfs_parent;\n+  /* For a node x m_key[x] is roughly the node nearest to the root from which\n      exists a way to x only over nodes behind x.  Such a node is also called\n      semidominator.  */\n-  TBB *key;\n-  /* The value in path_min[x] is the node y on the path from x to the root of\n-     the tree x is in with the smallest key[y].  */\n-  TBB *path_min;\n-  /* bucket[x] points to the first node of the set of nodes having x as key.  */\n-  TBB *bucket;\n-  /* And next_bucket[x] points to the next node.  */\n-  TBB *next_bucket;\n-  /* After the algorithm is done, dom[x] contains the immediate dominator\n+  TBB *m_key;\n+  /* The value in m_path_min[x] is the node y on the path from x to the root of\n+     the tree x is in with the smallest m_key[y].  */\n+  TBB *m_path_min;\n+  /* m_bucket[x] points to the first node of the set of nodes having x as\n+     key.  */\n+  TBB *m_bucket;\n+  /* And m_next_bucket[x] points to the next node.  */\n+  TBB *m_next_bucket;\n+  /* After the algorithm is done, m_dom[x] contains the immediate dominator\n      of x.  */\n-  TBB *dom;\n+  TBB *m_dom;\n \n   /* The following few fields implement the structures needed for disjoint\n      sets.  */\n-  /* set_chain[x] is the next node on the path from x to the representative\n-     of the set containing x.  If set_chain[x]==0 then x is a root.  */\n-  TBB *set_chain;\n-  /* set_size[x] is the number of elements in the set named by x.  */\n-  unsigned int *set_size;\n-  /* set_child[x] is used for balancing the tree representing a set.  It can\n+  /* m_set_chain[x] is the next node on the path from x to the representative\n+     of the set containing x.  If m_set_chain[x]==0 then x is a root.  */\n+  TBB *m_set_chain;\n+  /* m_set_size[x] is the number of elements in the set named by x.  */\n+  unsigned int *m_set_size;\n+  /* m_set_child[x] is used for balancing the tree representing a set.  It can\n      be understood as the next sibling of x.  */\n-  TBB *set_child;\n+  TBB *m_set_child;\n \n-  /* If b is the number of a basic block (BB->index), dfs_order[b] is the\n+  /* If b is the number of a basic block (BB->index), m_dfs_order[b] is the\n      number of that node in DFS order counted from 1.  This is an index\n      into most of the other arrays in this structure.  */\n-  TBB *dfs_order;\n+  TBB *m_dfs_order;\n+  /* Points to last element in m_dfs_order array.  */\n+  TBB *m_dfs_last;\n   /* If x is the DFS-index of a node which corresponds with a basic block,\n-     dfs_to_bb[x] is that basic block.  Note, that in our structure there are\n-     more nodes that basic blocks, so only dfs_to_bb[dfs_order[bb->index]]==bb\n-     is true for every basic block bb, but not the opposite.  */\n-  basic_block *dfs_to_bb;\n+     m_dfs_to_bb[x] is that basic block.  Note, that in our structure there are\n+     more nodes that basic blocks, so only\n+     m_dfs_to_bb[m_dfs_order[bb->index]]==bb is true for every basic block bb,\n+     but not the opposite.  */\n+  basic_block *m_dfs_to_bb;\n \n   /* This is the next free DFS number when creating the DFS tree.  */\n-  unsigned int dfsnum;\n-  /* The number of nodes in the DFS tree (==dfsnum-1).  */\n-  unsigned int nodes;\n+  unsigned int m_dfsnum;\n+  /* The number of nodes in the DFS tree (==m_dfsnum-1).  */\n+  unsigned int m_nodes;\n \n   /* Blocks with bits set here have a fake edge to EXIT.  These are used\n      to turn a DFS forest into a proper tree.  */\n-  bitmap fake_exit_edge;\n+  bitmap m_fake_exit_edge;\n+\n+  /* Number of basic blocks in the function being compiled.  */\n+  size_t m_n_basic_blocks;\n+\n+  /* True, if we are computing postdominators (rather than dominators).  */\n+  bool m_reverse;\n+\n+  /* Start block (the entry block for forward problem, exit block for backward\n+     problem).  */\n+  basic_block m_start_block;\n+  /* Ending block.  */\n+  basic_block m_end_block;\n };\n \n-static void init_dom_info (struct dom_info *, enum cdi_direction);\n-static void free_dom_info (struct dom_info *);\n-static void calc_dfs_tree_nonrec (struct dom_info *, basic_block, bool);\n-static void calc_dfs_tree (struct dom_info *, bool);\n-static void compress (struct dom_info *, TBB);\n-static TBB eval (struct dom_info *, TBB);\n-static void link_roots (struct dom_info *, TBB, TBB);\n-static void calc_idoms (struct dom_info *, bool);\n-void debug_dominance_info (enum cdi_direction);\n-void debug_dominance_tree (enum cdi_direction, basic_block);\n-\n-/* Helper macro for allocating and initializing an array,\n-   for aesthetic reasons.  */\n-#define init_ar(var, type, num, content)\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      unsigned int i = 1;    /* Catch content == i.  */\t\t\\\n-      if (! (content))\t\t\t\t\t\t\\\n-\t(var) = XCNEWVEC (type, num);\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  (var) = XNEWVEC (type, (num));\t\t\t\\\n-\t  for (i = 0; i < num; i++)\t\t\t\t\\\n-\t    (var)[i] = (content);\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Allocate all needed memory in a pessimistic fashion (so we round up).\n-   This initializes the contents of DI, which already must be allocated.  */\n+} // anonymous namespace\n \n-static void\n-init_dom_info (struct dom_info *di, enum cdi_direction dir)\n+void debug_dominance_info (cdi_direction);\n+void debug_dominance_tree (cdi_direction, basic_block);\n+\n+/* Allocate and zero-initialize NUM elements of type T (T must be a\n+   POD-type).  Note: after transition to C++11 or later,\n+   `x = new_zero_array <T> (num);' can be replaced with\n+   `x = new T[num] {};'.  */\n+\n+template<typename T>\n+inline T *new_zero_array (size_t num)\n+{\n+  T *result = new T[num];\n+  memset (result, 0, sizeof (T) * num);\n+  return result;\n+}\n+\n+/* Allocate all needed memory in a pessimistic fashion (so we round up).  */\n+\n+dom_info::dom_info (function *fn, cdi_direction dir)\n {\n   /* We need memory for n_basic_blocks nodes.  */\n-  unsigned int num = n_basic_blocks_for_fn (cfun);\n-  init_ar (di->dfs_parent, TBB, num, 0);\n-  init_ar (di->path_min, TBB, num, i);\n-  init_ar (di->key, TBB, num, i);\n-  init_ar (di->dom, TBB, num, 0);\n+  size_t num = m_n_basic_blocks = n_basic_blocks_for_fn (fn);\n+  m_dfs_parent = new_zero_array <TBB> (num);\n+  m_dom = new_zero_array <TBB> (num);\n+\n+  m_path_min = new TBB[num];\n+  m_key = new TBB[num];\n+  m_set_size = new unsigned int[num];\n+  for (size_t i = 0; i < num; i++)\n+    {\n+      m_path_min[i] = m_key[i] = i;\n+      m_set_size[i] = 1;\n+    }\n \n-  init_ar (di->bucket, TBB, num, 0);\n-  init_ar (di->next_bucket, TBB, num, 0);\n+  m_bucket = new_zero_array <TBB> (num);\n+  m_next_bucket = new_zero_array <TBB> (num);\n \n-  init_ar (di->set_chain, TBB, num, 0);\n-  init_ar (di->set_size, unsigned int, num, 1);\n-  init_ar (di->set_child, TBB, num, 0);\n+  m_set_chain = new_zero_array <TBB> (num);\n+  m_set_child = new_zero_array <TBB> (num);\n \n-  init_ar (di->dfs_order, TBB,\n-\t   (unsigned int) last_basic_block_for_fn (cfun) + 1, 0);\n-  init_ar (di->dfs_to_bb, basic_block, num, 0);\n+  unsigned last_bb_index = last_basic_block_for_fn (fn);\n+  m_dfs_order = new_zero_array <TBB> (last_bb_index + 1);\n+  m_dfs_last = &m_dfs_order[last_bb_index];\n+  m_dfs_to_bb = new_zero_array <basic_block> (num);\n \n-  di->dfsnum = 1;\n-  di->nodes = 0;\n+  m_dfsnum = 1;\n+  m_nodes = 0;\n \n   switch (dir)\n     {\n       case CDI_DOMINATORS:\n-\tdi->fake_exit_edge = NULL;\n+\tm_reverse = false;\n+\tm_fake_exit_edge = NULL;\n+\tm_start_block = ENTRY_BLOCK_PTR_FOR_FN (fn);\n+\tm_end_block = EXIT_BLOCK_PTR_FOR_FN (fn);\n \tbreak;\n       case CDI_POST_DOMINATORS:\n-\tdi->fake_exit_edge = BITMAP_ALLOC (NULL);\n+\tm_reverse = true;\n+\tm_fake_exit_edge = BITMAP_ALLOC (NULL);\n+\tm_start_block = EXIT_BLOCK_PTR_FOR_FN (fn);\n+\tm_end_block = ENTRY_BLOCK_PTR_FOR_FN (fn);\n \tbreak;\n       default:\n \tgcc_unreachable ();\n-\tbreak;\n     }\n }\n \n-#undef init_ar\n+inline basic_block\n+dom_info::get_idom (basic_block bb)\n+{\n+  TBB d = m_dom[m_dfs_order[bb->index]];\n+  return m_dfs_to_bb[d];\n+}\n \n /* Map dominance calculation type to array index used for various\n    dominance information arrays.  This version is simple -- it will need\n    to be modified, obviously, if additional values are added to\n    cdi_direction.  */\n \n-static unsigned int\n-dom_convert_dir_to_idx (enum cdi_direction dir)\n+static inline unsigned int\n+dom_convert_dir_to_idx (cdi_direction dir)\n {\n   gcc_checking_assert (dir == CDI_DOMINATORS || dir == CDI_POST_DOMINATORS);\n   return dir - 1;\n }\n \n-/* Free all allocated memory in DI, but not DI itself.  */\n+/* Free all allocated memory in dom_info.  */\n \n-static void\n-free_dom_info (struct dom_info *di)\n+dom_info::~dom_info ()\n {\n-  free (di->dfs_parent);\n-  free (di->path_min);\n-  free (di->key);\n-  free (di->dom);\n-  free (di->bucket);\n-  free (di->next_bucket);\n-  free (di->set_chain);\n-  free (di->set_size);\n-  free (di->set_child);\n-  free (di->dfs_order);\n-  free (di->dfs_to_bb);\n-  BITMAP_FREE (di->fake_exit_edge);\n+  delete[] m_dfs_parent;\n+  delete[] m_path_min;\n+  delete[] m_key;\n+  delete[] m_dom;\n+  delete[] m_bucket;\n+  delete[] m_next_bucket;\n+  delete[] m_set_chain;\n+  delete[] m_set_size;\n+  delete[] m_set_child;\n+  delete[] m_dfs_order;\n+  delete[] m_dfs_to_bb;\n+  BITMAP_FREE (m_fake_exit_edge);\n }\n \n-/* The nonrecursive variant of creating a DFS tree.  DI is our working\n-   structure, BB the starting basic block for this tree and REVERSE\n-   is true, if predecessors should be visited instead of successors of a\n-   node.  After this is done all nodes reachable from BB were visited, have\n-   assigned their dfs number and are linked together to form a tree.  */\n+/* The nonrecursive variant of creating a DFS tree.  BB is the starting basic\n+   block for this tree and m_reverse is true, if predecessors should be visited\n+   instead of successors of a node.  After this is done all nodes reachable\n+   from BB were visited, have assigned their dfs number and are linked together\n+   to form a tree.  */\n \n-static void\n-calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb, bool reverse)\n+void\n+dom_info::calc_dfs_tree_nonrec (basic_block bb)\n {\n-  /* We call this _only_ if bb is not already visited.  */\n-  edge e;\n-  TBB child_i, my_i = 0;\n-  edge_iterator *stack;\n-  edge_iterator ei, einext;\n-  int sp;\n-  /* Start block (the entry block for forward problem, exit block for backward\n-     problem).  */\n-  basic_block en_block;\n-  /* Ending block.  */\n-  basic_block ex_block;\n-\n-  stack = XNEWVEC (edge_iterator, n_basic_blocks_for_fn (cfun) + 1);\n-  sp = 0;\n+  edge_iterator *stack = new edge_iterator[m_n_basic_blocks + 1];\n+  int sp = 0;\n \n-  /* Initialize our border blocks, and the first edge.  */\n-  if (reverse)\n-    {\n-      ei = ei_start (bb->preds);\n-      en_block = EXIT_BLOCK_PTR_FOR_FN (cfun);\n-      ex_block = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n-    }\n-  else\n-    {\n-      ei = ei_start (bb->succs);\n-      en_block = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n-      ex_block = EXIT_BLOCK_PTR_FOR_FN (cfun);\n-    }\n+  /* Initialize the first edge.  */\n+  edge_iterator ei = m_reverse ? ei_start (bb->preds)\n+\t\t\t       : ei_start (bb->succs);\n \n   /* When the stack is empty we break out of this loop.  */\n   while (1)\n     {\n       basic_block bn;\n+      edge_iterator einext;\n \n       /* This loop traverses edges e in depth first manner, and fills the\n          stack.  */\n       while (!ei_end_p (ei))\n \t{\n-\t  e = ei_edge (ei);\n+\t  edge e = ei_edge (ei);\n \n \t  /* Deduce from E the current and the next block (BB and BN), and the\n \t     next edge.  */\n-\t  if (reverse)\n+\t  if (m_reverse)\n \t    {\n \t      bn = e->src;\n \n \t      /* If the next node BN is either already visited or a border\n \t         block the current edge is useless, and simply overwritten\n \t         with the next edge out of the current node.  */\n-\t      if (bn == ex_block || di->dfs_order[bn->index])\n+\t      if (bn == m_end_block || m_dfs_order[bn->index])\n \t\t{\n \t\t  ei_next (&ei);\n \t\t  continue;\n@@ -279,7 +291,7 @@ calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb, bool reverse)\n \t  else\n \t    {\n \t      bn = e->dest;\n-\t      if (bn == ex_block || di->dfs_order[bn->index])\n+\t      if (bn == m_end_block || m_dfs_order[bn->index])\n \t\t{\n \t\t  ei_next (&ei);\n \t\t  continue;\n@@ -288,16 +300,17 @@ calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb, bool reverse)\n \t      einext = ei_start (bn->succs);\n \t    }\n \n-\t  gcc_assert (bn != en_block);\n+\t  gcc_assert (bn != m_start_block);\n \n \t  /* Fill the DFS tree info calculatable _before_ recursing.  */\n-\t  if (bb != en_block)\n-\t    my_i = di->dfs_order[bb->index];\n+\t  TBB my_i;\n+\t  if (bb != m_start_block)\n+\t    my_i = m_dfs_order[bb->index];\n \t  else\n-\t    my_i = di->dfs_order[last_basic_block_for_fn (cfun)];\n-\t  child_i = di->dfs_order[bn->index] = di->dfsnum++;\n-\t  di->dfs_to_bb[child_i] = bn;\n-\t  di->dfs_parent[child_i] = my_i;\n+\t    my_i = *m_dfs_last;\n+\t  TBB child_i = m_dfs_order[bn->index] = m_dfsnum++;\n+\t  m_dfs_to_bb[child_i] = bn;\n+\t  m_dfs_parent[child_i] = my_i;\n \n \t  /* Save the current point in the CFG on the stack, and recurse.  */\n \t  stack[sp++] = ei;\n@@ -319,27 +332,24 @@ calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb, bool reverse)\n          descendants or the tree depth.  */\n       ei_next (&ei);\n     }\n-  free (stack);\n+  delete[] stack;\n }\n \n-/* The main entry for calculating the DFS tree or forest.  DI is our working\n-   structure and REVERSE is true, if we are interested in the reverse flow\n-   graph.  In that case the result is not necessarily a tree but a forest,\n-   because there may be nodes from which the EXIT_BLOCK is unreachable.  */\n+/* The main entry for calculating the DFS tree or forest.  m_reverse is true,\n+   if we are interested in the reverse flow graph.  In that case the result is\n+   not necessarily a tree but a forest, because there may be nodes from which\n+   the EXIT_BLOCK is unreachable.  */\n \n-static void\n-calc_dfs_tree (struct dom_info *di, bool reverse)\n+void\n+dom_info::calc_dfs_tree ()\n {\n-  /* The first block is the ENTRY_BLOCK (or EXIT_BLOCK if REVERSE).  */\n-  basic_block begin = (reverse\n-\t\t       ? EXIT_BLOCK_PTR_FOR_FN (cfun) : ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-  di->dfs_order[last_basic_block_for_fn (cfun)] = di->dfsnum;\n-  di->dfs_to_bb[di->dfsnum] = begin;\n-  di->dfsnum++;\n+  *m_dfs_last = m_dfsnum;\n+  m_dfs_to_bb[m_dfsnum] = m_start_block;\n+  m_dfsnum++;\n \n-  calc_dfs_tree_nonrec (di, begin, reverse);\n+  calc_dfs_tree_nonrec (m_start_block);\n \n-  if (reverse)\n+  if (m_reverse)\n     {\n       /* In the post-dom case we may have nodes without a path to EXIT_BLOCK.\n          They are reverse-unreachable.  In the dom-case we disallow such\n@@ -354,170 +364,159 @@ calc_dfs_tree (struct dom_info *di, bool reverse)\n       basic_block b;\n       bool saw_unconnected = false;\n \n-      FOR_EACH_BB_REVERSE_FN (b, cfun)\n+      FOR_BB_BETWEEN (b, m_start_block->prev_bb, m_end_block, prev_bb)\n \t{\n \t  if (EDGE_COUNT (b->succs) > 0)\n \t    {\n-\t      if (di->dfs_order[b->index] == 0)\n+\t      if (m_dfs_order[b->index] == 0)\n \t\tsaw_unconnected = true;\n \t      continue;\n \t    }\n-\t  bitmap_set_bit (di->fake_exit_edge, b->index);\n-\t  di->dfs_order[b->index] = di->dfsnum;\n-\t  di->dfs_to_bb[di->dfsnum] = b;\n-\t  di->dfs_parent[di->dfsnum] =\n-\t    di->dfs_order[last_basic_block_for_fn (cfun)];\n-\t  di->dfsnum++;\n-\t  calc_dfs_tree_nonrec (di, b, reverse);\n+\t  bitmap_set_bit (m_fake_exit_edge, b->index);\n+\t  m_dfs_order[b->index] = m_dfsnum;\n+\t  m_dfs_to_bb[m_dfsnum] = b;\n+\t  m_dfs_parent[m_dfsnum] = *m_dfs_last;\n+\t  m_dfsnum++;\n+\t  calc_dfs_tree_nonrec (b);\n \t}\n \n       if (saw_unconnected)\n \t{\n-\t  FOR_EACH_BB_REVERSE_FN (b, cfun)\n+\t  FOR_BB_BETWEEN (b, m_start_block->prev_bb, m_end_block, prev_bb)\n \t    {\n-\t      basic_block b2;\n-\t      if (di->dfs_order[b->index])\n+\t      if (m_dfs_order[b->index])\n \t\tcontinue;\n-\t      b2 = dfs_find_deadend (b);\n-\t      gcc_checking_assert (di->dfs_order[b2->index] == 0);\n-\t      bitmap_set_bit (di->fake_exit_edge, b2->index);\n-\t      di->dfs_order[b2->index] = di->dfsnum;\n-\t      di->dfs_to_bb[di->dfsnum] = b2;\n-\t      di->dfs_parent[di->dfsnum] =\n-\t\tdi->dfs_order[last_basic_block_for_fn (cfun)];\n-\t      di->dfsnum++;\n-\t      calc_dfs_tree_nonrec (di, b2, reverse);\n-\t      gcc_checking_assert (di->dfs_order[b->index]);\n+\t      basic_block b2 = dfs_find_deadend (b);\n+\t      gcc_checking_assert (m_dfs_order[b2->index] == 0);\n+\t      bitmap_set_bit (m_fake_exit_edge, b2->index);\n+\t      m_dfs_order[b2->index] = m_dfsnum;\n+\t      m_dfs_to_bb[m_dfsnum] = b2;\n+\t      m_dfs_parent[m_dfsnum] = *m_dfs_last;\n+\t      m_dfsnum++;\n+\t      calc_dfs_tree_nonrec (b2);\n+\t      gcc_checking_assert (m_dfs_order[b->index]);\n \t    }\n \t}\n     }\n \n-  di->nodes = di->dfsnum - 1;\n+  m_nodes = m_dfsnum - 1;\n \n   /* This aborts e.g. when there is _no_ path from ENTRY to EXIT at all.  */\n-  gcc_assert (di->nodes == (unsigned int) n_basic_blocks_for_fn (cfun) - 1);\n+  gcc_assert (m_nodes == (unsigned int) m_n_basic_blocks - 1);\n }\n \n /* Compress the path from V to the root of its set and update path_min at the\n    same time.  After compress(di, V) set_chain[V] is the root of the set V is\n    in and path_min[V] is the node with the smallest key[] value on the path\n    from V to that root.  */\n \n-static void\n-compress (struct dom_info *di, TBB v)\n+void\n+dom_info::compress (TBB v)\n {\n   /* Btw. It's not worth to unrecurse compress() as the depth is usually not\n      greater than 5 even for huge graphs (I've not seen call depth > 4).\n      Also performance wise compress() ranges _far_ behind eval().  */\n-  TBB parent = di->set_chain[v];\n-  if (di->set_chain[parent])\n+  TBB parent = m_set_chain[v];\n+  if (m_set_chain[parent])\n     {\n-      compress (di, parent);\n-      if (di->key[di->path_min[parent]] < di->key[di->path_min[v]])\n-\tdi->path_min[v] = di->path_min[parent];\n-      di->set_chain[v] = di->set_chain[parent];\n+      compress (parent);\n+      if (m_key[m_path_min[parent]] < m_key[m_path_min[v]])\n+\tm_path_min[v] = m_path_min[parent];\n+      m_set_chain[v] = m_set_chain[parent];\n     }\n }\n \n /* Compress the path from V to the set root of V if needed (when the root has\n    changed since the last call).  Returns the node with the smallest key[]\n    value on the path from V to the root.  */\n \n-static inline TBB\n-eval (struct dom_info *di, TBB v)\n+inline TBB\n+dom_info::eval (TBB v)\n {\n   /* The representative of the set V is in, also called root (as the set\n      representation is a tree).  */\n-  TBB rep = di->set_chain[v];\n+  TBB rep = m_set_chain[v];\n \n   /* V itself is the root.  */\n   if (!rep)\n-    return di->path_min[v];\n+    return m_path_min[v];\n \n   /* Compress only if necessary.  */\n-  if (di->set_chain[rep])\n+  if (m_set_chain[rep])\n     {\n-      compress (di, v);\n-      rep = di->set_chain[v];\n+      compress (v);\n+      rep = m_set_chain[v];\n     }\n \n-  if (di->key[di->path_min[rep]] >= di->key[di->path_min[v]])\n-    return di->path_min[v];\n+  if (m_key[m_path_min[rep]] >= m_key[m_path_min[v]])\n+    return m_path_min[v];\n   else\n-    return di->path_min[rep];\n+    return m_path_min[rep];\n }\n \n /* This essentially merges the two sets of V and W, giving a single set with\n    the new root V.  The internal representation of these disjoint sets is a\n    balanced tree.  Currently link(V,W) is only used with V being the parent\n    of W.  */\n \n-static void\n-link_roots (struct dom_info *di, TBB v, TBB w)\n+void\n+dom_info::link_roots (TBB v, TBB w)\n {\n   TBB s = w;\n \n   /* Rebalance the tree.  */\n-  while (di->key[di->path_min[w]] < di->key[di->path_min[di->set_child[s]]])\n+  while (m_key[m_path_min[w]] < m_key[m_path_min[m_set_child[s]]])\n     {\n-      if (di->set_size[s] + di->set_size[di->set_child[di->set_child[s]]]\n-\t  >= 2 * di->set_size[di->set_child[s]])\n+      if (m_set_size[s] + m_set_size[m_set_child[m_set_child[s]]]\n+\t  >= 2 * m_set_size[m_set_child[s]])\n \t{\n-\t  di->set_chain[di->set_child[s]] = s;\n-\t  di->set_child[s] = di->set_child[di->set_child[s]];\n+\t  m_set_chain[m_set_child[s]] = s;\n+\t  m_set_child[s] = m_set_child[m_set_child[s]];\n \t}\n       else\n \t{\n-\t  di->set_size[di->set_child[s]] = di->set_size[s];\n-\t  s = di->set_chain[s] = di->set_child[s];\n+\t  m_set_size[m_set_child[s]] = m_set_size[s];\n+\t  s = m_set_chain[s] = m_set_child[s];\n \t}\n     }\n \n-  di->path_min[s] = di->path_min[w];\n-  di->set_size[v] += di->set_size[w];\n-  if (di->set_size[v] < 2 * di->set_size[w])\n-    std::swap (di->set_child[v], s);\n+  m_path_min[s] = m_path_min[w];\n+  m_set_size[v] += m_set_size[w];\n+  if (m_set_size[v] < 2 * m_set_size[w])\n+    std::swap (m_set_child[v], s);\n \n   /* Merge all subtrees.  */\n   while (s)\n     {\n-      di->set_chain[s] = v;\n-      s = di->set_child[s];\n+      m_set_chain[s] = v;\n+      s = m_set_child[s];\n     }\n }\n \n-/* This calculates the immediate dominators (or post-dominators if REVERSE is\n-   true).  DI is our working structure and should hold the DFS forest.\n-   On return the immediate dominator to node V is in di->dom[V].  */\n+/* This calculates the immediate dominators (or post-dominators). THIS is our\n+   working structure and should hold the DFS forest.\n+   On return the immediate dominator to node V is in m_dom[V].  */\n \n-static void\n-calc_idoms (struct dom_info *di, bool reverse)\n+void\n+dom_info::calc_idoms ()\n {\n-  TBB v, w, k, par;\n-  basic_block en_block;\n-  edge_iterator ei, einext;\n-\n-  if (reverse)\n-    en_block = EXIT_BLOCK_PTR_FOR_FN (cfun);\n-  else\n-    en_block = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n-\n   /* Go backwards in DFS order, to first look at the leafs.  */\n-  v = di->nodes;\n-  while (v > 1)\n+  for (TBB v = m_nodes; v > 1; v--)\n     {\n-      basic_block bb = di->dfs_to_bb[v];\n+      basic_block bb = m_dfs_to_bb[v];\n       edge e;\n \n-      par = di->dfs_parent[v];\n-      k = v;\n+      TBB par = m_dfs_parent[v];\n+      TBB k = v;\n \n-      ei = (reverse) ? ei_start (bb->succs) : ei_start (bb->preds);\n+      edge_iterator ei = m_reverse ? ei_start (bb->succs)\n+\t\t\t\t   : ei_start (bb->preds);\n+      edge_iterator einext;\n \n-      if (reverse)\n+      if (m_reverse)\n \t{\n \t  /* If this block has a fake edge to exit, process that first.  */\n-\t  if (bitmap_bit_p (di->fake_exit_edge, bb->index))\n+\t  if (bitmap_bit_p (m_fake_exit_edge, bb->index))\n \t    {\n \t      einext = ei;\n \t      einext.index = 0;\n@@ -531,56 +530,55 @@ calc_idoms (struct dom_info *di, bool reverse)\n          semidominator.  */\n       while (!ei_end_p (ei))\n \t{\n-\t  TBB k1;\n \t  basic_block b;\n+\t  TBB k1;\n \n \t  e = ei_edge (ei);\n-\t  b = (reverse) ? e->dest : e->src;\n+\t  b = m_reverse ? e->dest : e->src;\n \t  einext = ei;\n \t  ei_next (&einext);\n \n-\t  if (b == en_block)\n+\t  if (b == m_start_block)\n \t    {\n \t    do_fake_exit_edge:\n-\t      k1 = di->dfs_order[last_basic_block_for_fn (cfun)];\n+\t      k1 = *m_dfs_last;\n \t    }\n \t  else\n-\t    k1 = di->dfs_order[b->index];\n+\t    k1 = m_dfs_order[b->index];\n \n \t  /* Call eval() only if really needed.  If k1 is above V in DFS tree,\n \t     then we know, that eval(k1) == k1 and key[k1] == k1.  */\n \t  if (k1 > v)\n-\t    k1 = di->key[eval (di, k1)];\n+\t    k1 = m_key[eval (k1)];\n \t  if (k1 < k)\n \t    k = k1;\n \n \t  ei = einext;\n \t}\n \n-      di->key[v] = k;\n-      link_roots (di, par, v);\n-      di->next_bucket[v] = di->bucket[k];\n-      di->bucket[k] = v;\n+      m_key[v] = k;\n+      link_roots (par, v);\n+      m_next_bucket[v] = m_bucket[k];\n+      m_bucket[k] = v;\n \n       /* Transform semidominators into dominators.  */\n-      for (w = di->bucket[par]; w; w = di->next_bucket[w])\n+      for (TBB w = m_bucket[par]; w; w = m_next_bucket[w])\n \t{\n-\t  k = eval (di, w);\n-\t  if (di->key[k] < di->key[w])\n-\t    di->dom[w] = k;\n+\t  k = eval (w);\n+\t  if (m_key[k] < m_key[w])\n+\t    m_dom[w] = k;\n \t  else\n-\t    di->dom[w] = par;\n+\t    m_dom[w] = par;\n \t}\n       /* We don't need to cleanup next_bucket[].  */\n-      di->bucket[par] = 0;\n-      v--;\n+      m_bucket[par] = 0;\n     }\n \n   /* Explicitly define the dominators.  */\n-  di->dom[1] = 0;\n-  for (v = 2; v <= di->nodes; v++)\n-    if (di->dom[v] != di->key[v])\n-      di->dom[v] = di->dom[di->dom[v]];\n+  m_dom[1] = 0;\n+  for (TBB v = 2; v <= m_nodes; v++)\n+    if (m_dom[v] != m_key[v])\n+      m_dom[v] = m_dom[m_dom[v]];\n }\n \n /* Assign dfs numbers starting from NUM to NODE and its sons.  */\n@@ -630,12 +628,9 @@ compute_dom_fast_query (enum cdi_direction dir)\n    we want to compute dominators or postdominators.  */\n \n void\n-calculate_dominance_info (enum cdi_direction dir)\n+calculate_dominance_info (cdi_direction dir)\n {\n-  struct dom_info di;\n-  basic_block b;\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n-  bool reverse = (dir == CDI_POST_DOMINATORS) ? true : false;\n \n   if (dom_computed[dir_index] == DOM_OK)\n     {\n@@ -650,25 +645,23 @@ calculate_dominance_info (enum cdi_direction dir)\n     {\n       gcc_assert (!n_bbs_in_dom_tree[dir_index]);\n \n+      basic_block b;\n       FOR_ALL_BB_FN (b, cfun)\n \t{\n \t  b->dom[dir_index] = et_new_tree (b);\n \t}\n       n_bbs_in_dom_tree[dir_index] = n_basic_blocks_for_fn (cfun);\n \n-      init_dom_info (&di, dir);\n-      calc_dfs_tree (&di, reverse);\n-      calc_idoms (&di, reverse);\n+      dom_info di (cfun, dir);\n+      di.calc_dfs_tree ();\n+      di.calc_idoms ();\n \n       FOR_EACH_BB_FN (b, cfun)\n \t{\n-\t  TBB d = di.dom[di.dfs_order[b->index]];\n-\n-\t  if (di.dfs_to_bb[d])\n-\t    et_set_father (b->dom[dir_index], di.dfs_to_bb[d]->dom[dir_index]);\n+\t  if (basic_block d = di.get_idom (b))\n+\t    et_set_father (b->dom[dir_index], d->dom[dir_index]);\n \t}\n \n-      free_dom_info (&di);\n       dom_computed[dir_index] = DOM_NO_FAST_QUERY;\n     }\n   else\n@@ -1022,38 +1015,34 @@ bb_dom_dfs_out (enum cdi_direction dir, basic_block bb)\n \n /* Verify invariants of dominator structure.  */\n DEBUG_FUNCTION void\n-verify_dominators (enum cdi_direction dir)\n+verify_dominators (cdi_direction dir)\n {\n-  int err = 0;\n-  basic_block bb, imm_bb, imm_bb_correct;\n-  struct dom_info di;\n-  bool reverse = (dir == CDI_POST_DOMINATORS) ? true : false;\n-\n   gcc_assert (dom_info_available_p (dir));\n \n-  init_dom_info (&di, dir);\n-  calc_dfs_tree (&di, reverse);\n-  calc_idoms (&di, reverse);\n+  dom_info di (cfun, dir);\n+  di.calc_dfs_tree ();\n+  di.calc_idoms ();\n \n+  bool err = false;\n+  basic_block bb;\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      imm_bb = get_immediate_dominator (dir, bb);\n+      basic_block imm_bb = get_immediate_dominator (dir, bb);\n       if (!imm_bb)\n \t{\n \t  error (\"dominator of %d status unknown\", bb->index);\n-\t  err = 1;\n+\t  err = true;\n \t}\n \n-      imm_bb_correct = di.dfs_to_bb[di.dom[di.dfs_order[bb->index]]];\n+      basic_block imm_bb_correct = di.get_idom (bb);\n       if (imm_bb != imm_bb_correct)\n \t{\n \t  error (\"dominator of %d should be %d, not %d\",\n \t\t bb->index, imm_bb_correct->index, imm_bb->index);\n-\t  err = 1;\n+\t  err = true;\n \t}\n     }\n \n-  free_dom_info (&di);\n   gcc_assert (!err);\n }\n "}]}