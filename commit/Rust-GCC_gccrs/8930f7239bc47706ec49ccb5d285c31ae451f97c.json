{"sha": "8930f7239bc47706ec49ccb5d285c31ae451f97c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkzMGY3MjM5YmM0NzcwNmVjNDljY2I1ZDI4NWMzMWFlNDUxZjk3Yw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-03-04T10:06:22Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-03-04T10:06:22Z"}, "message": "re PR middle-end/56461 (GCC is leaking lots of memory)\n\n\tPR middle-end/56461\n\t* tree-vect-stmts.c (vectorizable_shift): Don't call create methods\n\ton vec_oprnds0 or vec_oprnds1 before loop, only call it on\n\tvec_oprnds1 right before pushing anything to it for\n\tscalar_shift_arg.\n\nFrom-SVN: r196425", "tree": {"sha": "bb7c32bb2703fb371b776ebbc9773689575bb5c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb7c32bb2703fb371b776ebbc9773689575bb5c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8930f7239bc47706ec49ccb5d285c31ae451f97c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8930f7239bc47706ec49ccb5d285c31ae451f97c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8930f7239bc47706ec49ccb5d285c31ae451f97c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8930f7239bc47706ec49ccb5d285c31ae451f97c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "541d9ac892f3dcfbff8d2fb8b00b89e95bb75d1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/541d9ac892f3dcfbff8d2fb8b00b89e95bb75d1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/541d9ac892f3dcfbff8d2fb8b00b89e95bb75d1c"}], "stats": {"total": 37, "additions": 15, "deletions": 22}, "files": [{"sha": "7e75abaa7fcfc00533304a94699f318fbc956705", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8930f7239bc47706ec49ccb5d285c31ae451f97c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8930f7239bc47706ec49ccb5d285c31ae451f97c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8930f7239bc47706ec49ccb5d285c31ae451f97c", "patch": "@@ -1,5 +1,11 @@\n 2013-03-04  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/56461\n+\t* tree-vect-stmts.c (vectorizable_shift): Don't call create methods\n+\ton vec_oprnds0 or vec_oprnds1 before loop, only call it on\n+\tvec_oprnds1 right before pushing anything to it for\n+\tscalar_shift_arg.\n+\n \tPR middle-end/56461\n \t* tree-vect-loop.c (destroy_loop_vec_info): For !clean_stmts, just\n \tset nbbs to 0 instead of having separate code path.\n@@ -16,16 +22,17 @@\n \tTARGET_OPTION_PRAGMA_PARSE.  Also copy-edit and correct markup.\n \t* doc/tm.texi: Regenerated.\n \n-2013-03-02  David Holsgrove <david.holsgrove@xilinx.com>\n+2013-03-02  David Holsgrove  <david.holsgrove@xilinx.com>\n \n-\t*  config/microblaze/microblaze.c:\n+\t* config/microblaze/microblaze.c:\n \tCheck mcpu, pcmp requirement and set TARGET_REORDER to 0 if not met.\n-\t*  config/microblaze/microblaze.h: Add -mxl-reorder to DRIVER_SELF_SPECS\n-\t*  config/microblaze/microblaze.md: New bswapsi2 and bswaphi2\n-\tinstructions emitted if TARGET_REORDER\n-\t*  config/microblaze/microblaze.opt: New option -mxl-reorder set to 1 \n+\t* config/microblaze/microblaze.h: Add -mxl-reorder to\n+\tDRIVER_SELF_SPECS.\n+\t* config/microblaze/microblaze.md: New bswapsi2 and bswaphi2.\n+\tinstructions emitted if TARGET_REORDER.\n+\t* config/microblaze/microblaze.opt: New option -mxl-reorder set to 1 \n \tor 0 for -m/-mno case, but initialises as 2 to detect default use case \n-\tseparately\n+\tseparately.\n \n 2013-03-01  Xinliang David Li  <davidxl@google.com>\n "}, {"sha": "927aa3d3839b0b708b3b96f606f303af19c1e2cf", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8930f7239bc47706ec49ccb5d285c31ae451f97c/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8930f7239bc47706ec49ccb5d285c31ae451f97c/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=8930f7239bc47706ec49ccb5d285c31ae451f97c", "patch": "@@ -3335,21 +3335,6 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n   /* Handle def.  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n-  /* Allocate VECs for vector operands.  In case of SLP, vector operands are\n-     created in the previous stages of the recursion, so no allocation is\n-     needed, except for the case of shift with scalar shift argument.  In that\n-     case we store the scalar operand in VEC_OPRNDS1 for every vector stmt to\n-     be created to vectorize the SLP group, i.e., SLP_NODE->VEC_STMTS_SIZE.\n-     In case of loop-based vectorization we allocate VECs of size 1.  We\n-     allocate VEC_OPRNDS1 only in case of binary operation.  */\n-  if (!slp_node)\n-    {\n-      vec_oprnds0.create (1);\n-      vec_oprnds1.create (1);\n-    }\n-  else if (scalar_shift_arg)\n-    vec_oprnds1.create (slp_node->vec_stmts_size);\n-\n   prev_stmt_info = NULL;\n   for (j = 0; j < ncopies; j++)\n     {\n@@ -3369,6 +3354,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n                     dump_printf_loc (MSG_NOTE, vect_location,\n                                      \"operand 1 using scalar mode.\");\n                   vec_oprnd1 = op1;\n+                  vec_oprnds1.create (slp_node ? slp_node->vec_stmts_size : 1);\n                   vec_oprnds1.quick_push (vec_oprnd1);\n                   if (slp_node)\n                     {"}]}