{"sha": "c6f971f453890cb1e617307073d08fbca7de37c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZmOTcxZjQ1Mzg5MGNiMWU2MTczMDcwNzNkMDhmYmNhN2RlMzdjNw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-25T18:18:01Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-25T18:18:01Z"}, "message": "config/mips: Use rtx_insn and rtx_code_label\n\ngcc/\n\t* config/mips/mips-protos.h (mips_emit_move): Strengthen return\n\ttype from rtx to rtx_insn *.\n\t(mips_expand_call): Likewise.\n\t(mips_adjust_insn_length): Likewise for first param.\n\t(mips_output_conditional_branch): Likewise.\n\t(mips_output_order_conditional_branch): Likewise.\n\t(mips_final_prescan_insn): Likewise.\n\n\t* config/mips/mips.c (SEQ_BEGIN): For now, add checked cast to\n\trtx_insn * for the SEQUENCE case.\n\t(SEQ_END): Likewise.\n\t(mips_emit_move): Strengthen return type from rtx to rtx_insn *.\n\t(mips_emit_call_insn): Likewise, also for local \"insn\".\n\t(mips16_gp_pseudo_reg): Likewise for local \"scan\".\n\t(mips16_build_call_stub): Likewise for return type and for local\n\t\"insn\".  Introduce a new local \"pattern\" so that \"insn\" can indeed\n\tbe an insn.\n\t(mips_expand_call): Strengthen return type and local \"insn\" from\n\trtx to rtx_insn *.\n\t(mips_block_move_loop): Strengthen local \"label\" from rtx to\n\trtx_code_label *.\n\t(mips_expand_synci_loop): Likewise for locals \"label\",\n\t\"end_label\".\n\t(mips_set_frame_expr): Strengthen local \"insn\" from rtx to\n\trtx_insn *.\n\t(mips16e_collect_argument_saves): Likewise for locals \"insn\",\n\t\"next\".\n\t(mips_find_gp_ref): Likewise for param of callback for \"pred\"\n\tparam, and for local \"insn\".\n\t(mips_insn_has_inflexible_gp_ref_p): Likewise for param \"insn\".\n\t(mips_insn_has_flexible_gp_ref_p): Likewise.\n\t(mips_epilogue_emit_cfa_restores): Likewise for return type and\n\tlocal \"insn\".\n\t(mips_epilogue_set_cfa): Likewise for local \"insn\".\n\t(mips_expand_epilogue): Likewise.\n\t(mips_adjust_insn_length): Likewise for param \"insn\".\n\t(mips_output_conditional_branch): Likewise.\n\t(mips_output_order_conditional_branch): Likewise.\n\t(struct mips_ls2): Likewise for fields \"alu1_turn_enabled_insn\",\n\t\"alu2_turn_enabled_insn\", \"falu1_turn_enabled_insn\",\n\t\"falu2_turn_enabled_insn\".\n\t(mips_builtin_branch_and_move): Strengthen locals \"true_label\",\n\t\"done_label\" from rtx to rtx_code_label *.\n\t(struct mips16_constant): Likewise for field \"label\".\n\t(mips16_add_constant): Likewise for return type.\n\t(mips16_emit_constants_1): Strengthen return type and param \"insn\"\n\tfrom rtx to rtx_insn *.\n\t(mips16_emit_constants): Likewise for param \"insn\".\n\t(mips16_insn_length): Likewise.\n\t(mips16_rewrite_pool_constant): Strengthen local \"label\" from rtx\n\tto rtx_code_label *.\n\t(struct mips16_rewrite_pool_refs_info): Strengthen field \"insn\"\n\tfrom rtx to rtx_insn *.\n\t(mips16_lay_out_constants): Likewise for locals \"insn\", \"barrier\",\n\t\"jump\".  Strengthen local \"label\" from rtx to rtx_code_label *.\n\t(r10k_simplify_address): Strengthen param \"insn\" and local\n\t\"def_insn\" from rtx to rtx_insn *.\n\t(r10k_safe_address_p): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(r10k_needs_protection_p_1): Update target type of cast of data\n\tfrom to rtx to rtx_insn *.\n\t(r10k_needs_protection_p_store): Strengthen local \"insn_ptr\" from\n\trtx * to rtx_insn **.\n\t(r10k_needs_protection_p): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(r10k_insert_cache_barriers): Likewise for locals \"insn\", \"end\".\n\t(mips_call_expr_from_insn): Likewise for param \"insn\".\n\t(mips_pic_call_symbol_from_set): Likewise for local \"def_insn\".\n\t(mips_find_pic_call_symbol): Likewise for param \"insn\".\n\t(mips_annotate_pic_calls): Likewise for local \"insn\".\n\t(mips_sim_insn): Likewise for this variable.\n\t(struct mips_sim): Likewise for field \"insn\" within elements of\n\tlast_set array.\n\t(mips_sim_wait_reg): Likewise for param \"insn\".\n\t(mips_sim_wait_regs): Likewise.\n\t(mips_sim_wait_units): Likewise.\n\t(mips_sim_wait_insn): Likewise.\n\t(mips_sim_issue_insn): Likewise.\n\t(mips_sim_finish_insn): Likewise.\n\t(mips_seq_time): Likewise for param \"seq\" and local \"insn\".\n\t(vr4130_avoid_branch_rt_conflict): Likewise for param \"insn\" and\n\tlocals \"first\", \"second\".\n\t(vr4130_align_insns): Likewise for locals \"insn\", \"subinsn\",\n\t\"last\", \"last2\", \"next\".\n\t(mips_avoid_hazard): Likewise for params \"after\", \"insn\".\n\t(mips_reorg_process_insns): Likewise for locals \"insn\",\n\t\"last_insn\", \"subinsn\", \"next_insn\".\n\t(mips_has_long_branch_p): Likewise for locals \"insn\", \"subinsn\".\n\t(mips16_split_long_branches): Likewise for locals \"insn\" \"jump\",\n\t\"jump_sequence\".\n\t(mips_output_mi_thunk): Likewise for local \"insn\".\n\t(mips_final_prescan_insn): Likewise for param \"insn\".\n\nFrom-SVN: r214450", "tree": {"sha": "cc684fcd51933d10bfde305f4a59f0b60ac7f0ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc684fcd51933d10bfde305f4a59f0b60ac7f0ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6f971f453890cb1e617307073d08fbca7de37c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6f971f453890cb1e617307073d08fbca7de37c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6f971f453890cb1e617307073d08fbca7de37c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6f971f453890cb1e617307073d08fbca7de37c7/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "04f4b24c8de7dd4677f0c2f98cf88ca8f631b811", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04f4b24c8de7dd4677f0c2f98cf88ca8f631b811", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04f4b24c8de7dd4677f0c2f98cf88ca8f631b811"}], "stats": {"total": 296, "additions": 206, "deletions": 90}, "files": [{"sha": "b819d91680404df05618bcf91478167bedcec7e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f971f453890cb1e617307073d08fbca7de37c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f971f453890cb1e617307073d08fbca7de37c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6f971f453890cb1e617307073d08fbca7de37c7", "patch": "@@ -1,3 +1,98 @@\n+2014-08-25  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* config/mips/mips-protos.h (mips_emit_move): Strengthen return\n+\ttype from rtx to rtx_insn *.\n+\t(mips_expand_call): Likewise.\n+\t(mips_adjust_insn_length): Likewise for first param.\n+\t(mips_output_conditional_branch): Likewise.\n+\t(mips_output_order_conditional_branch): Likewise.\n+\t(mips_final_prescan_insn): Likewise.\n+\n+\t* config/mips/mips.c (SEQ_BEGIN): For now, add checked cast to\n+\trtx_insn * for the SEQUENCE case.\n+\t(SEQ_END): Likewise.\n+\t(mips_emit_move): Strengthen return type from rtx to rtx_insn *.\n+\t(mips_emit_call_insn): Likewise, also for local \"insn\".\n+\t(mips16_gp_pseudo_reg): Likewise for local \"scan\".\n+\t(mips16_build_call_stub): Likewise for return type and for local\n+\t\"insn\".  Introduce a new local \"pattern\" so that \"insn\" can indeed\n+\tbe an insn.\n+\t(mips_expand_call): Strengthen return type and local \"insn\" from\n+\trtx to rtx_insn *.\n+\t(mips_block_move_loop): Strengthen local \"label\" from rtx to\n+\trtx_code_label *.\n+\t(mips_expand_synci_loop): Likewise for locals \"label\",\n+\t\"end_label\".\n+\t(mips_set_frame_expr): Strengthen local \"insn\" from rtx to\n+\trtx_insn *.\n+\t(mips16e_collect_argument_saves): Likewise for locals \"insn\",\n+\t\"next\".\n+\t(mips_find_gp_ref): Likewise for param of callback for \"pred\"\n+\tparam, and for local \"insn\".\n+\t(mips_insn_has_inflexible_gp_ref_p): Likewise for param \"insn\".\n+\t(mips_insn_has_flexible_gp_ref_p): Likewise.\n+\t(mips_epilogue_emit_cfa_restores): Likewise for return type and\n+\tlocal \"insn\".\n+\t(mips_epilogue_set_cfa): Likewise for local \"insn\".\n+\t(mips_expand_epilogue): Likewise.\n+\t(mips_adjust_insn_length): Likewise for param \"insn\".\n+\t(mips_output_conditional_branch): Likewise.\n+\t(mips_output_order_conditional_branch): Likewise.\n+\t(struct mips_ls2): Likewise for fields \"alu1_turn_enabled_insn\",\n+\t\"alu2_turn_enabled_insn\", \"falu1_turn_enabled_insn\",\n+\t\"falu2_turn_enabled_insn\".\n+\t(mips_builtin_branch_and_move): Strengthen locals \"true_label\",\n+\t\"done_label\" from rtx to rtx_code_label *.\n+\t(struct mips16_constant): Likewise for field \"label\".\n+\t(mips16_add_constant): Likewise for return type.\n+\t(mips16_emit_constants_1): Strengthen return type and param \"insn\"\n+\tfrom rtx to rtx_insn *.\n+\t(mips16_emit_constants): Likewise for param \"insn\".\n+\t(mips16_insn_length): Likewise.\n+\t(mips16_rewrite_pool_constant): Strengthen local \"label\" from rtx\n+\tto rtx_code_label *.\n+\t(struct mips16_rewrite_pool_refs_info): Strengthen field \"insn\"\n+\tfrom rtx to rtx_insn *.\n+\t(mips16_lay_out_constants): Likewise for locals \"insn\", \"barrier\",\n+\t\"jump\".  Strengthen local \"label\" from rtx to rtx_code_label *.\n+\t(r10k_simplify_address): Strengthen param \"insn\" and local\n+\t\"def_insn\" from rtx to rtx_insn *.\n+\t(r10k_safe_address_p): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(r10k_needs_protection_p_1): Update target type of cast of data\n+\tfrom to rtx to rtx_insn *.\n+\t(r10k_needs_protection_p_store): Strengthen local \"insn_ptr\" from\n+\trtx * to rtx_insn **.\n+\t(r10k_needs_protection_p): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(r10k_insert_cache_barriers): Likewise for locals \"insn\", \"end\".\n+\t(mips_call_expr_from_insn): Likewise for param \"insn\".\n+\t(mips_pic_call_symbol_from_set): Likewise for local \"def_insn\".\n+\t(mips_find_pic_call_symbol): Likewise for param \"insn\".\n+\t(mips_annotate_pic_calls): Likewise for local \"insn\".\n+\t(mips_sim_insn): Likewise for this variable.\n+\t(struct mips_sim): Likewise for field \"insn\" within elements of\n+\tlast_set array.\n+\t(mips_sim_wait_reg): Likewise for param \"insn\".\n+\t(mips_sim_wait_regs): Likewise.\n+\t(mips_sim_wait_units): Likewise.\n+\t(mips_sim_wait_insn): Likewise.\n+\t(mips_sim_issue_insn): Likewise.\n+\t(mips_sim_finish_insn): Likewise.\n+\t(mips_seq_time): Likewise for param \"seq\" and local \"insn\".\n+\t(vr4130_avoid_branch_rt_conflict): Likewise for param \"insn\" and\n+\tlocals \"first\", \"second\".\n+\t(vr4130_align_insns): Likewise for locals \"insn\", \"subinsn\",\n+\t\"last\", \"last2\", \"next\".\n+\t(mips_avoid_hazard): Likewise for params \"after\", \"insn\".\n+\t(mips_reorg_process_insns): Likewise for locals \"insn\",\n+\t\"last_insn\", \"subinsn\", \"next_insn\".\n+\t(mips_has_long_branch_p): Likewise for locals \"insn\", \"subinsn\".\n+\t(mips16_split_long_branches): Likewise for locals \"insn\" \"jump\",\n+\t\"jump_sequence\".\n+\t(mips_output_mi_thunk): Likewise for local \"insn\".\n+\t(mips_final_prescan_insn): Likewise for param \"insn\".\n+\n 2014-08-25  David Malcolm  <dmalcolm@redhat.com>\n \n \t* config/microblaze/microblaze.c (microblaze_call_tls_get_addr):"}, {"sha": "464c6270a6ada220c53d5b63026a8c41f6849e46", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f971f453890cb1e617307073d08fbca7de37c7/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f971f453890cb1e617307073d08fbca7de37c7/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=c6f971f453890cb1e617307073d08fbca7de37c7", "patch": "@@ -199,7 +199,7 @@ extern int mips_const_insns (rtx);\n extern int mips_split_const_insns (rtx);\n extern int mips_load_store_insns (rtx, rtx);\n extern int mips_idiv_insns (void);\n-extern rtx mips_emit_move (rtx, rtx);\n+extern rtx_insn *mips_emit_move (rtx, rtx);\n #ifdef RTX_CODE\n extern void mips_emit_binary (enum rtx_code, rtx, rtx, rtx);\n #endif\n@@ -229,7 +229,8 @@ extern void mips_expand_conditional_move (rtx *);\n extern void mips_expand_conditional_trap (rtx);\n #endif\n extern bool mips_use_pic_fn_addr_reg_p (const_rtx);\n-extern rtx mips_expand_call (enum mips_call_type, rtx, rtx, rtx, rtx, bool);\n+extern rtx_insn *mips_expand_call (enum mips_call_type, rtx, rtx, rtx, rtx,\n+\t\t\t\t   bool);\n extern void mips_split_call (rtx, rtx);\n extern bool mips_get_pic_call_symbol (rtx *, int);\n extern void mips_set_return_address (rtx, rtx);\n@@ -286,11 +287,12 @@ extern enum reg_class mips_secondary_reload_class (enum reg_class,\n \t\t\t\t\t\t   rtx, bool);\n extern int mips_class_max_nregs (enum reg_class, enum machine_mode);\n \n-extern int mips_adjust_insn_length (rtx, int);\n+extern int mips_adjust_insn_length (rtx_insn *, int);\n extern void mips_output_load_label (rtx);\n-extern const char *mips_output_conditional_branch (rtx, rtx *, const char *,\n-\t\t\t\t\t\t   const char *);\n-extern const char *mips_output_order_conditional_branch (rtx, rtx *, bool);\n+extern const char *mips_output_conditional_branch (rtx_insn *, rtx *,\n+\t\t\t\t\t\t   const char *, const char *);\n+extern const char *mips_output_order_conditional_branch (rtx_insn *, rtx *,\n+\t\t\t\t\t\t\t bool);\n extern const char *mips_output_sync (void);\n extern const char *mips_output_sync_loop (rtx, rtx *);\n extern unsigned int mips_sync_loop_insns (rtx, rtx *);\n@@ -349,7 +351,7 @@ extern void mips16_expand_set_fcsr (rtx);\n \n extern bool mips_eh_uses (unsigned int);\n extern bool mips_epilogue_uses (unsigned int);\n-extern void mips_final_prescan_insn (rtx, rtx *, int);\n+extern void mips_final_prescan_insn (rtx_insn *, rtx *, int);\n extern int mips_trampoline_code_size (void);\n extern void mips_function_profiler (FILE *);\n "}, {"sha": "1cf2e8c17063ee1d08fa4abd988c5993c37e1251", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 102, "deletions": 83, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f971f453890cb1e617307073d08fbca7de37c7/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f971f453890cb1e617307073d08fbca7de37c7/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=c6f971f453890cb1e617307073d08fbca7de37c7", "patch": "@@ -123,13 +123,15 @@ along with GCC; see the file COPYING3.  If not see\n    in the sequence, otherwise return INSN itself.  */\n #define SEQ_BEGIN(INSN)\t\t\t\t\t\t\t\\\n   (INSN_P (INSN) && GET_CODE (PATTERN (INSN)) == SEQUENCE\t\t\\\n-   ? XVECEXP (PATTERN (INSN), 0, 0)\t\t\t\t\t\\\n+   ? as_a <rtx_insn *> (XVECEXP (PATTERN (INSN), 0, 0))\t\t\t\\\n    : (INSN))\n \n /* Likewise for the last instruction in a delayed branch sequence.  */\n #define SEQ_END(INSN)\t\t\t\t\t\t\t\\\n   (INSN_P (INSN) && GET_CODE (PATTERN (INSN)) == SEQUENCE\t\t\\\n-   ? XVECEXP (PATTERN (INSN), 0, XVECLEN (PATTERN (INSN), 0) - 1)\t\\\n+   ? as_a <rtx_insn *> (XVECEXP (PATTERN (INSN),\t\t\t\\\n+\t\t\t\t 0,\t\t\t\t\t\\\n+\t\t\t\t XVECLEN (PATTERN (INSN), 0) - 1))\t\\\n    : (INSN))\n \n /* Execute the following loop body with SUBINSN set to each instruction\n@@ -1195,7 +1197,7 @@ static const struct mips_rtx_cost_data\n   }\n };\n \f\n-static rtx mips_find_pic_call_symbol (rtx, rtx, bool);\n+static rtx mips_find_pic_call_symbol (rtx_insn *, rtx, bool);\n static int mips_register_move_cost (enum machine_mode, reg_class_t,\n \t\t\t\t    reg_class_t);\n static unsigned int mips_function_arg_boundary (enum machine_mode, const_tree);\n@@ -2725,7 +2727,7 @@ mips_idiv_insns (void)\n    how to force Pmode objects into the constant pool even when the\n    constant pool address is not itself legitimate.  */\n \n-rtx\n+rtx_insn *\n mips_emit_move (rtx dest, rtx src)\n {\n   return (can_create_pseudo_p ()\n@@ -2810,10 +2812,11 @@ mips_force_temporary (rtx dest, rtx value)\n    ADDR is the legitimized form, and LAZY_P is true if the call\n    address is lazily-bound.  */\n \n-static rtx\n+static rtx_insn *\n mips_emit_call_insn (rtx pattern, rtx orig_addr, rtx addr, bool lazy_p)\n {\n-  rtx insn, reg;\n+  rtx_insn *insn;\n+  rtx reg;\n \n   insn = emit_call_insn (pattern);\n \n@@ -2929,7 +2932,8 @@ mips16_gp_pseudo_reg (void)\n {\n   if (cfun->machine->mips16_gp_pseudo_rtx == NULL_RTX)\n     {\n-      rtx insn, scan;\n+      rtx insn;\n+      rtx_insn *scan;\n \n       cfun->machine->mips16_gp_pseudo_rtx = gen_reg_rtx (Pmode);\n \n@@ -6721,18 +6725,19 @@ mips16_copy_fpr_return_value (void)\n    automatically redirects the JAL to the stub, otherwise the JAL\n    continues to call FN directly.  */\n \n-static rtx\n+static rtx_insn *\n mips16_build_call_stub (rtx retval, rtx *fn_ptr, rtx args_size, int fp_code)\n {\n   const char *fnname;\n   bool fp_ret_p;\n   struct mips16_stub *l;\n-  rtx insn, fn;\n+  rtx_insn *insn;\n+  rtx pattern, fn;\n \n   /* We don't need to do anything if we aren't in MIPS16 mode, or if\n      we were invoked with the -msoft-float option.  */\n   if (!TARGET_MIPS16 || TARGET_SOFT_FLOAT_ABI)\n-    return NULL_RTX;\n+    return NULL;\n \n   /* Figure out whether the value might come back in a floating-point\n      register.  */\n@@ -6742,20 +6747,20 @@ mips16_build_call_stub (rtx retval, rtx *fn_ptr, rtx args_size, int fp_code)\n      arguments and the value will not be returned in a floating-point\n      register.  */\n   if (fp_code == 0 && !fp_ret_p)\n-    return NULL_RTX;\n+    return NULL;\n \n   /* We don't need to do anything if this is a call to a special\n      MIPS16 support function.  */\n   fn = *fn_ptr;\n   if (mips16_stub_function_p (fn))\n-    return NULL_RTX;\n+    return NULL;\n \n   /* If we're calling a locally-defined MIPS16 function, we know that\n      it will return values in both the \"soft-float\" and \"hard-float\"\n      registers.  There is no need to use a stub to move the latter\n      to the former.  */\n   if (fp_code == 0 && mips16_local_function_p (fn))\n-    return NULL_RTX;\n+    return NULL;\n \n   /* This code will only work for o32 and o64 abis.  The other ABI's\n      require more sophisticated support.  */\n@@ -6768,15 +6773,16 @@ mips16_build_call_stub (rtx retval, rtx *fn_ptr, rtx args_size, int fp_code)\n       || !call_insn_operand (fn, VOIDmode))\n     {\n       char buf[30];\n-      rtx stub_fn, insn, addr;\n+      rtx stub_fn, addr;\n+      rtx_insn *insn;\n       bool lazy_p;\n \n       /* If this is a locally-defined and locally-binding function,\n \t avoid the stub by calling the local alias directly.  */\n       if (mips16_local_function_p (fn))\n \t{\n \t  *fn_ptr = mips16_local_alias (fn);\n-\t  return NULL_RTX;\n+\t  return NULL;\n \t}\n \n       /* Create a SYMBOL_REF for the libgcc.a function.  */\n@@ -6998,10 +7004,10 @@ mips16_build_call_stub (rtx retval, rtx *fn_ptr, rtx args_size, int fp_code)\n     error (\"cannot handle inconsistent calls to %qs\", fnname);\n \n   if (retval == NULL_RTX)\n-    insn = gen_call_internal_direct (fn, args_size);\n+    pattern = gen_call_internal_direct (fn, args_size);\n   else\n-    insn = gen_call_value_internal_direct (retval, fn, args_size);\n-  insn = mips_emit_call_insn (insn, fn, fn, false);\n+    pattern = gen_call_value_internal_direct (retval, fn, args_size);\n+  insn = mips_emit_call_insn (pattern, fn, fn, false);\n \n   /* If we are calling a stub which handles a floating-point return\n      value, we need to arrange to save $18 in the prologue.  We do this\n@@ -7026,11 +7032,12 @@ mips16_build_call_stub (rtx retval, rtx *fn_ptr, rtx args_size, int fp_code)\n \n    Return the call itself.  */\n \n-rtx\n+rtx_insn *\n mips_expand_call (enum mips_call_type type, rtx result, rtx addr,\n \t\t  rtx args_size, rtx aux, bool lazy_p)\n {\n-  rtx orig_addr, pattern, insn;\n+  rtx orig_addr, pattern;\n+  rtx_insn *insn;\n   int fp_code;\n \n   fp_code = aux == 0 ? 0 : (int) GET_MODE (aux);\n@@ -7353,7 +7360,8 @@ static void\n mips_block_move_loop (rtx dest, rtx src, HOST_WIDE_INT length,\n \t\t      HOST_WIDE_INT bytes_per_iter)\n {\n-  rtx label, src_reg, dest_reg, final_src, test;\n+  rtx_code_label *label;\n+  rtx src_reg, dest_reg, final_src, test;\n   HOST_WIDE_INT leftover;\n \n   leftover = length % bytes_per_iter;\n@@ -7419,7 +7427,8 @@ mips_expand_block_move (rtx dest, rtx src, rtx length)\n void\n mips_expand_synci_loop (rtx begin, rtx end)\n {\n-  rtx inc, label, end_label, cmp_result, mask, length;\n+  rtx inc, cmp_result, mask, length;\n+  rtx_code_label *label, *end_label;\n \n   /* Create end_label.  */\n   end_label = gen_label_rtx ();\n@@ -9012,7 +9021,7 @@ mips_code_end (void)\n static void\n mips_set_frame_expr (rtx frame_pattern)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   insn = get_last_insn ();\n   RTX_FRAME_RELATED_P (insn) = 1;\n@@ -9180,7 +9189,8 @@ static unsigned int\n mips16e_collect_argument_saves (void)\n {\n   rtx reg_values[FIRST_PSEUDO_REGISTER];\n-  rtx insn, next, set, dest, src;\n+  rtx_insn *insn, *next;\n+  rtx set, dest, src;\n   unsigned int nargs, regno;\n \n   push_topmost_sequence ();\n@@ -9516,9 +9526,9 @@ mips16_cfun_returns_in_fpr_p (void)\n    if *CACHE is already true.  */\n \n static bool\n-mips_find_gp_ref (bool *cache, bool (*pred) (rtx))\n+mips_find_gp_ref (bool *cache, bool (*pred) (rtx_insn *))\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   if (!*cache)\n     {\n@@ -9538,7 +9548,7 @@ mips_find_gp_ref (bool *cache, bool (*pred) (rtx))\n    See mips_cfun_has_inflexible_gp_ref_p for details.  */\n \n static bool\n-mips_insn_has_inflexible_gp_ref_p (rtx insn)\n+mips_insn_has_inflexible_gp_ref_p (rtx_insn *insn)\n {\n   /* Uses of pic_offset_table_rtx in CALL_INSN_FUNCTION_USAGE\n      indicate that the target could be a traditional MIPS\n@@ -9591,7 +9601,7 @@ mips_cfun_has_inflexible_gp_ref_p (void)\n    See mips_cfun_has_flexible_gp_ref_p for details.  */\n \n static bool\n-mips_insn_has_flexible_gp_ref_p (rtx insn)\n+mips_insn_has_flexible_gp_ref_p (rtx_insn *insn)\n {\n   return (get_attr_got (insn) != GOT_UNSET\n \t  || mips_small_data_pattern_p (PATTERN (insn))\n@@ -11348,10 +11358,10 @@ mips_expand_prologue (void)\n /* Attach all pending register saves to the previous instruction.\n    Return that instruction.  */\n \n-static rtx\n+static rtx_insn *\n mips_epilogue_emit_cfa_restores (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   insn = get_last_insn ();\n   gcc_assert (insn && !REG_NOTES (insn));\n@@ -11370,7 +11380,7 @@ mips_epilogue_emit_cfa_restores (void)\n static void\n mips_epilogue_set_cfa (rtx reg, HOST_WIDE_INT offset)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   insn = mips_epilogue_emit_cfa_restores ();\n   if (reg != mips_epilogue.cfa_reg || offset != mips_epilogue.cfa_offset)\n@@ -11466,7 +11476,8 @@ mips_expand_epilogue (bool sibcall_p)\n {\n   const struct mips_frame_info *frame;\n   HOST_WIDE_INT step1, step2;\n-  rtx base, adjust, insn;\n+  rtx base, adjust;\n+  rtx_insn *insn;\n   bool use_jraddiusp_p = false;\n \n   if (!sibcall_p && mips_can_use_return_insn ())\n@@ -12395,7 +12406,7 @@ mips_output_load_label (rtx target)\n    attributes in the machine-description file.  */\n \n int\n-mips_adjust_insn_length (rtx insn, int length)\n+mips_adjust_insn_length (rtx_insn *insn, int length)\n {\n   /* mips.md uses MAX_PIC_BRANCH_LENGTH as a placeholder for the length\n      of a PIC long-branch sequence.  Substitute the correct value.  */\n@@ -12449,7 +12460,7 @@ mips_adjust_insn_length (rtx insn, int length)\n    version of BRANCH_IF_TRUE.  */\n \n const char *\n-mips_output_conditional_branch (rtx insn, rtx *operands,\n+mips_output_conditional_branch (rtx_insn *insn, rtx *operands,\n \t\t\t\tconst char *branch_if_true,\n \t\t\t\tconst char *branch_if_false)\n {\n@@ -12532,7 +12543,7 @@ mips_output_conditional_branch (rtx insn, rtx *operands,\n    its second is always zero.  */\n \n const char *\n-mips_output_order_conditional_branch (rtx insn, rtx *operands, bool inverted_p)\n+mips_output_order_conditional_branch (rtx_insn *insn, rtx *operands, bool inverted_p)\n {\n   const char *branch[2];\n \n@@ -13111,10 +13122,10 @@ static struct\n      DFA state.\n      E.g., when alu1_turn_enabled_insn is issued it makes next ALU1/2\n      instruction to go ALU1.  */\n-  rtx alu1_turn_enabled_insn;\n-  rtx alu2_turn_enabled_insn;\n-  rtx falu1_turn_enabled_insn;\n-  rtx falu2_turn_enabled_insn;\n+  rtx_insn *alu1_turn_enabled_insn;\n+  rtx_insn *alu2_turn_enabled_insn;\n+  rtx_insn *falu1_turn_enabled_insn;\n+  rtx_insn *falu2_turn_enabled_insn;\n } mips_ls2;\n \n /* Implement TARGET_SCHED_ADJUST_COST.  We assume that anti and output\n@@ -14475,7 +14486,7 @@ static rtx\n mips_builtin_branch_and_move (rtx condition, rtx target,\n \t\t\t      rtx value_if_true, rtx value_if_false)\n {\n-  rtx true_label, done_label;\n+  rtx_code_label *true_label, *done_label;\n \n   true_label = gen_label_rtx ();\n   done_label = gen_label_rtx ();\n@@ -14615,7 +14626,7 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n struct mips16_constant {\n   struct mips16_constant *next;\n   rtx value;\n-  rtx label;\n+  rtx_code_label *label;\n   enum machine_mode mode;\n };\n \n@@ -14632,7 +14643,7 @@ struct mips16_constant_pool {\n /* Add constant VALUE to POOL and return its label.  MODE is the\n    value's mode (used for CONST_INTs, etc.).  */\n \n-static rtx\n+static rtx_code_label *\n mips16_add_constant (struct mips16_constant_pool *pool,\n \t\t     rtx value, enum machine_mode mode)\n {\n@@ -14689,8 +14700,8 @@ mips16_add_constant (struct mips16_constant_pool *pool,\n /* Output constant VALUE after instruction INSN and return the last\n    instruction emitted.  MODE is the mode of the constant.  */\n \n-static rtx\n-mips16_emit_constants_1 (enum machine_mode mode, rtx value, rtx insn)\n+static rtx_insn *\n+mips16_emit_constants_1 (enum machine_mode mode, rtx value, rtx_insn *insn)\n {\n   if (SCALAR_INT_MODE_P (mode) || ALL_SCALAR_FIXED_POINT_MODE_P (mode))\n     {\n@@ -14717,7 +14728,7 @@ mips16_emit_constants_1 (enum machine_mode mode, rtx value, rtx insn)\n /* Dump out the constants in CONSTANTS after INSN.  */\n \n static void\n-mips16_emit_constants (struct mips16_constant *constants, rtx insn)\n+mips16_emit_constants (struct mips16_constant *constants, rtx_insn *insn)\n {\n   struct mips16_constant *c, *next;\n   int align;\n@@ -14746,7 +14757,7 @@ mips16_emit_constants (struct mips16_constant *constants, rtx insn)\n /* Return the length of instruction INSN.  */\n \n static int\n-mips16_insn_length (rtx insn)\n+mips16_insn_length (rtx_insn *insn)\n {\n   if (JUMP_TABLE_DATA_P (insn))\n     {\n@@ -14767,7 +14778,8 @@ mips16_insn_length (rtx insn)\n static void\n mips16_rewrite_pool_constant (struct mips16_constant_pool *pool, rtx *x)\n {\n-  rtx base, offset, label;\n+  rtx base, offset;\n+  rtx_code_label *label;\n \n   split_const (*x, &base, &offset);\n   if (GET_CODE (base) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (base))\n@@ -14783,7 +14795,7 @@ mips16_rewrite_pool_constant (struct mips16_constant_pool *pool, rtx *x)\n    INSN is the instruction we're rewriting and POOL points to the current\n    constant pool.  */\n struct mips16_rewrite_pool_refs_info {\n-  rtx insn;\n+  rtx_insn *insn;\n   struct mips16_constant_pool *pool;\n };\n \n@@ -14836,7 +14848,7 @@ mips16_lay_out_constants (bool split_p)\n {\n   struct mips16_constant_pool pool;\n   struct mips16_rewrite_pool_refs_info info;\n-  rtx insn, barrier;\n+  rtx_insn *insn, *barrier;\n \n   if (!TARGET_MIPS16_PCREL_LOADS)\n     return;\n@@ -14873,7 +14885,8 @@ mips16_lay_out_constants (bool split_p)\n \t     do it immediately before INSN.  */\n \t  if (barrier == 0 && pool.insn_address + 4 > pool.highest_address)\n \t    {\n-\t      rtx label, jump;\n+\t      rtx_code_label *label;\n+\t      rtx_insn *jump;\n \n \t      label = gen_label_rtx ();\n \n@@ -14921,9 +14934,10 @@ r10k_simplified_address_p (rtx x)\n    virtual_incoming_args_rtx (which should never occur in X otherwise).  */\n \n static rtx\n-r10k_simplify_address (rtx x, rtx insn)\n+r10k_simplify_address (rtx x, rtx_insn *insn)\n {\n-  rtx newx, op0, op1, set, def_insn, note;\n+  rtx newx, op0, op1, set, note;\n+  rtx_insn *def_insn;\n   df_ref use, def;\n   struct df_link *defs;\n \n@@ -15025,7 +15039,7 @@ r10k_uncached_address_p (unsigned HOST_WIDE_INT address)\n    expression; it might not be a legitimate address.  */\n \n static bool\n-r10k_safe_address_p (rtx x, rtx insn)\n+r10k_safe_address_p (rtx x, rtx_insn *insn)\n {\n   rtx base, offset;\n   HOST_WIDE_INT offset_val;\n@@ -15090,7 +15104,7 @@ r10k_needs_protection_p_1 (rtx *loc, void *data)\n       && r10k_safe_mem_expr_p (MEM_EXPR (mem), MEM_OFFSET (mem)))\n     return -1;\n \n-  if (r10k_safe_address_p (XEXP (mem, 0), (rtx) data))\n+  if (r10k_safe_address_p (XEXP (mem, 0), (rtx_insn *) data))\n     return -1;\n \n   return 1;\n@@ -15104,11 +15118,11 @@ static void\n r10k_needs_protection_p_store (rtx x, const_rtx pat ATTRIBUTE_UNUSED,\n \t\t\t       void *data)\n {\n-  rtx *insn_ptr;\n+  rtx_insn **insn_ptr;\n \n-  insn_ptr = (rtx *) data;\n+  insn_ptr = (rtx_insn **) data;\n   if (*insn_ptr && for_each_rtx (&x, r10k_needs_protection_p_1, *insn_ptr))\n-    *insn_ptr = NULL_RTX;\n+    *insn_ptr = NULL;\n }\n \n /* A for_each_rtx callback that iterates over the pattern of a CALL_INSN.\n@@ -15134,7 +15148,7 @@ r10k_needs_protection_p_call (rtx *loc, void *data ATTRIBUTE_UNUSED)\n    cache barrier.  */\n \n static bool\n-r10k_needs_protection_p (rtx insn)\n+r10k_needs_protection_p (rtx_insn *insn)\n {\n   if (CALL_P (insn))\n     return for_each_rtx (&PATTERN (insn), r10k_needs_protection_p_call, NULL);\n@@ -15174,7 +15188,8 @@ r10k_insert_cache_barriers (void)\n   unsigned int i, n;\n   basic_block bb;\n   sbitmap protected_bbs;\n-  rtx insn, end, unprotected_region;\n+  rtx_insn *insn, *end;\n+  rtx unprotected_region;\n \n   if (TARGET_MIPS16)\n     {\n@@ -15267,7 +15282,7 @@ r10k_insert_cache_barriers (void)\n    SECOND_CALL.  */\n \n static rtx\n-mips_call_expr_from_insn (rtx insn, rtx *second_call)\n+mips_call_expr_from_insn (rtx_insn *insn, rtx *second_call)\n {\n   rtx x;\n   rtx x2;\n@@ -15307,7 +15322,8 @@ mips_call_expr_from_insn (rtx insn, rtx *second_call)\n static rtx\n mips_pic_call_symbol_from_set (df_ref def, rtx reg, bool recurse_p)\n {\n-  rtx def_insn, set;\n+  rtx_insn *def_insn;\n+  rtx set;\n \n   if (DF_REF_IS_ARTIFICIAL (def))\n     return NULL_RTX;\n@@ -15370,7 +15386,7 @@ mips_pic_call_symbol_from_set (df_ref def, rtx reg, bool recurse_p)\n    mips_pic_call_symbol_from_set.  */\n \n static rtx\n-mips_find_pic_call_symbol (rtx insn, rtx reg, bool recurse_p)\n+mips_find_pic_call_symbol (rtx_insn *insn, rtx reg, bool recurse_p)\n {\n   df_ref use;\n   struct df_link *defs;\n@@ -15446,7 +15462,7 @@ static void\n mips_annotate_pic_calls (void)\n {\n   basic_block bb;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   FOR_EACH_BB_FN (bb, cfun)\n     FOR_BB_INSNS (bb, insn)\n@@ -15473,7 +15489,7 @@ mips_annotate_pic_calls (void)\n }\n \f\n /* A temporary variable used by for_each_rtx callbacks, etc.  */\n-static rtx mips_sim_insn;\n+static rtx_insn *mips_sim_insn;\n \n /* A structure representing the state of the processor pipeline.\n    Used by the mips_sim_* family of functions.  */\n@@ -15492,7 +15508,7 @@ struct mips_sim {\n      LAST_SET[X].TIME is the time at which that instruction was issued.\n      INSN is null if no instruction has yet set register X.  */\n   struct {\n-    rtx insn;\n+    rtx_insn *insn;\n     unsigned int time;\n   } last_set[FIRST_PSEUDO_REGISTER];\n \n@@ -15549,7 +15565,7 @@ mips_sim_next_cycle (struct mips_sim *state)\n    register REG.  */\n \n static void\n-mips_sim_wait_reg (struct mips_sim *state, rtx insn, rtx reg)\n+mips_sim_wait_reg (struct mips_sim *state, rtx_insn *insn, rtx reg)\n {\n   unsigned int regno, end_regno;\n \n@@ -15589,7 +15605,7 @@ mips_sim_wait_regs_1 (rtx *x, void *data)\n    dependencies are satisfied.  */\n \n static void\n-mips_sim_wait_regs (struct mips_sim *state, rtx insn)\n+mips_sim_wait_regs (struct mips_sim *state, rtx_insn *insn)\n {\n   mips_sim_insn = insn;\n   note_uses (&PATTERN (insn), mips_sim_wait_regs_1, state);\n@@ -15599,7 +15615,7 @@ mips_sim_wait_regs (struct mips_sim *state, rtx insn)\n    instruction INSN are available.  */\n \n static void\n-mips_sim_wait_units (struct mips_sim *state, rtx insn)\n+mips_sim_wait_units (struct mips_sim *state, rtx_insn *insn)\n {\n   state_t tmp_state;\n \n@@ -15613,7 +15629,7 @@ mips_sim_wait_units (struct mips_sim *state, rtx insn)\n /* Advance simulation state STATE until INSN is ready to issue.  */\n \n static void\n-mips_sim_wait_insn (struct mips_sim *state, rtx insn)\n+mips_sim_wait_insn (struct mips_sim *state, rtx_insn *insn)\n {\n   mips_sim_wait_regs (state, insn);\n   mips_sim_wait_units (state, insn);\n@@ -15646,7 +15662,7 @@ mips_sim_record_set (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data)\n    been called).  */\n \n static void\n-mips_sim_issue_insn (struct mips_sim *state, rtx insn)\n+mips_sim_issue_insn (struct mips_sim *state, rtx_insn *insn)\n {\n   curr_state = state->dfa_state;\n \n@@ -15673,7 +15689,7 @@ mips_sim_issue_nop (struct mips_sim *state)\n    SEQUENCE.  */\n \n static void\n-mips_sim_finish_insn (struct mips_sim *state, rtx insn)\n+mips_sim_finish_insn (struct mips_sim *state, rtx_insn *insn)\n {\n   /* If INSN is a jump with an implicit delay slot, simulate a nop.  */\n   if (JUMP_P (insn))\n@@ -15708,10 +15724,10 @@ mips_sim_finish_insn (struct mips_sim *state, rtx insn)\n    instruction sequence SEQ.  */\n \n static unsigned int\n-mips_seq_time (struct mips_sim *state, rtx seq)\n+mips_seq_time (struct mips_sim *state, rtx_insn *seq)\n {\n   mips_sim_reset (state);\n-  for (rtx insn = seq; insn; insn = NEXT_INSN (insn))\n+  for (rtx_insn *insn = seq; insn; insn = NEXT_INSN (insn))\n     {\n       mips_sim_wait_insn (state, insn);\n       mips_sim_issue_insn (state, insn);\n@@ -15820,9 +15836,9 @@ mips_expand_to_rtl_hook (void)\n    try to avoid it by swapping rs and rt.  */\n \n static void\n-vr4130_avoid_branch_rt_conflict (rtx insn)\n+vr4130_avoid_branch_rt_conflict (rtx_insn *insn)\n {\n-  rtx first, second;\n+  rtx_insn *first, *second;\n \n   first = SEQ_BEGIN (insn);\n   second = SEQ_END (insn);\n@@ -15857,7 +15873,7 @@ static void\n vr4130_align_insns (void)\n {\n   struct mips_sim state;\n-  rtx insn, subinsn, last, last2, next;\n+  rtx_insn *insn, *subinsn, *last, *last2, *next;\n   bool aligned_p;\n \n   dfa_start ();\n@@ -16109,7 +16125,7 @@ mips_orphaned_high_part_p (mips_offset_table *htab, rtx insn)\n    LO_REG is an rtx for the LO register, used in dependence checking.  */\n \n static void\n-mips_avoid_hazard (rtx after, rtx insn, int *hilo_delay,\n+mips_avoid_hazard (rtx_insn *after, rtx_insn *insn, int *hilo_delay,\n \t\t   rtx *delayed_reg, rtx lo_reg)\n {\n   rtx pattern, set;\n@@ -16174,7 +16190,8 @@ mips_avoid_hazard (rtx after, rtx insn, int *hilo_delay,\n static void\n mips_reorg_process_insns (void)\n {\n-  rtx insn, last_insn, subinsn, next_insn, lo_reg, delayed_reg;\n+  rtx_insn *insn, *last_insn, *subinsn, *next_insn;\n+  rtx lo_reg, delayed_reg;\n   int hilo_delay;\n \n   /* Force all instructions to be split into their final form.  */\n@@ -16301,7 +16318,7 @@ mips_reorg_process_insns (void)\n static bool\n mips_has_long_branch_p (void)\n {\n-  rtx insn, subinsn;\n+  rtx_insn *insn, *subinsn;\n   int normal_length;\n \n   /* We need up-to-date instruction lengths.  */\n@@ -16410,7 +16427,7 @@ mips16_split_long_branches (void)\n   /* Loop until the alignments for all targets are sufficient.  */\n   do\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n \n       shorten_branches (get_insns ());\n       something_changed = false;\n@@ -16420,7 +16437,8 @@ mips16_split_long_branches (void)\n \t    && (any_condjump_p (insn) || any_uncondjump_p (insn)))\n \t  {\n \t    rtx old_label, new_label, temp, saved_temp;\n-\t    rtx target, jump, jump_sequence;\n+\t    rtx target;\n+\t    rtx_insn *jump, *jump_sequence;\n \n \t    start_sequence ();\n \n@@ -16552,7 +16570,8 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t\t      HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n \t\t      tree function)\n {\n-  rtx this_rtx, temp1, temp2, insn, fnaddr;\n+  rtx this_rtx, temp1, temp2, fnaddr;\n+  rtx_insn *insn;\n   bool use_sibcall_p;\n \n   /* Pretend to be a post-reload pass while generating rtl.  */\n@@ -17562,7 +17581,7 @@ mips_need_noat_wrapper_p (rtx insn, rtx *opvec, int noperands)\n /* Implement FINAL_PRESCAN_INSN.  */\n \n void\n-mips_final_prescan_insn (rtx insn, rtx *opvec, int noperands)\n+mips_final_prescan_insn (rtx_insn *insn, rtx *opvec, int noperands)\n {\n   if (mips_need_noat_wrapper_p (insn, opvec, noperands))\n     mips_push_asm_switch (&mips_noat);"}]}