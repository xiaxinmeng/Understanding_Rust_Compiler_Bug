{"sha": "2450a057297b5bf665b98e9594ac6799c8a7e5fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ1MGEwNTcyOTdiNWJmNjY1Yjk4ZTk1OTRhYzY3OTljOGE3ZTVmYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-11-18T19:10:44Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-11-18T19:10:44Z"}, "message": "i386-protos.h (split_xf, [...]): Remove.\n\n        * i386-protos.h (split_xf, ix86_split_movdi): Remove.\n        (ix86_split_long_move): Declare.\n        * i386.c (split_xf, ix86_split_movdi): Remove.\n        (ix86_split_to_parts, ix86_split_long_move): New.\n        * i386.md (dimode move splitters): Use ix86_split_long_move.\n        (dfmode move splitters): Likewise.\n        (xfmode move splitters): Likewise.\n        (movsf_1): Allow F->r.\n        (movdf_1, movxf_1): Allow F->ro.\n\nCo-Authored-By: Richard Henderson <rth@cygnus.com>\n\nFrom-SVN: r30578", "tree": {"sha": "33ca9fa73edbb3730b350af5f3ed0a6b7c85eccf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33ca9fa73edbb3730b350af5f3ed0a6b7c85eccf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2450a057297b5bf665b98e9594ac6799c8a7e5fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2450a057297b5bf665b98e9594ac6799c8a7e5fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2450a057297b5bf665b98e9594ac6799c8a7e5fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2450a057297b5bf665b98e9594ac6799c8a7e5fb/comments", "author": null, "committer": null, "parents": [{"sha": "4a6ef811c845111d1988d027ec7c5fd3e787fdd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a6ef811c845111d1988d027ec7c5fd3e787fdd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a6ef811c845111d1988d027ec7c5fd3e787fdd3"}], "stats": {"total": 336, "additions": 251, "deletions": 85}, "files": [{"sha": "66758cd51e3f210b7391a9fd99562fd61cd246cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2450a057297b5bf665b98e9594ac6799c8a7e5fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2450a057297b5bf665b98e9594ac6799c8a7e5fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2450a057297b5bf665b98e9594ac6799c8a7e5fb", "patch": "@@ -1,3 +1,16 @@\n+Thu Nov 18 11:10:03 1999  Jan Hubicka  <hubicka@freesoft.cz>\n+\t\t\t  Richard Henderson  <rth@cygnus.com>\n+\n+\t* i386-protos.h (split_xf, ix86_split_movdi): Remove.\n+\t(ix86_split_long_move): Declare.\n+\t* i386.c (split_xf, ix86_split_movdi): Remove.\n+\t(ix86_split_to_parts, ix86_split_long_move): New.\n+\t* i386.md (dimode move splitters): Use ix86_split_long_move.\n+\t(dfmode move splitters): Likewise.\n+\t(xfmode move splitters): Likewise.\n+\t(movsf_1): Allow F->r.\n+\t(movdf_1, movxf_1): Allow F->ro.\n+\n 1999-11-17  Mark Mitchell  <mark@codesourcery.com>\n \n \t* except.h (struct eh_entry): Add goto_entry_p."}, {"sha": "a8e16b5eaa89c47e5de5482cabe76f6befcc1b9b", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2450a057297b5bf665b98e9594ac6799c8a7e5fb/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2450a057297b5bf665b98e9594ac6799c8a7e5fb/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=2450a057297b5bf665b98e9594ac6799c8a7e5fb", "patch": "@@ -73,7 +73,6 @@ extern void print_operand PROTO((FILE*, rtx, int));\n extern void print_operand_address PROTO((FILE*, rtx));\n \n extern void split_di PROTO((rtx[], int, rtx[], rtx[]));\n-extern void split_xf PROTO((rtx, rtx[3]));\n \n extern char *output_387_binary_op PROTO((rtx, rtx*));\n extern char *output_fix_trunc PROTO((rtx, rtx*));\n@@ -92,7 +91,7 @@ extern void ix86_expand_branch PROTO((enum rtx_code, int, rtx));\n extern int ix86_expand_setcc PROTO((enum rtx_code, int, rtx));\n extern int ix86_expand_int_movcc PROTO((rtx[]));\n extern int ix86_expand_fp_movcc PROTO((rtx[]));\n-extern int ix86_split_movdi PROTO((rtx[]));\n+extern int ix86_split_long_move PROTO((rtx[]));\n extern void ix86_split_ashldi PROTO((rtx *, rtx));\n extern void ix86_split_ashrdi PROTO((rtx *, rtx));\n extern void ix86_split_lshrdi PROTO((rtx *, rtx));"}, {"sha": "c8e89954be84b4c35c7fe2ab791a11cbae0be9a3", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 199, "deletions": 35, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2450a057297b5bf665b98e9594ac6799c8a7e5fb/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2450a057297b5bf665b98e9594ac6799c8a7e5fb/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2450a057297b5bf665b98e9594ac6799c8a7e5fb", "patch": "@@ -2996,26 +2996,6 @@ split_di (operands, num, lo_half, hi_half)\n \tabort();\n     }\n }\n-\n-void\n-split_xf (orig, out)\n-     rtx orig;\n-     rtx out[3];\n-{\n-  if (REG_P (orig))\n-    {\n-      int regno = REGNO (orig);\n-      out[0] = gen_rtx_REG (SImode, regno);\n-      out[1] = gen_rtx_REG (SImode, regno + 1);\n-      out[2] = gen_rtx_REG (SImode, regno + 2);\n-    }\n-  else\n-    {\n-      out[0] = change_address (orig, SImode, NULL_RTX);\n-      out[1] = adj_offsettable_operand (out[0], 4);\n-      out[2] = adj_offsettable_operand (out[0], 8);\n-    }\n-}\n \f\n /* Output code to perform a 387 binary operation in INSN, one of PLUS,\n    MINUS, MULT or DIV.  OPERANDS are the insn operands, where operands[3]\n@@ -4643,27 +4623,211 @@ ix86_expand_fp_movcc (operands)\n   return 1;\n }\n \n-int\n-ix86_split_movdi (operands)\n-     rtx operands[];\n+/* Split operands 0 and 1 into SImode parts.  Similar to split_di, but\n+   works for floating pointer parameters and nonoffsetable memories.\n+   For pushes, it returns just stack offsets; the values will be saved\n+   in the right order.  Maximally three parts are generated.  */\n+\n+static void\n+ix86_split_to_parts (operand, parts, mode)\n+     rtx operand;\n+     rtx *parts;\n+     enum machine_mode mode;\n {\n-  split_di (operands+0, 1, operands+2, operands+3);\n-  split_di (operands+1, 1, operands+4, operands+5);\n-  if (reg_overlap_mentioned_p (operands[2], operands[1]))\n+  int size = GET_MODE_SIZE (mode) / 4;\n+\n+  if (size < 2 || size > 3)\n+    abort ();\n+\n+  if (GET_CODE (operand) == MEM && !offsettable_memref_p (operand))\n     {\n-      rtx tmp;\n-      if (!reg_overlap_mentioned_p (operands[3], operands[4]))\n+      /* The only non-offsetable memories we handle are pushes.  */\n+      if (! push_operand (operand, VOIDmode))\n+\tabort ();\n+\n+      PUT_MODE (operand, SImode);\n+      parts[0] = parts[1] = parts[2] = operand;\n+    }\n+  else\n+    {\n+      if (mode == DImode)\n+\tsplit_di (&operand, 1, &parts[0], &parts[1]);\n+      else\n \t{\n-\t  tmp = operands[2], operands[2] = operands[3], operands[3] = tmp;\n-\t  tmp = operands[4], operands[4] = operands[5], operands[5] = tmp;\n+\t  if (REG_P (operand))\n+\t    {\n+\t      if (!reload_completed)\n+\t\tabort ();\n+\t      parts[0] = gen_rtx_REG (SImode, REGNO (operand) + 0);\n+\t      parts[1] = gen_rtx_REG (SImode, REGNO (operand) + 1);\n+\t      if (size == 3)\n+\t\tparts[2] = gen_rtx_REG (SImode, REGNO (operand) + 2);\n+\t    }\n+\t  else if (offsettable_memref_p (operand))\n+\t    {\n+\t      PUT_MODE (operand, SImode);\n+\t      parts[0] = operand;\n+\t      parts[1] = adj_offsettable_operand (operand, 4);\n+\t      if (size == 3)\n+\t\tparts[2] = adj_offsettable_operand (operand, 8);\n+\t    }\n+\t  else if (GET_CODE (operand) == CONST_DOUBLE)\n+\t    {\n+\t      REAL_VALUE_TYPE r;\n+\t      long l[3];\n+\n+\t      REAL_VALUE_FROM_CONST_DOUBLE (r, operand);\n+\t      switch (mode)\n+\t\t{\n+\t\tcase XFmode:\n+\t\t  REAL_VALUE_TO_TARGET_LONG_DOUBLE (r, l);\n+\t\t  parts[2] = GEN_INT (l[2]);\n+\t\t  break;\n+\t\tcase DFmode:\n+\t\t  REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  abort ();\n+\t\t}\n+\t      parts[1] = GEN_INT (l[1]);\n+\t      parts[0] = GEN_INT (l[0]);\n+\t    }\n+\t  else\n+\t    abort ();\n \t}\n-      else\n+    }\n+\n+  return;\n+}\n+\n+/* Emit insns to perform a move or push of DI, DF, and XF values.\n+   Return false when normal moves are needed; true when all required\n+   insns have been emitted.  Operands 2-4 contain the input values\n+   int the correct order; operands 5-7 contain the output values.  */\n+\n+int \n+ix86_split_long_move (operands1)\n+     rtx operands1[];\n+{\n+  rtx part[2][3];\n+  rtx operands[2];\n+  int size = GET_MODE_SIZE (GET_MODE (operands1[0])) / 4;\n+  int push = 0;\n+  int collisions = 0;\n+\n+  /* Make our own copy to avoid clobbering the operands.  */\n+  operands[0] = copy_rtx (operands1[0]);\n+  operands[1] = copy_rtx (operands1[1]);\n+\n+  if (size < 2 || size > 3)\n+    abort ();\n+\n+  /* The only non-offsettable memory we handle is push.  */\n+  if (push_operand (operands[0], VOIDmode))\n+    push = 1;\n+  else if (GET_CODE (operands[0]) == MEM\n+\t   && ! offsettable_memref_p (operands[0]))\n+    abort ();\n+\n+  ix86_split_to_parts (operands[0], part[0], GET_MODE (operands1[0]));\n+  ix86_split_to_parts (operands[1], part[1], GET_MODE (operands1[0]));\n+\n+  /* When emitting push, take care for source operands on the stack.  */\n+  if (push && GET_CODE (operands[1]) == MEM\n+      && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))\n+    {\n+      if (size == 3)\n+\tpart[1][1] = part[1][2];\n+      part[1][0] = part[1][1];\n+    }\n+\n+  /* We need to do copy in the right order in case an address register \n+     of the source overlaps the destination.  */\n+  if (REG_P (part[0][0]) && GET_CODE (part[1][0]) == MEM)\n+    {\n+      if (reg_overlap_mentioned_p (part[0][0], XEXP (part[1][0], 0)))\n+\tcollisions++;\n+      if (reg_overlap_mentioned_p (part[0][1], XEXP (part[1][0], 0)))\n+\tcollisions++;\n+      if (size == 3\n+\t  && reg_overlap_mentioned_p (part[0][2], XEXP (part[1][0], 0)))\n+\tcollisions++;\n+\n+      /* Collision in the middle part can be handled by reordering.  */\n+      if (collisions == 1 && size == 3\n+\t  && reg_overlap_mentioned_p (part[0][1], XEXP (part[1][0], 0)))\n \t{\n-\t  emit_insn (gen_push (operands[4]));\n-\t  emit_insn (gen_rtx_SET (VOIDmode, operands[3], operands[5]));\n-\t  emit_insn (gen_popsi1 (operands[2]));\n+\t  rtx tmp;\n+\t  tmp = part[0][1]; part[0][1] = part[0][2]; part[0][2] = tmp;\n+\t  tmp = part[1][1]; part[1][1] = part[1][2]; part[1][2] = tmp;\n+\t}\n \n-\t  return 1; /* DONE */\n+      /* If there are more collisions, we can't handle it by reordering.\n+\t Do an lea to the last part and use only one colliding move.  */\n+      else if (collisions > 1)\n+\t{\n+\t  collisions = 1;\n+\t  emit_insn (gen_rtx_SET (VOIDmode, part[0][size - 1],\n+\t\t\t\t  XEXP (part[1][0], 0)));\n+\t  part[1][0] = change_address (part[1][0], SImode, part[0][size - 1]);\n+\t  part[1][1] = adj_offsettable_operand (part[1][0], 4);\n+\t  if (size == 3)\n+\t    part[1][2] = adj_offsettable_operand (part[1][0], 8);\n+\t}\n+    }\n+\n+  if (push)\n+    {\n+      if (size == 3)\n+\temit_insn (gen_push (part[1][2]));\n+      emit_insn (gen_push (part[1][1]));\n+      emit_insn (gen_push (part[1][0]));\n+      return 1;\n+    }\n+\n+  /* Choose correct order to not overwrite the source before it is copied.  */\n+  if ((REG_P (part[0][0])\n+       && REG_P (part[1][1])\n+       && (REGNO (part[0][0]) == REGNO (part[1][1])\n+\t   || (size == 3\n+\t       && REGNO (part[0][0]) == REGNO (part[1][2]))))\n+      || (collisions > 0\n+\t  && reg_overlap_mentioned_p (part[0][0], XEXP (part[1][0], 0))))\n+    {\n+      if (size == 3)\n+\t{\n+\t  operands1[2] = part[0][2];\n+\t  operands1[3] = part[0][1];\n+\t  operands1[4] = part[0][0];\n+\t  operands1[5] = part[1][2];\n+\t  operands1[6] = part[1][1];\n+\t  operands1[7] = part[1][0];\n+\t}\n+      else\n+\t{\n+\t  operands1[2] = part[0][1];\n+\t  operands1[3] = part[0][0];\n+\t  operands1[5] = part[1][1];\n+\t  operands1[6] = part[1][0];\n+\t}\n+    }\n+  else\n+    {\n+      if (size == 3)\n+\t{\n+\t  operands1[2] = part[0][0];\n+\t  operands1[3] = part[0][1];\n+\t  operands1[4] = part[0][2];\n+\t  operands1[5] = part[1][0];\n+\t  operands1[6] = part[1][1];\n+\t  operands1[7] = part[1][2];\n+\t}\n+      else\n+\t{\n+\t  operands1[2] = part[0][0];\n+\t  operands1[3] = part[0][1];\n+\t  operands1[5] = part[1][0];\n+\t  operands1[6] = part[1][1];\n \t}\n     }\n "}, {"sha": "eb082278d7e1ec306a6c7cdf1708bbb1dcd65c82", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 38, "deletions": 48, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2450a057297b5bf665b98e9594ac6799c8a7e5fb/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2450a057297b5bf665b98e9594ac6799c8a7e5fb/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=2450a057297b5bf665b98e9594ac6799c8a7e5fb", "patch": "@@ -1665,37 +1665,29 @@\n (define_split\n   [(set (match_operand:DI 0 \"push_operand\" \"\")\n         (match_operand:DI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  [(set (mem:SI (pre_dec:SI (reg:SI 7))) (match_dup 3))\n-   (set (mem:SI (pre_dec:SI (reg:SI 7))) (match_dup 2))]\n-  \"\n-{\n-  split_di (operands+1, 1, operands+2, operands+3);\n-  /* Compensate for the fact that we're changing stack offsets in\n-     the middle of this operation.  */\n-  if (reg_mentioned_p (stack_pointer_rtx, operands[2]))\n-    operands[2] = adj_offsettable_operand (operands[2], 4);\n-}\")\n+  \"reload_completed\"\n+  [(const_int 0)]\n+  \"if (!ix86_split_long_move (operands)) abort (); DONE;\")\n \n ;; %%% This multiword shite has got to go.\n (define_split\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DI 1 \"general_operand\" \"\"))\n    (clobber (reg:CC 17))]\n   \"reload_completed\"\n-  [(parallel [(set (match_dup 2) (match_dup 4))\n+  [(parallel [(set (match_dup 2) (match_dup 5))\n \t      (clobber (reg:CC 17))])\n-   (parallel [(set (match_dup 3) (match_dup 5))\n+   (parallel [(set (match_dup 3) (match_dup 6))\n \t      (clobber (reg:CC 17))])]\n-  \"if (ix86_split_movdi (operands)) DONE;\")\n+  \"if (ix86_split_long_move (operands)) DONE;\")\n   \n (define_split\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DI 1 \"general_operand\" \"\"))]\n   \"reload_completed\"\n-  [(set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (match_dup 5))]\n-  \"if (ix86_split_movdi (operands)) DONE;\")\n+  [(set (match_dup 2) (match_dup 5))\n+   (set (match_dup 3) (match_dup 6))]\n+  \"if (ix86_split_long_move (operands)) DONE;\")\n   \n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"general_operand\" \"\")\n@@ -1740,7 +1732,7 @@\n \n (define_insn \"*movsf_1\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,m,f,*r,m,*r\")\n-\t(match_operand:SF 1 \"general_operand\" \"fm,f,G,*rm,*r,G\"))]\n+\t(match_operand:SF 1 \"general_operand\" \"fm,f,G,*rm,F*r,GF\"))]\n   \"\"\n   \"*\n {\n@@ -1843,20 +1835,12 @@\n   [(set (match_operand:DF 0 \"push_operand\" \"\")\n \t(match_operand:DF 1 \"general_operand\" \"\"))]\n   \"reload_completed\"\n-  [(set (mem:SI (pre_dec:SI (reg:SI 7))) (match_dup 1))\n-   (set (mem:SI (pre_dec:SI (reg:SI 7))) (match_dup 0))]\n-  \"\n-{\n-  split_di (operands+1, 1, operands+0, operands+1);\n-  /* Compensate for the fact that we're changing stack offsets in\n-     the middle of this operation.  */\n-  if (reg_mentioned_p (stack_pointer_rtx, operands[0]))\n-    operands[0] = adj_offsettable_operand (operands[0], 4);\n-}\")\n+  [(const_int 0)]\n+  \"if (!ix86_split_long_move (operands)) abort (); DONE;\")\n \n (define_insn \"*movdf_1\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,m,f,*&r,m,*r\")\n-\t(match_operand:DF 1 \"general_operand\" \"fm,f,G,*rm,*r,G\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,m,f,*r,o\")\n+\t(match_operand:DF 1 \"general_operand\" \"fm,f,G,*roF,F*r\"))]\n   \"\"\n   \"*\n {\n@@ -1889,14 +1873,13 @@\n \n     case 3:\n     case 4:\n-    case 5:\n       return \\\"#\\\";\n \n     default:\n       abort();\n     }\n }\"\n-  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi,multi\")])\n+  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")])\n \n (define_split\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n@@ -1909,10 +1892,9 @@\n    && ! (FP_REG_P (operands[1]) || \n \t (GET_CODE (operands[1]) == SUBREG\n \t  && FP_REG_P (SUBREG_REG (operands[1]))))\"\n-  [(set (match_dup 0) (match_dup 2))\n-   (set (match_dup 1) (match_dup 3))]\n-  \"split_di (operands+1, 1, operands+2, operands+3);\n-   split_di (operands+0, 1, operands+0, operands+1);\")\n+  [(set (match_dup 2) (match_dup 5))\n+   (set (match_dup 3) (match_dup 6))]\n+  \"if (ix86_split_long_move (operands)) DONE;\")\n \n (define_insn \"swapdf\"\n   [(set (match_operand:DF 0 \"register_operand\" \"+f\")\n@@ -1936,8 +1918,8 @@\n   \"ix86_expand_move (XFmode, operands); DONE;\")\n \n (define_insn \"*pushxf\"\n-  [(set (match_operand:XF 0 \"push_operand\" \"=<\")\n-\t(match_operand:XF 1 \"register_operand\" \"f\"))]\n+  [(set (match_operand:XF 0 \"push_operand\" \"=<,<\")\n+\t(match_operand:XF 1 \"register_operand\" \"f,oF*r\"))]\n   \"\"\n   \"*\n {\n@@ -1952,6 +1934,14 @@\n }\"\n   [(set_attr \"type\" \"multi\")])\n \n+(define_split\n+  [(set (match_operand:XF 0 \"push_operand\" \"\")\n+\t(match_operand:XF 1 \"general_operand\" \"\"))]\n+  \"reload_completed\n+   && (!REG_P (operands[1]) || !FP_REGNO_P (REGNO (operands[1])))\"\n+  [(const_int 0)]\n+  \"if (!ix86_split_long_move (operands)) abort (); DONE;\")\n+\n (define_split\n   [(set (match_operand:XF 0 \"push_operand\" \"\")\n \t(match_operand:XF 1 \"register_operand\" \"\"))]\n@@ -1980,8 +1970,8 @@\n }\")\n \n (define_insn \"*movxf_1\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,*&r,o\")\n-\t(match_operand:XF 1 \"general_operand\" \"fm,f,G,*ro,*r\"))]\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,*r,o\")\n+\t(match_operand:XF 1 \"general_operand\" \"fm,f,G,*roF,*r\"))]\n   \"\"\n   \"*\n {\n@@ -2023,14 +2013,14 @@\n \n (define_split\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:XF 1 \"nonimmediate_operand\" \"\"))]\n-  \"(REG_P (operands[0]) && ! FP_REGNO_P (REGNO (operands[0])))\n-   || (REG_P (operands[1]) && ! FP_REGNO_P (REGNO (operands[1])))\"\n-  [(set (match_dup 0) (match_dup 3))\n-   (set (match_dup 1) (match_dup 4))\n-   (set (match_dup 2) (match_dup 5))]\n-  \"split_xf (operands[1], &operands[3]);\n-   split_xf (operands[0], &operands[0]);\")\n+\t(match_operand:XF 1 \"general_operand\" \"\"))]\n+  \"reload_completed\n+   && ((REG_P (operands[0]) && ! FP_REGNO_P (REGNO (operands[0])))\n+        || (REG_P (operands[1]) && ! FP_REGNO_P (REGNO (operands[1]))))\"\n+  [(set (match_dup 2) (match_dup 5))\n+   (set (match_dup 3) (match_dup 6))\n+   (set (match_dup 4) (match_dup 7))]\n+  \"if (ix86_split_long_move (operands)) DONE;\")\n \n (define_insn \"swapxf\"\n   [(set (match_operand:XF 0 \"register_operand\" \"+f\")"}]}