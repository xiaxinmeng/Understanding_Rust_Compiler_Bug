{"sha": "147255d877091f864506da47ae1ff766725bfe06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ3MjU1ZDg3NzA5MWY4NjQ1MDZkYTQ3YWUxZmY3NjY3MjViZmUwNg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-01-13T23:51:01Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-01-13T23:51:01Z"}, "message": "(dfhigh, dflow, sfhigh, sflow): New variables.\n\n(mips_sw_reg_names): Consistently use $ as name prefix.\n(large_int): Handle 64 bit constants.\n(reg_or_0_operand, mips_const_double_ok): Don't examine\nCONST_DOUBLE internals.\n(mips_const_double_ok): Use REAL_VALUE_* macros.\n(simple_memory_operand): Add 64 bit support.  Only test\nTARGET_GP_OPT to determine if doing gp optimizations.  Pass\naddress not MEM to eliminate_constant_term.  Use SMALL_INT.\n(mips_fill_delay_slot): Add 64 bit support.\n(mips_move_1word): Add 64 bit support.  Don't examine CONST_DOUBLE\ninternals.\n(mips_move_2words): Likewise.\n(mips_address_cost): Pass address not MEM to\neliminate_constant_term.  Use SMALL_INT.\n(gen_int_relational): New variable mode.  Add 64 bit support.\n(gen_conditional_branch): Add 64 bit support.\n(block_move_load_store, block_move_loop, block_move_call,\nexpand_block_move, output_block_move, function_arg_advance,\nfunction_arg, function_arg_partial_nregs): Likewise.\n(override_options): Clear MASK_GPOPT if threshold is zero or\nnegative.  Set MASK_GPOPT if optimizing.  Set mips_isa from -misa=\noption, else from MIPS_ISA_DEFAULT if defined, else to 1.  Make\ndefault cpu depend on isa.  Add cpus r4400, r4600, orion.  Rewrite\nTARGET_NAME_REGS support.  Initialize dfhigh, dflow, sfhigh,\nsflow.  Add 64 bit support.\n(print_operand): Use REAL_VALUE_* macros.\n(mips_output_external): Don't depend on mips_section_threshold.\n(make_temp_file): Define P_tmpdir when __MSDOS__.  Malloc filename\nstring.  Don't unlink temp file when __MSDOS__.\n(mips_asm_file_start): Delete TARGET_NAME_REGS support.\n(mips_asm_file_end): Unlike temp file when __MSDOS__.\n(mips_declare_object): Don't test mips_sections_threshold.\n(compute_frame_size, save_restore_insns, function_prologue,\nmips_expand_prologue, function_epilogue, mips_expand_epilogue):\nAdd 64 bit support.\n(function_epilogue): Correctly output `#' before .set volatile.\n\nFrom-SVN: r6391", "tree": {"sha": "82655535f8608c1d2c14cdc6f6a731061b936a8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82655535f8608c1d2c14cdc6f6a731061b936a8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/147255d877091f864506da47ae1ff766725bfe06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/147255d877091f864506da47ae1ff766725bfe06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/147255d877091f864506da47ae1ff766725bfe06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/147255d877091f864506da47ae1ff766725bfe06/comments", "author": null, "committer": null, "parents": [{"sha": "284f1f5a9c896e139490964a2d3696ff907b29d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/284f1f5a9c896e139490964a2d3696ff907b29d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/284f1f5a9c896e139490964a2d3696ff907b29d3"}], "stats": {"total": 839, "additions": 606, "deletions": 233}, "files": [{"sha": "04097ef40f5356b7bbebb3ec501733a4cbb0f20e", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 606, "deletions": 233, "changes": 839, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/147255d877091f864506da47ae1ff766725bfe06/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/147255d877091f864506da47ae1ff766725bfe06/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=147255d877091f864506da47ae1ff766725bfe06", "patch": "@@ -1,7 +1,9 @@\n /* Subroutines for insn-output.c for MIPS\n    Contributed by A. Lichnewsky, lich@inria.inria.fr.\n    Changes by     Michael Meissner, meissner@osf.org.\n-   Copyright (C) 1989, 1990, 1991 Free Software Foundation, Inc.\n+   64 bit r4000 support by Ian Lance Taylor, ian@cygnus.com, and\n+   Brendan Eich, brendan@microunity.com.\n+   Copyright (C) 1989, 1990, 1991, 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -19,6 +21,10 @@ You should have received a copy of the GNU General Public License\n along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n+/* ??? The TARGET_FP_CALL_32 macros are intended to simulate a 32 bit\n+   calling convention in 64 bit mode.  It doesn't work though, and should\n+   be replaced with something better designed.  */\n+\n #include \"config.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n@@ -193,6 +199,11 @@ char *mips_isa_string;\t\t/* for -mips{1,2,3} */\n /* Generating calls to position independent functions?  */\n enum mips_abicalls_type mips_abicalls;\n \n+/* High and low marks for floating point values which we will accept\n+   as legitimate constants for LEGITIMATE_CONSTANT_P.  These are\n+   initialized in override_options.  */\n+REAL_VALUE_TYPE dfhigh, dflow, sfhigh, sflow;\n+\n /* Array to RTX class classification.  At present, we care about\n    whether the operator is an add-type operator, or a divide/modulus,\n    and if divide/modulus, whether it is unsigned.  This is for the\n@@ -244,10 +255,10 @@ char mips_reg_names[][8] =\n \n char mips_sw_reg_names[][8] =\n {\n-  \"$0\",   \"at\",   \"v0\",   \"v1\",   \"a0\",   \"a1\",   \"a2\",   \"a3\",\n-  \"t0\",   \"t1\",   \"t2\",   \"t3\",   \"t4\",   \"t5\",   \"t6\",   \"t7\",\n-  \"s0\",   \"s1\",   \"s2\",   \"s3\",   \"s4\",   \"s5\",   \"s6\",   \"s7\",\n-  \"t8\",   \"t9\",   \"k0\",   \"k1\",   \"gp\",   \"sp\",   \"$fp\",   \"ra\",\n+  \"$zero\",\"$at\",  \"$v0\",  \"$v1\",  \"$a0\",  \"$a1\",  \"$a2\",  \"$a3\",\n+  \"$t0\",  \"$t1\",  \"$t2\",  \"$t3\",  \"$t4\",  \"$t5\",  \"$t6\",  \"$t7\",\n+  \"$s0\",  \"$s1\",  \"$s2\",  \"$s3\",  \"$s4\",  \"$s5\",  \"$s6\",  \"$s7\",\n+  \"$t8\",  \"$t9\",  \"$k0\",  \"$k1\",  \"$gp\",  \"$sp\",  \"$fp\",  \"$ra\",\n   \"$f0\",  \"$f1\",  \"$f2\",  \"$f3\",  \"$f4\",  \"$f5\",  \"$f6\",  \"$f7\",\n   \"$f8\",  \"$f9\",  \"$f10\", \"$f11\", \"$f12\", \"$f13\", \"$f14\", \"$f15\",\n   \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\n@@ -419,7 +430,9 @@ large_int (op, mode)\n   if (((unsigned long)(value + 32768)) <= 32767)\t/* subu reg,$r0,value */\n     return FALSE;\n \n-  if ((value & 0xffff0000) == value)\t\t\t/* lui reg,value>>16 */\n+  if ((value & 0x0000ffff) == 0\t\t\t\t/* lui reg,value>>16 */\n+      && ((value & ~2147483647) == 0\t\t\t/* signed value */\n+\t  || (value & ~2147483647) == ~2147483647))\n     return FALSE;\n \n   return TRUE;\n@@ -441,7 +454,7 @@ reg_or_0_operand (op, mode)\n       return (INTVAL (op) == 0);\n \n     case CONST_DOUBLE:\n-      if (CONST_DOUBLE_HIGH (op) != 0 || CONST_DOUBLE_LOW (op) != 0)\n+      if (op != CONST0_RTX (mode))\n \treturn FALSE;\n \n       return TRUE;\n@@ -493,35 +506,34 @@ mips_const_double_ok (op, mode)\n   if (mode != SFmode && mode != DFmode)\n     return FALSE;\n \n-  if (CONST_DOUBLE_HIGH (op) == 0 && CONST_DOUBLE_LOW (op) == 0)\n+  if (op == CONST0_RTX (mode))\n     return TRUE;\n \n-#if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n   if (TARGET_MIPS_AS)\t\t/* gas doesn't like li.d/li.s yet */\n     {\n-      union { double d; int i[2]; } u;\n-      double d;\n-\n-      u.i[0] = CONST_DOUBLE_LOW (op);\n-      u.i[1] = CONST_DOUBLE_HIGH (op);\n-      d = u.d;\n-\n-      if (d != d)\n-\treturn FALSE;\t\t/* NAN */\n+      REAL_VALUE_TYPE d;\n \n-      if (d < 0.0)\n-\td = - d;\n+      REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n \n-      /* Rather than trying to get the accuracy down to the last bit,\n-\t just use approximate ranges.  */\n+      if (REAL_VALUE_ISNAN (d))\n+\treturn FALSE;\n \n-      if (mode == DFmode && d > 1.0e-300 && d < 1.0e300)\n-\treturn TRUE;\n+      if (REAL_VALUE_NEGATIVE (d))\n+\td = REAL_VALUE_NEGATE (d);\n \n-      if (mode == SFmode && d > 1.0e-38 && d < 1.0e+38)\n-\treturn TRUE;\n+      if (mode == DFmode)\n+\t{\n+\t  if (REAL_VALUES_LESS (d, dfhigh)\n+\t      && REAL_VALUES_LESS (dflow, d))\n+\t    return TRUE;\n+\t}\n+      else\n+\t{\n+\t  if (REAL_VALUES_LESS (d, sfhigh)\n+\t      && REAL_VALUES_LESS (sflow, d))\n+\t    return TRUE;\n+\t}\n     }\n-#endif\n \n   return FALSE;\n }\n@@ -541,7 +553,7 @@ simple_memory_operand (op, mode)\n     return FALSE;\n \n   /* dword operations really put out 2 instructions, so eliminate them.  */\n-  if (GET_MODE_SIZE (GET_MODE (op)) > (HAVE_64BIT_P () ? 8 : 4))\n+  if (GET_MODE_SIZE (GET_MODE (op)) > UNITS_PER_WORD)\n     return FALSE;\n \n   /* Decode the address now.  */\n@@ -585,17 +597,17 @@ simple_memory_operand (op, mode)\n     case CONST:\n       /* If -G 0, we can never have a GP relative memory operation.\n \t Also, save some time if not optimizing.  */\n-      if (mips_section_threshold == 0 || !optimize || !TARGET_GP_OPT)\n+      if (!TARGET_GP_OPT)\n \treturn FALSE;\n \n       {\n \trtx offset = const0_rtx;\n-\taddr = eliminate_constant_term (addr, &offset);\n+\taddr = eliminate_constant_term (XEXP (addr, 0), &offset);\n \tif (GET_CODE (op) != SYMBOL_REF)\n \t  return FALSE;\n \n \t/* let's be paranoid.... */\n-\tif (INTVAL (offset) < 0 || INTVAL (offset) > 0xffff)\n+\tif (! SMALL_INT (offset))\n \t  return FALSE;\n       }\n       /* fall through */\n@@ -778,10 +790,12 @@ mips_fill_delay_slot (ret, type, operands, cur_insn)\n \n   mode = GET_MODE (set_reg);\n   dslots_number_nops = num_nops;\n-  mips_load_reg  = set_reg;\n-  mips_load_reg2 = (mode == DImode || mode == DFmode)\n-\t\t\t? gen_rtx (REG, SImode, REGNO (set_reg) + 1)\n-\t\t\t: (rtx)0;\n+  mips_load_reg = set_reg;\n+  if (GET_MODE_SIZE (mode)\n+      > (FP_REG_P (set_reg) ? UNITS_PER_FPREG : UNITS_PER_WORD))\n+    mips_load_reg2 = gen_rtx (REG, SImode, REGNO (set_reg) + 1);\n+  else\n+    mips_load_reg2 = 0;\n \n   if (type == DELAY_HILO)\n     {\n@@ -1028,11 +1042,22 @@ mips_move_1word (operands, insn, unsignedp)\n \t\t target, so zero/sign extend can use this code as well.  */\n \t      switch (GET_MODE (op1))\n \t\t{\n-\t\tdefault:\t\t\t\t\t\t\tbreak;\n-\t\tcase SFmode: ret = \"lw\\t%0,%1\";\t\t\t\t\tbreak;\n-\t\tcase SImode: ret = \"lw\\t%0,%1\";\t\t\t\t\tbreak;\n-\t\tcase HImode: ret = (unsignedp) ? \"lhu\\t%0,%1\" : \"lh\\t%0,%1\";\tbreak;\n-\t\tcase QImode: ret = (unsignedp) ? \"lbu\\t%0,%1\" : \"lb\\t%0,%1\";\tbreak;\n+\t\tdefault:\n+\t\t  break;\n+\t\tcase SFmode:\n+\t\t  ret = \"lw\\t%0,%1\";\n+\t\t  break;\n+\t\tcase SImode:\n+\t\t  ret = ((unsignedp && TARGET_64BIT)\n+\t\t\t ? \"lwu\\t%0,%1\"\n+\t\t\t : \"lw\\t%0,%1\");\n+\t\t  break;\n+\t\tcase HImode:\n+\t\t  ret = (unsignedp) ? \"lhu\\t%0,%1\" : \"lh\\t%0,%1\";\n+\t\t  break;\n+\t\tcase QImode:\n+\t\t  ret = (unsignedp) ? \"lbu\\t%0,%1\" : \"lb\\t%0,%1\";\n+\t\t  break;\n \t\t}\n \t    }\n \n@@ -1070,7 +1095,7 @@ mips_move_1word (operands, insn, unsignedp)\n \n       else if (code1 == CONST_DOUBLE && mode == SFmode)\n \t{\n-\t  if (CONST_DOUBLE_HIGH (op1) == 0 && CONST_DOUBLE_LOW (op1) == 0)\n+\t  if (op1 == CONST0_RTX (SFmode))\n \t    {\n \t      if (GP_REG_P (regno0))\n \t\tret = \"move\\t%0,%.\";\n@@ -1116,15 +1141,22 @@ mips_move_1word (operands, insn, unsignedp)\n \t\t  if (INTVAL (offset) == 0)\n \t\t    {\n \t\t      delay = DELAY_LOAD;\n-\t\t      ret = \"lw\\t%0,%2\";\n+\t\t      ret = (unsignedp && TARGET_64BIT\n+\t\t\t     ? \"lwu\\t%0,%2\"\n+\t\t\t     : \"lw\\t%0,%2\");\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      dslots_load_total++;\n \t\t      operands[3] = offset;\n-\t\t      ret = (SMALL_INT (offset))\n-\t\t\t\t? \"lw\\t%0,%2%#\\n\\tadd\\t%0,%0,%3\"\n-\t\t\t\t: \"lw\\t%0,%2%#\\n\\t%[li\\t%@,%3\\n\\tadd\\t%0,%0,%@%]\";\n+\t\t      if (unsignedp && TARGET_64BIT)\n+\t\t\tret = (SMALL_INT (offset))\n+\t\t\t\t  ? \"lwu\\t%0,%2%#\\n\\tadd\\t%0,%0,%3\"\n+\t\t\t\t  : \"lwu\\t%0,%2%#\\n\\t%[li\\t%@,%3\\n\\tadd\\t%0,%0,%@%]\";\n+\t\t      else\n+\t\t\tret = (SMALL_INT (offset))\n+\t\t\t\t  ? \"lw\\t%0,%2%#\\n\\tadd\\t%0,%0,%3\"\n+\t\t\t\t  : \"lw\\t%0,%2%#\\n\\t%[li\\t%@,%3\\n\\tadd\\t%0,%0,%@%]\";\n \t\t    }\n \t\t}\n \t    }\n@@ -1191,7 +1223,7 @@ mips_move_1word (operands, insn, unsignedp)\n \t    }\n \t}\n \n-      else if (code1 == CONST_DOUBLE && CONST_DOUBLE_HIGH (op1) == 0 && CONST_DOUBLE_LOW (op1) == 0)\n+      else if (code1 == CONST_DOUBLE && op1 == CONST0_RTX (mode))\n \t{\n \t  switch (mode)\n \t    {\n@@ -1278,32 +1310,57 @@ mips_move_2words (operands, insn)\n \t      else\n \t\t{\n \t\t  delay = DELAY_LOAD;\n-\t\t  ret = (TARGET_FLOAT64)\n-\t\t\t\t? \"dmtc1\\t%1,%0\"\n-\t\t\t\t: \"mtc1\\t%L1,%0\\n\\tmtc1\\t%M1,%D0\";\n+\t\t  if (TARGET_64BIT)\n+\t\t    {\n+#ifdef TARGET_FP_CALL_32\n+\t\t      if (FP_CALL_GP_REG_P (regno1))\n+\t\t\tret = \"dsll\\t%1,32\\n\\tor\\t%1,%D1\\n\\tdmtc1\\t%1,%0\";\n+\t\t      else\n+#endif\n+\t\t\tret = \"dmtc1\\t%1,%0\";\n+\t\t    }\n+\t\t  else\n+\t\t    ret = \"mtc1\\t%L1,%0\\n\\tmtc1\\t%M1,%D0\";\n \t\t}\n \t    }\n \n \t  else if (FP_REG_P (regno1))\n \t    {\n \t      delay = DELAY_LOAD;\n-\t      ret = (TARGET_FLOAT64)\n-\t\t\t? \"dmfc1\\t%0,%1\"\n-\t\t\t: \"mfc1\\t%L0,%1\\n\\tmfc1\\t%M0,%D1\";\n+\t      if (TARGET_64BIT)\n+\t\t{\n+#ifdef TARGET_FP_CALL_32\n+\t\t  if (FP_CALL_GP_REG_P (regno0))\n+\t\t    ret = \"dmfc1\\t%0,%1\\n\\tmfc1\\t%D0,%1\\n\\tdsrl\\t%0,32\";\n+\t\t  else\n+#endif\n+\t\t    ret = \"dmfc1\\t%0,%1\";\n+\t\t}\n+\t      else\n+\t\tret = \"mfc1\\t%L0,%1\\n\\tmfc1\\t%M0,%D1\";\n \t    }\n \n \t  else if (MD_REG_P (regno0) && GP_REG_P (regno1))\n \t    {\n \t      delay = DELAY_HILO;\n-\t      ret = \"mthi\\t%M1\\n\\tmtlo\\t%L1\";\n+\t      if (TARGET_64BIT)\n+\t\tret = \"mt%0\\t%1\";\n+\t      else\n+\t\tret = \"mthi\\t%M1\\n\\tmtlo\\t%L1\";\n \t    }\n \n \t  else if (GP_REG_P (regno0) && MD_REG_P (regno1))\n \t    {\n \t      delay = DELAY_HILO;\n-\t      ret = \"mfhi\\t%M0\\n\\tmflo\\t%L0\";\n+\t      if (TARGET_64BIT)\n+\t\tret = \"mf%1\\t%0\";\n+\t      else\n+\t\tret = \"mfhi\\t%M0\\n\\tmflo\\t%L0\";\n \t    }\n \n+\t  else if (TARGET_64BIT)\n+\t    ret = \"move\\t%0,%1\";\n+\n \t  else if (regno0 != (regno1+1))\n \t    ret = \"move\\t%0,%1\\n\\tmove\\t%D0,%D1\";\n \n@@ -1313,14 +1370,22 @@ mips_move_2words (operands, insn)\n \n       else if (code1 == CONST_DOUBLE)\n \t{\n-\t  if (CONST_DOUBLE_HIGH (op1) != 0 || CONST_DOUBLE_LOW (op1) != 0)\n+\t  if (op1 != CONST0_RTX (GET_MODE (op1)))\n \t    {\n \t      if (GET_MODE (op1) == DFmode)\n \t\t{\n \t\t  delay = DELAY_LOAD;\n-\t\t  ret = \"li.d\\t%0,%1\";\n+#ifdef TARGET_FP_CALL_32\n+\t\t  if (FP_CALL_GP_REG_P (regno0))\n+\t\t    ret = \"li.d\\t%0,%1\\n\\tdsll\\t%D0,%0,32\\n\\tdsrl\\t%D0,32\\n\\tdsrl\\t%0,32\";\n+\t\t  else\n+#endif\n+\t\t    ret = \"li.d\\t%0,%1\";\n \t\t}\n \n+\t      else if (TARGET_64BIT)\n+\t\tret = \"li\\t%0,%1\";\n+\n \t      else\n \t\t{\n \t\t  operands[2] = GEN_INT (CONST_DOUBLE_LOW (op1));\n@@ -1332,12 +1397,18 @@ mips_move_2words (operands, insn)\n \t  else\n \t    {\n \t      if (GP_REG_P (regno0))\n-\t\tret = \"move\\t%0,%.\\n\\tmove\\t%D0,%.\";\n+\t\tret = (TARGET_64BIT\n+#ifdef TARGET_FP_CALL_32\n+\t\t       && ! FP_CALL_GP_REG_P (regno0)\n+#endif\n+\t\t       )\n+\t\t  ? \"move\\t%0,%.\"\n+\t\t    : \"move\\t%0,%.\\n\\tmove\\t%D0,%.\";\n \n \t      else if (FP_REG_P (regno0))\n \t\t{\n \t\t  delay = DELAY_LOAD;\n-\t\t  ret = (TARGET_FLOAT64)\n+\t\t  ret = (TARGET_64BIT)\n \t\t\t\t? \"dmtc1\\t%.,%0\"\n \t\t\t\t: \"mtc1\\t%.,%0\\n\\tmtc1\\t%.,%D0\";\n \t\t}\n@@ -1347,21 +1418,28 @@ mips_move_2words (operands, insn)\n       else if (code1 == CONST_INT && INTVAL (op1) == 0)\n \t{\n \t  if (GP_REG_P (regno0))\n-\t    ret = \"move\\t%0,%.\\n\\tmove\\t%D0,%.\";\n+\t    ret = (TARGET_64BIT)\n+\t                        ? \"move\\t%0,%.\"\n+\t\t\t\t: \"move\\t%0,%.\\n\\tmove\\t%D0,%.\";\n \t  \n \t  else if (FP_REG_P (regno0))\n \t    {\n \t      delay = DELAY_LOAD;\n-\t      ret = (TARGET_FLOAT64)\n+\t      ret = (TARGET_64BIT)\n \t\t\t\t? \"dmtc1\\t%.,%0\"\n \t\t\t\t: \"mtc1\\t%.,%0\\n\\tmtc1\\t%.,%D0\";\n \t    }\n \t}\n \t\n       else if (code1 == CONST_INT && GET_MODE (op0) == DImode && GP_REG_P (regno0))\n \t{\n-\t  operands[2] = GEN_INT (INTVAL (operands[1]) >= 0 ? 0 : -1);\n-\t  ret = \"li\\t%M0,%2\\n\\tli\\t%L0,%1\";\n+\t  if (TARGET_64BIT)\n+\t    ret = \"li\\t%0,%1\";\n+\t  else\n+\t    {\n+\t      operands[2] = GEN_INT (INTVAL (operands[1]) >= 0 ? 0 : -1);\n+\t      ret = \"li\\t%M0,%2\\n\\tli\\t%L0,%1\";\n+\t    }\n \t}\n \n       else if (code1 == MEM)\n@@ -1374,6 +1452,21 @@ mips_move_2words (operands, insn)\n \t  if (FP_REG_P (regno0))\n \t    ret = \"l.d\\t%0,%1\";\n \n+\t  else if (TARGET_64BIT)\n+\t    {\n+#ifdef TARGET_FP_CALL_32\n+\t      if (FP_CALL_GP_REG_P (regno0))\n+\t\t{\n+                  if (offsettable_address_p (FALSE, SImode, op1))\n+                    ret = \"lwu\\t%0,%1\\n\\tlwu\\t%D0,4+%1\";\n+                  else\n+                    ret = \"ld\\t%0,%1\\n\\tdsll\\t%D0,%0,32\\n\\tdsrl\\t%D0,32\\n\\tdsrl\\t%0,32\";\n+\t\t}\n+\t      else\n+#endif\n+\t\tret = \"ld\\t%0,%1\";\n+\t    }\n+\n \t  else if (offsettable_address_p (1, DFmode, XEXP (op1, 0)))\n \t    {\n \t      operands[2] = adj_offsettable_operand (op1, 4);\n@@ -1393,6 +1486,15 @@ mips_move_2words (operands, insn)\n \t      ret = volatile_buffer;\n \t    }\n \t}\n+\n+      else if (code1 == LABEL_REF\n+\t       || code1 == SYMBOL_REF\n+\t       || code1 == CONST)\n+\t{\n+\t  if (! TARGET_64BIT)\n+\t    abort ();\n+\t  return mips_move_1word (operands, insn, 0);\n+\t}\n     }\n \n   else if (code0 == MEM)\n@@ -1404,19 +1506,30 @@ mips_move_2words (operands, insn)\n \t  if (FP_REG_P (regno1))\n \t    ret = \"s.d\\t%1,%0\";\n \n+\t  else if (TARGET_64BIT)\n+\t    {\n+#ifdef TARGET_FP_CALL_32\n+\t      if (FP_CALL_GP_REG_P (regno1))\n+\t\tret = \"dsll\\t%1,32\\n\\tor\\t%1,%D1\\n\\tsd\\t%1,%0\";\n+\t      else\n+#endif\n+\t\tret = \"sd\\t%1,%0\";\n+\t    }\n+\n \t  else if (offsettable_address_p (1, DFmode, XEXP (op0, 0)))\n \t    {\n \t      operands[2] = adj_offsettable_operand (op0, 4);\n \t      ret = \"sw\\t%1,%0\\n\\tsw\\t%D1,%2\";\n \t    }\n \t}\n \n-      else if (code1 == CONST_DOUBLE\n-\t       && CONST_DOUBLE_HIGH (op1) == 0\n-\t       && CONST_DOUBLE_LOW (op1) == 0\n-\t       && offsettable_address_p (1, DFmode, XEXP (op0, 0)))\n+      else if (((code1 == CONST_INT && INTVAL (op1) == 0)\n+\t\t|| (code1 == CONST_DOUBLE\n+\t\t    && op1 == CONST0_RTX (GET_MODE (op1))))\n+\t       && (TARGET_64BIT\n+\t\t   || offsettable_address_p (1, DFmode, XEXP (op0, 0))))\n \t{\n-\t  if (TARGET_FLOAT64)\n+\t  if (TARGET_64BIT)\n \t    ret = \"sd\\t%.,%0\";\n \t  else\n \t    {\n@@ -1474,14 +1587,14 @@ mips_address_cost (addr)\n     case CONST:\n       {\n \trtx offset = const0_rtx;\n-\taddr = eliminate_constant_term (addr, &offset);\n+\taddr = eliminate_constant_term (XEXP (addr, 0), &offset);\n \tif (GET_CODE (addr) == LABEL_REF)\n \t  return 2;\n \n \tif (GET_CODE (addr) != SYMBOL_REF)\n \t  return 4;\n \n-\tif (INTVAL (offset) < -32768 || INTVAL (offset) > 32767)\n+\tif (! SMALL_INT (offset))\n \t  return 2;\n       }\n       /* fall through */\n@@ -1509,10 +1622,7 @@ mips_address_cost (addr)\n \t    break;\n \n \t  case CONST_INT:\n-\t    {\n-\t      int value = INTVAL (plus1);\n-\t      return (value < -32768 || value > 32767) ? 2 : 1;\n-\t    }\n+\t    return (SMALL_INT (plus1) ? 1 : 2);\n \n \t  case CONST:\n \t  case SYMBOL_REF:\n@@ -1557,7 +1667,24 @@ map_test_to_internal_test (test_code)\n \f\n /* Generate the code to compare two integer values.  The return value is:\n    (reg:SI xx)\t\tThe pseudo register the comparison is in\n-   (rtx)0\t       \tNo register, generate a simple branch.  */\n+   (rtx)0\t       \tNo register, generate a simple branch.\n+\n+   ??? This is called with result nonzero by the Scond patterns in\n+   mips.md.  These patterns are called with a target in the mode of\n+   the Scond instruction pattern.  Since this must be a constant, we\n+   must use SImode.  This means that if RESULT is non-zero, it will\n+   always be an SImode register, even if TARGET_64BIT is true.  We\n+   cope with this by calling convert_move rather than emit_move_insn.\n+   This will sometimes lead to an unnecessary extension of the result;\n+   for example:\n+\n+   long long\n+   foo (long long i)\n+   {\n+     return i < 5;\n+   }\n+\n+   */\n \n rtx\n gen_int_relational (test_code, result, cmp0, cmp1, p_invert)\n@@ -1594,6 +1721,7 @@ gen_int_relational (test_code, result, cmp0, cmp1, p_invert)\n   };\n \n   enum internal_test test;\n+  enum machine_mode mode;\n   struct cmp_info *p_info;\n   int branch_p;\n   int eqne_p;\n@@ -1608,6 +1736,10 @@ gen_int_relational (test_code, result, cmp0, cmp1, p_invert)\n   p_info = &info[ (int)test ];\n   eqne_p = (p_info->test_code == XOR);\n \n+  mode = GET_MODE (cmp0);\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (cmp1);\n+\n   /* Eliminate simple branches */\n   branch_p = (result == (rtx)0);\n   if (branch_p)\n@@ -1624,18 +1756,28 @@ gen_int_relational (test_code, result, cmp0, cmp1, p_invert)\n \t}\n \n       /* allocate a pseudo to calculate the value in.  */\n-      result = gen_reg_rtx (SImode);\n+      result = gen_reg_rtx (mode);\n     }\n \n   /* Make sure we can handle any constants given to us.  */\n   if (GET_CODE (cmp0) == CONST_INT)\n-    cmp0 = force_reg (SImode, cmp0);\n+    cmp0 = force_reg (mode, cmp0);\n \n   if (GET_CODE (cmp1) == CONST_INT)\n     {\n       HOST_WIDE_INT value = INTVAL (cmp1);\n-      if (value < p_info->const_low || value > p_info->const_high)\n-\tcmp1 = force_reg (SImode, cmp1);\n+      if (value < p_info->const_low\n+\t  || value > p_info->const_high\n+\t  /* ??? Why?  And why wasn't the similar code below modified too?  */\n+\t  || (TARGET_64BIT\n+\t      && HOST_BITS_PER_WIDE_INT < 64\n+\t      && p_info->const_add != 0\n+\t      && ((p_info->unsignedp\n+\t\t   ? ((unsigned HOST_WIDE_INT) (value + p_info->const_add)\n+\t\t      > INTVAL (cmp1))\n+\t\t   : (value + p_info->const_add) > INTVAL (cmp1))\n+\t\t  != (p_info->const_add > 0))))\n+\tcmp1 = force_reg (mode, cmp1);\n     }\n \n   /* See if we need to invert the result.  */\n@@ -1685,33 +1827,33 @@ gen_int_relational (test_code, result, cmp0, cmp1, p_invert)\n     reg = cmp0;\n   else\n     {\n-      reg = (invert || eqne_p) ? gen_reg_rtx (SImode) : result;\n-      emit_move_insn (reg, gen_rtx (p_info->test_code, SImode, cmp0, cmp1));\n+      reg = (invert || eqne_p) ? gen_reg_rtx (mode) : result;\n+      convert_move (reg, gen_rtx (p_info->test_code, mode, cmp0, cmp1), 0);\n     }\n \n   if (test == ITEST_NE)\n     {\n-      emit_move_insn (result, gen_rtx (GTU, SImode, reg, const0_rtx));\n+      convert_move (result, gen_rtx (GTU, mode, reg, const0_rtx), 0);\n       invert = FALSE;\n     }\n \n   else if (test == ITEST_EQ)\n     {\n-      reg2 = (invert) ? gen_reg_rtx (SImode) : result;\n-      emit_move_insn (reg2, gen_rtx (LTU, SImode, reg, const1_rtx));\n+      reg2 = (invert) ? gen_reg_rtx (mode) : result;\n+      convert_move (reg2, gen_rtx (LTU, mode, reg, const1_rtx), 0);\n       reg = reg2;\n     }\n \n   if (invert)\n-    emit_move_insn (result, gen_rtx (XOR, SImode, reg, const1_rtx));\n+    convert_move (result, gen_rtx (XOR, mode, reg, const1_rtx), 0);\n \n   return result;\n }\n \n \f\n /* Emit the common code for doing conditional branches.\n    operand[0] is the label to jump to.\n-   The comparison operands are saved away by cmp{si,sf,df}.  */\n+   The comparison operands are saved away by cmp{si,di,sf,df}.  */\n \n void\n gen_conditional_branch (operands, test_code)\n@@ -1731,6 +1873,18 @@ gen_conditional_branch (operands, test_code)\n       SImode,\t\t\t/* ltu */\n       SImode,\t\t\t/* leu */\n     },\n+    {\t\t\t\t/* CMP_DI */\n+      DImode,\t\t\t/* eq  */\n+      DImode,\t\t\t/* ne  */\n+      DImode,\t\t\t/* gt  */\n+      DImode,\t\t\t/* ge  */\n+      DImode,\t\t\t/* lt  */\n+      DImode,\t\t\t/* le  */\n+      DImode,\t\t\t/* gtu */\n+      DImode,\t\t\t/* geu */\n+      DImode,\t\t\t/* ltu */\n+      DImode,\t\t\t/* leu */\n+    },\n     {\t\t\t\t/* CMP_SF */\n       CC_FPmode,\t\t/* eq  */\n       CC_REV_FPmode,\t\t/* ne  */\n@@ -1769,7 +1923,7 @@ gen_conditional_branch (operands, test_code)\n \n   if (test == ITEST_MAX)\n     {\n-      mode = SImode;\n+      mode = word_mode;\n       goto fail;\n     }\n \n@@ -1778,12 +1932,13 @@ gen_conditional_branch (operands, test_code)\n   if (mode == VOIDmode)\n     goto fail;\n \n-  switch (branch_type)\n+  switch (type)\n     {\n     default:\n       goto fail;\n \n     case CMP_SI:\n+    case CMP_DI:\n       reg = gen_int_relational (test_code, (rtx)0, cmp0, cmp1, &invert);\n       if (reg != (rtx)0)\n \t{\n@@ -1794,7 +1949,7 @@ gen_conditional_branch (operands, test_code)\n \n       /* Make sure not non-zero constant if ==/!= */\n       else if (GET_CODE (cmp1) == CONST_INT && INTVAL (cmp1) != 0)\n-\tcmp1 = force_reg (SImode, cmp1);\n+\tcmp1 = force_reg (mode, cmp1);\n \n       break;\n \n@@ -1831,12 +1986,14 @@ gen_conditional_branch (operands, test_code)\n }\n \n \f\n-#define UNITS_PER_SHORT (SHORT_TYPE_SIZE / BITS_PER_UNIT)\n-\n+#if 0\n /* Internal code to generate the load and store of one word/short/byte.\n    The load is emitted directly, and the store insn is returned.  */\n \n-#if 0\n+#define UNITS_PER_MIPS_DWORD\t8\n+#define UNITS_PER_MIPS_WORD\t4\n+#define UNITS_PER_MIPS_HWORD\t2\n+\n static rtx\n block_move_load_store (dest_reg, src_reg, p_bytes, p_offset, align, orig_src)\n      rtx src_reg;\t\t/* register holding source memory address */\n@@ -1862,30 +2019,38 @@ block_move_load_store (dest_reg, src_reg, p_bytes, p_offset, align, orig_src)\n   if (bytes <= 0 || align <= 0)\n     abort ();\n \n-  if (bytes >= UNITS_PER_WORD && align >= UNITS_PER_WORD)\n+  if (bytes >= UNITS_PER_MIPS_DWORD && align >= UNIS_PER_MIPS_DWORD)\n+    {\n+      mode = DImode;\n+      size = UNITS_PER_MIPS_DWORD;\n+      load_func = gen_movdi;\n+      store_func = gen_movdi;\n+    }\n+  else if (bytes >= UNITS_PER_MIPS_WORD && align >= UNITS_PER_MIPS_WORD)\n     {\n       mode = SImode;\n-      size = UNITS_PER_WORD;\n+      size = UNITS_PER_MIPS_WORD;\n       load_func = gen_movsi;\n       store_func = gen_movsi;\n     }\n \n #if 0\n   /* Don't generate unaligned moves here, rather defer those to the\n-     general movestrsi_internal pattern.  */\n-  else if (bytes >= UNITS_PER_WORD)\n+     general movestrsi_internal pattern.\n+     If this gets commented back in, then should add the dword equivalent.  */\n+  else if (bytes >= UNITS_PER_MIPS_WORD)\n     {\n       mode = SImode;\n-      size = UNITS_PER_WORD;\n+      size = UNITS_PER_MIPS_WORD;\n       load_func = gen_movsi_ulw;\n       store_func = gen_movsi_usw;\n     }\n #endif\n \n-  else if (bytes >= UNITS_PER_SHORT && align >= UNITS_PER_SHORT)\n+  else if (bytes >= UNITS_PER_MIPS_SHORT && align >= UNITS_PER_MIPS_SHORT)\n     {\n       mode = HImode;\n-      size = UNITS_PER_SHORT;\n+      size = UNITS_PER_MIPS_SHORT;\n       load_func = gen_movhi;\n       store_func = gen_movhi;\n     }\n@@ -2007,6 +2172,8 @@ block_move_sequence (dest_reg, src_reg, bytes, align, orig_src)\n #define MAX_MOVE_REGS 4\n #define MAX_MOVE_BYTES (MAX_MOVE_REGS * UNITS_PER_WORD)\n \n+/* ??? Should add code to use DWORD load/stores.  */\n+\n static void\n block_move_loop (dest_reg, src_reg, bytes, align, orig_src)\n      rtx dest_reg;\t\t/* register holding destination address */\n@@ -2035,19 +2202,41 @@ block_move_loop (dest_reg, src_reg, bytes, align, orig_src)\n \n   if (bytes > 0x7fff)\n     {\n-      emit_insn (gen_movsi (final_src, bytes_rtx));\n-      emit_insn (gen_addsi3 (final_src, final_src, src_reg));\n+      if (TARGET_LONG64)\n+\t{\n+\t  emit_insn (gen_movdi (final_src, bytes_rtx));\n+\t  emit_insn (gen_adddi3 (final_src, final_src, src_reg));\n+\t}\n+      else\n+\t{\n+\t  emit_insn (gen_movsi (final_src, bytes_rtx));\n+\t  emit_insn (gen_addsi3 (final_src, final_src, src_reg));\n+\t}\n     }\n   else\n-    emit_insn (gen_addsi3 (final_src, src_reg, bytes_rtx));\n+    {\n+      if (TARGET_LONG64)\n+\temit_insn (gen_adddi3 (final_src, src_reg, bytes_rtx));\n+      else\n+\temit_insn (gen_addsi3 (final_src, src_reg, bytes_rtx));\n+    }\n \n   emit_label (label);\n \n   bytes_rtx = GEN_INT (MAX_MOVE_BYTES);\n   emit_insn (gen_movstrsi_internal (dest_mem, src_mem, bytes_rtx, align_rtx));\n-  emit_insn (gen_addsi3 (src_reg, src_reg, bytes_rtx));\n-  emit_insn (gen_addsi3 (dest_reg, dest_reg, bytes_rtx));\n-  emit_insn (gen_cmpsi (src_reg, final_src));\n+  if (TARGET_LONG64)\n+    {\n+      emit_insn (gen_adddi3 (src_reg, src_reg, bytes_rtx));\n+      emit_insn (gen_adddi3 (dest_reg, dest_reg, bytes_rtx));\n+      emit_insn (gen_cmpdi (src_reg, final_src));\n+    }\n+  else\n+    {\n+      emit_insn (gen_addsi3 (src_reg, src_reg, bytes_rtx));\n+      emit_insn (gen_addsi3 (dest_reg, dest_reg, bytes_rtx));\n+      emit_insn (gen_cmpsi (src_reg, final_src));\n+    }\n   emit_jump_insn (gen_bne (label));\n \n   if (leftover)\n@@ -2065,18 +2254,24 @@ block_move_call (dest_reg, src_reg, bytes_rtx)\n      rtx src_reg;\n      rtx bytes_rtx;\n {\n+  /* We want to pass the size as Pmode, which will normally be SImode\n+     but will be DImode if we are using 64 bit longs and pointers.  */\n+  if (GET_MODE (bytes_rtx) != VOIDmode\n+      && GET_MODE (bytes_rtx) != Pmode)\n+    bytes_rtx = convert_to_mode (Pmode, bytes_rtx, TRUE);\n+\n #ifdef TARGET_MEM_FUNCTIONS\n   emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"memcpy\"), 0,\n \t\t     VOIDmode, 3,\n \t\t     dest_reg, Pmode,\n \t\t     src_reg, Pmode,\n-\t\t     bytes_rtx, SImode);\n+\t\t     bytes_rtx, Pmode);\n #else\n   emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"bcopy\"), 0,\n \t\t     VOIDmode, 3,\n \t\t     src_reg, Pmode,\n \t\t     dest_reg, Pmode,\n-\t\t     bytes_rtx, SImode);\n+\t\t     bytes_rtx, Pmode);\n #endif\n }\n \n@@ -2140,9 +2335,18 @@ expand_block_move (operands)\n \n       bytes -= leftover;\n \n-      emit_insn (gen_iorsi3 (temp, src_reg, dest_reg));\n-      emit_insn (gen_andsi3 (temp, temp, GEN_INT (UNITS_PER_WORD-1)));\n-      emit_insn (gen_cmpsi (temp, const0_rtx));\n+      if (TARGET_LONG64)\n+\t{\n+\t  emit_insn (gen_iordi3 (temp, src_reg, dest_reg));\n+\t  emit_insn (gen_anddi3 (temp, temp, GEN_INT (UNITS_PER_WORD-1)));\n+\t  emit_insn (gen_cmpdi (temp, const0_rtx));\n+\t}\n+      else\n+\t{\n+\t  emit_insn (gen_iorsi3 (temp, src_reg, dest_reg));\n+\t  emit_insn (gen_andsi3 (temp, temp, GEN_INT (UNITS_PER_WORD-1)));\n+\t  emit_insn (gen_cmpsi (temp, const0_rtx));\n+\t}\n       emit_jump_insn (gen_beq (aligned_label));\n \n       /* Unaligned loop.  */\n@@ -2290,19 +2494,53 @@ output_block_move (insn, operands, num_regs, move_type)\n     {\n       load_store[num].offset = offset;\n \n-      if (bytes >= UNITS_PER_WORD && align >= UNITS_PER_WORD)\n+      if (TARGET_64BIT && bytes >= 8 && align >= 8)\n+\t{\n+\t  load_store[num].load       = \"ld\\t%0,%1\";\n+\t  load_store[num].load_nop   = \"ld\\t%0,%1%#\";\n+\t  load_store[num].store      = \"sd\\t%0,%1\";\n+\t  load_store[num].last_store = \"sd\\t%0,%1\";\n+\t  load_store[num].final      = (char *)0;\n+\t  load_store[num].mode       = DImode;\n+\t  offset += 8;\n+\t  bytes -= 8;\n+\t}\n+\n+      /* ??? Fails because of a MIPS assembler bug?  */\n+      else if (TARGET_64BIT && bytes >= 8)\n+\t{\n+#if BYTES_BIG_ENDIAN\n+\t  load_store[num].load       = \"ldl\\t%0,%1\\n\\tldr\\t%0,%2\";\n+\t  load_store[num].load_nop   = \"ldl\\t%0,%1\\n\\tldr\\t%0,%2%#\";\n+\t  load_store[num].store      = \"sdl\\t%0,%1\\n\\tsdr\\t%0,%2\";\n+\t  load_store[num].last_store = \"sdr\\t%0,%2\";\n+\t  load_store[num].final      = \"sdl\\t%0,%1\";\n+#else\n+\t  load_store[num].load\t     = \"ldl\\t%0,%2\\n\\tldr\\t%0,%1\";\n+\t  load_store[num].load_nop   = \"ldl\\t%0,%2\\n\\tldr\\t%0,%1%#\";\n+\t  load_store[num].store\t     = \"sdl\\t%0,%2\\n\\tsdr\\t%0,%1\";\n+\t  load_store[num].last_store = \"sdr\\t%0,%1\";\n+\t  load_store[num].final      = \"sdl\\t%0,%2\";\n+#endif\n+\t  load_store[num].mode = DImode;\n+\t  offset += 8;\n+\t  bytes -= 8;\n+\t  use_lwl_lwr = TRUE;\n+\t}\n+\n+      else if (bytes >= 4 && align >= 4)\n \t{\n \t  load_store[num].load       = \"lw\\t%0,%1\";\n \t  load_store[num].load_nop   = \"lw\\t%0,%1%#\";\n \t  load_store[num].store      = \"sw\\t%0,%1\";\n \t  load_store[num].last_store = \"sw\\t%0,%1\";\n \t  load_store[num].final      = (char *)0;\n \t  load_store[num].mode       = SImode;\n-\t  offset += UNITS_PER_WORD;\n-\t  bytes -= UNITS_PER_WORD;\n+\t  offset += 4;\n+\t  bytes -= 4;\n \t}\n \n-      else if (bytes >= UNITS_PER_WORD)\n+      else if (bytes >= 4)\n \t{\n #if BYTES_BIG_ENDIAN\n \t  load_store[num].load       = \"lwl\\t%0,%1\\n\\tlwr\\t%0,%2\";\n@@ -2318,22 +2556,21 @@ output_block_move (insn, operands, num_regs, move_type)\n \t  load_store[num].final      = \"swl\\t%0,%2\";\n #endif\n \t  load_store[num].mode = SImode;\n-\t  offset += UNITS_PER_WORD;\n-\t  bytes -= UNITS_PER_WORD;\n+\t  offset += 4;\n+\t  bytes -= 4;\n \t  use_lwl_lwr = TRUE;\n \t}\n \n-      else if (bytes >= UNITS_PER_SHORT && align >= UNITS_PER_SHORT)\n+      else if (bytes >= 2 && align >= 2)\n \t{\n \t  load_store[num].load\t     = \"lh\\t%0,%1\";\n \t  load_store[num].load_nop   = \"lh\\t%0,%1%#\";\n \t  load_store[num].store\t     = \"sh\\t%0,%1\";\n \t  load_store[num].last_store = \"sh\\t%0,%1\";\n \t  load_store[num].final      = (char *)0;\n-\t  load_store[num].offset     = offset;\n \t  load_store[num].mode\t     = HImode;\n-\t  offset += UNITS_PER_SHORT;\n-\t  bytes -= UNITS_PER_SHORT;\n+\t  offset += 2;\n+\t  bytes -= 2;\n \t}\n \n       else\n@@ -2391,8 +2628,14 @@ output_block_move (insn, operands, num_regs, move_type)\n \t\t\t\t\t  plus_constant (src_reg, offset));\n \n \t\t  if (use_lwl_lwr)\n-\t\t    xoperands[2] = gen_rtx (MEM, load_store[i].mode,\n-\t\t\t\t\t    plus_constant (src_reg, UNITS_PER_WORD-1+offset));\n+\t\t    {\n+\t\t      int extra_offset;\n+\t\t      extra_offset = GET_MODE_SIZE (load_store[i].mode) - 1;\n+\t\t      xoperands[2] = gen_rtx (MEM, load_store[i].mode,\n+\t\t\t\t\t      plus_constant (src_reg,\n+\t\t\t\t\t\t\t     extra_offset\n+\t\t\t\t\t\t\t     + offset));\n+\t\t    }\n \n \t\t  output_asm_insn (load_store[i].load, xoperands);\n \t\t}\n@@ -2409,8 +2652,14 @@ output_block_move (insn, operands, num_regs, move_type)\n \n \n \t      if (use_lwl_lwr)\n-\t\txoperands[2] = gen_rtx (MEM, load_store[i].mode,\n-\t\t\t\t\tplus_constant (dest_reg, UNITS_PER_WORD-1+offset));\n+\t\t{\n+\t\t  int extra_offset;\n+\t\t  extra_offset = GET_MODE_SIZE (load_store[i].mode) - 1;\n+\t\t  xoperands[2] = gen_rtx (MEM, load_store[i].mode,\n+\t\t\t\t\t  plus_constant (dest_reg,\n+\t\t\t\t\t\t\t extra_offset\n+\t\t\t\t\t\t\t + offset));\n+\t\t}\n \n \t      if (move_type == BLOCK_MOVE_NORMAL)\n \t\toutput_asm_insn (load_store[i].store, xoperands);\n@@ -2429,7 +2678,7 @@ output_block_move (insn, operands, num_regs, move_type)\n \t    }\n \n \t  num = 0;\t\t/* reset load_store */\n-\t  use_lwl_lwr = FALSE;\t/* reset whether or not we used lwl/lwr */\n+\t  use_lwl_lwr = FALSE;\n \t}\n     }\n \n@@ -2512,25 +2761,27 @@ function_arg_advance (cum, mode, type, named)\n \t  && GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)\n \tabort ();\n       cum->gp_reg_found = 1;\n-      cum->arg_words += (GET_MODE_SIZE (mode) + 3) / 4;\n+      cum->arg_words += ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1)\n+\t\t\t / UNITS_PER_WORD);\n       break;\n \n     case BLKmode:\n       cum->gp_reg_found = 1;\n-      cum->arg_words += (int_size_in_bytes (type) + 3) / 4;\n+      cum->arg_words += ((int_size_in_bytes (type) + UNITS_PER_WORD - 1)\n+\t\t\t / UNITS_PER_WORD);\n       break;\n \n     case SFmode:\n       cum->arg_words++;\n       break;\n \n     case DFmode:\n-      cum->arg_words += 2;\n+      cum->arg_words += (TARGET_64BIT ? 1 : 2);\n       break;\n \n     case DImode:\n       cum->gp_reg_found = 1;\n-      cum->arg_words += 2;\n+      cum->arg_words += (TARGET_64BIT ? 1 : 2);\n       break;\n \n     case QImode:\n@@ -2542,8 +2793,8 @@ function_arg_advance (cum, mode, type, named)\n     }\n }\n \n-/* Return a RTL expression containing the register for the given mode,\n-   or 0 if the argument is too be passed on the stack.  */\n+/* Return an RTL expression containing the register for the given mode,\n+   or 0 if the argument is to be passed on the stack.  */\n \n struct rtx_def *\n function_arg (cum, mode, type, named)\n@@ -2579,7 +2830,8 @@ function_arg (cum, mode, type, named)\n       break;\n \n     case DFmode:\n-      cum->arg_words += (cum->arg_words & 1);\n+      if (! TARGET_64BIT)\n+\tcum->arg_words += (cum->arg_words & 1);\n       regbase = (cum->gp_reg_found || TARGET_SOFT_FLOAT || cum->arg_number >= 2\n \t\t ? GP_ARG_FIRST\n \t\t : FP_ARG_FIRST);\n@@ -2592,7 +2844,8 @@ function_arg (cum, mode, type, named)\n \n       /* Drops through.  */\n     case BLKmode:\n-      if (type != (tree)0 && TYPE_ALIGN (type) > BITS_PER_WORD)\n+      if (type != (tree)0 && TYPE_ALIGN (type) > BITS_PER_WORD\n+\t  && ! TARGET_64BIT)\n \tcum->arg_words += (cum->arg_words & 1);\n \n       regbase = GP_ARG_FIRST;\n@@ -2606,7 +2859,8 @@ function_arg (cum, mode, type, named)\n       break;\n \n     case DImode:\n-      cum->arg_words += (cum->arg_words & 1);\n+      if (! TARGET_64BIT)\n+\tcum->arg_words += (cum->arg_words & 1);\n       regbase = GP_ARG_FIRST;\n     }\n \n@@ -2634,19 +2888,29 @@ function_arg (cum, mode, type, named)\n \t This also makes varargs work.  If we have such a structure,\n \t we save the adjustment RTL, and the call define expands will\n \t emit them.  For the VOIDmode argument (argument after the\n-\t last real argument, pass back a parallel vector holding each\n+\t last real argument), pass back a parallel vector holding each\n \t of the adjustments.  */\n \n       /* ??? function_arg can be called more than once for each argument.\n \t As a result, we compute more adjustments than we need here.\n \t See the CUMULATIVE_ARGS definition in mips.h.  */\n \n-      if (struct_p && int_size_in_bytes (type) < 4)\n+      /* ??? This scheme requires everything smaller than the word size to\n+\t shifted to the left, but when TARGET_64BIT and ! TARGET_INT64,\n+\t that would mean every int needs to be shifted left, which is very\n+\t inefficient.  Let's not carry this compatibility to the 64 bit\n+\t calling convention for now.  */\n+\n+      if (struct_p && int_size_in_bytes (type) < UNITS_PER_WORD\n+\t  && ! TARGET_64BIT)\n \t{\n \t  rtx amount = GEN_INT (BITS_PER_WORD\n \t\t\t\t- int_size_in_bytes (type) * BITS_PER_UNIT);\n-\t  rtx reg = gen_rtx (REG, SImode, regbase + cum->arg_words + bias);\n-\t  cum->adjust[ cum->num_adjusts++ ] = gen_ashlsi3 (reg, reg, amount);\n+\t  rtx reg = gen_rtx (REG, word_mode, regbase + cum->arg_words + bias);\n+\t  if (TARGET_64BIT)\n+\t    cum->adjust[ cum->num_adjusts++ ] = gen_ashldi3 (reg, reg, amount);\n+\t  else\n+\t    cum->adjust[ cum->num_adjusts++ ] = gen_ashlsi3 (reg, reg, amount);\n \t}\n     }\n \n@@ -2671,9 +2935,10 @@ function_arg_partial_nregs (cum, mode, type, named)\n     {\n       int words;\n       if (mode == BLKmode)\n-\twords = (int_size_in_bytes (type) + 3) / 4;\n+\twords = ((int_size_in_bytes (type) + UNITS_PER_WORD - 1)\n+\t\t / UNITS_PER_WORD);\n       else\n-\twords = (GET_MODE_SIZE (mode) + 3) / 4;\n+\twords = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n \n       if (words + cum->arg_words <= MAX_ARGS_IN_REGISTERS)\n \treturn 0;\t\t/* structure fits in registers */\n@@ -2685,7 +2950,8 @@ function_arg_partial_nregs (cum, mode, type, named)\n       return MAX_ARGS_IN_REGISTERS - cum->arg_words;\n     }\n \n-  else if (mode == DImode && cum->arg_words == MAX_ARGS_IN_REGISTERS-1)\n+  else if (mode == DImode && cum->arg_words == MAX_ARGS_IN_REGISTERS-1\n+\t   && ! TARGET_64BIT)\n     {\n       if (TARGET_DEBUG_E_MODE)\n \tfprintf (stderr, \"function_arg_partial_nregs = 1\\n\");\n@@ -2821,13 +3087,57 @@ override_options ()\n \n   mips_section_threshold = (g_switch_set) ? g_switch_value : MIPS_DEFAULT_GVALUE;\n \n+  if (mips_section_threshold <= 0)\n+    target_flags &= ~MASK_GPOPT;\n+  else if (optimize)\n+    target_flags |= MASK_GPOPT;\n+\n+  /* Get the architectural level.  */\n+  if (mips_isa_string == (char *)0)\n+    {\n+#ifdef MIPS_ISA_DEFAULT\n+      mips_isa = MIPS_ISA_DEFAULT;\n+#else\n+      mips_isa = 1;\n+#endif\n+    }\n+\n+  else if (isdigit (*mips_isa_string))\n+    {\n+      mips_isa = atoi (mips_isa_string);\n+      if (mips_isa < 1 || mips_isa > 3)\n+\t{\n+\t  error (\"-mips%d not supported\", mips_isa);\n+\t  mips_isa = 1;\n+\t}\n+    }\n+\n+  else\n+    {\n+      error (\"bad value (%s) for -mips switch\", mips_isa_string);\n+      mips_isa = 1;\n+    }\n+\n   /* Identify the processor type */\n   if (mips_cpu_string == (char *)0\n       || !strcmp (mips_cpu_string, \"default\")\n       || !strcmp (mips_cpu_string, \"DEFAULT\"))\n     {\n-      mips_cpu_string = \"default\";\n-      mips_cpu = PROCESSOR_DEFAULT;\n+      switch (mips_isa)\n+\t{\n+\tdefault:\n+\t  mips_cpu_string = \"3000\";\n+\t  mips_cpu = PROCESSOR_R3000;\n+\t  break;\n+\tcase 2:\n+\t  mips_cpu_string = \"6000\";\n+\t  mips_cpu = PROCESSOR_R6000;\n+\t  break;\n+\tcase 3:\n+\t  mips_cpu_string = \"4000\";\n+\t  mips_cpu = PROCESSOR_R4000;\n+\t  break;\n+\t}\n     }\n \n   else\n@@ -2856,12 +3166,23 @@ override_options ()\n \tcase '4':\n \t  if (!strcmp (p, \"4000\") || !strcmp (p, \"4k\") || !strcmp (p, \"4K\"))\n \t    mips_cpu = PROCESSOR_R4000;\n+\t  /* The r4400 is exactly the same as the r4000 from the compiler's\n+\t     viewpoint.  */\n+\t  else if (!strcmp (p, \"4400\"))\n+\t    mips_cpu = PROCESSOR_R4000;\n+\t  else if (!strcmp (p, \"4600\"))\n+\t    mips_cpu = PROCESSOR_R4600;\n \t  break;\n \n \tcase '6':\n \t  if (!strcmp (p, \"6000\") || !strcmp (p, \"6k\") || !strcmp (p, \"6K\"))\n \t    mips_cpu = PROCESSOR_R6000;\n \t  break;\n+\n+\tcase 'o':\n+\t  if (!strcmp (p, \"orion\"))\n+\t    mips_cpu = PROCESSOR_R4600;\n+\t  break;\n \t}\n \n       if (mips_cpu == PROCESSOR_DEFAULT)\n@@ -2871,46 +3192,32 @@ override_options ()\n \t}\n     }\n \n-  /* Now get the architectural level.  */\n-  if (mips_isa_string == (char *)0)\n-    mips_isa = 1;\n-\n-  else if (isdigit (*mips_isa_string))\n-    mips_isa = atoi (mips_isa_string);\n-\n-  else\n-    {\n-      error (\"bad value (%s) for -mips switch\", mips_isa_string);\n-      mips_isa = 1;\n-    }\n-\n-  if (mips_isa < 0 || mips_isa > 3)\n-    error (\"-mips%d not supported\", mips_isa);\n-\n-  else if (mips_isa > 1\n-\t   && (mips_cpu == PROCESSOR_DEFAULT || mips_cpu == PROCESSOR_R3000))\n-    error (\"-mcpu=%s does not support -mips%d\", mips_cpu_string, mips_isa);\n-\n-  else if (mips_cpu == PROCESSOR_R6000 && mips_isa > 2)\n+  if ((mips_cpu == PROCESSOR_R3000 && mips_isa > 1)\n+      || (mips_cpu == PROCESSOR_R6000 && mips_isa > 2))\n     error (\"-mcpu=%s does not support -mips%d\", mips_cpu_string, mips_isa);\n \n   /* make sure sizes of ints/longs/etc. are ok */\n   if (mips_isa < 3)\n     {\n       if (TARGET_INT64)\n-\tfatal (\"Only the r4000 can support 64 bit ints\");\n+\tfatal (\"Only MIPS-III CPUs can support 64 bit ints\");\n \n       else if (TARGET_LONG64)\n-\tfatal (\"Only the r4000 can support 64 bit longs\");\n+\tfatal (\"Only MIPS-III CPUs can support 64 bit longs\");\n \n       else if (TARGET_LLONG128)\n-\tfatal (\"Only the r4000 can support 128 bit long longs\");\n+\tfatal (\"Only MIPS-III CPUs can support 128 bit long longs\");\n \n       else if (TARGET_FLOAT64)\n-\tfatal (\"Only the r4000 can support 64 bit fp registers\");\n+\tfatal (\"Only MIPS-III CPUs can support 64 bit fp registers\");\n+    }\n+  else\n+    {\n+      target_flags |= MASK_64BIT;\n+\n+      if (TARGET_LLONG128)\n+\tfatal (\"128 bit long longs are not supported\");\n     }\n-  else if (TARGET_INT64 || TARGET_LONG64 || TARGET_LLONG128 || TARGET_FLOAT64)\n-    warning (\"r4000 64/128 bit types not yet supported\");\n \n   /* Tell halfpic.c that we have half-pic code if we do.  */\n   if (TARGET_HALF_PIC)\n@@ -2922,20 +3229,12 @@ override_options ()\n     mips_abicalls = MIPS_ABICALLS_NO;\n \n   /* -mrnames says to use the MIPS software convention for register\n-     names instead of the hardware names (ie, a0 instead of $4).\n+     names instead of the hardware names (ie, $a0 instead of $4).\n      We do this by switching the names in mips_reg_names, which the\n      reg_names points into via the REGISTER_NAMES macro.  */\n \n   if (TARGET_NAME_REGS)\n-    {\n-      if (TARGET_GAS)\n-\t{\n-\t  target_flags &= ~ MASK_NAME_REGS;\n-\t  error (\"Gas does not support the MIPS software register name convention.\");\n-\t}\n-      else\n-\tbcopy ((char *) mips_sw_reg_names, (char *) mips_reg_names, sizeof (mips_reg_names));\n-    }\n+    bcopy ((char *) mips_sw_reg_names, (char *) mips_reg_names, sizeof (mips_reg_names));\n \n   /* If this is OSF/1, set up a SIGINFO handler so we can see what function\n      is currently being compiled.  */\n@@ -2958,6 +3257,14 @@ override_options ()\n #endif\n #endif\n \n+  /* Initialize the high and low values for legitimate floating point\n+     constants.  Rather than trying to get the accuracy down to the\n+     last bit, just use approximate ranges.  */\n+  dfhigh = REAL_VALUE_ATOF (\"1.0e300\", DFmode);\n+  dflow = REAL_VALUE_ATOF (\"1.0e-300\", DFmode);\n+  sfhigh = REAL_VALUE_ATOF (\"1.0e38\", SFmode);\n+  sflow = REAL_VALUE_ATOF (\"1.0e-38\", SFmode);\n+\n   /* Set up the classification arrays now.  */\n   mips_rtx_classify[(int)PLUS]  = CLASS_ADD_OP;\n   mips_rtx_classify[(int)MINUS] = CLASS_ADD_OP;\n@@ -3046,7 +3353,14 @@ override_options ()\n \t\t\t|| (TARGET_DEBUG_H_MODE && class == MODE_INT)));\n \n \t  else if (MD_REG_P (regno))\n-\t    temp = (mode == SImode || (regno == MD_REG_FIRST && mode == DImode));\n+\t    {\n+\t      if (TARGET_64BIT)\n+\t\ttemp = (mode == DImode\n+\t\t\t|| (regno == MD_REG_FIRST && mode == TImode));\n+\t      else\n+\t\ttemp = (mode == SImode\n+\t\t\t|| (regno == MD_REG_FIRST && mode == DImode));\n+\t    }\n \n \t  else\n \t    temp = FALSE;\n@@ -3331,20 +3645,12 @@ print_operand (file, op, letter)\n \n   else if (code == CONST_DOUBLE)\n     {\n-#if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-      union { double d; int i[2]; } u;\n-      u.i[0] = CONST_DOUBLE_LOW (op);\n-      u.i[1] = CONST_DOUBLE_HIGH (op);\n-      if (GET_MODE (op) == SFmode)\n-\t{\n-\t  float f;\n-\t  f = u.d;\n-\t  u.d = f;\n-\t}\n-      fprintf (file, \"%.20e\", u.d);\n-#else\n-      fatal (\"CONST_DOUBLE found in cross compilation\");\n-#endif\n+      REAL_VALUE_TYPE d;\n+      char s[30];\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n+      REAL_VALUE_TO_DECIMAL (d, \"%.20e\", s);\n+      fprintf (file, s);\n     }\n \n   else if ((letter == 'x') && (GET_CODE(op) == CONST_INT))\n@@ -3468,7 +3774,6 @@ mips_output_external (file, decl, name)\n   int len;\n \n   if (TARGET_GP_OPT\n-      && mips_section_threshold != 0\n       && ((TREE_CODE (decl)) != FUNCTION_DECL)\n       && ((len = int_size_in_bytes (TREE_TYPE (decl))) > 0))\n     {\n@@ -3484,6 +3789,14 @@ mips_output_external (file, decl, name)\n \f\n /* Compute a string to use as a temporary file name.  */\n \n+/* On MSDOS, write temp files in current dir\n+   because there's no place else we can expect to use.  */\n+#if __MSDOS__\n+#ifndef P_tmpdir\n+#define P_tmpdir \"./\"\n+#endif\n+#endif\n+\n static FILE *\n make_temp_file ()\n {\n@@ -3505,19 +3818,25 @@ make_temp_file ()\n     }\n \n   len = strlen (base);\n-  temp_filename = (char *) alloca (len + sizeof(\"/ccXXXXXX\"));\n+  /* temp_filename is global, so we must use malloc, not alloca.  */\n+  temp_filename = (char *) xmalloc (len + sizeof(\"/ctXXXXXX\"));\n   strcpy (temp_filename, base);\n   if (len > 0 && temp_filename[len-1] != '/')\n     temp_filename[len++] = '/';\n \n-  strcpy (temp_filename + len, \"ccXXXXXX\");\n+  strcpy (temp_filename + len, \"ctXXXXXX\");\n   mktemp (temp_filename);\n \n   stream = fopen (temp_filename, \"w+\");\n   if (!stream)\n     pfatal_with_name (temp_filename);\n \n+#ifndef __MSDOS__\n+  /* In MSDOS, we cannot unlink the temporary file until we are finished using\n+     it.  Otherwise, we delete it now, so that it will be gone even if the\n+     compiler happens to crash.  */\n   unlink (temp_filename);\n+#endif\n   return stream;\n }\n \n@@ -3706,9 +4025,6 @@ mips_asm_file_start (stream)\n   else\n     asm_out_data_file = asm_out_text_file = stream;\n \n-  if (TARGET_NAME_REGS)\n-    fprintf (asm_out_file, \"#include <regdef.h>\\n\");\n-\n   print_options (stream);\n }\n \n@@ -3764,6 +4080,10 @@ mips_asm_file_end (file)\n \n       if (fclose (asm_out_text_file) != 0)\n \tpfatal_with_name (temp_filename);\n+\n+#ifdef __MSDOS__\n+      unlink (temp_filename);\n+#endif\n     }\n }\n \n@@ -3784,7 +4104,7 @@ mips_declare_object (stream, name, init_string, final_string, size)\n   assemble_name (stream, name);\n   fprintf (stream, final_string, size);\t/* \":\\n\", \",%u\\n\", \",%u\\n\" */\n \n-  if (TARGET_GP_OPT && mips_section_threshold != 0)\n+  if (TARGET_GP_OPT)\n     {\n       tree name_tree = get_identifier (name);\n       TREE_ASM_WRITTEN (name_tree) = 1;\n@@ -4011,7 +4331,7 @@ compute_frame_size (size)\n     {\n       if (regs_ever_live[regno] && !call_used_regs[regno])\n \t{\n-\t  fp_reg_size += 2*UNITS_PER_WORD;\n+\t  fp_reg_size += fp_inc * UNITS_PER_FPREG;\n \t  fmask |= fp_bits << (regno - FP_REG_FIRST);\n \t}\n     }\n@@ -4042,7 +4362,7 @@ compute_frame_size (size)\n   current_frame_info.fmask\t = fmask;\n   current_frame_info.initialized = reload_completed;\n   current_frame_info.num_gp\t = gp_reg_size / UNITS_PER_WORD;\n-  current_frame_info.num_fp\t = fp_reg_size / (2*UNITS_PER_WORD);\n+  current_frame_info.num_fp\t = fp_reg_size / (fp_inc * UNITS_PER_FPREG);\n \n   if (mask)\n     {\n@@ -4060,8 +4380,9 @@ compute_frame_size (size)\n \n   if (fmask)\n     {\n-      unsigned long offset = args_size + extra_size + var_size\n-\t\t\t     + gp_reg_rounded + fp_reg_size - 2*UNITS_PER_WORD;\n+      unsigned long offset = (args_size + extra_size + var_size\n+\t\t\t      + gp_reg_rounded + fp_reg_size\n+\t\t\t      - fp_inc * UNITS_PER_FPREG);\n       current_frame_info.fp_sp_offset = offset;\n       current_frame_info.fp_save_offset = offset - total_size + UNITS_PER_WORD;\n     }\n@@ -4140,9 +4461,15 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t  base_reg_rtx = gen_rtx (REG, Pmode, MIPS_TEMP2_REGNUM);\n \t  base_offset  = large_offset;\n \t  if (file == (FILE *)0)\n-\t    emit_insn (gen_addsi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n+\t    {\n+\t      if (TARGET_LONG64)\n+\t\temit_insn (gen_adddi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n+\t      else\n+\t\temit_insn (gen_addsi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n+\t    }\n \t  else\n-\t    fprintf (file, \"\\taddu\\t%s,%s,%s\\n\",\n+\t    fprintf (file, \"\\t%s\\t%s,%s,%s\\n\",\n+\t\t     TARGET_LONG64 ? \"daddu\" : \"addu\",\n \t\t     reg_names[MIPS_TEMP2_REGNUM],\n \t\t     reg_names[REGNO (large_reg)],\n \t\t     reg_names[STACK_POINTER_REGNUM]);\n@@ -4155,13 +4482,17 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t  if (file == (FILE *)0)\n \t    {\n \t      emit_move_insn (base_reg_rtx, GEN_INT (gp_offset));\n-\t      emit_insn (gen_addsi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n+\t      if (TARGET_LONG64)\n+\t\temit_insn (gen_adddi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n+\t      else\n+\t\temit_insn (gen_addsi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n \t    }\n \t  else\n-\t    fprintf (file, \"\\tli\\t%s,0x%.08lx\\t# %ld\\n\\taddu\\t%s,%s,%s\\n\",\n+\t    fprintf (file, \"\\tli\\t%s,0x%.08lx\\t# %ld\\n\\t%s\\t%s,%s,%s\\n\",\n \t\t     reg_names[MIPS_TEMP2_REGNUM],\n \t\t     (long)base_offset,\n \t\t     (long)base_offset,\n+\t\t     TARGET_LONG64 ? \"daddu\" : \"addu\",\n \t\t     reg_names[MIPS_TEMP2_REGNUM],\n \t\t     reg_names[MIPS_TEMP2_REGNUM],\n \t\t     reg_names[STACK_POINTER_REGNUM]);\n@@ -4173,8 +4504,8 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t    {\n \t      if (file == (FILE *)0)\n \t\t{\n-\t\t  rtx reg_rtx = gen_rtx (REG, Pmode, regno);\n-\t\t  rtx mem_rtx = gen_rtx (MEM, Pmode,\n+\t\t  rtx reg_rtx = gen_rtx (REG, word_mode, regno);\n+\t\t  rtx mem_rtx = gen_rtx (MEM, word_mode,\n \t\t\t\t\t gen_rtx (PLUS, Pmode, base_reg_rtx,\n \t\t\t\t\t\t  GEN_INT (gp_offset - base_offset)));\n \n@@ -4189,7 +4520,9 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t  if (store_p || !TARGET_ABICALLS\n \t\t      || regno != (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n \t\t    fprintf (file, \"\\t%s\\t%s,%ld(%s)\\n\",\n-\t\t\t     (store_p) ? \"sw\" : \"lw\",\n+\t\t\t     (TARGET_64BIT\n+\t\t\t      ? (store_p) ? \"sd\" : \"ld\"\n+\t\t\t      : (store_p) ? \"sw\" : \"lw\"),\n \t\t\t     reg_names[regno],\n \t\t\t     gp_offset - base_offset,\n \t\t\t     reg_names[REGNO(base_reg_rtx)]);\n@@ -4209,10 +4542,11 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n   if (fmask)\n     {\n       int fp_inc = (TARGET_FLOAT64) ? 1 : 2;\n+      int fp_size = fp_inc * UNITS_PER_FPREG;\n \n       /* Pick which pointer to use as a base register.  */\n       fp_offset  = current_frame_info.fp_sp_offset;\n-      end_offset = fp_offset - (current_frame_info.fp_reg_size - 2*UNITS_PER_WORD);\n+      end_offset = fp_offset - (current_frame_info.fp_reg_size - fp_size);\n \n       if (fp_offset < 0 || end_offset < 0)\n \tfatal (\"fp_offset (%ld) or end_offset (%ld) is less than zero.\",\n@@ -4238,9 +4572,15 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t  base_reg_rtx = gen_rtx (REG, Pmode, MIPS_TEMP2_REGNUM);\n \t  base_offset  = large_offset;\n \t  if (file == (FILE *)0)\n-\t    emit_insn (gen_addsi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n+\t    {\n+\t      if (TARGET_LONG64)\n+\t\temit_insn (gen_adddi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n+\t      else\n+\t\temit_insn (gen_addsi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n+\t    }\n \t  else\n-\t    fprintf (file, \"\\taddu\\t%s,%s,%s\\n\",\n+\t    fprintf (file, \"\\t%s\\t%s,%s,%s\\n\",\n+\t\t     TARGET_LONG64 ? \"daddu\" : \"addu\",\n \t\t     reg_names[MIPS_TEMP2_REGNUM],\n \t\t     reg_names[REGNO (large_reg)],\n \t\t     reg_names[STACK_POINTER_REGNUM]);\n@@ -4253,13 +4593,17 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t  if (file == (FILE *)0)\n \t    {\n \t      emit_move_insn (base_reg_rtx, GEN_INT (fp_offset));\n-\t      emit_insn (gen_addsi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n+\t      if (TARGET_LONG64)\n+\t\temit_insn (gen_adddi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n+\t      else\n+\t\temit_insn (gen_addsi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n \t    }\n \t  else\n-\t    fprintf (file, \"\\tli\\t%s,0x%.08lx\\t# %ld\\n\\taddu\\t%s,%s,%s\\n\",\n+\t    fprintf (file, \"\\tli\\t%s,0x%.08lx\\t# %ld\\n\\t%s\\t%s,%s,%s\\n\",\n \t\t     reg_names[MIPS_TEMP2_REGNUM],\n \t\t     (long)base_offset,\n \t\t     (long)base_offset,\n+\t\t     TARGET_LONG64 ? \"daddu\" : \"addu\",\n \t\t     reg_names[MIPS_TEMP2_REGNUM],\n \t\t     reg_names[MIPS_TEMP2_REGNUM],\n \t\t     reg_names[STACK_POINTER_REGNUM]);\n@@ -4289,7 +4633,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t\t reg_names[REGNO(base_reg_rtx)]);\n \n \n-\t      fp_offset -= 2*UNITS_PER_WORD;\n+\t      fp_offset -= fp_size;\n \t    }\n \t}\n     }\n@@ -4342,7 +4686,9 @@ function_prologue (file, size)\n \t       reg_names[PIC_FUNCTION_ADDR_REGNUM]);\n       if (tsize > 0)\n \t{\n-\t  fprintf (file, \"\\tsubu\\t%s,%s,%d\\n\", sp_str, sp_str, tsize);\n+\t  fprintf (file, \"\\t%s\\t%s,%s,%d\\n\",\n+\t\t   (TARGET_LONG64 ? \"dsubu\" : \"subu\"),\n+\t\t   sp_str, sp_str, tsize);\n \t  fprintf (file, \"\\t.cprestore %d\\n\", current_frame_info.args_size);\n \t}\n     }\n@@ -4474,8 +4820,8 @@ mips_expand_prologue ()\n \t{\n \t  if (offset != 0)\n \t    ptr = gen_rtx (PLUS, Pmode, stack_pointer_rtx, GEN_INT (offset));\n-\t  emit_move_insn (gen_rtx (MEM, Pmode, ptr),\n-\t\t\t  gen_rtx (REG, Pmode, regno));\n+\t  emit_move_insn (gen_rtx (MEM, word_mode, ptr),\n+\t\t\t  gen_rtx (REG, word_mode, regno));\n \t  offset += UNITS_PER_WORD;\n \t}\n     }\n@@ -4489,19 +4835,28 @@ mips_expand_prologue ()\n \t{\n \t  if (tsize > 32767)\n \t    {\n-\t      tmp_rtx = gen_rtx (REG, SImode, MIPS_TEMP1_REGNUM);\n+\t      tmp_rtx = gen_rtx (REG, Pmode, MIPS_TEMP1_REGNUM);\n \t      emit_move_insn (tmp_rtx, tsize_rtx);\n \t      tsize_rtx = tmp_rtx;\n \t    }\n \n-\t  emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t tsize_rtx));\n+\t  if (TARGET_LONG64)\n+\t    emit_insn (gen_subdi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t   tsize_rtx));\n+\t  else\n+\t    emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t   tsize_rtx));\n \t}\n \n       save_restore_insns (TRUE, tmp_rtx, tsize, (FILE *)0);\n \n       if (frame_pointer_needed)\n-\temit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n+\t{\n+\t  if (TARGET_64BIT)\n+\t    emit_insn (gen_movdi (frame_pointer_rtx, stack_pointer_rtx));\n+\t  else\n+\t    emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n+\t}\n     }\n \n   /* If we are profiling, make sure no instructions are scheduled before\n@@ -4580,7 +4935,7 @@ function_epilogue (file, size)\n   if (set_volatile != 0)\n     {\n       set_volatile = 0;\n-      fprintf (file, \"\\t#.set\\tnovolatile\\n\", (TARGET_MIPS_AS) ? \"\" : \"#\");\n+      fprintf (file, \"\\t%s.set\\tnovolatile\\n\", (TARGET_MIPS_AS) ? \"\" : \"#\");\n       error (\"internal gcc error: .set volatile left on in epilogue\");\n     }\n \n@@ -4654,10 +5009,14 @@ function_epilogue (file, size)\n \t  fprintf (file, \"\\tj\\t%s\\n\", reg_names[GP_REG_FIRST + 31]);\n \n \t  if (tsize > 32767)\n-\t    fprintf (file, \"\\taddu\\t%s,%s,%s\\n\", sp_str, sp_str, t1_str);\n+\t    fprintf (file, \"\\t%s\\t%s,%s,%s\\n\",\n+\t\t     TARGET_LONG64 ? \"daddu\" : \"addu\",\n+\t\t     sp_str, sp_str, t1_str);\n \n \t  else if (tsize > 0)\n-\t    fprintf (file, \"\\taddu\\t%s,%s,%d\\n\", sp_str, sp_str, tsize);\n+\t    fprintf (file, \"\\t%s\\t%s,%s,%d\\n\",\n+\t\t     TARGET_LONG64 ? \"daddu\" : \"addu\",\n+\t\t     sp_str, sp_str, tsize);\n \n \t  else if (!load_only_r31 && epilogue_delay != 0)\n \t    final_scan_insn (XEXP (epilogue_delay, 0),\n@@ -4672,10 +5031,14 @@ function_epilogue (file, size)\n       else\n \t{\n \t  if (tsize > 32767)\n-\t    fprintf (file, \"\\taddu\\t%s,%s,%s\\n\", sp_str, sp_str, t1_str);\n+\t    fprintf (file, \"\\t%s\\t%s,%s,%s\\n\",\n+\t\t     TARGET_LONG64 ? \"daddu\" : \"addu\",\n+\t\t     sp_str, sp_str, t1_str);\n \n \t  else if (tsize > 0)\n-\t    fprintf (file, \"\\taddu\\t%s,%s,%d\\n\", sp_str, sp_str, tsize);\n+\t    fprintf (file, \"\\t%s\\t%s,%s,%d\\n\",\n+\t\t     TARGET_LONG64 ? \"daddu\" : \"addu\",\n+\t\t     sp_str, sp_str, tsize);\n \n \t  fprintf (file, \"\\tj\\t%s\\n\", reg_names[GP_REG_FIRST + 31]);\n \t}\n@@ -4777,19 +5140,29 @@ mips_expand_epilogue ()\n \n   if (tsize > 32767)\n     {\n-      tmp_rtx = gen_rtx (REG, SImode, MIPS_TEMP1_REGNUM);\n+      tmp_rtx = gen_rtx (REG, Pmode, MIPS_TEMP1_REGNUM);\n       emit_move_insn (tmp_rtx, tsize_rtx);\n       tsize_rtx = tmp_rtx;\n     }\n \n   if (tsize > 0)\n     {\n       if (frame_pointer_needed)\n-\temit_insn (gen_movsi (stack_pointer_rtx, frame_pointer_rtx));\n+\t{\n+\t  if (TARGET_LONG64)\n+\t    emit_insn (gen_movdi (stack_pointer_rtx, frame_pointer_rtx));\n+\t  else\n+\t    emit_insn (gen_movsi (stack_pointer_rtx, frame_pointer_rtx));\n+\t}\n \n       save_restore_insns (FALSE, tmp_rtx, tsize, (FILE *)0);\n \n-      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, tsize_rtx));\n+      if (TARGET_LONG64)\n+\temit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t       tsize_rtx));\n+      else\n+\temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t       tsize_rtx));\n     }\n \n   emit_jump_insn (gen_return_internal (gen_rtx (REG, Pmode, GP_REG_FIRST+31)));"}]}