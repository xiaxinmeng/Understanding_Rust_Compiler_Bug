{"sha": "65f8144a803cef2fbd7f73334603318547f4df0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVmODE0NGE4MDNjZWYyZmJkN2Y3MzMzNDYwMzMxODU0N2Y0ZGYwYg==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-01-07T00:28:29Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-01-07T00:28:29Z"}, "message": "[multiple changes]\n\n2007-01-06  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n        * array.c, bbt.c, check.c:  Update copyright years.  Whitespace.\n\n\n2006-01-06  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n        * gfortran.dg/present_1.f90:  Update error message.\n\nFrom-SVN: r120542", "tree": {"sha": "887edab011cbaf9750f46bb7b5ed7530bb712341", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/887edab011cbaf9750f46bb7b5ed7530bb712341"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65f8144a803cef2fbd7f73334603318547f4df0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65f8144a803cef2fbd7f73334603318547f4df0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65f8144a803cef2fbd7f73334603318547f4df0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65f8144a803cef2fbd7f73334603318547f4df0b/comments", "author": null, "committer": null, "parents": [{"sha": "ae82248d4595b4d7dcd7272844233b0768ee609f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae82248d4595b4d7dcd7272844233b0768ee609f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae82248d4595b4d7dcd7272844233b0768ee609f"}], "stats": {"total": 947, "additions": 477, "deletions": 470}, "files": [{"sha": "4df2107f5a641f867ed40fb86bc0e9e96c0c4578", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f8144a803cef2fbd7f73334603318547f4df0b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f8144a803cef2fbd7f73334603318547f4df0b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=65f8144a803cef2fbd7f73334603318547f4df0b", "patch": "@@ -1,4 +1,8 @@\n-2007-01-05  Steven G. Kargl  <kargl@gcc.gnu.org>\n+2007-01-06  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\t* array.c, bbt.c, check.c:  Update copyright years.  Whitespace.\n+\n+2007-01-06  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* arith.c: Update copyright years.  Whitespace.\n "}, {"sha": "af281f78c10b7bec2a2dadcf1cdc88e40a49d5b2", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 130, "deletions": 134, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f8144a803cef2fbd7f73334603318547f4df0b/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f8144a803cef2fbd7f73334603318547f4df0b/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=65f8144a803cef2fbd7f73334603318547f4df0b", "patch": "@@ -1,6 +1,6 @@\n /* Array things\n-   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006 Free Software\n-   Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC.\n@@ -37,7 +37,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n /* Copy an array reference structure.  */\n \n gfc_array_ref *\n-gfc_copy_array_ref (gfc_array_ref * src)\n+gfc_copy_array_ref (gfc_array_ref *src)\n {\n   gfc_array_ref *dest;\n   int i;\n@@ -69,7 +69,7 @@ gfc_copy_array_ref (gfc_array_ref * src)\n    expression.  */\n \n static match\n-match_subscript (gfc_array_ref * ar, int init)\n+match_subscript (gfc_array_ref *ar, int init)\n {\n   match m;\n   int i;\n@@ -119,7 +119,7 @@ match_subscript (gfc_array_ref * ar, int init)\n   if (gfc_match_char (':') == MATCH_YES)\n     {\n       m = init ? gfc_match_init_expr (&ar->stride[i])\n-\t: gfc_match_expr (&ar->stride[i]);\n+\t       : gfc_match_expr (&ar->stride[i]);\n \n       if (m == MATCH_NO)\n \tgfc_error (\"Expected array subscript stride at %C\");\n@@ -136,7 +136,7 @@ match_subscript (gfc_array_ref * ar, int init)\n    to consist of init expressions.  */\n \n match\n-gfc_match_array_ref (gfc_array_ref * ar, gfc_array_spec * as, int init)\n+gfc_match_array_ref (gfc_array_ref *ar, gfc_array_spec *as, int init)\n {\n   match m;\n \n@@ -189,7 +189,7 @@ gfc_match_array_ref (gfc_array_ref * ar, gfc_array_spec * as, int init)\n    specifications.  */\n \n void\n-gfc_free_array_spec (gfc_array_spec * as)\n+gfc_free_array_spec (gfc_array_spec *as)\n {\n   int i;\n \n@@ -210,9 +210,8 @@ gfc_free_array_spec (gfc_array_spec * as)\n    shape and check associated constraints.  */\n \n static try\n-resolve_array_bound (gfc_expr * e, int check_constant)\n+resolve_array_bound (gfc_expr *e, int check_constant)\n {\n-\n   if (e == NULL)\n     return SUCCESS;\n \n@@ -235,7 +234,7 @@ resolve_array_bound (gfc_expr * e, int check_constant)\n    the shape and make sure everything is integral.  */\n \n try\n-gfc_resolve_array_spec (gfc_array_spec * as, int check_constant)\n+gfc_resolve_array_spec (gfc_array_spec *as, int check_constant)\n {\n   gfc_expr *e;\n   int i;\n@@ -264,22 +263,22 @@ gfc_resolve_array_spec (gfc_array_spec * as, int check_constant)\n    individual specifications make sense as a whole.\n \n \n-        Parsed       Lower   Upper  Returned\n-        ------------------------------------\n-          :          NULL    NULL   AS_DEFERRED (*)\n-          x           1       x     AS_EXPLICIT\n-          x:          x      NULL   AS_ASSUMED_SHAPE\n-          x:y         x       y     AS_EXPLICIT\n-          x:*         x      NULL   AS_ASSUMED_SIZE\n-          *           1      NULL   AS_ASSUMED_SIZE\n+\tParsed       Lower   Upper  Returned\n+\t------------------------------------\n+\t  :\t  NULL    NULL   AS_DEFERRED (*)\n+\t  x\t   1       x     AS_EXPLICIT\n+\t  x:\t  x      NULL   AS_ASSUMED_SHAPE\n+\t  x:y\t x       y     AS_EXPLICIT\n+\t  x:*\t x      NULL   AS_ASSUMED_SIZE\n+\t  *\t   1      NULL   AS_ASSUMED_SIZE\n \n   (*) For non-pointer dummy arrays this is AS_ASSUMED_SHAPE.  This\n   is fixed during the resolution of formal interfaces.\n \n    Anything else AS_UNKNOWN.  */\n \n static array_type\n-match_array_element_spec (gfc_array_spec * as)\n+match_array_element_spec (gfc_array_spec *as)\n {\n   gfc_expr **upper, **lower;\n   match m;\n@@ -328,7 +327,7 @@ match_array_element_spec (gfc_array_spec * as)\n    it is.  */\n \n match\n-gfc_match_array_spec (gfc_array_spec ** asp)\n+gfc_match_array_spec (gfc_array_spec **asp)\n {\n   array_type current_type;\n   gfc_array_spec *as;\n@@ -362,7 +361,7 @@ gfc_match_array_spec (gfc_array_spec ** asp)\n \t}\n       else\n \tswitch (as->type)\n-\t  {\t\t\t/* See how current spec meshes with the existing */\n+\t  {\t\t/* See how current spec meshes with the existing.  */\n \t  case AS_UNKNOWN:\n \t    goto cleanup;\n \n@@ -376,9 +375,8 @@ gfc_match_array_spec (gfc_array_spec ** asp)\n \t    if (current_type == AS_EXPLICIT)\n \t      break;\n \n-\t    gfc_error\n-\t      (\"Bad array specification for an explicitly shaped array\"\n-\t       \" at %C\");\n+\t    gfc_error (\"Bad array specification for an explicitly shaped \"\n+\t\t       \"array at %C\");\n \n \t    goto cleanup;\n \n@@ -387,8 +385,8 @@ gfc_match_array_spec (gfc_array_spec ** asp)\n \t\t|| (current_type == AS_DEFERRED))\n \t      break;\n \n-\t    gfc_error\n-\t      (\"Bad array specification for assumed shape array at %C\");\n+\t    gfc_error (\"Bad array specification for assumed shape \"\n+\t\t       \"array at %C\");\n \t    goto cleanup;\n \n \t  case AS_DEFERRED:\n@@ -452,9 +450,8 @@ gfc_match_array_spec (gfc_array_spec ** asp)\n    something goes wrong.  On failure, the caller must free the spec.  */\n \n try\n-gfc_set_array_spec (gfc_symbol * sym, gfc_array_spec * as, locus * error_loc)\n+gfc_set_array_spec (gfc_symbol *sym, gfc_array_spec *as, locus *error_loc)\n {\n-\n   if (as == NULL)\n     return SUCCESS;\n \n@@ -470,7 +467,7 @@ gfc_set_array_spec (gfc_symbol * sym, gfc_array_spec * as, locus * error_loc)\n /* Copy an array specification.  */\n \n gfc_array_spec *\n-gfc_copy_array_spec (gfc_array_spec * src)\n+gfc_copy_array_spec (gfc_array_spec *src)\n {\n   gfc_array_spec *dest;\n   int i;\n@@ -491,11 +488,12 @@ gfc_copy_array_spec (gfc_array_spec * src)\n   return dest;\n }\n \n+\n /* Returns nonzero if the two expressions are equal.  Only handles integer\n    constants.  */\n \n static int\n-compare_bounds (gfc_expr * bound1, gfc_expr * bound2)\n+compare_bounds (gfc_expr *bound1, gfc_expr *bound2)\n {\n   if (bound1 == NULL || bound2 == NULL\n       || bound1->expr_type != EXPR_CONSTANT\n@@ -510,11 +508,12 @@ compare_bounds (gfc_expr * bound1, gfc_expr * bound2)\n     return 0;\n }\n \n+\n /* Compares two array specifications.  They must be constant or deferred\n    shape.  */\n \n int\n-gfc_compare_array_spec (gfc_array_spec * as1, gfc_array_spec * as2)\n+gfc_compare_array_spec (gfc_array_spec *as1, gfc_array_spec *as2)\n {\n   int i;\n \n@@ -553,7 +552,7 @@ gfc_compare_array_spec (gfc_array_spec * as1, gfc_array_spec * as2)\n    elements and should be appended to by gfc_append_constructor().  */\n \n gfc_expr *\n-gfc_start_constructor (bt type, int kind, locus * where)\n+gfc_start_constructor (bt type, int kind, locus *where)\n {\n   gfc_expr *result;\n \n@@ -573,7 +572,7 @@ gfc_start_constructor (bt type, int kind, locus * where)\n    node onto the constructor.  */\n \n void\n-gfc_append_constructor (gfc_expr * base, gfc_expr * new)\n+gfc_append_constructor (gfc_expr *base, gfc_expr *new)\n {\n   gfc_constructor *c;\n \n@@ -600,7 +599,7 @@ gfc_append_constructor (gfc_expr * base, gfc_expr * new)\n    constructor onto the base's one according to the offset.  */\n \n void\n-gfc_insert_constructor (gfc_expr * base, gfc_constructor * c1)\n+gfc_insert_constructor (gfc_expr *base, gfc_constructor *c1)\n {\n   gfc_constructor *c, *pre;\n   expr_t type;\n@@ -614,40 +613,40 @@ gfc_insert_constructor (gfc_expr * base, gfc_constructor * c1)\n     {\n       c = pre = base->value.constructor;\n       while (c)\n-        {\n-          if (type == EXPR_ARRAY)\n-            {\n+\t{\n+\t  if (type == EXPR_ARRAY)\n+\t    {\n \t      t = mpz_cmp (c->n.offset, c1->n.offset);\n-              if (t < 0)\n-                {\n-                  pre = c;\n-                  c = c->next;\n-                }\n-              else if (t == 0)\n-                {\n-                  gfc_error (\"duplicated initializer\");\n-                  break;\n-                }\n-              else\n-                break;\n-            }\n-          else\n-            {\n-              pre = c;\n-              c = c->next;\n-            }\n-        }\n+\t      if (t < 0)\n+\t\t{\n+\t\t  pre = c;\n+\t\t  c = c->next;\n+\t\t}\n+\t      else if (t == 0)\n+\t\t{\n+\t\t  gfc_error (\"duplicated initializer\");\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\tbreak;\n+\t    }\n+\t  else\n+\t    {\n+\t      pre = c;\n+\t      c = c->next;\n+\t    }\n+\t}\n \n       if (pre != c)\n-        {\n-          pre->next = c1;\n-          c1->next = c;\n-        }\n+\t{\n+\t  pre->next = c1;\n+\t  c1->next = c;\n+\t}\n       else\n-        {\n-          c1->next = c;\n-          base->value.constructor = c1;\n-        }\n+\t{\n+\t  c1->next = c;\n+\t  base->value.constructor = c1;\n+\t}\n     }\n }\n \n@@ -672,7 +671,7 @@ gfc_get_constructor (void)\n /* Free chains of gfc_constructor structures.  */\n \n void\n-gfc_free_constructor (gfc_constructor * p)\n+gfc_free_constructor (gfc_constructor *p)\n {\n   gfc_constructor *next;\n \n@@ -684,7 +683,7 @@ gfc_free_constructor (gfc_constructor * p)\n       next = p->next;\n \n       if (p->expr)\n-        gfc_free_expr (p->expr);\n+\tgfc_free_expr (p->expr);\n       if (p->iterator != NULL)\n \tgfc_free_iterator (p->iterator, 1);\n       mpz_clear (p->n.offset);\n@@ -700,7 +699,7 @@ gfc_free_constructor (gfc_constructor * p)\n    duplicate was found.  */\n \n static int\n-check_duplicate_iterator (gfc_constructor * c, gfc_symbol * master)\n+check_duplicate_iterator (gfc_constructor *c, gfc_symbol *master)\n {\n   gfc_expr *e;\n \n@@ -717,9 +716,8 @@ check_duplicate_iterator (gfc_constructor * c, gfc_symbol * master)\n \n       if (c->iterator->var->symtree->n.sym == master)\n \t{\n-\t  gfc_error\n-\t    (\"DO-iterator '%s' at %L is inside iterator of the same name\",\n-\t     master->name, &c->where);\n+\t  gfc_error (\"DO-iterator '%s' at %L is inside iterator of the \"\n+\t\t     \"same name\", master->name, &c->where);\n \n \t  return 1;\n \t}\n@@ -735,7 +733,7 @@ static match match_array_cons_element (gfc_constructor **);\n /* Match a list of array elements.  */\n \n static match\n-match_array_list (gfc_constructor ** result)\n+match_array_list (gfc_constructor **result)\n {\n   gfc_constructor *p, *head, *tail, *new;\n   gfc_iterator iter;\n@@ -835,7 +833,7 @@ match_array_list (gfc_constructor ** result)\n    single expression or a list of elements.  */\n \n static match\n-match_array_cons_element (gfc_constructor ** result)\n+match_array_cons_element (gfc_constructor **result)\n {\n   gfc_constructor *p;\n   gfc_expr *expr;\n@@ -861,7 +859,7 @@ match_array_cons_element (gfc_constructor ** result)\n /* Match an array constructor.  */\n \n match\n-gfc_match_array_constructor (gfc_expr ** result)\n+gfc_match_array_constructor (gfc_expr **result)\n {\n   gfc_constructor *head, *tail, *new;\n   gfc_expr *expr;\n@@ -872,14 +870,14 @@ gfc_match_array_constructor (gfc_expr ** result)\n   if (gfc_match (\" (/\") == MATCH_NO)\n     {\n       if (gfc_match (\" [\") == MATCH_NO)\n-        return MATCH_NO;\n+\treturn MATCH_NO;\n       else\n-        {\n-          if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: [...] \"\n-                              \"style array constructors at %C\") == FAILURE)\n-            return MATCH_ERROR;\n-          end_delim = \" ]\";\n-        }\n+\t{\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: [...] \"\n+\t\t\t      \"style array constructors at %C\") == FAILURE)\n+\t    return MATCH_ERROR;\n+\t  end_delim = \" ]\";\n+\t}\n     }\n   else\n     end_delim = \" /)\";\n@@ -952,9 +950,8 @@ static enum\n cons_state;\n \n static int\n-check_element_type (gfc_expr * expr)\n+check_element_type (gfc_expr *expr)\n {\n-\n   if (cons_state == CONS_BAD)\n     return 0;\t\t\t/* Suppress further errors */\n \n@@ -986,7 +983,7 @@ check_element_type (gfc_expr * expr)\n /* Recursive work function for gfc_check_constructor_type().  */\n \n static try\n-check_constructor_type (gfc_constructor * c)\n+check_constructor_type (gfc_constructor *c)\n {\n   gfc_expr *e;\n \n@@ -1014,7 +1011,7 @@ check_constructor_type (gfc_constructor * c)\n    On FAILURE, an error has been generated.  */\n \n try\n-gfc_check_constructor_type (gfc_expr * e)\n+gfc_check_constructor_type (gfc_expr *e)\n {\n   try t;\n \n@@ -1039,15 +1036,14 @@ cons_stack;\n \n static cons_stack *base;\n \n-static try check_constructor (gfc_constructor *, try (*)(gfc_expr *));\n+static try check_constructor (gfc_constructor *, try (*) (gfc_expr *));\n \n /* Check an EXPR_VARIABLE expression in a constructor to make sure\n    that that variable is an iteration variables.  */\n \n try\n-gfc_check_iter_variable (gfc_expr * expr)\n+gfc_check_iter_variable (gfc_expr *expr)\n {\n-\n   gfc_symbol *sym;\n   cons_stack *c;\n \n@@ -1066,7 +1062,7 @@ gfc_check_iter_variable (gfc_expr * expr)\n    constructor, giving variables with the names of iterators a pass.  */\n \n static try\n-check_constructor (gfc_constructor * c, try (*check_function) (gfc_expr *))\n+check_constructor (gfc_constructor *c, try (*check_function) (gfc_expr *))\n {\n   cons_stack element;\n   gfc_expr *e;\n@@ -1104,7 +1100,7 @@ check_constructor (gfc_constructor * c, try (*check_function) (gfc_expr *))\n    determined by the check_function.  */\n \n try\n-gfc_check_constructor (gfc_expr * expr, try (*check_function) (gfc_expr *))\n+gfc_check_constructor (gfc_expr *expr, try (*check_function) (gfc_expr *))\n {\n   cons_stack *base_save;\n   try t;\n@@ -1148,7 +1144,7 @@ static try expand_constructor (gfc_constructor *);\n    constructor.  */\n \n static try\n-count_elements (gfc_expr * e)\n+count_elements (gfc_expr *e)\n {\n   mpz_t result;\n \n@@ -1175,7 +1171,7 @@ count_elements (gfc_expr * e)\n    constructor, freeing the rest.  */\n \n static try\n-extract_element (gfc_expr * e)\n+extract_element (gfc_expr *e)\n {\n \n   if (e->rank != 0)\n@@ -1198,9 +1194,8 @@ extract_element (gfc_expr * e)\n    stringing new elements together.  */\n \n static try\n-expand (gfc_expr * e)\n+expand (gfc_expr *e)\n {\n-\n   if (current_expand.new_head == NULL)\n     current_expand.new_head = current_expand.new_tail =\n       gfc_get_constructor ();\n@@ -1224,7 +1219,7 @@ expand (gfc_expr * e)\n    substitute the current value of the iteration variable.  */\n \n void\n-gfc_simplify_iterator_var (gfc_expr * e)\n+gfc_simplify_iterator_var (gfc_expr *e)\n {\n   iterator_stack *p;\n \n@@ -1247,9 +1242,8 @@ gfc_simplify_iterator_var (gfc_expr * e)\n    recursing into other constructors if present.  */\n \n static try\n-expand_expr (gfc_expr * e)\n+expand_expr (gfc_expr *e)\n {\n-\n   if (e->expr_type == EXPR_ARRAY)\n     return expand_constructor (e->value.constructor);\n \n@@ -1266,7 +1260,7 @@ expand_expr (gfc_expr * e)\n \n \n static try\n-expand_iterator (gfc_constructor * c)\n+expand_iterator (gfc_constructor *c)\n {\n   gfc_expr *start, *end, *step;\n   iterator_stack frame;\n@@ -1349,7 +1343,7 @@ expand_iterator (gfc_constructor * c)\n    passed expression.  */\n \n static try\n-expand_constructor (gfc_constructor * c)\n+expand_constructor (gfc_constructor *c)\n {\n   gfc_expr *e;\n \n@@ -1392,7 +1386,7 @@ expand_constructor (gfc_constructor * c)\n    constructor if they are small enough.  */\n \n try\n-gfc_expand_constructor (gfc_expr * e)\n+gfc_expand_constructor (gfc_expr *e)\n {\n   expand_info expand_save;\n   gfc_expr *f;\n@@ -1436,7 +1430,7 @@ gfc_expand_constructor (gfc_expr * e)\n    FAILURE if not so.  */\n \n static try\n-constant_element (gfc_expr * e)\n+constant_element (gfc_expr *e)\n {\n   int rv;\n \n@@ -1454,7 +1448,7 @@ constant_element (gfc_expr * e)\n    function that traverses the expression tree. FIXME.  */\n \n int\n-gfc_constant_ac (gfc_expr * e)\n+gfc_constant_ac (gfc_expr *e)\n {\n   expand_info expand_save;\n   try rc;\n@@ -1477,7 +1471,7 @@ gfc_constant_ac (gfc_expr * e)\n    expanded (no iterators) and zero if iterators are present.  */\n \n int\n-gfc_expanded_ac (gfc_expr * e)\n+gfc_expanded_ac (gfc_expr *e)\n {\n   gfc_constructor *p;\n \n@@ -1496,7 +1490,7 @@ gfc_expanded_ac (gfc_expr * e)\n    be of the same type.  */\n \n static try\n-resolve_array_list (gfc_constructor * p)\n+resolve_array_list (gfc_constructor *p)\n {\n   try t;\n \n@@ -1520,9 +1514,9 @@ resolve_array_list (gfc_constructor * p)\n    its element constructors' length.  */\n \n void\n-gfc_resolve_character_array_constructor (gfc_expr * expr)\n+gfc_resolve_character_array_constructor (gfc_expr *expr)\n {\n-  gfc_constructor * p;\n+  gfc_constructor *p;\n   int max_length;\n \n   gcc_assert (expr->expr_type == EXPR_ARRAY);\n@@ -1550,32 +1544,35 @@ gfc_resolve_character_array_constructor (gfc_expr * expr)\n \n   if (expr->ts.cl->length == NULL)\n     {\n-      /* Find the maximum length of the elements. Do nothing for variable array\n-\t constructor, unless the character length is constant or there is a\n-\tconstant substring reference.  */\n+      /* Find the maximum length of the elements. Do nothing for variable\n+\t array constructor, unless the character length is constant or\n+\t there is a constant substring reference.  */\n \n       for (p = expr->value.constructor; p; p = p->next)\n \t{\n \t  gfc_ref *ref;\n \t  for (ref = p->expr->ref; ref; ref = ref->next)\n \t    if (ref->type == REF_SUBSTRING\n-\t\t  && ref->u.ss.start->expr_type == EXPR_CONSTANT\n-\t\t  && ref->u.ss.end->expr_type == EXPR_CONSTANT)\n+\t\t&& ref->u.ss.start->expr_type == EXPR_CONSTANT\n+\t\t&& ref->u.ss.end->expr_type == EXPR_CONSTANT)\n \t      break;\n \n \t  if (p->expr->expr_type == EXPR_CONSTANT)\n \t    max_length = MAX (p->expr->value.character.length, max_length);\n-\n \t  else if (ref)\n-\t    max_length = MAX ((int)(mpz_get_ui (ref->u.ss.end->value.integer)\n-\t\t\t      - mpz_get_ui (ref->u.ss.start->value.integer))\n-\t\t\t      + 1, max_length);\n-\n+\t    {\n+\t      long j;\n+\t      j = mpz_get_ui (ref->u.ss.end->value.integer)\n+\t\t- mpz_get_ui (ref->u.ss.start->value.integer) + 1;\n+\t      max_length = MAX ((int) j, max_length);\n+\t    }\n \t  else if (p->expr->ts.cl && p->expr->ts.cl->length\n-\t\t     && p->expr->ts.cl->length->expr_type == EXPR_CONSTANT)\n-\t    max_length = MAX ((int)mpz_get_si (p->expr->ts.cl->length->value.integer),\n-\t\t\t      max_length);\n-\n+\t\t   && p->expr->ts.cl->length->expr_type == EXPR_CONSTANT)\n+\t    {\n+\t      long j;\n+\t      j = mpz_get_si (p->expr->ts.cl->length->value.integer);\n+\t      max_length = MAX ((int) j, max_length);\n+\t    }\n \t  else\n \t    return;\n \t}\n@@ -1592,10 +1589,11 @@ gfc_resolve_character_array_constructor (gfc_expr * expr)\n     }\n }\n \n+\n /* Resolve all of the expressions in an array list.  */\n \n try\n-gfc_resolve_array_constructor (gfc_expr * expr)\n+gfc_resolve_array_constructor (gfc_expr *expr)\n {\n   try t;\n \n@@ -1612,7 +1610,7 @@ gfc_resolve_array_constructor (gfc_expr * expr)\n /* Copy an iterator structure.  */\n \n static gfc_iterator *\n-copy_iterator (gfc_iterator * src)\n+copy_iterator (gfc_iterator *src)\n {\n   gfc_iterator *dest;\n \n@@ -1633,7 +1631,7 @@ copy_iterator (gfc_iterator * src)\n /* Copy a constructor structure.  */\n \n gfc_constructor *\n-gfc_copy_constructor (gfc_constructor * src)\n+gfc_copy_constructor (gfc_constructor *src)\n {\n   gfc_constructor *dest;\n   gfc_constructor *tail;\n@@ -1672,7 +1670,7 @@ gfc_copy_constructor (gfc_constructor * src)\n    have to be particularly fast.  */\n \n gfc_expr *\n-gfc_get_array_element (gfc_expr * array, int element)\n+gfc_get_array_element (gfc_expr *array, int element)\n {\n   expand_info expand_save;\n   gfc_expr *e;\n@@ -1708,9 +1706,8 @@ gfc_get_array_element (gfc_expr * array, int element)\n    array is guaranteed to be one dimensional.  */\n \n static try\n-spec_dimen_size (gfc_array_spec * as, int dimen, mpz_t * result)\n+spec_dimen_size (gfc_array_spec *as, int dimen, mpz_t *result)\n {\n-\n   if (as == NULL)\n     return FAILURE;\n \n@@ -1734,7 +1731,7 @@ spec_dimen_size (gfc_array_spec * as, int dimen, mpz_t * result)\n \n \n try\n-spec_size (gfc_array_spec * as, mpz_t * result)\n+spec_size (gfc_array_spec *as, mpz_t *result)\n {\n   mpz_t size;\n   int d;\n@@ -1760,7 +1757,7 @@ spec_size (gfc_array_spec * as, mpz_t * result)\n /* Get the number of elements in an array section.  */\n \n static try\n-ref_dimen_size (gfc_array_ref * ar, int dimen, mpz_t * result)\n+ref_dimen_size (gfc_array_ref *ar, int dimen, mpz_t *result)\n {\n   mpz_t upper, lower, stride;\n   try t;\n@@ -1848,7 +1845,7 @@ ref_dimen_size (gfc_array_ref * ar, int dimen, mpz_t * result)\n \n \n static try\n-ref_size (gfc_array_ref * ar, mpz_t * result)\n+ref_size (gfc_array_ref *ar, mpz_t *result)\n {\n   mpz_t size;\n   int d;\n@@ -1877,7 +1874,7 @@ ref_size (gfc_array_ref * ar, mpz_t * result)\n    otherwise.  */\n \n try\n-gfc_array_dimen_size (gfc_expr * array, int dimen, mpz_t * result)\n+gfc_array_dimen_size (gfc_expr *array, int dimen, mpz_t *result)\n {\n   gfc_ref *ref;\n   int i;\n@@ -1945,7 +1942,7 @@ gfc_array_dimen_size (gfc_expr * array, int dimen, mpz_t * result)\n    variable.  Otherwise returns FAILURE.  */\n \n try\n-gfc_array_size (gfc_expr * array, mpz_t * result)\n+gfc_array_size (gfc_expr *array, mpz_t *result)\n {\n   expand_info expand_save;\n   gfc_ref *ref;\n@@ -2010,7 +2007,7 @@ gfc_array_size (gfc_expr * array, mpz_t * result)\n    array of mpz_t integers.  */\n \n try\n-gfc_array_ref_shape (gfc_array_ref * ar, mpz_t * shape)\n+gfc_array_ref_shape (gfc_array_ref *ar, mpz_t *shape)\n {\n   int d;\n   int i;\n@@ -2055,14 +2052,13 @@ gfc_array_ref_shape (gfc_array_ref * ar, mpz_t * shape)\n    characterizes the reference.  */\n \n gfc_array_ref *\n-gfc_find_array_ref (gfc_expr * e)\n+gfc_find_array_ref (gfc_expr *e)\n {\n   gfc_ref *ref;\n \n   for (ref = e->ref; ref; ref = ref->next)\n     if (ref->type == REF_ARRAY\n-\t&& (ref->u.ar.type == AR_FULL\n-\t    || ref->u.ar.type == AR_SECTION))\n+\t&& (ref->u.ar.type == AR_FULL || ref->u.ar.type == AR_SECTION))\n       break;\n \n   if (ref == NULL)"}, {"sha": "6cee4743c89ecfc438343915ce6831ccacb62105", "filename": "gcc/fortran/bbt.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f8144a803cef2fbd7f73334603318547f4df0b/gcc%2Ffortran%2Fbbt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f8144a803cef2fbd7f73334603318547f4df0b/gcc%2Ffortran%2Fbbt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fbbt.c?ref=65f8144a803cef2fbd7f73334603318547f4df0b", "patch": "@@ -1,5 +1,6 @@\n /* Balanced binary trees using treaps.\n-   Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2002, 2003, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC.\n@@ -62,7 +63,7 @@ pseudo_random (void)\n /* Rotate the treap left.  */\n \n static gfc_bbt *\n-rotate_left (gfc_bbt * t)\n+rotate_left (gfc_bbt *t)\n {\n   gfc_bbt *temp;\n \n@@ -77,7 +78,7 @@ rotate_left (gfc_bbt * t)\n /* Rotate the treap right.  */\n \n static gfc_bbt *\n-rotate_right (gfc_bbt * t)\n+rotate_right (gfc_bbt *t)\n {\n   gfc_bbt *temp;\n \n@@ -93,7 +94,7 @@ rotate_right (gfc_bbt * t)\n    aborts if we find a duplicate key.  */\n \n static gfc_bbt *\n-insert (gfc_bbt * new, gfc_bbt * t, compare_fn compare)\n+insert (gfc_bbt *new, gfc_bbt *t, compare_fn compare)\n {\n   int c;\n \n@@ -108,14 +109,12 @@ insert (gfc_bbt * new, gfc_bbt * t, compare_fn compare)\n       if (t->priority < t->left->priority)\n \tt = rotate_right (t);\n     }\n-\n   else if (c > 0)\n     {\n       t->right = insert (new, t->right, compare);\n       if (t->priority < t->right->priority)\n \tt = rotate_left (t);\n     }\n-\n   else /* if (c == 0)  */\n     gfc_internal_error(\"insert_bbt(): Duplicate key found!\");\n \n@@ -134,13 +133,12 @@ gfc_insert_bbt (void *root, void *new, compare_fn compare)\n \n   r = (gfc_bbt **) root;\n   n = (gfc_bbt *) new;\n-\n   n->priority = pseudo_random ();\n   *r = insert (n, *r, compare);\n }\n \n static gfc_bbt *\n-delete_root (gfc_bbt * t)\n+delete_root (gfc_bbt *t)\n {\n   gfc_bbt *temp;\n \n@@ -170,7 +168,7 @@ delete_root (gfc_bbt * t)\n    Returns the new root node of the tree.  */\n \n static gfc_bbt *\n-delete_treap (gfc_bbt * old, gfc_bbt * t, compare_fn compare)\n+delete_treap (gfc_bbt *old, gfc_bbt *t, compare_fn compare)\n {\n   int c;\n \n@@ -196,6 +194,5 @@ gfc_delete_bbt (void *root, void *old, compare_fn compare)\n   gfc_bbt **t;\n \n   t = (gfc_bbt **) root;\n-\n   *t = delete_treap ((gfc_bbt *) old, *t, compare);\n }"}, {"sha": "6e4d798f6d1ab820d1ea8082c6559ea12bcc989e", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 329, "deletions": 323, "changes": 652, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f8144a803cef2fbd7f73334603318547f4df0b/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f8144a803cef2fbd7f73334603318547f4df0b/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=65f8144a803cef2fbd7f73334603318547f4df0b", "patch": "@@ -1,5 +1,6 @@\n /* Check functions\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught & Katherine Holcomb\n \n This file is part of GCC.\n@@ -36,7 +37,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n /* Check the type of an expression.  */\n \n static try\n-type_check (gfc_expr * e, int n, bt type)\n+type_check (gfc_expr *e, int n, bt type)\n {\n   if (e->ts.type == type)\n     return SUCCESS;\n@@ -52,7 +53,7 @@ type_check (gfc_expr * e, int n, bt type)\n /* Check that the expression is a numeric type.  */\n \n static try\n-numeric_check (gfc_expr * e, int n)\n+numeric_check (gfc_expr *e, int n)\n {\n   if (gfc_numeric_ts (&e->ts))\n     return SUCCESS;\n@@ -67,13 +68,13 @@ numeric_check (gfc_expr * e, int n)\n /* Check that an expression is integer or real.  */\n \n static try\n-int_or_real_check (gfc_expr * e, int n)\n+int_or_real_check (gfc_expr *e, int n)\n {\n   if (e->ts.type != BT_INTEGER && e->ts.type != BT_REAL)\n     {\n-      gfc_error (\n-\t\"'%s' argument of '%s' intrinsic at %L must be INTEGER or REAL\",\n-\tgfc_current_intrinsic_arg[n], gfc_current_intrinsic, &e->where);\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n+\t\t \"or REAL\", gfc_current_intrinsic_arg[n],\n+\t\t gfc_current_intrinsic, &e->where);\n       return FAILURE;\n     }\n \n@@ -84,13 +85,13 @@ int_or_real_check (gfc_expr * e, int n)\n /* Check that an expression is real or complex.  */\n \n static try\n-real_or_complex_check (gfc_expr * e, int n)\n+real_or_complex_check (gfc_expr *e, int n)\n {\n   if (e->ts.type != BT_REAL && e->ts.type != BT_COMPLEX)\n     {\n-      gfc_error (\n-\t\"'%s' argument of '%s' intrinsic at %L must be REAL or COMPLEX\",\n-\tgfc_current_intrinsic_arg[n], gfc_current_intrinsic, &e->where);\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be REAL \"\n+\t\t \"or COMPLEX\", gfc_current_intrinsic_arg[n],\n+\t\t gfc_current_intrinsic, &e->where);\n       return FAILURE;\n     }\n \n@@ -102,7 +103,7 @@ real_or_complex_check (gfc_expr * e, int n)\n    and that it specifies a valid kind for that type.  */\n \n static try\n-kind_check (gfc_expr * k, int n, bt type)\n+kind_check (gfc_expr *k, int n, bt type)\n {\n   int kind;\n \n@@ -114,9 +115,9 @@ kind_check (gfc_expr * k, int n, bt type)\n \n   if (k->expr_type != EXPR_CONSTANT)\n     {\n-      gfc_error (\n-\t\"'%s' argument of '%s' intrinsic at %L must be a constant\",\n-\tgfc_current_intrinsic_arg[n], gfc_current_intrinsic, &k->where);\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a constant\",\n+\t\t gfc_current_intrinsic_arg[n], gfc_current_intrinsic,\n+\t\t &k->where);\n       return FAILURE;\n     }\n \n@@ -135,16 +136,16 @@ kind_check (gfc_expr * k, int n, bt type)\n /* Make sure the expression is a double precision real.  */\n \n static try\n-double_check (gfc_expr * d, int n)\n+double_check (gfc_expr *d, int n)\n {\n   if (type_check (d, n, BT_REAL) == FAILURE)\n     return FAILURE;\n \n   if (d->ts.kind != gfc_default_double_kind)\n     {\n-      gfc_error (\n-\t\"'%s' argument of '%s' intrinsic at %L must be double precision\",\n-\tgfc_current_intrinsic_arg[n], gfc_current_intrinsic, &d->where);\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be double \"\n+\t\t \"precision\", gfc_current_intrinsic_arg[n],\n+\t\t gfc_current_intrinsic, &d->where);\n       return FAILURE;\n     }\n \n@@ -155,13 +156,13 @@ double_check (gfc_expr * d, int n)\n /* Make sure the expression is a logical array.  */\n \n static try\n-logical_array_check (gfc_expr * array, int n)\n+logical_array_check (gfc_expr *array, int n)\n {\n   if (array->ts.type != BT_LOGICAL || array->rank == 0)\n     {\n-      gfc_error (\n-\t\"'%s' argument of '%s' intrinsic at %L must be a logical array\",\n-\tgfc_current_intrinsic_arg[n], gfc_current_intrinsic, &array->where);\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a logical \"\n+\t\t \"array\", gfc_current_intrinsic_arg[n], gfc_current_intrinsic,\n+\t\t &array->where);\n       return FAILURE;\n     }\n \n@@ -172,7 +173,7 @@ logical_array_check (gfc_expr * array, int n)\n /* Make sure an expression is an array.  */\n \n static try\n-array_check (gfc_expr * e, int n)\n+array_check (gfc_expr *e, int n)\n {\n   if (e->rank != 0)\n     return SUCCESS;\n@@ -187,7 +188,7 @@ array_check (gfc_expr * e, int n)\n /* Make sure an expression is a scalar.  */\n \n static try\n-scalar_check (gfc_expr * e, int n)\n+scalar_check (gfc_expr *e, int n)\n {\n   if (e->rank == 0)\n     return SUCCESS;\n@@ -202,44 +203,45 @@ scalar_check (gfc_expr * e, int n)\n /* Make sure two expressions have the same type.  */\n \n static try\n-same_type_check (gfc_expr * e, int n, gfc_expr * f, int m)\n+same_type_check (gfc_expr *e, int n, gfc_expr *f, int m)\n {\n   if (gfc_compare_types (&e->ts, &f->ts))\n     return SUCCESS;\n \n   gfc_error (\"'%s' argument of '%s' intrinsic at %L must be the same type \"\n \t     \"and kind as '%s'\", gfc_current_intrinsic_arg[m],\n \t     gfc_current_intrinsic, &f->where, gfc_current_intrinsic_arg[n]);\n+\n   return FAILURE;\n }\n \n \n /* Make sure that an expression has a certain (nonzero) rank.  */\n \n static try\n-rank_check (gfc_expr * e, int n, int rank)\n+rank_check (gfc_expr *e, int n, int rank)\n {\n   if (e->rank == rank)\n     return SUCCESS;\n \n   gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of rank %d\",\n \t     gfc_current_intrinsic_arg[n], gfc_current_intrinsic,\n \t     &e->where, rank);\n+\n   return FAILURE;\n }\n \n \n /* Make sure a variable expression is not an optional dummy argument.  */\n \n static try\n-nonoptional_check (gfc_expr * e, int n)\n+nonoptional_check (gfc_expr *e, int n)\n {\n   if (e->expr_type == EXPR_VARIABLE && e->symtree->n.sym->attr.optional)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must not be OPTIONAL\",\n \t\t gfc_current_intrinsic_arg[n], gfc_current_intrinsic,\n \t\t &e->where);\n-\n     }\n \n   /* TODO: Recursive check on nonoptional variables?  */\n@@ -251,22 +253,23 @@ nonoptional_check (gfc_expr * e, int n)\n /* Check that an expression has a particular kind.  */\n \n static try\n-kind_value_check (gfc_expr * e, int n, int k)\n+kind_value_check (gfc_expr *e, int n, int k)\n {\n   if (e->ts.kind == k)\n     return SUCCESS;\n \n   gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of kind %d\",\n \t     gfc_current_intrinsic_arg[n], gfc_current_intrinsic,\n \t     &e->where, k);\n+\n   return FAILURE;\n }\n \n \n /* Make sure an expression is a variable.  */\n \n static try\n-variable_check (gfc_expr * e, int n)\n+variable_check (gfc_expr *e, int n)\n {\n   if ((e->expr_type == EXPR_VARIABLE\n        && e->symtree->n.sym->attr.flavor != FL_PARAMETER)\n@@ -293,7 +296,7 @@ variable_check (gfc_expr * e, int n)\n /* Check the common DIM parameter for correctness.  */\n \n static try\n-dim_check (gfc_expr * dim, int n, int optional)\n+dim_check (gfc_expr *dim, int n, int optional)\n {\n   if (optional && dim == NULL)\n     return SUCCESS;\n@@ -324,7 +327,7 @@ dim_check (gfc_expr * dim, int n, int optional)\n    for assumed size arrays.  */\n \n static try\n-dim_rank_check (gfc_expr * dim, gfc_expr * array, int allow_assumed)\n+dim_rank_check (gfc_expr *dim, gfc_expr *array, int allow_assumed)\n {\n   gfc_array_ref *ar;\n   int rank;\n@@ -349,6 +352,7 @@ dim_rank_check (gfc_expr * dim, gfc_expr * array, int allow_assumed)\n   return SUCCESS;\n }\n \n+\n /* Compare the size of a along dimension ai with the size of b along\n    dimension bi, returning 0 if they are known not to be identical,\n    and 1 if they are identical, or if this cannot be determined.  */\n@@ -378,6 +382,7 @@ identical_dimen_shape (gfc_expr *a, int ai, gfc_expr *b, int bi)\n   return ret;\n }\n \n+\n /* Error return for transformational intrinsics not allowed in\n    initialization expressions.  */\n  \n@@ -396,7 +401,7 @@ non_init_transformational (void)\n    a kind argument for the result.  */\n \n static try\n-check_a_kind (gfc_expr * a, gfc_expr * kind, bt type)\n+check_a_kind (gfc_expr *a, gfc_expr *kind, bt type)\n {\n   if (type_check (a, 0, BT_REAL) == FAILURE)\n     return FAILURE;\n@@ -406,35 +411,38 @@ check_a_kind (gfc_expr * a, gfc_expr * kind, bt type)\n   return SUCCESS;\n }\n \n+\n /* Check subroutine suitable for ceiling, floor and nint.  */\n \n try\n-gfc_check_a_ikind (gfc_expr * a, gfc_expr * kind)\n+gfc_check_a_ikind (gfc_expr *a, gfc_expr *kind)\n {\n   return check_a_kind (a, kind, BT_INTEGER);\n }\n \n+\n /* Check subroutine suitable for aint, anint.  */\n \n try\n-gfc_check_a_xkind (gfc_expr * a, gfc_expr * kind)\n+gfc_check_a_xkind (gfc_expr *a, gfc_expr *kind)\n {\n   return check_a_kind (a, kind, BT_REAL);\n }\n \n+\n try\n-gfc_check_abs (gfc_expr * a)\n+gfc_check_abs (gfc_expr *a)\n {\n   if (numeric_check (a, 0) == FAILURE)\n     return FAILURE;\n \n   return SUCCESS;\n }\n \n+\n try\n-gfc_check_achar (gfc_expr * a)\n+gfc_check_achar (gfc_expr *a)\n {\n-\n   if (type_check (a, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n@@ -443,13 +451,12 @@ gfc_check_achar (gfc_expr * a)\n \n \n try\n-gfc_check_access_func (gfc_expr * name, gfc_expr * mode)\n+gfc_check_access_func (gfc_expr *name, gfc_expr *mode)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE\n       || scalar_check (name, 0) == FAILURE)\n     return FAILURE;\n \n-\n   if (type_check (mode, 1, BT_CHARACTER) == FAILURE\n       || scalar_check (mode, 1) == FAILURE)\n     return FAILURE;\n@@ -459,7 +466,7 @@ gfc_check_access_func (gfc_expr * name, gfc_expr * mode)\n \n \n try\n-gfc_check_all_any (gfc_expr * mask, gfc_expr * dim)\n+gfc_check_all_any (gfc_expr *mask, gfc_expr *dim)\n {\n   if (logical_array_check (mask, 0) == FAILURE)\n     return FAILURE;\n@@ -475,7 +482,7 @@ gfc_check_all_any (gfc_expr * mask, gfc_expr * dim)\n \n \n try\n-gfc_check_allocated (gfc_expr * array)\n+gfc_check_allocated (gfc_expr *array)\n {\n   symbol_attribute attr;\n \n@@ -502,24 +509,24 @@ gfc_check_allocated (gfc_expr * array)\n    integer and the second argument must be the same as the first.  */\n \n try\n-gfc_check_a_p (gfc_expr * a, gfc_expr * p)\n+gfc_check_a_p (gfc_expr *a, gfc_expr *p)\n {\n   if (int_or_real_check (a, 0) == FAILURE)\n     return FAILURE;\n \n   if (a->ts.type != p->ts.type)\n     {\n       gfc_error (\"'%s' and '%s' arguments of '%s' intrinsic at %L must \"\n-                \"have the same type\", gfc_current_intrinsic_arg[0],\n-                gfc_current_intrinsic_arg[1], gfc_current_intrinsic,\n-                &p->where);\n+\t\t \"have the same type\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic_arg[1], gfc_current_intrinsic,\n+\t\t &p->where);\n       return FAILURE;\n     }\n \n   if (a->ts.kind != p->ts.kind)\n     {\n       if (gfc_notify_std (GFC_STD_GNU, \"Extension: Different type kinds at %L\",\n-                          &p->where) == FAILURE)\n+\t\t\t  &p->where) == FAILURE)\n        return FAILURE;\n     }\n \n@@ -528,7 +535,7 @@ gfc_check_a_p (gfc_expr * a, gfc_expr * p)\n \n \n try\n-gfc_check_associated (gfc_expr * pointer, gfc_expr * target)\n+gfc_check_associated (gfc_expr *pointer, gfc_expr *target)\n {\n   symbol_attribute attr;\n   int i;\n@@ -590,14 +597,14 @@ gfc_check_associated (gfc_expr * pointer, gfc_expr * target)\n   if (target->rank > 0)\n     {\n       for (i = 0; i < target->rank; i++)\n-        if (target->ref->u.ar.dimen_type[i] == DIMEN_VECTOR)\n-          {\n-            gfc_error (\"Array section with a vector subscript at %L shall not \"\n+\tif (target->ref->u.ar.dimen_type[i] == DIMEN_VECTOR)\n+\t  {\n+\t    gfc_error (\"Array section with a vector subscript at %L shall not \"\n \t\t       \"be the target of a pointer\",\n-                       &target->where);\n-            t = FAILURE;\n-            break;\n-          }\n+\t\t       &target->where);\n+\t    t = FAILURE;\n+\t    break;\n+\t  }\n     }\n   return t;\n \n@@ -611,7 +618,7 @@ gfc_check_associated (gfc_expr * pointer, gfc_expr * target)\n \n \n try\n-gfc_check_atan2 (gfc_expr * y, gfc_expr * x)\n+gfc_check_atan2 (gfc_expr *y, gfc_expr *x)\n {\n   if (type_check (y, 0, BT_REAL) == FAILURE)\n     return FAILURE;\n@@ -625,7 +632,7 @@ gfc_check_atan2 (gfc_expr * y, gfc_expr * x)\n /* BESJN and BESYN functions.  */\n \n try\n-gfc_check_besn (gfc_expr * n, gfc_expr * x)\n+gfc_check_besn (gfc_expr *n, gfc_expr *x)\n {\n   if (scalar_check (n, 0) == FAILURE)\n     return FAILURE;\n@@ -644,7 +651,7 @@ gfc_check_besn (gfc_expr * n, gfc_expr * x)\n \n \n try\n-gfc_check_btest (gfc_expr * i, gfc_expr * pos)\n+gfc_check_btest (gfc_expr *i, gfc_expr *pos)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -656,7 +663,7 @@ gfc_check_btest (gfc_expr * i, gfc_expr * pos)\n \n \n try\n-gfc_check_char (gfc_expr * i, gfc_expr * kind)\n+gfc_check_char (gfc_expr *i, gfc_expr *kind)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -668,7 +675,7 @@ gfc_check_char (gfc_expr * i, gfc_expr * kind)\n \n \n try\n-gfc_check_chdir (gfc_expr * dir)\n+gfc_check_chdir (gfc_expr *dir)\n {\n   if (type_check (dir, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -678,7 +685,7 @@ gfc_check_chdir (gfc_expr * dir)\n \n \n try\n-gfc_check_chdir_sub (gfc_expr * dir, gfc_expr * status)\n+gfc_check_chdir_sub (gfc_expr *dir, gfc_expr *status)\n {\n   if (type_check (dir, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -697,7 +704,7 @@ gfc_check_chdir_sub (gfc_expr * dir, gfc_expr * status)\n \n \n try\n-gfc_check_chmod (gfc_expr * name, gfc_expr * mode)\n+gfc_check_chmod (gfc_expr *name, gfc_expr *mode)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -710,7 +717,7 @@ gfc_check_chmod (gfc_expr * name, gfc_expr * mode)\n \n \n try\n-gfc_check_chmod_sub (gfc_expr * name, gfc_expr * mode, gfc_expr * status)\n+gfc_check_chmod_sub (gfc_expr *name, gfc_expr *mode, gfc_expr *status)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -732,7 +739,7 @@ gfc_check_chmod_sub (gfc_expr * name, gfc_expr * mode, gfc_expr * status)\n \n \n try\n-gfc_check_cmplx (gfc_expr * x, gfc_expr * y, gfc_expr * kind)\n+gfc_check_cmplx (gfc_expr *x, gfc_expr *y, gfc_expr *kind)\n {\n   if (numeric_check (x, 0) == FAILURE)\n     return FAILURE;\n@@ -759,23 +766,23 @@ gfc_check_cmplx (gfc_expr * x, gfc_expr * y, gfc_expr * kind)\n \n \n try\n-gfc_check_complex (gfc_expr * x, gfc_expr * y)\n+gfc_check_complex (gfc_expr *x, gfc_expr *y)\n {\n   if (x->ts.type != BT_INTEGER && x->ts.type != BT_REAL)\n     {\n-      gfc_error (\n-\t\"'%s' argument of '%s' intrinsic at %L must be INTEGER or REAL\",\n-\tgfc_current_intrinsic_arg[0], gfc_current_intrinsic, &x->where);\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n+\t\t \"or REAL\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic, &x->where);\n       return FAILURE;\n     }\n   if (scalar_check (x, 0) == FAILURE)\n     return FAILURE;\n \n   if (y->ts.type != BT_INTEGER && y->ts.type != BT_REAL)\n     {\n-      gfc_error (\n-\t\"'%s' argument of '%s' intrinsic at %L must be INTEGER or REAL\",\n-\tgfc_current_intrinsic_arg[1], gfc_current_intrinsic, &y->where);\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n+\t\t \"or REAL\", gfc_current_intrinsic_arg[1],\n+\t\t gfc_current_intrinsic, &y->where);\n       return FAILURE;\n     }\n   if (scalar_check (y, 1) == FAILURE)\n@@ -786,7 +793,7 @@ gfc_check_complex (gfc_expr * x, gfc_expr * y)\n \n \n try\n-gfc_check_count (gfc_expr * mask, gfc_expr * dim)\n+gfc_check_count (gfc_expr *mask, gfc_expr *dim)\n {\n   if (logical_array_check (mask, 0) == FAILURE)\n     return FAILURE;\n@@ -801,7 +808,7 @@ gfc_check_count (gfc_expr * mask, gfc_expr * dim)\n \n \n try\n-gfc_check_cshift (gfc_expr * array, gfc_expr * shift, gfc_expr * dim)\n+gfc_check_cshift (gfc_expr *array, gfc_expr *shift, gfc_expr *dim)\n {\n   if (array_check (array, 0) == FAILURE)\n     return FAILURE;\n@@ -827,7 +834,7 @@ gfc_check_cshift (gfc_expr * array, gfc_expr * shift, gfc_expr * dim)\n \n \n try\n-gfc_check_ctime (gfc_expr * time)\n+gfc_check_ctime (gfc_expr *time)\n {\n   if (scalar_check (time, 0) == FAILURE)\n     return FAILURE;\n@@ -840,7 +847,7 @@ gfc_check_ctime (gfc_expr * time)\n \n \n try\n-gfc_check_dcmplx (gfc_expr * x, gfc_expr * y)\n+gfc_check_dcmplx (gfc_expr *x, gfc_expr *y)\n {\n   if (numeric_check (x, 0) == FAILURE)\n     return FAILURE;\n@@ -864,7 +871,7 @@ gfc_check_dcmplx (gfc_expr * x, gfc_expr * y)\n \n \n try\n-gfc_check_dble (gfc_expr * x)\n+gfc_check_dble (gfc_expr *x)\n {\n   if (numeric_check (x, 0) == FAILURE)\n     return FAILURE;\n@@ -874,7 +881,7 @@ gfc_check_dble (gfc_expr * x)\n \n \n try\n-gfc_check_digits (gfc_expr * x)\n+gfc_check_digits (gfc_expr *x)\n {\n   if (int_or_real_check (x, 0) == FAILURE)\n     return FAILURE;\n@@ -884,7 +891,7 @@ gfc_check_digits (gfc_expr * x)\n \n \n try\n-gfc_check_dot_product (gfc_expr * vector_a, gfc_expr * vector_b)\n+gfc_check_dot_product (gfc_expr *vector_a, gfc_expr *vector_b)\n {\n   switch (vector_a->ts.type)\n     {\n@@ -915,11 +922,9 @@ gfc_check_dot_product (gfc_expr * vector_a, gfc_expr * vector_b)\n \n   if (! identical_dimen_shape (vector_a, 0, vector_b, 0))\n     {\n-      gfc_error (\"different shape for arguments '%s' and '%s' \"\n-\t\t \"at %L for intrinsic 'dot_product'\",\n-\t\t gfc_current_intrinsic_arg[0],\n-\t\t gfc_current_intrinsic_arg[1],\n-\t\t &vector_a->where);\n+      gfc_error (\"different shape for arguments '%s' and '%s' at %L for \"\n+\t\t \"intrinsic 'dot_product'\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic_arg[1], &vector_a->where);\n       return FAILURE;\n     }\n \n@@ -931,8 +936,8 @@ gfc_check_dot_product (gfc_expr * vector_a, gfc_expr * vector_b)\n \n \n try\n-gfc_check_eoshift (gfc_expr * array, gfc_expr * shift, gfc_expr * boundary,\n-\t\t   gfc_expr * dim)\n+gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n+\t\t   gfc_expr *dim)\n {\n   if (array_check (array, 0) == FAILURE)\n     return FAILURE;\n@@ -971,7 +976,7 @@ gfc_check_eoshift (gfc_expr * array, gfc_expr * shift, gfc_expr * boundary,\n /* A single complex argument.  */\n \n try\n-gfc_check_fn_c (gfc_expr * a)\n+gfc_check_fn_c (gfc_expr *a)\n {\n   if (type_check (a, 0, BT_COMPLEX) == FAILURE)\n     return FAILURE;\n@@ -983,7 +988,7 @@ gfc_check_fn_c (gfc_expr * a)\n /* A single real argument.  */\n \n try\n-gfc_check_fn_r (gfc_expr * a)\n+gfc_check_fn_r (gfc_expr *a)\n {\n   if (type_check (a, 0, BT_REAL) == FAILURE)\n     return FAILURE;\n@@ -995,7 +1000,7 @@ gfc_check_fn_r (gfc_expr * a)\n /* A single real or complex argument.  */\n \n try\n-gfc_check_fn_rc (gfc_expr * a)\n+gfc_check_fn_rc (gfc_expr *a)\n {\n   if (real_or_complex_check (a, 0) == FAILURE)\n     return FAILURE;\n@@ -1005,7 +1010,7 @@ gfc_check_fn_rc (gfc_expr * a)\n \n \n try\n-gfc_check_fnum (gfc_expr * unit)\n+gfc_check_fnum (gfc_expr *unit)\n {\n   if (type_check (unit, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -1021,7 +1026,7 @@ gfc_check_fnum (gfc_expr * unit)\n    error function.  */\n \n try\n-gfc_check_g77_math1 (gfc_expr * x)\n+gfc_check_g77_math1 (gfc_expr *x)\n {\n   if (scalar_check (x, 0) == FAILURE)\n     return FAILURE;\n@@ -1034,7 +1039,7 @@ gfc_check_g77_math1 (gfc_expr * x)\n \n \n try\n-gfc_check_huge (gfc_expr * x)\n+gfc_check_huge (gfc_expr *x)\n {\n   if (int_or_real_check (x, 0) == FAILURE)\n     return FAILURE;\n@@ -1046,7 +1051,7 @@ gfc_check_huge (gfc_expr * x)\n /* Check that the single argument is an integer.  */\n \n try\n-gfc_check_i (gfc_expr * i)\n+gfc_check_i (gfc_expr *i)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -1056,7 +1061,7 @@ gfc_check_i (gfc_expr * i)\n \n \n try\n-gfc_check_iand (gfc_expr * i, gfc_expr * j)\n+gfc_check_iand (gfc_expr *i, gfc_expr *j)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -1067,7 +1072,7 @@ gfc_check_iand (gfc_expr * i, gfc_expr * j)\n   if (i->ts.kind != j->ts.kind)\n     {\n       if (gfc_notify_std (GFC_STD_GNU, \"Extension: Different type kinds at %L\",\n-                          &i->where) == FAILURE)\n+\t\t\t  &i->where) == FAILURE)\n \treturn FAILURE;\n     }\n \n@@ -1076,7 +1081,7 @@ gfc_check_iand (gfc_expr * i, gfc_expr * j)\n \n \n try\n-gfc_check_ibclr (gfc_expr * i, gfc_expr * pos)\n+gfc_check_ibclr (gfc_expr *i, gfc_expr *pos)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -1089,7 +1094,7 @@ gfc_check_ibclr (gfc_expr * i, gfc_expr * pos)\n \n \n try\n-gfc_check_ibits (gfc_expr * i, gfc_expr * pos, gfc_expr * len)\n+gfc_check_ibits (gfc_expr *i, gfc_expr *pos, gfc_expr *len)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -1105,7 +1110,7 @@ gfc_check_ibits (gfc_expr * i, gfc_expr * pos, gfc_expr * len)\n \n \n try\n-gfc_check_ibset (gfc_expr * i, gfc_expr * pos)\n+gfc_check_ibset (gfc_expr *i, gfc_expr *pos)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -1118,7 +1123,7 @@ gfc_check_ibset (gfc_expr * i, gfc_expr * pos)\n \n \n try\n-gfc_check_ichar_iachar (gfc_expr * c)\n+gfc_check_ichar_iachar (gfc_expr *c)\n {\n   int i;\n \n@@ -1140,7 +1145,7 @@ gfc_check_ichar_iachar (gfc_expr * c)\n \n       if (!ref)\n \t{\n-          /* Check that the argument is length one.  Non-constant lengths\n+\t  /* Check that the argument is length one.  Non-constant lengths\n \t     can't be checked here, so assume they are ok.  */\n \t  if (c->ts.cl && c->ts.cl->length)\n \t    {\n@@ -1163,7 +1168,7 @@ gfc_check_ichar_iachar (gfc_expr * c)\n \t    return SUCCESS;\n \n \t  i = mpz_get_si (end->value.integer) + 1\n-\t      - mpz_get_si (start->value.integer);\n+\t    - mpz_get_si (start->value.integer);\n \t}\n     }\n   else\n@@ -1181,7 +1186,7 @@ gfc_check_ichar_iachar (gfc_expr * c)\n \n \n try\n-gfc_check_idnint (gfc_expr * a)\n+gfc_check_idnint (gfc_expr *a)\n {\n   if (double_check (a, 0) == FAILURE)\n     return FAILURE;\n@@ -1191,7 +1196,7 @@ gfc_check_idnint (gfc_expr * a)\n \n \n try\n-gfc_check_ieor (gfc_expr * i, gfc_expr * j)\n+gfc_check_ieor (gfc_expr *i, gfc_expr *j)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -1202,7 +1207,7 @@ gfc_check_ieor (gfc_expr * i, gfc_expr * j)\n   if (i->ts.kind != j->ts.kind)\n     {\n       if (gfc_notify_std (GFC_STD_GNU, \"Extension: Different type kinds at %L\",\n-                          &i->where) == FAILURE)\n+\t\t\t  &i->where) == FAILURE)\n \treturn FAILURE;\n     }\n \n@@ -1211,7 +1216,7 @@ gfc_check_ieor (gfc_expr * i, gfc_expr * j)\n \n \n try\n-gfc_check_index (gfc_expr * string, gfc_expr * substring, gfc_expr * back)\n+gfc_check_index (gfc_expr *string, gfc_expr *substring, gfc_expr *back)\n {\n   if (type_check (string, 0, BT_CHARACTER) == FAILURE\n       || type_check (substring, 1, BT_CHARACTER) == FAILURE)\n@@ -1235,15 +1240,15 @@ gfc_check_index (gfc_expr * string, gfc_expr * substring, gfc_expr * back)\n \n \n try\n-gfc_check_int (gfc_expr * x, gfc_expr * kind)\n+gfc_check_int (gfc_expr *x, gfc_expr *kind)\n {\n   if (numeric_check (x, 0) == FAILURE)\n     return FAILURE;\n \n   if (kind != NULL)\n     {\n       if (type_check (kind, 1, BT_INTEGER) == FAILURE)\n-    return FAILURE;\n+\treturn FAILURE;\n \n       if (scalar_check (kind, 1) == FAILURE)\n \treturn FAILURE;\n@@ -1254,7 +1259,7 @@ gfc_check_int (gfc_expr * x, gfc_expr * kind)\n \n \n try\n-gfc_check_intconv (gfc_expr * x)\n+gfc_check_intconv (gfc_expr *x)\n {\n   if (numeric_check (x, 0) == FAILURE)\n     return FAILURE;\n@@ -1264,7 +1269,7 @@ gfc_check_intconv (gfc_expr * x)\n \n \n try\n-gfc_check_ior (gfc_expr * i, gfc_expr * j)\n+gfc_check_ior (gfc_expr *i, gfc_expr *j)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -1275,16 +1280,16 @@ gfc_check_ior (gfc_expr * i, gfc_expr * j)\n   if (i->ts.kind != j->ts.kind)\n     {\n       if (gfc_notify_std (GFC_STD_GNU, \"Extension: Different type kinds at %L\",\n-                          &i->where) == FAILURE)\n-    return FAILURE;\n+\t\t\t  &i->where) == FAILURE)\n+\treturn FAILURE;\n     }\n \n   return SUCCESS;\n }\n \n \n try\n-gfc_check_ishft (gfc_expr * i, gfc_expr * shift)\n+gfc_check_ishft (gfc_expr *i, gfc_expr *shift)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE\n       || type_check (shift, 1, BT_INTEGER) == FAILURE)\n@@ -1295,7 +1300,7 @@ gfc_check_ishft (gfc_expr * i, gfc_expr * shift)\n \n \n try\n-gfc_check_ishftc (gfc_expr * i, gfc_expr * shift, gfc_expr * size)\n+gfc_check_ishftc (gfc_expr *i, gfc_expr *shift, gfc_expr *size)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE\n       || type_check (shift, 1, BT_INTEGER) == FAILURE)\n@@ -1309,7 +1314,7 @@ gfc_check_ishftc (gfc_expr * i, gfc_expr * shift, gfc_expr * size)\n \n \n try\n-gfc_check_kill (gfc_expr * pid, gfc_expr * sig)\n+gfc_check_kill (gfc_expr *pid, gfc_expr *sig)\n {\n   if (type_check (pid, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -1322,7 +1327,7 @@ gfc_check_kill (gfc_expr * pid, gfc_expr * sig)\n \n \n try\n-gfc_check_kill_sub (gfc_expr * pid, gfc_expr * sig, gfc_expr * status)\n+gfc_check_kill_sub (gfc_expr *pid, gfc_expr *sig, gfc_expr *status)\n {\n   if (type_check (pid, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -1350,7 +1355,7 @@ gfc_check_kill_sub (gfc_expr * pid, gfc_expr * sig, gfc_expr * status)\n \n \n try\n-gfc_check_kind (gfc_expr * x)\n+gfc_check_kind (gfc_expr *x)\n {\n   if (x->ts.type == BT_DERIVED)\n     {\n@@ -1365,7 +1370,7 @@ gfc_check_kind (gfc_expr * x)\n \n \n try\n-gfc_check_lbound (gfc_expr * array, gfc_expr * dim)\n+gfc_check_lbound (gfc_expr *array, gfc_expr *dim)\n {\n   if (array_check (array, 0) == FAILURE)\n     return FAILURE;\n@@ -1383,7 +1388,7 @@ gfc_check_lbound (gfc_expr * array, gfc_expr * dim)\n \n \n try\n-gfc_check_link (gfc_expr * path1, gfc_expr * path2)\n+gfc_check_link (gfc_expr *path1, gfc_expr *path2)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -1396,7 +1401,7 @@ gfc_check_link (gfc_expr * path1, gfc_expr * path2)\n \n \n try\n-gfc_check_link_sub (gfc_expr * path1, gfc_expr * path2, gfc_expr * status)\n+gfc_check_link_sub (gfc_expr *path1, gfc_expr *path2, gfc_expr *status)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -1416,6 +1421,7 @@ gfc_check_link_sub (gfc_expr * path1, gfc_expr * path2, gfc_expr * status)\n   return SUCCESS;\n }\n \n+\n try\n gfc_check_loc (gfc_expr *expr)\n {\n@@ -1424,7 +1430,7 @@ gfc_check_loc (gfc_expr *expr)\n \n \n try\n-gfc_check_symlnk (gfc_expr * path1, gfc_expr * path2)\n+gfc_check_symlnk (gfc_expr *path1, gfc_expr *path2)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -1437,7 +1443,7 @@ gfc_check_symlnk (gfc_expr * path1, gfc_expr * path2)\n \n \n try\n-gfc_check_symlnk_sub (gfc_expr * path1, gfc_expr * path2, gfc_expr * status)\n+gfc_check_symlnk_sub (gfc_expr *path1, gfc_expr *path2, gfc_expr *status)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -1459,7 +1465,7 @@ gfc_check_symlnk_sub (gfc_expr * path1, gfc_expr * path2, gfc_expr * status)\n \n \n try\n-gfc_check_logical (gfc_expr * a, gfc_expr * kind)\n+gfc_check_logical (gfc_expr *a, gfc_expr *kind)\n {\n   if (type_check (a, 0, BT_LOGICAL) == FAILURE)\n     return FAILURE;\n@@ -1473,7 +1479,7 @@ gfc_check_logical (gfc_expr * a, gfc_expr * kind)\n /* Min/max family.  */\n \n static try\n-min_max_args (gfc_actual_arglist * arg)\n+min_max_args (gfc_actual_arglist *arg)\n {\n   if (arg == NULL || arg->next == NULL)\n     {\n@@ -1487,7 +1493,7 @@ min_max_args (gfc_actual_arglist * arg)\n \n \n static try\n-check_rest (bt type, int kind, gfc_actual_arglist * arg)\n+check_rest (bt type, int kind, gfc_actual_arglist *arg)\n {\n   gfc_expr *x;\n   int n;\n@@ -1502,20 +1508,19 @@ check_rest (bt type, int kind, gfc_actual_arglist * arg)\n       x = arg->expr;\n       if (x->ts.type != type || x->ts.kind != kind)\n \t{\n-          if (x->ts.type == type)\n-            {\n-\t      if (gfc_notify_std (GFC_STD_GNU,\n-\t\t    \"Extension: Different type kinds at %L\", &x->where)\n-\t\t  == FAILURE)\n+\t  if (x->ts.type == type)\n+\t    {\n+\t      if (gfc_notify_std (GFC_STD_GNU, \"Extension: Different type \"\n+\t\t\t\t  \"kinds at %L\", &x->where) == FAILURE)\n \t\treturn FAILURE;\n-            }\n-          else\n-            {\n-              gfc_error (\"'a%d' argument of '%s' intrinsic at %L must be %s(%d)\",\n-                         n, gfc_current_intrinsic, &x->where,\n-                         gfc_basic_typename (type), kind);\n-              return FAILURE;\n-            }\n+\t    }\n+\t  else\n+\t    {\n+\t      gfc_error (\"'a%d' argument of '%s' intrinsic at %L must be \"\n+\t\t\t \"%s(%d)\", n, gfc_current_intrinsic, &x->where,\n+\t\t\t gfc_basic_typename (type), kind);\n+\t      return FAILURE;\n+\t    }\n \t}\n     }\n \n@@ -1524,7 +1529,7 @@ check_rest (bt type, int kind, gfc_actual_arglist * arg)\n \n \n try\n-gfc_check_min_max (gfc_actual_arglist * arg)\n+gfc_check_min_max (gfc_actual_arglist *arg)\n {\n   gfc_expr *x;\n \n@@ -1535,9 +1540,8 @@ gfc_check_min_max (gfc_actual_arglist * arg)\n \n   if (x->ts.type != BT_INTEGER && x->ts.type != BT_REAL)\n     {\n-      gfc_error\n-\t(\"'a1' argument of '%s' intrinsic at %L must be INTEGER or REAL\",\n-\t gfc_current_intrinsic, &x->where);\n+      gfc_error (\"'a1' argument of '%s' intrinsic at %L must be INTEGER \"\n+\t\t \"or REAL\", gfc_current_intrinsic, &x->where);\n       return FAILURE;\n     }\n \n@@ -1546,29 +1550,30 @@ gfc_check_min_max (gfc_actual_arglist * arg)\n \n \n try\n-gfc_check_min_max_integer (gfc_actual_arglist * arg)\n+gfc_check_min_max_integer (gfc_actual_arglist *arg)\n {\n   return check_rest (BT_INTEGER, gfc_default_integer_kind, arg);\n }\n \n \n try\n-gfc_check_min_max_real (gfc_actual_arglist * arg)\n+gfc_check_min_max_real (gfc_actual_arglist *arg)\n {\n   return check_rest (BT_REAL, gfc_default_real_kind, arg);\n }\n \n \n try\n-gfc_check_min_max_double (gfc_actual_arglist * arg)\n+gfc_check_min_max_double (gfc_actual_arglist *arg)\n {\n   return check_rest (BT_REAL, gfc_default_double_kind, arg);\n }\n \n+\n /* End of min/max family.  */\n \n try\n-gfc_check_malloc (gfc_expr * size)\n+gfc_check_malloc (gfc_expr *size)\n {\n   if (type_check (size, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -1581,7 +1586,7 @@ gfc_check_malloc (gfc_expr * size)\n \n \n try\n-gfc_check_matmul (gfc_expr * matrix_a, gfc_expr * matrix_b)\n+gfc_check_matmul (gfc_expr *matrix_a, gfc_expr *matrix_b)\n {\n   if ((matrix_a->ts.type != BT_LOGICAL) && !gfc_numeric_ts (&matrix_b->ts))\n     {\n@@ -1605,13 +1610,12 @@ gfc_check_matmul (gfc_expr * matrix_a, gfc_expr * matrix_b)\n       if (rank_check (matrix_b, 1, 2) == FAILURE)\n \treturn FAILURE;\n       /* Check for case matrix_a has shape(m), matrix_b has shape (m, k).  */\n-      if (! identical_dimen_shape (matrix_a, 0, matrix_b, 0))\n+      if (!identical_dimen_shape (matrix_a, 0, matrix_b, 0))\n \t{\n \t  gfc_error (\"different shape on dimension 1 for arguments '%s' \"\n \t\t     \"and '%s' at %L for intrinsic matmul\",\n \t\t     gfc_current_intrinsic_arg[0],\n-\t\t     gfc_current_intrinsic_arg[1],\n-\t\t     &matrix_a->where);\n+\t\t     gfc_current_intrinsic_arg[1], &matrix_a->where);\n \t  return FAILURE;\n \t}\n       break;\n@@ -1625,7 +1629,7 @@ gfc_check_matmul (gfc_expr * matrix_a, gfc_expr * matrix_b)\n       /* matrix_b has rank 1 or 2 here. Common check for the cases\n \t - matrix_a has shape (n,m) and matrix_b has shape (m, k)\n \t - matrix_a has shape (n,m) and matrix_b has shape (m).  */\n-      if (! identical_dimen_shape (matrix_a, 1, matrix_b, 0))\n+      if (!identical_dimen_shape (matrix_a, 1, matrix_b, 0))\n \t{\n \t  gfc_error (\"different shape on dimension 2 for argument '%s' and \"\n \t\t     \"dimension 1 for argument '%s' at %L for intrinsic \"\n@@ -1653,24 +1657,23 @@ gfc_check_matmul (gfc_expr * matrix_a, gfc_expr * matrix_b)\n    The possibilities for the occupation of the second and third\n    parameters are:\n \n-         Arg #2     Arg #3\n-         NULL       NULL\n-         DIM        NULL\n-         MASK       NULL\n-         NULL       MASK             minloc(array, mask=m)\n-         DIM        MASK\n+\t Arg #2     Arg #3\n+\t NULL       NULL\n+\t DIM\tNULL\n+\t MASK       NULL\n+\t NULL       MASK\t     minloc(array, mask=m)\n+\t DIM\tMASK\n \n    I.e. in the case of minloc(array,mask), mask will be in the second\n    position of the argument list and we'll have to fix that up.  */\n \n try\n-gfc_check_minloc_maxloc (gfc_actual_arglist * ap)\n+gfc_check_minloc_maxloc (gfc_actual_arglist *ap)\n {\n   gfc_expr *a, *m, *d;\n \n   a = ap->expr;\n-  if (int_or_real_check (a, 0) == FAILURE\n-      || array_check (a, 0) == FAILURE)\n+  if (int_or_real_check (a, 0) == FAILURE || array_check (a, 0) == FAILURE)\n     return FAILURE;\n \n   d = ap->next->expr;\n@@ -1681,7 +1684,6 @@ gfc_check_minloc_maxloc (gfc_actual_arglist * ap)\n     {\n       m = d;\n       d = NULL;\n-\n       ap->next->expr = NULL;\n       ap->next->next->expr = m;\n     }\n@@ -1698,9 +1700,9 @@ gfc_check_minloc_maxloc (gfc_actual_arglist * ap)\n   if (m != NULL)\n     {\n       char buffer[80];\n-      snprintf(buffer, sizeof(buffer), \"arguments '%s' and '%s' for intrinsic %s\",\n-\t       gfc_current_intrinsic_arg[0], gfc_current_intrinsic_arg[2],\n-\t       gfc_current_intrinsic);\n+      snprintf (buffer, 80, \"arguments '%s' and '%s' for intrinsic %s\",\n+\t\tgfc_current_intrinsic_arg[0], gfc_current_intrinsic_arg[2],\n+\t\tgfc_current_intrinsic);\n       if (gfc_check_conformance (buffer, a, m) == FAILURE)\n \treturn FAILURE;\n     }\n@@ -1717,18 +1719,18 @@ gfc_check_minloc_maxloc (gfc_actual_arglist * ap)\n    difference is that MINLOC/MAXLOC take an additional KIND argument.\n    The possibilities are:\n \n-         Arg #2     Arg #3\n-         NULL       NULL\n-         DIM        NULL\n-         MASK       NULL\n-         NULL       MASK             minval(array, mask=m)\n-         DIM        MASK\n+\t Arg #2     Arg #3\n+\t NULL       NULL\n+\t DIM\tNULL\n+\t MASK       NULL\n+\t NULL       MASK\t     minval(array, mask=m)\n+\t DIM\tMASK\n \n    I.e. in the case of minval(array,mask), mask will be in the second\n    position of the argument list and we'll have to fix that up.  */\n \n static try\n-check_reduction (gfc_actual_arglist * ap)\n+check_reduction (gfc_actual_arglist *ap)\n {\n   gfc_expr *a, *m, *d;\n \n@@ -1741,7 +1743,6 @@ check_reduction (gfc_actual_arglist * ap)\n     {\n       m = d;\n       d = NULL;\n-\n       ap->next->expr = NULL;\n       ap->next->next->expr = m;\n     }\n@@ -1758,9 +1759,9 @@ check_reduction (gfc_actual_arglist * ap)\n   if (m != NULL)\n     {\n       char buffer[80];\n-      snprintf(buffer, sizeof(buffer), \"arguments '%s' and '%s' for intrinsic %s\",\n-\t       gfc_current_intrinsic_arg[0], gfc_current_intrinsic_arg[2],\n-\t       gfc_current_intrinsic);\n+      snprintf (buffer, 80, \"arguments '%s' and '%s' for intrinsic %s\",\n+\t\tgfc_current_intrinsic_arg[0], gfc_current_intrinsic_arg[2],\n+\t\tgfc_current_intrinsic);\n       if (gfc_check_conformance (buffer, a, m) == FAILURE)\n \treturn FAILURE;\n     }\n@@ -1770,7 +1771,7 @@ check_reduction (gfc_actual_arglist * ap)\n \n \n try\n-gfc_check_minval_maxval (gfc_actual_arglist * ap)\n+gfc_check_minval_maxval (gfc_actual_arglist *ap)\n {\n   if (int_or_real_check (ap->expr, 0) == FAILURE\n       || array_check (ap->expr, 0) == FAILURE)\n@@ -1784,7 +1785,7 @@ gfc_check_minval_maxval (gfc_actual_arglist * ap)\n \n \n try\n-gfc_check_product_sum (gfc_actual_arglist * ap)\n+gfc_check_product_sum (gfc_actual_arglist *ap)\n {\n   if (numeric_check (ap->expr, 0) == FAILURE\n       || array_check (ap->expr, 0) == FAILURE)\n@@ -1798,7 +1799,7 @@ gfc_check_product_sum (gfc_actual_arglist * ap)\n \n \n try\n-gfc_check_merge (gfc_expr * tsource, gfc_expr * fsource, gfc_expr * mask)\n+gfc_check_merge (gfc_expr *tsource, gfc_expr *fsource, gfc_expr *mask)\n {\n   char buffer[80];\n \n@@ -1808,23 +1809,23 @@ gfc_check_merge (gfc_expr * tsource, gfc_expr * fsource, gfc_expr * mask)\n   if (type_check (mask, 2, BT_LOGICAL) == FAILURE)\n     return FAILURE;\n \n-  snprintf(buffer, sizeof(buffer), \"arguments '%s' and '%s' for intrinsic '%s'\",\n-\t   gfc_current_intrinsic_arg[0], gfc_current_intrinsic_arg[1],\n-\t   gfc_current_intrinsic);\n+  snprintf (buffer, 80, \"arguments '%s' and '%s' for intrinsic '%s'\",\n+\t    gfc_current_intrinsic_arg[0], gfc_current_intrinsic_arg[1],\n+\t    gfc_current_intrinsic);\n   if (gfc_check_conformance (buffer, tsource, fsource) == FAILURE)\n     return FAILURE;\n \n-  snprintf(buffer, sizeof(buffer), \"arguments '%s' and '%s' for intrinsic '%s'\",\n-\t   gfc_current_intrinsic_arg[0], gfc_current_intrinsic_arg[2],\n-\t   gfc_current_intrinsic);\n+  snprintf (buffer, 80, \"arguments '%s' and '%s' for intrinsic '%s'\",\n+\t    gfc_current_intrinsic_arg[0], gfc_current_intrinsic_arg[2],\n+\t    gfc_current_intrinsic);\n   if (gfc_check_conformance (buffer, tsource, mask) == FAILURE)\n     return FAILURE;\n \n   return SUCCESS;\n }\n \n try\n-gfc_check_move_alloc (gfc_expr * from, gfc_expr * to)\n+gfc_check_move_alloc (gfc_expr *from, gfc_expr *to)\n {\n   symbol_attribute attr;\n \n@@ -1882,8 +1883,9 @@ gfc_check_move_alloc (gfc_expr * from, gfc_expr * to)\n   return SUCCESS;\n }\n \n+\n try\n-gfc_check_nearest (gfc_expr * x, gfc_expr * s)\n+gfc_check_nearest (gfc_expr *x, gfc_expr *s)\n {\n   if (type_check (x, 0, BT_REAL) == FAILURE)\n     return FAILURE;\n@@ -1894,17 +1896,19 @@ gfc_check_nearest (gfc_expr * x, gfc_expr * s)\n   return SUCCESS;\n }\n \n+\n try\n-gfc_check_new_line (gfc_expr * a)\n+gfc_check_new_line (gfc_expr *a)\n {\n   if (type_check (a, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n \n   return SUCCESS;\n }\n \n+\n try\n-gfc_check_null (gfc_expr * mold)\n+gfc_check_null (gfc_expr *mold)\n {\n   symbol_attribute attr;\n \n@@ -1929,7 +1933,7 @@ gfc_check_null (gfc_expr * mold)\n \n \n try\n-gfc_check_pack (gfc_expr * array, gfc_expr * mask, gfc_expr * vector)\n+gfc_check_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)\n {\n   char buffer[80];\n \n@@ -1939,9 +1943,9 @@ gfc_check_pack (gfc_expr * array, gfc_expr * mask, gfc_expr * vector)\n   if (type_check (mask, 1, BT_LOGICAL) == FAILURE)\n     return FAILURE;\n \n-  snprintf(buffer, sizeof(buffer), \"arguments '%s' and '%s' for intrinsic '%s'\",\n-\t   gfc_current_intrinsic_arg[0], gfc_current_intrinsic_arg[1],\n-\t   gfc_current_intrinsic);\n+  snprintf (buffer, 80, \"arguments '%s' and '%s' for intrinsic '%s'\",\n+\t    gfc_current_intrinsic_arg[0], gfc_current_intrinsic_arg[1],\n+\t    gfc_current_intrinsic);\n   if (gfc_check_conformance (buffer, array, mask) == FAILURE)\n     return FAILURE;\n \n@@ -1964,7 +1968,7 @@ gfc_check_pack (gfc_expr * array, gfc_expr * mask, gfc_expr * vector)\n \n \n try\n-gfc_check_precision (gfc_expr * x)\n+gfc_check_precision (gfc_expr *x)\n {\n   if (x->ts.type != BT_REAL && x->ts.type != BT_COMPLEX)\n     {\n@@ -1979,7 +1983,7 @@ gfc_check_precision (gfc_expr * x)\n \n \n try\n-gfc_check_present (gfc_expr * a)\n+gfc_check_present (gfc_expr *a)\n {\n   gfc_symbol *sym;\n \n@@ -2003,18 +2007,18 @@ gfc_check_present (gfc_expr * a)\n       return FAILURE;\n     }\n \n-/*  13.14.82  PRESENT(A)\n-......\n-  Argument.  A shall be the name of an optional dummy argument that is accessible\n-  in the subprogram in which the PRESENT function reference appears...  */\n+  /* 13.14.82  PRESENT(A)\n+     ......\n+     Argument.  A shall be the name of an optional dummy argument that is\n+     accessible in the subprogram in which the PRESENT function reference\n+     appears...  */\n \n   if (a->ref != NULL\n-\t&& !(a->ref->next == NULL\n-\t       && a->ref->type == REF_ARRAY\n-\t       && a->ref->u.ar.type == AR_FULL))\n+      && !(a->ref->next == NULL && a->ref->type == REF_ARRAY\n+\t   && a->ref->u.ar.type == AR_FULL))\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must not be a sub-\"\n-\t\t \"object of '%s'\", gfc_current_intrinsic_arg[0],\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must not be a \"\n+\t\t \"subobject of '%s'\", gfc_current_intrinsic_arg[0],\n \t\t gfc_current_intrinsic, &a->where, sym->name);\n       return FAILURE;\n     }\n@@ -2024,7 +2028,7 @@ gfc_check_present (gfc_expr * a)\n \n \n try\n-gfc_check_radix (gfc_expr * x)\n+gfc_check_radix (gfc_expr *x)\n {\n   if (int_or_real_check (x, 0) == FAILURE)\n     return FAILURE;\n@@ -2034,7 +2038,7 @@ gfc_check_radix (gfc_expr * x)\n \n \n try\n-gfc_check_range (gfc_expr * x)\n+gfc_check_range (gfc_expr *x)\n {\n   if (numeric_check (x, 0) == FAILURE)\n     return FAILURE;\n@@ -2045,7 +2049,7 @@ gfc_check_range (gfc_expr * x)\n \n /* real, float, sngl.  */\n try\n-gfc_check_real (gfc_expr * a, gfc_expr * kind)\n+gfc_check_real (gfc_expr *a, gfc_expr *kind)\n {\n   if (numeric_check (a, 0) == FAILURE)\n     return FAILURE;\n@@ -2058,7 +2062,7 @@ gfc_check_real (gfc_expr * a, gfc_expr * kind)\n \n \n try\n-gfc_check_rename (gfc_expr * path1, gfc_expr * path2)\n+gfc_check_rename (gfc_expr *path1, gfc_expr *path2)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -2071,7 +2075,7 @@ gfc_check_rename (gfc_expr * path1, gfc_expr * path2)\n \n \n try\n-gfc_check_rename_sub (gfc_expr * path1, gfc_expr * path2, gfc_expr * status)\n+gfc_check_rename_sub (gfc_expr *path1, gfc_expr *path2, gfc_expr *status)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -2093,7 +2097,7 @@ gfc_check_rename_sub (gfc_expr * path1, gfc_expr * path2, gfc_expr * status)\n \n \n try\n-gfc_check_repeat (gfc_expr * x, gfc_expr * y)\n+gfc_check_repeat (gfc_expr *x, gfc_expr *y)\n {\n   if (type_check (x, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -2112,8 +2116,8 @@ gfc_check_repeat (gfc_expr * x, gfc_expr * y)\n \n \n try\n-gfc_check_reshape (gfc_expr * source, gfc_expr * shape,\n-\t\t   gfc_expr * pad, gfc_expr * order)\n+gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n+\t\t   gfc_expr *pad, gfc_expr *order)\n {\n   mpz_t size;\n   mpz_t nelems;\n@@ -2156,12 +2160,10 @@ gfc_check_reshape (gfc_expr * source, gfc_expr * shape,\n   if (order != NULL && array_check (order, 3) == FAILURE)\n     return FAILURE;\n \n-  if (pad == NULL\n-\t&& shape->expr_type == EXPR_ARRAY\n-\t&& gfc_is_constant_expr (shape)\n-\t&& !(source->expr_type == EXPR_VARIABLE\n-\t       && source->symtree->n.sym->as\n-\t       && source->symtree->n.sym->as->type == AS_ASSUMED_SIZE))\n+  if (pad == NULL && shape->expr_type == EXPR_ARRAY\n+      && gfc_is_constant_expr (shape)\n+      && !(source->expr_type == EXPR_VARIABLE && source->symtree->n.sym->as\n+\t   && source->symtree->n.sym->as->type == AS_ASSUMED_SIZE))\n     {\n       /* Check the match in size between source and destination.  */\n       if (gfc_array_size (source, &nelems) == SUCCESS)\n@@ -2180,9 +2182,9 @@ gfc_check_reshape (gfc_expr * source, gfc_expr * shape,\n \n \t  if (test)\n \t    {\n-\t      gfc_error (\"Without padding, there are not enough elements in the \"\n-\t\t\t \"intrinsic RESHAPE source at %L to match the shape\",\n-\t\t\t &source->where);\n+\t      gfc_error (\"Without padding, there are not enough elements \"\n+\t\t\t \"in the intrinsic RESHAPE source at %L to match \"\n+\t\t\t \"the shape\", &source->where);\n \t      return FAILURE;\n \t    }\n \t}\n@@ -2193,7 +2195,7 @@ gfc_check_reshape (gfc_expr * source, gfc_expr * shape,\n \n \n try\n-gfc_check_scale (gfc_expr * x, gfc_expr * i)\n+gfc_check_scale (gfc_expr *x, gfc_expr *i)\n {\n   if (type_check (x, 0, BT_REAL) == FAILURE)\n     return FAILURE;\n@@ -2206,7 +2208,7 @@ gfc_check_scale (gfc_expr * x, gfc_expr * i)\n \n \n try\n-gfc_check_scan (gfc_expr * x, gfc_expr * y, gfc_expr * z)\n+gfc_check_scan (gfc_expr *x, gfc_expr *y, gfc_expr *z)\n {\n   if (type_check (x, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -2225,9 +2227,8 @@ gfc_check_scan (gfc_expr * x, gfc_expr * y, gfc_expr * z)\n \n \n try\n-gfc_check_secnds (gfc_expr * r)\n+gfc_check_secnds (gfc_expr *r)\n {\n-\n   if (type_check (r, 0, BT_REAL) == FAILURE)\n     return FAILURE;\n \n@@ -2242,9 +2243,8 @@ gfc_check_secnds (gfc_expr * r)\n \n \n try\n-gfc_check_selected_int_kind (gfc_expr * r)\n+gfc_check_selected_int_kind (gfc_expr *r)\n {\n-\n   if (type_check (r, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n@@ -2256,7 +2256,7 @@ gfc_check_selected_int_kind (gfc_expr * r)\n \n \n try\n-gfc_check_selected_real_kind (gfc_expr * p, gfc_expr * r)\n+gfc_check_selected_real_kind (gfc_expr *p, gfc_expr *r)\n {\n   if (p == NULL && r == NULL)\n     {\n@@ -2277,7 +2277,7 @@ gfc_check_selected_real_kind (gfc_expr * p, gfc_expr * r)\n \n \n try\n-gfc_check_set_exponent (gfc_expr * x, gfc_expr * i)\n+gfc_check_set_exponent (gfc_expr *x, gfc_expr *i)\n {\n   if (type_check (x, 0, BT_REAL) == FAILURE)\n     return FAILURE;\n@@ -2290,7 +2290,7 @@ gfc_check_set_exponent (gfc_expr * x, gfc_expr * i)\n \n \n try\n-gfc_check_shape (gfc_expr * source)\n+gfc_check_shape (gfc_expr *source)\n {\n   gfc_array_ref *ar;\n \n@@ -2311,7 +2311,7 @@ gfc_check_shape (gfc_expr * source)\n \n \n try\n-gfc_check_sign (gfc_expr * a, gfc_expr * b)\n+gfc_check_sign (gfc_expr *a, gfc_expr *b)\n {\n   if (int_or_real_check (a, 0) == FAILURE)\n     return FAILURE;\n@@ -2324,7 +2324,7 @@ gfc_check_sign (gfc_expr * a, gfc_expr * b)\n \n \n try\n-gfc_check_size (gfc_expr * array, gfc_expr * dim)\n+gfc_check_size (gfc_expr *array, gfc_expr *dim)\n {\n   if (array_check (array, 0) == FAILURE)\n     return FAILURE;\n@@ -2346,7 +2346,7 @@ gfc_check_size (gfc_expr * array, gfc_expr * dim)\n \n \n try\n-gfc_check_sleep_sub (gfc_expr * seconds)\n+gfc_check_sleep_sub (gfc_expr *seconds)\n {\n   if (type_check (seconds, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -2359,7 +2359,7 @@ gfc_check_sleep_sub (gfc_expr * seconds)\n \n \n try\n-gfc_check_spread (gfc_expr * source, gfc_expr * dim, gfc_expr * ncopies)\n+gfc_check_spread (gfc_expr *source, gfc_expr *dim, gfc_expr *ncopies)\n {\n   if (source->rank >= GFC_MAX_DIMENSIONS)\n     {\n@@ -2388,8 +2388,9 @@ gfc_check_spread (gfc_expr * source, gfc_expr * dim, gfc_expr * ncopies)\n \n /* Functions for checking FGETC, FPUTC, FGET and FPUT (subroutines and\n    functions).  */\n+\n try\n-gfc_check_fgetputc_sub (gfc_expr * unit, gfc_expr * c, gfc_expr * status)\n+gfc_check_fgetputc_sub (gfc_expr *unit, gfc_expr *c, gfc_expr *status)\n {\n   if (type_check (unit, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -2413,14 +2414,14 @@ gfc_check_fgetputc_sub (gfc_expr * unit, gfc_expr * c, gfc_expr * status)\n \n \n try\n-gfc_check_fgetputc (gfc_expr * unit, gfc_expr * c)\n+gfc_check_fgetputc (gfc_expr *unit, gfc_expr *c)\n {\n   return gfc_check_fgetputc_sub (unit, c, NULL);\n }\n \n \n try\n-gfc_check_fgetput_sub (gfc_expr * c, gfc_expr * status)\n+gfc_check_fgetput_sub (gfc_expr *c, gfc_expr *status)\n {\n   if (type_check (c, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -2438,14 +2439,14 @@ gfc_check_fgetput_sub (gfc_expr * c, gfc_expr * status)\n \n \n try\n-gfc_check_fgetput (gfc_expr * c)\n+gfc_check_fgetput (gfc_expr *c)\n {\n   return gfc_check_fgetput_sub (c, NULL);\n }\n \n \n try\n-gfc_check_fstat (gfc_expr * unit, gfc_expr * array)\n+gfc_check_fstat (gfc_expr *unit, gfc_expr *array)\n {\n   if (type_check (unit, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -2465,7 +2466,7 @@ gfc_check_fstat (gfc_expr * unit, gfc_expr * array)\n \n \n try\n-gfc_check_fstat_sub (gfc_expr * unit, gfc_expr * array, gfc_expr * status)\n+gfc_check_fstat_sub (gfc_expr *unit, gfc_expr *array, gfc_expr *status)\n {\n   if (type_check (unit, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -2495,7 +2496,7 @@ gfc_check_fstat_sub (gfc_expr * unit, gfc_expr * array, gfc_expr * status)\n \n \n try\n-gfc_check_ftell (gfc_expr * unit)\n+gfc_check_ftell (gfc_expr *unit)\n {\n   if (type_check (unit, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -2508,7 +2509,7 @@ gfc_check_ftell (gfc_expr * unit)\n \n \n try\n-gfc_check_ftell_sub (gfc_expr * unit, gfc_expr * offset)\n+gfc_check_ftell_sub (gfc_expr *unit, gfc_expr *offset)\n {\n   if (type_check (unit, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -2527,7 +2528,7 @@ gfc_check_ftell_sub (gfc_expr * unit, gfc_expr * offset)\n \n \n try\n-gfc_check_stat (gfc_expr * name, gfc_expr * array)\n+gfc_check_stat (gfc_expr *name, gfc_expr *array)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -2544,7 +2545,7 @@ gfc_check_stat (gfc_expr * name, gfc_expr * array)\n \n \n try\n-gfc_check_stat_sub (gfc_expr * name, gfc_expr * array, gfc_expr * status)\n+gfc_check_stat_sub (gfc_expr *name, gfc_expr *array, gfc_expr *status)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -2571,9 +2572,8 @@ gfc_check_stat_sub (gfc_expr * name, gfc_expr * array, gfc_expr * status)\n \n \n try\n-gfc_check_transfer (gfc_expr * source ATTRIBUTE_UNUSED,\n-\t\t    gfc_expr * mold ATTRIBUTE_UNUSED,\n-\t\t    gfc_expr * size)\n+gfc_check_transfer (gfc_expr *source ATTRIBUTE_UNUSED,\n+\t\t    gfc_expr *mold ATTRIBUTE_UNUSED, gfc_expr *size)\n {\n   if (size != NULL)\n     {\n@@ -2592,7 +2592,7 @@ gfc_check_transfer (gfc_expr * source ATTRIBUTE_UNUSED,\n \n \n try\n-gfc_check_transpose (gfc_expr * matrix)\n+gfc_check_transpose (gfc_expr *matrix)\n {\n   if (rank_check (matrix, 0, 2) == FAILURE)\n     return FAILURE;\n@@ -2605,7 +2605,7 @@ gfc_check_transpose (gfc_expr * matrix)\n \n \n try\n-gfc_check_ubound (gfc_expr * array, gfc_expr * dim)\n+gfc_check_ubound (gfc_expr *array, gfc_expr *dim)\n {\n   if (array_check (array, 0) == FAILURE)\n     return FAILURE;\n@@ -2624,7 +2624,7 @@ gfc_check_ubound (gfc_expr * array, gfc_expr * dim)\n \n \n try\n-gfc_check_unpack (gfc_expr * vector, gfc_expr * mask, gfc_expr * field)\n+gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n {\n   if (rank_check (vector, 0, 1) == FAILURE)\n     return FAILURE;\n@@ -2646,7 +2646,7 @@ gfc_check_unpack (gfc_expr * vector, gfc_expr * mask, gfc_expr * field)\n \n \n try\n-gfc_check_verify (gfc_expr * x, gfc_expr * y, gfc_expr * z)\n+gfc_check_verify (gfc_expr *x, gfc_expr *y, gfc_expr *z)\n {\n   if (type_check (x, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -2662,7 +2662,7 @@ gfc_check_verify (gfc_expr * x, gfc_expr * y, gfc_expr * z)\n \n \n try\n-gfc_check_trim (gfc_expr * x)\n+gfc_check_trim (gfc_expr *x)\n {\n   if (type_check (x, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -2675,7 +2675,7 @@ gfc_check_trim (gfc_expr * x)\n \n \n try\n-gfc_check_ttynam (gfc_expr * unit)\n+gfc_check_ttynam (gfc_expr *unit)\n {\n   if (scalar_check (unit, 0) == FAILURE)\n     return FAILURE;\n@@ -2691,7 +2691,7 @@ gfc_check_ttynam (gfc_expr * unit)\n    single real argument.  */\n \n try\n-gfc_check_x (gfc_expr * x)\n+gfc_check_x (gfc_expr *x)\n {\n   if (type_check (x, 0, BT_REAL) == FAILURE)\n     return FAILURE;\n@@ -2703,7 +2703,7 @@ gfc_check_x (gfc_expr * x)\n /************* Check functions for intrinsic subroutines *************/\n \n try\n-gfc_check_cpu_time (gfc_expr * time)\n+gfc_check_cpu_time (gfc_expr *time)\n {\n   if (scalar_check (time, 0) == FAILURE)\n     return FAILURE;\n@@ -2719,8 +2719,8 @@ gfc_check_cpu_time (gfc_expr * time)\n \n \n try\n-gfc_check_date_and_time (gfc_expr * date, gfc_expr * time,\n-\t\t\t gfc_expr * zone, gfc_expr * values)\n+gfc_check_date_and_time (gfc_expr *date, gfc_expr *time,\n+\t\t\t gfc_expr *zone, gfc_expr *values)\n {\n   if (date != NULL)\n     {\n@@ -2769,8 +2769,8 @@ gfc_check_date_and_time (gfc_expr * date, gfc_expr * time,\n \n \n try\n-gfc_check_mvbits (gfc_expr * from, gfc_expr * frompos, gfc_expr * len,\n-\t\t  gfc_expr * to, gfc_expr * topos)\n+gfc_check_mvbits (gfc_expr *from, gfc_expr *frompos, gfc_expr *len,\n+\t\t  gfc_expr *to, gfc_expr *topos)\n {\n   if (type_check (from, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -2795,7 +2795,7 @@ gfc_check_mvbits (gfc_expr * from, gfc_expr * frompos, gfc_expr * len,\n \n \n try\n-gfc_check_random_number (gfc_expr * harvest)\n+gfc_check_random_number (gfc_expr *harvest)\n {\n   if (type_check (harvest, 0, BT_REAL) == FAILURE)\n     return FAILURE;\n@@ -2808,7 +2808,7 @@ gfc_check_random_number (gfc_expr * harvest)\n \n \n try\n-gfc_check_random_seed (gfc_expr * size, gfc_expr * put, gfc_expr * get)\n+gfc_check_random_seed (gfc_expr *size, gfc_expr *put, gfc_expr *get)\n {\n   if (size != NULL)\n     {\n@@ -2829,8 +2829,8 @@ gfc_check_random_seed (gfc_expr * size, gfc_expr * put, gfc_expr * get)\n     {\n \n       if (size != NULL)\n-        gfc_error (\"Too many arguments to %s at %L\", gfc_current_intrinsic,\n-                    &put->where);\n+\tgfc_error (\"Too many arguments to %s at %L\", gfc_current_intrinsic,\n+\t\t    &put->where);\n \n       if (array_check (put, 1) == FAILURE)\n \treturn FAILURE;\n@@ -2849,8 +2849,8 @@ gfc_check_random_seed (gfc_expr * size, gfc_expr * put, gfc_expr * get)\n     {\n \n       if (size != NULL || put != NULL)\n-        gfc_error (\"Too many arguments to %s at %L\", gfc_current_intrinsic,\n-                    &get->where);\n+\tgfc_error (\"Too many arguments to %s at %L\", gfc_current_intrinsic,\n+\t\t   &get->where);\n \n       if (array_check (get, 2) == FAILURE)\n \treturn FAILURE;\n@@ -2871,8 +2871,9 @@ gfc_check_random_seed (gfc_expr * size, gfc_expr * put, gfc_expr * get)\n   return SUCCESS;\n }\n \n+\n try\n-gfc_check_second_sub (gfc_expr * time)\n+gfc_check_second_sub (gfc_expr *time)\n {\n   if (scalar_check (time, 0) == FAILURE)\n     return FAILURE;\n@@ -2891,63 +2892,64 @@ gfc_check_second_sub (gfc_expr * time)\n    count, count_rate, and count_max are all optional arguments */\n \n try\n-gfc_check_system_clock (gfc_expr * count, gfc_expr * count_rate,\n-                        gfc_expr * count_max)\n+gfc_check_system_clock (gfc_expr *count, gfc_expr *count_rate,\n+\t\t\tgfc_expr *count_max)\n {\n   if (count != NULL)\n     {\n       if (scalar_check (count, 0) == FAILURE)\n-        return FAILURE;\n+\treturn FAILURE;\n \n       if (type_check (count, 0, BT_INTEGER) == FAILURE)\n-        return FAILURE;\n+\treturn FAILURE;\n \n       if (variable_check (count, 0) == FAILURE)\n-        return FAILURE;\n+\treturn FAILURE;\n     }\n \n   if (count_rate != NULL)\n     {\n       if (scalar_check (count_rate, 1) == FAILURE)\n-        return FAILURE;\n+\treturn FAILURE;\n \n       if (type_check (count_rate, 1, BT_INTEGER) == FAILURE)\n-        return FAILURE;\n+\treturn FAILURE;\n \n       if (variable_check (count_rate, 1) == FAILURE)\n-        return FAILURE;\n+\treturn FAILURE;\n \n       if (count != NULL\n \t  && same_type_check (count, 0, count_rate, 1) == FAILURE)\n-        return FAILURE;\n+\treturn FAILURE;\n \n     }\n \n   if (count_max != NULL)\n     {\n       if (scalar_check (count_max, 2) == FAILURE)\n-        return FAILURE;\n+\treturn FAILURE;\n \n       if (type_check (count_max, 2, BT_INTEGER) == FAILURE)\n-        return FAILURE;\n+\treturn FAILURE;\n \n       if (variable_check (count_max, 2) == FAILURE)\n-        return FAILURE;\n+\treturn FAILURE;\n \n       if (count != NULL\n \t  && same_type_check (count, 0, count_max, 2) == FAILURE)\n-        return FAILURE;\n+\treturn FAILURE;\n \n       if (count_rate != NULL\n-          && same_type_check (count_rate, 1, count_max, 2) == FAILURE)\n-        return FAILURE;\n+\t  && same_type_check (count_rate, 1, count_max, 2) == FAILURE)\n+\treturn FAILURE;\n     }\n \n   return SUCCESS;\n }\n \n+\n try\n-gfc_check_irand (gfc_expr * x)\n+gfc_check_irand (gfc_expr *x)\n {\n   if (x == NULL)\n     return SUCCESS;\n@@ -2966,7 +2968,7 @@ gfc_check_irand (gfc_expr * x)\n \n \n try\n-gfc_check_alarm_sub (gfc_expr * seconds, gfc_expr * handler, gfc_expr * status)\n+gfc_check_alarm_sub (gfc_expr *seconds, gfc_expr *handler, gfc_expr *status)\n {\n   if (scalar_check (seconds, 0) == FAILURE)\n     return FAILURE;\n@@ -2976,9 +2978,9 @@ gfc_check_alarm_sub (gfc_expr * seconds, gfc_expr * handler, gfc_expr * status)\n \n   if (handler->ts.type != BT_INTEGER && handler->ts.type != BT_PROCEDURE)\n     {\n-      gfc_error (\n-\t\"'%s' argument of '%s' intrinsic at %L must be INTEGER or PROCEDURE\",\n-\tgfc_current_intrinsic_arg[1], gfc_current_intrinsic, &handler->where);\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n+\t\t \"or PROCEDURE\", gfc_current_intrinsic_arg[1],\n+\t\t gfc_current_intrinsic, &handler->where);\n       return FAILURE;\n     }\n \n@@ -2999,7 +3001,7 @@ gfc_check_alarm_sub (gfc_expr * seconds, gfc_expr * handler, gfc_expr * status)\n \n \n try\n-gfc_check_rand (gfc_expr * x)\n+gfc_check_rand (gfc_expr *x)\n {\n   if (x == NULL)\n     return SUCCESS;\n@@ -3016,8 +3018,9 @@ gfc_check_rand (gfc_expr * x)\n   return SUCCESS;\n }\n \n+\n try\n-gfc_check_srand (gfc_expr * x)\n+gfc_check_srand (gfc_expr *x)\n {\n   if (scalar_check (x, 0) == FAILURE)\n     return FAILURE;\n@@ -3031,8 +3034,9 @@ gfc_check_srand (gfc_expr * x)\n   return SUCCESS;\n }\n \n+\n try\n-gfc_check_ctime_sub (gfc_expr * time, gfc_expr * result)\n+gfc_check_ctime_sub (gfc_expr *time, gfc_expr *result)\n {\n   if (scalar_check (time, 0) == FAILURE)\n     return FAILURE;\n@@ -3046,8 +3050,9 @@ gfc_check_ctime_sub (gfc_expr * time, gfc_expr * result)\n   return SUCCESS;\n }\n \n+\n try\n-gfc_check_etime (gfc_expr * x)\n+gfc_check_etime (gfc_expr *x)\n {\n   if (array_check (x, 0) == FAILURE)\n     return FAILURE;\n@@ -3067,8 +3072,9 @@ gfc_check_etime (gfc_expr * x)\n   return SUCCESS;\n }\n \n+\n try\n-gfc_check_etime_sub (gfc_expr * values, gfc_expr * time)\n+gfc_check_etime_sub (gfc_expr *values, gfc_expr *time)\n {\n   if (array_check (values, 0) == FAILURE)\n     return FAILURE;\n@@ -3099,7 +3105,7 @@ gfc_check_etime_sub (gfc_expr * values, gfc_expr * time)\n \n \n try\n-gfc_check_fdate_sub (gfc_expr * date)\n+gfc_check_fdate_sub (gfc_expr *date)\n {\n   if (type_check (date, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -3109,7 +3115,7 @@ gfc_check_fdate_sub (gfc_expr * date)\n \n \n try\n-gfc_check_gerror (gfc_expr * msg)\n+gfc_check_gerror (gfc_expr *msg)\n {\n   if (type_check (msg, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -3119,7 +3125,7 @@ gfc_check_gerror (gfc_expr * msg)\n \n \n try\n-gfc_check_getcwd_sub (gfc_expr * cwd, gfc_expr * status)\n+gfc_check_getcwd_sub (gfc_expr *cwd, gfc_expr *status)\n {\n   if (type_check (cwd, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -3138,7 +3144,7 @@ gfc_check_getcwd_sub (gfc_expr * cwd, gfc_expr * status)\n \n \n try\n-gfc_check_getlog (gfc_expr * msg)\n+gfc_check_getlog (gfc_expr *msg)\n {\n   if (type_check (msg, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -3148,7 +3154,7 @@ gfc_check_getlog (gfc_expr * msg)\n \n \n try\n-gfc_check_exit (gfc_expr * status)\n+gfc_check_exit (gfc_expr *status)\n {\n   if (status == NULL)\n     return SUCCESS;\n@@ -3164,7 +3170,7 @@ gfc_check_exit (gfc_expr * status)\n \n \n try\n-gfc_check_flush (gfc_expr * unit)\n+gfc_check_flush (gfc_expr *unit)\n {\n   if (unit == NULL)\n     return SUCCESS;\n@@ -3180,7 +3186,7 @@ gfc_check_flush (gfc_expr * unit)\n \n \n try\n-gfc_check_free (gfc_expr * i)\n+gfc_check_free (gfc_expr *i)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -3193,7 +3199,7 @@ gfc_check_free (gfc_expr * i)\n \n \n try\n-gfc_check_hostnm (gfc_expr * name)\n+gfc_check_hostnm (gfc_expr *name)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -3203,7 +3209,7 @@ gfc_check_hostnm (gfc_expr * name)\n \n \n try\n-gfc_check_hostnm_sub (gfc_expr * name, gfc_expr * status)\n+gfc_check_hostnm_sub (gfc_expr *name, gfc_expr *status)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -3222,7 +3228,7 @@ gfc_check_hostnm_sub (gfc_expr * name, gfc_expr * status)\n \n \n try\n-gfc_check_itime_idate (gfc_expr * values)\n+gfc_check_itime_idate (gfc_expr *values)\n {\n   if (array_check (values, 0) == FAILURE)\n     return FAILURE;\n@@ -3244,7 +3250,7 @@ gfc_check_itime_idate (gfc_expr * values)\n \n \n try\n-gfc_check_ltime_gmtime (gfc_expr * time, gfc_expr * values)\n+gfc_check_ltime_gmtime (gfc_expr *time, gfc_expr *values)\n {\n   if (type_check (time, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -3275,7 +3281,7 @@ gfc_check_ltime_gmtime (gfc_expr * time, gfc_expr * values)\n \n \n try\n-gfc_check_ttynam_sub (gfc_expr * unit, gfc_expr * name)\n+gfc_check_ttynam_sub (gfc_expr *unit, gfc_expr *name)\n {\n   if (scalar_check (unit, 0) == FAILURE)\n     return FAILURE;\n@@ -3291,7 +3297,7 @@ gfc_check_ttynam_sub (gfc_expr * unit, gfc_expr * name)\n \n \n try\n-gfc_check_isatty (gfc_expr * unit)\n+gfc_check_isatty (gfc_expr *unit)\n {\n   if (unit == NULL)\n     return FAILURE;\n@@ -3307,7 +3313,7 @@ gfc_check_isatty (gfc_expr * unit)\n \n \n try\n-gfc_check_perror (gfc_expr * string)\n+gfc_check_perror (gfc_expr *string)\n {\n   if (type_check (string, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -3317,7 +3323,7 @@ gfc_check_perror (gfc_expr * string)\n \n \n try\n-gfc_check_umask (gfc_expr * mask)\n+gfc_check_umask (gfc_expr *mask)\n {\n   if (type_check (mask, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -3330,7 +3336,7 @@ gfc_check_umask (gfc_expr * mask)\n \n \n try\n-gfc_check_umask_sub (gfc_expr * mask, gfc_expr * old)\n+gfc_check_umask_sub (gfc_expr *mask, gfc_expr *old)\n {\n   if (type_check (mask, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n@@ -3352,7 +3358,7 @@ gfc_check_umask_sub (gfc_expr * mask, gfc_expr * old)\n \n \n try\n-gfc_check_unlink (gfc_expr * name)\n+gfc_check_unlink (gfc_expr *name)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -3362,7 +3368,7 @@ gfc_check_unlink (gfc_expr * name)\n \n \n try\n-gfc_check_unlink_sub (gfc_expr * name, gfc_expr * status)\n+gfc_check_unlink_sub (gfc_expr *name, gfc_expr *status)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -3381,7 +3387,7 @@ gfc_check_unlink_sub (gfc_expr * name, gfc_expr * status)\n \n \n try\n-gfc_check_signal (gfc_expr * number, gfc_expr * handler)\n+gfc_check_signal (gfc_expr *number, gfc_expr *handler)\n {\n   if (scalar_check (number, 0) == FAILURE)\n     return FAILURE;\n@@ -3391,9 +3397,9 @@ gfc_check_signal (gfc_expr * number, gfc_expr * handler)\n \n   if (handler->ts.type != BT_INTEGER && handler->ts.type != BT_PROCEDURE)\n     {\n-      gfc_error (\n-\t\"'%s' argument of '%s' intrinsic at %L must be INTEGER or PROCEDURE\",\n-\tgfc_current_intrinsic_arg[1], gfc_current_intrinsic, &handler->where);\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n+\t\t \"or PROCEDURE\", gfc_current_intrinsic_arg[1],\n+\t\t gfc_current_intrinsic, &handler->where);\n       return FAILURE;\n     }\n \n@@ -3405,7 +3411,7 @@ gfc_check_signal (gfc_expr * number, gfc_expr * handler)\n \n \n try\n-gfc_check_signal_sub (gfc_expr * number, gfc_expr * handler, gfc_expr * status)\n+gfc_check_signal_sub (gfc_expr *number, gfc_expr *handler, gfc_expr *status)\n {\n   if (scalar_check (number, 0) == FAILURE)\n     return FAILURE;\n@@ -3415,9 +3421,9 @@ gfc_check_signal_sub (gfc_expr * number, gfc_expr * handler, gfc_expr * status)\n \n   if (handler->ts.type != BT_INTEGER && handler->ts.type != BT_PROCEDURE)\n     {\n-      gfc_error (\n-\t\"'%s' argument of '%s' intrinsic at %L must be INTEGER or PROCEDURE\",\n-\tgfc_current_intrinsic_arg[1], gfc_current_intrinsic, &handler->where);\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n+\t\t \"or PROCEDURE\", gfc_current_intrinsic_arg[1],\n+\t\t gfc_current_intrinsic, &handler->where);\n       return FAILURE;\n     }\n \n@@ -3438,7 +3444,7 @@ gfc_check_signal_sub (gfc_expr * number, gfc_expr * handler, gfc_expr * status)\n \n \n try\n-gfc_check_system_sub (gfc_expr * cmd, gfc_expr * status)\n+gfc_check_system_sub (gfc_expr *cmd, gfc_expr *status)\n {\n   if (type_check (cmd, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n@@ -3458,21 +3464,21 @@ gfc_check_system_sub (gfc_expr * cmd, gfc_expr * status)\n \n /* This is used for the GNU intrinsics AND, OR and XOR.  */\n try\n-gfc_check_and (gfc_expr * i, gfc_expr * j)\n+gfc_check_and (gfc_expr *i, gfc_expr *j)\n {\n   if (i->ts.type != BT_INTEGER && i->ts.type != BT_LOGICAL)\n     {\n-      gfc_error (\n-\t\"'%s' argument of '%s' intrinsic at %L must be INTEGER or LOGICAL\",\n-\tgfc_current_intrinsic_arg[0], gfc_current_intrinsic, &i->where);\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n+\t\t \"or LOGICAL\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic, &i->where);\n       return FAILURE;\n     }\n \n   if (j->ts.type != BT_INTEGER && j->ts.type != BT_LOGICAL)\n     {\n-      gfc_error (\n-\t\"'%s' argument of '%s' intrinsic at %L must be INTEGER or LOGICAL\",\n-\tgfc_current_intrinsic_arg[1], gfc_current_intrinsic, &j->where);\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n+\t\t \"or LOGICAL\", gfc_current_intrinsic_arg[1],\n+\t\t gfc_current_intrinsic, &j->where);\n       return FAILURE;\n     }\n "}, {"sha": "a8978d05ad411348ddc10e504a259f569d507624", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f8144a803cef2fbd7f73334603318547f4df0b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f8144a803cef2fbd7f73334603318547f4df0b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=65f8144a803cef2fbd7f73334603318547f4df0b", "patch": "@@ -1,3 +1,7 @@\n+2006-01-06  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\t* gfortran.dg/present_1.f90:  Update error message.\n+\n 2006-01-06  Lee Millward  <lee.millward@codesourcery.com>\n \n        PR c++/19439"}, {"sha": "96120399a1965255fcf028481726dfe138c33cb2", "filename": "gcc/testsuite/gfortran.dg/present_1.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f8144a803cef2fbd7f73334603318547f4df0b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpresent_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f8144a803cef2fbd7f73334603318547f4df0b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpresent_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpresent_1.f90?ref=65f8144a803cef2fbd7f73334603318547f4df0b", "patch": "@@ -11,8 +11,8 @@ MODULE M1\n  CONTAINS\n   SUBROUTINE S1(D1)\n    TYPE(T1), OPTIONAL :: D1(4)\n-   write(6,*) PRESENT(D1%I)  ! { dg-error \"must not be a sub-object\" }\n-   write(6,*) PRESENT(D1(1)) ! { dg-error \"must not be a sub-object\" }\n+   write(6,*) PRESENT(D1%I)  ! { dg-error \"must not be a subobject\" }\n+   write(6,*) PRESENT(D1(1)) ! { dg-error \"must not be a subobject\" }\n    write(6,*) PRESENT(D1)\n   END SUBROUTINE S1\n  END MODULE"}]}