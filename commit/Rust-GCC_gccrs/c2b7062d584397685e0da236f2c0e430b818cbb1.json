{"sha": "c2b7062d584397685e0da236f2c0e430b818cbb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJiNzA2MmQ1ODQzOTc2ODVlMGRhMjM2ZjJjMGU0MzBiODE4Y2JiMQ==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2019-01-10T03:34:06Z"}, "committer": {"name": "Tamar Christina", "email": "tnfchris@gcc.gnu.org", "date": "2019-01-10T03:34:06Z"}, "message": "arm-builtins.c (enum arm_type_qualifiers): Add qualifier_lane_pair_index.\n\n2019-01-10  Tamar Christina  <tamar.christina@arm.com>\n\n\t* config/arm/arm-builtins.c\n\t(enum arm_type_qualifiers): Add qualifier_lane_pair_index.\n\t(MAC_LANE_PAIR_QUALIFIERS): New.\n\t(arm_expand_builtin_args): Use it.\n\t(arm_expand_builtin_1): Likewise.\n\t* config/arm/arm-protos.h (neon_vcmla_lane_prepare_operands): New.\n\t* config/arm/arm.c (neon_vcmla_lane_prepare_operands): New.\n\t* config/arm/arm-c.c (arm_cpu_builtins): Add __ARM_FEATURE_COMPLEX.\n\t* config/arm/arm_neon.h:\n\t(vcadd_rot90_f16): New.\n\t(vcaddq_rot90_f16): New.\n\t(vcadd_rot270_f16): New.\n\t(vcaddq_rot270_f16): New.\n\t(vcmla_f16): New.\n\t(vcmlaq_f16): New.\n\t(vcmla_lane_f16): New.\n\t(vcmla_laneq_f16): New.\n\t(vcmlaq_lane_f16): New.\n\t(vcmlaq_laneq_f16): New.\n\t(vcmla_rot90_f16): New.\n\t(vcmlaq_rot90_f16): New.\n\t(vcmla_rot90_lane_f16): New.\n\t(vcmla_rot90_laneq_f16): New.\n\t(vcmlaq_rot90_lane_f16): New.\n\t(vcmlaq_rot90_laneq_f16): New.\n\t(vcmla_rot180_f16): New.\n\t(vcmlaq_rot180_f16): New.\n\t(vcmla_rot180_lane_f16): New.\n\t(vcmla_rot180_laneq_f16): New.\n\t(vcmlaq_rot180_lane_f16): New.\n\t(vcmlaq_rot180_laneq_f16): New.\n\t(vcmla_rot270_f16): New.\n\t(vcmlaq_rot270_f16): New.\n\t(vcmla_rot270_lane_f16): New.\n\t(vcmla_rot270_laneq_f16): New.\n\t(vcmlaq_rot270_lane_f16): New.\n\t(vcmlaq_rot270_laneq_f16): New.\n\t(vcadd_rot90_f32): New.\n\t(vcaddq_rot90_f32): New.\n\t(vcadd_rot270_f32): New.\n\t(vcaddq_rot270_f32): New.\n\t(vcmla_f32): New.\n\t(vcmlaq_f32): New.\n\t(vcmla_lane_f32): New.\n\t(vcmla_laneq_f32): New.\n\t(vcmlaq_lane_f32): New.\n\t(vcmlaq_laneq_f32): New.\n\t(vcmla_rot90_f32): New.\n\t(vcmlaq_rot90_f32): New.\n\t(vcmla_rot90_lane_f32): New.\n\t(vcmla_rot90_laneq_f32): New.\n\t(vcmlaq_rot90_lane_f32): New.\n\t(vcmlaq_rot90_laneq_f32): New.\n\t(vcmla_rot180_f32): New.\n\t(vcmlaq_rot180_f32): New.\n\t(vcmla_rot180_lane_f32): New.\n\t(vcmla_rot180_laneq_f32): New.\n\t(vcmlaq_rot180_lane_f32): New.\n\t(vcmlaq_rot180_laneq_f32): New.\n\t(vcmla_rot270_f32): New.\n\t(vcmlaq_rot270_f32): New.\n\t(vcmla_rot270_lane_f32): New.\n\t(vcmla_rot270_laneq_f32): New.\n\t(vcmlaq_rot270_lane_f32): New.\n\t(vcmlaq_rot270_laneq_f32): New.\n\t* config/arm/arm_neon_builtins.def (vcadd90, vcadd270, vcmla0, vcmla90,\n\tvcmla180, vcmla270, vcmla_lane0, vcmla_lane90, vcmla_lane180, vcmla_lane270,\n\tvcmla_laneq0, vcmla_laneq90, vcmla_laneq180, vcmla_laneq270,\n\tvcmlaq_lane0, vcmlaq_lane90, vcmlaq_lane180, vcmlaq_lane270): New.\n\t* config/arm/neon.md (neon_vcmla_lane<rot><mode>,\n\tneon_vcmla_laneq<rot><mode>, neon_vcmlaq_lane<rot><mode>): New.\n\t* config/arm/arm.c (arm_arch8_3, arm_arch8_4): New.\n\t* config/arm/arm.h (TARGET_COMPLEX, arm_arch8_3, arm_arch8_4): New.\n\t(arm_option_reconfigure_globals): Use them.\n\t* config/arm/iterators.md (VDF, VQ_HSF): New.\n\t(VCADD, VCMLA): New.\n\t(VF_constraint, rot, rotsplit1, rotsplit2): Add V4HF and V8HF.\n\t* config/arm/neon.md (neon_vcadd<rot><mode>, neon_vcmla<rot><mode>): New.\n\t* config/arm/unspecs.md (UNSPEC_VCADD90, UNSPEC_VCADD270,\n\tUNSPEC_VCMLA, UNSPEC_VCMLA90, UNSPEC_VCMLA180, UNSPEC_VCMLA270): New.\n\ngcc/testsuite/ChangeLog:\n\n2019-01-10  Tamar Christina  <tamar.christina@arm.com>\n\n\t* gcc.target/aarch64/advsimd-intrinsics/vector-complex.c: Add AArch32 regexpr.\n\t* gcc.target/aarch64/advsimd-intrinsics/vector-complex_f16.c: Likewise.\n\nFrom-SVN: r267796", "tree": {"sha": "44fc084c13d4839ac0871ee29a478163f3884ba7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44fc084c13d4839ac0871ee29a478163f3884ba7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2b7062d584397685e0da236f2c0e430b818cbb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2b7062d584397685e0da236f2c0e430b818cbb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2b7062d584397685e0da236f2c0e430b818cbb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2b7062d584397685e0da236f2c0e430b818cbb1/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9d63f43b2d6ac073164a43116b4cb11d7d188ff1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d63f43b2d6ac073164a43116b4cb11d7d188ff1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d63f43b2d6ac073164a43116b4cb11d7d188ff1"}], "stats": {"total": 786, "additions": 780, "deletions": 6}, "files": [{"sha": "e64e1f0fa697ddf490213a11adf36ff5683a3e06", "filename": "gcc/ChangeLog", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2b7062d584397685e0da236f2c0e430b818cbb1", "patch": "@@ -1,3 +1,86 @@\n+2019-01-10  Tamar Christina  <tamar.christina@arm.com>\n+\n+\t* config/arm/arm-builtins.c\n+\t(enum arm_type_qualifiers): Add qualifier_lane_pair_index.\n+\t(MAC_LANE_PAIR_QUALIFIERS): New.\n+\t(arm_expand_builtin_args): Use it.\n+\t(arm_expand_builtin_1): Likewise.\n+\t* config/arm/arm-protos.h (neon_vcmla_lane_prepare_operands): New.\n+\t* config/arm/arm.c (neon_vcmla_lane_prepare_operands): New.\n+\t* config/arm/arm-c.c (arm_cpu_builtins): Add __ARM_FEATURE_COMPLEX.\n+\t* config/arm/arm_neon.h:\n+\t(vcadd_rot90_f16): New.\n+\t(vcaddq_rot90_f16): New.\n+\t(vcadd_rot270_f16): New.\n+\t(vcaddq_rot270_f16): New.\n+\t(vcmla_f16): New.\n+\t(vcmlaq_f16): New.\n+\t(vcmla_lane_f16): New.\n+\t(vcmla_laneq_f16): New.\n+\t(vcmlaq_lane_f16): New.\n+\t(vcmlaq_laneq_f16): New.\n+\t(vcmla_rot90_f16): New.\n+\t(vcmlaq_rot90_f16): New.\n+\t(vcmla_rot90_lane_f16): New.\n+\t(vcmla_rot90_laneq_f16): New.\n+\t(vcmlaq_rot90_lane_f16): New.\n+\t(vcmlaq_rot90_laneq_f16): New.\n+\t(vcmla_rot180_f16): New.\n+\t(vcmlaq_rot180_f16): New.\n+\t(vcmla_rot180_lane_f16): New.\n+\t(vcmla_rot180_laneq_f16): New.\n+\t(vcmlaq_rot180_lane_f16): New.\n+\t(vcmlaq_rot180_laneq_f16): New.\n+\t(vcmla_rot270_f16): New.\n+\t(vcmlaq_rot270_f16): New.\n+\t(vcmla_rot270_lane_f16): New.\n+\t(vcmla_rot270_laneq_f16): New.\n+\t(vcmlaq_rot270_lane_f16): New.\n+\t(vcmlaq_rot270_laneq_f16): New.\n+\t(vcadd_rot90_f32): New.\n+\t(vcaddq_rot90_f32): New.\n+\t(vcadd_rot270_f32): New.\n+\t(vcaddq_rot270_f32): New.\n+\t(vcmla_f32): New.\n+\t(vcmlaq_f32): New.\n+\t(vcmla_lane_f32): New.\n+\t(vcmla_laneq_f32): New.\n+\t(vcmlaq_lane_f32): New.\n+\t(vcmlaq_laneq_f32): New.\n+\t(vcmla_rot90_f32): New.\n+\t(vcmlaq_rot90_f32): New.\n+\t(vcmla_rot90_lane_f32): New.\n+\t(vcmla_rot90_laneq_f32): New.\n+\t(vcmlaq_rot90_lane_f32): New.\n+\t(vcmlaq_rot90_laneq_f32): New.\n+\t(vcmla_rot180_f32): New.\n+\t(vcmlaq_rot180_f32): New.\n+\t(vcmla_rot180_lane_f32): New.\n+\t(vcmla_rot180_laneq_f32): New.\n+\t(vcmlaq_rot180_lane_f32): New.\n+\t(vcmlaq_rot180_laneq_f32): New.\n+\t(vcmla_rot270_f32): New.\n+\t(vcmlaq_rot270_f32): New.\n+\t(vcmla_rot270_lane_f32): New.\n+\t(vcmla_rot270_laneq_f32): New.\n+\t(vcmlaq_rot270_lane_f32): New.\n+\t(vcmlaq_rot270_laneq_f32): New.\n+\t* config/arm/arm_neon_builtins.def (vcadd90, vcadd270, vcmla0, vcmla90,\n+\tvcmla180, vcmla270, vcmla_lane0, vcmla_lane90, vcmla_lane180, vcmla_lane270,\n+\tvcmla_laneq0, vcmla_laneq90, vcmla_laneq180, vcmla_laneq270,\n+\tvcmlaq_lane0, vcmlaq_lane90, vcmlaq_lane180, vcmlaq_lane270): New.\n+\t* config/arm/neon.md (neon_vcmla_lane<rot><mode>,\n+\tneon_vcmla_laneq<rot><mode>, neon_vcmlaq_lane<rot><mode>): New.\n+\t* config/arm/arm.c (arm_arch8_3, arm_arch8_4): New.\n+\t* config/arm/arm.h (TARGET_COMPLEX, arm_arch8_3, arm_arch8_4): New.\n+\t(arm_option_reconfigure_globals): Use them.\n+\t* config/arm/iterators.md (VDF, VQ_HSF): New.\n+\t(VCADD, VCMLA): New.\n+\t(VF_constraint, rot, rotsplit1, rotsplit2): Add V4HF and V8HF.\n+\t* config/arm/neon.md (neon_vcadd<rot><mode>, neon_vcmla<rot><mode>): New.\n+\t* config/arm/unspecs.md (UNSPEC_VCADD90, UNSPEC_VCADD270,\n+\tUNSPEC_VCMLA, UNSPEC_VCMLA90, UNSPEC_VCMLA180, UNSPEC_VCMLA270): New.\n+\n 2019-01-10  Tamar Christina  <tamar.christina@arm.com>\n \n \t* config/aarch64/aarch64-builtins.c (enum aarch64_type_qualifiers): Add qualifier_lane_pair_index."}, {"sha": "f646ab537fcdac54a3eaf0f1fa403698e29ef005", "filename": "gcc/config/arm/arm-builtins.c", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Farm-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Farm-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.c?ref=c2b7062d584397685e0da236f2c0e430b818cbb1", "patch": "@@ -82,7 +82,10 @@ enum arm_type_qualifiers\n   /* A void pointer.  */\n   qualifier_void_pointer = 0x800,\n   /* A const void pointer.  */\n-  qualifier_const_void_pointer = 0x802\n+  qualifier_const_void_pointer = 0x802,\n+  /* Lane indices selected in pairs - must be within range of previous\n+     argument = a vector.  */\n+  qualifier_lane_pair_index = 0x1000\n };\n \n /*  The qualifier_internal allows generation of a unary builtin from\n@@ -144,6 +147,13 @@ arm_mac_lane_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n       qualifier_none, qualifier_lane_index };\n #define MAC_LANE_QUALIFIERS (arm_mac_lane_qualifiers)\n \n+/* T (T, T, T, lane pair index).  */\n+static enum arm_type_qualifiers\n+arm_mac_lane_pair_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_none, qualifier_none, qualifier_none,\n+      qualifier_none, qualifier_lane_pair_index };\n+#define MAC_LANE_PAIR_QUALIFIERS (arm_mac_lane_pair_qualifiers)\n+\n /* unsigned T (unsigned T, unsigned T, unsigend T, lane index).  */\n static enum arm_type_qualifiers\n arm_umac_lane_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n@@ -2129,6 +2139,7 @@ typedef enum {\n   ARG_BUILTIN_CONSTANT,\n   ARG_BUILTIN_LANE_INDEX,\n   ARG_BUILTIN_STRUCT_LOAD_STORE_LANE_INDEX,\n+  ARG_BUILTIN_LANE_PAIR_INDEX,\n   ARG_BUILTIN_NEON_MEMORY,\n   ARG_BUILTIN_MEMORY,\n   ARG_BUILTIN_STOP\n@@ -2266,6 +2277,19 @@ arm_expand_builtin_args (rtx target, machine_mode map_mode, int fcode,\n \t\t  machine_mode vmode = mode[argc - 1];\n \t\t  neon_lane_bounds (op[argc], 0, GET_MODE_NUNITS (vmode), exp);\n \t\t}\n+\t      /* If the lane index isn't a constant then error out.  */\n+\t      goto constant_arg;\n+\n+\t    case ARG_BUILTIN_LANE_PAIR_INDEX:\n+\t      /* Previous argument must be a vector, which this indexes. The\n+\t\t indexing will always select i and i+1 out of the vector, which\n+\t\t puts a limit on i.  */\n+\t      gcc_assert (argc > 0);\n+\t      if (CONST_INT_P (op[argc]))\n+\t\t{\n+\t\t  machine_mode vmode = mode[argc - 1];\n+\t\t  neon_lane_bounds (op[argc], 0, GET_MODE_NUNITS (vmode) / 2, exp);\n+\t\t}\n \t      /* If the lane index isn't a constant then the next\n \t\t case will error.  */\n \t      /* Fall through.  */\n@@ -2427,6 +2451,8 @@ arm_expand_builtin_1 (int fcode, tree exp, rtx target,\n \n       if (d->qualifiers[qualifiers_k] & qualifier_lane_index)\n \targs[k] = ARG_BUILTIN_LANE_INDEX;\n+      else if (d->qualifiers[qualifiers_k] & qualifier_lane_pair_index)\n+\targs[k] = ARG_BUILTIN_LANE_PAIR_INDEX;\n       else if (d->qualifiers[qualifiers_k] & qualifier_struct_load_store_lane_index)\n \targs[k] = ARG_BUILTIN_STRUCT_LOAD_STORE_LANE_INDEX;\n       else if (d->qualifiers[qualifiers_k] & qualifier_immediate)"}, {"sha": "6e256ee0a122faf5ab59a5dcb40ec89bd04e5778", "filename": "gcc/config/arm/arm-c.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Farm-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Farm-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-c.c?ref=c2b7062d584397685e0da236f2c0e430b818cbb1", "patch": "@@ -76,6 +76,7 @@ arm_cpu_builtins (struct cpp_reader* pfile)\n \n   def_or_undef_macro (pfile, \"__ARM_FEATURE_CRC32\", TARGET_CRC32);\n   def_or_undef_macro (pfile, \"__ARM_FEATURE_DOTPROD\", TARGET_DOTPROD);\n+  def_or_undef_macro (pfile, \"__ARM_FEATURE_COMPLEX\", TARGET_COMPLEX);\n   def_or_undef_macro (pfile, \"__ARM_32BIT_STATE\", TARGET_32BIT);\n \n   cpp_undef (pfile, \"__ARM_FEATURE_CMSE\");"}, {"sha": "2bc43019864ef70ed1bf1e725bad7437cf9b11d8", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=c2b7062d584397685e0da236f2c0e430b818cbb1", "patch": "@@ -109,6 +109,8 @@ extern int arm_coproc_mem_operand (rtx, bool);\n extern int neon_vector_mem_operand (rtx, int, bool);\n extern int neon_struct_mem_operand (rtx);\n \n+extern rtx *neon_vcmla_lane_prepare_operands (machine_mode, rtx *);\n+\n extern int tls_mentioned_p (rtx);\n extern int symbol_mentioned_p (rtx);\n extern int label_mentioned_p (rtx);"}, {"sha": "f473aee8d34c384a16a8c52f0c820269ad408698", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c2b7062d584397685e0da236f2c0e430b818cbb1", "patch": "@@ -895,6 +895,12 @@ int arm_arch8_1 = 0;\n /* Nonzero if this chip supports the ARM Architecture 8.2 extensions.  */\n int arm_arch8_2 = 0;\n \n+/* Nonzero if this chip supports the ARM Architecture 8.3 extensions.  */\n+int arm_arch8_3 = 0;\n+\n+/* Nonzero if this chip supports the ARM Architecture 8.4 extensions.  */\n+int arm_arch8_4 = 0;\n+\n /* Nonzero if this chip supports the FP16 instructions extension of ARM\n    Architecture 8.2.  */\n int arm_fp16_inst = 0;\n@@ -3649,6 +3655,8 @@ arm_option_reconfigure_globals (void)\n   arm_arch8 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv8);\n   arm_arch8_1 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv8_1);\n   arm_arch8_2 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv8_2);\n+  arm_arch8_3 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv8_3);\n+  arm_arch8_4 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv8_4);\n   arm_arch_thumb1 = bitmap_bit_p (arm_active_target.isa, isa_bit_thumb);\n   arm_arch_thumb2 = bitmap_bit_p (arm_active_target.isa, isa_bit_thumb2);\n   arm_arch_xscale = bitmap_bit_p (arm_active_target.isa, isa_bit_xscale);\n@@ -12713,6 +12721,44 @@ neon_struct_mem_operand (rtx op)\n   return FALSE;\n }\n \n+/* Prepares the operands for the VCMLA by lane instruction such that the right\n+   register number is selected.  This instruction is special in that it always\n+   requires a D register, however there is a choice to be made between Dn[0],\n+   Dn[1], D(n+1)[0], and D(n+1)[1] depending on the mode of the registers and\n+   the PATTERNMODE of the insn.\n+\n+   The VCMLA by lane function always selects two values. For instance given D0\n+   and a V2SF, the only valid index is 0 as the values in S0 and S1 will be\n+   used by the instruction.  However given V4SF then index 0 and 1 are valid as\n+   D0[0] or D1[0] are both valid.\n+\n+   This function centralizes that information based on OPERANDS, OPERANDS[3]\n+   will be changed from a REG into a CONST_INT RTX and OPERANDS[4] will be\n+   updated to contain the right index.  */\n+\n+rtx *\n+neon_vcmla_lane_prepare_operands (machine_mode patternmode, rtx *operands)\n+{\n+  int lane = NEON_ENDIAN_LANE_N (patternmode, INTVAL (operands[4]));\n+  machine_mode constmode = SImode;\n+  machine_mode mode = GET_MODE (operands[3]);\n+  int regno = REGNO (operands[3]);\n+  regno = ((regno - FIRST_VFP_REGNUM) >> 1);\n+  if (lane > 0 && lane >= GET_MODE_NUNITS (mode) / 4)\n+    {\n+      operands[3] = gen_int_mode (regno + 1, constmode);\n+      operands[4]\n+\t= gen_int_mode (lane - GET_MODE_NUNITS (mode) / 4, constmode);\n+    }\n+  else\n+    {\n+      operands[3] = gen_int_mode (regno, constmode);\n+      operands[4] = gen_int_mode (lane, constmode);\n+    }\n+  return operands;\n+}\n+\n+\n /* Return true if X is a register that will be eliminated later on.  */\n int\n arm_eliminable_register (rtx x)"}, {"sha": "103d390dd17273e947bbd4d605be2c1ef70fb137", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=c2b7062d584397685e0da236f2c0e430b818cbb1", "patch": "@@ -220,6 +220,9 @@ extern tree arm_fp16_type_node;\n \t\t\t\t\tisa_bit_dotprod)\t\t\\\n \t\t\t&& arm_arch8_2)\n \n+/* Supports the Armv8.3-a Complex number AdvSIMD extensions.  */\n+#define TARGET_COMPLEX (TARGET_NEON && arm_arch8_3)\n+\n /* FPU supports the floating point FP16 instructions for ARMv8.2-A\n    and later.  */\n #define TARGET_VFP_FP16INST \\\n@@ -442,6 +445,12 @@ extern int arm_arch8_1;\n /* Nonzero if this chip supports the ARM Architecture 8.2 extensions.  */\n extern int arm_arch8_2;\n \n+/* Nonzero if this chip supports the ARM Architecture 8.3 extensions.  */\n+extern int arm_arch8_3;\n+\n+/* Nonzero if this chip supports the ARM Architecture 8.4 extensions.  */\n+extern int arm_arch8_4;\n+\n /* Nonzero if this chip supports the FP16 instructions extension of ARM\n    Architecture 8.2.  */\n extern int arm_fp16_inst;"}, {"sha": "3cc2179ddee2a33f170c62ee58c0399b1bcbfd99", "filename": "gcc/config/arm/arm_neon.h", "status": "modified", "additions": 439, "deletions": 0, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Farm_neon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Farm_neon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_neon.h?ref=c2b7062d584397685e0da236f2c0e430b818cbb1", "patch": "@@ -18307,6 +18307,445 @@ vfmlsl_laneq_high_u32 (float32x2_t __r, float16x4_t __a, float16x8_t __b,\n #pragma GCC pop_options\n #endif\n \n+/* AdvSIMD Complex numbers intrinsics.  */\n+#if __ARM_ARCH >= 8\n+#pragma GCC push_options\n+#pragma GCC target((\"arch=armv8.3-a\"))\n+\n+\n+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)\n+#pragma GCC push_options\n+#pragma GCC target((\"+fp16\"))\n+__extension__ extern __inline float16x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcadd_rot90_f16 (float16x4_t __a, float16x4_t __b)\n+{\n+  return __builtin_neon_vcadd90v4hf (__a, __b);\n+}\n+\n+__extension__ extern __inline float16x8_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcaddq_rot90_f16 (float16x8_t __a, float16x8_t __b)\n+{\n+  return __builtin_neon_vcadd90v8hf (__a, __b);\n+}\n+\n+__extension__ extern __inline float16x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcadd_rot270_f16 (float16x4_t __a, float16x4_t __b)\n+{\n+  return __builtin_neon_vcadd90v4hf (__a, __b);\n+}\n+\n+__extension__ extern __inline float16x8_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcaddq_rot270_f16 (float16x8_t __a, float16x8_t __b)\n+{\n+  return __builtin_neon_vcadd90v8hf (__a, __b);\n+}\n+\n+__extension__ extern __inline float16x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_f16 (float16x4_t __r, float16x4_t __a, float16x4_t __b)\n+{\n+  return __builtin_neon_vcmla0v4hf (__r, __a, __b);\n+}\n+\n+__extension__ extern __inline float16x8_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_f16 (float16x8_t __r, float16x8_t __a, float16x8_t __b)\n+{\n+  return __builtin_neon_vcmla0v8hf (__r, __a, __b);\n+}\n+\n+__extension__ extern __inline float16x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_lane_f16 (float16x4_t __r, float16x4_t __a, float16x4_t __b,\n+\t\tconst int __index)\n+{\n+  return __builtin_neon_vcmla_lane0v4hf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float16x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_laneq_f16 (float16x4_t __r, float16x4_t __a, float16x8_t __b,\n+\t\t const int __index)\n+{\n+  return __builtin_neon_vcmla_laneq0v4hf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float16x8_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_lane_f16 (float16x8_t __r, float16x8_t __a, float16x4_t __b,\n+\t\t const int __index)\n+{\n+  return __builtin_neon_vcmlaq_lane0v8hf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float16x8_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_laneq_f16 (float16x8_t __r, float16x8_t __a, float16x8_t __b,\n+\t\t  const int __index)\n+{\n+  return __builtin_neon_vcmla_lane0v8hf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float16x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot90_f16 (float16x4_t __r, float16x4_t __a, float16x4_t __b)\n+{\n+  return __builtin_neon_vcmla90v4hf (__r, __a, __b);\n+}\n+\n+__extension__ extern __inline float16x8_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot90_f16 (float16x8_t __r, float16x8_t __a, float16x8_t __b)\n+{\n+  return __builtin_neon_vcmla90v8hf (__r, __a, __b);\n+}\n+\n+__extension__ extern __inline float16x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot90_lane_f16 (float16x4_t __r, float16x4_t __a, float16x4_t __b,\n+\t\t      const int __index)\n+{\n+  return __builtin_neon_vcmla_lane90v4hf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float16x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot90_laneq_f16 (float16x4_t __r, float16x4_t __a, float16x8_t __b,\n+\t\t       const int __index)\n+{\n+  return __builtin_neon_vcmla_laneq90v4hf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float16x8_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot90_lane_f16 (float16x8_t __r, float16x8_t __a, float16x4_t __b,\n+\t\t       const int __index)\n+{\n+  return __builtin_neon_vcmlaq_lane90v8hf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float16x8_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot90_laneq_f16 (float16x8_t __r, float16x8_t __a, float16x8_t __b,\n+\t\t\tconst int __index)\n+{\n+  return __builtin_neon_vcmla_lane90v8hf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float16x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot180_f16 (float16x4_t __r, float16x4_t __a, float16x4_t __b)\n+{\n+  return __builtin_neon_vcmla180v4hf (__r, __a, __b);\n+}\n+\n+__extension__ extern __inline float16x8_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot180_f16 (float16x8_t __r, float16x8_t __a, float16x8_t __b)\n+{\n+  return __builtin_neon_vcmla180v8hf (__r, __a, __b);\n+}\n+\n+__extension__ extern __inline float16x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot180_lane_f16 (float16x4_t __r, float16x4_t __a, float16x4_t __b,\n+\t\t       const int __index)\n+{\n+  return __builtin_neon_vcmla_lane180v4hf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float16x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot180_laneq_f16 (float16x4_t __r, float16x4_t __a, float16x8_t __b,\n+\t\t\tconst int __index)\n+{\n+  return __builtin_neon_vcmla_laneq180v4hf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float16x8_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot180_lane_f16 (float16x8_t __r, float16x8_t __a, float16x4_t __b,\n+\t\t\tconst int __index)\n+{\n+  return __builtin_neon_vcmlaq_lane180v8hf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float16x8_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot180_laneq_f16 (float16x8_t __r, float16x8_t __a, float16x8_t __b,\n+\t\t\t const int __index)\n+{\n+  return __builtin_neon_vcmla_lane180v8hf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float16x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot270_f16 (float16x4_t __r, float16x4_t __a, float16x4_t __b)\n+{\n+  return __builtin_neon_vcmla270v4hf (__r, __a, __b);\n+}\n+\n+__extension__ extern __inline float16x8_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot270_f16 (float16x8_t __r, float16x8_t __a, float16x8_t __b)\n+{\n+  return __builtin_neon_vcmla270v8hf (__r, __a, __b);\n+}\n+\n+__extension__ extern __inline float16x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot270_lane_f16 (float16x4_t __r, float16x4_t __a, float16x4_t __b,\n+\t\t       const int __index)\n+{\n+  return __builtin_neon_vcmla_lane270v4hf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float16x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot270_laneq_f16 (float16x4_t __r, float16x4_t __a, float16x8_t __b,\n+\t\t\tconst int __index)\n+{\n+  return __builtin_neon_vcmla_laneq270v4hf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float16x8_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot270_lane_f16 (float16x8_t __r, float16x8_t __a, float16x4_t __b,\n+\t\t\tconst int __index)\n+{\n+  return __builtin_neon_vcmlaq_lane270v8hf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float16x8_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot270_laneq_f16 (float16x8_t __r, float16x8_t __a, float16x8_t __b,\n+\t\t\t const int __index)\n+{\n+  return __builtin_neon_vcmla_lane270v8hf (__r, __a, __b, __index);\n+}\n+\n+#pragma GCC pop_options\n+#endif\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcadd_rot90_f32 (float32x2_t __a, float32x2_t __b)\n+{\n+  return __builtin_neon_vcadd90v2sf (__a, __b);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcaddq_rot90_f32 (float32x4_t __a, float32x4_t __b)\n+{\n+  return __builtin_neon_vcadd90v4sf (__a, __b);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcadd_rot270_f32 (float32x2_t __a, float32x2_t __b)\n+{\n+  return __builtin_neon_vcadd90v2sf (__a, __b);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcaddq_rot270_f32 (float32x4_t __a, float32x4_t __b)\n+{\n+  return __builtin_neon_vcadd90v4sf (__a, __b);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_f32 (float32x2_t __r, float32x2_t __a, float32x2_t __b)\n+{\n+  return __builtin_neon_vcmla0v2sf (__r, __a, __b);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_f32 (float32x4_t __r, float32x4_t __a, float32x4_t __b)\n+{\n+  return __builtin_neon_vcmla0v4sf (__r, __a, __b);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_lane_f32 (float32x2_t __r, float32x2_t __a, float32x2_t __b,\n+\t\tconst int __index)\n+{\n+  return __builtin_neon_vcmla_lane0v2sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_laneq_f32 (float32x2_t __r, float32x2_t __a, float32x4_t __b,\n+\t\t const int __index)\n+{\n+  return __builtin_neon_vcmla_laneq0v2sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_lane_f32 (float32x4_t __r, float32x4_t __a, float32x2_t __b,\n+\t\t const int __index)\n+{\n+  return __builtin_neon_vcmlaq_lane0v4sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_laneq_f32 (float32x4_t __r, float32x4_t __a, float32x4_t __b,\n+\t\t  const int __index)\n+{\n+  return __builtin_neon_vcmla_lane0v4sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot90_f32 (float32x2_t __r, float32x2_t __a, float32x2_t __b)\n+{\n+  return __builtin_neon_vcmla90v2sf (__r, __a, __b);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot90_f32 (float32x4_t __r, float32x4_t __a, float32x4_t __b)\n+{\n+  return __builtin_neon_vcmla90v4sf (__r, __a, __b);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot90_lane_f32 (float32x2_t __r, float32x2_t __a, float32x2_t __b,\n+\t\t      const int __index)\n+{\n+  return __builtin_neon_vcmla_lane90v2sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot90_laneq_f32 (float32x2_t __r, float32x2_t __a, float32x4_t __b,\n+\t\t       const int __index)\n+{\n+  return __builtin_neon_vcmla_laneq90v2sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot90_lane_f32 (float32x4_t __r, float32x4_t __a, float32x2_t __b,\n+\t\t       const int __index)\n+{\n+  return __builtin_neon_vcmlaq_lane90v4sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot90_laneq_f32 (float32x4_t __r, float32x4_t __a, float32x4_t __b,\n+\t\t\tconst int __index)\n+{\n+  return __builtin_neon_vcmla_lane90v4sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot180_f32 (float32x2_t __r, float32x2_t __a, float32x2_t __b)\n+{\n+  return __builtin_neon_vcmla180v2sf (__r, __a, __b);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot180_f32 (float32x4_t __r, float32x4_t __a, float32x4_t __b)\n+{\n+  return __builtin_neon_vcmla180v4sf (__r, __a, __b);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot180_lane_f32 (float32x2_t __r, float32x2_t __a, float32x2_t __b,\n+\t\t       const int __index)\n+{\n+  return __builtin_neon_vcmla_lane180v2sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot180_laneq_f32 (float32x2_t __r, float32x2_t __a, float32x4_t __b,\n+\t\t\tconst int __index)\n+{\n+  return __builtin_neon_vcmla_laneq180v2sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot180_lane_f32 (float32x4_t __r, float32x4_t __a, float32x2_t __b,\n+\t\t\tconst int __index)\n+{\n+  return __builtin_neon_vcmlaq_lane180v4sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot180_laneq_f32 (float32x4_t __r, float32x4_t __a, float32x4_t __b,\n+\t\t\t const int __index)\n+{\n+  return __builtin_neon_vcmla_lane180v4sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot270_f32 (float32x2_t __r, float32x2_t __a, float32x2_t __b)\n+{\n+  return __builtin_neon_vcmla270v2sf (__r, __a, __b);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot270_f32 (float32x4_t __r, float32x4_t __a, float32x4_t __b)\n+{\n+  return __builtin_neon_vcmla270v4sf (__r, __a, __b);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot270_lane_f32 (float32x2_t __r, float32x2_t __a, float32x2_t __b,\n+\t\t       const int __index)\n+{\n+  return __builtin_neon_vcmla_lane270v2sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmla_rot270_laneq_f32 (float32x2_t __r, float32x2_t __a, float32x4_t __b,\n+\t\t\tconst int __index)\n+{\n+  return __builtin_neon_vcmla_laneq270v2sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot270_lane_f32 (float32x4_t __r, float32x4_t __a, float32x2_t __b,\n+\t\t\tconst int __index)\n+{\n+  return __builtin_neon_vcmlaq_lane270v4sf (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline float32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vcmlaq_rot270_laneq_f32 (float32x4_t __r, float32x4_t __a, float32x4_t __b,\n+\t\t\t const int __index)\n+{\n+  return __builtin_neon_vcmla_lane270v4sf (__r, __a, __b, __index);\n+}\n+\n+#pragma GCC pop_options\n+#endif\n+\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "bcccf93f7fa2750e9006e5856efecbec0fb331b9", "filename": "gcc/config/arm/arm_neon_builtins.def", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def?ref=c2b7062d584397685e0da236f2c0e430b818cbb1", "patch": "@@ -351,3 +351,25 @@ VAR2 (TERNOP, sdot, v8qi, v16qi)\n VAR2 (UTERNOP, udot, v8qi, v16qi)\n VAR2 (MAC_LANE, sdot_lane, v8qi, v16qi)\n VAR2 (UMAC_LANE, udot_lane, v8qi, v16qi)\n+\n+VAR4 (BINOP, vcadd90, v4hf, v2sf, v8hf, v4sf)\n+VAR4 (BINOP, vcadd270, v4hf, v2sf, v8hf, v4sf)\n+VAR4 (TERNOP, vcmla0, v2sf, v4sf, v4hf, v8hf)\n+VAR4 (TERNOP, vcmla90, v2sf, v4sf, v4hf, v8hf)\n+VAR4 (TERNOP, vcmla180, v2sf, v4sf, v4hf, v8hf)\n+VAR4 (TERNOP, vcmla270, v2sf, v4sf, v4hf, v8hf)\n+\n+VAR4 (MAC_LANE_PAIR, vcmla_lane0, v2sf, v4hf, v8hf, v4sf)\n+VAR4 (MAC_LANE_PAIR, vcmla_lane90, v2sf, v4hf, v8hf, v4sf)\n+VAR4 (MAC_LANE_PAIR, vcmla_lane180, v2sf, v4hf, v8hf, v4sf)\n+VAR4 (MAC_LANE_PAIR, vcmla_lane270, v2sf, v4hf, v8hf, v4sf)\n+\n+VAR2 (MAC_LANE_PAIR, vcmla_laneq0, v2sf, v4hf)\n+VAR2 (MAC_LANE_PAIR, vcmla_laneq90, v2sf, v4hf)\n+VAR2 (MAC_LANE_PAIR, vcmla_laneq180, v2sf, v4hf)\n+VAR2 (MAC_LANE_PAIR, vcmla_laneq270, v2sf, v4hf)\n+\n+VAR2 (MAC_LANE_PAIR, vcmlaq_lane0, v4sf, v8hf)\n+VAR2 (MAC_LANE_PAIR, vcmlaq_lane90, v4sf, v8hf)\n+VAR2 (MAC_LANE_PAIR, vcmlaq_lane180, v4sf, v8hf)\n+VAR2 (MAC_LANE_PAIR, vcmlaq_lane270, v4sf, v8hf)"}, {"sha": "c33e572c3e89c3dc5848bd6b825d618481247558", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=c2b7062d584397685e0da236f2c0e430b818cbb1", "patch": "@@ -123,6 +123,13 @@\n (define_mode_iterator VF [(V4HF \"TARGET_NEON_FP16INST\")\n \t\t\t   (V8HF \"TARGET_NEON_FP16INST\") V2SF V4SF])\n \n+;; Double vector modes.\n+(define_mode_iterator VDF [V2SF V4HF])\n+\n+;; Quad vector Float modes with half/single elements.\n+(define_mode_iterator VQ_HSF [V8HF V4SF])\n+\n+\n ;; All supported vector modes (except those with 64-bit integer elements).\n (define_mode_iterator VDQW [V8QI V16QI V4HI V8HI V2SI V4SI V2SF V4SF])\n \n@@ -423,6 +430,9 @@\n \n (define_int_iterator VFMLHALVES [UNSPEC_VFML_LO UNSPEC_VFML_HI])\n \n+(define_int_iterator VCADD [UNSPEC_VCADD90 UNSPEC_VCADD270])\n+(define_int_iterator VCMLA [UNSPEC_VCMLA UNSPEC_VCMLA90 UNSPEC_VCMLA180 UNSPEC_VCMLA270])\n+\n ;;----------------------------------------------------------------------------\n ;; Mode attributes\n ;;----------------------------------------------------------------------------\n@@ -741,7 +751,7 @@\n (define_mode_attr F_constraint [(SF \"t\") (DF \"w\")])\n (define_mode_attr vfp_type [(SF \"s\") (DF \"d\")])\n (define_mode_attr vfp_double_cond [(SF \"\") (DF \"&& TARGET_VFP_DOUBLE\")])\n-(define_mode_attr VF_constraint [(V2SF \"t\") (V4SF \"w\")])\n+(define_mode_attr VF_constraint [(V4HF \"t\") (V8HF \"t\") (V2SF \"t\") (V4SF \"w\")])\n \n ;; Mode attribute used to build the \"type\" attribute.\n (define_mode_attr q [(V8QI \"\") (V16QI \"_q\")\n@@ -989,6 +999,13 @@\n                           (UNSPEC_SHA1SU0 \"V4SI\") (UNSPEC_SHA256H \"V4SI\")\n                           (UNSPEC_SHA256H2 \"V4SI\") (UNSPEC_SHA256SU1 \"V4SI\")])\n \n+(define_int_attr rot [(UNSPEC_VCADD90 \"90\")\n+\t\t      (UNSPEC_VCADD270 \"270\")\n+\t\t      (UNSPEC_VCMLA \"0\")\n+\t\t      (UNSPEC_VCMLA90 \"90\")\n+\t\t      (UNSPEC_VCMLA180 \"180\")\n+\t\t      (UNSPEC_VCMLA270 \"270\")])\n+\n ;; Both kinds of return insn.\n (define_code_iterator RETURNS [return simple_return])\n (define_code_attr return_str [(return \"\") (simple_return \"simple_\")])"}, {"sha": "6f8e7c1cffd2751c1ee7e03ded0410ad3c09c13f", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=c2b7062d584397685e0da236f2c0e430b818cbb1", "patch": "@@ -3457,6 +3457,80 @@\n   DONE;\n })\n \n+\n+;; The vcadd and vcmla patterns are made UNSPEC for the explicitly due to the\n+;; fact that their usage need to guarantee that the source vectors are\n+;; contiguous.  It would be wrong to describe the operation without being able\n+;; to describe the permute that is also required, but even if that is done\n+;; the permute would have been created as a LOAD_LANES which means the values\n+;; in the registers are in the wrong order.\n+(define_insn \"neon_vcadd<rot><mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\" \"=w\")\n+\t(unspec:VF [(match_operand:VF 1 \"register_operand\" \"w\")\n+\t\t    (match_operand:VF 2 \"register_operand\" \"w\")]\n+\t\t    VCADD))]\n+  \"TARGET_COMPLEX\"\n+  \"vcadd.<V_s_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2, #<rot>\"\n+  [(set_attr \"type\" \"neon_fcadd\")]\n+)\n+\n+(define_insn \"neon_vcmla<rot><mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\" \"=w\")\n+\t(plus:VF (match_operand:VF 1 \"register_operand\" \"0\")\n+\t\t (unspec:VF [(match_operand:VF 2 \"register_operand\" \"w\")\n+\t\t\t     (match_operand:VF 3 \"register_operand\" \"w\")]\n+\t\t\t     VCMLA)))]\n+  \"TARGET_COMPLEX\"\n+  \"vcmla.<V_s_elem>\\t%<V_reg>0, %<V_reg>2, %<V_reg>3, #<rot>\"\n+  [(set_attr \"type\" \"neon_fcmla\")]\n+)\n+\n+(define_insn \"neon_vcmla_lane<rot><mode>\"\n+  [(set (match_operand:VF 0 \"s_register_operand\" \"=w\")\n+\t(plus:VF (match_operand:VF 1 \"s_register_operand\" \"0\")\n+\t\t (unspec:VF [(match_operand:VF 2 \"s_register_operand\" \"w\")\n+\t\t\t     (match_operand:VF 3 \"s_register_operand\" \"<VF_constraint>\")\n+\t\t\t     (match_operand:SI 4 \"const_int_operand\" \"n\")]\n+\t\t\t     VCMLA)))]\n+  \"TARGET_COMPLEX\"\n+  {\n+    operands = neon_vcmla_lane_prepare_operands (<MODE>mode, operands);\n+    return \"vcmla.<V_s_elem>\\t%<V_reg>0, %<V_reg>2, d%c3[%c4], #<rot>\";\n+  }\n+  [(set_attr \"type\" \"neon_fcmla\")]\n+)\n+\n+(define_insn \"neon_vcmla_laneq<rot><mode>\"\n+  [(set (match_operand:VDF 0 \"s_register_operand\" \"=w\")\n+\t(plus:VDF (match_operand:VDF 1 \"s_register_operand\" \"0\")\n+\t\t  (unspec:VDF [(match_operand:VDF 2 \"s_register_operand\" \"w\")\n+\t\t\t      (match_operand:<V_DOUBLE> 3 \"s_register_operand\" \"<VF_constraint>\")\n+\t\t\t      (match_operand:SI 4 \"const_int_operand\" \"n\")]\n+\t\t\t      VCMLA)))]\n+  \"TARGET_COMPLEX\"\n+  {\n+    operands = neon_vcmla_lane_prepare_operands (<MODE>mode, operands);\n+    return \"vcmla.<V_s_elem>\\t%<V_reg>0, %<V_reg>2, d%c3[%c4], #<rot>\";\n+  }\n+  [(set_attr \"type\" \"neon_fcmla\")]\n+)\n+\n+(define_insn \"neon_vcmlaq_lane<rot><mode>\"\n+  [(set (match_operand:VQ_HSF 0 \"s_register_operand\" \"=w\")\n+\t(plus:VQ_HSF (match_operand:VQ_HSF 1 \"s_register_operand\" \"0\")\n+\t\t (unspec:VQ_HSF [(match_operand:VQ_HSF 2 \"s_register_operand\" \"w\")\n+\t\t\t\t (match_operand:<V_HALF> 3 \"s_register_operand\" \"<VF_constraint>\")\n+\t\t\t\t (match_operand:SI 4 \"const_int_operand\" \"n\")]\n+\t\t\t\t VCMLA)))]\n+  \"TARGET_COMPLEX\"\n+  {\n+    operands = neon_vcmla_lane_prepare_operands (<MODE>mode, operands);\n+    return \"vcmla.<V_s_elem>\\t%<V_reg>0, %<V_reg>2, d%c3[%c4], #<rot>\";\n+  }\n+  [(set_attr \"type\" \"neon_fcmla\")]\n+)\n+\n+\n ;; These instructions map to the __builtins for the Dot Product operations.\n (define_insn \"neon_<sup>dot<vsi2qi>\"\n   [(set (match_operand:VCVTI 0 \"register_operand\" \"=w\")"}, {"sha": "174bcc5e3d5e1123cb1c1a595f5003884840aea8", "filename": "gcc/config/arm/unspecs.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Funspecs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Fconfig%2Farm%2Funspecs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funspecs.md?ref=c2b7062d584397685e0da236f2c0e430b818cbb1", "patch": "@@ -418,4 +418,10 @@\n   UNSPEC_DOT_U\n   UNSPEC_VFML_LO\n   UNSPEC_VFML_HI\n+  UNSPEC_VCADD90\n+  UNSPEC_VCADD270\n+  UNSPEC_VCMLA\n+  UNSPEC_VCMLA90\n+  UNSPEC_VCMLA180\n+  UNSPEC_VCMLA270\n ])"}, {"sha": "7ba27e1f6224cae8e04ed56f83539d50933dd62d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c2b7062d584397685e0da236f2c0e430b818cbb1", "patch": "@@ -1,3 +1,8 @@\n+2019-01-10  Tamar Christina  <tamar.christina@arm.com>\n+\n+\t* gcc.target/aarch64/advsimd-intrinsics/vector-complex.c: Add AArch32 regexpr.\n+\t* gcc.target/aarch64/advsimd-intrinsics/vector-complex_f16.c: Likewise.\n+\n 2019-01-10  Tamar Christina  <tamar.christina@arm.com>\n \n \t* gcc.target/aarch64/advsimd-intrinsics/vector-complex.c: New test."}, {"sha": "1428cbe3f695f082ccae91dfb32ab92461561891", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vector-complex.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvector-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvector-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvector-complex.c?ref=c2b7062d584397685e0da236f2c0e430b818cbb1", "patch": "@@ -1,5 +1,4 @@\n-/* { dg-skip-if \"\" { arm-*-* } } */\n-/* { dg-do assemble } */\n+/* { dg-do compile } */\n /* { dg-require-effective-target arm_v8_3a_complex_neon_ok } */\n /* { dg-add-options arm_v8_3a_complex_neon }  */\n /* { dg-additional-options \"-O2 -save-temps\" } */\n@@ -249,3 +248,22 @@ test_vcmlaq_rot270_laneq_f32 (float32x4_t __r, float32x4_t __a, float32x4_t __b)\n /* { dg-final { scan-assembler-times {fcmla\\tv[0-9]+.4s, v[0-9]+.4s, v[0-9]+.s\\[1\\], #270} 1 { target { aarch64*-*-* } } } } */\n /* { dg-final { scan-assembler-times {fcmla\\tv[0-9]+.4s, v[0-9]+.4s, v[0-9]+.s\\[1\\], #90} 1 { target { aarch64*-*-* } } } } */\n /* { dg-final { scan-assembler-times {dup\\td[0-9]+, v[0-9]+.d\\[1\\]} 4 { target { aarch64*-*-* } } } } */\n+\n+/* { dg-final { scan-assembler-times {vcadd.f32\\td[0-9]+, d[0-9]+, d[0-9]+, #90} 2 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcadd.f32\\tq[0-9]+, q[0-9]+, q[0-9]+, #90} 2 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f32\\td[0-9]+, d[0-9]+, d[0-9]+, #0} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f32\\td[0-9]+, d[0-9]+, d[0-9]+, #180} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f32\\td[0-9]+, d[0-9]+, d[0-9]+, #270} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f32\\td[0-9]+, d[0-9]+, d[0-9]+, #90} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f32\\td[0-9]+, d[0-9]+, d[0-9]+\\[0\\], #0} 2 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f32\\td[0-9]+, d[0-9]+, d[0-9]+\\[0\\], #180} 2 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f32\\td[0-9]+, d[0-9]+, d[0-9]+\\[0\\], #270} 2 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f32\\td[0-9]+, d[0-9]+, d[0-9]+\\[0\\], #90} 2 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f32\\tq[0-9]+, q[0-9]+, d[0-9]+\\[0\\], #0} 2 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f32\\tq[0-9]+, q[0-9]+, d[0-9]+\\[0\\], #180} 2 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f32\\tq[0-9]+, q[0-9]+, d[0-9]+\\[0\\], #270} 2 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f32\\tq[0-9]+, q[0-9]+, d[0-9]+\\[0\\], #90} 2 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f32\\tq[0-9]+, q[0-9]+, q[0-9]+, #0} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f32\\tq[0-9]+, q[0-9]+, q[0-9]+, #180} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f32\\tq[0-9]+, q[0-9]+, q[0-9]+, #270} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f32\\tq[0-9]+, q[0-9]+, q[0-9]+, #90} 1 { target { arm*-*-* } } } } */"}, {"sha": "99754b67e4b4f62561a2c094a59bb70d6af4f31a", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vector-complex_f16.c", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvector-complex_f16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b7062d584397685e0da236f2c0e430b818cbb1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvector-complex_f16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvector-complex_f16.c?ref=c2b7062d584397685e0da236f2c0e430b818cbb1", "patch": "@@ -1,5 +1,4 @@\n-/* { dg-skip-if \"\" { arm-*-* } } */\n-/* { dg-do assemble } */\n+/* { dg-do compile } */\n /* { dg-require-effective-target arm_v8_3a_complex_neon_ok } */\n /* { dg-require-effective-target arm_v8_2a_fp16_scalar_ok } */\n /* { dg-add-options arm_v8_3a_complex_neon } */\n@@ -304,3 +303,30 @@ test_vcmlaq_rot270_laneq_f16_2 (float16x8_t __r, float16x8_t __a, float16x8_t __\n /* { dg-final { scan-assembler-times {fcmla\\tv[0-9]+.8h, v[0-9]+.8h, v[0-9]+.h\\[3\\], #180} 1 { target { aarch64*-*-* } } } } */\n /* { dg-final { scan-assembler-times {fcmla\\tv[0-9]+.8h, v[0-9]+.8h, v[0-9]+.h\\[3\\], #270} 1 { target { aarch64*-*-* } } } } */\n /* { dg-final { scan-assembler-times {fcmla\\tv[0-9]+.8h, v[0-9]+.8h, v[0-9]+.h\\[3\\], #90} 1 { target { aarch64*-*-* } } } } */\n+\n+/* { dg-final { scan-assembler-times {vcadd.f16\\td[0-9]+, d[0-9]+, d[0-9]+, #90} 2 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcadd.f16\\tq[0-9]+, q[0-9]+, q[0-9]+, #90} 2 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\td[0-9]+, d[0-9]+, d[0-9]+, #0} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\td[0-9]+, d[0-9]+, d[0-9]+\\[0\\], #0} 3 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\td[0-9]+, d[0-9]+, d[0-9]+\\[0\\], #180} 3 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\td[0-9]+, d[0-9]+, d[0-9]+\\[0\\], #270} 3 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\td[0-9]+, d[0-9]+, d[0-9]+\\[0\\], #90} 3 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\td[0-9]+, d[0-9]+, d[0-9]+\\[1\\], #0} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\td[0-9]+, d[0-9]+, d[0-9]+\\[1\\], #180} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\td[0-9]+, d[0-9]+, d[0-9]+\\[1\\], #270} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\td[0-9]+, d[0-9]+, d[0-9]+, #180} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\td[0-9]+, d[0-9]+, d[0-9]+\\[1\\], #90} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\td[0-9]+, d[0-9]+, d[0-9]+, #270} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\td[0-9]+, d[0-9]+, d[0-9]+, #90} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\tq[0-9]+, q[0-9]+, d[0-9]+\\[0\\], #0} 3 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\tq[0-9]+, q[0-9]+, d[0-9]+\\[0\\], #180} 3 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\tq[0-9]+, q[0-9]+, d[0-9]+\\[0\\], #270} 3 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\tq[0-9]+, q[0-9]+, d[0-9]+\\[0\\], #90} 3 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\tq[0-9]+, q[0-9]+, d[0-9]+\\[1\\], #0} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\tq[0-9]+, q[0-9]+, d[0-9]+\\[1\\], #180} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\tq[0-9]+, q[0-9]+, d[0-9]+\\[1\\], #270} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\tq[0-9]+, q[0-9]+, d[0-9]+\\[1\\], #90} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\tq[0-9]+, q[0-9]+, q[0-9]+, #0} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\tq[0-9]+, q[0-9]+, q[0-9]+, #180} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\tq[0-9]+, q[0-9]+, q[0-9]+, #270} 1 { target { arm*-*-* } } } } */\n+/* { dg-final { scan-assembler-times {vcmla.f16\\tq[0-9]+, q[0-9]+, q[0-9]+, #90} 1 { target { arm*-*-* } } } } */"}]}