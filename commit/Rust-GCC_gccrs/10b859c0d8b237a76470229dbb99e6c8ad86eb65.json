{"sha": "10b859c0d8b237a76470229dbb99e6c8ad86eb65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBiODU5YzBkOGIyMzdhNzY0NzAyMjlkYmI5OWU2YzhhZDg2ZWI2NQ==", "commit": {"author": {"name": "David S. Miller", "email": "davem@davemloft.net", "date": "2011-09-25T02:29:23Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2011-09-25T02:29:23Z"}, "message": "Teach sparc backend about %gsr register and add intrinsics to access it.\n\n\t* config/sparc/sparc.h (FIRST_PSEUDO_REGISTER): Bump to 103.\n\t(SPARC_GSR_REG): Define.\n\t(FIXED_REGISTERS): Mark GSR as fixed.\n\t(CALL_USED_REGISTERS): Mark GSR as call used.\n\t(HARD_REGNO_NREGS): GSR is always 1 register.\n\t(REG_CLASS_CONTENTS): Add GSR to ALL_REGS.\n\t(REG_ALLOC_ORDER, REG_LEAF_ALLOC_ORDER): Add GSR to the end.\n\t(REGISTER_NAMES): Add \"%gsr\".\n\t* config/sparc/sparc.md (UNSPEC_ALIGNADDR, UNSPEC_ALIGNADDRL):\n\tDelete.\n\t(UNSPEC_WRGSR): New unspec.\n\t(GSR_REG): New constant.\n\t(type): Add new insn type 'gsr'.\n\t(fpack16_vis, fpackfix_vis, fpack32_vis,\n\tfaligndata<V64I:MODE>_vis)): Add use of GSR_REG.\n\t(wrgsr_vis, *wrgsr_sp64, wrgsr_v8plus, rdgsr_vis, *rdgsr_sp64,\n\trdgsr_v8plus): New expanders and insns.\n\t(alignaddr<P:mode>_vis, alignaddrl<P:mode>_vis): Reimplement\n\tusing patterns which show that this is a plus in addition to a\n\tmodification of GSR_REG, instead of an unspec.\n\t* config/sparc/ultra1_2.md: Handle 'gsr'.\n\t* config/sparc/ultra3.md: Likewise.\n\t* config/sparc/niagara.md: Likewise.\n\t* config/sparc/niagara2.md: Likewise.\n\t* config/sparc/sparc.c (leaf_reg_remap, sparc_leaf_regs): Fill out\n\tend of table.\n\t(sparc_option_override): Make -mvis imply -mv8plus.\n\t(hard_32bit_mode_classes, hard_64bit_mode_classes): Add entries\n\tfor %gsr.\n\t(sparc_vis_init_builtins): Build __builtin_vis_write_gsr and\n\t__builtin_vis_read_gsr.\n\t(sparc_expand_buildin): Handle builtins that take one argument and\n\treturn void.\n\t(sparc_fold_builtin): Never fold writes to %gsr.\n\t* config/sparc/visintrin.h (__vis_write_gsr, __vis_read_gsr): New.\n\t* doc/extend.texi: Document new VIS intrinsics.\n\nFrom-SVN: r179159", "tree": {"sha": "dd9eb1da76d09fd0f8a738298d21e8737262f1fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd9eb1da76d09fd0f8a738298d21e8737262f1fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10b859c0d8b237a76470229dbb99e6c8ad86eb65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b859c0d8b237a76470229dbb99e6c8ad86eb65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10b859c0d8b237a76470229dbb99e6c8ad86eb65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b859c0d8b237a76470229dbb99e6c8ad86eb65/comments", "author": {"login": "davem330", "id": 1053866, "node_id": "MDQ6VXNlcjEwNTM4NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1053866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davem330", "html_url": "https://github.com/davem330", "followers_url": "https://api.github.com/users/davem330/followers", "following_url": "https://api.github.com/users/davem330/following{/other_user}", "gists_url": "https://api.github.com/users/davem330/gists{/gist_id}", "starred_url": "https://api.github.com/users/davem330/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davem330/subscriptions", "organizations_url": "https://api.github.com/users/davem330/orgs", "repos_url": "https://api.github.com/users/davem330/repos", "events_url": "https://api.github.com/users/davem330/events{/privacy}", "received_events_url": "https://api.github.com/users/davem330/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6eaade31bbb647403677bc9c47ce8ee1dd67b514", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eaade31bbb647403677bc9c47ce8ee1dd67b514", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6eaade31bbb647403677bc9c47ce8ee1dd67b514"}], "stats": {"total": 294, "additions": 240, "deletions": 54}, "files": [{"sha": "d5d0a10f9b499c1fca709166ef83296a96e46936", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10b859c0d8b237a76470229dbb99e6c8ad86eb65", "patch": "@@ -1,3 +1,42 @@\n+2011-09-24  David S. Miller  <davem@davemloft.net>\n+\n+\t* config/sparc/sparc.h (FIRST_PSEUDO_REGISTER): Bump to 103.\n+\t(SPARC_GSR_REG): Define.\n+\t(FIXED_REGISTERS): Mark GSR as fixed.\n+\t(CALL_USED_REGISTERS): Mark GSR as call used.\n+\t(HARD_REGNO_NREGS): GSR is always 1 register.\n+\t(REG_CLASS_CONTENTS): Add GSR to ALL_REGS.\n+\t(REG_ALLOC_ORDER, REG_LEAF_ALLOC_ORDER): Add GSR to the end.\n+\t(REGISTER_NAMES): Add \"%gsr\".\n+\t* config/sparc/sparc.md (UNSPEC_ALIGNADDR, UNSPEC_ALIGNADDRL):\n+\tDelete.\n+\t(UNSPEC_WRGSR): New unspec.\n+\t(GSR_REG): New constant.\n+\t(type): Add new insn type 'gsr'.\n+\t(fpack16_vis, fpackfix_vis, fpack32_vis,\n+\tfaligndata<V64I:MODE>_vis)): Add use of GSR_REG.\n+\t(wrgsr_vis, *wrgsr_sp64, wrgsr_v8plus, rdgsr_vis, *rdgsr_sp64,\n+\trdgsr_v8plus): New expanders and insns.\n+\t(alignaddr<P:mode>_vis, alignaddrl<P:mode>_vis): Reimplement\n+\tusing patterns which show that this is a plus in addition to a\n+\tmodification of GSR_REG, instead of an unspec.\n+\t* config/sparc/ultra1_2.md: Handle 'gsr'.\n+\t* config/sparc/ultra3.md: Likewise.\n+\t* config/sparc/niagara.md: Likewise.\n+\t* config/sparc/niagara2.md: Likewise.\n+\t* config/sparc/sparc.c (leaf_reg_remap, sparc_leaf_regs): Fill out\n+\tend of table.\n+\t(sparc_option_override): Make -mvis imply -mv8plus.\n+\t(hard_32bit_mode_classes, hard_64bit_mode_classes): Add entries\n+\tfor %gsr.\n+\t(sparc_vis_init_builtins): Build __builtin_vis_write_gsr and\n+\t__builtin_vis_read_gsr.\n+\t(sparc_expand_buildin): Handle builtins that take one argument and\n+\treturn void.\n+\t(sparc_fold_builtin): Never fold writes to %gsr.\n+\t* config/sparc/visintrin.h (__vis_write_gsr, __vis_read_gsr): New.\n+\t* doc/extend.texi: Document new VIS intrinsics.\n+\n 2011-09-23  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-inline-transform.c (inline_call): Add comment."}, {"sha": "3e5a3e5b19275720494091e3ccd5273c48cc95b3", "filename": "gcc/config/sparc/niagara.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fconfig%2Fsparc%2Fniagara.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fconfig%2Fsparc%2Fniagara.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fniagara.md?ref=10b859c0d8b237a76470229dbb99e6c8ad86eb65", "patch": "@@ -114,5 +114,5 @@\n  */\n (define_insn_reservation \"niag_vis\" 8\n   (and (eq_attr \"cpu\" \"niagara\")\n-    (eq_attr \"type\" \"fga,fgm_pack,fgm_mul,fgm_cmp,fgm_pdist,edge\"))\n+    (eq_attr \"type\" \"fga,fgm_pack,fgm_mul,fgm_cmp,fgm_pdist,edge,gsr\"))\n   \"niag_pipe*8\")"}, {"sha": "9ea6b04450e3025e1901d84884b02bd6bf64991e", "filename": "gcc/config/sparc/niagara2.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fconfig%2Fsparc%2Fniagara2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fconfig%2Fsparc%2Fniagara2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fniagara2.md?ref=10b859c0d8b237a76470229dbb99e6c8ad86eb65", "patch": "@@ -111,10 +111,10 @@\n \n (define_insn_reservation \"niag2_vis\" 6\n   (and (eq_attr \"cpu\" \"niagara2\")\n-    (eq_attr \"type\" \"fga,fgm_pack,fgm_mul,fgm_cmp,fgm_pdist,edge\"))\n+    (eq_attr \"type\" \"fga,fgm_pack,fgm_mul,fgm_cmp,fgm_pdist,edge,gsr\"))\n   \"niag2_pipe*6\")\n \n (define_insn_reservation \"niag3_vis\" 9\n   (and (eq_attr \"cpu\" \"niagara3\")\n-    (eq_attr \"type\" \"fga,fgm_pack,fgm_mul,fgm_cmp,fgm_pdist,edge\"))\n+    (eq_attr \"type\" \"fga,fgm_pack,fgm_mul,fgm_cmp,fgm_pdist,edge,gsr\"))\n   \"niag2_pipe*9\")"}, {"sha": "d648e872027bf426f9d3852ef3e77fe18cc747fd", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 53, "deletions": 20, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=10b859c0d8b237a76470229dbb99e6c8ad86eb65", "patch": "@@ -329,7 +329,7 @@ char leaf_reg_remap[] =\n   72, 73, 74, 75, 76, 77, 78, 79,\n   80, 81, 82, 83, 84, 85, 86, 87,\n   88, 89, 90, 91, 92, 93, 94, 95,\n-  96, 97, 98, 99, 100};\n+  96, 97, 98, 99, 100, 101, 102};\n \n /* Vector, indexed by hard register number, which contains 1\n    for a register that is allowable in a candidate for leaf\n@@ -347,7 +347,7 @@ char sparc_leaf_regs[] =\n   1, 1, 1, 1, 1, 1, 1, 1,\n   1, 1, 1, 1, 1, 1, 1, 1,\n   1, 1, 1, 1, 1, 1, 1, 1,\n-  1, 1, 1, 1, 1};\n+  1, 1, 1, 1, 1, 1, 1};\n \n struct GTY(()) machine_function\n {\n@@ -870,6 +870,10 @@ sparc_option_override (void)\n       target_flags &= ~(MASK_V8 | MASK_SPARCLET | MASK_SPARCLITE);\n     }\n \n+  /* -mvis also implies -mv8plus on 32-bit */\n+  if (TARGET_VIS && ! TARGET_ARCH64)\n+    target_flags |= MASK_V8PLUS;\n+\n   /* Use the deprecated v8 insns for sparc64 in 32 bit mode.  */\n   if (TARGET_V9 && TARGET_ARCH32)\n     target_flags |= MASK_DEPRECATED_V8_INSNS;\n@@ -4036,8 +4040,8 @@ static const int hard_32bit_mode_classes[] = {\n   /* %fcc[0123] */\n   CCFP_MODES, CCFP_MODES, CCFP_MODES, CCFP_MODES,\n \n-  /* %icc */\n-  CC_MODES\n+  /* %icc, %sfp, %gsr */\n+  CC_MODES, 0, D_MODES\n };\n \n static const int hard_64bit_mode_classes[] = {\n@@ -4061,8 +4065,8 @@ static const int hard_64bit_mode_classes[] = {\n   /* %fcc[0123] */\n   CCFP_MODES, CCFP_MODES, CCFP_MODES, CCFP_MODES,\n \n-  /* %icc */\n-  CC_MODES\n+  /* %icc, %sfp, %gsr */\n+  CC_MODES, 0, D_MODES\n };\n \n int sparc_mode_class [NUM_MACHINE_MODES];\n@@ -9168,6 +9172,10 @@ sparc_vis_init_builtins (void)\n \t\t\t\t\t\t      v4hi, v4hi, 0);\n   tree si_ftype_v2si_v2si = build_function_type_list (intSI_type_node,\n \t\t\t\t\t\t      v2si, v2si, 0);\n+  tree void_ftype_di = build_function_type_list (void_type_node,\n+\t\t\t\t\t\t intDI_type_node, 0);\n+  tree di_ftype_void = build_function_type_list (intDI_type_node,\n+\t\t\t\t\t\t void_type_node, 0);\n \n   /* Packing and expanding vectors.  */\n   def_builtin (\"__builtin_vis_fpack16\", CODE_FOR_fpack16_vis,\n@@ -9206,6 +9214,12 @@ sparc_vis_init_builtins (void)\n \t       v2si_ftype_v2si_v2si);\n   def_builtin (\"__builtin_vis_faligndatadi\", CODE_FOR_faligndatadi_vis,\n \t       di_ftype_di_di);\n+\n+  def_builtin (\"__builtin_vis_write_gsr\", CODE_FOR_wrgsr_vis,\n+\t       void_ftype_di);\n+  def_builtin (\"__builtin_vis_read_gsr\", CODE_FOR_rdgsr_vis,\n+\t       di_ftype_void);\n+\n   if (TARGET_ARCH64)\n     {\n       def_builtin (\"__builtin_vis_alignaddr\", CODE_FOR_alignaddrdi_vis,\n@@ -9289,32 +9303,47 @@ sparc_expand_builtin (tree exp, rtx target,\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   unsigned int icode = DECL_FUNCTION_CODE (fndecl);\n   rtx pat, op[4];\n-  enum machine_mode mode[4];\n   int arg_count = 0;\n+  bool nonvoid;\n \n-  mode[0] = insn_data[icode].operand[0].mode;\n-  if (!target\n-      || GET_MODE (target) != mode[0]\n-      || ! (*insn_data[icode].operand[0].predicate) (target, mode[0]))\n-    op[0] = gen_reg_rtx (mode[0]);\n-  else\n-    op[0] = target;\n+  nonvoid = TREE_TYPE (TREE_TYPE (fndecl)) != void_type_node;\n \n+  if (nonvoid)\n+    {\n+      enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+      if (!target\n+\t  || GET_MODE (target) != tmode\n+\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+\top[0] = gen_reg_rtx (tmode);\n+      else\n+\top[0] = target;\n+    }\n   FOR_EACH_CALL_EXPR_ARG (arg, iter, exp)\n     {\n+      const struct insn_operand_data *insn_op;\n+\n+      if (arg == error_mark_node)\n+\treturn NULL_RTX;\n+\n       arg_count++;\n-      mode[arg_count] = insn_data[icode].operand[arg_count].mode;\n+      insn_op = &insn_data[icode].operand[arg_count - !nonvoid];\n       op[arg_count] = expand_normal (arg);\n \n       if (! (*insn_data[icode].operand[arg_count].predicate) (op[arg_count],\n-\t\t\t\t\t\t\t      mode[arg_count]))\n-\top[arg_count] = copy_to_mode_reg (mode[arg_count], op[arg_count]);\n+\t\t\t\t\t\t\t      insn_op->mode))\n+\top[arg_count] = copy_to_mode_reg (insn_op->mode, op[arg_count]);\n     }\n \n   switch (arg_count)\n     {\n+    case 0:\n+      pat = GEN_FCN (icode) (op[0]);\n+      break;\n     case 1:\n-      pat = GEN_FCN (icode) (op[0], op[1]);\n+      if (nonvoid)\n+\tpat = GEN_FCN (icode) (op[0], op[1]);\n+      else\n+\tpat = GEN_FCN (icode) (op[1]);\n       break;\n     case 2:\n       pat = GEN_FCN (icode) (op[0], op[1], op[2]);\n@@ -9331,7 +9360,10 @@ sparc_expand_builtin (tree exp, rtx target,\n \n   emit_insn (pat);\n \n-  return op[0];\n+  if (nonvoid)\n+    return op[0];\n+  else\n+    return const0_rtx;\n }\n \n static int\n@@ -9416,7 +9448,8 @@ sparc_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n \n   if (ignore\n       && icode != CODE_FOR_alignaddrsi_vis\n-      && icode != CODE_FOR_alignaddrdi_vis)\n+      && icode != CODE_FOR_alignaddrdi_vis\n+      && icode != CODE_FOR_wrgsr_vis)\n     return build_zero_cst (rtype);\n \n   switch (icode)"}, {"sha": "77eff2e6bbfea16ef01eb5036832572b1c3ad29d", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=10b859c0d8b237a76470229dbb99e6c8ad86eb65", "patch": "@@ -691,7 +691,7 @@ extern enum cmodel sparc_cmodel;\n    Register 100 is used as the integer condition code register.\n    Register 101 is used as the soft frame pointer register.  */\n \n-#define FIRST_PSEUDO_REGISTER 102\n+#define FIRST_PSEUDO_REGISTER 103\n \n #define SPARC_FIRST_FP_REG     32\n /* Additional V9 fp regs.  */\n@@ -704,6 +704,7 @@ extern enum cmodel sparc_cmodel;\n #define SPARC_FCC_REG 96\n /* Integer CC reg.  We don't distinguish %icc from %xcc.  */\n #define SPARC_ICC_REG 100\n+#define SPARC_GSR_REG 102\n \n /* Nonzero if REGNO is an fp reg.  */\n #define SPARC_FP_REG_P(REGNO) \\\n@@ -757,7 +758,7 @@ extern enum cmodel sparc_cmodel;\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n \t\t\t\t\\\n-  0, 0, 0, 0, 0, 1}\n+  0, 0, 0, 0, 0, 1, 1}\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -782,7 +783,7 @@ extern enum cmodel sparc_cmodel;\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n \t\t\t\t\\\n-  1, 1, 1, 1, 1, 1}\n+  1, 1, 1, 1, 1, 1, 1}\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n@@ -796,11 +797,12 @@ extern enum cmodel sparc_cmodel;\n    included in the hard register count).  */\n \n #define HARD_REGNO_NREGS(REGNO, MODE) \\\n-  (TARGET_ARCH64\t\t\t\t\t\t\t\\\n-   ? ((REGNO) < 32 || (REGNO) == FRAME_POINTER_REGNUM\t\t\t\\\n-      ? (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD\t\\\n-      : (GET_MODE_SIZE (MODE) + 3) / 4)\t\t\t\t\t\\\n-   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+  ((REGNO) == SPARC_GSR_REG ? 1 :\t\t\t\t\t\\\n+   (TARGET_ARCH64\t\t\t\t\t\t\t\\\n+    ? ((REGNO) < 32 || (REGNO) == FRAME_POINTER_REGNUM\t\t\t\\\n+       ? (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD\t\\\n+       : (GET_MODE_SIZE (MODE) + 3) / 4)\t\t\t\t\\\n+    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n \n /* Due to the ARCH64 discrepancy above we must override this next\n    macro too.  */\n@@ -985,7 +987,7 @@ enum reg_class { NO_REGS, FPCC_REGS, I64_REGS, GENERAL_REGS, FP_REGS,\n    {0, -1, -1, 0},\t/* EXTRA_FP_REGS */\t\t\\\n    {-1, -1, 0, 0x20},\t/* GENERAL_OR_FP_REGS */\t\\\n    {-1, -1, -1, 0x20},\t/* GENERAL_OR_EXTRA_FP_REGS */\t\\\n-   {-1, -1, -1, 0x3f}}\t/* ALL_REGS */\n+   {-1, -1, -1, 0x7f}}\t/* ALL_REGS */\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n@@ -1046,7 +1048,7 @@ extern enum reg_class sparc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n   88, 89, 90, 91, 92, 93, 94, 95,\t/* %f56-%f63 */ \\\n   39, 38, 37, 36, 35, 34, 33, 32,\t/* %f7-%f0 */   \\\n   96, 97, 98, 99,\t\t\t/* %fcc0-3 */   \\\n-  100, 0, 14, 30, 101}\t\t\t/* %icc, %g0, %o6, %i6, %sfp */\n+  100, 0, 14, 30, 101, 102 }\t\t/* %icc, %g0, %o6, %i6, %sfp, %gsr */\n \n /* This is the order in which to allocate registers for\n    leaf functions.  If all registers can fit in the global and\n@@ -1085,7 +1087,7 @@ extern enum reg_class sparc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n   88, 89, 90, 91, 92, 93, 94, 95,\t/* %f56-%f63 */\t\\\n   39, 38, 37, 36, 35, 34, 33, 32,\t/* %f7-%f0 */\t\\\n   96, 97, 98, 99,\t\t\t/* %fcc0-3 */\t\\\n-  100, 0, 14, 30, 31, 101}\t\t/* %icc, %g0, %o6, %i6, %i7, %sfp */\n+  100, 0, 14, 30, 31, 101, 102 }\t/* %icc, %g0, %o6, %i6, %i7, %sfp, %gsr */\n \n #define ADJUST_REG_ALLOC_ORDER order_regs_for_local_alloc ()\n \n@@ -1724,7 +1726,7 @@ do {\t\t\t\t\t\t\t\t\t   \\\n  \"%f40\", \"%f41\", \"%f42\", \"%f43\", \"%f44\", \"%f45\", \"%f46\", \"%f47\",\t\\\n  \"%f48\", \"%f49\", \"%f50\", \"%f51\", \"%f52\", \"%f53\", \"%f54\", \"%f55\",\t\\\n  \"%f56\", \"%f57\", \"%f58\", \"%f59\", \"%f60\", \"%f61\", \"%f62\", \"%f63\",\t\\\n- \"%fcc0\", \"%fcc1\", \"%fcc2\", \"%fcc3\", \"%icc\", \"%sfp\" }\n+ \"%fcc0\", \"%fcc1\", \"%fcc2\", \"%fcc3\", \"%icc\", \"%sfp\", \"%gsr\" }\n \n /* Define additional names for use in asm clobbers and asm declarations.  */\n "}, {"sha": "e5cf82155339ef1c43c1e1ccec348d805a5c059d", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 112, "deletions": 17, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=10b859c0d8b237a76470229dbb99e6c8ad86eb65", "patch": "@@ -58,15 +58,14 @@\n    (UNSPEC_MUL8UL\t\t46)\n    (UNSPEC_MULDUL\t\t47)\n    (UNSPEC_ALIGNDATA\t\t48)\n-   (UNSPEC_ALIGNADDR\t\t49)\n+   (UNSPEC_WRGSR                49)\n    (UNSPEC_PDIST\t\t50)\n    (UNSPEC_EDGE8\t\t51)\n    (UNSPEC_EDGE8L\t\t52)\n    (UNSPEC_EDGE16\t\t53)\n    (UNSPEC_EDGE16L\t\t54)\n    (UNSPEC_EDGE32\t\t55)\n    (UNSPEC_EDGE32L\t\t56)\n-   (UNSPEC_ALIGNADDRL\t\t57)\n \n    (UNSPEC_SP_SET\t\t60)\n    (UNSPEC_SP_TEST\t\t61)\n@@ -176,6 +175,7 @@\n   (FCC3_REG\t\t\t99)\n   (CC_REG\t\t\t100)\n   (SFP_REG\t\t\t101)\n+  (GSR_REG\t\t\t102)\n  ])\n \n (define_mode_iterator P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n@@ -242,7 +242,7 @@\n    fpcmp,\n    fpmul,fpdivs,fpdivd,\n    fpsqrts,fpsqrtd,\n-   fga,fgm_pack,fgm_mul,fgm_pdist,fgm_cmp,edge,\n+   fga,fgm_pack,fgm_mul,fgm_pdist,fgm_cmp,edge,gsr,\n    cmove,\n    ialuX,\n    multi,savew,flushw,iflush,trap\"\n@@ -7752,7 +7752,8 @@\n (define_insn \"fpack16_vis\"\n   [(set (match_operand:V4QI 0 \"register_operand\" \"=f\")\n         (unspec:V4QI [(match_operand:V4HI 1 \"register_operand\" \"e\")]\n-\t\t      UNSPEC_FPACK16))]\n+\t\t      UNSPEC_FPACK16))\n+   (use (reg:DI GSR_REG))]\n   \"TARGET_VIS\"\n   \"fpack16\\t%1, %0\"\n   [(set_attr \"type\" \"fga\")\n@@ -7761,7 +7762,8 @@\n (define_insn \"fpackfix_vis\"\n   [(set (match_operand:V2HI 0 \"register_operand\" \"=f\")\n         (unspec:V2HI [(match_operand:V2SI 1 \"register_operand\" \"e\")]\n-\t\t      UNSPEC_FPACKFIX))]\n+\t\t      UNSPEC_FPACKFIX))\n+   (use (reg:DI GSR_REG))]\n   \"TARGET_VIS\"\n   \"fpackfix\\t%1, %0\"\n   [(set_attr \"type\" \"fga\")\n@@ -7771,7 +7773,8 @@\n   [(set (match_operand:V8QI 0 \"register_operand\" \"=e\")\n         (unspec:V8QI [(match_operand:V2SI 1 \"register_operand\" \"e\")\n         \t      (match_operand:V8QI 2 \"register_operand\" \"e\")]\n-                     UNSPEC_FPACK32))]\n+                     UNSPEC_FPACK32))\n+   (use (reg:DI GSR_REG))]\n   \"TARGET_VIS\"\n   \"fpack32\\t%1, %2, %0\"\n   [(set_attr \"type\" \"fga\")\n@@ -7871,32 +7874,124 @@\n   [(set_attr \"type\" \"fpmul\")\n    (set_attr \"fptype\" \"double\")])\n \n+(define_expand \"wrgsr_vis\"\n+  [(set (reg:DI GSR_REG) (unspec:DI [(match_operand:DI 0 \"arith_operand\" \"\")]\n+                                    UNSPEC_WRGSR))]\n+  \"TARGET_VIS\"\n+{\n+  if (! TARGET_ARCH64)\n+    {\n+      emit_insn (gen_wrgsr_v8plus (operands[0]));\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"*wrgsr_sp64\"\n+  [(set (reg:DI GSR_REG) (unspec:DI [(match_operand:DI 0 \"arith_operand\" \"rI\")]\n+                                    UNSPEC_WRGSR))]\n+  \"TARGET_VIS && TARGET_ARCH64\"\n+  \"wr\\t%%g0, %0, %%gsr\"\n+  [(set_attr \"type\" \"gsr\")])\n+\n+(define_insn \"wrgsr_v8plus\"\n+  [(set (reg:DI GSR_REG) (unspec:DI [(match_operand:DI 0 \"arith_operand\" \"I,r\")]\n+                                    UNSPEC_WRGSR))\n+   (clobber (match_scratch:SI 1 \"=X,&h\"))]\n+  \"TARGET_VIS && ! TARGET_ARCH64\"\n+{\n+  if (GET_CODE (operands[0]) == CONST_INT\n+      || sparc_check_64 (operands[0], insn))\n+    return \"wr\\t%%g0, %0, %%gsr\";\n+\n+  output_asm_insn(\"srl\\t%L0, 0, %L0\", operands);\n+  return \"sllx\\t%H0, 32, %1\\n\\tor\\t%L0, %1, %1\\n\\twr\\t%%g0, %1, %%gsr\";\n+}\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_expand \"rdgsr_vis\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\") (reg:DI GSR_REG))]\n+  \"TARGET_VIS\"\n+{\n+  if (! TARGET_ARCH64)\n+    {\n+      emit_insn (gen_rdgsr_v8plus (operands[0]));\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"*rdgsr_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\") (reg:DI GSR_REG))]\n+  \"TARGET_VIS && TARGET_ARCH64\"\n+  \"rd\\t%%gsr, %0\"\n+  [(set_attr \"type\" \"gsr\")])\n+\n+(define_insn \"rdgsr_v8plus\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\") (reg:DI GSR_REG))\n+   (clobber (match_scratch:SI 1 \"=&h\"))]\n+  \"TARGET_VIS && ! TARGET_ARCH64\"\n+{\n+  return \"rd\\t%%gsr, %1\\n\\tsrlx\\t%1, 32, %H0\\n\\tmov %1, %L0\";\n+}\n+  [(set_attr \"type\" \"multi\")])\n+\n ;; Using faligndata only makes sense after an alignaddr since the choice of\n ;; bytes to take out of each operand is dependent on the results of the last\n ;; alignaddr.\n (define_insn \"faligndata<V64I:mode>_vis\"\n   [(set (match_operand:V64I 0 \"register_operand\" \"=e\")\n         (unspec:V64I [(match_operand:V64I 1 \"register_operand\" \"e\")\n                       (match_operand:V64I 2 \"register_operand\" \"e\")]\n-         UNSPEC_ALIGNDATA))]\n+         UNSPEC_ALIGNDATA))\n+   (use (reg:SI GSR_REG))]\n   \"TARGET_VIS\"\n   \"faligndata\\t%1, %2, %0\"\n   [(set_attr \"type\" \"fga\")\n    (set_attr \"fptype\" \"double\")])\n \n-(define_insn \"alignaddr<P:mode>_vis\"\n-  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n-        (unspec:P [(match_operand:P 1 \"register_or_zero_operand\" \"rJ\")\n-                   (match_operand:P 2 \"register_or_zero_operand\" \"rJ\")]\n-         UNSPEC_ALIGNADDR))]\n+(define_insn \"alignaddrsi_vis\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (plus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n+                 (match_operand:SI 2 \"register_or_zero_operand\" \"rJ\")))\n+   (set (reg:SI GSR_REG)\n+        (ior:SI (and:SI (reg:SI GSR_REG) (const_int -8))\n+                (and:SI (plus:SI (match_dup 1) (match_dup 2))\n+                        (const_int 7))))]\n   \"TARGET_VIS\"\n   \"alignaddr\\t%r1, %r2, %0\")\n \n-(define_insn \"alignaddrl<P:mode>_vis\"\n-  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n-        (unspec:P [(match_operand:P 1 \"register_or_zero_operand\" \"rJ\")\n-                   (match_operand:P 2 \"register_or_zero_operand\" \"rJ\")]\n-         UNSPEC_ALIGNADDRL))]\n+(define_insn \"alignaddrdi_vis\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (plus:DI (match_operand:DI 1 \"register_or_zero_operand\" \"rJ\")\n+                 (match_operand:DI 2 \"register_or_zero_operand\" \"rJ\")))\n+   (set (reg:SI GSR_REG)\n+        (ior:SI (and:SI (reg:SI GSR_REG) (const_int -8))\n+                (and:SI (truncate:SI (plus:DI (match_dup 1) (match_dup 2)))\n+                        (const_int 7))))]\n+  \"TARGET_VIS\"\n+  \"alignaddr\\t%r1, %r2, %0\")\n+\n+(define_insn \"alignaddrlsi_vis\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (plus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n+                 (match_operand:SI 2 \"register_or_zero_operand\" \"rJ\")))\n+   (set (reg:SI GSR_REG)\n+        (ior:SI (and:SI (reg:SI GSR_REG) (const_int -8))\n+                (xor:SI (and:SI (plus:SI (match_dup 1) (match_dup 2))\n+                                (const_int 7))\n+                        (const_int 7))))]\n+  \"TARGET_VIS\"\n+  \"alignaddrl\\t%r1, %r2, %0\")\n+\n+(define_insn \"alignaddrldi_vis\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (plus:DI (match_operand:DI 1 \"register_or_zero_operand\" \"rJ\")\n+                 (match_operand:DI 2 \"register_or_zero_operand\" \"rJ\")))\n+   (set (reg:SI GSR_REG)\n+        (ior:SI (and:SI (reg:SI GSR_REG) (const_int -8))\n+                (xor:SI (and:SI (truncate:SI (plus:DI (match_dup 1)\n+                                                      (match_dup 2)))\n+                                (const_int 7))\n+                        (const_int 7))))]\n   \"TARGET_VIS\"\n   \"alignaddrl\\t%r1, %r2, %0\")\n "}, {"sha": "7f6e8b643643d112d511035c687c84f14baa7d8b", "filename": "gcc/config/sparc/ultra1_2.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fconfig%2Fsparc%2Fultra1_2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fconfig%2Fsparc%2Fultra1_2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fultra1_2.md?ref=10b859c0d8b237a76470229dbb99e6c8ad86eb65", "patch": "@@ -79,7 +79,7 @@\n \n (define_insn_reservation \"us1_single\" 1\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"multi,savew,flushw,iflush,trap\"))\n+    (eq_attr \"type\" \"multi,savew,flushw,iflush,trap,gsr\"))\n   \"us1_single_issue\")\n \n (define_insn_reservation \"us1_simple_ieuN\" 1"}, {"sha": "ac9709997286a9b22eea7ad8bd737c6340964989", "filename": "gcc/config/sparc/ultra3.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fconfig%2Fsparc%2Fultra3.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fconfig%2Fsparc%2Fultra3.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fultra3.md?ref=10b859c0d8b237a76470229dbb99e6c8ad86eb65", "patch": "@@ -36,7 +36,7 @@\n \n (define_insn_reservation \"us3_single\" 1\n   (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"multi,savew,flushw,iflush,trap,edge\"))\n+    (eq_attr \"type\" \"multi,savew,flushw,iflush,trap,edge,gsr\"))\n   \"us3_single_issue\")\n \n (define_insn_reservation \"us3_integer\" 1"}, {"sha": "e3a58180fe2b02080c81ea1b5a1c6711401ec0f7", "filename": "gcc/config/sparc/visintrin.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fconfig%2Fsparc%2Fvisintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fconfig%2Fsparc%2Fvisintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fvisintrin.h?ref=10b859c0d8b237a76470229dbb99e6c8ad86eb65", "patch": "@@ -31,6 +31,20 @@ typedef unsigned char __v8qi __attribute__ ((__vector_size__ (8)));\n typedef unsigned char __v4qi __attribute__ ((__vector_size__ (4)));\n typedef int __i64 __attribute__ ((__mode__ (DI)));\n \n+extern __inline void\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_write_gsr (__i64 __A)\n+{\n+  __builtin_vis_write_gsr (__A);\n+}\n+\n+extern __inline __i64\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_read_gsr (void)\n+{\n+  return __builtin_vis_read_gsr ();\n+}\n+\n extern __inline void *\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n __vis_alignaddr (void *__A, long __B)"}, {"sha": "d5106aaeee85467bd39889d5e817913ebe17437a", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b859c0d8b237a76470229dbb99e6c8ad86eb65/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=10b859c0d8b237a76470229dbb99e6c8ad86eb65", "patch": "@@ -12935,6 +12935,9 @@ typedef short v2hi __attribute__ ((vector_size (4)));\n typedef unsigned char v8qi __attribute__ ((vector_size (8)));\n typedef unsigned char v4qi __attribute__ ((vector_size (4)));\n \n+void __builtin_vis_write_gsr (int64_t);\n+int64_t __builtin_vis_read_gsr (void);\n+\n void * __builtin_vis_alignaddr (void *, long);\n void * __builtin_vis_alignaddrl (void *, long);\n int64_t __builtin_vis_faligndatadi (int64_t, int64_t);"}]}