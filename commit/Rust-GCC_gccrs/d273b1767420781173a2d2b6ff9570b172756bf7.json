{"sha": "d273b1767420781173a2d2b6ff9570b172756bf7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI3M2IxNzY3NDIwNzgxMTczYTJkMmI2ZmY5NTcwYjE3Mjc1NmJmNw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-03-05T14:45:23Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-03-05T14:45:23Z"}, "message": "re PR c++/55135 (Segfault of gcc on a big file)\n\ngcc/\n\tPR c++/55135\n\t* except.h (remove_unreachable_eh_regions): New prototype.\n\t* except.c (remove_eh_handler_splicer): New function, split out\n\tof remove_eh_handler.\n\t(remove_eh_handler): Use remove_eh_handler_splicer.  Add comment\n\twarning about running it on many EH regions one at a time.\n\t(remove_unreachable_eh_regions_worker): New function, walk the\n\tEH tree in depth-first order and remove non-marked regions.\n\t(remove_unreachable_eh_regions): New function.\n\t* tree-eh.c (mark_reachable_handlers): New function, split out\n\tfrom remove_unreachable_handlers.\n\t(remove_unreachable_handlers): Use mark_reachable_handlers and\n\tremove_unreachable_eh_regions.\n\t(remove_unreachable_handlers_no_lp): Use mark_reachable_handlers\n\tand remove_unreachable_eh_regions.\n\nFrom-SVN: r196464", "tree": {"sha": "4ff07f0d40ea5cef8af4fe46b0f91b0ca63c916a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ff07f0d40ea5cef8af4fe46b0f91b0ca63c916a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d273b1767420781173a2d2b6ff9570b172756bf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d273b1767420781173a2d2b6ff9570b172756bf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d273b1767420781173a2d2b6ff9570b172756bf7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d273b1767420781173a2d2b6ff9570b172756bf7/comments", "author": null, "committer": null, "parents": [{"sha": "574f9d7ecdea31bb7c611ae6d99efef10fb8cd0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/574f9d7ecdea31bb7c611ae6d99efef10fb8cd0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/574f9d7ecdea31bb7c611ae6d99efef10fb8cd0a"}], "stats": {"total": 246, "additions": 171, "deletions": 75}, "files": [{"sha": "dbef6b39da225a43d6b9ade767d237d89badd6a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d273b1767420781173a2d2b6ff9570b172756bf7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d273b1767420781173a2d2b6ff9570b172756bf7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d273b1767420781173a2d2b6ff9570b172756bf7", "patch": "@@ -1,3 +1,21 @@\n+2013-03-05  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\tPR c++/55135\n+\t* except.h (remove_unreachable_eh_regions): New prototype.\n+\t* except.c (remove_eh_handler_splicer): New function, split out\n+\tof remove_eh_handler.\n+\t(remove_eh_handler): Use remove_eh_handler_splicer.  Add comment\n+\twarning about running it on many EH regions one at a time.\n+\t(remove_unreachable_eh_regions_worker): New function, walk the\n+\tEH tree in depth-first order and remove non-marked regions.\n+\t(remove_unreachable_eh_regions): New function.\n+\t* tree-eh.c (mark_reachable_handlers): New function, split out\n+\tfrom remove_unreachable_handlers.\n+\t(remove_unreachable_handlers): Use mark_reachable_handlers and\n+\tremove_unreachable_eh_regions.\n+\t(remove_unreachable_handlers_no_lp): Use mark_reachable_handlers\n+\tand remove_unreachable_eh_regions.\n+\n 2013-03-05  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/56525"}, {"sha": "4e85f73183724c833cb4a5b994f19d0b91aa5087", "filename": "gcc/except.c", "status": "modified", "additions": 60, "deletions": 11, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d273b1767420781173a2d2b6ff9570b172756bf7/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d273b1767420781173a2d2b6ff9570b172756bf7/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=d273b1767420781173a2d2b6ff9570b172756bf7", "patch": "@@ -1505,12 +1505,12 @@ remove_eh_landing_pad (eh_landing_pad lp)\n   (*cfun->eh->lp_array)[lp->index] = NULL;\n }\n \n-/* Splice REGION from the region tree.  */\n+/* Splice the EH region at PP from the region tree.  */\n \n-void\n-remove_eh_handler (eh_region region)\n+static void\n+remove_eh_handler_splicer (eh_region *pp)\n {\n-  eh_region *pp, *pp_start, p, outer;\n+  eh_region region = *pp;\n   eh_landing_pad lp;\n \n   for (lp = region->landing_pads; lp ; lp = lp->next_lp)\n@@ -1520,15 +1520,11 @@ remove_eh_handler (eh_region region)\n       (*cfun->eh->lp_array)[lp->index] = NULL;\n     }\n \n-  outer = region->outer;\n-  if (outer)\n-    pp_start = &outer->inner;\n-  else\n-    pp_start = &cfun->eh->region_tree;\n-  for (pp = pp_start, p = *pp; p != region; pp = &p->next_peer, p = *pp)\n-    continue;\n   if (region->inner)\n     {\n+      eh_region p, outer;\n+      outer = region->outer;\n+\n       *pp = p = region->inner;\n       do\n \t{\n@@ -1543,6 +1539,59 @@ remove_eh_handler (eh_region region)\n   (*cfun->eh->region_array)[region->index] = NULL;\n }\n \n+/* Splice a single EH region REGION from the region tree.\n+\n+   To unlink REGION, we need to find the pointer to it with a relatively\n+   expensive search in REGION's outer region.  If you are going to\n+   remove a number of handlers, using remove_unreachable_eh_regions may\n+   be a better option.  */\n+\n+void\n+remove_eh_handler (eh_region region)\n+{\n+  eh_region *pp, *pp_start, p, outer;\n+\n+  outer = region->outer;\n+  if (outer)\n+    pp_start = &outer->inner;\n+  else\n+    pp_start = &cfun->eh->region_tree;\n+  for (pp = pp_start, p = *pp; p != region; pp = &p->next_peer, p = *pp)\n+    continue;\n+\n+  remove_eh_handler_splicer (pp);\n+}\n+\n+/* Worker for remove_unreachable_eh_regions.\n+   PP is a pointer to the region to start a region tree depth-first\n+   search from.  R_REACHABLE is the set of regions that have to be\n+   preserved.  */\n+\n+static void\n+remove_unreachable_eh_regions_worker (eh_region *pp, sbitmap r_reachable)\n+{\n+  while (*pp)\n+    {\n+      eh_region region = *pp;\n+      remove_unreachable_eh_regions_worker (&region->inner, r_reachable);\n+      if (!bitmap_bit_p (r_reachable, region->index))\n+\tremove_eh_handler_splicer (pp);\n+      else\n+\tpp = &region->next_peer;\n+    }\n+}\n+\n+/* Splice all EH regions *not* marked in R_REACHABLE from the region tree.\n+   Do this by traversing the EH tree top-down and splice out regions that\n+   are not marked.  By removing regions from the leaves, we avoid costly\n+   searches in the region tree.  */\n+\n+void\n+remove_unreachable_eh_regions (sbitmap r_reachable)\n+{\n+  remove_unreachable_eh_regions_worker (&cfun->eh->region_tree, r_reachable);\n+}\n+\n /* Invokes CALLBACK for every exception handler landing pad label.\n    Only used by reload hackery; should not be used by new code.  */\n "}, {"sha": "bc9654a7ae45ac95e8e8d307f18abb5c57cc7a7a", "filename": "gcc/except.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d273b1767420781173a2d2b6ff9570b172756bf7/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d273b1767420781173a2d2b6ff9570b172756bf7/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=d273b1767420781173a2d2b6ff9570b172756bf7", "patch": "@@ -229,6 +229,7 @@ extern void init_eh_for_function (void);\n \n extern void remove_eh_landing_pad (eh_landing_pad);\n extern void remove_eh_handler (eh_region);\n+extern void remove_unreachable_eh_regions (sbitmap);\n \n extern bool current_function_has_exception_handlers (void);\n extern void output_function_exception_table (const char *);"}, {"sha": "6b9dac9258e229f81fa8a5d3f44ce72ad95836de", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 92, "deletions": 64, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d273b1767420781173a2d2b6ff9570b172756bf7/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d273b1767420781173a2d2b6ff9570b172756bf7/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=d273b1767420781173a2d2b6ff9570b172756bf7", "patch": "@@ -3519,22 +3519,37 @@ struct gimple_opt_pass pass_lower_eh_dispatch =\n  }\n };\n \f\n-/* Walk statements, see what regions are really referenced and remove\n-   those that are unused.  */\n+/* Walk statements, see what regions and, optionally, landing pads\n+   are really referenced.\n+   \n+   Returns in R_REACHABLEP an sbitmap with bits set for reachable regions,\n+   and in LP_REACHABLE an sbitmap with bits set for reachable landing pads.\n+\n+   Passing NULL for LP_REACHABLE is valid, in this case only reachable\n+   regions are marked.\n+\n+   The caller is responsible for freeing the returned sbitmaps.  */\n \n static void\n-remove_unreachable_handlers (void)\n+mark_reachable_handlers (sbitmap *r_reachablep, sbitmap *lp_reachablep)\n {\n   sbitmap r_reachable, lp_reachable;\n-  eh_region region;\n-  eh_landing_pad lp;\n   basic_block bb;\n-  int lp_nr, r_nr;\n+  bool mark_landing_pads = (lp_reachablep != NULL);\n+  gcc_checking_assert (r_reachablep != NULL);\n \n   r_reachable = sbitmap_alloc (cfun->eh->region_array->length ());\n-  lp_reachable = sbitmap_alloc (cfun->eh->lp_array->length ());\n   bitmap_clear (r_reachable);\n-  bitmap_clear (lp_reachable);\n+  *r_reachablep = r_reachable;\n+\n+  if (mark_landing_pads)\n+    {\n+      lp_reachable = sbitmap_alloc (cfun->eh->lp_array->length ());\n+      bitmap_clear (lp_reachable);\n+      *lp_reachablep = lp_reachable;\n+    }\n+  else\n+    lp_reachable = NULL;\n \n   FOR_EACH_BB (bb)\n     {\n@@ -3543,20 +3558,24 @@ remove_unreachable_handlers (void)\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n-\t  lp_nr = lookup_stmt_eh_lp (stmt);\n \n-\t  /* Negative LP numbers are MUST_NOT_THROW regions which\n-\t     are not considered BB enders.  */\n-\t  if (lp_nr < 0)\n-\t    bitmap_set_bit (r_reachable, -lp_nr);\n-\n-\t  /* Positive LP numbers are real landing pads, are are BB enders.  */\n-\t  else if (lp_nr > 0)\n+\t  if (mark_landing_pads)\n \t    {\n-\t      gcc_assert (gsi_one_before_end_p (gsi));\n-\t      region = get_eh_region_from_lp_number (lp_nr);\n-\t      bitmap_set_bit (r_reachable, region->index);\n-\t      bitmap_set_bit (lp_reachable, lp_nr);\n+\t      int lp_nr = lookup_stmt_eh_lp (stmt);\n+\n+\t      /* Negative LP numbers are MUST_NOT_THROW regions which\n+\t\t are not considered BB enders.  */\n+\t      if (lp_nr < 0)\n+\t\tbitmap_set_bit (r_reachable, -lp_nr);\n+\n+\t      /* Positive LP numbers are real landing pads, and BB enders.  */\n+\t      else if (lp_nr > 0)\n+\t\t{\n+\t\t  gcc_assert (gsi_one_before_end_p (gsi));\n+\t\t  eh_region region = get_eh_region_from_lp_number (lp_nr);\n+\t\t  bitmap_set_bit (r_reachable, region->index);\n+\t\t  bitmap_set_bit (lp_reachable, lp_nr);\n+\t\t}\n \t    }\n \n \t  /* Avoid removing regions referenced from RESX/EH_DISPATCH.  */\n@@ -3573,6 +3592,19 @@ remove_unreachable_handlers (void)\n \t    }\n \t}\n     }\n+}\n+\n+/* Remove unreachable handlers and unreachable landing pads.  */\n+\n+static void\n+remove_unreachable_handlers (void)\n+{\n+  sbitmap r_reachable, lp_reachable;\n+  eh_region region;\n+  eh_landing_pad lp;\n+  unsigned i;\n+\n+  mark_reachable_handlers (&r_reachable, &lp_reachable);\n \n   if (dump_file)\n     {\n@@ -3584,21 +3616,24 @@ remove_unreachable_handlers (void)\n       dump_bitmap_file (dump_file, lp_reachable);\n     }\n \n-  for (r_nr = 1;\n-       vec_safe_iterate (cfun->eh->region_array, r_nr, &region); ++r_nr)\n-    if (region && !bitmap_bit_p (r_reachable, r_nr))\n-      {\n-\tif (dump_file)\n-\t  fprintf (dump_file, \"Removing unreachable region %d\\n\", r_nr);\n-\tremove_eh_handler (region);\n-      }\n+  if (dump_file)\n+    {\n+      FOR_EACH_VEC_SAFE_ELT (cfun->eh->region_array, i, region)\n+\tif (region && !bitmap_bit_p (r_reachable, region->index))\n+\t  fprintf (dump_file,\n+\t\t   \"Removing unreachable region %d\\n\",\n+\t\t   region->index);\n+    }\n+\n+  remove_unreachable_eh_regions (r_reachable);\n \n-  for (lp_nr = 1;\n-       vec_safe_iterate (cfun->eh->lp_array, lp_nr, &lp); ++lp_nr)\n-    if (lp && !bitmap_bit_p (lp_reachable, lp_nr))\n+  FOR_EACH_VEC_SAFE_ELT (cfun->eh->lp_array, i, lp)\n+    if (lp && !bitmap_bit_p (lp_reachable, lp->index))\n       {\n \tif (dump_file)\n-\t  fprintf (dump_file, \"Removing unreachable landing pad %d\\n\", lp_nr);\n+\t  fprintf (dump_file,\n+\t\t   \"Removing unreachable landing pad %d\\n\",\n+\t\t   lp->index);\n \tremove_eh_landing_pad (lp);\n       }\n \n@@ -3624,12 +3659,12 @@ void\n maybe_remove_unreachable_handlers (void)\n {\n   eh_landing_pad lp;\n-  int i;\n+  unsigned i;\n \n   if (cfun->eh == NULL)\n     return;\n-              \n-  for (i = 1; vec_safe_iterate (cfun->eh->lp_array, i, &lp); ++i)\n+           \n+  FOR_EACH_VEC_SAFE_ELT (cfun->eh->lp_array, i, lp)\n     if (lp && lp->post_landing_pad)\n       {\n \tif (label_to_block (lp->post_landing_pad) == NULL)\n@@ -3642,45 +3677,38 @@ maybe_remove_unreachable_handlers (void)\n \n /* Remove regions that do not have landing pads.  This assumes\n    that remove_unreachable_handlers has already been run, and\n-   that we've just manipulated the landing pads since then.  */\n+   that we've just manipulated the landing pads since then.\n+\n+   Preserve regions with landing pads and regions that prevent\n+   exceptions from propagating further, even if these regions\n+   are not reachable.  */\n \n static void\n remove_unreachable_handlers_no_lp (void)\n {\n-  eh_region r;\n-  int i;\n+  eh_region region;\n   sbitmap r_reachable;\n-  basic_block bb;\n+  unsigned i;\n \n-  r_reachable = sbitmap_alloc (cfun->eh->region_array->length ());\n-  bitmap_clear (r_reachable);\n+  mark_reachable_handlers (&r_reachable, /*lp_reachablep=*/NULL);\n \n-  FOR_EACH_BB (bb)\n+  FOR_EACH_VEC_SAFE_ELT (cfun->eh->region_array, i, region)\n     {\n-      gimple stmt = last_stmt (bb);\n-      if (stmt)\n-\t/* Avoid removing regions referenced from RESX/EH_DISPATCH.  */\n-\tswitch (gimple_code (stmt))\n-\t  {\n-\t  case GIMPLE_RESX:\n-\t    bitmap_set_bit (r_reachable, gimple_resx_region (stmt));\n-\t    break;\n-\t  case GIMPLE_EH_DISPATCH:\n-\t    bitmap_set_bit (r_reachable, gimple_eh_dispatch_region (stmt));\n-\t    break;\n-\t  default:\n-\t    break;\n-\t  }\n+      if (! region)\n+\tcontinue;\n+\n+      if (region->landing_pads != NULL\n+\t  || region->type == ERT_MUST_NOT_THROW)\n+\tbitmap_set_bit (r_reachable, region->index);\n+\n+      if (dump_file\n+\t  && !bitmap_bit_p (r_reachable, region->index))\n+\tfprintf (dump_file,\n+\t\t \"Removing unreachable region %d\\n\",\n+\t\t region->index);\n     }\n \n-  for (i = 1; cfun->eh->region_array->iterate (i, &r); ++i)\n-    if (r && r->landing_pads == NULL && r->type != ERT_MUST_NOT_THROW\n-\t&& !bitmap_bit_p (r_reachable, i))\n-      {\n-\tif (dump_file)\n-\t  fprintf (dump_file, \"Removing unreachable region %d\\n\", i);\n-\tremove_eh_handler (r);\n-      }\n+  remove_unreachable_eh_regions (r_reachable);\n \n   sbitmap_free (r_reachable);\n }"}]}