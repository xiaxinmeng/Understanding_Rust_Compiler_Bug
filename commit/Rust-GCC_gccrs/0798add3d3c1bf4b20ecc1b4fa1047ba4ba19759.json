{"sha": "0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc5OGFkZDNkM2MxYmY0YjIwZWNjMWI0ZmExMDQ3YmE0YmExOTc1OQ==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-09-04T23:29:33Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-09-04T23:42:24Z"}, "message": "Support Generic Traits in qualified paths\n\nThis extends the ProjectionType which represents an implemented associated\ntype with its own substitution mappings. The problem is a TypePath to a\ntrait does not represent a single TyTy primitive type, the type system\nhandles generics in an interesting way. Take for instance the case of a\ngeneric impl block:\n\n  impl<T> Foo<T> {\n    fn Bar<Y>(self, a:T, b:Y) {}\n  }\n\nThe compiler treats an impl block as the parent so that all items inherit\nfrom this, which is why rustc calls these inherent-impl-blocks. So\nin order to handle generic arguments we need to \"bind\" them, and in rust\nonly some types actually support generic argument binding, at the moment\nfor gccrs it is, ADTTypes, FnTypes and Projections. Going back to the\nexample the TyTy for this function turns into:\n\n  fn Bar<T,Y>(Foo<T>, T, Y)\n\nSo when it comes to the generic traits its a similar process but the\ndifference is that traits contain associated types, these must be able\nto bind the generic arguments such that we can substitute any covariant\ntypes fully. But there is a layer of complexity and indirection here\nconsider the following example:\n\n  trait Foo<T> {\n      type A;\n\n      fn test(a: T, b: Self::A) -> (T, Self::A) {\n          (a, b)\n      }\n  }\n\n  struct Bar<T>(T);\n  impl<T> Foo<T> for Bar<T> {\n      type A = T;\n  }\n\nWhen we deal with a trait with an optional trait function that uses the\nassociated types what actually happens here is that the type A in this\ntrait context is considered just a simple PlaceHolder which gets\nsetup within relation to its relevant impl block, so when we setup the\nassociated types it turns into:\n\n  Placeholder(A) ->\n    Projection<T>(Bar<T> as Foo<T>) ->\n      T\n\nSo it forms an recursive chain that must be substituted in relation to\nwhat the paticular query is.", "tree": {"sha": "c89214f404834153a72ac89311d7625cc322a8a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c89214f404834153a72ac89311d7625cc322a8a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07b354c31d2d17ba3a6759a76663d038912b682c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b354c31d2d17ba3a6759a76663d038912b682c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07b354c31d2d17ba3a6759a76663d038912b682c"}], "stats": {"total": 477, "additions": 375, "deletions": 102}, "files": [{"sha": "bffe97c5e8c4f7d483a9d6316aff37880c669242", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -336,7 +336,10 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::InferType &) override { gcc_unreachable (); }\n \n-  void visit (TyTy::ProjectionType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ProjectionType &type) override\n+  {\n+    type.get ()->accept_vis (*this);\n+  }\n \n   void visit (TyTy::PlaceholderType &type) override\n   {"}, {"sha": "dd51f837df19a75c97d0c80b439f65274458268b", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -276,6 +276,18 @@ class PathProbeType : public TypeCheckBase\n \n \tTyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ();\n \n+\tif (impl != nullptr)\n+\t  {\n+\t    HirId impl_block_id = impl->get_mappings ().get_hirid ();\n+\t    AssociatedImplTrait *lookup_associated = nullptr;\n+\t    bool found_impl_trait\n+\t      = context->lookup_associated_trait_impl (impl_block_id,\n+\t\t\t\t\t\t       &lookup_associated);\n+\t    // see testsuite/rust/compile/torture/traits10.rs this can be false\n+\t    if (found_impl_trait)\n+\t      lookup_associated->setup_associated_types ();\n+\t  }\n+\n \t// we can substitute the Self with the receiver here\n \tif (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n \t  {"}, {"sha": "f05ff0c7ab04ee3ca7d3eb1ab53ae0eced8b084d", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -47,26 +47,7 @@ class TraitItemReference\n \n   TraitItemReference (TraitItemReference const &other);\n \n-  TraitItemReference &operator= (TraitItemReference const &other)\n-  {\n-    identifier = other.identifier;\n-    optional_flag = other.optional_flag;\n-    type = other.type;\n-    hir_trait_item = other.hir_trait_item;\n-    self = other.self;\n-    locus = other.locus;\n-    context = other.context;\n-\n-    inherited_substitutions.clear ();\n-    inherited_substitutions.reserve (other.inherited_substitutions.size ());\n-    for (size_t i = 0; i < other.inherited_substitutions.size (); i++)\n-      inherited_substitutions.push_back (other.inherited_substitutions.at (i));\n-\n-    return *this;\n-  }\n-\n-  TraitItemReference (TraitItemReference &&other) = default;\n-  TraitItemReference &operator= (TraitItemReference &&other) = default;\n+  TraitItemReference &operator= (TraitItemReference const &other);\n \n   static TraitItemReference error ()\n   {\n@@ -368,6 +349,7 @@ class AssociatedImplTrait\n \n   TyTy::BaseType *get_projected_type (const TraitItemReference *trait_item_ref,\n \t\t\t\t      TyTy::BaseType *reciever, HirId ref,\n+\t\t\t\t      HIR::GenericArgs &trait_generics,\n \t\t\t\t      Location expr_locus);\n \n private:"}, {"sha": "be58840d8e9517bf2ab46cc861a67020e2937249", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -58,7 +58,7 @@ ResolveTraitItemToRef::visit (HIR::TraitItemFunc &fn)\n \n   resolved = TraitItemReference (identifier, is_optional,\n \t\t\t\t TraitItemReference::TraitItemType::FN, &fn,\n-\t\t\t\t self, substitutions, locus);\n+\t\t\t\t self, std::move (substitutions), locus);\n }\n \n // TraitItemReference items\n@@ -196,7 +196,7 @@ TraitItemReference::get_parent_trait_mappings () const\n TyTy::BaseType *\n AssociatedImplTrait::get_projected_type (\n   const TraitItemReference *trait_item_ref, TyTy::BaseType *receiver, HirId ref,\n-  Location expr_locus)\n+  HIR::GenericArgs &trait_generics, Location expr_locus)\n {\n   TyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ()->clone ();\n \n@@ -219,11 +219,17 @@ AssociatedImplTrait::get_projected_type (\n       std::vector<TyTy::SubstitutionArg> mappings;\n       mappings.push_back (TyTy::SubstitutionArg (param, receiver->clone ()));\n \n-      Location locus; // FIXME\n-      TyTy::SubstitutionArgumentMappings args (std::move (mappings), locus);\n+      TyTy::SubstitutionArgumentMappings args (std::move (mappings),\n+\t\t\t\t\t       expr_locus);\n       trait_item_tyty = SubstMapperInternal::Resolve (trait_item_tyty, args);\n     }\n \n+  if (!trait_generics.is_empty ())\n+    {\n+      trait_item_tyty\n+\t= SubstMapper::Resolve (trait_item_tyty, expr_locus, &trait_generics);\n+    }\n+\n   return trait_item_tyty;\n }\n "}, {"sha": "365994fbd552aed52d48f6201691d7acd02750e7", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -37,9 +37,9 @@ class ResolveTraitItemToRef : public TypeCheckBase\n   Resolve (HIR::TraitItem &item, TyTy::BaseType *self,\n \t   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n   {\n-    ResolveTraitItemToRef resolver (self, substitutions);\n+    ResolveTraitItemToRef resolver (self, std::move (substitutions));\n     item.accept_vis (resolver);\n-    return resolver.resolved;\n+    return std::move (resolver.resolved);\n   }\n \n   void visit (HIR::TraitItemType &type) override;\n@@ -51,9 +51,9 @@ class ResolveTraitItemToRef : public TypeCheckBase\n private:\n   ResolveTraitItemToRef (\n     TyTy::BaseType *self,\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions)\n+    std::vector<TyTy::SubstitutionParamMapping> &&substitutions)\n     : TypeCheckBase (), resolved (TraitItemReference::error ()), self (self),\n-      substitutions (substitutions)\n+      substitutions (std::move (substitutions))\n   {}\n \n   TraitItemReference resolved;\n@@ -146,8 +146,14 @@ class TraitResolver : public TypeCheckBase\n     std::vector<TraitItemReference> item_refs;\n     for (auto &item : trait_reference->get_trait_items ())\n       {\n+\t// make a copy of the substs\n+\tstd::vector<TyTy::SubstitutionParamMapping> item_subst;\n+\tfor (auto &sub : substitutions)\n+\t  item_subst.push_back (sub.clone ());\n+\n \tTraitItemReference trait_item_ref\n-\t  = ResolveTraitItemToRef::Resolve (*item.get (), self, substitutions);\n+\t  = ResolveTraitItemToRef::Resolve (*item.get (), self,\n+\t\t\t\t\t    std::move (item_subst));\n \titem_refs.push_back (std::move (trait_item_ref));\n       }\n "}, {"sha": "59ea4ef781b830703f35c8d1a1ea3a655cae146d", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -303,11 +303,12 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static const TraitItemReference &Resolve (HIR::ImplItem *item,\n-\t\t\t\t\t    TyTy::BaseType *self,\n-\t\t\t\t\t    TraitReference &trait_reference)\n+  static const TraitItemReference &\n+  Resolve (HIR::ImplItem *item, TyTy::BaseType *self,\n+\t   TraitReference &trait_reference,\n+\t   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n   {\n-    TypeCheckImplItemWithTrait resolver (self, trait_reference);\n+    TypeCheckImplItemWithTrait resolver (self, trait_reference, substitutions);\n     item->accept_vis (resolver);\n     return resolver.resolved_trait_item;\n   }\n@@ -383,7 +384,17 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \t  trait_reference.get_name ().c_str ());\n       }\n \n-    resolved_trait_item.associated_type_set (lookup);\n+    rust_debug_loc (type.get_locus (), \"type-alias within impl block\");\n+    lookup->debug ();\n+\n+    // its actually a projection, since we need a way to actually bind the\n+    // generic substitutions to the type itself\n+    TyTy::ProjectionType *projection = new TyTy::ProjectionType (\n+      type.get_mappings ().get_hirid (), lookup, &trait_reference,\n+      resolved_trait_item.get_mappings ().get_defid (), substitutions);\n+\n+    context->insert_type (type.get_mappings (), projection);\n+    resolved_trait_item.associated_type_set (projection);\n   }\n \n   void visit (HIR::Function &function) override\n@@ -452,10 +463,12 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n   }\n \n private:\n-  TypeCheckImplItemWithTrait (TyTy::BaseType *self,\n-\t\t\t      TraitReference &trait_reference)\n+  TypeCheckImplItemWithTrait (\n+    TyTy::BaseType *self, TraitReference &trait_reference,\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions)\n     : TypeCheckImplItem (self), trait_reference (trait_reference),\n-      resolved_trait_item (TraitItemReference::error_node ())\n+      resolved_trait_item (TraitItemReference::error_node ()),\n+      substitutions (substitutions)\n   {\n     rust_assert (is_trait_impl_block ());\n   }\n@@ -464,6 +477,7 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \n   TraitReference &trait_reference;\n   TraitItemReference &resolved_trait_item;\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n };\n \n } // namespace Resolver"}, {"sha": "476a9616aed3b732cc60da4019dac72377100c92", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -43,6 +43,33 @@ class TypeCheckItem : public TypeCheckBase\n \n   void visit (HIR::ImplBlock &impl_block) override\n   {\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+    if (impl_block.has_generics ())\n+      {\n+\tfor (auto &generic_param : impl_block.get_generic_params ())\n+\t  {\n+\t    switch (generic_param.get ()->get_kind ())\n+\t      {\n+\t      case HIR::GenericParam::GenericKind::LIFETIME:\n+\t\t// Skipping Lifetime completely until better handling.\n+\t\tbreak;\n+\n+\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n+\t\t  TyTy::BaseType *l = nullptr;\n+\t\t  bool ok = context->lookup_type (\n+\t\t    generic_param->get_mappings ().get_hirid (), &l);\n+\t\t  if (ok && l->get_kind () == TyTy::TypeKind::PARAM)\n+\t\t    {\n+\t\t      substitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t\tstatic_cast<HIR::TypeParam &> (*generic_param),\n+\t\t\tstatic_cast<TyTy::ParamType *> (l)));\n+\t\t    }\n+\t\t}\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+\n     TraitReference *trait_reference = &TraitReference::error_node ();\n     if (impl_block.has_trait_ref ())\n       {\n@@ -72,7 +99,8 @@ class TypeCheckItem : public TypeCheckBase\n \t  {\n \t    auto &trait_item_ref\n \t      = TypeCheckImplItemWithTrait::Resolve (impl_item.get (), self,\n-\t\t\t\t\t\t     *trait_reference);\n+\t\t\t\t\t\t     *trait_reference,\n+\t\t\t\t\t\t     substitutions);\n \t    trait_item_refs.push_back (trait_item_ref);\n \t  }\n       }"}, {"sha": "8b53e440ce9b9a1b94265b80977468e4bfaa8934", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -74,7 +74,6 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n     = context->lookup_associated_trait_impl (impl_block_id, &lookup_associated);\n   rust_assert (found_impl_trait);\n \n-  DefId resolved_item_id = UNKNOWN_DEFID;\n   HIR::PathExprSegment &item_seg = expr.get_segments ().at (0);\n \n   const TraitItemReference *trait_item_ref = nullptr;\n@@ -85,10 +84,14 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n       rust_error_at (item_seg.get_locus (), \"unknown associated item\");\n       return;\n     }\n-  resolved_item_id = trait_item_ref->get_mappings ().get_defid ();\n \n+  HIR::GenericArgs trait_generics = qual_path_type.trait_has_generic_args ()\n+\t\t\t\t      ? qual_path_type.get_trait_generic_args ()\n+\t\t\t\t      : HIR::GenericArgs::create_empty ();\n+\n+  lookup_associated->setup_associated_types ();\n   infered = lookup_associated->get_projected_type (\n-    trait_item_ref, root, item_seg.get_mappings ().get_hirid (),\n+    trait_item_ref, root, item_seg.get_mappings ().get_hirid (), trait_generics,\n     item_seg.get_locus ());\n \n   // turbo-fish segment path::<ty>\n@@ -106,12 +109,6 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n \t\t\t\t      &item_seg.get_generic_args ());\n     }\n \n-  TyTy::ProjectionType *projection\n-    = new TyTy::ProjectionType (qual_path_type.get_mappings ().get_hirid (),\n-\t\t\t\tTyTy::TyVar (root->get_ref ()), trait_ref,\n-\t\t\t\tresolved_item_id, lookup_associated);\n-  context->insert_type (qual_path_type.get_mappings (), projection);\n-\n   // continue on as a path-in-expression\n   NodeId root_resolved_node_id = trait_item_ref->get_mappings ().get_nodeid ();\n   bool fully_resolved = expr.get_segments ().size () <= 1;\n@@ -340,6 +337,7 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n \t  candidates\n \t    = PathProbeType::Probe (prev_segment, seg.get_segment (), false,\n \t\t\t\t    probe_bounds, ignore_mandatory_trait_items);\n+\n \t  if (candidates.size () == 0)\n \t    {\n \t      rust_error_at ("}, {"sha": "b54a403757d3315afbbf28c59bccc764ee42732d", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -139,7 +139,6 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n     = context->lookup_associated_trait_impl (impl_block_id, &lookup_associated);\n   rust_assert (found_impl_trait);\n \n-  DefId resolved_item_id = UNKNOWN_DEFID;\n   std::unique_ptr<HIR::TypePathSegment> &item_seg\n     = path.get_associated_segment ();\n \n@@ -152,14 +151,17 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n       rust_error_at (item_seg->get_locus (), \"unknown associated item\");\n       return;\n     }\n-  resolved_item_id = trait_item_ref->get_mappings ().get_defid ();\n \n   // project\n   lookup_associated->setup_associated_types ();\n \n+  HIR::GenericArgs trait_generics = qual_path_type.trait_has_generic_args ()\n+\t\t\t\t      ? qual_path_type.get_trait_generic_args ()\n+\t\t\t\t      : HIR::GenericArgs::create_empty ();\n+\n   translated = lookup_associated->get_projected_type (\n     trait_item_ref, root, item_seg->get_mappings ().get_hirid (),\n-    item_seg->get_locus ());\n+    trait_generics, item_seg->get_locus ());\n \n   if (translated->get_kind () == TyTy::TypeKind::PLACEHOLDER)\n     {\n@@ -194,12 +196,6 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n \t}\n     }\n \n-  TyTy::ProjectionType *projection\n-    = new TyTy::ProjectionType (qual_path_type.get_mappings ().get_hirid (),\n-\t\t\t\tTyTy::TyVar (root->get_ref ()), trait_ref,\n-\t\t\t\tresolved_item_id, lookup_associated);\n-  context->insert_type (qual_path_type.get_mappings (), projection);\n-\n   // continue on as a path-in-expression\n   NodeId root_resolved_node_id = trait_item_ref->get_mappings ().get_nodeid ();\n   bool fully_resolved = path.get_segments ().empty ();"}, {"sha": "453f7431ce9d42e81d4fa5e1b323afcacb10a974", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -408,8 +408,9 @@ TraitItemReference::TraitItemReference (\n   HIR::TraitItem *hir_trait_item, TyTy::BaseType *self,\n   std::vector<TyTy::SubstitutionParamMapping> substitutions, Location locus)\n   : identifier (identifier), optional_flag (optional), type (type),\n-    hir_trait_item (hir_trait_item), inherited_substitutions (substitutions),\n-    locus (locus), self (self), context (TypeCheckContext::get ())\n+    hir_trait_item (hir_trait_item),\n+    inherited_substitutions (std::move (substitutions)), locus (locus),\n+    self (self), context (TypeCheckContext::get ())\n {}\n \n TraitItemReference::TraitItemReference (TraitItemReference const &other)\n@@ -420,7 +421,28 @@ TraitItemReference::TraitItemReference (TraitItemReference const &other)\n   inherited_substitutions.clear ();\n   inherited_substitutions.reserve (other.inherited_substitutions.size ());\n   for (size_t i = 0; i < other.inherited_substitutions.size (); i++)\n-    inherited_substitutions.push_back (other.inherited_substitutions.at (i));\n+    inherited_substitutions.push_back (\n+      other.inherited_substitutions.at (i).clone ());\n+}\n+\n+TraitItemReference &\n+TraitItemReference::operator= (TraitItemReference const &other)\n+{\n+  identifier = other.identifier;\n+  optional_flag = other.optional_flag;\n+  type = other.type;\n+  hir_trait_item = other.hir_trait_item;\n+  self = other.self;\n+  locus = other.locus;\n+  context = other.context;\n+\n+  inherited_substitutions.clear ();\n+  inherited_substitutions.reserve (other.inherited_substitutions.size ());\n+  for (size_t i = 0; i < other.inherited_substitutions.size (); i++)\n+    inherited_substitutions.push_back (\n+      other.inherited_substitutions.at (i).clone ());\n+\n+  return *this;\n }\n \n TyTy::BaseType *\n@@ -524,10 +546,13 @@ TraitItemReference::get_type_from_fn (/*const*/ HIR::TraitItemFunc &fn) const\n       context->insert_type (param.get_mappings (), param_tyty);\n     }\n \n-  return new TyTy::FnType (fn.get_mappings ().get_hirid (),\n-\t\t\t   fn.get_mappings ().get_defid (),\n-\t\t\t   function.get_function_name (), function.is_method (),\n-\t\t\t   std::move (params), ret_type, substitutions);\n+  auto resolved\n+    = new TyTy::FnType (fn.get_mappings ().get_hirid (),\n+\t\t\tfn.get_mappings ().get_defid (),\n+\t\t\tfunction.get_function_name (), function.is_method (),\n+\t\t\tstd::move (params), ret_type, substitutions);\n+  context->insert_type (fn.get_mappings (), resolved);\n+  return resolved;\n }\n \n } // namespace Resolver"}, {"sha": "491de857d21bddf8ad01c40ac58072f613ebba93", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -42,6 +42,8 @@ class TypeCheckContext\n \t\t    TyTy::BaseType *type);\n   bool lookup_type (HirId id, TyTy::BaseType **type);\n \n+  void insert_implicit_type (HirId id, TyTy::BaseType *type);\n+\n   void insert_type_by_node_id (NodeId ref, HirId id);\n   bool lookup_type_by_node_id (NodeId ref, HirId *id);\n "}, {"sha": "28cbeb8fb42ebb1fd8ee013846f83d1f6541b547", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -90,6 +90,36 @@ class SubstMapper : public TyTy::TyVisitor\n       resolved = concrete;\n   }\n \n+  void visit (TyTy::PlaceholderType &type) override\n+  {\n+    rust_assert (type.can_resolve ());\n+    resolved = SubstMapper::Resolve (type.resolve (), locus, generics);\n+  }\n+\n+  void visit (TyTy::ProjectionType &type) override\n+  {\n+    TyTy::ProjectionType *concrete = nullptr;\n+    if (!have_generic_args ())\n+      {\n+\tTyTy::BaseType *substs = type.infer_substitions (locus);\n+\trust_assert (substs->get_kind () == TyTy::TypeKind::ADT);\n+\tconcrete = static_cast<TyTy::ProjectionType *> (substs);\n+      }\n+    else\n+      {\n+\tTyTy::SubstitutionArgumentMappings mappings\n+\t  = type.get_mappings_from_generic_args (*generics);\n+\tif (mappings.is_error ())\n+\t  return;\n+\n+\tconcrete = type.handle_substitions (mappings);\n+      }\n+\n+    if (concrete != nullptr)\n+      resolved = concrete;\n+  }\n+\n+  // nothing to do for these\n   void visit (TyTy::InferType &) override { gcc_unreachable (); }\n   void visit (TyTy::TupleType &) override { gcc_unreachable (); }\n   void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n@@ -107,8 +137,6 @@ class SubstMapper : public TyTy::TyVisitor\n   void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n   void visit (TyTy::StrType &) override { gcc_unreachable (); }\n   void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n-  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n-  void visit (TyTy::ProjectionType &) override { gcc_unreachable (); }\n \n private:\n   SubstMapper (HirId ref, HIR::GenericArgs *generics, Location locus)\n@@ -177,6 +205,17 @@ class SubstMapperInternal : public TyTy::TyVisitor\n     resolved = type.handle_substitions (mappings);\n   }\n \n+  void visit (TyTy::PlaceholderType &type) override\n+  {\n+    rust_assert (type.can_resolve ());\n+    resolved = SubstMapperInternal::Resolve (type.resolve (), mappings);\n+  }\n+\n+  void visit (TyTy::ProjectionType &type) override\n+  {\n+    resolved = type.handle_substitions (mappings);\n+  }\n+\n   // nothing to do for these\n   void visit (TyTy::InferType &) override { gcc_unreachable (); }\n   void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n@@ -191,8 +230,6 @@ class SubstMapperInternal : public TyTy::TyVisitor\n   void visit (TyTy::CharType &) override { gcc_unreachable (); }\n   void visit (TyTy::StrType &) override { gcc_unreachable (); }\n   void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n-  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n-  void visit (TyTy::ProjectionType &) override { gcc_unreachable (); }\n \n private:\n   SubstMapperInternal (HirId ref, TyTy::SubstitutionArgumentMappings &mappings)"}, {"sha": "95a16fa283e452ac5d0591ed49404d5d1c1065fb", "filename": "gcc/rust/typecheck/rust-tyctx.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -83,6 +83,13 @@ TypeCheckContext::insert_type (const Analysis::NodeMapping &mappings,\n   resolved[id] = type;\n }\n \n+void\n+TypeCheckContext::insert_implicit_type (HirId id, TyTy::BaseType *type)\n+{\n+  rust_assert (type != nullptr);\n+  resolved[id] = type;\n+}\n+\n bool\n TypeCheckContext::lookup_type (HirId id, TyTy::BaseType **type)\n {"}, {"sha": "f12ffb4b968e73cfa1d493ec85d4f1aee57db46c", "filename": "gcc/rust/typecheck/rust-tyty-coercion.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -46,6 +46,19 @@ class BaseCoercionRules : public TyVisitor\n \t    other = p->resolve ();\n \t  }\n       }\n+    else if (other->get_kind () == TypeKind::PLACEHOLDER)\n+      {\n+\tPlaceholderType *p = static_cast<PlaceholderType *> (other);\n+\tif (p->can_resolve ())\n+\t  {\n+\t    other = p->resolve ();\n+\t  }\n+      }\n+    else if (other->get_kind () == TypeKind::PROJECTION)\n+      {\n+\tProjectionType *p = static_cast<ProjectionType *> (other);\n+\tother = p->get ();\n+      }\n \n     other->accept_vis (*this);\n     if (resolved->get_kind () == TyTy::TypeKind::ERROR)"}, {"sha": "db7d8c02e221aa3d0236972480043ae80d758c7b", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -76,6 +76,11 @@ class BaseRules : public TyVisitor\n \t    other = p->resolve ();\n \t  }\n       }\n+    else if (other->get_kind () == TypeKind::PROJECTION)\n+      {\n+\tProjectionType *p = static_cast<ProjectionType *> (other);\n+\tother = p->get ();\n+      }\n \n     other->accept_vis (*this);\n     if (resolved->get_kind () == TyTy::TypeKind::ERROR)"}, {"sha": "7eb717fde93691852818909b5d9e7b95ecdc071f", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 83, "deletions": 23, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -414,8 +414,6 @@ SubstitutionArgumentMappings\n SubstitutionRef::adjust_mappings_for_this (\n   SubstitutionArgumentMappings &mappings)\n {\n-  Analysis::Mappings *mappings_table = Analysis::Mappings::get ();\n-\n   std::vector<SubstitutionArg> resolved_mappings;\n   for (size_t i = 0; i < substitutions.size (); i++)\n     {\n@@ -442,20 +440,16 @@ SubstitutionRef::adjust_mappings_for_this (\n \t}\n \n       bool ok = !arg.is_error ();\n-      if (!ok)\n+      if (ok)\n \t{\n-\t  rust_error_at (mappings_table->lookup_location (\n-\t\t\t   subst.get_param_ty ()->get_ref ()),\n-\t\t\t \"failed to find parameter type: %s vs mappings [%s]\",\n-\t\t\t subst.get_param_ty ()->as_string ().c_str (),\n-\t\t\t mappings.as_string ().c_str ());\n-\t  return SubstitutionArgumentMappings::error ();\n+\t  SubstitutionArg adjusted (&subst, arg.get_tyty ());\n+\t  resolved_mappings.push_back (std::move (adjusted));\n \t}\n-\n-      SubstitutionArg adjusted (&subst, arg.get_tyty ());\n-      resolved_mappings.push_back (std::move (adjusted));\n     }\n \n+  if (resolved_mappings.empty ())\n+    return SubstitutionArgumentMappings::error ();\n+\n   return SubstitutionArgumentMappings (resolved_mappings,\n \t\t\t\t       mappings.get_locus ());\n }\n@@ -907,7 +901,9 @@ FnType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n       bool ok\n \t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n       if (ok)\n-\tsub.fill_param_ty (arg.get_tyty (), subst_mappings.get_locus ());\n+\t{\n+\t  sub.fill_param_ty (arg.get_tyty (), subst_mappings.get_locus ());\n+\t}\n     }\n \n   auto fty = fn->get_return_type ();\n@@ -2139,42 +2135,106 @@ ProjectionType::accept_vis (TyConstVisitor &vis) const\n std::string\n ProjectionType::as_string () const\n {\n-  return \"<Projection>\";\n+  return \"<Projection=\" + subst_as_string () + \"::\" + base->as_string () + \">\";\n }\n \n BaseType *\n ProjectionType::unify (BaseType *other)\n {\n-  gcc_unreachable ();\n-  return nullptr;\n+  return base->unify (other);\n }\n \n BaseType *\n ProjectionType::coerce (BaseType *other)\n {\n-  gcc_unreachable ();\n-  return nullptr;\n+  return base->coerce (other);\n }\n \n BaseType *\n ProjectionType::cast (BaseType *other)\n {\n-  gcc_unreachable ();\n-  return nullptr;\n+  return base->cast (other);\n }\n \n bool\n ProjectionType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  gcc_unreachable ();\n-  return false;\n+  return base->can_eq (other, emit_errors);\n }\n \n BaseType *\n ProjectionType::clone () const\n {\n   return new ProjectionType (get_ref (), get_ty_ref (), base, trait, item,\n-\t\t\t     associated, get_combined_refs ());\n+\t\t\t     clone_substs (), used_arguments,\n+\t\t\t     get_combined_refs ());\n+}\n+\n+ProjectionType *\n+ProjectionType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n+{\n+  ProjectionType *projection = static_cast<ProjectionType *> (clone ());\n+  projection->set_ty_ref (mappings->get_next_hir_id ());\n+  projection->used_arguments = subst_mappings;\n+\n+  auto context = Resolver::TypeCheckContext::get ();\n+  context->insert_implicit_type (projection->get_ty_ref (), projection);\n+\n+  for (auto &sub : projection->get_substs ())\n+    {\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      bool ok\n+\t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n+      if (ok)\n+\tsub.fill_param_ty (arg.get_tyty (), subst_mappings.get_locus ());\n+    }\n+\n+  auto fty = projection->base;\n+  bool is_param_ty = fty->get_kind () == TypeKind::PARAM;\n+  if (is_param_ty)\n+    {\n+      ParamType *p = static_cast<ParamType *> (fty);\n+\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      bool ok = subst_mappings.get_argument_for_symbol (p, &arg);\n+      if (ok)\n+\t{\n+\t  auto argt = arg.get_tyty ();\n+\t  bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n+\t  bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n+\n+\t  if (arg_is_param || arg_is_concrete)\n+\t    {\n+\t      auto new_field = argt->clone ();\n+\t      new_field->set_ref (fty->get_ref ());\n+\t      projection->base = new_field;\n+\t    }\n+\t  else\n+\t    {\n+\t      fty->set_ty_ref (argt->get_ref ());\n+\t    }\n+\t}\n+    }\n+  else if (fty->needs_generic_substitutions ()\n+\t   || fty->contains_type_parameters ())\n+    {\n+      BaseType *concrete\n+\t= Resolver::SubstMapperInternal::Resolve (fty, subst_mappings);\n+\n+      if (concrete == nullptr || concrete->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (subst_mappings.get_locus (),\n+\t\t\t \"Failed to resolve field substitution type: %s\",\n+\t\t\t fty->as_string ().c_str ());\n+\t  return nullptr;\n+\t}\n+\n+      auto new_field = concrete->clone ();\n+      new_field->set_ref (fty->get_ref ());\n+      projection->base = new_field;\n+    }\n+\n+  return projection;\n }\n \n // rust-tyty-call.h"}, {"sha": "0dfae3705616b23e9aa99cf985662648d6a81c7a", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -1727,26 +1727,38 @@ class PlaceholderType : public BaseType\n \n   bool is_equal (const BaseType &other) const override;\n \n+  bool contains_type_parameters () const override\n+  {\n+    rust_assert (can_resolve ());\n+    return resolve ()->contains_type_parameters ();\n+  }\n+\n private:\n   std::string symbol;\n };\n \n-class ProjectionType : public BaseType\n+class ProjectionType : public BaseType, public SubstitutionRef\n {\n public:\n-  ProjectionType (HirId ref, TyVar base, Resolver::TraitReference *trait,\n-\t\t  DefId item, Resolver::AssociatedImplTrait *associated,\n+  ProjectionType (HirId ref, BaseType *base, Resolver::TraitReference *trait,\n+\t\t  DefId item, std::vector<SubstitutionParamMapping> subst_refs,\n+\t\t  SubstitutionArgumentMappings generic_arguments\n+\t\t  = SubstitutionArgumentMappings::error (),\n \t\t  std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::PROJECTION, refs), base (base),\n-      trait (trait), item (item), associated (associated)\n+    : BaseType (ref, ref, TypeKind::PROJECTION, refs),\n+      SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n+      base (base), trait (trait), item (item)\n   {}\n \n-  ProjectionType (HirId ref, HirId ty_ref, TyVar base,\n+  ProjectionType (HirId ref, HirId ty_ref, BaseType *base,\n \t\t  Resolver::TraitReference *trait, DefId item,\n-\t\t  Resolver::AssociatedImplTrait *associated,\n+\t\t  std::vector<SubstitutionParamMapping> subst_refs,\n+\t\t  SubstitutionArgumentMappings generic_arguments\n+\t\t  = SubstitutionArgumentMappings::error (),\n \t\t  std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::PROJECTION, refs), base (base),\n-      trait (trait), item (item), associated (associated)\n+    : BaseType (ref, ty_ref, TypeKind::PROJECTION, refs),\n+      SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n+      base (base), trait (trait), item (item)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -1765,11 +1777,32 @@ class ProjectionType : public BaseType\n \n   bool is_unit () const override { return false; }\n \n+  bool needs_generic_substitutions () const override final\n+  {\n+    return needs_substitution ();\n+  }\n+\n+  bool supports_substitutions () const override final { return true; }\n+\n+  bool has_subsititions_defined () const override final\n+  {\n+    return has_substitutions ();\n+  }\n+\n+  BaseType *get () { return base; }\n+\n+  bool contains_type_parameters () const override\n+  {\n+    return base->contains_type_parameters ();\n+  }\n+\n+  ProjectionType *\n+  handle_substitions (SubstitutionArgumentMappings mappings) override final;\n+\n private:\n-  TyVar base;\n+  BaseType *base;\n   Resolver::TraitReference *trait;\n   DefId item;\n-  Resolver::AssociatedImplTrait *associated;\n };\n \n } // namespace TyTy"}, {"sha": "8bca0d5c1f6c4f0e564c00327400fbe126059aeb", "filename": "gcc/testsuite/rust/compile/torture/traits14.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits14.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits14.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits14.rs?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -0,0 +1,23 @@\n+trait Foo<T> {\n+    type A;\n+\n+    fn test(a: T) -> T {\n+        a\n+    }\n+}\n+\n+struct Bar<T>(T);\n+impl<T> Foo<T> for Bar<T> {\n+    type A = T;\n+}\n+\n+pub fn main() {\n+    let a;\n+    a = Bar(123);\n+\n+    let b: <Bar<i32> as Foo<i32>>::A;\n+    b = 456;\n+\n+    let c: <Bar<i32> as Foo<i32>>::A;\n+    c = <Bar<i32> as Foo<i32>>::test(a.0);\n+}"}, {"sha": "c8c40b78b45e7550245c1c17e338bc0ab24d9829", "filename": "gcc/testsuite/rust/compile/torture/traits15.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits15.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits15.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits15.rs?ref=0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "patch": "@@ -0,0 +1,23 @@\n+trait Foo<T> {\n+    type A;\n+\n+    fn test(a: T, b: Self::A) -> (T, Self::A) {\n+        (a, b)\n+    }\n+}\n+\n+struct Bar<T>(T);\n+impl<T> Foo<T> for Bar<T> {\n+    type A = T;\n+}\n+\n+pub fn main() {\n+    let a;\n+    a = Bar(123);\n+\n+    let b: <Bar<i32> as Foo<i32>>::A;\n+    b = 456;\n+\n+    let c;\n+    c = <Bar<i32> as Foo<i32>>::test(a.0, 123);\n+}"}]}