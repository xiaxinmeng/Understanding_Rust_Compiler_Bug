{"sha": "f14540b6352b1a164ef79ae36d1ae1463efdac46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE0NTQwYjYzNTJiMWExNjRlZjc5YWUzNmQxYWUxNDYzZWZkYWM0Ng==", "commit": {"author": {"name": "Steve Ellcey", "email": "sellcey@imgtec.com", "date": "2013-05-16T17:09:40Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2013-05-16T17:09:40Z"}, "message": "cfghooks.c (copy_bbs): Add update_dominance argument.\n\n2013-05-16  Steve Ellcey  <sellcey@imgtec.com>\n\n\t* cfghooks.c (copy_bbs): Add update_dominance argument.\n\t* cfghooks.h (copy_bbs): Update prototype.\n\t* tree-cfg.c (gimple_duplicate_sese_region):\n\tAdd update_dominance argument.\n\t* tree-flow.h (gimple_duplicate_sese_region): Update prototype.\n\t* tree-ssa-loop-ch.c (copy_loop_headers): Update\n\tgimple_duplicate_sese_region call.\n\t* tree-vect-loop-manip.c (slpeel_tree_duplicate_loop_to_edge_cfg):\n\tUpdate copy_bbs call.\n\t* cfgloopmanip.c (duplicate_loop_to_header_edge): Ditto.\n\t* trans-mem.c (ipa_uninstrument_transaction): Ditto.\n\nFrom-SVN: r198980", "tree": {"sha": "0417eb55c06e17bb692b965567279eb2722fc0d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0417eb55c06e17bb692b965567279eb2722fc0d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f14540b6352b1a164ef79ae36d1ae1463efdac46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f14540b6352b1a164ef79ae36d1ae1463efdac46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f14540b6352b1a164ef79ae36d1ae1463efdac46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f14540b6352b1a164ef79ae36d1ae1463efdac46/comments", "author": null, "committer": null, "parents": [{"sha": "45f9820f0075149dcbbe71eac97bf31993e9f9df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45f9820f0075149dcbbe71eac97bf31993e9f9df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45f9820f0075149dcbbe71eac97bf31993e9f9df"}], "stats": {"total": 103, "additions": 68, "deletions": 35}, "files": [{"sha": "615c233532869fec69387d96b9001835d3e220c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f14540b6352b1a164ef79ae36d1ae1463efdac46", "patch": "@@ -1,3 +1,17 @@\n+2013-05-16  Steve Ellcey  <sellcey@imgtec.com>\n+\n+\t* cfghooks.c (copy_bbs): Add update_dominance argument.\n+\t* cfghooks.h (copy_bbs): Update prototype.\n+\t* tree-cfg.c (gimple_duplicate_sese_region):\n+\tAdd update_dominance argument.\n+\t* tree-flow.h (gimple_duplicate_sese_region): Update prototype.\n+\t* tree-ssa-loop-ch.c (copy_loop_headers): Update\n+\tgimple_duplicate_sese_region call.\n+\t* tree-vect-loop-manip.c (slpeel_tree_duplicate_loop_to_edge_cfg):\n+\tUpdate copy_bbs call.\n+\t* cfgloopmanip.c (duplicate_loop_to_header_edge): Ditto.\n+\t* trans-mem.c (ipa_uninstrument_transaction): Ditto.\n+\n 2013-05-16  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-vectorizer.h (NUM_PATTERNS): Increment."}, {"sha": "8331fa0e9561374a24895ad1e1d8341bc8bc2bdd", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=f14540b6352b1a164ef79ae36d1ae1463efdac46", "patch": "@@ -1282,12 +1282,17 @@ can_copy_bbs_p (basic_block *bbs, unsigned n)\n \n /* Duplicates N basic blocks stored in array BBS.  Newly created basic blocks\n    are placed into array NEW_BBS in the same order.  Edges from basic blocks\n-   in BBS are also duplicated and copies of those of them\n-   that lead into BBS are redirected to appropriate newly created block.  The\n-   function assigns bbs into loops (copy of basic block bb is assigned to\n-   bb->loop_father->copy loop, so this must be set up correctly in advance)\n-   and updates dominators locally (LOOPS structure that contains the information\n-   about dominators is passed to enable this).\n+   in BBS are also duplicated and copies of those that lead into BBS are\n+   redirected to appropriate newly created block.  The function assigns bbs\n+   into loops (copy of basic block bb is assigned to bb->loop_father->copy\n+   loop, so this must be set up correctly in advance)\n+\n+   If UPDATE_DOMINANCE is true then this function updates dominators locally\n+   (LOOPS structure that contains the information about dominators is passed\n+   to enable this), otherwise it does not update the dominator information\n+   and it assumed that the caller will do this, perhaps by destroying and\n+   recreating it instead of trying to do an incremental update like this\n+   function does when update_dominance is true.\n \n    BASE is the superloop to that basic block belongs; if its header or latch\n    is copied, we do not set the new blocks as header or latch.\n@@ -1301,7 +1306,7 @@ can_copy_bbs_p (basic_block *bbs, unsigned n)\n void\n copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n \t  edge *edges, unsigned num_edges, edge *new_edges,\n-\t  struct loop *base, basic_block after)\n+\t  struct loop *base, basic_block after, bool update_dominance)\n {\n   unsigned i, j;\n   basic_block bb, new_bb, dom_bb;\n@@ -1327,16 +1332,19 @@ copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n     }\n \n   /* Set dominators.  */\n-  for (i = 0; i < n; i++)\n+  if (update_dominance)\n     {\n-      bb = bbs[i];\n-      new_bb = new_bbs[i];\n-\n-      dom_bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n-      if (dom_bb->flags & BB_DUPLICATED)\n+      for (i = 0; i < n; i++)\n \t{\n-\t  dom_bb = get_bb_copy (dom_bb);\n-\t  set_immediate_dominator (CDI_DOMINATORS, new_bb, dom_bb);\n+\t  bb = bbs[i];\n+\t  new_bb = new_bbs[i];\n+\n+\t  dom_bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n+\t  if (dom_bb->flags & BB_DUPLICATED)\n+\t    {\n+\t      dom_bb = get_bb_copy (dom_bb);\n+\t      set_immediate_dominator (CDI_DOMINATORS, new_bb, dom_bb);\n+\t    }\n \t}\n     }\n "}, {"sha": "ec595a5123b668265369dd544cd1413c4090905a", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=f14540b6352b1a164ef79ae36d1ae1463efdac46", "patch": "@@ -201,7 +201,7 @@ extern void lv_add_condition_to_bb (basic_block, basic_block, basic_block,\n extern bool can_copy_bbs_p (basic_block *, unsigned);\n extern void copy_bbs (basic_block *, unsigned, basic_block *,\n \t\t      edge *, unsigned, edge *, struct loop *,\n-\t\t      basic_block);\n+\t\t      basic_block, bool);\n \n void account_profile_record (struct profile_record *, int);\n "}, {"sha": "bc877559052ea5f91e019828c0c1e912e4ca026e", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=f14540b6352b1a164ef79ae36d1ae1463efdac46", "patch": "@@ -1300,7 +1300,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \n       /* Copy bbs.  */\n       copy_bbs (bbs, n, new_bbs, spec_edges, 2, new_spec_edges, loop,\n-\t\tplace_after);\n+\t\tplace_after, true);\n       place_after = new_spec_edges[SE_LATCH]->src;\n \n       if (flags & DLTHE_RECORD_COPY_NUMBER)"}, {"sha": "c66278c01107fc2d5918a39750d8203355622888", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=f14540b6352b1a164ef79ae36d1ae1463efdac46", "patch": "@@ -3978,7 +3978,8 @@ ipa_uninstrument_transaction (struct tm_region *region,\n   int n = queue.length ();\n   basic_block *new_bbs = XNEWVEC (basic_block, n);\n \n-  copy_bbs (queue.address (), n, new_bbs, NULL, 0, NULL, NULL, transaction_bb);\n+  copy_bbs (queue.address (), n, new_bbs, NULL, 0, NULL, NULL, transaction_bb,\n+\t    true);\n   edge e = make_edge (transaction_bb, new_bbs[0], EDGE_TM_UNINSTRUMENTED);\n   add_phi_args_after_copy (new_bbs, n, e);\n "}, {"sha": "721c4f77d4ad23f9e53480756e9dece0a972c503", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=f14540b6352b1a164ef79ae36d1ae1463efdac46", "patch": "@@ -5686,16 +5686,19 @@ add_phi_args_after_copy (basic_block *region_copy, unsigned n_region,\n    inside region is live over the other exit edges of the region.  All entry\n    edges to the region must go to ENTRY->dest.  The edge ENTRY is redirected\n    to the duplicate of the region.  Dominance and loop information is\n-   updated, but not the SSA web.  The new basic blocks are stored to\n-   REGION_COPY in the same order as they had in REGION, provided that\n-   REGION_COPY is not NULL.\n+   updated if UPDATE_DOMINANCE is true, but not the SSA web.  If\n+   UPDATE_DOMINANCE is false then we assume that the caller will update the\n+   dominance information after calling this function.  The new basic\n+   blocks are stored to REGION_COPY in the same order as they had in REGION,\n+   provided that REGION_COPY is not NULL.\n    The function returns false if it is unable to copy the region,\n    true otherwise.  */\n \n bool\n gimple_duplicate_sese_region (edge entry, edge exit,\n \t\t\t    basic_block *region, unsigned n_region,\n-\t\t\t    basic_block *region_copy)\n+\t\t\t    basic_block *region_copy,\n+\t\t\t    bool update_dominance)\n {\n   unsigned i;\n   bool free_region_copy = false, copying_header = false;\n@@ -5749,12 +5752,15 @@ gimple_duplicate_sese_region (edge entry, edge exit,\n       free_region_copy = true;\n     }\n \n-  /* Record blocks outside the region that are dominated by something\n-     inside.  */\n-  doms.create (0);\n   initialize_original_copy_tables ();\n \n-  doms = get_dominated_by_region (CDI_DOMINATORS, region, n_region);\n+  /* Record blocks outside the region that are dominated by something\n+     inside.  */\n+  if (update_dominance)\n+    {\n+      doms.create (0);\n+      doms = get_dominated_by_region (CDI_DOMINATORS, region, n_region);\n+    }\n \n   if (entry->dest->count)\n     {\n@@ -5778,7 +5784,7 @@ gimple_duplicate_sese_region (edge entry, edge exit,\n     }\n \n   copy_bbs (region, n_region, region_copy, &exit, 1, &exit_copy, loop,\n-\t    split_edge_bb_loc (entry));\n+\t    split_edge_bb_loc (entry), update_dominance);\n   if (total_count)\n     {\n       scale_bbs_frequencies_gcov_type (region, n_region,\n@@ -5809,10 +5815,13 @@ gimple_duplicate_sese_region (edge entry, edge exit,\n      for entry block and its copy.  Anything that is outside of the\n      region, but was dominated by something inside needs recounting as\n      well.  */\n-  set_immediate_dominator (CDI_DOMINATORS, entry->dest, entry->src);\n-  doms.safe_push (get_bb_original (entry->dest));\n-  iterate_fix_dominators (CDI_DOMINATORS, doms, false);\n-  doms.release ();\n+  if (update_dominance)\n+    {\n+      set_immediate_dominator (CDI_DOMINATORS, entry->dest, entry->src);\n+      doms.safe_push (get_bb_original (entry->dest));\n+      iterate_fix_dominators (CDI_DOMINATORS, doms, false);\n+      doms.release ();\n+    }\n \n   /* Add the other PHI node arguments.  */\n   add_phi_args_after_copy (region_copy, n_region, NULL);\n@@ -5944,7 +5953,7 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n     }\n \n   copy_bbs (region, n_region, region_copy, exits, 2, nexits, orig_loop,\n-\t    split_edge_bb_loc (exit));\n+\t    split_edge_bb_loc (exit), true);\n   if (total_count)\n     {\n       scale_bbs_frequencies_gcov_type (region, n_region,"}, {"sha": "24fcfbfe92089692ca301b1db9faeb6e2750ca24", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=f14540b6352b1a164ef79ae36d1ae1463efdac46", "patch": "@@ -395,7 +395,7 @@ extern void verify_gimple_in_cfg (struct function *);\n extern tree gimple_block_label (basic_block);\n extern void extract_true_false_edges_from_block (basic_block, edge *, edge *);\n extern bool gimple_duplicate_sese_region (edge, edge, basic_block *, unsigned,\n-\t\t\t\t\tbasic_block *);\n+\t\t\t\t\tbasic_block *, bool);\n extern bool gimple_duplicate_sese_tail (edge, edge, basic_block *, unsigned,\n \t\t\t\t      basic_block *);\n extern void gather_blocks_in_sese_region (basic_block entry, basic_block exit,"}, {"sha": "ff17c7e78fbf1599038d3769155f7d5124622773", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=f14540b6352b1a164ef79ae36d1ae1463efdac46", "patch": "@@ -197,7 +197,8 @@ copy_loop_headers (void)\n       entry = loop_preheader_edge (loop);\n \n       propagate_threaded_block_debug_into (exit->dest, entry->dest);\n-      if (!gimple_duplicate_sese_region (entry, exit, bbs, n_bbs, copied_bbs))\n+      if (!gimple_duplicate_sese_region (entry, exit, bbs, n_bbs, copied_bbs,\n+\t\t\t\t\t true))\n \t{\n \t  fprintf (dump_file, \"Duplication failed.\\n\");\n \t  continue;"}, {"sha": "12f70ee002a6da090b28c9bd3a2aed26835ee544", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14540b6352b1a164ef79ae36d1ae1463efdac46/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=f14540b6352b1a164ef79ae36d1ae1463efdac46", "patch": "@@ -735,7 +735,7 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, edge e)\n \n   copy_bbs (bbs, loop->num_nodes + 1, new_bbs,\n \t    &exit, 1, &new_exit, NULL,\n-\t    e->src);\n+\t    e->src, true);\n   basic_block new_preheader = new_bbs[loop->num_nodes];\n \n   add_phi_args_after_copy (new_bbs, loop->num_nodes + 1, NULL);"}]}