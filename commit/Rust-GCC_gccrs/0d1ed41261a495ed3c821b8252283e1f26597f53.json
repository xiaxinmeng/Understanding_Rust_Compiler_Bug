{"sha": "0d1ed41261a495ed3c821b8252283e1f26597f53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQxZWQ0MTI2MWE0OTVlZDNjODIxYjgyNTIyODNlMWYyNjU5N2Y1Mw==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2016-01-12T14:57:45Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2016-01-12T14:57:45Z"}, "message": "libitm: Remove dead code and data.\n\nFrom-SVN: r232275", "tree": {"sha": "cce62f9d70ede7c9273428aa1052efb2ae3e0273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cce62f9d70ede7c9273428aa1052efb2ae3e0273"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d1ed41261a495ed3c821b8252283e1f26597f53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d1ed41261a495ed3c821b8252283e1f26597f53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d1ed41261a495ed3c821b8252283e1f26597f53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d1ed41261a495ed3c821b8252283e1f26597f53/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1c3c7c414570020cfb7b510f908fc20995ab2da0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c3c7c414570020cfb7b510f908fc20995ab2da0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c3c7c414570020cfb7b510f908fc20995ab2da0"}], "stats": {"total": 444, "additions": 11, "deletions": 433}, "files": [{"sha": "e07cca9c71b56d71024b9f6f889a0385f9269b46", "filename": "libitm/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d1ed41261a495ed3c821b8252283e1f26597f53/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d1ed41261a495ed3c821b8252283e1f26597f53/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=0d1ed41261a495ed3c821b8252283e1f26597f53", "patch": "@@ -1,3 +1,14 @@\n+2016-01-12  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* libitm_i.h (gtm_mask_stack): Remove.\n+\t* beginend.cc (gtm_stmlock_array, gtm_clock): Likewise.\n+\t* stmlock.h: Remove file.\n+\t* config/alpha/cacheline.h: Likewise.\n+\t* config/generic/cacheline.h: Likewise.\n+\t* config/powerpc/cacheline.h: Likewise.\n+\t* config/sparc/cacheline.h: Likewise.\n+\t* config/x86/cacheline.h: Likewise.\n+\n 2016-01-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "c801dab005bcaad37877bfca47c91a93f202d37b", "filename": "libitm/beginend.cc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d1ed41261a495ed3c821b8252283e1f26597f53/libitm%2Fbeginend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d1ed41261a495ed3c821b8252283e1f26597f53/libitm%2Fbeginend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fbeginend.cc?ref=0d1ed41261a495ed3c821b8252283e1f26597f53", "patch": "@@ -36,9 +36,6 @@ gtm_rwlock GTM::gtm_thread::serial_lock;\n gtm_thread *GTM::gtm_thread::list_of_threads = 0;\n unsigned GTM::gtm_thread::number_of_threads = 0;\n \n-gtm_stmlock GTM::gtm_stmlock_array[LOCK_ARRAY_SIZE];\n-atomic<gtm_version> GTM::gtm_clock;\n-\n /* ??? Move elsewhere when we figure out library initialization.  */\n uint64_t GTM::gtm_spin_count_var = 1000;\n "}, {"sha": "c8da46dcdf38613ebe9cc4526cffada96b25b887", "filename": "libitm/config/alpha/cacheline.h", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c3c7c414570020cfb7b510f908fc20995ab2da0/libitm%2Fconfig%2Falpha%2Fcacheline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c3c7c414570020cfb7b510f908fc20995ab2da0/libitm%2Fconfig%2Falpha%2Fcacheline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Falpha%2Fcacheline.h?ref=1c3c7c414570020cfb7b510f908fc20995ab2da0", "patch": "@@ -1,38 +0,0 @@\n-/* Copyright (C) 2009-2016 Free Software Foundation, Inc.\n-   Contributed by Richard Henderson <rth@redhat.com>.\n-\n-   This file is part of the GNU Transactional Memory Library (libitm).\n-\n-   Libitm is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n-   more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef LIBITM_ALPHA_CACHELINE_H\n-#define LIBITM_ALPHA_CACHELINE_H 1\n-\n-// A cacheline is the smallest unit with which locks are associated.\n-// The current implementation of the _ITM_[RW] barriers assumes that\n-// all data types can fit (aligned) within a cachline, which means\n-// in practice sizeof(complex long double) is the smallest cacheline size.\n-// It ought to be small enough for efficient manipulation of the\n-// modification mask, below.\n-#define CACHELINE_SIZE 64\n-\n-#include \"config/generic/cacheline.h\"\n-\n-#endif // LIBITM_ALPHA_CACHELINE_H"}, {"sha": "8b9f927574770ffb5b6f26669f2a20938e24ca9b", "filename": "libitm/config/generic/cacheline.h", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c3c7c414570020cfb7b510f908fc20995ab2da0/libitm%2Fconfig%2Fgeneric%2Fcacheline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c3c7c414570020cfb7b510f908fc20995ab2da0/libitm%2Fconfig%2Fgeneric%2Fcacheline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fgeneric%2Fcacheline.h?ref=1c3c7c414570020cfb7b510f908fc20995ab2da0", "patch": "@@ -1,58 +0,0 @@\n-/* Copyright (C) 2009-2016 Free Software Foundation, Inc.\n-   Contributed by Richard Henderson <rth@redhat.com>.\n-\n-   This file is part of the GNU Transactional Memory Library (libitm).\n-\n-   Libitm is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n-   more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef LIBITM_CACHELINE_H\n-#define LIBITM_CACHELINE_H 1\n-\n-namespace GTM HIDDEN {\n-\n-// A cacheline is the smallest unit with which locks are associated.\n-// The current implementation of the _ITM_[RW] barriers assumes that\n-// all data types can fit (aligned) within a cachline, which means\n-// in practice sizeof(complex long double) is the smallest cacheline size.\n-// It ought to be small enough for efficient manipulation of the\n-// modification mask, below.\n-#ifndef CACHELINE_SIZE\n-# define CACHELINE_SIZE 32\n-#endif\n-\n-// A gtm_cacheline_mask stores a modified bit for every modified byte\n-// in the cacheline with which it is associated.\n-typedef sized_integral<CACHELINE_SIZE / 8>::type gtm_cacheline_mask;\n-\n-union gtm_cacheline\n-{\n-  // Byte access to the cacheline.\n-  unsigned char b[CACHELINE_SIZE] __attribute__((aligned(CACHELINE_SIZE)));\n-\n-  // Larger sized access to the cacheline.\n-  uint16_t u16[CACHELINE_SIZE / sizeof(uint16_t)];\n-  uint32_t u32[CACHELINE_SIZE / sizeof(uint32_t)];\n-  uint64_t u64[CACHELINE_SIZE / sizeof(uint64_t)];\n-  gtm_word w[CACHELINE_SIZE / sizeof(gtm_word)];\n-};\n-\n-} // namespace GTM\n-\n-#endif // LIBITM_CACHELINE_H"}, {"sha": "ce06b40682bc2d93d06eb4fd32220339d8aebbbf", "filename": "libitm/config/powerpc/cacheline.h", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c3c7c414570020cfb7b510f908fc20995ab2da0/libitm%2Fconfig%2Fpowerpc%2Fcacheline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c3c7c414570020cfb7b510f908fc20995ab2da0/libitm%2Fconfig%2Fpowerpc%2Fcacheline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fpowerpc%2Fcacheline.h?ref=1c3c7c414570020cfb7b510f908fc20995ab2da0", "patch": "@@ -1,42 +0,0 @@\n-/* Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Contributed by Richard Henderson <rth@redhat.com>.\n-\n-   This file is part of the GNU Transactional Memory Library (libitm).\n-\n-   Libitm is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n-   more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef LIBITM_POWERPC_CACHELINE_H\n-#define LIBITM_POWERPC_CACHELINE_H 1\n-\n-// A cacheline is the smallest unit with which locks are associated.\n-// The current implementation of the _ITM_[RW] barriers assumes that\n-// all data types can fit (aligned) within a cachline, which means\n-// in practice sizeof(complex long double) is the smallest cacheline size.\n-// It ought to be small enough for efficient manipulation of the\n-// modification mask, below.\n-#if defined (__powerpc64__) || defined (__ppc64__)\n-# define CACHELINE_SIZE 64\n-#else\n-# define CACHELINE_SIZE 32\n-#endif\n-\n-#include \"config/generic/cacheline.h\"\n-\n-#endif // LIBITM_POWERPC_CACHELINE_H"}, {"sha": "732016e318356767f82b4f4fc20826268d3ff5cb", "filename": "libitm/config/sparc/cacheline.h", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c3c7c414570020cfb7b510f908fc20995ab2da0/libitm%2Fconfig%2Fsparc%2Fcacheline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c3c7c414570020cfb7b510f908fc20995ab2da0/libitm%2Fconfig%2Fsparc%2Fcacheline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fsparc%2Fcacheline.h?ref=1c3c7c414570020cfb7b510f908fc20995ab2da0", "patch": "@@ -1,41 +0,0 @@\n-/* Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-\n-   This file is part of the GNU Transactional Memory Library (libitm).\n-\n-   Libitm is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n-   more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef LIBITM_SPARC_CACHELINE_H\n-#define LIBITM_SPARC_CACHELINE_H 1\n-\n-// A cacheline is the smallest unit with which locks are associated.\n-// The current implementation of the _ITM_[RW] barriers assumes that\n-// all data types can fit (aligned) within a cachline, which means\n-// in practice sizeof(complex long double) is the smallest cacheline size.\n-// It ought to be small enough for efficient manipulation of the\n-// modification mask, below.\n-#ifdef __arch64__\n-# define CACHELINE_SIZE 64\n-#else\n-# define CACHELINE_SIZE 32\n-#endif\n-\n-#include \"config/generic/cacheline.h\"\n-\n-#endif // LIBITM_SPARC_CACHELINE_H"}, {"sha": "1c521931554e85d8848cbe7cf2512e0ec947596c", "filename": "libitm/config/x86/cacheline.h", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c3c7c414570020cfb7b510f908fc20995ab2da0/libitm%2Fconfig%2Fx86%2Fcacheline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c3c7c414570020cfb7b510f908fc20995ab2da0/libitm%2Fconfig%2Fx86%2Fcacheline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fx86%2Fcacheline.h?ref=1c3c7c414570020cfb7b510f908fc20995ab2da0", "patch": "@@ -1,125 +0,0 @@\n-/* Copyright (C) 2009-2016 Free Software Foundation, Inc.\n-   Contributed by Richard Henderson <rth@redhat.com>.\n-\n-   This file is part of the GNU Transactional Memory Library (libitm).\n-\n-   Libitm is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n-   more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef LIBITM_CACHELINE_H\n-#define LIBITM_CACHELINE_H 1\n-\n-// Minimum cacheline size is 32, due to both complex long double and __m256.\n-// There's no requirement that 64-bit use a 64-byte cacheline size, but do\n-// so for now to make sure everything is parameterized properly.\n-#ifdef __x86_64__\n-# define CACHELINE_SIZE 64\n-#else\n-# define CACHELINE_SIZE 32\n-#endif\n-\n-namespace GTM HIDDEN {\n-\n-// A gtm_cacheline_mask stores a modified bit for every modified byte\n-// in the cacheline with which it is associated.\n-typedef sized_integral<CACHELINE_SIZE / 8>::type gtm_cacheline_mask;\n-\n-union gtm_cacheline\n-{\n-  // Byte access to the cacheline.\n-  unsigned char b[CACHELINE_SIZE] __attribute__((aligned(CACHELINE_SIZE)));\n-\n-  // Larger sized access to the cacheline.\n-  uint16_t u16[CACHELINE_SIZE / sizeof(uint16_t)];\n-  uint32_t u32[CACHELINE_SIZE / sizeof(uint32_t)];\n-  uint64_t u64[CACHELINE_SIZE / sizeof(uint64_t)];\n-  gtm_word w[CACHELINE_SIZE / sizeof(gtm_word)];\n-\n-#ifdef __MMX__\n-  __m64 m64[CACHELINE_SIZE / sizeof(__m64)];\n-#endif\n-#ifdef __SSE__\n-  __m128 m128[CACHELINE_SIZE / sizeof(__m128)];\n-#endif\n-#ifdef __SSE2__\n-  __m128i m128i[CACHELINE_SIZE / sizeof(__m128i)];\n-#endif\n-#ifdef __AVX__\n-  __m256 m256[CACHELINE_SIZE / sizeof(__m256)];\n-  __m256i m256i[CACHELINE_SIZE / sizeof(__m256i)];\n-#endif\n-\n-#if defined(__SSE__) || defined(__AVX__)\n-  // Copy S to D; only bother defining if we can do this more efficiently\n-  // than the compiler-generated default implementation.\n-  gtm_cacheline& operator= (const gtm_cacheline &s);\n-#endif // SSE, AVX\n-};\n-\n-#if defined(__SSE__) || defined(__AVX__)\n-inline gtm_cacheline& ALWAYS_INLINE\n-gtm_cacheline::operator= (const gtm_cacheline & __restrict s)\n-{\n-#ifdef __AVX__\n-# define CP\tm256\n-# define TYPE\t__m256\n-#else\n-# define CP\tm128\n-# define TYPE\t__m128\n-#endif\n-\n-  TYPE w, x, y, z;\n-\n-  // ??? Wouldn't it be nice to have a pragma to tell the compiler\n-  // to completely unroll a given loop?\n-  switch (CACHELINE_SIZE / sizeof(TYPE))\n-    {\n-    case 1:\n-      this->CP[0] = s.CP[0];\n-      break;\n-    case 2:\n-      x = s.CP[0];\n-      y = s.CP[1];\n-      this->CP[0] = x;\n-      this->CP[1] = y;\n-      break;\n-    case 4:\n-      w = s.CP[0];\n-      x = s.CP[1];\n-      y = s.CP[2];\n-      z = s.CP[3];\n-      this->CP[0] = w;\n-      this->CP[1] = x;\n-      this->CP[2] = y;\n-      this->CP[3] = z;\n-      break;\n-    default:\n-      __builtin_trap ();\n-    }\n-\n-  return *this;\n-\n-#undef CP\n-#undef TYPE\n-}\n-#endif\n-\n-} // namespace GTM\n-\n-#endif // LIBITM_CACHELINE_H"}, {"sha": "751b4abaccc5a732cad3f22b9f05ccceb74f754a", "filename": "libitm/libitm_i.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d1ed41261a495ed3c821b8252283e1f26597f53/libitm%2Flibitm_i.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d1ed41261a495ed3c821b8252283e1f26597f53/libitm%2Flibitm_i.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm_i.h?ref=0d1ed41261a495ed3c821b8252283e1f26597f53", "patch": "@@ -82,8 +82,6 @@ enum gtm_restart_reason\n #include \"target.h\"\n #include \"rwlock.h\"\n #include \"aatree.h\"\n-#include \"cacheline.h\"\n-#include \"stmlock.h\"\n #include \"dispatch.h\"\n #include \"containers.h\"\n \n@@ -354,8 +352,6 @@ extern abi_dispatch *dispatch_gl_wt();\n extern abi_dispatch *dispatch_ml_wt();\n extern abi_dispatch *dispatch_htm();\n \n-extern gtm_cacheline_mask gtm_mask_stack(gtm_cacheline *, gtm_cacheline_mask);\n-\n // Control variable for the HTM fastpath that uses serial mode as fallback.\n // Non-zero if the HTM fastpath is enabled. See gtm_thread::begin_transaction.\n // Accessed from assembly language, thus the \"asm\" specifier on"}, {"sha": "6a8c11e42ff3fc316542d9b2373a7f2a7b1073a2", "filename": "libitm/stmlock.h", "status": "removed", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c3c7c414570020cfb7b510f908fc20995ab2da0/libitm%2Fstmlock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c3c7c414570020cfb7b510f908fc20995ab2da0/libitm%2Fstmlock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fstmlock.h?ref=1c3c7c414570020cfb7b510f908fc20995ab2da0", "patch": "@@ -1,122 +0,0 @@\n-/* Copyright (C) 2009-2016 Free Software Foundation, Inc.\n-   Contributed by Richard Henderson <rth@redhat.com>.\n-\n-   This file is part of the GNU Transactional Memory Library (libitm).\n-\n-   Libitm is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n-   more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef LIBITM_STMLOCK_H\n-#define LIBITM_STMLOCK_H 1\n-\n-namespace GTM HIDDEN {\n-\n-/* A versioned write lock on a cacheline.  This must be wide enough to\n-   store a pointer, and preferably wide enough to avoid overflowing the\n-   version counter.  Thus we use a \"word\", which should be 64-bits on\n-   64-bit systems even when their pointer size is forced smaller.  */\n-typedef gtm_word gtm_stmlock;\n-\n-/* This has to be the same size as gtm_stmlock, we just use this name\n-   for documentation purposes.  */\n-typedef gtm_word gtm_version;\n-\n-/* The maximum value a version number can have.  This is a consequence\n-   of having the low bit of gtm_stmlock reserved for the owned bit.  */\n-#define GTM_VERSION_MAX\t\t(~(gtm_version)0 >> 1)\n-\n-/* A value that may be used to indicate \"uninitialized\" for a version.  */\n-#define GTM_VERSION_INVALID\t(~(gtm_version)0)\n-\n-/* This bit is set when the write lock is held.  When set, the balance of\n-   the bits in the lock is a pointer that references STM backend specific\n-   data; it is up to the STM backend to determine if this thread holds the\n-   lock.  If this bit is clear, the balance of the bits are the last\n-   version number committed to the cacheline.  */\n-static inline bool\n-gtm_stmlock_owned_p (gtm_stmlock lock)\n-{\n-  return lock & 1;\n-}\n-\n-static inline gtm_stmlock\n-gtm_stmlock_set_owned (void *data)\n-{\n-  return (gtm_stmlock)(uintptr_t)data | 1;\n-}\n-\n-static inline void *\n-gtm_stmlock_get_addr (gtm_stmlock lock)\n-{\n-  return (void *)((uintptr_t)lock & ~(uintptr_t)1);\n-}\n-\n-static inline gtm_version\n-gtm_stmlock_get_version (gtm_stmlock lock)\n-{\n-  return lock >> 1;\n-}\n-\n-static inline gtm_stmlock\n-gtm_stmlock_set_version (gtm_version ver)\n-{\n-  return ver << 1;\n-}\n-\n-/* We use a fixed set of locks for all memory, hashed into the\n-   following table.  */\n-#define LOCK_ARRAY_SIZE  (1024 * 1024)\n-extern gtm_stmlock gtm_stmlock_array[LOCK_ARRAY_SIZE];\n-\n-static inline gtm_stmlock *\n-gtm_get_stmlock (const gtm_cacheline *addr)\n-{\n-  size_t idx = ((uintptr_t) addr / CACHELINE_SIZE) % LOCK_ARRAY_SIZE;\n-  return gtm_stmlock_array + idx;\n-}\n-\n-/* The current global version number.  */\n-extern atomic<gtm_version> gtm_clock;\n-\n-static inline gtm_version\n-gtm_get_clock (void)\n-{\n-  atomic_thread_fence(memory_order_release);\n-  return gtm_clock.load(memory_order_acquire);\n-}\n-\n-static inline gtm_version\n-gtm_inc_clock (void)\n-{\n-  /* ??? Here we have a choice, the pre-inc operator mapping to\n-     __atomic_add_fetch with memory_order_seq_cst, or fetch_add\n-     with memory_order_acq_rel plus another separate increment.\n-     We really ought to recognize and optimize fetch_op(x) op x... */\n-  gtm_version r = ++gtm_clock;\n-\n-  /* ??? Ought to handle wraparound for 32-bit.  */\n-  if (sizeof(r) < 8 && r > GTM_VERSION_MAX)\n-    abort ();\n-\n-  return r;\n-}\n-\n-} // namespace GTM\n-\n-#endif // LIBITM_STMLOCK_H"}]}