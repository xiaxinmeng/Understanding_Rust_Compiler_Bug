{"sha": "996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk2ZTFkZTVlNmJjZWQwYzZiNmIwY2JhY2VlMTFjY2M3MjBjY2RmNA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-09-08T13:00:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-09-08T13:00:23Z"}, "message": "re PR tree-optimization/19831 (Missing DSE/malloc/free optimization)\n\n2011-09-08  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/19831\n\t* tree-ssa-dce.c (mark_all_reaching_defs_necessary_1): Also\n\tskip builtins with vdefs that do not really store something.\n\t(propagate_necessity): For calls to free that we can associate\n\twith an allocation function do not mark the freed pointer\n\tdefinition necessary.\n\t(eliminate_unnecessary_stmts): Remove a call to free if\n\tthe associated call to an allocation function is not necessary.\n\n\t* gcc.dg/tree-ssa/pr19831-1.c: New testcase.\n\t* gcc.dg/tree-ssa/pr19831-2.c: Likewise.\n\t* gcc.dg/tree-ssa/pr19831-3.c: Likewise.\n\t* gcc.dg/errno-1.c: Adjust.\n\nFrom-SVN: r178687", "tree": {"sha": "bcaff4692c5de5b68874b434da9ce5fdf5834598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcaff4692c5de5b68874b434da9ce5fdf5834598"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c22c0db26ad16673415d7523781fcf80c8e545ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c22c0db26ad16673415d7523781fcf80c8e545ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c22c0db26ad16673415d7523781fcf80c8e545ba"}], "stats": {"total": 170, "additions": 169, "deletions": 1}, "files": [{"sha": "561c3dbecc1b36ca46539a35dd77ef8596c1417f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4", "patch": "@@ -1,3 +1,14 @@\n+2011-09-08  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/19831\n+\t* tree-ssa-dce.c (mark_all_reaching_defs_necessary_1): Also\n+\tskip builtins with vdefs that do not really store something.\n+\t(propagate_necessity): For calls to free that we can associate\n+\twith an allocation function do not mark the freed pointer\n+\tdefinition necessary.\n+\t(eliminate_unnecessary_stmts): Remove a call to free if\n+\tthe associated call to an allocation function is not necessary.\n+\n 2011-09-08  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/19831"}, {"sha": "c6109a6e52585955eedd99fb20f0fc9f89a714c5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4", "patch": "@@ -1,3 +1,11 @@\n+2011-09-08  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/19831\n+\t* gcc.dg/tree-ssa/pr19831-1.c: New testcase.\n+\t* gcc.dg/tree-ssa/pr19831-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr19831-3.c: Likewise.\n+\t* gcc.dg/errno-1.c: Adjust.\n+\n 2011-09-08  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/19831"}, {"sha": "295deefbe78af68d514b95c987caaaff4efdaf2c", "filename": "gcc/testsuite/gcc.dg/errno-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4/gcc%2Ftestsuite%2Fgcc.dg%2Ferrno-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4/gcc%2Ftestsuite%2Fgcc.dg%2Ferrno-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ferrno-1.c?ref=996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4", "patch": "@@ -6,7 +6,7 @@\n \n int main()\n {\n-  void *p;\n+  void * volatile p;\n   errno = 0;\n   p = malloc (-1);\n   if (errno != 0)"}, {"sha": "1c8f9722708380ee6f0ffa4fc4f3b91a553c2398", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr19831-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19831-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19831-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19831-1.c?ref=996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+void test1(void)\n+{\n+  int *p = __builtin_malloc (sizeof (int) * 4);\n+  int *q = p;\n+  *q++ = 4;\n+  *q++ = 4;\n+  __builtin_free (p);\n+}\n+\n+void test3(int b)\n+{\n+  int *p = __builtin_malloc (sizeof (int) * 4);\n+  if (b)\n+    __builtin_free (p);\n+  *p = 5;\n+}\n+\n+void test4(int b)\n+{\n+  int *p = __builtin_malloc (sizeof (int) * 4);\n+  if (b)\n+    __builtin_free (p);\n+  *p = 5;\n+  __builtin_free (p);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"free\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"malloc\" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "bc7c4cc31823149fb6dd6bc8cec04b595043cd9a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr19831-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19831-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19831-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19831-2.c?ref=996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+void test1(void)\n+{\n+  int *p = __builtin_malloc (sizeof (int) * 4);\n+  *p++ = 4;\n+  __builtin_free (p);\n+}\n+\n+/* Undefined.  We can't do anything here.  */\n+\n+/* { dg-final { scan-tree-dump-times \"free\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"malloc\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "02b55726a99b578d52c9b72ae57605ebd873fdcd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr19831-3.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19831-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19831-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19831-3.c?ref=996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+void test2(void)\n+{\n+  int *p = __builtin_malloc (sizeof (int) * 4);\n+  if (p == (void *)0)\n+    __builtin_abort ();\n+  __builtin_free (p);\n+}\n+\n+void test5(int b)\n+{\n+  int *p = __builtin_malloc (sizeof (int) * 4);\n+  if (p)\n+    __builtin_free (p);\n+}\n+\n+void test6(void)\n+{\n+  int *p = __builtin_malloc (sizeof (int) * 4);\n+  if (p == (void *)0)\n+    __builtin_abort ();\n+  if (p)\n+    __builtin_free (p);\n+}\n+\n+/* We should be able to remove all malloc/free pairs with CDDCE.\n+   Assume p was non-NULL for test2.\n+   For test5, it doesn't matter if p is NULL or non-NULL.  */\n+\n+/* { dg-final { scan-tree-dump-times \"free\" 0 \"optimized\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"malloc\" 0 \"optimized\" { xfail *-*-* } } } */\n+\n+/* But make sure we don't partially optimize for now.  */\n+\n+/* { dg-final { scan-tree-dump-times \"free\" 3 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"malloc\" 3 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "f225030de681ac7d1622995e97189db15ce710b4", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=996e1de5e6bced0c6b6b0cbacee11ccc720ccdf4", "patch": "@@ -309,6 +309,8 @@ mark_stmt_if_obviously_necessary (gimple stmt, bool aggressive)\n \t    case BUILT_IN_CALLOC:\n \t    case BUILT_IN_ALLOCA:\n \t      return;\n+\n+\t    default:;\n \t    }\n \t/* Most, but not all function calls are required.  Function calls that\n \t   produce no result and have no side effects (i.e. const pure\n@@ -625,6 +627,25 @@ mark_all_reaching_defs_necessary_1 (ao_ref *ref ATTRIBUTE_UNUSED,\n \treturn false;\n     }\n \n+  /* We want to skip statments that do not constitute stores but have\n+     a virtual definition.  */\n+  if (is_gimple_call (def_stmt))\n+    {\n+      tree callee = gimple_call_fndecl (def_stmt);\n+      if (callee != NULL_TREE\n+\t  && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL)\n+\tswitch (DECL_FUNCTION_CODE (callee))\n+\t  {\n+\t  case BUILT_IN_MALLOC:\n+\t  case BUILT_IN_CALLOC:\n+\t  case BUILT_IN_ALLOCA:\n+\t  case BUILT_IN_FREE:\n+\t    return false;\n+\n+\t  default:;\n+\t  }\n+    }\n+\n   mark_operand_necessary (vdef);\n \n   return false;\n@@ -805,6 +826,25 @@ propagate_necessity (struct edge_list *el)\n \t  ssa_op_iter iter;\n \t  tree use;\n \n+\t  /* If this is a call to free which is directly fed by an\n+\t     allocation function do not mark that necessary through\n+\t     processing the argument.  */\n+\t  if (gimple_call_builtin_p (stmt, BUILT_IN_FREE))\n+\t    {\n+\t      tree ptr = gimple_call_arg (stmt, 0);\n+\t      gimple def_stmt;\n+\t      tree def_callee;\n+\t      /* If the pointer we free is defined by an allocation\n+\t\t function do not add the call to the worklist.  */\n+\t      if (TREE_CODE (ptr) == SSA_NAME\n+\t\t  && is_gimple_call (def_stmt = SSA_NAME_DEF_STMT (ptr))\n+\t\t  && (def_callee = gimple_call_fndecl (def_stmt))\n+\t\t  && DECL_BUILT_IN_CLASS (def_callee) == BUILT_IN_NORMAL\n+\t\t  && (DECL_FUNCTION_CODE (def_callee) == BUILT_IN_MALLOC\n+\t\t      || DECL_FUNCTION_CODE (def_callee) == BUILT_IN_CALLOC))\n+\t\tcontinue;\n+\t    }\n+\n \t  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n \t    mark_operand_necessary (use);\n \n@@ -1218,6 +1258,29 @@ eliminate_unnecessary_stmts (void)\n \n \t  stats.total++;\n \n+\t  /* We can mark a call to free as not necessary if the\n+\t     defining statement of its argument is an allocation\n+\t     function and that is not necessary itself.  */\n+\t  if (gimple_call_builtin_p (stmt, BUILT_IN_FREE))\n+\t    {\n+\t      tree ptr = gimple_call_arg (stmt, 0);\n+\t      tree callee2;\n+\t      gimple def_stmt;\n+\t      if (TREE_CODE (ptr) != SSA_NAME)\n+\t\tcontinue;\n+\t      def_stmt = SSA_NAME_DEF_STMT (ptr);\n+\t      if (!is_gimple_call (def_stmt)\n+\t\t  || gimple_plf (def_stmt, STMT_NECESSARY))\n+\t\tcontinue;\n+\t      callee2 = gimple_call_fndecl (def_stmt);\n+\t      if (callee2 == NULL_TREE\n+\t\t  || DECL_BUILT_IN_CLASS (callee2) != BUILT_IN_NORMAL\n+\t\t  || (DECL_FUNCTION_CODE (callee2) != BUILT_IN_MALLOC\n+\t\t      && DECL_FUNCTION_CODE (callee2) != BUILT_IN_CALLOC))\n+\t\tcontinue;\n+\t      gimple_set_plf (stmt, STMT_NECESSARY, false);\n+\t    }\n+\n \t  /* If GSI is not necessary then remove it.  */\n \t  if (!gimple_plf (stmt, STMT_NECESSARY))\n \t    {"}]}