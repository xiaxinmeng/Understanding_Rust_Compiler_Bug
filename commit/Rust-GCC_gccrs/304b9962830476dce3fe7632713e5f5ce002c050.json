{"sha": "304b9962830476dce3fe7632713e5f5ce002c050", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA0Yjk5NjI4MzA0NzZkY2UzZmU3NjMyNzEzZTVmNWNlMDAyYzA1MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:10:36Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:10:36Z"}, "message": "[18/77] Make int_mode_for_mode return an opt_scalar_int_mode\n\nAlso use int_mode_for_mode instead of (int_)mode_for_size\nin cases where the requested size was the bitsize of an\nexisting mode.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n            Alan Hayward  <alan.hayward@arm.com>\n            David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* machmode.h (opt_mode::else_blk): New function.\n\t(int_mode_for_mode): Declare.\n\t* stor-layout.c (int_mode_for_mode): Return an opt_scalar_int_mode.\n\t* builtins.c (expand_builtin_signbit): Adjust for new int_mode_for_mode\n\treturn type.\n\t* cfgexpand.c (expand_debug_expr): Likewise.\n\t* combine.c (gen_lowpart_or_truncate): Likewise.\n\t(gen_lowpart_for_combine): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_emit_approx_sqrt): Likewise.\n\t* config/avr/avr.c (avr_to_int_mode): Likewise.\n\t(avr_out_plus_1): Likewise.\n\t(avr_out_plus): Likewise.\n\t(avr_out_round): Likewise.\n\t* config/i386/i386.c (ix86_split_to_parts): Likewise.\n\t* config/s390/s390.c (s390_expand_vec_compare_cc): Likewise.\n\t(s390_expand_vcond): Likewise.\n\t* config/spu/spu.c (spu_split_immediate): Likewise.\n\t(spu_expand_mov): Likewise.\n\t* dse.c (get_stored_val): Likewise.\n\t* expmed.c (store_bit_field_1): Likewise.\n\t(convert_extracted_bit_field): Use int_mode_for_mode instead of\n\tint_mode_for_size.\n\t(extract_bit_field_1): Adjust for new int_mode_for_mode return type.\n\t(extract_low_bits): Likewise.\n\t* expr.c (emit_group_load_1): Likewise.  Separate out the BLKmode\n\thandling rather than repeating the check.\n\t(emit_group_store): Likewise.\n\t(emit_move_via_integer): Adjust for new int_mode_for_mode return type.\n\t* optabs.c (expand_absneg_bit): Likewise.\n\t(expand_copysign_absneg): Likewise.\n\t(expand_copysign_bit): Likewise.\n\t* tree-if-conv.c (ifcvt_can_use_mask_load_store): Likewise.\n\t* tree-vect-slp.c (vect_transform_slp_perm_load): Likewise.\n\t* tree-vect-stmts.c (vect_gen_perm_mask_any): Likewise.\n\t* var-tracking.c (prepare_call_arguments):  Likewise.\n\t* config/powerpcspe/powerpcspe.c (rs6000_do_expand_vec_perm): Use\n\tint_mode_for_mode instead of mode_for_size.\n\t* config/rs6000/rs6000.c (rs6000_do_expand_vec_perm): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251470", "tree": {"sha": "4357020c2fa6f4639a809965e72c48c49d2ceb7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4357020c2fa6f4639a809965e72c48c49d2ceb7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/304b9962830476dce3fe7632713e5f5ce002c050", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/304b9962830476dce3fe7632713e5f5ce002c050", "html_url": "https://github.com/Rust-GCC/gccrs/commit/304b9962830476dce3fe7632713e5f5ce002c050", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/304b9962830476dce3fe7632713e5f5ce002c050/comments", "author": null, "committer": null, "parents": [{"sha": "fffbab82e7fd15ef695159746a0ce7b9ac906778", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fffbab82e7fd15ef695159746a0ce7b9ac906778", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fffbab82e7fd15ef695159746a0ce7b9ac906778"}], "stats": {"total": 309, "additions": 175, "deletions": 134}, "files": [{"sha": "065999764605659475e6f6e84f8b41ab081d4f70", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -1,3 +1,46 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+            Alan Hayward  <alan.hayward@arm.com>\n+            David Sherwood  <david.sherwood@arm.com>\n+\n+\t* machmode.h (opt_mode::else_blk): New function.\n+\t(int_mode_for_mode): Declare.\n+\t* stor-layout.c (int_mode_for_mode): Return an opt_scalar_int_mode.\n+\t* builtins.c (expand_builtin_signbit): Adjust for new int_mode_for_mode\n+\treturn type.\n+\t* cfgexpand.c (expand_debug_expr): Likewise.\n+\t* combine.c (gen_lowpart_or_truncate): Likewise.\n+\t(gen_lowpart_for_combine): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_emit_approx_sqrt): Likewise.\n+\t* config/avr/avr.c (avr_to_int_mode): Likewise.\n+\t(avr_out_plus_1): Likewise.\n+\t(avr_out_plus): Likewise.\n+\t(avr_out_round): Likewise.\n+\t* config/i386/i386.c (ix86_split_to_parts): Likewise.\n+\t* config/s390/s390.c (s390_expand_vec_compare_cc): Likewise.\n+\t(s390_expand_vcond): Likewise.\n+\t* config/spu/spu.c (spu_split_immediate): Likewise.\n+\t(spu_expand_mov): Likewise.\n+\t* dse.c (get_stored_val): Likewise.\n+\t* expmed.c (store_bit_field_1): Likewise.\n+\t(convert_extracted_bit_field): Use int_mode_for_mode instead of\n+\tint_mode_for_size.\n+\t(extract_bit_field_1): Adjust for new int_mode_for_mode return type.\n+\t(extract_low_bits): Likewise.\n+\t* expr.c (emit_group_load_1): Likewise.  Separate out the BLKmode\n+\thandling rather than repeating the check.\n+\t(emit_group_store): Likewise.\n+\t(emit_move_via_integer): Adjust for new int_mode_for_mode return type.\n+\t* optabs.c (expand_absneg_bit): Likewise.\n+\t(expand_copysign_absneg): Likewise.\n+\t(expand_copysign_bit): Likewise.\n+\t* tree-if-conv.c (ifcvt_can_use_mask_load_store): Likewise.\n+\t* tree-vect-slp.c (vect_transform_slp_perm_load): Likewise.\n+\t* tree-vect-stmts.c (vect_gen_perm_mask_any): Likewise.\n+\t* var-tracking.c (prepare_call_arguments):  Likewise.\n+\t* config/powerpcspe/powerpcspe.c (rs6000_do_expand_vec_perm): Use\n+\tint_mode_for_mode instead of mode_for_size.\n+\t* config/rs6000/rs6000.c (rs6000_do_expand_vec_perm): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "f65c3888f7ae123f82da7c30cad95f1446813baf", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -5349,8 +5349,7 @@ expand_builtin_signbit (tree exp, rtx target)\n \n   if (GET_MODE_SIZE (fmode) <= UNITS_PER_WORD)\n     {\n-      imode = int_mode_for_mode (fmode);\n-      gcc_assert (imode != BLKmode);\n+      imode = int_mode_for_mode (fmode).require ();\n       temp = gen_lowpart (imode, temp);\n     }\n   else"}, {"sha": "f6e306e35fb1d49b8580854efd31f77f9916e1ec", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -4838,10 +4838,11 @@ expand_debug_expr (tree exp)\n \t    }\n \t  else\n \t    {\n-\t      machine_mode ifmode = int_mode_for_mode (mode);\n-\t      machine_mode ihmode = int_mode_for_mode (imode);\n+\t      scalar_int_mode ifmode;\n+\t      scalar_int_mode ihmode;\n \t      rtx halfsize;\n-\t      if (ifmode == BLKmode || ihmode == BLKmode)\n+\t      if (!int_mode_for_mode (mode).exists (&ifmode)\n+\t\t  || !int_mode_for_mode (imode).exists (&ihmode))\n \t\treturn NULL;\n \t      halfsize = GEN_INT (GET_MODE_BITSIZE (ihmode));\n \t      re = op0;"}, {"sha": "f792a93b0c513b0906d90dc8cb3d518e78421899", "filename": "gcc/combine.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -8422,8 +8422,8 @@ gen_lowpart_or_truncate (machine_mode mode, rtx x)\n     {\n       /* Bit-cast X into an integer mode.  */\n       if (!SCALAR_INT_MODE_P (GET_MODE (x)))\n-\tx = gen_lowpart (int_mode_for_mode (GET_MODE (x)), x);\n-      x = simplify_gen_unary (TRUNCATE, int_mode_for_mode (mode),\n+\tx = gen_lowpart (int_mode_for_mode (GET_MODE (x)).require (), x);\n+      x = simplify_gen_unary (TRUNCATE, int_mode_for_mode (mode).require (),\n \t\t\t      x, GET_MODE (x));\n     }\n \n@@ -11497,7 +11497,7 @@ gen_lowpart_for_combine (machine_mode omode, rtx x)\n \n       if (imode == VOIDmode)\n \t{\n-\t  imode = int_mode_for_mode (omode);\n+\t  imode = int_mode_for_mode (omode).require ();\n \t  x = gen_lowpart_common (imode, x);\n \t  if (x == NULL)\n \t    goto fail;"}, {"sha": "54c30a2952a1c338526a84a2ee3c37d1913de1e6", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -4760,7 +4760,9 @@ aarch64_float_const_rtx_p (rtx x)\n       && SCALAR_FLOAT_MODE_P (mode)\n       && aarch64_reinterpret_float_as_int (x, &ival))\n     {\n-      machine_mode imode = mode == HFmode ? SImode : int_mode_for_mode (mode);\n+      machine_mode imode = (mode == HFmode\n+\t\t\t    ? SImode\n+\t\t\t    : int_mode_for_mode (mode).require ());\n       int num_instr = aarch64_internal_mov_immediate\n \t\t\t(NULL_RTX, gen_int_mode (ival, imode), false, imode);\n       return num_instr < 3;\n@@ -4802,7 +4804,7 @@ aarch64_can_const_movi_rtx_p (rtx x, machine_mode mode)\n       if (aarch64_float_const_zero_rtx_p (x))\n \treturn true;\n \n-      imode = int_mode_for_mode (mode);\n+      imode = int_mode_for_mode (mode).require ();\n     }\n   else if (GET_CODE (x) == CONST_INT\n \t   && SCALAR_INT_MODE_P (mode))\n@@ -6978,8 +6980,9 @@ aarch64_rtx_costs (rtx x, machine_mode mode, int outer ATTRIBUTE_UNUSED,\n \t  bool succeed = aarch64_reinterpret_float_as_int (x, &ival);\n \t  gcc_assert (succeed);\n \n-\t  machine_mode imode = mode == HFmode ? SImode\n-\t\t\t\t\t      : int_mode_for_mode (mode);\n+\t  machine_mode imode = (mode == HFmode\n+\t\t\t\t? SImode\n+\t\t\t\t: int_mode_for_mode (mode).require ());\n \t  int ncost = aarch64_internal_mov_immediate\n \t\t(NULL_RTX, gen_int_mode (ival, imode), false, imode);\n \t  *cost += COSTS_N_INSNS (ncost);\n@@ -8265,7 +8268,7 @@ aarch64_emit_approx_sqrt (rtx dst, rtx src, bool recp)\n     }\n \n   machine_mode mmsk\n-    = mode_for_vector (int_mode_for_mode (GET_MODE_INNER (mode)),\n+    = mode_for_vector (int_mode_for_mode (GET_MODE_INNER (mode)).require (),\n \t\t       GET_MODE_NUNITS (mode));\n   if (!recp)\n     {"}, {"sha": "d3d69367e0084af9a9a227c62a43c08b55e5035d", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -285,7 +285,7 @@ avr_to_int_mode (rtx x)\n \n   return VOIDmode == mode\n     ? x\n-    : simplify_gen_subreg (int_mode_for_mode (mode), x, mode, 0);\n+    : simplify_gen_subreg (int_mode_for_mode (mode).require (), x, mode, 0);\n }\n \n namespace {\n@@ -7739,7 +7739,7 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc,\n   machine_mode mode = GET_MODE (xop[0]);\n \n   /* INT_MODE of the same size.  */\n-  machine_mode imode = int_mode_for_mode (mode);\n+  scalar_int_mode imode = int_mode_for_mode (mode).require ();\n \n   /* Number of bytes to operate on.  */\n   int n_bytes = GET_MODE_SIZE (mode);\n@@ -8242,7 +8242,7 @@ avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc, bool out_label)\n   rtx xpattern = INSN_P (insn) ? single_set (as_a <rtx_insn *> (insn)) : insn;\n   rtx xdest = SET_DEST (xpattern);\n   machine_mode mode = GET_MODE (xdest);\n-  machine_mode imode = int_mode_for_mode (mode);\n+  scalar_int_mode imode = int_mode_for_mode (mode).require ();\n   int n_bytes = GET_MODE_SIZE (mode);\n   enum rtx_code code_sat = GET_CODE (SET_SRC (xpattern));\n   enum rtx_code code\n@@ -9177,7 +9177,7 @@ const char*\n avr_out_round (rtx_insn *insn ATTRIBUTE_UNUSED, rtx *xop, int *plen)\n {\n   machine_mode mode = GET_MODE (xop[0]);\n-  machine_mode imode = int_mode_for_mode (mode);\n+  scalar_int_mode imode = int_mode_for_mode (mode).require ();\n   // The smallest fractional bit not cleared by the rounding is 2^(-RP).\n   int fbit = (int) GET_MODE_FBIT (mode);\n   double_int i_add = double_int_zero.set_bit (fbit-1 - INTVAL (xop[2]));"}, {"sha": "c574c9573a5d9c038c9482e721de39a5c21822d4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -26361,7 +26361,7 @@ ix86_split_to_parts (rtx operand, rtx *parts, machine_mode mode)\n \n   if (GET_CODE (operand) == CONST_VECTOR)\n     {\n-      machine_mode imode = int_mode_for_mode (mode);\n+      scalar_int_mode imode = int_mode_for_mode (mode).require ();\n       /* Caution: if we looked through a constant pool memory above,\n \t the operand may actually have a different mode now.  That's\n \t ok, since we want to pun this all the way back to an integer.  */"}, {"sha": "5fdba021377650391cbfb5fac8b67b11ddea2426", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -38664,10 +38664,8 @@ rs6000_do_expand_vec_perm (rtx target, rtx op0, rtx op1,\n \n   imode = vmode;\n   if (GET_MODE_CLASS (vmode) != MODE_VECTOR_INT)\n-    {\n-      imode = mode_for_size (GET_MODE_UNIT_BITSIZE (vmode), MODE_INT, 0);\n-      imode = mode_for_vector (imode, nelt);\n-    }\n+    imode = mode_for_vector\n+      (int_mode_for_mode (GET_MODE_INNER (vmode)).require (), nelt);\n \n   x = gen_rtx_CONST_VECTOR (imode, gen_rtvec_v (nelt, perm));\n   x = expand_vec_perm (vmode, op0, op1, x, target);"}, {"sha": "9a0b42af89af5bfac81027a9ebdaebff864c44fd", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -35507,10 +35507,8 @@ rs6000_do_expand_vec_perm (rtx target, rtx op0, rtx op1,\n \n   imode = vmode;\n   if (GET_MODE_CLASS (vmode) != MODE_VECTOR_INT)\n-    {\n-      imode = mode_for_size (GET_MODE_UNIT_BITSIZE (vmode), MODE_INT, 0);\n-      imode = mode_for_vector (imode, nelt);\n-    }\n+    imode = mode_for_vector\n+      (int_mode_for_mode (GET_MODE_INNER (vmode)).require (), nelt);\n \n   x = gen_rtx_CONST_VECTOR (imode, gen_rtvec_v (nelt, perm));\n   x = expand_vec_perm (vmode, op0, op1, x, target);"}, {"sha": "b5c0bd13f3b30890e802bd6d510cac8843f66df1", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -6466,9 +6466,9 @@ s390_expand_vec_compare_cc (rtx target, enum rtx_code code,\n \tcase LE:   cc_producer_mode = CCVFHEmode; code = GE; swap_p = true; break;\n \tdefault: gcc_unreachable ();\n \t}\n-      scratch_mode = mode_for_vector (\n-\t\t       int_mode_for_mode (GET_MODE_INNER (GET_MODE (cmp1))),\n-\t\t       GET_MODE_NUNITS (GET_MODE (cmp1)));\n+      scratch_mode = mode_for_vector\n+\t(int_mode_for_mode (GET_MODE_INNER (GET_MODE (cmp1))).require (),\n+\t GET_MODE_NUNITS (GET_MODE (cmp1)));\n       gcc_assert (scratch_mode != BLKmode);\n \n       if (inv_p)\n@@ -6575,8 +6575,9 @@ s390_expand_vcond (rtx target, rtx then, rtx els,\n \n   /* We always use an integral type vector to hold the comparison\n      result.  */\n-  result_mode = mode_for_vector (int_mode_for_mode (GET_MODE_INNER (cmp_mode)),\n-\t\t\t\t GET_MODE_NUNITS (cmp_mode));\n+  result_mode = mode_for_vector\n+    (int_mode_for_mode (GET_MODE_INNER (cmp_mode)).require (),\n+     GET_MODE_NUNITS (cmp_mode));\n   result_target = gen_reg_rtx (result_mode);\n \n   /* We allow vector immediates as comparison operands that"}, {"sha": "dfa777e48a81bc50f8b3c2c5512b0bac5b8a6cba", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -1493,10 +1493,9 @@ spu_split_immediate (rtx * ops)\n \tunsigned char arrlo[16];\n \trtx to, temp, hi, lo;\n \tint i;\n-\tmachine_mode imode = mode;\n \t/* We need to do reals as ints because the constant used in the\n \t   IOR might not be a legitimate real constant. */\n-\timode = int_mode_for_mode (mode);\n+\tscalar_int_mode imode = int_mode_for_mode (mode).require ();\n \tconstant_to_array (mode, ops[1], arrhi);\n \tif (imode != mode)\n \t  to = simplify_gen_subreg (imode, ops[0], mode, 0);\n@@ -1522,10 +1521,9 @@ spu_split_immediate (rtx * ops)\n \tunsigned char arr_andbi[16];\n \trtx to, reg_fsmbi, reg_and;\n \tint i;\n-\tmachine_mode imode = mode;\n \t/* We need to do reals as ints because the constant used in the\n \t * AND might not be a legitimate real constant. */\n-\timode = int_mode_for_mode (mode);\n+\tscalar_int_mode imode = int_mode_for_mode (mode).require ();\n \tconstant_to_array (mode, ops[1], arr_fsmbi);\n \tif (imode != mode)\n \t  to = simplify_gen_subreg(imode, ops[0], GET_MODE (ops[0]), 0);\n@@ -4430,7 +4428,7 @@ spu_expand_mov (rtx * ops, machine_mode mode)\n   if (GET_CODE (ops[1]) == SUBREG && !valid_subreg (ops[1]))\n     {\n       rtx from = SUBREG_REG (ops[1]);\n-      machine_mode imode = int_mode_for_mode (GET_MODE (from));\n+      scalar_int_mode imode = int_mode_for_mode (GET_MODE (from)).require ();\n \n       gcc_assert (GET_MODE_CLASS (mode) == MODE_INT\n \t\t  && GET_MODE_CLASS (imode) == MODE_INT"}, {"sha": "aa1c766d1f44adc814f6fbd7ce6754e0a2f6fd7c", "filename": "gcc/dse.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -1734,12 +1734,12 @@ get_stored_val (store_info *store_info, machine_mode read_mode,\n     {\n       /* The store is a memset (addr, const_val, const_size).  */\n       gcc_assert (CONST_INT_P (store_info->rhs));\n-      store_mode = int_mode_for_mode (read_mode);\n-      if (store_mode == BLKmode)\n+      scalar_int_mode int_store_mode;\n+      if (!int_mode_for_mode (read_mode).exists (&int_store_mode))\n \tread_reg = NULL_RTX;\n       else if (store_info->rhs == const0_rtx)\n-\tread_reg = extract_low_bits (read_mode, store_mode, const0_rtx);\n-      else if (GET_MODE_BITSIZE (store_mode) > HOST_BITS_PER_WIDE_INT\n+\tread_reg = extract_low_bits (read_mode, int_store_mode, const0_rtx);\n+      else if (GET_MODE_BITSIZE (int_store_mode) > HOST_BITS_PER_WIDE_INT\n \t       || BITS_PER_UNIT >= HOST_BITS_PER_WIDE_INT)\n \tread_reg = NULL_RTX;\n       else\n@@ -1753,8 +1753,8 @@ get_stored_val (store_info *store_info, machine_mode read_mode,\n \t      c |= (c << shift);\n \t      shift <<= 1;\n \t    }\n-\t  read_reg = gen_int_mode (c, store_mode);\n-\t  read_reg = extract_low_bits (read_mode, store_mode, read_reg);\n+\t  read_reg = gen_int_mode (c, int_store_mode);\n+\t  read_reg = extract_low_bits (read_mode, int_store_mode, read_reg);\n \t}\n     }\n   else if (store_info->const_rhs"}, {"sha": "b24b6d1a31dcba0107635bc86d3c5b8c13c9f3a6", "filename": "gcc/expmed.c", "status": "modified", "additions": 42, "deletions": 48, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -829,19 +829,16 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      if we aren't.  This must come after the entire register case above,\n      since that case is valid for any mode.  The following cases are only\n      valid for integral modes.  */\n-  {\n-    machine_mode imode = int_mode_for_mode (GET_MODE (op0));\n-    if (imode != GET_MODE (op0))\n-      {\n-\tif (MEM_P (op0))\n-\t  op0 = adjust_bitfield_address_size (op0, imode, 0, MEM_SIZE (op0));\n-\telse\n-\t  {\n-\t    gcc_assert (imode != BLKmode);\n-\t    op0 = gen_lowpart (imode, op0);\n-\t  }\n-      }\n-  }\n+  opt_scalar_int_mode opt_imode = int_mode_for_mode (GET_MODE (op0));\n+  scalar_int_mode imode;\n+  if (!opt_imode.exists (&imode) || imode != GET_MODE (op0))\n+    {\n+      if (MEM_P (op0))\n+\top0 = adjust_bitfield_address_size (op0, opt_imode.else_blk (),\n+\t\t\t\t\t    0, MEM_SIZE (op0));\n+      else\n+\top0 = gen_lowpart (op0_mode.require (), op0);\n+    }\n \n   /* Storing an lsb-aligned field in a register\n      can be done with a movstrict instruction.  */\n@@ -956,7 +953,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       && GET_MODE_CLASS (GET_MODE (value)) != MODE_INT\n       && GET_MODE_CLASS (GET_MODE (value)) != MODE_PARTIAL_INT)\n     {\n-      value = gen_reg_rtx (int_mode_for_mode (GET_MODE (value)));\n+      value = gen_reg_rtx (int_mode_for_mode (GET_MODE (value)).require ());\n       emit_move_insn (gen_lowpart (GET_MODE (orig_value), value), orig_value);\n     }\n \n@@ -1426,8 +1423,7 @@ convert_extracted_bit_field (rtx x, machine_mode mode,\n      value via a SUBREG.  */\n   if (!SCALAR_INT_MODE_P (tmode))\n     {\n-      scalar_int_mode int_mode\n-\t= int_mode_for_size (GET_MODE_BITSIZE (tmode), 0).require ();\n+      scalar_int_mode int_mode = int_mode_for_mode (tmode).require ();\n       x = convert_to_mode (int_mode, x, unsignedp);\n       x = force_reg (int_mode, x);\n       return gen_lowpart (tmode, x);\n@@ -1532,7 +1528,6 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t     bool reverse, bool fallback_p, rtx *alt_rtl)\n {\n   rtx op0 = str_rtx;\n-  machine_mode int_mode;\n   machine_mode mode1;\n \n   if (tmode == VOIDmode)\n@@ -1673,30 +1668,30 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   /* Make sure we are playing with integral modes.  Pun with subregs\n      if we aren't.  */\n-  {\n-    machine_mode imode = int_mode_for_mode (GET_MODE (op0));\n-    if (imode != GET_MODE (op0))\n-      {\n-\tif (MEM_P (op0))\n-\t  op0 = adjust_bitfield_address_size (op0, imode, 0, MEM_SIZE (op0));\n-\telse if (imode != BLKmode)\n-\t  {\n-\t    op0 = gen_lowpart (imode, op0);\n+  opt_scalar_int_mode opt_imode = int_mode_for_mode (GET_MODE (op0));\n+  scalar_int_mode imode;\n+  if (!opt_imode.exists (&imode) || imode != GET_MODE (op0))\n+    {\n+      if (MEM_P (op0))\n+\top0 = adjust_bitfield_address_size (op0, opt_imode.else_blk (),\n+\t\t\t\t\t    0, MEM_SIZE (op0));\n+      else if (opt_imode.exists (&imode))\n+\t{\n+\t  op0 = gen_lowpart (imode, op0);\n \n-\t    /* If we got a SUBREG, force it into a register since we\n-\t       aren't going to be able to do another SUBREG on it.  */\n-\t    if (GET_CODE (op0) == SUBREG)\n-\t      op0 = force_reg (imode, op0);\n-\t  }\n-\telse\n-\t  {\n-\t    HOST_WIDE_INT size = GET_MODE_SIZE (GET_MODE (op0));\n-\t    rtx mem = assign_stack_temp (GET_MODE (op0), size);\n-\t    emit_move_insn (mem, op0);\n-\t    op0 = adjust_bitfield_address_size (mem, BLKmode, 0, size);\n-\t  }\n-      }\n-  }\n+\t  /* If we got a SUBREG, force it into a register since we\n+\t     aren't going to be able to do another SUBREG on it.  */\n+\t  if (GET_CODE (op0) == SUBREG)\n+\t    op0 = force_reg (imode, op0);\n+\t}\n+      else\n+\t{\n+\t  HOST_WIDE_INT size = GET_MODE_SIZE (GET_MODE (op0));\n+\t  rtx mem = assign_stack_temp (GET_MODE (op0), size);\n+\t  emit_move_insn (mem, op0);\n+\t  op0 = adjust_bitfield_address_size (mem, BLKmode, 0, size);\n+\t}\n+    }\n \n   /* ??? We currently assume TARGET is at least as big as BITSIZE.\n      If that's wrong, the solution is to test for it and set TARGET to 0\n@@ -1900,11 +1895,11 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   /* Find a correspondingly-sized integer field, so we can apply\n      shifts and masks to it.  */\n-  int_mode = int_mode_for_mode (tmode);\n-  if (int_mode == BLKmode)\n-    int_mode = int_mode_for_mode (mode);\n-  /* Should probably push op0 out to memory and then do a load.  */\n-  gcc_assert (int_mode != BLKmode);\n+  scalar_int_mode int_mode;\n+  if (!int_mode_for_mode (tmode).exists (&int_mode))\n+    /* If this fails, we should probably push op0 out to memory and then\n+       do a load.  */\n+    int_mode = int_mode_for_mode (mode).require ();\n \n   target = extract_fixed_bit_field (int_mode, op0, bitsize, bitnum, target,\n \t\t\t\t    unsignedp, reverse);\n@@ -2259,9 +2254,8 @@ extract_low_bits (machine_mode mode, machine_mode src_mode, rtx src)\n         return x;\n     }\n \n-  src_int_mode = int_mode_for_mode (src_mode);\n-  int_mode = int_mode_for_mode (mode);\n-  if (src_int_mode == BLKmode || int_mode == BLKmode)\n+  if (!int_mode_for_mode (src_mode).exists (&src_int_mode)\n+      || !int_mode_for_mode (mode).exists (&int_mode))\n     return NULL_RTX;\n \n   if (!MODES_TIEABLE_P (src_int_mode, src_mode))"}, {"sha": "b9a0b06962f8a09baf2dfe5a86481c5624544d3c", "filename": "gcc/expr.c", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -2094,17 +2094,17 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n       && !MEM_P (orig_src)\n       && GET_CODE (orig_src) != CONCAT)\n     {\n-      machine_mode imode = int_mode_for_mode (GET_MODE (orig_src));\n-      if (imode == BLKmode)\n-\tsrc = assign_stack_temp (GET_MODE (orig_src), ssize);\n+      scalar_int_mode imode;\n+      if (int_mode_for_mode (GET_MODE (orig_src)).exists (&imode))\n+\t{\n+\t  src = gen_reg_rtx (imode);\n+\t  emit_move_insn (gen_lowpart (GET_MODE (orig_src), src), orig_src);\n+\t}\n       else\n-\tsrc = gen_reg_rtx (imode);\n-      if (imode != BLKmode)\n-\tsrc = gen_lowpart (GET_MODE (orig_src), src);\n-      emit_move_insn (src, orig_src);\n-      /* ...and back again.  */\n-      if (imode != BLKmode)\n-\tsrc = gen_lowpart (imode, src);\n+\t{\n+\t  src = assign_stack_temp (GET_MODE (orig_src), ssize);\n+\t  emit_move_insn (src, orig_src);\n+\t}\n       emit_group_load_1 (tmps, dst, src, type, ssize);\n       return;\n     }\n@@ -2368,14 +2368,18 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n   if (!SCALAR_INT_MODE_P (m)\n       && !MEM_P (orig_dst) && GET_CODE (orig_dst) != CONCAT)\n     {\n-      machine_mode imode = int_mode_for_mode (GET_MODE (orig_dst));\n-      if (imode == BLKmode)\n-        dst = assign_stack_temp (GET_MODE (orig_dst), ssize);\n+      scalar_int_mode imode;\n+      if (int_mode_for_mode (GET_MODE (orig_dst)).exists (&imode))\n+\t{\n+\t  dst = gen_reg_rtx (imode);\n+\t  emit_group_store (dst, src, type, ssize);\n+\t  dst = gen_lowpart (GET_MODE (orig_dst), dst);\n+\t}\n       else\n-        dst = gen_reg_rtx (imode);\n-      emit_group_store (dst, src, type, ssize);\n-      if (imode != BLKmode)\n-        dst = gen_lowpart (GET_MODE (orig_dst), dst);\n+\t{\n+\t  dst = assign_stack_temp (GET_MODE (orig_dst), ssize);\n+\t  emit_group_store (dst, src, type, ssize);\n+\t}\n       emit_move_insn (orig_dst, dst);\n       return;\n     }\n@@ -3283,12 +3287,11 @@ emit_move_change_mode (machine_mode new_mode,\n static rtx_insn *\n emit_move_via_integer (machine_mode mode, rtx x, rtx y, bool force)\n {\n-  machine_mode imode;\n+  scalar_int_mode imode;\n   enum insn_code code;\n \n   /* There must exist a mode of the exact size we require.  */\n-  imode = int_mode_for_mode (mode);\n-  if (imode == BLKmode)\n+  if (!int_mode_for_mode (mode).exists (&imode))\n     return NULL;\n \n   /* The target must support moves in this mode.  */"}, {"sha": "590f10036a1e191ae0c4b53222b38b312a9fdfdf", "filename": "gcc/machmode.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -240,6 +240,7 @@ class opt_mode\n   ALWAYS_INLINE opt_mode (from_int m) : m_mode (machine_mode (m)) {}\n \n   machine_mode else_void () const;\n+  machine_mode else_blk () const;\n   T require () const;\n \n   bool exists () const;\n@@ -259,6 +260,15 @@ opt_mode<T>::else_void () const\n   return m_mode;\n }\n \n+/* If the T exists, return its enum value, otherwise return E_BLKmode.  */\n+\n+template<typename T>\n+inline machine_mode\n+opt_mode<T>::else_blk () const\n+{\n+  return m_mode == E_VOIDmode ? E_BLKmode : m_mode;\n+}\n+\n /* Assert that the object contains a T and return it.  */\n \n template<typename T>\n@@ -582,10 +592,9 @@ extern machine_mode smallest_mode_for_size (unsigned int,\n \t\t\t\t\t\t enum mode_class);\n \n \n-/* Return an integer mode of the exact same size as the input mode,\n-   or BLKmode on failure.  */\n+/* Return an integer mode of exactly the same size as the input mode.  */\n \n-extern machine_mode int_mode_for_mode (machine_mode);\n+extern opt_scalar_int_mode int_mode_for_mode (machine_mode);\n \n extern machine_mode bitwise_mode_for_mode (machine_mode);\n "}, {"sha": "1d854b604afb52f7943db921b51ddc588f99ff87", "filename": "gcc/optabs.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -2576,8 +2576,7 @@ expand_absneg_bit (enum rtx_code code, scalar_float_mode mode,\n \n   if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD)\n     {\n-      imode = int_mode_for_mode (mode);\n-      if (imode == BLKmode)\n+      if (!int_mode_for_mode (mode).exists (&imode))\n \treturn NULL_RTX;\n       word = 0;\n       nwords = 1;\n@@ -3270,8 +3269,7 @@ expand_copysign_absneg (scalar_float_mode mode, rtx op0, rtx op1, rtx target,\n     {\n       if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD)\n \t{\n-\t  imode = int_mode_for_mode (mode);\n-\t  if (imode == BLKmode)\n+\t  if (!int_mode_for_mode (mode).exists (&imode))\n \t    return NULL_RTX;\n \t  op1 = gen_lowpart (imode, op1);\n \t}\n@@ -3333,15 +3331,14 @@ static rtx\n expand_copysign_bit (scalar_float_mode mode, rtx op0, rtx op1, rtx target,\n \t\t     int bitpos, bool op0_is_abs)\n {\n-  machine_mode imode;\n+  scalar_int_mode imode;\n   int word, nwords, i;\n   rtx temp;\n   rtx_insn *insns;\n \n   if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD)\n     {\n-      imode = int_mode_for_mode (mode);\n-      if (imode == BLKmode)\n+      if (!int_mode_for_mode (mode).exists (&imode))\n \treturn NULL_RTX;\n       word = 0;\n       nwords = 1;"}, {"sha": "f1a601be13c44efbab75d2833a2a79d58a19bdeb", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -364,16 +364,16 @@ smallest_mode_for_size (unsigned int size, enum mode_class mclass)\n   return mode;\n }\n \n-/* Find an integer mode of the exact same size, or BLKmode on failure.  */\n+/* Return an integer mode of exactly the same size as MODE, if one exists.  */\n \n-machine_mode\n+opt_scalar_int_mode\n int_mode_for_mode (machine_mode mode)\n {\n   switch (GET_MODE_CLASS (mode))\n     {\n     case MODE_INT:\n     case MODE_PARTIAL_INT:\n-      break;\n+      return as_a <scalar_int_mode> (mode);\n \n     case MODE_COMPLEX_INT:\n     case MODE_COMPLEX_FLOAT:\n@@ -390,21 +390,18 @@ int_mode_for_mode (machine_mode mode)\n     case MODE_VECTOR_UFRACT:\n     case MODE_VECTOR_UACCUM:\n     case MODE_POINTER_BOUNDS:\n-      mode = mode_for_size (GET_MODE_BITSIZE (mode), MODE_INT, 0);\n-      break;\n+      return int_mode_for_size (GET_MODE_BITSIZE (mode), 0);\n \n     case MODE_RANDOM:\n       if (mode == BLKmode)\n-\tbreak;\n+\treturn opt_scalar_int_mode ();\n \n       /* fall through */\n \n     case MODE_CC:\n     default:\n       gcc_unreachable ();\n     }\n-\n-  return mode;\n }\n \n /* Find a mode that can be used for efficient bitwise operations on MODE."}, {"sha": "968d93cf86bf07e635e99b307a2e44ac4ba84077", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -933,8 +933,7 @@ ifcvt_can_use_mask_load_store (gimple *stmt)\n   /* Mask should be integer mode of the same size as the load/store\n      mode.  */\n   mode = TYPE_MODE (TREE_TYPE (lhs));\n-  if (int_mode_for_mode (mode) == BLKmode\n-      || VECTOR_MODE_P (mode))\n+  if (!int_mode_for_mode (mode).exists () || VECTOR_MODE_P (mode))\n     return false;\n \n   if (can_vec_mask_load_store_p (mode, VOIDmode, is_load))"}, {"sha": "08746b49f822b7e10d7a17da14815a19e19f6fce", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -3499,7 +3499,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n   /* The generic VEC_PERM_EXPR code always uses an integral type of the\n      same size as the vector element being permuted.  */\n   mask_element_type = lang_hooks.types.type_for_mode\n-\t\t(int_mode_for_mode (TYPE_MODE (TREE_TYPE (vectype))), 1);\n+    (int_mode_for_mode (TYPE_MODE (TREE_TYPE (vectype))).require (), 1);\n   mask_type = get_vectype_for_scalar_type (mask_element_type);\n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   mask = XALLOCAVEC (unsigned char, nunits);"}, {"sha": "96606bd49706d381ef7b3f9e7d2fd0b750776c38", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -6498,7 +6498,7 @@ vect_gen_perm_mask_any (tree vectype, const unsigned char *sel)\n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n   mask_elt_type = lang_hooks.types.type_for_mode\n-\t\t    (int_mode_for_mode (TYPE_MODE (TREE_TYPE (vectype))), 1);\n+    (int_mode_for_mode (TYPE_MODE (TREE_TYPE (vectype))).require (), 1);\n   mask_type = get_vectype_for_scalar_type (mask_elt_type);\n \n   mask_elts = XALLOCAVEC (tree, nunits);"}, {"sha": "b4b34a72b3e9e1f9788a009ba27baf1888f913cf", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/304b9962830476dce3fe7632713e5f5ce002c050/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=304b9962830476dce3fe7632713e5f5ce002c050", "patch": "@@ -6348,8 +6348,9 @@ prepare_call_arguments (basic_block bb, rtx_insn *insn)\n \t      {\n \t\t/* For non-integer stack argument see also if they weren't\n \t\t   initialized by integers.  */\n-\t\tmachine_mode imode = int_mode_for_mode (GET_MODE (mem));\n-\t\tif (imode != GET_MODE (mem) && imode != BLKmode)\n+\t\tscalar_int_mode imode;\n+\t\tif (int_mode_for_mode (GET_MODE (mem)).exists (&imode)\n+\t\t    && imode != GET_MODE (mem))\n \t\t  {\n \t\t    val = cselib_lookup (adjust_address_nv (mem, imode, 0),\n \t\t\t\t\t imode, 0, VOIDmode);"}]}