{"sha": "e92cc0291663bfd027be49e78e11e1f25cc90233", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkyY2MwMjkxNjYzYmZkMDI3YmU0OWU3OGUxMWUxZjI1Y2M5MDIzMw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-07-11T01:13:25Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-07-11T01:13:25Z"}, "message": "87 Cygnus<->FSF merge\n\nFrom-SVN: r12424", "tree": {"sha": "550b87aece0808946ae6109e0a2c279e374b41ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/550b87aece0808946ae6109e0a2c279e374b41ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e92cc0291663bfd027be49e78e11e1f25cc90233", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e92cc0291663bfd027be49e78e11e1f25cc90233", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e92cc0291663bfd027be49e78e11e1f25cc90233", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e92cc0291663bfd027be49e78e11e1f25cc90233/comments", "author": null, "committer": null, "parents": [{"sha": "0d78176b0258cfb747239d2e7be1176f25765869", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d78176b0258cfb747239d2e7be1176f25765869", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d78176b0258cfb747239d2e7be1176f25765869"}], "stats": {"total": 2323, "additions": 1632, "deletions": 691}, "files": [{"sha": "f577385b75cf2a6458e31c4ac6f3aa438c08119e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 225, "deletions": 29, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -1,3 +1,228 @@\n+Tue Jul  9 17:48:48 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (lookup_name_real): If we find mem in obj when parsing\n+ \t`obj->mem', make sure we return the right value.\n+\n+Tue Jul  9 16:11:28 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* search.c (get_base_distance): Call complete_type.\n+\n+Tue Jul  9 12:46:34 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (store_bindings): Make static.\n+\n+Mon Jul  8 16:42:31 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* init.c (expand_aggr_init_1): Don't check type conversions if\n+ \tNEW_OVER.\n+\n+\t* cvt.c (z_candidate): Put back template field.\n+\t(add_function_candidate): Set it.\n+\t(add_template_candidate): Likewise.\n+\t(joust): Use it.\n+\t(compare_qual): Handle references and pointers to members.\n+\t(compare_ics): Handle reference bindings.\n+\n+\t* decl.c (duplicate_decls): Propagate DECL_ONE_ONLY.\n+\n+Mon Jul  8 16:18:56 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* call.c (compute_conversion_costs): Call complete_type.\n+\n+\t* tree.c (vec_binfo_member): Use comptypes instead of comparing\n+ \tpointers, so we can handle template parameters.\n+\n+Fri Jul  5 16:51:53 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* cvt.c (cp_convert_to_pointer): We have to call complete_type\n+\there; let's make it explicit instead of a side effect of an\n+\terror check.\n+\n+Wed Jul  3 16:29:51 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cvt.c (z_candidate): Remove template field.\n+\t(reference_binding): Handle binding to temporary.\n+\t(implicit_conversion): Likewise.\n+\t(add_function_candidate): Handle artificial constructor parms.\n+\tHandle functions with too few parms.\n+\t(add_template_candidate): New function.\n+\t(build_user_type_conversion_1): Handle constructors.\n+\t(convert_like): Likewise.\n+\t(build_over_call): Likewise.\n+\t(build_new_function_call): Support templates.\n+\t(compare_ics): Fix reference, inheritance handling.\n+\n+Mon Jul  1 22:58:18 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* decl.c: Add signed_size_zero_node.\n+\t(init_decl_processing): Build it.\n+\t* class.c (prepare_fresh_vtable): Use it instead of size_zero_node\n+ \twhen we're trying to make a negative delta.\n+\n+Mon Jul  1 17:56:19 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\tStop doing this damn index==strchr variable name confusion.\n+\t* class.c (add_virtual_function): Change local var INDEX to be\n+\tnamed IDX.\n+\t(add_method): Likewise.\n+\t* lex.c (print_parse_statistics): Likewise.\n+\t* search.c (make_memoized_table_entry): Likewise.\n+\t(lookup_fnfields_here): Likewise.\n+\t(lookup_field): Likewise.\n+\t(lookup_fnfields): Likewise.\n+\t(get_baselinks): Likewise.\n+\t* sig.c (build_signature_table_constructor): Likewise.\n+\t(build_signature_method_call): Likewise.\n+\t* typeck.c (build_x_array_ref): Change INDEX parm to be named IDX.\n+\t(get_member_function_from_ptrfunc): Likewise.\n+\t(build_ptrmemfunc): Change local var INDEX to be IDX.\n+\t(c_expand_start_case): Likewise.\n+\n+Sat Jun 29 14:05:46 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cvt.c (cp_convert_to_pointer): Move user-defined type conversion\n+ \thandling to before extraction of TYPE_PTRMEMFUNC_FN_TYPE.\n+\t(convert_to_reference): Use build_type_conversion to convert to\n+ \tthe reference type directly.\n+\t(standard_conversion): Fix void* case, non-conversions.\n+\t(reference_binding): Fix expr == 0 case, non-conversions.\n+\t(convert_like): Support REF_BIND.\n+\t(compare_qual): Split out from compare_ics.\n+\t(compare_ics): Use it, handle icses with only a qual_conv.\n+\n+\t* init.c (expand_vec_init): Don't crash if decl is NULL.\n+\n+Fri Jun 28 11:52:51 1996  Stan Shebs  <shebs@andros.cygnus.com>\n+\n+\t* mpw-config.in: New file, configury for Mac MPW.\n+\t* mpw-make.sed: New file, makefile editing for MPW.\n+\n+Thu Jun 27 15:18:30 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (instantiate_class_template): Call repo_template_used.\n+\n+\t* search.c (lookup_conversions): Only lookup conversions in\n+ \tcomplete types.\n+\n+Thu Jun 27 12:59:53 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* cp-tree.def: Renamed from tree.def, to avoid confusion with\n+\tgcc's tree.def.\n+\t* cp-tree.h, lex.c: Include cp-tree.def.\n+\t* Makefile.in (CXX_TREE_H): Reference cp-tree.def.\n+\n+Wed Jun 26 18:29:47 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* init.c (build_vec_delete_1): Call complete_type.\n+\n+Mon Jun 24 17:17:32 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (start_anon_func): Make sure anonymous functions are\n+ \tnever external.\n+\n+Fri Jun 21 15:10:58 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (finish_function): If function_depth > 1, set nested.\n+\n+\t* decl2.c (grokbitfield): Revert Bob's change.\n+\t* class.c (finish_struct_1): Fix handling of named bitfield widths.\n+\n+Thu Jun 20 23:35:38 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (add_pending_template): Handle types.\n+\t(lookup_template_class): With -fexternal-templates, just add the class\n+\tto pending_templates instead of instantiating it now.\n+\t* decl2.c (finish_file): Handle types in pending_templates.\n+\n+Thu Jun 20 14:08:40 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* decl2.c (grokbitfield): Handle constant decls appropriately.\n+  \tGive an appropriate error message now instead of spewing core\n+ \tlater.\n+\n+Thu Jun 20 13:01:51 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c: Don't turn on thunks by default for now.\n+\n+Wed Jun 19 11:37:04 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (complete_type): Handle error_mark_node.\n+\t(common_type, OFFSET_TYPE): Handle template_type_parms.\n+\n+Tue Jun 18 10:02:15 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (instantiate_decl): If at_eof, call import_export_decl\n+ \tregardless of DECL_INLINE.\n+\n+\t* typeck.c (mark_addressable): Set TREE_ADDRESSABLE on CONSTRUCTORs.\n+\n+\t* class.c (finish_struct_bits): Copy TYPE_SIZE.\n+\n+\t* rtti.c (build_dynamic_cast): Support templates.\n+\t* tree.def: Support DYNAMIC_CAST_EXPR.\n+\t* pt.c (tsubst_copy): Likewise.\n+\t* decl2.c (build_expr_from_tree): Likewise.\n+\n+Mon Jun 17 15:23:36 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (build_static_cast): Support templates.\n+\t(build_const_cast): Likewise.\n+\t* tree.def: Support CONST/STATIC_CAST_EXPR.\n+\t* pt.c (tsubst_copy): Likewise.\n+\t* decl2.c (build_expr_from_tree): Likewise.\n+\n+Sun Jun 16 12:33:57 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c (finish_vtable_vardecl): Don't trust\n+ \tTREE_SYMBOL_REFERENCED for vtables of local classes.\n+\n+Fri Jun 14 18:13:36 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (tsubst_copy): Handle operator T.\n+\n+Wed Jun 12 17:52:40 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* init.c (build_delete): Move creation of PARMS inside test of\n+\tTYPE_HAS_DESTRUCTOR, since it's never used outside of that block.\n+\n+Tue Jun 11 15:09:18 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* typeck.c (build_conditional_expr): Don't assume that\n+\tthe arguments to ?: are always pointers or records.\n+\n+Tue Jun 11 13:56:23 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c (import_export_decl): Still emit static/weak/comdat\n+ \tcopies of inline template functions with -fno-implicit-templates.\n+\n+Tue Jun 11 11:42:13 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* init.c (build_delete): Determine the complete basetype\n+\tpath to the destructor we're calling.\n+\n+Fri Jun  7 15:30:10 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* decl.c (build_enumerator): Always copy the INTEGER_CST used to\n+ \tinitialize the enum, because we really and truly don't know where\n+ \tit came from.\n+\t(start_enum): Don't copy integer_zero_node because\n+ \tbuild_enumerator will do it.\n+\n+Fri Jun  7 11:11:09 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (finish_function): Do access control on base destructors.\n+\n+\t* pt.c (tsubst, case FUNCTION_DECL): Set up\n+ \tIDENTIFIER_GLOBAL_VALUE for member functions so pushdecl doesn't\n+ \those us.\n+\n+Fri Jun  7 10:37:33 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cvt.c (build_up_reference): If we have already extended the\n+ \tlifetime of the temporary, don't try it again.\n+\t* typeck.c (c_expand_return): Don't try and convert the return\n+\tvalue twice when we want a reference, once is enough.\n+\t\n Sat May 11 04:33:50 1996  Doug Evans  <dje@canuck.cygnus.com>\n \n \t* decl2.c (finish_vtable_vardecl): Surround DECL_ONE_ONLY with ifdef.\n@@ -2215,8 +2440,6 @@ Mon Jan 15 08:45:01 1996  Jeffrey A Law  (law@cygnus.com)\n \n \t* tree.c (layout_basetypes): Call build_lang_field_decl instead\n \tof build_lang_decl if first arg is a FIELD_DECL.\n-\t(tree_copy_lang_decl_for_deferred_output): Reverse test for when\n-\tto copy DECL_MAIN_VARIANT and DECL_CHAIN.\n \n Thu Jan 11 14:55:07 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n \n@@ -2335,11 +2558,6 @@ Sun Dec 17 21:13:23 1995  Rusty Russell  <rusty@adelaide.maptek.com.au>\n \n \t* init.c (expand_member_init): warning for base init after members.\n \n-Sun Dec 17 22:06:56 1995  Jeffrey A Law  (law@cygnus.com)\n-\n-\t* tree.c (tree_copy_lang_decl_for_deferred_output): Handle\n-\tCONST_DECLs correctly.\n-\n Fri Dec 15 15:32:18 1995  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* cvt.c (build_expr_type_conversion): Don't convert to a reference\n@@ -2531,14 +2749,6 @@ Mon Nov 13 15:45:34 1995  Mike Stump  <mrs@cygnus.com>\n \t(emit_base_init): Ditto.\n \t(expand_aggr_vbase_init_1): Ditto.\n \n-Fri Nov 10 09:19:31 1995  Jeffrey A Law  (law@cygnus.com)\n-\n-\t* tree.c (tree_copy_lang_decl_for_deferred_output): Handle\n-\tcopying of DECL_ARGUMENTS field.\n-\t(tree_copy_lang_type_for_deferred_output): Handle disgusting\n-\tre-use of TYPE_LANG_SPECIFIC for pointer to member function\n-\ttype nodes.\n-\n Fri Nov 10 09:18:09 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n \n \t* decl.c (push_namespace): Rewrite to use build_lang_decl, so we\n@@ -2595,11 +2805,6 @@ Tue Oct 31 11:56:55 1995  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl2.c (grokclassfn): Tweak __in_chrg attributes.\n \n-Thu Oct 26 20:58:59 1995  Jeffrey A Law  (law@cygnus.com)\n-\n-\t* cp/tree.c (tree_copy_lang_decl_for_deferred_output): Handle\n-\tFIELD_DECLs and VAR_DECLs correctly.\n-\n Thu Oct 26 16:45:58 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n \n \t* errfn.c: Include stdio.h.\n@@ -2726,15 +2931,6 @@ Fri Oct  6 14:44:27 1995  Mike Stump  <mrs@cygnus.com>\n \t* typeck.c (mark_addressable): Add missing call to\n \tassemble_external.\n \n-Wed Oct  4 22:05:23 1995  Jeff Law  (law@hurl.cygnus.com\n-\n-\t* cp/decl.c (deplicate_decls): Merge in deferred output\n-\tstatus for variables.\n-\t* cp/tree.c (tree_copy_lang_decl_for_deferred_output): New\n-\tfunction to copy the g++ specific parts of a DECL node.\n-\t(tree_copy_lang_type_for_deferred_output): Similarly for\n-\tTYPE nodes.\n-\n Wed Oct  4 15:06:39 1995  Mike Stump  <mrs@cygnus.com>\n \n \t* decl.c (store_parm_decls): Make sure the unwinder start comes"}, {"sha": "b7d94a41177d93aeba169c54a54e07d975501920", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -187,7 +187,7 @@ RTL_H = $(srcdir)/../rtl.h $(srcdir)/../rtl.def \\\n \t$(srcdir)/../machmode.h $(srcdir)/../machmode.def\n TREE_H = $(srcdir)/../tree.h $(srcdir)/../real.h $(srcdir)/../tree.def \\\n \t$(srcdir)/../machmode.h $(srcdir)/../machmode.def\n-CXX_TREE_H = $(TREE_H) cp-tree.h tree.def\n+CXX_TREE_H = $(TREE_H) cp-tree.h cp-tree.def\n PARSE_H = $(srcdir)/parse.h\n PARSE_C = $(srcdir)/parse.c\n "}, {"sha": "c0cdf8b96aec9942945c044bb3a6018c586bf15b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -21,7 +21,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n \n-/* High-level class interface. */\n+/* High-level class interface.  */\n \n #include \"config.h\"\n #include \"tree.h\"\n@@ -42,6 +42,7 @@ extern tree ctor_label, dtor_label;\n \n /* Compute the ease with which a conversion can be performed\n    between an expected and the given type.  */\n+\n static struct harshness_code convert_harshness PROTO((register tree, register tree, tree));\n \n #define EVIL_RETURN(ARG)\t((ARG).code = EVIL_CODE, (ARG))\n@@ -52,6 +53,7 @@ static struct harshness_code convert_harshness PROTO((register tree, register tr\n \n /* Ordering function for overload resolution.  Compare two candidates\n    by gross quality.  */\n+\n int\n rank_for_overload (x, y)\n      struct candidate *x, *y;\n@@ -79,6 +81,7 @@ rank_for_overload (x, y)\n }\n \n /* Compare two candidates, argument by argument.  */\n+\n int\n rank_for_ideal (x, y)\n      struct candidate *x, *y;\n@@ -108,6 +111,7 @@ rank_for_ideal (x, y)\n /* TYPE is the type we wish to convert to.  PARM is the parameter\n    we have to work with.  We use a somewhat arbitrary cost function\n    to measure this conversion.  */\n+\n static struct harshness_code\n convert_harshness (type, parmtype, parm)\n      register tree type, parmtype;\n@@ -315,7 +319,7 @@ convert_harshness (type, parmtype, parm)\n \n \t  if (h2.distance)\n \t    {\n-\t      /* This only works for pointers and references. */\n+\t      /* This only works for pointers and references.  */\n \t      if (TREE_CODE (TREE_VALUE (p1)) != POINTER_TYPE\n \t\t  && TREE_CODE (TREE_VALUE (p1)) != REFERENCE_TYPE)\n \t\treturn EVIL_RETURN (h);\n@@ -947,8 +951,8 @@ compute_conversion_costs (function, tta_in, cp, arglen)\n \t      if (formal_type != error_mark_node\n \t\t  && actual_type != error_mark_node)\n \t\t{\n-\t\t  formal_type = TYPE_MAIN_VARIANT (formal_type);\n-\t\t  actual_type = TYPE_MAIN_VARIANT (actual_type);\n+\t\t  formal_type = complete_type (TYPE_MAIN_VARIANT (formal_type));\n+\t\t  actual_type = complete_type (TYPE_MAIN_VARIANT (actual_type));\n \n \t\t  if (TYPE_HAS_CONSTRUCTOR (formal_type))\n \t\t    {\n@@ -1000,7 +1004,7 @@ compute_conversion_costs (function, tta_in, cp, arglen)\n     }\n \n   /* Const member functions get a small penalty because defaulting\n-     to const is less useful than defaulting to non-const. */\n+     to const is less useful than defaulting to non-const.  */\n   /* This is bogus, it does not correspond to anything in the ARM.\n      This code will be fixed when this entire section is rewritten\n      to conform to the ARM.  (mrs)  */\n@@ -1041,6 +1045,7 @@ compute_conversion_costs (function, tta_in, cp, arglen)\n \n /* Subroutine of ideal_candidate.  See if X or Y is a better match\n    than the other.  */\n+\n static int\n strictly_better (x, y)\n      unsigned short x, y;\n@@ -1135,6 +1140,7 @@ ideal_candidate (candidates, n_candidates, len)\n /* Assume that if the class referred to is not in the\n    current class hierarchy, that it may be remote.\n    PARENT is assumed to be of aggregate type here.  */\n+\n static int\n may_be_remote (parent)\n      tree parent;\n@@ -1180,6 +1186,7 @@ build_vfield_ref (datum, type)\n \n /* Build a call to a member of an object.  I.e., one that overloads\n    operator ()(), or is a pointer-to-function or pointer-to-method.  */\n+\n static tree\n build_field_call (basetype_path, instance_ptr, name, parms)\n      tree basetype_path, instance_ptr, name, parms;\n@@ -1314,6 +1321,7 @@ find_scoped_type (type, inner_name, inner_types)\n    is a chain of nested type names (held together by SCOPE_REFs);\n    OUTER_TYPE is the type we know to enclose INNER_TYPES.\n    Returns NULL_TREE if there is an error.  */\n+\n tree\n resolve_scope_to_name (outer_type, inner_stuff)\n      tree outer_type, inner_stuff;\n@@ -1400,6 +1408,7 @@ resolve_scope_to_name (outer_type, inner_stuff)\n \n /* Build a method call of the form `EXP->SCOPES::NAME (PARMS)'.\n    This is how virtual function calls are avoided.  */\n+\n tree\n build_scoped_method_call (exp, basetype, name, parms)\n      tree exp, basetype, name, parms;\n@@ -1523,6 +1532,7 @@ print_n_candidates (candidates, n)\n \n /* We want the address of a function or method.  We avoid creating a\n    pointer-to-member function.  */\n+\n tree\n build_addr_func (function)\n      tree function;\n@@ -1558,6 +1568,7 @@ build_addr_func (function)\n /* Build a CALL_EXPR, we can handle FUNCTION_TYPEs, METHOD_TYPEs, or\n    POINTER_TYPE to those.  Note, pointer to member function types\n    (TYPE_PTRMEMFUNC_P) must be handled by our callers.  */\n+\n tree\n build_call (function, result_type, parms)\n      tree function, result_type, parms;\n@@ -1647,6 +1658,7 @@ default_parm_conversions (parms, last)\n    Note that NAME may refer to an instance variable name.  If\n    `operator()()' is defined for the type of that field, then we return\n    that result.  */\n+\n tree\n build_method_call (instance, name, parms, basetype_path, flags)\n      tree instance, name, parms, basetype_path;\n@@ -1697,7 +1709,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n     }\n \n   /* This is the logic that magically deletes the second argument to\n-     operator delete, if it is not needed. */\n+     operator delete, if it is not needed.  */\n   if (name == ansi_opname[(int) DELETE_EXPR] && list_length (parms)==2)\n     {\n       tree save_last = TREE_CHAIN (parms);\n@@ -1707,7 +1719,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       result = build_method_call (instance, name, parms, basetype_path,\n \t\t\t\t  (LOOKUP_SPECULATIVELY|flags)\n \t\t\t\t  &~LOOKUP_COMPLAIN);\n-      /* If it finds a match, return it. */\n+      /* If it finds a match, return it.  */\n       if (result)\n \treturn build_method_call (instance, name, parms, basetype_path, flags);\n       /* If it doesn't work, two argument delete must work */\n@@ -1789,7 +1801,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \n       if (basetype != NULL_TREE)\n \t;\n-      /* call to a constructor... */\n+      /* call to a constructor...  */\n       else if (basetype_path)\n \t{\n \t  basetype = BINFO_TYPE (basetype_path);\n@@ -2224,7 +2236,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t      cp->function = function;\n \t\t      cp->basetypes = basetype_path;\n \n-\t\t      /* Don't allow non-converting constructors to convert. */\n+\t\t      /* Don't allow non-converting constructors to convert.  */\n \t\t      if (flags & LOOKUP_ONLYCONVERTING\n \t\t\t  && DECL_LANG_SPECIFIC (function)\n \t\t\t  && DECL_NONCONVERTING_P (function))\n@@ -2881,6 +2893,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, require_complete)\n }\n \n /* This requires a complete type on the result of the call.  */\n+\n tree\n build_overload_call (fnname, parms, flags)\n      tree fnname, parms;"}, {"sha": "b631b9679680759cedeb66fdd6694fda0b6bcac5", "filename": "gcc/cp/class.c", "status": "modified", "additions": 103, "deletions": 65, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -20,7 +20,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n \n-/* High-level class interface. */\n+/* High-level class interface.  */\n \n #include \"config.h\"\n #include \"tree.h\"\n@@ -37,7 +37,7 @@ Boston, MA 02111-1307, USA.  */\n extern struct obstack permanent_obstack;\n \n /* This is how we tell when two virtual member functions are really the\n-   same. */\n+   same.  */\n #define SAME_FN(FN1DECL, FN2DECL) (DECL_ASSEMBLER_NAME (FN1DECL) == DECL_ASSEMBLER_NAME (FN2DECL))\n \n extern void set_class_shadows PROTO ((tree));\n@@ -120,6 +120,7 @@ int n_inner_fields_searched = 0;\n #endif\n \n /* Virtual baseclass things.  */\n+\n tree\n build_vbase_pointer (exp, type)\n      tree exp, type;\n@@ -132,7 +133,8 @@ build_vbase_pointer (exp, type)\n }\n \n /* Is the type of the EXPR, the complete type of the object?\n-   If we are going to be wrong, we must be conservative, and return 0. */\n+   If we are going to be wrong, we must be conservative, and return 0.  */\n+\n int\n complete_type_p (expr)\n      tree expr;\n@@ -153,20 +155,20 @@ complete_type_p (expr)\n \tcase CALL_EXPR: \n \t  if (! TREE_HAS_CONSTRUCTOR (expr))\n \t    break;\n-\t  /* fall through... */\n+\t  /* fall through...  */\n \tcase VAR_DECL:\n \tcase FIELD_DECL:\n \t  if (TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n \t      && IS_AGGR_TYPE (TREE_TYPE (TREE_TYPE (expr)))\n \t      && TYPE_MAIN_VARIANT (TREE_TYPE (expr)) == type)\n \t    return 1;\n-\t  /* fall through... */\n+\t  /* fall through...  */\n \tcase TARGET_EXPR:\n \tcase PARM_DECL:\n \t  if (IS_AGGR_TYPE (TREE_TYPE (expr))\n \t      && TYPE_MAIN_VARIANT (TREE_TYPE (expr)) == type)\n \t    return 1;\n-\t  /* fall through... */\n+\t  /* fall through...  */\n \tcase PLUS_EXPR:\n \tdefault:\n \t  break;\n@@ -184,6 +186,7 @@ complete_type_p (expr)\n    TYPE is the type we want this path to have on exit.\n \n    ALIAS_THIS is non-zero if EXPR in an expression involving `this'.  */\n+\n tree\n build_vbase_path (code, type, expr, path, alias_this)\n      enum tree_code code;\n@@ -206,7 +209,7 @@ build_vbase_path (code, type, expr, path, alias_this)\n      to the type we want.  Until that is done, or until we can\n      recognize when that is, we cannot do the short cut logic. (mrs) */\n   /* Do this, until we can undo any previous conversions.  See net35.C\n-     for a testcase. */\n+     for a testcase.  */\n   fixed_type_p = complete_type_p (expr);\n \n   if (!fixed_type_p && TREE_SIDE_EFFECTS (expr))\n@@ -243,7 +246,7 @@ build_vbase_path (code, type, expr, path, alias_this)\n \t\t  tree ind;\n \n \t\t  /* We already check for ambiguous things in the caller, just\n-\t\t     find a path. */\n+\t\t     find a path.  */\n \t\t  if (last)\n \t\t    {\n \t\t      tree binfo = get_binfo (last, TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (nonnull_expr))), 0);\n@@ -359,15 +362,16 @@ build_vbase_path (code, type, expr, path, alias_this)\n /* Virtual function things.  */\n \n /* Virtual functions to be dealt with after laying out our base\n-   classes.  We do all overrides after we layout virtual base classes.\n-   */\n+   classes.  We do all overrides after we layout virtual base classes.  */\n+\n static tree pending_hard_virtuals;\n \n /* Build an entry in the virtual function table.\n    DELTA is the offset for the `this' pointer.\n    PFN is an ADDR_EXPR containing a pointer to the virtual function.\n    Note that the index (DELTA2) in the virtual function table\n    is always 0.  */\n+\n tree\n build_vtable_entry (delta, pfn)\n      tree delta, pfn;\n@@ -426,6 +430,7 @@ build_vtable_entry (delta, pfn)\n    virtual function vtable element corresponding to INDEX.  There are\n    many special cases for INSTANCE which we take care of here, mainly\n    to avoid creating extra tree nodes when we don't have to.  */\n+\n tree\n build_vtbl_ref (instance, idx)\n      tree instance, idx;\n@@ -491,6 +496,7 @@ build_vtbl_ref (instance, idx)\n    virtual function corresponding to INDEX.  There are many special\n    cases for INSTANCE which we take care of here, mainly to avoid\n    creating extra tree nodes when we don't have to.  */\n+\n tree\n build_vfn_ref (ptr_to_instptr, instance, idx)\n      tree *ptr_to_instptr, instance;\n@@ -522,6 +528,7 @@ build_vfn_ref (ptr_to_instptr, instance, idx)\n \n /* Return the name of the virtual function table (as an IDENTIFIER_NODE)\n    for the given TYPE.  */\n+\n static tree\n get_vtable_name (type)\n      tree type;\n@@ -545,6 +552,7 @@ get_vtable_name (type)\n }\n \n /* Return the offset to the main vtable for a given base BINFO.  */\n+\n tree\n get_vfield_offset (binfo)\n      tree binfo;\n@@ -561,6 +569,7 @@ get_vfield_offset (binfo)\n    that far.  The shortened search is useful because the this pointer\n    on method calling is expected to point to a DECL_CONTEXT (fndecl)\n    object, and not a baseclass of it.  */\n+\n static tree\n get_derived_offset (binfo, type)\n      tree binfo, type;\n@@ -581,6 +590,7 @@ get_derived_offset (binfo, type)\n }\n \n /* Update the rtti info for this class.  */\n+\n static void\n set_rtti_entry (virtuals, offset, type)\n      tree virtuals, offset, type;\n@@ -612,6 +622,7 @@ set_rtti_entry (virtuals, offset, type)\n    If BINFO is non-NULL, build the vtable starting with the initial\n    approximation that it is the same as the one which is the head of\n    the association list.  */\n+\n static tree\n build_vtable (binfo, type)\n      tree binfo, type;\n@@ -691,8 +702,8 @@ build_vtable (binfo, type)\n \n    Make sure to use the DECL_ASSEMBLER_NAME of the TYPE_NAME of the\n    type, as template have DECL_NAMEs like: X<int>, whereas the\n-   DECL_ASSEMBLER_NAME is set to be something the assembler can handle.\n-  */\n+   DECL_ASSEMBLER_NAME is set to be something the assembler can handle.  */\n+\n static tree\n build_type_pathname (format, parent, type)\n      char *format;\n@@ -734,6 +745,8 @@ build_type_pathname (format, parent, type)\n   return id;\n }\n \n+extern tree signed_size_zero_node;\n+\n /* Give TYPE a new virtual function table which is initialized\n    with a skeleton-copy of its original initialization.  The only\n    entry that changes is the `delta' entry, so we can really\n@@ -743,6 +756,7 @@ build_type_pathname (format, parent, type)\n    be needed.\n \n    BINFO is the type association which provided TYPE for FOR_TYPE.  */\n+\n static void\n prepare_fresh_vtable (binfo, for_type)\n      tree binfo, for_type;\n@@ -787,7 +801,7 @@ prepare_fresh_vtable (binfo, for_type)\n     offset = BINFO_OFFSET (binfo);\n \n   set_rtti_entry (BINFO_VIRTUALS (binfo),\n-\t\t  size_binop (MINUS_EXPR, size_zero_node, offset),\n+\t\t  size_binop (MINUS_EXPR, signed_size_zero_node, offset),\n \t\t  for_type);\n \n #ifdef GATHER_STATISTICS\n@@ -810,6 +824,7 @@ prepare_fresh_vtable (binfo, for_type)\n    contains BASE_FNDECL.  VIRTUALS is the virtual function table's\n    initializer.  We can run off the end, when dealing with virtual\n    destructors in MI situations, return NULL_TREE in that case.  */\n+\n static tree\n get_vtable_entry (virtuals, base_fndecl)\n      tree virtuals, base_fndecl;\n@@ -850,7 +865,7 @@ modify_vtable_entry (old_entry_in_list, new_entry, fndecl)\n   TREE_VALUE (old_entry_in_list) = new_entry;\n \n   /* Now assign virtual dispatch information, if unset.  */\n-  /* We can dispatch this, through any overridden base function. */\n+  /* We can dispatch this, through any overridden base function.  */\n   if (TREE_CODE (DECL_VINDEX (fndecl)) != INTEGER_CST)\n     {\n       DECL_VINDEX (fndecl) = DECL_VINDEX (base_fndecl);\n@@ -860,6 +875,7 @@ modify_vtable_entry (old_entry_in_list, new_entry, fndecl)\n \n /* Access the virtual function table entry i.  VIRTUALS is the virtual\n    function table's initializer.  */\n+\n static tree\n get_vtable_entry_n (virtuals, n)\n      tree virtuals;\n@@ -880,12 +896,13 @@ get_vtable_entry_n (virtuals, n)\n    HAS_VIRTUAL keeps track of how many virtuals there are in our main\n    vtable for the type, and we build upon the PENDING_VIRTUALS list\n    and return it.  */\n+\n static tree\n add_virtual_function (pending_virtuals, has_virtual, fndecl, t)\n      tree pending_virtuals;\n      int *has_virtual;\n      tree fndecl;\n-     tree t; /* Structure type. */\n+     tree t; /* Structure type.  */\n {\n   /* FUNCTION_TYPEs and OFFSET_TYPEs no longer freely\n      convert to void *.  Make such a conversion here.  */\n@@ -922,21 +939,21 @@ add_virtual_function (pending_virtuals, has_virtual, fndecl, t)\n       /* Build a new INT_CST for this DECL_VINDEX.  */\n       {\n \tstatic tree index_table[256];\n-\ttree index;\n+\ttree idx;\n \t/* We skip a slot for the offset/tdesc entry.  */\n \tint i = ++(*has_virtual);\n \n \tif (i >= 256 || index_table[i] == 0)\n \t  {\n-\t    index = build_int_2 (i, 0);\n+\t    idx = build_int_2 (i, 0);\n \t    if (i < 256)\n-\t      index_table[i] = index;\n+\t      index_table[i] = idx;\n \t  }\n \telse\n-\t  index = index_table[i];\n+\t  idx = index_table[i];\n \n-\t/* Now assign virtual dispatch information. */\n-\tDECL_VINDEX (fndecl) = index;\n+\t/* Now assign virtual dispatch information.  */\n+\tDECL_VINDEX (fndecl) = idx;\n \tDECL_CONTEXT (fndecl) = t;\n       }\n       entry = build_vtable_entry (integer_zero_node, vfn);\n@@ -963,6 +980,7 @@ extern struct obstack *current_obstack;\n \n    FIELDS is the entry in the METHOD_VEC vector entry of the class type where\n    the method should be added.  */\n+\n void\n add_method (type, fields, method)\n      tree type, *fields, method;\n@@ -1027,12 +1045,12 @@ add_method (type, fields, method)\n          METHOD_VEC always has a slot for such entries.  */\n       if (TYPE_IDENTIFIER (type) == DECL_NAME (decl))\n \t{\n-\t  int index = !!DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl));\n-\t  /* TREE_VEC_ELT (method_vec, index) = decl; */\n-\t  if (decl != TREE_VEC_ELT (method_vec, index))\n+\t  int idx = !!DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl));\n+\t  /* TREE_VEC_ELT (method_vec, idx) = decl; */\n+\t  if (decl != TREE_VEC_ELT (method_vec, idx))\n \t    {\n-\t      DECL_CHAIN (decl) = TREE_VEC_ELT (method_vec, index);\n-\t      TREE_VEC_ELT (method_vec, index) = decl;\n+\t      DECL_CHAIN (decl) = TREE_VEC_ELT (method_vec, idx);\n+\t      TREE_VEC_ELT (method_vec, idx) = decl;\n \t    }\n \t}\n       else\n@@ -1110,6 +1128,7 @@ add_method (type, fields, method)\n    Note that anonymous fields which are not of UNION_TYPE are\n    not duplicates, they are just anonymous fields.  This happens\n    when we have unnamed bitfields, for example.  */\n+\n static tree\n delete_duplicate_fields_1 (field, fields)\n      tree field, fields;\n@@ -1197,6 +1216,7 @@ delete_duplicate_fields (fields)\n \n /* Change the access of FDECL to ACCESS in T.\n    Return 1 if change was legit, otherwise return 0.  */\n+\n static int\n alter_access (t, fdecl, access)\n      tree t;\n@@ -1257,7 +1277,7 @@ maybe_fixup_vptrs (for_type, binfo, base_init_list)\n \t  : VF_BASETYPE_VALUE (vfields);\n \n       tree base_binfo = get_binfo (basetype, for_type, 0);\n-      /* Punt until this is implemented. */\n+      /* Punt until this is implemented.  */\n       if (1 /* BINFO_MODIFIED (base_binfo) */)\n \t{\n \t  tree base_offset = get_vfield_offset (base_binfo);\n@@ -1527,7 +1547,7 @@ finish_base_struct (t, b, t_binfo)\n \n       if (TYPE_VIRTUAL_P (basetype))\n \t{\n-\t  /* Remember that the baseclass has virtual members. */\n+\t  /* Remember that the baseclass has virtual members.  */\n \t  b->base_has_virtual = 1;\n \n \t  /* Ensure that this is set from at least a virtual base\n@@ -1686,6 +1706,7 @@ typecode_p (type, code)\n \f\n /* Set memoizing fields and bits of T (and its variants) for later use.\n    MAX_HAS_VIRTUAL is the largest size of any T's virtual function tables.  */\n+\n static void\n finish_struct_bits (t, max_has_virtual)\n      tree t;\n@@ -1711,6 +1732,7 @@ finish_struct_bits (t, max_has_virtual)\n       TYPE_MIN_VALUE (variants) = TYPE_MIN_VALUE (t);\n       TYPE_MAX_VALUE (variants) = TYPE_MAX_VALUE (t);\n       TYPE_FIELDS (variants) = TYPE_FIELDS (t);\n+      TYPE_SIZE (variants) = TYPE_SIZE (t);\n       variants = TYPE_NEXT_VARIANT (variants);\n     }\n \n@@ -1729,7 +1751,7 @@ finish_struct_bits (t, max_has_virtual)\n       if (might_have_abstract_virtuals)\n \t{\n \t  /* We use error_mark_node from override_one_vtable to signal\n-\t     an artificial abstract. */\n+\t     an artificial abstract.  */\n \t  if (CLASSTYPE_ABSTRACT_VIRTUALS (t) == error_mark_node)\n \t    CLASSTYPE_ABSTRACT_VIRTUALS (t) = NULL_TREE;\n \t  CLASSTYPE_ABSTRACT_VIRTUALS (t) = get_abstract_virtuals (t);\n@@ -1784,6 +1806,7 @@ finish_struct_bits (t, max_has_virtual)\n /* Add FNDECL to the method_vec growing on the class_obstack.  Used by\n    finish_struct_methods.  Note, FNDECL cannot be a constructor or\n    destructor, those cases are handled by the caller.  */\n+\n static void\n grow_method (fndecl, method_vec_ptr)\n      tree fndecl;\n@@ -2032,7 +2055,7 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n   return method_vec;\n }\n \n-/* Emit error when a duplicate definition of a type is seen.  Patch up. */\n+/* Emit error when a duplicate definition of a type is seen.  Patch up.  */\n \n void\n duplicate_tag_error (t)\n@@ -2046,12 +2069,11 @@ duplicate_tag_error (t)\n   /* All of the component_decl's were TREE_CHAINed together in the parser.\n      finish_struct_methods walks these chains and assembles all methods with\n      the same base name into DECL_CHAINs. Now we don't need the parser chains\n-     anymore, so we unravel them.\n-   */\n-  /*\n-   * This used to be in finish_struct, but it turns out that the\n-   * TREE_CHAIN is used by dbxout_type_methods and perhaps some other things...\n-   */\n+     anymore, so we unravel them.  */\n+\n+  /* This used to be in finish_struct, but it turns out that the\n+     TREE_CHAIN is used by dbxout_type_methods and perhaps some other\n+     things...  */\n   if (CLASSTYPE_METHOD_VEC (t)) \n     {\n       tree method_vec = CLASSTYPE_METHOD_VEC (t);\n@@ -2094,7 +2116,8 @@ duplicate_tag_error (t)\n   TYPE_CONTEXT (t) = NULL_TREE;\n }\n \n-/* finish up all new vtables. */\n+/* finish up all new vtables.  */\n+\n static void\n finish_vtbls (binfo, do_self, t)\n      tree binfo;\n@@ -2139,11 +2162,12 @@ finish_vtbls (binfo, do_self, t)\n \n /* True if we should override the given BASE_FNDECL with the given\n    FNDECL.  */\n+\n static int\n overrides (fndecl, base_fndecl)\n      tree fndecl, base_fndecl;\n {\n-  /* Destructors have special names. */\n+  /* Destructors have special names.  */\n   if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (base_fndecl)) &&\n       DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fndecl)))\n     return 1;\n@@ -2215,6 +2239,7 @@ get_class_offset_1 (parent, binfo, context, t, fndecl)\n \n /* Get the offset to the CONTEXT subobject that is related to the\n    given BINFO.  */\n+\n static tree\n get_class_offset (context, t, binfo, fndecl)\n      tree context, t, binfo, fndecl;\n@@ -2240,14 +2265,15 @@ get_class_offset (context, t, binfo, fndecl)\n     }\n \n   /* Ok, not found in the less derived binfos, now check the more\n-     derived binfos. */\n+     derived binfos.  */\n   offset = get_class_offset_1 (first_binfo, TYPE_BINFO (t), context, t, fndecl);\n   if (offset==0 || TREE_CODE (offset) != INTEGER_CST)\n     my_friendly_abort (999);\t/* we have to find it.  */\n   return offset;\n }\n \n /* Skip RTTI information at the front of the virtual list.  */\n+\n unsigned HOST_WIDE_INT\n skip_rtti_stuff (virtuals)\n      tree *virtuals;\n@@ -2357,7 +2383,8 @@ modify_one_vtable (binfo, t, fndecl, pfn)\n     }\n }\n \n-/* These are the ones that are not through virtual base classes. */\n+/* These are the ones that are not through virtual base classes.  */\n+\n static void\n modify_all_direct_vtables (binfo, do_self, t, fndecl, pfn)\n      tree binfo;\n@@ -2384,6 +2411,7 @@ modify_all_direct_vtables (binfo, do_self, t, fndecl, pfn)\n }\n \n /* Fixup all the delta entries in this one vtable that need updating.  */\n+\n static void\n fixup_vtable_deltas1 (binfo, t)\n      tree binfo, t;\n@@ -2458,6 +2486,7 @@ fixup_vtable_deltas1 (binfo, t)\n    This happens when we have non-overridden virtual functions from a\n    virtual base class, that are at a different offset, in the new\n    hierarchy, because the layout of the virtual bases has changed.  */\n+\n static void\n fixup_vtable_deltas (binfo, init_self, t)\n      tree binfo;\n@@ -2482,7 +2511,8 @@ fixup_vtable_deltas (binfo, init_self, t)\n     }\n }\n \n-/* These are the ones that are through virtual base classes. */\n+/* These are the ones that are through virtual base classes.  */\n+\n static void\n modify_all_indirect_vtables (binfo, do_self, via_virtual, t, fndecl, pfn)\n      tree binfo;\n@@ -2517,14 +2547,15 @@ modify_all_vtables (t, fndecl, vfn)\n      tree t, fndecl, vfn;\n {\n   /* Do these first, so that we will make use of any non-virtual class's\n-     vtable, over a virtual classes vtable. */\n+     vtable, over a virtual classes vtable.  */\n   modify_all_direct_vtables (TYPE_BINFO (t), 1, t, fndecl, vfn);\n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n     modify_all_indirect_vtables (TYPE_BINFO (t), 1, 0, t, fndecl, vfn);\n }\n \n /* Here, we already know that they match in every respect.\n    All we have to check is where they had their declarations.  */\n+\n static int \n strictly_overrides (fndecl1, fndecl2)\n      tree fndecl1, fndecl2;\n@@ -2549,6 +2580,7 @@ strictly_overrides (fndecl1, fndecl2)\n        then it is ill-formed.  (mrs)\n \n    We take special care to reuse a vtable, if we can.  */\n+\n static void\n override_one_vtable (binfo, old, t)\n      tree binfo, old, t;\n@@ -2558,7 +2590,7 @@ override_one_vtable (binfo, old, t)\n   enum { REUSE_NEW, REUSE_OLD, UNDECIDED, NEITHER } choose = UNDECIDED;\n \n   /* If we have already committed to modifying it, then don't try and\n-     reuse another vtable. */\n+     reuse another vtable.  */\n   if (BINFO_NEW_VTABLE_MARKED (binfo))\n     choose = NEITHER;\n \n@@ -2573,10 +2605,10 @@ override_one_vtable (binfo, old, t)\n       old_fndecl = FNADDR_FROM_VTABLE_ENTRY (old_fndecl);\n       fndecl = TREE_OPERAND (fndecl, 0);\n       old_fndecl = TREE_OPERAND (old_fndecl, 0);\n-      /* First check to see if they are the same. */\n+      /* First check to see if they are the same.  */\n       if (DECL_ASSEMBLER_NAME (fndecl) == DECL_ASSEMBLER_NAME (old_fndecl))\n \t{\n-\t  /* No need to do anything. */\n+\t  /* No need to do anything.  */\n \t}\n       else if (strictly_overrides (fndecl, old_fndecl))\n \t{\n@@ -2631,23 +2663,23 @@ override_one_vtable (binfo, old, t)\n \t    fndecl = copy_node (fndecl);\n \t    copy_lang_decl (fndecl);\n \t    DECL_ABSTRACT_VIRTUAL_P (fndecl) = 1;\n-\t    /* Make sure we search for it later. */\n+\t    /* Make sure we search for it later.  */\n \t    if (! CLASSTYPE_ABSTRACT_VIRTUALS (t))\n \t      CLASSTYPE_ABSTRACT_VIRTUALS (t) = error_mark_node;\n \n \t    vfn = build1 (ADDR_EXPR, vfunc_ptr_type_node, fndecl);\n \t    TREE_CONSTANT (vfn) = 1;\n \t    \n \t    /* We can use integer_zero_node, as we will will core dump\n-\t       if this is used anyway. */\n+\t       if this is used anyway.  */\n \t    TREE_VALUE (virtuals) = build_vtable_entry (integer_zero_node, vfn);\n \t  }\n \t}\n       virtuals = TREE_CHAIN (virtuals);\n       old_virtuals = TREE_CHAIN (old_virtuals);\n     }\n \n-  /* Let's reuse the old vtable. */\n+  /* Let's reuse the old vtable.  */\n   if (choose == REUSE_OLD)\n     {\n       BINFO_VTABLE (binfo) = BINFO_VTABLE (old);\n@@ -2658,6 +2690,7 @@ override_one_vtable (binfo, old, t)\n /* Merge in overrides for virtual bases.\n    BINFO is the hierarchy we want to modify, and OLD has the potential\n    overrides.  */\n+\n static void\n merge_overrides (binfo, old, do_self, t)\n      tree binfo, old;\n@@ -2688,6 +2721,7 @@ merge_overrides (binfo, old, do_self, t)\n /* Get the base virtual function declarations in T that are either\n    overridden or hidden by FNDECL as a list.  We set TREE_PURPOSE with\n    the overrider/hider.  */\n+\n tree\n get_basefndecls (fndecl, t)\n      tree fndecl, t;\n@@ -2725,6 +2759,7 @@ get_basefndecls (fndecl, t)\n /* Mark the functions that have been hidden with their overriders.\n    Since we start out with all functions already marked with a hider,\n    no need to mark functions that are just hidden.  */\n+\n void\n mark_overriders (fndecl, base_fndecls)\n      tree fndecl, base_fndecls;\n@@ -2781,7 +2816,7 @@ check_for_override (decl, ctype)\n \t      virtualp = 1;\n \n \t      {\n-\t\t/* The argument types may have changed... */\n+\t\t/* The argument types may have changed...  */\n \t\ttree type = TREE_TYPE (decl);\n \t\ttree argtypes = TYPE_ARG_TYPES (type);\n \t\ttree base_variant = TREE_TYPE (TREE_VALUE (argtypes));\n@@ -2811,6 +2846,7 @@ check_for_override (decl, ctype)\n \n /* Warn about hidden virtual functions that are not overridden in t.\n    We know that constructors and destructors don't apply.  */\n+\n void\n warn_hidden (t)\n      tree t;\n@@ -2881,6 +2917,7 @@ warn_hidden (t)\n \n /* Check for things that are invalid.  There are probably plenty of other\n    things we should check for also.  */\n+\n static void\n finish_struct_anon (t)\n      tree t;\n@@ -3080,7 +3117,7 @@ finish_struct_1 (t, attributes, warn_anon)\n       fields = chainon (vf, fields);\n \n       first_vfn_base_index = finish_base_struct (t, &base_info, t_binfo);\n-      /* Remember where we got our vfield from. */\n+      /* Remember where we got our vfield from.  */\n       CLASSTYPE_VFIELD_PARENT (t) = first_vfn_base_index;\n       has_virtual = base_info.has_virtual;\n       max_has_virtual = base_info.max_has_virtual;\n@@ -3222,7 +3259,7 @@ finish_struct_1 (t, attributes, warn_anon)\n \tcontinue;\n \n       /* If we've gotten this far, it's a data member, possibly static,\n-\t or an enumerator. */\n+\t or an enumerator.  */\n \n       DECL_FIELD_CONTEXT (x) = t;\n \n@@ -3413,14 +3450,10 @@ finish_struct_1 (t, attributes, warn_anon)\n \t\t  cp_warning_at (\"`%D' is too small to hold all values of `%#T'\",\n \t\t\t\t x, TREE_TYPE (x));\n \t\t}\n-\t    }\n-\n-\t  /* Process valid field width.  */\n-\t  if (DECL_INITIAL (x))\n-\t    {\n-\t      register int width = TREE_INT_CST_LOW (DECL_INITIAL (x));\n \n-\t      if (width == 0)\n+\t      if (DECL_INITIAL (x) == NULL_TREE)\n+\t\t;\n+\t      else if (width == 0)\n \t\t{\n #ifdef EMPTY_FIELD_BOUNDARY\n \t\t  DECL_ALIGN (x) = MAX (DECL_ALIGN (x), EMPTY_FIELD_BOUNDARY);\n@@ -3547,7 +3580,7 @@ finish_struct_1 (t, attributes, warn_anon)\n \tTYPE_NEEDS_DESTRUCTOR (t) = 0;\n       else\n \t{\n-\t  /* Link dtor onto end of fn_fields. */\n+\t  /* Link dtor onto end of fn_fields.  */\n \n \t  TREE_CHAIN (dtor) = fn_fields;\n \t  fn_fields = dtor;\n@@ -3713,7 +3746,7 @@ finish_struct_1 (t, attributes, warn_anon)\n \t\t\t\t      ptr_type_node);\n       /* If you change any of the below, take a look at all the\n \t other VFIELD_BASEs and VTABLE_BASEs in the code, and change\n-\t them too. */\n+\t them too.  */\n       DECL_ASSEMBLER_NAME (vfield) = get_identifier (VFIELD_BASE);\n       CLASSTYPE_VFIELD (t) = vfield;\n       DECL_VIRTUAL_P (vfield) = 1;\n@@ -3806,7 +3839,7 @@ finish_struct_1 (t, attributes, warn_anon)\n       TYPE_MODE (pseudo_basetype) = TYPE_MODE (t);\n       TYPE_ALIGN (pseudo_basetype) = CLASSTYPE_ALIGN (t);\n       DECL_ALIGN (base_layout_decl) = TYPE_ALIGN (pseudo_basetype);\n-      /* Don't re-use old size. */\n+      /* Don't re-use old size.  */\n       DECL_SIZE (base_layout_decl) = NULL_TREE;\n     }\n \n@@ -4086,7 +4119,7 @@ finish_struct_1 (t, attributes, warn_anon)\n   if (CLASSTYPE_VSIZE (t) != 0)\n     {\n #if 0\n-      /* This is now done above. */\n+      /* This is now done above.  */\n       if (DECL_FIELD_CONTEXT (vfield) != t)\n \t{\n \t  tree binfo = get_binfo (DECL_FIELD_CONTEXT (vfield), t, 0);\n@@ -4105,7 +4138,7 @@ finish_struct_1 (t, attributes, warn_anon)\n \t}\n #endif\n \n-      /* In addition to this one, all the other vfields should be listed. */\n+      /* In addition to this one, all the other vfields should be listed.  */\n       /* Before that can be done, we have to have FIELD_DECLs for them, and\n \t a place to find them.  */\n       TYPE_NONCOPIED_PARTS (t) = build_tree_list (default_conversion (TYPE_BINFO_VTABLE (t)), vfield);\n@@ -4280,7 +4313,7 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \t      DECL_CLASS_CONTEXT (x) = t;\n \t      if (last_x)\n \t\tTREE_CHAIN (last_x) = TREE_CHAIN (x);\n-\t      /* Link x onto end of TYPE_METHODS. */\n+\t      /* Link x onto end of TYPE_METHODS.  */\n \t      *tail = x;\n \t      tail = &TREE_CHAIN (x);\n \t      continue;\n@@ -4380,6 +4413,7 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \n    *NONNULL is set iff INSTANCE can be known to be nonnull, regardless\n    of our knowledge of its type.  */\n+\n int\n resolves_to_fixed_type_p (instance, nonnull)\n      tree instance;\n@@ -4453,7 +4487,7 @@ resolves_to_fixed_type_p (instance, nonnull)\n \t    *nonnull = 1;\n \t  return 1;\n \t}\n-      /* fall through... */\n+      /* fall through...  */\n     case TARGET_EXPR:\n     case PARM_DECL:\n       if (IS_AGGR_TYPE (TREE_TYPE (instance)))\n@@ -4636,6 +4670,7 @@ pushclass (type, modify)\n    previously, that is the one popped to.  The flag MODIFY tells whether\n    the current scope declarations needs to be modified as a result of\n    popping to the previous scope.  0 is used for class definitions.  */\n+\n void\n popclass (modify)\n      int modify;\n@@ -4762,6 +4797,7 @@ push_lang_context (name)\n }\n   \n /* Get out of the current language scope.  */\n+\n void\n pop_lang_context ()\n {\n@@ -4789,6 +4825,7 @@ root_lang_context_p ()\n \n    This function is used in build_modify_expr, convert_arguments,\n    build_c_cast, and compute_conversion_costs.  */\n+\n tree\n instantiate_type (lhstype, rhs, complain)\n      tree lhstype, rhs;\n@@ -5230,6 +5267,7 @@ instantiate_type (lhstype, rhs, complain)\n    this may have to look back through base types to find the\n    ultimate field name.  (For single inheritance, these could\n    all be the same name.  Who knows for multiple inheritance).  */\n+\n static tree\n get_vfield_name (type)\n      tree type;"}, {"sha": "1c83d5beb7ac649cc686806437ebbe279f46aca9", "filename": "gcc/cp/class.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fclass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fclass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.h?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -80,7 +80,7 @@ struct candidate\n   int h_len;\t\t\t/* The length of the harshness vector.  */\n \n   tree function;\t\t/* A FUNCTION_DECL */\n-  tree basetypes;\t\t/* The path to function. */\n+  tree basetypes;\t\t/* The path to function.  */\n   tree arg;\t\t\t/* first parm to function.  */\n \n   /* Indexed by argument number, encodes evil, user, d_to_b, and easy"}, {"sha": "00c0fcdfab959a1200f2d1b8493dc0e62e13dbb0", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -242,12 +242,12 @@ extern int warn_cast_qual;\n \n extern int warn_traditional;\n \n-/* Warn about *printf or *scanf format/argument anomalies. */\n+/* Warn about *printf or *scanf format/argument anomalies.  */\n \n extern int warn_format;\n \n /* Nonzero means warn about non virtual destructors in classes that have\n-   virtual functions. */\n+   virtual functions.  */\n \n extern int warn_nonvdtor;\n \n@@ -276,7 +276,7 @@ extern int write_virtuals;\n \n /* True for more efficient but incompatible (not not fully tested)\n    vtable implementation (using thunks).\n-   0 is old behavior; 1 is new behavior. */\n+   0 is old behavior; 1 is new behavior.  */\n extern int flag_vtable_thunks;\n \n /* INTERFACE_ONLY nonzero means that we are in an \"interface\"\n@@ -313,7 +313,7 @@ extern int flag_default_inline;\n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n enum cplus_tree_code {\n   __DUMMY = LAST_AND_UNUSED_TREE_CODE,\n-#include \"tree.def\"\n+#include \"cp-tree.def\"\n   LAST_CPLUS_TREE_CODE\n };\n #undef DEFTREECODE\n@@ -697,7 +697,7 @@ struct lang_type\n    which our VFIELD is based, -1 otherwise.  If this class has no base\n    classes, this is not used.\n    In D : B1, B2, PARENT would be 0, if D's vtable came from B1,\n-   1, if D's vtable came from B2. */\n+   1, if D's vtable came from B2.  */\n #define CLASSTYPE_VFIELD_PARENT(NODE)\t(TYPE_LANG_SPECIFIC(NODE)->vfield_parent)\n \n /* Remove when done merging.  */\n@@ -916,7 +916,7 @@ struct lang_type\n    this type can raise.  */\n #define TYPE_RAISES_EXCEPTIONS(NODE) TYPE_NONCOPIED_PARTS (NODE)\n \n-/* The binding level associated with the namespace. */\n+/* The binding level associated with the namespace.  */\n #define NAMESPACE_LEVEL(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.level)\n \f\n struct lang_decl_flags\n@@ -1070,7 +1070,7 @@ struct lang_decl\n #endif\n \n /* In a VAR_DECL for a variable declared in a for statement,\n-   this is the shadowed (local) variable. */\n+   this is the shadowed (local) variable.  */\n #define DECL_SHADOWED_FOR_VAR(NODE) DECL_RESULT(NODE)\n \n /* Points back to the decl which caused this lang_decl to be allocated.  */\n@@ -1081,7 +1081,7 @@ struct lang_decl\n    squirreled away.  */\n #define DECL_PENDING_INLINE_INFO(NODE) (DECL_LANG_SPECIFIC(NODE)->pending_inline_info)\n \n-/* True if on the saved_inlines (see decl2.c) list. */\n+/* True if on the saved_inlines (see decl2.c) list.  */\n #define DECL_SAVED_INLINE(DECL) \\\n   (DECL_LANG_SPECIFIC(DECL)->decl_flags.saved_inline)\n \n@@ -1162,7 +1162,7 @@ struct lang_decl\n extern int flag_new_for_scope;\n \n /* This flag is true of a local VAR_DECL if it was declared in a for\n-   statement, but we are no longer in the scope of the for. */\n+   statement, but we are no longer in the scope of the for.  */\n #define DECL_DEAD_FOR_LOCAL(NODE) DECL_LANG_FLAG_7 (NODE)\n \n /* This flag is set on a VAR_DECL that is a DECL_DEAD_FOR_LOCAL\n@@ -1266,18 +1266,18 @@ extern int flag_new_for_scope;\n   (TYPE_HAS_ASSIGN_REF (NODE) && ! TYPE_HAS_COMPLEX_ASSIGN_REF (NODE))\n \n /* Nonzero for _TYPE node means that this type is a pointer to member\n-   function type. */\n+   function type.  */\n #define TYPE_PTRMEMFUNC_P(NODE) (TREE_CODE(NODE) == RECORD_TYPE && TYPE_LANG_SPECIFIC(NODE)->type_flags.ptrmemfunc_flag)\n #define TYPE_PTRMEMFUNC_FLAG(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.ptrmemfunc_flag)\n /* Get the POINTER_TYPE to the METHOD_TYPE associated with this\n    pointer to member function.  TYPE_PTRMEMFUNC_P _must_ be true,\n-   before using this macro. */\n+   before using this macro.  */\n #define TYPE_PTRMEMFUNC_FN_TYPE(NODE) (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (NODE)))))))\n /* These are use to manipulate the the canonical RECORD_TYPE from the\n-   hashed POINTER_TYPE, and can only be used on the POINTER_TYPE. */\n+   hashed POINTER_TYPE, and can only be used on the POINTER_TYPE.  */\n #define TYPE_GET_PTRMEMFUNC_TYPE(NODE) ((tree)TYPE_LANG_SPECIFIC(NODE))\n #define TYPE_SET_PTRMEMFUNC_TYPE(NODE, VALUE) (TYPE_LANG_SPECIFIC(NODE) = ((struct lang_type *)(void*)(VALUE)))\n-/* These are to get the delta2 and pfn fields from a TYPE_PTRMEMFUNC_P. */\n+/* These are to get the delta2 and pfn fields from a TYPE_PTRMEMFUNC_P.  */\n #define DELTA2_FROM_PTRMEMFUNC(NODE) (build_component_ref (build_component_ref ((NODE), pfn_or_delta2_identifier, NULL_TREE, 0), delta2_identifier, NULL_TREE, 0))\n #define PFN_FROM_PTRMEMFUNC(NODE) (build_component_ref (build_component_ref ((NODE), pfn_or_delta2_identifier, NULL_TREE, 0), pfn_identifier, NULL_TREE, 0))\n \n@@ -1352,8 +1352,7 @@ extern int flag_new_for_scope;\n      0=normal declaration, e.g. int min (int, int);\n      1=implicit template instantiation\n      2=explicit template specialization, e.g. int min<int> (int, int);\n-     3=explicit template instantiation, e.g. template int min<int> (int, int);\n- */\n+     3=explicit template instantiation, e.g. template int min<int> (int, int);  */\n #define DECL_USE_TEMPLATE(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.use_template)\n \n #define DECL_TEMPLATE_INSTANTIATION(NODE) (DECL_USE_TEMPLATE (NODE) & 1)\n@@ -1465,7 +1464,7 @@ extern char *get_directive_line                 STDIO_PROTO((FILE *));\n    and, if so, perhaps change them both back to their original type.  */\n extern tree shorten_compare                     PROTO((tree *, tree *, tree *, enum tree_code *));\n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR,\n-   or validate its data type for an `if' or `while' statement or ?..: exp. */\n+   or validate its data type for an `if' or `while' statement or ?..: exp.  */\n extern tree truthvalue_conversion               PROTO((tree));\n extern tree type_for_mode                       PROTO((enum machine_mode, int));\n extern tree type_for_size                       PROTO((unsigned, int));\n@@ -1506,7 +1505,7 @@ extern tree unknown_type_node;\n extern tree opaque_type_node, signature_type_node;\n \n /* Node for \"pointer to (virtual) function\".\n-   This may be distinct from ptr_type_node so gdb can distinguish them. */\n+   This may be distinct from ptr_type_node so gdb can distinguish them.  */\n #define vfunc_ptr_type_node \\\n   (flag_vtable_thunks ? vtable_entry_type : ptr_type_node)\n \n@@ -1736,7 +1735,7 @@ extern int current_function_parms_stored;\n    can have.  These are sensible combinations of {public,private,protected}\n    cross {virtual,non-virtual}.  */\n \n-/* in class.c. */\n+/* in class.c.  */\n extern tree access_default_node; /* 0 */\n extern tree access_public_node; /* 1 */\n extern tree access_protected_node; /* 2 */"}, {"sha": "8bc2470db5519dd0a35c5e48b90a87d7860258fe", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 541, "deletions": 144, "changes": 685, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -35,6 +35,8 @@ Boston, MA 02111-1307, USA.  */\n #undef NULL\n #define NULL (char *)0\n \n+tree build_user_type_conversion ();\n+\n /* Change of width--truncation and extension of integers or reals--\n    is represented with NOP_EXPR.  Proper functioning of many things\n    assumes that no other conversions can be NOP_EXPRs.\n@@ -61,6 +63,7 @@ Boston, MA 02111-1307, USA.  */\n    adjust the this pointer (the first argument) by offset, and then\n    goto the real address of the function given by REAL_ADDR that we\n    would like called.  What we return is the address of the thunk.  */\n+\n static tree\n build_thunk (offset, real_addr)\n      tree offset, real_addr;\n@@ -78,6 +81,7 @@ build_thunk (offset, real_addr)\n /* Convert a `pointer to member' (POINTER_TYPE to METHOD_TYPE) into\n    another `pointer to method'.  This may involved the creation of\n    a thunk to handle the this offset calculation.  */\n+\n static tree\n convert_fn_ptr (type, expr)\n      tree type, expr;\n@@ -95,7 +99,7 @@ convert_fn_ptr (type, expr)\n \t}\n       if (binfo == NULL_TREE)\n \t{\n-\t  /* ARM 4.8 restriction. */\n+\t  /* ARM 4.8 restriction.  */\n \t  error (\"invalid pointer to member conversion\");\n \t  return error_mark_node;\n \t}\n@@ -115,13 +119,36 @@ convert_fn_ptr (type, expr)\n      else convert blindly\n    else if converting class, pass off to build_type_conversion\n    else try C-style pointer conversion  */\n+\n static tree\n cp_convert_to_pointer (type, expr)\n      tree type, expr;\n {\n   register tree intype = TREE_TYPE (expr);\n   register enum tree_code form;\n \n+  if (IS_AGGR_TYPE (intype))\n+    {\n+      tree rval;\n+\n+      intype = complete_type (intype);\n+      if (TYPE_SIZE (intype) == NULL_TREE)\n+\t{\n+\t  cp_error (\"can't convert from incomplete type `%T' to `%T'\",\n+\t\t    intype, type);\n+\t  return error_mark_node;\n+\t}\n+\n+      rval = build_type_conversion (CONVERT_EXPR, type, expr, 1);\n+      if (rval)\n+\t{\n+\t  if (rval == error_mark_node)\n+\t    cp_error (\"conversion of `%E' from `%T' to `%T' is ambiguous\",\n+\t\t      expr, intype, type);\n+\t  return rval;\n+\t}\n+    }\n+\n   if (TYPE_PTRMEMFUNC_P (type))\n     type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n   if (TYPE_PTRMEMFUNC_P (intype))\n@@ -202,27 +229,6 @@ cp_convert_to_pointer (type, expr)\n       && (IS_SIGNATURE_POINTER (intype) || IS_SIGNATURE_REFERENCE (intype)))\n     return convert_to_pointer (type, build_optr_ref (expr));\n \n-  if (IS_AGGR_TYPE (intype))\n-    {\n-      tree rval;\n-\n-      if (TYPE_SIZE (complete_type (intype)) == NULL_TREE)\n-\t{\n-\t  cp_error (\"can't convert from incomplete type `%T' to `%T'\",\n-\t\t    intype, type);\n-\t  return error_mark_node;\n-\t}\n-\n-      rval = build_type_conversion (CONVERT_EXPR, type, expr, 1);\n-      if (rval)\n-\t{\n-\t  if (rval == error_mark_node)\n-\t    cp_error (\"conversion of `%E' from `%T' to `%T' is ambiguous\",\n-\t\t      expr, intype, type);\n-\t  return rval;\n-\t}\n-    }\n-\n   if (integer_zerop (expr))\n     {\n       if (type == TREE_TYPE (null_pointer_node))\n@@ -254,6 +260,7 @@ cp_convert_to_pointer (type, expr)\n /* Like convert, except permit conversions to take place which\n    are not normally allowed due to access restrictions\n    (such as conversion from sub-type to private super-type).  */\n+\n static tree\n convert_to_pointer_force (type, expr)\n      tree type, expr;\n@@ -327,6 +334,7 @@ convert_to_pointer_force (type, expr)\n    FLAGS controls how we manage access checking.\n    INDIRECT_BIND in FLAGS controls how any temporarys are generated.\n    CHECKCONST controls if we report error messages on const subversion.  */\n+\n static tree\n build_up_reference (type, arg, flags, checkconst)\n      tree type, arg;\n@@ -351,7 +359,7 @@ build_up_reference (type, arg, flags, checkconst)\n \treturn error_not_base_type (target_type, argtype);\n     }\n \n-  /* Pass along const and volatile down into the type. */\n+  /* Pass along const and volatile down into the type.  */\n   if (TYPE_READONLY (type) || TYPE_VOLATILE (type))\n     target_type = cp_build_type_variant (target_type, TYPE_READONLY (type),\n \t\t\t\t\tTYPE_VOLATILE (type));\n@@ -567,7 +575,7 @@ build_up_reference (type, arg, flags, checkconst)\n \t\t    build_up_reference (type, TREE_OPERAND (targ, 2),\n \t\t\t\t\tLOOKUP_PROTECT, checkconst));\n \n-      /* Undo the folding... */\n+      /* Undo the folding...  */\n     case MIN_EXPR:\n     case MAX_EXPR:\n       return build (COND_EXPR, type,\n@@ -646,7 +654,7 @@ build_up_reference (type, arg, flags, checkconst)\n \t  tree decl = TREE_OPERAND (arg, 0);\n \t  tree cleanup;\n \n-\t  if (! toplevel_bindings_p ())\n+\t  if (! toplevel_bindings_p () && ! DECL_RTL (decl))\n \t    {\n \t      expand_decl (decl);\n \t      cleanup = maybe_build_cleanup (decl);\n@@ -708,7 +716,12 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n     {\n       /* Look for a user-defined conversion to lvalue that we can use.  */\n \n+#ifdef NEW_OVER\n+      rval_as_conversion\n+\t= build_type_conversion (CONVERT_EXPR, reftype, expr, 1);\n+#else\n       rval_as_conversion = build_type_conversion (CONVERT_EXPR, type, expr, 1);\n+#endif\n \n       if (rval_as_conversion && rval_as_conversion != error_mark_node\n \t  && real_lvalue_p (rval_as_conversion))\n@@ -866,7 +879,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \n   if (rval)\n     {\n-      /* If we found a way to convert earlier, then use it. */\n+      /* If we found a way to convert earlier, then use it.  */\n       return rval;\n     }\n \n@@ -882,7 +895,8 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n }\n \n /* We are using a reference VAL for its value. Bash that reference all the\n-   way down to its lowest form. */\n+   way down to its lowest form.  */\n+\n tree\n convert_from_reference (val)\n      tree val;\n@@ -904,6 +918,7 @@ convert_from_reference (val)\n    MSGP is a pointer to a message that would be an appropriate error\n    string.  If MSGP is NULL, then we are not interested in reporting\n    errors.  */\n+\n tree\n convert_to_aggr (type, expr, msgp, protect)\n      tree type, expr;\n@@ -1083,6 +1098,7 @@ convert_to_aggr (type, expr, msgp, protect)\n    convert to.  This routine should eventually become\n    convert_to_pointer after all references to convert_to_pointer\n    are removed.  */\n+\n tree\n convert_pointer_to_real (binfo, expr)\n      tree binfo, expr;\n@@ -1149,6 +1165,7 @@ convert_pointer_to_real (binfo, expr)\n    is more than one instance of that type in the expr, the conversion is\n    ambiguous.  This routine should eventually go away, and all\n    callers should use convert_to_pointer_real.  */\n+\n tree\n convert_pointer_to (binfo, expr)\n      tree binfo, expr;\n@@ -1219,7 +1236,7 @@ cp_convert (type, expr, convtype, flags)\n   if (INTEGRAL_CODE_P (code))\n     {\n       tree intype = TREE_TYPE (e);\n-      /* enum = enum, enum = int, enum = float are all errors. */\n+      /* enum = enum, enum = int, enum = float are all errors.  */\n       if (flag_int_enum_equivalence == 0\n \t  && TREE_CODE (type) == ENUMERAL_TYPE\n \t  && ARITHMETIC_TYPE_P (intype)\n@@ -1390,6 +1407,7 @@ convert (type, expr)\n /* Like convert, except permit conversions to take place which\n    are not normally allowed due to access restrictions\n    (such as conversion from sub-type to private super-type).  */\n+\n tree\n convert_force (type, expr, convtype)\n      tree type;\n@@ -1416,14 +1434,15 @@ convert_force (type, expr, convtype)\n        || TYPE_PTRMEMFUNC_P (TREE_TYPE (e)))\n       && TYPE_PTRMEMFUNC_P (type))\n     {\n-      /* compatible pointer to member functions. */\n+      /* compatible pointer to member functions.  */\n       return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), e, 1);\n     }\n \n   return cp_convert (type, e, CONV_C_CAST|convtype, LOOKUP_NORMAL);\n }\n \n /* Subroutine of build_type_conversion.  */\n+\n static tree\n build_type_conversion_1 (xtype, basetype, expr, typename, for_sure)\n      tree xtype, basetype;\n@@ -1481,6 +1500,10 @@ build_type_conversion (code, xtype, expr, for_sure)\n      tree xtype, expr;\n      int for_sure;\n {\n+#ifdef NEW_OVER\n+  return build_user_type_conversion\n+    (xtype, expr, for_sure ? LOOKUP_NORMAL : 0);\n+#else\n   /* C++: check to see if we can convert this aggregate type\n      into the required type.  */\n   tree basetype;\n@@ -1537,6 +1560,7 @@ build_type_conversion (code, xtype, expr, for_sure)\n \t\t\t\t    DECL_NAME (winner), for_sure);\n \n   return NULL_TREE;\n+#endif\n }\n \n /* Convert the given EXPR to one of a group of types suitable for use in an\n@@ -1566,7 +1590,7 @@ build_expr_type_conversion (desires, expr, complain)\n \tif ((desires & WANT_NULL) && TREE_CODE (expr) == INTEGER_CST\n \t    && integer_zerop (expr))\n \t  return expr;\n-\t/* else fall through... */\n+\t/* else fall through...  */\n \n       case BOOLEAN_TYPE:\n \treturn (desires & WANT_INT) ? expr : NULL_TREE;\n@@ -1650,6 +1674,7 @@ build_expr_type_conversion (desires, expr, complain)\n    Return 1 on success, 0 on failure.\n \n    @@ What are the real semantics of this supposed to be??? */\n+\n int\n build_default_binary_type_conversion (code, arg1, arg2)\n      enum tree_code code;\n@@ -1773,7 +1798,8 @@ build_default_binary_type_conversion (code, arg1, arg2)\n   return 0;\n }\n \n-/* Implements integral promotion (4.1) and float->double promotion. */\n+/* Implements integral promotion (4.1) and float->double promotion.  */\n+\n tree\n type_promotes_to (type)\n      tree type;\n@@ -1823,8 +1849,42 @@ type_promotes_to (type)\n   return cp_build_type_variant (type, constp, volatilep);\n }\n \n-#if 0\n-/* Work in progress.  Ask jason before removing. */\n+#ifdef NEW_OVER\n+/* Work in progress.  Ask jason before removing.  */\n+\n+struct z_candidate {\n+  tree fn;\n+  tree convs;\n+  tree second_conv;\n+  int viable;\n+  tree basetype_path;\n+  tree template;\n+  struct z_candidate *next;\n+};\n+\n+#define EXACT_RANK 0\n+#define PROMO_RANK 1\n+#define STD_RANK 2\n+#define PBOOL_RANK 3\n+#define USER_RANK 4\n+#define ELLIPSIS_RANK 5\n+\n+#define ICS_RANK(NODE)\t\t\t\t\\\n+  (ICS_ELLIPSIS_FLAG (NODE) ? ELLIPSIS_RANK\t\\\n+   : ICS_USER_FLAG (NODE) ? USER_RANK\t\t\\\n+   : ICS_STD_RANK (NODE))\n+\n+#define ICS_STD_RANK(NODE) TREE_COMPLEXITY (NODE)\n+\n+#define ICS_USER_FLAG(NODE) TREE_LANG_FLAG_0 (NODE)\n+#define ICS_ELLIPSIS_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n+\n+#define USER_CONV_FN(NODE) TREE_OPERAND (NODE, 1)\n+\n+struct z_candidate * build_user_type_conversion_1 ();\n+tree convert_like ();\n+tree build_over_call ();\n+struct z_candidate * tourney ();\n \n int\n null_ptr_cst (t)\n@@ -1857,19 +1917,30 @@ build_conv (code, type, from)\n   return t;\n }\n \n+tree\n+non_reference (t)\n+     tree t;\n+{\n+  if (TREE_CODE (t) == REFERENCE_TYPE)\n+    t = TREE_TYPE (t);\n+  return t;\n+}\n+\n tree\n standard_conversion (to, from, expr)\n      tree to, from, expr;\n {\n-  enum tree_code fcode = TREE_CODE (from);\n-  enum tree_code tcode = TREE_CODE (to);\n+  enum tree_code fcode, tcode;\n   tree conv;\n \n-  if (from == to)\n-    return from;\n+  fcode = TREE_CODE (from);\n+  tcode = TREE_CODE (to);\n \n   conv = build1 (EXACT_CONV, from, expr);\n \n+  if (from == to)\n+    return conv;\n+\n   if (fcode == FUNCTION_TYPE)\n     {\n       from = build_pointer_type (from);\n@@ -1893,15 +1964,16 @@ standard_conversion (to, from, expr)\n       enum tree_code ufcode = TREE_CODE (TREE_TYPE (from));\n       enum tree_code utcode = TREE_CODE (TREE_TYPE (to));\n \n-      if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (from))),\n-\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (to))), 1))\n+      if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (from)),\n+\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (to)), 1))\n \t/* OK for now */;\n       else if (utcode == VOID_TYPE && ufcode != OFFSET_TYPE\n \t       && ufcode != FUNCTION_TYPE)\n \t{\n-\t  from = cp_build_type_variant (void_type_node,\n-\t\t\t\t\tTYPE_READONLY (TREE_TYPE (from)),\n-\t\t\t\t\tTYPE_VOLATILE (TREE_TYPE (from)));\n+\t  from = build_pointer_type\n+\t    (cp_build_type_variant (void_type_node,\n+\t\t\t\t    TYPE_READONLY (TREE_TYPE (from)),\n+\t\t\t\t    TYPE_VOLATILE (TREE_TYPE (from))));\n \t  conv = build_conv (PTR_CONV, from, conv);\n \t}\n       else if (ufcode == OFFSET_TYPE && utcode == OFFSET_TYPE)\n@@ -1915,6 +1987,7 @@ standard_conversion (to, from, expr)\n \t\t\t     1)))\n \t    {\n \t      from = build_offset_type (tbase, TREE_TYPE (TREE_TYPE (from)));\n+\t      from = build_pointer_type (from);\n \t      conv = build_conv (PMEM_CONV, from, conv);\n \t    }\n \t  else\n@@ -1928,6 +2001,7 @@ standard_conversion (to, from, expr)\n \t      from = cp_build_type_variant (TREE_TYPE (to),\n \t\t\t\t\t    TYPE_READONLY (TREE_TYPE (from)),\n \t\t\t\t\t    TYPE_VOLATILE (TREE_TYPE (from)));\n+\t      from = build_pointer_type (from);\n \t      conv = build_conv (PTR_CONV, from, conv);\n \t    }\n \t  else\n@@ -1936,8 +2010,11 @@ standard_conversion (to, from, expr)\n       else\n \treturn 0;\n \n-      if (! comptypes (from, to, 1) && comp_ptr_ttypes (to, from))\n+      if (! comptypes (from, to, 1))\n \t{\n+\t  if (! comp_ptr_ttypes (TREE_TYPE (to), TREE_TYPE (from)))\n+\t    return 0;\n+\n \t  from = to;\n \t  conv = build_conv (QUAL_CONV, from, conv);\n \t}\n@@ -1994,40 +2071,110 @@ standard_conversion (to, from, expr)\n   return conv;\n }\n \n+tree\n+reference_binding (to, from, expr)\n+     tree to, from, expr;\n+{\n+  tree conv;\n+  int lvalue = 1;\n+  \n+  to = TREE_TYPE (to);\n+\n+  if (TREE_CODE (from) == REFERENCE_TYPE)\n+    from = TREE_TYPE (from);\n+  else if (! expr || ! lvalue_p (expr))\n+    lvalue = 0;\n+\n+  if (lvalue\n+      && TYPE_READONLY (to) >= TYPE_READONLY (from)\n+      && TYPE_VOLATILE (to) >= TYPE_VOLATILE (from))\n+    {\n+      conv = build1 (EXACT_CONV, from, expr);\n+\n+      if (TYPE_MAIN_VARIANT (to) == TYPE_MAIN_VARIANT (from))\n+\tconv = build_conv (REF_BIND, to, conv);\n+      else if (IS_AGGR_TYPE (to) && IS_AGGR_TYPE (from)\n+\t       && DERIVED_FROM_P (to, from))\n+\t{\n+\t  conv = build_conv (REF_BIND, to, conv);\n+\t  ICS_STD_RANK (conv) = STD_RANK;\n+\t}\n+      else\n+\tconv = NULL_TREE;\n+    }\n+  else\n+    conv = NULL_TREE;\n+\n+  if (! conv && TYPE_READONLY (to) && ! TYPE_VOLATILE (to))\n+    {\n+      conv = standard_conversion\n+\t(TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from), expr);\n+      if (conv)\n+\tconv = build_conv (REF_BIND, to, conv);\n+    }\n+\n+  return conv;\n+}\n+\n tree\n implicit_conversion (to, from, expr, flags)\n      tree to, from, expr;\n      int flags;\n {\n-  tree t, conv = standard_conversion (to, from, expr);\n+  tree conv;\n   struct z_candidate *cand;\n \n-  if (conv || (flags & LOOKUP_NO_CONVERSION))\n-    return conv;\n-\n-  flags |= LOOKUP_NO_CONVERSION;\n-\n-  cand = build_user_type_conversion_1 (to, expr, flags);\n-  if (! cand)\n-    return NULL_TREE;\n+  if (TREE_CODE (to) == REFERENCE_TYPE)\n+    conv = reference_binding (to, from, expr);\n+  else\n+    conv = standard_conversion\n+      (TYPE_MAIN_VARIANT (non_reference (to)),\n+       TYPE_MAIN_VARIANT (non_reference (from)), expr);\n+\n+  if (conv)\n+    ;\n+  else if ((IS_AGGR_TYPE (non_reference (from))\n+\t    || IS_AGGR_TYPE (non_reference (to)))\n+\t   && (flags & LOOKUP_NO_CONVERSION) == 0)\n+    {\n+      cand = build_user_type_conversion_1 (to, expr, LOOKUP_NORMAL);\n+      if (cand)\n+\tconv = cand->second_conv;\n+      else if (TREE_CODE (to) == REFERENCE_TYPE\n+\t       && TYPE_READONLY (TREE_TYPE (to))\n+\t       && ! TYPE_VOLATILE (TREE_TYPE (to)))\n+\t{\n+\t  cand = build_user_type_conversion_1\n+\t    (TYPE_MAIN_VARIANT (TREE_TYPE (to)), expr, LOOKUP_NORMAL);\n+\t  if (cand)\n+\t    conv = build_conv (REF_BIND, TREE_TYPE (to), cand->second_conv);\n+\t}\n+    }\n \n-  return cand->second_conv;\n+  return conv;\n }\n \n struct z_candidate *\n add_function_candidate (candidates, fn, arglist, flags)\n      struct z_candidate *candidates;\n-     tree fn, args;\n+     tree fn, arglist;\n      int flags;\n {\n   tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-  int i, len = list_length (args);\n+  int i, len = list_length (arglist);\n   tree convs = make_tree_vec (len);\n   tree parmnode = parmlist;\n   tree argnode = arglist;\n   int viable = 1;\n   struct z_candidate *cand;\n \n+  if (DECL_CONSTRUCTOR_P (fn))\n+    {\n+      parmnode = TREE_CHAIN (parmnode);\n+      if (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n+\tparmnode = TREE_CHAIN (parmnode);\n+    }\n+\n   for (i = 0; i < len; ++i)\n     {\n       tree arg = TREE_VALUE (argnode);\n@@ -2046,32 +2193,99 @@ add_function_candidate (candidates, fn, arglist, flags)\n \n       TREE_VEC_ELT (convs, i) = t;\n       if (! t)\n-\t{\n-\t  viable = 0;\n-\t  break;\n-\t}\n+\tbreak;\n \n-      if (parm)\n-\tparm = TREE_CHAIN (parm);\n-      arg = TREE_CHAIN (arg);\n+      if (parmnode)\n+\tparmnode = TREE_CHAIN (parmnode);\n+      argnode = TREE_CHAIN (argnode);\n     }\n \n-  if (parmnode && parmnode != void_list_node)\n+  if (i < len)\n     viable = 0;\n \n+  for (; parmnode && parmnode != void_list_node;\n+       parmnode = TREE_CHAIN (parmnode))\n+    if (! TREE_PURPOSE (parmnode))\n+      {\n+\tviable = 0;\n+\tbreak;\n+      }\n+\n   cand = (struct z_candidate *) oballoc (sizeof (struct z_candidate));\n \n   cand->fn = fn;\n   cand->convs = convs;\n   cand->second_conv = NULL_TREE;\n   cand->viable = viable;\n-  cand->template = NULL_TREE;\n   cand->basetype_path = NULL_TREE;\n+  cand->template = NULL_TREE;\n   cand->next = candidates;\n \n   return cand;\n }\n \n+struct z_candidate *\n+add_template_candidate (candidates, tmpl, arglist, flags)\n+     struct z_candidate *candidates;\n+     tree tmpl, arglist;\n+     int flags;\n+{\n+  int ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (tmpl));\n+  tree *targs = (tree *) alloca (sizeof (tree) * ntparms);\n+  struct z_candidate *cand;\n+  int i, dummy; \n+  tree fn;\n+\n+  i = type_unification (DECL_TEMPLATE_PARMS (tmpl), targs,\n+\t\t\tTYPE_ARG_TYPES (TREE_TYPE (tmpl)),\n+\t\t\targlist, &dummy, 0);\n+  if (i != 0)\n+    return candidates;\n+\n+  fn = instantiate_template (tmpl, targs);\n+  if (fn == error_mark_node)\n+    return candidates;\n+\n+  cand = add_function_candidate (candidates, fn, arglist, flags);\n+  cand->template = DECL_TEMPLATE_INFO (fn);\n+  return cand;\n+}\n+\n+int\n+any_viable (cands)\n+     struct z_candidate *cands;\n+{\n+  for (; cands; cands = cands->next)\n+    if (cands->viable)\n+      return 1;\n+  return 0;\n+}\n+\n+struct z_candidate *\n+splice_viable (cands)\n+     struct z_candidate *cands;\n+{\n+  struct z_candidate **p = &cands;\n+\n+  for (; *p; )\n+    {\n+      if ((*p)->viable)\n+\tp = &((*p)->next);\n+      else\n+\t*p = (*p)->next;\n+    }\n+\n+  return cands;\n+}\n+\n+tree\n+build_this (obj)\n+     tree obj;\n+{\n+  /* Fix this to work on non-lvalues.  */\n+  return build_unary_op (ADDR_EXPR, obj, 0);\n+}\n+\n /* Returns the best overload candidate to perform the requested\n    conversion.  */\n \n@@ -2082,47 +2296,56 @@ build_user_type_conversion_1 (totype, expr, flags)\n {\n   struct z_candidate *candidates, *cand;\n   tree fromtype = TREE_TYPE (expr);\n-  tree ctors = NULL_TREE, convs = NULL_TREE, t;\n-  tree method_args;\n+  tree ctors = NULL_TREE, convs = NULL_TREE, *p;\n+  tree args;\n \n   if (IS_AGGR_TYPE (totype))\n     ctors = lookup_fnfields (TYPE_BINFO (totype), ctor_identifier, 0);\n   if (IS_AGGR_TYPE (fromtype))\n     convs = lookup_conversions (fromtype);\n \n+  candidates = 0;\n+  flags |= LOOKUP_NO_CONVERSION;\n+\n   if (ctors)\n-    ctors = TREE_VALUE (ctors);\n+    {\n+      ctors = TREE_VALUE (ctors);\n+      args = build_tree_list (NULL_TREE, expr);\n+    }\n   for (; ctors; ctors = DECL_CHAIN (ctors))\n     {\n-      candidates = add_ctor_candidate (candidates, ctors, expr, flags);\n+      candidates = add_function_candidate (candidates, ctors, args, flags);\n+      candidates->second_conv = build1 (EXACT_CONV, totype, NULL_TREE);\n       candidates->basetype_path = TYPE_BINFO (totype);\n     }\n \n-  method_args = build_tree_list\n-    (NULL_TREE, build_unary_op (ADDR_EXPR, expr, 0));\n+  if (convs)\n+    args = build_tree_list (NULL_TREE, build_this (expr));\n \n   for (; convs; convs = TREE_CHAIN (convs))\n     {\n       tree fn = TREE_VALUE (convs);\n-      tree ics = standard_conversion (totype, TREE_TYPE (TREE_TYPE (fn)), 0);\n+      tree ics = implicit_conversion\n+\t(totype, TREE_TYPE (TREE_TYPE (fn)), 0, LOOKUP_NO_CONVERSION);\n       if (ics)\n \t{\n-\t  candidates = add_function_candidate\n-\t    (candidates, fn, method_args, flags);\n-\t  candidates->second_ics = ics;\n+\t  candidates = add_function_candidate (candidates, fn, args, flags);\n+\t  candidates->second_conv = ics;\n \t  candidates->basetype_path = TREE_PURPOSE (convs);\n \t}\n     }\n \n   if (! any_viable (candidates))\n     {\n+#if 0\n       if (flags & LOOKUP_COMPLAIN)\n \t{\n \t  if (candidates && ! candidates->next)\n \t    /* say why this one won't work or try to be loose */;\n \t  else\n \t    cp_error (\"no viable candidates\");\n \t}\n+#endif\n \n       return 0;\n     }\n@@ -2132,15 +2355,21 @@ build_user_type_conversion_1 (totype, expr, flags)\n \n   if (cand == 0)\n     {\n+      /* For recursive overloading, we need to wait and only diagnose this\n+\t if we are chosen */\n       if (flags & LOOKUP_COMPLAIN)\n \tcp_error (\"ambiguous user-defined type conversion\");\n+\n+      return 0;\n     }\n \n-  for (t = cand->second_conv; TREE_CODE (TREE_OPERAND (t, 0)) != EXACT_MATCH; )\n-    t = TREE_OPERAND (t, 0);\n+  for (p = &(cand->second_conv); TREE_CODE (*p) != EXACT_CONV; )\n+    p = &(TREE_OPERAND (*p, 0));\n \n-  TREE_OPERAND (t, 0) = build\n-    (USER_CONV, TREE_TYPE (TREE_TYPE (cand->fn)),\n+  *p = build\n+    (USER_CONV,\n+     (DECL_CONSTRUCTOR_P (cand->fn)\n+      ? totype : non_reference (TREE_TYPE (TREE_TYPE (cand->fn)))),\n      NULL_TREE, cand->fn, cand->convs, cand->basetype_path);\n   ICS_USER_FLAG (cand->second_conv) = 1;\n \n@@ -2154,7 +2383,52 @@ build_user_type_conversion (totype, expr, flags)\n   struct z_candidate *cand\n     = build_user_type_conversion_1 (totype, expr, flags);\n \n-  return convert_like (cand->second_conv, expr);\n+  if (cand)\n+    return convert_like (cand->second_conv, expr);\n+  return NULL_TREE;\n+}\n+\n+tree\n+build_new_function_call (fn, args, obj)\n+     tree fn, args, obj;\n+{\n+  struct z_candidate *candidates = 0, *cand;\n+ \n+  if (obj == NULL_TREE && TREE_CODE (fn) == TREE_LIST)\n+    {\n+      tree t = TREE_VALUE (fn);\n+\n+      for (; t; t = DECL_CHAIN (t))\n+\t{\n+\t  if (TREE_CODE (t) == TEMPLATE_DECL)\n+\t    candidates = add_template_candidate\n+\t      (candidates, t, args, LOOKUP_NORMAL);\n+\t  else\n+\t    candidates = add_function_candidate\n+\t      (candidates, t, args, LOOKUP_NORMAL);\n+\t}\n+\n+      if (! any_viable (candidates))\n+\t{\n+\t  if (candidates && ! candidates->next)\n+\t    return build_function_call (candidates->fn, args);\n+\t  else\n+\t    cp_error (\"no viable candidates\");\n+\t  return error_mark_node;\n+\t}\n+      candidates = splice_viable (candidates);\n+      cand = tourney (candidates, NULL_TREE);\n+\n+      if (cand == 0)\n+\t{\n+\t  cp_error (\"ambiguous function call\");\n+\t  return error_mark_node;\n+\t}\n+\n+      return build_over_call (cand->fn, cand->convs, args, LOOKUP_NORMAL);\n+    }\n+\n+  return build_function_call (fn, args);\n }\n \n void\n@@ -2165,14 +2439,14 @@ enforce_access (basetype_path, function)\n \n   if (access == access_private_node)\n     {\n-      cp_error_at (\"%s `%+#D' is %s\", name_kind, function, \n+      cp_error_at (\"`%+#D' is %s\", function, \n \t\t   TREE_PRIVATE (function) ? \"private\"\n \t\t   : \"from private base class\");\n       error (\"within this context\");\n     }\n   else if (access == access_protected_node)\n     {\n-      cp_error_at (\"%s `%+#D' %s\", name_kind, function,\n+      cp_error_at (\"`%+#D' %s\", function,\n \t\t   TREE_PROTECTED (function) ? \"is protected\"\n \t\t   : \"has protected accessibility\");\n       error (\"within this context\");\n@@ -2183,61 +2457,177 @@ tree\n convert_like (convs, expr)\n      tree convs, expr;\n {\n-  tree previous;\n+  switch (TREE_CODE (convs))\n+    {\n+    case USER_CONV:\n+      {\n+\ttree fn = TREE_OPERAND (convs, 1);\n+\tenforce_access (TREE_OPERAND (convs, 3), fn);\n+\texpr = build_over_call\n+\t  (TREE_OPERAND (convs, 1), TREE_OPERAND (convs, 2),\n+\t   DECL_CONSTRUCTOR_P (fn) ? expr : build_this (expr), LOOKUP_NORMAL);\n+\t\n+\tif (IS_AGGR_TYPE (TREE_TYPE (convs)))\n+\t  expr = build_cplus_new (TREE_TYPE (convs), expr);\n+\n+\treturn expr;\n+      }\n+    case EXACT_CONV:\n+      return expr;\n+    case REF_BIND:\n+      expr = convert_like (TREE_OPERAND (convs, 0), expr);\n+      return convert_to_reference\n+\t(build_reference_type (TREE_TYPE (convs)), expr,\n+\t CONV_IMPLICIT, LOOKUP_NORMAL|LOOKUP_NO_CONVERSION, error_mark_node);\n+    }\n+  expr = convert_like (TREE_OPERAND (convs, 0), expr);\n+  return cp_convert (TREE_TYPE (convs), expr, CONV_IMPLICIT,\n+\t\t     LOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n+}\n+\n+tree\n+convert_default_arg (type, arg)\n+     tree type, arg;\n+{\n+  arg = break_out_target_exprs (arg);\n \n-  if (TREE_CODE (convs) == USER_CONV)\n+  if (TREE_CODE (arg) == CONSTRUCTOR)\n     {\n-      tree fn = TREE_OPERAND (convs, 1);\n-      enforce_access (TREE_OPERAND (convs, 3), fn);\n-      return build_over_call (TREE_OPERAND (convs, 1),\n-\t\t\t      TREE_OPERAND (convs, 2), expr, LOOKUP_NORMAL);\n+      arg = digest_init (type, arg, 0);\n+      arg = convert_for_initialization (0, type, arg, LOOKUP_NORMAL,\n+\t\t\t\t\t\"default argument\", 0, 0);\n+    }\n+  else\n+    {\n+      /* This could get clobbered by the following call.  */\n+      if (TREE_HAS_CONSTRUCTOR (arg))\n+\targ = copy_node (arg);\n+\n+      arg = convert_for_initialization (0, type, arg, LOOKUP_NORMAL,\n+\t\t\t\t\t\"default argument\", 0, 0);\n+#ifdef PROMOTE_PROTOTYPES\n+      if ((TREE_CODE (type) == INTEGER_TYPE\n+\t   || TREE_CODE (type) == ENUMERAL_TYPE)\n+\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n+\targ = default_conversion (arg);\n+#endif\n     }\n-  else if (TREE_CODE (convs) == EXACT_CONV)\n-    return expr;\n \n-  previous = convert_like (TREE_OPERAND (convs, 0), expr);\n-  return convert (TREE_TYPE (convs), expr);\n+  return arg;\n }\n \n tree\n build_over_call (fn, convs, args, flags)\n      tree fn, convs, args;\n      int flags;\n {\n-  tree converted_args;\n+  tree converted_args = NULL_TREE;\n   tree parm = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-  tree conv = convs;\n-  tree arg = args;\n+  tree conv, arg;\n+  int i;\n+\n+  if (TREE_CODE (args) != TREE_LIST)\n+    args = build_tree_list (NULL_TREE, args);\n+  arg = args;\n \n-  if (TREE_CODE (arg) != TREE_LIST)\n-    arg = build_tree_list (NULL_TREE, arg);\n+  if (DECL_CONSTRUCTOR_P (fn))\n+    {\n+      tree t = build_int_2 (0, 0);\n+      TREE_TYPE (t) = build_pointer_type (DECL_CONTEXT (fn));\n+      converted_args = tree_cons (NULL_TREE, t, converted_args);\n+      parm = TREE_CHAIN (parm);\n \n-  for (; arg;\n-       parm = TREE_CHAIN (parm), arg = TREE_CHAIN (arg),\n-       conv = TREE_CHAIN (conv))\n+      if (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n+\t{\n+\t  converted_args = tree_cons\n+\t    (NULL_TREE, integer_one_node, converted_args);\n+\t  parm = TREE_CHAIN (parm);\n+\t}\n+    }\n+  /* Bypass access control for 'this' parameter.  */\n+  else if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n+    {\n+      converted_args = tree_cons\n+\t(NULL_TREE, convert_force (TREE_VALUE (parm), TREE_VALUE (arg), CONV_C_CAST),\n+\t converted_args);\n+      parm = TREE_CHAIN (parm);\n+      arg = TREE_CHAIN (arg);\n+      conv = TREE_CHAIN (conv);\n+    }\n+\n+  for (i = 0; conv = TREE_VEC_ELT (convs, i), arg;\n+       parm = TREE_CHAIN (parm), arg = TREE_CHAIN (arg), ++i)\n     converted_args = tree_cons\n-      (NULL_TREE, convert_like (TREE_VALUE (conv), TREE_VALUE (arg)),\n+      (NULL_TREE, convert_like (conv, TREE_VALUE (arg)),\n        converted_args);\n \n-  for (; parm; parm = TREE_CHAIN (parm))\n+  for (; parm && parm != void_list_node; parm = TREE_CHAIN (parm))\n     converted_args = tree_cons\n       (NULL_TREE,\n-       convert_for_ellipsis (TREE_VALUE (parm), TREE_PURPOSE (parm)),\n+       convert_default_arg (TREE_VALUE (parm), TREE_PURPOSE (parm)),\n        converted_args);\n \n   converted_args = nreverse (converted_args);\n \n-  return build_x_call (fn, converted_args, flags);\n+  mark_used (fn);\n+  /* Is it a synthesized method that needs to be synthesized?  */\n+  if (DECL_ARTIFICIAL (fn) && ! DECL_INITIAL (fn)\n+      /* Kludge: don't synthesize for default args.  */\n+      && current_function_decl)\n+    synthesize_method (fn);\n+\n+  if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0)\n+    {\n+      tree t = build_pointer_type (TREE_TYPE (fn));\n+      fn = build_vfn_ref (&TREE_VALUE (converted_args),\n+\t\t\t  build_indirect_ref (TREE_VALUE (args), 0),\n+\t\t\t  DECL_VINDEX (fn));\n+      TREE_TYPE (fn) = t;\n+    }\n+  else if (DECL_INLINE (fn))\n+    fn = inline_conversion (fn);\n+  else\n+    fn = build_addr_func (fn);\n+\n+  return convert_from_reference\n+    (build_call (fn, TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))), converted_args));\n }\n \n-tree\n-build_x_call (fn, args, flags)\n-     tree fn, args;\n-     int flags;\n+/* Compare two implicit conversion sequences that differ only in their\n+   qualification conversion.  */\n+\n+int\n+compare_qual (ics1, ics2)\n+     tree ics1, ics2;\n {\n-  if (DECL_FUNCTION_MEMBER_P (fn))\n+  tree to1 = TREE_TYPE (ics1);\n+  tree to2 = TREE_TYPE (ics2);\n+\n+  if (TREE_CODE (ics1) != REF_BIND)\n     {\n+      to1 = TREE_TYPE (to1);\n+      to2 = TREE_TYPE (to2);\n+\n+      if (TREE_CODE (to1) == OFFSET_TYPE)\n+\t{\n+\t  to1 = TREE_TYPE (to1);\n+\t  to2 = TREE_TYPE (to2);\n+\t}\n     }\n+\n+  if (TYPE_READONLY (to1) >= TYPE_READONLY (to2)\n+      && TYPE_VOLATILE (to1) > TYPE_VOLATILE (to2))\n+    return -1;\n+  else if (TYPE_READONLY (to1) > TYPE_READONLY (to2)\n+\t   && TYPE_VOLATILE (to1) == TYPE_VOLATILE (to2))\n+    return -1;\n+  else if (TYPE_READONLY (to1) <= TYPE_READONLY (to2)\n+\t   && TYPE_VOLATILE (to1) < TYPE_VOLATILE (to2))\n+    return 1;\n+  else if (TYPE_READONLY (to1) < TYPE_READONLY (to2)\n+\t   && TYPE_VOLATILE (to1) == TYPE_VOLATILE (to2))\n+    return 1;\n+  return 0;\n }\n \n /* Compare two implicit conversion sequences according to the rules set out in\n@@ -2254,15 +2644,15 @@ compare_ics (ics1, ics2)\n   tree main1, main2;\n \n   if (ICS_RANK (ics1) > ICS_RANK (ics2))\n-    return 1;\n-  else if (ICS_RANK (ics1) < ICS_RANK (ics2))\n     return -1;\n+  else if (ICS_RANK (ics1) < ICS_RANK (ics2))\n+    return 1;\n \n   /* User-defined  conversion sequence U1 is a better conversion sequence\n      than another user-defined conversion sequence U2 if they contain the\n      same user-defined conversion operator or constructor and if the sec-\n      ond standard conversion sequence of U1 is  better  than  the  second\n-     standard conversion sequence of U2. */\n+     standard conversion sequence of U2.  */\n \n   if (ICS_RANK (ics1) == USER_RANK)\n     {\n@@ -2276,9 +2666,9 @@ compare_ics (ics1, ics2)\n       if (USER_CONV_FN (t1) != USER_CONV_FN (t2))\n \treturn 0;\n       else if (ICS_STD_RANK (ics1) > ICS_STD_RANK (ics2))\n-\treturn 1;\n-      else if (ICS_STD_RANK (ics1) < ICS_STD_RANK (ics2))\n \treturn -1;\n+      else if (ICS_STD_RANK (ics1) < ICS_STD_RANK (ics2))\n+\treturn 1;\n \n       /* else fall through */\n     }\n@@ -2302,6 +2692,19 @@ compare_ics (ics1, ics2)\n   if (TREE_CODE (main1) != TREE_CODE (main2))\n     return 0;\n \n+  if (TREE_CODE (main1) == EXACT_CONV\n+      && (TREE_CODE (TREE_TYPE (main1)) == POINTER_TYPE\n+\t  || TYPE_PTRMEMFUNC_P (TREE_TYPE (main1))))\n+    {\n+      if (TREE_TYPE (main1) == TREE_TYPE (main2))\n+\treturn compare_qual (ics1, ics2);\n+\n+      /* existing practice, not WP-endorsed: const char * -> const char *\n+\t is better than char * -> const char *.  (jason 6/29/96) */\n+      if (TREE_TYPE (ics1) == TREE_TYPE (ics2))\n+\treturn -compare_qual (main1, main2);\n+    }\n+\n   if (TREE_CODE (main1) == PTR_CONV || TREE_CODE (main1) == PMEM_CONV\n       || TREE_CODE (main1) == REF_BIND)\n     {\n@@ -2318,32 +2721,21 @@ compare_ics (ics1, ics2)\n \t yield types identical except for cv-qualifiers and S2 adds all the\n \t qualifiers that S1 adds (and in the same places) and S2  adds  yet\n \t more  cv-qualifiers  than  S1,  or the similar case with reference\n-\t binding15). */\n-      if (from1 == from2 && to1 == to2)\n+\t binding15).  */\n+      if (TREE_CODE (main1) == REF_BIND)\n \t{\n-\t  to1 = TREE_TYPE (TREE_TYPE (ics1));\n-\t  to2 = TREE_TYPE (TREE_TYPE (ics2));\n-\t  if (TYPE_READONLY (to1) >= TYPE_READONLY (to2)\n-\t      && TYPE_VOLATILE (to1) > TYPE_VOLATILE (to2))\n-\t    return 1;\n-\t  else if (TYPE_READONLY (to1) > TYPE_READONLY (to2)\n-\t\t   && TYPE_VOLATILE (to1) == TYPE_VOLATILE (to2))\n-\t    return 1;\n-\t  else if (TYPE_READONLY (to1) <= TYPE_READONLY (to2)\n-\t\t   && TYPE_VOLATILE (to1) < TYPE_VOLATILE (to2))\n-\t    return -1;\n-\t  else if (TYPE_READONLY (to1) < TYPE_READONLY (to2)\n-\t\t   && TYPE_VOLATILE (to1) == TYPE_VOLATILE (to2))\n-\t    return -1;\n-\t  return 0;\n+\t  if (TYPE_MAIN_VARIANT (to1) == TYPE_MAIN_VARIANT (to2))\n+\t    return compare_qual (ics1, ics2);\n \t}\n+      else if (from1 == from2 && to1 == to2)\n+\treturn compare_qual (ics1, ics2);\n \t\n       if (TYPE_PTRMEMFUNC_P (to1))\n \t{\n \t  to1 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (to1));\n \t  from1 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (from1));\n \t}\n-      else\n+      else if (TREE_CODE (main1) != REF_BIND)\n \t{\n \t  to1 = TREE_TYPE (to1);\n \t  from1 = TREE_TYPE (from1);\n@@ -2360,7 +2752,7 @@ compare_ics (ics1, ics2)\n \t  to2 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (to2));\n \t  from2 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (from2));\n \t}\n-      else\n+      else if (TREE_CODE (main2) != REF_BIND)\n \t{\n \t  to2 = TREE_TYPE (to2);\n \t  from2 = TREE_TYPE (from2);\n@@ -2377,13 +2769,16 @@ compare_ics (ics1, ics2)\n \n       distf = get_base_distance (from1, from2, 0, 0);\n       if (distf == -1)\n-\tdistf = -get_base_distance (from2, from1, 0, 0);\n-      if (distf == -1)\n-\treturn 0;\n+\t{\n+\t  distf = -get_base_distance (from2, from1, 0, 0);\n+\t  if (distf == 1)\n+\t    return 0;\n+\t}\n \n-      /* If class B is derived directly or indirectly from class  A,  conver-\n-\t sion  of  B*  to  A*  is  better than conversion of B* to void*, and\n-\t conversion of A* to void* is better than conversion of B* to void*. */\n+      /* If class B is derived directly or indirectly from class A,\n+\t conver- sion of B* to A* is better than conversion of B* to\n+\t void*, and conversion of A* to void* is better than\n+\t conversion of B* to void*.  */\n \n       if (TREE_CODE (to1) == VOID_TYPE && TREE_CODE (to2) == VOID_TYPE)\n \t{\n@@ -2407,9 +2802,11 @@ compare_ics (ics1, ics2)\n \n       distt = get_base_distance (to1, to2, 0, 0);\n       if (distt == -1)\n-\tdistt = -get_base_distance (to2, to1, 0, 0);\n-      if (distt == -1)\n-\treturn 0;\n+\t{\n+\t  distt = -get_base_distance (to2, to1, 0, 0);\n+\t  if (distt == 1)\n+\t    return 0;\n+\t}\n \n       /* --conversion of C* to B* is better than conversion of C* to A*, */\n       if (distf == 0)\n@@ -2482,10 +2879,10 @@ int joust (cand1, cand2)\n      sequence  from  the return type of F1 to the destination type (i.e.,\n      the type of the entity being initialized)  is  a  better  conversion\n      sequence  than the standard conversion sequence from the return type\n-     of F2 to the destination type. */\n+     of F2 to the destination type.  */\n \n-  if (cand1->second_ics)\n-    winner = compare_ics (cand1->second_ics, cand2->second_ics);\n+  if (cand1->second_conv)\n+    winner = compare_ics (cand1->second_conv, cand2->second_conv);\n \n   return winner;\n }"}, {"sha": "8d7502eb7ccfe1e893b10646eced67eb8cfbf4c6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 160, "deletions": 121, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -229,7 +229,7 @@ static tree int_ftype_cptr_cptr_sizet;\n tree vtable_entry_type;\n tree delta_type_node;\n #if 0\n-/* Old rtti stuff. */\n+/* Old rtti stuff.  */\n tree __baselist_desc_type_node;\n tree __i_desc_type_node, __m_desc_type_node;\n tree __t_desc_array_type, __i_desc_array_type, __m_desc_array_type;\n@@ -295,7 +295,7 @@ tree base_init_expr;\n    parameter for destructors.  */\n tree this_identifier, in_charge_identifier;\n tree ctor_identifier, dtor_identifier;\n-/* Used in pointer to member functions, in vtables, and in sigtables. */\n+/* Used in pointer to member functions, in vtables, and in sigtables.  */\n tree pfn_identifier, index_identifier, delta_identifier, delta2_identifier;\n tree pfn_or_delta2_identifier, tag_identifier;\n tree vt_off_identifier;\n@@ -438,7 +438,7 @@ extern int flag_no_nonansi_builtin;\n extern int flag_ansi;\n \n /* Nonzero if we want to support huge (> 2^(sizeof(short)*8-1) bytes)\n-   objects. */\n+   objects.  */\n extern int flag_huge_objects;\n \n /* Nonzero if we want to conserve space in the .o files.  We do this\n@@ -473,8 +473,13 @@ extern int spew_debug;\n    when entering another class scope (i.e. a cache miss).  */\n extern tree previous_class_values;\n \n+/* A expression of value 0 with the same precision as a sizetype\n+   node, but signed.  */\n+tree signed_size_zero_node;\n+\n \f\n /* Allocate a level of searching.  */\n+\n struct stack_level *\n push_decl_level (stack, obstack)\n      struct stack_level *stack;\n@@ -487,44 +492,41 @@ push_decl_level (stack, obstack)\n }\n \f\n /* For each binding contour we allocate a binding_level structure\n- * which records the names defined in that contour.\n- * Contours include:\n- *  0) the global one\n- *  1) one for each function definition,\n- *     where internal declarations of the parameters appear.\n- *  2) one for each compound statement,\n- *     to record its declarations.\n- *\n- * The current meaning of a name can be found by searching the levels from\n- * the current one out to the global one.\n- *\n- * Off to the side, may be the class_binding_level.  This exists\n- * only to catch class-local declarations.  It is otherwise\n- * nonexistent.\n- * \n- * Also there may be binding levels that catch cleanups that\n- * must be run when exceptions occur.\n- */\n+   which records the names defined in that contour.\n+   Contours include:\n+    0) the global one\n+    1) one for each function definition,\n+       where internal declarations of the parameters appear.\n+    2) one for each compound statement,\n+       to record its declarations.\n+\n+   The current meaning of a name can be found by searching the levels\n+   from the current one out to the global one.\n+\n+   Off to the side, may be the class_binding_level.  This exists only\n+   to catch class-local declarations.  It is otherwise nonexistent.\n+\n+   Also there may be binding levels that catch cleanups that must be\n+   run when exceptions occur.  */\n \n /* Note that the information in the `names' component of the global contour\n    is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */\n \n struct binding_level\n   {\n     /* A chain of _DECL nodes for all variables, constants, functions,\n-     * and typedef types.  These are in the reverse of the order supplied.\n-     */\n+       and typedef types.  These are in the reverse of the order\n+       supplied.  */\n     tree names;\n \n-    /* A list of structure, union and enum definitions,\n-     * for looking up tag names.\n-     * It is a chain of TREE_LIST nodes, each of whose TREE_PURPOSE is a name,\n-     * or NULL_TREE; and whose TREE_VALUE is a RECORD_TYPE, UNION_TYPE,\n-     * or ENUMERAL_TYPE node.\n-     *\n-     * C++: the TREE_VALUE nodes can be simple types for component_bindings.\n-     *\n-     */\n+    /* A list of structure, union and enum definitions, for looking up\n+       tag names.\n+       It is a chain of TREE_LIST nodes, each of whose TREE_PURPOSE is a name,\n+       or NULL_TREE; and whose TREE_VALUE is a RECORD_TYPE, UNION_TYPE,\n+       or ENUMERAL_TYPE node.\n+\n+       C++: the TREE_VALUE nodes can be simple types for\n+       component_bindings.  */\n     tree tags;\n \n     /* For each level, a list of shadowed outer-level local definitions\n@@ -557,7 +559,7 @@ struct binding_level\n \n     /* List of VAR_DECLS saved from a previous for statement.\n        These would be dead in ANSI-conforming code, but might\n-       be referenced in traditional code. */\n+       be referenced in traditional code.  */\n     tree dead_vars_from_for;\n \n     /* 1 for the level that holds the parameters of a function.\n@@ -586,7 +588,7 @@ struct binding_level\n     unsigned namespace_p : 1;\n \n     /* True if this level is that of a for-statement where we need to\n-       worry about ambiguous (traditional or ANSI) scope rules. */\n+       worry about ambiguous (traditional or ANSI) scope rules.  */\n     unsigned is_for_scope : 1;\n \n     /* Two bits left for this word.  */\n@@ -685,7 +687,7 @@ pop_binding_level ()\n \n   if (global_binding_level)\n     {\n-      /* cannot pop a level, if there are none left to pop. */\n+      /* cannot pop a level, if there are none left to pop.  */\n       if (current_binding_level == global_binding_level)\n \tmy_friendly_abort (123);\n     }\n@@ -729,7 +731,7 @@ suspend_binding_level ()\n \n   if (global_binding_level)\n     {\n-      /* cannot suspend a level, if there are none left to suspend. */\n+      /* cannot suspend a level, if there are none left to suspend.  */\n       if (current_binding_level == global_binding_level)\n \tmy_friendly_abort (123);\n     }\n@@ -764,7 +766,7 @@ resume_binding_level (b)\n   if (class_binding_level)\n     {\n #if 1\n-      /* These are here because we cannot deal with shadows yet. */\n+      /* These are here because we cannot deal with shadows yet.  */\n       sorry (\"cannot resume a namespace inside class\");\n       return;\n #else\n@@ -775,7 +777,7 @@ resume_binding_level (b)\n   else\n     {\n #if 1\n-      /* These are here because we cannot deal with shadows yet. */\n+      /* These are here because we cannot deal with shadows yet.  */\n       if (b->level_chain != current_binding_level)\n \t{\n \t  sorry (\"cannot resume a namespace inside a different namespace\");\n@@ -1096,7 +1098,7 @@ poplevel (keep, reverse, functionbody)\n \t}\n \n       /* Save declarations made in a 'for' statement so we can support pre-ANSI\n-\t 'for' scoping semantics. */\n+\t 'for' scoping semantics.  */\n \n       for (link = current_binding_level->shadowed; link; link = TREE_CHAIN (link))\n \t{\n@@ -1106,7 +1108,7 @@ poplevel (keep, reverse, functionbody)\n \t  if (decl && DECL_DEAD_FOR_LOCAL (decl))\n \t    {\n \t      /* In this case keep the dead for-decl visible,\n-\t\t but remember what (if anything) it shadowed. */\n+\t\t but remember what (if anything) it shadowed.  */\n \t      DECL_SHADOWED_FOR_VAR (decl) = TREE_VALUE (link);\n \t      TREE_CHAIN (decl) = outer->dead_vars_from_for;\n \t      outer->dead_vars_from_for = decl;\n@@ -1115,7 +1117,7 @@ poplevel (keep, reverse, functionbody)\n \t    IDENTIFIER_LOCAL_VALUE (id) = TREE_VALUE (link);\n \t}\n     }\n-  else /* Not special for scope. */\n+  else /* Not special for scope.  */\n     {\n       for (link = decls; link; link = TREE_CHAIN (link))\n \t{\n@@ -1152,7 +1154,7 @@ poplevel (keep, reverse, functionbody)\n \n \t In this case, we want remove the binding for i#3, restoring\n \t that of i#2.  Then we want to remove the binding for i#2,\n-\t and restore that of i#1. */\n+\t and restore that of i#1.  */\n \n       link = current_binding_level->dead_vars_from_for;\n       for (; link != NULL_TREE; link = TREE_CHAIN (link))\n@@ -1272,6 +1274,7 @@ poplevel (keep, reverse, functionbody)\n }\n \n /* Resume a binding level for a namespace.  */\n+\n void\n resume_level (b)\n      struct binding_level *b;\n@@ -1337,6 +1340,7 @@ insert_block (block)\n }\n \n /* Add BLOCK to the current list of blocks for this binding contour.  */\n+\n void\n add_block_current_level (block)\n      tree block;\n@@ -1356,6 +1360,7 @@ set_block (block)\n }\n \n /* Do a pushlevel for class declarations.  */\n+\n void\n pushlevel_class ()\n {\n@@ -1397,6 +1402,7 @@ pushlevel_class ()\n \n /* ...and a poplevel for class declarations.  FORCE is used to force\n    clearing out of CLASS_VALUEs after a class definition.  */\n+\n tree\n poplevel_class (force)\n      int force;\n@@ -1613,6 +1619,7 @@ extern char * first_global_object_name;\n \n /* Get a unique name for each call to this routine for unnamed namespaces.\n    Mostly copied from get_file_function_name.  */\n+\n static tree\n get_unique_name ()\n {\n@@ -1641,7 +1648,7 @@ get_unique_name ()\n #ifndef NO_DOLLAR_IN_LABEL\t/* this for `$'; unlikely, but... -- kr */\n \t       || *p == '$'\n #endif\n-#ifndef NO_DOT_IN_LABEL\t\t/* this for `.'; unlikely, but... */\n+#ifndef NO_DOT_IN_LABEL\t\t/* this for `.'; unlikely, but...  */\n \t       || *p == '.'\n #endif\n \t       || (*p >= 'A' && *p <= 'Z')\n@@ -1654,6 +1661,7 @@ get_unique_name ()\n \n /* Push into the scope of the NAME namespace.  If NAME is NULL_TREE, then we\n    select a name that is unique to this compilation unit.  */\n+\n void\n push_namespace (name)\n      tree name;\n@@ -1672,7 +1680,7 @@ push_namespace (name)\n   d = build_lang_decl (NAMESPACE_DECL, name, void_type_node);\n \n   /* Mark them as external, so redeclaration_error_message doesn't think\n-     they are duplicates. */\n+     they are duplicates.  */\n \n   DECL_EXTERNAL (d) = 1;\n   d = pushdecl (d);\n@@ -1687,7 +1695,7 @@ push_namespace (name)\n   else\n     resume_level (NAMESPACE_LEVEL (d));\n \n-  /* This code is just is bit old now... */ \n+  /* This code is just is bit old now...  */ \n   current_namespace = tree_cons (NULL_TREE, name, current_namespace);\n   buf = (char *) alloca (4 + (old_id ? IDENTIFIER_LENGTH (old_id) : 0)\n \t\t\t + IDENTIFIER_LENGTH (name));\n@@ -1697,14 +1705,15 @@ push_namespace (name)\n }\n \n /* Pop from the scope of the current namespace.  */\n+\n void\n pop_namespace ()\n {\n   extern tree current_namespace;\n   tree decls, link;\n   current_namespace = TREE_CHAIN (current_namespace);\n \n-  /* Just in case we get out of sync. */\n+  /* Just in case we get out of sync.  */\n   if (! namespace_bindings_p ())\n     poplevel (0, 0, 0);\n \n@@ -1765,7 +1774,7 @@ struct saved_scope {\n };\n static struct saved_scope *current_saved_scope;\n \n-tree\n+static tree\n store_bindings (names, old_bindings)\n      tree names, old_bindings;\n {\n@@ -1947,7 +1956,7 @@ pop_from_top_level ()\n    Note that the definition may really be just a forward reference.\n    In that case, the TYPE_SIZE will be a NULL_TREE.\n \n-   C++ gratuitously puts all these tags in the name space. */\n+   C++ gratuitously puts all these tags in the name space.  */\n \n /* When setting the IDENTIFIER_TYPE_VALUE field of an identifier ID,\n    record the shadowed value for this binding contour.  TYPE is\n@@ -1968,7 +1977,7 @@ set_identifier_type_value_with_scope (id, type, b)\n   SET_IDENTIFIER_TYPE_VALUE (id, type);\n }\n \n-/* As set_identifier_type_value_with_scope, but using inner_binding_level. */\n+/* As set_identifier_type_value_with_scope, but using inner_binding_level.  */\n \n void\n set_identifier_type_value (id, type)\n@@ -1981,6 +1990,7 @@ set_identifier_type_value (id, type)\n /* Pop off extraneous binding levels left over due to syntax errors.\n \n    We don't pop past namespaces, as they might be valid.  */\n+\n void\n pop_everything ()\n {\n@@ -2002,7 +2012,7 @@ pop_everything ()\n /* Push a tag name NAME for struct/class/union/enum type TYPE.\n    Normally put into into the inner-most non-tag-transparent scope,\n    but if GLOBALIZE is true, put it in the inner-most non-class scope.\n-   The latter is needed for implicit declarations. */\n+   The latter is needed for implicit declarations.  */\n \n void\n pushtag (name, type, globalize)\n@@ -2054,7 +2064,7 @@ pushtag (name, type, globalize)\n \t\t      /* Mark the TYPE_DECL node we created just above as an\n \t\t\t gratuitous one.  We need to do this so that dwarfout.c\n \t\t\t will understand that it is not supposed to output a\n-\t\t\t TAG_typedef DIE  for it. */\n+\t\t\t TAG_typedef DIE  for it.  */\n \t\t      DECL_IGNORED_P (d) = 1;\n \t\t    }\n #endif /* DWARF_DEBUGGING_INFO */\n@@ -2090,7 +2100,7 @@ pushtag (name, type, globalize)\n \t\t  /* Mark the TYPE_DECL node we created just above as an\n \t\t     gratuitous one.  We need to do this so that dwarfout.c\n \t\t     will understand that it is not supposed to output a\n-\t\t     TAG_typedef DIE  for it. */\n+\t\t     TAG_typedef DIE  for it.  */\n \t\t  DECL_IGNORED_P (d) = 1;\n \t\t}\n #endif /* DWARF_DEBUGGING_INFO */\n@@ -2142,10 +2152,12 @@ pushtag (name, type, globalize)\n }\n \n /* Counter used to create anonymous type names.  */\n+\n static int anon_cnt = 0;\n \n /* Return an IDENTIFIER which can be used as a name for\n    anonymous structs and unions.  */\n+\n tree\n make_anon_name ()\n {\n@@ -2157,6 +2169,7 @@ make_anon_name ()\n \n /* Clear the TREE_PURPOSE slot of tags which have anonymous typenames.\n    This keeps dbxout from getting confused.  */\n+\n void\n clear_anon_tags ()\n {\n@@ -2191,6 +2204,7 @@ clear_anon_tags ()\n    For C++, we must compare the parameter list so that `int' can match\n    `int&' in a parameter position, but `int&' is not confused with\n    `const int&'.  */\n+\n int\n decls_match (newdecl, olddecl)\n      tree newdecl, olddecl;\n@@ -2460,7 +2474,7 @@ duplicate_decls (newdecl, olddecl)\n \t{\n \t  /* The name of a class template may not be declared to refer to\n \t     any other template, class, function, object, namespace, value,\n-\t     or type in the same scope. */\n+\t     or type in the same scope.  */\n \t  if (TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)) == TYPE_DECL\n \t      || TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)\n \t    {\n@@ -2613,7 +2627,7 @@ duplicate_decls (newdecl, olddecl)\n      warn about it.  */\n   warn_extern_redeclared_static (newdecl, olddecl);\n \n-  /* We have committed to returning 1 at this point. */\n+  /* We have committed to returning 1 at this point.  */\n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n       /* Now that functions must hold information normally held\n@@ -2779,6 +2793,9 @@ duplicate_decls (newdecl, olddecl)\n \n   /* Merge the storage class information.  */\n   DECL_WEAK (newdecl) |= DECL_WEAK (olddecl);\n+#ifdef DECL_ONE_ONLY\n+  DECL_ONE_ONLY (newdecl) |= DECL_ONE_ONLY (olddecl);\n+#endif\n   TREE_PUBLIC (newdecl) = TREE_PUBLIC (olddecl);\n   TREE_STATIC (olddecl) = TREE_STATIC (newdecl) |= TREE_STATIC (olddecl);\n   if (! DECL_EXTERNAL (olddecl))\n@@ -2965,7 +2982,7 @@ pushdecl (x)\n     DECL_CONTEXT (x) = 0;\n \n   /* Type are looked up using the DECL_NAME, as that is what the rest of the\n-     compiler wants to use. */\n+     compiler wants to use.  */\n   if (TREE_CODE (x) == TYPE_DECL || TREE_CODE (x) == VAR_DECL\n       || TREE_CODE (x) == NAMESPACE_DECL)\n     name = DECL_NAME (x);\n@@ -2990,7 +3007,7 @@ pushdecl (x)\n \t{\n #if 0\n \t  /* This is turned off until I have time to do it right (bpk).  */\n-\t  /* With the code below that uses it... */\n+\t  /* With the code below that uses it...  */\n \t  file = DECL_SOURCE_FILE (t);\n \t  line = DECL_SOURCE_LINE (t);\n #endif\n@@ -2999,7 +3016,7 @@ pushdecl (x)\n \t      if (DECL_CONTEXT (t) == NULL_TREE)\n \t\tfatal (\"parse errors have confused me too much\");\n \n-\t      /* Check for duplicate params. */\n+\t      /* Check for duplicate params.  */\n \t      if (duplicate_decls (x, t))\n \t\treturn t;\n \t    }\n@@ -3348,6 +3365,7 @@ pushdecl_with_scope (x, level)\n \n /* Like pushdecl, only it places X in GLOBAL_BINDING_LEVEL,\n    if appropriate.  */\n+\n tree\n pushdecl_top_level (x)\n      tree x;\n@@ -3391,6 +3409,7 @@ pushdecl_top_level (x)\n \n /* Like push_overloaded_decl, only it places X in GLOBAL_BINDING_LEVEL,\n    if appropriate.  */\n+\n void\n push_overloaded_decl_top_level (x, forget)\n      tree x;\n@@ -3404,6 +3423,7 @@ push_overloaded_decl_top_level (x, forget)\n }\n \n /* Make the declaration of X appear in CLASS scope.  */\n+\n tree\n pushdecl_class_level (x)\n      tree x;\n@@ -3446,6 +3466,7 @@ pushdecl_class_level (x)\n /* This function is used to push the mangled decls for nested types into\n    the appropriate scope.  Previously pushdecl_top_level was used, but that\n    is incorrect for members of local classes.  */\n+\n void\n pushdecl_nonclass_level (x)\n      tree x;\n@@ -3465,6 +3486,7 @@ pushdecl_nonclass_level (x)\n \n /* Make the declaration(s) of X appear in CLASS scope\n    under the name NAME.  */\n+\n void\n push_class_level_binding (name, x)\n      tree name;\n@@ -3485,6 +3507,7 @@ push_class_level_binding (name, x)\n \n /* Tell caller how to interpret a TREE_LIST which contains\n    chains of FUNCTION_DECLS.  */\n+\n int\n overloaded_globals_p (list)\n      tree list;\n@@ -3513,6 +3536,7 @@ overloaded_globals_p (list)\n    The value returned may be a previous declaration if we guessed wrong\n    about what language DECL should belong to (C or C++).  Otherwise,\n    it's always DECL (and never something that's not a _DECL).  */\n+\n tree\n push_overloaded_decl (decl, forgettable)\n      tree decl;\n@@ -3945,6 +3969,7 @@ pop_switch ()\n \n /* Same, but for CASE labels.  If DECL is NULL_TREE, it's the default.  */\n /* XXX Note decl is never actually used. (bpk) */\n+\n void\n define_case_label (decl)\n      tree decl;\n@@ -4193,6 +4218,7 @@ lookup_tag_reverse (type, name)\n \n /* Given type TYPE which was not declared in C++ language context,\n    attempt to find a name by which it is referred.  */\n+\n tree\n typedecl_for_tag (tag)\n      tree tag;\n@@ -4220,6 +4246,7 @@ typedecl_for_tag (tag)\n \f\n /* Lookup TYPE in CONTEXT (a chain of nested types or a FUNCTION_DECL).\n    Return the type value, or NULL_TREE if not found.  */\n+\n static tree\n lookup_nested_type (type, context)\n      tree type;\n@@ -4260,6 +4287,7 @@ lookup_nested_type (type, context)\n }\n \n /* Look up NAME in the NAMESPACE.  */\n+\n tree\n lookup_namespace_name (namespace, name)\n      tree namespace, name;\n@@ -4374,7 +4402,7 @@ lookup_name_real (name, prefer_type, nonclass)\n \t    }\n \t  else if (! IS_AGGR_TYPE (type)\n \t\t   || TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n-\t    /* Someone else will give an error about this if needed. */\n+\t    /* Someone else will give an error about this if needed.  */\n \t    val = NULL_TREE;\n \t  else if (TYPE_BEING_DEFINED (type))\n \t    {\n@@ -4416,7 +4444,7 @@ lookup_name_real (name, prefer_type, nonclass)\n \t}\n #endif\n \n-      if (got_scope)\n+      if (got_scope || val)\n \tgoto done;\n \n       /* This special lookup only applies to types.  */\n@@ -4638,6 +4666,7 @@ record_builtin_type (rid_index, name, type)\n \n /* Push overloaded decl, in global scope, with one argument so it\n    can be used as a callback from define_function.  */\n+\n static void\n push_overloaded_decl_1 (x)\n      tree x;\n@@ -4705,13 +4734,13 @@ init_decl_processing ()\n \n   /* Because most segmentation signals can be traced back into user\n      code, catch them and at least give the user a chance of working\n-     around compiler bugs. */\n+     around compiler bugs.  */\n   signal (SIGSEGV, signal_catch);\n \n   /* We will also catch aborts in the back-end through signal_catch and\n      give the user a chance to see where the error might be, and to defeat\n      aborts in the back-end when there have been errors previously in their\n-     code. */\n+     code.  */\n #ifdef SIGIOT\n   signal (SIGIOT, signal_catch);\n #endif\n@@ -4876,6 +4905,9 @@ init_decl_processing ()\n   size_zero_node = size_int (0);\n   size_one_node = size_int (1);\n \n+  signed_size_zero_node = build_int_2 (0, 0);\n+  TREE_TYPE (signed_size_zero_node) = make_signed_type (TYPE_PRECISION (sizetype));\n+\n   void_type_node = make_node (VOID_TYPE);\n   record_builtin_type (RID_VOID, NULL_PTR, void_type_node);\n   layout_type (void_type_node); /* Uses integer_zero_node.  */\n@@ -5205,7 +5237,7 @@ init_decl_processing ()\n   TYPE_MODE (unknown_type_node) = TYPE_MODE (void_type_node);\n   /* Indirecting an UNKNOWN_TYPE node yields an UNKNOWN_TYPE node.  */\n   TREE_TYPE (unknown_type_node) = unknown_type_node;\n-  /* Looking up TYPE_POINTER_TO and TYPE_REFERENCE_TO yield the same result. */\n+  /* Looking up TYPE_POINTER_TO and TYPE_REFERENCE_TO yield the same result.  */\n   TYPE_POINTER_TO (unknown_type_node) = unknown_type_node;\n   TYPE_REFERENCE_TO (unknown_type_node) = unknown_type_node;\n \n@@ -5214,7 +5246,7 @@ init_decl_processing ()\n   TYPE_MAIN_VARIANT (opaque_type_node) = opaque_type_node;\n   record_builtin_type (RID_MAX, 0, opaque_type_node);\n \n-  /* This is special for C++ so functions can be overloaded. */\n+  /* This is special for C++ so functions can be overloaded.  */\n   wchar_type_node\n     = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (WCHAR_TYPE)));\n   wchar_type_size = TYPE_PRECISION (wchar_type_node);\n@@ -5478,7 +5510,7 @@ init_decl_processing ()\n   init_function_format_info ();\n }\n \n-/* initialize type descriptor type node of various rtti type. */\n+/* initialize type descriptor type node of various rtti type.  */\n \n int\n init_type_desc()\n@@ -5737,7 +5769,7 @@ start_decl (declarator, declspecs, initialized, raises)\n   int init_written = initialized;\n #endif\n \n-  /* This should only be done once on the top most decl. */\n+  /* This should only be done once on the top most decl.  */\n   if (have_extern_spec && !used_extern_spec)\n     {\n       declspecs = decl_tree_cons (NULL_TREE, get_identifier (\"extern\"),\n@@ -6017,8 +6049,10 @@ start_decl_1 (decl)\n \n /* Handle initialization of references.\n    These three arguments from from `cp_finish_decl', and have the\n-   same meaning here that they do there.  */\n-/* quotes on semantics can be found in ARM 8.4.3. */\n+   same meaning here that they do there.\n+\n+   Quotes on semantics can be found in ARM 8.4.3.  */\n+\n static void\n grok_reference_init (decl, type, init, cleanupp)\n      tree decl, type, init;\n@@ -6661,7 +6695,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t\t current_binding_level.\n \n \t\t Otherwise, we need to preserve the temp slot for decl\n-\t\t to last into the outer binding level. */\n+\t\t to last into the outer binding level.  */\n \n \t      int handling_dead_for_vars = 0;\n \t      tree link = outer->names;\n@@ -6792,6 +6826,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n }\n \n /* This is here for a midend callback from c-common.c */\n+\n void\n finish_decl (decl, init, asmspec_tree)\n      tree decl, init;\n@@ -6822,7 +6857,7 @@ expand_static_init (decl, init)\n       tree old_cleanups;\n       int old_temp_level;\n \n-      /* Remember this information until end of file. */\n+      /* Remember this information until end of file.  */\n       push_obstacks (&permanent_obstack, &permanent_obstack);\n \n       /* Emit code to perform this initialization but once.  */\n@@ -6859,7 +6894,7 @@ expand_static_init (decl, init)\n \t  if (Atexit == 0)\n \t    {\n \t      tree atexit_fndecl, PFV, pfvlist;\n-\t      /* Remember this information until end of file. */\n+\t      /* Remember this information until end of file.  */\n \t      push_obstacks (&permanent_obstack, &permanent_obstack);\n \t      PFV = build_pointer_type (build_function_type\n \t\t\t\t\t(void_type_node, void_list_node));\n@@ -6894,7 +6929,7 @@ expand_static_init (decl, init)\n \t  TREE_STATIC (static_aggregates) = 1;\n \t}\n \n-      /* Resume old (possibly temporary) allocation. */\n+      /* Resume old (possibly temporary) allocation.  */\n       pop_obstacks ();\n     }\n   else\n@@ -6993,6 +7028,7 @@ complete_array_type (type, initial_value, do_default)\n /* Return zero if something is declared to be a member of type\n    CTYPE when in the context of CUR_TYPE.  STRING is the error\n    message to print in that case.  Otherwise, quietly return 1.  */\n+\n static int\n member_function_or_else (ctype, cur_type, string)\n      tree ctype, cur_type;\n@@ -7010,6 +7046,7 @@ member_function_or_else (ctype, cur_type, string)\n \n /* Generate errors possibly applicable for a given set of specifiers.\n    This is for ARM $7.1.2.  */\n+\n static void\n bad_specifiers (object, type, virtualp, quals, inlinep, friendp, raises)\n      tree object;\n@@ -7040,6 +7077,7 @@ bad_specifiers (object, type, virtualp, quals, inlinep, friendp, raises)\n    RAISES is a list of exceptions that this function can raise.\n    CHECK is 1 if we must find this method in CTYPE, 0 if we should\n    not look, and -1 if we should not call `grokclassfn' at all.  */\n+\n static tree\n grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n \t    raises, attrlist, check, publicp, inlinep, funcdef_flag)\n@@ -7285,7 +7323,7 @@ grokvardecl (type, declarator, specbits, initialized, constp)\n   return decl;\n }\n \n-/* Create a canonical pointer to member function type. */\n+/* Create a canonical pointer to member function type.  */\n \n tree\n build_ptrmemfunc_type (type)\n@@ -7314,7 +7352,7 @@ build_ptrmemfunc_type (type)\n \n   t = make_lang_type (RECORD_TYPE);\n \n-  /* Let the front-end know this is a pointer to member function. */\n+  /* Let the front-end know this is a pointer to member function.  */\n   TYPE_PTRMEMFUNC_FLAG (t) = 1;\n   /* and not really an aggregate.  */\n   IS_AGGR_TYPE (t) = 0;\n@@ -7334,7 +7372,7 @@ build_ptrmemfunc_type (type)\n \n   TYPE_SET_PTRMEMFUNC_TYPE (type, t);\n \n-  /* Seems to be wanted. */\n+  /* Seems to be wanted.  */\n   CLASSTYPE_GOT_SEMICOLON (t) = 1;\n   return t;\n }\n@@ -7666,7 +7704,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t    dname = DECL_NAME (decl);\n \t    name = IDENTIFIER_POINTER (dname);\n \n-\t    /* Avoid giving two errors for this. */\n+\t    /* Avoid giving two errors for this.  */\n \t    IDENTIFIER_CLASS_VALUE (dname) = NULL_TREE;\n \n \t    declspecs = temp_tree_cons (NULL_TREE, integer_type_node,\n@@ -7775,7 +7813,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t\t}\n \t      goto found;\n \t    }\n-\t  /* C++ aggregate types. */\n+\t  /* C++ aggregate types.  */\n \t  if (IDENTIFIER_HAS_TYPE_VALUE (id))\n \t    {\n \t      if (type)\n@@ -7805,7 +7843,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t\t}\n \t    }\n \t}\n-      /* C++ aggregate types. */\n+      /* C++ aggregate types.  */\n       else if (TREE_CODE (id) == TYPE_DECL)\n \t{\n \t  if (type)\n@@ -8515,7 +8553,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t\t\t  return void_type_node;\n \t\t      }\n \t\t  }\n-\t\telse            /* it's a constructor. */\n+\t\telse            /* it's a constructor.  */\n \t\t  {\n \t\t    if (explicitp == 1)\n \t\t      explicitp = 2;\n@@ -9128,7 +9166,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \n \tif (TREE_CODE (type) == ARRAY_TYPE)\n \t  {\n-\t    /* Transfer const-ness of array into that of type pointed to. */\n+\t    /* Transfer const-ness of array into that of type pointed to.  */\n \t    type = build_pointer_type\n \t      (cp_build_type_variant (TREE_TYPE (type), constp, volatilep));\n \t    volatilep = constp = 0;\n@@ -9484,7 +9522,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \n \t    if (TREE_CODE (type) == ARRAY_TYPE)\n \t      {\n-\t\t/* Transfer const-ness of array into that of type pointed to. */\n+\t\t/* Transfer const-ness of array into that of type\n+                   pointed to.  */\n \t\ttype = build_pointer_type\n \t\t  (cp_build_type_variant (TREE_TYPE (type), constp, volatilep));\n \t\tvolatilep = constp = 0;\n@@ -9558,6 +9597,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n    An empty exprlist is a parmlist.  An exprlist which\n    contains only identifiers at the global level\n    is a parmlist.  Otherwise, it is an exprlist.  */\n+\n int\n parmlist_is_exprlist (exprs)\n      tree exprs;\n@@ -9584,6 +9624,7 @@ parmlist_is_exprlist (exprs)\n    be complete.\n \n    C++: also subroutine of `start_function'.  */\n+\n static void\n require_complete_types_for_parms (parms)\n      tree parms;\n@@ -9811,7 +9852,7 @@ grokparms (first_parm, funcdef_flag)\n \t\t\t\t argument expressions.'' dpANSI C++ 8.2.6 */\n \t\t\t      /* If extern int i; within a function is not\n \t\t\t\t considered a local variable, then this code is\n-\t\t\t\t wrong. */\n+\t\t\t\t wrong.  */\n \t\t\t      cp_error (\"local variable `%D' may not be used as a default argument\", init);\n \t\t\t      any_error = 1;\n \t\t\t    }\n@@ -9879,6 +9920,7 @@ grokparms (first_parm, funcdef_flag)\n    `grok_op_properties' takes notice of the various forms of\n    operator= which are defined, as well as what sorts of type conversion\n    may apply.  Both functions take a FUNCTION_DECL as an argument.  */\n+\n int\n grok_ctor_properties (ctype, decl)\n      tree ctype, decl;\n@@ -9934,6 +9976,7 @@ grok_ctor_properties (ctype, decl)\n }\n \n /* An operator with this name can be either unary or binary.  */\n+\n static int\n ambi_op_p (name)\n      tree name;\n@@ -9947,6 +9990,7 @@ ambi_op_p (name)\n }\n \n /* An operator with this name can only be unary.  */\n+\n static int\n unary_op_p (name)\n      tree name;\n@@ -9958,6 +10002,7 @@ unary_op_p (name)\n }\n \n /* Do a little sanity-checking on how they declared their operator.  */\n+\n void\n grok_op_properties (decl, virtualp, friendp)\n      tree decl;\n@@ -10256,9 +10301,11 @@ xref_tag (code_type_node, name, binfo, globalize)\n       if (t && TYPE_CONTEXT (t) && got_type)\n \tref = t;\n       else\n-\t/* If we know we are defining this tag, only look it up in this scope\n-\t * and don't try to find it as a type. */\n-      \tref = lookup_tag (code, name, b, 1);\n+\t{\n+\t  /* If we know we are defining this tag, only look it up in\n+\t     this scope and don't try to find it as a type.  */\n+\t  ref = lookup_tag (code, name, b, 1);\n+\t}\n     }\n   else\n     {\n@@ -10565,9 +10612,8 @@ start_enum (name)\n \n   current_local_enum = NULL_TREE;\n \n-  /* We copy this value because enumerated type constants\n-     are really of the type of the enumerator, not integer_type_node.  */\n-  enum_next_value = copy_node (integer_zero_node);\n+  /* We don't copy this value because build_enumerator needs to do it.  */\n+  enum_next_value = integer_zero_node;\n   enum_overflow = 0;\n \n   GNU_xref_decl (current_function_decl, enumtype);\n@@ -10684,8 +10730,6 @@ build_enumerator (name, value)\n      tree name, value;\n {\n   tree decl, result;\n-  /* Change this to zero if we find VALUE is not shareable.  */\n-  int shareable = 1;\n \n   /* Remove no-op casts from the value.  */\n   if (value)\n@@ -10697,10 +10741,7 @@ build_enumerator (name, value)\n      if (value != NULL_TREE)\n        {\n \t if (TREE_READONLY_DECL_P (value))\n-\t   {\n-\t     value = decl_constant_value (value);\n-\t     shareable = 0;\n-\t   }\n+\t   value = decl_constant_value (value);\n \n \t if (TREE_CODE (value) == INTEGER_CST)\n \t   {\n@@ -10714,9 +10755,6 @@ build_enumerator (name, value)\n \t   }\n        }\n \n-     /* The order of things is reversed here so that we\n-\tcan check for possible sharing of enum values,\n-\tto keep that from happening.  */\n      /* Default based on previous value.  */\n      if (value == NULL_TREE && ! current_template_parms)\n        {\n@@ -10729,18 +10767,10 @@ build_enumerator (name, value)\n      if (value)\n        STRIP_TYPE_NOPS (value);\n \n-     /* Make up for hacks in lex.c.  */\n-     if (value == integer_zero_node)\n-       value = build_int_2 (0, 0);\n-     else if (value == integer_one_node)\n-       value = build_int_2 (1, 0);\n-     else if (TREE_CODE (value) == INTEGER_CST\n-\t      && (shareable == 0\n-\t\t  || TREE_CODE (TREE_TYPE (value)) == ENUMERAL_TYPE))\n-       {\n-\t value = copy_node (value);\n-\t TREE_TYPE (value) = integer_type_node;\n-       }\n+     /* We have to always copy here; not all INTEGER_CSTs are unshared,\n+\tand there's no wedding ring. Look at size_int()...*/\n+     value = copy_node (value);\n+     TREE_TYPE (value) = integer_type_node;\n    }\n \n   /* C++ associates enums with global, function, or class declarations.  */\n@@ -10774,9 +10804,6 @@ build_enumerator (name, value)\n      enum_next_value = build_binary_op_nodefault (PLUS_EXPR, value,\n \t\t\t\t\t\t  integer_one_node, PLUS_EXPR);\n      enum_overflow = tree_int_cst_lt (enum_next_value, value);\n-\n-     if (enum_next_value == integer_one_node)\n-       enum_next_value = copy_node (enum_next_value);\n    }\n \n   result = saveable_tree_cons (name, decl, NULL_TREE);\n@@ -10849,7 +10876,7 @@ start_function (declspecs, declarator, raises, attrs, pre_parsed_p)\n   my_friendly_assert (TREE_VALUE (void_list_node) == void_type_node, 160);\n   my_friendly_assert (TREE_CHAIN (void_list_node) == NULL_TREE, 161);\n \n-  /* Assume, until we see it does. */\n+  /* Assume, until we see it does.  */\n   current_function_returns_value = 0;\n   current_function_returns_null = 0;\n   warn_about_return_type = 0;\n@@ -10867,7 +10894,7 @@ start_function (declspecs, declarator, raises, attrs, pre_parsed_p)\n \n   clear_temp_name ();\n \n-  /* This should only be done once on the top most decl. */\n+  /* This should only be done once on the top most decl.  */\n   if (have_extern_spec && !used_extern_spec)\n     {\n       declspecs = decl_tree_cons (NULL_TREE, get_identifier (\"extern\"), declspecs);\n@@ -11386,6 +11413,7 @@ store_parm_decls ()\n \n /* Bind a name and initialization to the return value of\n    the current function.  */\n+\n void\n store_return_init (return_id, init)\n      tree return_id, init;\n@@ -11450,7 +11478,10 @@ store_return_init (return_id, init)\n    C++: CALL_POPLEVEL is non-zero if an extra call to poplevel\n    (and expand_end_bindings) must be made to take care of the binding\n    contour for the base initializers.  This is only relevant for\n-   constructors.  */\n+   constructors.\n+\n+   NESTED is nonzero if we were in the middle of compiling another function\n+   when we started on this one.  */\n \n void\n finish_function (lineno, call_poplevel, nested)\n@@ -11470,6 +11501,9 @@ finish_function (lineno, call_poplevel, nested)\n   if (fndecl == NULL_TREE)\n     return;\n \n+  if (! nested && function_depth > 1)\n+    nested = 1;\n+\n   fntype = TREE_TYPE (fndecl);\n \n /*  TREE_READONLY (fndecl) = 1;\n@@ -11567,10 +11601,10 @@ finish_function (lineno, call_poplevel, nested)\n \t  if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type)\n \t      || TYPE_GETS_REG_DELETE (current_class_type))\n \t    exprstmt = build_delete (current_class_type, current_class_ref, integer_zero_node,\n-\t\t\t\t     LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n+\t\t\t\t     LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR|LOOKUP_NORMAL, 0);\n \t  else\n \t    exprstmt = build_delete (current_class_type, current_class_ref, in_charge_node,\n-\t\t\t\t     LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n+\t\t\t\t     LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR|LOOKUP_NORMAL, 0);\n \n \t  /* If we did not assign to this, then `this' is non-zero at\n \t     the end of a destructor.  As a special optimization, don't\n@@ -11602,9 +11636,13 @@ finish_function (lineno, call_poplevel, nested)\n \t\t      if (TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (vbases)))\n \t\t\t{\n \t\t\t  tree ptr = convert_pointer_to_vbase (BINFO_TYPE (vbases), current_class_ptr);\n-\t\t\t  expand_expr_stmt (build_delete (build_pointer_type (BINFO_TYPE (vbases)),\n-\t\t\t\t\t\t\t  ptr, integer_zero_node,\n-\t\t\t\t\t\t\t  LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR|LOOKUP_HAS_IN_CHARGE, 0));\n+\t\t\t  expand_expr_stmt\n+\t\t\t    (build_delete\n+\t\t\t     (build_pointer_type (BINFO_TYPE (vbases)),\n+\t\t\t      ptr, integer_zero_node,\n+\t\t\t      (LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR\n+\t\t\t       |LOOKUP_HAS_IN_CHARGE|LOOKUP_NORMAL),\n+\t\t\t      0));\n \t\t\t}\n \t\t      vbases = TREE_CHAIN (vbases);\n \t\t    }\n@@ -12025,6 +12063,7 @@ finish_function (lineno, call_poplevel, nested)\n \n    DO NOT MAKE ANY CHANGES TO THIS CODE WITHOUT MAKING CORRESPONDING\n    CHANGES TO CODE IN `grokfield'.  */\n+\n tree\n start_method (declspecs, declarator, raises)\n      tree declarator, declspecs, raises;\n@@ -12242,6 +12281,7 @@ hack_incomplete_structures (type)\n \n    Don't build these on the momentary obstack; they must live\n    the life of the binding contour.  */\n+\n tree\n maybe_build_cleanup (decl)\n      tree decl;\n@@ -12292,9 +12332,8 @@ maybe_build_cleanup (decl)\n    expressions are combined with other, type-providing, expressions,\n    leaving only orphan expressions, such as:\n \n-   &class::bar;\t\t/ / takes its address, but does nothing with it.\n+   &class::bar;\t\t/ / takes its address, but does nothing with it.  */\n \n-   */\n void\n cplus_expand_expr_stmt (exp)\n      tree exp;"}, {"sha": "2b90b29d9fcdc46cab32e06f840a9082d1158354", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 65, "deletions": 25, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -56,7 +56,7 @@ tree pending_vtables;\n tree pending_statics;\n \n /* A list of functions which were declared inline, but which we\n-   may need to emit outline anyway. */\n+   may need to emit outline anyway.  */\n static tree saved_inlines;\n \n /* Used to help generate temporary names which are unique within\n@@ -131,7 +131,7 @@ int flag_ansi;\n int flag_implement_inlines = 1;\n \n /* Nonzero means do emit exported implementations of templates, instead of\n-   multiple static copies in each file that needs a definition. */\n+   multiple static copies in each file that needs a definition.  */\n \n int flag_external_templates;\n \n@@ -155,13 +155,9 @@ int warn_implicit = 1;\n int warn_ctor_dtor_privacy = 1;\n \n /* True if we want to implement vtables using \"thunks\".\n-   The default is off by default, on if explicitly supported. */\n+   The default is off by default, on if explicitly supported.  */\n \n-#ifdef ASM_OUTPUT_MI_THUNK\n-int flag_vtable_thunks = 1;\n-#else\n int flag_vtable_thunks;\n-#endif\n \n /* True if we want to deal with repository information.  */\n \n@@ -214,7 +210,7 @@ int warn_missing_braces;\n \n int warn_sign_compare;\n \n-/* Warn about *printf or *scanf format/argument anomalies. */\n+/* Warn about *printf or *scanf format/argument anomalies.  */\n \n int warn_format;\n \n@@ -236,7 +232,7 @@ int warn_parentheses;\n int warn_overloaded_virtual;\n \n /* Non-zero means warn when declaring a class that has a non virtual\n-   destructor, when it really ought to have a virtual one. */\n+   destructor, when it really ought to have a virtual one.  */\n int warn_nonvdtor;\n \n /* Non-zero means warn when a function is declared extern and later inline.  */\n@@ -345,7 +341,7 @@ extern int flag_gnu_xref;\n int flag_assume_nonnull_objects = 1;\n \n /* Nonzero if we want to support huge (> 2^(sizeof(short)*8-1) bytes)\n-   objects. */\n+   objects.  */\n \n int flag_huge_objects;\n \n@@ -628,6 +624,7 @@ lang_decode_option (p)\n /* Incorporate `const' and `volatile' qualifiers for member functions.\n    FUNCTION is a TYPE_DECL or a FUNCTION_DECL.\n    QUALS is a list of qualifiers.  */\n+\n tree\n grok_method_quals (ctype, function, quals)\n      tree ctype, function, quals;\n@@ -675,11 +672,12 @@ grok_method_quals (ctype, function, quals)\n   return ctype;\n }\n \n-#if 0\t\t\t\t/* Not used. */\n+#if 0\t\t\t\t/* Not used.  */\n /* This routine replaces cryptic DECL_NAMEs with readable DECL_NAMEs.\n    It leaves DECL_ASSEMBLER_NAMEs with the correct value.  */\n /* This does not yet work with user defined conversion operators\n    It should.  */\n+\n static void\n substitute_nice_name (decl)\n      tree decl;\n@@ -697,6 +695,7 @@ substitute_nice_name (decl)\n /* Warn when -fexternal-templates is used and #pragma\n    interface/implementation is not used all the times it should be,\n    inform the user.  */\n+\n void\n warn_if_unknown_interface (decl)\n      tree decl;\n@@ -727,6 +726,7 @@ warn_if_unknown_interface (decl)\n }\n \n /* A subroutine of the parser, to handle a component list.  */\n+\n tree\n grok_x_components (specs, components)\n      tree specs, components;\n@@ -1004,6 +1004,7 @@ grokclassfn (ctype, cname, function, flags, quals)\n }\n \n /* Work on the expr used by alignof (this is only called by the parser).  */\n+\n tree\n grok_alignof (expr)\n      tree expr;\n@@ -1047,6 +1048,7 @@ grok_alignof (expr)\n \n /* Create an ARRAY_REF, checking for the user doing things backwards\n    along the way.  */\n+\n tree\n grok_array_decl (array_expr, index_exp)\n      tree array_expr, index_exp;\n@@ -1120,6 +1122,7 @@ grok_array_decl (array_expr, index_exp)\n    for doing an array delete.  If DOING_VEC is 2, they gave us the\n    array size as an argument to delete.\n    Implements ARM $5.3.4.  This is called from the parser.  */\n+\n tree\n delete_sanity (exp, size, doing_vec, use_global_delete)\n      tree exp, size;\n@@ -1263,9 +1266,9 @@ check_classfn (ctype, function)\n \t\t    return fndecl;\n #if 0\n \t\t  /* This doesn't work for static member functions that are\n-                     pretending to be methods. */\n+                     pretending to be methods.  */\n \t\t  /* We have to do more extensive argument checking here, as\n-\t\t     the name may have been changed by asm(\"new_name\"). */\n+\t\t     the name may have been changed by asm(\"new_name\").  */\n \t\t  if (decls_match (function, fndecl))\n \t\t    return fndecl;\n #else\n@@ -1275,7 +1278,7 @@ check_classfn (ctype, function)\n \t\t      tree p2 = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n \n \t\t      /* Get rid of the this parameter on functions that become\n-\t\t\t static. */\n+\t\t\t static.  */\n \t\t      if (DECL_STATIC_FUNCTION_P (fndecl)\n \t\t\t  && TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE)\n \t\t\tp1 = TREE_CHAIN (p1);\n@@ -1643,6 +1646,7 @@ grokbitfield (declarator, declspecs, width)\n    buried in DECLSPECS.  Find the declarator, and\n    return something that looks like it came from\n    GROKFIELD.  */\n+\n tree\n groktypefield (declspecs, parmlist)\n      tree declspecs;\n@@ -1899,7 +1903,7 @@ grok_function_init (decl, init)\n #if 0\n       /* Mark this function as being \"defined\".  */\n       DECL_INITIAL (decl) = error_mark_node;\n-      /* pure virtual destructors must be defined. */\n+      /* pure virtual destructors must be defined.  */\n       /* pure virtual needs to be defined (as abort) only when put in \n \t vtbl. For wellformed call, it should be itself. pr4737 */\n       if (!DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl)))\n@@ -1971,6 +1975,7 @@ cplus_decl_attributes (decl, attributes, prefix_attributes)\n    specified class.  Argument can be RECORD_TYPE, TYPE_DECL, or\n    IDENTIFIER_NODE.  When given a template, this routine doesn't\n    lose the specialization.  */\n+\n tree\n constructor_name_full (thing)\n      tree thing;\n@@ -1997,6 +2002,7 @@ constructor_name_full (thing)\n    specified class.  Argument can be RECORD_TYPE, TYPE_DECL, or\n    IDENTIFIER_NODE.  When given a template, return the plain\n    unspecialized name.  */\n+\n tree\n constructor_name (thing)\n      tree thing;\n@@ -2012,6 +2018,7 @@ constructor_name (thing)\n /* Cache the value of this class's main virtual function table pointer\n    in a register variable.  This will save one indirection if a\n    more than one virtual function call is made this function.  */\n+\n void\n setup_vtbl_ptr ()\n {\n@@ -2030,6 +2037,7 @@ setup_vtbl_ptr ()\n }\n \n /* Record the existence of an addressable inline function.  */\n+\n void\n mark_inline_for_output (decl)\n      tree decl;\n@@ -2118,6 +2126,7 @@ get_temp_name (type, staticp)\n    It is not entered into current_binding_level, because\n    that breaks things when it comes time to do final cleanups\n    (which take place \"outside\" the binding contour of the function).  */\n+\n tree\n get_temp_regvar (type, init)\n      tree type, init;\n@@ -2143,6 +2152,7 @@ get_temp_regvar (type, init)\n \n /* Make the macro TEMP_NAME_P available to units which do not\n    include c-tree.h.  */\n+\n int\n temp_name_p (decl)\n      tree decl;\n@@ -2156,6 +2166,7 @@ temp_name_p (decl)\n    union is an anonymous union, we arrange for that\n    as well.  PUBLIC_P is nonzero if this union is\n    not declared static.  */\n+\n void\n finish_anon_union (anon_union_decl)\n      tree anon_union_decl;\n@@ -2240,6 +2251,7 @@ finish_anon_union (anon_union_decl)\n    TYPE is the type of the table entry.\n    INIT is all the elements in the table.\n    PUBLICP is non-zero if this table should be given external access.  */\n+\n tree\n finish_table (name, type, init, publicp)\n      tree name, type, init;\n@@ -2316,6 +2328,7 @@ finish_table (name, type, init, publicp)\n    used in FIELDS.\n \n    It is given the same alignment as ALIGN_TYPE.  */\n+\n void\n finish_builtin_type (type, name, fields, len, align_type)\n      tree type;\n@@ -2601,7 +2614,8 @@ finish_vtable_vardecl (prev, vars)\n \t   && ! DECL_ONE_ONLY (vars)\n #endif\n \t   )\n-\t  || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (vars)))\n+\t  || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (vars))\n+\t  || (hack_decl_function_context (vars) && TREE_USED (vars)))\n       && ! TREE_ASM_WRITTEN (vars))\n     {\n       /* Write it out.  */\n@@ -2747,7 +2761,8 @@ import_export_decl (decl)\n   if (DECL_TEMPLATE_INSTANTIATION (decl))\n     {\n       DECL_NOT_REALLY_EXTERN (decl) = 1;\n-      if (DECL_IMPLICIT_INSTANTIATION (decl) && flag_implicit_templates)\n+      if (DECL_IMPLICIT_INSTANTIATION (decl)\n+\t  && (flag_implicit_templates || DECL_THIS_INLINE (decl)))\n \t{\n \t  if (TREE_CODE (decl) == FUNCTION_DECL)\n \t    {\n@@ -2922,7 +2937,15 @@ finish_file ()\n   for (fnname = pending_templates; fnname; fnname = TREE_CHAIN (fnname))\n     {\n       tree decl = TREE_VALUE (fnname);\n-      instantiate_decl (decl);\n+      if (TREE_CODE_CLASS (TREE_CODE (decl)) == 't')\n+\t{\n+\t  instantiate_class_template (decl);\n+\t  if (CLASSTYPE_TEMPLATE_INSTANTIATION (decl))\n+\t    for (vars = TYPE_METHODS (decl); vars; vars = TREE_CHAIN (vars))\n+\t      instantiate_decl (vars);\n+\t}\n+      else\n+\tinstantiate_decl (decl);\n     }\n \n   /* Push into C language context, because that's all\n@@ -2941,7 +2964,7 @@ finish_file ()\n      virtual function tables, moving the implementation of this code to\n      decl.c (where we can manipulate global_binding_level directly),\n      popping the garbage after pushing it and slicing away the vtable\n-     stuff, or just leaving it alone. */\n+     stuff, or just leaving it alone.  */\n \n   /* Make last thing in global scope not be a virtual function table.  */\n #if 0 /* not yet, should get fixed properly later */\n@@ -2955,7 +2978,7 @@ finish_file ()\n #endif\n \n   /* Walk to mark the inline functions we need, then output them so\n-     that we can pick up any other tdecls that those routines need. */\n+     that we can pick up any other tdecls that those routines need.  */\n   walk_vtables ((void (*)())0, finish_prevtable_vardecl);\n \n   for (vars = pending_statics; vars; vars = TREE_CHAIN (vars))\n@@ -3267,7 +3290,7 @@ finish_file ()\n \t\t    /* We can't inline this function after it's been\n                        emitted, so just disable inlining.  We want a\n                        variant of output_inline_function that doesn't\n-                       prevent subsequent integration... */\n+                       prevent subsequent integration...  */\n \t\t    flag_no_inline = 1;\n \t\t    temporary_allocation ();\n \t\t    output_inline_function (decl);\n@@ -3329,6 +3352,7 @@ finish_file ()\n \n    Maybe this shouldn't be recursive, but how often will it actually be\n    used?  (jason) */\n+\n tree\n reparse_absdcl_as_expr (type, decl)\n      tree type, decl;\n@@ -3355,6 +3379,7 @@ reparse_absdcl_as_expr (type, decl)\n \n    In the above example, DECL is the `(int)(int)(int)', and EXPR is the\n    `1'.  */\n+\n tree\n reparse_absdcl_as_casts (decl, expr)\n      tree decl, expr;\n@@ -3392,7 +3417,7 @@ reparse_absdcl_as_casts (decl, expr)\n   return expr;\n }\n \n-/* Given plain tree nodes for an expression, build up the full semantics. */\n+/* Given plain tree nodes for an expression, build up the full semantics.  */\n \n tree\n build_expr_from_tree (t)\n@@ -3424,6 +3449,18 @@ build_expr_from_tree (t)\n       return build_reinterpret_cast\n \t(TREE_TYPE (t), build_expr_from_tree (TREE_OPERAND (t, 0)));\n \n+    case CONST_CAST_EXPR:\n+      return build_const_cast\n+\t(TREE_TYPE (t), build_expr_from_tree (TREE_OPERAND (t, 0)));\n+\n+    case DYNAMIC_CAST_EXPR:\n+      return build_dynamic_cast\n+\t(TREE_TYPE (t), build_expr_from_tree (TREE_OPERAND (t, 0)));\n+\n+    case STATIC_CAST_EXPR:\n+      return build_static_cast\n+\t(TREE_TYPE (t), build_expr_from_tree (TREE_OPERAND (t, 0)));\n+\n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n@@ -3608,6 +3645,7 @@ build_expr_from_tree (t)\n    build_expr_from_tree, above.\n \n    In the above example, TYPE is `int' and DECL is `*a'.  */\n+\n tree\n reparse_decl_as_expr (type, decl)\n      tree type, decl;\n@@ -3621,7 +3659,7 @@ reparse_decl_as_expr (type, decl)\n \n /* This is something of the form `int (*a)' that has turned out to be a\n    decl.  It was only converted into parse nodes, so we need to do the\n-   checking that make_{pointer,reference}_declarator do. */\n+   checking that make_{pointer,reference}_declarator do.  */\n \n tree\n finish_decl_parsing (decl)\n@@ -3692,6 +3730,7 @@ tree current_namespace;\n \n /* Get the inner part of a namespace id.  It doesn't have any prefix, nor\n    postfix.  Returns 0 if in global namespace.  */\n+\n tree\n get_namespace_id ()\n {\n@@ -3701,15 +3740,16 @@ get_namespace_id ()\n   return x;\n }\n \n-/* Build up a DECL_ASSEMBLER_NAME for NAME in the current namespace. */\n+/* Build up a DECL_ASSEMBLER_NAME for NAME in the current namespace.  */\n+\n tree\n current_namespace_id (name)\n      tree name;\n {\n   tree old_id = get_namespace_id ();\n   char *buf;\n \n-  /* Global names retain old encoding. */\n+  /* Global names retain old encoding.  */\n   if (! old_id)\n     return name;\n "}, {"sha": "9d68c5e2a8a3b530be903adc915082ca5c5a590a", "filename": "gcc/cp/error.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -121,7 +121,8 @@ dump_readonly_or_volatile (t, p)\n    value.  */\n static char digit_buffer[128];\n \n-/* Dump into the obstack a human-readable equivalent of TYPE. */\n+/* Dump into the obstack a human-readable equivalent of TYPE.  */\n+\n static void\n dump_type (t, v)\n      tree t;\n@@ -259,7 +260,8 @@ aggr_variety (t)\n     return \"struct\";\n }\n \n-/* Print out a class declaration, in the form `class foo'. */\n+/* Print out a class declaration, in the form `class foo'.  */\n+\n static void\n dump_aggr_type (t, v)\n      tree t;\n@@ -515,6 +517,7 @@ dump_type_suffix (t, v)\n \n /* Return a function declaration which corresponds to the IDENTIFIER_NODE\n    argument.  */\n+\n tree\n ident_fndecl (t)\n      tree t;\n@@ -650,7 +653,7 @@ dump_decl (t, v)\n       break;\n \n       /* These special cases are duplicated here so that other functions\n-\t can feed identifiers to cp_error and get them demangled properly. */\n+\t can feed identifiers to cp_error and get them demangled properly.  */\n     case IDENTIFIER_NODE:\n       { tree f;\n \tif (DESTRUCTOR_NAME_P (t)\n@@ -834,6 +837,7 @@ dump_function_decl (t, v)\n \n /* Handle the function name for a FUNCTION_DECL node, grokking operators\n    and destructors properly.  */\n+\n static void\n dump_function_name (t)\n      tree t;\n@@ -917,6 +921,7 @@ dump_char (c)\n }\n \n /* Print out a list of initializers (subr of dump_expr) */\n+\n static void\n dump_expr_list (l)\n      tree l;\n@@ -931,6 +936,7 @@ dump_expr_list (l)\n }\n \n /* Print out an expression */\n+\n static void\n dump_expr (t, nop)\n      tree t;\n@@ -1377,6 +1383,7 @@ fndecl_as_string (fndecl, print_ret_type_p)\n /* Same, but handtype a _TYPE.\n    Called from convert_to_reference, mangle_class_name_for_template,\n    build_unary_op, and GNU_xref_decl.  */\n+\n char *\n type_as_string (typ, v)\n      tree typ;\n@@ -1407,6 +1414,7 @@ expr_as_string (decl, v)\n \n /* A cross between type_as_string and fndecl_as_string.\n    Only called from substitute_nice_name.  */\n+\n char *\n decl_as_string (decl, v)\n      tree decl;\n@@ -1482,6 +1490,7 @@ language_as_string (c, v)\n }\n \n /* Return the proper printed version of a parameter to a C++ function.  */\n+\n char *\n parm_as_string (p, v)\n      int p, v;"}, {"sha": "03c4e71d3f89eeb270e914fd3db13c95106f96c6", "filename": "gcc/cp/except.c", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -106,7 +106,7 @@ easy_expand_asm (str)\n \n \n #if 0\n-/* This is the startup, and finish stuff per exception table. */\n+/* This is the startup, and finish stuff per exception table.  */\n \n /* XXX - Tad: exception handling section */\n #ifndef EXCEPT_SECTION_ASM_OP\n@@ -320,7 +320,7 @@ struct ehQueue {\n \n /* Holds the pc for doing \"throw\" */\n static tree saved_pc;\n-/* Holds the type of the thing being thrown. */\n+/* Holds the type of the thing being thrown.  */\n static tree saved_throw_type;\n /* Holds the value being thrown.  */\n static tree saved_throw_value;\n@@ -919,11 +919,11 @@ build_eh_type_type (type)\n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  /* peel back references, so they match. */\n+  /* peel back references, so they match.  */\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n \n-  /* Peel off cv qualifiers. */\n+  /* Peel off cv qualifiers.  */\n   type = TYPE_MAIN_VARIANT (type);\n \n   if (flag_rtti)\n@@ -1015,7 +1015,7 @@ expand_start_catch_block (declspecs, declarator)\n \t a warning about an unused ((anonymous)).  */\n       TREE_USED (decl) = 1;\n \n-      /* Figure out the type that the initializer is. */\n+      /* Figure out the type that the initializer is.  */\n       init_type = TREE_TYPE (decl);\n       if (TREE_CODE (init_type) != REFERENCE_TYPE\n \t  && TREE_CODE (init_type) != POINTER_TYPE)\n@@ -1054,7 +1054,7 @@ expand_start_catch_block (declspecs, declarator)\n     {\n       push_eh_cleanup ();\n \n-      /* Fall into the catch all section. */\n+      /* Fall into the catch all section.  */\n     }\n \n   emit_move_insn (DECL_RTL (saved_in_catch), const1_rtx);\n@@ -1229,14 +1229,14 @@ do_unwind (inner_throw_label)\n   rtx return_val_rtx;\n \n #if 0\n-  /* I would like to do this here, but the move below doesn't seem to work. */\n+  /* I would like to do this here, but the move below doesn't seem to work.  */\n   /* call to  __builtin_return_address () */\n   params = tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n   fcall = build_function_call (BuiltinReturnAddress, params);\n   return_val_rtx = expand_expr (fcall, NULL_RTX, Pmode, 0);\n \n   emit_move_insn (return_val_rtx, inner_throw_label);\n-  /* So, for now, just pass throw label to stack unwinder. */\n+  /* So, for now, just pass throw label to stack unwinder.  */\n #endif\n   params = tree_cons (NULL_TREE, make_tree (ptr_type_node,\n \t\t\t\t\t    inner_throw_label), NULL_TREE);\n@@ -1341,7 +1341,7 @@ expand_builtin_throw ()\n   unwind_first = gen_label_rtx ();\n \n   /* These two can be frontend specific.  If wanted, they can go in\n-     expand_throw. */\n+     expand_throw.  */\n   /* Do we have a valid object we are throwing? */\n   emit_cmp_insn (DECL_RTL (saved_throw_type), const0_rtx, EQ, NULL_RTX,\n \t\t GET_MODE (DECL_RTL (saved_throw_type)), 0, 0);\n@@ -1415,7 +1415,7 @@ expand_builtin_throw ()\n       emit_move_insn (ret_val, return_val_rtx);\n #endif\n \n-    /* Fall into epilogue to unwind prologue. */\n+    /* Fall into epilogue to unwind prologue.  */\n   }\n \n   expand_end_bindings (getdecls (), 1, 0);\n@@ -1614,6 +1614,7 @@ tree\n start_anon_func ()\n {\n   static int counter = 0;\n+  int old_interface_unknown = interface_unknown;\n   char name[32];\n   tree params;\n   tree t;\n@@ -1624,6 +1625,8 @@ start_anon_func ()\n   /* No need to mangle this.  */\n   push_lang_context (lang_name_c);\n \n+  interface_unknown = 1;\n+\n   params = void_list_node;\n   /* tcf stands for throw clean funciton.  */\n   sprintf (name, \"__tcf_%d\", counter++);\n@@ -1638,6 +1641,8 @@ start_anon_func ()\n   expand_start_bindings (0);\n   emit_line_note (input_filename, lineno);\n \n+  interface_unknown = old_interface_unknown;\n+\n   pop_lang_context ();\n \n   return current_function_decl;\n@@ -1686,7 +1691,7 @@ expand_throw (exp)\n       tree cleanup = empty_fndecl, e;\n \n       /* throw expression */\n-      /* First, decay it. */\n+      /* First, decay it.  */\n       exp = decay_conversion (exp);\n \n       if (TREE_CODE (TREE_TYPE (exp)) == POINTER_TYPE)"}, {"sha": "33f55df58826e3dad36713fb4f20fb71ebbac9d5", "filename": "gcc/cp/init.c", "status": "modified", "additions": 51, "deletions": 19, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -20,7 +20,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n \n-/* High-level class interface. */\n+/* High-level class interface.  */\n \n #include \"config.h\"\n #include \"tree.h\"\n@@ -116,6 +116,7 @@ void init_init_processing ()\n \n    Relies upon binfo being inside TYPE_BINFO (TREE_TYPE (TREE_TYPE\n    (addr))).  */\n+\n void\n expand_direct_vtbls_init (real_binfo, binfo, init_self, can_elide, addr)\n      tree real_binfo, binfo, addr;\n@@ -150,6 +151,7 @@ expand_direct_vtbls_init (real_binfo, binfo, init_self, can_elide, addr)\n \f\n /* 348 - 351 */\n /* Subroutine of emit_base_init.  */\n+\n static void\n perform_member_init (member, name, init, explicit, protect_list)\n      tree member, name, init;\n@@ -252,6 +254,7 @@ perform_member_init (member, name, init, explicit, protect_list)\n extern int warn_reorder;\n \n /* Subroutine of emit_member_init.  */\n+\n static tree\n sort_member_init (t)\n      tree t;\n@@ -482,6 +485,7 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n }\n \n /* Perform partial cleanups for a base for exception handling.  */\n+\n static tree\n build_partial_cleanup_for (binfo)\n      tree binfo;\n@@ -629,7 +633,7 @@ emit_base_init (t, immediately)\n     }\n \n   /* Initialize all the virtual function table fields that\n-     do come from virtual base classes. */\n+     do come from virtual base classes.  */\n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n     expand_indirect_vtbls_init (t_binfo, current_class_ref, current_class_ptr);\n \n@@ -735,6 +739,7 @@ emit_base_init (t, immediately)\n \n /* Check that all fields are properly initialized after\n    an assignment to `this'.  */\n+\n void\n check_base_init (t)\n      tree t;\n@@ -751,6 +756,7 @@ check_base_init (t)\n \n    BINFO is the exact type that DECL is supposed to be.  In\n    multiple inheritance, this might mean \"C's A\" if C : A, B.  */\n+\n static void\n expand_virtual_init (binfo, decl)\n      tree binfo, decl;\n@@ -781,6 +787,7 @@ expand_virtual_init (binfo, decl)\n /* Subroutine of `expand_aggr_vbase_init'.\n    BINFO is the binfo of the type that is being initialized.\n    INIT_LIST is the list of initializers for the virtual baseclass.  */\n+\n static void\n expand_aggr_vbase_init_1 (binfo, exp, addr, init_list)\n      tree binfo, exp, addr, init_list;\n@@ -817,6 +824,7 @@ expand_aggr_vbase_init_1 (binfo, exp, addr, init_list)\n    done only at the top-level of the object being constructed.\n \n    INIT_LIST is list of initialization for constructor to perform.  */\n+\n static void\n expand_aggr_vbase_init (binfo, exp, addr, init_list)\n      tree binfo;\n@@ -849,6 +857,7 @@ expand_aggr_vbase_init (binfo, exp, addr, init_list)\n    S_ID is the scoped identifier.\n    NAME is the name of the member.\n    INIT is the initializer, or `void_type_node' if none.  */\n+\n void\n do_member_init (s_id, name, init)\n      tree s_id, name, init;\n@@ -873,6 +882,7 @@ do_member_init (s_id, name, init)\n }\n \n /* Find the context in which this FIELD can be initialized.  */\n+\n static tree\n initializing_context (field)\n      tree field;\n@@ -932,6 +942,7 @@ member_init_ok_or_else (field, type, member_name)\n    If INIT is non-NULL, then it the initialization should\n    be placed in `current_base_init_list', where it will be processed\n    by `emit_base_init'.  */\n+\n void\n expand_member_init (exp, name, init)\n      tree exp, name, init;\n@@ -986,15 +997,15 @@ expand_member_init (exp, name, init)\n \n \t  if (name == NULL_TREE)\n \t    {\n-/*\n+#if 0\n \t      if (basetype)\n \t\tname = TYPE_IDENTIFIER (basetype);\n \t      else\n \t\t{\n \t\t  error (\"no base class to initialize\");\n \t\t  return;\n \t\t}\n-*/\n+#endif\n \t    }\n \t  else\n \t    {\n@@ -1063,7 +1074,7 @@ expand_member_init (exp, name, init)\n     return;\n \n   /* now see if there is a constructor for this type\n-     which will take these args. */\n+     which will take these args.  */\n \n   if (TYPE_HAS_CONSTRUCTOR (TREE_TYPE (field)))\n     {\n@@ -1166,7 +1177,7 @@ expand_member_init (exp, name, init)\n    initialization.\n \n    A constructor or a conversion operator may have to be used to\n-   perform the initialization, but not both, as it would be ambiguous. */\n+   perform the initialization, but not both, as it would be ambiguous.  */\n \n void\n expand_aggr_init (exp, init, alias_this, flags)\n@@ -1518,6 +1529,8 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \n \t  return;\n \t}\n+\n+#ifndef NEW_OVER\n       /* See whether we can go through a type conversion operator.\n \t This wins over going through a non-existent constructor.  If\n \t there is a constructor, it is ambiguous.  */\n@@ -1533,7 +1546,7 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t      if (rval)\n \t\t{\n \t\t  /* See if there is a constructor for``type'' that takes a\n-\t\t     ``ttype''-typed object. */\n+\t\t     ``ttype''-typed object.  */\n \t\t  tree parms = build_tree_list (NULL_TREE, init);\n \t\t  tree as_cons = NULL_TREE;\n \t\t  if (TYPE_HAS_CONSTRUCTOR (type))\n@@ -1550,6 +1563,7 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t\t}\n \t    }\n \t}\n+#endif\n     }\n \n   /* We know that expand_default_init can handle everything we want\n@@ -1559,6 +1573,7 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \n /* Report an error if NAME is not the name of a user-defined,\n    aggregate type.  If OR_ELSE is nonzero, give an error message.  */\n+\n int\n is_aggr_typedef (name, or_else)\n      tree name;\n@@ -1590,6 +1605,7 @@ is_aggr_typedef (name, or_else)\n \n /* Report an error if TYPE is not a user-defined, aggregate type.  If\n    OR_ELSE is nonzero, give an error message.  */\n+\n int\n is_aggr_type (type, or_else)\n      tree type;\n@@ -1609,6 +1625,7 @@ is_aggr_type (type, or_else)\n }\n \n /* Like is_aggr_typedef, but returns typedef if successful.  */\n+\n tree\n get_aggr_from_typedef (name, or_else)\n      tree name;\n@@ -1657,6 +1674,7 @@ get_type_value (name)\n \n /* For an expression of the form TYPE :: NAME (PARMLIST), build\n    the appropriate function call.  */\n+\n tree\n build_member_call (type, name, parmlist)\n      tree type, name, parmlist;\n@@ -1779,6 +1797,7 @@ build_member_call (type, name, parmlist)\n    @@ fields.\n \n    @@ This function should be rewritten and placed in search.c.  */\n+\n tree\n build_offset_ref (type, name)\n      tree type, name;\n@@ -1873,7 +1892,7 @@ build_offset_ref (type, name)\n     return error_mark_node;\n \n   /* A lot of this logic is now handled in lookup_field and\n-     lookup_fnfield. */\n+     lookup_fnfield.  */\n   if (fnfields)\n     {\n       extern int flag_save_memoized_contexts;\n@@ -2198,7 +2217,7 @@ is_friend (type, supplicant)\n \t}\n     }\n   else\n-    /* It's a type. */\n+    /* It's a type.  */\n     {\n       if (type == supplicant)\n \treturn 1;\n@@ -2235,6 +2254,7 @@ is_friend (type, supplicant)\n \n /* Add a new friend to the friends of the aggregate type TYPE.\n    DECL is the FUNCTION_DECL of the friend being added.  */\n+\n static void\n add_friend (type, decl)\n      tree type, decl;\n@@ -2284,6 +2304,7 @@ add_friend (type, decl)\n \n /* Declare that every member function NAME in FRIEND_TYPE\n    (which may be NULL_TREE) is a friend of type TYPE.  */\n+\n static void\n add_friends (type, name, friend_type)\n      tree type, name, friend_type;\n@@ -2336,6 +2357,7 @@ add_friends (type, name, friend_type)\n    then the DECL_WAITING_FRIENDS contains a list of types\n    waiting to make it their friend.  Note that these two can both\n    be in use at the same time!  */\n+\n void\n make_friend_class (type, friend_type)\n      tree type, friend_type;\n@@ -2395,6 +2417,7 @@ make_friend_class (type, friend_type)\n \n    QUALS say what special qualifies should apply to the object\n    pointed to by `this'.  */\n+\n tree\n do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n      tree ctype, declarator, decl, parmdecls;\n@@ -2781,7 +2804,7 @@ build_new (placement, decl, init, use_global_new)\n     }\n \n   /* Get a little extra space to store a couple of things before the new'ed\n-     array. */\n+     array.  */\n   if (has_array && TYPE_VEC_NEW_USES_COOKIE (true_type))\n     {\n       tree extra = BI_header_size;\n@@ -2797,7 +2820,7 @@ build_new (placement, decl, init, use_global_new)\n \tcp_pedwarn (\"initialization in array new\");\n     }\n \n-  /* Allocate the object. */\n+  /* Allocate the object.  */\n   if (! use_global_new && TYPE_LANG_SPECIFIC (true_type)\n       && (TYPE_GETS_NEW (true_type) & (1 << has_array)))\n     rval = build_opfncall (code, LOOKUP_NORMAL,\n@@ -3045,7 +3068,7 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n      int use_global_delete;\n {\n   tree virtual_size;\n-  tree ptype = build_pointer_type (type);\n+  tree ptype = build_pointer_type (type = complete_type (type));\n   tree size_exp = size_in_bytes (type);\n \n   /* Temporary variables used by the loop.  */\n@@ -3155,7 +3178,7 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n \t\t\t\t\t       convert (string_type_node, base),\n \t\t\t\t\t       BI_header_size,\n \t\t\t\t\t       1));\n-\t  /* True size with header. */\n+\t  /* True size with header.  */\n \t  virtual_size = size_binop (PLUS_EXPR, virtual_size, BI_header_size);\n \t}\n       deallocate_expr = build_x_delete (ptype, base_tbd,\n@@ -3196,6 +3219,7 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n    BASE is that starting address of the array.\n    COUNT is the count of objects that have been built, that need destroying.\n    TYPE is the type of elements in the array.  */\n+\n static tree\n build_array_eh_cleanup (base, count, type)\n      tree base, count, type;\n@@ -3261,7 +3285,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \n   if (init != NULL_TREE\n       && TREE_CODE (init) == CONSTRUCTOR\n-      && TREE_TYPE (init) == TREE_TYPE (decl))\n+      && (! decl || TREE_TYPE (init) == TREE_TYPE (decl)))\n     {\n       /* Initialization of array from {...}.  */\n       tree elts = CONSTRUCTOR_ELTS (init);\n@@ -3453,6 +3477,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n    static object, see Free Store 12.5 ANSI C++ WP.\n \n    This does not call any destructors.  */\n+\n tree\n build_x_delete (type, addr, which_delete, virtual_size)\n      tree type, addr;\n@@ -3484,14 +3509,15 @@ build_x_delete (type, addr, which_delete, virtual_size)\n    flags.  See cp-tree.h for more info.\n \n    This function does not delete an object's virtual base classes.  */\n+\n tree\n build_delete (type, addr, auto_delete, flags, use_global_delete)\n      tree type, addr;\n      tree auto_delete;\n      int flags;\n      int use_global_delete;\n {\n-  tree function, parms;\n+  tree function;\n   tree member;\n   tree expr;\n   tree ref;\n@@ -3587,15 +3613,14 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n       return build_builtin_call (void_type_node, BID,\n \t\t\t\t build_tree_list (NULL_TREE, addr));\n     }\n-  parms = build_tree_list (NULL_TREE, addr);\n \n   /* Below, we will reverse the order in which these calls are made.\n      If we have a destructor, then that destructor will take care\n      of the base classes; otherwise, we must do that here.  */\n   if (TYPE_HAS_DESTRUCTOR (type))\n     {\n+      tree parms = build_tree_list (NULL_TREE, addr);\n       tree dtor = DECL_MAIN_VARIANT (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), 1));\n-      tree basetypes = TYPE_BINFO (type);\n       tree passed_auto_delete;\n       tree do_delete = NULL_TREE;\n \n@@ -3619,7 +3644,13 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \n       if (flags & LOOKUP_PROTECT)\n \t{\n-\t  tree access = compute_access (basetypes, dtor);\n+\t  tree access;\n+\t  tree basetypes = NULL_TREE;\n+\t  if (current_class_type != NULL_TREE)\n+\t    basetypes = get_binfo (type, current_class_type, 0);\n+\t  if (basetypes == NULL_TREE)\n+\t    basetypes = TYPE_BINFO (type);\n+\t  access = compute_access (basetypes, dtor);\n \n \t  if (access == access_private_node)\n \t    {\n@@ -3863,6 +3894,7 @@ build_vbase_delete (type, decl)\n    values we'd have to extract.  (We could use MAXINDEX with pointers to\n    confirm the size, and trap if the numbers differ; not clear that it'd\n    be worth bothering.)  */\n+\n tree\n build_vec_delete (base, maxindex, auto_delete_vec, auto_delete,\n \t\t  use_global_delete)\n@@ -3879,7 +3911,7 @@ build_vec_delete (base, maxindex, auto_delete_vec, auto_delete,\n \n   base = stabilize_reference (base);\n \n-  /* Since we can use base many times, save_expr it. */\n+  /* Since we can use base many times, save_expr it.  */\n   if (TREE_SIDE_EFFECTS (base))\n     base = save_expr (base);\n "}, {"sha": "364b8e21813da85774691ddaf43f4a5ac2c0dcc0", "filename": "gcc/cp/input.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finput.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -156,7 +156,7 @@ sub_getch ()\n \t  input = inp->next;\n \t  input_filename = inp->filename;\n \t  lineno = inp->lineno;\n-\t  /* Get interface/implementation back in sync. */\n+\t  /* Get interface/implementation back in sync.  */\n \t  extract_interface_info ();\n \t  putback_char = inp->putback_char;\n \t  free_input (inp);"}, {"sha": "7ce0a96ae6b534ab8ec9a86f9d6f05274313a046", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -301,13 +301,13 @@ my_get_run_time ()\n \f\n /* Table indexed by tree code giving a string containing a character\n    classifying the tree code.  Possibilities are\n-   t, d, s, c, r, <, 1 and 2.  See cp/tree.def for details.  */\n+   t, d, s, c, r, <, 1 and 2.  See cp/cp-tree.def for details.  */\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n \n char *cplus_tree_code_type[] = {\n   \"x\",\n-#include \"tree.def\"\n+#include \"cp-tree.def\"\n };\n #undef DEFTREECODE\n \n@@ -319,7 +319,7 @@ char *cplus_tree_code_type[] = {\n \n int cplus_tree_code_length[] = {\n   0,\n-#include \"tree.def\"\n+#include \"cp-tree.def\"\n };\n #undef DEFTREECODE\n \n@@ -329,7 +329,7 @@ int cplus_tree_code_length[] = {\n \n char *cplus_tree_code_name[] = {\n   \"@@dummy\",\n-#include \"tree.def\"\n+#include \"cp-tree.def\"\n };\n #undef DEFTREECODE\n \f\n@@ -374,6 +374,7 @@ init_filename_times ()\n /* Change by Bryan Boreham, Kewill, Thu Jul 27 09:46:05 1989.\n    Stuck this hack in to get the files open correctly; this is called\n    in place of init_lex if we are an unexec'd binary.    */\n+\n void\n reinit_lang_specific ()\n {\n@@ -620,7 +621,7 @@ init_lex ()\n   SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_REGISTER],\n \t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_REGISTER]));\n \n-  /* C++ extensions. These are probably not correctly named. */\n+  /* C++ extensions. These are probably not correctly named.  */\n   ridpointers[(int) RID_WCHAR] = get_identifier (\"__wchar_t\");\n   SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_WCHAR],\n \t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_WCHAR]));\n@@ -662,7 +663,7 @@ init_lex ()\n   ridpointers[(int) RID_TEMPLATE] = get_identifier (\"template\");\n   SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_TEMPLATE],\n \t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_TEMPLATE]));\n-  /* This is for ANSI C++. */\n+  /* This is for ANSI C++.  */\n   ridpointers[(int) RID_MUTABLE] = get_identifier (\"mutable\");\n   SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_MUTABLE],\n \t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_MUTABLE]));\n@@ -937,27 +938,27 @@ print_parse_statistics ()\n   qsort (sorted, TOKEN_LENGTH, sizeof (int), token_cmp);\n   for (i = 0; i < TOKEN_LENGTH; i++)\n     {\n-      int index = sorted[i];\n-      if (token_count[index] == 0)\n+      int idx = sorted[i];\n+      if (token_count[idx] == 0)\n \tbreak;\n-      if (token_count[index] < token_count[-1])\n+      if (token_count[idx] < token_count[-1])\n \tbreak;\n       fprintf (stderr, \"token %d, `%s', count = %d\\n\",\n-\t       index, yytname[YYTRANSLATE (index)], token_count[index]);\n+\t       idx, yytname[YYTRANSLATE (idx)], token_count[idx]);\n     }\n   fprintf (stderr, \"\\n\");\n   for (i = 0; i < REDUCE_LENGTH; i++)\n     sorted[i] = i;\n   qsort (sorted, REDUCE_LENGTH, sizeof (int), reduce_cmp);\n   for (i = 0; i < REDUCE_LENGTH; i++)\n     {\n-      int index = sorted[i];\n-      if (reduce_count[index] == 0)\n+      int idx = sorted[i];\n+      if (reduce_count[idx] == 0)\n \tbreak;\n-      if (reduce_count[index] < reduce_count[-1])\n+      if (reduce_count[idx] < reduce_count[-1])\n \tbreak;\n       fprintf (stderr, \"rule %d, line %d, count = %d\\n\",\n-\t       index, yyrline[index], reduce_count[index]);\n+\t       idx, yyrline[idx], reduce_count[idx]);\n     }\n   fprintf (stderr, \"\\n\");\n #endif\n@@ -968,6 +969,7 @@ print_parse_statistics ()\n /* Sets the value of the 'yydebug' variable to VALUE.\n    This is a function so we don't have to have YYDEBUG defined\n    in order to build the compiler.  */\n+\n void\n set_yydebug (value)\n      int value;\n@@ -1010,6 +1012,7 @@ static struct impl_files *impl_file_chain;\n \n /* Helper function to load global variables with interface\n    information.  */\n+\n void\n extract_interface_info ()\n {\n@@ -1031,6 +1034,7 @@ extract_interface_info ()\n \n /* Return nonzero if S is not considered part of an\n    INTERFACE/IMPLEMENTATION pair.  Otherwise, return 0.  */\n+\n static int\n interface_strcmp (s)\n      char *s;\n@@ -1104,6 +1108,7 @@ set_vardecl_interface_info (prev, vars)\n    do, set up to process them now.  This function sets up the first function\n    to be parsed; after it has been, the rule for fndef in parse.y will\n    call process_next_inline to start working on the next one.  */\n+\n void\n do_pending_inlines ()\n {\n@@ -1168,6 +1173,7 @@ static int nextchar = -1;\n /* Called from the fndecl rule in the parser when the function just parsed\n    was declared using a PRE_PARSED_FUNCTION_DECL (i.e. came from\n    do_pending_inlines).  */\n+\n void\n process_next_inline (t)\n      tree t;\n@@ -1183,12 +1189,11 @@ process_next_inline (t)\n   if (yychar != END_OF_SAVED_INPUT)\n     {\n       error (\"parse error at end of saved function text\");\n+\n       /* restore_pending_input will abort unless yychar is either\n-       * END_OF_SAVED_INPUT or YYEMPTY; since we already know we're\n-       * hosed, feed back YYEMPTY.\n-       *  We also need to discard nextchar, since that may have gotten\n-       * set as well.\n-       */\n+         END_OF_SAVED_INPUT or YYEMPTY; since we already know we're\n+         hosed, feed back YYEMPTY.  We also need to discard nextchar,\n+         since that may have gotten set as well.  */\n       nextchar = -1;\n     }\n   yychar = YYEMPTY;\n@@ -1322,6 +1327,7 @@ restore_pending_input (p)\n \n /* Return next non-whitespace input character, which may come\n    from `finput', or from `nextchar'.  */\n+\n static int\n yynextch ()\n {\n@@ -1339,6 +1345,7 @@ yynextch ()\n /* Unget character CH from the input stream.\n    If RESCAN is non-zero, then we want to `see' this\n    character as the next input token.  */\n+\n void\n yyungetc (ch, rescan)\n      int ch;\n@@ -1733,6 +1740,7 @@ cons_up_default_function (type, full_name, kind)\n /* Heuristic to tell whether the user is missing a semicolon\n    after a struct or enum declaration.  Emit an error message\n    if we know the user has blown it.  */\n+\n void\n check_for_missing_semicolon (type)\n      tree type;\n@@ -3147,7 +3155,7 @@ real_yylex ()\n \t  }\n \tput_back (c1);\n       }\n-      /* fall through... */\n+      /* fall through...  */\n \t\t\t  case '2':  case '3':  case '4':\n     case '5':  case '6':  case '7':  case '8':  case '9':\n     resume_numerical_scan:\n@@ -3352,7 +3360,7 @@ real_yylex ()\n \t\tset_float_handler (handler);\n \t\t/*  The second argument, machine_mode, of REAL_VALUE_ATOF\n \t\t    tells the desired precision of the binary result of\n-\t\t    decimal-to-binary conversion. */\n+\t\t    decimal-to-binary conversion.  */\n \n \t\t/* Read the suffixes to choose a data type.  */\n \t\tswitch (c)\n@@ -4466,7 +4474,7 @@ handle_cp_pragma (pname)\n       interface_unknown = 1;\n #else\n       /* We make this zero so that templates in the impl\n-\t file will be emitted properly. */\n+\t file will be emitted properly.  */\n       interface_unknown = 0;\n #endif\n       TREE_INT_CST_LOW (fileinfo) = interface_only;\n@@ -4485,6 +4493,7 @@ handle_cp_pragma (pname)\n \n /* This function has to be in this file, in order to get at\n    the token types.  */\n+\n int\n handle_sysv_pragma (finput, token)\n      FILE *finput;"}, {"sha": "1c20f596f9abddd16197cb68486eee71efea09f1", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -63,7 +63,8 @@ enum rid\n   RID_AUTO,\n   RID_MUTABLE,\n \n-  /* This is where grokdeclarator ends its search when setting the specbits. */\n+  /* This is where grokdeclarator ends its search when setting the\n+     specbits.  */\n \n   RID_PUBLIC,\n   RID_PRIVATE,\n@@ -72,7 +73,7 @@ enum rid\n   RID_TEMPLATE,\n   RID_SIGNATURE,\n   /* Before adding enough to get up to 64, the RIDBIT_* macros\n-     will have to be changed a little. */\n+     will have to be changed a little.  */\n   RID_MAX\n };\n \n@@ -82,11 +83,11 @@ enum rid\n #define RID_LAST_MODIFIER RID_MUTABLE\n \n /* The type that can represent all values of RIDBIT.  */\n-/* We assume that we can stick in at least 32 bits into this. */\n+/* We assume that we can stick in at least 32 bits into this.  */\n typedef struct { unsigned long idata[2]; }\n      RID_BIT_TYPE;\n \n-/* Be careful, all these modify N twice. */\n+/* Be careful, all these modify N twice.  */\n #define RIDBIT_SETP(N, V) (((unsigned long)1 << (int) ((N)%32))\t\t      \\\n \t\t\t    & (V).idata[(N)/32])\n #define RIDBIT_NOTSETP(NN, VV) (! RIDBIT_SETP (NN, VV))"}, {"sha": "0927f177f6ee1c7e4108bba8caf724e956be9000", "filename": "gcc/cp/method.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -153,6 +153,7 @@ do_inline_function_hair (type, friend_list)\n \f\n /* Report an argument type mismatch between the best declared function\n    we could find and the current argument list that we have.  */\n+\n void\n report_type_mismatch (cp, parmtypes, name_kind)\n      struct candidate *cp;\n@@ -261,6 +262,7 @@ static int nofold;\n   } while (0)\n \n /* Code to concatenate an asciified integer to a string.  */\n+\n static\n #ifdef __GNUC__\n __inline\n@@ -355,7 +357,8 @@ build_overload_nested_name (decl)\n     build_overload_identifier (decl);\n }\n \n-/* Encoding for an INTEGER_CST value. */\n+/* Encoding for an INTEGER_CST value.  */\n+\n static void\n build_overload_int (value)\n      tree value;\n@@ -499,7 +502,7 @@ build_overload_value (type, value)\n \t{\n \t  if (TREE_CODE (value) == CONSTRUCTOR)\n \t    {\n-\t      /* This is dangerous code, crack built up pointer to members. */\n+\t      /* This is dangerous code, crack built up pointer to members.  */\n \t      tree args = CONSTRUCTOR_ELTS (value);\n \t      tree a1 = TREE_VALUE (args);\n \t      tree a2 = TREE_VALUE (TREE_CHAIN (args));\n@@ -876,7 +879,7 @@ build_overload_name (parmtypes, begin, end)\n \t      {\n \t\ttree context = name;\n \n-\t\t/* If DECL_ASSEMBLER_NAME has been set properly, use it. */\n+\t\t/* If DECL_ASSEMBLER_NAME has been set properly, use it.  */\n \t\tif (DECL_ASSEMBLER_NAME (context) != DECL_NAME (context))\n \t\t  {\n \t\t    OB_PUTID (DECL_ASSEMBLER_NAME (context));\n@@ -946,7 +949,7 @@ build_overload_name (parmtypes, begin, end)\n       if (nrepeats)\n \tflush_repeats (typevec[maxtype-1]);\n \n-      /* To get here, parms must end with `...'. */\n+      /* To get here, parms must end with `...'.  */\n       OB_PUTC ('e');\n     }\n \n@@ -974,6 +977,7 @@ build_static_name (basetype, name)\n    FOR_METHOD is 1 if this overload is being performed\n    for a method, rather than a function type.  It is 2 if\n    this overload is being performed for a constructor.  */\n+\n tree\n build_decl_overload (dname, parms, for_method)\n      tree dname;\n@@ -1058,6 +1062,7 @@ build_decl_overload (dname, parms, for_method)\n }\n \n /* Build an overload name for the type expression TYPE.  */\n+\n tree\n build_typename_overload (type)\n      tree type;\n@@ -1103,7 +1108,7 @@ get_id_2 (name, name2)\n \n /* Top-level interface to explicit overload requests. Allow NAME\n    to be overloaded. Error if NAME is already declared for the current\n-   scope. Warning if function is redundantly overloaded. */\n+   scope. Warning if function is redundantly overloaded.  */\n \n void\n declare_overloaded (name)\n@@ -1139,6 +1144,7 @@ declare_overloaded (name)\n /* Check to see if NAME is overloaded. For first approximation,\n    check to see if its TREE_OVERLOADED is set.  This is used on\n    IDENTIFIER nodes.  */\n+\n int\n is_overloaded (name)\n      tree name;\n@@ -1267,7 +1273,7 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n \t   \n \tif (TREE_CODE (TREE_TYPE (arg1)) == ARRAY_TYPE)\n \t  {\n-\t    /* Strip off the pointer and the array. */\n+\t    /* Strip off the pointer and the array.  */\n \t    arg1 = TREE_TYPE (TREE_TYPE (arg1));\n \n \t    while (TREE_CODE (arg1) == ARRAY_TYPE)\n@@ -1325,7 +1331,7 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n       /* Try to fail. First, fail if unary */\n       if (! try_second)\n \treturn rval;\n-      /* Second, see if second argument is non-aggregate. */\n+      /* Second, see if second argument is non-aggregate.  */\n       type2 = TREE_TYPE (xarg2);\n       if (TREE_CODE (type2) == OFFSET_TYPE)\n \ttype2 = TREE_TYPE (type2);\n@@ -1727,11 +1733,11 @@ emit_thunk (thunk_fndecl)\n   int failure = 0;\n   int save_ofp;\n \n-  /* Used to remember which regs we need to emit a USE rtx for. */\n+  /* Used to remember which regs we need to emit a USE rtx for.  */\n   rtx need_use[FIRST_PSEUDO_REGISTER];\n   int need_use_count = 0;\n \n-  /* rtx for the 'this' parameter. */\n+  /* rtx for the 'this' parameter.  */\n   rtx this_rtx = 0, this_reg_rtx = 0, fixed_this_rtx;\n \n   char *(*save_decl_printable_name) () = decl_printable_name;\n@@ -1775,7 +1781,7 @@ emit_thunk (thunk_fndecl)\n \n   /* Now look through all the parameters, make sure that we\n      don't clobber any registers used for parameters.\n-     Also, pick up an rtx for the first \"this\" parameter. */\n+     Also, pick up an rtx for the first \"this\" parameter.  */\n   for (argp = TYPE_ARG_TYPES (TREE_TYPE (function));\n        argp != NULL_TREE;\n        argp = TREE_CHAIN (argp))\n@@ -1949,6 +1955,7 @@ emit_thunk (thunk_fndecl)\n \n /* For the anonymous union in TYPE, return the member that is at least as\n    large as the rest of the members, so we can copy it.  */\n+\n static tree\n largest_union_member (type)\n      tree type;\n@@ -1965,6 +1972,7 @@ largest_union_member (type)\n }\n \n /* Generate code for default X(X&) constructor.  */\n+\n void\n do_build_copy_constructor (fndecl)\n      tree fndecl;"}, {"sha": "33c575923f67df63e2a17e13462f2d5010000c70", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -135,7 +135,7 @@ empty_parms ()\n %token ELLIPSIS\n \n /* the reserved words */\n-/* SCO include files test \"ASM\", so use something else. */\n+/* SCO include files test \"ASM\", so use something else.  */\n %token SIZEOF ENUM /* STRUCT UNION */ IF ELSE WHILE DO FOR SWITCH CASE DEFAULT\n %token BREAK CONTINUE RETURN GOTO ASM_KEYWORD GCC_ASM_KEYWORD TYPEOF ALIGNOF\n %token SIGOF\n@@ -265,7 +265,7 @@ empty_parms ()\n %type <ttype> new_initializer new_placement\n %type <ttype> using_decl .poplevel\n \n-/* in order to recognize aggr tags as defining and thus shadowing. */\n+/* in order to recognize aggr tags as defining and thus shadowing.  */\n %token TYPENAME_DEFN IDENTIFIER_DEFN PTYPENAME_DEFN\n %type <ttype> named_class_head_sans_basetype_defn\n %type <ttype> identifier_defn IDENTIFIER_DEFN TYPENAME_DEFN PTYPENAME_DEFN\n@@ -316,7 +316,7 @@ program: /* empty */\n \n /* the reason for the strange actions in this rule\n  is so that notype_initdecls when reached via datadef\n- can find a valid list of type and sc specs in $0. */\n+ can find a valid list of type and sc specs in $0.  */\n \n extdefs:\n \t  { $<ttype>$ = NULL_TREE; } lang_extdef\n@@ -1314,15 +1314,15 @@ primary:\n \t\t  class = TREE_CODE_CLASS (TREE_CODE ($$));\n \t\t  if (class == 'e' || class == '1'\n \t\t      || class == '2' || class == '<')\n-                    /* This inhibits warnings in truthvalue_conversion. */\n+                    /* This inhibits warnings in truthvalue_conversion.  */\n \t\t    C_SET_EXP_ORIGINAL_CODE ($$, ERROR_MARK); }\n \t| '(' expr_or_declarator ')'\n \t\t{ char class;\n \t\t  $$ = reparse_decl_as_expr (NULL_TREE, $2);\n \t\t  class = TREE_CODE_CLASS (TREE_CODE ($$));\n \t\t  if (class == 'e' || class == '1'\n \t\t      || class == '2' || class == '<')\n-                    /* This inhibits warnings in truthvalue_conversion. */\n+                    /* This inhibits warnings in truthvalue_conversion.  */\n \t\t    C_SET_EXP_ORIGINAL_CODE ($$, ERROR_MARK); }\n \t| '(' error ')'\n \t\t{ $$ = error_mark_node; }\n@@ -1510,7 +1510,7 @@ primary:\n #if 0\n \t\t  /* This is a future direction of this code, but because\n \t\t     build_x_function_call cannot always undo what is done\n-\t\t     in build_component_ref entirely yet, we cannot do this. */\n+\t\t     in build_component_ref entirely yet, we cannot do this.  */\n \t\t  $$ = build_x_function_call (build_component_ref ($$, $2, NULL_TREE, 1), $4, current_class_ref);\n \t\t  if (TREE_CODE ($$) == CALL_EXPR\n \t\t      && TREE_TYPE ($$) != void_type_node)\n@@ -1525,7 +1525,7 @@ primary:\n #if 0\n \t\t  /* This is a future direction of this code, but because\n \t\t     build_x_function_call cannot always undo what is done\n-\t\t     in build_component_ref entirely yet, we cannot do this. */\n+\t\t     in build_component_ref entirely yet, we cannot do this.  */\n \t\t  $$ = build_x_function_call (build_component_ref ($$, $2, NULL_TREE, 1), NULL_TREE, current_class_ref);\n \t\t  if (TREE_CODE ($$) == CALL_EXPR\n \t\t      && TREE_TYPE ($$) != void_type_node)\n@@ -2029,7 +2029,7 @@ nomods_initdcl0:\n \t;\n \n /* the * rules are dummies to accept the Apollo extended syntax\n-   so that the header files compile. */\n+   so that the header files compile.  */\n maybe_attribute:\n       /* empty */\n   \t\t{ $$ = NULL_TREE; }\n@@ -2203,7 +2203,7 @@ structsp:\n \t\t    yychar = YYLEX;\n \t\t  semi = yychar == ';';\n \t\t  /* finish_struct nukes this anyway; if\n-\t\t     finish_exception does too, then it can go. */\n+\t\t     finish_exception does too, then it can go.  */\n \t\t  if (semi)\n \t\t    note_got_semicolon ($1);\n \n@@ -2692,7 +2692,7 @@ component_decl_1:\n \t\t{ $$ = do_class_using_decl ($1); }\n \t;\n \n-/* The case of exactly one component is handled directly by component_decl. */\n+/* The case of exactly one component is handled directly by component_decl.  */\n /* ??? Huh? ^^^ */\n components:\n \t  /* empty: possibly anonymous */\n@@ -3100,7 +3100,7 @@ ptr_to_mem:\n \t;\n \n /* All uses of explicit global scope must go through this nonterminal so\n-   that got_scope will be set before yylex is called to get the next token. */\n+   that got_scope will be set before yylex is called to get the next token.  */\n global_scope:\n \t  SCOPE\n \t\t{ got_scope = void_type_node; }\n@@ -3738,7 +3738,7 @@ handler_args:\n \t| '(' typed_typespecs after_type_declarator ')'\n \t\t{ check_for_new_type (\"inside exception declarations\", $2);\n \t\t  expand_start_catch_block ($2.t, $3); }\n-\tThis allows reference parameters... */\n+\tThis allows reference parameters...  */\n \t| '(' parm ')'\n \t\t{ check_for_new_type (\"inside exception declarations\", $2);\n \t\t  expand_start_catch_block (TREE_PURPOSE ($2.t),"}, {"sha": "fc334e4004d3a3c7633aef662d91a211b0568e8c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -21,12 +21,12 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n /* Known bugs or deficiencies include:\n-   * templates for class static data don't work (methods only)\n-   * duplicated method templates can crash the compiler\n-   * interface/impl data is taken from file defining the template\n-   * all methods must be provided in header files; can't use a source\n-     file that contains only the method templates and \"just win\"\n- */\n+\n+     templates for class static data don't work (methods only),\n+     duplicated method templates can crash the compiler,\n+     interface/impl data is taken from file defining the template,\n+     all methods must be provided in header files; can't use a source\n+     file that contains only the method templates and \"just win\".  */\n \n #include \"config.h\"\n #include <stdio.h>\n@@ -78,6 +78,7 @@ begin_template_parm_list ()\n \n /* Process information from new template parameter NEXT and append it to the\n    LIST being built.  */\n+\n tree\n process_template_parm (list, next)\n      tree list, next;\n@@ -274,6 +275,7 @@ tree tsubst\t\tPROTO ((tree, tree*, int, tree));\n /* Convert all template arguments to their appropriate types, and return\n    a vector containing the resulting values.  If any error occurs, return\n    error_mark_node.  */\n+\n static tree\n coerce_template_parms (parms, arglist, in_decl)\n      tree parms, arglist;\n@@ -477,6 +479,7 @@ comp_template_args (oldargs, newargs)\n \n /* Given class template name and parameter list, produce a user-friendly name\n    for the instantiation.  */\n+\n static char *\n mangle_class_name_for_template (name, parms, arglist)\n      char *name;\n@@ -583,13 +586,20 @@ static void\n add_pending_template (d)\n      tree d;\n {\n-  if (TREE_LANG_FLAG_0 (DECL_TEMPLATE_INFO (d)))\n+  tree ti;\n+\n+  if (TREE_CODE_CLASS (TREE_CODE (d)) == 't')\n+    ti = CLASSTYPE_TEMPLATE_INFO (d);\n+  else\n+    ti = DECL_TEMPLATE_INFO (d);\n+\n+  if (TREE_LANG_FLAG_0 (ti))\n     return;\n \n   *template_tail = perm_tree_cons\n     (current_function_decl, d, NULL_TREE);\n   template_tail = &TREE_CHAIN (*template_tail);\n-  TREE_LANG_FLAG_0 (DECL_TEMPLATE_INFO (d)) = 1;\n+  TREE_LANG_FLAG_0 (ti) = 1;\n }\n \n /* Given an IDENTIFIER_NODE (type TEMPLATE_DECL) and a chain of\n@@ -601,6 +611,7 @@ add_pending_template (d)\n \n    IN_DECL, if non-NULL, is the template declaration we are trying to\n    instantiate.  */\n+\n tree\n lookup_template_class (d1, arglist, in_decl)\n      tree d1, arglist;\n@@ -708,7 +719,7 @@ lookup_template_class (d1, arglist, in_decl)\n \t}\n     }\n \n-  /* Seems to be wanted. */\n+  /* Seems to be wanted.  */\n   CLASSTYPE_GOT_SEMICOLON (t) = 1;\n \n   if (! CLASSTYPE_TEMPLATE_INFO (t))\n@@ -723,7 +734,7 @@ lookup_template_class (d1, arglist, in_decl)\n \n       SET_CLASSTYPE_IMPLICIT_INSTANTIATION (t);\n \n-      /* We need to set this again after CLASSTYPE_TEMPLATE_INFO is set up. */\n+      /* We need to set this again after CLASSTYPE_TEMPLATE_INFO is set up.  */\n       DECL_ASSEMBLER_NAME (TYPE_MAIN_DECL (t)) = id;\n       if (! uses_template_parms (arglist))\n \tDECL_ASSEMBLER_NAME (TYPE_MAIN_DECL (t)) \n@@ -732,14 +743,7 @@ lookup_template_class (d1, arglist, in_decl)\n       if (flag_external_templates && ! uses_template_parms (arglist)\n \t  && CLASSTYPE_INTERFACE_KNOWN (TREE_TYPE (template))\n \t  && ! CLASSTYPE_INTERFACE_ONLY (TREE_TYPE (template)))\n-\t{\n-\t  tree d;\n-\n-\t  instantiate_class_template (t);\n-\n-\t  for (d = TYPE_METHODS (t); d; d = TREE_CHAIN (d))\n-\t    add_pending_template (d);\n-\t}\n+\tadd_pending_template (t);\n     }\n \n   return t;\n@@ -1116,7 +1120,7 @@ instantiate_class_template (type)\n \t  {\n \t    if (! uses_template_parms (r))\n \t      pending_statics = perm_tree_cons (NULL_TREE, r, pending_statics);\n-\t    /* Perhaps I should do more of grokfield here. */\n+\t    /* Perhaps I should do more of grokfield here.  */\n \t    start_decl_1 (r);\n \t    DECL_IN_AGGR_P (r) = 1;\n \t    DECL_EXTERNAL (r) = 1;\n@@ -1188,6 +1192,8 @@ instantiate_class_template (type)\n       /* XXX handle attributes */\n       type = finish_struct_1 (type, NULL_TREE, 0);\n       CLASSTYPE_GOT_SEMICOLON (type) = 1;\n+\n+      repo_template_used (type);\n     }\n   else\n     {\n@@ -1484,6 +1490,12 @@ tsubst (t, args, nargs, in_decl)\n \t      tree_cons (argvec, r, DECL_TEMPLATE_INSTANTIATIONS (tmpl));\n \t  }\n \n+\t/* Like grokfndecl.  If we don't do this, pushdecl will mess up our\n+\t   TREE_CHAIN because it doesn't find a previous decl.  Sigh.  */\n+\tif (member\n+\t    && IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (r)) == NULL_TREE)\n+\t  IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (r)) = r;\n+\n \treturn r;\n       }\n \n@@ -1876,6 +1888,9 @@ tsubst_copy (t, args, nargs, in_decl)\n       \n     case CAST_EXPR:\n     case REINTERPRET_CAST_EXPR:\n+    case CONST_CAST_EXPR:\n+    case STATIC_CAST_EXPR:\n+    case DYNAMIC_CAST_EXPR:\n       return build1\n \t(code, tsubst (TREE_TYPE (t), args, nargs, in_decl),\n \t tsubst_copy (TREE_OPERAND (t, 0), args, nargs, in_decl));\n@@ -2038,6 +2053,13 @@ tsubst_copy (t, args, nargs, in_decl)\n     case TYPENAME_TYPE:\n       return tsubst (t, args, nargs, in_decl);\n \n+    case IDENTIFIER_NODE:\n+      if (IDENTIFIER_TYPENAME_P (t))\n+\treturn build_typename_overload\n+\t  (tsubst (TREE_TYPE (t), args, nargs, in_decl));\n+      else\n+\treturn t;\n+\n     default:\n       return t;\n     }\n@@ -2381,7 +2403,7 @@ overload_template_name (type)\n \n    If SUBR is 1, we're being called recursively (to unify the arguments of\n    a function or method parameter of a function template), so don't zero\n-   out targs and don't fail on an incomplete match. */\n+   out targs and don't fail on an incomplete match.  */\n \n int\n type_unification (tparms, targs, parms, args, nsubsts, subr)\n@@ -2497,6 +2519,7 @@ type_unification (tparms, targs, parms, args, nsubsts, subr)\n }\n \n /* Tail recursion is your friend.  */\n+\n static int\n unify (tparms, targs, ntparms, parm, arg, nsubsts)\n      tree tparms, *targs, parm, arg;\n@@ -2726,6 +2749,7 @@ mark_decl_instantiated (result, extern_p)\n }\n \n /* called from the parser.  */\n+\n void\n do_function_instantiation (declspecs, declarator, storage)\n      tree declspecs, declarator, storage;\n@@ -2948,7 +2972,7 @@ instantiate_decl (d)\n \t    warn_if_unknown_interface (pattern);\n \t}\n \n-      if (at_eof && ! DECL_INLINE (d))\n+      if (at_eof)\n \timport_export_decl (d);\n     }\n "}, {"sha": "47a111bc00d466d6251450e6695572cf768106f8", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -99,7 +99,7 @@ repo_get_id (t)\n }\n \n /* Note that a template has been used.  If we can see the definition, offer\n-   to emit it. */\n+   to emit it.  */\n \n void\n repo_template_used (t)"}, {"sha": "4bd32096b338f2e6f6c0501b0108740d2fc27b6b", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -55,6 +55,7 @@ init_rtti_processing ()\n    pointer somewhere, return a pointer to a possible sub-object that\n    has a virtual table pointer in it that is the vtable parent for\n    that sub-object.  */\n+\n static tree\n build_headof_sub (exp)\n      tree exp;\n@@ -71,6 +72,7 @@ build_headof_sub (exp)\n    object pointed to by EXP with type cv void*, if the class has any\n    virtual functions (TYPE_VIRTUAL_P), else just return the\n    expression.  */\n+\n static tree\n build_headof (exp)\n      tree exp;\n@@ -112,6 +114,7 @@ build_headof (exp)\n /* Return the type_info node associated with the expression EXP.  If EXP is\n    a reference to a polymorphic class, return the dynamic type; otherwise\n    return the static type of the expression.  */\n+\n tree\n build_typeid (exp)\n      tree exp;\n@@ -131,11 +134,11 @@ build_typeid (exp)\n   if (TREE_CODE (exp) == VAR_DECL && TREE_CODE (type) == RECORD_TYPE)\n     return get_typeid (type);\n \n-  /* peel back references, so they match. */\n+  /* peel back references, so they match.  */\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n \n-  /* Peel off cv qualifiers. */\n+  /* Peel off cv qualifiers.  */\n   type = TYPE_MAIN_VARIANT (type);\n \n   /* Apply trivial conversion T -> T& for dereferenced ptrs.  */\n@@ -269,6 +272,7 @@ get_typeid_1 (type)\n }\n   \n /* Return the type_info object for TYPE, creating it if necessary.  */\n+\n tree\n get_typeid (type)\n      tree type;\n@@ -285,7 +289,7 @@ get_typeid (type)\n     type = TREE_TYPE (type);\n \n   /* The top-level cv-qualifiers of the lvalue expression or the type-id\n-     that is the operand of typeid are always ignored. */\n+     that is the operand of typeid are always ignored.  */\n   type = TYPE_MAIN_VARIANT (type);\n \n   return get_typeid_1 (type);\n@@ -325,7 +329,8 @@ throw_bad_cast ()\n /* Check whether TEST is null before returning RESULT.  If TEST is used in\n    RESULT, it must have previously had a save_expr applied to it.  */\n \n-tree ifnonnull (test, result)\n+tree\n+ifnonnull (test, result)\n      tree test, result;\n {\n   return build (COND_EXPR, TREE_TYPE (result),\n@@ -349,6 +354,12 @@ build_dynamic_cast (type, expr)\n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n   \n+  if (current_template_parms)\n+    {\n+      tree t = build_min (DYNAMIC_CAST_EXPR, type, expr);\n+      return t;\n+    }\n+\n   switch (tc)\n     {\n     case POINTER_TYPE:\n@@ -539,7 +550,7 @@ build_dynamic_cast (type, expr)\n \t      return build (COND_EXPR, type, result, result, expr1);\n \t    }\n \n-\t  /* Now back to the type we want from a void*. */\n+\t  /* Now back to the type we want from a void*.  */\n \t  result = convert (type, result);\n           return ifnonnull (expr, result);\n \t}\n@@ -616,7 +627,7 @@ expand_si_desc (tdecl, type)\n   expand_expr_stmt (fn);\n }\n \n-/* Build an initializer for a __class_type_info node. */\n+/* Build an initializer for a __class_type_info node.  */\n \n static void\n expand_class_desc (tdecl, type)\n@@ -797,6 +808,7 @@ expand_class_desc (tdecl, type)\n }\n \n /* Build an initializer for a __pointer_type_info node.  */\n+\n static void\n expand_ptr_desc (tdecl, type)\n      tree tdecl;\n@@ -1022,13 +1034,14 @@ synthesize_tinfo_fn (fndecl)\n \n #if 0\n /* This is the old dossier type descriptor generation code, it's much\n-   more extended than rtti. It's reserved for later use. */\n+   more extended than rtti. It's reserved for later use.  */\n /* Build an initializer for a __t_desc node.  So that we can take advantage\n    of recursion, we accept NULL for TYPE.\n    DEFINITION is greater than zero iff we must define the type descriptor\n    (as opposed to merely referencing it).  1 means treat according to\n    #pragma interface/#pragma implementation rules.  2 means define as\n    global and public, no matter what.  */\n+\n tree\n build_t_desc (type, definition)\n      tree type;\n@@ -1192,6 +1205,7 @@ build_t_desc (type, definition)\n }\n \n /* Build an initializer for a __i_desc node.  */\n+\n tree\n build_i_desc (decl)\n      tree decl;\n@@ -1225,6 +1239,7 @@ build_i_desc (decl)\n }\n \n /* Build an initializer for a __m_desc node.  */\n+\n tree\n build_m_desc (decl)\n      tree decl;"}, {"sha": "1446df11cdceef6377892e848bd2482cd7451594", "filename": "gcc/cp/search.c", "status": "modified", "additions": 106, "deletions": 67, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -20,7 +20,7 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* High-level class interface. */\n+/* High-level class interface.  */\n \n #include \"config.h\"\n #include \"tree.h\"\n@@ -40,9 +40,11 @@ extern tree abort_fndecl;\n #include \"stack.h\"\n \n /* Obstack used for remembering decision points of breadth-first.  */\n+\n static struct obstack search_obstack;\n \n /* Methods for pushing and popping objects to and from obstacks.  */\n+\n struct stack_level *\n push_stack_level (obstack, tp, size)\n      struct obstack *obstack;\n@@ -85,6 +87,7 @@ static tree vbase_decl_ptr_intermediate, vbase_decl_ptr;\n static tree vbase_init_result;\n \n /* Allocate a level of searching.  */\n+\n static struct search_level *\n push_search_level (stack, obstack)\n      struct stack_level *stack;\n@@ -97,6 +100,7 @@ push_search_level (stack, obstack)\n }\n \n /* Discard a level of search allocation.  */\n+\n static struct search_level *\n pop_search_level (obstack)\n      struct stack_level *obstack;\n@@ -107,6 +111,7 @@ pop_search_level (obstack)\n }\n \f\n /* Search memoization.  */\n+\n struct type_level\n {\n   struct stack_level base;\n@@ -157,6 +162,7 @@ static struct type_level *prev_type_stack;\n static tree closed_envelopes = NULL_TREE;\n \n /* Allocate a level of type memoization context.  */\n+\n static struct type_level *\n push_type_level (stack, obstack)\n      struct stack_level *stack;\n@@ -186,6 +192,7 @@ pop_type_level (stack)\n \n /* Make something that looks like a TREE_LIST, but\n    do it on the type_obstack_entries obstack.  */\n+\n static tree\n my_tree_cons (purpose, value, chain)\n      tree purpose, value, chain;\n@@ -217,6 +224,7 @@ my_build_string (str)\n \f\n /* Memoizing machinery to make searches for multiple inheritance\n    reasonably efficient.  */\n+\n #define MEMOIZE_HASHSIZE 8\n typedef struct memoized_entry\n {\n@@ -247,6 +255,7 @@ my_new_memoized_entry (chain)\n }\n \n /* Clears the deferred pop from pop_memoized_context, if any.  */\n+\n static void\n clear_memoized_cache ()\n {\n@@ -266,7 +275,7 @@ make_memoized_table_entry (type, name, function_p)\n      tree type, name;\n      int function_p;\n {\n-  int index = MEMOIZED_HASH_FN (name);\n+  int idx = MEMOIZED_HASH_FN (name);\n   tree entry, *prev_entry;\n \n   /* Since we allocate from the type_obstack, we must pop any deferred\n@@ -284,9 +293,9 @@ make_memoized_table_entry (type, name, function_p)\n \tmy_friendly_abort (88);\n     }\n   if (function_p)\n-    prev_entry = &MEMOIZED_FNFIELDS (CLASSTYPE_MTABLE_ENTRY (type), index);\n+    prev_entry = &MEMOIZED_FNFIELDS (CLASSTYPE_MTABLE_ENTRY (type), idx);\n   else\n-    prev_entry = &MEMOIZED_FIELDS (CLASSTYPE_MTABLE_ENTRY (type), index);\n+    prev_entry = &MEMOIZED_FIELDS (CLASSTYPE_MTABLE_ENTRY (type), idx);\n \n   entry = my_tree_cons (name, NULL_TREE, *prev_entry);\n   *prev_entry = entry;\n@@ -325,6 +334,7 @@ make_memoized_table_entry (type, name, function_p)\n    be NULL_TREE if we are not in a class's scope.\n \n    USE_OLD, if nonzero tries to use previous context.  */\n+\n void\n push_memoized_context (type, use_old)\n      tree type;\n@@ -363,6 +373,7 @@ push_memoized_context (type, use_old)\n    If we wanted to, we could not use pop_search_level, since\n    poping that level allows the data we have collected to\n    be clobbered; a stack of obstacks would be needed.  */\n+\n void\n pop_memoized_context (use_old)\n      int use_old;\n@@ -402,6 +413,7 @@ pop_memoized_context (use_old)\n    the same type as the type given in PARENT.  To be optimal, we want\n    the first one that is found by going through the least number of\n    virtual bases.  DEPTH should be NULL_PTR.  */\n+\n static tree\n get_vbase (parent, binfo, depth)\n      tree parent, binfo;\n@@ -448,6 +460,7 @@ get_vbase (parent, binfo, depth)\n /* Convert EXPR to a virtual base class of type TYPE.  We know that\n    EXPR is a non-null POINTER_TYPE to RECORD_TYPE.  We also know that\n    the type of what expr points to has a virtual base of type TYPE.  */\n+\n tree\n convert_pointer_to_vbase (type, expr)\n      tree type;\n@@ -508,6 +521,7 @@ get_binfo (parent, binfo, protect)\n }\n \n /* This is the newer depth first get_base_distance routine.  */\n+\n static int\n get_base_distance_recursive (binfo, depth, is_private, rval,\n \t\t\t     rval_private_ptr, new_binfo_ptr, parent, path_ptr,\n@@ -575,7 +589,7 @@ get_base_distance_recursive (binfo, depth, is_private, rval,\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n \n       /* Find any specific instance of a virtual base, when searching with\n-\t a binfo... */\n+\t a binfo...  */\n       if (BINFO_MARKED (base_binfo) == 0 || TREE_CODE (parent) == TREE_VEC)\n \t{\n \t  int via_private\n@@ -589,7 +603,7 @@ get_base_distance_recursive (binfo, depth, is_private, rval,\n \t  int was;\n \n \t  /* When searching for a non-virtual, we cannot mark\n-\t     virtually found binfos. */\n+\t     virtually found binfos.  */\n \t  if (! this_virtual)\n \t    SET_BINFO_MARKED (base_binfo);\n \n@@ -602,7 +616,7 @@ get_base_distance_recursive (binfo, depth, is_private, rval,\n \t\t\t\t\t      protect, via_virtual_ptr,\n \t\t\t\t\t      this_virtual,\n \t\t\t\t\t      current_scope_in_chain);\n-\t  /* watch for updates; only update if path is good. */\n+\t  /* watch for updates; only update if path is good.  */\n \t  if (path_ptr && WATCH_VALUES (rval, *via_virtual_ptr) != was)\n \t    BINFO_INHERITANCE_CHAIN (base_binfo) = binfo;\n \t  if (rval == -2 && *via_virtual_ptr == 0)\n@@ -658,7 +672,7 @@ get_base_distance (parent, binfo, protect, path_ptr)\n     type = BINFO_TYPE (binfo);\n   else if (IS_AGGR_TYPE_CODE (TREE_CODE (binfo)))\n     {\n-      type = binfo;\n+      type = complete_type (binfo);\n       binfo = TYPE_BINFO (type);\n \n       if (path_ptr)\n@@ -693,7 +707,7 @@ get_base_distance (parent, binfo, protect, path_ptr)\n   if (rval && protect && rval_private)\n     return -3;\n \n-  /* find real virtual base classes. */\n+  /* find real virtual base classes.  */\n   if (rval == -1 && TREE_CODE (parent) == TREE_VEC\n       && parent == binfo_member (BINFO_TYPE (parent),\n \t\t\t\t CLASSTYPE_VBASECLASSES (type)))\n@@ -716,6 +730,7 @@ get_base_distance (parent, binfo, protect, path_ptr)\n /* Do a 1-level search for NAME as a member of TYPE.  The caller must\n    figure out whether it can access this field.  (Since it is only one\n    level, this is reasonable.)  */\n+\n static tree\n lookup_field_1 (type, name)\n      tree type, name;\n@@ -759,11 +774,11 @@ lookup_field_1 (type, name)\n \n /* There are a number of cases we need to be aware of here:\n \t\t\t current_class_type\tcurrent_function_decl\n-   * global\t\t\tNULL\t\t\tNULL\n-   * fn-local\t\t\tNULL\t\t\tSET\n-   * class-local\t\tSET\t\t\tNULL\n-   * class->fn\t\t\tSET\t\t\tSET\n-   * fn->class\t\t\tSET\t\t\tSET\n+     global\t\t\tNULL\t\t\tNULL\n+     fn-local\t\t\tNULL\t\t\tSET\n+     class-local\t\tSET\t\t\tNULL\n+     class->fn\t\t\tSET\t\t\tSET\n+     fn->class\t\t\tSET\t\t\tSET\n \n    Those last two make life interesting.  If we're in a function which is\n    itself inside a class, we need decls to go into the fn's decls (our\n@@ -806,7 +821,7 @@ current_scope ()\n    lexical scope because it is protected.\n \n    access_private_node means that the field cannot be accessed by the current\n-   lexical scope because it is private. */\n+   lexical scope because it is private.  */\n \n #if 0\n #define PUBLIC_RETURN return (DECL_PUBLIC (field) = 1), access_public_node\n@@ -998,6 +1013,7 @@ compute_access (basetype_path, field)\n    found as a base class and sub-object of the object denoted by\n    BINFO.  This routine relies upon binfos not being shared, except\n    for binfos for virtual bases.  */\n+\n static int\n is_subobject_of_p (parent, binfo)\n      tree parent, binfo;\n@@ -1024,7 +1040,8 @@ is_subobject_of_p (parent, binfo)\n    correspond to ANSI working paper Sept 17, 1992 10p4.  The two\n    binfos given are the binfos corresponding to the particular places\n    the FIELD_DECLs are found.  This routine relies upon binfos not\n-   being shared, except for virtual bases. */\n+   being shared, except for virtual bases.  */\n+\n static int\n hides (hider_binfo, hidee_binfo)\n      tree hider_binfo, hidee_binfo;\n@@ -1034,29 +1051,30 @@ hides (hider_binfo, hidee_binfo)\n      part is always true is the second part is true.\n \n      When hider and hidee are the same (two ways to get to the exact\n-     same member) we consider either one as hiding the other. */\n+     same member) we consider either one as hiding the other.  */\n   return is_subobject_of_p (hidee_binfo, hider_binfo);\n }\n \n /* Very similar to lookup_fnfields_1 but it ensures that at least one\n    function was declared inside the class given by TYPE.  It really should\n    only return functions that match the given TYPE.  */\n+\n static int\n lookup_fnfields_here (type, name)\n      tree type, name;\n {\n-  int index = lookup_fnfields_1 (type, name);\n+  int idx = lookup_fnfields_1 (type, name);\n   tree fndecls;\n \n   /* ctors and dtors are always only in the right class.  */\n-  if (index <= 1)\n-    return index;\n-  fndecls = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), index);\n+  if (idx <= 1)\n+    return idx;\n+  fndecls = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx);\n   while (fndecls)\n     {\n       if (TYPE_MAIN_VARIANT (DECL_CLASS_CONTEXT (fndecls))\n \t  == TYPE_MAIN_VARIANT (type))\n-\treturn index;\n+\treturn idx;\n       fndecls = TREE_CHAIN (fndecls);\n     }\n   return -1;\n@@ -1070,6 +1088,7 @@ lookup_fnfields_here (type, name)\n    It was not clear what should happen if WANT_TYPE is set, and an\n    ambiguity is found.  At least one use (lookup_name) to not see\n    the error.  */\n+\n tree\n lookup_field (xbasetype, name, protect, want_type)\n      register tree xbasetype, name;\n@@ -1101,7 +1120,7 @@ lookup_field (xbasetype, name, protect, want_type)\n \n   /* Set this to nonzero if we don't know how to compute\n      accurate error messages for access control.  */\n-  int index = MEMOIZED_HASH_FN (name);\n+  int idx = MEMOIZED_HASH_FN (name);\n \n #if 0\n   /* We cannot search for constructor/destructor names like this.  */\n@@ -1128,7 +1147,7 @@ lookup_field (xbasetype, name, protect, want_type)\n \n   if (CLASSTYPE_MTABLE_ENTRY (type))\n     {\n-      tree tem = MEMOIZED_FIELDS (CLASSTYPE_MTABLE_ENTRY (type), index);\n+      tree tem = MEMOIZED_FIELDS (CLASSTYPE_MTABLE_ENTRY (type), idx);\n \n       while (tem && TREE_PURPOSE (tem) != name)\n \t{\n@@ -1232,7 +1251,7 @@ lookup_field (xbasetype, name, protect, want_type)\n   TREE_VIA_PROTECTED (basetype_chain) = TREE_VIA_PROTECTED (basetype_path);\n   TREE_VIA_VIRTUAL (basetype_chain) = TREE_VIA_VIRTUAL (basetype_path);\n \n-  /* The ambiguity check relies upon breadth first searching. */\n+  /* The ambiguity check relies upon breadth first searching.  */\n \n   search_stack = push_search_level (search_stack, &search_obstack);\n   binfo = basetype_path;\n@@ -1303,12 +1322,12 @@ lookup_field (xbasetype, name, protect, want_type)\n \t  else if (rval_binfo && hides (rval_binfo_h, binfo_h))\n \t    {\n \t      /* This is ok, the member found is in rval_binfo, not\n-\t\t here (binfo). */\n+\t\t here (binfo).  */\n \t    }\n \t  else if (rval_binfo==NULL_TREE || hides (binfo_h, rval_binfo_h))\n \t    {\n \t      /* This is ok, the member found is here (binfo), not in\n-\t\t rval_binfo. */\n+\t\t rval_binfo.  */\n \t      if (nval)\n \t\t{\n \t\t  rval = nval;\n@@ -1320,15 +1339,15 @@ lookup_field (xbasetype, name, protect, want_type)\n \t\t}\n \t      else\n \t\t{\n-\t\t  /* Undo finding it before, as something else hides it. */\n+\t\t  /* Undo finding it before, as something else hides it.  */\n \t\t  rval = NULL_TREE;\n \t\t}\n \t      rval_binfo = binfo;\n \t      rval_binfo_h = binfo_h;\n \t    }\n \t  else\n \t    {\n-\t      /* This is ambiguous. */\n+\t      /* This is ambiguous.  */\n \t      errstr = \"request for member `%D' is ambiguous\";\n \t      protect += 2;\n \t      break;\n@@ -1453,6 +1472,7 @@ lookup_field (xbasetype, name, protect, want_type)\n }\n \n /* Try to find NAME inside a nested class.  */\n+\n tree\n lookup_nested_field (name, complain)\n      tree name;\n@@ -1517,6 +1537,7 @@ lookup_nested_field (name, complain)\n \n /* TYPE is a class type. Return the index of the fields within\n    the method vector with name NAME, or -1 is no such field exists.  */\n+\n static int\n lookup_fnfields_1 (type, name)\n      tree type, name;\n@@ -1573,6 +1594,7 @@ lookup_fnfields_1 (type, name)\n    As a special case, is COMPLAIN is -1, we don't complain, and we\n    don't return error_mark_node, but rather the complete list of\n    virtuals.  This is used by get_virtuals_named_this.  */\n+\n tree\n lookup_fnfields (basetype_path, name, complain)\n      tree basetype_path, name;\n@@ -1604,7 +1626,7 @@ lookup_fnfields (basetype_path, name, complain)\n \n   /* Set this to nonzero if we don't know how to compute\n      accurate error messages for access control.  */\n-  int index = MEMOIZED_HASH_FN (name);\n+  int idx = MEMOIZED_HASH_FN (name);\n \n   if (complain == -1)\n     {\n@@ -1625,10 +1647,10 @@ lookup_fnfields (basetype_path, name, complain)\n   binfo_h = binfo;\n   type = complete_type (BINFO_TYPE (basetype_path));\n \n-  /* The memoization code is in need of maintenance. */\n+  /* The memoization code is in need of maintenance.  */\n   if (!find_all && CLASSTYPE_MTABLE_ENTRY (type))\n     {\n-      tree tem = MEMOIZED_FNFIELDS (CLASSTYPE_MTABLE_ENTRY (type), index);\n+      tree tem = MEMOIZED_FNFIELDS (CLASSTYPE_MTABLE_ENTRY (type), idx);\n \n       while (tem && TREE_PURPOSE (tem) != name)\n \t{\n@@ -1685,19 +1707,19 @@ lookup_fnfields (basetype_path, name, complain)\n   else\n     entry = 0;\n \n-  index = lookup_fnfields_here (type, name);\n-  if (index >= 0 || lookup_field_1 (type, name))\n+  idx = lookup_fnfields_here (type, name);\n+  if (idx >= 0 || lookup_field_1 (type, name))\n     {\n       rval_binfo = basetype_path;\n       rval_binfo_h = rval_binfo;\n     }\n \n-  if (index >= 0)\n+  if (idx >= 0)\n     {\n-      rval = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), index);\n+      rval = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx);\n       rvals = my_tree_cons (basetype_path, rval, rvals);\n       if (BINFO_BASETYPES (binfo) && CLASSTYPE_BASELINK_VEC (type))\n-\tTREE_TYPE (rvals) = TREE_VEC_ELT (CLASSTYPE_BASELINK_VEC (type), index);\n+\tTREE_TYPE (rvals) = TREE_VEC_ELT (CLASSTYPE_BASELINK_VEC (type), idx);\n \n       if (entry)\n \t{\n@@ -1734,7 +1756,7 @@ lookup_fnfields (basetype_path, name, complain)\n       TREE_VIA_VIRTUAL (basetype_chain) = TREE_VIA_VIRTUAL (basetype_path);\n     }\n \n-  /* The ambiguity check relies upon breadth first searching. */\n+  /* The ambiguity check relies upon breadth first searching.  */\n \n   search_stack = push_search_level (search_stack, &search_obstack);\n   binfo = basetype_path;\n@@ -1744,7 +1766,7 @@ lookup_fnfields (basetype_path, name, complain)\n     {\n       tree binfos = BINFO_BASETYPES (binfo);\n       int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-      int index;\n+      int idx;\n \n       /* Process and/or queue base types.  */\n       for (i = 0; i < n_baselinks; i++)\n@@ -1794,32 +1816,32 @@ lookup_fnfields (basetype_path, name, complain)\n \t and we do find NAME in TYPE, verify that such a second\n \t sighting is in fact valid.  */\n \n-      index = lookup_fnfields_here (type, name);\n+      idx = lookup_fnfields_here (type, name);\n \n-      if (index >= 0 || (lookup_field_1 (type, name)!=NULL_TREE && !find_all))\n+      if (idx >= 0 || (lookup_field_1 (type, name)!=NULL_TREE && !find_all))\n \t{\n \t  if (rval_binfo && !find_all && hides (rval_binfo_h, binfo_h))\n \t    {\n \t      /* This is ok, the member found is in rval_binfo, not\n-\t\t here (binfo). */\n+\t\t here (binfo).  */\n \t    }\n \t  else if (rval_binfo==NULL_TREE || find_all || hides (binfo_h, rval_binfo_h))\n \t    {\n \t      /* This is ok, the member found is here (binfo), not in\n-\t\t rval_binfo. */\n-\t      if (index >= 0)\n+\t\t rval_binfo.  */\n+\t      if (idx >= 0)\n \t\t{\n-\t\t  rval = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), index);\n+\t\t  rval = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx);\n \t\t  /* Note, rvals can only be previously set if find_all is\n \t\t     true.  */\n \t\t  rvals = my_tree_cons (basetype_path, rval, rvals);\n \t\t  if (TYPE_BINFO_BASETYPES (type)\n \t\t      && CLASSTYPE_BASELINK_VEC (type))\n-\t\t    TREE_TYPE (rvals) = TREE_VEC_ELT (CLASSTYPE_BASELINK_VEC (type), index);\n+\t\t    TREE_TYPE (rvals) = TREE_VEC_ELT (CLASSTYPE_BASELINK_VEC (type), idx);\n \t\t}\n \t      else\n \t\t{\n-\t\t  /* Undo finding it before, as something else hides it. */\n+\t\t  /* Undo finding it before, as something else hides it.  */\n \t\t  rval = NULL_TREE;\n \t\t  rvals = NULL_TREE;\n \t\t}\n@@ -1828,7 +1850,7 @@ lookup_fnfields (basetype_path, name, complain)\n \t    }\n \t  else\n \t    {\n-\t      /* This is ambiguous. */\n+\t      /* This is ambiguous.  */\n \t      errstr = \"request for method `%D' is ambiguous\";\n \t      rvals = error_mark_node;\n \t      break;\n@@ -2006,6 +2028,7 @@ tree_has_any_destructor_p (binfo, i)\n \n    DTORP is nonzero if we are looking for a destructor.  Destructors\n    need special treatment because they do not match by name.  */\n+\n tree\n get_matching_virtual (binfo, fndecl, dtorp)\n      tree binfo, fndecl;\n@@ -2134,6 +2157,7 @@ get_matching_virtual (binfo, fndecl, dtorp)\n /* Return the list of virtual functions which are abstract in type\n    TYPE that come from non virtual base classes.  See\n    expand_direct_vtbls_init for the style of search we do.  */\n+\n static tree\n get_abstract_virtuals_1 (binfo, do_self, abstract_virtuals)\n      tree binfo;\n@@ -2175,14 +2199,15 @@ get_abstract_virtuals_1 (binfo, do_self, abstract_virtuals)\n /* Return the list of virtual functions which are abstract in type TYPE.\n    This information is cached, and so must be built on a\n    non-temporary obstack.  */\n+\n tree\n get_abstract_virtuals (type)\n      tree type;\n {\n   tree vbases;\n   tree abstract_virtuals = CLASSTYPE_ABSTRACT_VIRTUALS (type);\n \n-  /* First get all from non-virtual bases. */\n+  /* First get all from non-virtual bases.  */\n   abstract_virtuals\n     = get_abstract_virtuals_1 (TYPE_BINFO (type), 1, abstract_virtuals);\n \t\t\t\t\t       \n@@ -2217,7 +2242,7 @@ get_baselinks (type_as_binfo_list, type, name)\n      tree type_as_binfo_list;\n      tree type, name;\n {\n-  int head = 0, tail = 0, index;\n+  int head = 0, tail = 0, idx;\n   tree rval = 0, nval = 0;\n   tree basetypes = type_as_binfo_list;\n   tree binfo = TYPE_BINFO (type);\n@@ -2253,17 +2278,17 @@ get_baselinks (type_as_binfo_list, type, name)\n       basetypes = search_stack->first[head++];\n       binfo = TREE_VALUE (basetypes);\n       type = BINFO_TYPE (binfo);\n-      index = lookup_fnfields_1 (type, name);\n-      if (index >= 0)\n+      idx = lookup_fnfields_1 (type, name);\n+      if (idx >= 0)\n \t{\n-\t  nval = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), index);\n+\t  nval = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx);\n \t  rval = hash_tree_cons (0, 0, 0, basetypes, nval, rval);\n \t  if (TYPE_BINFO_BASETYPES (type) == 0)\n \t    goto dont_queue;\n \t  else if (TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (type)) == 1)\n \t    {\n \t      if (CLASSTYPE_BASELINK_VEC (type))\n-\t\tTREE_TYPE (rval) = TREE_VEC_ELT (CLASSTYPE_BASELINK_VEC (type), index);\n+\t\tTREE_TYPE (rval) = TREE_VEC_ELT (CLASSTYPE_BASELINK_VEC (type), idx);\n \t      goto dont_queue;\n \t    }\n \t}\n@@ -2321,7 +2346,8 @@ static int mi_size;\n /* This routine converts a pointer to be a pointer of an immediate\n    base class.  The normal convert_pointer_to routine would diagnose\n    the conversion as ambiguous, under MI code that has the base class\n-   as an ambiguous base class. */\n+   as an ambiguous base class.  */\n+\n static tree\n convert_pointer_to_single_level (to_type, expr)\n      tree to_type, expr;\n@@ -2340,7 +2366,8 @@ convert_pointer_to_single_level (to_type, expr)\n \n    This routine has to remember the path it walked up, when\n    dfs_init_vbase_pointers is the work function, as otherwise there\n-   would be no record. */\n+   would be no record.  */\n+\n static void\n dfs_walk (binfo, fn, qfn)\n      tree binfo;\n@@ -2554,6 +2581,7 @@ dfs_debug_mark (binfo)\n     virtual base class, given the global pointer vbase_decl_ptr.\n \n     We use the global vbase_types.  ICK!  */\n+\n static void\n dfs_find_vbases (binfo)\n      tree binfo;\n@@ -2624,6 +2652,7 @@ dfs_init_vbase_pointers (binfo)\n /* Sometimes this needs to clear both VTABLE_PATH and NEW_VTABLE.  Other\n    times, just NEW_VTABLE, but optimizer should make both with equal\n    efficiency (though it does not currently).  */\n+\n static void\n dfs_clear_vbase_slots (binfo)\n      tree binfo;\n@@ -2666,6 +2695,7 @@ init_vbase_pointers (type, decl_ptr)\n    We know that if there is more than one place (binfo) the fndecl that the\n    declared, they all refer to the same binfo.  See get_class_offset_1 for\n    the check that ensures this.  */\n+\n static tree\n virtual_context (fndecl, t, vbase)\n      tree fndecl, t, vbase;\n@@ -2717,7 +2747,8 @@ virtual_context (fndecl, t, vbase)\n    offset information for the virtual bases, so the offsets are only\n    calculated once.  The offsets are computed by where we think the\n    vbase should be (as noted by the CLASSTYPE_SEARCH_SLOT) minus where\n-   the vbase really is. */\n+   the vbase really is.  */\n+\n static void\n expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n \t\t      vbase_offsets)\n@@ -2749,7 +2780,7 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n \t  && current_fndecl != abort_fndecl\n \t  && (vc=virtual_context (current_fndecl, t, vbase)) != vbase)\n \t{\n-\t  /* This may in fact need a runtime fixup. */\n+\t  /* This may in fact need a runtime fixup.  */\n \t  tree idx = DECL_VINDEX (current_fndecl);\n \t  tree vtbl = BINFO_VTABLE (binfo);\n \t  tree nvtbl = lookup_name (DECL_NAME (vtbl), 0);\n@@ -2777,7 +2808,7 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n \t\t\t    nvtbl, vtbl);\n \t      TREE_SIDE_EFFECTS (init) = 1;\n \t      expand_expr_stmt (init);\n-\t      /* Update the vtable pointers as necessary. */\n+\t      /* Update the vtable pointers as necessary.  */\n \t      ref = build_vfield_ref (build_indirect_ref (addr, NULL_PTR), DECL_CONTEXT (CLASSTYPE_VFIELD (BINFO_TYPE (binfo))));\n \t      expand_expr_stmt (build_modify_expr (ref, NOP_EXPR,\n \t\t\t\t\t\t   build_unary_op (ADDR_EXPR, nvtbl, 0)));\n@@ -2826,6 +2857,7 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n \n /* Fixup upcast offsets for all direct vtables.  Patterned after\n    expand_direct_vtbls_init.  */\n+\n static void\n fixup_virtual_upcast_offsets (real_binfo, binfo, init_self, can_elide, addr, orig_addr, type, vbase, vbase_offsets)\n      tree real_binfo, binfo;\n@@ -2900,21 +2932,22 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr)\n \n \t  addr = convert_pointer_to_vbase (TREE_TYPE (vbases), vbase_decl_ptr);\n \n-\t  /* Do all vtables from this virtual base. */\n+\t  /* Do all vtables from this virtual base.  */\n \t  /* This assumes that virtual bases can never serve as parent\n \t     binfos.  (in the CLASSTPE_VFIELD_PARENT sense)  */\n \t  expand_direct_vtbls_init (vbases, TYPE_BINFO (BINFO_TYPE (vbases)),\n \t\t\t\t    1, 0, addr);\n \n-\t  /* Now we adjust the offsets for virtual functions that cross\n-\t     virtual boundaries on an implicit upcast on vf call so that\n-\t     the layout of the most complete type is used, instead of\n-\t     assuming the layout of the virtual bases from our current type. */\n+\t  /* Now we adjust the offsets for virtual functions that\n+\t     cross virtual boundaries on an implicit upcast on vf call\n+\t     so that the layout of the most complete type is used,\n+\t     instead of assuming the layout of the virtual bases from\n+\t     our current type.  */\n \n \t  if (flag_vtable_thunks)\n \t    {\n \t      /* We don't have dynamic thunks yet!\n-\t\t So for now, just fail silently. */\n+\t\t So for now, just fail silently.  */\n \t    }\n \t  else\n \t    {\n@@ -2968,6 +3001,7 @@ dfs_get_vbase_types (binfo)\n }\n \n /* get a list of virtual base classes in dfs order.  */\n+\n tree\n get_vbase_types (type)\n      tree type;\n@@ -3097,6 +3131,7 @@ note_debug_info_needed (type)\n /* Subroutines of push_class_decls ().  */\n \n /* Add in a decl to the envelope.  */\n+\n static void\n envelope_add_decl (type, decl, values)\n      tree type, decl, *values;\n@@ -3105,7 +3140,7 @@ envelope_add_decl (type, decl, values)\n   tree name = DECL_NAME (decl);\n   int dont_add = 0;\n \n-  /* virtual base names are always unique. */\n+  /* virtual base names are always unique.  */\n   if (VBASE_NAME_P (name))\n     *values = NULL_TREE;\n \n@@ -3298,6 +3333,7 @@ dfs_pushdecls (binfo)\n }\n \n /* Consolidate unique (by name) member functions.  */\n+\n static void\n dfs_compress_decls (binfo)\n      tree binfo;\n@@ -3340,6 +3376,7 @@ dfs_compress_decls (binfo)\n    with `error_mark_node' so that if they are encountered\n    without explicit qualification, we can emit an error\n    message.  */\n+\n void\n push_class_decls (type)\n      tree type;\n@@ -3394,6 +3431,7 @@ push_class_decls (type)\n }\n \n /* Here's a subroutine we need because C lacks lambdas.  */\n+\n static void\n dfs_unuse_fields (binfo)\n      tree binfo;\n@@ -3517,6 +3555,7 @@ lookup_conversions (type)\n      tree type;\n {\n   conversions = NULL_TREE;\n-  dfs_walk (TYPE_BINFO (type), add_conversions, 0);\n+  if (TYPE_SIZE (type))\n+    dfs_walk (TYPE_BINFO (type), add_conversions, 0);\n   return conversions;\n }"}, {"sha": "f98577c5a061ff9ba434bc2d45423b479b3ed51a", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -153,8 +153,7 @@ build_signature_pointer_or_reference_type (to_type, constp, volatilep, refp)\n \t const s * sptr;\n        };\n \n-     Similarly, for `volatile' and `const volatile'.\n-   */\n+     Similarly, for `volatile' and `const volatile'.  */\n \n   t = make_lang_type (RECORD_TYPE);\n   {\n@@ -423,6 +422,7 @@ match_method_types (sig_mtype, class_mtype)\n }\n \n /* Undo casts of opaque type variables to the RHS types.  */\n+\n static void\n undo_casts (sig_ty)\n      tree sig_ty;\n@@ -562,7 +562,7 @@ build_signature_table_constructor (sig_ty, rhs)\n \t}\n       else\n \t{\n-\t  tree tag, vb_off, delta, index, pfn, vt_off;\n+\t  tree tag, vb_off, delta, idx, pfn, vt_off;\n \t  tree tag_decl, vb_off_decl, delta_decl, index_decl;\n \t  tree pfn_decl, vt_off_decl;\n \n@@ -572,7 +572,7 @@ build_signature_table_constructor (sig_ty, rhs)\n \t      tag = build_unary_op (NEGATE_EXPR, integer_one_node, 0);\n \t      vb_off = build_unary_op (NEGATE_EXPR, integer_one_node, 0);\n \t      delta = integer_zero_node;\n-\t      index = integer_zero_node;\n+\t      idx = integer_zero_node;\n \t      pfn = build_addr_func (rhs_method);\n \t      TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (rhs_method)) = 1;\n \t      TREE_TYPE (pfn) = ptr_type_node;\n@@ -590,7 +590,7 @@ build_signature_table_constructor (sig_ty, rhs)\n \t      else\n \t\tdelta = BINFO_OFFSET\n \t\t  (get_binfo (DECL_CLASS_CONTEXT (rhs_method), rhstype, 1));\n-\t      index = DECL_VINDEX (rhs_method);\n+\t      idx = DECL_VINDEX (rhs_method);\n \t      vt_off = get_vfield_offset (get_binfo (DECL_CONTEXT (rhs_method),\n \t\t\t\t\t\t     rhstype, 0));\n \t    }\n@@ -601,7 +601,7 @@ build_signature_table_constructor (sig_ty, rhs)\n \t      vb_off = build_unary_op (NEGATE_EXPR, integer_one_node, 0);\n \t      delta = BINFO_OFFSET (get_binfo (DECL_CLASS_CONTEXT (rhs_method),\n \t\t\t\t\t       rhstype, 1));\n-\t      index = integer_zero_node;\n+\t      idx = integer_zero_node;\n \t      pfn = build_addr_func (rhs_method);\n \t      TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (rhs_method)) = 1;\n \t      TREE_TYPE (pfn) = ptr_type_node;\n@@ -621,7 +621,7 @@ build_signature_table_constructor (sig_ty, rhs)\n \t  tag = convert (TREE_TYPE (tag_decl), tag);\n \t  vb_off = convert (TREE_TYPE (vb_off_decl), vb_off);\n \t  delta = convert (TREE_TYPE (delta_decl), delta);\n-\t  index = convert (TREE_TYPE (index_decl), index);\n+\t  idx = convert (TREE_TYPE (index_decl), idx);\n \n \t  if (DECL_VINDEX (rhs_method))\n \t    {\n@@ -636,7 +636,7 @@ build_signature_table_constructor (sig_ty, rhs)\n \t      tbl_entry = build_tree_list (pfn_decl, pfn);\n \t    }\n \t  tbl_entry = tree_cons (delta_decl, delta,\n-\t\t\t\t tree_cons (index_decl, index, tbl_entry));\n+\t\t\t\t tree_cons (index_decl, idx, tbl_entry));\n \t  tbl_entry = tree_cons (tag_decl, tag,\n \t\t\t\t tree_cons (vb_off_decl, vb_off, tbl_entry));\n \t  tbl_entry = build (CONSTRUCTOR, sigtable_entry_type,\n@@ -934,15 +934,15 @@ build_signature_method_call (basetype, instance, function, parms)\n   tree tbl_entry = build_component_ref (build1 (INDIRECT_REF, basetype,\n \t\t\t\t\t\tsignature_tbl_ptr),\n \t\t\t\t\tsig_field_name, basetype_path, 1);\n-  tree tag, delta, pfn, vt_off, index, vfn;\n+  tree tag, delta, pfn, vt_off, idx, vfn;\n   tree deflt_call = NULL_TREE, direct_call, virtual_call, result;\n \n   tbl_entry = save_expr (tbl_entry);\n   tag = build_component_ref (tbl_entry, tag_identifier, NULL_TREE, 1);\n   delta = build_component_ref (tbl_entry, delta_identifier, NULL_TREE, 1);\n   pfn = build_component_ref (tbl_entry, pfn_identifier, NULL_TREE, 1);\n   vt_off = build_component_ref (tbl_entry, vt_off_identifier, NULL_TREE, 1);\n-  index = build_component_ref (tbl_entry, index_identifier, NULL_TREE, 1);\n+  idx = build_component_ref (tbl_entry, index_identifier, NULL_TREE, 1);\n   TREE_TYPE (pfn) = build_pointer_type (TREE_TYPE (function)); \n \n   if (IS_DEFAULT_IMPLEMENTATION (function))\n@@ -980,7 +980,7 @@ build_signature_method_call (basetype, instance, function, parms)\n \t\t    convert (ptrdiff_type_node, vt_off));\n       vtbl = build_indirect_ref (build_indirect_ref (vfld, NULL_PTR),\n \t\t\t\t NULL_PTR);\n-      aref = build_array_ref (vtbl, index);\n+      aref = build_array_ref (vtbl, idx);\n \n       if (flag_vtable_thunks)\n \tvfn = aref;"}, {"sha": "90deea77c206538c9c1f230babeb689020a2dd2c", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -35,9 +35,9 @@ Boston, MA 02111-1307, USA.  */\n \n /* This takes a token stream that hasn't decided much about types and\n    tries to figure out as much as it can, with excessive lookahead and\n-   backtracking. */\n+   backtracking.  */\n \n-/* fifo of tokens recognized and available to parser. */\n+/* fifo of tokens recognized and available to parser.  */\n struct token  {\n   /* The values for YYCHAR will fit in a short.  */\n   short\t\tyychar;\n@@ -68,6 +68,7 @@ static int debug_yychar ();\n #endif\n \n /* Initialize token_obstack. Called once, from init_lex.  */\n+\n void\n init_spew ()\n {\n@@ -77,26 +78,29 @@ init_spew ()\n #ifdef SPEW_DEBUG\n /* Use functions for debugging...  */\n \n-/* Return the number of tokens available on the fifo. */\n+/* Return the number of tokens available on the fifo.  */\n+\n static int\n num_tokens ()\n {\n   return (obstack_object_size (&token_obstack) / sizeof (struct token))\n     - first_token;\n }\n \n-/* Fetch the token N down the line from the head of the fifo. */\n+/* Fetch the token N down the line from the head of the fifo.  */\n+\n static struct token*\n nth_token (n)\n      int n;\n {\n   /* could just have this do slurp_ implicitly, but this way is easier\n-   * to debug... */\n+     to debug...  */\n   my_friendly_assert (n < num_tokens (), 298);\n   return ((struct token*)obstack_base (&token_obstack)) + n + first_token;\n }\n \n-/* Add a token to the token fifo. */\n+/* Add a token to the token fifo.  */\n+\n static void\n add_token (t)\n      struct token* t;\n@@ -105,6 +109,7 @@ add_token (t)\n }\n \n /* Consume the next token out of the fifo.  */\n+\n static void\n consume_token ()\n {\n@@ -194,7 +199,7 @@ probe_obstack (h, obj, nlevels)\n   lp = (h)->chunk;\n   /* We use >= rather than > since the object cannot be exactly at\n      the beginning of the chunk but might be an empty object exactly\n-     at the end of an adjacent chunk. */\n+     at the end of an adjacent chunk.  */\n   for (; nlevels != 0 && lp != 0 && ((tree)lp >= obj || (tree)lp->limit < obj);\n        nlevels -= 1)\n     {\n@@ -207,7 +212,7 @@ probe_obstack (h, obj, nlevels)\n /* from lex.c: */\n /* Value is 1 (or 2) if we should try to make the next identifier look like\n    a typename (when it may be a local variable or a class variable).\n-   Value is 0 if we treat this name in a default fashion. */\n+   Value is 0 if we treat this name in a default fashion.  */\n extern int looking_for_typename;\n int looking_for_template;\n \n@@ -262,8 +267,8 @@ yylex ()\n     }\n \n   /* many tokens just need to be returned. At first glance, all we\n-   * have to do is send them back up, but some of them are needed to\n-   * figure out local context. */\n+     have to do is send them back up, but some of them are needed to\n+     figure out local context.  */\n   switch (tmp_token.yychar)\n     {\n     case EMPTY:\n@@ -318,7 +323,7 @@ yylex ()\n       else\n \tlastiddecl = trrr;\n       got_scope = NULL_TREE;\n-      /* and fall through to... */\n+      /* and fall through to...  */\n     case IDENTIFIER_DEFN:\n     case TYPENAME:\n     case TYPENAME_DEFN:\n@@ -344,11 +349,11 @@ yylex ()\n     case AGGR:\n       *nth_token (0) = tmp_token;\n       do_aggr ();\n-      /* fall through to output... */\n+      /* fall through to output...  */\n     case ENUM:\n       /* Set this again, in case we are rescanning.  */\n       looking_for_typename = 1;\n-      /* fall through... */\n+      /* fall through...  */\n     default:\n       consume_token ();\n     }\n@@ -365,11 +370,11 @@ yylex ()\n }\n \n /* token[0] == AGGR (struct/union/enum)\n- * Thus, token[1] is either a TYPENAME or a TYPENAME_DEFN.\n- * If token[2] == '{' or ':' then it's TYPENAME_DEFN.\n- * It's also a definition if it's a forward declaration (as in 'struct Foo;')\n- * which we can tell if token[2] == ';' *and* token[-1] != FRIEND or NEW.\n- */\n+   Thus, token[1] is either a TYPENAME or a TYPENAME_DEFN.\n+   If token[2] == '{' or ':' then it's TYPENAME_DEFN.\n+   It's also a definition if it's a forward declaration (as in 'struct Foo;')\n+   which we can tell if token[2] == ';' *and* token[-1] != FRIEND or NEW.  */\n+\n static int\n do_aggr ()\n {\n@@ -383,7 +388,7 @@ do_aggr ()\n   if (yc2 == ';')\n     {\n       /* It's a forward declaration iff we were not preceded by\n-         'friend' or `new'. */\n+         'friend' or `new'.  */\n       if (first_token > 0)\n \t{\n \t  if (nth_token (-1)->yychar == SCSPEC\n@@ -414,7 +419,8 @@ do_aggr ()\n }  \n   \n #ifdef SPEW_DEBUG    \n-/* debug_yychar takes a yychar (token number) value and prints its name. */\n+/* debug_yychar takes a yychar (token number) value and prints its name.  */\n+\n static int\n debug_yychar (yy)\n      int yy;"}, {"sha": "6a4263fbe40e3e45c2534b99933b8d1743ec9b6e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -54,7 +54,7 @@ real_lvalue_p (ref)\n   switch (TREE_CODE (ref))\n     {\n       /* preincrements and predecrements are valid lvals, provided\n-\t what they refer to are valid lvals. */\n+\t what they refer to are valid lvals.  */\n     case PREINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n     case COMPONENT_REF:\n@@ -124,7 +124,7 @@ lvalue_p (ref)\n   switch (TREE_CODE (ref))\n     {\n       /* preincrements and predecrements are valid lvals, provided\n-\t what they refer to are valid lvals. */\n+\t what they refer to are valid lvals.  */\n     case PREINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n     case COMPONENT_REF:\n@@ -206,6 +206,7 @@ lvalue_or_else (ref, string)\n    Build an encapsulation of the initialization to perform\n    and return it so that it can be processed by language-independent\n    and language-specific expression expanders.  */\n+\n tree\n build_cplus_new (type, init)\n      tree type;\n@@ -279,7 +280,7 @@ break_out_calls (exp)\n   if (code == CALL_EXPR)\n     return copy_node (exp);\n \n-  /* Don't try and defeat a save_expr, as it should only be done once. */\n+  /* Don't try and defeat a save_expr, as it should only be done once.  */\n     if (code == SAVE_EXPR)\n        return exp;\n \n@@ -360,6 +361,7 @@ extern struct obstack *saveable_obstack;\n /* Construct, lay out and return the type of methods belonging to class\n    BASETYPE and whose arguments are described by ARGTYPES and whose values\n    are described by RETTYPE.  If each type exists already, reuse it.  */\n+\n tree\n build_cplus_method_type (basetype, rettype, argtypes)\n      tree basetype, rettype, argtypes;\n@@ -496,6 +498,7 @@ cp_build_type_variant (type, constp, volatilep)\n \n    Note that we don't have to worry about having two paths to the\n    same base type, since this type owns its association list.  */\n+\n void\n propagate_binfo_offsets (binfo, offset)\n      tree binfo;\n@@ -577,6 +580,7 @@ propagate_binfo_offsets (binfo, offset)\n \n    Returns the maximum number of virtual functions any of the virtual\n    baseclasses provide.  */\n+\n int\n layout_vbasetypes (rec, max)\n      tree rec;\n@@ -717,6 +721,7 @@ layout_vbasetypes (rec, max)\n    creates a list of base_binfos in TYPE_BINFO (REC) from BINFOS.\n \n    Returns list of virtual base classes in a FIELD_DECL chain.  */\n+\n tree\n layout_basetypes (rec, binfos)\n      tree rec, binfos;\n@@ -734,7 +739,7 @@ layout_basetypes (rec, binfos)\n   /* Record size so far is CONST_SIZE + VAR_SIZE bits, where CONST_SIZE is\n      an integer and VAR_SIZE is a tree expression.  If VAR_SIZE is null,\n      the size is just CONST_SIZE.  Naturally we try to avoid using\n-     VAR_SIZE.  And so far, we've been successful. */\n+     VAR_SIZE.  And so far, we've been successful.  */\n #if 0\n   register tree var_size = 0;\n #endif\n@@ -769,7 +774,7 @@ layout_basetypes (rec, binfos)\n \t     class A;\n \t     class B: private A { virtual void F(); };\n \n-\t     does not dump core when compiled. */\n+\t     does not dump core when compiled.  */\n \t  my_friendly_abort (121);\n #endif\n \t  continue;\n@@ -805,7 +810,7 @@ layout_basetypes (rec, binfos)\n \t\t\t\t\tbuild_pointer_type (basetype));\n \t  /* If you change any of the below, take a look at all the\n \t     other VFIELD_BASEs and VTABLE_BASEs in the code, and change\n-\t     them too. */\n+\t     them too.  */\n \t  DECL_ASSEMBLER_NAME (decl) = get_identifier (VTABLE_BASE);\n \t  DECL_VIRTUAL_P (decl) = 1;\n \t  DECL_FIELD_CONTEXT (decl) = rec;\n@@ -992,6 +997,7 @@ list_hash_add (hashcode, list)\n    This function frees the list you pass in if it is a duplicate.  */\n \n /* Set to 1 to debug without canonicalization.  Never set by program.  */\n+\n static int debug_no_list_hash = 0;\n \n tree\n@@ -1038,6 +1044,7 @@ hash_tree_cons (via_public, via_virtual, via_protected, purpose, value, chain)\n }\n \n /* Constructor for hashed lists.  */\n+\n tree\n hash_tree_chain (value, chain)\n      tree value, chain;\n@@ -1055,6 +1062,7 @@ hash_tree_chain (value, chain)\n }\n \n /* Similar, but used for concatenating two lists.  */\n+\n tree\n hash_chainon (list1, list2)\n      tree list1, list2;\n@@ -1353,6 +1361,7 @@ is_aggr_type_2 (t1, t2)\n /* Give message using types TYPE1 and TYPE2 as arguments.\n    PFN is the function which will print the message;\n    S is the format string for PFN to use.  */\n+\n void\n message_2_types (pfn, s, type1, type2)\n      void (*pfn) ();\n@@ -1421,6 +1430,7 @@ lang_printable_name (decl)\n \f\n /* Build the FUNCTION_TYPE or METHOD_TYPE which may throw exceptions\n    listed in RAISES.  */\n+\n tree\n build_exception_variant (type, raises)\n      tree type;\n@@ -1436,7 +1446,7 @@ build_exception_variant (type, raises)\n \t  || TYPE_VOLATILE (v) != volatilep)\n \tcontinue;\n \n-      /* @@ This should do set equality, not exact match. */\n+      /* @@ This should do set equality, not exact match.  */\n       if (simple_cst_list_equal (TYPE_RAISES_EXCEPTIONS (v), raises))\n \t/* List of exceptions raised matches previously found list.\n \n@@ -1653,6 +1663,7 @@ perm_manip (t)\n \n /* Assuming T is a node built bottom-up, make it all exist on\n    permanent obstack, if it is not permanent already.  */\n+\n tree\n copy_to_permanent (t)\n      tree t;\n@@ -1701,6 +1712,7 @@ print_lang_statistics ()\n    which `cc' doesn't know how to link.  Note that the C++ front-end\n    no longer actually uses the `assert' macro (instead, it calls\n    my_friendly_assert).  But all of the back-end files still need this.  */\n+\n void\n __eprintf (string, expression, line, filename)\n #ifdef __STDC__\n@@ -1720,8 +1732,9 @@ __eprintf (string, expression, line, filename)\n   abort ();\n }\n \n-/* Return, as an INTEGER_CST node, the number of elements for\n-   TYPE (which is an ARRAY_TYPE).  This counts only elements of the top array. */\n+/* Return, as an INTEGER_CST node, the number of elements for TYPE\n+   (which is an ARRAY_TYPE).  This counts only elements of the top\n+   array.  */\n \n tree\n array_type_nelts_top (type)\n@@ -1732,9 +1745,9 @@ array_type_nelts_top (type)\n \t\t      integer_one_node));\n }\n \n-/* Return, as an INTEGER_CST node, the number of elements for\n-   TYPE (which is an ARRAY_TYPE).  This one is a recursive count of all\n-   ARRAY_TYPEs that are clumped together. */\n+/* Return, as an INTEGER_CST node, the number of elements for TYPE\n+   (which is an ARRAY_TYPE).  This one is a recursive count of all\n+   ARRAY_TYPEs that are clumped together.  */\n \n tree\n array_type_nelts_total (type)\n@@ -1765,6 +1778,7 @@ bot_manip (t)\n }\n   \n /* Actually, we'll just clean out the target exprs for the moment.  */\n+\n tree\n break_out_target_exprs (t)\n      tree t;\n@@ -1918,7 +1932,7 @@ vec_binfo_member (elem, vec)\n \n   if (vec)\n     for (i = 0; i < TREE_VEC_LENGTH (vec); ++i)\n-      if (elem == BINFO_TYPE (TREE_VEC_ELT (vec, i)))\n+      if (comptypes (elem, BINFO_TYPE (TREE_VEC_ELT (vec, i)), 1))\n \treturn TREE_VEC_ELT (vec, i);\n \n   return NULL_TREE;"}, {"sha": "33f883865899cdc3727781e869f476370689fd8d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 101, "deletions": 53, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -127,7 +127,7 @@ tree\n complete_type (type)\n      tree type;\n {\n-  if (TYPE_SIZE (type) != NULL_TREE)\n+  if (type == error_mark_node || TYPE_SIZE (type) != NULL_TREE)\n     ;\n   else if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))\n     {\n@@ -142,6 +142,7 @@ complete_type (type)\n }\n \n /* Return truthvalue of whether type of EXP is instantiated.  */\n+\n int\n type_unknown_p (exp)\n      tree exp;\n@@ -153,6 +154,7 @@ type_unknown_p (exp)\n }\n \n /* Return truthvalue of whether T is function (or pfn) type.  */\n+\n int\n fntype_p (t)\n      tree t;\n@@ -166,6 +168,7 @@ fntype_p (t)\n /* Do `exp = require_instantiated_type (type, exp);' to make sure EXP\n    does not have an uninstantiated type.\n    TYPE is type to instantiate with, if uninstantiated.  */\n+\n tree\n require_instantiated_type (type, exp, errval)\n      tree type, exp, errval;\n@@ -541,7 +544,8 @@ common_type (t1, t2)\n \t  tree b1 = TYPE_OFFSET_BASETYPE (t1);\n \t  tree b2 = TYPE_OFFSET_BASETYPE (t2);\n \n-\t  if (DERIVED_FROM_P (b1, b2) && binfo_or_else (b1, b2))\n+\t  if (comptypes (b1, b2, 1)\n+\t      || (DERIVED_FROM_P (b1, b2) && binfo_or_else (b1, b2)))\n \t    return build_type_attribute_variant (t2, attributes);\n \t  else if (binfo_or_else (b2, b1))\n \t    return build_type_attribute_variant (t1, attributes);\n@@ -554,6 +558,7 @@ common_type (t1, t2)\n }\n \f\n /* Return 1 if TYPE1 and TYPE2 raise the same exceptions.  */\n+\n int\n compexcepttypes (t1, t2)\n      tree t1, t2;\n@@ -616,6 +621,7 @@ comp_array_types (cmp, t1, t2, strict)\n    pointer to a base classes. These allowances do not commute. In this\n    case, TYPE1 is assumed to be the base class, and TYPE2 is assumed to\n    be the derived class.  */\n+\n int\n comptypes (type1, type2, strict)\n      tree type1, type2;\n@@ -931,6 +937,7 @@ comp_target_types (ttl, ttr, nptrs)\n /* If two types share a common base type, return that basetype.\n    If there is not a unique most-derived base type, this function\n    returns ERROR_MARK_NODE.  */\n+\n tree\n common_base_type (tt1, tt2)\n      tree tt1, tt2;\n@@ -990,6 +997,7 @@ common_base_type (tt1, tt2)\n    C++: See comment above about TYPE1, TYPE2, STRICT.\n    If STRICT == 3, it means checking is strict, but do not compare\n    default parameter values.  */\n+\n int\n compparms (parms1, parms2, strict)\n      tree parms1, parms2;\n@@ -1036,6 +1044,7 @@ compparms (parms1, parms2, strict)\n \n /* This really wants return whether or not parameter type lists\n    would make their owning functions assignment compatible or not.  */\n+\n int\n comp_target_parms (parms1, parms2, strict)\n      tree parms1, parms2;\n@@ -1617,6 +1626,7 @@ build_object_ref (datum, basetype, field)\n \n /* Like `build_component_ref, but uses an already found field.\n    Must compute access for current_class_ref.  Otherwise, ok.  */\n+\n tree\n build_component_ref_1 (datum, field, protect)\n      tree datum, field;\n@@ -1689,6 +1699,7 @@ build_component_ref_1 (datum, field, protect)\n    we're dealing with aggregates.  So, we now call this in unary_complex_lvalue,\n    and in build_modify_expr.  The case (in particular) that led to this was\n    with CODE == ADDR_EXPR, since it's not an lvalue when we'd get it there.  */\n+\n static tree\n rationalize_conditional_expr (code, t)\n      enum tree_code code;\n@@ -1704,6 +1715,7 @@ rationalize_conditional_expr (code, t)\n    FIELD_DECL for the field.  If not found return NULL_TREE.  Because\n    anonymous unions can nest, we must also search all anonymous unions\n    that are directly reachable.  */\n+\n static tree\n lookup_anon_field (t, type)\n      tree t, type;\n@@ -1739,6 +1751,7 @@ lookup_anon_field (t, type)\n /* Build a COMPONENT_REF for a given DATUM, and it's member COMPONENT.\n    COMPONENT can be an IDENTIFIER_NODE that is the name of the member\n    that we are interested in, or it can be a FIELD_DECL.  */\n+\n tree\n build_component_ref (datum, component, basetype_path, protect)\n      tree datum, component, basetype_path;\n@@ -1752,7 +1765,8 @@ build_component_ref (datum, component, basetype_path, protect)\n   if (current_template_parms)\n     return build_min_nt (COMPONENT_REF, datum, component);\n \n-  /* If DATUM is a COMPOUND_EXPR or COND_EXPR, move our reference inside it. */\n+  /* If DATUM is a COMPOUND_EXPR or COND_EXPR, move our reference\n+     inside it.  */\n   switch (TREE_CODE (datum))\n     {\n     case COMPOUND_EXPR:\n@@ -1786,7 +1800,7 @@ build_component_ref (datum, component, basetype_path, protect)\n       code = TREE_CODE (basetype);\n     }\n \n-  /* First, see if there is a field or component with name COMPONENT. */\n+  /* First, see if there is a field or component with name COMPONENT.  */\n   if (TREE_CODE (component) == TREE_LIST)\n     {\n       my_friendly_assert (!(TREE_CHAIN (component) == NULL_TREE\n@@ -2076,13 +2090,13 @@ build_indirect_ref (ptr, errorstring)\n    will inherit the type of the array, which will be some pointer type.  */\n \n tree\n-build_x_array_ref (array, index)\n-     tree array, index;\n+build_x_array_ref (array, idx)\n+     tree array, idx;\n {\n-  tree rval = build_opfncall (ARRAY_REF, LOOKUP_NORMAL, array, index, NULL_TREE);\n+  tree rval = build_opfncall (ARRAY_REF, LOOKUP_NORMAL, array, idx, NULL_TREE);\n   if (rval)\n     return rval;\n-  return build_array_ref (array, index);\n+  return build_array_ref (array, idx);\n }\n \n tree\n@@ -2256,7 +2270,7 @@ build_x_function_call (function, params, decl)\n       && TREE_CODE (function) == TREE_LIST\n       && TREE_CHAIN (function) == NULL_TREE)\n     {\n-      /* Undo (Foo:bar)()... */\n+      /* Undo (Foo:bar)()...  */\n       type = TYPE_OFFSET_BASETYPE (type);\n       function = TREE_VALUE (function);\n       my_friendly_assert (TREE_CODE (function) == TREE_LIST, 999);\n@@ -2341,7 +2355,7 @@ build_x_function_call (function, params, decl)\n     {\n       /* Should we undo what was done in build_component_ref? */\n       if (TREE_CODE (TREE_PURPOSE (TREE_OPERAND (function, 1))) == TREE_VEC)\n-\t/* Get the name that build_component_ref hid. */\n+\t/* Get the name that build_component_ref hid.  */\n \tfunction = DECL_NAME (TREE_VALUE (TREE_OPERAND (function, 1)));\n       else\n \tfunction = TREE_PURPOSE (TREE_OPERAND (function, 1));\n@@ -2458,7 +2472,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (function)))\n     {\n-      tree fntype, index, e1, delta, delta2, e2, e3, aref, vtbl;\n+      tree fntype, idx, e1, delta, delta2, e2, e3, aref, vtbl;\n       tree instance;\n \n       tree instance_ptr = *instance_ptrptr;\n@@ -2470,16 +2484,16 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \tfunction = save_expr (function);\n \n       fntype = TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (function));\n-      index = save_expr (build_component_ref (function,\n-\t\t\t\t\t      index_identifier,\n-\t\t\t\t\t      NULL_TREE, 0));\n-      e1 = build (GT_EXPR, boolean_type_node, index,\n+      idx = save_expr (build_component_ref (function,\n+\t\t\t\t\t    index_identifier,\n+\t\t\t\t\t    NULL_TREE, 0));\n+      e1 = build (GT_EXPR, boolean_type_node, idx,\n \t\t  convert (delta_type_node, integer_zero_node));\n       delta = convert (ptrdiff_type_node,\n \t\t       build_component_ref (function, delta_identifier, NULL_TREE, 0));\n       delta2 = DELTA2_FROM_PTRMEMFUNC (function);\n \n-      /* convert down to the right base, before using the instance. */\n+      /* convert down to the right base, before using the instance.  */\n       instance\n \t= convert_pointer_to_real (TYPE_METHOD_BASETYPE (TREE_TYPE (fntype)),\n \t\t\t\t   instance_ptr);\n@@ -2493,7 +2507,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \t\t vtbl, convert (ptrdiff_type_node, delta2));\n       vtbl = build_indirect_ref (vtbl, NULL_PTR);\n       aref = build_array_ref (vtbl, build_binary_op (MINUS_EXPR,\n-\t\t\t\t\t\t     index,\n+\t\t\t\t\t\t     idx,\n \t\t\t\t\t\t     integer_one_node, 1));\n       if (! flag_vtable_thunks)\n \t{\n@@ -2783,7 +2797,7 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n       else if (TREE_CODE (val) == OFFSET_REF\n \t    && TREE_CODE (TREE_TYPE (val)) == METHOD_TYPE)\n \t{\n-\t  /* This is unclean.  Should be handled elsewhere. */\n+\t  /* This is unclean.  Should be handled elsewhere.  */\n \t  val = build_unary_op (ADDR_EXPR, val, 0);\n \t}\n       else if (TREE_CODE (val) == OFFSET_REF)\n@@ -3646,7 +3660,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  tree primop0 = get_narrower (op0, &unsignedp0);\n \t  tree primop1 = get_narrower (op1, &unsignedp1);\n \n-\t  /* Check for comparison of different enum types. */\n+\t  /* Check for comparison of different enum types.  */\n \t  if (flag_int_enum_equivalence == 0 \n \t      && TREE_CODE (TREE_TYPE (orig_op0)) == ENUMERAL_TYPE \n \t      && TREE_CODE (TREE_TYPE (orig_op1)) == ENUMERAL_TYPE \n@@ -3987,7 +4001,7 @@ build_x_unary_op (code, xarg)\n     return build_min_nt (code, xarg, NULL_TREE);\n \n   /* & rec, on incomplete RECORD_TYPEs is the simple opr &, not an\n-     error message. */\n+     error message.  */\n   if (code == ADDR_EXPR\n       && ((IS_AGGR_TYPE_CODE (TREE_CODE (TREE_TYPE (xarg)))\n \t   && TYPE_SIZE (TREE_TYPE (xarg)) == NULL_TREE)\n@@ -4033,6 +4047,7 @@ condition_conversion (expr)\n \n    NOCONVERT nonzero suppresses the default promotions\n    (such as from short to int).  */\n+\n tree\n build_unary_op (code, xarg, noconvert)\n      enum tree_code code;\n@@ -4198,7 +4213,7 @@ build_unary_op (code, xarg, noconvert)\n \t      modify = build_modify_expr (arg, NOP_EXPR, incremented);\n \t      compound = build (COMPOUND_EXPR, TREE_TYPE (arg), modify, value);\n \n-\t      /* Eliminate warning about unused result of + or -. */\n+\t      /* Eliminate warning about unused result of + or -.  */\n \t      TREE_NO_UNUSED_WARNING (compound) = 1;\n \t      return compound;\n \t    }\n@@ -4499,7 +4514,7 @@ unary_complex_lvalue (code, arg)\n \n       t = TREE_OPERAND (arg, 1);\n \n-      if (TREE_CODE (t) == FUNCTION_DECL) /* Check all this code for right semantics. */\n+      if (TREE_CODE (t) == FUNCTION_DECL) /* Check all this code for right semantics.  */\n \treturn build_unary_op (ADDR_EXPR, t, 0);\n       if (TREE_CODE (t) == VAR_DECL)\n \treturn build_unary_op (ADDR_EXPR, t, 0);\n@@ -4648,6 +4663,10 @@ mark_addressable (exp)\n \tTREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (x)) = 1;\n \treturn 1;\n \n+      case CONSTRUCTOR:\n+\tTREE_ADDRESSABLE (x) = 1;\n+\treturn 1;\n+\n       default:\n \treturn 1;\n     }\n@@ -4915,8 +4934,13 @@ build_conditional_expr (ifexp, op1, op2)\n          a type is done using NOP_EXPRs.  */\n       if (code1 == RECORD_TYPE && TYPE_HAS_CONVERSION (type1))\n \t{\n-\t  tree tmp = build_pointer_type\n-\t    (build_type_variant (TREE_TYPE (type2), 1, 1));\n+\t  /* There are other types besides pointers and records.  */\n+\t  tree tmp;\n+\t  if (code2 == POINTER_TYPE)\n+\t      tmp = build_pointer_type\n+\t\t(build_type_variant (TREE_TYPE (type2), 1, 1));\n+\t  else\n+\t    tmp = type2;\n \t  tmp = build_type_conversion (CONVERT_EXPR, tmp, op1, 0);\n \t  if (tmp == NULL_TREE)\n \t    {\n@@ -4928,13 +4952,18 @@ build_conditional_expr (ifexp, op1, op2)\n \t    error (\"ambiguous pointer conversion\");\n \t  else\n \t    STRIP_NOPS (tmp);\n-\t  result_type = common_type (type1, TREE_TYPE (tmp));\n+\t  result_type = common_type (type2, TREE_TYPE (tmp));\n \t  op1 = tmp;\n \t}\n       else if (code2 == RECORD_TYPE && TYPE_HAS_CONVERSION (type2))\n \t{\n-\t  tree tmp = build_pointer_type\n-\t    (build_type_variant (TREE_TYPE (type1), 1, 1));\n+\t  tree tmp;\n+\t  if (code1 == POINTER_TYPE)\n+\t    tmp = build_pointer_type\n+\t      (build_type_variant (TREE_TYPE (type1), 1, 1));\n+\t  else\n+\t    tmp = type1;\n+\n \t  tmp = build_type_conversion (CONVERT_EXPR, tmp, op2, 0);\n \t  if (tmp == NULL_TREE)\n \t    {\n@@ -4976,6 +5005,7 @@ build_conditional_expr (ifexp, op1, op2)\n \f\n /* Handle overloading of the ',' operator when needed.  Otherwise,\n    this function just builds an expression list.  */\n+\n tree\n build_x_compound_expr (list)\n      tree list;\n@@ -5054,6 +5084,12 @@ tree\n build_static_cast (type, expr)\n    tree type, expr;\n {\n+  if (current_template_parms)\n+    {\n+      tree t = build_min (STATIC_CAST_EXPR, type, expr);\n+      return t;\n+    }\n+\n   return build_c_cast (type, expr, 0);\n }\n \n@@ -5118,6 +5154,12 @@ build_const_cast (type, expr)\n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n \n+  if (current_template_parms)\n+    {\n+      tree t = build_min (CONST_CAST_EXPR, type, expr);\n+      return t;\n+    }\n+\n   if (TYPE_PTRMEMFUNC_P (type))\n     type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n   if (TYPE_PTRMEMFUNC_P (intype))\n@@ -5389,8 +5431,8 @@ expand_target_expr (t)\n    to combine the old value of LHS with RHS to get the new value.\n    Or else MODIFYCODE is NOP_EXPR meaning do a simple assignment.\n \n-   C++: If MODIFYCODE is INIT_EXPR, then leave references unbashed.\n-*/\n+   C++: If MODIFYCODE is INIT_EXPR, then leave references unbashed.  */\n+\n tree\n build_modify_expr (lhs, modifycode, rhs)\n      tree lhs;\n@@ -5782,7 +5824,7 @@ build_modify_expr (lhs, modifycode, rhs)\n     }\n   else\n     {\n-      /* Avoid warnings on enum bit fields. */\n+      /* Avoid warnings on enum bit fields.  */\n       if (TREE_CODE (olhstype) == ENUMERAL_TYPE\n \t  && TREE_CODE (lhstype) == INTEGER_TYPE)\n \t{\n@@ -5858,7 +5900,7 @@ build_modify_expr (lhs, modifycode, rhs)\n   if (olhstype == TREE_TYPE (result))\n     return result;\n   /* Avoid warnings converting integral types back into enums\n-     for enum bit fields. */\n+     for enum bit fields.  */\n   if (TREE_CODE (TREE_TYPE (result)) == INTEGER_TYPE\n       && TREE_CODE (olhstype) == ENUMERAL_TYPE)\n     {\n@@ -5903,6 +5945,7 @@ language_lvalue_valid (exp)\n /* Get difference in deltas for different pointer to member function\n    types.  Return integer_zero_node, if FROM cannot be converted to a\n    TO type.  If FORCE is true, then allow reverse conversions as well.  */\n+\n static tree\n get_delta_difference (from, to, force)\n      tree from, to;\n@@ -5980,14 +6023,14 @@ build_ptrmemfunc (type, pfn, force)\n      tree type, pfn;\n      int force;\n {\n-  tree index = integer_zero_node;\n+  tree idx = integer_zero_node;\n   tree delta = integer_zero_node;\n   tree delta2 = integer_zero_node;\n   tree vfield_offset;\n   tree npfn;\n   tree u;\n \n-  /* Handle multiple conversions of pointer to member functions. */\n+  /* Handle multiple conversions of pointer to member functions.  */\n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (pfn)))\n     {\n       tree ndelta, ndelta2, nindex;\n@@ -6000,17 +6043,17 @@ build_ptrmemfunc (type, pfn, force)\n \t  tree e1, e2, e3;\n \t  ndelta = convert (ptrdiff_type_node, build_component_ref (pfn, delta_identifier, NULL_TREE, 0));\n \t  ndelta2 = convert (ptrdiff_type_node, DELTA2_FROM_PTRMEMFUNC (pfn));\n-\t  index = build_component_ref (pfn, index_identifier, NULL_TREE, 0);\n+\t  idx = build_component_ref (pfn, index_identifier, NULL_TREE, 0);\n \t  delta = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))),\n \t\t\t\t\tTYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n \t\t\t\t\tforce);\n \t  delta = build_binary_op (PLUS_EXPR, delta, ndelta, 1);\n \t  delta2 = build_binary_op (PLUS_EXPR, ndelta2, delta2, 1);\n-\t  e1 = fold (build (GT_EXPR, boolean_type_node, index, integer_zero_node));\n+\t  e1 = fold (build (GT_EXPR, boolean_type_node, idx, integer_zero_node));\n \t  \n \t  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (delta2_identifier, delta2, NULL_TREE));\n \t  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (NULL_TREE, delta,\n-\t\t\t\t\t\t\t   tree_cons (NULL_TREE, index,\n+\t\t\t\t\t\t\t   tree_cons (NULL_TREE, idx,\n \t\t\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n \t  e2 = digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n \n@@ -6020,7 +6063,7 @@ build_ptrmemfunc (type, pfn, force)\n \n \t  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (pfn_identifier, npfn, NULL_TREE));\n \t  u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (NULL_TREE, delta,\n-\t\t\t\t\t\t\t   tree_cons (NULL_TREE, index,\n+\t\t\t\t\t\t\t   tree_cons (NULL_TREE, idx,\n \t\t\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n \t  e3 = digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n \t  return build_conditional_expr (e1, e2, e3);\n@@ -6056,7 +6099,7 @@ build_ptrmemfunc (type, pfn, force)\n \t}\n     }\n \n-  /* Handle null pointer to member function conversions. */\n+  /* Handle null pointer to member function conversions.  */\n   if (integer_zerop (pfn))\n     {\n       pfn = build_c_cast (type, integer_zero_node, 0);\n@@ -6077,7 +6120,7 @@ build_ptrmemfunc (type, pfn, force)\n       pfn = build_addr_func (pfn);\n     }\n \n-  /* Allow pointer to member conversions here. */\n+  /* Allow pointer to member conversions here.  */\n   delta = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (TREE_TYPE (pfn))),\n \t\t\t\tTYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n \t\t\t\tforce);\n@@ -6097,22 +6140,22 @@ build_ptrmemfunc (type, pfn, force)\n   if (TREE_CODE (TREE_OPERAND (pfn, 0)) == FUNCTION_DECL\n       && DECL_VINDEX (TREE_OPERAND (pfn, 0)))\n     {\n-      /* Find the offset to the vfield pointer in the object. */\n+      /* Find the offset to the vfield pointer in the object.  */\n       vfield_offset = get_binfo (DECL_CONTEXT (TREE_OPERAND (pfn, 0)),\n \t\t\t\t DECL_CLASS_CONTEXT (TREE_OPERAND (pfn, 0)),\n \t\t\t\t 0);\n       vfield_offset = get_vfield_offset (vfield_offset);\n       delta2 = size_binop (PLUS_EXPR, vfield_offset, delta2);\n \n       /* Map everything down one to make room for the null pointer to member.  */\n-      index = size_binop (PLUS_EXPR,\n-\t\t\t  DECL_VINDEX (TREE_OPERAND (pfn, 0)),\n-\t\t\t  integer_one_node);\n+      idx = size_binop (PLUS_EXPR,\n+\t\t\tDECL_VINDEX (TREE_OPERAND (pfn, 0)),\n+\t\t\tinteger_one_node);\n       u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (delta2_identifier, delta2, NULL_TREE));\n     }\n   else\n     {\n-      index = size_binop (MINUS_EXPR, integer_zero_node, integer_one_node);\n+      idx = size_binop (MINUS_EXPR, integer_zero_node, integer_one_node);\n \n       if (type == TREE_TYPE (pfn))\n \t{\n@@ -6128,7 +6171,7 @@ build_ptrmemfunc (type, pfn, force)\n     }\n \n   u = build_nt (CONSTRUCTOR, NULL_TREE, tree_cons (NULL_TREE, delta,\n-\t\t\t\t\t\t   tree_cons (NULL_TREE, index,\n+\t\t\t\t\t\t   tree_cons (NULL_TREE, idx,\n \t\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n   return digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n }\n@@ -6573,7 +6616,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n       else if (ctt == 0)\n \tcp_error (\"%s to `%T' from `%T'\", errtype, ttl, ttr);\n \n-      /* compatible pointer to member functions. */\n+      /* compatible pointer to member functions.  */\n       return build_ptrmemfunc (ttl, rhs, 0);\n     }\n   else if (codel == ERROR_MARK || coder == ERROR_MARK)\n@@ -6612,6 +6655,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n    exist, an ambiguity exists.\n \n    If flags doesn't include LOOKUP_COMPLAIN, don't complain about anything.  */\n+\n tree\n convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n      tree exp, type, rhs;\n@@ -7063,9 +7107,11 @@ c_expand_return (retval)\n \t}\n       else\n \t{\n-\t  retval = convert_for_initialization (result, valtype, retval,\n-\t\t\t\t\t       LOOKUP_NORMAL,\n-\t\t\t\t\t       \"return\", NULL_TREE, 0);\n+\t  /* We already did this above, don't do it again.  */\n+\t  if (TREE_CODE (valtype) != REFERENCE_TYPE)\n+\t    retval = convert_for_initialization (result, valtype, retval,\n+\t\t\t\t\t\t LOOKUP_NORMAL,\n+\t\t\t\t\t\t \"return\", NULL_TREE, 0);\n \t  DECL_INITIAL (result) = NULL_TREE;\n \t}\n       if (retval == error_mark_node)\n@@ -7186,18 +7232,18 @@ c_expand_start_case (exp)\n     }\n   else\n     {\n-      tree index;\n+      tree idx;\n \n       exp = default_conversion (exp);\n       type = TREE_TYPE (exp);\n-      index = get_unwidened (exp, 0);\n+      idx = get_unwidened (exp, 0);\n       /* We can't strip a conversion from a signed type to an unsigned,\n \t because if we did, int_fits_type_p would do the wrong thing\n \t when checking case values for being in range,\n \t and it's too hard to do the right thing.  */\n       if (TREE_UNSIGNED (TREE_TYPE (exp))\n-\t  == TREE_UNSIGNED (TREE_TYPE (index)))\n-\texp = index;\n+\t  == TREE_UNSIGNED (TREE_TYPE (idx)))\n+\texp = idx;\n     }\n \n   expand_start_case\n@@ -7209,6 +7255,7 @@ c_expand_start_case (exp)\n \n /* CONSTP remembers whether or not all the intervening pointers in the `to'\n    type have been const.  */\n+\n int\n comp_ptr_ttypes_real (to, from, constp)\n      tree to, from;\n@@ -7242,6 +7289,7 @@ comp_ptr_ttypes_real (to, from, constp)\n /* When comparing, say, char ** to char const **, this function takes the\n    'char *' and 'char const *'.  Do not pass non-pointer types to this\n    function.  */\n+\n int\n comp_ptr_ttypes (to, from)\n      tree to, from;"}, {"sha": "b9b8c6d8a4558b4ffc90bc561b4b36e67789c0e9", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -44,6 +44,7 @@ extern int sorrycount;\n \n /* Print an error message stemming from an attempt to use\n    BASETYPE as a base class for TYPE.  */\n+\n tree\n error_not_base_type (basetype, type)\n      tree basetype, type;\n@@ -75,6 +76,7 @@ binfo_or_else (parent_or_type, type)\n    value may not be changed thereafter.  Thus, we emit hard errors for these,\n    rather than just pedwarns.  If `SOFT' is 1, then we just pedwarn.  (For\n    example, conversions to references.)  */\n+\n void\n readonly_error (arg, string, soft)\n      tree arg;\n@@ -122,6 +124,7 @@ readonly_error (arg, string, soft)\n \n /* Print an error message for invalid use of a type which declares\n    virtual functions which are not inheritable.  */\n+\n void\n abstract_virtuals_error (decl, type)\n      tree decl;\n@@ -167,6 +170,7 @@ abstract_virtuals_error (decl, type)\n /* Print an error message for invalid use of a signature type.\n    Signatures are treated similar to abstract classes here, they\n    cannot be instantiated.  */\n+\n void\n signature_error (decl, type)\n      tree decl;\n@@ -253,6 +257,7 @@ incomplete_type_error (value, type)\n }\n \n /* Like error(), but don't call report_error_function().  */\n+\n static void\n ack (s, v, v2)\n      char *s;\n@@ -1182,9 +1187,7 @@ process_init_constructor (type, init, elts)\n \n    x.A::ii refers to the ii member of the L part of\n    of A part of the C object named by X.  In this case,\n-   DATUM would be x, and BASETYPE would be A.\n-\n-*/\n+   DATUM would be x, and BASETYPE would be A.  */\n \n tree\n build_scoped_ref (datum, basetype)\n@@ -1242,6 +1245,7 @@ build_scoped_ref (datum, basetype)\n    performed until an object which does not have the `->' operator\n    overloaded is found.  An error is reported when circular pointer\n    delegation is detected.  */\n+\n tree\n build_x_arrow (datum)\n      tree datum;\n@@ -1320,6 +1324,7 @@ build_x_arrow (datum)\n    As a special case, if there is only one method by that name,\n    it is returned.  Otherwise we return an expression which other\n    routines will have to know how to deal with later.  */\n+\n tree\n build_m_component_ref (datum, component)\n      tree datum, component;\n@@ -1378,6 +1383,7 @@ build_m_component_ref (datum, component)\n }\n \n /* Return a tree node for the expression TYPENAME '(' PARMS ')'.  */\n+\n tree\n build_functional_cast (exp, parms)\n      tree exp;\n@@ -1464,6 +1470,7 @@ build_functional_cast (exp, parms)\n \f\n /* Return the character string for the name that encodes the\n    enumeral value VALUE in the domain TYPE.  */\n+\n char *\n enum_name_string (value, type)\n      tree value;\n@@ -1495,6 +1502,7 @@ enum_name_string (value, type)\n    TYPE is the type of the switch index expression.\n    NEW is the new value that we were trying to add.\n    OLD is the old value that stopped us from adding it.  */\n+\n void\n report_case_error (code, type, new_value, old_value)\n      int code;"}, {"sha": "a5ea79452dbcb7beb9c9a7d6fdbf7ae9fb286cd9", "filename": "gcc/cp/xref.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fxref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92cc0291663bfd027be49e78e11e1f25cc90233/gcc%2Fcp%2Fxref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fxref.c?ref=e92cc0291663bfd027be49e78e11e1f25cc90233", "patch": "@@ -569,6 +569,7 @@ gen_assign(xf, name)\n    of CLS.\n \n    ??? Needs to handle nested classes.  */\n+\n void\n GNU_xref_hier(cls, base, pub, virt, frnd)\n    char *cls;"}]}