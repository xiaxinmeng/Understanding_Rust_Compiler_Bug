{"sha": "22e40cc7feb8abda85762e4f07719836d5c57f1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJlNDBjYzdmZWI4YWJkYTg1NzYyZTRmMDc3MTk4MzZkNWM1N2YxYQ==", "commit": {"author": {"name": "Cherry Mui", "email": "cherryyz@google.com", "date": "2021-08-03T23:35:55Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-08-04T01:32:07Z"}, "message": "compiler: support new language constructs in escape analysis\n\nPrevious CLs add new language constructs in Go 1.17, specifically,\nunsafe.Add, unsafe.Slice, and conversion from a slice to a pointer\nto an array. This CL handles them in the escape analysis.\n\nAt the point of the escape analysis, unsafe.Add and unsafe.Slice\nare still builtin calls, so just handle them in data flow.\nConversion from a slice to a pointer to an array has already been\nlowered to a combination of compound expression, conditional\nexpression and slice info expressions, so handle them in the\nescape analysis.\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/339671", "tree": {"sha": "006460b18638cda9e6daada502ef6f79ee7820e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/006460b18638cda9e6daada502ef6f79ee7820e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22e40cc7feb8abda85762e4f07719836d5c57f1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22e40cc7feb8abda85762e4f07719836d5c57f1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22e40cc7feb8abda85762e4f07719836d5c57f1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22e40cc7feb8abda85762e4f07719836d5c57f1a/comments", "author": {"login": "cherrymui", "id": 14119929, "node_id": "MDQ6VXNlcjE0MTE5OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/14119929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cherrymui", "html_url": "https://github.com/cherrymui", "followers_url": "https://api.github.com/users/cherrymui/followers", "following_url": "https://api.github.com/users/cherrymui/following{/other_user}", "gists_url": "https://api.github.com/users/cherrymui/gists{/gist_id}", "starred_url": "https://api.github.com/users/cherrymui/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cherrymui/subscriptions", "organizations_url": "https://api.github.com/users/cherrymui/orgs", "repos_url": "https://api.github.com/users/cherrymui/repos", "events_url": "https://api.github.com/users/cherrymui/events{/privacy}", "received_events_url": "https://api.github.com/users/cherrymui/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa1407c7613214cb4a45734fdb14c4756a83808a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa1407c7613214cb4a45734fdb14c4756a83808a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa1407c7613214cb4a45734fdb14c4756a83808a"}], "stats": {"total": 184, "additions": 134, "deletions": 50}, "files": [{"sha": "be1a90f7aa133e22e3b659aa5b87f6b8e9e37872", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e40cc7feb8abda85762e4f07719836d5c57f1a/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e40cc7feb8abda85762e4f07719836d5c57f1a/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=22e40cc7feb8abda85762e4f07719836d5c57f1a", "patch": "@@ -1,4 +1,4 @@\n-2031f0be9c0b5fda6421d290a0261eb6bd1c8205\n+616ee658a6238e7de53592ebda5997f6de6a00de\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "347ac2534c98a45d93db58d0692ab42217ac5157", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 57, "deletions": 6, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e40cc7feb8abda85762e4f07719836d5c57f1a/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e40cc7feb8abda85762e4f07719836d5c57f1a/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=22e40cc7feb8abda85762e4f07719836d5c57f1a", "patch": "@@ -2325,19 +2325,55 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t  }\n \t  break;\n \n+        case Expression::EXPRESSION_SLICE_INFO:\n+          {\n+            Slice_info_expression* sie = e->slice_info_expression();\n+            if (sie->info() == Expression::SLICE_INFO_VALUE_POINTER)\n+              {\n+                Node* slice = Node::make_node(sie->slice());\n+                this->assign(dst, slice);\n+              }\n+          }\n+          break;\n+\n \tcase Expression::EXPRESSION_CALL:\n \t  {\n \t    Call_expression* call = e->call_expression();\n             if (call->is_builtin())\n               {\n                 Builtin_call_expression* bce = call->builtin_call_expression();\n-                if (bce->code() == Builtin_call_expression::BUILTIN_APPEND)\n+                switch (bce->code())\n                   {\n-                    // Append returns the first argument.\n-                    // The subsequent arguments are already leaked because\n-                    // they are operands to append.\n-                    Node* appendee = Node::make_node(call->args()->front());\n-                    this->assign(dst, appendee);\n+                  case Builtin_call_expression::BUILTIN_APPEND:\n+                    {\n+                      // Append returns the first argument.\n+                      // The subsequent arguments are already leaked because\n+                      // they are operands to append.\n+                      Node* appendee = Node::make_node(call->args()->front());\n+                      this->assign(dst, appendee);\n+                    }\n+                    break;\n+\n+                  case Builtin_call_expression::BUILTIN_ADD:\n+                    {\n+                      // unsafe.Add(p, off).\n+                      // Flow p to result.\n+                      Node* arg = Node::make_node(call->args()->front());\n+                      this->assign(dst, arg);\n+                    }\n+                    break;\n+\n+                  case Builtin_call_expression::BUILTIN_SLICE:\n+                    {\n+                      // unsafe.Slice(p, len).\n+                      // The resulting slice has the same backing store as p. Flow p to result.\n+                      Node* arg = Node::make_node(call->args()->front());\n+                      this->assign(dst, arg);\n+                    }\n+                    break;\n+\n+                  default:\n+                    break;\n                   }\n                 break;\n               }\n@@ -2592,6 +2628,21 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t  }\n \t  break;\n \n+        case Expression::EXPRESSION_CONDITIONAL:\n+          {\n+            Conditional_expression* ce = e->conditional_expression();\n+            this->assign(dst, Node::make_node(ce->then_expr()));\n+            this->assign(dst, Node::make_node(ce->else_expr()));\n+          }\n+          break;\n+\n+        case Expression::EXPRESSION_COMPOUND:\n+          {\n+            Compound_expression* ce = e->compound_expression();\n+            this->assign(dst, Node::make_node(ce->expr()));\n+          }\n+          break;\n+\n \tdefault:\n \t  // TODO(cmang): Add debug info here; this should not be reachable.\n \t  // For now, just to be conservative, we'll just say dst flows to src."}, {"sha": "3e433d6c20d59154dd6855115a3e28f66a104832", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 1, "deletions": 43, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e40cc7feb8abda85762e4f07719836d5c57f1a/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e40cc7feb8abda85762e4f07719836d5c57f1a/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=22e40cc7feb8abda85762e4f07719836d5c57f1a", "patch": "@@ -18009,49 +18009,7 @@ Expression::make_type_info(Type* type, Type_info type_info)\n   return new Type_info_expression(type, type_info);\n }\n \n-// An expression that evaluates to some characteristic of a slice.\n-// This is used when indexing, bound-checking, or nil checking a slice.\n-\n-class Slice_info_expression : public Expression\n-{\n- public:\n-  Slice_info_expression(Expression* slice, Slice_info slice_info,\n-                        Location location)\n-    : Expression(EXPRESSION_SLICE_INFO, location),\n-      slice_(slice), slice_info_(slice_info)\n-  { }\n-\n- protected:\n-  Type*\n-  do_type();\n-\n-  void\n-  do_determine_type(const Type_context*)\n-  { }\n-\n-  Expression*\n-  do_copy()\n-  {\n-    return new Slice_info_expression(this->slice_->copy(), this->slice_info_,\n-                                     this->location());\n-  }\n-\n-  Bexpression*\n-  do_get_backend(Translate_context* context);\n-\n-  void\n-  do_dump_expression(Ast_dump_context*) const;\n-\n-  void\n-  do_issue_nil_check()\n-  { this->slice_->issue_nil_check(); }\n-\n- private:\n-  // The slice for which we are getting information.\n-  Expression* slice_;\n-  // What information we want.\n-  Slice_info slice_info_;\n-};\n+// Slice_info_expression.\n \n // Return the type of the slice info.\n "}, {"sha": "79a8785b69d129876bd2093bc52c93c6913e61fe", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e40cc7feb8abda85762e4f07719836d5c57f1a/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e40cc7feb8abda85762e4f07719836d5c57f1a/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=22e40cc7feb8abda85762e4f07719836d5c57f1a", "patch": "@@ -62,6 +62,7 @@ class Type_guard_expression;\n class Heap_expression;\n class Receive_expression;\n class Slice_value_expression;\n+class Slice_info_expression;\n class Conditional_expression;\n class Compound_expression;\n class Numeric_constant;\n@@ -900,6 +901,14 @@ class Expression\n   compound_expression()\n   { return this->convert<Compound_expression, EXPRESSION_COMPOUND>(); }\n \n+  // If this is a slice info expression, return the\n+  // Slice_info_expression structure.  Otherwise, return NULL.\n+  Slice_info_expression*\n+  slice_info_expression()\n+  {\n+    return this->convert<Slice_info_expression, EXPRESSION_SLICE_INFO>();\n+  }\n+\n   // Return true if this is a composite literal.\n   bool\n   is_composite_literal() const;\n@@ -4262,6 +4271,60 @@ class Slice_value_expression : public Expression\n   Expression* cap_;\n };\n \n+// An expression that evaluates to some characteristic of a slice.\n+// This is used when indexing, bound-checking, or nil checking a slice.\n+\n+class Slice_info_expression : public Expression\n+{\n+ public:\n+  Slice_info_expression(Expression* slice, Slice_info slice_info,\n+                        Location location)\n+    : Expression(EXPRESSION_SLICE_INFO, location),\n+      slice_(slice), slice_info_(slice_info)\n+  { }\n+\n+  // The slice operand of this slice info expression.\n+  Expression*\n+  slice() const\n+  { return this->slice_; }\n+\n+  // The info this expression is about.\n+  Slice_info\n+  info() const\n+  { return this->slice_info_; }\n+\n+ protected:\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { }\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return new Slice_info_expression(this->slice_->copy(), this->slice_info_,\n+                                     this->location());\n+  }\n+\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+  void\n+  do_issue_nil_check()\n+  { this->slice_->issue_nil_check(); }\n+\n+ private:\n+  // The slice for which we are getting information.\n+  Expression* slice_;\n+  // What information we want.\n+  Slice_info slice_info_;\n+};\n+\n // Conditional expressions.\n \n class Conditional_expression : public Expression\n@@ -4277,6 +4340,14 @@ class Conditional_expression : public Expression\n   condition() const\n   { return this->cond_; }\n \n+  Expression*\n+  then_expr() const\n+  { return this->then_; }\n+\n+  Expression*\n+  else_expr() const\n+  { return this->else_; }\n+\n  protected:\n   int\n   do_traverse(Traverse*);\n@@ -4322,6 +4393,10 @@ class Compound_expression : public Expression\n   init() const\n   { return this->init_; }\n \n+  Expression*\n+  expr() const\n+  { return this->expr_; }\n+\n  protected:\n   int\n   do_traverse(Traverse*);"}]}