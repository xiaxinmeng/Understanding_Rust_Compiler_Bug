{"sha": "9bf448b9057dee370741ca48edfc9bec954894a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJmNDQ4YjkwNTdkZWUzNzA3NDFjYTQ4ZWRmYzliZWM5NTQ4OTRhNg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-06-19T12:57:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-06-19T12:57:58Z"}, "message": "tree-ssa-structalias.c (handle_ptr_arith): Make sure to only handle positive offsets that fit in a HOST_WIDE_INT.\n\n2007-06-19  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-structalias.c (handle_ptr_arith): Make sure to\n\tonly handle positive offsets that fit in a HOST_WIDE_INT.\n\n\t* g++.dg/torture/pr30252.C: New testcase.\n\nFrom-SVN: r125849", "tree": {"sha": "bd94d5dc228225eeb3ef8f7672769335206713d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd94d5dc228225eeb3ef8f7672769335206713d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bf448b9057dee370741ca48edfc9bec954894a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bf448b9057dee370741ca48edfc9bec954894a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bf448b9057dee370741ca48edfc9bec954894a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bf448b9057dee370741ca48edfc9bec954894a6/comments", "author": null, "committer": null, "parents": [{"sha": "258d0b9b9e7ca27b5e7e3a2dbb1488a9f4e13bfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/258d0b9b9e7ca27b5e7e3a2dbb1488a9f4e13bfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/258d0b9b9e7ca27b5e7e3a2dbb1488a9f4e13bfd"}], "stats": {"total": 250, "additions": 246, "deletions": 4}, "files": [{"sha": "409885a20153b62381c15bd0456969fb740d4fc4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf448b9057dee370741ca48edfc9bec954894a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf448b9057dee370741ca48edfc9bec954894a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9bf448b9057dee370741ca48edfc9bec954894a6", "patch": "@@ -1,4 +1,9 @@\n-2007-06-18  Uros Bizjak  <ubizjak@gmail.com>\n+2007-06-19  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-structalias.c (handle_ptr_arith): Make sure to\n+\tonly handle positive offsets that fit in a HOST_WIDE_INT.\n+\n+2007-06-19  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (ix86_emit_swsqrtsf): Limit the result of\n \trsqrt insn to FLT_MAX to avoid NaN for zero input argument."}, {"sha": "dd2a1a40e2b12b92fe82bf9f243c3791b59fba20", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf448b9057dee370741ca48edfc9bec954894a6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf448b9057dee370741ca48edfc9bec954894a6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9bf448b9057dee370741ca48edfc9bec954894a6", "patch": "@@ -1,3 +1,7 @@\n+2007-06-19  Richard Guenther  <rguenther@suse.de>\n+\n+\t* g++.dg/torture/pr30252.C: New testcase.\n+\n 2007-06-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/32353"}, {"sha": "aabf88f51e26e2b42efc59fdf4cec38cc16631a5", "filename": "gcc/testsuite/g++.dg/torture/pr30252.C", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf448b9057dee370741ca48edfc9bec954894a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr30252.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf448b9057dee370741ca48edfc9bec954894a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr30252.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr30252.C?ref=9bf448b9057dee370741ca48edfc9bec954894a6", "patch": "@@ -0,0 +1,226 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fstrict-aliasing\" } */\n+\n+extern \"C\" void abort (void);\n+namespace sigc {\n+  template <class T_type>\n+  struct type_trait\n+  {\n+    typedef T_type& pass;\n+    typedef const T_type& take;\n+    typedef T_type* pointer;\n+  };\n+  template <class T_base, class T_derived>\n+  struct is_base_and_derived\n+  {\n+    struct big {\n+      char memory[64];\n+    };\n+    static big is_base_class_(...);\n+    static char is_base_class_(typename type_trait<T_base>::pointer);\n+    static const bool value =\n+    sizeof(is_base_class_(reinterpret_cast<typename type_trait<T_derived>::pointer>(0))) ==\n+    sizeof(char);\n+  };\n+  struct nil;\n+  struct functor_base {};\n+  template <class T_functor, bool I_derives_functor_base=is_base_and_derived<functor_base,T_functor>::value>\n+  struct functor_trait\n+  {\n+  };\n+  template <class T_functor>\n+  struct functor_trait<T_functor,true>\n+  {\n+    typedef typename T_functor::result_type result_type;\n+    typedef T_functor functor_type;\n+  };\n+  template <class T_arg1, class T_return>\n+  class pointer_functor1 : public functor_base\n+  {\n+    typedef T_return (*function_type)(T_arg1);\n+    function_type func_ptr_;\n+  public:\n+    typedef T_return result_type;\n+    explicit pointer_functor1(function_type _A_func): func_ptr_(_A_func) {}\n+    T_return operator()(typename type_trait<T_arg1>::take _A_a1) const\n+    { return func_ptr_(_A_a1); }\n+  };\n+  template <class T_arg1, class T_return>\n+  inline pointer_functor1<T_arg1, T_return>\n+  ptr_fun1(T_return (*_A_func)(T_arg1))\n+  { return pointer_functor1<T_arg1, T_return>(_A_func); }\n+  struct adaptor_base : public functor_base {};\n+  template <class T_functor,\n+    class T_arg1=void,\n+    bool I_derives_adaptor_base=is_base_and_derived<adaptor_base,T_functor>::value>\n+  struct deduce_result_type\n+  { typedef typename functor_trait<T_functor>::result_type type; };\n+  template <class T_functor>\n+  struct adaptor_functor : public adaptor_base\n+  {\n+    template <class T_arg1=void>\n+    struct deduce_result_type\n+    { typedef typename sigc::deduce_result_type<T_functor, T_arg1>::type type; };\n+    typedef typename functor_trait<T_functor>::result_type result_type;\n+    result_type\n+    operator()() const;\n+    template <class T_arg1>\n+    typename deduce_result_type<T_arg1>::type\n+    operator()(T_arg1 _A_arg1) const\n+    { return functor_(_A_arg1); }\n+    explicit adaptor_functor(const T_functor& _A_functor)\n+      : functor_(_A_functor)\n+    {}\n+    mutable T_functor functor_;\n+  };\n+  template <class T_functor>\n+  typename adaptor_functor<T_functor>::result_type\n+  adaptor_functor<T_functor>::operator()() const\n+  { return functor_(); }\n+  template <class T_functor, bool I_isadaptor = is_base_and_derived<adaptor_base, T_functor>::value> struct adaptor_trait;\n+  template <class T_functor>\n+  struct adaptor_trait<T_functor, true>\n+  {\n+    typedef T_functor adaptor_type;\n+  };\n+  template <class T_functor>\n+  struct adaptor_trait<T_functor, false>\n+  {\n+    typedef typename functor_trait<T_functor>::functor_type functor_type;\n+    typedef adaptor_functor<functor_type> adaptor_type;\n+  };\n+  template <class T_functor>\n+  struct adapts : public adaptor_base\n+  {\n+    typedef typename adaptor_trait<T_functor>::adaptor_type adaptor_type;\n+    explicit adapts(const T_functor& _A_functor)\n+      : functor_(_A_functor)\n+    {}\n+    mutable adaptor_type functor_;\n+  };\n+  template <class T_type>\n+  struct reference_wrapper\n+  {\n+  };\n+  template <class T_type>\n+  struct unwrap_reference\n+  {\n+    typedef T_type type;\n+  };\n+  template <class T_type>\n+  class bound_argument\n+  {\n+  public:\n+    bound_argument(const T_type& _A_argument)\n+      : visited_(_A_argument)\n+    {}\n+    inline T_type& invoke()\n+    { return visited_; }\n+    T_type visited_;\n+  };\n+  template <class T_wrapped>\n+  class bound_argument< reference_wrapper<T_wrapped> >\n+  {\n+  };\n+  template <int I_location, class T_functor, class T_type1=nil>\n+  struct bind_functor;\n+  template <class T_functor, class T_type1>\n+  struct bind_functor<-1, T_functor, T_type1> : public adapts<T_functor>\n+  {\n+    typedef typename adapts<T_functor>::adaptor_type adaptor_type;\n+    typedef typename adaptor_type::result_type result_type;\n+    result_type\n+    operator()()\n+    {\n+      return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_type1>::type>::pass> (bound1_.invoke());\n+    }\n+    bind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_type1>::take _A_bound1)\n+      : adapts<T_functor>(_A_func), bound1_(_A_bound1)\n+    {}\n+    bound_argument<T_type1> bound1_;\n+  };\n+  template <class T_type1, class T_functor>\n+  inline bind_functor<-1, T_functor,\n+\t\t      T_type1>\n+  bind(const T_functor& _A_func, T_type1 _A_b1)\n+  { return bind_functor<-1, T_functor,\n+      T_type1>\n+      (_A_func, _A_b1);\n+  }\n+  namespace internal {\n+    struct slot_rep;\n+    typedef void* (*hook)(slot_rep *);\n+    struct slot_rep\n+    {\n+      hook call_;\n+    };\n+  }\n+  class slot_base : public functor_base\n+  {\n+  public:\n+    typedef internal::slot_rep rep_type;\n+    explicit slot_base(rep_type* rep)\n+      : rep_(rep)\n+    {\n+    }\n+    mutable rep_type *rep_;\n+  };\n+  namespace internal {\n+    template <class T_functor>\n+    struct typed_slot_rep : public slot_rep\n+    {\n+      typedef typename adaptor_trait<T_functor>::adaptor_type adaptor_type;\n+      adaptor_type functor_;\n+      inline typed_slot_rep(const T_functor& functor)\n+\t: functor_(functor)\n+      {\n+      }\n+    };\n+    template<class T_functor>\n+    struct slot_call0\n+    {\n+      static void *call_it(slot_rep* rep)\n+      {\n+\ttypedef typed_slot_rep<T_functor> typed_slot;\n+\ttyped_slot *typed_rep = static_cast<typed_slot*>(rep);\n+\treturn (typed_rep->functor_)();\n+      }\n+      static hook address()\n+      {\n+\treturn &call_it;\n+      }\n+    };\n+  }\n+\n+  class slot0 : public slot_base\n+  {\n+  public:\n+    typedef void * (*call_type)(rep_type*);\n+    inline void *operator()() const\n+    {\n+      return slot_base::rep_->call_ (slot_base::rep_);\n+    }\n+    template <class T_functor>\n+    slot0(const T_functor& _A_func)\n+      : slot_base(new internal::typed_slot_rep<T_functor>(_A_func))\n+    {\n+      slot_base::rep_->call_ = internal::slot_call0<T_functor>::address();\n+    }\n+  };\n+}\n+struct A\n+{\n+  static void *foo (void *p) { return p; }\n+  typedef sigc::slot0 C;\n+  C bar();\n+};\n+A::C A::bar ()\n+{\n+  return sigc::bind (sigc::ptr_fun1 (&A::foo), (void*)0);\n+}\n+int main (void)\n+{\n+  A a;\n+  if (a.bar ()() != 0)\n+    abort ();\n+}"}, {"sha": "663dff0b1cbeba9014c4e0b26fa01f15f250cf05", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf448b9057dee370741ca48edfc9bec954894a6/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf448b9057dee370741ca48edfc9bec954894a6/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=9bf448b9057dee370741ca48edfc9bec954894a6", "patch": "@@ -3291,7 +3291,7 @@ handle_ptr_arith (VEC (ce_s, heap) *lhsc, tree expr)\n   unsigned int i = 0;\n   unsigned int j = 0;\n   VEC (ce_s, heap) *temp = NULL;\n-  unsigned int rhsoffset = 0;\n+  unsigned HOST_WIDE_INT rhsoffset = 0;\n \n   if (TREE_CODE (expr) != POINTER_PLUS_EXPR)\n     return false;\n@@ -3302,8 +3302,15 @@ handle_ptr_arith (VEC (ce_s, heap) *lhsc, tree expr)\n \n   get_constraint_for (op0, &temp);\n \n-  if (TREE_CODE (op1) == INTEGER_CST)\n-    rhsoffset = TREE_INT_CST_LOW (op1) * BITS_PER_UNIT;\n+  /* We can only handle positive offsets that do not overflow\n+     if we multiply it by BITS_PER_UNIT.  */\n+  if (host_integerp (op1, 1))\n+    {\n+      rhsoffset = TREE_INT_CST_LOW (op1) * BITS_PER_UNIT;\n+\n+      if (rhsoffset / BITS_PER_UNIT != TREE_INT_CST_LOW (op1))\n+\treturn false;\n+    }\n \n   for (i = 0; VEC_iterate (ce_s, lhsc, i, c); i++)\n     for (j = 0; VEC_iterate (ce_s, temp, j, c2); j++)"}]}