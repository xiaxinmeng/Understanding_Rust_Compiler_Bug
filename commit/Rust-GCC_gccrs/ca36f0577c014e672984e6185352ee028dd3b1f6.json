{"sha": "ca36f0577c014e672984e6185352ee028dd3b1f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EzNmYwNTc3YzAxNGU2NzI5ODRlNjE4NTM1MmVlMDI4ZGQzYjFmNg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-03-29T07:36:39Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-03-29T07:36:39Z"}, "message": "class.c: Reorganize to put virtual function table initialization machinery at the end of...\n\n\t* class.c: Reorganize to put virtual function table initialization\n\tmachinery at the end of the file.\n\nFrom-SVN: r32798", "tree": {"sha": "fcb203576ef11b3f5a6198b8678090aee600a52c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcb203576ef11b3f5a6198b8678090aee600a52c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca36f0577c014e672984e6185352ee028dd3b1f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca36f0577c014e672984e6185352ee028dd3b1f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca36f0577c014e672984e6185352ee028dd3b1f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca36f0577c014e672984e6185352ee028dd3b1f6/comments", "author": null, "committer": null, "parents": [{"sha": "d6121128fe93baf5cf81a09a04a381eec61ad63d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6121128fe93baf5cf81a09a04a381eec61ad63d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6121128fe93baf5cf81a09a04a381eec61ad63d"}], "stats": {"total": 1909, "additions": 958, "deletions": 951}, "files": [{"sha": "e92612d23580dd6977a71e4f591d7c07d979c3e8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca36f0577c014e672984e6185352ee028dd3b1f6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca36f0577c014e672984e6185352ee028dd3b1f6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ca36f0577c014e672984e6185352ee028dd3b1f6", "patch": "@@ -1,3 +1,8 @@\n+2000-03-28  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c: Reorganize to put virtual function table initialization\n+\tmachinery at the end of the file.\n+\n 2000-03-28  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* class.c (finish_struct): Use bitsize_zero_node."}, {"sha": "f3a94dc065c659e815d9de0f641b2a7e657df326", "filename": "gcc/cp/class.c", "status": "modified", "additions": 953, "deletions": 951, "changes": 1904, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca36f0577c014e672984e6185352ee028dd3b1f6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca36f0577c014e672984e6185352ee028dd3b1f6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=ca36f0577c014e672984e6185352ee028dd3b1f6", "patch": "@@ -256,438 +256,134 @@ build_vbase_pointer_fields (rli, empty_p)\n   return vbase_decls;\n }\n \n-/* Called from build_vbase_offset_vtbl_entries via dfs_walk.  */\n+/* Returns a pointer to the virtual base class of EXP that has the\n+   indicated TYPE.  EXP is of class type, not a pointer type.  */\n \n static tree\n-dfs_build_vbase_offset_vtbl_entries (binfo, data)\n-     tree binfo;\n-     void *data;\n+build_vbase_pointer (exp, type)\n+     tree exp, type;\n {\n-  tree list = (tree) data;\n-\n-  if (TREE_TYPE (list) == binfo)\n-    /* The TREE_TYPE of LIST is the base class from which we started\n-       walking.  If that BINFO is virtual it's not a virtual baseclass\n-       of itself.  */\n-    ;\n-  else if (TREE_VIA_VIRTUAL (binfo))\n+  if (vbase_offsets_in_vtable_p ())\n     {\n-      tree init;\n       tree vbase;\n+      tree vbase_ptr;\n \n-      /* Remember the index to the vbase offset for this virtual\n-\t base.  */\n-      vbase = BINFO_FOR_VBASE (BINFO_TYPE (binfo), TREE_PURPOSE (list));\n-      if (!TREE_VALUE (list))\n-\tBINFO_VPTR_FIELD (vbase) = build_int_2 (-3, 0);\n-      else\n-\t{\n-\t  BINFO_VPTR_FIELD (vbase) = TREE_PURPOSE (TREE_VALUE (list));\n-\t  BINFO_VPTR_FIELD (vbase)\n-\t    = fold (build (MINUS_EXPR, integer_type_node,\n-\t\t\t   BINFO_VPTR_FIELD (vbase), integer_one_node));\n-\t}\n-\n-      /* And record the offset at which this virtual base lies in the\n-\t vtable.  */\n-      init = BINFO_OFFSET (binfo);\n-      TREE_VALUE (list) = tree_cons (BINFO_VPTR_FIELD (vbase),\n-\t\t\t\t     init, TREE_VALUE (list));\n+      /* Find the shared copy of TYPE; that's where the vtable offset\n+\t is recorded.  */\n+      vbase = BINFO_FOR_VBASE (type, TREE_TYPE (exp));\n+      /* Find the virtual function table pointer.  */\n+      vbase_ptr = build_vfield_ref (exp, TREE_TYPE (exp));\n+      /* Compute the location where the offset will lie.  */\n+      vbase_ptr = build_binary_op (PLUS_EXPR, \n+\t\t\t\t   vbase_ptr,\n+\t\t\t\t   BINFO_VPTR_FIELD (vbase));\n+      vbase_ptr = build1 (NOP_EXPR, \n+\t\t\t  build_pointer_type (ptrdiff_type_node),\n+\t\t\t  vbase_ptr);\n+      /* Add the contents of this location to EXP.  */\n+      return build (PLUS_EXPR,\n+\t\t    build_pointer_type (type),\n+\t\t    build_unary_op (ADDR_EXPR, exp, /*noconvert=*/0),\n+\t\t    build1 (INDIRECT_REF, ptrdiff_type_node, vbase_ptr));\n     }\n-\n-  SET_BINFO_VTABLE_PATH_MARKED (binfo);\n-  \n-  return NULL_TREE;\n-}\n-\n-/* Returns the initializers for the vbase offset entries in the vtable\n-   for BINFO (which is part of the class hierarchy dominated by T), in\n-   reverse order.  */\n-\n-static tree\n-build_vbase_offset_vtbl_entries (binfo, t)\n-     tree binfo;\n-     tree t;\n-{\n-  tree inits;\n-  tree init;\n-  tree list;\n-\n-  /* Under the old ABI, pointers to virtual bases are stored in each\n-     object.  */\n-  if (!vbase_offsets_in_vtable_p ())\n-    return NULL_TREE;\n-\n-  /* If there are no virtual baseclasses, then there is nothing to\n-     do.  */\n-  if (!TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo)))\n-    return NULL_TREE;\n-\n-  inits = NULL_TREE;\n-\n-  /* The offsets are allocated in the reverse order of a\n-     depth-first left-to-right traversal of the hierarchy.  We use\n-     BINFO_VTABLE_PATH_MARKED because we are ourselves during a\n-     dfs_walk, and so BINFO_MARKED is already in use.  */\n-  list = build_tree_list (t, NULL_TREE);\n-  TREE_TYPE (list) = binfo;\n-  dfs_walk (binfo,\n-\t    dfs_build_vbase_offset_vtbl_entries,\n-\t    unmarked_vtable_pathp,\n-\t    list);\n-  dfs_walk (binfo,\n-\t    dfs_vtable_path_unmark,\n-\t    marked_vtable_pathp,\n-\t    list);\n-  inits = nreverse (TREE_VALUE (list));\n-\n-  /* We've now got offsets in the right order.  However, the offsets\n-     we've stored are offsets from the beginning of the complete\n-     object, and we need offsets from this BINFO.  */\n-  for (init = inits; init; init = TREE_CHAIN (init))\n+  else\n     {\n-      /* The dfs_build_vbase_offset_vtbl_entries routine uses the\n-\t TREE_PURPOSE to scribble in.  But, we need to clear it now so\n-\t that the values are not perceived as labeled initializers.  */\n-      TREE_PURPOSE (init) = NULL_TREE;\n-      TREE_VALUE (init)\n-\t= fold (build1 (NOP_EXPR, vtable_entry_type,\n-\t\t\tsize_diffop (TREE_VALUE (init),\n-\t\t\t\t     BINFO_OFFSET (binfo))));\n+      char *name;\n+      FORMAT_VBASE_NAME (name, type);\n+      return build_component_ref (exp, get_identifier (name), NULL_TREE, 0);\n     }\n-\n-  return inits;\n }\n \n-typedef struct vcall_offset_data_s\n-{\n-  /* The binfo for the most-derived type.  */\n-  tree derived;\n-  /* The binfo for the virtual base for which we're building\n-     initializers.  */\n-  tree vbase;\n-  /* The vcall offset initializers built up so far.  */\n-  tree inits;\n-  /* The number of vcall offsets accumulated.  */\n-  int offsets;\n-} vcall_offset_data;\n+/* Build multi-level access to EXPR using hierarchy path PATH.\n+   CODE is PLUS_EXPR if we are going with the grain,\n+   and MINUS_EXPR if we are not (in which case, we cannot traverse\n+   virtual baseclass links).\n \n-/* Called from build_vcall_offset_vtbl_entries via dfs_walk.  */\n+   TYPE is the type we want this path to have on exit.\n \n-static tree\n-dfs_vcall_offset_queue_p (binfo, data)\n-     tree binfo;\n-     void *data;\n+   NONNULL is non-zero if  we know (for any reason) that EXPR is\n+   not, in fact, zero.  */\n+\n+tree\n+build_vbase_path (code, type, expr, path, nonnull)\n+     enum tree_code code;\n+     tree type, expr, path;\n+     int nonnull;\n {\n-  vcall_offset_data* vod = (vcall_offset_data *) data;\n+  register int changed = 0;\n+  tree last = NULL_TREE, last_virtual = NULL_TREE;\n+  int fixed_type_p;\n+  tree null_expr = 0, nonnull_expr;\n+  tree basetype;\n+  tree offset = integer_zero_node;\n \n-  return (binfo == vod->vbase) ? binfo : dfs_skip_vbases (binfo, NULL);\n-}\n+  if (BINFO_INHERITANCE_CHAIN (path) == NULL_TREE)\n+    return build1 (NOP_EXPR, type, expr);\n \n-/* Called from build_vcall_offset_vtbl_entries via dfs_walk.  */\n+  /* We could do better if we had additional logic to convert back to the\n+     unconverted type (the static type of the complete object), and then\n+     convert back to the type we want.  Until that is done, we only optimize\n+     if the complete type is the same type as expr has.  */\n+  fixed_type_p = resolves_to_fixed_type_p (expr, &nonnull);\n \n-static tree\n-dfs_build_vcall_offset_vtbl_entries (binfo, data)\n-     tree binfo;\n-     void *data;\n-{\n-  vcall_offset_data* vod;\n-  tree virtuals;\n-  tree binfo_inits;\n+  if (!fixed_type_p && TREE_SIDE_EFFECTS (expr))\n+    expr = save_expr (expr);\n+  nonnull_expr = expr;\n \n-  /* Primary bases are not interesting; all of the virtual\n-     function table entries have been overridden.  */\n-  if (BINFO_PRIMARY_MARKED_P (binfo))\n-     return NULL_TREE;\n+  path = reverse_path (path);\n \n-  vod = (vcall_offset_data *) data;\n-  binfo_inits = NULL_TREE;\n+  basetype = BINFO_TYPE (path);\n \n-  /* We chain the offsets on in reverse order.  That's correct --\n-     build_vtbl_initializer will straighten them out.  */\n-  for (virtuals = BINFO_VIRTUALS (binfo);\n-       virtuals;\n-       virtuals = TREE_CHAIN (virtuals))\n+  while (path)\n     {\n-      /* Figure out what function we're looking at.  */\n-      tree fn = TREE_VALUE (virtuals);\n-      tree base = DECL_CONTEXT (fn);\n-      /* The FN comes from BASE.  So, we must caculate the adjustment\n-\t from the virtual base that derived from BINFO to BASE.  */\n-      tree base_binfo = get_binfo (base, vod->derived, /*protect=*/0);\n+      if (TREE_VIA_VIRTUAL (TREE_VALUE (path)))\n+\t{\n+\t  last_virtual = BINFO_TYPE (TREE_VALUE (path));\n+\t  if (code == PLUS_EXPR)\n+\t    {\n+\t      changed = ! fixed_type_p;\n \n-      binfo_inits\n-\t= tree_cons (NULL_TREE,\n-\t\t     fold (build1 (NOP_EXPR, vtable_entry_type,\n-\t\t\t\t   size_diffop (BINFO_OFFSET (base_binfo),\n-\t\t\t\t\t\tBINFO_OFFSET (vod->vbase)))),\n-\t\t     binfo_inits);\n-    }\n+\t      if (changed)\n+\t\t{\n+\t\t  tree ind;\n \n-  /* Now add the initializers we've just created to the list that will\n-     be returned to our caller.  */\n-  vod->inits = chainon (vod->inits, binfo_inits);\n+\t\t  /* We already check for ambiguous things in the caller, just\n+\t\t     find a path.  */\n+\t\t  if (last)\n+\t\t    {\n+\t\t      tree binfo = get_binfo (last, TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (nonnull_expr))), 0);\n+\t\t      nonnull_expr = convert_pointer_to_real (binfo, nonnull_expr);\n+\t\t    }\n+\t\t  ind = build_indirect_ref (nonnull_expr, NULL_PTR);\n+\t\t  nonnull_expr = build_vbase_pointer (ind, last_virtual);\n+\t\t  if (nonnull == 0\n+\t\t      && TREE_CODE (type) == POINTER_TYPE\n+\t\t      && null_expr == NULL_TREE)\n+\t\t    {\n+\t\t      null_expr = build1 (NOP_EXPR, build_pointer_type (last_virtual), integer_zero_node);\n+\t\t      expr = build (COND_EXPR, build_pointer_type (last_virtual),\n+\t\t\t\t    build (EQ_EXPR, boolean_type_node, expr,\n+\t\t\t\t\t   integer_zero_node),\n+\t\t\t\t    null_expr, nonnull_expr);\n+\t\t    }\n+\t\t}\n+\t      /* else we'll figure out the offset below.  */\n \n-  return NULL_TREE;\n-}\n-\n-/* Returns the initializers for the vcall offset entries in the vtable\n-   for BINFO (which is part of the class hierarchy dominated by T), in\n-   reverse order.  */\n-\n-static tree\n-build_vcall_offset_vtbl_entries (binfo, t)\n-     tree binfo;\n-     tree t;\n-{\n-  vcall_offset_data vod;\n-\n-  /* Under the old ABI, the adjustments to the `this' pointer were made\n-     elsewhere.  */\n-  if (!vcall_offsets_in_vtable_p ())\n-    return NULL_TREE;\n-\n-  /* We only need these entries if this base is a virtual base.  */\n-  if (!TREE_VIA_VIRTUAL (binfo))\n-    return NULL_TREE;\n-\n-  /* We need a vcall offset for each of the virtual functions in this\n-     vtable.  For example:\n-\n-       class A { virtual void f (); };\n-       class B : virtual public A { };\n-       class C: virtual public A, public B {};\n-      \n-     Now imagine:\n-\n-       B* b = new C;\n-       b->f();\n-\n-     The location of `A' is not at a fixed offset relative to `B'; the\n-     offset depends on the complete object derived from `B'.  So, \n-     `B' vtable contains an entry for `f' that indicates by what\n-     amount the `this' pointer for `B' needs to be adjusted to arrive\n-     at `A'.  \n-\n-     We need entries for all the functions in our primary vtable and\n-     in our non-virtual bases vtables.  For each base, the entries\n-     appear in the same order as in the base; but the bases themselves\n-     appear in reverse depth-first, left-to-right order.  */\n-  vod.derived = t;\n-  vod.vbase = binfo;\n-  vod.inits = NULL_TREE;\n-  dfs_walk (binfo,\n-\t    dfs_build_vcall_offset_vtbl_entries,\n-\t    dfs_vcall_offset_queue_p,\n-\t    &vod);\n-\n-  return vod.inits;\n-}\n-\n-/* Return vtbl initializers for the RTTI entries coresponding to the\n-   BINFO's vtable.  BINFO is a part of the hierarchy dominated by \n-   T.  */\n-\n-static tree\n-build_rtti_vtbl_entries (binfo, t)\n-     tree binfo;\n-     tree t;\n-{\n-  tree b;\n-  tree basetype;\n-  tree inits;\n-  tree offset;\n-  tree decl;\n-  tree init;\n-\n-  basetype = BINFO_TYPE (binfo);\n-  inits = NULL_TREE;\n-\n-  /* For a COM object there is no RTTI entry.  */\n-  if (CLASSTYPE_COM_INTERFACE (basetype))\n-    return inits;\n-\n-  /* To find the complete object, we will first convert to our most\n-     primary base, and then add the offset in the vtbl to that value.  */\n-  b = binfo;\n-  while (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (b)))\n-    b = BINFO_BASETYPE (b, \n-\t\t\tCLASSTYPE_VFIELD_PARENT (BINFO_TYPE (b)));\n-  offset = size_diffop (size_zero_node, BINFO_OFFSET (b));\n-\n-  /* Add the offset-to-top entry.  */\n-  if (flag_vtable_thunks)\n-    {\n-      /* Convert the offset to look like a function pointer, so that\n-\t we can put it in the vtable.  */\n-      init = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n-      TREE_CONSTANT (init) = 1;\n-      inits = tree_cons (NULL_TREE, init, inits);\n-    }\n-\n-  /* The second entry is, in the case of the new ABI, the address of\n-     the typeinfo object, or, in the case of the old ABI, a function\n-     which returns a typeinfo object.  */\n-  if (new_abi_rtti_p ())\n-    {\n-      if (flag_rtti)\n-\tdecl = build_unary_op (ADDR_EXPR, get_tinfo_decl (t), 0);\n-      else\n-\tdecl = integer_zero_node;\n-\n-      /* Convert the declaration to a type that can be stored in the\n-\t vtable.  */\n-      init = build1 (NOP_EXPR, vfunc_ptr_type_node, decl);\n-      TREE_CONSTANT (init) = 1;\n-    }\n-  else\n-    {\n-      if (flag_rtti)\n-\tdecl = get_tinfo_decl (t);\n-      else\n-\tdecl = abort_fndecl;\n-\n-      /* Convert the declaration to a type that can be stored in the\n-\t vtable.  */\n-      init = build1 (ADDR_EXPR, vfunc_ptr_type_node, decl);\n-      TREE_CONSTANT (init) = 1;\n-      init = build_vtable_entry (offset, integer_zero_node, init);\n-    }\n-\n-  /* Hook the RTTI declaration onto the list.  */\n-  inits = tree_cons (NULL_TREE, init, inits);\n-\n-  return inits;\n-}\n-\n-/* Returns a pointer to the virtual base class of EXP that has the\n-   indicated TYPE.  EXP is of class type, not a pointer type.  */\n-\n-static tree\n-build_vbase_pointer (exp, type)\n-     tree exp, type;\n-{\n-  if (vbase_offsets_in_vtable_p ())\n-    {\n-      tree vbase;\n-      tree vbase_ptr;\n-\n-      /* Find the shared copy of TYPE; that's where the vtable offset\n-\t is recorded.  */\n-      vbase = BINFO_FOR_VBASE (type, TREE_TYPE (exp));\n-      /* Find the virtual function table pointer.  */\n-      vbase_ptr = build_vfield_ref (exp, TREE_TYPE (exp));\n-      /* Compute the location where the offset will lie.  */\n-      vbase_ptr = build_binary_op (PLUS_EXPR, \n-\t\t\t\t   vbase_ptr,\n-\t\t\t\t   BINFO_VPTR_FIELD (vbase));\n-      vbase_ptr = build1 (NOP_EXPR, \n-\t\t\t  build_pointer_type (ptrdiff_type_node),\n-\t\t\t  vbase_ptr);\n-      /* Add the contents of this location to EXP.  */\n-      return build (PLUS_EXPR,\n-\t\t    build_pointer_type (type),\n-\t\t    build_unary_op (ADDR_EXPR, exp, /*noconvert=*/0),\n-\t\t    build1 (INDIRECT_REF, ptrdiff_type_node, vbase_ptr));\n-    }\n-  else\n-    {\n-      char *name;\n-      FORMAT_VBASE_NAME (name, type);\n-      return build_component_ref (exp, get_identifier (name), NULL_TREE, 0);\n-    }\n-}\n-\n-/* Build multi-level access to EXPR using hierarchy path PATH.\n-   CODE is PLUS_EXPR if we are going with the grain,\n-   and MINUS_EXPR if we are not (in which case, we cannot traverse\n-   virtual baseclass links).\n-\n-   TYPE is the type we want this path to have on exit.\n-\n-   NONNULL is non-zero if  we know (for any reason) that EXPR is\n-   not, in fact, zero.  */\n-\n-tree\n-build_vbase_path (code, type, expr, path, nonnull)\n-     enum tree_code code;\n-     tree type, expr, path;\n-     int nonnull;\n-{\n-  register int changed = 0;\n-  tree last = NULL_TREE, last_virtual = NULL_TREE;\n-  int fixed_type_p;\n-  tree null_expr = 0, nonnull_expr;\n-  tree basetype;\n-  tree offset = integer_zero_node;\n-\n-  if (BINFO_INHERITANCE_CHAIN (path) == NULL_TREE)\n-    return build1 (NOP_EXPR, type, expr);\n-\n-  /* We could do better if we had additional logic to convert back to the\n-     unconverted type (the static type of the complete object), and then\n-     convert back to the type we want.  Until that is done, we only optimize\n-     if the complete type is the same type as expr has.  */\n-  fixed_type_p = resolves_to_fixed_type_p (expr, &nonnull);\n-\n-  if (!fixed_type_p && TREE_SIDE_EFFECTS (expr))\n-    expr = save_expr (expr);\n-  nonnull_expr = expr;\n-\n-  path = reverse_path (path);\n-\n-  basetype = BINFO_TYPE (path);\n-\n-  while (path)\n-    {\n-      if (TREE_VIA_VIRTUAL (TREE_VALUE (path)))\n-\t{\n-\t  last_virtual = BINFO_TYPE (TREE_VALUE (path));\n-\t  if (code == PLUS_EXPR)\n-\t    {\n-\t      changed = ! fixed_type_p;\n-\n-\t      if (changed)\n-\t\t{\n-\t\t  tree ind;\n-\n-\t\t  /* We already check for ambiguous things in the caller, just\n-\t\t     find a path.  */\n-\t\t  if (last)\n-\t\t    {\n-\t\t      tree binfo = get_binfo (last, TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (nonnull_expr))), 0);\n-\t\t      nonnull_expr = convert_pointer_to_real (binfo, nonnull_expr);\n-\t\t    }\n-\t\t  ind = build_indirect_ref (nonnull_expr, NULL_PTR);\n-\t\t  nonnull_expr = build_vbase_pointer (ind, last_virtual);\n-\t\t  if (nonnull == 0\n-\t\t      && TREE_CODE (type) == POINTER_TYPE\n-\t\t      && null_expr == NULL_TREE)\n-\t\t    {\n-\t\t      null_expr = build1 (NOP_EXPR, build_pointer_type (last_virtual), integer_zero_node);\n-\t\t      expr = build (COND_EXPR, build_pointer_type (last_virtual),\n-\t\t\t\t    build (EQ_EXPR, boolean_type_node, expr,\n-\t\t\t\t\t   integer_zero_node),\n-\t\t\t\t    null_expr, nonnull_expr);\n-\t\t    }\n-\t\t}\n-\t      /* else we'll figure out the offset below.  */\n-\n-\t      /* Happens in the case of parse errors.  */\n-\t      if (nonnull_expr == error_mark_node)\n-\t\treturn error_mark_node;\n-\t    }\n-\t  else\n-\t    {\n-\t      cp_error (\"cannot cast up from virtual baseclass `%T'\",\n-\t\t\t  last_virtual);\n-\t      return error_mark_node;\n-\t    }\n-\t}\n-      last = TREE_VALUE (path);\n-      path = TREE_CHAIN (path);\n-    }\n-  /* LAST is now the last basetype assoc on the path.  */\n+\t      /* Happens in the case of parse errors.  */\n+\t      if (nonnull_expr == error_mark_node)\n+\t\treturn error_mark_node;\n+\t    }\n+\t  else\n+\t    {\n+\t      cp_error (\"cannot cast up from virtual baseclass `%T'\",\n+\t\t\t  last_virtual);\n+\t      return error_mark_node;\n+\t    }\n+\t}\n+      last = TREE_VALUE (path);\n+      path = TREE_CHAIN (path);\n+    }\n+  /* LAST is now the last basetype assoc on the path.  */\n \n   /* A pointer to a virtual base member of a non-null object\n      is non-null.  Therefore, we only need to test for zeroness once.\n@@ -752,75 +448,6 @@ build_vbase_path (code, type, expr, path, nonnull)\n \f\n /* Virtual function things.  */\n \n-/* Build an entry in the virtual function table.  DELTA is the offset\n-   for the `this' pointer.  VCALL_INDEX is the vtable index containing\n-   the vcall offset; zero if none.  ENTRY is the virtual function\n-   table entry itself.  It's TREE_TYPE must be VFUNC_PTR_TYPE_NODE,\n-   but it may not actually be a virtual function table pointer.  (For\n-   example, it might be the address of the RTTI object, under the new\n-   ABI.)  */\n-\n-static tree\n-build_vtable_entry (delta, vcall_index, entry)\n-     tree delta;\n-     tree vcall_index;\n-     tree entry;\n-{\n-  if (flag_vtable_thunks)\n-    {\n-      HOST_WIDE_INT idelta;\n-      HOST_WIDE_INT ivindex;\n-\n-      idelta = tree_low_cst (delta, 0);\n-      ivindex = tree_low_cst (vcall_index, 0);\n-      if ((idelta || ivindex) \n-\t  && ! DECL_PURE_VIRTUAL_P (TREE_OPERAND (entry, 0)))\n-\t{\n-\t  entry = make_thunk (entry, idelta, ivindex);\n-\t  entry = build1 (ADDR_EXPR, vtable_entry_type, entry);\n-\t  TREE_READONLY (entry) = 1;\n-\t  TREE_CONSTANT (entry) = 1;\n-\t}\n-#ifdef GATHER_STATISTICS\n-      n_vtable_entries += 1;\n-#endif\n-      return entry;\n-    }\n-  else\n-    {\n-      extern int flag_huge_objects;\n-      tree elems = tree_cons (NULL_TREE, delta,\n-\t\t\t      tree_cons (NULL_TREE, integer_zero_node,\n-\t\t\t\t\t build_tree_list (NULL_TREE, entry)));\n-      tree entry = build (CONSTRUCTOR, vtable_entry_type, NULL_TREE, elems);\n-\n-      /* We don't use vcall offsets when not using vtable thunks.  */\n-      my_friendly_assert (integer_zerop (vcall_index), 20000125);\n-\n-      /* DELTA used to be constructed by `size_int' and/or size_binop,\n-\t which caused overflow problems when it was negative.  That should\n-\t be fixed now.  */\n-\n-      if (! int_fits_type_p (delta, delta_type_node))\n-\t{\n-\t  if (flag_huge_objects)\n-\t    sorry (\"object size exceeds built-in limit for virtual function table implementation\");\n-\t  else\n-\t    sorry (\"object size exceeds normal limit for virtual function table implementation, recompile all source and use -fhuge-objects\");\n-\t}\n-      \n-      TREE_CONSTANT (entry) = 1;\n-      TREE_STATIC (entry) = 1;\n-      TREE_READONLY (entry) = 1;\n-\n-#ifdef GATHER_STATISTICS\n-      n_vtable_entries += 1;\n-#endif\n-\n-      return entry;\n-    }\n-}\n-\n /* We want to give the assembler the vtable identifier as well as\n    the offset to the function pointer.  So we generate\n \n@@ -2590,6 +2217,19 @@ num_vfun_entries (binfo)\n   return list_length (BINFO_VIRTUALS (binfo));\n }\n \n+typedef struct vcall_offset_data_s\n+{\n+  /* The binfo for the most-derived type.  */\n+  tree derived;\n+  /* The binfo for the virtual base for which we're building\n+     initializers.  */\n+  tree vbase;\n+  /* The vcall offset initializers built up so far.  */\n+  tree inits;\n+  /* The number of vcall offsets accumulated.  */\n+  int offsets;\n+} vcall_offset_data;\n+\n /* Called from num_extra_vtbl_entries via dfs_walk.  */\n \n static tree\n@@ -2664,284 +2304,79 @@ size_extra_vtbl_entries (binfo)\n   return fold (offset);\n }\n \n-/* Construct the initializer for BINFOs virtual function table.  BINFO\n-   is part of the hierarchy dominated by T.  The value returned is a\n-   TREE_LIST suitable for wrapping in a CONSTRUCTOR to use as the\n-   DECL_INITIAL for a vtable.  */\n+/* True if we should override the given BASE_FNDECL with the given\n+   FNDECL.  */\n \n-static tree\n-build_vtbl_initializer (binfo, t)\n-     tree binfo;\n-     tree t;\n+static int\n+overrides (fndecl, base_fndecl)\n+     tree fndecl, base_fndecl;\n {\n-  tree v = BINFO_VIRTUALS (binfo);\n-  tree inits = NULL_TREE;\n-\n-  /* Add entries to the vtable that indicate how to adjust the this\n-     pointer when calling a virtual function in this class.  */\n-  inits = build_vcall_offset_vtbl_entries (binfo, t);\n-\n-  /* Add entries to the vtable for offsets to our virtual bases.  */\n-  inits = chainon (build_vbase_offset_vtbl_entries (binfo, t),\n-\t\t   inits);\n-\n-  /* Add entries to the vtable for RTTI.  */\n-  inits = chainon (build_rtti_vtbl_entries (binfo, t), inits);\n-\n-  /* Go through all the ordinary virtual functions, building up\n-     initializers.  */\n-  while (v)\n+  /* Destructors have special names.  */\n+  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (base_fndecl))\n+      && DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fndecl)))\n+    return 1;\n+  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (base_fndecl))\n+      || DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fndecl)))\n+    return 0;\n+  if (DECL_NAME (fndecl) == DECL_NAME (base_fndecl))\n     {\n-      tree delta;\n-      tree vcall_index;\n-      tree fn;\n-      tree pfn;\n-      tree init;\n-\n-      /* Pull the offset for `this', and the function to call, out of\n-\t the list.  */\n-      delta = BV_DELTA (v);\n-      vcall_index = BV_VCALL_INDEX (v);\n-      fn = BV_FN (v);\n-      my_friendly_assert (TREE_CODE (delta) == INTEGER_CST, 19990727);\n-      my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 19990727);\n-\n-      /* You can't call an abstract virtual function; it's abstract.\n-\t So, we replace these functions with __pure_virtual.  */\n-      if (DECL_PURE_VIRTUAL_P (fn))\n-\tfn = abort_fndecl;\n-\n-      /* Take the address of the function, considering it to be of an\n-\t appropriate generic type.  */\n-      pfn = build1 (ADDR_EXPR, vfunc_ptr_type_node, fn);\n-      /* The address of a function can't change.  */\n-      TREE_CONSTANT (pfn) = 1;\n-      /* Enter it in the vtable.  */\n-      init = build_vtable_entry (delta, vcall_index, pfn);\n-      /* And add it to the chain of initializers.  */\n-      inits = tree_cons (NULL_TREE, init, inits);\n-\n-      /* Keep going.  */\n-      v = TREE_CHAIN (v);\n+      tree types, base_types;\n+#if 0\n+      retypes = TREE_TYPE (TREE_TYPE (fndecl));\n+      base_retypes = TREE_TYPE (TREE_TYPE (base_fndecl));\n+#endif\n+      types = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+      base_types = TYPE_ARG_TYPES (TREE_TYPE (base_fndecl));\n+      if ((TYPE_QUALS (TREE_TYPE (TREE_VALUE (base_types)))\n+\t   == TYPE_QUALS (TREE_TYPE (TREE_VALUE (types))))\n+\t  && compparms (TREE_CHAIN (base_types), TREE_CHAIN (types)))\n+\treturn 1;\n     }\n-\n-  /* The initializers were built up in reverse order; straighten them\n-     out now.  */\n-  return nreverse (inits);\n-}\n-\n-/* Initialize the vtable for BINFO with the INITS.  */\n-\n-static void\n-initialize_vtable (binfo, inits)\n-     tree binfo;\n-     tree inits;\n-{\n-  tree context;\n-  tree decl;\n-\n-  layout_vtable_decl (binfo, list_length (inits));\n-  decl = BINFO_VTABLE (binfo);\n-  context = DECL_CONTEXT (decl);\n-  DECL_CONTEXT (decl) = 0;\n-  DECL_INITIAL (decl) = build_nt (CONSTRUCTOR, NULL_TREE, inits);\n-  cp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0);\n-  DECL_CONTEXT (decl) = context;\n+  return 0;\n }\n \n-/* Called from finish_vtbls via dfs_walk.  */\n-\n-static tree\n-dfs_finish_vtbls (binfo, data)\n-     tree binfo;\n-     void *data;\n-{\n-  tree t = (tree) data;\n-\n-  if (!BINFO_PRIMARY_MARKED_P (binfo)\n-      && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo))\n-      && BINFO_NEW_VTABLE_MARKED (binfo, t))\n-    initialize_vtable (binfo, \n-\t\t       build_vtbl_initializer (binfo, t));\n-\n-  CLEAR_BINFO_NEW_VTABLE_MARKED (binfo, t);\n-  SET_BINFO_MARKED (binfo);\n-\n-  return NULL_TREE;\n-}\n+typedef struct find_final_overrider_data_s {\n+  /* The function for which we are trying to find a final overrider.  */\n+  tree fn;\n+  /* The base class in which the function was declared.  */\n+  tree declaring_base;\n+  /* The most derived class in the hierarchy.  */\n+  tree most_derived_type;\n+  /* The final overriding function.  */\n+  tree overriding_fn;\n+  /* The BINFO for the class in which the final overriding function\n+     appears.  */\n+  tree overriding_base;\n+} find_final_overrider_data;\n \n-/* Called from finish_vtbls via dfs_walk when using the new ABI.\n-   Accumulates the vtable initializers for all of the vtables into\n-   TREE_VALUE (DATA).  */\n+/* Called from find_final_overrider via dfs_walk.  */\n \n static tree\n-dfs_accumulate_vtbl_inits (binfo, data)\n+dfs_find_final_overrider (binfo, data)\n      tree binfo;\n      void *data;\n {\n-  tree l;\n-  tree t;\n-\n-  l = (tree) data;\n-  t = TREE_PURPOSE (l);\n+  find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n \n-  if (!BINFO_PRIMARY_MARKED_P (binfo)\n-      && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo))\n-      && BINFO_NEW_VTABLE_MARKED (binfo, t))\n+  if (same_type_p (BINFO_TYPE (binfo), \n+\t\t   BINFO_TYPE (ffod->declaring_base))\n+      && tree_int_cst_equal (BINFO_OFFSET (binfo),\n+\t\t\t     BINFO_OFFSET (ffod->declaring_base)))\n     {\n-      /* If this is a secondary vtable, record its location.  */\n-      if (binfo != TYPE_BINFO (t))\n+      tree path;\n+      tree method;\n+\n+      /* We've found a path to the declaring base.  Walk down the path\n+\t looking for an overrider for FN.  */\n+      for (path = reverse_path (binfo); \n+\t   path; \n+\t   path = TREE_CHAIN (path))\n \t{\n-\t  tree vtbl;\n-\n-\t  vtbl = TYPE_BINFO_VTABLE (t);\n-\t  vtbl = build1 (ADDR_EXPR, \n-\t\t\t build_pointer_type (TREE_TYPE (vtbl)),\n-\t\t\t vtbl);\n-\t  BINFO_VTABLE (binfo)\n-\t    = build (PLUS_EXPR, TREE_TYPE (vtbl), vtbl,\n-\t\t     size_binop (MULT_EXPR,\n-\t\t\t\t TYPE_SIZE_UNIT (TREE_TYPE (vtbl)),\n-\t\t\t\t size_int (list_length (TREE_VALUE (l)))));\n-\t}\n-\n-      /* Add the initializers for this vtable to the initializers for\n-\t the other vtables we've already got.  */\n-      TREE_VALUE (l) \n-\t= chainon (TREE_VALUE (l),\n-\t\t   build_vtbl_initializer (binfo, t));\n-    }\n-\n-  CLEAR_BINFO_NEW_VTABLE_MARKED (binfo, t);\n-\n-  return NULL_TREE;\n-}\n-\n-/* Add the vtbl initializers for BINFO (and its non-primary,\n-   non-virtual bases) to the list of INITS.  */\n-\n-static void\n-accumulate_vtbl_inits (binfo, inits)\n-     tree binfo;\n-     tree inits;\n-{\n-  /* Walk the BINFO and its bases.  */\n-  dfs_walk_real (binfo,\n-\t\t dfs_accumulate_vtbl_inits,\n-\t\t NULL, \n-\t\t dfs_skip_vbases,\n-\t\t inits);\n-}\n-\n-/* Create all the necessary vtables for T and its base classes.  */\n-\n-static void\n-finish_vtbls (t)\n-     tree t;\n-{\n-  if (merge_primary_and_secondary_vtables_p ())\n-    {\n-      tree list;\n-      tree vbase;\n-\n-      /* Under the new ABI, we lay out the primary and secondary\n-\t vtables in one contiguous vtable.  The primary vtable is\n-\t first, followed by the non-virtual secondary vtables in\n-\t inheritance graph order.  */\n-      list = build_tree_list (t, NULL_TREE);\n-      accumulate_vtbl_inits (TYPE_BINFO (t), list);\n-      /* Then come the virtual bases, also in inheritance graph\n-\t order.  */\n-      for (vbase = CLASSTYPE_VBASECLASSES (t);\n-\t   vbase;\n-\t   vbase = TREE_CHAIN (vbase))\n-\taccumulate_vtbl_inits (vbase, list);\n-\n-      if (TYPE_BINFO_VTABLE (t))\n-\tinitialize_vtable (TYPE_BINFO (t), TREE_VALUE (list));\n-    }\n-  else\n-    {\n-      dfs_walk (TYPE_BINFO (t), dfs_finish_vtbls, \n-\t\tdfs_unmarked_real_bases_queue_p, t);\n-      dfs_walk (TYPE_BINFO (t), dfs_unmark, \n-\t\tdfs_marked_real_bases_queue_p, t);\n-    }\n-}\n-\n-/* True if we should override the given BASE_FNDECL with the given\n-   FNDECL.  */\n-\n-static int\n-overrides (fndecl, base_fndecl)\n-     tree fndecl, base_fndecl;\n-{\n-  /* Destructors have special names.  */\n-  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (base_fndecl))\n-      && DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fndecl)))\n-    return 1;\n-  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (base_fndecl))\n-      || DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fndecl)))\n-    return 0;\n-  if (DECL_NAME (fndecl) == DECL_NAME (base_fndecl))\n-    {\n-      tree types, base_types;\n-#if 0\n-      retypes = TREE_TYPE (TREE_TYPE (fndecl));\n-      base_retypes = TREE_TYPE (TREE_TYPE (base_fndecl));\n-#endif\n-      types = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n-      base_types = TYPE_ARG_TYPES (TREE_TYPE (base_fndecl));\n-      if ((TYPE_QUALS (TREE_TYPE (TREE_VALUE (base_types)))\n-\t   == TYPE_QUALS (TREE_TYPE (TREE_VALUE (types))))\n-\t  && compparms (TREE_CHAIN (base_types), TREE_CHAIN (types)))\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n-typedef struct find_final_overrider_data_s {\n-  /* The function for which we are trying to find a final overrider.  */\n-  tree fn;\n-  /* The base class in which the function was declared.  */\n-  tree declaring_base;\n-  /* The most derived class in the hierarchy.  */\n-  tree most_derived_type;\n-  /* The final overriding function.  */\n-  tree overriding_fn;\n-  /* The BINFO for the class in which the final overriding function\n-     appears.  */\n-  tree overriding_base;\n-} find_final_overrider_data;\n-\n-/* Called from find_final_overrider via dfs_walk.  */\n-\n-static tree\n-dfs_find_final_overrider (binfo, data)\n-     tree binfo;\n-     void *data;\n-{\n-  find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n-\n-  if (same_type_p (BINFO_TYPE (binfo), \n-\t\t   BINFO_TYPE (ffod->declaring_base))\n-      && tree_int_cst_equal (BINFO_OFFSET (binfo),\n-\t\t\t     BINFO_OFFSET (ffod->declaring_base)))\n-    {\n-      tree path;\n-      tree method;\n-\n-      /* We've found a path to the declaring base.  Walk down the path\n-\t looking for an overrider for FN.  */\n-      for (path = reverse_path (binfo); \n-\t   path; \n-\t   path = TREE_CHAIN (path))\n-\t{\n-\t  for (method = TYPE_METHODS (BINFO_TYPE (TREE_VALUE (path)));\n-\t       method;\n-\t       method = TREE_CHAIN (method))\n-\t    if (DECL_VIRTUAL_P (method) && overrides (method, ffod->fn))\n-\t      break;\n+\t  for (method = TYPE_METHODS (BINFO_TYPE (TREE_VALUE (path)));\n+\t       method;\n+\t       method = TREE_CHAIN (method))\n+\t    if (DECL_VIRTUAL_P (method) && overrides (method, ffod->fn))\n+\t      break;\n \n \t  if (method)\n \t    break;\n@@ -5299,7 +4734,7 @@ finish_struct_1 (t)\n \n   /* If we created a new vtbl pointer for this class, add it to the\n      list.  */\n-  if (TYPE_VFIELD (t) && CLASSTYPE_VFIELD_PARENT (t) == -1)\n+  if (TYPE_VFIELD (t) && !CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n     CLASSTYPE_VFIELDS (t) \n       = chainon (CLASSTYPE_VFIELDS (t), build_tree_list (NULL_TREE, t));\n \n@@ -6367,270 +5802,837 @@ instantiate_type (lhstype, rhs, flags)\n \terror (\"not enough type information\");\n       return error_mark_node;\n \n-    case COND_EXPR:\n-      if (type_unknown_p (TREE_OPERAND (rhs, 0)))\n+    case COND_EXPR:\n+      if (type_unknown_p (TREE_OPERAND (rhs, 0)))\n+\t{\n+\t  if (complain)\n+\t    error (\"not enough type information\");\n+\t  return error_mark_node;\n+\t}\n+      TREE_OPERAND (rhs, 1)\n+\t= instantiate_type (lhstype, TREE_OPERAND (rhs, 1), flags);\n+      if (TREE_OPERAND (rhs, 1) == error_mark_node)\n+\treturn error_mark_node;\n+      TREE_OPERAND (rhs, 2)\n+\t= instantiate_type (lhstype, TREE_OPERAND (rhs, 2), flags);\n+      if (TREE_OPERAND (rhs, 2) == error_mark_node)\n+\treturn error_mark_node;\n+\n+      TREE_TYPE (rhs) = lhstype;\n+      return rhs;\n+\n+    case MODIFY_EXPR:\n+      TREE_OPERAND (rhs, 1)\n+\t= instantiate_type (lhstype, TREE_OPERAND (rhs, 1), flags);\n+      if (TREE_OPERAND (rhs, 1) == error_mark_node)\n+\treturn error_mark_node;\n+\n+      TREE_TYPE (rhs) = lhstype;\n+      return rhs;\n+      \n+    case ADDR_EXPR:\n+      return instantiate_type (lhstype, TREE_OPERAND (rhs, 0), flags);\n+\n+    case ENTRY_VALUE_EXPR:\n+      my_friendly_abort (184);\n+      return error_mark_node;\n+\n+    case ERROR_MARK:\n+      return error_mark_node;\n+\n+    default:\n+      my_friendly_abort (185);\n+      return error_mark_node;\n+    }\n+}\n+\f\n+/* Return the name of the virtual function pointer field\n+   (as an IDENTIFIER_NODE) for the given TYPE.  Note that\n+   this may have to look back through base types to find the\n+   ultimate field name.  (For single inheritance, these could\n+   all be the same name.  Who knows for multiple inheritance).  */\n+\n+static tree\n+get_vfield_name (type)\n+     tree type;\n+{\n+  tree binfo = TYPE_BINFO (type);\n+  char *buf;\n+\n+  while (BINFO_BASETYPES (binfo)\n+\t && TYPE_CONTAINS_VPTR_P (BINFO_TYPE (BINFO_BASETYPE (binfo, 0)))\n+\t && ! TREE_VIA_VIRTUAL (BINFO_BASETYPE (binfo, 0)))\n+    binfo = BINFO_BASETYPE (binfo, 0);\n+\n+  type = BINFO_TYPE (binfo);\n+  buf = (char *) alloca (sizeof (VFIELD_NAME_FORMAT)\n+\t\t\t + TYPE_NAME_LENGTH (type) + 2);\n+  sprintf (buf, VFIELD_NAME_FORMAT, TYPE_NAME_STRING (type));\n+  return get_identifier (buf);\n+}\n+\n+void\n+print_class_statistics ()\n+{\n+#ifdef GATHER_STATISTICS\n+  fprintf (stderr, \"convert_harshness = %d\\n\", n_convert_harshness);\n+  fprintf (stderr, \"compute_conversion_costs = %d\\n\", n_compute_conversion_costs);\n+  fprintf (stderr, \"build_method_call = %d (inner = %d)\\n\",\n+\t   n_build_method_call, n_inner_fields_searched);\n+  if (n_vtables)\n+    {\n+      fprintf (stderr, \"vtables = %d; vtable searches = %d\\n\",\n+\t       n_vtables, n_vtable_searches);\n+      fprintf (stderr, \"vtable entries = %d; vtable elems = %d\\n\",\n+\t       n_vtable_entries, n_vtable_elems);\n+    }\n+#endif\n+}\n+\n+/* Build a dummy reference to ourselves so Derived::Base (and A::A) works,\n+   according to [class]:\n+                                          The class-name is also inserted\n+   into  the scope of the class itself.  For purposes of access checking,\n+   the inserted class name is treated as if it were a public member name.  */\n+\n+void\n+build_self_reference ()\n+{\n+  tree name = constructor_name (current_class_type);\n+  tree value = build_lang_decl (TYPE_DECL, name, current_class_type);\n+  tree saved_cas;\n+\n+  DECL_NONLOCAL (value) = 1;\n+  DECL_CONTEXT (value) = current_class_type;\n+  DECL_ARTIFICIAL (value) = 1;\n+\n+  if (processing_template_decl)\n+    value = push_template_decl (value);\n+\n+  saved_cas = current_access_specifier;\n+  current_access_specifier = access_public_node;\n+  finish_member_declaration (value);\n+  current_access_specifier = saved_cas;\n+}\n+\n+/* Returns 1 if TYPE contains only padding bytes.  */\n+\n+int\n+is_empty_class (type)\n+     tree type;\n+{\n+  tree t;\n+\n+  if (type == error_mark_node)\n+    return 0;\n+\n+  if (! IS_AGGR_TYPE (type))\n+    return 0;\n+\n+  if (flag_new_abi)\n+    return integer_zerop (CLASSTYPE_SIZE (type));\n+\n+  if (TYPE_BINFO_BASETYPES (type))\n+    return 0;\n+  t = TYPE_FIELDS (type);\n+  while (t && TREE_CODE (t) != FIELD_DECL)\n+    t = TREE_CHAIN (t);\n+  return (t == NULL_TREE);\n+}\n+\n+/* Find the enclosing class of the given NODE.  NODE can be a *_DECL or\n+   a *_TYPE node.  NODE can also be a local class.  */\n+\n+tree\n+get_enclosing_class (type)\n+     tree type;\n+{\n+  tree node = type;\n+\n+  while (node && TREE_CODE (node) != NAMESPACE_DECL)\n+    {\n+      switch (TREE_CODE_CLASS (TREE_CODE (node)))\n+\t{\n+\tcase 'd':\n+\t  node = DECL_CONTEXT (node);\n+\t  break;\n+\n+\tcase 't':\n+\t  if (node != type)\n+\t    return node;\n+\t  node = TYPE_CONTEXT (node);\n+\t  break;\n+\n+\tdefault:\n+\t  my_friendly_abort (0);\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Return 1 if TYPE or one of its enclosing classes is derived from BASE.  */\n+\n+int\n+is_base_of_enclosing_class (base, type)\n+     tree base, type;\n+{\n+  while (type)\n+    {\n+      if (get_binfo (base, type, 0))\n+\treturn 1;\n+\n+      type = get_enclosing_class (type);\n+    }\n+  return 0;\n+}\n+\n+/* Note that NAME was looked up while the current class was being\n+   defined and that the result of that lookup was DECL.  */\n+\n+void\n+maybe_note_name_used_in_class (name, decl)\n+     tree name;\n+     tree decl;\n+{\n+  splay_tree names_used;\n+\n+  /* If we're not defining a class, there's nothing to do.  */\n+  if (!current_class_type || !TYPE_BEING_DEFINED (current_class_type))\n+    return;\n+  \n+  /* If there's already a binding for this NAME, then we don't have\n+     anything to worry about.  */\n+  if (IDENTIFIER_CLASS_VALUE (name))\n+    return;\n+\n+  if (!current_class_stack[current_class_depth - 1].names_used)\n+    current_class_stack[current_class_depth - 1].names_used\n+      = splay_tree_new (splay_tree_compare_pointers, 0, 0);\n+  names_used = current_class_stack[current_class_depth - 1].names_used;\n+\n+  splay_tree_insert (names_used,\n+\t\t     (splay_tree_key) name, \n+\t\t     (splay_tree_value) decl);\n+}\n+\n+/* Note that NAME was declared (as DECL) in the current class.  Check\n+   to see that the declaration is legal.  */\n+\n+void\n+note_name_declared_in_class (name, decl)\n+     tree name;\n+     tree decl;\n+{\n+  splay_tree names_used;\n+  splay_tree_node n;\n+\n+  /* Look to see if we ever used this name.  */\n+  names_used \n+    = current_class_stack[current_class_depth - 1].names_used;\n+  if (!names_used)\n+    return;\n+\n+  n = splay_tree_lookup (names_used, (splay_tree_key) name);\n+  if (n)\n+    {\n+      /* [basic.scope.class]\n+\t \n+\t A name N used in a class S shall refer to the same declaration\n+\t in its context and when re-evaluated in the completed scope of\n+\t S.  */\n+      cp_error (\"declaration of `%#D'\", decl);\n+      cp_error_at (\"changes meaning of `%s' from `%+#D'\", \n+\t\t   IDENTIFIER_POINTER (DECL_NAME (OVL_CURRENT (decl))),\n+\t\t   (tree) n->value);\n+    }\n+}\n+\n+/* Dump the offsets of all the bases rooted at BINFO to stderr.\n+   INDENT should be zero when called from the top level; it is\n+   incremented recursively.  */\n+\n+void\n+dump_class_hierarchy (binfo, indent)\n+     tree binfo;\n+     int indent;\n+{\n+  int i;\n+\n+  fprintf (stderr, \"%*s0x%lx (%s) \", indent, \"\",\n+\t   (unsigned long) binfo,\n+\t   type_as_string (binfo, TS_PLAIN));\n+  fprintf (stderr, HOST_WIDE_INT_PRINT_DEC,\n+\t   tree_low_cst (BINFO_OFFSET (binfo), 0));\n+  fprintf (stderr, \" %s\\n\",\n+\t   BINFO_PRIMARY_MARKED_P (binfo) ? \"primary\" : \"\");\n+\n+  for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n+    dump_class_hierarchy (BINFO_BASETYPE (binfo, i), indent + 2);\n+}\n+\n+/* Virtual function table initialization.  */\n+\n+/* Create all the necessary vtables for T and its base classes.  */\n+\n+static void\n+finish_vtbls (t)\n+     tree t;\n+{\n+  if (merge_primary_and_secondary_vtables_p ())\n+    {\n+      tree list;\n+      tree vbase;\n+\n+      /* Under the new ABI, we lay out the primary and secondary\n+\t vtables in one contiguous vtable.  The primary vtable is\n+\t first, followed by the non-virtual secondary vtables in\n+\t inheritance graph order.  */\n+      list = build_tree_list (t, NULL_TREE);\n+      accumulate_vtbl_inits (TYPE_BINFO (t), list);\n+      /* Then come the virtual bases, also in inheritance graph\n+\t order.  */\n+      for (vbase = CLASSTYPE_VBASECLASSES (t);\n+\t   vbase;\n+\t   vbase = TREE_CHAIN (vbase))\n+\taccumulate_vtbl_inits (vbase, list);\n+\n+      if (TYPE_BINFO_VTABLE (t))\n+\tinitialize_vtable (TYPE_BINFO (t), TREE_VALUE (list));\n+    }\n+  else\n+    {\n+      dfs_walk (TYPE_BINFO (t), dfs_finish_vtbls, \n+\t\tdfs_unmarked_real_bases_queue_p, t);\n+      dfs_walk (TYPE_BINFO (t), dfs_unmark, \n+\t\tdfs_marked_real_bases_queue_p, t);\n+    }\n+}\n+\n+/* Called from finish_vtbls via dfs_walk.  */\n+\n+static tree\n+dfs_finish_vtbls (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  tree t = (tree) data;\n+\n+  if (!BINFO_PRIMARY_MARKED_P (binfo)\n+      && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo))\n+      && BINFO_NEW_VTABLE_MARKED (binfo, t))\n+    initialize_vtable (binfo, \n+\t\t       build_vtbl_initializer (binfo, t));\n+\n+  CLEAR_BINFO_NEW_VTABLE_MARKED (binfo, t);\n+  SET_BINFO_MARKED (binfo);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Initialize the vtable for BINFO with the INITS.  */\n+\n+static void\n+initialize_vtable (binfo, inits)\n+     tree binfo;\n+     tree inits;\n+{\n+  tree context;\n+  tree decl;\n+\n+  layout_vtable_decl (binfo, list_length (inits));\n+  decl = BINFO_VTABLE (binfo);\n+  context = DECL_CONTEXT (decl);\n+  DECL_CONTEXT (decl) = 0;\n+  DECL_INITIAL (decl) = build_nt (CONSTRUCTOR, NULL_TREE, inits);\n+  cp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0);\n+  DECL_CONTEXT (decl) = context;\n+}\n+\n+/* Add the vtbl initializers for BINFO (and its non-primary,\n+   non-virtual bases) to the list of INITS.  */\n+\n+static void\n+accumulate_vtbl_inits (binfo, inits)\n+     tree binfo;\n+     tree inits;\n+{\n+  /* Walk the BINFO and its bases.  */\n+  dfs_walk_real (binfo,\n+\t\t dfs_accumulate_vtbl_inits,\n+\t\t NULL, \n+\t\t dfs_skip_vbases,\n+\t\t inits);\n+}\n+\n+/* Called from finish_vtbls via dfs_walk when using the new ABI.\n+   Accumulates the vtable initializers for all of the vtables into\n+   TREE_VALUE (DATA).  */\n+\n+static tree\n+dfs_accumulate_vtbl_inits (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  tree l;\n+  tree t;\n+\n+  l = (tree) data;\n+  t = TREE_PURPOSE (l);\n+\n+  if (!BINFO_PRIMARY_MARKED_P (binfo)\n+      && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo))\n+      && BINFO_NEW_VTABLE_MARKED (binfo, t))\n+    {\n+      /* If this is a secondary vtable, record its location.  */\n+      if (binfo != TYPE_BINFO (t))\n+\t{\n+\t  tree vtbl;\n+\n+\t  vtbl = TYPE_BINFO_VTABLE (t);\n+\t  vtbl = build1 (ADDR_EXPR, \n+\t\t\t build_pointer_type (TREE_TYPE (vtbl)),\n+\t\t\t vtbl);\n+\t  BINFO_VTABLE (binfo)\n+\t    = build (PLUS_EXPR, TREE_TYPE (vtbl), vtbl,\n+\t\t     size_binop (MULT_EXPR,\n+\t\t\t\t TYPE_SIZE_UNIT (TREE_TYPE (vtbl)),\n+\t\t\t\t size_int (list_length (TREE_VALUE (l)))));\n+\t}\n+\n+      /* Add the initializers for this vtable to the initializers for\n+\t the other vtables we've already got.  */\n+      TREE_VALUE (l) \n+\t= chainon (TREE_VALUE (l),\n+\t\t   build_vtbl_initializer (binfo, t));\n+    }\n+\n+  CLEAR_BINFO_NEW_VTABLE_MARKED (binfo, t);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Construct the initializer for BINFOs virtual function table.  BINFO\n+   is part of the hierarchy dominated by T.  The value returned is a\n+   TREE_LIST suitable for wrapping in a CONSTRUCTOR to use as the\n+   DECL_INITIAL for a vtable.  */\n+\n+static tree\n+build_vtbl_initializer (binfo, t)\n+     tree binfo;\n+     tree t;\n+{\n+  tree v = BINFO_VIRTUALS (binfo);\n+  tree inits = NULL_TREE;\n+\n+  /* Add entries to the vtable that indicate how to adjust the this\n+     pointer when calling a virtual function in this class.  */\n+  inits = build_vcall_offset_vtbl_entries (binfo, t);\n+\n+  /* Add entries to the vtable for offsets to our virtual bases.  */\n+  inits = chainon (build_vbase_offset_vtbl_entries (binfo, t),\n+\t\t   inits);\n+\n+  /* Add entries to the vtable for RTTI.  */\n+  inits = chainon (build_rtti_vtbl_entries (binfo, t), inits);\n+\n+  /* Go through all the ordinary virtual functions, building up\n+     initializers.  */\n+  while (v)\n+    {\n+      tree delta;\n+      tree vcall_index;\n+      tree fn;\n+      tree pfn;\n+      tree init;\n+\n+      /* Pull the offset for `this', and the function to call, out of\n+\t the list.  */\n+      delta = BV_DELTA (v);\n+      vcall_index = BV_VCALL_INDEX (v);\n+      fn = BV_FN (v);\n+      my_friendly_assert (TREE_CODE (delta) == INTEGER_CST, 19990727);\n+      my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 19990727);\n+\n+      /* You can't call an abstract virtual function; it's abstract.\n+\t So, we replace these functions with __pure_virtual.  */\n+      if (DECL_PURE_VIRTUAL_P (fn))\n+\tfn = abort_fndecl;\n+\n+      /* Take the address of the function, considering it to be of an\n+\t appropriate generic type.  */\n+      pfn = build1 (ADDR_EXPR, vfunc_ptr_type_node, fn);\n+      /* The address of a function can't change.  */\n+      TREE_CONSTANT (pfn) = 1;\n+      /* Enter it in the vtable.  */\n+      init = build_vtable_entry (delta, vcall_index, pfn);\n+      /* And add it to the chain of initializers.  */\n+      inits = tree_cons (NULL_TREE, init, inits);\n+\n+      /* Keep going.  */\n+      v = TREE_CHAIN (v);\n+    }\n+\n+  /* The initializers were built up in reverse order; straighten them\n+     out now.  */\n+  return nreverse (inits);\n+}\n+\n+/* Called from build_vbase_offset_vtbl_entries via dfs_walk.  */\n+\n+static tree\n+dfs_build_vbase_offset_vtbl_entries (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  tree list = (tree) data;\n+\n+  if (TREE_TYPE (list) == binfo)\n+    /* The TREE_TYPE of LIST is the base class from which we started\n+       walking.  If that BINFO is virtual it's not a virtual baseclass\n+       of itself.  */\n+    ;\n+  else if (TREE_VIA_VIRTUAL (binfo))\n+    {\n+      tree init;\n+      tree vbase;\n+\n+      /* Remember the index to the vbase offset for this virtual\n+\t base.  */\n+      vbase = BINFO_FOR_VBASE (BINFO_TYPE (binfo), TREE_PURPOSE (list));\n+      if (!TREE_VALUE (list))\n+\tBINFO_VPTR_FIELD (vbase) = build_int_2 (-3, 0);\n+      else\n \t{\n-\t  if (complain)\n-\t    error (\"not enough type information\");\n-\t  return error_mark_node;\n+\t  BINFO_VPTR_FIELD (vbase) = TREE_PURPOSE (TREE_VALUE (list));\n+\t  BINFO_VPTR_FIELD (vbase)\n+\t    = fold (build (MINUS_EXPR, integer_type_node,\n+\t\t\t   BINFO_VPTR_FIELD (vbase), integer_one_node));\n \t}\n-      TREE_OPERAND (rhs, 1)\n-\t= instantiate_type (lhstype, TREE_OPERAND (rhs, 1), flags);\n-      if (TREE_OPERAND (rhs, 1) == error_mark_node)\n-\treturn error_mark_node;\n-      TREE_OPERAND (rhs, 2)\n-\t= instantiate_type (lhstype, TREE_OPERAND (rhs, 2), flags);\n-      if (TREE_OPERAND (rhs, 2) == error_mark_node)\n-\treturn error_mark_node;\n \n-      TREE_TYPE (rhs) = lhstype;\n-      return rhs;\n+      /* And record the offset at which this virtual base lies in the\n+\t vtable.  */\n+      init = BINFO_OFFSET (binfo);\n+      TREE_VALUE (list) = tree_cons (BINFO_VPTR_FIELD (vbase),\n+\t\t\t\t     init, TREE_VALUE (list));\n+    }\n \n-    case MODIFY_EXPR:\n-      TREE_OPERAND (rhs, 1)\n-\t= instantiate_type (lhstype, TREE_OPERAND (rhs, 1), flags);\n-      if (TREE_OPERAND (rhs, 1) == error_mark_node)\n-\treturn error_mark_node;\n+  SET_BINFO_VTABLE_PATH_MARKED (binfo);\n+  \n+  return NULL_TREE;\n+}\n \n-      TREE_TYPE (rhs) = lhstype;\n-      return rhs;\n-      \n-    case ADDR_EXPR:\n-      return instantiate_type (lhstype, TREE_OPERAND (rhs, 0), flags);\n+/* Returns the initializers for the vbase offset entries in the vtable\n+   for BINFO (which is part of the class hierarchy dominated by T), in\n+   reverse order.  */\n \n-    case ENTRY_VALUE_EXPR:\n-      my_friendly_abort (184);\n-      return error_mark_node;\n+static tree\n+build_vbase_offset_vtbl_entries (binfo, t)\n+     tree binfo;\n+     tree t;\n+{\n+  tree inits;\n+  tree init;\n+  tree list;\n \n-    case ERROR_MARK:\n-      return error_mark_node;\n+  /* Under the old ABI, pointers to virtual bases are stored in each\n+     object.  */\n+  if (!vbase_offsets_in_vtable_p ())\n+    return NULL_TREE;\n \n-    default:\n-      my_friendly_abort (185);\n-      return error_mark_node;\n+  /* If there are no virtual baseclasses, then there is nothing to\n+     do.  */\n+  if (!TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo)))\n+    return NULL_TREE;\n+\n+  inits = NULL_TREE;\n+\n+  /* The offsets are allocated in the reverse order of a\n+     depth-first left-to-right traversal of the hierarchy.  We use\n+     BINFO_VTABLE_PATH_MARKED because we are ourselves during a\n+     dfs_walk, and so BINFO_MARKED is already in use.  */\n+  list = build_tree_list (t, NULL_TREE);\n+  TREE_TYPE (list) = binfo;\n+  dfs_walk (binfo,\n+\t    dfs_build_vbase_offset_vtbl_entries,\n+\t    unmarked_vtable_pathp,\n+\t    list);\n+  dfs_walk (binfo,\n+\t    dfs_vtable_path_unmark,\n+\t    marked_vtable_pathp,\n+\t    list);\n+  inits = nreverse (TREE_VALUE (list));\n+\n+  /* We've now got offsets in the right order.  However, the offsets\n+     we've stored are offsets from the beginning of the complete\n+     object, and we need offsets from this BINFO.  */\n+  for (init = inits; init; init = TREE_CHAIN (init))\n+    {\n+      /* The dfs_build_vbase_offset_vtbl_entries routine uses the\n+\t TREE_PURPOSE to scribble in.  But, we need to clear it now so\n+\t that the values are not perceived as labeled initializers.  */\n+      TREE_PURPOSE (init) = NULL_TREE;\n+      TREE_VALUE (init)\n+\t= fold (build1 (NOP_EXPR, vtable_entry_type,\n+\t\t\tsize_diffop (TREE_VALUE (init),\n+\t\t\t\t     BINFO_OFFSET (binfo))));\n     }\n+\n+  return inits;\n }\n-\f\n-/* Return the name of the virtual function pointer field\n-   (as an IDENTIFIER_NODE) for the given TYPE.  Note that\n-   this may have to look back through base types to find the\n-   ultimate field name.  (For single inheritance, these could\n-   all be the same name.  Who knows for multiple inheritance).  */\n+\n+/* Called from build_vcall_offset_vtbl_entries via dfs_walk.  */\n \n static tree\n-get_vfield_name (type)\n-     tree type;\n+dfs_vcall_offset_queue_p (binfo, data)\n+     tree binfo;\n+     void *data;\n {\n-  tree binfo = TYPE_BINFO (type);\n-  char *buf;\n-\n-  while (BINFO_BASETYPES (binfo)\n-\t && TYPE_CONTAINS_VPTR_P (BINFO_TYPE (BINFO_BASETYPE (binfo, 0)))\n-\t && ! TREE_VIA_VIRTUAL (BINFO_BASETYPE (binfo, 0)))\n-    binfo = BINFO_BASETYPE (binfo, 0);\n+  vcall_offset_data* vod = (vcall_offset_data *) data;\n \n-  type = BINFO_TYPE (binfo);\n-  buf = (char *) alloca (sizeof (VFIELD_NAME_FORMAT)\n-\t\t\t + TYPE_NAME_LENGTH (type) + 2);\n-  sprintf (buf, VFIELD_NAME_FORMAT, TYPE_NAME_STRING (type));\n-  return get_identifier (buf);\n+  return (binfo == vod->vbase) ? binfo : dfs_skip_vbases (binfo, NULL);\n }\n \n-void\n-print_class_statistics ()\n+/* Called from build_vcall_offset_vtbl_entries via dfs_walk.  */\n+\n+static tree\n+dfs_build_vcall_offset_vtbl_entries (binfo, data)\n+     tree binfo;\n+     void *data;\n {\n-#ifdef GATHER_STATISTICS\n-  fprintf (stderr, \"convert_harshness = %d\\n\", n_convert_harshness);\n-  fprintf (stderr, \"compute_conversion_costs = %d\\n\", n_compute_conversion_costs);\n-  fprintf (stderr, \"build_method_call = %d (inner = %d)\\n\",\n-\t   n_build_method_call, n_inner_fields_searched);\n-  if (n_vtables)\n+  vcall_offset_data* vod;\n+  tree virtuals;\n+  tree binfo_inits;\n+\n+  /* Primary bases are not interesting; all of the virtual\n+     function table entries have been overridden.  */\n+  if (BINFO_PRIMARY_MARKED_P (binfo))\n+     return NULL_TREE;\n+\n+  vod = (vcall_offset_data *) data;\n+  binfo_inits = NULL_TREE;\n+\n+  /* We chain the offsets on in reverse order.  That's correct --\n+     build_vtbl_initializer will straighten them out.  */\n+  for (virtuals = BINFO_VIRTUALS (binfo);\n+       virtuals;\n+       virtuals = TREE_CHAIN (virtuals))\n     {\n-      fprintf (stderr, \"vtables = %d; vtable searches = %d\\n\",\n-\t       n_vtables, n_vtable_searches);\n-      fprintf (stderr, \"vtable entries = %d; vtable elems = %d\\n\",\n-\t       n_vtable_entries, n_vtable_elems);\n+      /* Figure out what function we're looking at.  */\n+      tree fn = TREE_VALUE (virtuals);\n+      tree base = DECL_CONTEXT (fn);\n+      /* The FN comes from BASE.  So, we must caculate the adjustment\n+\t from the virtual base that derived from BINFO to BASE.  */\n+      tree base_binfo = get_binfo (base, vod->derived, /*protect=*/0);\n+\n+      binfo_inits\n+\t= tree_cons (NULL_TREE,\n+\t\t     fold (build1 (NOP_EXPR, vtable_entry_type,\n+\t\t\t\t   size_diffop (BINFO_OFFSET (base_binfo),\n+\t\t\t\t\t\tBINFO_OFFSET (vod->vbase)))),\n+\t\t     binfo_inits);\n     }\n-#endif\n+\n+  /* Now add the initializers we've just created to the list that will\n+     be returned to our caller.  */\n+  vod->inits = chainon (vod->inits, binfo_inits);\n+\n+  return NULL_TREE;\n }\n \n-/* Build a dummy reference to ourselves so Derived::Base (and A::A) works,\n-   according to [class]:\n-                                          The class-name is also inserted\n-   into  the scope of the class itself.  For purposes of access checking,\n-   the inserted class name is treated as if it were a public member name.  */\n+/* Returns the initializers for the vcall offset entries in the vtable\n+   for BINFO (which is part of the class hierarchy dominated by T), in\n+   reverse order.  */\n \n-void\n-build_self_reference ()\n+static tree\n+build_vcall_offset_vtbl_entries (binfo, t)\n+     tree binfo;\n+     tree t;\n {\n-  tree name = constructor_name (current_class_type);\n-  tree value = build_lang_decl (TYPE_DECL, name, current_class_type);\n-  tree saved_cas;\n-\n-  DECL_NONLOCAL (value) = 1;\n-  DECL_CONTEXT (value) = current_class_type;\n-  DECL_ARTIFICIAL (value) = 1;\n+  vcall_offset_data vod;\n \n-  if (processing_template_decl)\n-    value = push_template_decl (value);\n+  /* Under the old ABI, the adjustments to the `this' pointer were made\n+     elsewhere.  */\n+  if (!vcall_offsets_in_vtable_p ())\n+    return NULL_TREE;\n \n-  saved_cas = current_access_specifier;\n-  current_access_specifier = access_public_node;\n-  finish_member_declaration (value);\n-  current_access_specifier = saved_cas;\n-}\n+  /* We only need these entries if this base is a virtual base.  */\n+  if (!TREE_VIA_VIRTUAL (binfo))\n+    return NULL_TREE;\n \n-/* Returns 1 if TYPE contains only padding bytes.  */\n+  /* We need a vcall offset for each of the virtual functions in this\n+     vtable.  For example:\n \n-int\n-is_empty_class (type)\n-     tree type;\n-{\n-  tree t;\n+       class A { virtual void f (); };\n+       class B : virtual public A { };\n+       class C: virtual public A, public B {};\n+      \n+     Now imagine:\n \n-  if (type == error_mark_node)\n-    return 0;\n+       B* b = new C;\n+       b->f();\n \n-  if (! IS_AGGR_TYPE (type))\n-    return 0;\n+     The location of `A' is not at a fixed offset relative to `B'; the\n+     offset depends on the complete object derived from `B'.  So, \n+     `B' vtable contains an entry for `f' that indicates by what\n+     amount the `this' pointer for `B' needs to be adjusted to arrive\n+     at `A'.  \n \n-  if (flag_new_abi)\n-    return integer_zerop (CLASSTYPE_SIZE (type));\n+     We need entries for all the functions in our primary vtable and\n+     in our non-virtual bases vtables.  For each base, the entries\n+     appear in the same order as in the base; but the bases themselves\n+     appear in reverse depth-first, left-to-right order.  */\n+  vod.derived = t;\n+  vod.vbase = binfo;\n+  vod.inits = NULL_TREE;\n+  dfs_walk (binfo,\n+\t    dfs_build_vcall_offset_vtbl_entries,\n+\t    dfs_vcall_offset_queue_p,\n+\t    &vod);\n \n-  if (TYPE_BINFO_BASETYPES (type))\n-    return 0;\n-  t = TYPE_FIELDS (type);\n-  while (t && TREE_CODE (t) != FIELD_DECL)\n-    t = TREE_CHAIN (t);\n-  return (t == NULL_TREE);\n+  return vod.inits;\n }\n \n-/* Find the enclosing class of the given NODE.  NODE can be a *_DECL or\n-   a *_TYPE node.  NODE can also be a local class.  */\n+/* Return vtbl initializers for the RTTI entries coresponding to the\n+   BINFO's vtable.  BINFO is a part of the hierarchy dominated by \n+   T.  */\n \n-tree\n-get_enclosing_class (type)\n-     tree type;\n+static tree\n+build_rtti_vtbl_entries (binfo, t)\n+     tree binfo;\n+     tree t;\n {\n-  tree node = type;\n-\n-  while (node && TREE_CODE (node) != NAMESPACE_DECL)\n-    {\n-      switch (TREE_CODE_CLASS (TREE_CODE (node)))\n-\t{\n-\tcase 'd':\n-\t  node = DECL_CONTEXT (node);\n-\t  break;\n+  tree b;\n+  tree basetype;\n+  tree inits;\n+  tree offset;\n+  tree decl;\n+  tree init;\n \n-\tcase 't':\n-\t  if (node != type)\n-\t    return node;\n-\t  node = TYPE_CONTEXT (node);\n-\t  break;\n+  basetype = BINFO_TYPE (binfo);\n+  inits = NULL_TREE;\n \n-\tdefault:\n-\t  my_friendly_abort (0);\n-\t}\n-    }\n-  return NULL_TREE;\n-}\n+  /* For a COM object there is no RTTI entry.  */\n+  if (CLASSTYPE_COM_INTERFACE (basetype))\n+    return inits;\n \n-/* Return 1 if TYPE or one of its enclosing classes is derived from BASE.  */\n+  /* To find the complete object, we will first convert to our most\n+     primary base, and then add the offset in the vtbl to that value.  */\n+  b = binfo;\n+  while (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (b)))\n+    b = BINFO_BASETYPE (b, \n+\t\t\tCLASSTYPE_VFIELD_PARENT (BINFO_TYPE (b)));\n+  offset = size_diffop (size_zero_node, BINFO_OFFSET (b));\n \n-int\n-is_base_of_enclosing_class (base, type)\n-     tree base, type;\n-{\n-  while (type)\n+  /* Add the offset-to-top entry.  */\n+  if (flag_vtable_thunks)\n     {\n-      if (get_binfo (base, type, 0))\n-\treturn 1;\n-\n-      type = get_enclosing_class (type);\n+      /* Convert the offset to look like a function pointer, so that\n+\t we can put it in the vtable.  */\n+      init = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n+      TREE_CONSTANT (init) = 1;\n+      inits = tree_cons (NULL_TREE, init, inits);\n     }\n-  return 0;\n-}\n \n-/* Note that NAME was looked up while the current class was being\n-   defined and that the result of that lookup was DECL.  */\n+  /* The second entry is, in the case of the new ABI, the address of\n+     the typeinfo object, or, in the case of the old ABI, a function\n+     which returns a typeinfo object.  */\n+  if (new_abi_rtti_p ())\n+    {\n+      if (flag_rtti)\n+\tdecl = build_unary_op (ADDR_EXPR, get_tinfo_decl (t), 0);\n+      else\n+\tdecl = integer_zero_node;\n \n-void\n-maybe_note_name_used_in_class (name, decl)\n-     tree name;\n-     tree decl;\n-{\n-  splay_tree names_used;\n+      /* Convert the declaration to a type that can be stored in the\n+\t vtable.  */\n+      init = build1 (NOP_EXPR, vfunc_ptr_type_node, decl);\n+      TREE_CONSTANT (init) = 1;\n+    }\n+  else\n+    {\n+      if (flag_rtti)\n+\tdecl = get_tinfo_decl (t);\n+      else\n+\tdecl = abort_fndecl;\n \n-  /* If we're not defining a class, there's nothing to do.  */\n-  if (!current_class_type || !TYPE_BEING_DEFINED (current_class_type))\n-    return;\n-  \n-  /* If there's already a binding for this NAME, then we don't have\n-     anything to worry about.  */\n-  if (IDENTIFIER_CLASS_VALUE (name))\n-    return;\n+      /* Convert the declaration to a type that can be stored in the\n+\t vtable.  */\n+      init = build1 (ADDR_EXPR, vfunc_ptr_type_node, decl);\n+      TREE_CONSTANT (init) = 1;\n+      init = build_vtable_entry (offset, integer_zero_node, init);\n+    }\n \n-  if (!current_class_stack[current_class_depth - 1].names_used)\n-    current_class_stack[current_class_depth - 1].names_used\n-      = splay_tree_new (splay_tree_compare_pointers, 0, 0);\n-  names_used = current_class_stack[current_class_depth - 1].names_used;\n+  /* Hook the RTTI declaration onto the list.  */\n+  inits = tree_cons (NULL_TREE, init, inits);\n \n-  splay_tree_insert (names_used,\n-\t\t     (splay_tree_key) name, \n-\t\t     (splay_tree_value) decl);\n+  return inits;\n }\n \n-/* Note that NAME was declared (as DECL) in the current class.  Check\n-   to see that the declaration is legal.  */\n+/* Build an entry in the virtual function table.  DELTA is the offset\n+   for the `this' pointer.  VCALL_INDEX is the vtable index containing\n+   the vcall offset; zero if none.  ENTRY is the virtual function\n+   table entry itself.  It's TREE_TYPE must be VFUNC_PTR_TYPE_NODE,\n+   but it may not actually be a virtual function table pointer.  (For\n+   example, it might be the address of the RTTI object, under the new\n+   ABI.)  */\n \n-void\n-note_name_declared_in_class (name, decl)\n-     tree name;\n-     tree decl;\n+static tree\n+build_vtable_entry (delta, vcall_index, entry)\n+     tree delta;\n+     tree vcall_index;\n+     tree entry;\n {\n-  splay_tree names_used;\n-  splay_tree_node n;\n-\n-  /* Look to see if we ever used this name.  */\n-  names_used \n-    = current_class_stack[current_class_depth - 1].names_used;\n-  if (!names_used)\n-    return;\n-\n-  n = splay_tree_lookup (names_used, (splay_tree_key) name);\n-  if (n)\n+  if (flag_vtable_thunks)\n     {\n-      /* [basic.scope.class]\n-\t \n-\t A name N used in a class S shall refer to the same declaration\n-\t in its context and when re-evaluated in the completed scope of\n-\t S.  */\n-      cp_error (\"declaration of `%#D'\", decl);\n-      cp_error_at (\"changes meaning of `%s' from `%+#D'\", \n-\t\t   IDENTIFIER_POINTER (DECL_NAME (OVL_CURRENT (decl))),\n-\t\t   (tree) n->value);\n+      HOST_WIDE_INT idelta;\n+      HOST_WIDE_INT ivindex;\n+\n+      idelta = tree_low_cst (delta, 0);\n+      ivindex = tree_low_cst (vcall_index, 0);\n+      if ((idelta || ivindex) \n+\t  && ! DECL_PURE_VIRTUAL_P (TREE_OPERAND (entry, 0)))\n+\t{\n+\t  entry = make_thunk (entry, idelta, ivindex);\n+\t  entry = build1 (ADDR_EXPR, vtable_entry_type, entry);\n+\t  TREE_READONLY (entry) = 1;\n+\t  TREE_CONSTANT (entry) = 1;\n+\t}\n+#ifdef GATHER_STATISTICS\n+      n_vtable_entries += 1;\n+#endif\n+      return entry;\n     }\n-}\n+  else\n+    {\n+      extern int flag_huge_objects;\n+      tree elems = tree_cons (NULL_TREE, delta,\n+\t\t\t      tree_cons (NULL_TREE, integer_zero_node,\n+\t\t\t\t\t build_tree_list (NULL_TREE, entry)));\n+      tree entry = build (CONSTRUCTOR, vtable_entry_type, NULL_TREE, elems);\n \n-/* Dump the offsets of all the bases rooted at BINFO to stderr.\n-   INDENT should be zero when called from the top level; it is\n-   incremented recursively.  */\n+      /* We don't use vcall offsets when not using vtable thunks.  */\n+      my_friendly_assert (integer_zerop (vcall_index), 20000125);\n \n-void\n-dump_class_hierarchy (binfo, indent)\n-     tree binfo;\n-     int indent;\n-{\n-  int i;\n+      /* DELTA used to be constructed by `size_int' and/or size_binop,\n+\t which caused overflow problems when it was negative.  That should\n+\t be fixed now.  */\n \n-  fprintf (stderr, \"%*s0x%lx (%s) \", indent, \"\",\n-\t   (unsigned long) binfo,\n-\t   type_as_string (binfo, TS_PLAIN));\n-  fprintf (stderr, HOST_WIDE_INT_PRINT_DEC,\n-\t   tree_low_cst (BINFO_OFFSET (binfo), 0));\n-  fprintf (stderr, \" %s\\n\",\n-\t   BINFO_PRIMARY_MARKED_P (binfo) ? \"primary\" : \"\");\n+      if (! int_fits_type_p (delta, delta_type_node))\n+\t{\n+\t  if (flag_huge_objects)\n+\t    sorry (\"object size exceeds built-in limit for virtual function table implementation\");\n+\t  else\n+\t    sorry (\"object size exceeds normal limit for virtual function table implementation, recompile all source and use -fhuge-objects\");\n+\t}\n+      \n+      TREE_CONSTANT (entry) = 1;\n+      TREE_STATIC (entry) = 1;\n+      TREE_READONLY (entry) = 1;\n \n-  for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n-    dump_class_hierarchy (BINFO_BASETYPE (binfo, i), indent + 2);\n+#ifdef GATHER_STATISTICS\n+      n_vtable_entries += 1;\n+#endif\n+\n+      return entry;\n+    }\n }"}]}