{"sha": "38b3627d6fcedf4e1b99e988440c1c366f6dba10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhiMzYyN2Q2ZmNlZGY0ZTFiOTllOTg4NDQwYzFjMzY2ZjZkYmExMA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-12-21T17:43:27Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-12-21T17:43:27Z"}, "message": "system.c (IN_RANGE): Use plain unsigned, not unsigned HOST_WIDE_INT.\n\n\t* system.c (IN_RANGE): Use plain unsigned, not unsigned\n\tHOST_WIDE_INT.\n\t* tree.def (VOID_TYPE, INTEGER_TYPE, REAL_TYPE, COMPLEX_TYPE,\n\tVECTOR_TYPE, OFFSET_TYPE, ENUMERAL_TYPE, BOOLEAN_TYPE, CHAR_TYPE,\n\tPOINTER_TYPE, REFERENCE_TYPE, METHOD_TYPE, FUNCTION_TYPE,\n\tFILE_TYPE, ARRAY_TYPE, RECORD_TYPE, UNION_TYPE,\n\tQUAL_UNION_TYPE): Reorder for better code efficiency.\n\t(CONST_DECL, TYPE_DECL, VAR_DECL, FIELD_DECL, PARM_DECL): Likewise.\n\t(INDIRECT_REF, ALIGN_INDIRECT_REF, MISALIGNED_INDIRECT_REF): Likewise.\n\t* tree.h (INDIRECT_REF_P): Reorder checks for better optimization.\n\t(IS_EXPR_CODE_CLASS): Use IN_RANGE.\n\t(INTEGRAL_TYPE_P, FLOAT_TYPE_P): Reorder checks for better\n\toptimization.\n\n\t* cp/cp-tree.def (TEMPLATE_TYPE_PARM,\n\tBOUND_TEMPLATE_TEMPLATE_PARM, TYPE_OF_TYPE, TYPENAME_TYPE): Reorder\n\tfor better code efficiency.\n\t* cp/cp-tree.h (CLASS_TYPE_P): Short circuit IS_AGGR_TYPE check.\n\t(CAN_HAVE_FULL_LANG_DECL_P): Reorder for better optimization.\n\t(INTEGRAL_CODE_P, CP_INTEGRAL_TYPE_P,\n\tINTEGRAL_OR_ENUMERATION_TYPE_P, SCALAR_TYPE_P,\n\tCP_AGGREGATE_TYPE_P, TYPE_PTROB_P, TYPE_REF_OBJ_P,\n\tTYPE_PTROBV_P): Likewise.\n\nFrom-SVN: r92463", "tree": {"sha": "4b5adf425ed835f3fe30098c1efdec407152dc19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b5adf425ed835f3fe30098c1efdec407152dc19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38b3627d6fcedf4e1b99e988440c1c366f6dba10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b3627d6fcedf4e1b99e988440c1c366f6dba10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38b3627d6fcedf4e1b99e988440c1c366f6dba10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b3627d6fcedf4e1b99e988440c1c366f6dba10/comments", "author": null, "committer": null, "parents": [{"sha": "1763d00076ac7e7da7a781a74932bb8aef649b8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1763d00076ac7e7da7a781a74932bb8aef649b8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1763d00076ac7e7da7a781a74932bb8aef649b8b"}], "stats": {"total": 324, "additions": 210, "deletions": 114}, "files": [{"sha": "262600c02e2b2f31bad8c224f25b984e8408e445", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b3627d6fcedf4e1b99e988440c1c366f6dba10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b3627d6fcedf4e1b99e988440c1c366f6dba10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38b3627d6fcedf4e1b99e988440c1c366f6dba10", "patch": "@@ -1,3 +1,19 @@\n+2004-12-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* system.c (IN_RANGE): Use plain unsigned, not unsigned\n+\tHOST_WIDE_INT.\n+\t* tree.def (VOID_TYPE, INTEGER_TYPE, REAL_TYPE, COMPLEX_TYPE,\n+\tVECTOR_TYPE, OFFSET_TYPE, ENUMERAL_TYPE, BOOLEAN_TYPE, CHAR_TYPE,\n+\tPOINTER_TYPE, REFERENCE_TYPE, METHOD_TYPE, FUNCTION_TYPE,\n+\tFILE_TYPE, ARRAY_TYPE, RECORD_TYPE, UNION_TYPE,\n+\tQUAL_UNION_TYPE): Reorder for better code efficiency.\n+\t(CONST_DECL, TYPE_DECL, VAR_DECL, FIELD_DECL, PARM_DECL): Likewise.\n+\t(INDIRECT_REF, ALIGN_INDIRECT_REF, MISALIGNED_INDIRECT_REF): Likewise.\n+\t* tree.h (INDIRECT_REF_P): Reorder checks for better optimization.\n+\t(IS_EXPR_CODE_CLASS): Use IN_RANGE.\n+\t(INTEGRAL_TYPE_P, FLOAT_TYPE_P): Reorder checks for better\n+\toptimization.\n+\n 2004-12-21  David O'Brien  <obrien@FreeBSD.org>\n \n \t* config/freebsd-spec.h:  Use KSE pthread lib for -pthread."}, {"sha": "c90f5af67ed797afea5f9aee8f8b6176fc4619d2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b3627d6fcedf4e1b99e988440c1c366f6dba10/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b3627d6fcedf4e1b99e988440c1c366f6dba10/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=38b3627d6fcedf4e1b99e988440c1c366f6dba10", "patch": "@@ -1,5 +1,15 @@\n 2004-12-21  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* cp-tree.def (TEMPLATE_TYPE_PARM,\n+\tBOUND_TEMPLATE_TEMPLATE_PARM, TYPE_OF_TYPE, TYPENAME_TYPE): Reorder \n+\tfor better code efficiency.\n+\t* cp-tree.h (CLASS_TYPE_P): Short circuit IS_AGGR_TYPE check.\n+\t(CAN_HAVE_FULL_LANG_DECL_P): Reorder for better optimization.\n+\t(INTEGRAL_CODE_P, CP_INTEGRAL_TYPE_P,\n+\tINTEGRAL_OR_ENUMERATION_TYPE_P, SCALAR_TYPE_P,\n+\tCP_AGGREGATE_TYPE_P, TYPE_PTROB_P, TYPE_REF_OBJ_P,\n+\tTYPE_PTROBV_P): Likewise. \n+\n \tPR c++/18975\n \t* method.c (do_build_copy_constructor): Refactor. Don't const\n \tqualify a mutable field."}, {"sha": "74f0d37e850c28a86eba0410d9577b665c764158", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b3627d6fcedf4e1b99e988440c1c366f6dba10/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b3627d6fcedf4e1b99e988440c1c366f6dba10/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=38b3627d6fcedf4e1b99e988440c1c366f6dba10", "patch": "@@ -159,10 +159,6 @@ DEFTREECODE (TEMPLATE_DECL, \"template_decl\", tcc_declaration, 0)\n    worrying about instantiating things.  */\n DEFTREECODE (TEMPLATE_PARM_INDEX, \"template_parm_index\", tcc_exceptional, 0)\n \n-/* Index into a template parameter list.  This parameter must be a type.\n-   The type.value field will be a TEMPLATE_PARM_INDEX.  */\n-DEFTREECODE (TEMPLATE_TYPE_PARM, \"template_type_parm\", tcc_type, 0)\n-\n /* Index into a template parameter list for template template parameters.\n    This parameter must be a type.  The TYPE_FIELDS value will be a \n    TEMPLATE_PARM_INDEX.\n@@ -172,28 +168,37 @@ DEFTREECODE (TEMPLATE_TYPE_PARM, \"template_type_parm\", tcc_type, 0)\n    and TYPE_NAME is a TEMPLATE_DECL.  */\n DEFTREECODE (TEMPLATE_TEMPLATE_PARM, \"template_template_parm\", tcc_type, 0)\n \n-/* Like TEMPLATE_TEMPLATE_PARM it is used with bound template arguments \n-   like TT<int>.\n-   In this case, TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO contains the\n-   template name and its bound arguments.  TYPE_NAME is a TYPE_DECL.  */\n-DEFTREECODE (BOUND_TEMPLATE_TEMPLATE_PARM, \"bound_template_template_parm\",\n-\t     tcc_type, 0)\n+/* The ordering of the following codes is optimized for the checking\n+   macros in tree.h.  Changing the order will degrade the speed of the\n+   compiler.  TEMPLATE_TYPE_PARM, TYPENAME_TYPE, TYPEOF_TYPE,\n+   BOUND_TEMPLATE_TEMPLATE_PARM.  */\n+     \n+/* Index into a template parameter list.  This parameter must be a type.\n+   The type.value field will be a TEMPLATE_PARM_INDEX.  */\n+DEFTREECODE (TEMPLATE_TYPE_PARM, \"template_type_parm\", tcc_type, 0)\n \n /* A type designated by `typename T::t'.  TYPE_CONTEXT is `T',\n    TYPE_NAME is an IDENTIFIER_NODE for `t'.  If the type was named via\n    template-id, TYPENAME_TYPE_FULLNAME will hold the TEMPLATE_ID_EXPR.\n    TREE_TYPE is always NULL.  */\n DEFTREECODE (TYPENAME_TYPE, \"typename_type\", tcc_type, 0)\n \n+/* A type designated by `__typeof (expr)'.  TYPEOF_TYPE_EXPR is the\n+   expression in question.  */\n+DEFTREECODE (TYPEOF_TYPE, \"typeof_type\", tcc_type, 0)\n+\n+/* Like TEMPLATE_TEMPLATE_PARM it is used with bound template arguments \n+   like TT<int>.\n+   In this case, TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO contains the\n+   template name and its bound arguments.  TYPE_NAME is a TYPE_DECL.  */\n+DEFTREECODE (BOUND_TEMPLATE_TEMPLATE_PARM, \"bound_template_template_parm\",\n+\t     tcc_type, 0)\n+\n /* For template template argument of the form `T::template C'.\n    TYPE_CONTEXT is `T', the template parameter dependent object.\n    TYPE_NAME is an IDENTIFIER_NODE for `C', the member class template.  */\n DEFTREECODE (UNBOUND_CLASS_TEMPLATE, \"unbound_class_template\", tcc_type, 0)\n \n-/* A type designated by `__typeof (expr)'.  TYPEOF_TYPE_EXPR is the\n-   expression in question.  */\n-DEFTREECODE (TYPEOF_TYPE, \"typeof_type\", tcc_type, 0)\n-\n /* A using declaration.  DECL_INITIAL contains the specified scope.  \n    This is not an alias, but is later expanded into multiple aliases.\n    The decl will have a NULL_TYPE iff the scope is a dependent scope,"}, {"sha": "82cd13f418fd622c659abf4402d2e3d8975a5926", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 59, "deletions": 39, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b3627d6fcedf4e1b99e988440c1c366f6dba10/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b3627d6fcedf4e1b99e988440c1c366f6dba10/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=38b3627d6fcedf4e1b99e988440c1c366f6dba10", "patch": "@@ -865,7 +865,8 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n    for template type parameters, typename types, and instantiated\n    template template parameters.  Despite its name,\n    this macro has nothing to do with the definition of aggregate given\n-   in the standard.  Think of this macro as MAYBE_CLASS_TYPE_P.  */\n+   in the standard.  Think of this macro as MAYBE_CLASS_TYPE_P.  Keep\n+   these checks in ascending code order.  */\n #define IS_AGGR_TYPE(T)\t\t\t\t\t\\\n   (TREE_CODE (T) == TEMPLATE_TYPE_PARM\t\t\t\\\n    || TREE_CODE (T) == TYPENAME_TYPE\t\t\t\\\n@@ -881,9 +882,11 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n /* Nonzero if T is a class type.  Zero for template type parameters,\n    typename types, and so forth.  */\n #define CLASS_TYPE_P(T) \\\n-  (IS_AGGR_TYPE_CODE (TREE_CODE (T)) && IS_AGGR_TYPE (T))\n+  (IS_AGGR_TYPE_CODE (TREE_CODE (T)) && TYPE_LANG_FLAG_5 (T))\n \n-#define IS_AGGR_TYPE_CODE(T)\t((T) == RECORD_TYPE || (T) == UNION_TYPE)\n+/* Keep these checks in ascending code order.  */\n+#define IS_AGGR_TYPE_CODE(T)\t\\\n+  ((T) == RECORD_TYPE || (T) == UNION_TYPE)\n #define TAGGED_TYPE_P(T) \\\n   (CLASS_TYPE_P (T) || TREE_CODE (T) == ENUMERAL_TYPE)\n #define IS_OVERLOAD_TYPE(T) TAGGED_TYPE_P (T)\n@@ -1485,11 +1488,12 @@ struct lang_type GTY(())\n /* If a DECL has DECL_LANG_SPECIFIC, it is either a lang_decl_flags or\n    a lang_decl (which has lang_decl_flags as its initial prefix).\n    This macro is nonzero for tree nodes whose DECL_LANG_SPECIFIC is\n-   the full lang_decl, and not just lang_decl_flags.  */\n-#define CAN_HAVE_FULL_LANG_DECL_P(NODE)\t\t\\\n-  (!(TREE_CODE (NODE) == VAR_DECL\t\t\\\n-     || TREE_CODE (NODE) == CONST_DECL\t\t\\\n-     || TREE_CODE (NODE) == FIELD_DECL\t\t\\\n+   the full lang_decl, and not just lang_decl_flags.  Keep these\n+   checks in ascending code order.  */\n+#define CAN_HAVE_FULL_LANG_DECL_P(NODE)\t\t\t\\\n+  (!(TREE_CODE (NODE) == FIELD_DECL\t\t\t\\\n+     || TREE_CODE (NODE) == VAR_DECL\t\t\t\\\n+     || TREE_CODE (NODE) == CONST_DECL\t\t\t\\\n      || TREE_CODE (NODE) == USING_DECL))\n \n struct lang_decl_flags GTY(())\n@@ -2315,53 +2319,63 @@ struct lang_decl GTY(())\n #define DECL_EXTERNAL_LINKAGE_P(DECL) \\\n   (decl_linkage (DECL) == lk_external)\n \n-#define INTEGRAL_CODE_P(CODE) \\\n-  ((CODE) == INTEGER_TYPE || (CODE) == ENUMERAL_TYPE || (CODE) == BOOLEAN_TYPE)\n+/* Keep these codes in ascending code order.  CHAR_TYPE is used here\n+   to completely fill the range.  */\n+\n+#define INTEGRAL_CODE_P(CODE) \t\t\t\t\\\n+  ((CODE) == ENUMERAL_TYPE || (CODE) == BOOLEAN_TYPE\t\\\n+   || (CODE) == CHAR_TYPE || (CODE) == INTEGER_TYPE)\n \n /* [basic.fundamental]\n \n    Types  bool, char, wchar_t, and the signed and unsigned integer types\n    are collectively called integral types.\n \n    Note that INTEGRAL_TYPE_P, as defined in tree.h, allows enumeration\n-   types as well, which is incorrect in C++.  */\n+   types as well, which is incorrect in C++.  Keep these checks in\n+   ascending code order.  CHAR_TYPE is added to complete the interval of\n+   values.  */\n #define CP_INTEGRAL_TYPE_P(TYPE)\t\t\\\n   (TREE_CODE (TYPE) == BOOLEAN_TYPE\t\t\\\n+   || TREE_CODE (TYPE) == CHAR_TYPE\t\t\\\n    || TREE_CODE (TYPE) == INTEGER_TYPE)\n \n-/* Returns true if TYPE is an integral or enumeration name.  */\n+/* Returns true if TYPE is an integral or enumeration name.  Keep\n+   these checks in ascending code order.  */\n #define INTEGRAL_OR_ENUMERATION_TYPE_P(TYPE) \\\n-  (CP_INTEGRAL_TYPE_P (TYPE) || TREE_CODE (TYPE) == ENUMERAL_TYPE)\n+   (TREE_CODE (TYPE) == ENUMERAL_TYPE || CP_INTEGRAL_TYPE_P (TYPE))\n \n /* [basic.fundamental]\n \n    Integral and floating types are collectively called arithmetic\n-   types.  */\n+   types.  Keep these checks in ascending code order.  */\n #define ARITHMETIC_TYPE_P(TYPE) \\\n   (CP_INTEGRAL_TYPE_P (TYPE) || TREE_CODE (TYPE) == REAL_TYPE)\n \n /* [basic.types]\n \n    Arithmetic types, enumeration types, pointer types, and\n-   pointer-to-member types, are collectively called scalar types.  */\n+   pointer-to-member types, are collectively called scalar types.\n+   Keep these checks in ascending code order.  */\n #define SCALAR_TYPE_P(TYPE)\t\t\t\\\n-  (ARITHMETIC_TYPE_P (TYPE)\t\t\t\\\n+  (TYPE_PTRMEM_P (TYPE)\t\t\t\t\\\n    || TREE_CODE (TYPE) == ENUMERAL_TYPE\t\t\\\n+   || ARITHMETIC_TYPE_P (TYPE)\t\t\t\\\n    || TYPE_PTR_P (TYPE)\t\t\t\t\\\n-   || TYPE_PTR_TO_MEMBER_P (TYPE))\n+   || TYPE_PTRMEMFUNC_P (TYPE))\n \n /* [dcl.init.aggr]\n \n    An aggregate is an array or a class with no user-declared\n    constructors, no private or protected non-static data members, no\n    base classes, and no virtual functions.\n \n-   As an extension, we also treat vectors as aggregates.  */\n-#define CP_AGGREGATE_TYPE_P(TYPE)\t\t\\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n-   || TREE_CODE (TYPE) == VECTOR_TYPE\t\t\\\n-   || (CLASS_TYPE_P (TYPE)\t\t\t\\\n-       && !CLASSTYPE_NON_AGGREGATE (TYPE)))\n+   As an extension, we also treat vectors as aggregates.  Keep these\n+   checks in ascending code order.  */\n+#define CP_AGGREGATE_TYPE_P(TYPE)\t\t\t\t\\\n+  (TREE_CODE (TYPE) == VECTOR_TYPE\t\t\t\t\\\n+   ||TREE_CODE (TYPE) == ARRAY_TYPE\t\t\t\t\\\n+   || (CLASS_TYPE_P (TYPE) && !CLASSTYPE_NON_AGGREGATE (TYPE)))\n \n /* Nonzero for a class type means that the class type has a\n    user-declared constructor.  */\n@@ -2442,21 +2456,26 @@ struct lang_decl GTY(())\n /* Returns true if NODE is a pointer.  */\n #define TYPE_PTR_P(NODE)\t\t\t\\\n   (TREE_CODE (NODE) == POINTER_TYPE)\n-/* Returns true if NODE is a pointer to an object.  */\n-#define TYPE_PTROB_P(NODE)\t\t\t\t\\\n-  (TYPE_PTR_P (NODE) \t\t\t\t\t\\\n-   && TREE_CODE (TREE_TYPE (NODE)) != FUNCTION_TYPE\t\\\n-   && TREE_CODE (TREE_TYPE (NODE)) != METHOD_TYPE\t\\\n-   && TREE_CODE (TREE_TYPE (NODE)) != VOID_TYPE)\n-/* Returns true if NODE is a reference to an object.  */\n-#define TYPE_REF_OBJ_P(NODE)\t\t\t\t\\\n-  (TREE_CODE (NODE) == REFERENCE_TYPE\t\t\t\\\n-   && TREE_CODE (TREE_TYPE (NODE)) != FUNCTION_TYPE\t\\\n-   && TREE_CODE (TREE_TYPE (NODE)) != METHOD_TYPE\t\\\n-   && TREE_CODE (TREE_TYPE (NODE)) != VOID_TYPE)\n-/* Returns true if NODE is a pointer to an object, or a pointer to void.  */\n-#define TYPE_PTROBV_P(NODE)\t\t\t\t\t\t\\\n-  (TYPE_PTR_P (NODE) && TREE_CODE (TREE_TYPE (NODE)) != FUNCTION_TYPE)\n+/* Returns true if NODE is a pointer to an object.  Keep these checks\n+   in ascending tree code order.  */\n+#define TYPE_PTROB_P(NODE)\t\t\t\t\t\\\n+  (TYPE_PTR_P (NODE) \t\t\t\t\t\t\\\n+   && !(TREE_CODE (TREE_TYPE (NODE)) == VOID_TYPE\t\t\\\n+        || TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE\t\\\n+        || TREE_CODE (TREE_TYPE (NODE)) == METHOD_TYPE))\n+/* Returns true if NODE is a reference to an object.  Keep these checks\n+   in ascending tree code order.  */\n+#define TYPE_REF_OBJ_P(NODE)\t\t\t\t\t\\\n+  (TREE_CODE (NODE) == REFERENCE_TYPE\t\t\t\t\\\n+   && !(TREE_CODE (TREE_TYPE (NODE)) == VOID_TYPE\t\t\\\n+        || TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE\t\\\n+        || TREE_CODE (TREE_TYPE (NODE)) == METHOD_TYPE))\n+/* Returns true if NODE is a pointer to an object, or a pointer to\n+   void.  Keep these checks in ascending tree code order.  */\n+#define TYPE_PTROBV_P(NODE)\t\t\t\t\t\\\n+  (TYPE_PTR_P (NODE) \t\t\t\t\t\t\\\n+   && !(TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE\t\t\\\n+        || TREE_CODE (TREE_TYPE (NODE)) == METHOD_TYPE))\n /* Returns true if NODE is a pointer to function.  */\n #define TYPE_PTRFN_P(NODE)\t\t\t\t\\\n   (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\\\n@@ -2680,7 +2699,8 @@ struct lang_decl GTY(())\n    This list is not used for static variable templates.  */\n #define DECL_TEMPLATE_SPECIALIZATIONS(NODE)     DECL_SIZE (NODE)\n \n-/* Nonzero for a DECL which is actually a template parameter.  */\n+/* Nonzero for a DECL which is actually a template parameter.  Keep\n+   these checks in ascending tree code order.   */\n #define DECL_TEMPLATE_PARM_P(NODE)\t\t\\\n   (DECL_LANG_FLAG_0 (NODE)\t\t\t\\\n    && (TREE_CODE (NODE) == CONST_DECL\t\t\\"}, {"sha": "0efd4142bf38a8c31c702f4ca5be2a910b43eba3", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b3627d6fcedf4e1b99e988440c1c366f6dba10/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b3627d6fcedf4e1b99e988440c1c366f6dba10/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=38b3627d6fcedf4e1b99e988440c1c366f6dba10", "patch": "@@ -179,7 +179,7 @@ extern int errno;\n    UPPER.  However the bounds themselves can be either positive or\n    negative.  */\n #define IN_RANGE(VALUE, LOWER, UPPER) \\\n-  ((unsigned HOST_WIDE_INT) ((VALUE) - (LOWER)) <= ((UPPER) - (LOWER)))\n+  ((unsigned)((VALUE) - (LOWER)) <= ((UPPER) - (LOWER)))\n \n /* Infrastructure for defining missing _MAX and _MIN macros.  Note that\n    macros defined with these cannot be used in #if.  */"}, {"sha": "b69dfcc1d939609d3fb2841661bef16568f0d506", "filename": "gcc/tree.def", "status": "modified", "additions": 82, "deletions": 47, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b3627d6fcedf4e1b99e988440c1c366f6dba10/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b3627d6fcedf4e1b99e988440c1c366f6dba10/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=38b3627d6fcedf4e1b99e988440c1c366f6dba10", "patch": "@@ -28,7 +28,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    different structures, and the size is determined by the tree_union\n    member structure; the 4th element should be zero.  Languages that\n    define language-specific tcc_exceptional or tcc_constant codes must\n-   define the tree_size langhook to say how big they are.  */\n+   define the tree_size langhook to say how big they are.\n+\n+   These tree codes have been sorted so that the macros in tree.h that\n+   check for various tree codes are optimized into range checks.  This\n+   gives a measureable performance improvement.  When adding a new\n+   code, consider its placement in relation to the other codes.  */\n \n /* Any erroneous construct is parsed into a node of this type.\n    This type of node is accepted without complaint in all contexts\n@@ -118,31 +123,16 @@ DEFTREECODE (BLOCK, \"block\", tcc_exceptional, 0)\n     ENUMERAL_TYPE, RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE nodes;\n     see below.  */\n \n-DEFTREECODE (VOID_TYPE, \"void_type\", tcc_type, 0)\n-\t/* The void type in C */\n-\n-/* Integer types in all languages, including char in C.\n-   Also used for sub-ranges of other discrete types.\n-   Has components TYPE_MIN_VALUE, TYPE_MAX_VALUE (expressions, inclusive)\n-   and TYPE_PRECISION (number of bits used by this type).\n-   In the case of a subrange type in Pascal, the TREE_TYPE\n-   of this will point at the supertype (another INTEGER_TYPE,\n-   or an ENUMERAL_TYPE, CHAR_TYPE, or BOOLEAN_TYPE).\n-   Otherwise, the TREE_TYPE is zero.  */\n-DEFTREECODE (INTEGER_TYPE, \"integer_type\", tcc_type, 0)\n-\n-/* C's float and double.  Different floating types are distinguished\n-   by machine mode and by the TYPE_SIZE and the TYPE_PRECISION.  */\n-DEFTREECODE (REAL_TYPE, \"real_type\", tcc_type, 0)\n-\n-/* Complex number types.  The TREE_TYPE field is the data type\n-   of the real and imaginary parts.  */\n-DEFTREECODE (COMPLEX_TYPE, \"complex_type\", tcc_type, 0)\n-\n-/* Vector types.  The TREE_TYPE field is the data type of the vector\n-   elements.  The TYPE_PRECISION field is the number of subparts of\n-   the vector.  */\n-DEFTREECODE (VECTOR_TYPE, \"vector_type\", tcc_type, 0)\n+/* The ordering of the following codes is optimized for the checking\n+   macros in tree.h.  Changing the order will degrade the speed of the\n+   compiler.  OFFSET_TYPE, ENUMERAL_TYPE, BOOLEAN_TYPE, CHAR_TYPE,\n+   INTEGER_TYPE, REAL_TYPE, POINTER_TYPE.  */\n+     \n+/* An offset is a pointer relative to an object.\n+   The TREE_TYPE field is the type of the object at the offset.\n+   The TYPE_OFFSET_BASETYPE points to the node for the type of object\n+   that the offset is relative to.  */\n+DEFTREECODE (OFFSET_TYPE, \"offset_type\", tcc_type, 0)\n \n /* C enums.  The type node looks just like an INTEGER_TYPE node.\n    The symbols for the values of the enum type are defined by\n@@ -157,38 +147,58 @@ DEFTREECODE (VECTOR_TYPE, \"vector_type\", tcc_type, 0)\n    treated similarly.  */\n DEFTREECODE (ENUMERAL_TYPE, \"enumeral_type\", tcc_type, 0)\n \n-/* Pascal's boolean type (true or false are the only values);\n-   no special fields needed.  */\n+/* Boolean type (true or false are the only values).  Looks like an\n+   INTEGRAL_TYPE. */\n DEFTREECODE (BOOLEAN_TYPE, \"boolean_type\", tcc_type, 0)\n \n-/* CHAR in Pascal; not used in C.\n-   No special fields needed.  */\n+/* CHAR in Java; not used in C.  Looks like an INTEGRAL_TYPE.  */\n DEFTREECODE (CHAR_TYPE, \"char_type\", tcc_type, 0)\n \n+/* Integer types in all languages, including char in C.\n+   Also used for sub-ranges of other discrete types.\n+   Has components TYPE_MIN_VALUE, TYPE_MAX_VALUE (expressions, inclusive)\n+   and TYPE_PRECISION (number of bits used by this type).\n+   In the case of a subrange type in Pascal, the TREE_TYPE\n+   of this will point at the supertype (another INTEGER_TYPE,\n+   or an ENUMERAL_TYPE, CHAR_TYPE, or BOOLEAN_TYPE).\n+   Otherwise, the TREE_TYPE is zero.  */\n+DEFTREECODE (INTEGER_TYPE, \"integer_type\", tcc_type, 0)\n+\n+/* C's float and double.  Different floating types are distinguished\n+   by machine mode and by the TYPE_SIZE and the TYPE_PRECISION.  */\n+DEFTREECODE (REAL_TYPE, \"real_type\", tcc_type, 0)\n+\n+/* The ordering of the following codes is optimized for the checking\n+   macros in tree.h.  Changing the order will degrade the speed of the\n+   compiler.  POINTER_TYPE, REFERENCE_TYPE.  Note that this range\n+   overlaps the previous range of ordered types. */\n+     \n /* All pointer-to-x types have code POINTER_TYPE.\n    The TREE_TYPE points to the node for the type pointed to.  */\n DEFTREECODE (POINTER_TYPE, \"pointer_type\", tcc_type, 0)\n \n-/* An offset is a pointer relative to an object.\n-   The TREE_TYPE field is the type of the object at the offset.\n-   The TYPE_OFFSET_BASETYPE points to the node for the type of object\n-   that the offset is relative to.  */\n-DEFTREECODE (OFFSET_TYPE, \"offset_type\", tcc_type, 0)\n-\n /* A reference is like a pointer except that it is coerced\n    automatically to the value it points to.  Used in C++.  */\n DEFTREECODE (REFERENCE_TYPE, \"reference_type\", tcc_type, 0)\n \n-/* METHOD_TYPE is the type of a function which takes an extra first\n-   argument for \"self\", which is not present in the declared argument list.\n-   The TREE_TYPE is the return type of the method.  The TYPE_METHOD_BASETYPE\n-   is the type of \"self\".  TYPE_ARG_TYPES is the real argument list, which\n-   includes the hidden argument for \"self\".  */\n-DEFTREECODE (METHOD_TYPE, \"method_type\", tcc_type, 0)\n+/* The ordering of the following codes is optimized for the checking\n+   macros in tree.h.  Changing the order will degrade the speed of the\n+   compiler.  COMPLEX_TYPE, VECTOR_TYPE, ARRAY_TYPE.  */\n+     \n+/* Complex number types.  The TREE_TYPE field is the data type\n+   of the real and imaginary parts.  */\n+DEFTREECODE (COMPLEX_TYPE, \"complex_type\", tcc_type, 0)\n \n-/* Used for Pascal; details not determined right now.  */\n-DEFTREECODE (FILE_TYPE, \"file_type\", tcc_type, 0)\n+/* Vector types.  The TREE_TYPE field is the data type of the vector\n+   elements.  The TYPE_PRECISION field is the number of subparts of\n+   the vector.  */\n+DEFTREECODE (VECTOR_TYPE, \"vector_type\", tcc_type, 0)\n \n+/* The ordering of the following codes is optimized for the checking\n+   macros in tree.h.  Changing the order will degrade the speed of the\n+   compiler.  ARRAY_TYPE, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE.\n+   Note that this range overlaps the previous range.  */\n+     \n /* Types of arrays.  Special fields:\n    TREE_TYPE\t\t  Type of an array element.\n    TYPE_DOMAIN\t\t  Type to index by.\n@@ -222,6 +232,13 @@ DEFTREECODE (UNION_TYPE, \"union_type\", tcc_type, 0)\t/* C union type */\n    the union.  */\n DEFTREECODE (QUAL_UNION_TYPE, \"qual_union_type\", tcc_type, 0)\n \n+/* The ordering of the following codes is optimized for the checking\n+   macros in tree.h.  Changing the order will degrade the speed of the\n+   compiler.  VOID_TYPE, FUNCTION_TYPE, METHOD_TYPE.  */\n+     \n+/* The void type in C */\n+DEFTREECODE (VOID_TYPE, \"void_type\", tcc_type, 0)\n+\n /* Type of functions.  Special fields:\n    TREE_TYPE\t\t    type of value returned.\n    TYPE_ARG_TYPES      list of types of arguments expected.\n@@ -230,6 +247,16 @@ DEFTREECODE (QUAL_UNION_TYPE, \"qual_union_type\", tcc_type, 0)\n    have code FUNCTION_TYPE also, but then TREE_TYPE is zero or void type.  */\n DEFTREECODE (FUNCTION_TYPE, \"function_type\", tcc_type, 0)\n \n+/* METHOD_TYPE is the type of a function which takes an extra first\n+   argument for \"self\", which is not present in the declared argument list.\n+   The TREE_TYPE is the return type of the method.  The TYPE_METHOD_BASETYPE\n+   is the type of \"self\".  TYPE_ARG_TYPES is the real argument list, which\n+   includes the hidden argument for \"self\".  */\n+DEFTREECODE (METHOD_TYPE, \"method_type\", tcc_type, 0)\n+\n+/* Used for Pascal; details not determined right now.  */\n+DEFTREECODE (FILE_TYPE, \"file_type\", tcc_type, 0)\n+\n /* This is a language-specific kind of type.\n    Its meaning is defined by the language front end.\n    layout_type does not know how to lay this out,\n@@ -323,12 +350,16 @@ DEFTREECODE (STRING_CST, \"string_cst\", tcc_constant, 0)\n \n DEFTREECODE (FUNCTION_DECL, \"function_decl\", tcc_declaration, 0)\n DEFTREECODE (LABEL_DECL, \"label_decl\", tcc_declaration, 0)\n-DEFTREECODE (CONST_DECL, \"const_decl\", tcc_declaration, 0)\n-DEFTREECODE (TYPE_DECL, \"type_decl\", tcc_declaration, 0)\n+/* The ordering of the following codes is optimized for the checking\n+   macros in tree.h.  Changing the order will degrade the speed of the\n+   compiler.  FIELD_DECL, VAR_DECL, CONST_DECL, PARM_DECL,\n+   TYPE_DECL.  */\n+DEFTREECODE (FIELD_DECL, \"field_decl\", tcc_declaration, 0)\n DEFTREECODE (VAR_DECL, \"var_decl\", tcc_declaration, 0)\n+DEFTREECODE (CONST_DECL, \"const_decl\", tcc_declaration, 0)\n DEFTREECODE (PARM_DECL, \"parm_decl\", tcc_declaration, 0)\n+DEFTREECODE (TYPE_DECL, \"type_decl\", tcc_declaration, 0)\n DEFTREECODE (RESULT_DECL, \"result_decl\", tcc_declaration, 0)\n-DEFTREECODE (FIELD_DECL, \"field_decl\", tcc_declaration, 0)\n \n /* A namespace declaration.  Namespaces appear in DECL_CONTEXT of other\n    _DECLs, providing a hierarchy of names.  */\n@@ -357,6 +388,10 @@ DEFTREECODE (COMPONENT_REF, \"component_ref\", tcc_reference, 3)\n    BIT_FIELD_REF_UNSIGNED says which.  */\n DEFTREECODE (BIT_FIELD_REF, \"bit_field_ref\", tcc_reference, 3)\n \n+/* The ordering of the following codes is optimized for the checking\n+   macros in tree.h.  Changing the order will degrade the speed of the\n+   compiler.  INDIRECT_REF, ALIGN_INDIRECT_REF, MISALIGNED_INDIRECT_REF.  */\n+\n /* C unary `*' or Pascal `^'.  One operand, an expression for a pointer.  */\n DEFTREECODE (INDIRECT_REF, \"indirect_ref\", tcc_reference, 1)\n "}, {"sha": "f70683ccd54a186367234101671ee9ab734c65d2", "filename": "gcc/tree.h", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b3627d6fcedf4e1b99e988440c1c366f6dba10/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b3627d6fcedf4e1b99e988440c1c366f6dba10/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=38b3627d6fcedf4e1b99e988440c1c366f6dba10", "patch": "@@ -51,6 +51,7 @@ enum tree_code {\n enum tree_code_class {\n   tcc_exceptional, /* An exceptional code (fits no category).  */\n   tcc_constant,    /* A constant.  */\n+  /* Order of tcc_type and tcc_declaration is important.  */\n   tcc_type,        /* A type object code.  */\n   tcc_declaration, /* A declaration (also serving as variable refs).  */\n   tcc_reference,   /* A reference to storage.  */\n@@ -96,11 +97,12 @@ extern const enum tree_code_class tree_code_type[];\n #define DECL_P(CODE)\\\n         (TREE_CODE_CLASS (TREE_CODE (CODE)) == tcc_declaration)\n \n-/* Nonzero if CODE represents a INDIRECT_REF.  */\n+/* Nonzero if CODE represents a INDIRECT_REF.  Keep these checks in\n+   ascending code order.  */\n #define INDIRECT_REF_P(CODE)\\\n   (TREE_CODE (CODE) == INDIRECT_REF \\\n-   || TREE_CODE (CODE) == MISALIGNED_INDIRECT_REF \\\n-   || TREE_CODE (CODE) == ALIGN_INDIRECT_REF)\n+   || TREE_CODE (CODE) == ALIGN_INDIRECT_REF \\\n+   || TREE_CODE (CODE) == MISALIGNED_INDIRECT_REF)\n \n /* Nonzero if CODE represents a reference.  */\n \n@@ -145,7 +147,7 @@ extern const enum tree_code_class tree_code_type[];\n    expression.  */\n \n #define IS_EXPR_CODE_CLASS(CLASS)\\\n-\t(((CLASS) >= tcc_reference) && ((CLASS) <= tcc_expression))\n+\t(IN_RANGE (CLASS, tcc_reference, tcc_expression))\n \n /* Returns nonzero iff NODE is an expression of some kind.  */\n \n@@ -737,11 +739,14 @@ extern void tree_operand_check_failed (int, enum tree_code,\n \tEXP = TREE_OPERAND (EXP, 0)\n \n /* Nonzero if TYPE represents an integral type.  Note that we do not\n-   include COMPLEX types here.  */\n+   include COMPLEX types here.  Keep these checks in ascending code\n+   order. */\n \n #define INTEGRAL_TYPE_P(TYPE)  \\\n-  (TREE_CODE (TYPE) == INTEGER_TYPE || TREE_CODE (TYPE) == ENUMERAL_TYPE  \\\n-   || TREE_CODE (TYPE) == BOOLEAN_TYPE || TREE_CODE (TYPE) == CHAR_TYPE)\n+  (TREE_CODE (TYPE) == ENUMERAL_TYPE  \\\n+   || TREE_CODE (TYPE) == BOOLEAN_TYPE \\\n+   || TREE_CODE (TYPE) == CHAR_TYPE \\\n+   || TREE_CODE (TYPE) == INTEGER_TYPE)\n \n /* Nonzero if TYPE represents a scalar floating-point type.  */\n \n@@ -760,20 +765,25 @@ extern void tree_operand_check_failed (int, enum tree_code,\n    && TREE_CODE (TREE_TYPE (TYPE)) == REAL_TYPE)\n \n /* Nonzero if TYPE represents a floating-point type, including complex\n-   and vector floating-point types.  */\n+   and vector floating-point types.  The vector and complex check does\n+   not use the previous two macros to enable early folding.  */\n \n-#define FLOAT_TYPE_P(TYPE)\t\t\\\n-  (SCALAR_FLOAT_TYPE_P (TYPE) || COMPLEX_FLOAT_TYPE_P (TYPE)\t\\\n-   || VECTOR_FLOAT_TYPE_P (TYPE))\n+#define FLOAT_TYPE_P(TYPE)\t\t\t\\\n+  (SCALAR_FLOAT_TYPE_P (TYPE)\t\t\t\\\n+   || ((TREE_CODE (TYPE) == COMPLEX_TYPE \t\\\n+        || TREE_CODE (TYPE) == VECTOR_TYPE)\t\\\n+       && SCALAR_FLOAT_TYPE_P (TREE_TYPE (TYPE))))\n \n-/* Nonzero if TYPE represents an aggregate (multi-component) type.  */\n+/* Nonzero if TYPE represents an aggregate (multi-component) type.\n+   Keep these checks in ascending code order.  */\n \n #define AGGREGATE_TYPE_P(TYPE) \\\n   (TREE_CODE (TYPE) == ARRAY_TYPE || TREE_CODE (TYPE) == RECORD_TYPE \\\n    || TREE_CODE (TYPE) == UNION_TYPE || TREE_CODE (TYPE) == QUAL_UNION_TYPE)\n \n /* Nonzero if TYPE represents a pointer or reference type.\n-   (It should be renamed to INDIRECT_TYPE_P.)  */\n+   (It should be renamed to INDIRECT_TYPE_P.)  Keep these checks in\n+   ascending code order.  */\n \n #define POINTER_TYPE_P(TYPE) \\\n   (TREE_CODE (TYPE) == POINTER_TYPE || TREE_CODE (TYPE) == REFERENCE_TYPE)"}]}