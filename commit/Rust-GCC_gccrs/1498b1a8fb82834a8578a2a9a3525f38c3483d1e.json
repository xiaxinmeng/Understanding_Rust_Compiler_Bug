{"sha": "1498b1a8fb82834a8578a2a9a3525f38c3483d1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ5OGIxYThmYjgyODM0YTg1NzhhMmE5YTM1MjVmMzhjMzQ4M2QxZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-13T10:41:09Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-13T10:41:09Z"}, "message": "Tweak the way that is_a is implemented\n\nAt the moment, class hierarchies that use is_a are expected\nto define specialisations like:\n\n  template <>\n  template <>\n  inline bool\n  is_a_helper <cgraph_node *>::test (symtab_node *p)\n  {\n    return p->type == SYMTAB_FUNCTION;\n  }\n\nBut this doesn't scale well to larger hierarchies, because it only\ndefines ::test for an argument that is exactly \u201csymtab_node *\u201d\n(and not for example \u201cconst symtab_node *\u201d or something that\ncomes between cgraph_node and symtab_node in the hierarchy).\n\nFor example:\n\n  struct A { int x; };\n  struct B : A {};\n  struct C : B {};\n\n  template <>\n  template <>\n  inline bool\n  is_a_helper <C *>::test (A *a)\n  {\n    return a->x == 1;\n  }\n\n  bool f(B *b) { return is_a<C *> (b); }\n\ngives:\n\n  warning: inline function \u2018static bool is_a_helper<T>::test(U*) [with U = B; T = C*]\u2019 used but never defined\n\nand:\n\n  bool f(const A *a) { return is_a<const C *> (a); }\n\ngives:\n\n  warning: inline function \u2018static bool is_a_helper<T>::test(U*) [with U = const A; T = const C*]\u2019 used but never defined\n\nThis patch instead allows is_a to be implemented by specialising\nis_a_helper as a whole, for example:\n\n  template<>\n  struct is_a_helper<C *> : static_is_a_helper<C *>\n  {\n    static inline bool test (const A *a) { return a->x == 1; }\n  };\n\nIt also adds a general specialisation of is_a_helper for const\npointers.  Together, this makes both of the above examples work.\n\ngcc/\n\t* is-a.h (reinterpret_is_a_helper): New class.\n\t(static_is_a_helper): Likewise.\n\t(is_a_helper): Inherit from reinterpret_is_a_helper.\n\t(is_a_helper<const T *>): New specialization.", "tree": {"sha": "100a00b14b25b7f5bee08c5bea2d47bacb5d8c70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/100a00b14b25b7f5bee08c5bea2d47bacb5d8c70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1498b1a8fb82834a8578a2a9a3525f38c3483d1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1498b1a8fb82834a8578a2a9a3525f38c3483d1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1498b1a8fb82834a8578a2a9a3525f38c3483d1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1498b1a8fb82834a8578a2a9a3525f38c3483d1e/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1751a78ecafb1d16d4a843dd22e739b8fd1cfede", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1751a78ecafb1d16d4a843dd22e739b8fd1cfede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1751a78ecafb1d16d4a843dd22e739b8fd1cfede"}], "stats": {"total": 81, "additions": 63, "deletions": 18}, "files": [{"sha": "26f53a5ba4a1ab3387939513a728e8c13463a00e", "filename": "gcc/is-a.h", "status": "modified", "additions": 63, "deletions": 18, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1498b1a8fb82834a8578a2a9a3525f38c3483d1e/gcc%2Fis-a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1498b1a8fb82834a8578a2a9a3525f38c3483d1e/gcc%2Fis-a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fis-a.h?ref=1498b1a8fb82834a8578a2a9a3525f38c3483d1e", "patch": "@@ -116,9 +116,30 @@ the connection between the types has not been made.  See below.\n \n EXTENDING THE GENERIC TYPE FACILITY\n \n-Each connection between types must be made by defining a specialization of the\n-template member function 'test' of the template class 'is_a_helper'.  For\n-example,\n+Method 1\n+--------\n+\n+If DERIVED is derived from BASE, and if BASE contains enough information\n+to determine whether an object is actually an instance of DERIVED,\n+then you can make the above routines work for DERIVED by defining\n+a specialization of is_a_helper such as:\n+\n+  template<>\n+  struct is_a_helper<DERIVED *> : static_is_a_helper<DERIVED *>\n+  {\n+    static inline bool test (const BASE *p) { return ...; }\n+  };\n+\n+This test function should return true if P is an instanced of DERIVED.\n+This on its own is enough; the comments below for method 2 do not apply.\n+\n+Method 2\n+--------\n+\n+Alternatively, if two types are connected in ways other than C++\n+inheritance, each connection between them must be made by defining a\n+specialization of the template member function 'test' of the template\n+class 'is_a_helper'.  For example,\n \n   template <>\n   template <>\n@@ -145,35 +166,59 @@ when needed may result in a crash.  For example,\n #ifndef GCC_IS_A_H\n #define GCC_IS_A_H\n \n+/* A base class that specializations of is_a_helper can use if casting\n+   U * to T is simply a reinterpret_cast.  */\n+\n+template <typename T>\n+struct reinterpret_is_a_helper\n+{\n+  template <typename U>\n+  static inline T cast (U *p) { return reinterpret_cast <T> (p); }\n+};\n+\n+/* A base class that specializations of is_a_helper can use if casting\n+   U * to T is simply a static_cast.  This is more type-safe than\n+   reinterpret_is_a_helper.  */\n+\n+template <typename T>\n+struct static_is_a_helper\n+{\n+  template <typename U>\n+  static inline T cast (U *p) { return static_cast <T> (p); }\n+};\n+\n /* A generic type conversion internal helper class.  */\n \n template <typename T>\n-struct is_a_helper\n+struct is_a_helper : reinterpret_is_a_helper<T>\n {\n   template <typename U>\n   static inline bool test (U *p);\n+};\n+\n+/* Reuse the definition of is_a_helper<T *> to implement\n+   is_a_helper<const T *>.  */\n+\n+template <typename T>\n+struct is_a_helper<const T *>\n+{\n   template <typename U>\n-  static inline T cast (U *p);\n+  static inline const T *cast (const U *p)\n+  {\n+    return is_a_helper<T *>::cast (const_cast <U *> (p));\n+  }\n+  template <typename U>\n+  static inline bool test (const U *p)\n+  {\n+    return is_a_helper<T *>::test (p);\n+  }\n };\n \n /* Note that we deliberately do not define the 'test' member template.  Not\n    doing so will result in a build-time error for type relationships that have\n    not been defined, rather than a run-time error.  See the discussion above\n    for when to define this member.  */\n \n-/* This is the generic implementation for casting from one type to another.\n-   Do not use this routine directly; it is an internal function.  See the\n-   discussion above for when to define this member.  */\n-\n-template <typename T>\n-template <typename U>\n-inline T\n-is_a_helper <T>::cast (U *p)\n-{\n-  return reinterpret_cast <T> (p);\n-}\n-\n-\n /* The public interface.  */\n \n /* A generic test for a type relationship.  See the discussion above for when"}]}