{"sha": "0ac2a27ad751182f295a6baab384ca22c11e53b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFjMmEyN2FkNzUxMTgyZjI5NWE2YmFhYjM4NGNhMjJjMTFlNTNiMg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-05-29T15:37:44Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2005-05-29T15:37:44Z"}, "message": "reg-stack.c (propagate_stack): Always copy the source stack to the destination.\n\n\n\t* reg-stack.c (propagate_stack): Always copy the source stack to\n\tthe destination.  This routine is now only called when this is safe.\n\t(better_edge): New function split out from convert_regs_1 to\n\tdetermine which of two edges is better to propagate across.\n\t(convert_regs_1):  We need only search for a best edge if the\n\tstack layout hasn't been defined yet.  Use better_edge to help\n\tfind beste.  No longer traverse unnecessary edges.\n\nFrom-SVN: r100323", "tree": {"sha": "33f875d7a34eb17686fd2ba815611a406f5634cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33f875d7a34eb17686fd2ba815611a406f5634cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ac2a27ad751182f295a6baab384ca22c11e53b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ac2a27ad751182f295a6baab384ca22c11e53b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ac2a27ad751182f295a6baab384ca22c11e53b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ac2a27ad751182f295a6baab384ca22c11e53b2/comments", "author": null, "committer": null, "parents": [{"sha": "9cf5a7e38d9098ce4961b091f70c40e8eb287e65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cf5a7e38d9098ce4961b091f70c40e8eb287e65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cf5a7e38d9098ce4961b091f70c40e8eb287e65"}], "stats": {"total": 138, "additions": 62, "deletions": 76}, "files": [{"sha": "891b283d5ee8217d5ee2a5527ebd7c4130667d37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac2a27ad751182f295a6baab384ca22c11e53b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac2a27ad751182f295a6baab384ca22c11e53b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ac2a27ad751182f295a6baab384ca22c11e53b2", "patch": "@@ -1,3 +1,13 @@\n+2005-05-29  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* reg-stack.c (propagate_stack): Always copy the source stack to\n+\tthe destination.  This routine is now only called when this is safe.\n+\t(better_edge): New function split out from convert_regs_1 to\n+\tdetermine which of two edges is better to propagate across.\n+\t(convert_regs_1):  We need only search for a best edge if the\n+\tstack layout hasn't been defined yet.  Use better_edge to help\n+\tfind beste.  No longer traverse unnecessary edges.\n+\n 2005-05-29  Keith Besaw  <kbesaw@us.ibm.com>\n \n \t* tree-ssa-alias.c (new_type_alias): New procedure to"}, {"sha": "85fa8816295371dfed9ee07ce7553cb4a7e9486b", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 52, "deletions": 76, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac2a27ad751182f295a6baab384ca22c11e53b2/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac2a27ad751182f295a6baab384ca22c11e53b2/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=0ac2a27ad751182f295a6baab384ca22c11e53b2", "patch": "@@ -2578,28 +2578,22 @@ convert_regs_exit (void)\n     }\n }\n \n-/* If the stack of the target block hasn't been processed yet,\n-   copy the stack info from the source block.  */\n+/* Copy the stack info from the end of edge E's source block to the\n+   start of E's destination block.  */\n \n static void\n propagate_stack (edge e)\n {\n-  basic_block dest = e->dest;\n-  stack dest_stack = &BLOCK_INFO (dest)->stack_in;\n-\n-  if (dest_stack->top == -2)\n-    {\n-      basic_block src = e->src;\n-      stack src_stack = &BLOCK_INFO (src)->stack_out;\n-      int reg;\n+  stack src_stack = &BLOCK_INFO (e->src)->stack_out;\n+  stack dest_stack = &BLOCK_INFO (e->dest)->stack_in;\n+  int reg;\n \n-      /* Preserve the order of the original stack, but check whether\n-\t any pops are needed.  */\n-      dest_stack->top = -1;\n-      for (reg = 0; reg <= src_stack->top; ++reg)\n-\tif (TEST_HARD_REG_BIT (dest_stack->reg_set, src_stack->reg[reg]))\n-\t  dest_stack->reg[++dest_stack->top] = src_stack->reg[reg];\n-    }\n+  /* Preserve the order of the original stack, but check whether\n+     any pops are needed.  */\n+  dest_stack->top = -1;\n+  for (reg = 0; reg <= src_stack->top; ++reg)\n+    if (TEST_HARD_REG_BIT (dest_stack->reg_set, src_stack->reg[reg]))\n+      dest_stack->reg[++dest_stack->top] = src_stack->reg[reg];\n }\n \n \n@@ -2738,6 +2732,37 @@ compensate_edges (FILE *file)\n   return inserted;\n }\n \n+/* Select the better of two edges E1 and E2 to use to determine the\n+   stack layout for their shared destination basic block.  This is\n+   typically the more frequently executed.  The edge E1 may be NULL\n+   (in which case E2 is returned), but E2 is always non-NULL.  */\n+\n+static edge\n+better_edge (edge e1, edge e2)\n+{\n+  if (!e1)\n+    return e2;\n+\n+  if (EDGE_FREQUENCY (e1) > EDGE_FREQUENCY (e2))\n+    return e1;\n+  if (EDGE_FREQUENCY (e1) < EDGE_FREQUENCY (e2))\n+    return e2;\n+\n+  if (e1->count > e2->count)\n+    return e1;\n+  if (e1->count < e2->count)\n+    return e2;\n+\n+  /* Prefer critical edges to minimize inserting compensation code on\n+     critical edges.  */\n+\n+  if (EDGE_CRITICAL_P (e1) != EDGE_CRITICAL_P (e2))\n+    return EDGE_CRITICAL_P (e1) ? e1 : e2;\n+\n+  /* Avoid non-deterministic behaviour.  */\n+  return (e1->src->index < e2->src->index) ? e1 : e2;\n+}\n+\n /* Convert stack register references in one block.  */\n \n static void\n@@ -2747,60 +2772,33 @@ convert_regs_1 (FILE *file, basic_block block)\n   block_info bi = BLOCK_INFO (block);\n   int reg;\n   rtx insn, next;\n-  edge e, beste = NULL;\n   bool control_flow_insn_deleted = false;\n-  edge_iterator ei;\n \n   any_malformed_asm = false;\n \n-  /* Find the edge we will copy stack from.  It should be the most frequent\n-     one as it will get cheapest after compensation code is generated,\n-     if multiple such exists, take one with largest count, prefer critical\n-     one (as splitting critical edges is more expensive), or one with lowest\n-     index, to avoid random changes with different orders of the edges.  */\n-  FOR_EACH_EDGE (e, ei, block->preds)\n-    {\n-      if (e->flags & EDGE_DFS_BACK)\n-\t;\n-      else if (! beste)\n-\tbeste = e;\n-      else if (EDGE_FREQUENCY (beste) < EDGE_FREQUENCY (e))\n-\tbeste = e;\n-      else if (EDGE_FREQUENCY (beste) > EDGE_FREQUENCY (e))\n-\t;\n-      else if (beste->count < e->count)\n-\tbeste = e;\n-      else if (beste->count > e->count)\n-\t;\n-      else if ((EDGE_CRITICAL_P (e) != 0)\n-\t       != (EDGE_CRITICAL_P (beste) != 0))\n-\t{\n-\t  if (EDGE_CRITICAL_P (e))\n-\t    beste = e;\n-\t}\n-      else if (e->src->index < beste->src->index)\n-\tbeste = e;\n-    }\n-\n-  /* Initialize stack at block entry.  */\n+  /* Choose an initial stack layout, if one hasn't already been chosen.  */\n   if (bi->stack_in.top == -2)\n     {\n+      edge e, beste = NULL;\n+      edge_iterator ei;\n+\n+      /* Select the best incoming edge (typically the most frequent) to\n+\t use as a template for this basic block.  */\n+      FOR_EACH_EDGE (e, ei, block->preds)\n+\tif (BLOCK_INFO (e->src)->done)\n+\t  beste = better_edge (beste, e);\n+\n       if (beste)\n \tpropagate_stack (beste);\n       else\n \t{\n \t  /* No predecessors.  Create an arbitrary input stack.  */\n-\t  int reg;\n-\n \t  bi->stack_in.top = -1;\n \t  for (reg = LAST_STACK_REG; reg >= FIRST_STACK_REG; --reg)\n \t    if (TEST_HARD_REG_BIT (bi->stack_in.reg_set, reg))\n \t      bi->stack_in.reg[++bi->stack_in.top] = reg;\n \t}\n     }\n-  else\n-    /* Entry blocks do have stack already initialized.  */\n-    beste = NULL;\n \n   current_block = block;\n \n@@ -2901,28 +2899,6 @@ convert_regs_1 (FILE *file, basic_block block)\n   gcc_assert (any_malformed_asm);\n  win:\n   bi->stack_out = regstack;\n-\n-  /* Compensate the back edges, as those wasn't visited yet.  */\n-  FOR_EACH_EDGE (e, ei, block->succs)\n-    {\n-      if (e->flags & EDGE_DFS_BACK\n-\t  || (e->dest == EXIT_BLOCK_PTR))\n-\t{\n-\t  gcc_assert (BLOCK_INFO (e->dest)->done\n-\t\t      || e->dest == block);\n-\t  propagate_stack (e);\n-\t}\n-    }\n-\n-  FOR_EACH_EDGE (e, ei, block->preds)\n-    {\n-      if (e != beste && !(e->flags & EDGE_DFS_BACK)\n-\t  && e->src != ENTRY_BLOCK_PTR)\n-\t{\n-\t  gcc_assert (BLOCK_INFO (e->src)->done);\n-\t  propagate_stack (e);\n-\t}\n-    }\n }\n \n /* Convert registers in all blocks reachable from BLOCK.  */"}]}