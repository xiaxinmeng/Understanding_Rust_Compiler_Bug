{"sha": "c6d6367f848cfd8381aba41e035c5e7e873667c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZkNjM2N2Y4NDhjZmQ4MzgxYWJhNDFlMDM1YzVlN2U4NzM2NjdjNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-17T14:20:29Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-17T14:20:29Z"}, "message": "libgo: update to Go1.10beta2 release\n    \n    Reviewed-on: https://go-review.googlesource.com/87897\n\nFrom-SVN: r256794", "tree": {"sha": "a218e98243463fc27f5053b4444e2544c63cd57a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a218e98243463fc27f5053b4444e2544c63cd57a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6d6367f848cfd8381aba41e035c5e7e873667c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6d6367f848cfd8381aba41e035c5e7e873667c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6d6367f848cfd8381aba41e035c5e7e873667c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6d6367f848cfd8381aba41e035c5e7e873667c5/comments", "author": null, "committer": null, "parents": [{"sha": "9bff0086915f544fa648ea81131f035cb9ce79a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bff0086915f544fa648ea81131f035cb9ce79a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bff0086915f544fa648ea81131f035cb9ce79a4"}], "stats": {"total": 11954, "additions": 6743, "deletions": 5211}, "files": [{"sha": "b6f59a63860a000003c2d286d447a23a3caf354d", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -1,4 +1,4 @@\n-ff851e1190923f8612004c6c214a7c202471b0ba\n+ca805b704fc141d7ad61f8fcd3badbaa04b7e363\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "b42c3a76f4f5cb3f7ed231f4e5d5fd8ee3fe5191", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -1,4 +1,4 @@\n-9ce6b5c2ed5d3d5251b9a6a0c548d5fb2c8567e8\n+594668a5a96267a46282ce3007a584ec07adf705\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "16ccf9caa135968d12e86c30dd315fc567f4b2e7", "filename": "libgo/Makefile.am", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -479,7 +479,7 @@ version.go: s-version; @true\n s-version: Makefile\n \trm -f version.go.tmp\n \techo \"package sys\" > version.go.tmp\n-\techo 'const DefaultGoroot = \"$(prefix)\"' >> version.go.tmp\n+\techo 'func init() { DefaultGoroot = \"$(prefix)\" }' >> version.go.tmp\n \techo 'const TheVersion = \"'`cat $(srcdir)/VERSION | sed 1q`' '`$(GOC) --version | sed 1q`'\"' >> version.go.tmp\n \techo 'const Goexperiment = ``' >> version.go.tmp\n \techo 'const GOARCH = \"'$(GOARCH)'\"' >> version.go.tmp\n@@ -535,7 +535,7 @@ s-objabi: Makefile\n \trm -f objabi.go.tmp\n \techo \"package objabi\" > objabi.go.tmp\n \techo \"import \\\"runtime\\\"\" >> objabi.go.tmp\n-\techo 'const defaultGOROOT = `$(prefix)`' >> objabi.go.tmp\n+\techo 'func init() { defaultGOROOT = `$(prefix)` }' >> objabi.go.tmp\n \techo 'const defaultGO386 = `sse2`' >> objabi.go.tmp\n \techo 'const defaultGOARM = `5`' >> objabi.go.tmp\n \techo 'const defaultGOMIPS = `hardfloat`' >> objabi.go.tmp\n@@ -824,6 +824,7 @@ PACKAGES = \\\n \tinternal/singleflight \\\n \tinternal/syscall/unix \\\n \tinternal/testenv \\\n+\tinternal/testlog \\\n \tinternal/trace \\\n \tio \\\n \tio/ioutil \\"}, {"sha": "7a02fa640296ad876c843793ccd85e96c87b08ab", "filename": "libgo/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -931,6 +931,7 @@ PACKAGES = \\\n \tinternal/singleflight \\\n \tinternal/syscall/unix \\\n \tinternal/testenv \\\n+\tinternal/testlog \\\n \tinternal/trace \\\n \tio \\\n \tio/ioutil \\\n@@ -3061,7 +3062,7 @@ version.go: s-version; @true\n s-version: Makefile\n \trm -f version.go.tmp\n \techo \"package sys\" > version.go.tmp\n-\techo 'const DefaultGoroot = \"$(prefix)\"' >> version.go.tmp\n+\techo 'func init() { DefaultGoroot = \"$(prefix)\" }' >> version.go.tmp\n \techo 'const TheVersion = \"'`cat $(srcdir)/VERSION | sed 1q`' '`$(GOC) --version | sed 1q`'\"' >> version.go.tmp\n \techo 'const Goexperiment = ``' >> version.go.tmp\n \techo 'const GOARCH = \"'$(GOARCH)'\"' >> version.go.tmp\n@@ -3117,7 +3118,7 @@ s-objabi: Makefile\n \trm -f objabi.go.tmp\n \techo \"package objabi\" > objabi.go.tmp\n \techo \"import \\\"runtime\\\"\" >> objabi.go.tmp\n-\techo 'const defaultGOROOT = `$(prefix)`' >> objabi.go.tmp\n+\techo 'func init() { defaultGOROOT = `$(prefix)` }' >> objabi.go.tmp\n \techo 'const defaultGO386 = `sse2`' >> objabi.go.tmp\n \techo 'const defaultGOARM = `5`' >> objabi.go.tmp\n \techo 'const defaultGOMIPS = `hardfloat`' >> objabi.go.tmp"}, {"sha": "9c5f795559152910f39ae96b664381a193c1750a", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -1 +1 @@\n-go1.10beta1\n+go1.10beta2"}, {"sha": "0b64b31d463a4a2f0fd74255bdf846de91e429fc", "filename": "libgo/go/cmd/cgo/doc.go", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -403,16 +403,35 @@ the CF*Ref types from the CoreFoundation library on Darwin, including:\n \tCFXMLParserRef\n \tCFXMLTreeRef\n \n+Also the object types from Java's JNI interface:\n+\n+\tjobject\n+\tjclass\n+\tjthrowable\n+\tjstring\n+\tjarray\n+\tjbooleanArray\n+\tjbyteArray\n+\tjcharArray\n+\tjshortArray\n+\tjintArray\n+\tjlongArray\n+\tjfloatArray\n+\tjdoubleArray\n+\tjobjectArray\n+\tjweak\n+\n These types are uintptr on the Go side because they would otherwise\n confuse the Go garbage collector; they are sometimes not really\n pointers but data structures encoded in a pointer type. All operations\n on these types must happen in C. The proper constant to initialize an\n empty such reference is 0, not nil.\n \n-This special case was introduced in Go 1.10. For auto-updating code\n-from Go 1.9 and earlier, use the cftype rewrite in the Go fix tool:\n+These special cases were introduced in Go 1.10. For auto-updating code\n+from Go 1.9 and earlier, use the cftype or jni rewrites in the Go fix tool:\n \n \tgo tool fix -r cftype <pkg>\n+\tgo tool fix -r jni <pkg>\n \n It will replace nil with 0 in the appropriate places.\n "}, {"sha": "d9db573438e474c2f62b9e7bbd8a7876bbe43b8d", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 73, "deletions": 5, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -2152,7 +2152,7 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\tname := c.Ident(\"_Ctype_\" + dt.Name)\n \t\tgoIdent[name.Name] = name\n \t\tsub := c.Type(dt.Type, pos)\n-\t\tif badPointerTypedef(dt.Name) {\n+\t\tif badPointerTypedef(dt) {\n \t\t\t// Treat this typedef as a uintptr.\n \t\t\ts := *sub\n \t\t\ts.Go = c.uintptr\n@@ -2318,7 +2318,7 @@ func (c *typeConv) FuncArg(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t\t}\n \t\t\t// ...or the typedef is one in which we expect bad pointers.\n \t\t\t// It will be a uintptr instead of *X.\n-\t\t\tif badPointerTypedef(dt.Name) {\n+\t\t\tif badPointerTypedef(dt) {\n \t\t\t\tbreak\n \t\t\t}\n \n@@ -2666,13 +2666,23 @@ func fieldPrefix(fld []*ast.Field) string {\n // A typedef is bad if C code sometimes stores non-pointers in this type.\n // TODO: Currently our best solution is to find these manually and list them as\n // they come up. A better solution is desired.\n-func badPointerTypedef(t string) bool {\n-\t// The real bad types are CFNumberRef and CFTypeRef.\n+func badPointerTypedef(dt *dwarf.TypedefType) bool {\n+\tif badCFType(dt) {\n+\t\treturn true\n+\t}\n+\tif badJNI(dt) {\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func badCFType(dt *dwarf.TypedefType) bool {\n+\t// The real bad types are CFNumberRef and CFDateRef.\n \t// Sometimes non-pointers are stored in these types.\n \t// CFTypeRef is a supertype of those, so it can have bad pointers in it as well.\n \t// We return true for the other CF*Ref types just so casting between them is easier.\n \t// See comment below for details about the bad pointers.\n-\treturn goos == \"darwin\" && strings.HasPrefix(t, \"CF\") && strings.HasSuffix(t, \"Ref\")\n+\treturn goos == \"darwin\" && strings.HasPrefix(dt.Name, \"CF\") && strings.HasSuffix(dt.Name, \"Ref\")\n }\n \n // Comment from Darwin's CFInternal.h\n@@ -2709,3 +2719,61 @@ enum {\n     kCFTaggedObjectID_Undefined7 = (7 << 1) + 1,\n };\n */\n+\n+func badJNI(dt *dwarf.TypedefType) bool {\n+\t// In Dalvik and ART, the jobject type in the JNI interface of the JVM has the\n+\t// property that it is sometimes (always?) a small integer instead of a real pointer.\n+\t// Note: although only the android JVMs are bad in this respect, we declare the JNI types\n+\t// bad regardless of platform, so the same Go code compiles on both android and non-android.\n+\tif parent, ok := jniTypes[dt.Name]; ok {\n+\t\t// Try to make sure we're talking about a JNI type, not just some random user's\n+\t\t// type that happens to use the same name.\n+\t\t// C doesn't have the notion of a package, so it's hard to be certain.\n+\n+\t\t// Walk up to jobject, checking each typedef on the way.\n+\t\tw := dt\n+\t\tfor parent != \"\" {\n+\t\t\tt, ok := w.Type.(*dwarf.TypedefType)\n+\t\t\tif !ok || t.Name != parent {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tw = t\n+\t\t\tparent, ok = jniTypes[w.Name]\n+\t\t\tif !ok {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Check that the typedef is:\n+\t\t//     struct _jobject;\n+\t\t//     typedef struct _jobject *jobject;\n+\t\tif ptr, ok := w.Type.(*dwarf.PtrType); ok {\n+\t\t\tif str, ok := ptr.Type.(*dwarf.StructType); ok {\n+\t\t\t\tif str.StructName == \"_jobject\" && str.Kind == \"struct\" && len(str.Field) == 0 && str.Incomplete {\n+\t\t\t\t\treturn true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+// jniTypes maps from JNI types that we want to be uintptrs, to the underlying type to which\n+// they are mapped.  The base \"jobject\" maps to the empty string.\n+var jniTypes = map[string]string{\n+\t\"jobject\":       \"\",\n+\t\"jclass\":        \"jobject\",\n+\t\"jthrowable\":    \"jobject\",\n+\t\"jstring\":       \"jobject\",\n+\t\"jarray\":        \"jobject\",\n+\t\"jbooleanArray\": \"jarray\",\n+\t\"jbyteArray\":    \"jarray\",\n+\t\"jcharArray\":    \"jarray\",\n+\t\"jshortArray\":   \"jarray\",\n+\t\"jintArray\":     \"jarray\",\n+\t\"jlongArray\":    \"jarray\",\n+\t\"jfloatArray\":   \"jarray\",\n+\t\"jdoubleArray\":  \"jarray\",\n+\t\"jobjectArray\":  \"jarray\",\n+\t\"jweak\":         \"jobject\",\n+}"}, {"sha": "92fad5d31a784f2bf76a5874a346238bc2eaac5f", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -1680,9 +1680,7 @@ const builtinExportProlog = `\n #ifndef GO_CGO_EXPORT_PROLOGUE_H\n #define GO_CGO_EXPORT_PROLOGUE_H\n \n-typedef ptrdiff_t intgo;\n-\n-typedef struct { const char *p; intgo n; } _GoString_;\n+typedef struct { const char *p; ptrdiff_t n; } _GoString_;\n \n #endif\n `"}, {"sha": "c151fa6a126ad3505c6b29e6d0157d4ebe753a3e", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -505,7 +505,7 @@\n //\n // Usage:\n //\n-// \tgo get [-d] [-f] [-fix] [-insecure] [-t] [-u] [build flags] [packages]\n+// \tgo get [-d] [-f] [-fix] [-insecure] [-t] [-u] [-v] [build flags] [packages]\n //\n // Get downloads the packages named by the import paths, along with their\n // dependencies. It then installs the named packages, like 'go install'.\n@@ -1710,14 +1710,14 @@\n // The 'go test' command expects to find test, benchmark, and example functions\n // in the \"*_test.go\" files corresponding to the package under test.\n //\n-// A test function is one named TestXXX (where XXX is any alphanumeric string\n-// not starting with a lower case letter) and should have the signature,\n+// A test function is one named TestXxx (where Xxx does not start with a\n+// lower case letter) and should have the signature,\n //\n-// \tfunc TestXXX(t *testing.T) { ... }\n+// \tfunc TestXxx(t *testing.T) { ... }\n //\n-// A benchmark function is one named BenchmarkXXX and should have the signature,\n+// A benchmark function is one named BenchmarkXxx and should have the signature,\n //\n-// \tfunc BenchmarkXXX(b *testing.B) { ... }\n+// \tfunc BenchmarkXxx(b *testing.B) { ... }\n //\n // An example function is similar to a test function but, instead of using\n // *testing.T to report success or failure, prints output to os.Stdout.\n@@ -1728,8 +1728,8 @@\n // comment is compiled but not executed. An example with no text after\n // \"Output:\" is compiled, executed, and expected to produce no output.\n //\n-// Godoc displays the body of ExampleXXX to demonstrate the use\n-// of the function, constant, or variable XXX. An example of a method M with\n+// Godoc displays the body of ExampleXxx to demonstrate the use\n+// of the function, constant, or variable Xxx. An example of a method M with\n // receiver type T or *T is named ExampleT_M. There may be multiple examples\n // for a given function, constant, or variable, distinguished by a trailing _xxx,\n // where xxx is a suffix not beginning with an upper case letter."}, {"sha": "7276a2c59cca0384f5016b7a65de0b2d318c4059", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 356, "deletions": 63, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -36,6 +36,16 @@ var (\n \tskipExternal = false // skip external tests\n )\n \n+func tooSlow(t *testing.T) {\n+\tif testing.Short() {\n+\t\t// In -short mode; skip test, except run it on the {darwin,linux,windows}/amd64 builders.\n+\t\tif testenv.Builder() != \"\" && runtime.GOARCH == \"amd64\" && (runtime.GOOS == \"linux\" || runtime.GOOS == \"darwin\" || runtime.GOOS == \"windows\") {\n+\t\t\treturn\n+\t\t}\n+\t\tt.Skip(\"skipping test in -short mode\")\n+\t}\n+}\n+\n func init() {\n \tswitch runtime.GOOS {\n \tcase \"android\", \"nacl\":\n@@ -92,6 +102,7 @@ func TestMain(m *testing.M) {\n \t\tfmt.Printf(\"SKIP\\n\")\n \t\treturn\n \t}\n+\tos.Unsetenv(\"GOROOT_FINAL\")\n \n \tif canRun {\n \t\targs := []string{\"build\", \"-tags\", \"testgo\", \"-o\", \"testgo\" + exeSuffix}\n@@ -916,6 +927,7 @@ func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n \n func TestGoListStandard(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo does not GOROOT\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \t// TODO: tg.parallel()\n@@ -941,6 +953,7 @@ func TestGoListStandard(t *testing.T) {\n }\n \n func TestGoInstallCleansUpAfterGoBuild(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \t// TODO: tg.parallel()\n@@ -983,6 +996,7 @@ func TestGoInstallCleansUpAfterGoBuild(t *testing.T) {\n }\n \n func TestGoInstallRebuildsStalePackagesInOtherGOPATH(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -1084,6 +1098,7 @@ func TestGoInstallErrorOnCrossCompileToBin(t *testing.T) {\n \n func TestGoInstallDetectsRemovedFilesInPackageMain(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo does not yet support package build IDs\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -1586,6 +1601,7 @@ func TestBuildOutputToDevNull(t *testing.T) {\n }\n \n func TestPackageMainTestImportsArchiveNotBinary(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -1601,6 +1617,19 @@ func TestPackageMainTestImportsArchiveNotBinary(t *testing.T) {\n \ttg.run(\"test\", \"main_test\")\n }\n \n+func TestPackageMainTestCompilerFlags(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.tempFile(\"src/p1/p1.go\", \"package main\\n\")\n+\ttg.tempFile(\"src/p1/p1_test.go\", \"package main\\nimport \\\"testing\\\"\\nfunc Test(t *testing.T){}\\n\")\n+\ttg.run(\"test\", \"-c\", \"-n\", \"p1\")\n+\ttg.grepBothNot(`([\\\\/]compile|gccgo).* (-p main|-fgo-pkgpath=main).*p1\\.go`, \"should not have run compile -p main p1.go\")\n+\ttg.grepStderr(`([\\\\/]compile|gccgo).* (-p p1|-fgo-pkgpath=p1).*p1\\.go`, \"should have run compile -p p1 p1.go\")\n+}\n+\n // The runtime version string takes one of two forms:\n // \"go1.X[.Y]\" for Go releases, and \"devel +hash\" at tip.\n // Determine whether we are in a released copy by\n@@ -1788,6 +1817,7 @@ func TestIgnoreEmptyPathsInGOPATH(t *testing.T) {\n \n // Issue 4104.\n func TestGoTestWithPackageListedMultipleTimes(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -1798,6 +1828,7 @@ func TestGoTestWithPackageListedMultipleTimes(t *testing.T) {\n }\n \n func TestGoListHasAConsistentOrder(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -1810,6 +1841,7 @@ func TestGoListHasAConsistentOrder(t *testing.T) {\n }\n \n func TestGoListStdDoesNotIncludeCommands(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -1819,6 +1851,7 @@ func TestGoListStdDoesNotIncludeCommands(t *testing.T) {\n \n func TestGoListCmdOnlyShowsCommands(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no GOROOT\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -2038,6 +2071,7 @@ func TestGoGetIntoGOROOT(t *testing.T) {\n \n func TestLdflagsArgumentsWithSpacesIssue3941(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo does not support -ldflags -X\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -2052,6 +2086,7 @@ func TestLdflagsArgumentsWithSpacesIssue3941(t *testing.T) {\n \n func TestGoTestCpuprofileLeavesBinaryBehind(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no standard packages\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \t// TODO: tg.parallel()\n@@ -2063,6 +2098,7 @@ func TestGoTestCpuprofileLeavesBinaryBehind(t *testing.T) {\n \n func TestGoTestCpuprofileDashOControlsBinaryLocation(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no standard packages\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \t// TODO: tg.parallel()\n@@ -2074,6 +2110,7 @@ func TestGoTestCpuprofileDashOControlsBinaryLocation(t *testing.T) {\n \n func TestGoTestMutexprofileLeavesBinaryBehind(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no standard packages\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \t// TODO: tg.parallel()\n@@ -2085,6 +2122,7 @@ func TestGoTestMutexprofileLeavesBinaryBehind(t *testing.T) {\n \n func TestGoTestMutexprofileDashOControlsBinaryLocation(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no standard packages\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \t// TODO: tg.parallel()\n@@ -2106,6 +2144,7 @@ func TestGoBuildNonMain(t *testing.T) {\n \n func TestGoTestDashCDashOControlsBinaryLocation(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no standard packages\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -2116,6 +2155,7 @@ func TestGoTestDashCDashOControlsBinaryLocation(t *testing.T) {\n \n func TestGoTestDashOWritesBinary(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no standard packages\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -2126,6 +2166,7 @@ func TestGoTestDashOWritesBinary(t *testing.T) {\n \n func TestGoTestDashIDashOWritesBinary(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no standard packages\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -2223,6 +2264,7 @@ func TestSymlinksInternal(t *testing.T) {\n \n // Issue 4515.\n func TestInstallWithTags(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -2408,10 +2450,8 @@ func checkCoverage(tg *testgoData, data string) {\n }\n \n func TestCoverageRuns(t *testing.T) {\n-\tif testing.Short() {\n-\t\tt.Skip(\"don't build libraries for coverage in short mode\")\n-\t}\n \tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.run(\"test\", \"-short\", \"-coverpkg=strings\", \"strings\", \"regexp\")\n@@ -2424,10 +2464,8 @@ func TestCoverageRuns(t *testing.T) {\n // Check that coverage analysis uses set mode.\n // Also check that coverage profiles merge correctly.\n func TestCoverageUsesSetMode(t *testing.T) {\n-\tif testing.Short() {\n-\t\tt.Skip(\"don't build libraries for coverage in short mode\")\n-\t}\n \tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.creatingTemp(\"testdata/cover.out\")\n@@ -2453,9 +2491,7 @@ func TestCoverageUsesSetMode(t *testing.T) {\n }\n \n func TestCoverageUsesAtomicModeForRace(t *testing.T) {\n-\tif testing.Short() {\n-\t\tt.Skip(\"don't build libraries for coverage in short mode\")\n-\t}\n+\ttooSlow(t)\n \tif !canRace {\n \t\tt.Skip(\"skipping because race detector not supported\")\n \t}\n@@ -2478,13 +2514,26 @@ func TestCoverageUsesAtomicModeForRace(t *testing.T) {\n \n func TestCoverageSyncAtomicImport(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n \ttg.run(\"test\", \"-short\", \"-cover\", \"-covermode=atomic\", \"-coverpkg=coverdep/p1\", \"coverdep\")\n }\n \n+func TestCoverageDepLoop(t *testing.T) {\n+\ttooSlow(t)\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\t// coverdep2/p1's xtest imports coverdep2/p2 which imports coverdep2/p1.\n+\t// Make sure that coverage on coverdep2/p2 recompiles coverdep2/p2.\n+\ttg.run(\"test\", \"-short\", \"-cover\", \"coverdep2/p1\")\n+\ttg.grepStdout(\"coverage: 100.0% of statements\", \"expected 100.0% coverage\")\n+}\n+\n func TestCoverageImportMainLoop(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no cover tool\")\n \ttg := testgo(t)\n@@ -2498,6 +2547,7 @@ func TestCoverageImportMainLoop(t *testing.T) {\n \n func TestCoveragePattern(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -2508,11 +2558,12 @@ func TestCoveragePattern(t *testing.T) {\n \t// (as opposed to pattern matching on deps)\n \t// then it will try to load sleepybad, which does not compile,\n \t// and the test command will fail.\n-\ttg.run(\"test\", \"-coverprofile=\"+filepath.Join(tg.tempdir, \"cover.out\"), \"-coverpkg=sleepy...\", \"-run=^$\", \"sleepy1\")\n+\ttg.run(\"test\", \"-coverprofile=\"+tg.path(\"cover.out\"), \"-coverpkg=sleepy...\", \"-run=^$\", \"sleepy1\")\n }\n \n func TestCoverageErrorLine(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -2542,6 +2593,8 @@ func TestCoverageErrorLine(t *testing.T) {\n }\n \n func TestTestBuildFailureOutput(t *testing.T) {\n+\ttooSlow(t)\n+\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -2554,14 +2607,15 @@ func TestTestBuildFailureOutput(t *testing.T) {\n \n func TestCoverageFunc(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n \ttg.makeTempdir()\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n \n \ttg.run(\"test\", \"-outputdir=\"+tg.tempdir, \"-coverprofile=cover.out\", \"coverasm\")\n-\ttg.run(\"tool\", \"cover\", \"-func=\"+filepath.Join(tg.tempdir, \"cover.out\"))\n+\ttg.run(\"tool\", \"cover\", \"-func=\"+tg.path(\"cover.out\"))\n \ttg.grepStdout(`\\tg\\t*100.0%`, \"did not find g 100% covered\")\n \ttg.grepStdoutNot(`\\tf\\t*[0-9]`, \"reported coverage for assembly function f\")\n }\n@@ -2628,9 +2682,7 @@ func TestTestRaceInstall(t *testing.T) {\n \tif !canRace {\n \t\tt.Skip(\"no race detector\")\n \t}\n-\tif testing.Short() && testenv.Builder() == \"\" {\n-\t\tt.Skip(\"don't rebuild the standard library in short mode\")\n-\t}\n+\ttooSlow(t)\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -2668,6 +2720,7 @@ func main() {\n \n func TestCoverageWithCgo(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttooSlow(t)\n \tif !canCgo {\n \t\tt.Skip(\"skipping because cgo not enabled\")\n \t}\n@@ -2742,6 +2795,7 @@ func TestCgoShowsFullPathNames(t *testing.T) {\n }\n \n func TestCgoHandlesWlORIGIN(t *testing.T) {\n+\ttooSlow(t)\n \tif !canCgo {\n \t\tt.Skip(\"skipping because cgo not enabled\")\n \t}\n@@ -2759,6 +2813,7 @@ func TestCgoHandlesWlORIGIN(t *testing.T) {\n }\n \n func TestCgoPkgConfig(t *testing.T) {\n+\ttooSlow(t)\n \tif !canCgo {\n \t\tt.Skip(\"skipping because cgo not enabled\")\n \t}\n@@ -2810,6 +2865,7 @@ func main() {\n // even if it's really just updating the mtime on an existing up-to-date binary.\n func TestIssue6480(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no standard packages\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \t// TODO: tg.parallel()\n@@ -2945,6 +3001,8 @@ func TestIssue6844(t *testing.T) {\n }\n \n func TestBuildDashIInstallsDependencies(t *testing.T) {\n+\ttooSlow(t)\n+\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -3015,7 +3073,20 @@ func TestGoTestMainAsNormalTest(t *testing.T) {\n \ttg.grepBoth(okPattern, \"go test did not say ok\")\n }\n \n+func TestGoTestMainTwice(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOCACHE\", tg.tempdir)\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.run(\"test\", \"-v\", \"multimain\")\n+\tif strings.Count(tg.getStdout(), \"notwithstanding\") != 2 {\n+\t\tt.Fatal(\"tests did not run twice\")\n+\t}\n+}\n+\n func TestGoTestFlagsAfterPackage(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.run(\"test\", \"testdata/flag_test.go\", \"-v\", \"-args\", \"-v=7\") // Two distinct -v flags.\n@@ -3203,6 +3274,8 @@ func TestGoGetHTTPS404(t *testing.T) {\n // Test that you cannot import a main package.\n // See golang.org/issue/4210 and golang.org/issue/17475.\n func TestImportMain(t *testing.T) {\n+\ttooSlow(t)\n+\n \ttg := testgo(t)\n \ttg.parallel()\n \tdefer tg.cleanup()\n@@ -3291,6 +3364,8 @@ func TestImportMain(t *testing.T) {\n // accessed by a non-local import (found in a GOPATH/GOROOT).\n // See golang.org/issue/17475.\n func TestImportLocal(t *testing.T) {\n+\ttooSlow(t)\n+\n \ttg := testgo(t)\n \ttg.parallel()\n \tdefer tg.cleanup()\n@@ -3509,6 +3584,8 @@ func TestGoRunDirs(t *testing.T) {\n \n func TestGoInstallPkgdir(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no standard packages\")\n+\ttooSlow(t)\n+\n \ttg := testgo(t)\n \ttg.parallel()\n \tdefer tg.cleanup()\n@@ -3544,6 +3621,8 @@ func TestGoTestRaceInstallCgo(t *testing.T) {\n }\n \n func TestGoTestRaceFailures(t *testing.T) {\n+\ttooSlow(t)\n+\n \tif !canRace {\n \t\tt.Skip(\"skipping because race detector not supported\")\n \t}\n@@ -3753,6 +3832,7 @@ func TestIssue12096(t *testing.T) {\n \n func TestGoBuildOutput(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no standard packages\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \n@@ -3833,6 +3913,7 @@ func TestGoBuildARM(t *testing.T) {\n \n // For issue 14337.\n func TestParallelTest(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \ttg.parallel()\n \tdefer tg.cleanup()\n@@ -3852,6 +3933,7 @@ func TestParallelTest(t *testing.T) {\n }\n \n func TestCgoConsistentResults(t *testing.T) {\n+\ttooSlow(t)\n \tif !canCgo {\n \t\tt.Skip(\"skipping because cgo not enabled\")\n \t}\n@@ -3918,6 +4000,8 @@ func TestFatalInBenchmarkCauseNonZeroExitStatus(t *testing.T) {\n }\n \n func TestBinaryOnlyPackages(t *testing.T) {\n+\ttooSlow(t)\n+\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -4228,13 +4312,15 @@ func TestMatchesOnlySubtestParallelIsOK(t *testing.T) {\n \n // Issue 18845\n func TestBenchTimeout(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.run(\"test\", \"-bench\", \".\", \"-timeout\", \"750ms\", \"testdata/timeoutbench_test.go\")\n }\n \n // Issue 19394\n func TestWriteProfilesOnTimeout(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.tempDir(\"profiling\")\n@@ -4350,6 +4436,7 @@ func TestFFLAGS(t *testing.T) {\n // This is really a cmd/link issue but this is a convenient place to test it.\n func TestDuplicateGlobalAsmSymbols(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo does not use cmd/asm\")\n+\ttooSlow(t)\n \tif runtime.GOARCH != \"386\" && runtime.GOARCH != \"amd64\" {\n \t\tt.Skipf(\"skipping test on %s\", runtime.GOARCH)\n \t}\n@@ -4386,7 +4473,7 @@ func main() {\n }\n `)\n \ttg.setenv(\"GOPATH\", tg.path(\"go\"))\n-\texe := filepath.Join(tg.tempdir, \"p.exe\")\n+\texe := tg.path(\"p.exe\")\n \ttg.creatingTemp(exe)\n \ttg.run(\"build\", \"-o\", exe, \"p\")\n }\n@@ -4469,19 +4556,9 @@ func TestExecutableGOROOT(t *testing.T) {\n \tnewRoot := tg.path(\"new\")\n \n \tt.Run(\"RelocatedExe\", func(t *testing.T) {\n-\t\tt.Skip(\"TODO: skipping known broken test; see golang.org/issue/20284\")\n-\n-\t\t// Should fall back to default location in binary.\n-\t\t// No way to dig out other than look at source code.\n-\t\tdata, err := ioutil.ReadFile(\"../../runtime/internal/sys/zversion.go\")\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\t\tm := regexp.MustCompile(\"var DefaultGoroot = `([^`]+)`\").FindStringSubmatch(string(data))\n-\t\tif m == nil {\n-\t\t\tt.Fatal(\"cannot find DefaultGoroot in ../../runtime/internal/sys/zversion.go\")\n-\t\t}\n-\t\tcheck(t, newGoTool, m[1])\n+\t\t// Should fall back to default location in binary,\n+\t\t// which is the GOROOT we used when building testgo.exe.\n+\t\tcheck(t, newGoTool, testGOROOT)\n \t})\n \n \t// If the binary is sitting in a bin dir next to ../pkg/tool, that counts as a GOROOT,\n@@ -4506,9 +4583,7 @@ func TestExecutableGOROOT(t *testing.T) {\n \ttg.must(os.RemoveAll(tg.path(\"new/pkg\")))\n \n \t// Binaries built in the new tree should report the\n-\t// new tree when they call runtime.GOROOT().\n-\t// This is implemented by having the go tool pass a -X option\n-\t// to the linker setting runtime/internal/sys.DefaultGoroot.\n+\t// new tree when they call runtime.GOROOT.\n \tt.Run(\"RuntimeGoroot\", func(t *testing.T) {\n \t\t// Build a working GOROOT the easy way, with symlinks.\n \t\ttestenv.MustHaveSymlink(t)\n@@ -4584,6 +4659,7 @@ func main() {}`)\n }\n \n func TestCgoFlagContainsSpace(t *testing.T) {\n+\ttooSlow(t)\n \tif !canCgo {\n \t\tt.Skip(\"skipping because cgo not enabled\")\n \t}\n@@ -4607,6 +4683,7 @@ func TestCgoFlagContainsSpace(t *testing.T) {\n \n // Issue #20435.\n func TestGoTestRaceCoverModeFailures(t *testing.T) {\n+\ttooSlow(t)\n \tif !canRace {\n \t\tt.Skip(\"skipping because race detector not supported\")\n \t}\n@@ -4721,6 +4798,7 @@ func TestTestRegexps(t *testing.T) {\n }\n \n func TestListTests(t *testing.T) {\n+\ttooSlow(t)\n \tvar tg *testgoData\n \ttestWith := func(listName, expected string) func(*testing.T) {\n \t\treturn func(t *testing.T) {\n@@ -4738,6 +4816,10 @@ func TestListTests(t *testing.T) {\n }\n \n func TestBuildmodePIE(t *testing.T) {\n+\tif testing.Short() && testenv.Builder() == \"\" {\n+\t\tt.Skipf(\"skipping in -short mode on non-builder\")\n+\t}\n+\n \tplatform := fmt.Sprintf(\"%s/%s\", runtime.GOOS, runtime.GOARCH)\n \tswitch platform {\n \tcase \"linux/386\", \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/ppc64le\", \"linux/s390x\",\n@@ -4792,6 +4874,7 @@ func TestBuildmodePIE(t *testing.T) {\n }\n \n func TestExecBuildX(t *testing.T) {\n+\ttooSlow(t)\n \tif !canCgo {\n \t\tt.Skip(\"skipping because cgo not enabled\")\n \t}\n@@ -4803,12 +4886,14 @@ func TestExecBuildX(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \n+\ttg.setenv(\"GOCACHE\", \"off\")\n+\n \ttg.tempFile(\"main.go\", `package main; import \"C\"; func main() { print(\"hello\") }`)\n \tsrc := tg.path(\"main.go\")\n \tobj := tg.path(\"main\")\n \ttg.run(\"build\", \"-x\", \"-o\", obj, src)\n \tsh := tg.path(\"test.sh\")\n-\terr := ioutil.WriteFile(sh, []byte(tg.getStderr()), 0666)\n+\terr := ioutil.WriteFile(sh, []byte(\"set -e\\n\"+tg.getStderr()), 0666)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -4842,6 +4927,7 @@ func TestExecBuildX(t *testing.T) {\n }\n \n func TestParallelNumber(t *testing.T) {\n+\ttooSlow(t)\n \tfor _, n := range [...]string{\"-1\", \"0\"} {\n \t\tt.Run(n, func(t *testing.T) {\n \t\t\ttg := testgo(t)\n@@ -4931,6 +5017,7 @@ func TestGOTMPDIR(t *testing.T) {\n }\n \n func TestBuildCache(t *testing.T) {\n+\ttooSlow(t)\n \tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n \t\tt.Skip(\"GODEBUG gocacheverify\")\n \t}\n@@ -4991,6 +5078,8 @@ func TestCacheOutput(t *testing.T) {\n }\n \n func TestCacheCoverage(t *testing.T) {\n+\ttooSlow(t)\n+\n \tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n \t\tt.Skip(\"GODEBUG gocacheverify\")\n \t}\n@@ -5001,9 +5090,9 @@ func TestCacheCoverage(t *testing.T) {\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n \ttg.makeTempdir()\n \n-\ttg.setenv(\"GOCACHE\", filepath.Join(tg.tempdir, \"c1\"))\n-\ttg.run(\"test\", \"-cover\", \"strings\")\n-\ttg.run(\"test\", \"-cover\", \"math\", \"strings\")\n+\ttg.setenv(\"GOCACHE\", tg.path(\"c1\"))\n+\ttg.run(\"test\", \"-cover\", \"-short\", \"strings\")\n+\ttg.run(\"test\", \"-cover\", \"-short\", \"math\", \"strings\")\n }\n \n func TestIssue22588(t *testing.T) {\n@@ -5022,6 +5111,7 @@ func TestIssue22588(t *testing.T) {\n }\n \n func TestIssue22531(t *testing.T) {\n+\ttooSlow(t)\n \tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n \t\tt.Skip(\"GODEBUG gocacheverify\")\n \t}\n@@ -5030,12 +5120,12 @@ func TestIssue22531(t *testing.T) {\n \ttg.parallel()\n \ttg.makeTempdir()\n \ttg.setenv(\"GOPATH\", tg.tempdir)\n-\ttg.setenv(\"GOCACHE\", filepath.Join(tg.tempdir, \"cache\"))\n+\ttg.setenv(\"GOCACHE\", tg.path(\"cache\"))\n \ttg.tempFile(\"src/m/main.go\", \"package main /* c1 */; func main() {}\\n\")\n \ttg.run(\"install\", \"-x\", \"m\")\n \ttg.run(\"list\", \"-f\", \"{{.Stale}}\", \"m\")\n \ttg.grepStdout(\"false\", \"reported m as stale after install\")\n-\ttg.run(\"tool\", \"buildid\", filepath.Join(tg.tempdir, \"bin/m\"+exeSuffix))\n+\ttg.run(\"tool\", \"buildid\", tg.path(\"bin/m\"+exeSuffix))\n \n \t// The link action ID did not include the full main build ID,\n \t// even though the full main build ID is written into the\n@@ -5046,28 +5136,29 @@ func TestIssue22531(t *testing.T) {\n \ttg.run(\"install\", \"-x\", \"m\")\n \ttg.run(\"list\", \"-f\", \"{{.Stale}}\", \"m\")\n \ttg.grepStdout(\"false\", \"reported m as stale after reinstall\")\n-\ttg.run(\"tool\", \"buildid\", filepath.Join(tg.tempdir, \"bin/m\"+exeSuffix))\n+\ttg.run(\"tool\", \"buildid\", tg.path(\"bin/m\"+exeSuffix))\n }\n \n func TestIssue22596(t *testing.T) {\n+\ttooSlow(t)\n \tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n \t\tt.Skip(\"GODEBUG gocacheverify\")\n \t}\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n \ttg.makeTempdir()\n-\ttg.setenv(\"GOCACHE\", filepath.Join(tg.tempdir, \"cache\"))\n+\ttg.setenv(\"GOCACHE\", tg.path(\"cache\"))\n \ttg.tempFile(\"gopath1/src/p/p.go\", \"package p; func F(){}\\n\")\n \ttg.tempFile(\"gopath2/src/p/p.go\", \"package p; func F(){}\\n\")\n \n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.tempdir, \"gopath1\"))\n+\ttg.setenv(\"GOPATH\", tg.path(\"gopath1\"))\n \ttg.run(\"list\", \"-f={{.Target}}\", \"p\")\n \ttarget1 := strings.TrimSpace(tg.getStdout())\n \ttg.run(\"install\", \"p\")\n \ttg.wantNotStale(\"p\", \"\", \"p stale after install\")\n \n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.tempdir, \"gopath2\"))\n+\ttg.setenv(\"GOPATH\", tg.path(\"gopath2\"))\n \ttg.run(\"list\", \"-f={{.Target}}\", \"p\")\n \ttarget2 := strings.TrimSpace(tg.getStdout())\n \ttg.must(os.MkdirAll(filepath.Dir(target2), 0777))\n@@ -5078,6 +5169,8 @@ func TestIssue22596(t *testing.T) {\n }\n \n func TestTestCache(t *testing.T) {\n+\ttooSlow(t)\n+\n \tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n \t\tt.Skip(\"GODEBUG gocacheverify\")\n \t}\n@@ -5086,7 +5179,7 @@ func TestTestCache(t *testing.T) {\n \ttg.parallel()\n \ttg.makeTempdir()\n \ttg.setenv(\"GOPATH\", tg.tempdir)\n-\ttg.setenv(\"GOCACHE\", filepath.Join(tg.tempdir, \"cache\"))\n+\ttg.setenv(\"GOCACHE\", tg.path(\"cache\"))\n \n \tif runtime.Compiler != \"gccgo\" {\n \t\t// timeout here should not affect result being cached\n@@ -5191,7 +5284,124 @@ func TestTestCache(t *testing.T) {\n \t}\n }\n \n+func TestTestCacheInputs(t *testing.T) {\n+\ttooSlow(t)\n+\n+\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n+\t\tt.Skip(\"GODEBUG gocacheverify\")\n+\t}\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.setenv(\"GOCACHE\", tg.path(\"cache\"))\n+\n+\tdefer os.Remove(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"))\n+\tdefer os.Remove(filepath.Join(tg.pwd(), \"testdata/src/testcache/script.sh\"))\n+\ttg.must(ioutil.WriteFile(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"), []byte(\"x\"), 0644))\n+\told := time.Now().Add(-1 * time.Minute)\n+\ttg.must(os.Chtimes(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"), old, old))\n+\tinfo, err := os.Stat(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tt.Logf(\"file.txt: old=%v, info.ModTime=%v\", old, info.ModTime()) // help debug when Chtimes lies about succeeding\n+\ttg.setenv(\"TESTKEY\", \"x\")\n+\n+\ttg.must(ioutil.WriteFile(filepath.Join(tg.pwd(), \"testdata/src/testcache/script.sh\"), []byte(\"#!/bin/sh\\nexit 0\\n\"), 0755))\n+\ttg.must(os.Chtimes(filepath.Join(tg.pwd(), \"testdata/src/testcache/script.sh\"), old, old))\n+\n+\ttg.run(\"test\", \"testcache\")\n+\ttg.run(\"test\", \"testcache\")\n+\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n+\n+\ttg.setenv(\"TESTKEY\", \"y\")\n+\ttg.run(\"test\", \"testcache\")\n+\ttg.grepStdoutNot(`\\(cached\\)`, \"did not notice env var change\")\n+\ttg.run(\"test\", \"testcache\")\n+\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n+\n+\ttg.run(\"test\", \"testcache\", \"-run=FileSize\")\n+\ttg.run(\"test\", \"testcache\", \"-run=FileSize\")\n+\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n+\ttg.must(ioutil.WriteFile(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"), []byte(\"xxx\"), 0644))\n+\ttg.run(\"test\", \"testcache\", \"-run=FileSize\")\n+\ttg.grepStdoutNot(`\\(cached\\)`, \"did not notice file size change\")\n+\ttg.run(\"test\", \"testcache\", \"-run=FileSize\")\n+\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n+\n+\ttg.run(\"test\", \"testcache\", \"-run=Chdir\")\n+\ttg.run(\"test\", \"testcache\", \"-run=Chdir\")\n+\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n+\ttg.must(ioutil.WriteFile(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"), []byte(\"xxxxx\"), 0644))\n+\ttg.run(\"test\", \"testcache\", \"-run=Chdir\")\n+\ttg.grepStdoutNot(`\\(cached\\)`, \"did not notice file size change\")\n+\ttg.run(\"test\", \"testcache\", \"-run=Chdir\")\n+\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n+\n+\ttg.must(os.Chtimes(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"), old, old))\n+\ttg.run(\"test\", \"testcache\", \"-run=FileContent\")\n+\ttg.run(\"test\", \"testcache\", \"-run=FileContent\")\n+\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n+\ttg.must(ioutil.WriteFile(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"), []byte(\"yyy\"), 0644))\n+\told2 := old.Add(10 * time.Second)\n+\ttg.must(os.Chtimes(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"), old2, old2))\n+\ttg.run(\"test\", \"testcache\", \"-run=FileContent\")\n+\ttg.grepStdoutNot(`\\(cached\\)`, \"did not notice file content change\")\n+\ttg.run(\"test\", \"testcache\", \"-run=FileContent\")\n+\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n+\n+\ttg.run(\"test\", \"testcache\", \"-run=DirList\")\n+\ttg.run(\"test\", \"testcache\", \"-run=DirList\")\n+\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n+\ttg.must(os.Remove(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\")))\n+\ttg.run(\"test\", \"testcache\", \"-run=DirList\")\n+\ttg.grepStdoutNot(`\\(cached\\)`, \"did not notice directory change\")\n+\ttg.run(\"test\", \"testcache\", \"-run=DirList\")\n+\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n+\n+\ttg.tempFile(\"file.txt\", \"\")\n+\ttg.must(ioutil.WriteFile(filepath.Join(tg.pwd(), \"testdata/src/testcache/testcachetmp_test.go\"), []byte(`package testcache\n+\n+\t\timport (\n+\t\t\t\"os\"\n+\t\t\t\"testing\"\n+\t\t)\n+\n+\t\tfunc TestExternalFile(t *testing.T) {\n+\t\t\tos.Open(`+fmt.Sprintf(\"%q\", tg.path(\"file.txt\"))+`)\n+\t\t\t_, err := os.Stat(`+fmt.Sprintf(\"%q\", tg.path(\"file.txt\"))+`)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t}\n+\t`), 0666))\n+\tdefer os.Remove(filepath.Join(tg.pwd(), \"testdata/src/testcache/testcachetmp_test.go\"))\n+\ttg.run(\"test\", \"testcache\", \"-run=ExternalFile\")\n+\ttg.run(\"test\", \"testcache\", \"-run=ExternalFile\")\n+\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n+\ttg.must(os.Remove(filepath.Join(tg.tempdir, \"file.txt\")))\n+\ttg.run(\"test\", \"testcache\", \"-run=ExternalFile\")\n+\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n+\n+\tswitch runtime.GOOS {\n+\tcase \"nacl\", \"plan9\", \"windows\":\n+\t\t// no shell scripts\n+\tdefault:\n+\t\ttg.run(\"test\", \"testcache\", \"-run=Exec\")\n+\t\ttg.run(\"test\", \"testcache\", \"-run=Exec\")\n+\t\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n+\t\ttg.must(os.Chtimes(filepath.Join(tg.pwd(), \"testdata/src/testcache/script.sh\"), old2, old2))\n+\t\ttg.run(\"test\", \"testcache\", \"-run=Exec\")\n+\t\ttg.grepStdoutNot(`\\(cached\\)`, \"did not notice script change\")\n+\t\ttg.run(\"test\", \"testcache\", \"-run=Exec\")\n+\t\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n+\t}\n+}\n+\n func TestTestVet(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -5204,9 +5414,9 @@ func TestTestVet(t *testing.T) {\n \t\t}\n \t`)\n \n-\ttg.runFail(\"test\", filepath.Join(tg.tempdir, \"p1_test.go\"))\n+\ttg.runFail(\"test\", tg.path(\"p1_test.go\"))\n \ttg.grepStderr(`Logf format %d`, \"did not diagnose bad Logf\")\n-\ttg.run(\"test\", \"-vet=off\", filepath.Join(tg.tempdir, \"p1_test.go\"))\n+\ttg.run(\"test\", \"-vet=off\", tg.path(\"p1_test.go\"))\n \ttg.grepStdout(`^ok`, \"did not print test summary\")\n \n \ttg.tempFile(\"p1.go\", `\n@@ -5216,19 +5426,24 @@ func TestTestVet(t *testing.T) {\n \t\t\tfmt.Printf(\"%d\") // oops\n \t\t}\n \t`)\n-\ttg.runFail(\"test\", filepath.Join(tg.tempdir, \"p1.go\"))\n+\ttg.runFail(\"test\", tg.path(\"p1.go\"))\n \ttg.grepStderr(`Printf format %d`, \"did not diagnose bad Printf\")\n-\ttg.run(\"test\", \"-x\", \"-vet=shift\", filepath.Join(tg.tempdir, \"p1.go\"))\n+\ttg.run(\"test\", \"-x\", \"-vet=shift\", tg.path(\"p1.go\"))\n \ttg.grepStderr(`[\\\\/]vet.*-shift`, \"did not run vet with -shift\")\n \ttg.grepStdout(`\\[no test files\\]`, \"did not print test summary\")\n-\ttg.run(\"test\", \"-vet=off\", filepath.Join(tg.tempdir, \"p1.go\"))\n+\ttg.run(\"test\", \"-vet=off\", tg.path(\"p1.go\"))\n \ttg.grepStdout(`\\[no test files\\]`, \"did not print test summary\")\n \n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n \ttg.run(\"test\", \"vetcycle\") // must not fail; #22890\n+\n+\ttg.runFail(\"test\", \"vetfail/...\")\n+\ttg.grepStderr(`Printf format %d`, \"did not diagnose bad Printf\")\n+\ttg.grepStdout(`ok\\s+vetfail/p2`, \"did not run vetfail/p2\")\n }\n \n func TestInstallDeps(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -5276,6 +5491,7 @@ func TestFmtLoadErrors(t *testing.T) {\n }\n \n func TestRelativePkgdir(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n@@ -5292,26 +5508,28 @@ func TestGcflagsPatterns(t *testing.T) {\n \ttg.setenv(\"GOPATH\", \"\")\n \ttg.setenv(\"GOCACHE\", \"off\")\n \n-\ttg.run(\"build\", \"-v\", \"-gcflags= \\t\\r\\n -e\", \"fmt\")\n-\ttg.grepStderr(\"fmt\", \"did not rebuild fmt\")\n-\ttg.grepStderrNot(\"reflect\", \"incorrectly rebuilt reflect\")\n+\ttg.run(\"build\", \"-n\", \"-v\", \"-gcflags= \\t\\r\\n -e\", \"fmt\")\n+\ttg.grepStderr(\"^# fmt\", \"did not rebuild fmt\")\n+\ttg.grepStderrNot(\"^# reflect\", \"incorrectly rebuilt reflect\")\n \n-\ttg.run(\"build\", \"-v\", \"-gcflags=-e\", \"fmt\", \"reflect\")\n-\ttg.grepStderr(\"fmt\", \"did not rebuild fmt\")\n-\ttg.grepStderr(\"reflect\", \"did not rebuild reflect\")\n-\ttg.grepStderrNot(\"runtime\", \"incorrectly rebuilt runtime\")\n+\ttg.run(\"build\", \"-n\", \"-v\", \"-gcflags=-e\", \"fmt\", \"reflect\")\n+\ttg.grepStderr(\"^# fmt\", \"did not rebuild fmt\")\n+\ttg.grepStderr(\"^# reflect\", \"did not rebuild reflect\")\n+\ttg.grepStderrNot(\"^# runtime\", \"incorrectly rebuilt runtime\")\n \n-\ttg.run(\"build\", \"-x\", \"-v\", \"-gcflags= \\t\\r\\n reflect \\t\\r\\n = \\t\\r\\n -N\", \"fmt\")\n-\ttg.grepStderr(\"fmt\", \"did not rebuild fmt\")\n-\ttg.grepStderr(\"reflect\", \"did not rebuild reflect\")\n+\ttg.run(\"build\", \"-n\", \"-x\", \"-v\", \"-gcflags= \\t\\r\\n reflect \\t\\r\\n = \\t\\r\\n -N\", \"fmt\")\n+\ttg.grepStderr(\"^# fmt\", \"did not rebuild fmt\")\n+\ttg.grepStderr(\"^# reflect\", \"did not rebuild reflect\")\n \ttg.grepStderr(\"compile.* -N .*-p reflect\", \"did not build reflect with -N flag\")\n \ttg.grepStderrNot(\"compile.* -N .*-p fmt\", \"incorrectly built fmt with -N flag\")\n \n-\ttg.run(\"test\", \"-c\", \"-n\", \"-gcflags=-N\", \"strings\")\n-\ttg.grepStderr(\"compile.* -N .*compare_test.go\", \"did not build strings_test package with -N flag\")\n+\ttg.run(\"test\", \"-c\", \"-n\", \"-gcflags=-N\", \"-ldflags=-X=x.y=z\", \"strings\")\n+\ttg.grepStderr(\"compile.* -N .*compare_test.go\", \"did not compile strings_test package with -N flag\")\n+\ttg.grepStderr(\"link.* -X=x.y=z\", \"did not link strings.test binary with -X flag\")\n \n-\ttg.run(\"test\", \"-c\", \"-n\", \"-gcflags=strings=-N\", \"strings\")\n-\ttg.grepStderr(\"compile.* -N .*compare_test.go\", \"did not build strings_test package with -N flag\")\n+\ttg.run(\"test\", \"-c\", \"-n\", \"-gcflags=strings=-N\", \"-ldflags=strings=-X=x.y=z\", \"strings\")\n+\ttg.grepStderr(\"compile.* -N .*compare_test.go\", \"did not compile strings_test package with -N flag\")\n+\ttg.grepStderr(\"link.* -X=x.y=z\", \"did not link strings.test binary with -X flag\")\n }\n \n func TestGoTestMinusN(t *testing.T) {\n@@ -5324,6 +5542,8 @@ func TestGoTestMinusN(t *testing.T) {\n \n func TestGoTestJSON(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo does not have standard packages\")\n+\ttooSlow(t)\n+\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -5344,18 +5564,22 @@ func TestGoTestJSON(t *testing.T) {\n \ttg.grepStdout(`\"Action\":\"output\",\"Package\":\"skipper\",\"Test\":\"Test\",\"Output\":\"--- SKIP:`, \"did not see SKIP output\")\n \ttg.grepStdout(`\"Action\":\"skip\",\"Package\":\"skipper\",\"Test\":\"Test\"`, \"did not see skip result for Test\")\n \n+\ttg.run(\"test\", \"-json\", \"-short\", \"-v\", \"errors\")\n+\ttg.grepStdout(`\"Action\":\"output\",\"Package\":\"errors\",\"Output\":\".*\\(cached\\)`, \"did not see no cached output\")\n+\n \ttg.run(\"test\", \"-json\", \"-bench=NONE\", \"-short\", \"-v\", \"errors\")\n \ttg.grepStdout(`\"Package\":\"errors\"`, \"did not see JSON output\")\n \ttg.grepStdout(`\"Action\":\"run\"`, \"did not see JSON output\")\n \n-\ttg.run(\"test\", \"-o\", filepath.Join(tg.tempdir, \"errors.test.exe\"), \"-c\", \"errors\")\n-\ttg.run(\"tool\", \"test2json\", \"-p\", \"errors\", filepath.Join(tg.tempdir, \"errors.test.exe\"), \"-test.v\", \"-test.short\")\n+\ttg.run(\"test\", \"-o\", tg.path(\"errors.test.exe\"), \"-c\", \"errors\")\n+\ttg.run(\"tool\", \"test2json\", \"-p\", \"errors\", tg.path(\"errors.test.exe\"), \"-test.v\", \"-test.short\")\n \ttg.grepStdout(`\"Package\":\"errors\"`, \"did not see JSON output\")\n \ttg.grepStdout(`\"Action\":\"run\"`, \"did not see JSON output\")\n \ttg.grepStdout(`\\{\"Action\":\"pass\",\"Package\":\"errors\"\\}`, \"did not see final pass\")\n }\n \n func TestFailFast(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \n@@ -5398,3 +5622,72 @@ func TestFailFast(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+// Issue 22986.\n+func TestImportPath(t *testing.T) {\n+\ttooSlow(t)\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\n+\ttg.tempFile(\"src/a/a.go\", `\n+package main\n+\n+import (\n+\t\"log\"\n+\tp \"a/p-1.0\"\n+)\n+\n+func main() {\n+\tif !p.V {\n+\t\tlog.Fatal(\"false\")\n+\t}\n+}`)\n+\n+\ttg.tempFile(\"src/a/a_test.go\", `\n+package main_test\n+\n+import (\n+\tp \"a/p-1.0\"\n+\t\"testing\"\n+)\n+\n+func TestV(t *testing.T) {\n+\tif !p.V {\n+\t\tt.Fatal(\"false\")\n+\t}\n+}`)\n+\n+\ttg.tempFile(\"src/a/p-1.0/p.go\", `\n+package p\n+\n+var V = true\n+\n+func init() {}\n+`)\n+\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"build\", \"-o\", tg.path(\"a.exe\"), \"a\")\n+\ttg.run(\"test\", \"a\")\n+}\n+\n+// Issue 23150.\n+func TestCpuprofileTwice(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"prof/src/x/x_test.go\", `\n+\t\tpackage x_test\n+\t\timport (\n+\t\t\t\"testing\"\n+\t\t\t\"time\"\n+\t\t)\n+\t\tfunc TestSleep(t *testing.T) { time.Sleep(10 * time.Millisecond) }`)\n+\ttg.setenv(\"GOPATH\", tg.path(\"prof\"))\n+\tbin := tg.path(\"x.test\")\n+\tout := tg.path(\"cpu.out\")\n+\ttg.run(\"test\", \"-o=\"+bin, \"-cpuprofile=\"+out, \"x\")\n+\ttg.must(os.Remove(out))\n+\ttg.run(\"test\", \"-o=\"+bin, \"-cpuprofile=\"+out, \"x\")\n+\ttg.mustExist(out)\n+}"}, {"sha": "edb58826f170483cae85c2895e6ce3aa567b1bde", "filename": "libgo/go/cmd/go/internal/cache/cache.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -97,6 +97,9 @@ const (\n // GODEBUG=gocacheverify=1.\n var verify = false\n \n+// DebugTest is set when GODEBUG=gocachetest=1 is in the environment.\n+var DebugTest = false\n+\n func init() { initEnv() }\n \n func initEnv() {\n@@ -110,6 +113,9 @@ func initEnv() {\n \t\tif f == \"gocachehash=1\" {\n \t\t\tdebugHash = true\n \t\t}\n+\t\tif f == \"gocachetest=1\" {\n+\t\t\tDebugTest = true\n+\t\t}\n \t}\n }\n "}, {"sha": "8a5c12c5f59ac06e544ab33b59588be5998a2200", "filename": "libgo/go/cmd/go/internal/cache/default.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -68,6 +68,9 @@ func DefaultDir() string {\n \tswitch runtime.GOOS {\n \tcase \"windows\":\n \t\tdir = os.Getenv(\"LocalAppData\")\n+\t\tif dir == \"\" {\n+\t\t\treturn \"off\"\n+\t\t}\n \n \tcase \"darwin\":\n \t\tdir = os.Getenv(\"HOME\")"}, {"sha": "bfdd67e842d3aaa7b9cd42764c33f7bc5e9b6aa9", "filename": "libgo/go/cmd/go/internal/cfg/cfg.go", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -76,11 +76,12 @@ func init() {\n }\n \n var (\n-\tGOROOT    = findGOROOT()\n-\tGOBIN     = os.Getenv(\"GOBIN\")\n-\tGOROOTbin = filepath.Join(GOROOT, \"bin\")\n-\tGOROOTpkg = filepath.Join(GOROOT, \"pkg\")\n-\tGOROOTsrc = filepath.Join(GOROOT, \"src\")\n+\tGOROOT       = findGOROOT()\n+\tGOBIN        = os.Getenv(\"GOBIN\")\n+\tGOROOTbin    = filepath.Join(GOROOT, \"bin\")\n+\tGOROOTpkg    = filepath.Join(GOROOT, \"pkg\")\n+\tGOROOTsrc    = filepath.Join(GOROOT, \"src\")\n+\tGOROOT_FINAL = findGOROOT_FINAL()\n \n \t// Used in envcmd.MkEnv and build ID computations.\n \tGOARM  = fmt.Sprint(objabi.GOARM)\n@@ -134,6 +135,14 @@ func findGOROOT() string {\n \treturn def\n }\n \n+func findGOROOT_FINAL() string {\n+\tdef := GOROOT\n+\tif env := os.Getenv(\"GOROOT_FINAL\"); env != \"\" {\n+\t\tdef = filepath.Clean(env)\n+\t}\n+\treturn def\n+}\n+\n // isSameDir reports whether dir1 and dir2 are the same directory.\n func isSameDir(dir1, dir2 string) bool {\n \tif dir1 == dir2 {"}, {"sha": "733116eca04d83d8c5d1267d6931c1e33c32a67b", "filename": "libgo/go/cmd/go/internal/get/get.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -22,7 +22,7 @@ import (\n )\n \n var CmdGet = &base.Command{\n-\tUsageLine: \"get [-d] [-f] [-fix] [-insecure] [-t] [-u] [build flags] [packages]\",\n+\tUsageLine: \"get [-d] [-f] [-fix] [-insecure] [-t] [-u] [-v] [build flags] [packages]\",\n \tShort:     \"download and install packages and dependencies\",\n \tLong: `\n Get downloads the packages named by the import paths, along with their"}, {"sha": "d8dd66426b429210b4b39d288686f115063e8838", "filename": "libgo/go/cmd/go/internal/load/icfg.go", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ficfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ficfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ficfg.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -19,7 +19,8 @@ var DebugDeprecatedImportcfg debugDeprecatedImportcfgFlag\n \n type debugDeprecatedImportcfgFlag struct {\n \tenabled bool\n-\tpkgs    map[string]*debugDeprecatedImportcfgPkg\n+\tImport  map[string]string\n+\tPkg     map[string]*debugDeprecatedImportcfgPkg\n }\n \n type debugDeprecatedImportcfgPkg struct {\n@@ -49,27 +50,29 @@ func (f *debugDeprecatedImportcfgFlag) Set(x string) error {\n \t}\n \tdata = data[len(debugDeprecatedImportcfgMagic):]\n \n-\tf.pkgs = nil\n-\tif err := json.Unmarshal(data, &f.pkgs); err != nil {\n+\tf.Import = nil\n+\tf.Pkg = nil\n+\tif err := json.Unmarshal(data, &f); err != nil {\n \t\treturn errImportcfgSyntax\n \t}\n \tf.enabled = true\n \treturn nil\n }\n \n func (f *debugDeprecatedImportcfgFlag) lookup(parent *Package, path string) (dir, newPath string) {\n-\tif parent == nil {\n-\t\tif p1 := f.pkgs[path]; p1 != nil {\n-\t\t\treturn p1.Dir, path\n-\t\t}\n-\t\treturn \"\", \"\"\n+\tnewPath = path\n+\tif p := f.Import[path]; p != \"\" {\n+\t\tnewPath = p\n \t}\n-\tif p1 := f.pkgs[parent.ImportPath]; p1 != nil {\n-\t\tif newPath := p1.Import[path]; newPath != \"\" {\n-\t\t\tif p2 := f.pkgs[newPath]; p2 != nil {\n-\t\t\t\treturn p2.Dir, newPath\n+\tif parent != nil {\n+\t\tif p1 := f.Pkg[parent.ImportPath]; p1 != nil {\n+\t\t\tif p := p1.Import[path]; p != \"\" {\n+\t\t\t\tnewPath = p\n \t\t\t}\n \t\t}\n \t}\n+\tif p2 := f.Pkg[newPath]; p2 != nil {\n+\t\treturn p2.Dir, newPath\n+\t}\n \treturn \"\", \"\"\n }"}, {"sha": "45a9e7b242be1fc73cad3e76063797a678b188f0", "filename": "libgo/go/cmd/go/internal/load/path.go", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpath.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -56,25 +56,3 @@ func expandPath(p string) string {\n \t}\n \treturn p\n }\n-\n-// hasFilePathPrefix reports whether the filesystem path s begins with the\n-// elements in prefix.\n-func hasFilePathPrefix(s, prefix string) bool {\n-\tsv := strings.ToUpper(filepath.VolumeName(s))\n-\tpv := strings.ToUpper(filepath.VolumeName(prefix))\n-\ts = s[len(sv):]\n-\tprefix = prefix[len(pv):]\n-\tswitch {\n-\tdefault:\n-\t\treturn false\n-\tcase sv != pv:\n-\t\treturn false\n-\tcase len(s) == len(prefix):\n-\t\treturn s == prefix\n-\tcase len(s) > len(prefix):\n-\t\tif prefix != \"\" && prefix[len(prefix)-1] == filepath.Separator {\n-\t\t\treturn strings.HasPrefix(s, prefix)\n-\t\t}\n-\t\treturn s[len(prefix)] == filepath.Separator && s[:len(prefix)] == prefix\n-\t}\n-}"}, {"sha": "20e905c6b45512c43c0180370ec954f115a00c05", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -524,13 +524,13 @@ func VendoredImportPath(parent *Package, path string) (found string) {\n \n \tdir := filepath.Clean(parent.Dir)\n \troot := filepath.Join(parent.Root, \"src\")\n-\tif !hasFilePathPrefix(dir, root) || parent.ImportPath != \"command-line-arguments\" && filepath.Join(root, parent.ImportPath) != dir {\n+\tif !str.HasFilePathPrefix(dir, root) || parent.ImportPath != \"command-line-arguments\" && filepath.Join(root, parent.ImportPath) != dir {\n \t\t// Look for symlinks before reporting error.\n \t\tdir = expandPath(dir)\n \t\troot = expandPath(root)\n \t}\n \n-\tif !hasFilePathPrefix(dir, root) || len(dir) <= len(root) || dir[len(root)] != filepath.Separator || parent.ImportPath != \"command-line-arguments\" && !parent.Internal.Local && filepath.Join(root, parent.ImportPath) != dir {\n+\tif !str.HasFilePathPrefix(dir, root) || len(dir) <= len(root) || dir[len(root)] != filepath.Separator || parent.ImportPath != \"command-line-arguments\" && !parent.Internal.Local && filepath.Join(root, parent.ImportPath) != dir {\n \t\tbase.Fatalf(\"unexpected directory layout:\\n\"+\n \t\t\t\"\timport path: %s\\n\"+\n \t\t\t\"\troot: %s\\n\"+\n@@ -674,14 +674,14 @@ func disallowInternal(srcDir string, p *Package, stk *ImportStack) *Package {\n \t\ti-- // rewind over slash in \".../internal\"\n \t}\n \tparent := p.Dir[:i+len(p.Dir)-len(p.ImportPath)]\n-\tif hasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {\n+\tif str.HasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {\n \t\treturn p\n \t}\n \n \t// Look for symlinks before reporting error.\n \tsrcDir = expandPath(srcDir)\n \tparent = expandPath(parent)\n-\tif hasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {\n+\tif str.HasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {\n \t\treturn p\n \t}\n \n@@ -774,14 +774,14 @@ func disallowVendorVisibility(srcDir string, p *Package, stk *ImportStack) *Pack\n \t\treturn p\n \t}\n \tparent := p.Dir[:truncateTo]\n-\tif hasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {\n+\tif str.HasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {\n \t\treturn p\n \t}\n \n \t// Look for symlinks before reporting error.\n \tsrcDir = expandPath(srcDir)\n \tparent = expandPath(parent)\n-\tif hasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {\n+\tif str.HasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {\n \t\treturn p\n \t}\n "}, {"sha": "84ca9d581e97820e27ded6c05d9897eeff45a9fb", "filename": "libgo/go/cmd/go/internal/str/path.go", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package str\n+\n+import (\n+\t\"path/filepath\"\n+\t\"strings\"\n+)\n+\n+// HasFilePathPrefix reports whether the filesystem path s begins with the\n+// elements in prefix.\n+func HasFilePathPrefix(s, prefix string) bool {\n+\tsv := strings.ToUpper(filepath.VolumeName(s))\n+\tpv := strings.ToUpper(filepath.VolumeName(prefix))\n+\ts = s[len(sv):]\n+\tprefix = prefix[len(pv):]\n+\tswitch {\n+\tdefault:\n+\t\treturn false\n+\tcase sv != pv:\n+\t\treturn false\n+\tcase len(s) == len(prefix):\n+\t\treturn s == prefix\n+\tcase len(s) > len(prefix):\n+\t\tif prefix != \"\" && prefix[len(prefix)-1] == filepath.Separator {\n+\t\t\treturn strings.HasPrefix(s, prefix)\n+\t\t}\n+\t\treturn s[len(prefix)] == filepath.Separator && s[:len(prefix)] == prefix\n+\t}\n+}"}, {"sha": "b82fdd5e3c8923fff421e4e34a0dc765eb328d38", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 356, "deletions": 80, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -406,14 +406,14 @@ var HelpTestfunc = &base.Command{\n The 'go test' command expects to find test, benchmark, and example functions\n in the \"*_test.go\" files corresponding to the package under test.\n \n-A test function is one named TestXXX (where XXX is any alphanumeric string\n-not starting with a lower case letter) and should have the signature,\n+A test function is one named TestXxx (where Xxx does not start with a\n+lower case letter) and should have the signature,\n \n-\tfunc TestXXX(t *testing.T) { ... }\n+\tfunc TestXxx(t *testing.T) { ... }\n \n-A benchmark function is one named BenchmarkXXX and should have the signature,\n+A benchmark function is one named BenchmarkXxx and should have the signature,\n \n-\tfunc BenchmarkXXX(b *testing.B) { ... }\n+\tfunc BenchmarkXxx(b *testing.B) { ... }\n \n An example function is similar to a test function but, instead of using\n *testing.T to report success or failure, prints output to os.Stdout.\n@@ -424,8 +424,8 @@ comment, however the order of the lines is ignored. An example with no such\n comment is compiled but not executed. An example with no text after\n \"Output:\" is compiled, executed, and expected to produce no output.\n \n-Godoc displays the body of ExampleXXX to demonstrate the use\n-of the function, constant, or variable XXX. An example of a method M with\n+Godoc displays the body of ExampleXxx to demonstrate the use\n+of the function, constant, or variable Xxx. An example of a method M with\n receiver type T or *T is named ExampleT_M. There may be multiple examples\n for a given function, constant, or variable, distinguished by a trailing _xxx,\n where xxx is a suffix not beginning with an upper case letter.\n@@ -938,6 +938,11 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \t\tInternal: load.PackageInternal{\n \t\t\tBuild:     &build.Package{Name: \"main\"},\n \t\t\tOmitDebug: !testC && !testNeedBinary,\n+\n+\t\t\tAsmflags:   p.Internal.Asmflags,\n+\t\t\tGcflags:    p.Internal.Gcflags,\n+\t\t\tLdflags:    p.Internal.Ldflags,\n+\t\t\tGccgoflags: p.Internal.Gccgoflags,\n \t\t},\n \t}\n \n@@ -1010,7 +1015,7 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \t\t// This will cause extra compilation, so for now we only do it\n \t\t// when testCover is set. The conditions are more general, though,\n \t\t// and we may find that we need to do it always in the future.\n-\t\trecompileForTest(pmain, p, ptest)\n+\t\trecompileForTest(pmain, p, ptest, pxtest)\n \t}\n \n \tfor _, cp := range pmain.Internal.Imports {\n@@ -1064,8 +1069,7 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \t\t}\n \t}\n \tbuildAction = a\n-\tvar installAction *work.Action\n-\n+\tvar installAction, cleanAction *work.Action\n \tif testC || testNeedBinary {\n \t\t// -c or profiling flag: create action to copy binary to ./test.out.\n \t\ttarget := filepath.Join(base.Cwd, testBinary+cfg.ExeSuffix)\n@@ -1083,7 +1087,6 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \t\t\tPackage: pmain,\n \t\t\tTarget:  target,\n \t\t}\n-\t\tbuildAction = installAction\n \t\trunAction = installAction // make sure runAction != nil even if not running test\n \t}\n \tif testC {\n@@ -1096,7 +1099,7 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \t\t\tFunc:       c.builderRunTest,\n \t\t\tDeps:       []*work.Action{buildAction},\n \t\t\tPackage:    p,\n-\t\t\tIgnoreFail: true,\n+\t\t\tIgnoreFail: true, // run (prepare output) even if build failed\n \t\t\tTryCache:   c.tryCache,\n \t\t\tObjdir:     testDir,\n \t\t}\n@@ -1106,18 +1109,28 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \t\tif pxtest != nil {\n \t\t\taddTestVet(b, pxtest, runAction, installAction)\n \t\t}\n-\t\tcleanAction := &work.Action{\n-\t\t\tMode:    \"test clean\",\n-\t\t\tFunc:    builderCleanTest,\n-\t\t\tDeps:    []*work.Action{runAction},\n-\t\t\tPackage: p,\n-\t\t\tObjdir:  testDir,\n+\t\tcleanAction = &work.Action{\n+\t\t\tMode:       \"test clean\",\n+\t\t\tFunc:       builderCleanTest,\n+\t\t\tDeps:       []*work.Action{runAction},\n+\t\t\tPackage:    p,\n+\t\t\tIgnoreFail: true, // clean even if test failed\n+\t\t\tObjdir:     testDir,\n \t\t}\n \t\tprintAction = &work.Action{\n-\t\t\tMode:    \"test print\",\n-\t\t\tFunc:    builderPrintTest,\n-\t\t\tDeps:    []*work.Action{cleanAction},\n-\t\t\tPackage: p,\n+\t\t\tMode:       \"test print\",\n+\t\t\tFunc:       builderPrintTest,\n+\t\t\tDeps:       []*work.Action{cleanAction},\n+\t\t\tPackage:    p,\n+\t\t\tIgnoreFail: true, // print even if test failed\n+\t\t}\n+\t}\n+\tif installAction != nil {\n+\t\tif runAction != installAction {\n+\t\t\tinstallAction.Deps = append(installAction.Deps, runAction)\n+\t\t}\n+\t\tif cleanAction != nil {\n+\t\t\tcleanAction.Deps = append(cleanAction.Deps, installAction)\n \t\t}\n \t}\n \n@@ -1158,14 +1171,17 @@ Search:\n \treturn stk\n }\n \n-func recompileForTest(pmain, preal, ptest *load.Package) {\n+func recompileForTest(pmain, preal, ptest, pxtest *load.Package) {\n \t// The \"test copy\" of preal is ptest.\n \t// For each package that depends on preal, make a \"test copy\"\n \t// that depends on ptest. And so on, up the dependency tree.\n \ttestCopy := map[*load.Package]*load.Package{preal: ptest}\n \tfor _, p := range load.PackageList([]*load.Package{pmain}) {\n+\t\tif p == preal {\n+\t\t\tcontinue\n+\t\t}\n \t\t// Copy on write.\n-\t\tdidSplit := false\n+\t\tdidSplit := p == pmain || p == pxtest\n \t\tsplit := func() {\n \t\t\tif didSplit {\n \t\t\t\treturn\n@@ -1245,23 +1261,6 @@ func (lockedStdout) Write(b []byte) (int, error) {\n \n // builderRunTest is the action for running a test binary.\n func (c *runCache) builderRunTest(b *work.Builder, a *work.Action) error {\n-\tif c.buf == nil {\n-\t\t// We did not find a cached result using the link step action ID,\n-\t\t// so we ran the link step. Try again now with the link output\n-\t\t// content ID. The attempt using the action ID makes sure that\n-\t\t// if the link inputs don't change, we reuse the cached test\n-\t\t// result without even rerunning the linker. The attempt using\n-\t\t// the link output (test binary) content ID makes sure that if\n-\t\t// we have different link inputs but the same final binary,\n-\t\t// we still reuse the cached test result.\n-\t\t// c.saveOutput will store the result under both IDs.\n-\t\tc.tryCacheWithID(b, a, a.Deps[0].BuildContentID())\n-\t}\n-\tif c.buf != nil {\n-\t\ta.TestOutput = c.buf\n-\t\treturn nil\n-\t}\n-\n \tif a.Failed {\n \t\t// We were unable to build the binary.\n \t\ta.Failed = false\n@@ -1271,39 +1270,19 @@ func (c *runCache) builderRunTest(b *work.Builder, a *work.Action) error {\n \t\treturn nil\n \t}\n \n-\targs := str.StringList(work.FindExecCmd(), a.Deps[0].Target, testArgs)\n-\n-\tif testCoverProfile != \"\" {\n-\t\t// Write coverage to temporary profile, for merging later.\n-\t\tfor i, arg := range args {\n-\t\t\tif strings.HasPrefix(arg, \"-test.coverprofile=\") {\n-\t\t\t\targs[i] = \"-test.coverprofile=\" + a.Objdir + \"_cover_.out\"\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif cfg.BuildN || cfg.BuildX {\n-\t\tb.Showcmd(\"\", \"%s\", strings.Join(args, \" \"))\n-\t\tif cfg.BuildN {\n-\t\t\treturn nil\n-\t\t}\n-\t}\n-\n-\tcmd := exec.Command(args[0], args[1:]...)\n-\tcmd.Dir = a.Package.Dir\n-\tcmd.Env = base.EnvForDir(cmd.Dir, cfg.OrigEnv)\n-\tvar buf bytes.Buffer\n \tvar stdout io.Writer = os.Stdout\n \tif testJSON {\n \t\tjson := test2json.NewConverter(lockedStdout{}, a.Package.ImportPath, test2json.Timestamp)\n \t\tdefer json.Close()\n \t\tstdout = json\n \t}\n+\n+\tvar buf bytes.Buffer\n \tif len(pkgArgs) == 0 || testBench {\n \t\t// Stream test output (no buffering) when no package has\n \t\t// been given on the command line (implicit current directory)\n \t\t// or when benchmarking.\n-\t\tcmd.Stdout = stdout\n+\t\t// No change to stdout.\n \t} else {\n \t\t// If we're only running a single package under test or if parallelism is\n \t\t// set to 1, and if we're displaying all output (testShowPass), we can\n@@ -1322,12 +1301,61 @@ func (c *runCache) builderRunTest(b *work.Builder, a *work.Action) error {\n \t\tif testShowPass && (len(pkgs) == 1 || cfg.BuildP == 1) || testJSON {\n \t\t\t// Write both to stdout and buf, for possible saving\n \t\t\t// to cache, and for looking for the \"no tests to run\" message.\n-\t\t\tcmd.Stdout = io.MultiWriter(stdout, &buf)\n+\t\t\tstdout = io.MultiWriter(stdout, &buf)\n \t\t} else {\n-\t\t\tcmd.Stdout = &buf\n+\t\t\tstdout = &buf\n \t\t}\n \t}\n-\tcmd.Stderr = cmd.Stdout\n+\n+\tif c.buf == nil {\n+\t\t// We did not find a cached result using the link step action ID,\n+\t\t// so we ran the link step. Try again now with the link output\n+\t\t// content ID. The attempt using the action ID makes sure that\n+\t\t// if the link inputs don't change, we reuse the cached test\n+\t\t// result without even rerunning the linker. The attempt using\n+\t\t// the link output (test binary) content ID makes sure that if\n+\t\t// we have different link inputs but the same final binary,\n+\t\t// we still reuse the cached test result.\n+\t\t// c.saveOutput will store the result under both IDs.\n+\t\tc.tryCacheWithID(b, a, a.Deps[0].BuildContentID())\n+\t}\n+\tif c.buf != nil {\n+\t\tif stdout != &buf {\n+\t\t\tstdout.Write(c.buf.Bytes())\n+\t\t\tc.buf.Reset()\n+\t\t}\n+\t\ta.TestOutput = c.buf\n+\t\treturn nil\n+\t}\n+\n+\texecCmd := work.FindExecCmd()\n+\ttestlogArg := []string{}\n+\tif !c.disableCache && len(execCmd) == 0 {\n+\t\ttestlogArg = []string{\"-test.testlogfile=\" + a.Objdir + \"testlog.txt\"}\n+\t}\n+\targs := str.StringList(execCmd, a.Deps[0].BuiltTarget(), testlogArg, testArgs)\n+\n+\tif testCoverProfile != \"\" {\n+\t\t// Write coverage to temporary profile, for merging later.\n+\t\tfor i, arg := range args {\n+\t\t\tif strings.HasPrefix(arg, \"-test.coverprofile=\") {\n+\t\t\t\targs[i] = \"-test.coverprofile=\" + a.Objdir + \"_cover_.out\"\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif cfg.BuildN || cfg.BuildX {\n+\t\tb.Showcmd(\"\", \"%s\", strings.Join(args, \" \"))\n+\t\tif cfg.BuildN {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\tcmd := exec.Command(args[0], args[1:]...)\n+\tcmd.Dir = a.Package.Dir\n+\tcmd.Env = base.EnvForDir(cmd.Dir, cfg.OrigEnv)\n+\tcmd.Stdout = stdout\n+\tcmd.Stderr = stdout\n \n \t// If there are any local SWIG dependencies, we want to load\n \t// the shared library from the build directory.\n@@ -1392,7 +1420,7 @@ func (c *runCache) builderRunTest(b *work.Builder, a *work.Action) error {\n \n \tif err == nil {\n \t\tnorun := \"\"\n-\t\tif !testShowPass {\n+\t\tif !testShowPass && !testJSON {\n \t\t\tbuf.Reset()\n \t\t}\n \t\tif bytes.HasPrefix(out, noTestsToRun[1:]) || bytes.Contains(out, noTestsToRun) {\n@@ -1427,6 +1455,9 @@ func (c *runCache) tryCacheWithID(b *work.Builder, a *work.Action, id string) bo\n \tif len(pkgArgs) == 0 {\n \t\t// Caching does not apply to \"go test\",\n \t\t// only to \"go test foo\" (including \"go test .\").\n+\t\tif cache.DebugTest {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testcache: caching disabled in local directory mode\\n\")\n+\t\t}\n \t\tc.disableCache = true\n \t\treturn false\n \t}\n@@ -1435,6 +1466,9 @@ func (c *runCache) tryCacheWithID(b *work.Builder, a *work.Action, id string) bo\n \tfor _, arg := range testArgs {\n \t\ti := strings.Index(arg, \"=\")\n \t\tif i < 0 || !strings.HasPrefix(arg, \"-test.\") {\n+\t\t\tif cache.DebugTest {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"testcache: caching disabled for test argument: %s\\n\", arg)\n+\t\t\t}\n \t\t\tc.disableCache = true\n \t\t\treturn false\n \t\t}\n@@ -1456,49 +1490,111 @@ func (c *runCache) tryCacheWithID(b *work.Builder, a *work.Action, id string) bo\n \n \t\tdefault:\n \t\t\t// nothing else is cacheable\n+\t\t\tif cache.DebugTest {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"testcache: caching disabled for test argument: %s\\n\", arg)\n+\t\t\t}\n \t\t\tc.disableCache = true\n \t\t\treturn false\n \t\t}\n \t}\n \n \tif cache.Default() == nil {\n+\t\tif cache.DebugTest {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testcache: GOCACHE=off\\n\")\n+\t\t}\n \t\tc.disableCache = true\n \t\treturn false\n \t}\n \n+\t// The test cache result fetch is a two-level lookup.\n+\t//\n+\t// First, we use the content hash of the test binary\n+\t// and its command-line arguments to find the\n+\t// list of environment variables and files consulted\n+\t// the last time the test was run with those arguments.\n+\t// (To avoid unnecessary links, we store this entry\n+\t// under two hashes: id1 uses the linker inputs as a\n+\t// proxy for the test binary, and id2 uses the actual\n+\t// test binary. If the linker inputs are unchanged,\n+\t// this way we avoid the link step, even though we\n+\t// do not cache link outputs.)\n+\t//\n+\t// Second, we compute a hash of the values of the\n+\t// environment variables and the content of the files\n+\t// listed in the log from the previous run.\n+\t// Then we look up test output using a combination of\n+\t// the hash from the first part (testID) and the hash of the\n+\t// test inputs (testInputsID).\n+\t//\n+\t// In order to store a new test result, we must redo the\n+\t// testInputsID computation using the log from the run\n+\t// we want to cache, and then we store that new log and\n+\t// the new outputs.\n+\n \th := cache.NewHash(\"testResult\")\n \tfmt.Fprintf(h, \"test binary %s args %q execcmd %q\", id, cacheArgs, work.ExecCmd)\n-\t// TODO(rsc): How to handle other test dependencies like environment variables or input files?\n-\t// We could potentially add new API like testing.UsedEnv(envName string)\n-\t// or testing.UsedFile(inputFile string) to let tests declare what external inputs\n-\t// they consulted. These could be recorded and rechecked.\n-\t// The lookup here would become a two-step lookup: first use the binary+args\n-\t// to fetch the list of other inputs, then add the other inputs to produce a\n-\t// second key for fetching the results.\n-\t// For now, we'll assume that users will use -count=1 (or \"go test\") to bypass the test result\n-\t// cache when modifying those things.\n \ttestID := h.Sum()\n \tif c.id1 == (cache.ActionID{}) {\n \t\tc.id1 = testID\n \t} else {\n \t\tc.id2 = testID\n \t}\n+\tif cache.DebugTest {\n+\t\tfmt.Fprintf(os.Stderr, \"testcache: %s: test ID %x => %x\\n\", a.Package.ImportPath, id, testID)\n+\t}\n+\n+\t// Load list of referenced environment variables and files\n+\t// from last run of testID, and compute hash of that content.\n+\tdata, entry, err := cache.Default().GetBytes(testID)\n+\tif !bytes.HasPrefix(data, testlogMagic) || data[len(data)-1] != '\\n' {\n+\t\tif cache.DebugTest {\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"testcache: %s: input list not found: %v\\n\", a.Package.ImportPath, err)\n+\t\t\t} else {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"testcache: %s: input list malformed\\n\", a.Package.ImportPath)\n+\t\t\t}\n+\t\t}\n+\t\treturn false\n+\t}\n+\ttestInputsID, err := computeTestInputsID(a, data)\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\tif cache.DebugTest {\n+\t\tfmt.Fprintf(os.Stderr, \"testcache: %s: test ID %x => input ID %x => %x\\n\", a.Package.ImportPath, testID, testInputsID, testAndInputKey(testID, testInputsID))\n+\t}\n \n \t// Parse cached result in preparation for changing run time to \"(cached)\".\n \t// If we can't parse the cached result, don't use it.\n-\tdata, entry, _ := cache.Default().GetBytes(testID)\n+\tdata, entry, err = cache.Default().GetBytes(testAndInputKey(testID, testInputsID))\n \tif len(data) == 0 || data[len(data)-1] != '\\n' {\n+\t\tif cache.DebugTest {\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"testcache: %s: test output not found: %v\\n\", a.Package.ImportPath, err)\n+\t\t\t} else {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"testcache: %s: test output malformed\\n\", a.Package.ImportPath)\n+\t\t\t}\n+\t\t}\n \t\treturn false\n \t}\n \tif entry.Time.Before(testCacheExpire) {\n+\t\tif cache.DebugTest {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testcache: %s: test output expired due to go clean -testcache\\n\", a.Package.ImportPath)\n+\t\t}\n \t\treturn false\n \t}\n \ti := bytes.LastIndexByte(data[:len(data)-1], '\\n') + 1\n \tif !bytes.HasPrefix(data[i:], []byte(\"ok  \\t\")) {\n+\t\tif cache.DebugTest {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testcache: %s: test output malformed\\n\", a.Package.ImportPath)\n+\t\t}\n \t\treturn false\n \t}\n \tj := bytes.IndexByte(data[i+len(\"ok  \\t\"):], '\\t')\n \tif j < 0 {\n+\t\tif cache.DebugTest {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testcache: %s: test output malformed\\n\", a.Package.ImportPath)\n+\t\t}\n \t\treturn false\n \t}\n \tj += i + len(\"ok  \\t\") + 1\n@@ -1514,12 +1610,192 @@ func (c *runCache) tryCacheWithID(b *work.Builder, a *work.Action, id string) bo\n \treturn true\n }\n \n+var errBadTestInputs = errors.New(\"error parsing test inputs\")\n+var testlogMagic = []byte(\"# test log\\n\") // known to testing/internal/testdeps/deps.go\n+\n+// computeTestInputsID computes the \"test inputs ID\"\n+// (see comment in tryCacheWithID above) for the\n+// test log.\n+func computeTestInputsID(a *work.Action, testlog []byte) (cache.ActionID, error) {\n+\ttestlog = bytes.TrimPrefix(testlog, testlogMagic)\n+\th := cache.NewHash(\"testInputs\")\n+\tpwd := a.Package.Dir\n+\tfor _, line := range bytes.Split(testlog, []byte(\"\\n\")) {\n+\t\tif len(line) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\ts := string(line)\n+\t\ti := strings.Index(s, \" \")\n+\t\tif i < 0 {\n+\t\t\tif cache.DebugTest {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"testcache: %s: input list malformed (%q)\\n\", a.Package.ImportPath, line)\n+\t\t\t}\n+\t\t\treturn cache.ActionID{}, errBadTestInputs\n+\t\t}\n+\t\top := s[:i]\n+\t\tname := s[i+1:]\n+\t\tswitch op {\n+\t\tdefault:\n+\t\t\tif cache.DebugTest {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"testcache: %s: input list malformed (%q)\\n\", a.Package.ImportPath, line)\n+\t\t\t}\n+\t\t\treturn cache.ActionID{}, errBadTestInputs\n+\t\tcase \"getenv\":\n+\t\t\tfmt.Fprintf(h, \"env %s %x\\n\", name, hashGetenv(name))\n+\t\tcase \"chdir\":\n+\t\t\tpwd = name // always absolute\n+\t\t\tfmt.Fprintf(h, \"cbdir %s %x\\n\", name, hashStat(name))\n+\t\tcase \"stat\":\n+\t\t\tif !filepath.IsAbs(name) {\n+\t\t\t\tname = filepath.Join(pwd, name)\n+\t\t\t}\n+\t\t\tif !inDir(name, a.Package.Root) {\n+\t\t\t\t// Do not recheck files outside the GOPATH or GOROOT root.\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tfmt.Fprintf(h, \"stat %s %x\\n\", name, hashStat(name))\n+\t\tcase \"open\":\n+\t\t\tif !filepath.IsAbs(name) {\n+\t\t\t\tname = filepath.Join(pwd, name)\n+\t\t\t}\n+\t\t\tif !inDir(name, a.Package.Root) {\n+\t\t\t\t// Do not recheck files outside the GOPATH or GOROOT root.\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tfh, err := hashOpen(name)\n+\t\t\tif err != nil {\n+\t\t\t\tif cache.DebugTest {\n+\t\t\t\t\tfmt.Fprintf(os.Stderr, \"testcache: %s: input file %s: %s\\n\", a.Package.ImportPath, name, err)\n+\t\t\t\t}\n+\t\t\t\treturn cache.ActionID{}, err\n+\t\t\t}\n+\t\t\tfmt.Fprintf(h, \"open %s %x\\n\", name, fh)\n+\t\t}\n+\t}\n+\tsum := h.Sum()\n+\treturn sum, nil\n+}\n+\n+func inDir(path, dir string) bool {\n+\tif str.HasFilePathPrefix(path, dir) {\n+\t\treturn true\n+\t}\n+\txpath, err1 := filepath.EvalSymlinks(path)\n+\txdir, err2 := filepath.EvalSymlinks(dir)\n+\tif err1 == nil && err2 == nil && str.HasFilePathPrefix(xpath, xdir) {\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func hashGetenv(name string) cache.ActionID {\n+\th := cache.NewHash(\"getenv\")\n+\tv, ok := os.LookupEnv(name)\n+\tif !ok {\n+\t\th.Write([]byte{0})\n+\t} else {\n+\t\th.Write([]byte{1})\n+\t\th.Write([]byte(v))\n+\t}\n+\treturn h.Sum()\n+}\n+\n+const modTimeCutoff = 2 * time.Second\n+\n+var errFileTooNew = errors.New(\"file used as input is too new\")\n+\n+func hashOpen(name string) (cache.ActionID, error) {\n+\th := cache.NewHash(\"open\")\n+\tinfo, err := os.Stat(name)\n+\tif err != nil {\n+\t\tfmt.Fprintf(h, \"err %v\\n\", err)\n+\t\treturn h.Sum(), nil\n+\t}\n+\thashWriteStat(h, info)\n+\tif info.IsDir() {\n+\t\tnames, err := ioutil.ReadDir(name)\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(h, \"err %v\\n\", err)\n+\t\t}\n+\t\tfor _, f := range names {\n+\t\t\tfmt.Fprintf(h, \"file %s \", f.Name())\n+\t\t\thashWriteStat(h, f)\n+\t\t}\n+\t} else if info.Mode().IsRegular() {\n+\t\t// Because files might be very large, do not attempt\n+\t\t// to hash the entirety of their content. Instead assume\n+\t\t// the mtime and size recorded in hashWriteStat above\n+\t\t// are good enough.\n+\t\t//\n+\t\t// To avoid problems for very recent files where a new\n+\t\t// write might not change the mtime due to file system\n+\t\t// mtime precision, reject caching if a file was read that\n+\t\t// is less than modTimeCutoff old.\n+\t\tif time.Since(info.ModTime()) < modTimeCutoff {\n+\t\t\treturn cache.ActionID{}, errFileTooNew\n+\t\t}\n+\t}\n+\treturn h.Sum(), nil\n+}\n+\n+func hashStat(name string) cache.ActionID {\n+\th := cache.NewHash(\"stat\")\n+\tif info, err := os.Stat(name); err != nil {\n+\t\tfmt.Fprintf(h, \"err %v\\n\", err)\n+\t} else {\n+\t\thashWriteStat(h, info)\n+\t}\n+\tif info, err := os.Lstat(name); err != nil {\n+\t\tfmt.Fprintf(h, \"err %v\\n\", err)\n+\t} else {\n+\t\thashWriteStat(h, info)\n+\t}\n+\treturn h.Sum()\n+}\n+\n+func hashWriteStat(h io.Writer, info os.FileInfo) {\n+\tfmt.Fprintf(h, \"stat %d %x %v %v\\n\", info.Size(), uint64(info.Mode()), info.ModTime(), info.IsDir())\n+}\n+\n+// testAndInputKey returns the actual cache key for the pair (testID, testInputsID).\n+func testAndInputKey(testID, testInputsID cache.ActionID) cache.ActionID {\n+\treturn cache.Subkey(testID, fmt.Sprintf(\"inputs:%x\", testInputsID))\n+}\n+\n func (c *runCache) saveOutput(a *work.Action) {\n+\tif c.id1 == (cache.ActionID{}) && c.id2 == (cache.ActionID{}) {\n+\t\treturn\n+\t}\n+\n+\t// See comment about two-level lookup in tryCacheWithID above.\n+\ttestlog, err := ioutil.ReadFile(a.Objdir + \"testlog.txt\")\n+\tif err != nil || !bytes.HasPrefix(testlog, testlogMagic) || testlog[len(testlog)-1] != '\\n' {\n+\t\tif cache.DebugTest {\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"testcache: %s: reading testlog: %v\\n\", a.Package.ImportPath, err)\n+\t\t\t} else {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"testcache: %s: reading testlog: malformed\\n\", a.Package.ImportPath)\n+\t\t\t}\n+\t\t}\n+\t\treturn\n+\t}\n+\ttestInputsID, err := computeTestInputsID(a, testlog)\n+\tif err != nil {\n+\t\treturn\n+\t}\n \tif c.id1 != (cache.ActionID{}) {\n-\t\tcache.Default().PutNoVerify(c.id1, bytes.NewReader(a.TestOutput.Bytes()))\n+\t\tif cache.DebugTest {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testcache: %s: save test ID %x => input ID %x => %x\\n\", a.Package.ImportPath, c.id1, testInputsID, testAndInputKey(c.id1, testInputsID))\n+\t\t}\n+\t\tcache.Default().PutNoVerify(c.id1, bytes.NewReader(testlog))\n+\t\tcache.Default().PutNoVerify(testAndInputKey(c.id1, testInputsID), bytes.NewReader(a.TestOutput.Bytes()))\n \t}\n \tif c.id2 != (cache.ActionID{}) {\n-\t\tcache.Default().PutNoVerify(c.id2, bytes.NewReader(a.TestOutput.Bytes()))\n+\t\tif cache.DebugTest {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testcache: %s: save test ID %x => input ID %x => %x\\n\", a.Package.ImportPath, c.id2, testInputsID, testAndInputKey(c.id2, testInputsID))\n+\t\t}\n+\t\tcache.Default().PutNoVerify(c.id2, bytes.NewReader(testlog))\n+\t\tcache.Default().PutNoVerify(testAndInputKey(c.id2, testInputsID), bytes.NewReader(a.TestOutput.Bytes()))\n \t}\n }\n "}, {"sha": "8a686b71255133f1be47bb4d02285dc3c9209fe1", "filename": "libgo/go/cmd/go/internal/test/testflag.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -137,7 +137,7 @@ func testFlags(args []string) (packageNames, passToTest []string) {\n \t\t\tcase \"c\", \"i\", \"v\", \"cover\", \"json\":\n \t\t\t\tcmdflag.SetBool(cmd, f.BoolVar, value)\n \t\t\t\tif f.Name == \"json\" && testJSON {\n-\t\t\t\t\tpassToTest = append(passToTest, \"-test.v\")\n+\t\t\t\t\tpassToTest = append(passToTest, \"-test.v=true\")\n \t\t\t\t}\n \t\t\tcase \"o\":\n \t\t\t\ttestO = value"}, {"sha": "8b4f9264ac3ad062f16a0052c2b16585c44db5eb", "filename": "libgo/go/cmd/go/internal/vet/vet.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/work\"\n+\t\"path/filepath\"\n )\n \n var CmdVet = &base.Command{\n@@ -38,6 +39,13 @@ func runVet(cmd *base.Command, args []string) {\n \n \twork.BuildInit()\n \twork.VetFlags = vetFlags\n+\tif vetTool != \"\" {\n+\t\tvar err error\n+\t\twork.VetTool, err = filepath.Abs(vetTool)\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"%v\", err)\n+\t\t}\n+\t}\n \n \tpkgs := load.PackagesForBuild(pkgArgs)\n \tif len(pkgs) == 0 {"}, {"sha": "d4664cc7e9d0a6263002063f692625050feb2931", "filename": "libgo/go/cmd/go/internal/vet/vetflag.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -55,10 +55,13 @@ var vetFlagDefn = []*cmdflag.Defn{\n \t{Name: \"unusedstringmethods\"},\n }\n \n+var vetTool string\n+\n // add build flags to vetFlagDefn.\n func init() {\n \tvar cmd base.Command\n \twork.AddBuildFlags(&cmd)\n+\tcmd.Flag.StringVar(&vetTool, \"vettool\", \"\", \"path to vet tool binary\") // for cmd/vet tests; undocumented for now\n \tcmd.Flag.VisitAll(func(f *flag.Flag) {\n \t\tvetFlagDefn = append(vetFlagDefn, &cmdflag.Defn{\n \t\t\tName:  f.Name,\n@@ -87,8 +90,13 @@ func vetFlags(args []string) (passToVet, packageNames []string) {\n \t\t\t}\n \t\t\tswitch f.Name {\n \t\t\t// Flags known to the build but not to vet, so must be dropped.\n-\t\t\tcase \"x\", \"n\":\n-\t\t\t\targs = append(args[:i], args[i+1:]...)\n+\t\t\tcase \"x\", \"n\", \"vettool\":\n+\t\t\t\tif extraWord {\n+\t\t\t\t\targs = append(args[:i], args[i+2:]...)\n+\t\t\t\t\textraWord = false\n+\t\t\t\t} else {\n+\t\t\t\t\targs = append(args[:i], args[i+1:]...)\n+\t\t\t\t}\n \t\t\t\ti--\n \t\t\t}\n \t\t}"}, {"sha": "e7a0c776ba40250abfbae16721b397f3f001f076", "filename": "libgo/go/cmd/go/internal/work/action.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -99,6 +99,10 @@ func (a *Action) BuildContentID() string { return contentID(a.buildID) }\n // BuildID returns a's build ID.\n func (a *Action) BuildID() string { return a.buildID }\n \n+// BuiltTarget returns the actual file that was built. This differs\n+// from Target when the result was cached.\n+func (a *Action) BuiltTarget() string { return a.built }\n+\n // An actionQueue is a priority queue of actions.\n type actionQueue []*Action\n "}, {"sha": "39ca20ee4f0c9cc276b852e7dc66d93b278f36ae", "filename": "libgo/go/cmd/go/internal/work/buildid.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -535,6 +535,8 @@ func (b *Builder) flushOutput(a *Action) {\n // a.buildID to record as the build ID in the resulting package or binary.\n // updateBuildID computes the final content ID and updates the build IDs\n // in the binary.\n+//\n+// Keep in sync with src/cmd/buildid/buildid.go\n func (b *Builder) updateBuildID(a *Action, target string, rewrite bool) error {\n \tif cfg.BuildX || cfg.BuildN {\n \t\tif rewrite {"}, {"sha": "7e3f695e6f3b2698cc600d886ea59f9efa3b4ea1", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -509,6 +509,7 @@ func (b *Builder) build(a *Action) (err error) {\n \t\t\tCompiler:    cfg.BuildToolchainName,\n \t\t\tDir:         a.Package.Dir,\n \t\t\tGoFiles:     mkAbsFiles(a.Package.Dir, gofiles),\n+\t\t\tImportPath:  a.Package.ImportPath,\n \t\t\tImportMap:   make(map[string]string),\n \t\t\tPackageFile: make(map[string]string),\n \t\t}\n@@ -675,10 +676,15 @@ type vetConfig struct {\n \tGoFiles     []string\n \tImportMap   map[string]string\n \tPackageFile map[string]string\n+\tImportPath  string\n \n \tSucceedOnTypecheckFailure bool\n }\n \n+// VetTool is the path to an alternate vet tool binary.\n+// The caller is expected to set it (if needed) before executing any vet actions.\n+var VetTool string\n+\n // VetFlags are the flags to pass to vet.\n // The caller is expected to set them before executing any vet actions.\n var VetFlags []string\n@@ -724,7 +730,11 @@ func (b *Builder) vet(a *Action) error {\n \t}\n \n \tp := a.Package\n-\treturn b.run(a, p.Dir, p.ImportPath, env, cfg.BuildToolexec, base.Tool(\"vet\"), VetFlags, a.Objdir+\"vet.cfg\")\n+\ttool := VetTool\n+\tif tool == \"\" {\n+\t\ttool = base.Tool(\"vet\")\n+\t}\n+\treturn b.run(a, p.Dir, p.ImportPath, env, cfg.BuildToolexec, tool, VetFlags, a.Objdir+\"vet.cfg\")\n }\n \n // linkActionID computes the action ID for a link action.\n@@ -780,15 +790,8 @@ func (b *Builder) printLinkerConfig(h io.Writer, p *load.Package) {\n \t\t}\n \t\tfmt.Fprintf(h, \"GO$GOARCH=%s\\n\", os.Getenv(\"GO\"+strings.ToUpper(cfg.BuildContext.GOARCH))) // GO386, GOARM, etc\n \n-\t\t/*\n-\t\t\t// TODO(rsc): Enable this code.\n-\t\t\t// golang.org/issue/22475.\n-\t\t\tgoroot := cfg.BuildContext.GOROOT\n-\t\t\tif final := os.Getenv(\"GOROOT_FINAL\"); final != \"\" {\n-\t\t\t\tgoroot = final\n-\t\t\t}\n-\t\t\tfmt.Fprintf(h, \"GOROOT=%s\\n\", goroot)\n-\t\t*/\n+\t\t// The linker writes source file paths that say GOROOT_FINAL.\n+\t\tfmt.Fprintf(h, \"GOROOT=%s\\n\", cfg.GOROOT_FINAL)\n \n \t\t// TODO(rsc): Convince linker team not to add more magic environment variables,\n \t\t// or perhaps restrict the environment variables passed to subprocesses.\n@@ -1845,7 +1848,7 @@ func (b *Builder) gccSupportsFlag(compiler []string, flag string) bool {\n \t// GCC and clang.\n \tcmdArgs := str.StringList(compiler, flag, \"-c\", \"-x\", \"c\", \"-\")\n \tif cfg.BuildN || cfg.BuildX {\n-\t\tb.Showcmd(b.WorkDir, \"%s\", joinUnambiguously(cmdArgs))\n+\t\tb.Showcmd(b.WorkDir, \"%s || true\", joinUnambiguously(cmdArgs))\n \t\tif cfg.BuildN {\n \t\t\treturn false\n \t\t}"}, {"sha": "71b5337939ea3627030187c72022377b53648d4d", "filename": "libgo/go/cmd/go/internal/work/gc.go", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -49,7 +49,7 @@ func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, a\n \tpkgpath := p.ImportPath\n \tif cfg.BuildBuildmode == \"plugin\" {\n \t\tpkgpath = pluginPath(a)\n-\t} else if p.Name == \"main\" {\n+\t} else if p.Name == \"main\" && !p.Internal.ForceLibrary {\n \t\tpkgpath = \"main\"\n \t}\n \tgcargs := []string{\"-p\", pkgpath}\n@@ -418,11 +418,6 @@ func (gcToolchain) ld(b *Builder, root *Action, out, importcfg, mainpkg string)\n \t\tldflags = append(ldflags, \"-pluginpath\", pluginPath(root))\n \t}\n \n-\t// TODO(rsc): This is probably wrong - see golang.org/issue/22155.\n-\tif cfg.GOROOT != runtime.GOROOT() {\n-\t\tldflags = append(ldflags, \"-X=runtime/internal/sys.DefaultGoroot=\"+cfg.GOROOT)\n-\t}\n-\n \t// Store BuildID inside toolchain binaries as a unique identifier of the\n \t// tool being run, for use by content-based staleness determination.\n \tif root.Package.Goroot && strings.HasPrefix(root.Package.ImportPath, \"cmd/\") {"}, {"sha": "fd315272ea21d544f0db689c99bce227ca20617c", "filename": "libgo/go/cmd/go/testdata/src/coverdep2/p1/p.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp1%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp1%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp1%2Fp.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -0,0 +1,3 @@\n+package p1\n+\n+func F() int { return 1 }"}, {"sha": "c40256885c1a8892ccb114db5530b92964d882a6", "filename": "libgo/go/cmd/go/testdata/src/coverdep2/p1/p_test.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp1%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp1%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp1%2Fp_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -0,0 +1,10 @@\n+package p1_test\n+\n+import (\n+\t\"coverdep2/p2\"\n+\t\"testing\"\n+)\n+\n+func Test(t *testing.T) {\n+\tp2.F()\n+}"}, {"sha": "33561bbb5826f2a729bf0a22dbcdf92ae48372fd", "filename": "libgo/go/cmd/go/testdata/src/coverdep2/p2/p2.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp2%2Fp2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp2%2Fp2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep2%2Fp2%2Fp2.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -0,0 +1,7 @@\n+package p2\n+\n+import \"coverdep2/p1\"\n+\n+func F() {\n+\tp1.F()\n+}"}, {"sha": "4f21a510a3cff765fd502b6b7df2dde0ac0f96cd", "filename": "libgo/go/cmd/go/vendor_test.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -148,6 +148,7 @@ func splitLines(s string) []string {\n }\n \n func TestVendorGet(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.tempFile(\"src/v/m.go\", `\n@@ -173,8 +174,8 @@ func TestVendorGet(t *testing.T) {\n \ttg.grepStdout(\"v/vendor/vendor.org/p\", \"import not in vendor directory\")\n \ttg.run(\"list\", \"-f\", \"{{.TestImports}}\")\n \ttg.grepStdout(\"v/vendor/vendor.org/p\", \"test import not in vendor directory\")\n-\ttg.run(\"get\")\n-\ttg.run(\"get\", \"-t\")\n+\ttg.run(\"get\", \"-d\")\n+\ttg.run(\"get\", \"-t\", \"-d\")\n }\n \n func TestVendorGetUpdate(t *testing.T) {"}, {"sha": "eafef6bfa71a3c927b5e3034b556c3ea8850f729", "filename": "libgo/go/cmd/internal/objabi/util.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Futil.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -19,6 +19,8 @@ func envOr(key, value string) string {\n }\n \n var (\n+\tdefaultGOROOT string // set by linker\n+\n \tGOROOT  = envOr(\"GOROOT\", defaultGOROOT)\n \tGOARCH  = envOr(\"GOARCH\", defaultGOARCH)\n \tGOOS    = envOr(\"GOOS\", defaultGOOS)"}, {"sha": "dc4260e1316653e91b69ae6fede0e9f8d97f80ce", "filename": "libgo/go/container/list/list.go", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -65,15 +65,15 @@ func New() *List { return new(List).Init() }\n // The complexity is O(1).\n func (l *List) Len() int { return l.len }\n \n-// Front returns the first element of list l or nil.\n+// Front returns the first element of list l or nil if the list is empty.\n func (l *List) Front() *Element {\n \tif l.len == 0 {\n \t\treturn nil\n \t}\n \treturn l.root.next\n }\n \n-// Back returns the last element of list l or nil.\n+// Back returns the last element of list l or nil if the list is empty.\n func (l *List) Back() *Element {\n \tif l.len == 0 {\n \t\treturn nil\n@@ -118,6 +118,7 @@ func (l *List) remove(e *Element) *Element {\n \n // Remove removes e from l if e is an element of list l.\n // It returns the element value e.Value.\n+// The element must not be nil.\n func (l *List) Remove(e *Element) interface{} {\n \tif e.list == l {\n \t\t// if e.list == l, l must have been initialized when e was inserted\n@@ -141,6 +142,7 @@ func (l *List) PushBack(v interface{}) *Element {\n \n // InsertBefore inserts a new element e with value v immediately before mark and returns e.\n // If mark is not an element of l, the list is not modified.\n+// The mark must not be nil.\n func (l *List) InsertBefore(v interface{}, mark *Element) *Element {\n \tif mark.list != l {\n \t\treturn nil\n@@ -151,6 +153,7 @@ func (l *List) InsertBefore(v interface{}, mark *Element) *Element {\n \n // InsertAfter inserts a new element e with value v immediately after mark and returns e.\n // If mark is not an element of l, the list is not modified.\n+// The mark must not be nil.\n func (l *List) InsertAfter(v interface{}, mark *Element) *Element {\n \tif mark.list != l {\n \t\treturn nil\n@@ -161,6 +164,7 @@ func (l *List) InsertAfter(v interface{}, mark *Element) *Element {\n \n // MoveToFront moves element e to the front of list l.\n // If e is not an element of l, the list is not modified.\n+// The element must not be nil.\n func (l *List) MoveToFront(e *Element) {\n \tif e.list != l || l.root.next == e {\n \t\treturn\n@@ -171,6 +175,7 @@ func (l *List) MoveToFront(e *Element) {\n \n // MoveToBack moves element e to the back of list l.\n // If e is not an element of l, the list is not modified.\n+// The element must not be nil.\n func (l *List) MoveToBack(e *Element) {\n \tif e.list != l || l.root.prev == e {\n \t\treturn\n@@ -181,6 +186,7 @@ func (l *List) MoveToBack(e *Element) {\n \n // MoveBefore moves element e to its new position before mark.\n // If e or mark is not an element of l, or e == mark, the list is not modified.\n+// The element and mark must not be nil.\n func (l *List) MoveBefore(e, mark *Element) {\n \tif e.list != l || e == mark || mark.list != l {\n \t\treturn\n@@ -190,6 +196,7 @@ func (l *List) MoveBefore(e, mark *Element) {\n \n // MoveAfter moves element e to its new position after mark.\n // If e or mark is not an element of l, or e == mark, the list is not modified.\n+// The element and mark must not be nil.\n func (l *List) MoveAfter(e, mark *Element) {\n \tif e.list != l || e == mark || mark.list != l {\n \t\treturn\n@@ -198,7 +205,7 @@ func (l *List) MoveAfter(e, mark *Element) {\n }\n \n // PushBackList inserts a copy of an other list at the back of list l.\n-// The lists l and other may be the same.\n+// The lists l and other may be the same. They must not be nil.\n func (l *List) PushBackList(other *List) {\n \tl.lazyInit()\n \tfor i, e := other.Len(), other.Front(); i > 0; i, e = i-1, e.Next() {\n@@ -207,7 +214,7 @@ func (l *List) PushBackList(other *List) {\n }\n \n // PushFrontList inserts a copy of an other list at the front of list l.\n-// The lists l and other may be the same.\n+// The lists l and other may be the same. They must not be nil.\n func (l *List) PushFrontList(other *List) {\n \tl.lazyInit()\n \tfor i, e := other.Len(), other.Back(); i > 0; i, e = i-1, e.Prev() {"}, {"sha": "646b107958ac4c7fdf83199f7bef8eecf1db1ef5", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -406,8 +406,9 @@ type Config struct {\n \t//\n \t// If normal verification fails then the handshake will abort before\n \t// considering this callback. If normal verification is disabled by\n-\t// setting InsecureSkipVerify then this callback will be considered but\n-\t// the verifiedChains argument will always be nil.\n+\t// setting InsecureSkipVerify, or (for a server) when ClientAuth is\n+\t// RequestClientCert or RequireAnyClientCert, then this callback will\n+\t// be considered but the verifiedChains argument will always be nil.\n \tVerifyPeerCertificate func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error\n \n \t// RootCAs defines the set of root certificate authorities"}, {"sha": "e5e0df2ee3823922bd5a04cb8be2339e01ff4f6b", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -372,26 +372,34 @@ func (hs *clientHandshakeState) doFullHandshake() error {\n \t\t}\n \t}\n \n-\tif hs.serverHello.ocspStapling {\n-\t\tmsg, err = c.readHandshake()\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tcs, ok := msg.(*certificateStatusMsg)\n-\t\tif !ok {\n+\tmsg, err = c.readHandshake()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tcs, ok := msg.(*certificateStatusMsg)\n+\tif ok {\n+\t\t// RFC4366 on Certificate Status Request:\n+\t\t// The server MAY return a \"certificate_status\" message.\n+\n+\t\tif !hs.serverHello.ocspStapling {\n+\t\t\t// If a server returns a \"CertificateStatus\" message, then the\n+\t\t\t// server MUST have included an extension of type \"status_request\"\n+\t\t\t// with empty \"extension_data\" in the extended server hello.\n+\n \t\t\tc.sendAlert(alertUnexpectedMessage)\n-\t\t\treturn unexpectedMessageError(cs, msg)\n+\t\t\treturn errors.New(\"tls: received unexpected CertificateStatus message\")\n \t\t}\n \t\ths.finishedHash.Write(cs.marshal())\n \n \t\tif cs.statusType == statusTypeOCSP {\n \t\t\tc.ocspResponse = cs.response\n \t\t}\n-\t}\n \n-\tmsg, err = c.readHandshake()\n-\tif err != nil {\n-\t\treturn err\n+\t\tmsg, err = c.readHandshake()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n \n \tkeyAgreement := hs.suite.ka(c.vers)"}, {"sha": "80cd2501c43ed7764b90c676c17c167c5d9c77f8", "filename": "libgo/go/crypto/x509/root_cgo_darwin.go", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -119,7 +119,11 @@ int FetchPEMRoots(CFDataRef *pemRoots, CFDataRef *untrustedPemRoots) {\n \t\t\t}\n \t\t\t// We only want trusted certs.\n \t\t\tint untrusted = 0;\n-\t\t\tif (i != 0) {\n+\t\t\tint trustAsRoot = 0;\n+\t\t\tint trustRoot = 0;\n+\t\t\tif (i == 0) {\n+\t\t\t\ttrustAsRoot = 1;\n+\t\t\t} else {\n \t\t\t\t// Certs found in the system domain are always trusted. If the user\n \t\t\t\t// configures \"Never Trust\" on such a cert, it will also be found in the\n \t\t\t\t// admin or user domain, causing it to be added to untrustedPemRoots. The\n@@ -129,7 +133,7 @@ int FetchPEMRoots(CFDataRef *pemRoots, CFDataRef *untrustedPemRoots) {\n \t\t\t\t// SecTrustServer.c, \"user trust settings overrule admin trust settings\",\n \t\t\t\t// so take the last trust settings array we find.\n \t\t\t\t// Skip the system domain since it is always trusted.\n-\t\t\t\tfor (int k = 1; k < numDomains; k++) {\n+\t\t\t\tfor (int k = i; k < numDomains; k++) {\n \t\t\t\t\tCFArrayRef domainTrustSettings = NULL;\n \t\t\t\t\terr = SecTrustSettingsCopyTrustSettings(cert, domains[k], &domainTrustSettings);\n \t\t\t\t\tif (err == errSecSuccess && domainTrustSettings != NULL) {\n@@ -152,28 +156,35 @@ int FetchPEMRoots(CFDataRef *pemRoots, CFDataRef *untrustedPemRoots) {\n \t\t\t\t\t\t// TODO: The rest of the dictionary specifies conditions for evaluation.\n \t\t\t\t\t\tif (result == kSecTrustSettingsResultDeny) {\n \t\t\t\t\t\t\tuntrusted = 1;\n+\t\t\t\t\t\t} else if (result == kSecTrustSettingsResultTrustAsRoot) {\n+\t\t\t\t\t\t\ttrustAsRoot = 1;\n+\t\t\t\t\t\t} else if (result == kSecTrustSettingsResultTrustRoot) {\n+\t\t\t\t\t\t\ttrustRoot = 1;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tCFRelease(trustSettings);\n \t\t\t}\n-\t\t\t// We only want to add Root CAs, so make sure Subject and Issuer Name match\n-\t\t\tCFDataRef subjectName = SecCertificateCopyNormalizedSubjectContent(cert, &errRef);\n-\t\t\tif (errRef != NULL) {\n-\t\t\t\tCFRelease(errRef);\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tCFDataRef issuerName = SecCertificateCopyNormalizedIssuerContent(cert, &errRef);\n-\t\t\tif (errRef != NULL) {\n+\n+\t\t\tif (trustRoot) {\n+\t\t\t\t// We only want to add Root CAs, so make sure Subject and Issuer Name match\n+\t\t\t\tCFDataRef subjectName = SecCertificateCopyNormalizedSubjectContent(cert, &errRef);\n+\t\t\t\tif (errRef != NULL) {\n+\t\t\t\t\tCFRelease(errRef);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tCFDataRef issuerName = SecCertificateCopyNormalizedIssuerContent(cert, &errRef);\n+\t\t\t\tif (errRef != NULL) {\n+\t\t\t\t\tCFRelease(subjectName);\n+\t\t\t\t\tCFRelease(errRef);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tBoolean equal = CFEqual(subjectName, issuerName);\n \t\t\t\tCFRelease(subjectName);\n-\t\t\t\tCFRelease(errRef);\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tBoolean equal = CFEqual(subjectName, issuerName);\n-\t\t\tCFRelease(subjectName);\n-\t\t\tCFRelease(issuerName);\n-\t\t\tif (!equal) {\n-\t\t\t\tcontinue;\n+\t\t\t\tCFRelease(issuerName);\n+\t\t\t\tif (!equal) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\t// Note: SecKeychainItemExport is deprecated as of 10.7 in favor of SecItemExport.\n@@ -185,6 +196,9 @@ int FetchPEMRoots(CFDataRef *pemRoots, CFDataRef *untrustedPemRoots) {\n \t\t\t}\n \n \t\t\tif (data != NULL) {\n+\t\t\t\tif (!trustRoot && !trustAsRoot) {\n+\t\t\t\t\tuntrusted = 1;\n+\t\t\t\t}\n \t\t\t\tCFMutableDataRef appendTo = untrusted ? combinedUntrustedData : combinedData;\n \t\t\t\tCFDataAppendBytes(appendTo, CFDataGetBytePtr(data), CFDataGetLength(data));\n \t\t\t\tCFRelease(data);"}, {"sha": "b5580d6f02a3b97375e232bd7f5c3e55e8ab60af", "filename": "libgo/go/crypto/x509/root_darwin_arm_gen.go", "status": "modified", "additions": 42, "deletions": 48, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_arm_gen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_arm_gen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_arm_gen.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -18,16 +18,18 @@ package main\n \n import (\n \t\"bytes\"\n+\t\"crypto/sha256\"\n \t\"crypto/x509\"\n+\t\"encoding/hex\"\n \t\"encoding/pem\"\n \t\"flag\"\n \t\"fmt\"\n \t\"go/format\"\n \t\"io/ioutil\"\n \t\"log\"\n-\t\"math/big\"\n \t\"net/http\"\n \t\"os/exec\"\n+\t\"regexp\"\n \t\"strings\"\n )\n \n@@ -41,7 +43,7 @@ func main() {\n \n \tbuf := new(bytes.Buffer)\n \n-\tfmt.Fprintf(buf, \"// Created by root_darwin_arm_gen --output %s; DO NOT EDIT\\n\", *output)\n+\tfmt.Fprintf(buf, \"// Code generated by root_darwin_arm_gen --output %s; DO NOT EDIT.\\n\", *output)\n \tfmt.Fprintf(buf, \"%s\", header)\n \n \tfmt.Fprintf(buf, \"const systemRootsPEM = `\\n\")\n@@ -78,36 +80,22 @@ func selectCerts() ([]*x509.Certificate, error) {\n \n \tvar certs []*x509.Certificate\n \tfor _, id := range ids {\n-\t\tsn, ok := big.NewInt(0).SetString(id.serialNumber, 0) // 0x prefix selects hex\n-\t\tif !ok {\n-\t\t\treturn nil, fmt.Errorf(\"invalid serial number: %q\", id.serialNumber)\n-\t\t}\n-\t\tski, ok := big.NewInt(0).SetString(id.subjectKeyID, 0)\n-\t\tif !ok {\n-\t\t\treturn nil, fmt.Errorf(\"invalid Subject Key ID: %q\", id.subjectKeyID)\n-\t\t}\n-\n-\t\tfor _, cert := range scerts {\n-\t\t\tif sn.Cmp(cert.SerialNumber) != 0 {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tcski := big.NewInt(0).SetBytes(cert.SubjectKeyId)\n-\t\t\tif ski.Cmp(cski) != 0 {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tcerts = append(certs, cert)\n-\t\t\tbreak\n+\t\tif c, ok := scerts[id.fingerprint]; ok {\n+\t\t\tcerts = append(certs, c)\n+\t\t} else {\n+\t\t\tfmt.Printf(\"WARNING: cannot find certificate: %s (fingerprint: %s)\\n\", id.name, id.fingerprint)\n \t\t}\n \t}\n \treturn certs, nil\n }\n \n-func sysCerts() (certs []*x509.Certificate, err error) {\n+func sysCerts() (certs map[string]*x509.Certificate, err error) {\n \tcmd := exec.Command(\"/usr/bin/security\", \"find-certificate\", \"-a\", \"-p\", \"/System/Library/Keychains/SystemRootCertificates.keychain\")\n \tdata, err := cmd.Output()\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\tcerts = make(map[string]*x509.Certificate)\n \tfor len(data) > 0 {\n \t\tvar block *pem.Block\n \t\tblock, data = pem.Decode(data)\n@@ -122,19 +110,23 @@ func sysCerts() (certs []*x509.Certificate, err error) {\n \t\tif err != nil {\n \t\t\tcontinue\n \t\t}\n-\t\tcerts = append(certs, cert)\n+\n+\t\tfingerprint := sha256.Sum256(cert.Raw)\n+\t\tcerts[hex.EncodeToString(fingerprint[:])] = cert\n \t}\n \treturn certs, nil\n }\n \n type certID struct {\n-\tserialNumber string\n-\tsubjectKeyID string\n+\tname        string\n+\tfingerprint string\n }\n \n // fetchCertIDs fetches IDs of iOS X509 certificates from apple.com.\n func fetchCertIDs() ([]certID, error) {\n-\tresp, err := http.Get(\"https://support.apple.com/en-us/HT204132\")\n+\t// Download the iOS 11 support page. The index for all iOS versions is here:\n+\t// https://support.apple.com/en-us/HT204132\n+\tresp, err := http.Get(\"https://support.apple.com/en-us/HT208125\")\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -144,31 +136,33 @@ func fetchCertIDs() ([]certID, error) {\n \t\treturn nil, err\n \t}\n \ttext := string(body)\n-\ttext = text[strings.Index(text, \"<section id=trusted\"):]\n-\ttext = text[:strings.Index(text, \"</section>\")]\n+\ttext = text[strings.Index(text, \"<div id=trusted\"):]\n+\ttext = text[:strings.Index(text, \"</div>\")]\n \n-\tlines := strings.Split(text, \"\\n\")\n \tvar ids []certID\n-\tvar id certID\n-\tfor i, ln := range lines {\n-\t\tif i == len(lines)-1 {\n-\t\t\tbreak\n-\t\t}\n-\t\tconst sn = \"Serial Number:\"\n-\t\tif ln == sn {\n-\t\t\tid.serialNumber = \"0x\" + strings.Replace(strings.TrimSpace(lines[i+1]), \":\", \"\", -1)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif strings.HasPrefix(ln, sn) {\n-\t\t\t// extract hex value from parentheses.\n-\t\t\tid.serialNumber = ln[strings.Index(ln, \"(\")+1 : len(ln)-1]\n+\tcols := make(map[string]int)\n+\tfor i, rowmatch := range regexp.MustCompile(\"(?s)<tr>(.*?)</tr>\").FindAllStringSubmatch(text, -1) {\n+\t\trow := rowmatch[1]\n+\t\tif i == 0 {\n+\t\t\t// Parse table header row to extract column names\n+\t\t\tfor i, match := range regexp.MustCompile(\"(?s)<th>(.*?)</th>\").FindAllStringSubmatch(row, -1) {\n+\t\t\t\tcols[match[1]] = i\n+\t\t\t}\n \t\t\tcontinue\n \t\t}\n-\t\tif strings.TrimSpace(ln) == \"X509v3 Subject Key Identifier:\" {\n-\t\t\tid.subjectKeyID = \"0x\" + strings.Replace(strings.TrimSpace(lines[i+1]), \":\", \"\", -1)\n-\t\t\tids = append(ids, id)\n-\t\t\tid = certID{}\n-\t\t}\n+\n+\t\tvalues := regexp.MustCompile(\"(?s)<td>(.*?)</td>\").FindAllStringSubmatch(row, -1)\n+\t\tname := values[cols[\"Certificate name\"]][1]\n+\t\tfingerprint := values[cols[\"Fingerprint (SHA-256)\"]][1]\n+\t\tfingerprint = strings.Replace(fingerprint, \"<br>\", \"\", -1)\n+\t\tfingerprint = strings.Replace(fingerprint, \"\\n\", \"\", -1)\n+\t\tfingerprint = strings.Replace(fingerprint, \" \", \"\", -1)\n+\t\tfingerprint = strings.ToLower(fingerprint)\n+\n+\t\tids = append(ids, certID{\n+\t\t\tname:        name,\n+\t\t\tfingerprint: fingerprint,\n+\t\t})\n \t}\n \treturn ids, nil\n }\n@@ -180,7 +174,7 @@ const header = `\n \n // +build cgo\n // +build darwin\n-// +build arm arm64\n+// +build arm arm64 ios\n \n package x509\n "}, {"sha": "fcbbd6b170150aa1dcd91c10f9189a4e4f192077", "filename": "libgo/go/crypto/x509/root_darwin_armx.go", "status": "modified", "additions": 3768, "deletions": 4363, "changes": 8131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_armx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_armx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_armx.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5"}, {"sha": "86d9e82aca45332b4744261de68a56650cee7a69", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -984,7 +984,7 @@ type distributionPoint struct {\n }\n \n type distributionPointName struct {\n-\tFullName     asn1.RawValue    `asn1:\"optional,tag:0\"`\n+\tFullName     []asn1.RawValue  `asn1:\"optional,tag:0\"`\n \tRelativeName pkix.RDNSequence `asn1:\"optional,tag:1\"`\n }\n \n@@ -1466,20 +1466,14 @@ func parseCertificate(in *certificate) (*Certificate, error) {\n \n \t\t\t\tfor _, dp := range cdp {\n \t\t\t\t\t// Per RFC 5280, 4.2.1.13, one of distributionPoint or cRLIssuer may be empty.\n-\t\t\t\t\tif len(dp.DistributionPoint.FullName.Bytes) == 0 {\n+\t\t\t\t\tif len(dp.DistributionPoint.FullName) == 0 {\n \t\t\t\t\t\tcontinue\n \t\t\t\t\t}\n \n-\t\t\t\t\tvar n asn1.RawValue\n-\t\t\t\t\tif _, err := asn1.Unmarshal(dp.DistributionPoint.FullName.Bytes, &n); err != nil {\n-\t\t\t\t\t\treturn nil, err\n-\t\t\t\t\t}\n-\t\t\t\t\t// Trailing data after the fullName is\n-\t\t\t\t\t// allowed because other elements of\n-\t\t\t\t\t// the SEQUENCE can appear.\n-\n-\t\t\t\t\tif n.Tag == 6 {\n-\t\t\t\t\t\tout.CRLDistributionPoints = append(out.CRLDistributionPoints, string(n.Bytes))\n+\t\t\t\t\tfor _, fullName := range dp.DistributionPoint.FullName {\n+\t\t\t\t\t\tif fullName.Tag == 6 {\n+\t\t\t\t\t\t\tout.CRLDistributionPoints = append(out.CRLDistributionPoints, string(fullName.Bytes))\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n@@ -1946,11 +1940,11 @@ func buildExtensions(template *Certificate, subjectIsEmpty bool, authorityKeyId\n \n \t\tvar crlDp []distributionPoint\n \t\tfor _, name := range template.CRLDistributionPoints {\n-\t\t\trawFullName, _ := asn1.Marshal(asn1.RawValue{Tag: 6, Class: 2, Bytes: []byte(name)})\n-\n \t\t\tdp := distributionPoint{\n \t\t\t\tDistributionPoint: distributionPointName{\n-\t\t\t\t\tFullName: asn1.RawValue{Tag: 0, Class: 2, IsCompound: true, Bytes: rawFullName},\n+\t\t\t\t\tFullName: []asn1.RawValue{\n+\t\t\t\t\t\tasn1.RawValue{Tag: 6, Class: 2, Bytes: []byte(name)},\n+\t\t\t\t\t},\n \t\t\t\t},\n \t\t\t}\n \t\t\tcrlDp = append(crlDp, dp)"}, {"sha": "7d75727a8ca8c68a15e84c9db01c33846f3e4a22", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -1891,3 +1891,58 @@ func TestEmptySubject(t *testing.T) {\n \n \tt.Fatal(\"SAN extension is missing\")\n }\n+\n+// multipleURLsInCRLDPPEM contains two URLs in a single CRL DistributionPoint\n+// structure. It is taken from https://crt.sh/?id=12721534.\n+const multipleURLsInCRLDPPEM = `\n+-----BEGIN CERTIFICATE-----\n+MIIF4TCCBMmgAwIBAgIQc+6uFePfrahUGpXs8lhiTzANBgkqhkiG9w0BAQsFADCB\n+8zELMAkGA1UEBhMCRVMxOzA5BgNVBAoTMkFnZW5jaWEgQ2F0YWxhbmEgZGUgQ2Vy\n+dGlmaWNhY2lvIChOSUYgUS0wODAxMTc2LUkpMSgwJgYDVQQLEx9TZXJ2ZWlzIFB1\n+YmxpY3MgZGUgQ2VydGlmaWNhY2lvMTUwMwYDVQQLEyxWZWdldSBodHRwczovL3d3\n+dy5jYXRjZXJ0Lm5ldC92ZXJhcnJlbCAoYykwMzE1MDMGA1UECxMsSmVyYXJxdWlh\n+IEVudGl0YXRzIGRlIENlcnRpZmljYWNpbyBDYXRhbGFuZXMxDzANBgNVBAMTBkVD\n+LUFDQzAeFw0xNDA5MTgwODIxMDBaFw0zMDA5MTgwODIxMDBaMIGGMQswCQYDVQQG\n+EwJFUzEzMDEGA1UECgwqQ09OU09SQ0kgQURNSU5JU1RSQUNJTyBPQkVSVEEgREUg\n+Q0FUQUxVTllBMSowKAYDVQQLDCFTZXJ2ZWlzIFDDumJsaWNzIGRlIENlcnRpZmlj\n+YWNpw7MxFjAUBgNVBAMMDUVDLUNpdXRhZGFuaWEwggEiMA0GCSqGSIb3DQEBAQUA\n+A4IBDwAwggEKAoIBAQDFkHPRZPZlXTWZ5psJhbS/Gx+bxcTpGrlVQHHtIkgGz77y\n+TA7UZUFb2EQMncfbOhR0OkvQQn1aMvhObFJSR6nI+caf2D+h/m/InMl1MyH3S0Ak\n+YGZZsthnyC6KxqK2A/NApncrOreh70ULkQs45aOKsi1kR1W0zE+iFN+/P19P7AkL\n+Rl3bXBCVd8w+DLhcwRrkf1FCDw6cEqaFm3cGgf5cbBDMaVYAweWTxwBZAq2RbQAW\n+jE7mledcYghcZa4U6bUmCBPuLOnO8KMFAvH+aRzaf3ws5/ZoOVmryyLLJVZ54peZ\n+OwnP9EL4OuWzmXCjBifXR2IAblxs5JYj57tls45nAgMBAAGjggHaMIIB1jASBgNV\n+HRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUC2hZPofI\n+oxUa4ECCIl+fHbLFNxUwHwYDVR0jBBgwFoAUoMOLRKo3pUW/l4Ba0fF4opvpXY0w\n+gdYGA1UdIASBzjCByzCByAYEVR0gADCBvzAxBggrBgEFBQcCARYlaHR0cHM6Ly93\n+d3cuYW9jLmNhdC9DQVRDZXJ0L1JlZ3VsYWNpbzCBiQYIKwYBBQUHAgIwfQx7QXF1\n+ZXN0IGNlcnRpZmljYXQgw6lzIGVtw6hzIMO6bmljYSBpIGV4Y2x1c2l2YW1lbnQg\n+YSBFbnRpdGF0cyBkZSBDZXJ0aWZpY2FjacOzLiBWZWdldSBodHRwczovL3d3dy5h\n+b2MuY2F0L0NBVENlcnQvUmVndWxhY2lvMDMGCCsGAQUFBwEBBCcwJTAjBggrBgEF\n+BQcwAYYXaHR0cDovL29jc3AuY2F0Y2VydC5jYXQwYgYDVR0fBFswWTBXoFWgU4Yn\n+aHR0cDovL2Vwc2NkLmNhdGNlcnQubmV0L2NybC9lYy1hY2MuY3JshihodHRwOi8v\n+ZXBzY2QyLmNhdGNlcnQubmV0L2NybC9lYy1hY2MuY3JsMA0GCSqGSIb3DQEBCwUA\n+A4IBAQChqFTjlAH5PyIhLjLgEs68CyNNC1+vDuZXRhy22TI83JcvGmQrZosPvVIL\n+PsUXx+C06Pfqmh48Q9S89X9K8w1SdJxP/rZeGEoRiKpwvQzM4ArD9QxyC8jirxex\n+3Umg9Ai/sXQ+1lBf6xw4HfUUr1WIp7pNHj0ZWLo106urqktcdeAFWme+/klis5fu\n+labCSVPuT/QpwakPrtqOhRms8vgpKiXa/eLtL9ZiA28X/Mker0zlAeTA7Z7uAnp6\n+oPJTlZu1Gg1ZDJueTWWsLlO+P+Wzm3MRRIbcgdRzm4mdO7ubu26SzX/aQXDhuih+\n+eVxXDTCfs7GUlxnjOp5j559X/N0A\n+-----END CERTIFICATE-----\n+`\n+\n+func TestMultipleURLsInCRLDP(t *testing.T) {\n+\tblock, _ := pem.Decode([]byte(multipleURLsInCRLDPPEM))\n+\tcert, err := ParseCertificate(block.Bytes)\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to parse certificate: %s\", err)\n+\t}\n+\n+\twant := []string{\n+\t\t\"http://epscd.catcert.net/crl/ec-acc.crl\",\n+\t\t\"http://epscd2.catcert.net/crl/ec-acc.crl\",\n+\t}\n+\tif got := cert.CRLDistributionPoints; !reflect.DeepEqual(got, want) {\n+\t\tt.Errorf(\"CRL distribution points = %#v, want #%v\", got, want)\n+\t}\n+}"}, {"sha": "19a3a4f7c9aa2bcaa23c559f93d80e101a52bf1e", "filename": "libgo/go/database/sql/driver/driver.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -15,7 +15,8 @@ import (\n )\n \n // Value is a value that drivers must be able to handle.\n-// It is either nil or an instance of one of these types:\n+// It is either nil, a type handled by a database driver's NamedValueChecker\n+// interface, or an instance of one of these types:\n //\n //   int64\n //   float64"}, {"sha": "8f5588ed2680886be6766e68d0feb8b77e5d9e29", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -2055,14 +2055,14 @@ func (tx *Tx) StmtContext(ctx context.Context, stmt *Stmt) *Stmt {\n \t\tstmt.mu.Unlock()\n \n \t\tif si == nil {\n+\t\t\tvar ds *driverStmt\n \t\t\twithLock(dc, func() {\n-\t\t\t\tvar ds *driverStmt\n \t\t\t\tds, err = stmt.prepareOnConnLocked(ctx, dc)\n-\t\t\t\tsi = ds.si\n \t\t\t})\n \t\t\tif err != nil {\n \t\t\t\treturn &Stmt{stickyErr: err}\n \t\t\t}\n+\t\t\tsi = ds.si\n \t\t}\n \t\tparentStmt = stmt\n \t}"}, {"sha": "2da913fceb3ff3ea470418991e66345c8d75e190", "filename": "libgo/go/encoding/gob/decode.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -1038,6 +1038,8 @@ func (dec *Decoder) compatibleType(fr reflect.Type, fw typeId, inProgress map[re\n \n // typeString returns a human-readable description of the type identified by remoteId.\n func (dec *Decoder) typeString(remoteId typeId) string {\n+\ttypeLock.Lock()\n+\tdefer typeLock.Unlock()\n \tif t := idToType[remoteId]; t != nil {\n \t\t// globally known type.\n \t\treturn t.string()"}, {"sha": "934270eedd8a547d5af9a2dc070de0c244d9c03b", "filename": "libgo/go/encoding/gob/type_test.go", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fencoding%2Fgob%2Ftype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fencoding%2Fgob%2Ftype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ftype_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -7,6 +7,7 @@ package gob\n import (\n \t\"bytes\"\n \t\"reflect\"\n+\t\"sync\"\n \t\"testing\"\n )\n \n@@ -218,3 +219,44 @@ func TestStressParallel(t *testing.T) {\n \t\t<-c\n \t}\n }\n+\n+// Issue 23328. Note that this test name is known to cmd/dist/test.go.\n+func TestTypeRace(t *testing.T) {\n+\tc := make(chan bool)\n+\tvar wg sync.WaitGroup\n+\tfor i := 0; i < 2; i++ {\n+\t\twg.Add(1)\n+\t\tgo func(i int) {\n+\t\t\tdefer wg.Done()\n+\t\t\tvar buf bytes.Buffer\n+\t\t\tenc := NewEncoder(&buf)\n+\t\t\tdec := NewDecoder(&buf)\n+\t\t\tvar x interface{}\n+\t\t\tswitch i {\n+\t\t\tcase 0:\n+\t\t\t\tx = &N1{}\n+\t\t\tcase 1:\n+\t\t\t\tx = &N2{}\n+\t\t\tdefault:\n+\t\t\t\tt.Errorf(\"bad i %d\", i)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tm := make(map[string]string)\n+\t\t\t<-c\n+\t\t\tif err := enc.Encode(x); err != nil {\n+\t\t\t\tt.Error(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err := enc.Encode(x); err != nil {\n+\t\t\t\tt.Error(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err := dec.Decode(&m); err == nil {\n+\t\t\t\tt.Error(\"decode unexpectedly succeeded\")\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}(i)\n+\t}\n+\tclose(c)\n+\twg.Wait()\n+}"}, {"sha": "a0ccf44028b19bda077599fef69ec310fa6659d0", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -583,16 +583,6 @@ var marshalTests = []struct {\n \t\tExpectXML: `<PresenceTest></PresenceTest>`,\n \t},\n \n-\t// A pointer to struct{} may be used to test for an element's presence.\n-\t{\n-\t\tValue:     &PresenceTest{new(struct{})},\n-\t\tExpectXML: `<PresenceTest><Exists></Exists></PresenceTest>`,\n-\t},\n-\t{\n-\t\tValue:     &PresenceTest{},\n-\t\tExpectXML: `<PresenceTest></PresenceTest>`,\n-\t},\n-\n \t// A []byte field is only nil if the element was not found.\n \t{\n \t\tValue:         &Data{},"}, {"sha": "e14a304f2fac4d206529dbc8766f057de3d59f5f", "filename": "libgo/go/go/build/deps_test.go", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -154,12 +154,13 @@ var pkgDeps = map[string][]string{\n \t\t\"syscall\",\n \t},\n \n-\t\"internal/poll\": {\"L0\", \"internal/race\", \"syscall\", \"time\", \"unicode/utf16\", \"unicode/utf8\", \"internal/syscall/windows\"},\n-\t\"os\":            {\"L1\", \"os\", \"syscall\", \"time\", \"internal/poll\", \"internal/syscall/windows\"},\n-\t\"path/filepath\": {\"L2\", \"os\", \"syscall\", \"internal/syscall/windows\"},\n-\t\"io/ioutil\":     {\"L2\", \"os\", \"path/filepath\", \"time\"},\n-\t\"os/exec\":       {\"L2\", \"os\", \"context\", \"path/filepath\", \"syscall\"},\n-\t\"os/signal\":     {\"L2\", \"os\", \"syscall\"},\n+\t\"internal/poll\":    {\"L0\", \"internal/race\", \"syscall\", \"time\", \"unicode/utf16\", \"unicode/utf8\", \"internal/syscall/windows\"},\n+\t\"internal/testlog\": {\"L0\"},\n+\t\"os\":               {\"L1\", \"os\", \"syscall\", \"time\", \"internal/poll\", \"internal/syscall/windows\", \"internal/testlog\"},\n+\t\"path/filepath\":    {\"L2\", \"os\", \"syscall\", \"internal/syscall/windows\"},\n+\t\"io/ioutil\":        {\"L2\", \"os\", \"path/filepath\", \"time\"},\n+\t\"os/exec\":          {\"L2\", \"os\", \"context\", \"path/filepath\", \"syscall\"},\n+\t\"os/signal\":        {\"L2\", \"os\", \"syscall\"},\n \n \t// OS enables basic operating system functionality,\n \t// but not direct use of package syscall, nor os/signal.\n@@ -271,7 +272,7 @@ var pkgDeps = map[string][]string{\n \t\"net/url\":                  {\"L4\"},\n \t\"plugin\":                   {\"L0\", \"OS\", \"CGO\"},\n \t\"runtime/pprof/internal/profile\": {\"L4\", \"OS\", \"compress/gzip\", \"regexp\"},\n-\t\"testing/internal/testdeps\":      {\"L4\", \"runtime/pprof\", \"regexp\"},\n+\t\"testing/internal/testdeps\":      {\"L4\", \"internal/testlog\", \"runtime/pprof\", \"regexp\"},\n \t\"text/scanner\":                   {\"L4\", \"OS\"},\n \t\"text/template/parse\":            {\"L4\"},\n "}, {"sha": "64f8eb660a8815ea4e5a88b7ae7263056a126cd6", "filename": "libgo/go/go/constant/value.go", "status": "modified", "additions": 83, "deletions": 21, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -18,6 +18,8 @@ import (\n \t\"math\"\n \t\"math/big\"\n \t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n \t\"unicode/utf8\"\n )\n \n@@ -67,7 +69,12 @@ const prec = 512\n type (\n \tunknownVal struct{}\n \tboolVal    bool\n-\tstringVal  string\n+\tstringVal  struct {\n+\t\t// Lazy value: either a string (l,r==nil) or an addition (l,r!=nil).\n+\t\tmu   sync.Mutex\n+\t\ts    string\n+\t\tl, r *stringVal\n+\t}\n \tint64Val   int64                    // Int values representable as an int64\n \tintVal     struct{ val *big.Int }   // Int values not representable as an int64\n \tratVal     struct{ val *big.Rat }   // Float values representable as a fraction\n@@ -77,7 +84,7 @@ type (\n \n func (unknownVal) Kind() Kind { return Unknown }\n func (boolVal) Kind() Kind    { return Bool }\n-func (stringVal) Kind() Kind  { return String }\n+func (*stringVal) Kind() Kind { return String }\n func (int64Val) Kind() Kind   { return Int }\n func (intVal) Kind() Kind     { return Int }\n func (ratVal) Kind() Kind     { return Float }\n@@ -88,9 +95,9 @@ func (unknownVal) String() string { return \"unknown\" }\n func (x boolVal) String() string  { return strconv.FormatBool(bool(x)) }\n \n // String returns a possibly shortened quoted form of the String value.\n-func (x stringVal) String() string {\n+func (x *stringVal) String() string {\n \tconst maxLen = 72 // a reasonable length\n-\ts := strconv.Quote(string(x))\n+\ts := strconv.Quote(x.string())\n \tif utf8.RuneCountInString(s) > maxLen {\n \t\t// The string without the enclosing quotes is greater than maxLen-2 runes\n \t\t// long. Remove the last 3 runes (including the closing '\"') by keeping\n@@ -105,6 +112,60 @@ func (x stringVal) String() string {\n \treturn s\n }\n \n+// string constructs and returns the actual string literal value.\n+// If x represents an addition, then it rewrites x to be a single\n+// string, to speed future calls. This lazy construction avoids\n+// building different string values for all subpieces of a large\n+// concatenation. See golang.org/issue/23348.\n+func (x *stringVal) string() string {\n+\tx.mu.Lock()\n+\tif x.l != nil {\n+\t\tx.s = strings.Join(reverse(x.appendReverse(nil)), \"\")\n+\t\tx.l = nil\n+\t\tx.r = nil\n+\t}\n+\ts := x.s\n+\tx.mu.Unlock()\n+\n+\treturn s\n+}\n+\n+// reverse reverses x in place and returns it.\n+func reverse(x []string) []string {\n+\tn := len(x)\n+\tfor i := 0; i+i < n; i++ {\n+\t\tx[i], x[n-1-i] = x[n-1-i], x[i]\n+\t}\n+\treturn x\n+}\n+\n+// appendReverse appends to list all of x's subpieces, but in reverse,\n+// and returns the result. Appending the reversal allows processing\n+// the right side in a recursive call and the left side in a loop.\n+// Because a chain like a + b + c + d + e is actually represented\n+// as ((((a + b) + c) + d) + e), the left-side loop avoids deep recursion.\n+// x must be locked.\n+func (x *stringVal) appendReverse(list []string) []string {\n+\ty := x\n+\tfor y.r != nil {\n+\t\ty.r.mu.Lock()\n+\t\tlist = y.r.appendReverse(list)\n+\t\ty.r.mu.Unlock()\n+\n+\t\tl := y.l\n+\t\tif y != x {\n+\t\t\ty.mu.Unlock()\n+\t\t}\n+\t\tl.mu.Lock()\n+\t\ty = l\n+\t}\n+\ts := y.s\n+\tif y != x {\n+\t\ty.mu.Unlock()\n+\t}\n+\treturn append(list, s)\n+}\n+\n func (x int64Val) String() string { return strconv.FormatInt(int64(x), 10) }\n func (x intVal) String() string   { return x.val.String() }\n func (x ratVal) String() string   { return rtof(x).String() }\n@@ -160,7 +221,7 @@ func (x complexVal) String() string { return fmt.Sprintf(\"(%s + %si)\", x.re, x.i\n \n func (x unknownVal) ExactString() string { return x.String() }\n func (x boolVal) ExactString() string    { return x.String() }\n-func (x stringVal) ExactString() string  { return strconv.Quote(string(x)) }\n+func (x *stringVal) ExactString() string { return strconv.Quote(x.string()) }\n func (x int64Val) ExactString() string   { return x.String() }\n func (x intVal) ExactString() string     { return x.String() }\n \n@@ -180,7 +241,7 @@ func (x complexVal) ExactString() string {\n \n func (unknownVal) implementsValue() {}\n func (boolVal) implementsValue()    {}\n-func (stringVal) implementsValue()  {}\n+func (*stringVal) implementsValue() {}\n func (int64Val) implementsValue()   {}\n func (ratVal) implementsValue()     {}\n func (intVal) implementsValue()     {}\n@@ -283,7 +344,7 @@ func MakeUnknown() Value { return unknownVal{} }\n func MakeBool(b bool) Value { return boolVal(b) }\n \n // MakeString returns the String value for s.\n-func MakeString(s string) Value { return stringVal(s) }\n+func MakeString(s string) Value { return &stringVal{s: s} }\n \n // MakeInt64 returns the Int value for x.\n func MakeInt64(x int64) Value { return int64Val(x) }\n@@ -382,8 +443,8 @@ func BoolVal(x Value) bool {\n // If x is Unknown, the result is \"\".\n func StringVal(x Value) string {\n \tswitch x := x.(type) {\n-\tcase stringVal:\n-\t\treturn string(x)\n+\tcase *stringVal:\n+\t\treturn x.string()\n \tcase unknownVal:\n \t\treturn \"\"\n \tdefault:\n@@ -856,7 +917,7 @@ func ord(x Value) int {\n \t\treturn -1\n \tcase unknownVal:\n \t\treturn 0\n-\tcase boolVal, stringVal:\n+\tcase boolVal, *stringVal:\n \t\treturn 1\n \tcase int64Val:\n \t\treturn 2\n@@ -884,7 +945,7 @@ func match(x, y Value) (_, _ Value) {\n \t// ord(x) <= ord(y)\n \n \tswitch x := x.(type) {\n-\tcase boolVal, stringVal, complexVal:\n+\tcase boolVal, *stringVal, complexVal:\n \t\treturn x, y\n \n \tcase int64Val:\n@@ -1108,9 +1169,9 @@ func BinaryOp(x_ Value, op token.Token, y_ Value) Value {\n \t\t}\n \t\treturn makeComplex(re, im)\n \n-\tcase stringVal:\n+\tcase *stringVal:\n \t\tif op == token.ADD {\n-\t\t\treturn x + y.(stringVal)\n+\t\t\treturn &stringVal{l: x, r: y.(*stringVal)}\n \t\t}\n \t}\n \n@@ -1236,21 +1297,22 @@ func Compare(x_ Value, op token.Token, y_ Value) bool {\n \t\t\treturn !re || !im\n \t\t}\n \n-\tcase stringVal:\n-\t\ty := y.(stringVal)\n+\tcase *stringVal:\n+\t\txs := x.string()\n+\t\tys := y.(*stringVal).string()\n \t\tswitch op {\n \t\tcase token.EQL:\n-\t\t\treturn x == y\n+\t\t\treturn xs == ys\n \t\tcase token.NEQ:\n-\t\t\treturn x != y\n+\t\t\treturn xs != ys\n \t\tcase token.LSS:\n-\t\t\treturn x < y\n+\t\t\treturn xs < ys\n \t\tcase token.LEQ:\n-\t\t\treturn x <= y\n+\t\t\treturn xs <= ys\n \t\tcase token.GTR:\n-\t\t\treturn x > y\n+\t\t\treturn xs > ys\n \t\tcase token.GEQ:\n-\t\t\treturn x >= y\n+\t\t\treturn xs >= ys\n \t\t}\n \t}\n "}, {"sha": "5ec4f4c41853499140c6e559beb17b2443222bb2", "filename": "libgo/go/go/constant/value_test.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -5,6 +5,7 @@\n package constant\n \n import (\n+\t\"fmt\"\n \t\"go/token\"\n \t\"strings\"\n \t\"testing\"\n@@ -449,3 +450,23 @@ func TestUnknown(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func BenchmarkStringAdd(b *testing.B) {\n+\tfor size := 1; size <= 65536; size *= 4 {\n+\t\tb.Run(fmt.Sprint(size), func(b *testing.B) {\n+\t\t\tb.ReportAllocs()\n+\t\t\tn := int64(0)\n+\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\tx := MakeString(strings.Repeat(\"x\", 100))\n+\t\t\t\ty := x\n+\t\t\t\tfor j := 0; j < size-1; j++ {\n+\t\t\t\t\ty = BinaryOp(y, token.ADD, x)\n+\t\t\t\t}\n+\t\t\t\tn += int64(len(StringVal(y)))\n+\t\t\t}\n+\t\t\tif n != int64(b.N)*int64(size)*100 {\n+\t\t\t\tb.Fatalf(\"bad string %d != %d\", n, int64(b.N)*int64(size)*100)\n+\t\t\t}\n+\t\t})\n+\t}\n+}"}, {"sha": "56e83136fb1a0b09b4c6af27d69eeccf598d9252", "filename": "libgo/go/go/importer/importer_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Fimporter%2Fimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Fimporter%2Fimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fimporter%2Fimporter_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -17,7 +17,7 @@ func TestFor(t *testing.T) {\n \ttestenv.MustHaveGoBuild(t)\n \n \tconst thePackage = \"math/big\"\n-\tout, err := exec.Command(\"go\", \"list\", \"-f={{context.Compiler}}:{{.Target}}\", thePackage).CombinedOutput()\n+\tout, err := exec.Command(testenv.GoToolPath(t), \"list\", \"-f={{context.Compiler}}:{{.Target}}\", thePackage).CombinedOutput()\n \tif err != nil {\n \t\tt.Fatalf(\"go list %s: %v\\n%s\", thePackage, err, out)\n \t}"}, {"sha": "01ab47a445129aae1983f9e8a41a2ef738ff1e7b", "filename": "libgo/go/go/internal/gccgoimporter/importer_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fimporter_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -102,6 +102,7 @@ var importerTests = [...]importerTest{\n \t{pkgpath: \"unicode\", name: \"MaxRune\", want: \"const MaxRune untyped rune\", wantval: \"1114111\"},\n \t{pkgpath: \"imports\", wantinits: []string{\"imports..import\", \"fmt..import\", \"math..import\"}},\n \t{pkgpath: \"alias\", name: \"IntAlias2\", want: \"type IntAlias2 = Int\"},\n+\t{pkgpath: \"escapeinfo\", name: \"NewT\", want: \"func NewT(data []byte) *T\"},\n }\n \n func TestGoxImporter(t *testing.T) {"}, {"sha": "4b3d899efd1bf8d7acc77a6f7fe006944eb32f3e", "filename": "libgo/go/go/internal/gccgoimporter/parser.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -226,6 +226,14 @@ func (p *parser) parseField(pkg *types.Package) (field *types.Var, tag string) {\n // Param = Name [\"...\"] Type .\n func (p *parser) parseParam(pkg *types.Package) (param *types.Var, isVariadic bool) {\n \tname := p.parseName()\n+\tif p.tok == '<' && p.scanner.Peek() == 'e' {\n+\t\t// EscInfo = \"<esc:\" int \">\" . (optional and ignored)\n+\t\tp.next()\n+\t\tp.expectKeyword(\"esc\")\n+\t\tp.expect(':')\n+\t\tp.expect(scanner.Int)\n+\t\tp.expect('>')\n+\t}\n \tif p.tok == '.' {\n \t\tp.next()\n \t\tp.expect('.')"}, {"sha": "ced7d84c4f615ff5437560ef13ead55bce6f8303", "filename": "libgo/go/go/internal/gccgoimporter/testdata/alias.gox", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Ftestdata%2Falias.gox", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Ftestdata%2Falias.gox", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Ftestdata%2Falias.gox?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -0,0 +1,4 @@\n+v1;\n+package alias;\n+pkgpath alias;\n+type <type 115 \"I1\" <type 116 interface { M1 (? <type 117 \"IntAlias2\" = <type 118 \"IntAlias\" = <type 119 \"Int\" <type -11>>>>) < type 114>; M2 () <type 1>; }>>;"}, {"sha": "103ad9549425a64ab94220d1299fc567ead0a37b", "filename": "libgo/go/go/internal/gccgoimporter/testdata/escapeinfo.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Ftestdata%2Fescapeinfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Ftestdata%2Fescapeinfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Ftestdata%2Fescapeinfo.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -0,0 +1,13 @@\n+// Test case for escape info in export data. To compile and extract .gox file:\n+// gccgo -fgo-optimize-allocs -c escapeinfo.go\n+// objcopy -j .go_export escapeinfo.o escapeinfo.gox\n+\n+package escapeinfo\n+\n+type T struct{ data []byte }\n+\n+func NewT(data []byte) *T {\n+\treturn &T{data}\n+}\n+\n+func (*T) Read(p []byte) {}"}, {"sha": "1db81562c1d74a34f1739fd1bf1ac5dd269502d8", "filename": "libgo/go/go/internal/gccgoimporter/testdata/escapeinfo.gox", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Ftestdata%2Fescapeinfo.gox", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Ftestdata%2Fescapeinfo.gox", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Ftestdata%2Fescapeinfo.gox?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5"}, {"sha": "e3ca90a6bdcc43292435ecd65dafeb8c860ae747", "filename": "libgo/go/go/types/check_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -42,7 +42,7 @@ import (\n )\n \n var (\n-\tlistErrors = flag.Bool(\"list\", false, \"list errors\")\n+\tlistErrors = flag.Bool(\"errlist\", false, \"list errors\")\n \ttestFiles  = flag.String(\"files\", \"\", \"space-separated list of test files\")\n )\n "}, {"sha": "59534c75708b959e60a2449c4c457f3d68a8846d", "filename": "libgo/go/go/types/expr.go", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -1194,17 +1194,18 @@ func (check *Checker) exprInternal(x *operand, e ast.Expr, hint Type) exprKind {\n \t\t\t\tif x.mode == constant_ {\n \t\t\t\t\tduplicate := false\n \t\t\t\t\t// if the key is of interface type, the type is also significant when checking for duplicates\n+\t\t\t\t\txkey := keyVal(x.val)\n \t\t\t\t\tif _, ok := utyp.key.Underlying().(*Interface); ok {\n-\t\t\t\t\t\tfor _, vtyp := range visited[x.val] {\n+\t\t\t\t\t\tfor _, vtyp := range visited[xkey] {\n \t\t\t\t\t\t\tif Identical(vtyp, x.typ) {\n \t\t\t\t\t\t\t\tduplicate = true\n \t\t\t\t\t\t\t\tbreak\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tvisited[x.val] = append(visited[x.val], x.typ)\n+\t\t\t\t\t\tvisited[xkey] = append(visited[xkey], x.typ)\n \t\t\t\t\t} else {\n-\t\t\t\t\t\t_, duplicate = visited[x.val]\n-\t\t\t\t\t\tvisited[x.val] = nil\n+\t\t\t\t\t\t_, duplicate = visited[xkey]\n+\t\t\t\t\t\tvisited[xkey] = nil\n \t\t\t\t\t}\n \t\t\t\t\tif duplicate {\n \t\t\t\t\t\tcheck.errorf(x.pos(), \"duplicate key %s in map literal\", x.val)\n@@ -1508,6 +1509,30 @@ Error:\n \treturn statement // avoid follow-up errors\n }\n \n+func keyVal(x constant.Value) interface{} {\n+\tswitch x.Kind() {\n+\tcase constant.Bool:\n+\t\treturn constant.BoolVal(x)\n+\tcase constant.String:\n+\t\treturn constant.StringVal(x)\n+\tcase constant.Int:\n+\t\tif v, ok := constant.Int64Val(x); ok {\n+\t\t\treturn v\n+\t\t}\n+\t\tif v, ok := constant.Uint64Val(x); ok {\n+\t\t\treturn v\n+\t\t}\n+\tcase constant.Float:\n+\t\tv, _ := constant.Float64Val(x)\n+\t\treturn v\n+\tcase constant.Complex:\n+\t\tr, _ := constant.Float64Val(constant.Real(x))\n+\t\ti, _ := constant.Float64Val(constant.Imag(x))\n+\t\treturn complex(r, i)\n+\t}\n+\treturn x\n+}\n+\n // typeAssertion checks that x.(T) is legal; xtyp must be the type of x.\n func (check *Checker) typeAssertion(pos token.Pos, x *operand, xtyp *Interface, T Type) {\n \tmethod, wrongType := assertableTo(xtyp, T)"}, {"sha": "d03c1799af939428be819858b488699f99c349cb", "filename": "libgo/go/go/types/resolver.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Ftypes%2Fresolver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Ftypes%2Fresolver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fresolver.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -417,9 +417,9 @@ func (check *Checker) collectObjects() {\n \t\t\t\t\t// receiver name. They will be type-checked later, with regular\n \t\t\t\t\t// functions.\n \t\t\t\t\tif list := d.Recv.List; len(list) > 0 {\n-\t\t\t\t\t\ttyp := list[0].Type\n+\t\t\t\t\t\ttyp := unparen(list[0].Type)\n \t\t\t\t\t\tif ptr, _ := typ.(*ast.StarExpr); ptr != nil {\n-\t\t\t\t\t\t\ttyp = ptr.X\n+\t\t\t\t\t\t\ttyp = unparen(ptr.X)\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif base, _ := typ.(*ast.Ident); base != nil && base.Name != \"_\" {\n \t\t\t\t\t\t\tcheck.assocMethod(base.Name, obj)"}, {"sha": "8e82c6dcde13625dc6ec5dcf10d0978ebd1058b5", "filename": "libgo/go/go/types/testdata/decls2b.src", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls2b.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls2b.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls2b.src?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -63,3 +63,13 @@ func ((*T7)) m3() {}\n func (x *(T7),) m4() {}\n func (x (*(T7)),) m5() {}\n func (x ((*((T7)))),) m6() {}\n+\n+// Check that methods with parenthesized receiver are actually present (issue #23130).\n+var (\n+\t_ = T7.m1\n+\t_ = T7.m2\n+\t_ = (*T7).m3\n+\t_ = (*T7).m4\n+\t_ = (*T7).m5\n+\t_ = (*T7).m6\n+)\n\\ No newline at end of file"}, {"sha": "b7ab9b38c75cec0285a9143bf463a3fdfeaefccb", "filename": "libgo/go/go/types/testdata/expr3.src", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexpr3.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexpr3.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexpr3.src?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -367,6 +367,10 @@ func map_literals() {\n \t_ = map[interface{}]int{\"a\": 1, \"a\" /* ERROR \"duplicate key\" */ : 1}\n \t_ = map[interface{}]int{\"a\": 1, S(\"a\"): 1}\n \t_ = map[interface{}]int{S(\"a\"): 1, S /* ERROR \"duplicate key\" */ (\"a\"): 1}\n+\t_ = map[interface{}]int{1.0: 1, 1.0 /* ERROR \"duplicate key\" */: 1}\n+\t_ = map[interface{}]int{int64(-1): 1, int64 /* ERROR \"duplicate key\" */ (-1) : 1}\n+\t_ = map[interface{}]int{^uint64(0): 1, ^ /* ERROR \"duplicate key\" */ uint64(0): 1}\n+\t_ = map[interface{}]int{complex(1,2): 1, complex /* ERROR \"duplicate key\" */ (1,2) : 1}\n \n \ttype I interface {\n \t\tf()"}, {"sha": "a58684a535fd4604d4dc4be0040d40452799ef4a", "filename": "libgo/go/go/types/type.go", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Ftypes%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Ftypes%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftype.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -418,7 +418,6 @@ func (t *Named) NumMethods() int { return len(t.methods) }\n func (t *Named) Method(i int) *Func { return t.methods[i] }\n \n // SetUnderlying sets the underlying type and marks t as complete.\n-// TODO(gri) determine if there's a better solution rather than providing this function\n func (t *Named) SetUnderlying(underlying Type) {\n \tif underlying == nil {\n \t\tpanic(\"types.Named.SetUnderlying: underlying type must not be nil\")\n@@ -430,7 +429,6 @@ func (t *Named) SetUnderlying(underlying Type) {\n }\n \n // AddMethod adds method m unless it is already in the method list.\n-// TODO(gri) find a better solution instead of providing this function\n func (t *Named) AddMethod(m *Func) {\n \tif i, _ := lookupMethod(t.methods, m.pkg, m.name); i < 0 {\n \t\tt.methods = append(t.methods, m)"}, {"sha": "07d7078ae25b780534d42cf0347d01f28399f5a4", "filename": "libgo/go/go/types/universe.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Ftypes%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fgo%2Ftypes%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Funiverse.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -20,6 +20,12 @@ var (\n \tuniverseRune *Basic // int32 alias, but has name \"rune\"\n )\n \n+// Typ contains the predeclared *Basic types indexed by their\n+// corresponding BasicKind.\n+//\n+// The *Basic type for Typ[Byte] will have the name \"uint8\".\n+// Use Universe.Lookup(\"byte\").Type() to obtain the specific\n+// alias basic type named \"byte\" (and analogous for \"rune\").\n var Typ = []*Basic{\n \tInvalid: {Invalid, 0, \"invalid type\"},\n "}, {"sha": "92d2789e8041e829264a5a641ecdf06e70c6920e", "filename": "libgo/go/html/template/attr.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fattr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fattr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fattr.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -120,6 +120,7 @@ var attrTypeMap = map[string]contentType{\n \t\"src\":         contentTypeURL,\n \t\"srcdoc\":      contentTypeHTML,\n \t\"srclang\":     contentTypePlain,\n+\t\"srcset\":      contentTypeSrcset,\n \t\"start\":       contentTypePlain,\n \t\"step\":        contentTypePlain,\n \t\"style\":       contentTypeCSS,"}, {"sha": "e7cdedc3b62099f1344bfcce79c411eb219082d8", "filename": "libgo/go/html/template/content.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -83,6 +83,14 @@ type (\n \t// the encapsulated content should come from a trusted source,\n \t// as it will be included verbatim in the template output.\n \tURL string\n+\n+\t// Srcset encapsulates a known safe srcset attribute\n+\t// (see http://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset).\n+\t//\n+\t// Use of this type presents a security risk:\n+\t// the encapsulated content should come from a trusted source,\n+\t// as it will be included verbatim in the template output.\n+\tSrcset string\n )\n \n type contentType uint8\n@@ -95,6 +103,7 @@ const (\n \tcontentTypeJS\n \tcontentTypeJSStr\n \tcontentTypeURL\n+\tcontentTypeSrcset\n \t// contentTypeUnsafe is used in attr.go for values that affect how\n \t// embedded content and network messages are formed, vetted,\n \t// or interpreted; or which credentials network messages carry.\n@@ -156,6 +165,8 @@ func stringify(args ...interface{}) (string, contentType) {\n \t\t\treturn string(s), contentTypeJSStr\n \t\tcase URL:\n \t\t\treturn string(s), contentTypeURL\n+\t\tcase Srcset:\n+\t\t\treturn string(s), contentTypeSrcset\n \t\t}\n \t}\n \tfor i, arg := range args {"}, {"sha": "cc092f50c0c1e4df2f36a8f32fdcb40191b44633", "filename": "libgo/go/html/template/content_test.go", "status": "modified", "additions": 152, "deletions": 14, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -19,7 +19,9 @@ func TestTypedContent(t *testing.T) {\n \t\tHTMLAttr(` dir=\"ltr\"`),\n \t\tJS(`c && alert(\"Hello, World!\");`),\n \t\tJSStr(`Hello, World & O'Reilly\\x21`),\n-\t\tURL(`greeting=H%69&addressee=(World)`),\n+\t\tURL(`greeting=H%69,&addressee=(World)`),\n+\t\tSrcset(`greeting=H%69,&addressee=(World) 2x, https://golang.org/favicon.ico 500.5w`),\n+\t\tURL(`,foo/,`),\n \t}\n \n \t// For each content sensitive escaper, see how it does on\n@@ -40,6 +42,8 @@ func TestTypedContent(t *testing.T) {\n \t\t\t\t`ZgotmplZ`,\n \t\t\t\t`ZgotmplZ`,\n \t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n \t\t\t},\n \t\t},\n \t\t{\n@@ -53,6 +57,8 @@ func TestTypedContent(t *testing.T) {\n \t\t\t\t`ZgotmplZ`,\n \t\t\t\t`ZgotmplZ`,\n \t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n \t\t\t},\n \t\t},\n \t\t{\n@@ -65,7 +71,9 @@ func TestTypedContent(t *testing.T) {\n \t\t\t\t` dir=&#34;ltr&#34;`,\n \t\t\t\t`c &amp;&amp; alert(&#34;Hello, World!&#34;);`,\n \t\t\t\t`Hello, World &amp; O&#39;Reilly\\x21`,\n-\t\t\t\t`greeting=H%69&amp;addressee=(World)`,\n+\t\t\t\t`greeting=H%69,&amp;addressee=(World)`,\n+\t\t\t\t`greeting=H%69,&amp;addressee=(World) 2x, https://golang.org/favicon.ico 500.5w`,\n+\t\t\t\t`,foo/,`,\n \t\t\t},\n \t\t},\n \t\t{\n@@ -79,6 +87,8 @@ func TestTypedContent(t *testing.T) {\n \t\t\t\t`ZgotmplZ`,\n \t\t\t\t`ZgotmplZ`,\n \t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n \t\t\t},\n \t\t},\n \t\t{\n@@ -91,7 +101,9 @@ func TestTypedContent(t *testing.T) {\n \t\t\t\t`&#32;dir&#61;&#34;ltr&#34;`,\n \t\t\t\t`c&#32;&amp;&amp;&#32;alert(&#34;Hello,&#32;World!&#34;);`,\n \t\t\t\t`Hello,&#32;World&#32;&amp;&#32;O&#39;Reilly\\x21`,\n-\t\t\t\t`greeting&#61;H%69&amp;addressee&#61;(World)`,\n+\t\t\t\t`greeting&#61;H%69,&amp;addressee&#61;(World)`,\n+\t\t\t\t`greeting&#61;H%69,&amp;addressee&#61;(World)&#32;2x,&#32;https://golang.org/favicon.ico&#32;500.5w`,\n+\t\t\t\t`,foo/,`,\n \t\t\t},\n \t\t},\n \t\t{\n@@ -104,7 +116,9 @@ func TestTypedContent(t *testing.T) {\n \t\t\t\t` dir=&#34;ltr&#34;`,\n \t\t\t\t`c &amp;&amp; alert(&#34;Hello, World!&#34;);`,\n \t\t\t\t`Hello, World &amp; O&#39;Reilly\\x21`,\n-\t\t\t\t`greeting=H%69&amp;addressee=(World)`,\n+\t\t\t\t`greeting=H%69,&amp;addressee=(World)`,\n+\t\t\t\t`greeting=H%69,&amp;addressee=(World) 2x, https://golang.org/favicon.ico 500.5w`,\n+\t\t\t\t`,foo/,`,\n \t\t\t},\n \t\t},\n \t\t{\n@@ -117,7 +131,9 @@ func TestTypedContent(t *testing.T) {\n \t\t\t\t` dir=&#34;ltr&#34;`,\n \t\t\t\t`c &amp;&amp; alert(&#34;Hello, World!&#34;);`,\n \t\t\t\t`Hello, World &amp; O&#39;Reilly\\x21`,\n-\t\t\t\t`greeting=H%69&amp;addressee=(World)`,\n+\t\t\t\t`greeting=H%69,&amp;addressee=(World)`,\n+\t\t\t\t`greeting=H%69,&amp;addressee=(World) 2x, https://golang.org/favicon.ico 500.5w`,\n+\t\t\t\t`,foo/,`,\n \t\t\t},\n \t\t},\n \t\t{\n@@ -131,7 +147,9 @@ func TestTypedContent(t *testing.T) {\n \t\t\t\t`c && alert(\"Hello, World!\");`,\n \t\t\t\t// Escape sequence not over-escaped.\n \t\t\t\t`\"Hello, World & O'Reilly\\x21\"`,\n-\t\t\t\t`\"greeting=H%69\\u0026addressee=(World)\"`,\n+\t\t\t\t`\"greeting=H%69,\\u0026addressee=(World)\"`,\n+\t\t\t\t`\"greeting=H%69,\\u0026addressee=(World) 2x, https://golang.org/favicon.ico 500.5w\"`,\n+\t\t\t\t`\",foo/,\"`,\n \t\t\t},\n \t\t},\n \t\t{\n@@ -145,7 +163,9 @@ func TestTypedContent(t *testing.T) {\n \t\t\t\t`c &amp;&amp; alert(&#34;Hello, World!&#34;);`,\n \t\t\t\t// Escape sequence not over-escaped.\n \t\t\t\t`&#34;Hello, World &amp; O&#39;Reilly\\x21&#34;`,\n-\t\t\t\t`&#34;greeting=H%69\\u0026addressee=(World)&#34;`,\n+\t\t\t\t`&#34;greeting=H%69,\\u0026addressee=(World)&#34;`,\n+\t\t\t\t`&#34;greeting=H%69,\\u0026addressee=(World) 2x, https://golang.org/favicon.ico 500.5w&#34;`,\n+\t\t\t\t`&#34;,foo/,&#34;`,\n \t\t\t},\n \t\t},\n \t\t{\n@@ -158,7 +178,9 @@ func TestTypedContent(t *testing.T) {\n \t\t\t\t`c \\x26\\x26 alert(\\x22Hello, World!\\x22);`,\n \t\t\t\t// Escape sequence not over-escaped.\n \t\t\t\t`Hello, World \\x26 O\\x27Reilly\\x21`,\n-\t\t\t\t`greeting=H%69\\x26addressee=(World)`,\n+\t\t\t\t`greeting=H%69,\\x26addressee=(World)`,\n+\t\t\t\t`greeting=H%69,\\x26addressee=(World) 2x, https:\\/\\/golang.org\\/favicon.ico 500.5w`,\n+\t\t\t\t`,foo\\/,`,\n \t\t\t},\n \t\t},\n \t\t{\n@@ -171,7 +193,9 @@ func TestTypedContent(t *testing.T) {\n \t\t\t\t`c \\x26\\x26 alert(\\x22Hello, World!\\x22);`,\n \t\t\t\t// Escape sequence not over-escaped.\n \t\t\t\t`Hello, World \\x26 O\\x27Reilly\\x21`,\n-\t\t\t\t`greeting=H%69\\x26addressee=(World)`,\n+\t\t\t\t`greeting=H%69,\\x26addressee=(World)`,\n+\t\t\t\t`greeting=H%69,\\x26addressee=(World) 2x, https:\\/\\/golang.org\\/favicon.ico 500.5w`,\n+\t\t\t\t`,foo\\/,`,\n \t\t\t},\n \t\t},\n \t\t{\n@@ -185,7 +209,9 @@ func TestTypedContent(t *testing.T) {\n \t\t\t\t`c && alert(\"Hello, World!\");`,\n \t\t\t\t// Escape sequence not over-escaped.\n \t\t\t\t`\"Hello, World & O'Reilly\\x21\"`,\n-\t\t\t\t`\"greeting=H%69\\u0026addressee=(World)\"`,\n+\t\t\t\t`\"greeting=H%69,\\u0026addressee=(World)\"`,\n+\t\t\t\t`\"greeting=H%69,\\u0026addressee=(World) 2x, https://golang.org/favicon.ico 500.5w\"`,\n+\t\t\t\t`\",foo/,\"`,\n \t\t\t},\n \t\t},\n \t\t{\n@@ -199,7 +225,9 @@ func TestTypedContent(t *testing.T) {\n \t\t\t\t` dir=&#34;ltr&#34;`,\n \t\t\t\t`c &amp;&amp; alert(&#34;Hello, World!&#34;);`,\n \t\t\t\t`Hello, World &amp; O&#39;Reilly\\x21`,\n-\t\t\t\t`greeting=H%69&amp;addressee=(World)`,\n+\t\t\t\t`greeting=H%69,&amp;addressee=(World)`,\n+\t\t\t\t`greeting=H%69,&amp;addressee=(World) 2x, https://golang.org/favicon.ico 500.5w`,\n+\t\t\t\t`,foo/,`,\n \t\t\t},\n \t\t},\n \t\t{\n@@ -212,7 +240,9 @@ func TestTypedContent(t *testing.T) {\n \t\t\t\t`c \\x26\\x26 alert(\\x22Hello, World!\\x22);`,\n \t\t\t\t// Escape sequence not over-escaped.\n \t\t\t\t`Hello, World \\x26 O\\x27Reilly\\x21`,\n-\t\t\t\t`greeting=H%69\\x26addressee=(World)`,\n+\t\t\t\t`greeting=H%69,\\x26addressee=(World)`,\n+\t\t\t\t`greeting=H%69,\\x26addressee=(World) 2x, https:\\/\\/golang.org\\/favicon.ico 500.5w`,\n+\t\t\t\t`,foo\\/,`,\n \t\t\t},\n \t\t},\n \t\t{\n@@ -225,7 +255,9 @@ func TestTypedContent(t *testing.T) {\n \t\t\t\t`c%20%26%26%20alert%28%22Hello%2c%20World%21%22%29%3b`,\n \t\t\t\t`Hello%2c%20World%20%26%20O%27Reilly%5cx21`,\n \t\t\t\t// Quotes and parens are escaped but %69 is not over-escaped. HTML escaping is done.\n-\t\t\t\t`greeting=H%69&amp;addressee=%28World%29`,\n+\t\t\t\t`greeting=H%69,&amp;addressee=%28World%29`,\n+\t\t\t\t`greeting%3dH%2569%2c%26addressee%3d%28World%29%202x%2c%20https%3a%2f%2fgolang.org%2ffavicon.ico%20500.5w`,\n+\t\t\t\t`,foo/,`,\n \t\t\t},\n \t\t},\n \t\t{\n@@ -238,7 +270,113 @@ func TestTypedContent(t *testing.T) {\n \t\t\t\t`c%20%26%26%20alert%28%22Hello%2c%20World%21%22%29%3b`,\n \t\t\t\t`Hello%2c%20World%20%26%20O%27Reilly%5cx21`,\n \t\t\t\t// Quotes and parens are escaped but %69 is not over-escaped. HTML escaping is not done.\n-\t\t\t\t`greeting=H%69&addressee=%28World%29`,\n+\t\t\t\t`greeting=H%69,&addressee=%28World%29`,\n+\t\t\t\t`greeting%3dH%2569%2c%26addressee%3d%28World%29%202x%2c%20https%3a%2f%2fgolang.org%2ffavicon.ico%20500.5w`,\n+\t\t\t\t`,foo/,`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<img srcset=\"{{.}}\">`,\n+\t\t\t[]string{\n+\t\t\t\t`#ZgotmplZ`,\n+\t\t\t\t`#ZgotmplZ`,\n+\t\t\t\t// Commas are not esacped\n+\t\t\t\t`Hello,#ZgotmplZ`,\n+\t\t\t\t// Leading spaces are not percent escapes.\n+\t\t\t\t` dir=%22ltr%22`,\n+\t\t\t\t// Spaces after commas are not percent escaped.\n+\t\t\t\t`#ZgotmplZ, World!%22%29;`,\n+\t\t\t\t`Hello,#ZgotmplZ`,\n+\t\t\t\t`greeting=H%69%2c&amp;addressee=%28World%29`,\n+\t\t\t\t// Metadata is not escaped.\n+\t\t\t\t`greeting=H%69,&amp;addressee=(World) 2x, https://golang.org/favicon.ico 500.5w`,\n+\t\t\t\t`%2cfoo/%2c`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<img srcset={{.}}>`,\n+\t\t\t[]string{\n+\t\t\t\t`#ZgotmplZ`,\n+\t\t\t\t`#ZgotmplZ`,\n+\t\t\t\t`Hello,#ZgotmplZ`,\n+\t\t\t\t// Spaces are HTML escaped not %-escaped\n+\t\t\t\t`&#32;dir&#61;%22ltr%22`,\n+\t\t\t\t`#ZgotmplZ,&#32;World!%22%29;`,\n+\t\t\t\t`Hello,#ZgotmplZ`,\n+\t\t\t\t`greeting&#61;H%69%2c&amp;addressee&#61;%28World%29`,\n+\t\t\t\t`greeting&#61;H%69,&amp;addressee&#61;(World)&#32;2x,&#32;https://golang.org/favicon.ico&#32;500.5w`,\n+\t\t\t\t// Commas are escaped.\n+\t\t\t\t`%2cfoo/%2c`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<img srcset=\"{{.}} 2x, https://golang.org/ 500.5w\">`,\n+\t\t\t[]string{\n+\t\t\t\t`#ZgotmplZ`,\n+\t\t\t\t`#ZgotmplZ`,\n+\t\t\t\t`Hello,#ZgotmplZ`,\n+\t\t\t\t` dir=%22ltr%22`,\n+\t\t\t\t`#ZgotmplZ, World!%22%29;`,\n+\t\t\t\t`Hello,#ZgotmplZ`,\n+\t\t\t\t`greeting=H%69%2c&amp;addressee=%28World%29`,\n+\t\t\t\t`greeting=H%69,&amp;addressee=(World) 2x, https://golang.org/favicon.ico 500.5w`,\n+\t\t\t\t`%2cfoo/%2c`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<img srcset=\"http://godoc.org/ {{.}}, https://golang.org/ 500.5w\">`,\n+\t\t\t[]string{\n+\t\t\t\t`#ZgotmplZ`,\n+\t\t\t\t`#ZgotmplZ`,\n+\t\t\t\t`Hello,#ZgotmplZ`,\n+\t\t\t\t` dir=%22ltr%22`,\n+\t\t\t\t`#ZgotmplZ, World!%22%29;`,\n+\t\t\t\t`Hello,#ZgotmplZ`,\n+\t\t\t\t`greeting=H%69%2c&amp;addressee=%28World%29`,\n+\t\t\t\t`greeting=H%69,&amp;addressee=(World) 2x, https://golang.org/favicon.ico 500.5w`,\n+\t\t\t\t`%2cfoo/%2c`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<img srcset=\"http://godoc.org/?q={{.}} 2x, https://golang.org/ 500.5w\">`,\n+\t\t\t[]string{\n+\t\t\t\t`#ZgotmplZ`,\n+\t\t\t\t`#ZgotmplZ`,\n+\t\t\t\t`Hello,#ZgotmplZ`,\n+\t\t\t\t` dir=%22ltr%22`,\n+\t\t\t\t`#ZgotmplZ, World!%22%29;`,\n+\t\t\t\t`Hello,#ZgotmplZ`,\n+\t\t\t\t`greeting=H%69%2c&amp;addressee=%28World%29`,\n+\t\t\t\t`greeting=H%69,&amp;addressee=(World) 2x, https://golang.org/favicon.ico 500.5w`,\n+\t\t\t\t`%2cfoo/%2c`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<img srcset=\"http://godoc.org/ 2x, {{.}} 500.5w\">`,\n+\t\t\t[]string{\n+\t\t\t\t`#ZgotmplZ`,\n+\t\t\t\t`#ZgotmplZ`,\n+\t\t\t\t`Hello,#ZgotmplZ`,\n+\t\t\t\t` dir=%22ltr%22`,\n+\t\t\t\t`#ZgotmplZ, World!%22%29;`,\n+\t\t\t\t`Hello,#ZgotmplZ`,\n+\t\t\t\t`greeting=H%69%2c&amp;addressee=%28World%29`,\n+\t\t\t\t`greeting=H%69,&amp;addressee=(World) 2x, https://golang.org/favicon.ico 500.5w`,\n+\t\t\t\t`%2cfoo/%2c`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<img srcset=\"http://godoc.org/ 2x, https://golang.org/ {{.}}\">`,\n+\t\t\t[]string{\n+\t\t\t\t`#ZgotmplZ`,\n+\t\t\t\t`#ZgotmplZ`,\n+\t\t\t\t`Hello,#ZgotmplZ`,\n+\t\t\t\t` dir=%22ltr%22`,\n+\t\t\t\t`#ZgotmplZ, World!%22%29;`,\n+\t\t\t\t`Hello,#ZgotmplZ`,\n+\t\t\t\t`greeting=H%69%2c&amp;addressee=%28World%29`,\n+\t\t\t\t`greeting=H%69,&amp;addressee=(World) 2x, https://golang.org/favicon.ico 500.5w`,\n+\t\t\t\t`%2cfoo/%2c`,\n \t\t\t},\n \t\t},\n \t}"}, {"sha": "50730d3f2b775d1676880ad6268038ab2a6dbcfd", "filename": "libgo/go/html/template/context.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontext.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontext.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontext.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -102,6 +102,8 @@ const (\n \tstateAttr\n \t// stateURL occurs inside an HTML attribute whose content is a URL.\n \tstateURL\n+\t// stateSrcset occurs inside an HTML srcset attribute.\n+\tstateSrcset\n \t// stateJS occurs inside an event handler or script element.\n \tstateJS\n \t// stateJSDqStr occurs inside a JavaScript double quoted string.\n@@ -145,6 +147,7 @@ var stateNames = [...]string{\n \tstateRCDATA:      \"stateRCDATA\",\n \tstateAttr:        \"stateAttr\",\n \tstateURL:         \"stateURL\",\n+\tstateSrcset:      \"stateSrcset\",\n \tstateJS:          \"stateJS\",\n \tstateJSDqStr:     \"stateJSDqStr\",\n \tstateJSSqStr:     \"stateJSSqStr\",\n@@ -326,6 +329,8 @@ const (\n \tattrStyle\n \t// attrURL corresponds to an attribute whose value is a URL.\n \tattrURL\n+\t// attrSrcset corresponds to a srcset attribute.\n+\tattrSrcset\n )\n \n var attrNames = [...]string{\n@@ -334,6 +339,7 @@ var attrNames = [...]string{\n \tattrScriptType: \"attrScriptType\",\n \tattrStyle:      \"attrStyle\",\n \tattrURL:        \"attrURL\",\n+\tattrSrcset:     \"attrSrcset\",\n }\n \n func (a attr) String() string {"}, {"sha": "5963194be6fe326ad4824b6679d7c247540a0b56", "filename": "libgo/go/html/template/escape.go", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -71,6 +71,7 @@ var funcMap = template.FuncMap{\n \t\"_html_template_jsvalescaper\":    jsValEscaper,\n \t\"_html_template_nospaceescaper\":  htmlNospaceEscaper,\n \t\"_html_template_rcdataescaper\":   rcdataEscaper,\n+\t\"_html_template_srcsetescaper\":   srcsetFilterAndEscaper,\n \t\"_html_template_urlescaper\":      urlEscaper,\n \t\"_html_template_urlfilter\":       urlFilter,\n \t\"_html_template_urlnormalizer\":   urlNormalizer,\n@@ -215,6 +216,8 @@ func (e *escaper) escapeAction(c context, n *parse.ActionNode) context {\n \tcase stateAttrName, stateTag:\n \t\tc.state = stateAttrName\n \t\ts = append(s, \"_html_template_htmlnamefilter\")\n+\tcase stateSrcset:\n+\t\ts = append(s, \"_html_template_srcsetescaper\")\n \tdefault:\n \t\tif isComment(c.state) {\n \t\t\ts = append(s, \"_html_template_commentescaper\")\n@@ -280,9 +283,22 @@ func ensurePipelineContains(p *parse.PipeNode, s []string) {\n \t}\n \t// Rewrite the pipeline, creating the escapers in s at the end of the pipeline.\n \tnewCmds := make([]*parse.CommandNode, pipelineLen, pipelineLen+len(s))\n-\tcopy(newCmds, p.Cmds)\n+\tinsertedIdents := make(map[string]bool)\n+\tfor i := 0; i < pipelineLen; i++ {\n+\t\tcmd := p.Cmds[i]\n+\t\tnewCmds[i] = cmd\n+\t\tif idNode, ok := cmd.Args[0].(*parse.IdentifierNode); ok {\n+\t\t\tinsertedIdents[normalizeEscFn(idNode.Ident)] = true\n+\t\t}\n+\t}\n \tfor _, name := range s {\n-\t\tnewCmds = appendCmd(newCmds, newIdentCmd(name, p.Position()))\n+\t\tif !insertedIdents[normalizeEscFn(name)] {\n+\t\t\t// When two templates share an underlying parse tree via the use of\n+\t\t\t// AddParseTree and one template is executed after the other, this check\n+\t\t\t// ensures that escapers that were already inserted into the pipeline on\n+\t\t\t// the first escaping pass do not get inserted again.\n+\t\t\tnewCmds = appendCmd(newCmds, newIdentCmd(name, p.Position()))\n+\t\t}\n \t}\n \tp.Cmds = newCmds\n }\n@@ -317,13 +333,16 @@ var equivEscapers = map[string]string{\n \n // escFnsEq reports whether the two escaping functions are equivalent.\n func escFnsEq(a, b string) bool {\n-\tif e := equivEscapers[a]; e != \"\" {\n-\t\ta = e\n-\t}\n-\tif e := equivEscapers[b]; e != \"\" {\n-\t\tb = e\n+\treturn normalizeEscFn(a) == normalizeEscFn(b)\n+}\n+\n+// normalizeEscFn(a) is equal to normalizeEscFn(b) for any pair of names of\n+// escaper functions a and b that are equivalent.\n+func normalizeEscFn(e string) string {\n+\tif norm := equivEscapers[e]; norm != \"\" {\n+\t\treturn norm\n \t}\n-\treturn a == b\n+\treturn e\n }\n \n // redundantFuncs[a][b] implies that funcMap[b](funcMap[a](x)) == funcMap[a](x)"}, {"sha": "55f808ccba8b656552a37eeda3b8e105faee0a39", "filename": "libgo/go/html/template/escape_test.go", "status": "modified", "additions": 60, "deletions": 17, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -650,6 +650,12 @@ func TestEscape(t *testing.T) {\n \t\t\t`<{{\"script\"}}>{{\"doEvil()\"}}</{{\"script\"}}>`,\n \t\t\t`&lt;script>doEvil()&lt;/script>`,\n \t\t},\n+\t\t{\n+\t\t\t\"srcset bad URL in second position\",\n+\t\t\t`<img srcset=\"{{\"/not-an-image#,javascript:alert(1)\"}}\">`,\n+\t\t\t// The second URL is also filtered.\n+\t\t\t`<img srcset=\"/not-an-image#,#ZgotmplZ\">`,\n+\t\t},\n \t}\n \n \tfor _, test := range tests {\n@@ -1840,7 +1846,7 @@ func TestErrorOnUndefined(t *testing.T) {\n \n \terr := tmpl.Execute(nil, nil)\n \tif err == nil {\n-\t\tt.Fatal(\"expected error\")\n+\t\tt.Error(\"expected error\")\n \t}\n \tif !strings.Contains(err.Error(), \"incomplete\") {\n \t\tt.Errorf(\"expected error about incomplete template; got %s\", err)\n@@ -1860,18 +1866,18 @@ func TestIdempotentExecute(t *testing.T) {\n \tfor i := 0; i < 2; i++ {\n \t\terr = tmpl.ExecuteTemplate(got, \"hello\", nil)\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n+\t\t\tt.Errorf(\"unexpected error: %s\", err)\n \t\t}\n \t\tif got.String() != want {\n-\t\t\tt.Fatalf(\"after executing template \\\"hello\\\", got:\\n\\t%q\\nwant:\\n\\t%q\\n\", got.String(), want)\n+\t\t\tt.Errorf(\"after executing template \\\"hello\\\", got:\\n\\t%q\\nwant:\\n\\t%q\\n\", got.String(), want)\n \t\t}\n \t\tgot.Reset()\n \t}\n \t// Ensure that the implicit re-execution of \"hello\" during the execution of\n \t// \"main\" does not cause the output of \"hello\" to change.\n \terr = tmpl.ExecuteTemplate(got, \"main\", nil)\n \tif err != nil {\n-\t\tt.Fatalf(\"unexpected error: %s\", err)\n+\t\tt.Errorf(\"unexpected error: %s\", err)\n \t}\n \t// If the HTML escaper is added again to the action {{\"Ladies & Gentlemen!\"}},\n \t// we would expected to see the ampersand overescaped to \"&amp;amp;\".\n@@ -1881,19 +1887,6 @@ func TestIdempotentExecute(t *testing.T) {\n \t}\n }\n \n-// This covers issue #21844.\n-func TestAddExistingTreeError(t *testing.T) {\n-\ttmpl := Must(New(\"foo\").Parse(`<p>{{.}}</p>`))\n-\ttmpl, err := tmpl.AddParseTree(\"bar\", tmpl.Tree)\n-\tif err == nil {\n-\t\tt.Fatalf(\"expected error after AddParseTree\")\n-\t}\n-\tconst want = `html/template: cannot add parse tree that template \"foo\" already references`\n-\tif got := err.Error(); got != want {\n-\t\tt.Errorf(\"got error:\\n\\t%q\\nwant:\\n\\t%q\\n\", got, want)\n-\t}\n-}\n-\n func BenchmarkEscapedExecute(b *testing.B) {\n \ttmpl := Must(New(\"t\").Parse(`<a onclick=\"alert('{{.}}')\">{{.}}</a>`))\n \tvar buf bytes.Buffer\n@@ -1903,3 +1896,53 @@ func BenchmarkEscapedExecute(b *testing.B) {\n \t\tbuf.Reset()\n \t}\n }\n+\n+// Covers issue 22780.\n+func TestOrphanedTemplate(t *testing.T) {\n+\tt1 := Must(New(\"foo\").Parse(`<a href=\"{{.}}\">link1</a>`))\n+\tt2 := Must(t1.New(\"foo\").Parse(`bar`))\n+\n+\tvar b bytes.Buffer\n+\tconst wantError = `template: \"foo\" is an incomplete or empty template`\n+\tif err := t1.Execute(&b, \"javascript:alert(1)\"); err == nil {\n+\t\tt.Fatal(\"expected error executing t1\")\n+\t} else if gotError := err.Error(); gotError != wantError {\n+\t\tt.Fatalf(\"got t1 execution error:\\n\\t%s\\nwant:\\n\\t%s\", gotError, wantError)\n+\t}\n+\tb.Reset()\n+\tif err := t2.Execute(&b, nil); err != nil {\n+\t\tt.Fatalf(\"error executing t2: %s\", err)\n+\t}\n+\tconst want = \"bar\"\n+\tif got := b.String(); got != want {\n+\t\tt.Fatalf(\"t2 rendered %q, want %q\", got, want)\n+\t}\n+}\n+\n+// Covers issue 21844.\n+func TestAliasedParseTreeDoesNotOverescape(t *testing.T) {\n+\tconst (\n+\t\ttmplText = `{{.}}`\n+\t\tdata     = `<baz>`\n+\t\twant     = `&lt;baz&gt;`\n+\t)\n+\t// Templates \"foo\" and \"bar\" both alias the same underlying parse tree.\n+\ttpl := Must(New(\"foo\").Parse(tmplText))\n+\tif _, err := tpl.AddParseTree(\"bar\", tpl.Tree); err != nil {\n+\t\tt.Fatalf(\"AddParseTree error: %v\", err)\n+\t}\n+\tvar b1, b2 bytes.Buffer\n+\tif err := tpl.ExecuteTemplate(&b1, \"foo\", data); err != nil {\n+\t\tt.Fatalf(`ExecuteTemplate failed for \"foo\": %v`, err)\n+\t}\n+\tif err := tpl.ExecuteTemplate(&b2, \"bar\", data); err != nil {\n+\t\tt.Fatalf(`ExecuteTemplate failed for \"foo\": %v`, err)\n+\t}\n+\tgot1, got2 := b1.String(), b2.String()\n+\tif got1 != want {\n+\t\tt.Fatalf(`Template \"foo\" rendered %q, want %q`, got1, want)\n+\t}\n+\tif got1 != got2 {\n+\t\tt.Fatalf(`Template \"foo\" and \"bar\" rendered %q and %q respectively, expected equal values`, got1, got2)\n+\t}\n+}"}, {"sha": "4641a37da3cddbc12d83b08cca835f4469082ced", "filename": "libgo/go/html/template/template.go", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -219,11 +219,6 @@ func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error\n \n \tt.nameSpace.mu.Lock()\n \tdefer t.nameSpace.mu.Unlock()\n-\tfor _, tmpl := range t.set {\n-\t\tif tmpl.Tree == tree {\n-\t\t\treturn nil, fmt.Errorf(\"html/template: cannot add parse tree that template %q already references\", tmpl.Name())\n-\t\t}\n-\t}\n \ttext, err := t.text.AddParseTree(name, tree)\n \tif err != nil {\n \t\treturn nil, err\n@@ -300,6 +295,10 @@ func New(name string) *Template {\n // New allocates a new HTML template associated with the given one\n // and with the same delimiters. The association, which is transitive,\n // allows one template to invoke another with a {{template}} action.\n+//\n+// If a template with the given name already exists, the new HTML template\n+// will replace it. The existing template will be reset and disassociated with\n+// t.\n func (t *Template) New(name string) *Template {\n \tt.nameSpace.mu.Lock()\n \tdefer t.nameSpace.mu.Unlock()\n@@ -314,6 +313,10 @@ func (t *Template) new(name string) *Template {\n \t\tnil,\n \t\tt.nameSpace,\n \t}\n+\tif existing, ok := tmpl.set[name]; ok {\n+\t\temptyTmpl := New(existing.Name())\n+\t\t*existing = *emptyTmpl\n+\t}\n \ttmpl.set[name] = tmpl\n \treturn tmpl\n }"}, {"sha": "c72cf1ea60ef0a50f83802bdad161dbe826ba741", "filename": "libgo/go/html/template/transition.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftransition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftransition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftransition.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -23,6 +23,7 @@ var transitionFunc = [...]func(context, []byte) (context, int){\n \tstateRCDATA:      tSpecialTagEnd,\n \tstateAttr:        tAttr,\n \tstateURL:         tURL,\n+\tstateSrcset:      tURL,\n \tstateJS:          tJS,\n \tstateJSDqStr:     tJSDelimited,\n \tstateJSSqStr:     tJSDelimited,\n@@ -117,6 +118,8 @@ func tTag(c context, s []byte) (context, int) {\n \t\t\tattr = attrStyle\n \t\tcase contentTypeJS:\n \t\t\tattr = attrScript\n+\t\tcase contentTypeSrcset:\n+\t\t\tattr = attrSrcset\n \t\t}\n \t}\n \n@@ -161,6 +164,7 @@ var attrStartStates = [...]state{\n \tattrScriptType: stateAttr,\n \tattrStyle:      stateCSS,\n \tattrURL:        stateURL,\n+\tattrSrcset:     stateSrcset,\n }\n \n // tBeforeValue is the context transition function for stateBeforeValue."}, {"sha": "69a6ff49b844cd6714081c8f43fe1d1f4373eee2", "filename": "libgo/go/html/template/url.go", "status": "modified", "additions": 101, "deletions": 7, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Furl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Furl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Furl.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -37,13 +37,23 @@ func urlFilter(args ...interface{}) string {\n \tif t == contentTypeURL {\n \t\treturn s\n \t}\n+\tif !isSafeUrl(s) {\n+\t\treturn \"#\" + filterFailsafe\n+\t}\n+\treturn s\n+}\n+\n+// isSafeUrl is true if s is a relative URL or if URL has a protocol in\n+// (http, https, mailto).\n+func isSafeUrl(s string) bool {\n \tif i := strings.IndexRune(s, ':'); i >= 0 && !strings.ContainsRune(s[:i], '/') {\n-\t\tprotocol := strings.ToLower(s[:i])\n-\t\tif protocol != \"http\" && protocol != \"https\" && protocol != \"mailto\" {\n-\t\t\treturn \"#\" + filterFailsafe\n+\n+\t\tprotocol := s[:i]\n+\t\tif !strings.EqualFold(protocol, \"http\") && !strings.EqualFold(protocol, \"https\") && !strings.EqualFold(protocol, \"mailto\") {\n+\t\t\treturn false\n \t\t}\n \t}\n-\treturn s\n+\treturn true\n }\n \n // urlEscaper produces an output that can be embedded in a URL query.\n@@ -69,6 +79,16 @@ func urlProcessor(norm bool, args ...interface{}) string {\n \t\tnorm = true\n \t}\n \tvar b bytes.Buffer\n+\tif processUrlOnto(s, norm, &b) {\n+\t\treturn b.String()\n+\t}\n+\treturn s\n+}\n+\n+// processUrlOnto appends a normalized URL corresponding to its input to b\n+// and returns true if the appended content differs from s.\n+func processUrlOnto(s string, norm bool, b *bytes.Buffer) bool {\n+\tb.Grow(b.Cap() + len(s) + 16)\n \twritten := 0\n \t// The byte loop below assumes that all URLs use UTF-8 as the\n \t// content-encoding. This is similar to the URI to IRI encoding scheme\n@@ -114,12 +134,86 @@ func urlProcessor(norm bool, args ...interface{}) string {\n \t\t\t}\n \t\t}\n \t\tb.WriteString(s[written:i])\n-\t\tfmt.Fprintf(&b, \"%%%02x\", c)\n+\t\tfmt.Fprintf(b, \"%%%02x\", c)\n \t\twritten = i + 1\n \t}\n-\tif written == 0 {\n+\tb.WriteString(s[written:])\n+\treturn written != 0\n+}\n+\n+// Filters and normalizes srcset values which are comma separated\n+// URLs followed by metadata.\n+func srcsetFilterAndEscaper(args ...interface{}) string {\n+\ts, t := stringify(args...)\n+\tswitch t {\n+\tcase contentTypeSrcset:\n \t\treturn s\n+\tcase contentTypeURL:\n+\t\t// Normalizing gets rid of all HTML whitespace\n+\t\t// which separate the image URL from its metadata.\n+\t\tvar b bytes.Buffer\n+\t\tif processUrlOnto(s, true, &b) {\n+\t\t\ts = b.String()\n+\t\t}\n+\t\t// Additionally, commas separate one source from another.\n+\t\treturn strings.Replace(s, \",\", \"%2c\", -1)\n \t}\n-\tb.WriteString(s[written:])\n+\n+\tvar b bytes.Buffer\n+\twritten := 0\n+\tfor i := 0; i < len(s); i++ {\n+\t\tif s[i] == ',' {\n+\t\t\tfilterSrcsetElement(s, written, i, &b)\n+\t\t\tb.WriteString(\",\")\n+\t\t\twritten = i + 1\n+\t\t}\n+\t}\n+\tfilterSrcsetElement(s, written, len(s), &b)\n \treturn b.String()\n }\n+\n+// Derived from https://play.golang.org/p/Dhmj7FORT5\n+const htmlSpaceAndAsciiAlnumBytes = \"\\x00\\x36\\x00\\x00\\x01\\x00\\xff\\x03\\xfe\\xff\\xff\\x07\\xfe\\xff\\xff\\x07\"\n+\n+// isHtmlSpace is true iff c is a whitespace character per\n+// https://infra.spec.whatwg.org/#ascii-whitespace\n+func isHtmlSpace(c byte) bool {\n+\treturn (c <= 0x20) && 0 != (htmlSpaceAndAsciiAlnumBytes[c>>3]&(1<<uint(c&0x7)))\n+}\n+\n+func isHtmlSpaceOrAsciiAlnum(c byte) bool {\n+\treturn (c < 0x80) && 0 != (htmlSpaceAndAsciiAlnumBytes[c>>3]&(1<<uint(c&0x7)))\n+}\n+\n+func filterSrcsetElement(s string, left int, right int, b *bytes.Buffer) {\n+\tstart := left\n+\tfor start < right && isHtmlSpace(s[start]) {\n+\t\tstart += 1\n+\t}\n+\tend := right\n+\tfor i := start; i < right; i++ {\n+\t\tif isHtmlSpace(s[i]) {\n+\t\t\tend = i\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif url := s[start:end]; isSafeUrl(url) {\n+\t\t// If image metadata is only spaces or alnums then\n+\t\t// we don't need to URL normalize it.\n+\t\tmetadataOk := true\n+\t\tfor i := end; i < right; i++ {\n+\t\t\tif !isHtmlSpaceOrAsciiAlnum(s[i]) {\n+\t\t\t\tmetadataOk = false\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif metadataOk {\n+\t\t\tb.WriteString(s[left:start])\n+\t\t\tprocessUrlOnto(url, true, b)\n+\t\t\tb.WriteString(s[end:right])\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tb.WriteString(\"#\")\n+\tb.WriteString(filterFailsafe)\n+}"}, {"sha": "75c354eba87de41a8d4a8d4c4fc4fe8a0822d685", "filename": "libgo/go/html/template/url_test.go", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Furl_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fhtml%2Ftemplate%2Furl_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Furl_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -87,6 +87,51 @@ func TestURLFilters(t *testing.T) {\n \t}\n }\n \n+func TestSrcsetFilter(t *testing.T) {\n+\ttests := []struct {\n+\t\tname  string\n+\t\tinput string\n+\t\twant  string\n+\t}{\n+\t\t{\n+\t\t\t\"one ok\",\n+\t\t\t\"http://example.com/img.png\",\n+\t\t\t\"http://example.com/img.png\",\n+\t\t},\n+\t\t{\n+\t\t\t\"one ok with metadata\",\n+\t\t\t\" /img.png 200w\",\n+\t\t\t\" /img.png 200w\",\n+\t\t},\n+\t\t{\n+\t\t\t\"one bad\",\n+\t\t\t\"javascript:alert(1) 200w\",\n+\t\t\t\"#ZgotmplZ\",\n+\t\t},\n+\t\t{\n+\t\t\t\"two ok\",\n+\t\t\t\"foo.png, bar.png\",\n+\t\t\t\"foo.png, bar.png\",\n+\t\t},\n+\t\t{\n+\t\t\t\"left bad\",\n+\t\t\t\"javascript:alert(1), /foo.png\",\n+\t\t\t\"#ZgotmplZ, /foo.png\",\n+\t\t},\n+\t\t{\n+\t\t\t\"right bad\",\n+\t\t\t\"/bogus#, javascript:alert(1)\",\n+\t\t\t\"/bogus#,#ZgotmplZ\",\n+\t\t},\n+\t}\n+\n+\tfor _, test := range tests {\n+\t\tif got := srcsetFilterAndEscaper(test.input); got != test.want {\n+\t\t\tt.Errorf(\"%s: srcsetFilterAndEscaper(%q) want %q != %q\", test.name, test.input, test.want, got)\n+\t\t}\n+\t}\n+}\n+\n func BenchmarkURLEscaper(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\turlEscaper(\"http://example.com:80/foo?q=bar%20&baz=x+y#frag\")\n@@ -110,3 +155,15 @@ func BenchmarkURLNormalizerNoSpecials(b *testing.B) {\n \t\turlNormalizer(\"http://example.com:80/foo?q=bar%20&baz=x+y#frag\")\n \t}\n }\n+\n+func BenchmarkSrcsetFilter(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tsrcsetFilterAndEscaper(\" /foo/bar.png 200w, /baz/boo(1).png\")\n+\t}\n+}\n+\n+func BenchmarkSrcsetFilterNoSpecials(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tsrcsetFilterAndEscaper(\"http://example.com:80/foo?q=bar%20&baz=x+y#frag\")\n+\t}\n+}"}, {"sha": "2ba7de7da376b81a90c06d61e6ad3a86afb89d13", "filename": "libgo/go/internal/poll/fd_mutex.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_mutex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_mutex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_mutex.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -65,7 +65,7 @@ func (mu *fdMutex) incref() bool {\n }\n \n // increfAndClose sets the state of mu to closed.\n-// It reports whether there is no remaining reference.\n+// It returns false if the file was already closed.\n func (mu *fdMutex) increfAndClose() bool {\n \tfor {\n \t\told := atomic.LoadUint64(&mu.state)"}, {"sha": "cfd441e735e0aa97ef260c89f65dc2f039c9e5a7", "filename": "libgo/go/internal/poll/fd_unix.go", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_unix.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -40,6 +40,9 @@ type FD struct {\n \n \t// Whether this is a file rather than a network socket.\n \tisFile bool\n+\n+\t// Whether this file has been set to blocking mode.\n+\tisBlocking bool\n }\n \n // Init initializes the FD. The Sysfd field should already be set.\n@@ -53,6 +56,7 @@ func (fd *FD) Init(net string, pollable bool) error {\n \t\tfd.isFile = true\n \t}\n \tif !pollable {\n+\t\tfd.isBlocking = true\n \t\treturn nil\n \t}\n \treturn fd.pd.init(fd)\n@@ -76,18 +80,26 @@ func (fd *FD) Close() error {\n \tif !fd.fdmu.increfAndClose() {\n \t\treturn errClosing(fd.isFile)\n \t}\n+\n \t// Unblock any I/O.  Once it all unblocks and returns,\n \t// so that it cannot be referring to fd.sysfd anymore,\n \t// the final decref will close fd.sysfd. This should happen\n \t// fairly quickly, since all the I/O is non-blocking, and any\n \t// attempts to block in the pollDesc will return errClosing(fd.isFile).\n \tfd.pd.evict()\n+\n \t// The call to decref will call destroy if there are no other\n \t// references.\n \terr := fd.decref()\n+\n \t// Wait until the descriptor is closed. If this was the only\n-\t// reference, it is already closed.\n-\truntime_Semacquire(&fd.csema)\n+\t// reference, it is already closed. Only wait if the file has\n+\t// not been set to blocking mode, as otherwise any current I/O\n+\t// may be blocking, and that would block the Close.\n+\tif !fd.isBlocking {\n+\t\truntime_Semacquire(&fd.csema)\n+\t}\n+\n \treturn err\n }\n \n@@ -100,6 +112,16 @@ func (fd *FD) Shutdown(how int) error {\n \treturn syscall.Shutdown(fd.Sysfd, how)\n }\n \n+// SetBlocking puts the file into blocking mode.\n+func (fd *FD) SetBlocking() error {\n+\tif err := fd.incref(); err != nil {\n+\t\treturn err\n+\t}\n+\tdefer fd.decref()\n+\tfd.isBlocking = true\n+\treturn syscall.SetNonblock(fd.Sysfd, false)\n+}\n+\n // Darwin and FreeBSD can't read or write 2GB+ files at a time,\n // even on 64-bit systems.\n // The same is true of socket implementations on many systems."}, {"sha": "1e9960d575d4c7219fcf5cbb5e20ab44b5bddb12", "filename": "libgo/go/internal/singleflight/singleflight.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Finternal%2Fsingleflight%2Fsingleflight.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Finternal%2Fsingleflight%2Fsingleflight.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fsingleflight%2Fsingleflight.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -65,8 +65,10 @@ func (g *Group) Do(key string, fn func() (interface{}, error)) (v interface{}, e\n }\n \n // DoChan is like Do but returns a channel that will receive the\n-// results when they are ready.\n-func (g *Group) DoChan(key string, fn func() (interface{}, error)) <-chan Result {\n+// results when they are ready. The second result is true if the function\n+// will eventually be called, false if it will not (because there is\n+// a pending request with this key).\n+func (g *Group) DoChan(key string, fn func() (interface{}, error)) (<-chan Result, bool) {\n \tch := make(chan Result, 1)\n \tg.mu.Lock()\n \tif g.m == nil {\n@@ -76,7 +78,7 @@ func (g *Group) DoChan(key string, fn func() (interface{}, error)) <-chan Result\n \t\tc.dups++\n \t\tc.chans = append(c.chans, ch)\n \t\tg.mu.Unlock()\n-\t\treturn ch\n+\t\treturn ch, false\n \t}\n \tc := &call{chans: []chan<- Result{ch}}\n \tc.wg.Add(1)\n@@ -85,7 +87,7 @@ func (g *Group) DoChan(key string, fn func() (interface{}, error)) <-chan Result\n \n \tgo g.doCall(c, key, fn)\n \n-\treturn ch\n+\treturn ch, true\n }\n \n // doCall handles the single call for a key."}, {"sha": "385397378d1f284692548f0eefd8d5624ccda118", "filename": "libgo/go/internal/testenv/testenv_notwin.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv_notwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv_notwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv_notwin.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -18,3 +18,7 @@ func hasSymlink() (ok bool, reason string) {\n \n \treturn true, \"\"\n }\n+\n+func IsWindowsXP() bool {\n+\treturn false\n+}"}, {"sha": "4a7da5fcb64a71ed79385e8d446fd691dafd6833", "filename": "libgo/go/internal/testenv/testenv_windows.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv_windows.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -46,3 +46,12 @@ func hasSymlink() (ok bool, reason string) {\n \n \treturn false, \"\"\n }\n+\n+func IsWindowsXP() bool {\n+\tv, err := syscall.GetVersion()\n+\tif err != nil {\n+\t\tpanic(\"GetVersion failed: \" + err.Error())\n+\t}\n+\tmajor := byte(v)\n+\treturn major < 6\n+}"}, {"sha": "3c5f780ac4d62b28b790e0c0d1a28e64deb5c681", "filename": "libgo/go/internal/testlog/log.go", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Finternal%2Ftestlog%2Flog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Finternal%2Ftestlog%2Flog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Ftestlog%2Flog.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package testlog provides a back-channel communication path\n+// between tests and package os, so that cmd/go can see which\n+// environment variables and files a test consults.\n+package testlog\n+\n+import \"sync/atomic\"\n+\n+// Interface is the interface required of test loggers.\n+// The os package will invoke the interface's methods to indicate that\n+// it is inspecting the given environment variables or files.\n+// Multiple goroutines may call these methods simultaneously.\n+type Interface interface {\n+\tGetenv(key string)\n+\tStat(file string)\n+\tOpen(file string)\n+\tChdir(dir string)\n+}\n+\n+// logger is the current logger Interface.\n+// We use an atomic.Value in case test startup\n+// is racing with goroutines started during init.\n+// That must not cause a race detector failure,\n+// although it will still result in limited visibility\n+// into exactly what those goroutines do.\n+var logger atomic.Value\n+\n+// SetLogger sets the test logger implementation for the current process.\n+// It must be called only once, at process startup.\n+func SetLogger(impl Interface) {\n+\tif logger.Load() != nil {\n+\t\tpanic(\"testlog: SetLogger must be called only once\")\n+\t}\n+\tlogger.Store(&impl)\n+}\n+\n+// Logger returns the current test logger implementation.\n+// It returns nil if there is no logger.\n+func Logger() Interface {\n+\timpl := logger.Load()\n+\tif impl == nil {\n+\t\treturn nil\n+\t}\n+\treturn *impl.(*Interface)\n+}\n+\n+// Getenv calls Logger().Getenv, if a logger has been set.\n+func Getenv(name string) {\n+\tif log := Logger(); log != nil {\n+\t\tlog.Getenv(name)\n+\t}\n+}\n+\n+// Open calls Logger().Open, if a logger has been set.\n+func Open(name string) {\n+\tif log := Logger(); log != nil {\n+\t\tlog.Open(name)\n+\t}\n+}\n+\n+// Stat calls Logger().Stat, if a logger has been set.\n+func Stat(name string) {\n+\tif log := Logger(); log != nil {\n+\t\tlog.Stat(name)\n+\t}\n+}"}, {"sha": "c7954f0d03a2fb43e6e30193b7d9cded8086d91e", "filename": "libgo/go/internal/trace/parser.go", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Finternal%2Ftrace%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Finternal%2Ftrace%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Ftrace%2Fparser.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -75,36 +75,44 @@ const (\n \tGCP      // depicts GC state\n )\n \n+// ParseResult is the result of Parse.\n+type ParseResult struct {\n+\t// Events is the sorted list of Events in the trace.\n+\tEvents []*Event\n+\t// Stacks is the stack traces keyed by stack IDs from the trace.\n+\tStacks map[uint64][]*Frame\n+}\n+\n // Parse parses, post-processes and verifies the trace.\n-func Parse(r io.Reader, bin string) ([]*Event, error) {\n-\tver, events, err := parse(r, bin)\n+func Parse(r io.Reader, bin string) (ParseResult, error) {\n+\tver, res, err := parse(r, bin)\n \tif err != nil {\n-\t\treturn nil, err\n+\t\treturn ParseResult{}, err\n \t}\n \tif ver < 1007 && bin == \"\" {\n-\t\treturn nil, fmt.Errorf(\"for traces produced by go 1.6 or below, the binary argument must be provided\")\n+\t\treturn ParseResult{}, fmt.Errorf(\"for traces produced by go 1.6 or below, the binary argument must be provided\")\n \t}\n-\treturn events, nil\n+\treturn res, nil\n }\n \n // parse parses, post-processes and verifies the trace. It returns the\n // trace version and the list of events.\n-func parse(r io.Reader, bin string) (int, []*Event, error) {\n+func parse(r io.Reader, bin string) (int, ParseResult, error) {\n \tver, rawEvents, strings, err := readTrace(r)\n \tif err != nil {\n-\t\treturn 0, nil, err\n+\t\treturn 0, ParseResult{}, err\n \t}\n \tevents, stacks, err := parseEvents(ver, rawEvents, strings)\n \tif err != nil {\n-\t\treturn 0, nil, err\n+\t\treturn 0, ParseResult{}, err\n \t}\n \tevents, err = removeFutile(events)\n \tif err != nil {\n-\t\treturn 0, nil, err\n+\t\treturn 0, ParseResult{}, err\n \t}\n \terr = postProcessTrace(ver, events)\n \tif err != nil {\n-\t\treturn 0, nil, err\n+\t\treturn 0, ParseResult{}, err\n \t}\n \t// Attach stack traces.\n \tfor _, ev := range events {\n@@ -114,10 +122,10 @@ func parse(r io.Reader, bin string) (int, []*Event, error) {\n \t}\n \tif ver < 1007 && bin != \"\" {\n \t\tif err := symbolize(events, bin); err != nil {\n-\t\t\treturn 0, nil, err\n+\t\t\treturn 0, ParseResult{}, err\n \t\t}\n \t}\n-\treturn ver, events, nil\n+\treturn ver, ParseResult{Events: events, Stacks: stacks}, nil\n }\n \n // rawEvent is a helper type used during parsing."}, {"sha": "c9afa68c3c36c3c6543cacff4d6cdc6bd0deef39", "filename": "libgo/go/internal/trace/parser_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Finternal%2Ftrace%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Finternal%2Ftrace%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Ftrace%2Fparser_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -25,8 +25,8 @@ func TestCorruptedInputs(t *testing.T) {\n \t\t\"go 1.5 trace\\x00\\x00\\x00\\x00\\xc3\\x0200\",\n \t}\n \tfor _, data := range tests {\n-\t\tevents, err := Parse(strings.NewReader(data), \"\")\n-\t\tif err == nil || events != nil {\n+\t\tres, err := Parse(strings.NewReader(data), \"\")\n+\t\tif err == nil || res.Events != nil || res.Stacks != nil {\n \t\t\tt.Fatalf(\"no error on input: %q\", data)\n \t\t}\n \t}"}, {"sha": "6682395aa0a78690c5b272af93fff7570cee9601", "filename": "libgo/go/math/all_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fmath%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fmath%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fall_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -1589,6 +1589,7 @@ var vfpowSC = [][2]float64{\n \t{Inf(-1), 1},\n \t{Inf(-1), 3},\n \t{Inf(-1), Pi},\n+\t{Inf(-1), 0.5},\n \t{Inf(-1), NaN()},\n \n \t{-Pi, Inf(-1)},\n@@ -1607,9 +1608,11 @@ var vfpowSC = [][2]float64{\n \t{-1 / 2, Inf(1)},\n \t{Copysign(0, -1), Inf(-1)},\n \t{Copysign(0, -1), -Pi},\n+\t{Copysign(0, -1), -0.5},\n \t{Copysign(0, -1), -3},\n \t{Copysign(0, -1), 3},\n \t{Copysign(0, -1), Pi},\n+\t{Copysign(0, -1), 0.5},\n \t{Copysign(0, -1), Inf(1)},\n \n \t{0, Inf(-1)},\n@@ -1666,6 +1669,7 @@ var powSC = []float64{\n \tInf(-1),         // pow(-Inf, 1)\n \tInf(-1),         // pow(-Inf, 3)\n \tInf(1),          // pow(-Inf, Pi)\n+\tInf(1),          // pow(-Inf, 0.5)\n \tNaN(),           // pow(-Inf, NaN)\n \t0,               // pow(-Pi, -Inf)\n \tNaN(),           // pow(-Pi, -Pi)\n@@ -1682,9 +1686,11 @@ var powSC = []float64{\n \t0,               // pow(-1/2, +Inf)\n \tInf(1),          // pow(-0, -Inf)\n \tInf(1),          // pow(-0, -Pi)\n+\tInf(1),          // pow(-0, -0.5)\n \tInf(-1),         // pow(-0, -3) IEEE 754-2008\n \tCopysign(0, -1), // pow(-0, 3) IEEE 754-2008\n \t0,               // pow(-0, +Pi)\n+\t0,               // pow(-0, 0.5)\n \t0,               // pow(-0, +Inf)\n \tInf(1),          // pow(+0, -Inf)\n \tInf(1),          // pow(+0, -Pi)"}, {"sha": "314ff90d3c45239c695559b57a37a0ba1fe49d99", "filename": "libgo/go/math/pow.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fmath%2Fpow.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fmath%2Fpow.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fpow.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -48,10 +48,6 @@ func pow(x, y float64) float64 {\n \t\treturn 1\n \tcase y == 1:\n \t\treturn x\n-\tcase y == 0.5:\n-\t\treturn Sqrt(x)\n-\tcase y == -0.5:\n-\t\treturn 1 / Sqrt(x)\n \tcase IsNaN(x) || IsNaN(y):\n \t\treturn NaN()\n \tcase x == 0:\n@@ -86,6 +82,10 @@ func pow(x, y float64) float64 {\n \t\tcase y > 0:\n \t\t\treturn Inf(1)\n \t\t}\n+\tcase y == 0.5:\n+\t\treturn Sqrt(x)\n+\tcase y == -0.5:\n+\t\treturn 1 / Sqrt(x)\n \t}\n \n \tabsy := y"}, {"sha": "147c92f9e257e3270b936079d68d75d840db6dc6", "filename": "libgo/go/math/rand/rand.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fmath%2Frand%2Frand.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fmath%2Frand%2Frand.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Frand%2Frand.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -393,7 +393,7 @@ func (r *lockedSource) Seed(seed int64) {\n \tr.lk.Unlock()\n }\n \n-// seedPos implements Seed for a lockedSource without a race condiiton.\n+// seedPos implements Seed for a lockedSource without a race condition.\n func (r *lockedSource) seedPos(seed int64, readPos *int8) {\n \tr.lk.Lock()\n \tr.src.Seed(seed)"}, {"sha": "49da9936d3f5360e05fbee5171051c6c32e39e06", "filename": "libgo/go/net/cgo_unix_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fcgo_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fcgo_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_unix_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -13,6 +13,7 @@ import (\n )\n \n func TestCgoLookupIP(t *testing.T) {\n+\tdefer dnsWaitGroup.Wait()\n \tctx := context.Background()\n \t_, err, ok := cgoLookupIP(ctx, \"localhost\")\n \tif !ok {\n@@ -24,6 +25,7 @@ func TestCgoLookupIP(t *testing.T) {\n }\n \n func TestCgoLookupIPWithCancel(t *testing.T) {\n+\tdefer dnsWaitGroup.Wait()\n \tctx, cancel := context.WithCancel(context.Background())\n \tdefer cancel()\n \t_, err, ok := cgoLookupIP(ctx, \"localhost\")\n@@ -36,6 +38,7 @@ func TestCgoLookupIPWithCancel(t *testing.T) {\n }\n \n func TestCgoLookupPort(t *testing.T) {\n+\tdefer dnsWaitGroup.Wait()\n \tctx := context.Background()\n \t_, err, ok := cgoLookupPort(ctx, \"tcp\", \"smtp\")\n \tif !ok {\n@@ -47,6 +50,7 @@ func TestCgoLookupPort(t *testing.T) {\n }\n \n func TestCgoLookupPortWithCancel(t *testing.T) {\n+\tdefer dnsWaitGroup.Wait()\n \tctx, cancel := context.WithCancel(context.Background())\n \tdefer cancel()\n \t_, err, ok := cgoLookupPort(ctx, \"tcp\", \"smtp\")\n@@ -59,6 +63,7 @@ func TestCgoLookupPortWithCancel(t *testing.T) {\n }\n \n func TestCgoLookupPTR(t *testing.T) {\n+\tdefer dnsWaitGroup.Wait()\n \tctx := context.Background()\n \t_, err, ok := cgoLookupPTR(ctx, \"127.0.0.1\")\n \tif !ok {\n@@ -70,6 +75,7 @@ func TestCgoLookupPTR(t *testing.T) {\n }\n \n func TestCgoLookupPTRWithCancel(t *testing.T) {\n+\tdefer dnsWaitGroup.Wait()\n \tctx, cancel := context.WithCancel(context.Background())\n \tdefer cancel()\n \t_, err, ok := cgoLookupPTR(ctx, \"127.0.0.1\")"}, {"sha": "b5f1dc9e98ba07652a2171f2531dbcc54e34e428", "filename": "libgo/go/net/dial_test.go", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fdial_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fdial_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"internal/poll\"\n \t\"internal/testenv\"\n \t\"io\"\n+\t\"os\"\n \t\"runtime\"\n \t\"sync\"\n \t\"testing\"\n@@ -85,11 +86,6 @@ func TestDialerDualStackFDLeak(t *testing.T) {\n \t\tt.Skip(\"both IPv4 and IPv6 are required\")\n \t}\n \n-\tclosedPortDelay, expectClosedPortDelay := dialClosedPort()\n-\tif closedPortDelay > expectClosedPortDelay {\n-\t\tt.Errorf(\"got %v; want <= %v\", closedPortDelay, expectClosedPortDelay)\n-\t}\n-\n \tbefore := sw.Sockets()\n \torigTestHookLookupIP := testHookLookupIP\n \tdefer func() { testHookLookupIP = origTestHookLookupIP }()\n@@ -115,7 +111,7 @@ func TestDialerDualStackFDLeak(t *testing.T) {\n \tconst N = 10\n \tvar wg sync.WaitGroup\n \twg.Add(N)\n-\td := &Dialer{DualStack: true, Timeout: 100*time.Millisecond + closedPortDelay}\n+\td := &Dialer{DualStack: true, Timeout: 5 * time.Second}\n \tfor i := 0; i < N; i++ {\n \t\tgo func() {\n \t\t\tdefer wg.Done()\n@@ -639,7 +635,13 @@ func TestDialerLocalAddr(t *testing.T) {\n \t\t}\n \t\tc, err := d.Dial(tt.network, addr)\n \t\tif err == nil && tt.error != nil || err != nil && tt.error == nil {\n-\t\t\tt.Errorf(\"%s %v->%s: got %v; want %v\", tt.network, tt.laddr, tt.raddr, err, tt.error)\n+\t\t\t// On Darwin this occasionally times out.\n+\t\t\t// We don't know why. Issue #22019.\n+\t\t\tif runtime.GOOS == \"darwin\" && tt.error == nil && os.IsTimeout(err) {\n+\t\t\t\tt.Logf(\"ignoring timeout error on Darwin; see https://golang.org/issue/22019\")\n+\t\t\t} else {\n+\t\t\t\tt.Errorf(\"%s %v->%s: got %v; want %v\", tt.network, tt.laddr, tt.raddr, err, tt.error)\n+\t\t\t}\n \t\t}\n \t\tif err != nil {\n \t\t\tif perr := parseDialError(err); perr != nil {"}, {"sha": "73a507e506b7de6eea0022141175408c7b4fc56c", "filename": "libgo/go/net/dnsclient_unix.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -479,7 +479,9 @@ func (r *Resolver) goLookupIPCNAMEOrder(ctx context.Context, name string, order\n \tvar lastErr error\n \tfor _, fqdn := range conf.nameList(name) {\n \t\tfor _, qtype := range qtypes {\n+\t\t\tdnsWaitGroup.Add(1)\n \t\t\tgo func(qtype uint16) {\n+\t\t\t\tdefer dnsWaitGroup.Done()\n \t\t\t\tcname, rrs, err := r.tryOneName(ctx, conf, fqdn, qtype)\n \t\t\t\tlane <- racer{cname, rrs, err}\n \t\t\t}(qtype)"}, {"sha": "82a6c6572c25264a927a33bab9d77fabf65c183f", "filename": "libgo/go/net/dnsclient_unix_test.go", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -203,6 +203,7 @@ var fakeDNSServerSuccessful = fakeDNSServer{func(_, _ string, q *dnsMsg, _ time.\n \n // Issue 13705: don't try to resolve onion addresses, etc\n func TestLookupTorOnion(t *testing.T) {\n+\tdefer dnsWaitGroup.Wait()\n \tr := Resolver{PreferGo: true, Dial: fakeDNSServerSuccessful.DialContext}\n \taddrs, err := r.LookupIPAddr(context.Background(), \"foo.onion\")\n \tif err != nil {\n@@ -300,6 +301,8 @@ var updateResolvConfTests = []struct {\n }\n \n func TestUpdateResolvConf(t *testing.T) {\n+\tdefer dnsWaitGroup.Wait()\n+\n \tr := Resolver{PreferGo: true, Dial: fakeDNSServerSuccessful.DialContext}\n \n \tconf, err := newResolvConfTest()\n@@ -455,6 +458,8 @@ var goLookupIPWithResolverConfigTests = []struct {\n }\n \n func TestGoLookupIPWithResolverConfig(t *testing.T) {\n+\tdefer dnsWaitGroup.Wait()\n+\n \tfake := fakeDNSServer{func(n, s string, q *dnsMsg, _ time.Time) (*dnsMsg, error) {\n \t\tswitch s {\n \t\tcase \"[2001:4860:4860::8888]:53\", \"8.8.8.8:53\":\n@@ -547,6 +552,8 @@ func TestGoLookupIPWithResolverConfig(t *testing.T) {\n \n // Test that goLookupIPOrder falls back to the host file when no DNS servers are available.\n func TestGoLookupIPOrderFallbackToFile(t *testing.T) {\n+\tdefer dnsWaitGroup.Wait()\n+\n \tfake := fakeDNSServer{func(n, s string, q *dnsMsg, tm time.Time) (*dnsMsg, error) {\n \t\tr := &dnsMsg{\n \t\t\tdnsMsgHdr: dnsMsgHdr{\n@@ -603,6 +610,8 @@ func TestGoLookupIPOrderFallbackToFile(t *testing.T) {\n // querying the original name instead of an error encountered\n // querying a generated name.\n func TestErrorForOriginalNameWhenSearching(t *testing.T) {\n+\tdefer dnsWaitGroup.Wait()\n+\n \tconst fqdn = \"doesnotexist.domain\"\n \n \tconf, err := newResolvConfTest()\n@@ -657,6 +666,8 @@ func TestErrorForOriginalNameWhenSearching(t *testing.T) {\n \n // Issue 15434. If a name server gives a lame referral, continue to the next.\n func TestIgnoreLameReferrals(t *testing.T) {\n+\tdefer dnsWaitGroup.Wait()\n+\n \tconf, err := newResolvConfTest()\n \tif err != nil {\n \t\tt.Fatal(err)\n@@ -889,6 +900,8 @@ func TestIgnoreDNSForgeries(t *testing.T) {\n \n // Issue 16865. If a name server times out, continue to the next.\n func TestRetryTimeout(t *testing.T) {\n+\tdefer dnsWaitGroup.Wait()\n+\n \tconf, err := newResolvConfTest()\n \tif err != nil {\n \t\tt.Fatal(err)\n@@ -945,6 +958,8 @@ func TestRotate(t *testing.T) {\n }\n \n func testRotate(t *testing.T, rotate bool, nameservers, wantServers []string) {\n+\tdefer dnsWaitGroup.Wait()\n+\n \tconf, err := newResolvConfTest()\n \tif err != nil {\n \t\tt.Fatal(err)\n@@ -1008,6 +1023,8 @@ func mockTXTResponse(q *dnsMsg) *dnsMsg {\n // Issue 17448. With StrictErrors enabled, temporary errors should make\n // LookupIP fail rather than return a partial result.\n func TestStrictErrorsLookupIP(t *testing.T) {\n+\tdefer dnsWaitGroup.Wait()\n+\n \tconf, err := newResolvConfTest()\n \tif err != nil {\n \t\tt.Fatal(err)\n@@ -1256,6 +1273,8 @@ func TestStrictErrorsLookupIP(t *testing.T) {\n // Issue 17448. With StrictErrors enabled, temporary errors should make\n // LookupTXT stop walking the search list.\n func TestStrictErrorsLookupTXT(t *testing.T) {\n+\tdefer dnsWaitGroup.Wait()\n+\n \tconf, err := newResolvConfTest()\n \tif err != nil {\n \t\tt.Fatal(err)\n@@ -1312,3 +1331,25 @@ func TestStrictErrorsLookupTXT(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// Test for a race between uninstalling the test hooks and closing a\n+// socket connection. This used to fail when testing with -race.\n+func TestDNSGoroutineRace(t *testing.T) {\n+\tdefer dnsWaitGroup.Wait()\n+\n+\tfake := fakeDNSServer{func(n, s string, q *dnsMsg, t time.Time) (*dnsMsg, error) {\n+\t\ttime.Sleep(10 * time.Microsecond)\n+\t\treturn nil, poll.ErrTimeout\n+\t}}\n+\tr := Resolver{PreferGo: true, Dial: fake.DialContext}\n+\n+\t// The timeout here is less than the timeout used by the server,\n+\t// so the goroutine started to query the (fake) server will hang\n+\t// around after this test is done if we don't call dnsWaitGroup.Wait.\n+\tctx, cancel := context.WithTimeout(context.Background(), 2*time.Microsecond)\n+\tdefer cancel()\n+\t_, err := r.LookupIPAddr(ctx, \"where.are.they.now\")\n+\tif err == nil {\n+\t\tt.Fatal(\"fake DNS lookup unexpectedly succeeded\")\n+\t}\n+}"}, {"sha": "95d5e4fd0f649179f5356178af17bcc3689d0915", "filename": "libgo/go/net/fd_unix.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Ffd_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Ffd_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_unix.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -173,7 +173,7 @@ func (fd *netFD) connect(ctx context.Context, la, ra syscall.Sockaddr) (rsa sysc\n \t\t\t\treturn rsa, nil\n \t\t\t}\n \t\tdefault:\n-\t\t\treturn nil, os.NewSyscallError(\"getsockopt\", err)\n+\t\t\treturn nil, os.NewSyscallError(\"connect\", err)\n \t\t}\n \t\truntime.KeepAlive(fd)\n \t}\n@@ -321,7 +321,7 @@ func (fd *netFD) dup() (f *os.File, err error) {\n \t// This also puts the old fd into blocking mode, meaning that\n \t// I/O will block the thread instead of letting us use the epoll server.\n \t// Everything will still work, just with more threads.\n-\tif err = syscall.SetNonblock(ns, false); err != nil {\n+\tif err = fd.pfd.SetBlocking(); err != nil {\n \t\treturn nil, os.NewSyscallError(\"setnonblock\", err)\n \t}\n "}, {"sha": "8f2e5749542f0b58999dbfad5d3a86b30c87d4b0", "filename": "libgo/go/net/http/clientserver_test.go", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Fclientserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Fclientserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclientserver_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -1428,3 +1428,59 @@ func testWriteHeader0(t *testing.T, h2 bool) {\n \t\tt.Error(\"expected panic in handler\")\n \t}\n }\n+\n+// Issue 23010: don't be super strict checking WriteHeader's code if\n+// it's not even valid to call WriteHeader then anyway.\n+func TestWriteHeaderNoCodeCheck_h1(t *testing.T)       { testWriteHeaderAfterWrite(t, h1Mode, false) }\n+func TestWriteHeaderNoCodeCheck_h1hijack(t *testing.T) { testWriteHeaderAfterWrite(t, h1Mode, true) }\n+func TestWriteHeaderNoCodeCheck_h2(t *testing.T)       { testWriteHeaderAfterWrite(t, h2Mode, false) }\n+func testWriteHeaderAfterWrite(t *testing.T, h2, hijack bool) {\n+\tsetParallel(t)\n+\tdefer afterTest(t)\n+\n+\tvar errorLog lockedBytesBuffer\n+\tcst := newClientServerTest(t, h2, HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tif hijack {\n+\t\t\tconn, _, _ := w.(Hijacker).Hijack()\n+\t\t\tdefer conn.Close()\n+\t\t\tconn.Write([]byte(\"HTTP/1.1 200 OK\\r\\nContent-Length: 6\\r\\n\\r\\nfoo\"))\n+\t\t\tw.WriteHeader(0) // verify this doesn't panic if there's already output; Issue 23010\n+\t\t\tconn.Write([]byte(\"bar\"))\n+\t\t\treturn\n+\t\t}\n+\t\tio.WriteString(w, \"foo\")\n+\t\tw.(Flusher).Flush()\n+\t\tw.WriteHeader(0) // verify this doesn't panic if there's already output; Issue 23010\n+\t\tio.WriteString(w, \"bar\")\n+\t}), func(ts *httptest.Server) {\n+\t\tts.Config.ErrorLog = log.New(&errorLog, \"\", 0)\n+\t})\n+\tdefer cst.close()\n+\tres, err := cst.c.Get(cst.ts.URL)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer res.Body.Close()\n+\tbody, err := ioutil.ReadAll(res.Body)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif got, want := string(body), \"foobar\"; got != want {\n+\t\tt.Errorf(\"got = %q; want %q\", got, want)\n+\t}\n+\n+\t// Also check the stderr output:\n+\tif h2 {\n+\t\t// TODO: also emit this log message for HTTP/2?\n+\t\t// We historically haven't, so don't check.\n+\t\treturn\n+\t}\n+\tgotLog := strings.TrimSpace(errorLog.String())\n+\twantLog := \"http: multiple response.WriteHeader calls\"\n+\tif hijack {\n+\t\twantLog = \"http: response.WriteHeader on hijacked connection\"\n+\t}\n+\tif gotLog != wantLog {\n+\t\tt.Errorf(\"stderr output = %q; want %q\", gotLog, wantLog)\n+\t}\n+}"}, {"sha": "de772f9c28af1a82d3b8e6b8ebddbc24ae4494b0", "filename": "libgo/go/net/http/fs_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -1140,7 +1140,7 @@ func TestLinuxSendfile(t *testing.T) {\n \tPost(fmt.Sprintf(\"http://%s/quit\", ln.Addr()), \"\", nil)\n \tchild.Wait()\n \n-\trx := regexp.MustCompile(`sendfile(64)?\\(\\d+,\\s*\\d+,\\s*NULL,\\s*\\d+`)\n+\trx := regexp.MustCompile(`sendfile(64)?\\(`)\n \tout := buf.String()\n \tif !rx.MatchString(out) {\n \t\tt.Errorf(\"no sendfile system call found in:\\n%s\", out)"}, {"sha": "3671875ddd1829272aaf29a06653355f316e24df", "filename": "libgo/go/net/http/h2_bundle.go", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -989,7 +989,7 @@ type http2noDialH2RoundTripper struct{ t *http2Transport }\n \n func (rt http2noDialH2RoundTripper) RoundTrip(req *Request) (*Response, error) {\n \tres, err := rt.t.RoundTrip(req)\n-\tif err == http2ErrNoCachedConn {\n+\tif http2isNoCachedConnError(err) {\n \t\treturn nil, ErrSkipAltProtocol\n \t}\n \treturn res, err\n@@ -6204,7 +6204,6 @@ func http2checkWriteHeaderCode(code int) {\n }\n \n func (w *http2responseWriter) WriteHeader(code int) {\n-\thttp2checkWriteHeaderCode(code)\n \trws := w.rws\n \tif rws == nil {\n \t\tpanic(\"WriteHeader called after Handler finished\")\n@@ -6214,6 +6213,7 @@ func (w *http2responseWriter) WriteHeader(code int) {\n \n func (rws *http2responseWriterState) writeHeader(code int) {\n \tif !rws.wroteHeader {\n+\t\thttp2checkWriteHeaderCode(code)\n \t\trws.wroteHeader = true\n \t\trws.status = code\n \t\tif len(rws.handlerHeader) > 0 {\n@@ -6856,7 +6856,27 @@ func (sew http2stickyErrWriter) Write(p []byte) (n int, err error) {\n \treturn\n }\n \n-var http2ErrNoCachedConn = errors.New(\"http2: no cached connection was available\")\n+// noCachedConnError is the concrete type of ErrNoCachedConn, needs to be detected\n+// by net/http regardless of whether it's its bundled version (in h2_bundle.go with a rewritten type name)\n+// or from a user's x/net/http2. As such, as it has a unique method name (IsHTTP2NoCachedConnError) that\n+// net/http sniffs for via func isNoCachedConnError.\n+type http2noCachedConnError struct{}\n+\n+func (http2noCachedConnError) IsHTTP2NoCachedConnError() {}\n+\n+func (http2noCachedConnError) Error() string { return \"http2: no cached connection was available\" }\n+\n+// isNoCachedConnError reports whether err is of type noCachedConnError\n+// or its equivalent renamed type in net/http2's h2_bundle.go. Both types\n+// may coexist in the same running program.\n+func http2isNoCachedConnError(err error) bool {\n+\t_, ok := err.(interface {\n+\t\tIsHTTP2NoCachedConnError()\n+\t})\n+\treturn ok\n+}\n+\n+var http2ErrNoCachedConn error = http2noCachedConnError{}\n \n // RoundTripOpt are options for the Transport.RoundTripOpt method.\n type http2RoundTripOpt struct {"}, {"sha": "b96bb21019b0fc1492c4086c9f6c75867b38d1d2", "filename": "libgo/go/net/http/httputil/reverseproxy.go", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -191,11 +191,10 @@ func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n \t}\n \n \tres, err := transport.RoundTrip(outreq)\n-\tif res == nil {\n-\t\tres = &http.Response{\n-\t\t\tStatusCode: http.StatusBadGateway,\n-\t\t\tBody:       http.NoBody,\n-\t\t}\n+\tif err != nil {\n+\t\tp.logf(\"http: proxy error: %v\", err)\n+\t\trw.WriteHeader(http.StatusBadGateway)\n+\t\treturn\n \t}\n \n \tremoveConnectionHeaders(res.Header)\n@@ -205,16 +204,12 @@ func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n \t}\n \n \tif p.ModifyResponse != nil {\n-\t\tif err != nil {\n+\t\tif err := p.ModifyResponse(res); err != nil {\n \t\t\tp.logf(\"http: proxy error: %v\", err)\n+\t\t\trw.WriteHeader(http.StatusBadGateway)\n+\t\t\tres.Body.Close()\n+\t\t\treturn\n \t\t}\n-\t\terr = p.ModifyResponse(res)\n-\t}\n-\tif err != nil {\n-\t\tp.logf(\"http: proxy error: %v\", err)\n-\t\trw.WriteHeader(http.StatusBadGateway)\n-\t\tres.Body.Close()\n-\t\treturn\n \t}\n \n \tcopyHeader(rw.Header(), res.Header)"}, {"sha": "2232042d3ed14eec76116bc0b778e5b14e3fdb74", "filename": "libgo/go/net/http/httputil/reverseproxy_test.go", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -631,35 +631,6 @@ func TestReverseProxyModifyResponse(t *testing.T) {\n \t}\n }\n \n-// Issue 21255. Test ModifyResponse when an error from transport.RoundTrip\n-// occurs, and that the proxy returns StatusOK.\n-func TestReverseProxyModifyResponse_OnError(t *testing.T) {\n-\t// Always returns an error\n-\terrBackend := httptest.NewUnstartedServer(nil)\n-\terrBackend.Config.ErrorLog = log.New(ioutil.Discard, \"\", 0) // quiet for tests\n-\tdefer errBackend.Close()\n-\n-\trpURL, _ := url.Parse(errBackend.URL)\n-\trproxy := NewSingleHostReverseProxy(rpURL)\n-\trproxy.ModifyResponse = func(resp *http.Response) error {\n-\t\t// Will be set for a non-nil error\n-\t\tresp.StatusCode = http.StatusOK\n-\t\treturn nil\n-\t}\n-\n-\tfrontend := httptest.NewServer(rproxy)\n-\tdefer frontend.Close()\n-\n-\tresp, err := http.Get(frontend.URL)\n-\tif err != nil {\n-\t\tt.Fatalf(\"failed to reach proxy: %v\", err)\n-\t}\n-\tif resp.StatusCode != http.StatusOK {\n-\t\tt.Errorf(\"err != nil: got res.StatusCode %d; expected %d\", resp.StatusCode, http.StatusOK)\n-\t}\n-\tresp.Body.Close()\n-}\n-\n // Issue 16659: log errors from short read\n func TestReverseProxy_CopyBuffer(t *testing.T) {\n \tbackendServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {"}, {"sha": "c9642e55c29bda47bf38aadcf4f26e6914d7cb8b", "filename": "libgo/go/net/http/request.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -98,6 +98,10 @@ var reqWriteExcludeHeader = map[string]bool{\n type Request struct {\n \t// Method specifies the HTTP method (GET, POST, PUT, etc.).\n \t// For client requests an empty string means GET.\n+\t//\n+\t// Go's HTTP client does not support sending a request with\n+\t// the CONNECT method. See the documentation on Transport for\n+\t// details.\n \tMethod string\n \n \t// URL specifies either the URI being requested (for server"}, {"sha": "a91efcffbac6e32ef5c7deeece69d14644f1ba31", "filename": "libgo/go/net/http/response.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -57,10 +57,9 @@ type Response struct {\n \t// The http Client and Transport guarantee that Body is always\n \t// non-nil, even on responses without a body or responses with\n \t// a zero-length body. It is the caller's responsibility to\n-\t// close Body. The default HTTP client's Transport does not\n-\t// attempt to reuse HTTP/1.0 or HTTP/1.1 TCP connections\n-\t// (\"keep-alive\") unless the Body is read to completion and is\n-\t// closed.\n+\t// close Body. The default HTTP client's Transport may not\n+\t// reuse HTTP/1.x \"keep-alive\" TCP connections if the Body is\n+\t// not read to completion and closed.\n \t//\n \t// The Body is automatically dechunked if the server replied\n \t// with a \"chunked\" Transfer-Encoding."}, {"sha": "9cbfe872afe0bc53522e32bf95879e4e72f03252", "filename": "libgo/go/net/http/serve_test.go", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -523,6 +523,64 @@ func TestServeWithSlashRedirectKeepsQueryString(t *testing.T) {\n \t}\n }\n \n+func TestServeWithSlashRedirectForHostPatterns(t *testing.T) {\n+\tsetParallel(t)\n+\tdefer afterTest(t)\n+\n+\tmux := NewServeMux()\n+\tmux.Handle(\"example.com/pkg/foo/\", stringHandler(\"example.com/pkg/foo/\"))\n+\tmux.Handle(\"example.com/pkg/bar\", stringHandler(\"example.com/pkg/bar\"))\n+\tmux.Handle(\"example.com/pkg/bar/\", stringHandler(\"example.com/pkg/bar/\"))\n+\tmux.Handle(\"example.com:3000/pkg/connect/\", stringHandler(\"example.com:3000/pkg/connect/\"))\n+\tmux.Handle(\"example.com:9000/\", stringHandler(\"example.com:9000/\"))\n+\tmux.Handle(\"/pkg/baz/\", stringHandler(\"/pkg/baz/\"))\n+\n+\ttests := []struct {\n+\t\tmethod string\n+\t\turl    string\n+\t\tcode   int\n+\t\tloc    string\n+\t\twant   string\n+\t}{\n+\t\t{\"GET\", \"http://example.com/\", 404, \"\", \"\"},\n+\t\t{\"GET\", \"http://example.com/pkg/foo\", 301, \"/pkg/foo/\", \"\"},\n+\t\t{\"GET\", \"http://example.com/pkg/bar\", 200, \"\", \"example.com/pkg/bar\"},\n+\t\t{\"GET\", \"http://example.com/pkg/bar/\", 200, \"\", \"example.com/pkg/bar/\"},\n+\t\t{\"GET\", \"http://example.com/pkg/baz\", 301, \"/pkg/baz/\", \"\"},\n+\t\t{\"GET\", \"http://example.com:3000/pkg/foo\", 301, \"/pkg/foo/\", \"\"},\n+\t\t{\"CONNECT\", \"http://example.com/\", 404, \"\", \"\"},\n+\t\t{\"CONNECT\", \"http://example.com:3000/\", 404, \"\", \"\"},\n+\t\t{\"CONNECT\", \"http://example.com:9000/\", 200, \"\", \"example.com:9000/\"},\n+\t\t{\"CONNECT\", \"http://example.com/pkg/foo\", 301, \"/pkg/foo/\", \"\"},\n+\t\t{\"CONNECT\", \"http://example.com:3000/pkg/foo\", 404, \"\", \"\"},\n+\t\t{\"CONNECT\", \"http://example.com:3000/pkg/baz\", 301, \"/pkg/baz/\", \"\"},\n+\t\t{\"CONNECT\", \"http://example.com:3000/pkg/connect\", 301, \"/pkg/connect/\", \"\"},\n+\t}\n+\n+\tts := httptest.NewServer(mux)\n+\tdefer ts.Close()\n+\n+\tfor i, tt := range tests {\n+\t\treq, _ := NewRequest(tt.method, tt.url, nil)\n+\t\tw := httptest.NewRecorder()\n+\t\tmux.ServeHTTP(w, req)\n+\n+\t\tif got, want := w.Code, tt.code; got != want {\n+\t\t\tt.Errorf(\"#%d: Status = %d; want = %d\", i, got, want)\n+\t\t}\n+\n+\t\tif tt.code == 301 {\n+\t\t\tif got, want := w.HeaderMap.Get(\"Location\"), tt.loc; got != want {\n+\t\t\t\tt.Errorf(\"#%d: Location = %q; want = %q\", i, got, want)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif got, want := w.HeaderMap.Get(\"Result\"), tt.want; got != want {\n+\t\t\t\tt.Errorf(\"#%d: Result = %q; want = %q\", i, got, want)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n func BenchmarkServeMux(b *testing.B) {\n \n \ttype test struct {\n@@ -5478,32 +5536,54 @@ func testServerKeepAlivesEnabled(t *testing.T, h2 bool) {\n func TestServerCancelsReadTimeoutWhenIdle(t *testing.T) {\n \tsetParallel(t)\n \tdefer afterTest(t)\n-\tconst timeout = 250 * time.Millisecond\n-\tts := httptest.NewUnstartedServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n-\t\tselect {\n-\t\tcase <-time.After(2 * timeout):\n-\t\t\tfmt.Fprint(w, \"ok\")\n-\t\tcase <-r.Context().Done():\n-\t\t\tfmt.Fprint(w, r.Context().Err())\n-\t\t}\n-\t}))\n-\tts.Config.ReadTimeout = timeout\n-\tts.Start()\n-\tdefer ts.Close()\n+\trunTimeSensitiveTest(t, []time.Duration{\n+\t\t10 * time.Millisecond,\n+\t\t50 * time.Millisecond,\n+\t\t250 * time.Millisecond,\n+\t\ttime.Second,\n+\t\t2 * time.Second,\n+\t}, func(t *testing.T, timeout time.Duration) error {\n+\t\tts := httptest.NewUnstartedServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\t\tselect {\n+\t\t\tcase <-time.After(2 * timeout):\n+\t\t\t\tfmt.Fprint(w, \"ok\")\n+\t\t\tcase <-r.Context().Done():\n+\t\t\t\tfmt.Fprint(w, r.Context().Err())\n+\t\t\t}\n+\t\t}))\n+\t\tts.Config.ReadTimeout = timeout\n+\t\tts.Start()\n+\t\tdefer ts.Close()\n \n-\tc := ts.Client()\n+\t\tc := ts.Client()\n \n-\tres, err := c.Get(ts.URL)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tslurp, err := ioutil.ReadAll(res.Body)\n-\tres.Body.Close()\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif string(slurp) != \"ok\" {\n-\t\tt.Fatalf(\"Got: %q, want ok\", slurp)\n+\t\tres, err := c.Get(ts.URL)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"Get: %v\", err)\n+\t\t}\n+\t\tslurp, err := ioutil.ReadAll(res.Body)\n+\t\tres.Body.Close()\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"Body ReadAll: %v\", err)\n+\t\t}\n+\t\tif string(slurp) != \"ok\" {\n+\t\t\treturn fmt.Errorf(\"got: %q, want ok\", slurp)\n+\t\t}\n+\t\treturn nil\n+\t})\n+}\n+\n+// runTimeSensitiveTest runs test with the provided durations until one passes.\n+// If they all fail, t.Fatal is called with the last one's duration and error value.\n+func runTimeSensitiveTest(t *testing.T, durations []time.Duration, test func(t *testing.T, d time.Duration) error) {\n+\tfor i, d := range durations {\n+\t\terr := test(t, d)\n+\t\tif err == nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif i == len(durations)-1 {\n+\t\t\tt.Fatalf(\"failed with duration %v: %v\", d, err)\n+\t\t}\n \t}\n }\n "}, {"sha": "57e1b5dacb3faf3dbecb5bbecba6d242580164d5", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 45, "deletions": 16, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -132,12 +132,20 @@ type ResponseWriter interface {\n \t// possible to maximize compatibility.\n \tWrite([]byte) (int, error)\n \n-\t// WriteHeader sends an HTTP response header with status code.\n+\t// WriteHeader sends an HTTP response header with the provided\n+\t// status code.\n+\t//\n \t// If WriteHeader is not called explicitly, the first call to Write\n \t// will trigger an implicit WriteHeader(http.StatusOK).\n \t// Thus explicit calls to WriteHeader are mainly used to\n \t// send error codes.\n-\tWriteHeader(int)\n+\t//\n+\t// The provided code must be a valid HTTP 1xx-5xx status code.\n+\t// Only one header may be written. Go does not currently\n+\t// support sending user-defined 1xx informational headers,\n+\t// with the exception of 100-continue response header that the\n+\t// Server sends automatically when the Request.Body is read.\n+\tWriteHeader(statusCode int)\n }\n \n // The Flusher interface is implemented by ResponseWriters that allow\n@@ -1064,7 +1072,6 @@ func checkWriteHeaderCode(code int) {\n }\n \n func (w *response) WriteHeader(code int) {\n-\tcheckWriteHeaderCode(code)\n \tif w.conn.hijacked() {\n \t\tw.conn.server.logf(\"http: response.WriteHeader on hijacked connection\")\n \t\treturn\n@@ -1073,6 +1080,7 @@ func (w *response) WriteHeader(code int) {\n \t\tw.conn.server.logf(\"http: multiple response.WriteHeader calls\")\n \t\treturn\n \t}\n+\tcheckWriteHeaderCode(code)\n \tw.wroteHeader = true\n \tw.status = code\n \n@@ -2212,25 +2220,38 @@ func (mux *ServeMux) match(path string) (h Handler, pattern string) {\n // This occurs when a handler for path + \"/\" was already registered, but\n // not for path itself. If the path needs appending to, it creates a new\n // URL, setting the path to u.Path + \"/\" and returning true to indicate so.\n-func (mux *ServeMux) redirectToPathSlash(path string, u *url.URL) (*url.URL, bool) {\n-\tif !mux.shouldRedirect(path) {\n+func (mux *ServeMux) redirectToPathSlash(host, path string, u *url.URL) (*url.URL, bool) {\n+\tif !mux.shouldRedirect(host, path) {\n \t\treturn u, false\n \t}\n \tpath = path + \"/\"\n \tu = &url.URL{Path: path, RawQuery: u.RawQuery}\n \treturn u, true\n }\n \n-// shouldRedirect reports whether the given path should be redirected to\n+// shouldRedirect reports whether the given path and host should be redirected to\n // path+\"/\". This should happen if a handler is registered for path+\"/\" but\n // not path -- see comments at ServeMux.\n-func (mux *ServeMux) shouldRedirect(path string) bool {\n-\tif _, exist := mux.m[path]; exist {\n-\t\treturn false\n+func (mux *ServeMux) shouldRedirect(host, path string) bool {\n+\tp := []string{path, host + path}\n+\n+\tfor _, c := range p {\n+\t\tif _, exist := mux.m[c]; exist {\n+\t\t\treturn false\n+\t\t}\n \t}\n+\n \tn := len(path)\n-\t_, exist := mux.m[path+\"/\"]\n-\treturn n > 0 && path[n-1] != '/' && exist\n+\tif n == 0 {\n+\t\treturn false\n+\t}\n+\tfor _, c := range p {\n+\t\tif _, exist := mux.m[c+\"/\"]; exist {\n+\t\t\treturn path[n-1] != '/'\n+\t\t}\n+\t}\n+\n+\treturn false\n }\n \n // Handler returns the handler to use for the given request,\n@@ -2255,7 +2276,7 @@ func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {\n \t\t// If r.URL.Path is /tree and its handler is not registered,\n \t\t// the /tree -> /tree/ redirect applies to CONNECT requests\n \t\t// but the path canonicalization does not.\n-\t\tif u, ok := mux.redirectToPathSlash(r.URL.Path, r.URL); ok {\n+\t\tif u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok {\n \t\t\treturn RedirectHandler(u.String(), StatusMovedPermanently), u.Path\n \t\t}\n \n@@ -2269,7 +2290,7 @@ func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {\n \n \t// If the given path is /tree and its handler is not registered,\n \t// redirect for /tree/.\n-\tif u, ok := mux.redirectToPathSlash(path, r.URL); ok {\n+\tif u, ok := mux.redirectToPathSlash(host, path, r.URL); ok {\n \t\treturn RedirectHandler(u.String(), StatusMovedPermanently), u.Path\n \t}\n \n@@ -2386,9 +2407,17 @@ func ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error {\n // A Server defines parameters for running an HTTP server.\n // The zero value for Server is a valid configuration.\n type Server struct {\n-\tAddr      string      // TCP address to listen on, \":http\" if empty\n-\tHandler   Handler     // handler to invoke, http.DefaultServeMux if nil\n-\tTLSConfig *tls.Config // optional TLS config, used by ServeTLS and ListenAndServeTLS\n+\tAddr    string  // TCP address to listen on, \":http\" if empty\n+\tHandler Handler // handler to invoke, http.DefaultServeMux if nil\n+\n+\t// TLSConfig optionally provides a TLS configuration for use\n+\t// by ServeTLS and ListenAndServeTLS. Note that this value is\n+\t// cloned by ServeTLS and ListenAndServeTLS, so it's not\n+\t// possible to modify the configuration with methods like\n+\t// tls.Config.SetSessionTicketKeys. To use\n+\t// SetSessionTicketKeys, use Server.Serve with a TLS Listener\n+\t// instead.\n+\tTLSConfig *tls.Config\n \n \t// ReadTimeout is the maximum duration for reading the entire\n \t// request, including the body."}, {"sha": "7ef8f0147bdb74f554b719430c9ccf18ad4a1ba1", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -73,6 +73,15 @@ const DefaultMaxIdleConnsPerHost = 2\n // and how the Transport is configured. The DefaultTransport supports HTTP/2.\n // To explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2\n // and call ConfigureTransport. See the package docs for more about HTTP/2.\n+//\n+// The Transport will send CONNECT requests to a proxy for its own use\n+// when processing HTTPS requests, but Transport should generally not\n+// be used to send a CONNECT request. That is, the Request passed to\n+// the RoundTrip method should not have a Method of \"CONNECT\", as Go's\n+// HTTP/1.x implementation does not support full-duplex request bodies\n+// being written while the response body is streamed. Go's HTTP/2\n+// implementation does support full duplex, but many CONNECT proxies speak\n+// HTTP/1.x.\n type Transport struct {\n \tidleMu     sync.Mutex\n \twantIdle   bool                                // user has requested to close all idle conns\n@@ -443,7 +452,7 @@ func (t *Transport) RoundTrip(req *Request) (*Response, error) {\n // HTTP request on a new connection. The non-nil input error is the\n // error from roundTrip.\n func (pc *persistConn) shouldRetryRequest(req *Request, err error) bool {\n-\tif err == http2ErrNoCachedConn {\n+\tif http2isNoCachedConnError(err) {\n \t\t// Issue 16582: if the user started a bunch of\n \t\t// requests at once, they can all pick the same conn\n \t\t// and violate the server's max concurrent streams.\n@@ -646,9 +655,14 @@ var (\n \terrTooManyIdleHost    = errors.New(\"http: putIdleConn: too many idle connections for host\")\n \terrCloseIdleConns     = errors.New(\"http: CloseIdleConnections called\")\n \terrReadLoopExiting    = errors.New(\"http: persistConn.readLoop exiting\")\n-\terrServerClosedIdle   = errors.New(\"http: server closed idle connection\")\n \terrIdleConnTimeout    = errors.New(\"http: idle connection timeout\")\n \terrNotCachingH2Conn   = errors.New(\"http: not caching alternate protocol's connections\")\n+\n+\t// errServerClosedIdle is not seen by users for idempotent requests, but may be\n+\t// seen by a user if the server shuts down an idle connection and sends its FIN\n+\t// in flight with already-written POST body bytes from the client.\n+\t// See https://github.com/golang/go/issues/19943#issuecomment-355607646\n+\terrServerClosedIdle = errors.New(\"http: server closed idle connection\")\n )\n \n // transportReadFromServerError is used by Transport.readLoop when the"}, {"sha": "a5f29c97a9087cc2b7716b50ee247e178e5ef666", "filename": "libgo/go/net/http/transport_internal_test.go", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_internal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_internal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_internal_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -96,6 +96,12 @@ func dummyRequestWithBodyNoGetBody(method string) *Request {\n \treturn req\n }\n \n+// issue22091Error acts like a golang.org/x/net/http2.ErrNoCachedConn.\n+type issue22091Error struct{}\n+\n+func (issue22091Error) IsHTTP2NoCachedConnError() {}\n+func (issue22091Error) Error() string             { return \"issue22091Error\" }\n+\n func TestTransportShouldRetryRequest(t *testing.T) {\n \ttests := []struct {\n \t\tpc  *persistConn\n@@ -123,36 +129,42 @@ func TestTransportShouldRetryRequest(t *testing.T) {\n \t\t\twant: true,\n \t\t},\n \t\t3: {\n+\t\t\tpc:   nil,\n+\t\t\treq:  nil,\n+\t\t\terr:  issue22091Error{}, // like an external http2ErrNoCachedConn\n+\t\t\twant: true,\n+\t\t},\n+\t\t4: {\n \t\t\tpc:   &persistConn{reused: true},\n \t\t\treq:  dummyRequest(\"POST\"),\n \t\t\terr:  errMissingHost,\n \t\t\twant: false,\n \t\t},\n-\t\t4: {\n+\t\t5: {\n \t\t\tpc:   &persistConn{reused: true},\n \t\t\treq:  dummyRequest(\"POST\"),\n \t\t\terr:  transportReadFromServerError{},\n \t\t\twant: false,\n \t\t},\n-\t\t5: {\n+\t\t6: {\n \t\t\tpc:   &persistConn{reused: true},\n \t\t\treq:  dummyRequest(\"GET\"),\n \t\t\terr:  transportReadFromServerError{},\n \t\t\twant: true,\n \t\t},\n-\t\t6: {\n+\t\t7: {\n \t\t\tpc:   &persistConn{reused: true},\n \t\t\treq:  dummyRequest(\"GET\"),\n \t\t\terr:  errServerClosedIdle,\n \t\t\twant: true,\n \t\t},\n-\t\t7: {\n+\t\t8: {\n \t\t\tpc:   &persistConn{reused: true},\n \t\t\treq:  dummyRequestWithBody(\"POST\"),\n \t\t\terr:  nothingWrittenError{},\n \t\t\twant: true,\n \t\t},\n-\t\t8: {\n+\t\t9: {\n \t\t\tpc:   &persistConn{reused: true},\n \t\t\treq:  dummyRequestWithBodyNoGetBody(\"POST\"),\n \t\t\terr:  nothingWrittenError{},"}, {"sha": "9cff96006ce646d5b214112b4cea34844bda5a37", "filename": "libgo/go/net/ipsock_posix.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock_posix.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -24,7 +24,7 @@ import (\n // general. Unfortunately, we need to run on kernels built without\n // IPv6 support too. So probe the kernel to figure it out.\n func (p *ipStackCapabilities) probe() {\n-\ts, err := socketFunc(syscall.AF_INET, syscall.SOCK_STREAM, syscall.IPPROTO_TCP)\n+\ts, err := sysSocket(syscall.AF_INET, syscall.SOCK_STREAM, syscall.IPPROTO_TCP)\n \tswitch err {\n \tcase syscall.EAFNOSUPPORT, syscall.EPROTONOSUPPORT:\n \tcase nil:\n@@ -48,7 +48,7 @@ func (p *ipStackCapabilities) probe() {\n \t\tprobes = probes[:1]\n \t}\n \tfor i := range probes {\n-\t\ts, err := socketFunc(syscall.AF_INET6, syscall.SOCK_STREAM, syscall.IPPROTO_TCP)\n+\t\ts, err := sysSocket(syscall.AF_INET6, syscall.SOCK_STREAM, syscall.IPPROTO_TCP)\n \t\tif err != nil {\n \t\t\tcontinue\n \t\t}"}, {"sha": "85e472932fcda7a8bb8d6bbfea488e202cb0636a", "filename": "libgo/go/net/lookup.go", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Flookup.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Flookup.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"context\"\n \t\"internal/nettrace\"\n \t\"internal/singleflight\"\n+\t\"sync\"\n )\n \n // protocols contains minimal mappings between internet protocol\n@@ -53,6 +54,10 @@ var services = map[string]map[string]int{\n \t},\n }\n \n+// dnsWaitGroup can be used by tests to wait for all DNS goroutines to\n+// complete. This avoids races on the test hooks.\n+var dnsWaitGroup sync.WaitGroup\n+\n const maxProtoLength = len(\"RSVP-E2E-IGNORE\") + 10 // with room to grow\n \n func lookupProtocolMap(name string) (int, error) {\n@@ -189,9 +194,14 @@ func (r *Resolver) LookupIPAddr(ctx context.Context, host string) ([]IPAddr, err\n \t\tresolverFunc = alt\n \t}\n \n-\tch := lookupGroup.DoChan(host, func() (interface{}, error) {\n+\tdnsWaitGroup.Add(1)\n+\tch, called := lookupGroup.DoChan(host, func() (interface{}, error) {\n+\t\tdefer dnsWaitGroup.Done()\n \t\treturn testHookLookupIP(ctx, resolverFunc, host)\n \t})\n+\tif !called {\n+\t\tdnsWaitGroup.Done()\n+\t}\n \n \tselect {\n \tcase <-ctx.Done():"}, {"sha": "bfb872551c04c77f8bf9afc91a5189b419aba84b", "filename": "libgo/go/net/lookup_test.go", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Flookup_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Flookup_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -105,6 +105,8 @@ func TestLookupGmailMX(t *testing.T) {\n \t\tt.Skip(\"IPv4 is required\")\n \t}\n \n+\tdefer dnsWaitGroup.Wait()\n+\n \tfor _, tt := range lookupGmailMXTests {\n \t\tmxs, err := LookupMX(tt.name)\n \t\tif err != nil {\n@@ -137,6 +139,8 @@ func TestLookupGmailNS(t *testing.T) {\n \t\tt.Skip(\"IPv4 is required\")\n \t}\n \n+\tdefer dnsWaitGroup.Wait()\n+\n \tfor _, tt := range lookupGmailNSTests {\n \t\tnss, err := LookupNS(tt.name)\n \t\tif err != nil {\n@@ -170,6 +174,8 @@ func TestLookupGmailTXT(t *testing.T) {\n \t\tt.Skip(\"IPv4 is required\")\n \t}\n \n+\tdefer dnsWaitGroup.Wait()\n+\n \tfor _, tt := range lookupGmailTXTTests {\n \t\ttxts, err := LookupTXT(tt.name)\n \t\tif err != nil {\n@@ -205,6 +211,8 @@ func TestLookupGooglePublicDNSAddr(t *testing.T) {\n \t\tt.Skip(\"both IPv4 and IPv6 are required\")\n \t}\n \n+\tdefer dnsWaitGroup.Wait()\n+\n \tfor _, tt := range lookupGooglePublicDNSAddrTests {\n \t\tnames, err := LookupAddr(tt.addr)\n \t\tif err != nil {\n@@ -226,6 +234,8 @@ func TestLookupIPv6LinkLocalAddr(t *testing.T) {\n \t\tt.Skip(\"IPv6 is required\")\n \t}\n \n+\tdefer dnsWaitGroup.Wait()\n+\n \taddrs, err := LookupHost(\"localhost\")\n \tif err != nil {\n \t\tt.Fatal(err)\n@@ -262,6 +272,8 @@ func TestLookupCNAME(t *testing.T) {\n \t\tt.Skip(\"IPv4 is required\")\n \t}\n \n+\tdefer dnsWaitGroup.Wait()\n+\n \tfor _, tt := range lookupCNAMETests {\n \t\tcname, err := LookupCNAME(tt.name)\n \t\tif err != nil {\n@@ -289,6 +301,8 @@ func TestLookupGoogleHost(t *testing.T) {\n \t\tt.Skip(\"IPv4 is required\")\n \t}\n \n+\tdefer dnsWaitGroup.Wait()\n+\n \tfor _, tt := range lookupGoogleHostTests {\n \t\taddrs, err := LookupHost(tt.name)\n \t\tif err != nil {\n@@ -313,6 +327,8 @@ func TestLookupLongTXT(t *testing.T) {\n \t\ttestenv.MustHaveExternalNetwork(t)\n \t}\n \n+\tdefer dnsWaitGroup.Wait()\n+\n \ttxts, err := LookupTXT(\"golang.rsc.io\")\n \tif err != nil {\n \t\tt.Fatal(err)\n@@ -343,6 +359,8 @@ func TestLookupGoogleIP(t *testing.T) {\n \t\tt.Skip(\"IPv4 is required\")\n \t}\n \n+\tdefer dnsWaitGroup.Wait()\n+\n \tfor _, tt := range lookupGoogleIPTests {\n \t\tips, err := LookupIP(tt.name)\n \t\tif err != nil {\n@@ -378,6 +396,7 @@ var revAddrTests = []struct {\n }\n \n func TestReverseAddress(t *testing.T) {\n+\tdefer dnsWaitGroup.Wait()\n \tfor i, tt := range revAddrTests {\n \t\ta, err := reverseaddr(tt.Addr)\n \t\tif len(tt.ErrPrefix) > 0 && err == nil {\n@@ -401,6 +420,8 @@ func TestDNSFlood(t *testing.T) {\n \t\tt.Skip(\"test disabled; use -dnsflood to enable\")\n \t}\n \n+\tdefer dnsWaitGroup.Wait()\n+\n \tvar N = 5000\n \tif runtime.GOOS == \"darwin\" {\n \t\t// On Darwin this test consumes kernel threads much\n@@ -482,6 +503,8 @@ func TestLookupDotsWithLocalSource(t *testing.T) {\n \t\ttestenv.MustHaveExternalNetwork(t)\n \t}\n \n+\tdefer dnsWaitGroup.Wait()\n+\n \tfor i, fn := range []func() func(){forceGoDNS, forceCgoDNS} {\n \t\tfixup := fn()\n \t\tif fixup == nil {\n@@ -527,6 +550,8 @@ func TestLookupDotsWithRemoteSource(t *testing.T) {\n \t\tt.Skip(\"IPv4 is required\")\n \t}\n \n+\tdefer dnsWaitGroup.Wait()\n+\n \tif fixup := forceGoDNS(); fixup != nil {\n \t\ttestDots(t, \"go\")\n \t\tfixup()\n@@ -747,6 +772,9 @@ func TestLookupNonLDH(t *testing.T) {\n \tif runtime.GOOS == \"nacl\" {\n \t\tt.Skip(\"skip on nacl\")\n \t}\n+\n+\tdefer dnsWaitGroup.Wait()\n+\n \tif fixup := forceGoDNS(); fixup != nil {\n \t\tdefer fixup()\n \t}"}, {"sha": "3ad91036e76564814a6f1371ce65f909177cfb0d", "filename": "libgo/go/net/net.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fnet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fnet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -288,6 +288,8 @@ func (c *conn) SetWriteBuffer(bytes int) error {\n // The returned os.File's file descriptor is different from the connection's.\n // Attempting to change properties of the original using this duplicate\n // may or may not have the desired effect.\n+//\n+// On Unix systems this will cause the SetDeadline methods to stop working.\n func (c *conn) File() (f *os.File, err error) {\n \tf, err = c.fd.dup()\n \tif err != nil {"}, {"sha": "def8d657f16338df5ea36f68b73373d0a4315b62", "filename": "libgo/go/net/protoconn_test.go", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fprotoconn_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fprotoconn_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fprotoconn_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -8,6 +8,7 @@\n package net\n \n import (\n+\t\"internal/testenv\"\n \t\"os\"\n \t\"runtime\"\n \t\"testing\"\n@@ -138,11 +139,15 @@ func TestUDPConnSpecificMethods(t *testing.T) {\n \tif _, _, err := c.ReadFromUDP(rb); err != nil {\n \t\tt.Fatal(err)\n \t}\n-\tif _, _, err := c.WriteMsgUDP(wb, nil, c.LocalAddr().(*UDPAddr)); err != nil {\n-\t\tcondFatalf(t, c.LocalAddr().Network(), \"%v\", err)\n-\t}\n-\tif _, _, _, _, err := c.ReadMsgUDP(rb, nil); err != nil {\n-\t\tcondFatalf(t, c.LocalAddr().Network(), \"%v\", err)\n+\tif testenv.IsWindowsXP() {\n+\t\tt.Log(\"skipping broken test on Windows XP (see golang.org/issue/23072)\")\n+\t} else {\n+\t\tif _, _, err := c.WriteMsgUDP(wb, nil, c.LocalAddr().(*UDPAddr)); err != nil {\n+\t\t\tcondFatalf(t, c.LocalAddr().Network(), \"%v\", err)\n+\t\t}\n+\t\tif _, _, _, _, err := c.ReadMsgUDP(rb, nil); err != nil {\n+\t\t\tcondFatalf(t, c.LocalAddr().Network(), \"%v\", err)\n+\t\t}\n \t}\n \n \tif f, err := c.File(); err != nil {"}, {"sha": "769576cd9766723cee6dc4b3d1a9257aba975f1e", "filename": "libgo/go/net/udpsock_test.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fudpsock_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Fudpsock_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -163,6 +163,11 @@ func testWriteToConn(t *testing.T, raddr string) {\n \tswitch runtime.GOOS {\n \tcase \"nacl\": // see golang.org/issue/9252\n \t\tt.Skipf(\"not implemented yet on %s\", runtime.GOOS)\n+\tcase \"windows\":\n+\t\tif testenv.IsWindowsXP() {\n+\t\t\tt.Log(\"skipping broken test on Windows XP (see golang.org/issue/23072)\")\n+\t\t\treturn\n+\t\t}\n \tdefault:\n \t\tif err != nil {\n \t\t\tt.Fatal(err)\n@@ -206,6 +211,11 @@ func testWriteToPacketConn(t *testing.T, raddr string) {\n \tswitch runtime.GOOS {\n \tcase \"nacl\": // see golang.org/issue/9252\n \t\tt.Skipf(\"not implemented yet on %s\", runtime.GOOS)\n+\tcase \"windows\":\n+\t\tif testenv.IsWindowsXP() {\n+\t\t\tt.Log(\"skipping broken test on Windows XP (see golang.org/issue/23072)\")\n+\t\t\treturn\n+\t\t}\n \tdefault:\n \t\tif err != nil {\n \t\t\tt.Fatal(err)"}, {"sha": "3e1217954220389c08b0ce086f131dde9052f187", "filename": "libgo/go/net/url/url.go", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Furl%2Furl.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -563,6 +563,9 @@ func parseAuthority(authority string) (user *Userinfo, host string, err error) {\n \t\treturn nil, host, nil\n \t}\n \tuserinfo := authority[:i]\n+\tif !validUserinfo(userinfo) {\n+\t\treturn nil, \"\", errors.New(\"net/url: invalid userinfo\")\n+\t}\n \tif !strings.Contains(userinfo, \":\") {\n \t\tif userinfo, err = unescape(userinfo, encodeUserPassword); err != nil {\n \t\t\treturn nil, \"\", err\n@@ -1069,3 +1072,33 @@ func (u *URL) UnmarshalBinary(text []byte) error {\n \t*u = *u1\n \treturn nil\n }\n+\n+// validUserinfo reports whether s is a valid userinfo string per RFC 3986\n+// Section 3.2.1:\n+//     userinfo    = *( unreserved / pct-encoded / sub-delims / \":\" )\n+//     unreserved  = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n+//     sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n+//                   / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n+//\n+// It doesn't validate pct-encoded. The caller does that via func unescape.\n+func validUserinfo(s string) bool {\n+\tfor _, r := range s {\n+\t\tif 'A' <= r && r <= 'Z' {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif 'a' <= r && r <= 'z' {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif '0' <= r && r <= '9' {\n+\t\t\tcontinue\n+\t\t}\n+\t\tswitch r {\n+\t\tcase '-', '.', '_', ':', '~', '!', '$', '&', '\\'',\n+\t\t\t'(', ')', '*', '+', ',', ';', '=', '%', '@':\n+\t\t\tcontinue\n+\t\tdefault:\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}"}, {"sha": "f2d311a9986975a6733f60df25643a6c4c841f21", "filename": "libgo/go/net/url/url_test.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -1735,3 +1735,10 @@ func TestNilUser(t *testing.T) {\n \t\tt.Fatalf(\"expected empty string, got %s\", v)\n \t}\n }\n+\n+func TestInvalidUserPassword(t *testing.T) {\n+\t_, err := Parse(\"http://us\\ner:pass\\nword@foo.com/\")\n+\tif got, wantsub := fmt.Sprint(err), \"net/url: invalid userinfo\"; !strings.Contains(got, wantsub) {\n+\t\tt.Errorf(\"error = %q; want substring %q\", got, wantsub)\n+\t}\n+}"}, {"sha": "4e0171f40830b1590dc3b4f7e3c31634a95a7021", "filename": "libgo/go/os/env.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fenv.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -6,7 +6,10 @@\n \n package os\n \n-import \"syscall\"\n+import (\n+\t\"internal/testlog\"\n+\t\"syscall\"\n+)\n \n // Expand replaces ${var} or $var in the string based on the mapping function.\n // For example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).\n@@ -78,6 +81,7 @@ func getShellName(s string) (string, int) {\n // It returns the value, which will be empty if the variable is not present.\n // To distinguish between an empty value and an unset value, use LookupEnv.\n func Getenv(key string) string {\n+\ttestlog.Getenv(key)\n \tv, _ := syscall.Getenv(key)\n \treturn v\n }\n@@ -88,6 +92,7 @@ func Getenv(key string) string {\n // Otherwise the returned value will be empty and the boolean will\n // be false.\n func LookupEnv(key string) (string, bool) {\n+\ttestlog.Getenv(key)\n \treturn syscall.Getenv(key)\n }\n "}, {"sha": "b3f60b62d0379b9653490a948b8df09bee95e6ad", "filename": "libgo/go/os/exec.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -5,6 +5,7 @@\n package os\n \n import (\n+\t\"internal/testlog\"\n \t\"runtime\"\n \t\"sync\"\n \t\"sync/atomic\"\n@@ -84,13 +85,15 @@ func FindProcess(pid int) (*Process, error) {\n }\n \n // StartProcess starts a new process with the program, arguments and attributes\n-// specified by name, argv and attr.\n+// specified by name, argv and attr. The argv slice will become os.Args in the\n+// new process, so it normally starts with the program name.\n //\n // StartProcess is a low-level interface. The os/exec package provides\n // higher-level interfaces.\n //\n // If there is an error, it will be of type *PathError.\n func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error) {\n+\ttestlog.Open(name)\n \treturn startProcess(name, argv, attr)\n }\n "}, {"sha": "aa33570f3c6449e8123ada2e5a0b4c1da58006fd", "filename": "libgo/go/os/exec/exec_test.go", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -405,9 +405,15 @@ var testedAlreadyLeaked = false\n \n // basefds returns the number of expected file descriptors\n // to be present in a process at start.\n-// stdin, stdout, stderr, epoll/kqueue\n+// stdin, stdout, stderr, epoll/kqueue, maybe testlog\n func basefds() uintptr {\n-\treturn os.Stderr.Fd() + 1\n+\tn := os.Stderr.Fd() + 1\n+\tfor _, arg := range os.Args {\n+\t\tif strings.HasPrefix(arg, \"-test.testlogfile=\") {\n+\t\t\tn++\n+\t\t}\n+\t}\n+\treturn n\n }\n \n func closeUnexpectedFds(t *testing.T, m string) {\n@@ -1003,6 +1009,9 @@ func TestContext(t *testing.T) {\n }\n \n func TestContextCancel(t *testing.T) {\n+\tif testenv.Builder() == \"windows-386-xp\" {\n+\t\tt.Skipf(\"known to fail on Windows XP. Issue 17245\")\n+\t}\n \tctx, cancel := context.WithCancel(context.Background())\n \tdefer cancel()\n \tc := helperCommandContext(t, ctx, \"cat\")"}, {"sha": "4a9a8837be415a4faa30f24a53c20c973cd861e7", "filename": "libgo/go/os/executable_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fexecutable_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fexecutable_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexecutable_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -17,7 +17,7 @@ import (\n const executable_EnvVar = \"OSTEST_OUTPUT_EXECPATH\"\n \n func TestExecutable(t *testing.T) {\n-\ttestenv.MustHaveExec(t) // will also execlude nacl, which doesn't support Executable anyway\n+\ttestenv.MustHaveExec(t) // will also exclude nacl, which doesn't support Executable anyway\n \tep, err := os.Executable()\n \tif err != nil {\n \t\tt.Fatalf(\"Executable failed: %v\", err)"}, {"sha": "c667421dc6ef89383fe027dfc80ab7a9db40c984", "filename": "libgo/go/os/file.go", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -39,6 +39,7 @@ package os\n import (\n \t\"errors\"\n \t\"internal/poll\"\n+\t\"internal/testlog\"\n \t\"io\"\n \t\"syscall\"\n \t\"time\"\n@@ -207,7 +208,8 @@ func (f *File) WriteString(s string) (n int, err error) {\n \treturn f.Write([]byte(s))\n }\n \n-// Mkdir creates a new directory with the specified name and permission bits.\n+// Mkdir creates a new directory with the specified name and permission\n+// bits (before umask).\n // If there is an error, it will be of type *PathError.\n func Mkdir(name string, perm FileMode) error {\n \te := syscall.Mkdir(fixLongPath(name), syscallMode(perm))\n@@ -228,8 +230,15 @@ func Mkdir(name string, perm FileMode) error {\n // If there is an error, it will be of type *PathError.\n func Chdir(dir string) error {\n \tif e := syscall.Chdir(dir); e != nil {\n+\t\ttestlog.Open(dir) // observe likely non-existent directory\n \t\treturn &PathError{\"chdir\", dir, e}\n \t}\n+\tif log := testlog.Logger(); log != nil {\n+\t\twd, err := Getwd()\n+\t\tif err == nil {\n+\t\t\tlog.Chdir(wd)\n+\t\t}\n+\t}\n \treturn nil\n }\n \n@@ -250,6 +259,16 @@ func Create(name string) (*File, error) {\n \treturn OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)\n }\n \n+// OpenFile is the generalized open call; most users will use Open\n+// or Create instead. It opens the named file with specified flag\n+// (O_RDONLY etc.) and perm (before umask), if applicable. If successful,\n+// methods on the returned File can be used for I/O.\n+// If there is an error, it will be of type *PathError.\n+func OpenFile(name string, flag int, perm FileMode) (*File, error) {\n+\ttestlog.Open(name)\n+\treturn openFileNolog(name, flag, perm)\n+}\n+\n // lstat is overridden in tests.\n var lstat = Lstat\n "}, {"sha": "7e281789642879315ed36d6e9b32c6a1597ecb22", "filename": "libgo/go/os/file_plan9.go", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Ffile_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Ffile_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_plan9.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -79,12 +79,8 @@ func syscallMode(i FileMode) (o uint32) {\n \treturn\n }\n \n-// OpenFile is the generalized open call; most users will use Open\n-// or Create instead. It opens the named file with specified flag\n-// (O_RDONLY etc.) and perm, (0666 etc.) if applicable. If successful,\n-// methods on the returned File can be used for I/O.\n-// If there is an error, it will be of type *PathError.\n-func OpenFile(name string, flag int, perm FileMode) (*File, error) {\n+// openFileNolog is the Plan 9 implementation of OpenFile.\n+func openFileNolog(name string, flag int, perm FileMode) (*File, error) {\n \tvar (\n \t\tfd     int\n \t\te      error"}, {"sha": "67d2ee1d10752570769af310a5ec27dcaebabd57", "filename": "libgo/go/os/file_unix.go", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Ffile_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Ffile_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_unix.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -66,7 +66,7 @@ func (f *File) Fd() uintptr {\n \t// opened in blocking mode. The File will continue to work,\n \t// but any blocking operation will tie up a thread.\n \tif f.nonblock {\n-\t\tsyscall.SetNonblock(f.pfd.Sysfd, false)\n+\t\tf.pfd.SetBlocking()\n \t}\n \n \treturn uintptr(f.pfd.Sysfd)\n@@ -152,12 +152,8 @@ func epipecheck(file *File, e error) {\n // On Unix-like systems, it is \"/dev/null\"; on Windows, \"NUL\".\n const DevNull = \"/dev/null\"\n \n-// OpenFile is the generalized open call; most users will use Open\n-// or Create instead. It opens the named file with specified flag\n-// (O_RDONLY etc.) and perm, (0666 etc.) if applicable. If successful,\n-// methods on the returned File can be used for I/O.\n-// If there is an error, it will be of type *PathError.\n-func OpenFile(name string, flag int, perm FileMode) (*File, error) {\n+// openFileNolog is the Unix implementation of OpenFile.\n+func openFileNolog(name string, flag int, perm FileMode) (*File, error) {\n \tchmod := false\n \tif !supportsCreateWithStickyBit && flag&O_CREATE != 0 && perm&ModeSticky != 0 {\n \t\tif _, err := Stat(name); IsNotExist(err) {"}, {"sha": "87ad8eb13703e50f1c0b6aaf45464dcd69890982", "filename": "libgo/go/os/getwd.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fgetwd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fgetwd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fgetwd.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -30,13 +30,13 @@ func Getwd() (dir string, err error) {\n \n \t// Clumsy but widespread kludge:\n \t// if $PWD is set and matches \".\", use it.\n-\tdot, err := Stat(\".\")\n+\tdot, err := statNolog(\".\")\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n \tdir = Getenv(\"PWD\")\n \tif len(dir) > 0 && dir[0] == '/' {\n-\t\td, err := Stat(dir)\n+\t\td, err := statNolog(dir)\n \t\tif err == nil && SameFile(dot, d) {\n \t\t\treturn dir, nil\n \t\t}\n@@ -56,15 +56,15 @@ func Getwd() (dir string, err error) {\n \tdir = getwdCache.dir\n \tgetwdCache.Unlock()\n \tif len(dir) > 0 {\n-\t\td, err := Stat(dir)\n+\t\td, err := statNolog(dir)\n \t\tif err == nil && SameFile(dot, d) {\n \t\t\treturn dir, nil\n \t\t}\n \t}\n \n \t// Root is a special case because it has no parent\n \t// and ends in a slash.\n-\troot, err := Stat(\"/\")\n+\troot, err := statNolog(\"/\")\n \tif err != nil {\n \t\t// Can't stat root - no hope.\n \t\treturn \"\", err\n@@ -81,7 +81,7 @@ func Getwd() (dir string, err error) {\n \t\tif len(parent) >= 1024 { // Sanity check\n \t\t\treturn \"\", syscall.ENAMETOOLONG\n \t\t}\n-\t\tfd, err := Open(parent)\n+\t\tfd, err := openFileNolog(parent, O_RDONLY, 0)\n \t\tif err != nil {\n \t\t\treturn \"\", err\n \t\t}\n@@ -93,7 +93,7 @@ func Getwd() (dir string, err error) {\n \t\t\t\treturn \"\", err\n \t\t\t}\n \t\t\tfor _, name := range names {\n-\t\t\t\td, _ := Lstat(parent + \"/\" + name)\n+\t\t\t\td, _ := lstatNolog(parent + \"/\" + name)\n \t\t\t\tif SameFile(d, dot) {\n \t\t\t\t\tdir = \"/\" + name + dir\n \t\t\t\t\tgoto Found"}, {"sha": "8ed9252d8a73a56f6e337568fe04a4af283d509e", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -1360,14 +1360,26 @@ func TestSeek(t *testing.T) {\n \t\t{-1, io.SeekEnd, int64(len(data)) - 1},\n \t\t{1 << 33, io.SeekStart, 1 << 33},\n \t\t{1 << 33, io.SeekEnd, 1<<33 + int64(len(data))},\n+\n+\t\t// Issue 21681, Windows 4G-1, etc:\n+\t\t{1<<32 - 1, io.SeekStart, 1<<32 - 1},\n+\t\t{0, io.SeekCurrent, 1<<32 - 1},\n+\t\t{2<<32 - 1, io.SeekStart, 2<<32 - 1},\n+\t\t{0, io.SeekCurrent, 2<<32 - 1},\n \t}\n \tfor i, tt := range tests {\n+\t\tif runtime.GOOS == \"nacl\" && tt.out > 1<<30 {\n+\t\t\tt.Logf(\"skipping test case #%d on nacl; https://golang.org/issue/21728\", i)\n+\t\t\tcontinue\n+\t\t}\n \t\toff, err := f.Seek(tt.in, tt.whence)\n \t\tif off != tt.out || err != nil {\n-\t\t\tif e, ok := err.(*PathError); ok && e.Err == syscall.EINVAL && tt.out > 1<<32 {\n-\t\t\t\t// Reiserfs rejects the big seeks.\n-\t\t\t\t// https://golang.org/issue/91\n-\t\t\t\tbreak\n+\t\t\tif e, ok := err.(*PathError); ok && e.Err == syscall.EINVAL && tt.out > 1<<32 && runtime.GOOS == \"linux\" {\n+\t\t\t\tmounts, _ := ioutil.ReadFile(\"/proc/mounts\")\n+\t\t\t\tif strings.Contains(string(mounts), \"reiserfs\") {\n+\t\t\t\t\t// Reiserfs rejects the big seeks.\n+\t\t\t\t\tt.Skipf(\"skipping test known to fail on reiserfs; https://golang.org/issue/91\")\n+\t\t\t\t}\n \t\t\t}\n \t\t\tt.Errorf(\"#%d: Seek(%v, %v) = %v, %v want %v, nil\", i, tt.in, tt.whence, off, err, tt.out)\n \t\t}"}, {"sha": "eb996e5fb9174b9aad4f45b3a795d89f7b9cedf0", "filename": "libgo/go/os/path.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fpath.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -13,7 +13,7 @@ import (\n // MkdirAll creates a directory named path,\n // along with any necessary parents, and returns nil,\n // or else returns an error.\n-// The permission bits perm are used for all\n+// The permission bits perm (before umask) are used for all\n // directories that MkdirAll creates.\n // If path is already a directory, MkdirAll does nothing\n // and returns nil."}, {"sha": "aad6c27f1b11e8feccf6e894e1cc63e269000a2c", "filename": "libgo/go/os/pipe_test.go", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fpipe_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fpipe_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fpipe_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -10,13 +10,15 @@ package os_test\n import (\n \t\"fmt\"\n \t\"internal/testenv\"\n+\t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n \tosexec \"os/exec\"\n \t\"os/signal\"\n \t\"runtime\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"sync\"\n \t\"syscall\"\n \t\"testing\"\n \t\"time\"\n@@ -220,3 +222,86 @@ func TestReadNonblockingFd(t *testing.T) {\n \t\tt.Errorf(\"child process failed: %v\", err)\n \t}\n }\n+\n+func TestCloseWithBlockingReadByNewFile(t *testing.T) {\n+\tvar p [2]int\n+\terr := syscall.Pipe(p[:])\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t// os.NewFile returns a blocking mode file.\n+\ttestCloseWithBlockingRead(t, os.NewFile(uintptr(p[0]), \"reader\"), os.NewFile(uintptr(p[1]), \"writer\"))\n+}\n+\n+func TestCloseWithBlockingReadByFd(t *testing.T) {\n+\tr, w, err := os.Pipe()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t// Calling Fd will put the file into blocking mode.\n+\t_ = r.Fd()\n+\ttestCloseWithBlockingRead(t, r, w)\n+}\n+\n+// Test that we don't let a blocking read prevent a close.\n+func testCloseWithBlockingRead(t *testing.T, r, w *os.File) {\n+\tdefer r.Close()\n+\tdefer w.Close()\n+\n+\tc1, c2 := make(chan bool), make(chan bool)\n+\tvar wg sync.WaitGroup\n+\n+\twg.Add(1)\n+\tgo func(c chan bool) {\n+\t\tdefer wg.Done()\n+\t\t// Give the other goroutine a chance to enter the Read\n+\t\t// or Write call. This is sloppy but the test will\n+\t\t// pass even if we close before the read/write.\n+\t\ttime.Sleep(20 * time.Millisecond)\n+\n+\t\tif err := r.Close(); err != nil {\n+\t\t\tt.Error(err)\n+\t\t}\n+\t\tclose(c)\n+\t}(c1)\n+\n+\twg.Add(1)\n+\tgo func(c chan bool) {\n+\t\tdefer wg.Done()\n+\t\tvar b [1]byte\n+\t\t_, err := r.Read(b[:])\n+\t\tclose(c)\n+\t\tif err == nil {\n+\t\t\tt.Error(\"I/O on closed pipe unexpectedly succeeded\")\n+\t\t}\n+\t\tif err != io.EOF {\n+\t\t\tt.Errorf(\"got %v, expected io.EOF\", err)\n+\t\t}\n+\t}(c2)\n+\n+\tfor c1 != nil || c2 != nil {\n+\t\tselect {\n+\t\tcase <-c1:\n+\t\t\tc1 = nil\n+\t\t\t// r.Close has completed, but the blocking Read\n+\t\t\t// is hanging. Close the writer to unblock it.\n+\t\t\tw.Close()\n+\t\tcase <-c2:\n+\t\t\tc2 = nil\n+\t\tcase <-time.After(1 * time.Second):\n+\t\t\tswitch {\n+\t\t\tcase c1 != nil && c2 != nil:\n+\t\t\t\tt.Error(\"timed out waiting for Read and Close\")\n+\t\t\t\tw.Close()\n+\t\t\tcase c1 != nil:\n+\t\t\t\tt.Error(\"timed out waiting for Close\")\n+\t\t\tcase c2 != nil:\n+\t\t\t\tt.Error(\"timed out waiting for Read\")\n+\t\t\tdefault:\n+\t\t\t\tt.Error(\"impossible case\")\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\twg.Wait()\n+}"}, {"sha": "af66838e3e22b105b6406889038327ffaac61949", "filename": "libgo/go/os/stat.go", "status": "modified", "additions": 14, "deletions": 55, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fstat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fstat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -1,64 +1,23 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n+// Copyright 2017 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !aix\n-// +build !darwin\n-// +build !freebsd\n-// +build !linux\n-// +build !netbsd\n-// +build !openbsd\n-// +build !solaris\n-\n package os\n \n-import (\n-\t\"syscall\"\n-\t\"time\"\n-)\n-\n-func sameFile(fs1, fs2 *fileStat) bool {\n-\tstat1 := fs1.sys.(*syscall.Stat_t)\n-\tstat2 := fs2.sys.(*syscall.Stat_t)\n-\treturn stat1.Dev == stat2.Dev && stat1.Ino == stat2.Ino\n-}\n-\n-func fileInfoFromStat(st *syscall.Stat_t, name string) FileInfo {\n-\tfs := &fileStat{\n-\t\tname:    basename(name),\n-\t\tsize:    int64(st.Size),\n-\t\tmodTime: timespecToTime(st.Mtim),\n-\t\tsys:     st,\n-\t}\n-\tfs.mode = FileMode(st.Mode & 0777)\n-\tswitch st.Mode & syscall.S_IFMT {\n-\tcase syscall.S_IFBLK, syscall.S_IFCHR:\n-\t\tfs.mode |= ModeDevice\n-\tcase syscall.S_IFDIR:\n-\t\tfs.mode |= ModeDir\n-\tcase syscall.S_IFIFO:\n-\t\tfs.mode |= ModeNamedPipe\n-\tcase syscall.S_IFLNK:\n-\t\tfs.mode |= ModeSymlink\n-\tcase syscall.S_IFREG:\n-\t\t// nothing to do\n-\tcase syscall.S_IFSOCK:\n-\t\tfs.mode |= ModeSocket\n-\t}\n-\tif st.Mode&syscall.S_ISGID != 0 {\n-\t\tfs.mode |= ModeSetgid\n-\t}\n-\tif st.Mode&syscall.S_ISUID != 0 {\n-\t\tfs.mode |= ModeSetuid\n-\t}\n-\treturn fs\n-}\n+import \"internal/testlog\"\n \n-func timespecToTime(ts syscall.Timespec) time.Time {\n-\treturn time.Unix(int64(ts.Sec), int64(ts.Nsec))\n+// Stat returns a FileInfo describing the named file.\n+// If there is an error, it will be of type *PathError.\n+func Stat(name string) (FileInfo, error) {\n+\ttestlog.Stat(name)\n+\treturn statNolog(name)\n }\n \n-// For testing.\n-func atime(fi FileInfo) time.Time {\n-\treturn timespecToTime(fi.Sys().(*syscall.Stat_t).Atim)\n+// Lstat returns a FileInfo describing the named file.\n+// If the file is a symbolic link, the returned FileInfo\n+// describes the symbolic link. Lstat makes no attempt to follow the link.\n+// If there is an error, it will be of type *PathError.\n+func Lstat(name string) (FileInfo, error) {\n+\ttestlog.Stat(name)\n+\treturn lstatNolog(name)\n }"}, {"sha": "8057fd4a02de697e9467db396bfac42f455992e4", "filename": "libgo/go/os/stat_plan9.go", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fstat_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fstat_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat_plan9.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -86,22 +86,18 @@ func dirstat(arg interface{}) (*syscall.Dir, error) {\n \treturn nil, &PathError{\"stat\", name, err}\n }\n \n-// Stat returns a FileInfo describing the named file.\n-// If there is an error, it will be of type *PathError.\n-func Stat(name string) (FileInfo, error) {\n+// statNolog implements Stat for Plan 9.\n+func statNolog(name string) (FileInfo, error) {\n \td, err := dirstat(name)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \treturn fileInfoFromStat(d), nil\n }\n \n-// Lstat returns a FileInfo describing the named file.\n-// If the file is a symbolic link, the returned FileInfo\n-// describes the symbolic link. Lstat makes no attempt to follow the link.\n-// If there is an error, it will be of type *PathError.\n-func Lstat(name string) (FileInfo, error) {\n-\treturn Stat(name)\n+// lstatNolog implements Lstat for Plan 9.\n+func lstatNolog(name string) (FileInfo, error) {\n+\treturn statNolog(name)\n }\n \n // For testing."}, {"sha": "bc5d06cdda7d8601ac57960a5bc55f0bf8769484", "filename": "libgo/go/os/stat_unix.go", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fstat_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fos%2Fstat_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat_unix.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -25,9 +25,8 @@ func (f *File) Stat() (FileInfo, error) {\n \treturn &fs, nil\n }\n \n-// Stat returns a FileInfo describing the named file.\n-// If there is an error, it will be of type *PathError.\n-func Stat(name string) (FileInfo, error) {\n+// statNolog stats a file with no test logging.\n+func statNolog(name string) (FileInfo, error) {\n \tvar fs fileStat\n \terr := syscall.Stat(name, &fs.sys)\n \tif err != nil {\n@@ -37,11 +36,8 @@ func Stat(name string) (FileInfo, error) {\n \treturn &fs, nil\n }\n \n-// Lstat returns a FileInfo describing the named file.\n-// If the file is a symbolic link, the returned FileInfo\n-// describes the symbolic link. Lstat makes no attempt to follow the link.\n-// If there is an error, it will be of type *PathError.\n-func Lstat(name string) (FileInfo, error) {\n+// lstatNolog lstats a file with no test logging.\n+func lstatNolog(name string) (FileInfo, error) {\n \tvar fs fileStat\n \terr := syscall.Lstat(name, &fs.sys)\n \tif err != nil {"}, {"sha": "5506e956925fe722b5cd544072936d630e9445af", "filename": "libgo/go/plugin/plugin.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fplugin%2Fplugin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fplugin%2Fplugin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fplugin%2Fplugin.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -13,8 +13,8 @@\n // already part of the program are called. The main function is not run.\n // A plugin is only initialized once, and cannot be closed.\n //\n-// The plugin support is currently incomplete, only supports Linux,\n-// and has known bugs. Please report any issues.\n+// Currently plugins are only supported on Linux and macOS.\n+// Please report any issues.\n package plugin\n \n // Plugin is a loaded Go plugin."}, {"sha": "6b082c172b440d4245a3132a9079dbb052cc6c1e", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -31,7 +31,8 @@ import (\n // calling kind-specific methods. Calling a method\n // inappropriate to the kind of type causes a run-time panic.\n //\n-// Type values are comparable, such as with the == operator.\n+// Type values are comparable, such as with the == operator,\n+// so they can be used as map keys.\n // Two Type values are equal if they represent identical types.\n type Type interface {\n \t// Methods applicable to all types."}, {"sha": "35321470425a79cf91d707c6aff920883c3a718f", "filename": "libgo/go/runtime/crash_cgo_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -484,7 +484,7 @@ func TestWindowsStackMemoryCgo(t *testing.T) {\n func TestSigStackSwapping(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"plan9\", \"windows\":\n-\t\tt.Skip(\"no sigaltstack on %s\", runtime.GOOS)\n+\t\tt.Skipf(\"no sigaltstack on %s\", runtime.GOOS)\n \t}\n \tt.Parallel()\n \tgot := runTestProg(t, \"testprogcgo\", \"SigStack\")"}, {"sha": "53280232682b8828f67ba15eed30ceb5bb7d1731", "filename": "libgo/go/runtime/internal/sys/stubs.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fruntime%2Finternal%2Fsys%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fruntime%2Finternal%2Fsys%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Finternal%2Fsys%2Fstubs.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -9,3 +9,5 @@ package sys\n const PtrSize = 4 << (^uintptr(0) >> 63)           // unsafe.Sizeof(uintptr(0)) but an ideal const\n const RegSize = 4 << (^Uintreg(0) >> 63)           // unsafe.Sizeof(uintreg(0)) but an ideal const\n const SpAlign = 1*(1-GoarchArm64) + 16*GoarchArm64 // SP alignment: 1 normally, 16 for ARM64\n+\n+var DefaultGoroot string // set at link time"}, {"sha": "191239ac5477490884d3dcedd7fa9ff925337a84", "filename": "libgo/go/runtime/mbitmap.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fruntime%2Fmbitmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fruntime%2Fmbitmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmbitmap.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -489,6 +489,9 @@ func (h heapBits) forward(n uintptr) heapBits {\n // The caller can test morePointers and isPointer by &-ing with bitScan and bitPointer.\n // The result includes in its higher bits the bits for subsequent words\n // described by the same bitmap byte.\n+//\n+// nosplit because it is used during write barriers and must not be preempted.\n+//go:nosplit\n func (h heapBits) bits() uint32 {\n \t// The (shift & 31) eliminates a test and conditional branch\n \t// from the generated code."}, {"sha": "095a0de1ae520e790764e7d9e5811b06fbcfc19f", "filename": "libgo/go/runtime/mstats.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fruntime%2Fmstats.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fruntime%2Fmstats.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmstats.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -262,7 +262,7 @@ type MemStats struct {\n \t// can only be used for other objects of roughly the same\n \t// size.\n \t//\n-\t// HeapInuse minus HeapAlloc esimates the amount of memory\n+\t// HeapInuse minus HeapAlloc estimates the amount of memory\n \t// that has been dedicated to particular size classes, but is\n \t// not currently being used. This is an upper bound on\n \t// fragmentation, but in general this memory can be reused"}, {"sha": "7e88463490c98aea45cf38a905a2c789bdb202ab", "filename": "libgo/go/runtime/mwbbuf.go", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fruntime%2Fmwbbuf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fruntime%2Fmwbbuf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmwbbuf.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -95,6 +95,15 @@ func (b *wbBuf) reset() {\n \t}\n }\n \n+// discard resets b's next pointer, but not its end pointer.\n+//\n+// This must be nosplit because it's called by wbBufFlush.\n+//\n+//go:nosplit\n+func (b *wbBuf) discard() {\n+\tb.next = uintptr(unsafe.Pointer(&b.buf[0]))\n+}\n+\n // putFast adds old and new to the write barrier buffer and returns\n // false if a flush is necessary. Callers should use this as:\n //\n@@ -143,10 +152,14 @@ func (b *wbBuf) putFast(old, new uintptr) bool {\n //go:nowritebarrierrec\n //go:nosplit\n func wbBufFlush(dst *uintptr, src uintptr) {\n+\t// Note: Every possible return from this function must reset\n+\t// the buffer's next pointer to prevent buffer overflow.\n+\n \tif getg().m.dying > 0 {\n \t\t// We're going down. Not much point in write barriers\n \t\t// and this way we can allow write barriers in the\n \t\t// panic path.\n+\t\tgetg().m.p.ptr().wbBuf.discard()\n \t\treturn\n \t}\n \n@@ -156,8 +169,7 @@ func wbBufFlush(dst *uintptr, src uintptr) {\n \t\tcgoCheckWriteBarrier(dst, src)\n \t\tif !writeBarrier.needed {\n \t\t\t// We were only called for cgocheck.\n-\t\t\tb := &getg().m.p.ptr().wbBuf\n-\t\t\tb.next = uintptr(unsafe.Pointer(&b.buf[0]))\n+\t\t\tgetg().m.p.ptr().wbBuf.discard()\n \t\t\treturn\n \t\t}\n \t}"}, {"sha": "2972daa059febc1ff43a065d859fc01f274aafd8", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -2220,6 +2220,12 @@ stop:\n \t\treturn gp, false\n \t}\n \n+\t// Before we drop our P, make a snapshot of the allp slice,\n+\t// which can change underfoot once we no longer block\n+\t// safe-points. We don't need to snapshot the contents because\n+\t// everything up to cap(allp) is immutable.\n+\tallpSnapshot := allp\n+\n \t// return P and block\n \tlock(&sched.lock)\n \tif sched.gcwaiting != 0 || _p_.runSafePointFn != 0 {\n@@ -2259,7 +2265,7 @@ stop:\n \t}\n \n \t// check all runqueues once again\n-\tfor _, _p_ := range allp {\n+\tfor _, _p_ := range allpSnapshot {\n \t\tif !runqempty(_p_) {\n \t\t\tlock(&sched.lock)\n \t\t\t_p_ = pidleget()"}, {"sha": "492dfeff7f5628c02f462e9e223de1b134cc08b6", "filename": "libgo/go/runtime/testdata/testprogcgo/sigstack.go", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fsigstack.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fsigstack.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fsigstack.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -17,15 +17,11 @@ package main\n #include <stdlib.h>\n #include <sys/mman.h>\n \n-#ifndef MAP_STACK\n-#define MAP_STACK 0\n-#endif\n-\n extern void SigStackCallback();\n \n static void* WithSigStack(void* arg __attribute__((unused))) {\n \t// Set up an alternate system stack.\n-\tvoid* base = mmap(0, SIGSTKSZ, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON|MAP_STACK, -1, 0);\n+\tvoid* base = mmap(0, SIGSTKSZ, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);\n \tif (base == MAP_FAILED) {\n \t\tperror(\"mmap failed\");\n \t\tabort();"}, {"sha": "997d486c65ad50ecd92b5f9564da83ead2f7087d", "filename": "libgo/go/runtime/trace/trace_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fruntime%2Ftrace%2Ftrace_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fruntime%2Ftrace%2Ftrace_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftrace%2Ftrace_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -127,20 +127,20 @@ func TestTrace(t *testing.T) {\n }\n \n func parseTrace(t *testing.T, r io.Reader) ([]*trace.Event, map[uint64]*trace.GDesc) {\n-\tevents, err := trace.Parse(r, \"\")\n+\tres, err := trace.Parse(r, \"\")\n \tif err == trace.ErrTimeOrder {\n \t\tt.Skipf(\"skipping trace: %v\", err)\n \t}\n \tif err != nil {\n \t\tt.Fatalf(\"failed to parse trace: %v\", err)\n \t}\n-\tgs := trace.GoroutineStats(events)\n+\tgs := trace.GoroutineStats(res.Events)\n \tfor goid := range gs {\n \t\t// We don't do any particular checks on the result at the moment.\n \t\t// But still check that RelatedGoroutines does not crash, hang, etc.\n-\t\t_ = trace.RelatedGoroutines(events, goid)\n+\t\t_ = trace.RelatedGoroutines(res.Events, goid)\n \t}\n-\treturn events, gs\n+\treturn res.Events, gs\n }\n \n func testBrokenTimestamps(t *testing.T, data []byte) {"}, {"sha": "ac58f34e1dec25048761a3047ee87a2c7941a441", "filename": "libgo/go/strings/builder.go", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fstrings%2Fbuilder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fstrings%2Fbuilder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fbuilder.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -5,16 +5,41 @@\n package strings\n \n import (\n-\t\"errors\"\n-\t\"io\"\n \t\"unicode/utf8\"\n \t\"unsafe\"\n )\n \n // A Builder is used to efficiently build a string using Write methods.\n // It minimizes memory copying. The zero value is ready to use.\n+// Do not copy a non-zero Builder.\n type Builder struct {\n-\tbuf []byte\n+\taddr *Builder // of receiver, to detect copies by value\n+\tbuf  []byte\n+}\n+\n+// noescape hides a pointer from escape analysis.  noescape is\n+// the identity function but escape analysis doesn't think the\n+// output depends on the input. noescape is inlined and currently\n+// compiles down to zero instructions.\n+// USE CAREFULLY!\n+// This was copied from the runtime; see issues 23382 and 7921.\n+//go:nosplit\n+func noescape(p unsafe.Pointer) unsafe.Pointer {\n+\tx := uintptr(p)\n+\treturn unsafe.Pointer(x ^ 0)\n+}\n+\n+func (b *Builder) copyCheck() {\n+\tif b.addr == nil {\n+\t\t// This hack works around a failing of Go's escape analysis\n+\t\t// that was causing b to escape and be heap allocated.\n+\t\t// See issue 23382.\n+\t\t// TODO: once issue 7921 is fixed, this should be reverted to\n+\t\t// just \"b.addr = b\".\n+\t\tb.addr = (*Builder)(noescape(unsafe.Pointer(b)))\n+\t} else if b.addr != b {\n+\t\tpanic(\"strings: illegal use of non-zero Builder copied by value\")\n+\t}\n }\n \n // String returns the accumulated string.\n@@ -26,9 +51,10 @@ func (b *Builder) String() string {\n func (b *Builder) Len() int { return len(b.buf) }\n \n // Reset resets the Builder to be empty.\n-func (b *Builder) Reset() { b.buf = nil }\n-\n-const maxInt = int(^uint(0) >> 1)\n+func (b *Builder) Reset() {\n+\tb.addr = nil\n+\tb.buf = nil\n+}\n \n // grow copies the buffer to a new, larger buffer so that there are at least n\n // bytes of capacity beyond len(b.buf).\n@@ -42,6 +68,7 @@ func (b *Builder) grow(n int) {\n // another n bytes. After Grow(n), at least n bytes can be written to b\n // without another allocation. If n is negative, Grow panics.\n func (b *Builder) Grow(n int) {\n+\tb.copyCheck()\n \tif n < 0 {\n \t\tpanic(\"strings.Builder.Grow: negative count\")\n \t}\n@@ -53,20 +80,23 @@ func (b *Builder) Grow(n int) {\n // Write appends the contents of p to b's buffer.\n // Write always returns len(p), nil.\n func (b *Builder) Write(p []byte) (int, error) {\n+\tb.copyCheck()\n \tb.buf = append(b.buf, p...)\n \treturn len(p), nil\n }\n \n // WriteByte appends the byte c to b's buffer.\n // The returned error is always nil.\n func (b *Builder) WriteByte(c byte) error {\n+\tb.copyCheck()\n \tb.buf = append(b.buf, c)\n \treturn nil\n }\n \n // WriteRune appends the UTF-8 encoding of Unicode code point r to b's buffer.\n // It returns the length of r and a nil error.\n func (b *Builder) WriteRune(r rune) (int, error) {\n+\tb.copyCheck()\n \tif r < utf8.RuneSelf {\n \t\tb.buf = append(b.buf, byte(r))\n \t\treturn 1, nil\n@@ -83,38 +113,7 @@ func (b *Builder) WriteRune(r rune) (int, error) {\n // WriteString appends the contents of s to b's buffer.\n // It returns the length of s and a nil error.\n func (b *Builder) WriteString(s string) (int, error) {\n+\tb.copyCheck()\n \tb.buf = append(b.buf, s...)\n \treturn len(s), nil\n }\n-\n-// minRead is the minimum slice passed to a Read call by Builder.ReadFrom.\n-// It is the same as bytes.MinRead.\n-const minRead = 512\n-\n-// errNegativeRead is the panic value if the reader passed to Builder.ReadFrom\n-// returns a negative count.\n-var errNegativeRead = errors.New(\"strings.Builder: reader returned negative count from Read\")\n-\n-// ReadFrom reads data from r until EOF and appends it to b's buffer.\n-// The return value n is the number of bytes read.\n-// Any error except io.EOF encountered during the read is also returned.\n-func (b *Builder) ReadFrom(r io.Reader) (n int64, err error) {\n-\tfor {\n-\t\tl := len(b.buf)\n-\t\tif cap(b.buf)-l < minRead {\n-\t\t\tb.grow(minRead)\n-\t\t}\n-\t\tm, e := r.Read(b.buf[l:cap(b.buf)])\n-\t\tif m < 0 {\n-\t\t\tpanic(errNegativeRead)\n-\t\t}\n-\t\tb.buf = b.buf[:l+m]\n-\t\tn += int64(m)\n-\t\tif e == io.EOF {\n-\t\t\treturn n, nil\n-\t\t}\n-\t\tif e != nil {\n-\t\t\treturn n, e\n-\t\t}\n-\t}\n-}"}, {"sha": "ad012bb352464568e89b14caae7e69e8b40dc390", "filename": "libgo/go/strings/builder_test.go", "status": "modified", "additions": 115, "deletions": 90, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fstrings%2Fbuilder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fstrings%2Fbuilder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fbuilder_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -6,12 +6,9 @@ package strings_test\n \n import (\n \t\"bytes\"\n-\t\"errors\"\n-\t\"io\"\n \t\"runtime\"\n \t. \"strings\"\n \t\"testing\"\n-\t\"testing/iotest\"\n )\n \n func check(t *testing.T, b *Builder, want string) {\n@@ -169,94 +166,10 @@ func TestBuilderWriteByte(t *testing.T) {\n \tcheck(t, &b, \"a\\x00\")\n }\n \n-func TestBuilderReadFrom(t *testing.T) {\n-\tfor _, tt := range []struct {\n-\t\tname string\n-\t\tfn   func(io.Reader) io.Reader\n-\t}{\n-\t\t{\"Reader\", func(r io.Reader) io.Reader { return r }},\n-\t\t{\"DataErrReader\", iotest.DataErrReader},\n-\t\t{\"OneByteReader\", iotest.OneByteReader},\n-\t} {\n-\t\tt.Run(tt.name, func(t *testing.T) {\n-\t\t\tvar b Builder\n-\n-\t\t\tr := tt.fn(NewReader(\"hello\"))\n-\t\t\tn, err := b.ReadFrom(r)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"first call: got %s\", err)\n-\t\t\t}\n-\t\t\tif n != 5 {\n-\t\t\t\tt.Errorf(\"first call: got n=%d; want 5\", n)\n-\t\t\t}\n-\t\t\tcheck(t, &b, \"hello\")\n-\n-\t\t\tr = tt.fn(NewReader(\" world\"))\n-\t\t\tn, err = b.ReadFrom(r)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"first call: got %s\", err)\n-\t\t\t}\n-\t\t\tif n != 6 {\n-\t\t\t\tt.Errorf(\"first call: got n=%d; want 6\", n)\n-\t\t\t}\n-\t\t\tcheck(t, &b, \"hello world\")\n-\t\t})\n-\t}\n-}\n-\n-var errRead = errors.New(\"boom\")\n-\n-// errorReader sends reads to the underlying reader\n-// but returns errRead instead of io.EOF.\n-type errorReader struct {\n-\tr io.Reader\n-}\n-\n-func (r errorReader) Read(b []byte) (int, error) {\n-\tn, err := r.r.Read(b)\n-\tif err == io.EOF {\n-\t\terr = errRead\n-\t}\n-\treturn n, err\n-}\n-\n-func TestBuilderReadFromError(t *testing.T) {\n-\tvar b Builder\n-\tr := errorReader{NewReader(\"hello\")}\n-\tn, err := b.ReadFrom(r)\n-\tif n != 5 {\n-\t\tt.Errorf(\"got n=%d; want 5\", n)\n-\t}\n-\tif err != errRead {\n-\t\tt.Errorf(\"got err=%q; want %q\", err, errRead)\n-\t}\n-\tcheck(t, &b, \"hello\")\n-}\n-\n-type negativeReader struct{}\n-\n-func (r negativeReader) Read([]byte) (int, error) { return -1, nil }\n-\n-func TestBuilderReadFromNegativeReader(t *testing.T) {\n-\tvar b Builder\n-\tdefer func() {\n-\t\tswitch err := recover().(type) {\n-\t\tcase nil:\n-\t\t\tt.Fatal(\"ReadFrom didn't panic\")\n-\t\tcase error:\n-\t\t\twantErr := \"strings.Builder: reader returned negative count from Read\"\n-\t\t\tif err.Error() != wantErr {\n-\t\t\t\tt.Fatalf(\"recovered panic: got %v; want %v\", err.Error(), wantErr)\n-\t\t\t}\n-\t\tdefault:\n-\t\t\tt.Fatalf(\"unexpected panic value: %#v\", err)\n-\t\t}\n-\t}()\n-\n-\tb.ReadFrom(negativeReader{})\n-}\n-\n func TestBuilderAllocs(t *testing.T) {\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\tt.Skip(\"skip for gccgo until escape analysis enabled by default\")\n+\t}\n \tvar b Builder\n \tb.Grow(5)\n \tvar s string\n@@ -270,6 +183,18 @@ func TestBuilderAllocs(t *testing.T) {\n \tif allocs > 0 {\n \t\tt.Fatalf(\"got %d alloc(s); want 0\", allocs)\n \t}\n+\n+\t// Issue 23382; verify that copyCheck doesn't force the\n+\t// Builder to escape and be heap allocated.\n+\tn := testing.AllocsPerRun(10000, func() {\n+\t\tvar b Builder\n+\t\tb.Grow(5)\n+\t\tb.WriteString(\"abcde\")\n+\t\t_ = b.String()\n+\t})\n+\tif n != 1 {\n+\t\tt.Errorf(\"Builder allocs = %v; want 1\", n)\n+\t}\n }\n \n func numAllocs(fn func()) uint64 {\n@@ -280,3 +205,103 @@ func numAllocs(fn func()) uint64 {\n \truntime.ReadMemStats(&m2)\n \treturn m2.Mallocs - m1.Mallocs\n }\n+\n+func TestBuilderCopyPanic(t *testing.T) {\n+\ttests := []struct {\n+\t\tname      string\n+\t\tfn        func()\n+\t\twantPanic bool\n+\t}{\n+\t\t{\n+\t\t\tname:      \"String\",\n+\t\t\twantPanic: false,\n+\t\t\tfn: func() {\n+\t\t\t\tvar a Builder\n+\t\t\t\ta.WriteByte('x')\n+\t\t\t\tb := a\n+\t\t\t\t_ = b.String() // appease vet\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Len\",\n+\t\t\twantPanic: false,\n+\t\t\tfn: func() {\n+\t\t\t\tvar a Builder\n+\t\t\t\ta.WriteByte('x')\n+\t\t\t\tb := a\n+\t\t\t\tb.Len()\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Reset\",\n+\t\t\twantPanic: false,\n+\t\t\tfn: func() {\n+\t\t\t\tvar a Builder\n+\t\t\t\ta.WriteByte('x')\n+\t\t\t\tb := a\n+\t\t\t\tb.Reset()\n+\t\t\t\tb.WriteByte('y')\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Write\",\n+\t\t\twantPanic: true,\n+\t\t\tfn: func() {\n+\t\t\t\tvar a Builder\n+\t\t\t\ta.Write([]byte(\"x\"))\n+\t\t\t\tb := a\n+\t\t\t\tb.Write([]byte(\"y\"))\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"WriteByte\",\n+\t\t\twantPanic: true,\n+\t\t\tfn: func() {\n+\t\t\t\tvar a Builder\n+\t\t\t\ta.WriteByte('x')\n+\t\t\t\tb := a\n+\t\t\t\tb.WriteByte('y')\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"WriteString\",\n+\t\t\twantPanic: true,\n+\t\t\tfn: func() {\n+\t\t\t\tvar a Builder\n+\t\t\t\ta.WriteString(\"x\")\n+\t\t\t\tb := a\n+\t\t\t\tb.WriteString(\"y\")\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"WriteRune\",\n+\t\t\twantPanic: true,\n+\t\t\tfn: func() {\n+\t\t\t\tvar a Builder\n+\t\t\t\ta.WriteRune('x')\n+\t\t\t\tb := a\n+\t\t\t\tb.WriteRune('y')\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"Grow\",\n+\t\t\twantPanic: true,\n+\t\t\tfn: func() {\n+\t\t\t\tvar a Builder\n+\t\t\t\ta.Grow(1)\n+\t\t\t\tb := a\n+\t\t\t\tb.Grow(2)\n+\t\t\t},\n+\t\t},\n+\t}\n+\tfor _, tt := range tests {\n+\t\tdidPanic := make(chan bool)\n+\t\tgo func() {\n+\t\t\tdefer func() { didPanic <- recover() != nil }()\n+\t\t\ttt.fn()\n+\t\t}()\n+\t\tif got := <-didPanic; got != tt.wantPanic {\n+\t\t\tt.Errorf(\"%s: panicked = %v; want %v\", tt.name, got, tt.wantPanic)\n+\t\t}\n+\t}\n+}"}, {"sha": "c4a0dc4194ab6df1df102eaef113ac5ff149f886", "filename": "libgo/go/sync/map.go", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fsync%2Fmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fsync%2Fmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fmap.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -9,20 +9,21 @@ import (\n \t\"unsafe\"\n )\n \n-// Map is a concurrent map with amortized-constant-time loads, stores, and deletes.\n-// It is safe for multiple goroutines to call a Map's methods concurrently.\n+// Map is like a Go map[interface{}]interface{} but is safe for concurrent use\n+// by multiple goroutines without additional locking or coordination.\n+// Loads, stores, and deletes run in amortized constant time.\n //\n-// It is optimized for use in concurrent loops with keys that are\n-// stable over time, and either few steady-state stores, or stores\n-// localized to one goroutine per key.\n+// The Map type is specialized. Most code should use a plain Go map instead,\n+// with separate locking or coordination, for better type safety and to make it\n+// easier to maintain other invariants along with the map content.\n //\n-// For use cases that do not share these attributes, it will likely have\n-// comparable or worse performance and worse type safety than an ordinary\n-// map paired with a read-write mutex.\n+// The Map type is optimized for two common use cases: (1) when the entry for a given\n+// key is only ever written once but read many times, as in caches that only grow,\n+// or (2) when multiple goroutines read, write, and overwrite entries for disjoint\n+// sets of keys. In these two cases, use of a Map may significantly reduce lock\n+// contention compared to a Go map paired with a separate Mutex or RWMutex.\n //\n-// The zero Map is valid and empty.\n-//\n-// A Map must not be copied after first use.\n+// The zero Map is empty and ready for use. A Map must not be copied after first use.\n type Map struct {\n \tmu Mutex\n "}, {"sha": "4c5582c809457a9689f336695e3c3220de714bfc", "filename": "libgo/go/sync/mutex.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fsync%2Fmutex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fsync%2Fmutex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fmutex.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -118,7 +118,7 @@ func (m *Mutex) Lock() {\n \t\t\t// The goroutine has been woken from sleep,\n \t\t\t// so we need to reset the flag in either case.\n \t\t\tif new&mutexWoken == 0 {\n-\t\t\t\tpanic(\"sync: inconsistent mutex state\")\n+\t\t\t\tthrow(\"sync: inconsistent mutex state\")\n \t\t\t}\n \t\t\tnew &^= mutexWoken\n \t\t}\n@@ -140,7 +140,7 @@ func (m *Mutex) Lock() {\n \t\t\t\t// inconsistent state: mutexLocked is not set and we are still\n \t\t\t\t// accounted as waiter. Fix that.\n \t\t\t\tif old&(mutexLocked|mutexWoken) != 0 || old>>mutexWaiterShift == 0 {\n-\t\t\t\t\tpanic(\"sync: inconsistent mutex state\")\n+\t\t\t\t\tthrow(\"sync: inconsistent mutex state\")\n \t\t\t\t}\n \t\t\t\tdelta := int32(mutexLocked - 1<<mutexWaiterShift)\n \t\t\t\tif !starving || old>>mutexWaiterShift == 1 {\n@@ -181,7 +181,7 @@ func (m *Mutex) Unlock() {\n \t// Fast path: drop lock bit.\n \tnew := atomic.AddInt32(&m.state, -mutexLocked)\n \tif (new+mutexLocked)&mutexLocked == 0 {\n-\t\tpanic(\"sync: unlock of unlocked mutex\")\n+\t\tthrow(\"sync: unlock of unlocked mutex\")\n \t}\n \tif new&mutexStarving == 0 {\n \t\told := new"}, {"sha": "521468439abc2b5a5f4d7a73856edbbb509381d2", "filename": "libgo/go/sync/mutex_test.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fsync%2Fmutex_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Fsync%2Fmutex_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fmutex_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -155,7 +155,10 @@ func init() {\n \tif len(os.Args) == 3 && os.Args[1] == \"TESTMISUSE\" {\n \t\tfor _, test := range misuseTests {\n \t\t\tif test.name == os.Args[2] {\n-\t\t\t\ttest.f()\n+\t\t\t\tfunc() {\n+\t\t\t\t\tdefer func() { recover() }()\n+\t\t\t\t\ttest.f()\n+\t\t\t\t}()\n \t\t\t\tfmt.Printf(\"test completed\\n\")\n \t\t\t\tos.Exit(0)\n \t\t\t}"}, {"sha": "4986898a8e1ecf4dfa107ad3229cf2165036c9bb", "filename": "libgo/go/testing/internal/testdeps/deps.go", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Ftesting%2Finternal%2Ftestdeps%2Fdeps.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Ftesting%2Finternal%2Ftestdeps%2Fdeps.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Finternal%2Ftestdeps%2Fdeps.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -11,9 +11,13 @@\n package testdeps\n \n import (\n+\t\"bufio\"\n+\t\"internal/testlog\"\n \t\"io\"\n \t\"regexp\"\n \t\"runtime/pprof\"\n+\t\"strings\"\n+\t\"sync\"\n )\n \n // TestDeps is an implementation of the testing.testDeps interface,\n@@ -56,3 +60,69 @@ var ImportPath string\n func (TestDeps) ImportPath() string {\n \treturn ImportPath\n }\n+\n+// testLog implements testlog.Interface, logging actions by package os.\n+type testLog struct {\n+\tmu  sync.Mutex\n+\tw   *bufio.Writer\n+\tset bool\n+}\n+\n+func (l *testLog) Getenv(key string) {\n+\tl.add(\"getenv\", key)\n+}\n+\n+func (l *testLog) Open(name string) {\n+\tl.add(\"open\", name)\n+}\n+\n+func (l *testLog) Stat(name string) {\n+\tl.add(\"stat\", name)\n+}\n+\n+func (l *testLog) Chdir(name string) {\n+\tl.add(\"chdir\", name)\n+}\n+\n+// add adds the (op, name) pair to the test log.\n+func (l *testLog) add(op, name string) {\n+\tif strings.Contains(name, \"\\n\") || name == \"\" {\n+\t\treturn\n+\t}\n+\n+\tl.mu.Lock()\n+\tdefer l.mu.Unlock()\n+\tif l.w == nil {\n+\t\treturn\n+\t}\n+\tl.w.WriteString(op)\n+\tl.w.WriteByte(' ')\n+\tl.w.WriteString(name)\n+\tl.w.WriteByte('\\n')\n+}\n+\n+var log testLog\n+var didSetLogger bool\n+\n+func (TestDeps) StartTestLog(w io.Writer) {\n+\tlog.mu.Lock()\n+\tlog.w = bufio.NewWriter(w)\n+\tif !log.set {\n+\t\t// Tests that define TestMain and then run m.Run multiple times\n+\t\t// will call StartTestLog/StopTestLog multiple times.\n+\t\t// Checking log.set avoids calling testlog.SetLogger multiple times\n+\t\t// (which will panic) and also avoids writing the header multiple times.\n+\t\tlog.set = true\n+\t\ttestlog.SetLogger(&log)\n+\t\tlog.w.WriteString(\"# test log\\n\") // known to cmd/go/internal/test/test.go\n+\t}\n+\tlog.mu.Unlock()\n+}\n+\n+func (TestDeps) StopTestLog() error {\n+\tlog.mu.Lock()\n+\tdefer log.mu.Unlock()\n+\terr := log.w.Flush()\n+\tlog.w = nil\n+\treturn err\n+}"}, {"sha": "f39d5ef155c68a226fa865004b257e8f50881436", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 53, "deletions": 8, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -6,8 +6,8 @@\n // It is intended to be used in concert with the ``go test'' command, which automates\n // execution of any function of the form\n //     func TestXxx(*testing.T)\n-// where Xxx can be any alphanumeric string (but the first letter must not be in\n-// [a-z]) and serves to identify the test routine.\n+// where Xxx does not start with a lowercase letter. The function name\n+// serves to identify the test routine.\n //\n // Within these functions, use the Error, Fail or related methods to signal failure.\n //\n@@ -268,10 +268,12 @@ var (\n \ttimeout              = flag.Duration(\"test.timeout\", 0, \"panic test binary after duration `d` (default 0, timeout disabled)\")\n \tcpuListStr           = flag.String(\"test.cpu\", \"\", \"comma-separated `list` of cpu counts to run each test with\")\n \tparallel             = flag.Int(\"test.parallel\", runtime.GOMAXPROCS(0), \"run at most `n` tests in parallel\")\n+\ttestlog              = flag.String(\"test.testlogfile\", \"\", \"write test action log to `file` (for use only by cmd/go)\")\n \n \thaveExamples bool // are there examples?\n \n-\tcpuList []int\n+\tcpuList     []int\n+\ttestlogFile *os.File\n \n \tnumFailed uint32 // number of test failures\n )\n@@ -518,7 +520,8 @@ func (c *common) Failed() bool {\n }\n \n // FailNow marks the function as having failed and stops its execution\n-// by calling runtime.Goexit.\n+// by calling runtime.Goexit (which then runs all deferred calls in the\n+// current goroutine).\n // Execution will continue at the next test or benchmark.\n // FailNow must be called from the goroutine running the\n // test or benchmark function, not from other goroutines\n@@ -779,9 +782,9 @@ func tRunner(t *T, fn func(t *T)) {\n \tt.finished = true\n }\n \n-// Run runs f as a subtest of t called name. It reports whether f succeeded. Run\n-// runs f in a separate goroutine and will block until all its parallel subtests\n-// have completed.\n+// Run runs f as a subtest of t called name. It runs f in a separate goroutine\n+// and blocks until f returns or calls t.Parallel to become a parallel test.\n+// Run reports whether f succeeded (or at least did not fail before calling t.Parallel).\n //\n // Run may be called simultaneously from multiple goroutines, but all such calls\n // must return before the outer test function for t returns.\n@@ -889,6 +892,8 @@ func (f matchStringOnly) StopCPUProfile()                             {}\n func (f matchStringOnly) WriteHeapProfile(w io.Writer) error          { return errMain }\n func (f matchStringOnly) WriteProfileTo(string, io.Writer, int) error { return errMain }\n func (f matchStringOnly) ImportPath() string                          { return \"\" }\n+func (f matchStringOnly) StartTestLog(io.Writer)                      {}\n+func (f matchStringOnly) StopTestLog() error                          { return errMain }\n \n // Main is an internal function, part of the implementation of the \"go test\" command.\n // It was exported because it is cross-package and predates \"internal\" packages.\n@@ -909,19 +914,23 @@ type M struct {\n \n \ttimer     *time.Timer\n \tafterOnce sync.Once\n+\n+\tnumRun int\n }\n \n // testDeps is an internal interface of functionality that is\n // passed into this package by a test's generated main package.\n // The canonical implementation of this interface is\n // testing/internal/testdeps's TestDeps.\n type testDeps interface {\n+\tImportPath() string\n \tMatchString(pat, str string) (bool, error)\n \tStartCPUProfile(io.Writer) error\n \tStopCPUProfile()\n+\tStartTestLog(io.Writer)\n+\tStopTestLog() error\n \tWriteHeapProfile(io.Writer) error\n \tWriteProfileTo(string, io.Writer, int) error\n-\tImportPath() string\n }\n \n // MainStart is meant for use by tests generated by 'go test'.\n@@ -938,6 +947,12 @@ func MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchma\n \n // Run runs the tests. It returns an exit code to pass to os.Exit.\n func (m *M) Run() int {\n+\t// Count the number of calls to m.Run.\n+\t// We only ever expected 1, but we didn't enforce that,\n+\t// and now there are tests in the wild that call m.Run multiple times.\n+\t// Sigh. golang.org/issue/23129.\n+\tm.numRun++\n+\n \t// TestMain may have already called flag.Parse.\n \tif !flag.Parsed() {\n \t\tflag.Parse()\n@@ -1100,6 +1115,26 @@ func (m *M) before() {\n \t\tfmt.Fprintf(os.Stderr, \"testing: cannot use -test.coverprofile because test binary was not built with coverage enabled\\n\")\n \t\tos.Exit(2)\n \t}\n+\tif *testlog != \"\" {\n+\t\t// Note: Not using toOutputDir.\n+\t\t// This file is for use by cmd/go, not users.\n+\t\tvar f *os.File\n+\t\tvar err error\n+\t\tif m.numRun == 1 {\n+\t\t\tf, err = os.Create(*testlog)\n+\t\t} else {\n+\t\t\tf, err = os.OpenFile(*testlog, os.O_WRONLY, 0)\n+\t\t\tif err == nil {\n+\t\t\t\tf.Seek(0, io.SeekEnd)\n+\t\t\t}\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testing: %s\\n\", err)\n+\t\t\tos.Exit(2)\n+\t\t}\n+\t\tm.deps.StartTestLog(f)\n+\t\ttestlogFile = f\n+\t}\n }\n \n // after runs after all testing.\n@@ -1110,6 +1145,16 @@ func (m *M) after() {\n }\n \n func (m *M) writeProfiles() {\n+\tif *testlog != \"\" {\n+\t\tif err := m.deps.StopTestLog(); err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testing: can't write %s: %s\\n\", *testlog, err)\n+\t\t\tos.Exit(2)\n+\t\t}\n+\t\tif err := testlogFile.Close(); err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testing: can't write %s: %s\\n\", *testlog, err)\n+\t\t\tos.Exit(2)\n+\t\t}\n+\t}\n \tif *cpuProfile != \"\" {\n \t\tm.deps.StopCPUProfile() // flushes profile to disk\n \t}"}, {"sha": "cfacb9c40d09f6f1d5c5d7da37e26673b8fc6984", "filename": "libgo/misc/cgo/test/cgo_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -86,5 +86,6 @@ func Test21809(t *testing.T)                 { test21809(t) }\n func Test6907(t *testing.T)                  { test6907(t) }\n func Test6907Go(t *testing.T)                { test6907Go(t) }\n func Test21897(t *testing.T)                 { test21897(t) }\n+func Test22906(t *testing.T)                 { test22906(t) }\n \n func BenchmarkCgoCall(b *testing.B) { benchCgoCall(b) }"}, {"sha": "02bae9cfa7d13a8b819321b7b61ff1f4cd4f5f10", "filename": "libgo/misc/cgo/test/test22906.go", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fmisc%2Fcgo%2Ftest%2Ftest22906.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fmisc%2Fcgo%2Ftest%2Ftest22906.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Ftest22906.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build cgo\n+\n+package cgotest\n+\n+/*\n+\n+// It's going to be hard to include a whole real JVM to test this.\n+// So we'll simulate a really easy JVM using just the parts we need.\n+\n+// This is the relevant part of jni.h.\n+\n+struct _jobject;\n+\n+typedef struct _jobject *jobject;\n+typedef jobject jclass;\n+typedef jobject jthrowable;\n+typedef jobject jstring;\n+typedef jobject jarray;\n+typedef jarray jbooleanArray;\n+typedef jarray jbyteArray;\n+typedef jarray jcharArray;\n+typedef jarray jshortArray;\n+typedef jarray jintArray;\n+typedef jarray jlongArray;\n+typedef jarray jfloatArray;\n+typedef jarray jdoubleArray;\n+typedef jarray jobjectArray;\n+\n+typedef jobject jweak;\n+\n+// Note: jvalue is already a non-pointer type due to it being a C union.\n+\n+*/\n+import \"C\"\n+import (\n+\t\"testing\"\n+)\n+\n+func test22906(t *testing.T) {\n+\tvar x1 C.jobject = 0 // Note: 0, not nil. That makes sure we use uintptr for these types.\n+\t_ = x1\n+\tvar x2 C.jclass = 0\n+\t_ = x2\n+\tvar x3 C.jthrowable = 0\n+\t_ = x3\n+\tvar x4 C.jstring = 0\n+\t_ = x4\n+\tvar x5 C.jarray = 0\n+\t_ = x5\n+\tvar x6 C.jbooleanArray = 0\n+\t_ = x6\n+\tvar x7 C.jbyteArray = 0\n+\t_ = x7\n+\tvar x8 C.jcharArray = 0\n+\t_ = x8\n+\tvar x9 C.jshortArray = 0\n+\t_ = x9\n+\tvar x10 C.jintArray = 0\n+\t_ = x10\n+\tvar x11 C.jlongArray = 0\n+\t_ = x11\n+\tvar x12 C.jfloatArray = 0\n+\t_ = x12\n+\tvar x13 C.jdoubleArray = 0\n+\t_ = x13\n+\tvar x14 C.jobjectArray = 0\n+\t_ = x14\n+\tvar x15 C.jweak = 0\n+\t_ = x15\n+}"}, {"sha": "306844bdc80a6b56c9792837b7176c78545b9399", "filename": "libgo/misc/cgo/testsanitizers/cc_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fcc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d6367f848cfd8381aba41e035c5e7e873667c5/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fcc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fcc_test.go?ref=c6d6367f848cfd8381aba41e035c5e7e873667c5", "patch": "@@ -407,7 +407,7 @@ func (d *tempDir) RemoveAll(t *testing.T) {\n \t\treturn\n \t}\n \tif err := os.RemoveAll(d.base); err != nil {\n-\t\tt.Fatal(\"Failed to remove temp dir: %v\", err)\n+\t\tt.Fatalf(\"Failed to remove temp dir: %v\", err)\n \t}\n }\n "}]}