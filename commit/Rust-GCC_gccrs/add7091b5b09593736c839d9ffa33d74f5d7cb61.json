{"sha": "add7091b5b09593736c839d9ffa33d74f5d7cb61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRkNzA5MWI1YjA5NTkzNzM2YzgzOWQ5ZmZhMzNkNzRmNWQ3Y2I2MQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@rabi.phys.columbia.edu", "date": "1998-10-29T11:54:13Z"}, "committer": {"name": "Dave Brolley", "email": "brolley@gcc.gnu.org", "date": "1998-10-29T11:54:13Z"}, "message": "[multiple changes]\n\n1998-10-28 16:10 -0500\tZack Weinberg  <zack@rabi.phys.columbia.edu>\n\t * c-lang.c: Declare extern char *yy_cur if USE_CPPLIB.\n\t   (lang_init): Call check_newline always.\n\t * c-lex.c (init_parse) [USE_CPPLIB=1]: After calling\n\t   cpp_start_read, set yy_cur and yy_lim to read from\n\t   parse_in.token_buffer, so that we'll see the first #line\n\t   directive.\n\t * cpplib.c (cpp_start_read): finclude the main input file\n\t   before processing -include/-imacros.\t Process -imacros and\n\t   -include separately, and handle -include by stacking a\n\t   buffer for the file in question as if it'd been #included.\n\t * toplev.c (documented_lang_options) Recognize -H when\n\t   USE_CPPLIB is on.\n1998-10-28 16:09 -0500\tZack Weinberg  <zack@rabi.phys.columbia.edu>\n\t * cpplib.c: Merge do_once into do_pragma.  Break file handling\n\t   code out of do_include.\n\t   Move append_include_chain, deps_output,\n\t   file_cleanup, redundant_include_p, import_hash,\n\t   lookup_import, add_import, read_filename_string, read_name_map,\n\t   open_include_file, finclude, safe_read to cppfiles.c.\n\t   Move prototypes for deps_output, append_include_chain,\n\t   finclude to cpplib.h.  Move definition of struct\n\t   file_name_list there also.\n\t * cppfiles.c: New file.  Contains all the above functions\n\t   broken out of cpplib.c; also hack_vms_include_specification\n\t   from cccp.c and find_include_file, a new function broken out of\n\t   do_include.\n\t * Makefile.in (cppmain): Depend on cppfiles.o.\n\t   (fix-header): Likewise.\n\t   (cppfiles.o): New target.\n\t * configure.in (--enable-c-cpplib): Add cppfiles.o to\n\t   extra_c_objs.  Add ../cppfiles.o to extra_cxx_objs.\n\nFrom-SVN: r23424", "tree": {"sha": "7471f4f8da9d046f66479432942077da10b066ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7471f4f8da9d046f66479432942077da10b066ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/add7091b5b09593736c839d9ffa33d74f5d7cb61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/add7091b5b09593736c839d9ffa33d74f5d7cb61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/add7091b5b09593736c839d9ffa33d74f5d7cb61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/add7091b5b09593736c839d9ffa33d74f5d7cb61/comments", "author": null, "committer": null, "parents": [{"sha": "0fc1434bd0b2e9c1f3649d8b1df27e37403dda33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fc1434bd0b2e9c1f3649d8b1df27e37403dda33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fc1434bd0b2e9c1f3649d8b1df27e37403dda33"}], "stats": {"total": 2186, "additions": 1273, "deletions": 913}, "files": [{"sha": "8eb81d2c43fe0ecca5322631e23fb87c10f2320c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add7091b5b09593736c839d9ffa33d74f5d7cb61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add7091b5b09593736c839d9ffa33d74f5d7cb61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=add7091b5b09593736c839d9ffa33d74f5d7cb61", "patch": "@@ -86,6 +86,44 @@ Wed Oct 28 16:46:07 1998  Andreas Schwab  <schwab@issan.cs.uni-dortmund.de>\n \t(purge_addressof_replacements): New variable.\n \t(purge_addressof): Clear it at end.\n \n+1998-10-28 16:10 -0500\tZack Weinberg  <zack@rabi.phys.columbia.edu>\n+\n+\t * c-lang.c: Declare extern char *yy_cur if USE_CPPLIB.\n+\t   (lang_init): Call check_newline always.\n+\t * c-lex.c (init_parse) [USE_CPPLIB=1]: After calling\n+\t   cpp_start_read, set yy_cur and yy_lim to read from\n+\t   parse_in.token_buffer, so that we'll see the first #line\n+\t   directive.\n+\t * cpplib.c (cpp_start_read): finclude the main input file\n+\t   before processing -include/-imacros.\t Process -imacros and\n+\t   -include separately, and handle -include by stacking a\n+\t   buffer for the file in question as if it'd been #included.\n+\t * toplev.c (documented_lang_options) Recognize -H when\n+\t   USE_CPPLIB is on.\n+\n+1998-10-28 16:09 -0500\tZack Weinberg  <zack@rabi.phys.columbia.edu>\n+\n+\t * cpplib.c: Merge do_once into do_pragma.  Break file handling\n+\t   code out of do_include.\n+\t   Move append_include_chain, deps_output,\n+\t   file_cleanup, redundant_include_p, import_hash,\n+\t   lookup_import, add_import, read_filename_string, read_name_map,\n+\t   open_include_file, finclude, safe_read to cppfiles.c.\n+\t   Move prototypes for deps_output, append_include_chain,\n+\t   finclude to cpplib.h.  Move definition of struct\n+\t   file_name_list there also.\n+\n+\t * cppfiles.c: New file.  Contains all the above functions\n+\t   broken out of cpplib.c; also hack_vms_include_specification\n+\t   from cccp.c and find_include_file, a new function broken out of\n+\t   do_include.\n+\n+\t * Makefile.in (cppmain): Depend on cppfiles.o.\n+\t   (fix-header): Likewise.\n+\t   (cppfiles.o): New target.\n+\t * configure.in (--enable-c-cpplib): Add cppfiles.o to\n+\t   extra_c_objs.  Add ../cppfiles.o to extra_cxx_objs.\n+\n Wed Oct 28 14:06:49 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* dwarfout.c (dwarfout_file_scope_decl): If DECL_CONTEXT, don't abort"}, {"sha": "c407d28bfb69fc17f619d6457b2f5502ec98ecd6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add7091b5b09593736c839d9ffa33d74f5d7cb61/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add7091b5b09593736c839d9ffa33d74f5d7cb61/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=add7091b5b09593736c839d9ffa33d74f5d7cb61", "patch": "@@ -1881,7 +1881,7 @@ cccp.o: cccp.c $(CONFIG_H) pcp.h version.c config.status system.h gansidecl.h \\\n \t  -DTOOL_INCLUDE_DIR=\\\"$(tooldir)/include\\\" \\\n \t  -c `echo $(srcdir)/cccp.c | sed 's,^\\./,,'`\n \n-LIBCPP_OBJS =\tcpplib.o cpphash.o cppalloc.o cpperror.o cppexp.o \\\n+LIBCPP_OBJS =\tcpplib.o cpphash.o cppalloc.o cpperror.o cppexp.o cppfiles.o \\\n \t\tcppulp.o prefix.o version.o mbchar.o @extra_cpp_objs@\n \n libcpp.a: $(LIBCPP_OBJS)\n@@ -1907,6 +1907,8 @@ cpperror.o: cpperror.c $(CONFIG_H) cpplib.h system.h gansidecl.h\n \n cppexp.o: cppexp.c $(CONFIG_H) cpplib.h system.h gansidecl.h\n \n+cppfiles.o: cppfiles.c $(CONFIG_H) cpplib.h system.h gansidecl.h\n+\n cpphash.o: cpphash.c cpplib.h cpphash.h $(CONFIG_H) system.h gansidecl.h\n \n cppalloc.o: cppalloc.c $(CONFIG_H) cpplib.h system.h gansidecl.h"}, {"sha": "6e04bd76f8b23d3ff8e7103bb54a57789480437f", "filename": "gcc/c-lang.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add7091b5b09593736c839d9ffa33d74f5d7cb61/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add7091b5b09593736c839d9ffa33d74f5d7cb61/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=add7091b5b09593736c839d9ffa33d74f5d7cb61", "patch": "@@ -28,6 +28,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"output.h\"\n \n+#if USE_CPPLIB\n+extern char *yy_cur;\n+#endif\n+\n /* Each of the functions defined here\n    is an alternative to a function in objc-actions.c.  */\n    \n@@ -47,12 +51,15 @@ lang_init_options ()\n void\n lang_init ()\n {\n-#if !USE_CPPLIB\n   /* the beginning of the file is a new line; check for # */\n   /* With luck, we discover the real source file's name from that\n      and put it in input_filename.  */\n+#if !USE_CPPLIB\n   ungetc (check_newline (), finput);\n-#endif\n+#else\n+  check_newline ();\n+  yy_cur--;\n+#endif \n }\n \n void"}, {"sha": "b6d8295606c21bbb8b1cdecb17f0011d11d3b03f", "filename": "gcc/c-lex.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add7091b5b09593736c839d9ffa33d74f5d7cb61/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add7091b5b09593736c839d9ffa33d74f5d7cb61/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=add7091b5b09593736c839d9ffa33d74f5d7cb61", "patch": "@@ -194,12 +194,14 @@ init_parse (filename)\n   init_lex ();\n \n #if USE_CPPLIB\n-  yy_cur = \"\\n\";\n-  yy_lim = yy_cur+1;\n-\n   parse_in.show_column = 1;\n   if (! cpp_start_read (&parse_in, filename))\n     abort ();\n+\n+  /* cpp_start_read always puts at least one line directive into the\n+     token buffer.  We must arrange to read it out here. */\n+  yy_cur = parse_in.token_buffer;\n+  yy_lim = CPP_PWRITTEN (&parse_in);\n #endif\n \n   return filename;"}, {"sha": "559cc118985aee683d3315463ff1a31d4fa4a587", "filename": "gcc/cppfiles.c", "status": "added", "additions": 1023, "deletions": 0, "changes": 1023, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add7091b5b09593736c839d9ffa33d74f5d7cb61/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add7091b5b09593736c839d9ffa33d74f5d7cb61/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=add7091b5b09593736c839d9ffa33d74f5d7cb61", "patch": "@@ -0,0 +1,1023 @@\n+/* Part of CPP library.  (include file handling)\n+   Copyright (C) 1986, 87, 89, 92 - 95, 1998 Free Software Foundation, Inc.\n+   Written by Per Bothner, 1994.\n+   Based on CCCP program by Paul Rubin, June 1986\n+   Adapted to ANSI C, Richard Stallman, Jan 1987\n+   Split out of cpplib.c, Zack Weinberg, Oct 1998\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+\n+ In other words, you are welcome to use, share and improve this program.\n+ You are forbidden to forbid anyone else to use, share and improve\n+ what you give them.   Help stamp out software-hoarding!  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"gansidecl.h\"\n+#include \"cpplib.h\"\n+\n+/* The entry points to this file are: find_include_file, finclude,\n+   append_include_chain, deps_output, and file_cleanup.\n+   file_cleanup is only called through CPP_BUFFER(pfile)->cleanup,\n+   so it's static anyway. */\n+\n+static void add_import\t\t\tPROTO ((cpp_reader *, int, char *));\n+static int lookup_import\t\tPROTO ((cpp_reader *, char *,\n+\t\t\t\t\t\tstruct file_name_list *));\n+static int redundant_include_p\t\tPROTO ((cpp_reader *, char *));\n+static struct file_name_map *read_name_map\tPROTO ((cpp_reader *, char *));\n+static char *read_filename_string\tPROTO ((int, FILE *));\n+static int open_include_file\t\tPROTO ((cpp_reader *, char *,\n+\t\t\t\t\t\tstruct file_name_list *));\n+static int safe_read\t\t\tPROTO ((int, char *, int));\n+\n+/* Not safe to prototype these. */\n+extern char *xmalloc();\n+extern char *xrealloc();\n+\n+/* Append a chain of `struct file_name_list's\n+   to the end of the main include chain.\n+   FIRST is the beginning of the chain to append, and LAST is the end.  */\n+\n+void\n+append_include_chain (pfile, first, last)\n+     cpp_reader *pfile;\n+     struct file_name_list *first, *last;\n+{\n+  struct cpp_options *opts = CPP_OPTIONS (pfile);\n+  struct file_name_list *dir;\n+\n+  if (!first || !last)\n+    return;\n+\n+  if (opts->include == 0)\n+    opts->include = first;\n+  else\n+    opts->last_include->next = first;\n+\n+  if (opts->first_bracket_include == 0)\n+    opts->first_bracket_include = first;\n+\n+  for (dir = first; ; dir = dir->next) {\n+    int len = strlen (dir->fname) + INCLUDE_LEN_FUDGE;\n+    if (len > pfile->max_include_len)\n+      pfile->max_include_len = len;\n+    if (dir == last)\n+      break;\n+  }\n+\n+  last->next = NULL;\n+  opts->last_include = last;\n+}\n+\n+/* Add output to `deps_buffer' for the -M switch.\n+   STRING points to the text to be output.\n+   SPACER is ':' for targets, ' ' for dependencies, zero for text\n+   to be inserted literally.  */\n+\n+void\n+deps_output (pfile, string, spacer)\n+     cpp_reader *pfile;\n+     char *string;\n+     int spacer;\n+{\n+  int size;\n+\n+  if (!*string)\n+    return;\n+\n+#ifdef VMS\n+  hack_vms_include_specification (string);\n+#endif\n+\n+  size = strlen (string);\n+\n+#ifndef MAX_OUTPUT_COLUMNS\n+#define MAX_OUTPUT_COLUMNS 72\n+#endif\n+  if (spacer\n+      && pfile->deps_column > 0\n+      && (pfile->deps_column + size) > MAX_OUTPUT_COLUMNS)\n+    {\n+      deps_output (pfile, \" \\\\\\n  \", 0);\n+      pfile->deps_column = 0;\n+    }\n+\n+  if (pfile->deps_size + size + 8 > pfile->deps_allocated_size)\n+    {\n+      pfile->deps_allocated_size = (pfile->deps_size + size + 50) * 2;\n+      pfile->deps_buffer = (char *) xrealloc (pfile->deps_buffer,\n+\t\t\t\t\t      pfile->deps_allocated_size);\n+    }\n+  if (spacer == ' ' && pfile->deps_column > 0)\n+    pfile->deps_buffer[pfile->deps_size++] = ' ';\n+  bcopy (string, &pfile->deps_buffer[pfile->deps_size], size);\n+  pfile->deps_size += size;\n+  pfile->deps_column += size;\n+  if (spacer == ':')\n+    pfile->deps_buffer[pfile->deps_size++] = ':';\n+  pfile->deps_buffer[pfile->deps_size] = 0;\n+}\n+\n+static int\n+file_cleanup (pbuf, pfile)\n+     cpp_buffer *pbuf;\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  if (pbuf->buf)\n+    {\n+      free (pbuf->buf);\n+      pbuf->buf = 0;\n+    }\n+  return 0;\n+}\n+\n+int\n+find_include_file (pfile, fbeg, flen, fname,\n+\t\t   importing, search_start, foundhere)\n+     cpp_reader *pfile;\n+     char *fbeg;\n+     unsigned long flen;\n+     char *fname;\n+     int importing;\n+     struct file_name_list *search_start;\n+     struct file_name_list **foundhere;\n+{\n+  struct file_name_list *searchptr;\n+  int f;\n+    \n+  /* If specified file name is absolute, just open it.  */\n+\n+  if (*fbeg == '/')\n+  {\n+    strcpy (fname, fbeg);\n+#ifdef VMS\n+    hack_vms_include_specification (fname);\n+#endif\n+    if (redundant_include_p (pfile, fname))\n+      return -2;\n+    if (importing)\n+      f = lookup_import (pfile, fname, NULL_PTR);\n+    else\n+      f = open_include_file (pfile, fname, NULL_PTR);\n+    if (f == -2)\n+      return -2;\t/* Already included this file */\n+  }\n+  else\n+  {\n+    /* Search directory path, trying to open the file.\n+       Copy each filename tried into FNAME.  */\n+\n+    for (searchptr = search_start; searchptr; searchptr = searchptr->next)\n+    {\n+      unsigned int l = 0;\n+      if (searchptr->fname)\n+      {\n+\t/* The empty string in a search path is ignored.\n+\t   This makes it possible to turn off entirely\n+\t   a standard piece of the list.  */\n+\tif (searchptr->fname[0] == 0)\n+\t  continue;\n+\n+\tl = strlen (searchptr->fname);\n+\n+\tbcopy (searchptr->fname, fname, l);\n+\tfname[l++] = '/';\n+      }\n+\n+      bcopy (fbeg, &fname[l], flen);\n+      fname[flen+l] = '\\0';\n+#ifdef VMS\n+      hack_vms_include_specification (fname);\n+#endif /* VMS */\n+      /* ??? There are currently 3 separate mechanisms for avoiding processing\n+\t of redundant include files: #import, #pragma once, and\n+\t redundant_include_p.  It would be nice if they were unified.  */\n+      if (redundant_include_p (pfile, fname))\n+\treturn -2;\n+      if (importing)\n+\tf = lookup_import (pfile, fname, searchptr);\n+      else\n+\tf = open_include_file (pfile, fname, searchptr);\n+      if (f == -2)\n+\treturn -2;\t\t\t/* Already included this file */\n+#ifdef EACCES\n+      else if (f == -1 && errno == EACCES)\n+\tcpp_warning (pfile, \"Header file %s exists, but is not readable\",\n+\t\t     fname);\n+#endif\n+      if (f >= 0)\n+\tbreak;\n+    }\n+  }\n+\n+  if (f < 0)\n+    {\n+      /* A file that was not found.  */\n+      bcopy (fbeg, fname, flen);\n+      fname[flen] = 0;\n+\n+      return -1;\n+    }\n+  else\n+    {\n+      /* Check to see if this include file is a once-only include file.\n+\t If so, give up.  */\n+\n+      struct file_name_list *ptr;\n+\n+      for (ptr = pfile->dont_repeat_files; ptr; ptr = ptr->next)\n+\t  if (!strcmp (ptr->fname, fname))\n+\t    {\n+\t      close (f);\n+\t      return -2;\t\t/* This file was once'd.  */\n+\t    }\n+    }\n+\n+    /* Record file on \"seen\" list for #import.  */\n+    add_import (pfile, f, fname);\n+\n+    *foundhere = searchptr;\n+    return f;\n+}\n+\n+/* Return nonzero if there is no need to include file NAME\n+   because it has already been included and it contains a conditional\n+   to make a repeated include do nothing.  */\n+\n+static int\n+redundant_include_p (pfile, name)\n+     cpp_reader *pfile;\n+     char *name;\n+{\n+  struct file_name_list *l = pfile->all_include_files;\n+  for (; l; l = l->next)\n+    if (! strcmp (name, l->fname)\n+\t&& l->control_macro\n+\t&& cpp_lookup (pfile, l->control_macro, -1, -1))\n+      return 1;\n+  return 0;\n+}\n+\n+\n+\n+/* Maintain and search list of included files, for #import.  */\n+\n+/* Hash a file name for import_hash_table.  */\n+\n+static int \n+import_hash (f)\n+     char *f;\n+{\n+  int val = 0;\n+\n+  while (*f) val += *f++;\n+  return (val%IMPORT_HASH_SIZE);\n+}\n+\n+/* Search for file FILENAME in import_hash_table.\n+   Return -2 if found, either a matching name or a matching inode.\n+   Otherwise, open the file and return a file descriptor if successful\n+   or -1 if unsuccessful.  */\n+\n+static int\n+lookup_import (pfile, filename, searchptr)\n+     cpp_reader *pfile;\n+     char *filename;\n+     struct file_name_list *searchptr;\n+{\n+  struct import_file *i;\n+  int h;\n+  int hashval;\n+  struct stat sb;\n+  int fd;\n+\n+  hashval = import_hash (filename);\n+\n+  /* Attempt to find file in list of already included files */\n+  i = pfile->import_hash_table[hashval];\n+\n+  while (i) {\n+    if (!strcmp (filename, i->name))\n+      return -2;\t\t/* return found */\n+    i = i->next;\n+  }\n+  /* Open it and try a match on inode/dev */\n+  fd = open_include_file (pfile, filename, searchptr);\n+  if (fd < 0)\n+    return fd;\n+  fstat (fd, &sb);\n+  for (h = 0; h < IMPORT_HASH_SIZE; h++) {\n+    i = pfile->import_hash_table[h];\n+    while (i) {\n+      /* Compare the inode and the device.\n+\t Supposedly on some systems the inode is not a scalar.  */\n+      if (!bcmp ((char *) &i->inode, (char *) &sb.st_ino, sizeof (sb.st_ino))\n+\t  && i->dev == sb.st_dev) {\n+        close (fd);\n+        return -2;\t\t/* return found */\n+      }\n+      i = i->next;\n+    }\n+  }\n+  return fd;\t\t\t/* Not found, return open file */\n+}\n+\n+/* Add the file FNAME, open on descriptor FD, to import_hash_table.  */\n+\n+static void\n+add_import (pfile, fd, fname)\n+     cpp_reader *pfile;\n+     int fd;\n+     char *fname;\n+{\n+  struct import_file *i;\n+  int hashval;\n+  struct stat sb;\n+\n+  hashval = import_hash (fname);\n+  fstat (fd, &sb);\n+  i = (struct import_file *)xmalloc (sizeof (struct import_file));\n+  i->name = (char *)xmalloc (strlen (fname)+1);\n+  strcpy (i->name, fname);\n+  bcopy ((char *) &sb.st_ino, (char *) &i->inode, sizeof (sb.st_ino));\n+  i->dev = sb.st_dev;\n+  i->next = pfile->import_hash_table[hashval];\n+  pfile->import_hash_table[hashval] = i;\n+}\n+\n+/* The file_name_map structure holds a mapping of file names for a\n+   particular directory.  This mapping is read from the file named\n+   FILE_NAME_MAP_FILE in that directory.  Such a file can be used to\n+   map filenames on a file system with severe filename restrictions,\n+   such as DOS.  The format of the file name map file is just a series\n+   of lines with two tokens on each line.  The first token is the name\n+   to map, and the second token is the actual name to use.  */\n+\n+struct file_name_map\n+{\n+  struct file_name_map *map_next;\n+  char *map_from;\n+  char *map_to;\n+};\n+\n+#define FILE_NAME_MAP_FILE \"header.gcc\"\n+\n+/* Read a space delimited string of unlimited length from a stdio\n+   file.  */\n+\n+static char *\n+read_filename_string (ch, f)\n+     int ch;\n+     FILE *f;\n+{\n+  char *alloc, *set;\n+  int len;\n+\n+  len = 20;\n+  set = alloc = xmalloc (len + 1);\n+  if (! is_space[ch])\n+    {\n+      *set++ = ch;\n+      while ((ch = getc (f)) != EOF && ! is_space[ch])\n+\t{\n+\t  if (set - alloc == len)\n+\t    {\n+\t      len *= 2;\n+\t      alloc = xrealloc (alloc, len + 1);\n+\t      set = alloc + len / 2;\n+\t    }\n+\t  *set++ = ch;\n+\t}\n+    }\n+  *set = '\\0';\n+  ungetc (ch, f);\n+  return alloc;\n+}\n+\n+/* This structure holds a linked list of file name maps, one per directory.  */\n+\n+struct file_name_map_list\n+{\n+  struct file_name_map_list *map_list_next;\n+  char *map_list_name;\n+  struct file_name_map *map_list_map;\n+};\n+\n+/* Read the file name map file for DIRNAME.  */\n+\n+static struct file_name_map *\n+read_name_map (pfile, dirname)\n+     cpp_reader *pfile;\n+     char *dirname;\n+{\n+  register struct file_name_map_list *map_list_ptr;\n+  char *name;\n+  FILE *f;\n+\n+  for (map_list_ptr = CPP_OPTIONS (pfile)->map_list; map_list_ptr;\n+       map_list_ptr = map_list_ptr->map_list_next)\n+    if (! strcmp (map_list_ptr->map_list_name, dirname))\n+      return map_list_ptr->map_list_map;\n+\n+  map_list_ptr = ((struct file_name_map_list *)\n+\t\t  xmalloc (sizeof (struct file_name_map_list)));\n+  map_list_ptr->map_list_name = savestring (dirname);\n+  map_list_ptr->map_list_map = NULL;\n+\n+  name = (char *) alloca (strlen (dirname) + strlen (FILE_NAME_MAP_FILE) + 2);\n+  strcpy (name, dirname);\n+  if (*dirname)\n+    strcat (name, \"/\");\n+  strcat (name, FILE_NAME_MAP_FILE);\n+  f = fopen (name, \"r\");\n+  if (!f)\n+    map_list_ptr->map_list_map = NULL;\n+  else\n+    {\n+      int ch;\n+      int dirlen = strlen (dirname);\n+\n+      while ((ch = getc (f)) != EOF)\n+\t{\n+\t  char *from, *to;\n+\t  struct file_name_map *ptr;\n+\n+\t  if (is_space[ch])\n+\t    continue;\n+\t  from = read_filename_string (ch, f);\n+\t  while ((ch = getc (f)) != EOF && is_hor_space[ch])\n+\t    ;\n+\t  to = read_filename_string (ch, f);\n+\n+\t  ptr = ((struct file_name_map *)\n+\t\t xmalloc (sizeof (struct file_name_map)));\n+\t  ptr->map_from = from;\n+\n+\t  /* Make the real filename absolute.  */\n+\t  if (*to == '/')\n+\t    ptr->map_to = to;\n+\t  else\n+\t    {\n+\t      ptr->map_to = xmalloc (dirlen + strlen (to) + 2);\n+\t      strcpy (ptr->map_to, dirname);\n+\t      ptr->map_to[dirlen] = '/';\n+\t      strcpy (ptr->map_to + dirlen + 1, to);\n+\t      free (to);\n+\t    }\t      \n+\n+\t  ptr->map_next = map_list_ptr->map_list_map;\n+\t  map_list_ptr->map_list_map = ptr;\n+\n+\t  while ((ch = getc (f)) != '\\n')\n+\t    if (ch == EOF)\n+\t      break;\n+\t}\n+      fclose (f);\n+    }\n+  \n+  map_list_ptr->map_list_next = CPP_OPTIONS (pfile)->map_list;\n+  CPP_OPTIONS (pfile)->map_list = map_list_ptr;\n+\n+  return map_list_ptr->map_list_map;\n+}  \n+\n+/* Try to open include file FILENAME.  SEARCHPTR is the directory\n+   being tried from the include file search path.  This function maps\n+   filenames on file systems based on information read by\n+   read_name_map.  */\n+\n+static int\n+open_include_file (pfile, filename, searchptr)\n+     cpp_reader *pfile;\n+     char *filename;\n+     struct file_name_list *searchptr;\n+{\n+  if (CPP_OPTIONS (pfile)->remap)\n+    {\n+      register struct file_name_map *map;\n+      register char *from;\n+      char *p, *dir;\n+\n+      if (searchptr && ! searchptr->got_name_map)\n+\t{\n+\t  searchptr->name_map = read_name_map (pfile,\n+\t\t\t\t\t       searchptr->fname\n+\t\t\t\t\t       ? searchptr->fname : \".\");\n+\t  searchptr->got_name_map = 1;\n+\t}\n+\n+      /* First check the mapping for the directory we are using.  */\n+      if (searchptr && searchptr->name_map)\n+\t{\n+\t  from = filename;\n+\t  if (searchptr->fname)\n+\t    from += strlen (searchptr->fname) + 1;\n+\t  for (map = searchptr->name_map; map; map = map->map_next)\n+\t    {\n+\t      if (! strcmp (map->map_from, from))\n+\t\t{\n+\t\t  /* Found a match.  */\n+\t\t  return open (map->map_to, O_RDONLY, 0666);\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* Try to find a mapping file for the particular directory we are\n+\t looking in.  Thus #include <sys/types.h> will look up sys/types.h\n+\t in /usr/include/header.gcc and look up types.h in\n+\t /usr/include/sys/header.gcc.  */\n+      p = rindex (filename, '/');\n+      if (! p)\n+\tp = filename;\n+      if (searchptr\n+\t  && searchptr->fname\n+\t  && strlen (searchptr->fname) == (size_t) (p - filename)\n+\t  && ! strncmp (searchptr->fname, filename, p - filename))\n+\t{\n+\t  /* FILENAME is in SEARCHPTR, which we've already checked.  */\n+\t  return open (filename, O_RDONLY, 0666);\n+\t}\n+\n+      if (p == filename)\n+\t{\n+\t  dir = \".\";\n+\t  from = filename;\n+\t}\n+      else\n+\t{\n+\t  dir = (char *) alloca (p - filename + 1);\n+\t  bcopy (filename, dir, p - filename);\n+\t  dir[p - filename] = '\\0';\n+\t  from = p + 1;\n+\t}\n+      for (map = read_name_map (pfile, dir); map; map = map->map_next)\n+\tif (! strcmp (map->map_from, from))\n+\t  return open (map->map_to, O_RDONLY, 0666);\n+    }\n+\n+  return open (filename, O_RDONLY, 0666);\n+}\n+\n+/* Process the contents of include file FNAME, already open on descriptor F,\n+   with output to OP.\n+   SYSTEM_HEADER_P is 1 if this file resides in any one of the known\n+   \"system\" include directories (as decided by the `is_system_include'\n+   function above).\n+   DIRPTR is the link in the dir path through which this file was found,\n+   or 0 if the file name was absolute or via the current directory.\n+   Return 1 on success, 0 on failure.\n+\n+   The caller is responsible for the cpp_push_buffer.  */\n+\n+int\n+finclude (pfile, f, fname, system_header_p, dirptr)\n+     cpp_reader *pfile;\n+     int f;\n+     char *fname;\n+     int system_header_p;\n+     struct file_name_list *dirptr;\n+{\n+  struct stat st;\n+  size_t st_size;\n+  long i;\n+  int length;\n+  cpp_buffer *fp;\t\t\t/* For input stack frame */\n+#if 0\n+  int missing_newline = 0;\n+#endif\n+\n+  if (fstat (f, &st) < 0)\n+    {\n+      cpp_perror_with_name (pfile, fname);\n+      close (f);\n+      cpp_pop_buffer (pfile);\n+      return 0;\n+    }\n+\n+  fp = CPP_BUFFER (pfile);\n+  fp->nominal_fname = fp->fname = fname;\n+#if 0\n+  fp->length = 0;\n+#endif\n+  fp->dir = dirptr;\n+  fp->system_header_p = system_header_p;\n+  fp->lineno = 1;\n+  fp->colno = 1;\n+  fp->cleanup = file_cleanup;\n+\n+  if (S_ISREG (st.st_mode)) {\n+    st_size = (size_t) st.st_size;\n+    if (st_size != st.st_size || st_size + 2 < st_size) {\n+      cpp_error (pfile, \"file `%s' too large\", fname);\n+      close (f);\n+      return 0;\n+    }\n+    fp->buf = (U_CHAR *) xmalloc (st_size + 2);\n+    fp->alimit = fp->buf + st_size + 2;\n+    fp->cur = fp->buf;\n+\n+    /* Read the file contents, knowing that st_size is an upper bound\n+       on the number of bytes we can read.  */\n+    length = safe_read (f, fp->buf, st_size);\n+    fp->rlimit = fp->buf + length;\n+    if (length < 0) goto nope;\n+  }\n+  else if (S_ISDIR (st.st_mode)) {\n+    cpp_error (pfile, \"directory `%s' specified in #include\", fname);\n+    close (f);\n+    return 0;\n+  } else {\n+    /* Cannot count its file size before reading.\n+       First read the entire file into heap and\n+       copy them into buffer on stack.  */\n+\n+    size_t bsize = 2000;\n+\n+    st_size = 0;\n+    fp->buf = (U_CHAR *) xmalloc (bsize + 2);\n+\n+    for (;;) {\n+      i = safe_read (f, fp->buf + st_size, bsize - st_size);\n+      if (i < 0)\n+\tgoto nope;      /* error! */\n+      st_size += i;\n+      if (st_size != bsize)\n+\tbreak;\t/* End of file */\n+      bsize *= 2;\n+      fp->buf = (U_CHAR *) xrealloc (fp->buf, bsize + 2);\n+    }\n+    fp->cur = fp->buf;\n+    length = st_size;\n+  }\n+\n+  if ((length > 0 && fp->buf[length - 1] != '\\n')\n+      /* Backslash-newline at end is not good enough.  */\n+      || (length > 1 && fp->buf[length - 2] == '\\\\')) {\n+    fp->buf[length++] = '\\n';\n+#if 0\n+    missing_newline = 1;\n+#endif\n+  }\n+  fp->buf[length] = '\\0';\n+  fp->rlimit = fp->buf + length;\n+\n+  /* Close descriptor now, so nesting does not use lots of descriptors.  */\n+  close (f);\n+\n+  /* Must do this before calling trigraph_pcp, so that the correct file name\n+     will be printed in warning messages.  */\n+\n+  pfile->input_stack_listing_current = 0;\n+\n+#if 0\n+  if (!no_trigraphs)\n+    trigraph_pcp (fp);\n+#endif\n+\n+#if 0\n+  rescan (op, 0);\n+\n+  if (missing_newline)\n+    fp->lineno--;\n+\n+  if (CPP_PEDANTIC (pfile) && missing_newline)\n+    pedwarn (\"file does not end in newline\");\n+\n+  indepth--;\n+  input_file_stack_tick++;\n+  free (fp->buf);\n+#endif\n+  return 1;\n+\n+ nope:\n+\n+  cpp_perror_with_name (pfile, fname);\n+  close (f);\n+  free (fp->buf);\n+  return 1;\n+}\n+\n+/* Read LEN bytes at PTR from descriptor DESC, for file FILENAME,\n+   retrying if necessary.  If MAX_READ_LEN is defined, read at most\n+   that bytes at a time.  Return a negative value if an error occurs,\n+   otherwise return the actual number of bytes read,\n+   which must be LEN unless end-of-file was reached.  */\n+\n+static int\n+safe_read (desc, ptr, len)\n+     int desc;\n+     char *ptr;\n+     int len;\n+{\n+  int left, rcount, nchars;\n+\n+  left = len;\n+  while (left > 0) {\n+    rcount = left;\n+#ifdef MAX_READ_LEN\n+    if (rcount > MAX_READ_LEN)\n+      rcount = MAX_READ_LEN;\n+#endif\n+    nchars = read (desc, ptr, rcount);\n+    if (nchars < 0)\n+      {\n+#ifdef EINTR\n+\tif (errno == EINTR)\n+\t  continue;\n+#endif\n+\treturn nchars;\n+      }\n+    if (nchars == 0)\n+      break;\n+    ptr += nchars;\n+    left -= nchars;\n+  }\n+  return len - left;\n+}\n+\n+#ifdef VMS\n+\n+/* Under VMS we need to fix up the \"include\" specification filename.\n+\n+   Rules for possible conversions\n+\n+\tfullname\t\ttried paths\n+\n+\tname\t\t\tname\n+\t./dir/name\t\t[.dir]name\n+\t/dir/name\t\tdir:name\n+\t/name\t\t\t[000000]name, name\n+\tdir/name\t\tdir:[000000]name, dir:name, dir/name\n+\tdir1/dir2/name\t\tdir1:[dir2]name, dir1:[000000.dir2]name\n+\tpath:/name\t\tpath:[000000]name, path:name\n+\tpath:/dir/name\t\tpath:[000000.dir]name, path:[dir]name\n+\tpath:dir/name\t\tpath:[dir]name\n+\t[path]:[dir]name\t[path.dir]name\n+\tpath/[dir]name\t\t[path.dir]name\n+\n+   The path:/name input is constructed when expanding <> includes. */\n+\n+\n+static void\n+hack_vms_include_specification (fullname)\n+     char *fullname;\n+{\n+  register char *basename, *unixname, *local_ptr, *first_slash;\n+  int f, check_filename_before_returning, must_revert;\n+  char Local[512];\n+\n+  check_filename_before_returning = 0;\n+  must_revert = 0;\n+  /* See if we can find a 1st slash. If not, there's no path information.  */\n+  first_slash = index (fullname, '/');\n+  if (first_slash == 0)\n+    return 0;\t\t\t\t/* Nothing to do!!! */\n+\n+  /* construct device spec if none given.  */\n+\n+  if (index (fullname, ':') == 0)\n+    {\n+\n+      /* If fullname has a slash, take it as device spec.  */\n+\n+      if (first_slash == fullname)\n+\t{\n+\t  first_slash = index (fullname+1, '/');\t/* 2nd slash ? */\n+\t  if (first_slash)\n+\t    *first_slash = ':';\t\t\t\t/* make device spec  */\n+\t  for (basename = fullname; *basename != 0; basename++)\n+\t    *basename = *(basename+1);\t\t\t/* remove leading slash  */\n+\t}\n+      else if ((first_slash[-1] != '.')\t\t/* keep ':/', './' */\n+\t    && (first_slash[-1] != ':')\n+\t    && (first_slash[-1] != ']'))\t/* or a vms path  */\n+\t{\n+\t  *first_slash = ':';\n+\t}\n+      else if ((first_slash[1] == '[')\t\t/* skip './' in './[dir'  */\n+\t    && (first_slash[-1] == '.'))\n+\tfullname += 2;\n+    }\n+\n+  /* Get part after first ':' (basename[-1] == ':')\n+     or last '/' (basename[-1] == '/').  */\n+\n+  basename = base_name (fullname);\n+\n+  local_ptr = Local;\t\t\t/* initialize */\n+\n+  /* We are trying to do a number of things here.  First of all, we are\n+     trying to hammer the filenames into a standard format, such that later\n+     processing can handle them.\n+     \n+     If the file name contains something like [dir.], then it recognizes this\n+     as a root, and strips the \".]\".  Later processing will add whatever is\n+     needed to get things working properly.\n+     \n+     If no device is specified, then the first directory name is taken to be\n+     a device name (or a rooted logical).  */\n+\n+  /* Point to the UNIX filename part (which needs to be fixed!)\n+     but skip vms path information.\n+     [basename != fullname since first_slash != 0].  */\n+\n+  if ((basename[-1] == ':')\t\t/* vms path spec.  */\n+      || (basename[-1] == ']')\n+      || (basename[-1] == '>'))\n+    unixname = basename;\n+  else\n+    unixname = fullname;\n+\n+  if (*unixname == '/')\n+    unixname++;\n+\n+  /* If the directory spec is not rooted, we can just copy\n+     the UNIX filename part and we are done.  */\n+\n+  if (((basename - fullname) > 1)\n+     && (  (basename[-1] == ']')\n+        || (basename[-1] == '>')))\n+    {\n+      if (basename[-2] != '.')\n+\t{\n+\n+\t/* The VMS part ends in a `]', and the preceding character is not a `.'.\n+\t   -> PATH]:/name (basename = '/name', unixname = 'name')\n+\t   We strip the `]', and then splice the two parts of the name in the\n+\t   usual way.  Given the default locations for include files in cccp.c,\n+\t   we will only use this code if the user specifies alternate locations\n+\t   with the /include (-I) switch on the command line.  */\n+\n+\t  basename -= 1;\t/* Strip \"]\" */\n+\t  unixname--;\t\t/* backspace */\n+\t}\n+      else\n+\t{\n+\n+\t/* The VMS part has a \".]\" at the end, and this will not do.  Later\n+\t   processing will add a second directory spec, and this would be a syntax\n+\t   error.  Thus we strip the \".]\", and thus merge the directory specs.\n+\t   We also backspace unixname, so that it points to a '/'.  This inhibits the\n+\t   generation of the 000000 root directory spec (which does not belong here\n+\t   in this case).  */\n+\n+\t  basename -= 2;\t/* Strip \".]\" */\n+\t  unixname--;\t\t/* backspace */\n+\t}\n+    }\n+\n+  else\n+\n+    {\n+\n+      /* We drop in here if there is no VMS style directory specification yet.\n+         If there is no device specification either, we make the first dir a\n+         device and try that.  If we do not do this, then we will be essentially\n+         searching the users default directory (as if they did a #include \"asdf.h\").\n+        \n+         Then all we need to do is to push a '[' into the output string. Later\n+         processing will fill this in, and close the bracket.  */\n+\n+      if ((unixname != fullname)\t/* vms path spec found.  */\n+\t && (basename[-1] != ':'))\n+\t*local_ptr++ = ':';\t\t/* dev not in spec.  take first dir */\n+\n+      *local_ptr++ = '[';\t\t/* Open the directory specification */\n+    }\n+\n+    if (unixname == fullname)\t\t/* no vms dir spec.  */\n+      {\n+\tmust_revert = 1;\n+\tif ((first_slash != 0)\t\t/* unix dir spec.  */\n+\t    && (*unixname != '/')\t/* not beginning with '/'  */\n+\t    && (*unixname != '.'))\t/* or './' or '../'  */\n+\t  *local_ptr++ = '.';\t\t/* dir is local !  */\n+      }\n+\n+  /* at this point we assume that we have the device spec, and (at least\n+     the opening \"[\" for a directory specification.  We may have directories\n+     specified already.\n+\n+     If there are no other slashes then the filename will be\n+     in the \"root\" directory.  Otherwise, we need to add\n+     directory specifications.  */\n+\n+  if (index (unixname, '/') == 0)\n+    {\n+      /* if no directories specified yet and none are following.  */\n+      if (local_ptr[-1] == '[')\n+\t{\n+\t  /* Just add \"000000]\" as the directory string */\n+\t  strcpy (local_ptr, \"000000]\");\n+\t  local_ptr += strlen (local_ptr);\n+\t  check_filename_before_returning = 1; /* we might need to fool with this later */\n+\t}\n+    }\n+  else\n+    {\n+\n+      /* As long as there are still subdirectories to add, do them.  */\n+      while (index (unixname, '/') != 0)\n+\t{\n+\t  /* If this token is \".\" we can ignore it\n+\t       if it's not at the beginning of a path.  */\n+\t  if ((unixname[0] == '.') && (unixname[1] == '/'))\n+\t    {\n+\t      /* remove it at beginning of path.  */\n+\t      if (  ((unixname == fullname)\t\t/* no device spec  */\n+\t\t    && (fullname+2 != basename))\t/* starts with ./ */\n+\t\t\t\t\t\t\t/* or  */\n+\t\t || ((basename[-1] == ':')\t\t/* device spec  */\n+\t\t    && (unixname-1 == basename)))\t/* and ./ afterwards  */\n+\t\t*local_ptr++ = '.';\t\t \t/* make '[.' start of path.  */\n+\t      unixname += 2;\n+\t      continue;\n+\t    }\n+\n+\t  /* Add a subdirectory spec. Do not duplicate \".\" */\n+\t  if (  local_ptr[-1] != '.'\n+\t     && local_ptr[-1] != '['\n+\t     && local_ptr[-1] != '<')\n+\t    *local_ptr++ = '.';\n+\n+\t  /* If this is \"..\" then the spec becomes \"-\" */\n+\t  if (  (unixname[0] == '.')\n+\t     && (unixname[1] == '.')\n+\t     && (unixname[2] == '/'))\n+\t    {\n+\t      /* Add \"-\" and skip the \"..\" */\n+\t      if ((local_ptr[-1] == '.')\n+\t\t  && (local_ptr[-2] == '['))\n+\t\tlocal_ptr--;\t\t\t/* prevent [.-  */\n+\t      *local_ptr++ = '-';\n+\t      unixname += 3;\n+\t      continue;\n+\t    }\n+\n+\t  /* Copy the subdirectory */\n+\t  while (*unixname != '/')\n+\t    *local_ptr++= *unixname++;\n+\n+\t  unixname++;\t\t\t/* Skip the \"/\" */\n+\t}\n+\n+      /* Close the directory specification */\n+      if (local_ptr[-1] == '.')\t\t/* no trailing periods */\n+\tlocal_ptr--;\n+\n+      if (local_ptr[-1] == '[')\t\t/* no dir needed */\n+\tlocal_ptr--;\n+      else\n+\t*local_ptr++ = ']';\n+    }\n+\n+  /* Now add the filename.  */\n+\n+  while (*unixname)\n+    *local_ptr++ = *unixname++;\n+  *local_ptr = 0;\n+\n+  /* Now append it to the original VMS spec.  */\n+\n+  strcpy ((must_revert==1)?fullname:basename, Local);\n+\n+  /* If we put a [000000] in the filename, try to open it first. If this fails,\n+     remove the [000000], and return that name.  This provides flexibility\n+     to the user in that they can use both rooted and non-rooted logical names\n+     to point to the location of the file.  */\n+\n+  if (check_filename_before_returning)\n+    {\n+      f = open (fullname, O_RDONLY, 0666);\n+      if (f >= 0)\n+\t{\n+\t  /* The file name is OK as it is, so return it as is.  */\n+\t  close (f);\n+\t  return 1;\n+\t}\n+\n+      /* The filename did not work.  Try to remove the [000000] from the name,\n+\t and return it.  */\n+\n+      basename = index (fullname, '[');\n+      local_ptr = index (fullname, ']') + 1;\n+      strcpy (basename, local_ptr);\t\t/* this gets rid of it */\n+\n+    }\n+\n+  return 1;\n+}\n+#endif\t/* VMS */"}, {"sha": "e8d2e09d1c69a0f996848bf2ec81075fbfd17767", "filename": "gcc/cpplib.c", "status": "modified", "additions": 152, "deletions": 907, "changes": 1059, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add7091b5b09593736c839d9ffa33d74f5d7cb61/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add7091b5b09593736c839d9ffa33d74f5d7cb61/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=add7091b5b09593736c839d9ffa33d74f5d7cb61", "patch": "@@ -89,9 +89,6 @@ extern char *update_path PARAMS ((char *, char *));\n #ifndef STANDARD_INCLUDE_DIR\n #define STANDARD_INCLUDE_DIR \"/usr/include\"\n #endif\n-#ifndef INCLUDE_LEN_FUDGE\n-#define INCLUDE_LEN_FUDGE 0\n-#endif\n \n /* Symbols to predefine.  */\n \n@@ -200,49 +197,34 @@ char *xmalloc ();\n extern void cpp_hash_cleanup PARAMS ((cpp_reader *));\n \n static char *my_strerror\t\tPROTO ((int));\n-static void add_import\t\t\tPROTO ((cpp_reader *, int, char *));\n-static void append_include_chain\tPROTO ((cpp_reader *,\n-\t\t\t\t\t\tstruct file_name_list *,\n-\t\t\t\t\t\tstruct file_name_list *));\n static void make_assertion\t\tPROTO ((cpp_reader *, char *, U_CHAR *));\n static void path_include\t\tPROTO ((cpp_reader *, char *));\n static void initialize_builtins\t\tPROTO ((cpp_reader *));\n static void initialize_char_syntax\tPROTO ((struct cpp_options *));\n #if 0\n static void trigraph_pcp ();\n #endif\n-static int finclude\t\t\tPROTO ((cpp_reader *, int, char *,\n-\t\t\t\t\t\tint, struct file_name_list *));\n static void validate_else\t\tPROTO ((cpp_reader *, char *));\n static int comp_def_part\t\tPROTO ((int, U_CHAR *, int, U_CHAR *,\n \t\t\t\t\t\tint, int));\n #ifdef abort\n extern void fancy_abort ();\n #endif\n-static int lookup_import\t\tPROTO ((cpp_reader *, char *,\n-\t\t\t\t\t\tstruct file_name_list *));\n-static int redundant_include_p\t\tPROTO ((cpp_reader *, char *));\n-static int is_system_include\t\tPROTO ((cpp_reader *, char *));\n-static struct file_name_map *read_name_map\tPROTO ((cpp_reader *, char *));\n-static char *read_filename_string\tPROTO ((int, FILE *));\n-static int open_include_file\t\tPROTO ((cpp_reader *, char *,\n-\t\t\t\t\t\tstruct file_name_list *));\n static int check_macro_name\t\tPROTO ((cpp_reader *, U_CHAR *, char *));\n static int compare_defs\t\t\tPROTO ((cpp_reader *,\n \t\t\t\t\t\tDEFINITION *, DEFINITION *));\n static int compare_token_lists\t\tPROTO ((struct arglist *,\n \t\t\t\t\t\tstruct arglist *));\n+static int is_system_include\t\tPROTO ((cpp_reader *, char *));\n static HOST_WIDE_INT eval_if_expression\tPROTO ((cpp_reader *, U_CHAR *, int));\n static int change_newlines\t\tPROTO ((U_CHAR *, int));\n static struct arglist *read_token_list\tPROTO ((cpp_reader *, int *));\n static void free_token_list\t\tPROTO ((struct arglist *));\n-static int safe_read\t\t\tPROTO ((int, char *, int));\n static void push_macro_expansion PARAMS ((cpp_reader *,\n \t\t\t\t\t  U_CHAR *, int, HASHNODE *));\n static struct cpp_pending *nreverse_pending PARAMS ((struct cpp_pending *));\n extern char *xrealloc ();\n static char *xcalloc\t\t\tPROTO ((unsigned, unsigned));\n-static char *savestring\t\t\tPROTO ((char *));\n \n static void conditional_skip\t\tPROTO ((cpp_reader *, int,\n \t\t\t\t\t       enum node_type, U_CHAR *));\n@@ -260,25 +242,6 @@ extern HOST_WIDE_INT cpp_parse_expr PARAMS ((cpp_reader *));\n extern char *version_string;\n extern struct tm *localtime ();\n \f\n-struct file_name_list\n-  {\n-    struct file_name_list *next;\n-    char *fname;\n-    /* If the following is nonzero, it is a macro name.\n-       Don't include the file again if that macro is defined.  */\n-    U_CHAR *control_macro;\n-    /* If the following is nonzero, it is a C-language system include\n-       directory.  */\n-    int c_system_include_path;\n-    /* Mapping of file names for this directory.  */\n-    struct file_name_map *name_map;\n-    /* Non-zero if name_map is valid.  */\n-    int got_name_map;\n-  };\n-\n-/* If a buffer's dir field is SELF_DIR_DUMMY, it means the file was found\n-   via the same directory as the file that #included it.  */\n-#define SELF_DIR_DUMMY ((struct file_name_list *) (~0))\n \n /* #include \"file\" looks in source file dir, then stack.  */\n /* #include <file> just looks in the stack.  */\n@@ -366,7 +329,6 @@ static int do_endif PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR\n #ifdef SCCS_DIRECTIVE\n static int do_sccs PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n #endif\n-static int do_once PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n static int do_assert PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n static int do_unassert PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n static int do_warning PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n@@ -403,13 +365,13 @@ static struct directive directive_table[] = {\n };\n \f\n /* table to tell if char can be part of a C identifier.  */\n-U_CHAR is_idchar[256];\n+U_CHAR is_idchar[256] = { 0 };\n /* table to tell if char can be first char of a c identifier.  */\n-U_CHAR is_idstart[256];\n+U_CHAR is_idstart[256] = { 0 };\n /* table to tell if c is horizontal space.  */\n-U_CHAR is_hor_space[256];\n+U_CHAR is_hor_space[256] = { 0 };\n /* table to tell if c is horizontal or vertical space.  */\n-static U_CHAR is_space[256];\n+U_CHAR is_space[256] = { 0 };\n \n /* Initialize syntactic classifications of characters.  */\n \n@@ -615,85 +577,7 @@ make_assertion (pfile, option, str)\n       cpp_pop_buffer (pfile);\n     }\n }\n-\f\n-/* Append a chain of `struct file_name_list's\n-   to the end of the main include chain.\n-   FIRST is the beginning of the chain to append, and LAST is the end.  */\n-\n-static void\n-append_include_chain (pfile, first, last)\n-     cpp_reader *pfile;\n-     struct file_name_list *first, *last;\n-{\n-  struct cpp_options *opts = CPP_OPTIONS (pfile);\n-  struct file_name_list *dir;\n-\n-  if (!first || !last)\n-    return;\n \n-  if (opts->include == 0)\n-    opts->include = first;\n-  else\n-    opts->last_include->next = first;\n-\n-  if (opts->first_bracket_include == 0)\n-    opts->first_bracket_include = first;\n-\n-  for (dir = first; ; dir = dir->next) {\n-    int len = strlen (dir->fname) + INCLUDE_LEN_FUDGE;\n-    if (len > pfile->max_include_len)\n-      pfile->max_include_len = len;\n-    if (dir == last)\n-      break;\n-  }\n-\n-  last->next = NULL;\n-  opts->last_include = last;\n-}\n-\f\n-/* Add output to `deps_buffer' for the -M switch.\n-   STRING points to the text to be output.\n-   SPACER is ':' for targets, ' ' for dependencies, zero for text\n-   to be inserted literally.  */\n-\n-static void\n-deps_output (pfile, string, spacer)\n-     cpp_reader *pfile;\n-     char *string;\n-     int spacer;\n-{\n-  int size = strlen (string);\n-\n-  if (size == 0)\n-    return;\n-\n-#ifndef MAX_OUTPUT_COLUMNS\n-#define MAX_OUTPUT_COLUMNS 72\n-#endif\n-  if (spacer\n-      && pfile->deps_column > 0\n-      && (pfile->deps_column + size) > MAX_OUTPUT_COLUMNS)\n-    {\n-      deps_output (pfile, \" \\\\\\n  \", 0);\n-      pfile->deps_column = 0;\n-    }\n-\n-  if (pfile->deps_size + size + 8 > pfile->deps_allocated_size)\n-    {\n-      pfile->deps_allocated_size = (pfile->deps_size + size + 50) * 2;\n-      pfile->deps_buffer = (char *) xrealloc (pfile->deps_buffer,\n-\t\t\t\t\t      pfile->deps_allocated_size);\n-    }\n-  if (spacer == ' ' && pfile->deps_column > 0)\n-    pfile->deps_buffer[pfile->deps_size++] = ' ';\n-  bcopy (string, &pfile->deps_buffer[pfile->deps_size], size);\n-  pfile->deps_size += size;\n-  pfile->deps_column += size;\n-  if (spacer == ':')\n-    pfile->deps_buffer[pfile->deps_size++] = ':';\n-  pfile->deps_buffer[pfile->deps_size] = 0;\n-}\n-\f\n /* Given a colon-separated list of file names PATH,\n    add all the names to the search path for include files.  */\n \n@@ -806,19 +690,6 @@ macro_cleanup (pbuf, pfile)\n   return 0;\n }\n \n-int\n-file_cleanup (pbuf, pfile)\n-     cpp_buffer *pbuf;\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  if (pbuf->buf)\n-    {\n-      free (pbuf->buf);\n-      pbuf->buf = 0;\n-    }\n-  return 0;\n-}\n-\n /* Assuming we have read '/'.\n    If this is the start of a comment (followed by '*' or '/'),\n    skip to the end of the comment, and return ' '.\n@@ -3077,29 +2948,21 @@ do_include (pfile, keyword, unused1, unused2)\n {\n   int importing = (keyword->type == T_IMPORT);\n   int skip_dirs = (keyword->type == T_INCLUDE_NEXT);\n+  int angle_brackets = 0;\t/* 0 for \"...\", 1 for <...> */\n   char *fname;\t\t/* Dynamically allocated fname buffer */\n-  char *pcftry;\n-  U_CHAR *fbeg, *fend;\t\t/* Beginning and end of fname */\n+  char *fbeg, *fend;\t\t/* Beginning and end of fname */\n+  long flen;\n+\n   enum cpp_token token;\n \n   /* Chain of dirs to search */\n   struct file_name_list *search_start = CPP_OPTIONS (pfile)->include;\n-  struct file_name_list dsp[1];\t/* First in chain, if #include \"...\" */\n-  struct file_name_list *searchptr = 0;\n+  struct file_name_list dsp;\t/* First in chain, if #include \"...\" */\n+  struct file_name_list *foundhere, *ptr;\n+  \n   long old_written = CPP_WRITTEN (pfile);\n \n-  int flen;\n-\n-  int f;\t\t\t/* file number */\n-\n-  int angle_brackets = 0;\t/* 0 for \"...\", 1 for <...> */\n-  char *pcfbuf;\n-#if 0\n-  int pcf = -1;\n-  char *pcfbuflimit;\n-#endif\n-  int pcfnum;\n-  f= -1;\t\t\t/* JF we iz paranoid! */\n+  int fd;\n \n   if (CPP_PEDANTIC (pfile) && !CPP_BUFFER (pfile)->system_header_p)\n     {\n@@ -3133,9 +2996,9 @@ do_include (pfile, keyword, unused1, unused2)\n \n   if (token == CPP_STRING)\n     {\n-      /* FIXME - check no trailing garbage */\n       fbeg = pfile->token_buffer + old_written + 1;\n       fend = CPP_PWRITTEN (pfile) - 1;\n+      *fend = '\\0';\n       if (fbeg[-1] == '<')\n \t{\n \t  angle_brackets = 1;\n@@ -3159,8 +3022,8 @@ do_include (pfile, keyword, unused1, unused2)\n \t\t{\n \t\t  /* Found a named file.  Figure out dir of the file,\n \t\t     and put it in front of the search list.  */\n-\t\t  dsp[0].next = search_start;\n-\t\t  search_start = dsp;\n+\t\t  dsp.next = search_start;\n+\t\t  search_start = &dsp;\n #ifndef VMS\n \t\t  ep = rindex (nam, '/');\n #else\t\t\t\t/* VMS */\n@@ -3172,17 +3035,17 @@ do_include (pfile, keyword, unused1, unused2)\n \t\t  if (ep != NULL)\n \t\t    {\n \t\t      n = ep - nam;\n-\t\t      dsp[0].fname = (char *) alloca (n + 1);\n-\t\t      strncpy (dsp[0].fname, nam, n);\n-\t\t      dsp[0].fname[n] = '\\0';\n+\t\t      dsp.fname = (char *) alloca (n + 1);\n+\t\t      strncpy (dsp.fname, nam, n);\n+\t\t      dsp.fname[n] = '\\0';\n \t\t      if (n + INCLUDE_LEN_FUDGE > pfile->max_include_len)\n \t\t\tpfile->max_include_len = n + INCLUDE_LEN_FUDGE;\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      dsp[0].fname = 0; /* Current directory */\n+\t\t      dsp.fname = 0; /* Current directory */\n \t\t    }\n-\t\t  dsp[0].got_name_map = 0;\n+\t\t  dsp.got_name_map = 0;\n \t\t  break;\n \t\t}\n \t    }\n@@ -3202,6 +3065,11 @@ do_include (pfile, keyword, unused1, unused2)\n       /* If -I-, start with the first -I dir after the -I-.  */\n       if (CPP_OPTIONS (pfile)->first_bracket_include)\n \tsearch_start = CPP_OPTIONS (pfile)->first_bracket_include;\n+\n+      /* Append the missing `.h' to the name. */\n+      CPP_PUTS (pfile, \".h\", 3)\n+      CPP_NUL_TERMINATE_Q (pfile);\n+\n       fbeg = pfile->token_buffer + old_written;\n       fend = CPP_PWRITTEN (pfile);\n     }\n@@ -3215,14 +3083,11 @@ do_include (pfile, keyword, unused1, unused2)\n       return 0;\n     }\n \n-  *fend = 0;\n-\n   token = get_directive_token (pfile);\n   if (token != CPP_VSPACE)\n     {\n       cpp_error (pfile, \"junk at end of `#include'\");\n-      while (token != CPP_VSPACE && token != CPP_EOF && token != CPP_POP)\n-\ttoken = get_directive_token (pfile);\n+      skip_rest_of_line (pfile);\n     }\n \n   /* For #include_next, skip in the search path\n@@ -3255,127 +3120,57 @@ do_include (pfile, keyword, unused1, unused2)\n \n   /* Allocate this permanently, because it gets stored in the definitions\n      of macros.  */\n-  fname = (char *) xmalloc (pfile->max_include_len + flen + 4);\n   /* + 2 above for slash and terminating null.  */\n-  /* + 2 added for '.h' on VMS (to support '#include filename') */\n+  fname = (char *) xmalloc (pfile->max_include_len + flen + 2);\n \n-  /* If specified file name is absolute, just open it.  */\n+  fd = find_include_file (pfile, fbeg, flen, fname,\n+\t\t\t  importing, search_start, &foundhere);\n \n-  if (*fbeg == '/') {\n-    strncpy (fname, fbeg, flen);\n-    fname[flen] = 0;\n-    if (redundant_include_p (pfile, fname))\n+  if (fd == -2)\n+    {\n+      free (fname);\n       return 0;\n-    if (importing)\n-      f = lookup_import (pfile, fname, NULL_PTR);\n-    else\n-      f = open_include_file (pfile, fname, NULL_PTR);\n-    if (f == -2)\n-      return 0;\t\t/* Already included this file */\n-  } else {\n-    /* Search directory path, trying to open the file.\n-       Copy each filename tried into FNAME.  */\n-\n-    for (searchptr = search_start; searchptr; searchptr = searchptr->next) {\n-      if (searchptr->fname) {\n-\t/* The empty string in a search path is ignored.\n-\t   This makes it possible to turn off entirely\n-\t   a standard piece of the list.  */\n-\tif (searchptr->fname[0] == 0)\n-\t  continue;\n-\tstrcpy (fname, searchptr->fname);\n-\tstrcat (fname, \"/\");\n-\tfname[strlen (fname) + flen] = 0;\n-      } else {\n-\tfname[0] = 0;\n-      }\n-      strncat (fname, fbeg, flen);\n-#ifdef VMS\n-      /* Change this 1/2 Unix 1/2 VMS file specification into a\n-         full VMS file specification */\n-      if (searchptr->fname && (searchptr->fname[0] != 0)) {\n-\t/* Fix up the filename */\n-\thack_vms_include_specification (fname);\n-      } else {\n-      \t/* This is a normal VMS filespec, so use it unchanged.  */\n-\tstrncpy (fname, fbeg, flen);\n-\tfname[flen] = 0;\n-\t/* if it's '#include filename', add the missing .h */\n-\tif (index(fname,'.')==NULL) {\n-\t  strcat (fname, \".h\");\n-\t}\n-      }\n-#endif /* VMS */\n-      /* ??? There are currently 3 separate mechanisms for avoiding processing\n-\t of redundant include files: #import, #pragma once, and\n-\t redundant_include_p.  It would be nice if they were unified.  */\n-      if (redundant_include_p (pfile, fname))\n-\treturn 0;\n-      if (importing)\n-\tf = lookup_import (pfile, fname, searchptr);\n-      else\n-\tf = open_include_file (pfile, fname, searchptr);\n-      if (f == -2)\n-\treturn 0;\t\t\t/* Already included this file */\n-#ifdef EACCES\n-      else if (f == -1 && errno == EACCES)\n-\tcpp_warning (pfile, \"Header file %s exists, but is not readable\",\n-\t\t     fname);\n-#endif\n-      if (f >= 0)\n-\tbreak;\n     }\n-  }\n-\n-  if (f < 0)\n+  \n+  if (fd == -1)\n     {\n-      /* A file that was not found.  */\n-      strncpy (fname, fbeg, flen);\n-      fname[flen] = 0;\n-      /* If generating dependencies and -MG was specified, we assume missing\n-\t files are leaf files, living in the same directory as the source file\n-\t or other similar place; these missing files may be generated from\n-\t other files and may not exist yet (eg: y.tab.h).  */\n-\n-      if (CPP_OPTIONS(pfile)->print_deps_missing_files\n-\t  && CPP_PRINT_DEPS (pfile)\n-\t  > (angle_brackets || (pfile->system_include_depth > 0)))\n-\t{\n-\t  /* If it was requested as a system header file,\n-\t     then assume it belongs in the first place to look for such.  */\n-\t  if (angle_brackets)\n+      if (CPP_OPTIONS (pfile)->print_deps_missing_files\n+\t  && CPP_PRINT_DEPS (pfile) > (angle_brackets ||\n+\t\t\t\t       (pfile->system_include_depth > 0)))\n+        {\n+\t  if (!angle_brackets)\n+\t    deps_output (pfile, fbeg, ' ');\n+\t  else\n \t    {\n-\t      for (searchptr = search_start; searchptr;\n-\t\t   searchptr = searchptr->next)\n-\t\t{\n-\t\t  if (searchptr->fname)\n+\t      /* If requested as a system header, assume it belongs in\n+\t\t the first system header directory. */\n+\t      if (CPP_OPTIONS (pfile)->first_bracket_include)\n+\t        ptr = CPP_OPTIONS (pfile)->first_bracket_include;\n+\t      else\n+\t\tptr = CPP_OPTIONS (pfile)->include;\n+\t      for (; ptr; ptr = ptr->next)\n+\t\t  if (ptr->fname)\n \t\t    {\n \t\t      char *p;\n \n-\t\t      if (searchptr->fname[0] == 0)\n+\t\t      if (ptr->fname[0] == 0)\n \t\t\tcontinue;\n-\t\t      p = (char *) alloca (strlen (searchptr->fname)\n+\t\t      p = (char *) alloca (strlen (ptr->fname)\n \t\t\t\t\t   + strlen (fname) + 2);\n-\t\t      strcpy (p, searchptr->fname);\n+\t\t      strcpy (p, ptr->fname);\n \t\t      strcat (p, \"/\");\n \t\t      strcat (p, fname);\n \t\t      deps_output (pfile, p, ' ');\n \t\t      break;\n \t\t    }\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Otherwise, omit the directory, as if the file existed\n-\t\t in the directory with the source.  */\n-\t      deps_output (pfile, fname, ' ');\n \t    }\n \t}\n-      /* If -M was specified, and this header file won't be added to the\n-\t dependency list, then don't count this as an error, because we can\n-\t still produce correct output.  Otherwise, we can't produce correct\n-\t output, because there may be dependencies we need inside the missing\n-\t file, and we don't know what directory this missing file exists in.*/\n+      /* If -M was specified, and this header file won't be added to\n+\t the dependency list, then don't count this as an error,\n+\t because we can still produce correct output.  Otherwise, we\n+\t can't produce correct output, because there may be\n+\t dependencies we need inside the missing file, and we don't\n+\t know what directory this missing file exists in. */\n       else if (CPP_PRINT_DEPS (pfile)\n \t       && (CPP_PRINT_DEPS (pfile)\n \t\t   <= (angle_brackets || (pfile->system_include_depth > 0))))\n@@ -3384,26 +3179,19 @@ do_include (pfile, keyword, unused1, unused2)\n \tcpp_error_from_errno (pfile, fname);\n       else\n \tcpp_error (pfile, \"No include path in which to find %s\", fname);\n-    }\n-  else {\n-    /* Check to see if this include file is a once-only include file.\n-       If so, give up.  */\n \n-    struct file_name_list *ptr;\n-\n-    for (ptr = pfile->dont_repeat_files; ptr; ptr = ptr->next) {\n-      if (!strcmp (ptr->fname, fname)) {\n-\tclose (f);\n-        return 0;\t\t\t\t/* This file was once'd.  */\n-      }\n+      free (fname);\n+      return 0;\n     }\n \n-    for (ptr = pfile->all_include_files; ptr; ptr = ptr->next) {\n-      if (!strcmp (ptr->fname, fname))\n-        break;\t\t\t\t/* This file was included before.  */\n-    }\n+  /* If we get here, we have a file to process. */\n \n-    if (ptr == 0) {\n+  for (ptr = pfile->all_include_files; ptr; ptr = ptr->next)\n+    if (!strcmp (ptr->fname, fname))\n+      break;\t\t\t\t/* This file was included before.  */\n+\n+  if (ptr == 0)\n+    {\n       /* This is the first time for this file.  */\n       /* Add it to list of files included.  */\n \n@@ -3419,95 +3207,38 @@ do_include (pfile, keyword, unused1, unused2)\n       if (CPP_PRINT_DEPS (pfile)\n \t  > (angle_brackets || (pfile->system_include_depth > 0)))\n \tdeps_output (pfile, fname, ' ');\n-    }   \n-\n-    /* Handle -H option.  */\n-    if (CPP_OPTIONS(pfile)->print_include_names)\n-      {\n-\tcpp_buffer *buf = CPP_BUFFER (pfile);\n-\twhile ((buf = CPP_PREV_BUFFER (buf)) != CPP_NULL_BUFFER (pfile))\n-\t  putc ('.', stderr);\n-\tfprintf (stderr, \"%s\\n\", fname);\n-      }\n-\n-    if (angle_brackets)\n-      pfile->system_include_depth++;\n-\n-    /* Actually process the file.  */\n-\n-    /* Record file on \"seen\" list for #import.  */\n-    add_import (pfile, f, fname);\n-\n-    pcftry = (char *) alloca (strlen (fname) + 30);\n-    pcfbuf = 0;\n-    pcfnum = 0;\n-\n-#if 0\n-    if (!no_precomp)\n-      {\n-\tstruct stat stat_f;\n-\n-\tfstat (f, &stat_f);\n-\n-\tdo {\n-\t  sprintf (pcftry, \"%s%d\", fname, pcfnum++);\n+    }\n \n-\t  pcf = open (pcftry, O_RDONLY, 0666);\n-\t  if (pcf != -1)\n-\t    {\n-\t      struct stat s;\n+  /* Handle -H option.  */\n+  if (CPP_OPTIONS(pfile)->print_include_names)\n+    {\n+      cpp_buffer *buf = CPP_BUFFER (pfile);\n+      while ((buf = CPP_PREV_BUFFER (buf)) != CPP_NULL_BUFFER (pfile))\n+\tputc ('.', stderr);\n+      fprintf (stderr, \"%s\\n\", fname);\n+    }\n \n-\t      fstat (pcf, &s);\n-\t      if (bcmp ((char *) &stat_f.st_ino, (char *) &s.st_ino,\n-\t\t\tsizeof (s.st_ino))\n-\t\t  || stat_f.st_dev != s.st_dev)\n-\t\t{\n-\t\t  pcfbuf = check_precompiled (pcf, fname, &pcfbuflimit);\n-\t\t  /* Don't need it any more.  */\n-\t\t  close (pcf);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Don't need it at all.  */\n-\t\t  close (pcf);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t} while (pcf != -1 && !pcfbuf);\n-      }\n-#endif\n-    \n-    /* Actually process the file */\n-    if (cpp_push_buffer (pfile, NULL, 0) == NULL)\n+  /* Actually process the file */\n+  if (cpp_push_buffer (pfile, NULL, 0) == NULL)\n+    {\n+      close (fd);\n+      free (fname);\n       return 0;\n-    if (finclude (pfile, f, fname, is_system_include (pfile, fname),\n-\t\t  searchptr != dsp ? searchptr : SELF_DIR_DUMMY))\n-      {\n-\toutput_line_command (pfile, 0, enter_file);\n-\tpfile->only_seen_white = 2;\n-      }\n+    }\n \n-    if (angle_brackets)\n-      pfile->system_include_depth--;\n-  }\n-  return 0;\n-}\n+  if (angle_brackets)\n+    pfile->system_include_depth++;\n \n-/* Return nonzero if there is no need to include file NAME\n-   because it has already been included and it contains a conditional\n-   to make a repeated include do nothing.  */\n+  if (finclude (pfile, fd, fname, is_system_include (pfile, fname),\n+\t\tfoundhere != &dsp ? foundhere : SELF_DIR_DUMMY))\n+    {\n+      output_line_command (pfile, 0, enter_file);\n+      pfile->only_seen_white = 2;\n+    }\n+  \n+  if (angle_brackets)\n+    pfile->system_include_depth--;\n \n-static int\n-redundant_include_p (pfile, name)\n-     cpp_reader *pfile;\n-     char *name;\n-{\n-  struct file_name_list *l = pfile->all_include_files;\n-  for (; l; l = l->next)\n-    if (! strcmp (name, l->fname)\n-\t&& l->control_macro\n-\t&& cpp_lookup (pfile, l->control_macro, -1, -1))\n-      return 1;\n   return 0;\n }\n \n@@ -3546,7 +3277,6 @@ is_system_include (pfile, filename)\n   return 0;\n }\n \n-\f\n /*\n  * Install a name in the assertion hash table.\n  *\n@@ -3911,38 +3641,6 @@ do_warning (pfile, keyword, buf, limit)\n   return 0;\n }\n \n-/* Remember the name of the current file being read from so that we can\n-   avoid ever including it again.  */\n-\n-static int\n-do_once (pfile, keyword, unused1, unused2)\n-     cpp_reader *pfile;\n-     struct directive *keyword ATTRIBUTE_UNUSED;\n-     U_CHAR *unused1 ATTRIBUTE_UNUSED, *unused2 ATTRIBUTE_UNUSED;\n-{\n-  cpp_buffer *ip = NULL;\n-  struct file_name_list *new;\n-\n-  for (ip = CPP_BUFFER (pfile); ; ip = CPP_PREV_BUFFER (ip))\n-    {\n-      if (ip == CPP_NULL_BUFFER (pfile))\n-\treturn 0;\n-      if (ip->fname != NULL)\n-\tbreak;\n-    }\n-\n-    \n-  new = (struct file_name_list *) xmalloc (sizeof (struct file_name_list));\n-  new->next = pfile->dont_repeat_files;\n-  pfile->dont_repeat_files = new;\n-  new->fname = savestring (ip->fname);\n-  new->control_macro = 0;\n-  new->got_name_map = 0;\n-  new->c_system_include_path = 0;\n-\n-  return 0;\n-}\n-\n /* Report program identification.  */\n \n static int\n@@ -3973,13 +3671,32 @@ do_pragma (pfile, keyword, buf, limit)\n {\n   while (*buf == ' ' || *buf == '\\t')\n     buf++;\n-  if (!strncmp (buf, \"once\", 4)) {\n-    /* Allow #pragma once in system headers, since that's not the user's\n-       fault.  */\n-    if (!CPP_BUFFER (pfile)->system_header_p)\n-      cpp_warning (pfile, \"`#pragma once' is obsolete\");\n-    do_once (pfile, NULL, NULL, NULL);\n-  }\n+  if (!strncmp (buf, \"once\", 4))\n+    {\n+      cpp_buffer *ip = NULL;\n+      struct file_name_list *new;\n+\n+      /* Allow #pragma once in system headers, since that's not the user's\n+\t fault.  */\n+      if (!CPP_BUFFER (pfile)->system_header_p)\n+\tcpp_warning (pfile, \"`#pragma once' is obsolete\");\n+      \n+      for (ip = CPP_BUFFER (pfile); ; ip = CPP_PREV_BUFFER (ip))\n+        {\n+\t  if (ip == CPP_NULL_BUFFER (pfile))\n+\t    return 0;\n+\t  if (ip->fname != NULL)\n+\t    break;\n+\t}\n+      \n+      new = (struct file_name_list *) xmalloc (sizeof (struct file_name_list));\n+      new->next = pfile->dont_repeat_files;\n+      new->fname = savestring (ip->fname);\n+      new->control_macro = 0;\n+      new->got_name_map = 0;\n+      new->c_system_include_path = 0;\n+      pfile->dont_repeat_files = new;\n+    }\n \n   if (!strncmp (buf, \"implementation\", 14)) {\n     /* Be quiet about `#pragma implementation' for a file only if it hasn't\n@@ -5271,444 +4988,6 @@ parse_name (pfile, c)\n   return 1;\n }\n \n-\f\n-/* Maintain and search list of included files, for #import.  */\n-\n-/* Hash a file name for import_hash_table.  */\n-\n-static int \n-import_hash (f)\n-     char *f;\n-{\n-  int val = 0;\n-\n-  while (*f) val += *f++;\n-  return (val%IMPORT_HASH_SIZE);\n-}\n-\n-/* Search for file FILENAME in import_hash_table.\n-   Return -2 if found, either a matching name or a matching inode.\n-   Otherwise, open the file and return a file descriptor if successful\n-   or -1 if unsuccessful.  */\n-\n-static int\n-lookup_import (pfile, filename, searchptr)\n-     cpp_reader *pfile;\n-     char *filename;\n-     struct file_name_list *searchptr;\n-{\n-  struct import_file *i;\n-  int h;\n-  int hashval;\n-  struct stat sb;\n-  int fd;\n-\n-  hashval = import_hash (filename);\n-\n-  /* Attempt to find file in list of already included files */\n-  i = pfile->import_hash_table[hashval];\n-\n-  while (i) {\n-    if (!strcmp (filename, i->name))\n-      return -2;\t\t/* return found */\n-    i = i->next;\n-  }\n-  /* Open it and try a match on inode/dev */\n-  fd = open_include_file (pfile, filename, searchptr);\n-  if (fd < 0)\n-    return fd;\n-  fstat (fd, &sb);\n-  for (h = 0; h < IMPORT_HASH_SIZE; h++) {\n-    i = pfile->import_hash_table[h];\n-    while (i) {\n-      /* Compare the inode and the device.\n-\t Supposedly on some systems the inode is not a scalar.  */\n-      if (!bcmp ((char *) &i->inode, (char *) &sb.st_ino, sizeof (sb.st_ino))\n-\t  && i->dev == sb.st_dev) {\n-        close (fd);\n-        return -2;\t\t/* return found */\n-      }\n-      i = i->next;\n-    }\n-  }\n-  return fd;\t\t\t/* Not found, return open file */\n-}\n-\n-/* Add the file FNAME, open on descriptor FD, to import_hash_table.  */\n-\n-static void\n-add_import (pfile, fd, fname)\n-     cpp_reader *pfile;\n-     int fd;\n-     char *fname;\n-{\n-  struct import_file *i;\n-  int hashval;\n-  struct stat sb;\n-\n-  hashval = import_hash (fname);\n-  fstat (fd, &sb);\n-  i = (struct import_file *)xmalloc (sizeof (struct import_file));\n-  i->name = (char *)xmalloc (strlen (fname)+1);\n-  strcpy (i->name, fname);\n-  bcopy ((char *) &sb.st_ino, (char *) &i->inode, sizeof (sb.st_ino));\n-  i->dev = sb.st_dev;\n-  i->next = pfile->import_hash_table[hashval];\n-  pfile->import_hash_table[hashval] = i;\n-}\n-\f\n-/* The file_name_map structure holds a mapping of file names for a\n-   particular directory.  This mapping is read from the file named\n-   FILE_NAME_MAP_FILE in that directory.  Such a file can be used to\n-   map filenames on a file system with severe filename restrictions,\n-   such as DOS.  The format of the file name map file is just a series\n-   of lines with two tokens on each line.  The first token is the name\n-   to map, and the second token is the actual name to use.  */\n-\n-struct file_name_map\n-{\n-  struct file_name_map *map_next;\n-  char *map_from;\n-  char *map_to;\n-};\n-\n-#define FILE_NAME_MAP_FILE \"header.gcc\"\n-\n-/* Read a space delimited string of unlimited length from a stdio\n-   file.  */\n-\n-static char *\n-read_filename_string (ch, f)\n-     int ch;\n-     FILE *f;\n-{\n-  char *alloc, *set;\n-  int len;\n-\n-  len = 20;\n-  set = alloc = xmalloc (len + 1);\n-  if (! is_space[ch])\n-    {\n-      *set++ = ch;\n-      while ((ch = getc (f)) != EOF && ! is_space[ch])\n-\t{\n-\t  if (set - alloc == len)\n-\t    {\n-\t      len *= 2;\n-\t      alloc = xrealloc (alloc, len + 1);\n-\t      set = alloc + len / 2;\n-\t    }\n-\t  *set++ = ch;\n-\t}\n-    }\n-  *set = '\\0';\n-  ungetc (ch, f);\n-  return alloc;\n-}\n-\n-/* This structure holds a linked list of file name maps, one per directory.  */\n-\n-struct file_name_map_list\n-{\n-  struct file_name_map_list *map_list_next;\n-  char *map_list_name;\n-  struct file_name_map *map_list_map;\n-};\n-\n-/* Read the file name map file for DIRNAME.  */\n-\n-static struct file_name_map *\n-read_name_map (pfile, dirname)\n-     cpp_reader *pfile;\n-     char *dirname;\n-{\n-  register struct file_name_map_list *map_list_ptr;\n-  char *name;\n-  FILE *f;\n-\n-  for (map_list_ptr = CPP_OPTIONS (pfile)->map_list; map_list_ptr;\n-       map_list_ptr = map_list_ptr->map_list_next)\n-    if (! strcmp (map_list_ptr->map_list_name, dirname))\n-      return map_list_ptr->map_list_map;\n-\n-  map_list_ptr = ((struct file_name_map_list *)\n-\t\t  xmalloc (sizeof (struct file_name_map_list)));\n-  map_list_ptr->map_list_name = savestring (dirname);\n-  map_list_ptr->map_list_map = NULL;\n-\n-  name = (char *) alloca (strlen (dirname) + strlen (FILE_NAME_MAP_FILE) + 2);\n-  strcpy (name, dirname);\n-  if (*dirname)\n-    strcat (name, \"/\");\n-  strcat (name, FILE_NAME_MAP_FILE);\n-  f = fopen (name, \"r\");\n-  if (!f)\n-    map_list_ptr->map_list_map = NULL;\n-  else\n-    {\n-      int ch;\n-      int dirlen = strlen (dirname);\n-\n-      while ((ch = getc (f)) != EOF)\n-\t{\n-\t  char *from, *to;\n-\t  struct file_name_map *ptr;\n-\n-\t  if (is_space[ch])\n-\t    continue;\n-\t  from = read_filename_string (ch, f);\n-\t  while ((ch = getc (f)) != EOF && is_hor_space[ch])\n-\t    ;\n-\t  to = read_filename_string (ch, f);\n-\n-\t  ptr = ((struct file_name_map *)\n-\t\t xmalloc (sizeof (struct file_name_map)));\n-\t  ptr->map_from = from;\n-\n-\t  /* Make the real filename absolute.  */\n-\t  if (*to == '/')\n-\t    ptr->map_to = to;\n-\t  else\n-\t    {\n-\t      ptr->map_to = xmalloc (dirlen + strlen (to) + 2);\n-\t      strcpy (ptr->map_to, dirname);\n-\t      ptr->map_to[dirlen] = '/';\n-\t      strcpy (ptr->map_to + dirlen + 1, to);\n-\t      free (to);\n-\t    }\t      \n-\n-\t  ptr->map_next = map_list_ptr->map_list_map;\n-\t  map_list_ptr->map_list_map = ptr;\n-\n-\t  while ((ch = getc (f)) != '\\n')\n-\t    if (ch == EOF)\n-\t      break;\n-\t}\n-      fclose (f);\n-    }\n-  \n-  map_list_ptr->map_list_next = CPP_OPTIONS (pfile)->map_list;\n-  CPP_OPTIONS (pfile)->map_list = map_list_ptr;\n-\n-  return map_list_ptr->map_list_map;\n-}  \n-\n-/* Try to open include file FILENAME.  SEARCHPTR is the directory\n-   being tried from the include file search path.  This function maps\n-   filenames on file systems based on information read by\n-   read_name_map.  */\n-\n-static int\n-open_include_file (pfile, filename, searchptr)\n-     cpp_reader *pfile;\n-     char *filename;\n-     struct file_name_list *searchptr;\n-{\n-  if (CPP_OPTIONS (pfile)->remap)\n-    {\n-      register struct file_name_map *map;\n-      register char *from;\n-      char *p, *dir;\n-\n-      if (searchptr && ! searchptr->got_name_map)\n-\t{\n-\t  searchptr->name_map = read_name_map (pfile,\n-\t\t\t\t\t       searchptr->fname\n-\t\t\t\t\t       ? searchptr->fname : \".\");\n-\t  searchptr->got_name_map = 1;\n-\t}\n-\n-      /* First check the mapping for the directory we are using.  */\n-      if (searchptr && searchptr->name_map)\n-\t{\n-\t  from = filename;\n-\t  if (searchptr->fname)\n-\t    from += strlen (searchptr->fname) + 1;\n-\t  for (map = searchptr->name_map; map; map = map->map_next)\n-\t    {\n-\t      if (! strcmp (map->map_from, from))\n-\t\t{\n-\t\t  /* Found a match.  */\n-\t\t  return open (map->map_to, O_RDONLY, 0666);\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Try to find a mapping file for the particular directory we are\n-\t looking in.  Thus #include <sys/types.h> will look up sys/types.h\n-\t in /usr/include/header.gcc and look up types.h in\n-\t /usr/include/sys/header.gcc.  */\n-      p = rindex (filename, '/');\n-      if (! p)\n-\tp = filename;\n-      if (searchptr\n-\t  && searchptr->fname\n-\t  && strlen (searchptr->fname) == (size_t) (p - filename)\n-\t  && ! strncmp (searchptr->fname, filename, p - filename))\n-\t{\n-\t  /* FILENAME is in SEARCHPTR, which we've already checked.  */\n-\t  return open (filename, O_RDONLY, 0666);\n-\t}\n-\n-      if (p == filename)\n-\t{\n-\t  dir = \".\";\n-\t  from = filename;\n-\t}\n-      else\n-\t{\n-\t  dir = (char *) alloca (p - filename + 1);\n-\t  bcopy (filename, dir, p - filename);\n-\t  dir[p - filename] = '\\0';\n-\t  from = p + 1;\n-\t}\n-      for (map = read_name_map (pfile, dir); map; map = map->map_next)\n-\tif (! strcmp (map->map_from, from))\n-\t  return open (map->map_to, O_RDONLY, 0666);\n-    }\n-\n-  return open (filename, O_RDONLY, 0666);\n-}\n-\n-/* Process the contents of include file FNAME, already open on descriptor F,\n-   with output to OP.\n-   SYSTEM_HEADER_P is 1 if this file resides in any one of the known\n-   \"system\" include directories (as decided by the `is_system_include'\n-   function above).\n-   DIRPTR is the link in the dir path through which this file was found,\n-   or 0 if the file name was absolute or via the current directory.\n-   Return 1 on success, 0 on failure.\n-\n-   The caller is responsible for the cpp_push_buffer.  */\n-\n-static int\n-finclude (pfile, f, fname, system_header_p, dirptr)\n-     cpp_reader *pfile;\n-     int f;\n-     char *fname;\n-     int system_header_p;\n-     struct file_name_list *dirptr;\n-{\n-  struct stat st;\n-  size_t st_size;\n-  long i;\n-  int length;\n-  cpp_buffer *fp;\t\t\t/* For input stack frame */\n-#if 0\n-  int missing_newline = 0;\n-#endif\n-\n-  if (fstat (f, &st) < 0)\n-    {\n-      cpp_perror_with_name (pfile, fname);\n-      close (f);\n-      cpp_pop_buffer (pfile);\n-      return 0;\n-    }\n-\n-  fp = CPP_BUFFER (pfile);\n-  fp->nominal_fname = fp->fname = fname;\n-#if 0\n-  fp->length = 0;\n-#endif\n-  fp->dir = dirptr;\n-  fp->system_header_p = system_header_p;\n-  fp->lineno = 1;\n-  fp->colno = 1;\n-  fp->cleanup = file_cleanup;\n-\n-  if (S_ISREG (st.st_mode)) {\n-    st_size = (size_t) st.st_size;\n-    if (st_size != st.st_size || st_size + 2 < st_size) {\n-      cpp_error (pfile, \"file `%s' too large\", fname);\n-      close (f);\n-      return 0;\n-    }\n-    fp->buf = (U_CHAR *) xmalloc (st_size + 2);\n-    fp->alimit = fp->buf + st_size + 2;\n-    fp->cur = fp->buf;\n-\n-    /* Read the file contents, knowing that st_size is an upper bound\n-       on the number of bytes we can read.  */\n-    length = safe_read (f, fp->buf, st_size);\n-    fp->rlimit = fp->buf + length;\n-    if (length < 0) goto nope;\n-  }\n-  else if (S_ISDIR (st.st_mode)) {\n-    cpp_error (pfile, \"directory `%s' specified in #include\", fname);\n-    close (f);\n-    return 0;\n-  } else {\n-    /* Cannot count its file size before reading.\n-       First read the entire file into heap and\n-       copy them into buffer on stack.  */\n-\n-    size_t bsize = 2000;\n-\n-    st_size = 0;\n-    fp->buf = (U_CHAR *) xmalloc (bsize + 2);\n-\n-    for (;;) {\n-      i = safe_read (f, fp->buf + st_size, bsize - st_size);\n-      if (i < 0)\n-\tgoto nope;      /* error! */\n-      st_size += i;\n-      if (st_size != bsize)\n-\tbreak;\t/* End of file */\n-      bsize *= 2;\n-      fp->buf = (U_CHAR *) xrealloc (fp->buf, bsize + 2);\n-    }\n-    fp->cur = fp->buf;\n-    length = st_size;\n-  }\n-\n-  if ((length > 0 && fp->buf[length - 1] != '\\n')\n-      /* Backslash-newline at end is not good enough.  */\n-      || (length > 1 && fp->buf[length - 2] == '\\\\')) {\n-    fp->buf[length++] = '\\n';\n-#if 0\n-    missing_newline = 1;\n-#endif\n-  }\n-  fp->buf[length] = '\\0';\n-  fp->rlimit = fp->buf + length;\n-\n-  /* Close descriptor now, so nesting does not use lots of descriptors.  */\n-  close (f);\n-\n-  /* Must do this before calling trigraph_pcp, so that the correct file name\n-     will be printed in warning messages.  */\n-\n-  pfile->input_stack_listing_current = 0;\n-\n-#if 0\n-  if (!no_trigraphs)\n-    trigraph_pcp (fp);\n-#endif\n-\n-#if 0\n-  rescan (op, 0);\n-\n-  if (missing_newline)\n-    fp->lineno--;\n-\n-  if (CPP_PEDANTIC (pfile) && missing_newline)\n-    pedwarn (\"file does not end in newline\");\n-\n-  indepth--;\n-  input_file_stack_tick++;\n-  free (fp->buf);\n-#endif\n-  return 1;\n-\n- nope:\n-\n-  cpp_perror_with_name (pfile, fname);\n-  close (f);\n-  free (fp->buf);\n-  return 1;\n-}\n-\n /* This is called after options have been processed.\n  * Check options for consistency, and setup for processing input\n  * from the file named FNAME.  (Use standard input if FNAME==NULL.)\n@@ -6143,18 +5422,27 @@ cpp_start_read (pfile, fname)\n     trigraph_pcp (fp);\n #endif\n \n-  /* Avoid a #line 0 if -include files are present. */\n-  CPP_BUFFER (pfile)->lineno = 1;\n+  /* Must call finclude() on the main input before processing\n+     -include switches; otherwise the -included text winds up\n+     after the main input. */\n+  if (!finclude (pfile, f, fname, 0, NULL_PTR))\n+    return 0;\n   output_line_command (pfile, 0, same_file);\n+  pfile->only_seen_white = 2;\n+\n+  /* The -imacros files can be scanned now, but the -include files\n+     have to be pushed onto the include stack and processed later,\n+     in the main loop calling cpp_get_token.  That means the -include\n+     files have to be processed in reverse order of the pending list,\n+     which means the pending list has to be reversed again, which\n+     means the -imacros files have to be done separately and first. */\n   \n-  /* Scan the -include and -imacros files before the main input. */\n-\n   pfile->no_record_file++;\n-  for (pend = opts->pending;  pend;  pend = pend->next)\n+  for (pend = opts->pending; pend; pend = pend->next)\n     {\n       if (pend->cmd != NULL)\n         {\n-\t  if (strcmp (pend->cmd, \"-include\") == 0)\n+\t  if (strcmp (pend->cmd, \"-imacros\") == 0)\n \t    {\n \t      int fd = open (pend->arg, O_RDONLY, 0666);\n \t      if (fd < 0)\n@@ -6164,26 +5452,30 @@ cpp_start_read (pfile, fname)\n \t        }\n \t      if (!cpp_push_buffer (pfile, NULL, 0))\n \t        return 0;\n+\t      opts->no_output++;\n \t      if (finclude (pfile, fd, pend->arg, 0, NULL_PTR))\n-\t        {\n-\t\t  output_line_command (pfile, 0, enter_file);\n-\t\t  cpp_scan_buffer (pfile);\n-\t\t}\n+\t\tcpp_scan_buffer (pfile);\n+\t      opts->no_output--;\n \t    }\n-\t  else if (strcmp (pend->cmd, \"-imacros\") == 0)\n+\t}\n+    }\n+  opts->pending = nreverse_pending (opts->pending);\n+  for (pend = opts->pending; pend; pend = pend->next)\n+    {\n+      if (pend->cmd != NULL)\n+        {\n+\t  if (strcmp (pend->cmd, \"-include\") == 0)\n \t    {\n \t      int fd = open (pend->arg, O_RDONLY, 0666);\n \t      if (fd < 0)\n \t        {\n \t          cpp_perror_with_name (pfile, pend->arg);\n \t          return 0;\n \t        }\n-\t      opts->no_output++;\n \t      if (!cpp_push_buffer (pfile, NULL, 0))\n \t        return 0;\n \t      if (finclude (pfile, fd, pend->arg, 0, NULL_PTR))\n-\t\tcpp_scan_buffer (pfile);\n-\t      opts->no_output--;\n+\t        output_line_command (pfile, 0, enter_file);\n \t    }\n \t}\n     }\n@@ -6198,19 +5490,6 @@ cpp_start_read (pfile, fname)\n     }\n   opts->pending = NULL;\n \n-#if 0\n-  /* Scan the input, processing macros and directives.  */\n-\n-  rescan (&outbuf, 0);\n-\n-  if (missing_newline)\n-    fp->lineno--;\n-\n-  if (CPP_PEDANTIC (pfile) && missing_newline)\n-    pedwarn (\"file does not end in newline\");\n-\n-#endif\n-  finclude (pfile, f, fname, 0, NULL_PTR);\n   return 1;\n }\n \n@@ -7309,45 +6588,11 @@ free_token_list (tokens)\n     tokens = next;\n   }\n }\n-\f\n-/* Read LEN bytes at PTR from descriptor DESC, for file FILENAME,\n-   retrying if necessary.  If MAX_READ_LEN is defined, read at most\n-   that bytes at a time.  Return a negative value if an error occurs,\n-   otherwise return the actual number of bytes read,\n-   which must be LEN unless end-of-file was reached.  */\n-\n-static int\n-safe_read (desc, ptr, len)\n-     int desc;\n-     char *ptr;\n-     int len;\n-{\n-  int left, rcount, nchars;\n-\n-  left = len;\n-  while (left > 0) {\n-    rcount = left;\n-#ifdef MAX_READ_LEN\n-    if (rcount > MAX_READ_LEN)\n-      rcount = MAX_READ_LEN;\n-#endif\n-    nchars = read (desc, ptr, rcount);\n-    if (nchars < 0)\n-      {\n-#ifdef EINTR\n-\tif (errno == EINTR)\n-\t  continue;\n-#endif\n-\treturn nchars;\n-      }\n-    if (nchars == 0)\n-      break;\n-    ptr += nchars;\n-    left -= nchars;\n-  }\n-  return len - left;\n-}\n \n+/* FIXME: savestring() should be renamed strdup() and both should\n+   be moved into cppalloc.c.  We can't do that right now because\n+   then we'd get multiple-symbol clashes with toplev.c and several\n+   other people. */\n static char *\n xcalloc (number, size)\n      unsigned number, size;\n@@ -7358,7 +6603,7 @@ xcalloc (number, size)\n   return ptr;\n }\n \n-static char *\n+char *\n savestring (input)\n      char *input;\n {"}, {"sha": "3ff0c9214bfcf8eb23992ac64142d12d98c46026", "filename": "gcc/cpplib.h", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add7091b5b09593736c839d9ffa33d74f5d7cb61/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add7091b5b09593736c839d9ffa33d74f5d7cb61/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=add7091b5b09593736c839d9ffa33d74f5d7cb61", "patch": "@@ -510,6 +510,27 @@ struct cpp_options {\n #define CPP_PEDANTIC(PFILE) (CPP_OPTIONS (PFILE)->pedantic)\n #define CPP_PRINT_DEPS(PFILE) (CPP_OPTIONS (PFILE)->print_deps)\n \n+struct file_name_list\n+  {\n+    struct file_name_list *next;\n+    char *fname;\n+    /* If the following is nonzero, it is a macro name.\n+       Don't include the file again if that macro is defined.  */\n+    U_CHAR *control_macro;\n+    /* If the following is nonzero, it is a C-language system include\n+       directory.  */\n+    int c_system_include_path;\n+    /* Mapping of file names for this directory.  */\n+    struct file_name_map *name_map;\n+    /* Non-zero if name_map is valid.  */\n+    int got_name_map;\n+  };\n+\n+/* If a buffer's dir field is SELF_DIR_DUMMY, it means the file was found\n+   via the same directory as the file that #included it.  */\n+#define SELF_DIR_DUMMY ((struct file_name_list *) (~0))\n+\n+    \n /* Name under which this program was invoked.  */\n \n extern char *progname;\n@@ -623,6 +644,8 @@ struct definition {\n };\n \n extern unsigned char is_idchar[256];\n+extern unsigned char is_hor_space[256];\n+extern unsigned char is_space[256];\n \n /* Stack of conditionals currently in progress\n    (including both successful and failing conditionals).  */\n@@ -685,6 +708,25 @@ extern void cpp_pfatal_with_name PROTO ((cpp_reader *, const char *));\n extern void cpp_file_line_for_message PROTO ((cpp_reader *, char *, int, int));\n extern void cpp_print_containing_files PROTO ((cpp_reader *));\n \n+/* In cppfiles.c */\n+extern void append_include_chain\tPROTO ((cpp_reader *,\n+\t\t\t\t\t\tstruct file_name_list *,\n+\t\t\t\t\t\tstruct file_name_list *));\n+extern int finclude\t\t\tPROTO ((cpp_reader *, int, char *,\n+\t\t\t\t\t\tint, struct file_name_list *));\n+extern int find_include_file\t\tPROTO ((cpp_reader *, char *,\n+\t\t\t\t\t\tunsigned long, char *, int,\n+\t\t\t\t\t\tstruct file_name_list *,\n+\t\t\t\t\t\tstruct file_name_list **));\n+extern void deps_output\t\t\tPROTO ((cpp_reader *, char *, int));\n+\n+/* Bleargh. */\n+extern char *savestring\t\t\tPROTO ((char *));\n+#ifndef INCLUDE_LEN_FUDGE\n+#define INCLUDE_LEN_FUDGE 0\n+#endif\n+\n+    \n #ifdef __cplusplus\n }\n #endif"}, {"sha": "acf3d431aa7e5cd25d8a52624805ab7a7b77c4d7", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add7091b5b09593736c839d9ffa33d74f5d7cb61/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add7091b5b09593736c839d9ffa33d74f5d7cb61/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=add7091b5b09593736c839d9ffa33d74f5d7cb61", "patch": "@@ -1058,6 +1058,7 @@ documented_lang_options[] =\n   { \"-D\", \"\" },\n   { \"-I\", \"\" },\n   { \"-U\", \"\" },\n+  { \"-H\", \"\" },\n   { \"-idirafter\", \"\" },\n   { \"-imacros\", \"\" },\n   { \"-include\", \"\" },"}]}