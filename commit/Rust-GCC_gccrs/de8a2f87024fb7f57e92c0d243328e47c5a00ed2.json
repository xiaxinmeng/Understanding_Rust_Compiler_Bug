{"sha": "de8a2f87024fb7f57e92c0d243328e47c5a00ed2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU4YTJmODcwMjRmYjdmNTdlOTJjMGQyNDMzMjhlNDdjNWEwMGVkMg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-02-05T01:33:07Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-02-05T01:33:07Z"}, "message": "[multiple changes]\n\n\n2004-02-04  Felix Yen  <fwy@alumni.brown.edu>\n\n\t* testsuite/performance/20_util/producer_consumer.cc: New.\n\t* testsuite/performance/20_util/allocator/insert_insert.cc: Two loops.\n\n2004-02-04  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* testsuite/performance/20_util/allocator.cc: Move to..\n\t* testsuite/performance/20_util/allocator/insert.cc: ...here.\n\t* testsuite/performance/20_util/allocator_thread.cc: Move to...\n\t* testsuite/performance/20_util/allocator/insert_insert.cc: ...here.\n\t* testsuite/performance/20_util/allocator_map_thread.cc: Move to...\n\t* testsuite/performance/20_util/allocator/map_thread.cc: ...here.\n\nFrom-SVN: r77285", "tree": {"sha": "0a4ea350ce95ca0d512480d22fb8cd506f2c9797", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a4ea350ce95ca0d512480d22fb8cd506f2c9797"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de8a2f87024fb7f57e92c0d243328e47c5a00ed2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de8a2f87024fb7f57e92c0d243328e47c5a00ed2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de8a2f87024fb7f57e92c0d243328e47c5a00ed2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de8a2f87024fb7f57e92c0d243328e47c5a00ed2/comments", "author": null, "committer": null, "parents": [{"sha": "90bd9d546df94f81daa4a633803aacabd5cebd27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90bd9d546df94f81daa4a633803aacabd5cebd27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90bd9d546df94f81daa4a633803aacabd5cebd27"}], "stats": {"total": 380, "additions": 355, "deletions": 25}, "files": [{"sha": "1a5a989a826725c01ce8ac9f7a484a28b4683664", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de8a2f87024fb7f57e92c0d243328e47c5a00ed2/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de8a2f87024fb7f57e92c0d243328e47c5a00ed2/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=de8a2f87024fb7f57e92c0d243328e47c5a00ed2", "patch": "@@ -1,3 +1,17 @@\n+2004-02-04  Felix Yen  <fwy@alumni.brown.edu>\n+\n+\t* testsuite/performance/20_util/producer_consumer.cc: New.\n+\t* testsuite/performance/20_util/allocator/insert_insert.cc: Two loops.\n+\t\n+2004-02-04  Benjamin Kosnik  <bkoz@redhat.com>\n+\t\n+\t* testsuite/performance/20_util/allocator.cc: Move to..\n+\t* testsuite/performance/20_util/allocator/insert.cc: ...here.\t\n+\t* testsuite/performance/20_util/allocator_thread.cc: Move to...\n+\t* testsuite/performance/20_util/allocator/insert_insert.cc: ...here.\n+\t* testsuite/performance/20_util/allocator_map_thread.cc: Move to...\n+\t* testsuite/performance/20_util/allocator/map_thread.cc: ...here.\n+\t\n 2004-02-04  Jonathan Wakely  <redi@gcc.gnu.org>\n \n \t* docs/html/faq/index.html: Recommend using LD_LIBRARY_PATH."}, {"sha": "7a27c2fd3425a8b75da63916cdc04edb8ac7e79a", "filename": "libstdc++-v3/testsuite/performance/20_util/allocator/insert.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de8a2f87024fb7f57e92c0d243328e47c5a00ed2/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de8a2f87024fb7f57e92c0d243328e47c5a00ed2/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert.cc?ref=de8a2f87024fb7f57e92c0d243328e47c5a00ed2", "previous_filename": "libstdc++-v3/testsuite/performance/20_util/allocator.cc"}, {"sha": "c5df36a33388241fd3451d16a34e416371add964", "filename": "libstdc++-v3/testsuite/performance/20_util/allocator/insert_insert.cc", "status": "renamed", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de8a2f87024fb7f57e92c0d243328e47c5a00ed2/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert_insert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de8a2f87024fb7f57e92c0d243328e47c5a00ed2/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert_insert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Finsert_insert.cc?ref=de8a2f87024fb7f57e92c0d243328e47c5a00ed2", "patch": "@@ -71,35 +71,33 @@ template<typename TestType>\n     inline operator TestType() const { return this->first; }\n   };\n \n+template<typename Container>\n+  void\n+  do_loop()\n+  {\n+    Container obj;\n+    int test_iterations = 0;\n+    value_type<test_type> test_value;\n+    while (test_iterations < iterations)\n+      {\n+\tfor (int j = 0; j < insert_values; ++j)\n+\t  obj.insert(obj.end(), ++test_value);\n+\t++test_iterations;\n+      }\n+  }\n+\n template<typename Container>\n   void*\n-  do_loop(void* p = NULL)\n+  do_test(void* p = NULL)\n   {\n-    Container obj;    \n     try\n       {\n-\tint test_iterations = 0;\n-\tvalue_type<test_type> test_value;\n-\twhile (test_iterations < iterations)\n-\t  {\n-\t    for (int j = 0; j < insert_values; ++j)\n-\t      obj.insert(obj.end(), ++test_value);\n-\t    ++test_iterations;\n-\t  }\n-\t// NB: Don't use clear() here, instead force deallocation.\n-        obj = Container();\n-\ttest_iterations = 0;\n-\ttest_value = value_type<test_type>();\n-\twhile (test_iterations < iterations)\n-\t  {\n-\t    for (int j = 0; j < insert_values; ++j)\n-\t      obj.insert(obj.end(), ++test_value);\n-\t    ++test_iterations;\n-\t  }\n+\tdo_loop<Container>();\n+\tdo_loop<Container>();\n       }\n     catch(...)\n       {\n-\t// No point allocating all available memory, repeatedly.\t\n+\t// No point allocating all available memory, repeatedly.\n       }\n   }\n \n@@ -117,10 +115,10 @@ template<typename Container>\n     start_counters(time, resource);\n     \n     pthread_t  t1, t2, t3, t4;\n-    pthread_create(&t1, 0, &do_loop<Container>, 0);\n-    pthread_create(&t2, 0, &do_loop<Container>, 0);\n-    pthread_create(&t3, 0, &do_loop<Container>, 0);\n-    pthread_create(&t4, 0, &do_loop<Container>, 0);\n+    pthread_create(&t1, 0, &do_test<Container>, 0);\n+    pthread_create(&t2, 0, &do_test<Container>, 0);\n+    pthread_create(&t3, 0, &do_test<Container>, 0);\n+    pthread_create(&t4, 0, &do_test<Container>, 0);\n \n     pthread_join(t1, NULL);\n     pthread_join(t2, NULL);", "previous_filename": "libstdc++-v3/testsuite/performance/20_util/allocator_thread.cc"}, {"sha": "f6b4d45b651547c57235c14ee64057afbac14e91", "filename": "libstdc++-v3/testsuite/performance/20_util/allocator/map_thread.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de8a2f87024fb7f57e92c0d243328e47c5a00ed2/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fmap_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de8a2f87024fb7f57e92c0d243328e47c5a00ed2/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fmap_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fmap_thread.cc?ref=de8a2f87024fb7f57e92c0d243328e47c5a00ed2", "previous_filename": "libstdc++-v3/testsuite/performance/20_util/allocator_map_thread.cc"}, {"sha": "c8d2f1d0caf96022f65bf5fedbef509981ae22e9", "filename": "libstdc++-v3/testsuite/performance/20_util/allocator/producer_consumer.cc", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de8a2f87024fb7f57e92c0d243328e47c5a00ed2/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fproducer_consumer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de8a2f87024fb7f57e92c0d243328e47c5a00ed2/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fproducer_consumer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fallocator%2Fproducer_consumer.cc?ref=de8a2f87024fb7f57e92c0d243328e47c5a00ed2", "patch": "@@ -0,0 +1,318 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/*\n+ * The goal with this application is to compare the performance of\n+ * different allocators in a simple producer-consumer scenario.\n+ */\n+\n+// 2004-02-04 Felix Yen <fwy@alumni.brown.edu>\n+\n+#include <vector>\n+#include <list>\n+#include <map>\n+#include <typeinfo>\n+#include <sstream>\n+#include <pthread.h>\n+#include <ext/mt_allocator.h>\n+#include <ext/new_allocator.h>\n+#include <ext/malloc_allocator.h>\n+#include <cxxabi.h>\n+#include <testsuite_performance.h>\n+\n+\n+using namespace std;\n+using __gnu_cxx::__mt_alloc;\n+using __gnu_cxx::new_allocator;\n+using __gnu_cxx::malloc_allocator;\n+using abi::__cxa_demangle;\n+\n+typedef int test_type;\n+typedef less<test_type> compare_type;\n+typedef malloc_allocator<test_type> malloc_alloc_type;\n+typedef new_allocator<test_type> new_alloc_type;\n+typedef __mt_alloc<test_type> so_alloc_type;\n+\n+// The number of iterations to be performed.\n+int iterations = 25000;\n+\n+// TODO - restore Stefan's comment?  i don't understand it.  -- fwy\n+int insert_values = 128;\n+\n+class Lock\n+{\n+public:\n+  Lock() {pthread_mutex_init(&mutex, 0);}\n+  ~Lock() {pthread_mutex_destroy(&mutex);}\n+\n+public:\n+  inline pthread_mutex_t* operator&() {return &mutex;}\n+\n+public:\n+  inline void lock() {pthread_mutex_lock(&mutex);}\n+  inline void unlock() {pthread_mutex_unlock(&mutex);}\n+\n+private:\n+  Lock(const Lock&);\n+  Lock& operator=(Lock&);\n+\n+private:\n+  pthread_mutex_t mutex;\n+};\n+\n+class AutoLock\n+{\n+public:\n+  AutoLock(Lock& _lock)\n+  : lock(_lock)\n+  {lock.lock();}\n+\n+  ~AutoLock() {lock.unlock();}\n+\n+private:\n+  AutoLock(AutoLock&);\n+  AutoLock& operator=(AutoLock&);\n+\n+private:\n+  Lock& lock;\n+};\n+\n+template<typename Container>\n+  class Queue\n+  {\n+  public:\n+    Queue() {pthread_cond_init(&condition, 0);}\n+    ~Queue() {pthread_cond_destroy(&condition);}\n+\n+  public:\n+    void push_back(const typename Container::value_type& x);\n+    void swap(Container& container);\n+\n+  private:\n+    pthread_cond_t condition;\n+    Lock lock;\n+    Container queue;\n+  };\n+\n+template<typename Container>\n+  void\n+  Queue<Container>::push_back(const typename Container::value_type& value)\n+  {\n+    AutoLock auto_lock(lock);\n+    queue.insert(queue.end(), value);\n+    if (queue.size() == 1) pthread_cond_signal(&condition);\n+  }\n+\n+template<typename Container>\n+  void\n+  Queue<Container>::swap(Container& container)\n+  {\n+    AutoLock auto_lock(lock);\n+    while (queue.empty()) pthread_cond_wait(&condition, &lock);\n+    queue.swap(container);\n+  }\n+\n+class Thread\n+{ \n+  // NB: Make this the last data member of an object defining operator()().\n+public:\n+  class Attributes\n+  {\n+  public:\n+    Attributes(int state = PTHREAD_CREATE_JOINABLE);\n+    ~Attributes() {pthread_attr_destroy(&attributes);}\n+\n+  public:\n+    inline pthread_attr_t* operator&() {return &attributes;}\n+\n+  private:\n+    pthread_attr_t attributes;\n+  };\n+\n+public:\n+  Thread() {thread = pthread_self();}\n+  ~Thread();\n+\n+public:\n+  template <typename ThreadOwner>\n+    void create(ThreadOwner* owner);\n+\n+private:\n+  pthread_t thread;\n+};\n+\n+Thread::Attributes::Attributes(int state)\n+{\n+  pthread_attr_init(&attributes);\n+  pthread_attr_setdetachstate(&attributes, state);\n+}\n+\n+Thread::~Thread()\n+{\n+  if (!pthread_equal(thread, pthread_self()))\n+    pthread_join(thread, 0);\n+}\n+\n+template<typename ThreadOwner>\n+  void*\n+  create_thread(void* _this)\n+  {\n+    ThreadOwner* owner = static_cast<ThreadOwner*>(_this);\n+    (*owner)();\n+    return 0;\n+  }\n+\n+template<typename ThreadOwner>\n+  void\n+  Thread::create(ThreadOwner* owner)\n+  {\n+    Thread::Attributes attributes;\n+    pthread_create(&thread, &attributes, create_thread<ThreadOwner>, owner);\n+  }\n+\n+template<typename Container>\n+  class Consumer\n+  {\n+  public:\n+    Consumer(Queue<Container>& _queue)\n+    : queue(_queue)\n+    {thread.create(this);}\n+\n+  public:\n+    void operator()();\n+\n+  private:\n+    Queue<Container>& queue;\n+    Thread thread;\n+  };\n+\n+template<typename Container>\n+  void\n+  Consumer<Container>::operator()()\n+  {\n+    for (int j = insert_values * iterations; j > 0;)\n+    {\n+      Container container;\n+      queue.swap(container);\n+      j -= container.size();\n+    }\n+  }\n+\n+template<typename TestType>\n+  struct Value : public pair<TestType, TestType>\n+  {\n+    Value()\n+    : pair<TestType, TestType>(0, 0)\n+    { }\n+\n+    inline Value operator++() {return ++this->first, *this;}\n+    inline operator TestType() const {return this->first;}\n+  };\n+\n+template<typename Container>\n+  class ProducerConsumer : private Queue<Container>\n+  {\n+  public:\n+    ProducerConsumer() {thread.create(this);}\n+ \n+  public:\n+    void operator()();\n+\n+  private:\n+    Thread thread;\n+  };\n+\n+template<typename Container>\n+  void\n+  ProducerConsumer<Container>::operator()()\n+  {\n+    Consumer<Container> consumer(*this);\n+    Value<test_type> test_value;\n+    for (int j = insert_values * iterations; j-- > 0;)\n+      this->push_back(++test_value);\n+  }\n+\n+template<typename Container>\n+  void\n+  test_container(Container obj)\n+  {\n+    using namespace __gnu_test;\n+    int status;\n+\n+    time_counter time;\n+    resource_counter resource;\n+\n+    clear_counters(time, resource);\n+    start_counters(time, resource);\n+    {\n+      ProducerConsumer<Container> pc1;\n+      ProducerConsumer<Container> pc2;\n+    }\n+    stop_counters(time, resource);\n+\n+    std::ostringstream comment;\n+    comment << \"iterations: \" << iterations << '\\t';\n+    comment << \"type: \" << __cxa_demangle(typeid(obj).name(), 0, 0, &status);\n+    report_header(__FILE__, comment.str());\n+    report_performance(__FILE__, string(), time, resource);\n+  }\n+\n+int main(void)\n+{\n+#ifdef TEST_T1\n+  test_container(vector<test_type, malloc_alloc_type>());\n+#endif\n+#ifdef TEST_T2\n+  test_container(vector<test_type, new_alloc_type>());\n+#endif\n+#ifdef TEST_T3\n+  test_container(vector<test_type, so_alloc_type>());\n+#endif\n+\n+#ifdef TEST_T5\n+  test_container(list<test_type, malloc_alloc_type>());\n+#endif\n+#ifdef TEST_T6\n+  test_container(list<test_type, new_alloc_type>());\n+#endif\n+#ifdef TEST_T7\n+  test_container(list<test_type, so_alloc_type>());\n+#endif\n+\n+#ifdef TEST_T9\n+  test_container(map<test_type, test_type, compare_type, malloc_alloc_type>());\n+#endif\n+#ifdef TEST_T10\n+  test_container(map<test_type, test_type, compare_type, new_alloc_type>());\n+#endif\n+#ifdef TEST_T11\n+  test_container(map<test_type, test_type, compare_type, so_alloc_type>());\n+#endif\n+\n+  return 0;\n+}\n+"}]}