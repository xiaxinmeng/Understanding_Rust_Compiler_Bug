{"sha": "429b876b0784f5f4406eadf56115a8b4c20e874d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI5Yjg3NmIwNzg0ZjVmNDQwNmVhZGY1NjExNWE4YjRjMjBlODc0ZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2006-09-01T13:46:19Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2006-09-01T13:46:19Z"}, "message": "re PR c++/23287 (Explicitly invoking destructor of template class in a template and is dependent)\n\ncp/\n\tPR c++/23287\n\t* parser.c (cp_parser_id_expression): Add member_p\n\targument. Update all callers.\n\t(cp_parser_unqualified_id): Likewise.  Lookup a destructor name in\n\tthe object's scope, if valid.\n\t(cp_parser_global_scope_opt): Add object_scope_valid_p.  Update\n\tcallers.\n\t(cp_parser_postfix_dot_deref_expression): Set object_scope.\n\t* pt.c (tsubst_copy_and_build): Lookup dependent dtor name here.\ntestsuite/\n\tPR c++/23287\n\t* g++.dg/parse/dtor12.C: New.\n\nFrom-SVN: r116623", "tree": {"sha": "fd1ec9cb6d051bba56eed98210ea04146e9c7267", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd1ec9cb6d051bba56eed98210ea04146e9c7267"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/429b876b0784f5f4406eadf56115a8b4c20e874d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/429b876b0784f5f4406eadf56115a8b4c20e874d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/429b876b0784f5f4406eadf56115a8b4c20e874d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/429b876b0784f5f4406eadf56115a8b4c20e874d/comments", "author": null, "committer": null, "parents": [{"sha": "39aa3581c4e83d5c54196ae2f332b3a7d62e4ec8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39aa3581c4e83d5c54196ae2f332b3a7d62e4ec8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39aa3581c4e83d5c54196ae2f332b3a7d62e4ec8"}], "stats": {"total": 189, "additions": 147, "deletions": 42}, "files": [{"sha": "bb2e8415f3ae56640acc75f613fce8dbf059b765", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429b876b0784f5f4406eadf56115a8b4c20e874d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429b876b0784f5f4406eadf56115a8b4c20e874d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=429b876b0784f5f4406eadf56115a8b4c20e874d", "patch": "@@ -1,3 +1,15 @@\n+2006-09-01  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/23287\n+\t* parser.c (cp_parser_id_expression): Add member_p\n+\targument. Update all callers.\n+\t(cp_parser_unqualified_id): Likewise.  Lookup a destructor name in\n+\tthe object's scope, if valid.\n+\t(cp_parser_global_scope_opt): Add object_scope_valid_p.  Update\n+\tcallers.\n+\t(cp_parser_postfix_dot_deref_expression): Set object_scope.\n+\t* pt.c (tsubst_copy_and_build): Lookup dependent dtor name here.\n+\n 2006-08-30  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/26670"}, {"sha": "2e2885691023a86d2b2edd62471459ac2c94061a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 107, "deletions": 42, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429b876b0784f5f4406eadf56115a8b4c20e874d/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429b876b0784f5f4406eadf56115a8b4c20e874d/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=429b876b0784f5f4406eadf56115a8b4c20e874d", "patch": "@@ -1393,9 +1393,9 @@ static bool cp_parser_translation_unit\n static tree cp_parser_primary_expression\n   (cp_parser *, bool, bool, bool, cp_id_kind *);\n static tree cp_parser_id_expression\n-  (cp_parser *, bool, bool, bool *, bool, bool);\n+  (cp_parser *, bool, bool, bool *, bool, bool, bool);\n static tree cp_parser_unqualified_id\n-  (cp_parser *, bool, bool, bool, bool);\n+  (cp_parser *, bool, bool, bool, bool, bool);\n static tree cp_parser_nested_name_specifier_opt\n   (cp_parser *, bool, bool, bool, bool);\n static tree cp_parser_nested_name_specifier\n@@ -1720,7 +1720,7 @@ static bool cp_parser_check_template_parameters\n static tree cp_parser_simple_cast_expression\n   (cp_parser *);\n static tree cp_parser_global_scope_opt\n-  (cp_parser *, bool);\n+  (cp_parser *, bool, bool);\n static bool cp_parser_constructor_declarator_p\n   (cp_parser *, bool);\n static tree cp_parser_function_definition_from_specifiers_and_declarator\n@@ -2182,7 +2182,8 @@ cp_parser_parse_and_diagnose_invalid_type_name (cp_parser *parser)\n \t\t\t\t/*check_dependency_p=*/true,\n \t\t\t\t/*template_p=*/NULL,\n \t\t\t\t/*declarator_p=*/true,\n-\t\t\t\t/*optional_p=*/false);\n+\t\t\t\t/*optional_p=*/false,\n+\t\t\t\t/*member_p=*/false);\n   /* After the id-expression, there should be a plain identifier,\n      otherwise this is not a simple variable declaration. Also, if\n      the scope is dependent, we cannot do much.  */\n@@ -3061,7 +3062,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t\t\t     /*check_dependency_p=*/true,\n \t\t\t\t     &template_p,\n \t\t\t\t     /*declarator_p=*/false,\n-\t\t\t\t     /*optional_p=*/false);\n+\t\t\t\t     /*optional_p=*/false,\n+\t\t\t\t     /*member_p=*/false);\n \tif (id_expression == error_mark_node)\n \t  return error_mark_node;\n \ttoken = cp_lexer_peek_token (parser->lexer);\n@@ -3195,7 +3197,8 @@ cp_parser_id_expression (cp_parser *parser,\n \t\t\t bool check_dependency_p,\n \t\t\t bool *template_p,\n \t\t\t bool declarator_p,\n-\t\t\t bool optional_p)\n+\t\t\t bool optional_p,\n+\t\t\t bool member_p)\n {\n   bool global_scope_p;\n   bool nested_name_specifier_p;\n@@ -3206,8 +3209,10 @@ cp_parser_id_expression (cp_parser *parser,\n \n   /* Look for the optional `::' operator.  */\n   global_scope_p\n-    = (cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false)\n+    = (cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false,\n+\t\t\t\t   /*object_scope_valid_p=*/member_p)\n        != NULL_TREE);\n+  \n   /* Look for the optional nested-name-specifier.  */\n   nested_name_specifier_p\n     = (cp_parser_nested_name_specifier_opt (parser,\n@@ -3239,7 +3244,8 @@ cp_parser_id_expression (cp_parser *parser,\n       unqualified_id = cp_parser_unqualified_id (parser, *template_p,\n \t\t\t\t\t\t check_dependency_p,\n \t\t\t\t\t\t declarator_p,\n-\t\t\t\t\t\t /*optional_p=*/false);\n+\t\t\t\t\t\t /*optional_p=*/false,\n+\t\t\t\t\t\t /*member_p=*/false);\n       /* Restore the SAVED_SCOPE for our caller.  */\n       parser->scope = saved_scope;\n       parser->object_scope = saved_object_scope;\n@@ -3297,8 +3303,7 @@ cp_parser_id_expression (cp_parser *parser,\n   else\n     return cp_parser_unqualified_id (parser, template_keyword_p,\n \t\t\t\t     /*check_dependency_p=*/true,\n-\t\t\t\t     declarator_p,\n-\t\t\t\t     optional_p);\n+\t\t\t\t     declarator_p, optional_p, member_p);\n }\n \n /* Parse an unqualified-id.\n@@ -3328,7 +3333,8 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t\t\t  bool template_keyword_p,\n \t\t\t  bool check_dependency_p,\n \t\t\t  bool declarator_p,\n-\t\t\t  bool optional_p)\n+\t\t\t  bool optional_p,\n+\t\t\t  bool member_p)\n {\n   cp_token *token;\n \n@@ -3456,6 +3462,7 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t    if (cp_parser_parse_definitely (parser))\n \t      done = true;\n \t  }\n+\n \t/* In \"N::S::~S\", look in \"N\" as well.  */\n \tif (!done && scope && qualifying_scope)\n \t  {\n@@ -3474,24 +3481,56 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t    if (cp_parser_parse_definitely (parser))\n \t      done = true;\n \t  }\n-\t/* In \"p->S::~T\", look in the scope given by \"*p\" as well.  */\n-\telse if (!done && object_scope)\n+\t/* In \"p->~T\", look in the scope given by \"*p\" as well.  */\n+\telse if (!done && member_p)\n \t  {\n+\t    if (!object_scope)\n+\t      {\n+\t\t/* It's a dependent expression, so just parse the\n+\t\t   dtor name.  */\n+\t\ttree id;\n+\n+\t\tif (template_keyword_p)\n+\t\t  /* It's a template-id.  */\n+\t\t  id = cp_parser_template_id (parser, true,\n+\t\t\t\t\t      check_dependency_p,\n+\t\t\t\t\t      declarator_p);\n+\t\telse\n+\t\t  {\n+\t\t    /* Otherwise, it's an ordinary identifier.  */\n+\t\t    id = cp_parser_identifier (parser);\n+\t\t    /* If ID is a template type parm, then use that\n+\t\t       directly.  */\n+\t\t    if (TREE_TYPE (id)\n+\t\t\t&& TREE_CODE (TREE_TYPE (id)) == TEMPLATE_TYPE_PARM)\n+\t\t      id = TREE_TYPE (id);\n+\t\t  }\n+\n+\t\tif (id != error_mark_node)\n+\t\t  id = build_nt (BIT_NOT_EXPR, id);\n+\t\treturn id;\n+\t      }\n+\n \t    cp_parser_parse_tentatively (parser);\n \t    parser->scope = object_scope;\n \t    parser->object_scope = NULL_TREE;\n \t    parser->qualifying_scope = NULL_TREE;\n \t    type_decl\n \t      = cp_parser_class_name (parser,\n-\t\t\t\t      /*typename_keyword_p=*/false,\n+\t\t\t\t\t/*typename_keyword_p=*/false,\n \t\t\t\t      /*template_keyword_p=*/false,\n \t\t\t\t      none_type,\n \t\t\t\t      /*check_dependency=*/false,\n \t\t\t\t      /*class_head_p=*/false,\n \t\t\t\t      declarator_p);\n+\t    /* The name is not qualified, so reset the parser scopes\n+\t       so our callers do not get confused.  */\n+\t    parser->object_scope = object_scope;\n+\t    parser->scope = NULL_TREE;\n \t    if (cp_parser_parse_definitely (parser))\n \t      done = true;\n \t  }\n+\t\n \t/* Look in the surrounding context.  */\n \tif (!done)\n \t  {\n@@ -4482,11 +4521,12 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n   parser->qualifying_scope = NULL_TREE;\n   parser->object_scope = NULL_TREE;\n   *idk = CP_ID_KIND_NONE;\n+\n   /* Enter the scope corresponding to the type of the object\n      given by the POSTFIX_EXPRESSION.  */\n-  if (!dependent_p && TREE_TYPE (postfix_expression) != NULL_TREE)\n+  scope = TREE_TYPE (postfix_expression);\n+  if (!dependent_p && scope)\n     {\n-      scope = TREE_TYPE (postfix_expression);\n       /* According to the standard, no expression should ever have\n \t reference type.  Unfortunately, we do not currently match\n \t the standard in this respect in that our internal representation\n@@ -4500,11 +4540,8 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t  error (\"%qE does not have class type\", postfix_expression);\n \t  scope = NULL_TREE;\n \t}\n-      else\n+      else if (!dependent_p)\n \tscope = complete_type_or_else (scope, NULL_TREE);\n-      /* Let the name lookup machinery know that we are processing a\n-\t class member access expression.  */\n-      parser->context->object_type = scope;\n       /* If something went wrong, we want to be able to discern that case,\n \t as opposed to the case where there was no SCOPE due to the type\n \t of expression being dependent.  */\n@@ -4516,6 +4553,10 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n       if (scope == error_mark_node)\n \tpostfix_expression = error_mark_node;\n     }\n+  /* Let the name lookup machinery know that we are processing a class\n+     member access expression.  */\n+  parser->context->object_type = scope;\n+  parser->object_scope = scope;\n \n   /* Assume this expression is not a pseudo-destructor access.  */\n   pseudo_destructor_p = false;\n@@ -4553,7 +4594,8 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t       /*check_dependency_p=*/true,\n \t       &template_p,\n \t       /*declarator_p=*/false,\n-\t       /*optional_p=*/false));\n+\t       /*optional_p=*/false,\n+\t       /*member_p=*/true));\n       /* In general, build a SCOPE_REF if the member name is qualified.\n \t However, if the name was not dependent and has already been\n \t resolved; there is no need to build the SCOPE_REF.  For example;\n@@ -4758,7 +4800,9 @@ cp_parser_pseudo_destructor_name (cp_parser* parser,\n   *type = error_mark_node;\n \n   /* Look for the optional `::' operator.  */\n-  cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/true);\n+  cp_parser_global_scope_opt (parser,\n+\t\t\t      /*current_scope_valid_p=*/true,\n+\t\t\t      /*object_scop_valid_p=*/true);\n   /* Look for the optional nested-name-specifier.  */\n   nested_name_specifier_p\n     = (cp_parser_nested_name_specifier_opt (parser,\n@@ -5069,7 +5113,8 @@ cp_parser_new_expression (cp_parser* parser)\n   /* Look for the optional `::' operator.  */\n   global_scope_p\n     = (cp_parser_global_scope_opt (parser,\n-\t\t\t\t   /*current_scope_valid_p=*/false)\n+\t\t\t\t   /*current_scope_valid_p=*/false,\n+\t\t\t\t   /*object_scope_valid_p=*/false)\n        != NULL_TREE);\n   /* Look for the `new' operator.  */\n   cp_parser_require_keyword (parser, RID_NEW, \"`new'\");\n@@ -5367,7 +5412,8 @@ cp_parser_delete_expression (cp_parser* parser)\n   /* Look for the optional `::' operator.  */\n   global_scope_p\n     = (cp_parser_global_scope_opt (parser,\n-\t\t\t\t   /*current_scope_valid_p=*/false)\n+\t\t\t\t   /*current_scope_valid_p=*/false,\n+\t\t\t\t   /*object_scope_valid_p=*/false)\n        != NULL_TREE);\n   /* Look for the `delete' keyword.  */\n   cp_parser_require_keyword (parser, RID_DELETE, \"`delete'\");\n@@ -8022,7 +8068,8 @@ cp_parser_mem_initializer_id (cp_parser* parser)\n   /* Look for the optional `::' operator.  */\n   global_scope_p\n     = (cp_parser_global_scope_opt (parser,\n-\t\t\t\t   /*current_scope_valid_p=*/false)\n+\t\t\t\t   /*current_scope_valid_p=*/false,\n+\t\t\t\t   /*object_scope_valid_p=*/false)\n        != NULL_TREE);\n   /* Look for the optional nested-name-specifier.  The simplest way to\n      implement:\n@@ -8594,7 +8641,8 @@ cp_parser_type_parameter (cp_parser* parser)\n \t\t\t\t\t /*check_dependency_p=*/true,\n \t\t\t\t\t /*template_p=*/&is_template,\n \t\t\t\t\t /*declarator_p=*/false,\n-\t\t\t\t\t /*optional_p=*/false);\n+\t\t\t\t\t /*optional_p=*/false,\n+\t\t\t\t\t /*member_p=*/false);\n \t    if (TREE_CODE (default_argument) == TYPE_DECL)\n \t      /* If the id-expression was a template-id that refers to\n \t\t a template-class, we already have the declaration here,\n@@ -9159,7 +9207,8 @@ cp_parser_template_argument (cp_parser* parser)\n \t\t\t\t      /*check_dependency_p=*/true,\n \t\t\t\t      &template_p,\n \t\t\t\t      /*declarator_p=*/false,\n-\t\t\t\t      /*optional_p=*/false);\n+\t\t\t\t      /*optional_p=*/false,\n+\t\t\t\t      /*member_p=*/false);\n   /* If the next token isn't a `,' or a `>', then this argument wasn't\n      really finished.  */\n   if (!cp_parser_next_token_ends_template_argument_p (parser))\n@@ -9799,7 +9848,8 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n       /* Look for the optional `::' operator.  */\n       global_p\n \t= (cp_parser_global_scope_opt (parser,\n-\t\t\t\t       /*current_scope_valid_p=*/false)\n+\t\t\t\t       /*current_scope_valid_p=*/false,\n+\t\t\t\t       /*object_scope_valid_p=*/false)\n \t   != NULL_TREE);\n       /* Look for the nested-name specifier.  */\n       qualified_p\n@@ -10024,7 +10074,8 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \n   /* Look for the `::' operator.  */\n   cp_parser_global_scope_opt (parser,\n-\t\t\t      /*current_scope_valid_p=*/false);\n+\t\t\t      /*current_scope_valid_p=*/false,\n+\t\t\t      /*object_scope_valid_p=*/false);\n   /* Look for the nested-name-specifier.  */\n   if (tag_type == typename_type)\n     {\n@@ -10559,7 +10610,8 @@ cp_parser_qualified_namespace_specifier (cp_parser* parser)\n {\n   /* Look for the optional `::'.  */\n   cp_parser_global_scope_opt (parser,\n-\t\t\t      /*current_scope_valid_p=*/false);\n+\t\t\t      /*current_scope_valid_p=*/false,\n+\t\t\t      /*object_scope_valid_p=*/false);\n \n   /* Look for the optional nested-name-specifier.  */\n   cp_parser_nested_name_specifier_opt (parser,\n@@ -10604,7 +10656,8 @@ cp_parser_using_declaration (cp_parser* parser)\n   /* Look for the optional global scope qualification.  */\n   global_scope_p\n     = (cp_parser_global_scope_opt (parser,\n-\t\t\t\t   /*current_scope_valid_p=*/false)\n+\t\t\t\t   /*current_scope_valid_p=*/false,\n+\t\t\t\t   /*object_scope_valid_p=*/false)\n        != NULL_TREE);\n \n   /* If we saw `typename', or didn't see `::', then there must be a\n@@ -10630,7 +10683,8 @@ cp_parser_using_declaration (cp_parser* parser)\n \t\t\t\t\t /*template_keyword_p=*/false,\n \t\t\t\t\t /*check_dependency_p=*/true,\n \t\t\t\t\t /*declarator_p=*/true,\n-\t\t\t\t\t /*optional_p=*/false);\n+\t\t\t\t\t /*optional_p=*/false,\n+\t\t\t\t\t /*member_p=*/false);\n \n   /* The function we call to handle a using-declaration is different\n      depending on what scope we are in.  */\n@@ -10684,7 +10738,8 @@ cp_parser_using_directive (cp_parser* parser)\n   /* And the `namespace' keyword.  */\n   cp_parser_require_keyword (parser, RID_NAMESPACE, \"`namespace'\");\n   /* Look for the optional `::' operator.  */\n-  cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false);\n+  cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false,\n+\t\t\t      /*object_scope_valid_p=*/false);\n   /* And the optional nested-name-specifier.  */\n   cp_parser_nested_name_specifier_opt (parser,\n \t\t\t\t       /*typename_keyword_p=*/false,\n@@ -11752,7 +11807,8 @@ cp_parser_ptr_operator (cp_parser* parser,\n       cp_parser_parse_tentatively (parser);\n       /* Look for the optional `::' operator.  */\n       cp_parser_global_scope_opt (parser,\n-\t\t\t\t  /*current_scope_valid_p=*/false);\n+\t\t\t\t  /*current_scope_valid_p=*/false,\n+\t\t\t\t  /*object_scope_valid_p=*/false);\n       /* Look for the nested-name specifier.  */\n       cp_parser_nested_name_specifier (parser,\n \t\t\t\t       /*typename_keyword_p=*/false,\n@@ -11892,7 +11948,8 @@ cp_parser_declarator_id (cp_parser* parser, bool optional_p)\n \t\t\t\t/*check_dependency_p=*/false,\n \t\t\t\t/*template_p=*/NULL,\n \t\t\t\t/*declarator_p=*/true,\n-\t\t\t\toptional_p);\n+\t\t\t\toptional_p,\n+\t\t\t\t/*member_p=*/false);\n   if (id && BASELINK_P (id))\n     id = BASELINK_FUNCTIONS (id);\n   return id;\n@@ -13097,7 +13154,8 @@ cp_parser_class_head (cp_parser* parser,\n      issuing an error about it later if this really is a\n      class-head.  If it turns out just to be an elaborated type\n      specifier, remain silent.  */\n-  if (cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false))\n+  if (cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false,\n+\t\t\t\t  /*object_scope_valid_p=*/false))\n     qualified_p = true;\n \n   push_deferring_access_checks (dk_no_check);\n@@ -14083,7 +14141,8 @@ cp_parser_base_specifier (cp_parser* parser)\n     }\n \n   /* Look for the optional `::' operator.  */\n-  cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false);\n+  cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false,\n+\t\t\t      /*object_scope_valid_p=*/false);\n   /* Look for the nested-name-specifier.  The simplest way to\n      implement:\n \n@@ -15132,7 +15191,8 @@ cp_parser_check_template_parameters (cp_parser* parser,\n    present, and NULL_TREE otherwise.  */\n \n static tree\n-cp_parser_global_scope_opt (cp_parser* parser, bool current_scope_valid_p)\n+cp_parser_global_scope_opt (cp_parser* parser, bool current_scope_valid_p,\n+\t\t\t    bool object_scope_valid_p)\n {\n   cp_token *token;\n \n@@ -15151,12 +15211,15 @@ cp_parser_global_scope_opt (cp_parser* parser, bool current_scope_valid_p)\n \n       return parser->scope;\n     }\n-  else if (!current_scope_valid_p)\n+\n+  if (!current_scope_valid_p)\n     {\n       parser->scope = NULL_TREE;\n       parser->qualifying_scope = NULL_TREE;\n-      parser->object_scope = NULL_TREE;\n     }\n+  \n+  if (!object_scope_valid_p)\n+    parser->object_scope = NULL_TREE;\n \n   return NULL_TREE;\n }\n@@ -15194,7 +15257,8 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \n   /* Look for the optional `::' operator.  */\n   cp_parser_global_scope_opt (parser,\n-\t\t\t      /*current_scope_valid_p=*/false);\n+\t\t\t      /*current_scope_valid_p=*/false,\n+\t\t\t      /*object_scope_valid_p=*/false);\n   /* Look for the nested-name-specifier.  */\n   nested_name_p\n     = (cp_parser_nested_name_specifier_opt (parser,\n@@ -17901,7 +17965,8 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t\t\t      /*check_dependency_p=*/true,\n \t\t\t\t      /*template_p=*/NULL,\n \t\t\t\t      /*declarator_p=*/false,\n-\t\t\t\t      /*optional_p=*/false);\n+\t\t\t\t      /*optional_p=*/false,\n+\t\t\t\t      /*member_p=*/false);\n       if (name == error_mark_node)\n \tgoto skip_comma;\n "}, {"sha": "c8081f65fb2b1e979c9f149aa6e5bbbc25af6f23", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429b876b0784f5f4406eadf56115a8b4c20e874d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429b876b0784f5f4406eadf56115a8b4c20e874d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=429b876b0784f5f4406eadf56115a8b4c20e874d", "patch": "@@ -9200,6 +9200,14 @@ tsubst_copy_and_build (tree t,\n \t  member = tsubst_baselink (member,\n \t\t\t\t    non_reference (TREE_TYPE (object)),\n \t\t\t\t    args, complain, in_decl);\n+\telse if (TREE_CODE (member) == BIT_NOT_EXPR\n+\t\t && !TYPE_P (TREE_OPERAND (member, 0)))\n+\t  {\n+\t    tree id = TREE_OPERAND (member, 0);\n+\t    id = make_typename_type (object_type, id, typename_type, complain);\n+\t    gcc_assert (TREE_CODE (id) != TYPENAME_TYPE);\n+\t    member = build_nt (BIT_NOT_EXPR, id);\n+\t  }\n \telse\n \t  member = tsubst_copy (member, args, complain, in_decl);\n \tif (member == error_mark_node)"}, {"sha": "cec12fabecb9a5374306f6c4d9cd9107123ae2dd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429b876b0784f5f4406eadf56115a8b4c20e874d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429b876b0784f5f4406eadf56115a8b4c20e874d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=429b876b0784f5f4406eadf56115a8b4c20e874d", "patch": "@@ -1,3 +1,8 @@\n+2006-09-01  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/23287\n+\t* g++.dg/parse/dtor12.C: New.\n+\n 2006-08-31  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR tree-optimization/28839"}, {"sha": "d964662178e6d21c67264bb40a02c31331899fbd", "filename": "gcc/testsuite/g++.dg/parse/dtor12.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429b876b0784f5f4406eadf56115a8b4c20e874d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdtor12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429b876b0784f5f4406eadf56115a8b4c20e874d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdtor12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdtor12.C?ref=429b876b0784f5f4406eadf56115a8b4c20e874d", "patch": "@@ -0,0 +1,15 @@\n+// Copyright (C) 2006 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 1 Sep 2006 <nathan@codesourcery.com>\n+\n+// PR 23287: Failure to parse dependent dtor name\n+// Origin:Wolfgang Bangerth  <bangerth@dealii.org>\n+\n+\n+template <class T> struct A {}; \n+ \n+template <class T> void f(A<T> *ptr) { \n+  ptr->~A(); \n+}\n+\n+template void f<void> (A<void> *);\n+"}]}