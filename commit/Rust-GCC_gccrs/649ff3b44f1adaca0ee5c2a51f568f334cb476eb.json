{"sha": "649ff3b44f1adaca0ee5c2a51f568f334cb476eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ5ZmYzYjQ0ZjFhZGFjYTBlZTVjMmE1MWY1NjhmMzM0Y2I0NzZlYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-13T13:30:50Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-13T13:30:50Z"}, "message": "(force_fit_value): Operate on REAL_CST as well.\n\n(real_value_truncate): Don't use its own handler.\n(const_binop): Set overflow on FP error and call force_fit_type.\n(fold_convert): Likewise.\n\nFrom-SVN: r6768", "tree": {"sha": "10f334e93637d357f239c92a898fd640d576eb19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10f334e93637d357f239c92a898fd640d576eb19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/649ff3b44f1adaca0ee5c2a51f568f334cb476eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/649ff3b44f1adaca0ee5c2a51f568f334cb476eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/649ff3b44f1adaca0ee5c2a51f568f334cb476eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/649ff3b44f1adaca0ee5c2a51f568f334cb476eb/comments", "author": null, "committer": null, "parents": [{"sha": "831522a46e410eb9332a0883cfd3b50105aea4db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/831522a46e410eb9332a0883cfd3b50105aea4db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/831522a46e410eb9332a0883cfd3b50105aea4db"}], "stats": {"total": 90, "additions": 53, "deletions": 37}, "files": [{"sha": "453af6cd0dd9938031e29979f0e7d8fdff1d9902", "filename": "gcc/fold-const.c", "status": "modified", "additions": 53, "deletions": 37, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649ff3b44f1adaca0ee5c2a51f568f334cb476eb/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649ff3b44f1adaca0ee5c2a51f568f334cb476eb/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=649ff3b44f1adaca0ee5c2a51f568f334cb476eb", "patch": "@@ -140,7 +140,10 @@ decode (shorts, low, hi)\n    that don't belong in the type.\n    Yield 1 if a signed overflow occurs, 0 otherwise.\n    If OVERFLOW is nonzero, a signed overflow has already occurred\n-   in calculating T, so propagate it.  */\n+   in calculating T, so propagate it.\n+\n+   Make the real constant T valid for its type by calling CHECK_FLOAT_VALUE,\n+   if it exists.  */\n \n int\n force_fit_type (t, overflow)\n@@ -150,7 +153,16 @@ force_fit_type (t, overflow)\n   HOST_WIDE_INT low, high;\n   register int prec;\n \n-  if (TREE_CODE (t) != INTEGER_CST)\n+  if (TREE_CODE (t) == REAL_CST)\n+    {\n+#ifdef CHECK_FLOAT_VALUE\n+      CHECK_FLOAT_VALUE (TYPE_MODE (TREE_TYPE (t)), TREE_REAL_CST (t),\n+\t\t\t overflow);\n+#endif\n+      return overflow;\n+    }\n+\n+  else if (TREE_CODE (t) != INTEGER_CST)\n     return overflow;\n \n   low = TREE_INT_CST_LOW (t);\n@@ -803,34 +815,19 @@ div_and_round_double (code, uns,\n }\n \f\n #ifndef REAL_ARITHMETIC\n-/* Effectively truncate a real value to represent\n-   the nearest possible value in a narrower mode.\n-   The result is actually represented in the same data type as the argument,\n-   but its value is usually different.  */\n+/* Effectively truncate a real value to represent the nearest possible value\n+   in a narrower mode.  The result is actually represented in the same data\n+   type as the argument, but its value is usually different.\n+\n+   A trap may occur during the FP operations and it is the responsibility\n+   of the calling function to have a handler established.  */\n \n REAL_VALUE_TYPE\n real_value_truncate (mode, arg)\n      enum machine_mode mode;\n      REAL_VALUE_TYPE arg;\n {\n-#ifdef __STDC__\n-  /* Make sure the value is actually stored in memory before we turn off\n-     the handler.  */\n-  volatile\n-#endif\n-    REAL_VALUE_TYPE value;\n-  jmp_buf handler, old_handler;\n-  int handled;\n-\n-  if (setjmp (handler))\n-    {\n-      error (\"floating overflow\");\n-      return dconst0;\n-    }\n-  handled = push_float_handler (handler, old_handler);\n-  value = REAL_VALUE_TRUNCATE (mode, arg);\n-  pop_float_handler (handled, old_handler);\n-  return value;\n+  return REAL_VALUE_TRUNCATE (mode, arg);\n }\n \n #if TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n@@ -1333,18 +1330,19 @@ const_binop (code, arg1, arg2, notrunc)\n #if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n   if (TREE_CODE (arg1) == REAL_CST)\n     {\n-      REAL_VALUE_TYPE d1;\n-      REAL_VALUE_TYPE d2;\n+      REAL_VALUE_TYPE d1 = TREE_REAL_CST (arg1);\n+      REAL_VALUE_TYPE d2 = TREE_REAL_CST (arg2);\n+      int overflow = 0;\n       REAL_VALUE_TYPE value;\n       tree t;\n \n-      d1 = TREE_REAL_CST (arg1);\n-      d2 = TREE_REAL_CST (arg2);\n       if (setjmp (float_error))\n \t{\n-\t  pedwarn (\"floating overflow in constant expression\");\n-\t  return build (code, TREE_TYPE (arg1), arg1, arg2);\n+\t  t = copy_node (arg1);\n+\t  overflow = 1;\n+\t  goto got_float;\n \t}\n+\n       set_float_handler (float_error);\n \n #ifdef REAL_ARITHMETIC\n@@ -1387,7 +1385,16 @@ const_binop (code, arg1, arg2, notrunc)\n #endif /* no REAL_ARITHMETIC */\n       t = build_real (TREE_TYPE (arg1),\n \t\t      real_value_truncate (TYPE_MODE (TREE_TYPE (arg1)), value));\n+    got_float:\n       set_float_handler (NULL_PTR);\n+\n+      TREE_OVERFLOW (t)\n+\t= (force_fit_type (t, overflow)\n+\t   | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2));\n+      TREE_CONSTANT_OVERFLOW (t)\n+\t= TREE_OVERFLOW (t)\n+\t  | TREE_CONSTANT_OVERFLOW (arg1)\n+\t  | TREE_CONSTANT_OVERFLOW (arg2);\n       return t;\n     }\n #endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n@@ -1540,6 +1547,7 @@ fold_convert (t, arg1)\n      register tree arg1;\n {\n   register tree type = TREE_TYPE (t);\n+  int overflow = 0;\n \n   if (TREE_CODE (type) == POINTER_TYPE || INTEGRAL_TYPE_P (type))\n     {\n@@ -1583,10 +1591,8 @@ fold_convert (t, arg1)\n \t  u++;\n #endif\n \t  if (! (REAL_VALUES_LESS (l, x) && REAL_VALUES_LESS (x, u)))\n-\t    {\n-\t      pedwarn (\"real constant out of range for integer conversion\");\n-\t      return t;\n-\t    }\n+\t    overflow = 1;\n+\n #ifndef REAL_ARITHMETIC\n \t  {\n \t    REAL_VALUE_TYPE d;\n@@ -1619,7 +1625,10 @@ fold_convert (t, arg1)\n \t  }\n #endif\n \t  TREE_TYPE (t) = type;\n-\t  force_fit_type (t, 0);\n+\t  TREE_OVERFLOW (t)\n+\t    = TREE_OVERFLOW (arg1) | force_fit_type (t, overflow);\n+\t  TREE_CONSTANT_OVERFLOW (t)\n+\t    = TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg1);\n \t}\n #endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n       TREE_TYPE (t) = type;\n@@ -1634,14 +1643,21 @@ fold_convert (t, arg1)\n \t{\n \t  if (setjmp (float_error))\n \t    {\n-\t      pedwarn (\"floating overflow in constant expression\");\n-\t      return t;\n+\t      overflow = 1;\n+\t      t = copy_node (arg1);\n+\t      goto got_it;\n \t    }\n \t  set_float_handler (float_error);\n \n \t  t = build_real (type, real_value_truncate (TYPE_MODE (type),\n \t\t\t\t\t\t     TREE_REAL_CST (arg1)));\n \t  set_float_handler (NULL_PTR);\n+\n+\tgot_it:\n+\t  TREE_OVERFLOW (t)\n+\t    = TREE_OVERFLOW (arg1) | force_fit_type (t, overflow);\n+\t  TREE_CONSTANT_OVERFLOW (t)\n+\t    = TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg1);\n \t  return t;\n \t}\n     }"}]}