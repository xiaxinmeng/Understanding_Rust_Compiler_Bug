{"sha": "d886a5248e66ab911391af18bf955beb87ee8461", "node_id": "C_kwDOANBUbNoAKGQ4ODZhNTI0OGU2NmFiOTExMzkxYWYxOGJmOTU1YmViODdlZTg0NjE", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-03-28T22:19:20Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-03-29T18:10:37Z"}, "message": "gimple: Wrong -Wimplicit-fallthrough with if(1) [PR103597]\n\nThis patch fixes a wrong -Wimplicit-fallthrough warning for\n\n    case 0:\n      if (1)  // wrong may fallthrough\n\treturn 0;\n    case 1:\n\nwhich in .gimple looks like\n\n    <D.1981>: // case 0\n    if (1 != 0) goto <D.1985>; else goto <D.1986>;\n    <D.1985>:\n    D.1987 = 0;\n    // predicted unlikely by early return (on trees) predictor.\n    return D.1987;\n    <D.1986>:  // dead\n    <D.1982>: // case 1\n\nand the warning thinks that <D.1986>: falls through to <D.1982>:.  It\ndoes not know that <D.1986> is effectively a dead label, only reachable\nthrough fallthrough from previous instructions, never jumped to.  To\nthat effect, Jakub introduced UNUSED_LABEL_P, which is set on such dead\nlabels.\n\ncollect_fallthrough_labels has code to deal with cases like\n\n    case 2:\n      if (e != 10)\n\ti++; // this may fallthru, warn\n      else\n\treturn 44;\n    case 3:\n\nwhich collects labels that may fall through.  Here it sees the \"goto <D.1990>;\"\nat the end of the then branch and so when the warning reaches\n\n    ...\n    <D.1990>: // from if-then\n    <D.1984>: // case 3\n\nit knows it should warn about the possible fallthrough.  But an UNUSED_LABEL_P\nis not a label that can fallthrough like that, so it should ignore those.\n\nHowever, we still want to warn about this:\n\n    case 0:\n      if (1)\n\tn++; // falls through\n    case 1:\n\nso collect_fallthrough_labels needs to return the \"n = n + 1;\" statement, rather\nthan the dead label.\n\nCo-authored-by: Jakub Jelinek <jakub@redhat.com>\n\n\tPR middle-end/103597\n\ngcc/ChangeLog:\n\n\t* gimplify.cc (collect_fallthrough_labels): Don't push UNUSED_LABEL_Ps\n\tinto labels.  Maybe set prev to the statement preceding UNUSED_LABEL_P.\n\t(gimplify_cond_expr): Set UNUSED_LABEL_P.\n\t* tree.h (UNUSED_LABEL_P): New.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/Wimplicit-fallthrough-39.c: New test.", "tree": {"sha": "f47537490d8af1be79da3e2789de16eb383f891e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f47537490d8af1be79da3e2789de16eb383f891e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d886a5248e66ab911391af18bf955beb87ee8461", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d886a5248e66ab911391af18bf955beb87ee8461", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d886a5248e66ab911391af18bf955beb87ee8461", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d886a5248e66ab911391af18bf955beb87ee8461/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89976d082488b3a7dc7520b980f854ce83043d38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89976d082488b3a7dc7520b980f854ce83043d38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89976d082488b3a7dc7520b980f854ce83043d38"}], "stats": {"total": 200, "additions": 194, "deletions": 6}, "files": [{"sha": "2588824dce25b3c5bbcf97ba30625ea26152044f", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 48, "deletions": 6, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d886a5248e66ab911391af18bf955beb87ee8461/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d886a5248e66ab911391af18bf955beb87ee8461/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=d886a5248e66ab911391af18bf955beb87ee8461", "patch": "@@ -2250,9 +2250,9 @@ last_stmt_in_scope (gimple *stmt)\n     }\n }\n \n-/* Collect interesting labels in LABELS and return the statement preceding\n-   another case label, or a user-defined label.  Store a location useful\n-   to give warnings at *PREVLOC (usually the location of the returned\n+/* Collect labels that may fall through into LABELS and return the statement\n+   preceding another case label, or a user-defined label.  Store a location\n+   useful to give warnings at *PREVLOC (usually the location of the returned\n    statement or of its surrounding scope).  */\n \n static gimple *\n@@ -2331,8 +2331,12 @@ collect_fallthrough_labels (gimple_stmt_iterator *gsi_p,\n \t  if (gsi_end_p (*gsi_p))\n \t    break;\n \n-\t  struct label_entry l = { false_lab, if_loc };\n-\t  labels->safe_push (l);\n+\t  /* A dead label can't fall through.  */\n+\t  if (!UNUSED_LABEL_P (false_lab))\n+\t    {\n+\t      struct label_entry l = { false_lab, if_loc };\n+\t      labels->safe_push (l);\n+\t    }\n \n \t  /* Go to the last statement of the then branch.  */\n \t  gsi_prev (gsi_p);\n@@ -2359,6 +2363,17 @@ collect_fallthrough_labels (gimple_stmt_iterator *gsi_p,\n \t\t  labels->safe_push (l);\n \t\t}\n \t    }\n+\t  /* This case is about\n+\t      if (1 != 0) goto <D.2022>; else goto <D.2023>;\n+\t      <D.2022>:\n+\t      n = n + 1; // #1\n+\t      <D.2023>:  // #2\n+\t      <D.1988>:  // #3\n+\t     where #2 is UNUSED_LABEL_P and we want to warn about #1 falling\n+\t     through to #3.  So set PREV to #1.  */\n+\t  else if (UNUSED_LABEL_P (false_lab))\n+\t    prev = gsi_stmt (*gsi_p);\n+\n \t  /* And move back.  */\n \t  gsi_next (gsi_p);\n \t}\n@@ -4461,9 +4476,19 @@ gimplify_cond_expr (tree *expr_p, gimple_seq *pre_p, fallback_t fallback)\n       if (TREE_OPERAND (expr, 1) == NULL_TREE\n \t  && !have_else_clause_p\n \t  && TREE_OPERAND (expr, 2) != NULL_TREE)\n-\tlabel_cont = label_true;\n+\t{\n+\t  /* For if (0) {} else { code; } tell -Wimplicit-fallthrough\n+\t     handling that label_cont == label_true can be only reached\n+\t     through fallthrough from { code; }.  */\n+\t  if (integer_zerop (COND_EXPR_COND (expr)))\n+\t    UNUSED_LABEL_P (label_true) = 1;\n+\t  label_cont = label_true;\n+\t}\n       else\n \t{\n+\t  bool then_side_effects\n+\t    = (TREE_OPERAND (expr, 1)\n+\t       && TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 1)));\n \t  gimplify_seq_add_stmt (&seq, gimple_build_label (label_true));\n \t  have_then_clause_p = gimplify_stmt (&TREE_OPERAND (expr, 1), &seq);\n \t  /* For if (...) { code; } else {} or\n@@ -4477,6 +4502,16 @@ gimplify_cond_expr (tree *expr_p, gimple_seq *pre_p, fallback_t fallback)\n \t      gimple *g;\n \t      label_cont = create_artificial_label (UNKNOWN_LOCATION);\n \n+\t      /* For if (0) { non-side-effect-code } else { code }\n+\t\t tell -Wimplicit-fallthrough handling that label_cont can\n+\t\t be only reached through fallthrough from { code }.  */\n+\t      if (integer_zerop (COND_EXPR_COND (expr)))\n+\t\t{\n+\t\t  UNUSED_LABEL_P (label_true) = 1;\n+\t\t  if (!then_side_effects)\n+\t\t    UNUSED_LABEL_P (label_cont) = 1;\n+\t\t}\n+\n \t      g = gimple_build_goto (label_cont);\n \n \t      /* GIMPLE_COND's are very low level; they have embedded\n@@ -4493,6 +4528,13 @@ gimplify_cond_expr (tree *expr_p, gimple_seq *pre_p, fallback_t fallback)\n     }\n   if (!have_else_clause_p)\n     {\n+      /* For if (1) { code } or if (1) { code } else { non-side-effect-code }\n+\t tell -Wimplicit-fallthrough handling that label_false can be only\n+\t reached through fallthrough from { code }.  */\n+      if (integer_nonzerop (COND_EXPR_COND (expr))\n+\t  && (TREE_OPERAND (expr, 2) == NULL_TREE\n+\t      || !TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 2))))\n+\tUNUSED_LABEL_P (label_false) = 1;\n       gimplify_seq_add_stmt (&seq, gimple_build_label (label_false));\n       have_else_clause_p = gimplify_stmt (&TREE_OPERAND (expr, 2), &seq);\n     }"}, {"sha": "da4aef3a3182149c5c5e4200fb5a71bf02b035d0", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-39.c", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d886a5248e66ab911391af18bf955beb87ee8461/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-39.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d886a5248e66ab911391af18bf955beb87ee8461/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-39.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-39.c?ref=d886a5248e66ab911391af18bf955beb87ee8461", "patch": "@@ -0,0 +1,140 @@\n+/* PR middle-end/103597 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+#define E(c, e) if (c) e\n+\n+int\n+fn0 (int n)\n+{\n+  switch (n)\n+    {\n+    case 0:\n+      E (1, return 0);\n+    case 1:\n+      return -1;\n+    }\n+  return 0;\n+}\n+\n+int\n+fn1 (int n)\n+{\n+  switch (n)\n+    {\n+    case 0:\n+      E (1, goto out);\n+    case 1:\n+      return -1;\n+    }\n+out:\n+  return 0;\n+}\n+\n+int\n+fn2 (int n)\n+{\n+  switch (n)\n+    {\n+    case 0:\n+      if (1)\t  /* { dg-warning \"statement may fall through\" \"\" { target c++ } } */\n+       \tn++;\t  /* { dg-warning \"statement may fall through\" \"\" { target c } } */\n+    case 1:\t  /* { dg-message \"here\" } */\n+      return -1;\n+    }\n+  return 0;\n+}\n+\n+int\n+fn3 (int n)\n+{\n+  switch (n)\n+    {\n+    case 0:\n+      if (0)\t\t/* { dg-warning \"statement may fall through\" } */\n+       \treturn 0;\n+    case 1:\t\t/* { dg-message \"here\" } */\n+      return -1;\n+    }\n+  return 0;\n+}\n+\n+int\n+fn4 (int n)\n+{\n+  switch (n)\n+    {\n+    case 0:\n+      E (0, n++);\n+      --n;\t  /* { dg-warning \"statement may fall through\" } */\n+    case 1:\t  /* { dg-message \"here\" } */\n+      return -1;\n+    }\n+  return 0;\n+}\n+\n+int\n+fn5 (int n)\n+{\n+  switch (n)\n+    {\n+    case 0:\n+      if (1)\n+\treturn 0;\n+      else\n+\treturn -1;\n+    case 1:\n+      return -1;\n+    }\n+  return 0;\n+}\n+\n+int\n+fn6 (int n)\n+{\n+  switch (n)\n+    {\n+    case 0:\n+      if (1)\n+\treturn 0;\n+      else\n+\t{\n+meow:\n+\t  n--;  /* { dg-warning \"statement may fall through\" } */\n+\t}\n+    case 1:   /* { dg-message \"here\" } */\n+      return -1;\n+    case 2:\n+      goto meow;\n+    }\n+  return 0;\n+}\n+\n+int\n+fn7 (int n)\n+{\n+  switch (n)\n+    {\n+    case 0:\n+      if (1)\n+       \treturn 0;\n+woof:\n+    case 1:\n+      return -1;\n+    }\n+  return 0;\n+}\n+\n+int\n+fn8 (int n)\n+{\n+  switch (n)\n+    {\n+    case 0:\n+      if (1) n++; /* { dg-warning \"statement may fall through\" } */\n+woof:\t\t  /* { dg-message \"here\" } */\n+    case 1:\n+      return -1;\n+    }\n+  return 0;\n+}"}, {"sha": "cea49a500f295b7e3ba55543751729cd645a7576", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d886a5248e66ab911391af18bf955beb87ee8461/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d886a5248e66ab911391af18bf955beb87ee8461/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d886a5248e66ab911391af18bf955beb87ee8461", "patch": "@@ -787,6 +787,12 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define SWITCH_BREAK_LABEL_P(NODE) \\\n   (LABEL_DECL_CHECK (NODE)->base.protected_flag)\n \n+/* Set on label that is known not to be jumped to, it can be only\n+   reached by falling through from previous statements.\n+   This is used to implement -Wimplicit-fallthrough.  */\n+#define UNUSED_LABEL_P(NODE) \\\n+  (LABEL_DECL_CHECK (NODE)->base.default_def_flag)\n+\n /* Nonzero means this expression is volatile in the C sense:\n    its address should be of type `volatile WHATEVER *'.\n    In other words, the declared item is volatile qualified."}]}