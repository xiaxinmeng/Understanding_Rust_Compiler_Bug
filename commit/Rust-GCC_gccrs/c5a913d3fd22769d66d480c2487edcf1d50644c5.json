{"sha": "c5a913d3fd22769d66d480c2487edcf1d50644c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVhOTEzZDNmZDIyNzY5ZDY2ZDQ4MGMyNDg3ZWRjZjFkNTA2NDRjNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-04-01T17:13:06Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-15T08:04:39Z"}, "message": "[Ada] Implement AI12-0343 Return Statement Checks\n\n2020-06-15  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* einfo.ads (Return_Applies_To): Document special usage for E_Block.\n\t* einfo.adb (Write_Field8_Name): Write it for E_Block too.\n\t* exp_ch4.adb (Expand_N_Type_Conversion): Remove implementation of\n\tthe check prescribed by AI05-0073.\n\t* exp_ch6.adb (Apply_CW_Accessibility_Check): New procedure to apply\n\tthe check prescribed by AI95-344 extracted from...\n\t(Expand_N_Extended_Return_Statement): Apply the check prescribed by\n\tAI95-344 to the expression, if present.  Suppress only access checks\n\twhen analyzing the rewritten result.\n\t(Expand_Simple_Function_Return): ...here.  Rename local variable.\n\tCall Apply_CW_Accessibility_Check to apply the check prescribed by\n\tAI95-344, but do not do it for the simple return statement generated\n\tby the expansion of an extended return statement.  Apply the check\n\tprescribed by AI05-0073 to all functions returning anonymous access\n\ttype designating a specific tagged type, but not if the expression\n\twas null or tag checks are suppressed for the type, and use Not In\n\toperator rather than comparing the tags explicitly.\n\t* sem.adb (Analyze): Handle all Suppress values.\n\t* sem_ch6.adb (Analyze_Function_Return): Do not explicitly apply\n\tpredicate checks in the case of an extended return statement.\n\tDo not apply an implicit conversion to the anonymous access result\n\ttype in the case of the simple return statement generated by the\n\texpansion of an extended return statement.\n\t(New_Overloaded_Entity): Small comment tweak.\n\t* treepr.adb (Print_Node): Fix typo in flag string.", "tree": {"sha": "be42a128e9648a12f83adbde5f32b168ab889b1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be42a128e9648a12f83adbde5f32b168ab889b1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5a913d3fd22769d66d480c2487edcf1d50644c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a913d3fd22769d66d480c2487edcf1d50644c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5a913d3fd22769d66d480c2487edcf1d50644c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a913d3fd22769d66d480c2487edcf1d50644c5/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acc20d256c51f394904b904e8a8ceea3a44855fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acc20d256c51f394904b904e8a8ceea3a44855fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acc20d256c51f394904b904e8a8ceea3a44855fc"}], "stats": {"total": 456, "additions": 231, "deletions": 225}, "files": [{"sha": "4b664316ace33644efde0ae3dec2be2dd60d3e51", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a913d3fd22769d66d480c2487edcf1d50644c5/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a913d3fd22769d66d480c2487edcf1d50644c5/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=c5a913d3fd22769d66d480c2487edcf1d50644c5", "patch": "@@ -10185,7 +10185,9 @@ package body Einfo is\n          when E_Abstract_State =>\n             Write_Str (\"Refinement_Constituents\");\n \n-         when E_Return_Statement =>\n+         when E_Block\n+            | E_Return_Statement\n+         =>\n             Write_Str (\"Return_Applies_To\");\n \n          when others =>"}, {"sha": "1ca0faf6d916ed842c6e78177f4551bb21fe1522", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a913d3fd22769d66d480c2487edcf1d50644c5/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a913d3fd22769d66d480c2487edcf1d50644c5/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=c5a913d3fd22769d66d480c2487edcf1d50644c5", "patch": "@@ -4184,6 +4184,10 @@ package Einfo is\n --       RM-6.5(4/2). Note that a (simple) return statement within an\n --       extended_return_statement applies to the extended_return_statement,\n --       even though it causes the whole function to return.\n+--       Also defined in special E_Block entities built as E_Return_Statement\n+--       for extended return statements and attached to the block statement\n+--       by Expand_N_Extended_Return_Statement before being turned into an\n+--       E_Block by semantic analysis.\n \n --    Return_Present (Flag54)\n --       Defined in function and generic function entities. Set if the\n@@ -5917,6 +5921,7 @@ package Einfo is\n    --    (plus type attributes)\n \n    --  E_Block\n+   --    Return_Applies_To                   (Node8)\n    --    Block_Node                          (Node11)\n    --    First_Entity                        (Node17)\n    --    Last_Entity                         (Node20)"}, {"sha": "ba83a097f1516b730ca3985d3b4a28dd43400daa", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 18, "deletions": 71, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a913d3fd22769d66d480c2487edcf1d50644c5/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a913d3fd22769d66d480c2487edcf1d50644c5/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=c5a913d3fd22769d66d480c2487edcf1d50644c5", "patch": "@@ -12040,7 +12040,6 @@ package body Exp_Ch4 is\n          Tagged_Conversion : declare\n             Actual_Op_Typ   : Entity_Id;\n             Actual_Targ_Typ : Entity_Id;\n-            Make_Conversion : Boolean := False;\n             Root_Op_Typ     : Entity_Id;\n \n             procedure Make_Tag_Check (Targ_Typ : Entity_Id);\n@@ -12124,78 +12123,26 @@ package body Exp_Ch4 is\n                goto Done;\n             end if;\n \n-            if not Tag_Checks_Suppressed (Actual_Targ_Typ) then\n+            --  Create a runtime tag check for a downward CW type conversion\n \n-               --  Create a runtime tag check for a downward class-wide type\n-               --  conversion.\n-\n-               if Is_Class_Wide_Type (Actual_Op_Typ)\n-                 and then Actual_Op_Typ /= Actual_Targ_Typ\n-                 and then Root_Op_Typ /= Actual_Targ_Typ\n-                 and then Is_Ancestor (Root_Op_Typ, Actual_Targ_Typ,\n-                                       Use_Full_View => True)\n-               then\n+            if Is_Class_Wide_Type (Actual_Op_Typ)\n+              and then Actual_Op_Typ /= Actual_Targ_Typ\n+              and then Root_Op_Typ /= Actual_Targ_Typ\n+              and then Is_Ancestor\n+                         (Root_Op_Typ, Actual_Targ_Typ, Use_Full_View => True)\n+              and then not Tag_Checks_Suppressed (Actual_Targ_Typ)\n+            then\n+               declare\n+                  Conv : Node_Id;\n+               begin\n                   Make_Tag_Check (Class_Wide_Type (Actual_Targ_Typ));\n-                  Make_Conversion := True;\n-               end if;\n-\n-               --  AI05-0073: If the result subtype of the function is defined\n-               --  by an access_definition designating a specific tagged type\n-               --  T, a check is made that the result value is null or the tag\n-               --  of the object designated by the result value identifies T.\n-               --  Constraint_Error is raised if this check fails.\n-\n-               if Nkind (Parent (N)) = N_Simple_Return_Statement then\n-                  declare\n-                     Func     : Entity_Id;\n-                     Func_Typ : Entity_Id;\n-\n-                  begin\n-                     --  Climb scope stack looking for the enclosing function\n-\n-                     Func := Current_Scope;\n-                     while Present (Func)\n-                       and then Ekind (Func) /= E_Function\n-                     loop\n-                        Func := Scope (Func);\n-                     end loop;\n-\n-                     --  The function's return subtype must be defined using\n-                     --  an access definition.\n-\n-                     if Nkind (Result_Definition (Parent (Func))) =\n-                          N_Access_Definition\n-                     then\n-                        Func_Typ := Directly_Designated_Type (Etype (Func));\n-\n-                        --  The return subtype denotes a specific tagged type,\n-                        --  in other words, a non class-wide type.\n-\n-                        if Is_Tagged_Type (Func_Typ)\n-                          and then not Is_Class_Wide_Type (Func_Typ)\n-                        then\n-                           Make_Tag_Check (Actual_Targ_Typ);\n-                           Make_Conversion := True;\n-                        end if;\n-                     end if;\n-                  end;\n-               end if;\n-\n-               --  We have generated a tag check for either a class-wide type\n-               --  conversion or for AI05-0073.\n-\n-               if Make_Conversion then\n-                  declare\n-                     Conv : Node_Id;\n-                  begin\n-                     Conv :=\n-                       Make_Unchecked_Type_Conversion (Loc,\n-                         Subtype_Mark => New_Occurrence_Of (Target_Type, Loc),\n-                         Expression   => Relocate_Node (Expression (N)));\n-                     Rewrite (N, Conv);\n-                     Analyze_And_Resolve (N, Target_Type);\n-                  end;\n-               end if;\n+                  Conv :=\n+                    Make_Unchecked_Type_Conversion (Loc,\n+                      Subtype_Mark => New_Occurrence_Of (Target_Type, Loc),\n+                      Expression   => Relocate_Node (Expression (N)));\n+                  Rewrite (N, Conv);\n+                  Analyze_And_Resolve (N, Target_Type);\n+               end;\n             end if;\n          end Tagged_Conversion;\n "}, {"sha": "d679a8a9c83d6856fd611f9a16e6eecefc99cdff", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 188, "deletions": 148, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a913d3fd22769d66d480c2487edcf1d50644c5/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a913d3fd22769d66d480c2487edcf1d50644c5/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=c5a913d3fd22769d66d480c2487edcf1d50644c5", "patch": "@@ -137,6 +137,16 @@ package body Exp_Ch6 is\n    --  the activation Chain. Note: Master_Actual can be Empty, but only if\n    --  there are no tasks.\n \n+   procedure Apply_CW_Accessibility_Check (Exp : Node_Id; Func : Entity_Id);\n+   --  Ada 2005 (AI95-344): If the result type is class-wide, insert a check\n+   --  that the level of the return expression's underlying type is not deeper\n+   --  than the level of the master enclosing the function. Always generate the\n+   --  check when the type of the return expression is class-wide, when it's a\n+   --  type conversion, or when it's a formal parameter. Otherwise suppress the\n+   --  check in the case where the return expression has a specific type whose\n+   --  level is known not to be statically deeper than the result type of the\n+   --  function.\n+\n    function Caller_Known_Size\n      (Func_Call   : Node_Id;\n       Result_Subt : Entity_Id) return Boolean;\n@@ -610,6 +620,115 @@ package body Exp_Ch6 is\n       Add_Extra_Actual_To_Call (Function_Call, Chain_Formal, Chain_Actual);\n    end Add_Task_Actuals_To_Build_In_Place_Call;\n \n+   ----------------------------------\n+   -- Apply_CW_Accessibility_Check --\n+   ----------------------------------\n+\n+   procedure Apply_CW_Accessibility_Check (Exp : Node_Id; Func : Entity_Id) is\n+      Loc : constant Source_Ptr := Sloc (Exp);\n+\n+   begin\n+      if Ada_Version >= Ada_2005\n+        and then Tagged_Type_Expansion\n+        and then not Scope_Suppress.Suppress (Accessibility_Check)\n+        and then\n+          (Is_Class_Wide_Type (Etype (Exp))\n+            or else Nkind_In (Exp, N_Type_Conversion,\n+                                   N_Unchecked_Type_Conversion)\n+            or else (Is_Entity_Name (Exp)\n+                      and then Is_Formal (Entity (Exp)))\n+            or else Scope_Depth (Enclosing_Dynamic_Scope (Etype (Exp))) >\n+                      Scope_Depth (Enclosing_Dynamic_Scope (Func)))\n+      then\n+         declare\n+            Tag_Node : Node_Id;\n+\n+         begin\n+            --  Ada 2005 (AI-251): In class-wide interface objects we displace\n+            --  \"this\" to reference the base of the object. This is required to\n+            --  get access to the TSD of the object.\n+\n+            if Is_Class_Wide_Type (Etype (Exp))\n+              and then Is_Interface (Etype (Exp))\n+            then\n+               --  If the expression is an explicit dereference then we can\n+               --  directly displace the pointer to reference the base of\n+               --  the object.\n+\n+               if Nkind (Exp) = N_Explicit_Dereference then\n+                  Tag_Node :=\n+                    Make_Explicit_Dereference (Loc,\n+                      Prefix =>\n+                        Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                          Make_Function_Call (Loc,\n+                            Name                   =>\n+                              New_Occurrence_Of (RTE (RE_Base_Address), Loc),\n+                            Parameter_Associations => New_List (\n+                              Unchecked_Convert_To (RTE (RE_Address),\n+                                Duplicate_Subexpr (Prefix (Exp)))))));\n+\n+               --  Similar case to the previous one but the expression is a\n+               --  renaming of an explicit dereference.\n+\n+               elsif Nkind (Exp) = N_Identifier\n+                 and then Present (Renamed_Object (Entity (Exp)))\n+                 and then Nkind (Renamed_Object (Entity (Exp)))\n+                            = N_Explicit_Dereference\n+               then\n+                  Tag_Node :=\n+                    Make_Explicit_Dereference (Loc,\n+                      Prefix =>\n+                        Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                          Make_Function_Call (Loc,\n+                            Name                   =>\n+                              New_Occurrence_Of (RTE (RE_Base_Address), Loc),\n+                            Parameter_Associations => New_List (\n+                              Unchecked_Convert_To (RTE (RE_Address),\n+                                Duplicate_Subexpr\n+                                  (Prefix\n+                                    (Renamed_Object (Entity (Exp)))))))));\n+\n+               --  Common case: obtain the address of the actual object and\n+               --  displace the pointer to reference the base of the object.\n+\n+               else\n+                  Tag_Node :=\n+                    Make_Explicit_Dereference (Loc,\n+                      Prefix =>\n+                        Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                          Make_Function_Call (Loc,\n+                            Name               =>\n+                              New_Occurrence_Of (RTE (RE_Base_Address), Loc),\n+                            Parameter_Associations => New_List (\n+                              Make_Attribute_Reference (Loc,\n+                                Prefix         => Duplicate_Subexpr (Exp),\n+                                Attribute_Name => Name_Address)))));\n+               end if;\n+            else\n+               Tag_Node :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         => Duplicate_Subexpr (Exp),\n+                   Attribute_Name => Name_Tag);\n+            end if;\n+\n+            --  CodePeer does not do anything useful with\n+            --  Ada.Tags.Type_Specific_Data components.\n+\n+            if not CodePeer_Mode then\n+               Insert_Action (Exp,\n+                 Make_Raise_Program_Error (Loc,\n+                   Condition =>\n+                     Make_Op_Gt (Loc,\n+                       Left_Opnd  => Build_Get_Access_Level (Loc, Tag_Node),\n+                       Right_Opnd =>\n+                         Make_Integer_Literal (Loc,\n+                           Scope_Depth (Enclosing_Dynamic_Scope (Func)))),\n+                   Reason    => PE_Accessibility_Check_Failed));\n+            end if;\n+         end;\n+      end if;\n+   end Apply_CW_Accessibility_Check;\n+\n    -----------------------\n    -- BIP_Formal_Suffix --\n    -----------------------\n@@ -5282,6 +5401,17 @@ package body Exp_Ch6 is\n                Is_Build_In_Place_Function_Call (Exp));\n             null;\n          end if;\n+\n+         --  Ada 2005 (AI95-344): If the result type is class-wide, then insert\n+         --  a check that the level of the return expression's underlying type\n+         --  is not deeper than the level of the master enclosing the function.\n+\n+         --  AI12-043: The check is made immediately after the return object\n+         --  is created.\n+\n+         if Present (Exp) and then Is_Class_Wide_Type (Ret_Typ) then\n+            Apply_CW_Accessibility_Check (Exp, Func_Id);\n+         end if;\n       else\n          Exp := Empty;\n       end if;\n@@ -6034,7 +6164,14 @@ package body Exp_Ch6 is\n       Set_Comes_From_Extended_Return_Statement (Return_Stmt);\n \n       Rewrite (N, Result);\n-      Analyze (N, Suppress => All_Checks);\n+\n+      --  AI12-043: The checks of 6.5(8.1/3) and 6.5(21/3) are made immediately\n+      --  before an object is returned. A predicate that applies to the return\n+      --  subtype is checked immediately before an object is returned.\n+\n+      --  Suppress access checks to avoid generating extra checks for b-i-p.\n+\n+      Analyze (N, Suppress => Access_Check);\n    end Expand_N_Extended_Return_Statement;\n \n    ----------------------------\n@@ -7006,7 +7143,7 @@ package body Exp_Ch6 is\n       Exp : Node_Id := Expression (N);\n       pragma Assert (Present (Exp));\n \n-      Exptyp : constant Entity_Id := Etype (Exp);\n+      Exp_Typ : constant Entity_Id := Etype (Exp);\n       --  The type of the expression (not necessarily the same as R_Type)\n \n       Subtype_Ind : Node_Id;\n@@ -7039,12 +7176,13 @@ package body Exp_Ch6 is\n       end Check_Against_Result_Level;\n \n    --  Start of processing for Expand_Simple_Function_Return\n+\n    begin\n       if Is_Class_Wide_Type (R_Type)\n-        and then not Is_Class_Wide_Type (Exptyp)\n+        and then not Is_Class_Wide_Type (Exp_Typ)\n         and then Nkind (Exp) /= N_Type_Conversion\n       then\n-         Subtype_Ind := New_Occurrence_Of (Exptyp, Loc);\n+         Subtype_Ind := New_Occurrence_Of (Exp_Typ, Loc);\n       else\n          Subtype_Ind := New_Occurrence_Of (R_Type, Loc);\n \n@@ -7054,7 +7192,7 @@ package body Exp_Ch6 is\n          --  altogether to prevent tag overwriting.\n \n          if Is_Class_Wide_Type (R_Type)\n-           and then not Is_Class_Wide_Type (Exptyp)\n+           and then not Is_Class_Wide_Type (Exp_Typ)\n            and then Nkind (Exp) = N_Type_Conversion\n          then\n             Exp := Expression (Exp);\n@@ -7115,7 +7253,7 @@ package body Exp_Ch6 is\n          --  handled by means of simple return statements. This leaves their\n          --  expansion simple and clean.\n \n-        and then not Is_Thunk (Current_Scope)\n+        and then not Is_Thunk (Scope_Id)\n       then\n          declare\n             Return_Object_Entity : constant Entity_Id :=\n@@ -7150,18 +7288,14 @@ package body Exp_Ch6 is\n       --  barrier functions for protected types, which turn the condition into\n       --  a return statement.\n \n-      if Is_Boolean_Type (Exptyp)\n-        and then Nonzero_Is_True (Exptyp)\n-      then\n+      if Is_Boolean_Type (Exp_Typ) and then Nonzero_Is_True (Exp_Typ) then\n          Adjust_Condition (Exp);\n-         Adjust_Result_Type (Exp, Exptyp);\n+         Adjust_Result_Type (Exp, Exp_Typ);\n       end if;\n \n       --  Do validity check if enabled for returns\n \n-      if Validity_Checks_On\n-        and then Validity_Check_Returns\n-      then\n+      if Validity_Checks_On and then Validity_Check_Returns then\n          Ensure_Valid (Exp);\n       end if;\n \n@@ -7171,7 +7305,7 @@ package body Exp_Ch6 is\n       --  only done for scalars.\n       --  ???\n \n-      if Is_Scalar_Type (Exptyp) then\n+      if Is_Scalar_Type (Exp_Typ) then\n          Rewrite (Exp, Convert_To (R_Type, Exp));\n \n          --  The expression is resolved to ensure that the conversion gets\n@@ -7187,21 +7321,21 @@ package body Exp_Ch6 is\n       --  it requires a cleanup scope for the secondary stack case).\n \n       if Is_Build_In_Place_Function (Scope_Id)\n-        or else Is_Limited_Interface (Exptyp)\n+        or else Is_Limited_Interface (Exp_Typ)\n       then\n          null;\n \n       --  No copy needed for thunks returning interface type objects since\n       --  the object is returned by reference and the maximum functionality\n       --  required is just to displace the pointer.\n \n-      elsif Is_Thunk (Current_Scope) and then Is_Interface (Exptyp) then\n+      elsif Is_Thunk (Scope_Id) and then Is_Interface (Exp_Typ) then\n          null;\n \n       --  If the call is within a thunk and the type is a limited view, the\n       --  backend will eventually see the non-limited view of the type.\n \n-      elsif Is_Thunk (Current_Scope) and then Is_Incomplete_Type (Exptyp) then\n+      elsif Is_Thunk (Scope_Id) and then Is_Incomplete_Type (Exp_Typ) then\n          return;\n \n       --  A return statement from an ignored Ghost function does not use the\n@@ -7220,7 +7354,7 @@ package body Exp_Ch6 is\n          --  cause a temporary with maximum size to be created.\n \n          declare\n-            Ubt  : constant Entity_Id := Underlying_Type (Base_Type (Exptyp));\n+            Ubt  : constant Entity_Id := Underlying_Type (Base_Type (Exp_Typ));\n             Decl : Node_Id;\n             Ent  : Entity_Id;\n          begin\n@@ -7257,10 +7391,10 @@ package body Exp_Ch6 is\n          --  for array types if the constrained status of the target type is\n          --  different from that of the expression.\n \n-         if Requires_Transient_Scope (Exptyp)\n+         if Requires_Transient_Scope (Exp_Typ)\n            and then\n-              (not Is_Array_Type (Exptyp)\n-                or else Is_Constrained (Exptyp) = Is_Constrained (R_Type)\n+              (not Is_Array_Type (Exp_Typ)\n+                or else Is_Constrained (Exp_Typ) = Is_Constrained (R_Type)\n                 or else CW_Or_Has_Controlled_Part (Utyp))\n            and then Nkind (Exp) = N_Function_Call\n          then\n@@ -7432,134 +7566,44 @@ package body Exp_Ch6 is\n             end;\n          end if;\n \n-      --  Ada 2005 (AI-344): If the result type is class-wide, then insert\n+      --  Ada 2005 (AI95-344): If the result type is class-wide, then insert\n       --  a check that the level of the return expression's underlying type\n       --  is not deeper than the level of the master enclosing the function.\n-      --  Always generate the check when the type of the return expression\n-      --  is class-wide, when it's a type conversion, or when it's a formal\n-      --  parameter. Otherwise, suppress the check in the case where the\n-      --  return expression has a specific type whose level is known not to\n-      --  be statically deeper than the function's result type.\n+\n+      --  AI12-043: The check is made immediately after the return object is\n+      --  created. This means that we do not apply it to the simple return\n+      --  generated by the expansion of an extended return statement.\n \n       --  No runtime check needed in interface thunks since it is performed\n       --  by the target primitive associated with the thunk.\n \n-      --  Note: accessibility check is skipped in the VM case, since there\n-      --  does not seem to be any practical way to implement this check.\n-\n-      elsif Ada_Version >= Ada_2005\n-        and then Tagged_Type_Expansion\n-        and then Is_Class_Wide_Type (R_Type)\n-        and then not Is_Thunk (Current_Scope)\n-        and then not Scope_Suppress.Suppress (Accessibility_Check)\n-        and then\n-          (Is_Class_Wide_Type (Etype (Exp))\n-            or else Nkind_In (Exp, N_Type_Conversion,\n-                                   N_Unchecked_Type_Conversion)\n-            or else (Is_Entity_Name (Exp)\n-                      and then Is_Formal (Entity (Exp)))\n-            or else Scope_Depth (Enclosing_Dynamic_Scope (Etype (Exp))) >\n-                      Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))\n+      elsif Is_Class_Wide_Type (R_Type)\n+        and then not Comes_From_Extended_Return_Statement (N)\n+        and then not Is_Thunk (Scope_Id)\n       then\n-         declare\n-            Tag_Node : Node_Id;\n+         Apply_CW_Accessibility_Check (Exp, Scope_Id);\n \n-         begin\n-            --  Ada 2005 (AI-251): In class-wide interface objects we displace\n-            --  \"this\" to reference the base of the object. This is required to\n-            --  get access to the TSD of the object.\n-\n-            if Is_Class_Wide_Type (Etype (Exp))\n-              and then Is_Interface (Etype (Exp))\n-            then\n-               --  If the expression is an explicit dereference then we can\n-               --  directly displace the pointer to reference the base of\n-               --  the object.\n-\n-               if Nkind (Exp) = N_Explicit_Dereference then\n-                  Tag_Node :=\n-                    Make_Explicit_Dereference (Loc,\n-                      Prefix =>\n-                        Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n-                          Make_Function_Call (Loc,\n-                            Name                   =>\n-                              New_Occurrence_Of (RTE (RE_Base_Address), Loc),\n-                            Parameter_Associations => New_List (\n-                              Unchecked_Convert_To (RTE (RE_Address),\n-                                Duplicate_Subexpr (Prefix (Exp)))))));\n-\n-               --  Similar case to the previous one but the expression is a\n-               --  renaming of an explicit dereference.\n-\n-               elsif Nkind (Exp) = N_Identifier\n-                 and then Present (Renamed_Object (Entity (Exp)))\n-                 and then Nkind (Renamed_Object (Entity (Exp)))\n-                            = N_Explicit_Dereference\n-               then\n-                  Tag_Node :=\n-                    Make_Explicit_Dereference (Loc,\n-                      Prefix =>\n-                        Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n-                          Make_Function_Call (Loc,\n-                            Name                   =>\n-                              New_Occurrence_Of (RTE (RE_Base_Address), Loc),\n-                            Parameter_Associations => New_List (\n-                              Unchecked_Convert_To (RTE (RE_Address),\n-                                Duplicate_Subexpr\n-                                  (Prefix\n-                                    (Renamed_Object (Entity (Exp)))))))));\n-\n-               --  Common case: obtain the address of the actual object and\n-               --  displace the pointer to reference the base of the object.\n-\n-               else\n-                  Tag_Node :=\n-                    Make_Explicit_Dereference (Loc,\n-                      Prefix =>\n-                        Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n-                          Make_Function_Call (Loc,\n-                            Name               =>\n-                              New_Occurrence_Of (RTE (RE_Base_Address), Loc),\n-                            Parameter_Associations => New_List (\n-                              Make_Attribute_Reference (Loc,\n-                                Prefix         => Duplicate_Subexpr (Exp),\n-                                Attribute_Name => Name_Address)))));\n-               end if;\n-            else\n-               Tag_Node :=\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix         => Duplicate_Subexpr (Exp),\n-                   Attribute_Name => Name_Tag);\n-            end if;\n-\n-            --  CodePeer does not do anything useful with\n-            --  Ada.Tags.Type_Specific_Data components.\n-\n-            if not CodePeer_Mode then\n-               Insert_Action (Exp,\n-                 Make_Raise_Program_Error (Loc,\n-                   Condition =>\n-                     Make_Op_Gt (Loc,\n-                       Left_Opnd  => Build_Get_Access_Level (Loc, Tag_Node),\n-                       Right_Opnd =>\n-                         Make_Integer_Literal (Loc,\n-                           Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))),\n-                   Reason    => PE_Accessibility_Check_Failed));\n-            end if;\n-         end;\n-\n-      --  AI05-0073: If function has a controlling access result, check that\n-      --  the tag of the return value, if it is not null, matches designated\n-      --  type of return type.\n+      --  Ada 2012 (AI05-0073): If the result subtype of the function is\n+      --  defined by an access_definition designating a specific tagged\n+      --  type T, a check is made that the result value is null or the tag\n+      --  of the object designated by the result value identifies T.\n \n       --  The return expression is referenced twice in the code below, so it\n       --  must be made free of side effects. Given that different compilers\n       --  may evaluate these parameters in different order, both occurrences\n       --  perform a copy.\n \n       elsif Ekind (R_Type) = E_Anonymous_Access_Type\n-        and then Has_Controlling_Result (Scope_Id)\n+        and then Is_Tagged_Type (Designated_Type (R_Type))\n+        and then not Is_Class_Wide_Type (Designated_Type (R_Type))\n+        and then Nkind (Original_Node (Exp)) /= N_Null\n+        and then not Tag_Checks_Suppressed (Designated_Type (R_Type))\n       then\n+         --  Generate:\n+         --    [Constraint_Error\n+         --       when Exp /= null\n+         --         and then Exp.all not in Designated_Type]\n+\n          Insert_Action (N,\n            Make_Raise_Constraint_Error (Loc,\n              Condition =>\n@@ -7569,17 +7613,13 @@ package body Exp_Ch6 is\n                      Left_Opnd  => Duplicate_Subexpr (Exp),\n                      Right_Opnd => Make_Null (Loc)),\n \n-                 Right_Opnd => Make_Op_Ne (Loc,\n-                   Left_Opnd  =>\n-                     Make_Selected_Component (Loc,\n-                       Prefix        => Duplicate_Subexpr (Exp),\n-                       Selector_Name => Make_Identifier (Loc, Name_uTag)),\n-\n-                   Right_Opnd =>\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix         =>\n-                         New_Occurrence_Of (Designated_Type (R_Type), Loc),\n-                       Attribute_Name => Name_Tag))),\n+                 Right_Opnd =>\n+                   Make_Not_In (Loc,\n+                     Left_Opnd  =>\n+                       Make_Explicit_Dereference (Loc,\n+                         Prefix => Duplicate_Subexpr (Exp)),\n+                     Right_Opnd =>\n+                       New_Occurrence_Of (Designated_Type (R_Type), Loc))),\n \n              Reason    => CE_Tag_Check_Failed),\n              Suppress  => All_Checks);\n@@ -7595,9 +7635,9 @@ package body Exp_Ch6 is\n              Object_Access_Level (Entity (Ultimate_Prefix (Prefix (Exp))))));\n       end if;\n \n-      --  AI05-0234: RM 6.5(21/3). Check access discriminants to\n-      --  ensure that the function result does not outlive an\n-      --  object designated by one of it discriminants.\n+      --  AI05-0234: Check unconstrained access discriminants to ensure\n+      --  that the result does not outlive an object designated by one\n+      --  of its discriminants (RM 6.5(21/3)).\n \n       if Present (Extra_Accessibility_Of_Result (Scope_Id))\n         and then Has_Unconstrained_Access_Discriminants (R_Type)\n@@ -7843,7 +7883,7 @@ package body Exp_Ch6 is\n         and then Comes_From_Extended_Return_Statement (N)\n         and then Nkind (Expression (N)) = N_Identifier\n         and then Is_Interface (Utyp)\n-        and then Utyp /= Underlying_Type (Exptyp)\n+        and then Utyp /= Underlying_Type (Exp_Typ)\n       then\n          Rewrite (Exp, Convert_To (Utyp, Relocate_Node (Exp)));\n          Analyze_And_Resolve (Exp);"}, {"sha": "44aac6346dc35a0a2cdd5c861fe69e3bdfeb34fd", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a913d3fd22769d66d480c2487edcf1d50644c5/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a913d3fd22769d66d480c2487edcf1d50644c5/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=c5a913d3fd22769d66d480c2487edcf1d50644c5", "patch": "@@ -819,7 +819,7 @@ package body Sem is\n             Scope_Suppress.Suppress := Svs;\n          end;\n \n-      elsif Suppress = Overflow_Check then\n+      else\n          declare\n             Svg : constant Boolean := Scope_Suppress.Suppress (Suppress);\n          begin"}, {"sha": "8ff017a85725608e6b39b2dc7eea4e461da88628", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a913d3fd22769d66d480c2487edcf1d50644c5/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a913d3fd22769d66d480c2487edcf1d50644c5/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=c5a913d3fd22769d66d480c2487edcf1d50644c5", "patch": "@@ -1250,20 +1250,31 @@ package body Sem_Ch6 is\n \n          --  The return value is converted to the return type of the function,\n          --  which implies a predicate check if the return type is predicated.\n+         --  We do not apply the check for an extended return statement because\n+         --  Analyze_Object_Declaration has already done it on Obj_Decl above.\n          --  We do not apply the check to a case expression because it will\n          --  be expanded into a series of return statements, each of which\n          --  will receive a predicate check.\n \n-         if Nkind (Expr) /= N_Case_Expression then\n+         if Nkind (N) /= N_Extended_Return_Statement\n+           and then Nkind (Expr) /= N_Case_Expression\n+         then\n             Apply_Predicate_Check (Expr, R_Type);\n          end if;\n \n          --  Ada 2005 (AI-318-02): When the result type is an anonymous access\n          --  type, apply an implicit conversion of the expression to that type\n          --  to force appropriate static and run-time accessibility checks.\n+         --  But we want to apply the checks to an extended return statement\n+         --  only once, i.e. not to the simple return statement generated at\n+         --  the end of its expansion because, prior to leaving the function,\n+         --  the accessibility level of the return object changes to be a level\n+         --  determined by the point of call (RM 3.10.2(10.8/3).\n \n          if Ada_Version >= Ada_2005\n            and then Ekind (R_Type) = E_Anonymous_Access_Type\n+           and then (Nkind (N) = N_Extended_Return_Statement\n+                     or else not Comes_From_Extended_Return_Statement (N))\n          then\n             Rewrite (Expr, Convert_To (R_Type, Relocate_Node (Expr)));\n             Analyze_And_Resolve (Expr, R_Type);\n@@ -10614,8 +10625,9 @@ package body Sem_Ch6 is\n                              (\"\\move subprogram to the visible part\"\n                               & \" (RM 3.9.3(10))\", S);\n \n-                        --  AI05-0073: extend this test to the case of a\n-                        --  function with a controlling access result.\n+                        --  Ada 2012 (AI05-0073): Extend this check to the case\n+                        --  of a function whose result subtype is defined by an\n+                        --  access_definition designating specific tagged type.\n \n                         elsif Ekind (Etype (S)) = E_Anonymous_Access_Type\n                           and then Is_Tagged_Type (Designated_Type (Etype (S)))"}, {"sha": "b84af01d40f4c52435d2050a714f428d4afe37db", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a913d3fd22769d66d480c2487edcf1d50644c5/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a913d3fd22769d66d480c2487edcf1d50644c5/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=c5a913d3fd22769d66d480c2487edcf1d50644c5", "patch": "@@ -1164,7 +1164,7 @@ package body Treepr is\n \n             if Raises_Constraint_Error (N) then\n                Print_Str (Prefix_Str_Char);\n-               Print_Str (\"Raise_Constraint_Error = True\");\n+               Print_Str (\"Raises_Constraint_Error = True\");\n                Print_Eol;\n             end if;\n "}]}