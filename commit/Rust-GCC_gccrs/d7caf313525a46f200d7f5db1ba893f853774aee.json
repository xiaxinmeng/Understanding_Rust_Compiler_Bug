{"sha": "d7caf313525a46f200d7f5db1ba893f853774aee", "node_id": "C_kwDOANBUbNoAKGQ3Y2FmMzEzNTI1YTQ2ZjIwMGQ3ZjVkYjFiYTg5M2Y4NTM3NzRhZWU", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2023-03-18T07:56:23Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2023-03-18T07:56:23Z"}, "message": "Fortran: Fix bugs and missing features in finalization [PR37336]\n\n2023-03-18  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran\n\tPR fortran/103854\n\tPR fortran/96122\n\tPR fortran/37336\n\t* class.cc (finalize_component): Include the missing arguments\n\tin the call to the component's finalizer wrapper.\n\t(has_finalizer_component): Do not return true for procedure\n\tpointer components.\n\t(finalizer_insert_packed_call): Remove the redundant argument\n\tin the call to the final subroutine.\n\t(generate_finalization_wrapper): Add support for assumed rank\n\tfinalizers.\n\t(gfc_may_be_finalized): New helper function.\n\t* dump-parse-tree.cc (write_proc): Whitespace.\n\t* gfortran.h : Add prototype for gfc_may_be_finalized.\n\t* resolve.cc (resolve_function): Correct derived types that\n\thave an incomplete namespace.\n\t(resolve_where, gfc_resolve_where_code_in_forall,\n\tgfc_resolve_forall_body, gfc_resolve_code): Check that the op\n\tcode is still EXEC_ASSIGN. If it is set lhs to must finalize.\n\t(is_finalizable_type): New function.\n\t(generate_component_assignments): Set must_finalize if needed.\n\t(gfc_resolve_finalizers): Error if assumed rank finalizer is\n\tnot the only one. Warning on lack of scalar finalizer modified\n\tto account for assumed rank finalizers.\n\t(generate_final_call): New function.\n\t(generate_component_assignments): Enclose the outermost call in\n\ta block to capture automatic deallocation and final calls.\n\tSet must_finalize as required to satisfy the standards. Use an\n\texplicit pointer assignment for pointer components to capture\n\tfinalization of the target. Likewise use explicit assignment\n\tfor allocatable components. Do not use the temporary copy of\n\tthe lhs in defined assignment if the component is allocatable.\n\tPut the temporary in the same namespace as the lhs symbol if\n\tthe component may be finalized. Remove the leading assignment\n\tfrom the expansion of assignment of components that have their\n\town defined assignment components. Suppress finalization of\n\tassignment of temporary components to the lhs. Make an explicit\n\tfinal call for the rhs function temporary if it exists.\n\t(gfc_resolve_code): Set must_finalize for assignments with an\n\tarray constructor on the rhs.\n\t(gfc_resolve_finalizers): Ensure that an assumed rank finalizer\n\tis the only finalizer for that type and correct the surprising\n\twarning for the lack of a scalar finalizer.\n\t(check_defined_assignments): Handle allocatable components.\n\t(resolve_fl_derived): Set referenced the vtab for use\n\tassociated symbols.\n\t(resolve_symbol): Set referenced an unreferenced symbol that\n\twill be finalized.\n\t* trans-array.cc (gfc_trans_array_constructor_value): Add code\n\tto finalize the constructor result. Warn that this feature was\n\tremoved in F2018 and that it is suppressed by -std=2018.\n\t(trans_array_constructor): Add finalblock, pass to previous\n\tand apply to loop->post if filled.\n\t(gfc_add_loop_ss_code): Add se finalblock to outer loop post.\n\t(gfc_trans_array_cobounds, gfc_trans_array_bounds): Add any\n\tgenerated finalization code to the main block.\n\t(structure_alloc_comps): Add boolean argument to suppress\n\tfinalization and use it for calls from\n\tgfc_deallocate_alloc_comp_no_caf. Otherwise it defaults to\n\tfalse.\n\t(gfc_copy_alloc_comp_no_fini): New wrapper for\n\tstructure_alloc_comps.\n\t(gfc_alloc_allocatable_for_assignment): Suppress finalization\n\tby setting new arg in call to gfc_deallocate_alloc_comp_no_caf.\n\t(gfc_trans_deferred_array): Use gfc_may_be_finalized and do not\n\tdeallocate the components of entities with a leading '_' in the\n\tname that are also marked as artificial.\n\t* trans-array.h : Add the new boolean argument to the prototype\n\tof gfc_deallocate_alloc_comp_no_caf with a default of false.\n\tAdd prototype for gfc_copy_alloc_comp_no_fini.\n\t* trans-decl.cc(init_intent_out_dt): Tidy up the code.\n\t* trans-expr.cc (gfc_init_se): Initialize finalblock.\n\t(gfc_conv_procedure_call): Use gfc_finalize_tree_expr to\n\tfinalize function results. Replace in-line block for class\n\tresults with call to new function.\n\t(gfc_conv_expr): Finalize structure constructors for F2003 and\n\tF2008. Warn that this feature was deleted in F2018 and, unlike\n\tarray constructors, is not default. Add array constructor\n\tfinalblock to the post block.\n\t(gfc_trans_scalar_assign): Suppress finalization by setting new\n\targument in call to gfc_deallocate_alloc_comp_no_caf. Add the\n\tfinalization blocks to the main block.\n\t(gfc_trans_arrayfunc_assign): Use gfc_assignment_finalizer_call\n\tand ensure that finalization occurs after the evaluation of the\n\trhs but using the initial value for the lhs. Finalize rhs\n\tfunction results using gfc_finalize_tree_expr.\n\t(trans_class_assignment, gfc_trans_assignment_1): As previous\n\tfunction, taking care to order evaluation, assignment and\n\tfinalization correctly.\n\t* trans-io.cc (gfc_trans_transfer): Add the final block.\n\t* trans-stmt.cc (gfc_trans_call, gfc_trans_allocate): likewise.\n\t(trans_associate_var): Nullify derived allocatable components\n\tand finalize function targets with defined assignment\n\tcomponents on leaving the block scope.\n\t(trans_allocate): Finalize source expressions, if required,\n\tand set init_expr artificial temporarily to suppress the\n\tfinalization in gfc_trans_assignment.\n\t* trans.cc (gfc_add_finalizer_call): Do not finalize the\n\ttemporaries generated in type assignment with defined\n\tassignment components.\n\t(gfc_assignment_finalizer_call): New function.\n\t(gfc_finalize_tree_expr): New function.\n\t* trans.h: Add finalblock to gfc_se. Add the prototypes for\n\tgfc_finalize_tree_expr and gfc_assignment_finalizer_call.\n\ngcc/testsuite/\n\tPR fortran/64290\n\t* gfortran.dg/finalize_38.f90 : New test.\n\t* gfortran.dg/finalize_38a.f90 : New test.\n\t* gfortran.dg/allocate_with_source_25.f90 : The number of final\n\tcalls goes down from 6 to 4.\n\t* gfortran.dg/associate_25.f90 : Remove the incorrect comment.\n\t* gfortran.dg/auto_dealloc_2.f90 : Change the tree dump expr\n\tbut the final count remains the same.\n\t* gfortran.dg/unlimited_polymorphic_8.f90 : Tree dump reveals\n\tfoo.1.x rather than foo.0.x\n\n\tPR fortran/67444\n\t* gfortran.dg/finalize_39.f90 : New test.\n\n\tPR fortran/67471\n\t* gfortran.dg/finalize_40.f90 : New test.\n\n\tPR fortran/69298\n\tPR fortran/70863\n\t* gfortran.dg/finalize_41.f90 : New test.\n\n\tPR fortran/71798\n\t* gfortran.dg/finalize_42.f90 : New test.\n\n\tPR fortran/80524\n\t* gfortran.dg/finalize_43.f90 : New test.\n\n\tPR fortran/82996\n\t* gfortran.dg/finalize_44.f90 : New test.\n\n\tPR fortran/84472\n\t* gfortran.dg/finalize_45.f90 : New test.\n\n\tPR fortran/88735\n\tPR fortran/93691\n\t* gfortran.dg/finalize_46.f90 : New test.\n\n\tPR fortran/91316\n\t* gfortran.dg/finalize_47.f90 : New test.\n\n\tPR fortran/106576\n\t* gfortran.dg/finalize_48.f90 : New test.\n\n\tPR fortran/37336\n\t* gfortran.dg/finalize_49.f90 : New test.\n\t* gfortran.dg/finalize_50.f90 : New test.\n\t* gfortran.dg/finalize_51.f90 : New test.", "tree": {"sha": "a0a0ad7eb356672a6f3a614dc137eb14ceb26065", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0a0ad7eb356672a6f3a614dc137eb14ceb26065"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7caf313525a46f200d7f5db1ba893f853774aee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7caf313525a46f200d7f5db1ba893f853774aee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7caf313525a46f200d7f5db1ba893f853774aee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7caf313525a46f200d7f5db1ba893f853774aee/comments", "author": null, "committer": null, "parents": [{"sha": "454a4d5041f53cd1f7d902f6c0017b7ce95b36df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/454a4d5041f53cd1f7d902f6c0017b7ce95b36df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/454a4d5041f53cd1f7d902f6c0017b7ce95b36df"}], "stats": {"total": 3045, "additions": 2801, "deletions": 244}, "files": [{"sha": "bffc0ffff3a36fae1bcff461d3d8777c4ffb5243", "filename": "gcc/fortran/class.cc", "status": "modified", "additions": 76, "deletions": 5, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Fclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Fclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.cc?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -909,7 +909,8 @@ has_finalizer_component (gfc_symbol *derived)\n    gfc_component *c;\n \n   for (c = derived->components; c; c = c->next)\n-    if (c->ts.type == BT_DERIVED && !c->attr.pointer && !c->attr.allocatable)\n+    if (c->ts.type == BT_DERIVED && !c->attr.pointer && !c->attr.allocatable\n+\t&& c->attr.flavor != FL_PROCEDURE)\n       {\n \tif (c->ts.u.derived->f2k_derived\n \t    && c->ts.u.derived->f2k_derived->finalizers)\n@@ -1072,7 +1073,8 @@ finalize_component (gfc_expr *expr, gfc_symbol *derived, gfc_component *comp,\n     {\n       /* Call FINAL_WRAPPER (comp);  */\n       gfc_code *final_wrap;\n-      gfc_symbol *vtab;\n+      gfc_symbol *vtab, *byte_stride;\n+      gfc_expr *scalar, *size_expr, *fini_coarray_expr;\n       gfc_component *c;\n \n       vtab = gfc_find_derived_vtab (comp->ts.u.derived);\n@@ -1081,12 +1083,54 @@ finalize_component (gfc_expr *expr, gfc_symbol *derived, gfc_component *comp,\n \t  break;\n \n       gcc_assert (c);\n+\n+      /* Set scalar argument for storage_size.  */\n+      gfc_get_symbol (\"comp_byte_stride\", sub_ns, &byte_stride);\n+      byte_stride->ts = e->ts;\n+      byte_stride->attr.flavor = FL_VARIABLE;\n+      byte_stride->attr.value = 1;\n+      byte_stride->attr.artificial = 1;\n+      gfc_set_sym_referenced (byte_stride);\n+      gfc_commit_symbol (byte_stride);\n+      scalar = gfc_lval_expr_from_sym (byte_stride);\n+\n       final_wrap = gfc_get_code (EXEC_CALL);\n       final_wrap->symtree = c->initializer->symtree;\n       final_wrap->resolved_sym = c->initializer->symtree->n.sym;\n       final_wrap->ext.actual = gfc_get_actual_arglist ();\n       final_wrap->ext.actual->expr = e;\n \n+      /* size_expr = STORAGE_SIZE (...) / NUMERIC_STORAGE_SIZE.  */\n+      size_expr = gfc_get_expr ();\n+      size_expr->where = gfc_current_locus;\n+      size_expr->expr_type = EXPR_OP;\n+      size_expr->value.op.op = INTRINSIC_DIVIDE;\n+\n+      /* STORAGE_SIZE (array,kind=c_intptr_t).  */\n+      size_expr->value.op.op1\n+\t= gfc_build_intrinsic_call (sub_ns, GFC_ISYM_STORAGE_SIZE,\n+\t\t\t\t    \"storage_size\", gfc_current_locus, 2,\n+\t\t\t\t    scalar,\n+\t\t\t\t    gfc_get_int_expr (gfc_index_integer_kind,\n+\t\t\t\t\t\t      NULL, 0));\n+\n+      /* NUMERIC_STORAGE_SIZE.  */\n+      size_expr->value.op.op2 = gfc_get_int_expr (gfc_index_integer_kind, NULL,\n+\t\t\t\t\t\t  gfc_character_storage_size);\n+      size_expr->value.op.op1->ts = size_expr->value.op.op2->ts;\n+      size_expr->ts = size_expr->value.op.op1->ts;\n+\n+      /* Which provides the argument 'byte_stride'.....  */\n+      final_wrap->ext.actual->next = gfc_get_actual_arglist ();\n+      final_wrap->ext.actual->next->expr = size_expr;\n+\n+      /* ...and last of all the 'fini_coarray' argument.  */\n+      fini_coarray_expr = gfc_lval_expr_from_sym (fini_coarray);\n+      final_wrap->ext.actual->next->next = gfc_get_actual_arglist ();\n+      final_wrap->ext.actual->next->next->expr = fini_coarray_expr;\n+\n+\n+\n       if (*code)\n \t{\n \t  (*code)->next = final_wrap;\n@@ -1443,8 +1487,6 @@ finalizer_insert_packed_call (gfc_code *block, gfc_finalizer *fini,\n   block->next->resolved_sym = fini->proc_tree->n.sym;\n   block->next->ext.actual = gfc_get_actual_arglist ();\n   block->next->ext.actual->expr = gfc_lval_expr_from_sym (array);\n-  block->next->ext.actual->next = gfc_get_actual_arglist ();\n-  block->next->ext.actual->next->expr = gfc_copy_expr (size_expr);\n \n   /* ELSE.  */\n \n@@ -2060,13 +2102,32 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n       gfc_set_sym_referenced (ptr);\n       gfc_commit_symbol (ptr);\n \n+      fini = derived->f2k_derived->finalizers;\n+\n+      /* Assumed rank finalizers can be called directly. The call takes care\n+\t of setting up the descriptor.  resolve_finalizers has already checked\n+\t that this is the only finalizer for this kind/type (F2018: C790).  */\n+      if (fini->proc_tree && fini->proc_tree->n.sym->formal->sym->as\n+\t  && fini->proc_tree->n.sym->formal->sym->as->type == AS_ASSUMED_RANK)\n+\t{\n+\t  last_code->next = gfc_get_code (EXEC_CALL);\n+\t  last_code->next->symtree = fini->proc_tree;\n+\t  last_code->next->resolved_sym = fini->proc_tree->n.sym;\n+\t  last_code->next->ext.actual = gfc_get_actual_arglist ();\n+\t  last_code->next->ext.actual->expr = gfc_lval_expr_from_sym (array);\n+\n+\t  last_code = last_code->next;\n+\t  goto finish_assumed_rank;\n+\t}\n+\n       /* SELECT CASE (RANK (array)).  */\n       last_code->next = gfc_get_code (EXEC_SELECT);\n       last_code = last_code->next;\n       last_code->expr1 = gfc_copy_expr (rank);\n       block = NULL;\n \n-      for (fini = derived->f2k_derived->finalizers; fini; fini = fini->next)\n+\n+      for (; fini; fini = fini->next)\n \t{\n \t  gcc_assert (fini->proc_tree);   /* Should have been set in gfc_resolve_finalizers.  */\n \t  if (fini->proc_tree->n.sym->attr.elemental)\n@@ -2165,6 +2226,8 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n \t}\n     }\n \n+finish_assumed_rank:\n+\n   /* Finalize and deallocate allocatable components. The same manual\n      scalarization is used as above.  */\n \n@@ -2699,6 +2762,14 @@ gfc_is_finalizable (gfc_symbol *derived, gfc_expr **final_expr)\n }\n \n \n+bool\n+gfc_may_be_finalized (gfc_typespec ts)\n+{\n+  return (ts.type == BT_CLASS || (ts.type == BT_DERIVED\n+\t  && ts.u.derived && gfc_is_finalizable (ts.u.derived, NULL)));\n+}\n+\n+\n /* Find (or generate) the symbol for an intrinsic type's vtab.  This is\n    needed to support unlimited polymorphism.  */\n "}, {"sha": "3b24bdc1a6c76ef34001cf335f88668475084472", "filename": "gcc/fortran/dump-parse-tree.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Fdump-parse-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Fdump-parse-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.cc?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -3909,7 +3909,7 @@ write_proc (gfc_symbol *sym, bool bind_c)\n       if (sym->formal)\n \tfputs (\", \", dumpfile);\n     }\n-      \n+\n   for (f = sym->formal; f; f = f->next)\n     {\n       gfc_symbol *s;"}, {"sha": "9bab2c40ead3f5394213636f60823346701f6aa2", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -3931,6 +3931,7 @@ gfc_typebound_proc* gfc_find_typebound_intrinsic_op (gfc_symbol*, bool*,\n \t\t\t\t\t\t     locus*);\n gfc_symtree* gfc_get_tbp_symtree (gfc_symtree**, const char*);\n bool gfc_is_finalizable (gfc_symbol *, gfc_expr **);\n+bool gfc_may_be_finalized (gfc_typespec);\n \n #define CLASS_DATA(sym) sym->ts.u.derived->components\n #define UNLIMITED_POLY(sym) \\"}, {"sha": "ba603b4c4072852c5904870d9b05823fcc74b370", "filename": "gcc/fortran/resolve.cc", "status": "modified", "additions": 293, "deletions": 62, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.cc?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -3478,6 +3478,24 @@ resolve_function (gfc_expr *expr)\n \texpr->ts = expr->symtree->n.sym->result->ts;\n     }\n \n+  /* These derived types with an incomplete namespace, arising from use\n+     association, cause gfc_get_derived_vtab to segfault. If the function\n+     namespace does not suffice, something is badly wrong.  */\n+  if (expr->ts.type == BT_DERIVED\n+      && !expr->ts.u.derived->ns->proc_name)\n+    {\n+      gfc_symbol *der;\n+      gfc_find_symbol (expr->ts.u.derived->name, expr->symtree->n.sym->ns, 1, &der);\n+      if (der)\n+\t{\n+\t  expr->ts.u.derived->refs--;\n+\t  expr->ts.u.derived = der;\n+\t  der->refs++;\n+\t}\n+      else\n+\texpr->ts.u.derived->ns = expr->symtree->n.sym->ns;\n+    }\n+\n   if (!expr->ref && !expr->value.function.isym)\n     {\n       if (expr->value.function.esym)\n@@ -10556,6 +10574,11 @@ resolve_where (gfc_code *code, gfc_expr *mask)\n \t      if (e && !resolve_where_shape (cnext->expr1, e))\n \t       gfc_error (\"WHERE assignment target at %L has \"\n \t\t\t  \"inconsistent shape\", &cnext->expr1->where);\n+\n+\t      if (cnext->op == EXEC_ASSIGN\n+\t\t  && gfc_may_be_finalized (cnext->expr1->ts))\n+\t\tcnext->expr1->must_finalize = 1;\n+\n \t      break;\n \n \n@@ -10643,6 +10666,11 @@ gfc_resolve_where_code_in_forall (gfc_code *code, int nvar,\n \t    /* WHERE assignment statement */\n \t    case EXEC_ASSIGN:\n \t      gfc_resolve_assign_in_forall (cnext, nvar, var_expr);\n+\n+\t      if (cnext->op == EXEC_ASSIGN\n+\t\t  && gfc_may_be_finalized (cnext->expr1->ts))\n+\t\tcnext->expr1->must_finalize = 1;\n+\n \t      break;\n \n \t    /* WHERE operator assignment statement */\n@@ -10689,6 +10717,11 @@ gfc_resolve_forall_body (gfc_code *code, int nvar, gfc_expr **var_expr)\n \tcase EXEC_ASSIGN:\n \tcase EXEC_POINTER_ASSIGN:\n \t  gfc_resolve_assign_in_forall (c, nvar, var_expr);\n+\n+\t  if (c->op == EXEC_ASSIGN\n+\t      && gfc_may_be_finalized (c->expr1->ts))\n+\t    c->expr1->must_finalize = 1;\n+\n \t  break;\n \n \tcase EXEC_ASSIGN_CALL:\n@@ -10828,15 +10861,20 @@ gfc_resolve_forall (gfc_code *code, gfc_namespace *ns, int forall_save)\n \n \n /* Resolve a BLOCK construct statement.  */\n+static gfc_expr*\n+get_temp_from_expr (gfc_expr *, gfc_namespace *);\n+static gfc_code *\n+build_assignment (gfc_exec_op, gfc_expr *, gfc_expr *,\n+\t\t  gfc_component *, gfc_component *, locus);\n \n static void\n resolve_block_construct (gfc_code* code)\n {\n-  /* Resolve the BLOCK's namespace.  */\n-  gfc_resolve (code->ext.block.ns);\n+  gfc_namespace *ns = code->ext.block.ns;\n \n   /* For an ASSOCIATE block, the associations (and their targets) are already\n-     resolved during resolve_symbol.  */\n+     resolved during resolve_symbol. Resolve the BLOCK's namespace.  */\n+  gfc_resolve (ns);\n }\n \n \n@@ -11369,6 +11407,7 @@ get_temp_from_expr (gfc_expr *e, gfc_namespace *ns)\n   tmp->n.sym->attr.use_assoc = 0;\n   tmp->n.sym->attr.intent = INTENT_UNKNOWN;\n \n+\n   if (as)\n     {\n       tmp->n.sym->as = gfc_copy_array_spec (as);\n@@ -11420,9 +11459,62 @@ add_code_to_chain (gfc_code **this_code, gfc_code **head, gfc_code **tail)\n }\n \n \n+/* Generate a final call from a variable expression  */\n+\n+static void\n+generate_final_call (gfc_expr *tmp_expr, gfc_code **head, gfc_code **tail)\n+{\n+  gfc_code *this_code;\n+  gfc_expr *final_expr = NULL;\n+  gfc_expr *size_expr;\n+  gfc_expr *fini_coarray;\n+\n+  gcc_assert (tmp_expr->expr_type == EXPR_VARIABLE);\n+  if (!gfc_is_finalizable (tmp_expr->ts.u.derived, &final_expr) || !final_expr)\n+    return;\n+\n+  /* Now generate the finalizer call.  */\n+  this_code = gfc_get_code (EXEC_CALL);\n+  this_code->symtree = final_expr->symtree;\n+  this_code->resolved_sym = final_expr->symtree->n.sym;\n+\n+  //* Expression to be finalized  */\n+  this_code->ext.actual = gfc_get_actual_arglist ();\n+  this_code->ext.actual->expr = gfc_copy_expr (tmp_expr);\n+\n+  /* size_expr = STORAGE_SIZE (...) / NUMERIC_STORAGE_SIZE.  */\n+  this_code->ext.actual->next = gfc_get_actual_arglist ();\n+  size_expr = gfc_get_expr ();\n+  size_expr->where = gfc_current_locus;\n+  size_expr->expr_type = EXPR_OP;\n+  size_expr->value.op.op = INTRINSIC_DIVIDE;\n+  size_expr->value.op.op1\n+\t= gfc_build_intrinsic_call (gfc_current_ns, GFC_ISYM_STORAGE_SIZE,\n+\t\t\t\t    \"storage_size\", gfc_current_locus, 2,\n+\t\t\t\t    gfc_lval_expr_from_sym (tmp_expr->symtree->n.sym),\n+\t\t\t\t    gfc_get_int_expr (gfc_index_integer_kind,\n+\t\t\t\t\t\t      NULL, 0));\n+  size_expr->value.op.op2 = gfc_get_int_expr (gfc_index_integer_kind, NULL,\n+\t\t\t\t\t      gfc_character_storage_size);\n+  size_expr->value.op.op1->ts = size_expr->value.op.op2->ts;\n+  size_expr->ts = size_expr->value.op.op1->ts;\n+  this_code->ext.actual->next->expr = size_expr;\n+\n+  /* fini_coarray  */\n+  this_code->ext.actual->next->next = gfc_get_actual_arglist ();\n+  fini_coarray = gfc_get_constant_expr (BT_LOGICAL, gfc_default_logical_kind,\n+\t\t\t\t\t&tmp_expr->where);\n+  fini_coarray->value.logical = (int)gfc_expr_attr (tmp_expr).codimension;\n+  this_code->ext.actual->next->next->expr = fini_coarray;\n+\n+  add_code_to_chain (&this_code, head, tail);\n+\n+}\n+\n /* Counts the potential number of part array references that would\n    result from resolution of typebound defined assignments.  */\n \n+\n static int\n nonscalar_typebound_assign (gfc_symbol *derived, int depth)\n {\n@@ -11455,62 +11547,111 @@ nonscalar_typebound_assign (gfc_symbol *derived, int depth)\n }\n \n \n-/* Implement 7.2.1.3 of the F08 standard:\n-   \"An intrinsic assignment where the variable is of derived type is\n-   performed as if each component of the variable were assigned from the\n-   corresponding component of expr using pointer assignment (7.2.2) for\n-   each pointer component, defined assignment for each nonpointer\n-   nonallocatable component of a type that has a type-bound defined\n-   assignment consistent with the component, intrinsic assignment for\n-   each other nonpointer nonallocatable component, ...\"\n+/* Implement 10.2.1.3 paragraph 13 of the F18 standard:\n+   \"An intrinsic assignment where the variable is of derived type is performed\n+    as if each component of the variable were assigned from the corresponding\n+    component of expr using pointer assignment (10.2.2) for each pointer\n+    component, defined assignment for each nonpointer nonallocatable component\n+    of a type that has a type-bound defined assignment consistent with the\n+    component, intrinsic assignment for each other nonpointer nonallocatable\n+    component, and intrinsic assignment for each allocated coarray component.\n+    For unallocated coarray components, the corresponding component of the\n+    variable shall be unallocated. For a noncoarray allocatable component the\n+    following sequence of operations is applied.\n+\t(1) If the component of the variable is allocated, it is deallocated.\n+\t(2) If the component of the value of expr is allocated, the\n+\t    corresponding component of the variable is allocated with the same\n+\t    dynamic type and type parameters as the component of the value of\n+\t    expr. If it is an array, it is allocated with the same bounds. The\n+\t    value of the component of the value of expr is then assigned to the\n+\t    corresponding component of the variable using defined assignment if\n+\t    the declared type of the component has a type-bound defined\n+\t    assignment consistent with the component, and intrinsic assignment\n+\t    for the dynamic type of that component otherwise.\"\n+\n+   The pointer assignments are taken care of by the intrinsic assignment of the\n+   structure itself.  This function recursively adds defined assignments where\n+   required.  The recursion is accomplished by calling gfc_resolve_code.\n+\n+   When the lhs in a defined assignment has intent INOUT or is intent OUT\n+   and the component of 'var' is finalizable, we need a temporary for the\n+   lhs.  In pseudo-code for an assignment var = expr:\n+\n+   ! Confine finalization of temporaries, as far as possible.\n+     Enclose the code for the assignment in a block\n+   ! Only call function 'expr' once.\n+      #if ('expr is not a constant or an variable)\n+\ttemp_expr = expr\n+\texpr = temp_x\n+   ! Do the intrinsic assignment\n+      #if typeof ('var') has a typebound final subroutine\n+\tfinalize (var)\n+      var = expr\n+   ! Now do the component assignments\n+      #do over derived type components [%cmp]\n+\t#if (cmp is a pointer of any kind)\n+\t  continue\n+\tbuild the assignment\n+\tresolve the code\n+\t#if the code is a typebound assignment\n+\t   #if (arg1 is INOUT or finalizable OUT && !t1)\n+\t     t1 = var\n+\t     arg1 = t1\n+\t     deal with allocatation or not of var and this component\n+\t#elseif the code is an assignment by itself\n+\t   #if this component does not need finalization\n+\t     delete code and continue\n+\t#else\n+\t   remove the leading assignment\n+\t#endif\n+\tcommit the code\n+\t#if (t1 and (arg1 is INOUT or finalizable OUT))\n+\t   var%cmp = t1%cmp\n+      #enddo\n+      put all code chunks involving t1 to the top of the generated code\n+      insert the generated block in place of the original code\n+*/\n \n-   The pointer assignments are taken care of by the intrinsic\n-   assignment of the structure itself.  This function recursively adds\n-   defined assignments where required.  The recursion is accomplished\n-   by calling gfc_resolve_code.\n+static bool\n+is_finalizable_type (gfc_typespec ts)\n+{\n+  gfc_component *c;\n \n-   When the lhs in a defined assignment has intent INOUT, we need a\n-   temporary for the lhs.  In pseudo-code:\n+  if (ts.type != BT_DERIVED)\n+    return false;\n \n-   ! Only call function lhs once.\n-      if (lhs is not a constant or an variable)\n-\t  temp_x = expr2\n-          expr2 => temp_x\n-   ! Do the intrinsic assignment\n-      expr1 = expr2\n-   ! Now do the defined assignments\n-      do over components with typebound defined assignment [%cmp]\n-\t#if one component's assignment procedure is INOUT\n-\t  t1 = expr1\n-\t  #if expr2 non-variable\n-\t    temp_x = expr2\n-\t    expr2 => temp_x\n-\t  # endif\n-\t  expr1 = expr2\n-\t  # for each cmp\n-\t    t1%cmp {defined=} expr2%cmp\n-\t    expr1%cmp = t1%cmp\n-\t#else\n-\t  expr1 = expr2\n+  /* (1) Check for FINAL subroutines.  */\n+  if (ts.u.derived->f2k_derived && ts.u.derived->f2k_derived->finalizers)\n+    return true;\n \n-\t# for each cmp\n-\t  expr1%cmp {defined=} expr2%cmp\n-\t#endif\n-   */\n+  /* (2) Check for components of finalizable type.  */\n+  for (c = ts.u.derived->components; c; c = c->next)\n+    if (c->ts.type == BT_DERIVED\n+\t&& !c->attr.pointer && !c->attr.proc_pointer && !c->attr.allocatable\n+\t&& c->ts.u.derived->f2k_derived\n+\t&& c->ts.u.derived->f2k_derived->finalizers)\n+      return true;\n+\n+  return false;\n+}\n \n /* The temporary assignments have to be put on top of the additional\n    code to avoid the result being changed by the intrinsic assignment.\n    */\n static int component_assignment_level = 0;\n static gfc_code *tmp_head = NULL, *tmp_tail = NULL;\n+static bool finalizable_comp;\n \n static void\n generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n {\n   gfc_component *comp1, *comp2;\n   gfc_code *this_code = NULL, *head = NULL, *tail = NULL;\n-  gfc_expr *t1;\n+  gfc_code *tmp_code = NULL;\n+  gfc_expr *t1 = NULL;\n+  gfc_expr *tmp_expr = NULL;\n   int error_count, depth;\n+  bool finalizable_lhs;\n \n   gfc_get_errors (NULL, &error_count);\n \n@@ -11531,19 +11672,39 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n       return;\n     }\n \n+  if (!component_assignment_level)\n+    finalizable_comp = true;\n+\n+  /* Build a block so that function result temporaries are finalized\n+     locally on exiting the rather than enclosing scope.  */\n+  if (!component_assignment_level)\n+    {\n+      ns = gfc_build_block_ns (ns);\n+      tmp_code = gfc_get_code (EXEC_NOP);\n+      *tmp_code = **code;\n+      tmp_code->next = NULL;\n+      (*code)->op = EXEC_BLOCK;\n+      (*code)->ext.block.ns = ns;\n+      (*code)->ext.block.assoc = NULL;\n+      (*code)->expr1 = (*code)->expr2 = NULL;\n+      ns->code = tmp_code;\n+      code = &ns->code;\n+    }\n+\n   component_assignment_level++;\n \n+  finalizable_lhs = is_finalizable_type ((*code)->expr1->ts);\n+\n   /* Create a temporary so that functions get called only once.  */\n   if ((*code)->expr2->expr_type != EXPR_VARIABLE\n       && (*code)->expr2->expr_type != EXPR_CONSTANT)\n     {\n-      gfc_expr *tmp_expr;\n-\n       /* Assign the rhs to the temporary.  */\n       tmp_expr = get_temp_from_expr ((*code)->expr1, ns);\n       this_code = build_assignment (EXEC_ASSIGN,\n \t\t\t\t    tmp_expr, (*code)->expr2,\n \t\t\t\t    NULL, NULL, (*code)->loc);\n+      this_code->expr2->must_finalize = 1;\n       /* Add the code and substitute the rhs expression.  */\n       add_code_to_chain (&this_code, &tmp_head, &tmp_tail);\n       gfc_free_expr ((*code)->expr2);\n@@ -11553,8 +11714,10 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n   /* Do the intrinsic assignment.  This is not needed if the lhs is one\n      of the temporaries generated here, since the intrinsic assignment\n      to the final result already does this.  */\n-  if ((*code)->expr1->symtree->n.sym->name[2] != '@')\n+  if ((*code)->expr1->symtree->n.sym->name[2] != '.')\n     {\n+      if (finalizable_lhs)\n+\t(*code)->expr1->must_finalize = 1;\n       this_code = build_assignment (EXEC_ASSIGN,\n \t\t\t\t    (*code)->expr1, (*code)->expr2,\n \t\t\t\t    NULL, NULL, (*code)->loc);\n@@ -11564,21 +11727,23 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n   comp1 = (*code)->expr1->ts.u.derived->components;\n   comp2 = (*code)->expr2->ts.u.derived->components;\n \n-  t1 = NULL;\n   for (; comp1; comp1 = comp1->next, comp2 = comp2->next)\n     {\n       bool inout = false;\n+      bool finalizable_out = false;\n \n       /* The intrinsic assignment does the right thing for pointers\n \t of all kinds and allocatable components.  */\n       if (!gfc_bt_struct (comp1->ts.type)\n \t  || comp1->attr.pointer\n-\t  || comp1->attr.allocatable\n \t  || comp1->attr.proc_pointer_comp\n \t  || comp1->attr.class_pointer\n \t  || comp1->attr.proc_pointer)\n \tcontinue;\n \n+      finalizable_comp = is_finalizable_type (comp1->ts)\n+\t\t\t && !finalizable_lhs;\n+\n       /* Make an assignment for this component.  */\n       this_code = build_assignment (EXEC_ASSIGN,\n \t\t\t\t    (*code)->expr1, (*code)->expr2,\n@@ -11611,8 +11776,13 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n \t     a temporary must be generated and used instead.  */\n \t  rsym = this_code->resolved_sym;\n \t  dummy_args = gfc_sym_get_dummy_args (rsym);\n-\t  if (dummy_args\n-\t      && dummy_args->sym->attr.intent == INTENT_INOUT)\n+\t  finalizable_out = gfc_may_be_finalized (comp1->ts)\n+\t\t\t    && dummy_args\n+\t\t\t    && dummy_args->sym->attr.intent == INTENT_OUT;\n+\t  inout = dummy_args\n+\t\t  && dummy_args->sym->attr.intent == INTENT_INOUT;\n+\t  if ((inout || finalizable_out)\n+\t      && !comp1->attr.allocatable)\n \t    {\n \t      gfc_code *temp_code;\n \t      inout = true;\n@@ -11621,7 +11791,11 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n \t\t it at the head of the generated code.  */\n \t      if (!t1)\n \t\t{\n-\t\t  t1 = get_temp_from_expr ((*code)->expr1, ns);\n+\t\t  gfc_namespace *tmp_ns = ns;\n+\t\t  if (ns->parent && gfc_may_be_finalized (comp1->ts))\n+\t\t    tmp_ns = (*code)->expr1->symtree->n.sym->ns;\n+\t\t  t1 = get_temp_from_expr ((*code)->expr1, tmp_ns);\n+\t\t  t1->symtree->n.sym->attr.artificial = 1;\n \t\t  temp_code = build_assignment (EXEC_ASSIGN,\n \t\t\t\t\t\tt1, (*code)->expr1,\n \t\t\t\tNULL, NULL, (*code)->loc);\n@@ -11683,20 +11857,38 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n       else if (this_code->op == EXEC_ASSIGN && !this_code->next)\n \t{\n \t  /* Don't add intrinsic assignments since they are already\n-\t     effected by the intrinsic assignment of the structure.  */\n-\t  gfc_free_statements (this_code);\n-\t  this_code = NULL;\n-\t  continue;\n+\t     effected by the intrinsic assignment of the structure, unless\n+\t     finalization is required.  */\n+\t  if (finalizable_comp)\n+\t    this_code->expr1->must_finalize = 1;\n+\t  else\n+\t    {\n+\t      gfc_free_statements (this_code);\n+\t      this_code = NULL;\n+\t      continue;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Resolution has expanded an assignment of a derived type with\n+\t     defined assigned components.  Remove the redundant, leading\n+\t     assignment.  */\n+\t  gcc_assert (this_code->op == EXEC_ASSIGN);\n+\t  gfc_code *tmp = this_code;\n+\t  this_code = this_code->next;\n+\t  tmp->next = NULL;\n+\t  gfc_free_statements (tmp);\n \t}\n \n       add_code_to_chain (&this_code, &head, &tail);\n \n-      if (t1 && inout)\n+      if (t1 && (inout || finalizable_out))\n \t{\n \t  /* Transfer the value to the final result.  */\n \t  this_code = build_assignment (EXEC_ASSIGN,\n \t\t\t\t\t(*code)->expr1, t1,\n \t\t\t\t\tcomp1, comp2, (*code)->loc);\n+\t  this_code->expr1->must_finalize = 0;\n \t  add_code_to_chain (&this_code, &head, &tail);\n \t}\n     }\n@@ -11709,8 +11901,8 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n       tmp_head = tmp_tail = NULL;\n     }\n \n-  // If we did a pointer assignment - thus, we need to ensure that the LHS is\n-  // not accidentally deallocated. Hence, nullify t1.\n+  /* If we did a pointer assignment - thus, we need to ensure that the LHS is\n+     not accidentally deallocated. Hence, nullify t1.  */\n   if (t1 && (*code)->expr1->symtree->n.sym->attr.allocatable\n       && gfc_expr_attr ((*code)->expr1).allocatable)\n     {\n@@ -11731,6 +11923,18 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n       tail = block;\n     }\n \n+  component_assignment_level--;\n+\n+  /* Make an explicit final call for the function result.  */\n+  if (tmp_expr)\n+    generate_final_call (tmp_expr, &head, &tail);\n+\n+  if (tmp_code)\n+    {\n+      ns->code = head;\n+      return;\n+    }\n+\n   /* Now attach the remaining code chain to the input code.  Step on\n      to the end of the new code since resolution is complete.  */\n   gcc_assert ((*code)->op == EXEC_ASSIGN);\n@@ -11743,8 +11947,6 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n   if (head != tail)\n     free (head);\n   *code = tail;\n-\n-  component_assignment_level--;\n }\n \n \n@@ -12164,6 +12366,14 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t      && code->expr1->ts.u.derived\n \t      && code->expr1->ts.u.derived->attr.defined_assign_comp)\n \t    generate_component_assignments (&code, ns);\n+\t  else if (code->op == EXEC_ASSIGN)\n+\t    {\n+\t      if (gfc_may_be_finalized (code->expr1->ts))\n+\t\tcode->expr1->must_finalize = 1;\n+\t      if (code->expr2->expr_type == EXPR_ARRAY\n+\t\t  && gfc_may_be_finalized (code->expr2->ts))\n+\t\tcode->expr2->must_finalize = 1;\n+\t    }\n \n \t  break;\n \n@@ -13741,6 +13951,15 @@ gfc_resolve_finalizers (gfc_symbol* derived, bool *finalizable)\n \t}\n       arg = dummy_args->sym;\n \n+      if (arg->as && arg->as->type == AS_ASSUMED_RANK\n+\t  && ((list != derived->f2k_derived->finalizers) || list->next))\n+\t{\n+\t  gfc_error (\"FINAL procedure at %L with assumed rank argument must \"\n+\t\t     \"be the only finalizer with the same kind/type \"\n+\t\t     \"(F2018: C790)\", &list->where);\n+\t  goto error;\n+\t}\n+\n       /* This argument must be of our type.  */\n       if (arg->ts.type != BT_DERIVED || arg->ts.u.derived != derived)\n \t{\n@@ -13841,7 +14060,8 @@ gfc_resolve_finalizers (gfc_symbol* derived, bool *finalizable)\n   if (warn_surprising && derived->f2k_derived->finalizers && !seen_scalar)\n     gfc_warning (OPT_Wsurprising,\n \t\t \"Only array FINAL procedures declared for derived type %qs\"\n-\t\t \" defined at %L, suggest also scalar one\",\n+\t\t \" defined at %L, suggest also scalar one unless an assumed\"\n+\t\t \" rank finalizer has been declared\",\n \t\t derived->name, &derived->declared_at);\n \n   vtab = gfc_find_derived_vtab (derived);\n@@ -14573,7 +14793,6 @@ check_defined_assignments (gfc_symbol *derived)\n     {\n       if (!gfc_bt_struct (c->ts.type)\n \t  || c->attr.pointer\n-\t  || c->attr.allocatable\n \t  || c->attr.proc_pointer_comp\n \t  || c->attr.class_pointer\n \t  || c->attr.proc_pointer)\n@@ -14587,6 +14806,9 @@ check_defined_assignments (gfc_symbol *derived)\n \t  return;\n \t}\n \n+      if (c->attr.allocatable)\n+\tcontinue;\n+\n       check_defined_assignments (c->ts.u.derived);\n       if (c->ts.u.derived->attr.defined_assign_comp)\n \t{\n@@ -15261,7 +15483,7 @@ resolve_fl_derived (gfc_symbol *sym)\n       && sym->ns->proc_name\n       && sym->ns->proc_name->attr.flavor == FL_MODULE\n       && sym->attr.access != ACCESS_PRIVATE\n-      && !(sym->attr.use_assoc || sym->attr.vtype || sym->attr.pdt_template))\n+      && !(sym->attr.vtype || sym->attr.pdt_template))\n     {\n       gfc_symbol *vtab = gfc_find_derived_vtab (sym);\n       gfc_set_sym_referenced (vtab);\n@@ -16357,6 +16579,15 @@ resolve_symbol (gfc_symbol *sym)\n \n   if (sym->param_list)\n     resolve_pdt (sym);\n+\n+  if (!sym->attr.referenced\n+      && (sym->ts.type == BT_CLASS || sym->ts.type == BT_DERIVED))\n+    {\n+      gfc_expr *final_expr = gfc_lval_expr_from_sym (sym);\n+      if (gfc_is_finalizable (final_expr->ts.u.derived, NULL))\n+\tgfc_set_sym_referenced (sym);\n+      gfc_free_expr (final_expr);\n+    }\n }\n \n "}, {"sha": "7bc0e03dd0d2d2be7cb8d3bce8df03c807298509", "filename": "gcc/fortran/trans-array.cc", "status": "modified", "additions": 161, "deletions": 73, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Ftrans-array.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Ftrans-array.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.cc?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -994,9 +994,9 @@ gfc_get_array_span (tree desc, gfc_expr *expr)\n       if (tmp && TREE_CODE (tmp) == ARRAY_TYPE && TYPE_STRING_FLAG (tmp))\n \t{\n \t  gcc_assert (expr->ts.type == BT_CHARACTER);\n-\t  \n+\n \t  tmp = gfc_get_character_len_in_bytes (tmp);\n-\t  \n+\n \t  if (tmp == NULL_TREE || integer_zerop (tmp))\n \t    {\n \t      tree bs;\n@@ -1007,7 +1007,7 @@ gfc_get_array_span (tree desc, gfc_expr *expr)\n \t      tmp = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t\t     gfc_array_index_type, tmp, bs);\n \t    }\n-\t  \n+\n \t  tmp = (tmp && !integer_zerop (tmp))\n \t    ? (fold_convert (gfc_array_index_type, tmp)) : (NULL_TREE);\n \t}\n@@ -2026,10 +2026,11 @@ gfc_trans_array_constructor_subarray (stmtblock_t * pblock,\n    for the dynamic parts must be allocated using realloc.  */\n \n static void\n-gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n-\t\t\t\t   tree desc, gfc_constructor_base base,\n-\t\t\t\t   tree * poffset, tree * offsetvar,\n-\t\t\t\t   bool dynamic)\n+gfc_trans_array_constructor_value (stmtblock_t * pblock,\n+\t\t\t\t   stmtblock_t * finalblock,\n+\t\t\t\t   tree type, tree desc,\n+\t\t\t\t   gfc_constructor_base base, tree * poffset,\n+\t\t\t\t   tree * offsetvar, bool dynamic)\n {\n   tree tmp;\n   tree start = NULL_TREE;\n@@ -2039,13 +2040,16 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n   gfc_se se;\n   mpz_t size;\n   gfc_constructor *c;\n+  gfc_typespec ts;\n+  int ctr = 0;\n \n   tree shadow_loopvar = NULL_TREE;\n   gfc_saved_var saved_loopvar;\n \n   mpz_init (size);\n   for (c = gfc_constructor_first (base); c; c = gfc_constructor_next (c))\n     {\n+      ctr++;\n       /* If this is an iterator or an array, the offset must be a variable.  */\n       if ((c->iterator || c->expr->rank > 0) && INTEGER_CST_P (*poffset))\n \tgfc_put_offset_into_var (pblock, poffset, offsetvar);\n@@ -2091,8 +2095,8 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n       if (c->expr->expr_type == EXPR_ARRAY)\n \t{\n \t  /* Array constructors can be nested.  */\n-\t  gfc_trans_array_constructor_value (&body, type, desc,\n-\t\t\t\t\t     c->expr->value.constructor,\n+\t  gfc_trans_array_constructor_value (&body, finalblock, type,\n+\t\t\t\t\t     desc, c->expr->value.constructor,\n \t\t\t\t\t     poffset, offsetvar, dynamic);\n \t}\n       else if (c->expr->rank > 0)\n@@ -2200,6 +2204,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n               gfc_add_modify (&body, *offsetvar, *poffset);\n               *poffset = *offsetvar;\n             }\n+\t  ts = c->expr->ts;\n \t}\n \n       /* The frontend should already have done any expansions\n@@ -2292,6 +2297,34 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  gfc_restore_sym (c->iterator->var->symtree->n.sym, &saved_loopvar);\n \t}\n     }\n+\n+  /* F2008 4.5.6.3 para 5: If an executable construct references a structure\n+     constructor or array constructor, the entity created by the constructor is\n+     finalized after execution of the innermost executable construct containing\n+     the reference. This, in fact, was later deleted by the Combined Techical\n+     Corrigenda 1 TO 4 for fortran 2008 (f08/0011).\n+\n+     Transmit finalization of this constructor through 'finalblock'. */\n+  if (!gfc_notification_std (GFC_STD_F2018_DEL) && finalblock != NULL\n+      && gfc_may_be_finalized (ts)\n+      && ctr > 0 && desc != NULL_TREE\n+      && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))\n+    {\n+      symbol_attribute attr;\n+      gfc_se fse;\n+      gfc_warning (0, \"The structure constructor at %C has been\"\n+\t\t\t \" finalized. This feature was removed by f08/0011.\"\n+\t\t\t \" Use -std=f2018 or -std=gnu to eliminate the\"\n+\t\t\t \" finalization.\");\n+      attr.pointer = attr.allocatable = 0;\n+      gfc_init_se (&fse, NULL);\n+      fse.expr = desc;\n+      gfc_finalize_tree_expr (&fse, ts.u.derived, attr, 1);\n+      gfc_add_block_to_block (finalblock, &fse.pre);\n+      gfc_add_block_to_block (finalblock, &fse.finalblock);\n+      gfc_add_block_to_block (finalblock, &fse.post);\n+    }\n+\n   mpz_clear (size);\n }\n \n@@ -2738,6 +2771,7 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n   gfc_ss *s;\n   tree neg_len;\n   char *msg;\n+  stmtblock_t finalblock;\n \n   /* Save the old values for nested checking.  */\n   old_first_len = first_len;\n@@ -2897,8 +2931,12 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n   offsetvar = gfc_create_var_np (gfc_array_index_type, \"offset\");\n   suppress_warning (offsetvar);\n   TREE_USED (offsetvar) = 0;\n-  gfc_trans_array_constructor_value (&outer_loop->pre, type, desc, c,\n-\t\t\t\t     &offset, &offsetvar, dynamic);\n+\n+  gfc_init_block (&finalblock);\n+  gfc_trans_array_constructor_value (&outer_loop->pre,\n+\t\t\t\t     expr->must_finalize ? &finalblock : NULL,\n+\t\t\t\t     type, desc, c, &offset, &offsetvar,\n+\t\t\t\t     dynamic);\n \n   /* If the array grows dynamically, the upper bound of the loop variable\n      is determined by the array's final upper bound.  */\n@@ -2933,6 +2971,15 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n   first_len = old_first_len;\n   first_len_val = old_first_len_val;\n   typespec_chararray_ctor = old_typespec_chararray_ctor;\n+\n+  /* F2008 4.5.6.3 para 5: If an executable construct references a structure\n+     constructor or array constructor, the entity created by the constructor is\n+     finalized after execution of the innermost executable construct containing\n+     the reference.  */\n+  if ((expr->ts.type == BT_DERIVED || expr->ts.type == BT_CLASS)\n+       && finalblock.head != NULL_TREE)\n+    gfc_add_block_to_block (&loop->post, &finalblock);\n+\n }\n \n \n@@ -3161,6 +3208,7 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t  gfc_conv_expr (&se, expr);\n \t  gfc_add_block_to_block (&outer_loop->pre, &se.pre);\n \t  gfc_add_block_to_block (&outer_loop->post, &se.post);\n+\t  gfc_add_block_to_block (&outer_loop->post, &se.finalblock);\n \t  ss_info->string_length = se.string_length;\n \t  break;\n \n@@ -6454,23 +6502,29 @@ gfc_trans_array_cobounds (tree type, stmtblock_t * pblock,\n \n   for (dim = as->rank; dim < as->rank + as->corank; dim++)\n     {\n-      /* Evaluate non-constant array bound expressions.  */\n+      /* Evaluate non-constant array bound expressions.\n+\t F2008 4.5.6.3 para 6: If a specification expression in a scoping unit\n+\t references a function, the result is finalized before execution of the\n+\t executable constructs in the scoping unit.\n+\t Adding the finalblocks enables this.  */\n       lbound = GFC_TYPE_ARRAY_LBOUND (type, dim);\n       if (as->lower[dim] && !INTEGER_CST_P (lbound))\n-        {\n-          gfc_init_se (&se, NULL);\n-          gfc_conv_expr_type (&se, as->lower[dim], gfc_array_index_type);\n-          gfc_add_block_to_block (pblock, &se.pre);\n-          gfc_add_modify (pblock, lbound, se.expr);\n-        }\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr_type (&se, as->lower[dim], gfc_array_index_type);\n+\t  gfc_add_block_to_block (pblock, &se.pre);\n+\t  gfc_add_block_to_block (pblock, &se.finalblock);\n+\t  gfc_add_modify (pblock, lbound, se.expr);\n+\t}\n       ubound = GFC_TYPE_ARRAY_UBOUND (type, dim);\n       if (as->upper[dim] && !INTEGER_CST_P (ubound))\n-        {\n-          gfc_init_se (&se, NULL);\n-          gfc_conv_expr_type (&se, as->upper[dim], gfc_array_index_type);\n-          gfc_add_block_to_block (pblock, &se.pre);\n-          gfc_add_modify (pblock, ubound, se.expr);\n-        }\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr_type (&se, as->upper[dim], gfc_array_index_type);\n+\t  gfc_add_block_to_block (pblock, &se.pre);\n+\t  gfc_add_block_to_block (pblock, &se.finalblock);\n+\t  gfc_add_modify (pblock, ubound, se.expr);\n+\t}\n     }\n }\n \n@@ -6499,23 +6553,29 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n   offset = gfc_index_zero_node;\n   for (dim = 0; dim < as->rank; dim++)\n     {\n-      /* Evaluate non-constant array bound expressions.  */\n+      /* Evaluate non-constant array bound expressions.\n+\t F2008 4.5.6.3 para 6: If a specification expression in a scoping unit\n+\t references a function, the result is finalized before execution of the\n+\t executable constructs in the scoping unit.\n+\t Adding the finalblocks enables this.  */\n       lbound = GFC_TYPE_ARRAY_LBOUND (type, dim);\n       if (as->lower[dim] && !INTEGER_CST_P (lbound))\n-        {\n-          gfc_init_se (&se, NULL);\n-          gfc_conv_expr_type (&se, as->lower[dim], gfc_array_index_type);\n-          gfc_add_block_to_block (pblock, &se.pre);\n-          gfc_add_modify (pblock, lbound, se.expr);\n-        }\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr_type (&se, as->lower[dim], gfc_array_index_type);\n+\t  gfc_add_block_to_block (pblock, &se.pre);\n+\t  gfc_add_block_to_block (pblock, &se.finalblock);\n+\t  gfc_add_modify (pblock, lbound, se.expr);\n+\t}\n       ubound = GFC_TYPE_ARRAY_UBOUND (type, dim);\n       if (as->upper[dim] && !INTEGER_CST_P (ubound))\n-        {\n-          gfc_init_se (&se, NULL);\n-          gfc_conv_expr_type (&se, as->upper[dim], gfc_array_index_type);\n-          gfc_add_block_to_block (pblock, &se.pre);\n-          gfc_add_modify (pblock, ubound, se.expr);\n-        }\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr_type (&se, as->upper[dim], gfc_array_index_type);\n+\t  gfc_add_block_to_block (pblock, &se.pre);\n+\t  gfc_add_block_to_block (pblock, &se.finalblock);\n+\t  gfc_add_modify (pblock, ubound, se.expr);\n+\t}\n       /* The offset of this dimension.  offset = offset - lbound * stride.  */\n       tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n \t\t\t     lbound, size);\n@@ -6529,19 +6589,19 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n \tstride = GFC_TYPE_ARRAY_SIZE (type);\n \n       if (ubound != NULL_TREE && !(stride && INTEGER_CST_P (stride)))\n-        {\n-          /* Calculate stride = size * (ubound + 1 - lbound).  */\n-          tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t{\n+\t  /* Calculate stride = size * (ubound + 1 - lbound).  */\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n \t\t\t\t gfc_array_index_type,\n \t\t\t\t gfc_index_one_node, lbound);\n-          tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t\t gfc_array_index_type, ubound, tmp);\n-          tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t  tmp = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t\t gfc_array_index_type, size, tmp);\n-          if (stride)\n-            gfc_add_modify (pblock, stride, tmp);\n-          else\n-            stride = gfc_evaluate_now (tmp, pblock);\n+\t  if (stride)\n+\t    gfc_add_modify (pblock, stride, tmp);\n+\t  else\n+\t    stride = gfc_evaluate_now (tmp, pblock);\n \n \t  /* Make sure that negative size arrays are translated\n \t     to being zero size.  */\n@@ -6551,7 +6611,7 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n \t\t\t\t gfc_array_index_type, tmp,\n \t\t\t\t stride, gfc_index_zero_node);\n \t  gfc_add_modify (pblock, stride, tmp);\n-        }\n+\t}\n \n       size = stride;\n     }\n@@ -7531,7 +7591,7 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \n   if (!se->direct_byref)\n     se->unlimited_polymorphic = UNLIMITED_POLY (expr);\n-  \n+\n   /* Special case things we know we can pass easily.  */\n   switch (expr->expr_type)\n     {\n@@ -8973,9 +9033,10 @@ enum {DEALLOCATE_ALLOC_COMP = 1, NULLIFY_ALLOC_COMP,\n static gfc_actual_arglist *pdt_param_list;\n \n static tree\n-structure_alloc_comps (gfc_symbol * der_type, tree decl,\n-\t\t       tree dest, int rank, int purpose, int caf_mode,\n-\t\t       gfc_co_subroutines_args *args)\n+structure_alloc_comps (gfc_symbol * der_type, tree decl, tree dest,\n+\t\t       int rank, int purpose, int caf_mode,\n+\t\t       gfc_co_subroutines_args *args,\n+\t\t       bool no_finalization = false)\n {\n   gfc_component *c;\n   gfc_loopinfo loop;\n@@ -9063,11 +9124,12 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t\t     gfc_conv_array_data (dest));\n \t  dref = gfc_build_array_ref (tmp, index, NULL);\n \t  tmp = structure_alloc_comps (der_type, vref, dref, rank,\n-\t\t\t\t       COPY_ALLOC_COMP, caf_mode, args);\n+\t\t\t\t       COPY_ALLOC_COMP, caf_mode, args,\n+\t\t\t\t       no_finalization);\n \t}\n       else\n \ttmp = structure_alloc_comps (der_type, vref, NULL_TREE, rank, purpose,\n-\t\t\t\t     caf_mode, args);\n+\t\t\t\t     caf_mode, args, no_finalization);\n \n       gfc_add_expr_to_block (&loopbody, tmp);\n \n@@ -9101,13 +9163,15 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n   if (purpose == DEALLOCATE_ALLOC_COMP && der_type->attr.pdt_type)\n     {\n       tmp = structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n-\t\t\t\t   DEALLOCATE_PDT_COMP, 0, args);\n+\t\t\t\t   DEALLOCATE_PDT_COMP, 0, args,\n+\t\t\t\t   no_finalization);\n       gfc_add_expr_to_block (&fnblock, tmp);\n     }\n   else if (purpose == ALLOCATE_PDT_COMP && der_type->attr.alloc_comp)\n     {\n       tmp = structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n-\t\t\t\t   NULLIFY_ALLOC_COMP, 0, args);\n+\t\t\t\t   NULLIFY_ALLOC_COMP, 0, args,\n+\t\t\t\t   no_finalization);\n       gfc_add_expr_to_block (&fnblock, tmp);\n     }\n \n@@ -9169,15 +9233,16 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t  add_when_allocated\n \t\t      = structure_alloc_comps (CLASS_DATA (c)->ts.u.derived,\n \t\t\t\t\t       comp, NULL_TREE, rank, purpose,\n-\t\t\t\t\t       caf_mode, args);\n+\t\t\t\t\t       caf_mode, args, no_finalization);\n \t\t}\n \t      else\n \t\t{\n \t\t  rank = c->as ? c->as->rank : 0;\n \t\t  add_when_allocated = structure_alloc_comps (c->ts.u.derived,\n \t\t\t\t\t\t\t      comp, NULL_TREE,\n \t\t\t\t\t\t\t      rank, purpose,\n-\t\t\t\t\t\t\t      caf_mode, args);\n+\t\t\t\t\t\t\t      caf_mode, args,\n+\t\t\t\t\t\t\t      no_finalization);\n \t\t}\n \t    }\n \n@@ -9293,8 +9358,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\tcontinue;\n \t    }\n \n-\t  if ((c->ts.type == BT_DERIVED && !c->attr.pointer)\n-\t     || (c->ts.type == BT_CLASS && !CLASS_DATA (c)->attr.class_pointer))\n+\t  if (!no_finalization && ((c->ts.type == BT_DERIVED && !c->attr.pointer)\n+\t     || (c->ts.type == BT_CLASS && !CLASS_DATA (c)->attr.class_pointer)))\n \t    /* Call the finalizer, which will free the memory and nullify the\n \t       pointer of an array.  */\n \t    deallocate_called = gfc_add_comp_finalizer_call (&tmpblock, comp, c,\n@@ -9322,15 +9387,16 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t  add_when_allocated\n \t\t      = structure_alloc_comps (CLASS_DATA (c)->ts.u.derived,\n \t\t\t\t\t       comp, NULL_TREE, rank, purpose,\n-\t\t\t\t\t       caf_mode, args);\n+\t\t\t\t\t       caf_mode, args, no_finalization);\n \t\t}\n \t      else\n \t\t{\n \t\t  rank = c->as ? c->as->rank : 0;\n \t\t  add_when_allocated = structure_alloc_comps (c->ts.u.derived,\n \t\t\t\t\t\t\t      comp, NULL_TREE,\n \t\t\t\t\t\t\t      rank, purpose,\n-\t\t\t\t\t\t\t      caf_mode, args);\n+\t\t\t\t\t\t\t      caf_mode, args,\n+\t\t\t\t\t\t\t      no_finalization);\n \t\t}\n \t    }\n \n@@ -9628,7 +9694,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t      decl, cdecl, NULL_TREE);\n \t      rank = c->as ? c->as->rank : 0;\n \t      tmp = structure_alloc_comps (c->ts.u.derived, comp, NULL_TREE,\n-\t\t\t\t\t   rank, purpose, caf_mode, args);\n+\t\t\t\t\t   rank, purpose, caf_mode, args,\n+\t\t\t\t\t   no_finalization);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \t  break;\n@@ -9664,7 +9731,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t  tmp = structure_alloc_comps (c->ts.u.derived, comp, dcmp,\n \t\t\t\t\t       rank, purpose, caf_mode\n \t\t\t\t\t       | GFC_STRUCTURE_CAF_MODE_IN_COARRAY,\n-\t\t\t\t\t       args);\n+\t\t\t\t\t       args, no_finalization);\n \t\t  gfc_add_expr_to_block (&fnblock, tmp);\n \t\t}\n \t    }\n@@ -9772,7 +9839,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      add_when_allocated = structure_alloc_comps (c->ts.u.derived,\n \t\t\t\t\t\t\t  comp, dcmp,\n \t\t\t\t\t\t\t  rank, purpose,\n-\t\t\t\t\t\t\t  caf_mode, args);\n+\t\t\t\t\t\t\t  caf_mode, args,\n+\t\t\t\t\t\t\t  no_finalization);\n \t    }\n \t  else\n \t    add_when_allocated = NULL_TREE;\n@@ -10145,7 +10213,8 @@ gfc_nullify_alloc_comp (gfc_symbol * der_type, tree decl, int rank,\n {\n   return structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n \t\t\t\tNULLIFY_ALLOC_COMP,\n-\t\t\t\tGFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY | caf_mode, NULL);\n+\t\t\t\tGFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY | caf_mode,\n+\t\t\t\tNULL);\n }\n \n \n@@ -10158,7 +10227,8 @@ gfc_deallocate_alloc_comp (gfc_symbol * der_type, tree decl, int rank,\n {\n   return structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n \t\t\t\tDEALLOCATE_ALLOC_COMP,\n-\t\t\t\tGFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY | caf_mode, NULL);\n+\t\t\t\tGFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY | caf_mode,\n+\t\t\t\tNULL);\n }\n \n tree\n@@ -10196,7 +10266,8 @@ gfc_bcast_alloc_comp (gfc_symbol *derived, gfc_expr *expr, int rank,\n \n   tmp = structure_alloc_comps (derived, array, NULL_TREE, rank,\n \t\t\t       BCAST_ALLOC_COMP,\n-  \t\t\t       GFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY, &args);\n+\t\t\t       GFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY,\n+\t\t\t       &args);\n   return tmp;\n }\n \n@@ -10206,18 +10277,21 @@ gfc_bcast_alloc_comp (gfc_symbol *derived, gfc_expr *expr, int rank,\n    status of coarrays.  */\n \n tree\n-gfc_deallocate_alloc_comp_no_caf (gfc_symbol * der_type, tree decl, int rank)\n+gfc_deallocate_alloc_comp_no_caf (gfc_symbol * der_type, tree decl, int rank,\n+\t\t\t\t  bool no_finalization)\n {\n   return structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n-\t\t\t\tDEALLOCATE_ALLOC_COMP, 0, NULL);\n+\t\t\t\tDEALLOCATE_ALLOC_COMP, 0, NULL,\n+\t\t\t\tno_finalization);\n }\n \n \n tree\n gfc_reassign_alloc_comp_caf (gfc_symbol *der_type, tree decl, tree dest)\n {\n   return structure_alloc_comps (der_type, decl, dest, 0, REASSIGN_CAF_COMP,\n-\t\t\t\tGFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY, NULL);\n+\t\t\t\tGFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY,\n+\t\t\t\tNULL);\n }\n \n \n@@ -10233,6 +10307,20 @@ gfc_copy_alloc_comp (gfc_symbol * der_type, tree decl, tree dest, int rank,\n }\n \n \n+/* Recursively traverse an object of derived type, generating code to\n+   copy it and its allocatable components, while suppressing any\n+   finalization that might occur.  This is used in the finalization of\n+   function results.  */\n+\n+tree\n+gfc_copy_alloc_comp_no_fini (gfc_symbol * der_type, tree decl, tree dest,\n+\t\t\t     int rank, int caf_mode)\n+{\n+  return structure_alloc_comps (der_type, decl, dest, rank, COPY_ALLOC_COMP,\n+\t\t\t\tcaf_mode, NULL, true);\n+}\n+\n+\n /* Recursively traverse an object of derived type, generating code to\n    copy only its allocatable components.  */\n \n@@ -10972,7 +11060,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \t&& expr1->ts.u.derived->attr.alloc_comp)\n     {\n       tmp = gfc_deallocate_alloc_comp_no_caf (expr1->ts.u.derived, old_desc,\n-\t\t\t\t\t      expr1->rank);\n+\t\t\t\t\t      expr1->rank, true);\n       gfc_add_expr_to_block (&realloc_block, tmp);\n     }\n \n@@ -11145,8 +11233,7 @@ gfc_trans_deferred_array (gfc_symbol * sym, gfc_wrapped_block * block)\n   sym_has_alloc_comp = (sym->ts.type == BT_DERIVED\n \t\t\t|| sym->ts.type == BT_CLASS)\n \t\t\t  && sym->ts.u.derived->attr.alloc_comp;\n-  has_finalizer = sym->ts.type == BT_CLASS || sym->ts.type == BT_DERIVED\n-\t\t   ? gfc_is_finalizable (sym->ts.u.derived, NULL) : false;\n+  has_finalizer = gfc_may_be_finalized (sym->ts);\n \n   /* Make sure the frontend gets these right.  */\n   gcc_assert (sym->attr.pointer || sym->attr.allocatable || sym_has_alloc_comp\n@@ -11269,6 +11356,7 @@ gfc_trans_deferred_array (gfc_symbol * sym, gfc_wrapped_block * block)\n   else if ((!sym->attr.allocatable || !has_finalizer)\n       && sym_has_alloc_comp && !(sym->attr.function || sym->attr.result)\n       && !sym->attr.pointer && !sym->attr.save\n+      && !(sym->attr.artificial && sym->name[0] == '_')\n       && !sym->ns->proc_name->attr.is_main_program)\n     {\n       int rank;"}, {"sha": "5408755138ea2847802c5207a0ddacfe5fef0f60", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -56,11 +56,14 @@ tree gfc_nullify_alloc_comp (gfc_symbol *, tree, int, int cm = 0);\n tree gfc_deallocate_alloc_comp (gfc_symbol *, tree, int, int cm = 0);\n tree gfc_bcast_alloc_comp (gfc_symbol *, gfc_expr *, int, tree,\n \t\t\t   tree, tree, tree);\n-tree gfc_deallocate_alloc_comp_no_caf (gfc_symbol *, tree, int);\n+tree gfc_deallocate_alloc_comp_no_caf (gfc_symbol *, tree, int,\n+\t\t\t\t       bool no_finalization = false);\n tree gfc_reassign_alloc_comp_caf (gfc_symbol *, tree, tree);\n \n tree gfc_copy_alloc_comp (gfc_symbol *, tree, tree, int, int);\n \n+tree gfc_copy_alloc_comp_no_fini (gfc_symbol *, tree, tree, int, int);\n+\n tree gfc_copy_only_alloc_comp (gfc_symbol *, tree, tree, int);\n \n tree gfc_allocate_pdt_comp (gfc_symbol *, tree, int, gfc_actual_arglist *);"}, {"sha": "77610df340bdbb8047b7312b9a8cbdb81b866506", "filename": "gcc/fortran/trans-decl.cc", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Ftrans-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Ftrans-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.cc?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -4345,49 +4345,61 @@ init_intent_out_dt (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n   gfc_formal_arglist *f;\n   tree tmp;\n   tree present;\n+  gfc_symbol *s;\n+  bool dealloc_with_value = false;\n \n   gfc_init_block (&init);\n   for (f = gfc_sym_get_dummy_args (proc_sym); f; f = f->next)\n     if (f->sym && f->sym->attr.intent == INTENT_OUT\n \t&& !f->sym->attr.pointer\n \t&& f->sym->ts.type == BT_DERIVED)\n       {\n+\ts = f->sym;\n \ttmp = NULL_TREE;\n \n \t/* Note: Allocatables are excluded as they are already handled\n \t   by the caller.  */\n \tif (!f->sym->attr.allocatable\n-\t    && gfc_is_finalizable (f->sym->ts.u.derived, NULL))\n+\t    && gfc_is_finalizable (s->ts.u.derived, NULL))\n \t  {\n \t    stmtblock_t block;\n \t    gfc_expr *e;\n \n \t    gfc_init_block (&block);\n-\t    f->sym->attr.referenced = 1;\n-\t    e = gfc_lval_expr_from_sym (f->sym);\n+\t    s->attr.referenced = 1;\n+\t    e = gfc_lval_expr_from_sym (s);\n \t    gfc_add_finalizer_call (&block, e);\n \t    gfc_free_expr (e);\n \t    tmp = gfc_finish_block (&block);\n \t  }\n \n-\tif (tmp == NULL_TREE && !f->sym->attr.allocatable\n-\t    && f->sym->ts.u.derived->attr.alloc_comp && !f->sym->value)\n-\t  tmp = gfc_deallocate_alloc_comp (f->sym->ts.u.derived,\n-\t\t\t\t\t   f->sym->backend_decl,\n-\t\t\t\t\t   f->sym->as ? f->sym->as->rank : 0);\n+\t/* Note: Allocatables are excluded as they are already handled\n+\t   by the caller.  */\n+\tif (tmp == NULL_TREE && !s->attr.allocatable\n+\t    && s->ts.u.derived->attr.alloc_comp)\n+\t  {\n+\t    tmp = gfc_deallocate_alloc_comp (s->ts.u.derived,\n+\t\t\t\t\t     s->backend_decl,\n+\t\t\t\t\t     s->as ? s->as->rank : 0);\n+\t    dealloc_with_value = s->value;\n+\t  }\n \n-\tif (tmp != NULL_TREE && (f->sym->attr.optional\n-\t\t\t\t || f->sym->ns->proc_name->attr.entry_master))\n+\tif (tmp != NULL_TREE && (s->attr.optional\n+\t\t\t\t || s->ns->proc_name->attr.entry_master))\n \t  {\n-\t    present = gfc_conv_expr_present (f->sym);\n+\t    present = gfc_conv_expr_present (s);\n \t    tmp = build3_loc (input_location, COND_EXPR, TREE_TYPE (tmp),\n \t\t\t      present, tmp, build_empty_stmt (input_location));\n \t  }\n \n-\tif (tmp != NULL_TREE)\n+\tif (tmp != NULL_TREE && !dealloc_with_value)\n \t  gfc_add_expr_to_block (&init, tmp);\n-\telse if (f->sym->value && !f->sym->attr.allocatable)\n-\t  gfc_init_default_dt (f->sym, &init, true);\n+\telse if (s->value && !s->attr.allocatable)\n+\t  {\n+\t    gfc_add_expr_to_block (&init, tmp);\n+\t    gfc_init_default_dt (s, &init, false);\n+\t    dealloc_with_value = false;\n+\t  }\n       }\n     else if (f->sym && f->sym->attr.intent == INTENT_OUT\n \t     && f->sym->ts.type == BT_CLASS\n@@ -4411,10 +4423,8 @@ init_intent_out_dt (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t\t\t      present, tmp,\n \t\t\t      build_empty_stmt (input_location));\n \t  }\n-\n \tgfc_add_expr_to_block (&init, tmp);\n       }\n-\n   gfc_add_init_cleanup (block, gfc_finish_block (&init), NULL_TREE);\n }\n "}, {"sha": "d996d295bd2155bba30a3eb7bbef0fad805c9b77", "filename": "gcc/fortran/trans-expr.cc", "status": "modified", "additions": 185, "deletions": 74, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Ftrans-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Ftrans-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.cc?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -1911,6 +1911,7 @@ gfc_init_se (gfc_se * se, gfc_se * parent)\n {\n   memset (se, 0, sizeof (gfc_se));\n   gfc_init_block (&se->pre);\n+  gfc_init_block (&se->finalblock);\n   gfc_init_block (&se->post);\n \n   se->parent = parent;\n@@ -7074,6 +7075,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n       gfc_add_block_to_block (&se->pre, &parmse.pre);\n       gfc_add_block_to_block (&post, &parmse.post);\n+      gfc_add_block_to_block (&se->finalblock, &parmse.finalblock);\n \n       /* Allocated allocatable components of derived types must be\n \t deallocated for non-variable scalars, array arguments to elemental\n@@ -7440,6 +7442,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n       vec_safe_push (arglist, parmse.expr);\n     }\n+\n   gfc_add_block_to_block (&se->pre, &clobbers);\n   gfc_finish_interface_mapping (&mapping, &se->pre, &se->post);\n \n@@ -7738,9 +7741,20 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   /* Allocatable scalar function results must be freed and nullified\n      after use. This necessitates the creation of a temporary to\n      hold the result to prevent duplicate calls.  */\n+  symbol_attribute attr =  comp ? comp->attr : sym->attr;\n+  bool allocatable = attr.allocatable && !attr.dimension;\n+  gfc_symbol *der = comp ?\n+\t\t    comp->ts.type == BT_DERIVED ? comp->ts.u.derived : NULL\n+\t\t\t :\n+\t\t    sym->ts.type == BT_DERIVED ? sym->ts.u.derived : NULL;\n+  bool finalizable = der != NULL && der->ns->proc_name\n+\t\t\t    && gfc_is_finalizable (der, NULL);\n+\n+  if (!byref && finalizable)\n+    gfc_finalize_tree_expr (se, der, attr, expr->rank);\n+\n   if (!byref && sym->ts.type != BT_CHARACTER\n-      && ((sym->attr.allocatable && !sym->attr.dimension && !comp)\n-\t  || (comp && comp->attr.allocatable && !comp->attr.dimension)))\n+      && allocatable && !finalizable)\n     {\n       tmp = gfc_create_var (TREE_TYPE (se->expr), NULL);\n       gfc_add_modify (&se->pre, tmp, se->expr);\n@@ -7800,6 +7814,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      se->expr = info->descriptor;\n \t      /* Bundle in the string length.  */\n \t      se->string_length = len;\n+\n+\t      if (finalizable)\n+\t\tgfc_finalize_tree_expr (se, der, attr, expr->rank);\n \t    }\n \t  else if (ts.type == BT_CHARACTER)\n \t    {\n@@ -7892,8 +7909,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  && se->expr && GFC_CLASS_TYPE_P (TREE_TYPE (se->expr))\n \t  && expr->must_finalize)\n \t{\n-\t  tree final_fndecl;\n-\t  tree is_final;\n \t  int n;\n \t  if (se->ss && se->ss->loop)\n \t    {\n@@ -7915,66 +7930,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      /* TODO Eliminate the doubling of temporaries. This\n \t\t one is necessary to ensure no memory leakage.  */\n \t      se->expr = gfc_evaluate_now (se->expr, &se->pre);\n-\t      tmp = gfc_class_data_get (se->expr);\n-\t      tmp = gfc_conv_scalar_to_descriptor (se, tmp,\n-\t\t\tCLASS_DATA (expr->value.function.esym->result)->attr);\n \t    }\n \n-\t  if ((gfc_is_class_array_function (expr)\n-\t       || gfc_is_alloc_class_scalar_function (expr))\n-\t      && CLASS_DATA (expr->value.function.esym->result)->attr.pointer)\n-\t    goto no_finalization;\n-\n-\t  final_fndecl = gfc_class_vtab_final_get (se->expr);\n-\t  is_final = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t      logical_type_node,\n-\t\t\t\t      final_fndecl,\n-\t\t\t\t      fold_convert (TREE_TYPE (final_fndecl),\n-\t\t\t\t\t   \t    null_pointer_node));\n-\t  final_fndecl = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t      final_fndecl);\n- \t  tmp = build_call_expr_loc (input_location,\n-\t\t\t\t     final_fndecl, 3,\n-\t\t\t\t     gfc_build_addr_expr (NULL, tmp),\n-\t\t\t\t     gfc_class_vtab_size_get (se->expr),\n-\t\t\t\t     boolean_false_node);\n-\t  tmp = fold_build3_loc (input_location, COND_EXPR,\n-\t\t\t\t void_type_node, is_final, tmp,\n-\t\t\t\t build_empty_stmt (input_location));\n-\n-\t  if (se->ss && se->ss->loop)\n-\t    {\n-\t      gfc_prepend_expr_to_block (&se->ss->loop->post, tmp);\n-\t      tmp = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t     logical_type_node,\n-\t\t\t\t     info->data,\n-\t\t\t\t     fold_convert (TREE_TYPE (info->data),\n-\t\t\t\t\t   \t    null_pointer_node));\n-\t      tmp = fold_build3_loc (input_location, COND_EXPR,\n-\t\t\t\t     void_type_node, tmp,\n-\t\t\t\t     gfc_call_free (info->data),\n-\t\t\t\t     build_empty_stmt (input_location));\n-\t      gfc_add_expr_to_block (&se->ss->loop->post, tmp);\n-\t    }\n-\t  else\n-\t    {\n-\t      tree classdata;\n-\t      gfc_prepend_expr_to_block (&se->post, tmp);\n-\t      classdata = gfc_class_data_get (se->expr);\n-\t      tmp = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t     logical_type_node,\n-\t\t\t\t     classdata,\n-\t\t\t\t     fold_convert (TREE_TYPE (classdata),\n-\t\t\t\t\t   \t    null_pointer_node));\n-\t      tmp = fold_build3_loc (input_location, COND_EXPR,\n-\t\t\t\t     void_type_node, tmp,\n-\t\t\t\t     gfc_call_free (classdata),\n-\t\t\t\t     build_empty_stmt (input_location));\n-\t      gfc_add_expr_to_block (&se->post, tmp);\n-\t    }\n+\t  /* Finalize the result, if necessary.  */\n+\t  attr = CLASS_DATA (expr->value.function.esym->result)->attr;\n+\t  if (!((gfc_is_class_array_function (expr)\n+\t\t || gfc_is_alloc_class_scalar_function (expr))\n+\t\t&& attr.pointer))\n+\t    gfc_finalize_tree_expr (se, NULL, attr, expr->rank);\n \t}\n-\n-no_finalization:\n       gfc_add_block_to_block (&se->post, &post);\n     }\n \n@@ -9486,10 +9450,29 @@ gfc_conv_expr (gfc_se * se, gfc_expr * expr)\n \n     case EXPR_STRUCTURE:\n       gfc_conv_structure (se, expr, 0);\n+      /* F2008 4.5.6.3 para 5: If an executable construct references a\n+\t structure constructor or array constructor, the entity created by\n+\t the constructor is finalized after execution of the innermost\n+\t executable construct containing the reference. This, in fact,\n+\t was later deleted by the Combined Techical Corrigenda 1 TO 4 for\n+\t fortran 2008 (f08/0011).  */\n+      if (!gfc_notification_std (GFC_STD_F2018_DEL) && expr->must_finalize\n+\t  && gfc_may_be_finalized (expr->ts))\n+\t{\n+\t  gfc_warning (0, \"The structure constructor at %C has been\"\n+\t\t\t \" finalized. This feature was removed by f08/0011.\"\n+\t\t\t \" Use -std=f2018 or -std=gnu to eliminate the\"\n+\t\t\t \" finalization.\");\n+\t  symbol_attribute attr;\n+\t  attr.allocatable = attr.pointer = 0;\n+\t  gfc_finalize_tree_expr (se, expr->ts.u.derived, attr, 0);\n+\t  gfc_add_block_to_block (&se->post, &se->finalblock);\n+\t}\n       break;\n \n     case EXPR_ARRAY:\n       gfc_conv_array_constructor_expr (se, expr);\n+      gfc_add_block_to_block (&se->post, &se->finalblock);\n       break;\n \n     default:\n@@ -10490,14 +10473,16 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n       if (dealloc)\n \t{\n \t  tmp_var = gfc_evaluate_now (lse->expr, &lse->pre);\n-\t  tmp = gfc_deallocate_alloc_comp_no_caf (ts.u.derived, tmp_var, 0);\n+\t  tmp = gfc_deallocate_alloc_comp_no_caf (ts.u.derived, tmp_var,\n+\t\t\t\t\t\t  0, true);\n \t  if (deep_copy)\n \t    tmp = build3_v (COND_EXPR, cond, build_empty_stmt (input_location),\n \t\t\t    tmp);\n \t  gfc_add_expr_to_block (&lse->post, tmp);\n \t}\n \n       gfc_add_block_to_block (&block, &rse->pre);\n+      gfc_add_block_to_block (&block, &lse->finalblock);\n       gfc_add_block_to_block (&block, &lse->pre);\n \n       gfc_add_modify (&block, lse->expr,\n@@ -10527,8 +10512,9 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n     }\n   else if (gfc_bt_struct (ts.type))\n     {\n-      gfc_add_block_to_block (&block, &lse->pre);\n       gfc_add_block_to_block (&block, &rse->pre);\n+      gfc_add_block_to_block (&block, &lse->finalblock);\n+      gfc_add_block_to_block (&block, &lse->pre);\n       tmp = fold_build1_loc (input_location, VIEW_CONVERT_EXPR,\n \t\t\t     TREE_TYPE (lse->expr), rse->expr);\n       gfc_add_modify (&block, lse->expr, tmp);\n@@ -10538,6 +10524,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n     {\n       gfc_add_block_to_block (&block, &lse->pre);\n       gfc_add_block_to_block (&block, &rse->pre);\n+      gfc_add_block_to_block (&block, &lse->finalblock);\n \n       if (!trans_scalar_class_assign (&block, lse, rse))\n \t{\n@@ -10868,6 +10855,11 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n   gfc_ss *ss = NULL;\n   gfc_component *comp = NULL;\n   gfc_loopinfo loop;\n+  tree tmp;\n+  tree lhs;\n+  gfc_se final_se;\n+  gfc_symbol *sym = expr1->symtree->n.sym;\n+  bool finalizable =  gfc_may_be_finalized (expr1->ts);\n \n   if (arrayfunc_assign_needs_temporary (expr1, expr2))\n     return NULL;\n@@ -10886,12 +10878,44 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n   gfc_start_block (&se.pre);\n   se.want_pointer = 1;\n \n+  /* First the lhs must be finalized, if necessary. We use a copy of the symbol\n+     backend decl, stash the original away for the finalization so that the\n+     value used is that before the assignment. This is necessary because\n+     evaluation of the rhs expression using direct by reference can change\n+     the value. However, the standard mandates that the finalization must occur\n+     after evaluation of the rhs.  */\n+  gfc_init_se (&final_se, NULL);\n+\n+  if (finalizable)\n+    {\n+      tmp = sym->backend_decl;\n+      lhs = sym->backend_decl;\n+      if (TREE_CODE (tmp) == INDIRECT_REF)\n+\ttmp = TREE_OPERAND (tmp, 0);\n+      sym->backend_decl = gfc_create_var (TREE_TYPE (tmp), \"lhs\");\n+      gfc_add_modify (&se.pre, sym->backend_decl, tmp);\n+      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))\n+\t{\n+\t  tmp = gfc_copy_alloc_comp (expr1->ts.u.derived, tmp, sym->backend_decl,\n+\t\t\t\t     expr1->rank, 0);\n+\t  gfc_add_expr_to_block (&final_se.pre, tmp);\n+\t}\n+    }\n+\n+  if (finalizable && gfc_assignment_finalizer_call (&final_se, expr1, false))\n+    {\n+      gfc_add_block_to_block (&se.pre, &final_se.pre);\n+      gfc_add_block_to_block (&se.post, &final_se.finalblock);\n+    }\n+\n+  if (finalizable)\n+    sym->backend_decl = lhs;\n+\n   gfc_conv_array_parameter (&se, expr1, false, NULL, NULL, NULL);\n \n   if (expr1->ts.type == BT_DERIVED\n \t&& expr1->ts.u.derived->attr.alloc_comp)\n     {\n-      tree tmp;\n       tmp = gfc_deallocate_alloc_comp_no_caf (expr1->ts.u.derived, se.expr,\n \t\t\t\t\t      expr1->rank);\n       gfc_add_expr_to_block (&se.pre, tmp);\n@@ -10901,6 +10925,18 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n   se.ss = gfc_walk_expr (expr2);\n   gcc_assert (se.ss != gfc_ss_terminator);\n \n+  /* Since this is a direct by reference call, references to the lhs can be\n+     used for finalization of the function result just as long as the blocks\n+     from final_se are added at the right time.  */\n+  gfc_init_se (&final_se, NULL);\n+  if (finalizable && expr2->value.function.esym)\n+    {\n+      final_se.expr = build_fold_indirect_ref_loc (input_location, se.expr);\n+      gfc_finalize_tree_expr (&final_se, expr2->ts.u.derived,\n+\t\t\t\t    expr2->value.function.esym->attr,\n+\t\t\t\t    expr2->rank);\n+    }\n+\n   /* Reallocate on assignment needs the loopinfo for extrinsic functions.\n      This is signalled to gfc_conv_procedure_call by setting is_alloc_lhs.\n      Clearly, this cannot be done for an allocatable function result, since\n@@ -10931,7 +10967,19 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n     }\n \n   gfc_conv_function_expr (&se, expr2);\n+\n+  /* Fix the result.  */\n   gfc_add_block_to_block (&se.pre, &se.post);\n+  if (finalizable)\n+    gfc_add_block_to_block (&se.pre, &final_se.pre);\n+\n+  /* Do the finalization, including final calls from function arguments.  */\n+  if (finalizable)\n+    {\n+      gfc_add_block_to_block (&se.pre, &final_se.post);\n+      gfc_add_block_to_block (&se.pre, &se.finalblock);\n+      gfc_add_block_to_block (&se.pre, &final_se.finalblock);\n+   }\n \n   if (ss)\n     gfc_cleanup_loop (&loop);\n@@ -11454,6 +11502,17 @@ trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,\n {\n   tree tmp, fcn, stdcopy, to_len, from_len, vptr, old_vptr;\n   vec<tree, va_gc> *args = NULL;\n+  bool final_expr;\n+\n+  final_expr = gfc_assignment_finalizer_call (lse, lhs, false);\n+  if (final_expr)\n+    {\n+      if (rse->loop)\n+\tgfc_prepend_expr_to_block (&rse->loop->pre,\n+\t\t\t\t   gfc_finish_block (&lse->finalblock));\n+      else\n+\tgfc_add_block_to_block (block, &lse->finalblock);\n+    }\n \n   /* Store the old vptr so that dynamic types can be compared for\n      reallocation to occur or not.  */\n@@ -11479,8 +11538,9 @@ trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,\n \told_vptr = build_int_cst (TREE_TYPE (vptr), 0);\n \n       size = gfc_vptr_size_get (vptr);\n-      class_han = GFC_CLASS_TYPE_P (TREE_TYPE (lse->expr))\n-\t  ? gfc_class_data_get (lse->expr) : lse->expr;\n+      tmp = lse->expr;\n+      class_han = GFC_CLASS_TYPE_P (TREE_TYPE (tmp))\n+\t  ? gfc_class_data_get (tmp) : tmp;\n \n       if (!POINTER_TYPE_P (TREE_TYPE (class_han)))\n \tclass_han = gfc_build_addr_expr (NULL_TREE, class_han);\n@@ -11501,6 +11561,10 @@ trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,\n \t\t\t    tmp, re, build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&re_alloc, re);\n \n+      tree realloc_expr = lhs->ts.type == BT_CLASS ?\n+\t\t\t\t\t  gfc_finish_block (&re_alloc) :\n+\t\t\t\t\t  build_empty_stmt (input_location);\n+\n       /* Allocate if _data is NULL, reallocate otherwise.  */\n       tmp = fold_build2_loc (input_location, EQ_EXPR,\n \t\t\t     logical_type_node, class_han,\n@@ -11509,7 +11573,7 @@ trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,\n \t\t\t     gfc_unlikely (tmp,\n \t\t\t\t\t   PRED_FORTRAN_FAIL_ALLOC),\n \t\t\t     gfc_finish_block (&alloc),\n-\t\t\t     gfc_finish_block (&re_alloc));\n+\t\t\t     realloc_expr);\n       gfc_add_expr_to_block (&lse->pre, tmp);\n     }\n \n@@ -11582,6 +11646,7 @@ trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,\n     }\n }\n \n+\n /* Subroutine of gfc_trans_assignment that actually scalarizes the\n    assignment.  EXPR1 is the destination/LHS and EXPR2 is the source/RHS.\n    init_flag indicates initialization expressions and dealloc that no\n@@ -11605,6 +11670,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n   tree tmp;\n   stmtblock_t block;\n   stmtblock_t body;\n+  bool final_expr;\n   bool l_is_temp;\n   bool scalar_to_array;\n   tree string_length;\n@@ -11636,15 +11702,29 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \n   rss = NULL;\n \n-  if ((expr1->ts.type == BT_DERIVED)\n-      && (gfc_is_class_array_function (expr2)\n-\t  || gfc_is_alloc_class_scalar_function (expr2)))\n-    expr2->must_finalize = 1;\n+  if (expr2->expr_type != EXPR_VARIABLE\n+      && expr2->expr_type != EXPR_CONSTANT\n+      && (expr2->ts.type == BT_CLASS || gfc_may_be_finalized (expr2->ts)))\n+    {\n+      expr2->must_finalize = 1;\n+      /* F2008 4.5.6.3 para 5: If an executable construct references a\n+\t structure constructor or array constructor, the entity created by\n+\t the constructor is finalized after execution of the innermost\n+\t executable construct containing the reference.\n+\t These finalizations were later deleted by the Combined Techical\n+\t Corrigenda 1 TO 4 for fortran 2008 (f08/0011).  */\n+      if (gfc_notification_std (GFC_STD_F2018_DEL)\n+\t  && (expr2->expr_type == EXPR_STRUCTURE\n+\t      || expr2->expr_type == EXPR_ARRAY))\n+\texpr2->must_finalize = 0;\n+    }\n+\n \n   /* Checking whether a class assignment is desired is quite complicated and\n      needed at two locations, so do it once only before the information is\n      needed.  */\n   lhs_attr = gfc_expr_attr (expr1);\n+\n   is_poly_assign = (use_vptr_copy || lhs_attr.pointer\n \t\t    || (lhs_attr.allocatable && !lhs_attr.dimension))\n \t\t   && (expr1->ts.type == BT_CLASS\n@@ -11918,6 +11998,8 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t  else\n \t    gfc_add_expr_to_block (&loop.post, tmp2);\n \t}\n+\n+      expr1->must_finalize = 0;\n     }\n   else if (flag_coarray == GFC_FCOARRAY_LIB\n \t   && lhs_caf_attr.codimension && rhs_caf_attr.codimension\n@@ -11963,6 +12045,27 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t}\n     }\n \n+  /* Comply with F2018 (7.5.6.3). Make sure that any finalization code is added\n+     after evaluation of the rhs and before reallocation.  */\n+  final_expr = gfc_assignment_finalizer_call (&lse, expr1, init_flag);\n+  if (final_expr && !(expr2->expr_type == EXPR_VARIABLE\n+\t\t      && expr2->symtree->n.sym->attr.artificial))\n+    {\n+      if (lss == gfc_ss_terminator)\n+\t{\n+\t  gfc_add_block_to_block (&block, &rse.pre);\n+\t  gfc_add_block_to_block (&block, &lse.finalblock);\n+\t}\n+      else\n+\t{\n+\t  gfc_add_block_to_block (&body, &rse.pre);\n+\t  gfc_add_block_to_block (&loop.code[expr1->rank - 1],\n+\t\t\t\t  &lse.finalblock);\n+\t}\n+    }\n+  else\n+    gfc_add_block_to_block (&body, &rse.pre);\n+\n   /* If nothing else works, do it the old fashioned way!  */\n   if (tmp == NULL_TREE)\n     tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts,\n@@ -11972,12 +12075,20 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t\t\t\t   !(l_is_temp || init_flag) && dealloc,\n \t\t\t\t   expr1->symtree->n.sym->attr.codimension);\n \n-  /* Add the pre blocks to the body.  */\n-  gfc_add_block_to_block (&body, &rse.pre);\n+\n+  /* Add the lse pre block to the body  */\n   gfc_add_block_to_block (&body, &lse.pre);\n   gfc_add_expr_to_block (&body, tmp);\n+\n   /* Add the post blocks to the body.  */\n-  gfc_add_block_to_block (&body, &rse.post);\n+  if (!l_is_temp)\n+    {\n+      gfc_add_block_to_block (&rse.finalblock, &rse.post);\n+      gfc_add_block_to_block (&body, &rse.finalblock);\n+    }\n+  else\n+    gfc_add_block_to_block (&body, &rse.post);\n+\n   gfc_add_block_to_block (&body, &lse.post);\n \n   if (lss == gfc_ss_terminator)"}, {"sha": "baeea955d358603fc41381ac6df676292725b04e", "filename": "gcc/fortran/trans-io.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Ftrans-io.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Ftrans-io.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.cc?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -2690,6 +2690,7 @@ gfc_trans_transfer (gfc_code * code)\n \n   gfc_add_block_to_block (&body, &se.pre);\n   gfc_add_block_to_block (&body, &se.post);\n+  gfc_add_block_to_block (&body, &se.finalblock);\n \n   if (se.ss == NULL)\n     tmp = gfc_finish_block (&body);"}, {"sha": "f78875455a5f1d742dfc7e8f46604c60a9e7a195", "filename": "gcc/fortran/trans-stmt.cc", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Ftrans-stmt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Ftrans-stmt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.cc?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -444,7 +444,8 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n       else\n \tgfc_add_expr_to_block (&se.pre, se.expr);\n \n-      gfc_add_block_to_block (&se.pre, &se.post);\n+      gfc_add_block_to_block (&se.finalblock, &se.post);\n+      gfc_add_block_to_block (&se.pre, &se.finalblock);\n     }\n \n   else\n@@ -543,6 +544,7 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n       gfc_trans_scalarizing_loops (&loop, &body);\n       gfc_add_block_to_block (&se.pre, &loop.pre);\n       gfc_add_block_to_block (&se.pre, &loop.post);\n+      gfc_add_block_to_block (&se.pre, &loopse.finalblock);\n       gfc_add_block_to_block (&se.pre, &se.post);\n       gfc_cleanup_loop (&loop);\n     }\n@@ -2189,13 +2191,23 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n       gfc_expr *lhs;\n       tree res;\n       gfc_se se;\n+      stmtblock_t final_block;\n \n       gfc_init_se (&se, NULL);\n \n       /* resolve.cc converts some associate names to allocatable so that\n \t allocation can take place automatically in gfc_trans_assignment.\n \t The frontend prevents them from being either allocated,\n \t deallocated or reallocated.  */\n+      if (sym->ts.type == BT_DERIVED\n+\t  && sym->ts.u.derived->attr.alloc_comp)\n+\t{\n+\t  tmp = sym->backend_decl;\n+\t  tmp = gfc_nullify_alloc_comp (sym->ts.u.derived, tmp,\n+\t\t\t\tsym->attr.dimension ? sym->as->rank : 0);\n+\t  gfc_add_expr_to_block (&se.pre, tmp);\n+\t}\n+\n       if (sym->attr.allocatable)\n \t{\n \t  tmp = sym->backend_decl;\n@@ -2206,9 +2218,33 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t}\n \n       lhs = gfc_lval_expr_from_sym (sym);\n+      lhs->must_finalize = 0;\n       res = gfc_trans_assignment (lhs, e, false, true);\n       gfc_add_expr_to_block (&se.pre, res);\n \n+      gfc_init_block (&final_block);\n+\n+      if (sym->attr.associate_var\n+\t  && sym->ts.type == BT_DERIVED\n+\t  && sym->ts.u.derived->attr.defined_assign_comp\n+\t  && gfc_may_be_finalized (sym->ts)\n+\t  && e->expr_type == EXPR_FUNCTION)\n+\t{\n+\t  gfc_expr *ef;\n+\t  ef = gfc_lval_expr_from_sym (sym);\n+\t  gfc_add_finalizer_call (&final_block, ef);\n+\t  gfc_free_expr (ef);\n+\t}\n+\n+      if (sym->ts.type == BT_DERIVED\n+\t  && sym->ts.u.derived->attr.alloc_comp)\n+\t{\n+\t  tmp = sym->backend_decl;\n+\t  tmp = gfc_deallocate_alloc_comp (sym->ts.u.derived,\n+\t\t\t\t\t   tmp, 0);\n+\t  gfc_add_expr_to_block (&final_block, tmp);\n+\t}\n+\n       tmp = sym->backend_decl;\n       if (e->expr_type == EXPR_FUNCTION\n \t  && sym->ts.type == BT_DERIVED\n@@ -2243,6 +2279,8 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n       else\n \ttmp = NULL_TREE;\n \n+      gfc_add_expr_to_block (&final_block, tmp);\n+      tmp = gfc_finish_block (&final_block);\n       res = gfc_finish_block (&se.pre);\n       gfc_add_init_cleanup (block, res, tmp);\n       gfc_free_expr (lhs);\n@@ -6347,7 +6385,10 @@ gfc_trans_allocate (gfc_code * code)\n \t}\n       gfc_add_block_to_block (&block, &se.pre);\n       if (code->expr3->must_finalize)\n-\tgfc_add_block_to_block (&final_block, &se.post);\n+\t{\n+\t  gfc_add_block_to_block (&final_block, &se.finalblock);\n+\t  gfc_add_block_to_block (&final_block, &se.post);\n+\t}\n       else\n \tgfc_add_block_to_block (&post, &se.post);\n \n@@ -7007,8 +7048,13 @@ gfc_trans_allocate (gfc_code * code)\n \t  gfc_expr *init_expr = gfc_expr_to_initialize (expr);\n \t  gfc_expr *rhs = e3rhs ? e3rhs : gfc_copy_expr (code->expr3);\n \t  flag_realloc_lhs = 0;\n+\n+\t  /* Set the symbol to be artificial so that the result is not finalized.  */\n+\t  init_expr->symtree->n.sym->attr.artificial = 1;\n \t  tmp = gfc_trans_assignment (init_expr, rhs, true, false, true,\n \t\t\t\t      false);\n+\t  init_expr->symtree->n.sym->attr.artificial = 0;\n+\n \t  flag_realloc_lhs = realloc_lhs;\n \t  /* Free the expression allocated for init_expr.  */\n \t  gfc_free_expr (init_expr);"}, {"sha": "f7745add045f8a0d6061ec9d68000b87a4b68a5e", "filename": "gcc/fortran/trans.cc", "status": "modified", "additions": 280, "deletions": 1, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Ftrans.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Ftrans.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.cc?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -1098,7 +1098,7 @@ gfc_build_final_call (gfc_typespec ts, gfc_expr *final_wrapper, gfc_expr *var,\n       else\n \t{\n \t  gfc_conv_expr (&se, var);\n-\t  gcc_assert (se.pre.head == NULL_TREE && se.post.head == NULL_TREE);\n+//\t  gcc_assert (se.pre.head == NULL_TREE && se.post.head == NULL_TREE);\n \t  array = se.expr;\n \n \t  /* No copy back needed, hence set attr's allocatable/pointer\n@@ -1276,6 +1276,14 @@ gfc_add_finalizer_call (stmtblock_t *block, gfc_expr *expr2)\n   if (!expr2 || (expr2->ts.type != BT_DERIVED && expr2->ts.type != BT_CLASS))\n     return false;\n \n+  /* Finalization of these temporaries is made by explicit calls in\n+     resolve.cc(generate_component_assignments).  */\n+  if (expr2->expr_type == EXPR_VARIABLE\n+      && expr2->symtree->n.sym->name[0] == '_'\n+      && expr2->ts.type == BT_DERIVED\n+      && expr2->ts.u.derived->attr.defined_assign_comp)\n+    return false;\n+\n   if (expr2->ts.type == BT_DERIVED)\n     {\n       gfc_is_finalizable (expr2->ts.u.derived, &final_expr);\n@@ -1370,6 +1378,277 @@ gfc_add_finalizer_call (stmtblock_t *block, gfc_expr *expr2)\n }\n \n \n+  /* F2018 (7.5.6.3): \"When an intrinsic assignment statement is executed\n+     (10.2.1.3), if the variable is not an unallocated allocatable variable,\n+     it is finalized after evaluation of expr and before the definition of\n+     the variable. If the variable is an allocated allocatable variable, or\n+     has an allocated allocatable subobject, that would be deallocated by\n+     intrinsic assignment, the finalization occurs before the deallocation */\n+\n+bool\n+gfc_assignment_finalizer_call (gfc_se *lse, gfc_expr *expr1, bool init_flag)\n+{\n+  symbol_attribute lhs_attr;\n+  tree final_expr;\n+  tree ptr;\n+  tree cond;\n+  gfc_se se;\n+  gfc_symbol *sym = expr1->symtree->n.sym;\n+  gfc_ref *ref = expr1->ref;\n+  stmtblock_t final_block;\n+  gfc_init_block (&final_block);\n+  gfc_expr *finalize_expr;\n+  bool class_array_ref;\n+\n+  /* We have to exclude vtable procedures (_copy and _final especially), uses\n+     of gfc_trans_assignment_1 in initialization and allocation before trying\n+     to build a final call.  */\n+  if (!expr1->must_finalize\n+      || sym->attr.artificial\n+      || sym->ns->proc_name->attr.artificial\n+      || init_flag)\n+    return false;\n+\n+  class_array_ref = ref && ref->type == REF_COMPONENT\n+\t\t    && !strcmp (ref->u.c.component->name, \"_data\")\n+\t\t    && ref->next && ref->next->type == REF_ARRAY\n+\t\t    && !ref->next->next;\n+\n+  if (class_array_ref)\n+    {\n+      finalize_expr = gfc_lval_expr_from_sym (sym);\n+      finalize_expr->must_finalize = 1;\n+      ref = NULL;\n+    }\n+  else\n+    finalize_expr = gfc_copy_expr (expr1);\n+\n+  /* F2018 7.5.6.2: Only finalizable entities are finalized.  */\n+  if (!(expr1->ts.type == BT_DERIVED\n+\t&& gfc_is_finalizable (expr1->ts.u.derived, NULL))\n+      && expr1->ts.type != BT_CLASS)\n+      return false;\n+\n+  if (!gfc_may_be_finalized (sym->ts))\n+    return false;\n+\n+  gfc_init_block (&final_block);\n+  bool finalizable = gfc_add_finalizer_call (&final_block, finalize_expr);\n+  gfc_free_expr (finalize_expr);\n+\n+  if (!finalizable)\n+    return false;\n+\n+  lhs_attr = gfc_expr_attr (expr1);\n+\n+  /* Check allocatable/pointer is allocated/associated.  */\n+  if (lhs_attr.allocatable || lhs_attr.pointer)\n+    {\n+      if (expr1->ts.type == BT_CLASS)\n+\t{\n+\t  ptr = gfc_get_class_from_gfc_expr (expr1);\n+\t  gcc_assert (ptr != NULL_TREE);\n+\t  ptr = gfc_class_data_get (ptr);\n+\t  if (lhs_attr.dimension)\n+\t    ptr = gfc_conv_descriptor_data_get (ptr);\n+\t}\n+      else\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  if (expr1->rank)\n+\t    {\n+\t      gfc_conv_expr_descriptor (&se, expr1);\n+\t      ptr = gfc_conv_descriptor_data_get (se.expr);\n+\t    }\n+\t  else\n+\t    {\n+\t      gfc_conv_expr (&se, expr1);\n+\t      ptr = gfc_build_addr_expr (NULL_TREE, se.expr);\n+\t    }\n+\t}\n+\n+      cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n+\t\t\t      ptr, build_zero_cst (TREE_TYPE (ptr)));\n+      final_expr = build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t       cond, gfc_finish_block (&final_block),\n+\t\t\t       build_empty_stmt (input_location));\n+    }\n+  else\n+    final_expr = gfc_finish_block (&final_block);\n+\n+  /* Check optional present.  */\n+  if (sym->attr.optional)\n+    {\n+      cond = gfc_conv_expr_present (sym);\n+      final_expr = build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t       cond, final_expr,\n+\t\t\t       build_empty_stmt (input_location));\n+    }\n+\n+  gfc_add_expr_to_block (&lse->finalblock, final_expr);\n+\n+  return true;\n+}\n+\n+\n+/* Finalize a TREE expression using the finalizer wrapper. The result is\n+   fixed in order to prevent repeated calls.  */\n+\n+void\n+gfc_finalize_tree_expr (gfc_se *se, gfc_symbol *derived,\n+\t\t\tsymbol_attribute attr, int rank)\n+{\n+  tree vptr, final_fndecl, desc, tmp, size, is_final;\n+  tree data_ptr, data_null, cond;\n+  gfc_symbol *vtab;\n+  gfc_se post_se;\n+  bool is_class = GFC_CLASS_TYPE_P (TREE_TYPE (se->expr));\n+\n+  if (attr.pointer)\n+    return;\n+\n+  /* Derived type function results with components that have defined\n+     assignements are handled in resolve.cc(generate_component_assignments)  */\n+  if (derived && (derived->attr.is_c_interop\n+\t\t  || derived->attr.is_iso_c\n+\t\t  || derived->attr.is_bind_c\n+\t\t  || derived->attr.defined_assign_comp))\n+    return;\n+\n+  if (is_class)\n+    {\n+      if (!VAR_P (se->expr))\n+\t{\n+\t  desc = gfc_evaluate_now (se->expr, &se->pre);\n+\t  se->expr = desc;\n+\t}\n+      desc = gfc_class_data_get (se->expr);\n+      vptr = gfc_class_vptr_get (se->expr);\n+    }\n+  else if (derived && gfc_is_finalizable (derived, NULL))\n+    {\n+      if (derived->attr.zero_comp && !rank)\n+\t{\n+\t  /* Any attempt to assign zero length entities, causes the gimplifier\n+\t     all manner of problems. Instead, a variable is created to act as\n+\t     as the argument for the final call.  */\n+\t  desc = gfc_create_var (TREE_TYPE (se->expr), \"zero\");\n+\t}\n+      else if (se->direct_byref)\n+\t{\n+\t  desc = gfc_evaluate_now (se->expr, &se->finalblock);\n+\t  if (derived->attr.alloc_comp)\n+\t    {\n+\t      /* Need to copy allocated components and not finalize.  */\n+\t      tmp = gfc_copy_alloc_comp_no_fini (derived, se->expr, desc, rank, 0);\n+\t      gfc_add_expr_to_block (&se->finalblock, tmp);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  desc = gfc_evaluate_now (se->expr, &se->pre);\n+\t  se->expr = gfc_evaluate_now (desc, &se->pre);\n+\t  if (derived->attr.alloc_comp)\n+\t    {\n+\t      /* Need to copy allocated components and not finalize.  */\n+\t      tmp = gfc_copy_alloc_comp_no_fini (derived, se->expr, desc, rank, 0);\n+\t      gfc_add_expr_to_block (&se->pre, tmp);\n+\t    }\n+\t}\n+\n+      vtab = gfc_find_derived_vtab (derived);\n+      if (vtab->backend_decl == NULL_TREE)\n+\tvptr = gfc_get_symbol_decl (vtab);\n+      else\n+\tvptr = vtab->backend_decl;\n+      vptr = gfc_build_addr_expr (NULL, vptr);\n+    }\n+  else\n+    return;\n+\n+  size = gfc_vptr_size_get (vptr);\n+  final_fndecl = gfc_vptr_final_get (vptr);\n+  is_final = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t      logical_type_node,\n+\t\t\t      final_fndecl,\n+\t\t\t      fold_convert (TREE_TYPE (final_fndecl),\n+\t\t\t\t\t    null_pointer_node));\n+\n+  final_fndecl = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t      final_fndecl);\n+  if (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))\n+    {\n+      if (is_class)\n+\tdesc = gfc_conv_scalar_to_descriptor (se, desc, attr);\n+      else\n+\t{\n+\t  gfc_init_se (&post_se, NULL);\n+\t  desc = gfc_conv_scalar_to_descriptor (&post_se, desc, attr);\n+\t  gfc_add_expr_to_block (&se->pre, gfc_finish_block (&post_se.pre));\n+\t}\n+    }\n+\n+  if (derived && derived->attr.zero_comp)\n+    {\n+      /* All the conditions below break down for zero length derived types.  */\n+      tmp = build_call_expr_loc (input_location, final_fndecl, 3,\n+\t\t\t\t gfc_build_addr_expr (NULL, desc),\n+\t\t\t\t size, boolean_false_node);\n+      gfc_add_expr_to_block (&se->finalblock, tmp);\n+      return;\n+    }\n+\n+  if (!VAR_P (desc))\n+    {\n+      tmp = gfc_create_var (TREE_TYPE (desc), \"res\");\n+      if (se->direct_byref)\n+\tgfc_add_modify (&se->finalblock, tmp, desc);\n+      else\n+\tgfc_add_modify (&se->pre, tmp, desc);\n+      desc = tmp;\n+    }\n+\n+  data_ptr = gfc_conv_descriptor_data_get (desc);\n+  data_null = fold_convert (TREE_TYPE (data_ptr), null_pointer_node);\n+  cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t  logical_type_node, data_ptr, data_null);\n+  is_final = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t      logical_type_node, is_final, cond);\n+  tmp = build_call_expr_loc (input_location, final_fndecl, 3,\n+\t\t\t     gfc_build_addr_expr (NULL, desc),\n+\t\t\t     size, boolean_false_node);\n+  tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t void_type_node, is_final, tmp,\n+\t\t\t build_empty_stmt (input_location));\n+\n+  if (is_class && se->ss && se->ss->loop)\n+    {\n+      gfc_add_expr_to_block (&se->loop->post, tmp);\n+      tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t     void_type_node, cond,\n+\t\t\t     gfc_call_free (data_ptr),\n+\t\t\t     build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&se->loop->post, tmp);\n+      gfc_add_modify (&se->loop->post, data_ptr, data_null);\n+    }\n+  else\n+    {\n+      gfc_add_expr_to_block (&se->finalblock, tmp);\n+\n+      /* Let the scalarizer take care of freeing of temporary arrays.  */\n+      if (attr.allocatable && !(se->loop && se->loop->temp_dim))\n+\t{\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t void_type_node, cond,\n+\t\t\t\t gfc_call_free (data_ptr),\n+\t\t\t\t build_empty_stmt (input_location));\n+\t  gfc_add_expr_to_block (&se->finalblock, tmp);\n+\t  gfc_add_modify (&se->finalblock, data_ptr, data_null);\n+\t}\n+    }\n+}\n+\n+\n /* User-deallocate; we emit the code directly from the front-end, and the\n    logic is the same as the previous library function:\n "}, {"sha": "1ad6d944fcf2ba88ecadae96c628ad978a9cc835", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -43,6 +43,10 @@ typedef struct gfc_se\n   stmtblock_t pre;\n   stmtblock_t post;\n \n+  /* Carries finalization code that is required to be executed execution of the\n+     innermost executable construct.  */\n+  stmtblock_t finalblock;\n+\n   /* the result of the expression */\n   tree expr;\n \n@@ -55,7 +59,7 @@ typedef struct gfc_se\n \n   /* Whether expr is a reference to an unlimited polymorphic object.  */\n   unsigned unlimited_polymorphic:1;\n-  \n+\n   /* If set gfc_conv_variable will return an expression for the array\n      descriptor. When set, want_pointer should also be set.\n      If not set scalarizing variables will be substituted.  */\n@@ -450,6 +454,8 @@ tree gfc_get_vptr_from_expr (tree);\n tree gfc_copy_class_to_class (tree, tree, tree, bool);\n bool gfc_add_finalizer_call (stmtblock_t *, gfc_expr *);\n bool gfc_add_comp_finalizer_call (stmtblock_t *, tree, gfc_component *, bool);\n+void gfc_finalize_tree_expr (gfc_se *, gfc_symbol *, symbol_attribute, int);\n+bool gfc_assignment_finalizer_call (gfc_se *, gfc_expr *, bool);\n \n void gfc_conv_derived_to_class (gfc_se *, gfc_expr *, gfc_typespec, tree, bool,\n \t\t\t\tbool, tree *derived_array = NULL);"}, {"sha": "de20a147842cbb181730b7b60650b81ad501acb8", "filename": "gcc/testsuite/gfortran.dg/allocate_with_source_25.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_25.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_25.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_25.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -68,4 +68,4 @@ function func_foo_a (D) result (f)\n   end function func_foo_a\n \n end program simple_leak\n-! { dg-final { scan-tree-dump-times \"\\>_final\" 6 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\>_final\" 4 \"original\" } }"}, {"sha": "97b53f64ded798e7ffb94b8bf8061270cb3a564f", "filename": "gcc/testsuite/gfortran.dg/associate_25.f90", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_25.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_25.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_25.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -21,9 +21,7 @@ subroutine Testf()\n     associate(X => T()) ! This was failing: Symbol 'x' at (1) has no IMPLICIT type\n       final_flag = X%val\n     end associate\n-! This should now be 4 but the finalization is not happening.\n-! TODO put it right!\n-    if (final_flag .ne. 2) STOP 1\n+    if (final_flag .ne. 2) stop 1\n   end subroutine Testf\n end module\n "}, {"sha": "93d4f95ddf6faa50c37b439a963bf003d715614f", "filename": "gcc/testsuite/gfortran.dg/auto_dealloc_2.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_dealloc_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_dealloc_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_dealloc_2.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -24,7 +24,7 @@ subroutine init(x)\n     allocate(x%i(1000))\n   end subroutine\n \n-end program \n+end program\n \n ! { dg-final { scan-tree-dump-times \"__builtin_free\" 4 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"x->_vptr->_final \\\\(\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_vptr->_final \\\\(&desc\" 1 \"original\" } }"}, {"sha": "f4b00a16a5404109d1fde8c74693df9a38740156", "filename": "gcc/testsuite/gfortran.dg/finalize_38.f90", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_38.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_38.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_38.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -0,0 +1,222 @@\n+! { dg-do run }\n+!\n+! Test finalization on intrinsic assignment (F2018 (7.5.6.3))\n+! With -std=gnu, no finalization of array or structure constructors should occur.\n+! See finalize_38a.f90 for the result with f2008.\n+! Tests fix for PR64290 as well.\n+!\n+module testmode\n+  implicit none\n+\n+  type :: simple\n+    integer :: ind\n+  contains\n+    final :: destructor1, destructor2\n+  end type simple\n+\n+  type, extends(simple) :: complicated\n+    real :: rind\n+  contains\n+    final :: destructor3, destructor4\n+  end type complicated\n+\n+  integer :: check_scalar\n+  integer :: check_array(4)\n+  real :: check_real\n+  real :: check_rarray(4)\n+  integer :: final_count = 0\n+\n+contains\n+\n+  subroutine destructor1(self)\n+    type(simple), intent(inout) :: self\n+    check_scalar = self%ind\n+    check_array = 0\n+    final_count = final_count + 1\n+  end subroutine destructor1\n+\n+  subroutine destructor2(self)\n+    type(simple), intent(inout) :: self(:)\n+    check_scalar = 0\n+    check_array(1:size(self, 1)) = self%ind\n+    final_count = final_count + 1\n+  end subroutine destructor2\n+\n+  subroutine destructor3(self)\n+    type(complicated), intent(inout) :: self\n+    check_real = self%rind\n+    check_array = 0.0\n+    final_count = final_count + 1\n+  end subroutine destructor3\n+\n+  subroutine destructor4(self)\n+    type(complicated), intent(inout) :: self(:)\n+    check_real = 0.0\n+    check_rarray(1:size(self, 1)) = self%rind\n+    final_count = final_count + 1\n+  end subroutine destructor4\n+\n+  function constructor1(ind) result(res)\n+    class(simple), allocatable :: res\n+    integer, intent(in) :: ind\n+    allocate (res, source = simple (ind))\n+  end function constructor1\n+\n+  function constructor2(ind, rind) result(res)\n+    class(simple), allocatable :: res(:)\n+    integer, intent(in) :: ind(:)\n+    real, intent(in), optional :: rind(:)\n+    type(complicated), allocatable :: src(:)\n+    integer :: sz\n+    integer :: i\n+    if (present (rind)) then\n+      sz = min (size (ind, 1), size (rind, 1))\n+      src  = [(complicated (ind(i), rind(i)), i = 1, sz)]\n+      allocate (res, source = src)\n+    else\n+      sz = size (ind, 1)\n+      allocate (res, source = [(simple (ind(i)), i = 1, sz)])\n+    end if\n+  end function constructor2\n+\n+  subroutine test (cnt, scalar, array, off, rind, rarray)\n+    integer :: cnt\n+    integer :: scalar\n+    integer :: array(:)\n+    integer :: off\n+    real, optional :: rind\n+    real, optional :: rarray(:)\n+    if (final_count .ne. cnt) then\n+        stop 1 + off\n+    endif\n+    if (check_scalar .ne. scalar) then\n+        stop 2 + off\n+    endif\n+    if (any (check_array(1:size (array, 1)) .ne. array)) then\n+        stop 3 + off\n+    endif\n+    if (present (rind)) then\n+        stop 4 + off\n+    end if\n+    if (present (rarray)) then\n+      if (any (check_rarray(1:size (rarray, 1)) .ne. rarray)) then\n+        stop 5 + off\n+      endif\n+    end if\n+    final_count = 0\n+  end subroutine test\n+end module testmode\n+\n+program test_final\n+  use testmode\n+  implicit none\n+\n+  type(simple), allocatable :: MyType, MyType2\n+  type(simple), allocatable :: MyTypeArray(:)\n+  type(simple) :: ThyType = simple(21), ThyType2 = simple(22)\n+  class(simple), allocatable :: MyClass\n+  class(simple), allocatable :: MyClassArray(:)\n+\n+! ************************\n+! Derived type assignments\n+! ************************\n+\n+! The original PR - no finalization of 'var' before (re)allocation\n+! because it is deallocated on scope entry (para 1 of F2018 7.5.6.3.)\n+  MyType = ThyType\n+  call test(0, 0, [0,0], 0)\n+\n+  if (.not. allocated(MyType)) allocate(MyType)\n+  allocate(MyType2)\n+  MyType%ind = 1\n+  MyType2%ind = 2\n+\n+! This should result in a final call with self = simple(1) (para 1 of F2018 7.5.6.3.).\n+  MyType = MyType2\n+  call test(1, 1, [0,0], 10)\n+\n+  allocate(MyTypeArray(2))\n+  MyTypeArray%ind = [42, 43]\n+! This should result no calls.\n+  call test(0, 1, [0,0], 20)\n+\n+! This should result in a final call 'var' = initialization = simple(22).\n+  ThyType2 = simple(99)\n+  call test(1, 22, [0,0], 30)\n+\n+! This should result in a final call for 'var' with self = simple(21).\n+  ThyType = ThyType2\n+  call test(1, 21, [0,0], 40)\n+\n+! This should result in two final calls; the last is for Mytype2 = simple(2).\n+  deallocate (MyType, MyType2)\n+  call test(2, 2, [0,0], 50)\n+\n+! This should result in one final call; MyTypeArray = [simple(42),simple(43)].\n+  deallocate (MyTypeArray)\n+  call test(1, 0, [42,43], 60)\n+\n+! The lhs is finalized before assignment.\n+! The function result is finalized after the assignment.\n+! NAGFOR doesn't finalize the function result.\n+  allocate (MyType, source = simple (11))\n+  MyType = constructor1 (99)\n+  call test(2, 99, [0,0], 70)\n+  deallocate (MyType)\n+! *****************\n+! Class assignments\n+! *****************\n+\n+  final_count = 0\n+\n+! This should result in a final call for MyClass, which is simple(3).\n+  allocate (MyClass, source = simple (3))\n+  MyClass = simple (4)\n+  call test(1, 3, [0,0], 100)\n+\n+! This should result in a final call with the assigned value of simple(4).\n+  deallocate (MyClass)\n+  call test(1, 4, [0,0], 110)\n+\n+\n+  allocate (MyClassArray, source = [simple (5), simple (6)])\n+! Make sure that there is no final call since MyClassArray is not allocated.\n+  call test(0, 4, [0,0], 120)\n+\n+  MyClassArray = [simple (7), simple (8)]\n+! The only final call should finalize 'var'.\n+! NAGFOR does something strange here: makes a scalar final call with value\n+! simple(5).\n+  call test(1, 0, [5,6], 130)\n+\n+! This should result in a final call with the assigned value.\n+  deallocate (MyClassArray)\n+  call test(1, 0, [7,8], 140)\n+\n+! This should produce no final calls since MyClassArray was deallocated.\n+  allocate (MyClassArray, source = [complicated(1, 2.0),complicated(3, 4.0)])\n+\n+! This should produce calls to destructor4 then destructor2.\n+  if (allocated (MyClassArray)) deallocate (MyClassArray)\n+\n+! F2018 7.5.6.3: \"If the entity is of extended type and the parent type is\n+! finalizable, the parent component is finalized.\n+  call test(2, 0, [1, 3], 150, rarray = [2.0, 4.0])\n+\n+! This produces 2 final calls in turn for 'src' as it goes out of scope, for\n+! MyClassArray before it is assigned to and the result of 'constructor2' after\n+! the assignment, for which the result should be should be [10,20] & [10.0,20.0].\n+  MyClassArray = constructor2 ([10,20], [10.0,20.0])\n+  call test(4, 0, [10,20], 160, rarray = [10.0,20.0])\n+\n+! This produces two final calls with the contents of 'MyClassArray. and its\n+! parent component.\n+  deallocate (MyClassArray)\n+  call test(2, 0, [10, 20], 170, rarray = [10.0,20.0])\n+\n+! Clean up for valgrind testing\n+  if (allocated (MyType)) deallocate (MyType)\n+  if (allocated (MyType2)) deallocate (MyType2)\n+  if (allocated (MyTypeArray)) deallocate (MyTypeArray)\n+  if (allocated (MyClass)) deallocate (MyClass)\n+end program test_final"}, {"sha": "26041a0aa97f592baf93fd84e141c5c2da5af438", "filename": "gcc/testsuite/gfortran.dg/finalize_38a.f90", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_38a.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_38a.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_38a.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -0,0 +1,240 @@\n+! { dg-do run }\n+! { dg-options \"-std=f2008\" }\n+!\n+! Test finalization on intrinsic assignment (F2018 (7.5.6.3))\n+! With -std=f2008, structure and array constructors are finalized.\n+! See finalize_38.f90 for the result with -std=gnu.\n+! Tests fix for PR64290 as well.\n+!\n+module testmode\n+  implicit none\n+\n+  type :: simple\n+    integer :: ind\n+  contains\n+    final :: destructor1, destructor2\n+  end type simple\n+\n+  type, extends(simple) :: complicated\n+    real :: rind\n+  contains\n+    final :: destructor3, destructor4\n+  end type complicated\n+\n+  integer :: check_scalar\n+  integer :: check_array(4)\n+  real :: check_real\n+  real :: check_rarray(4)\n+  integer :: final_count = 0\n+  integer :: fails = 0\n+\n+contains\n+\n+  subroutine destructor1(self)\n+    type(simple), intent(inout) :: self\n+    check_scalar = self%ind\n+    check_array = 0\n+    final_count = final_count + 1\n+  end subroutine destructor1\n+\n+  subroutine destructor2(self)\n+    type(simple), intent(inout) :: self(:)\n+    check_scalar = 0\n+    check_array(1:size(self, 1)) = self%ind\n+    final_count = final_count + 1\n+  end subroutine destructor2\n+\n+  subroutine destructor3(self)\n+    type(complicated), intent(inout) :: self\n+    check_real = self%rind\n+    check_array = 0.0\n+    final_count = final_count + 1\n+  end subroutine destructor3\n+\n+  subroutine destructor4(self)\n+    type(complicated), intent(inout) :: self(:)\n+    check_real = 0.0\n+    check_rarray(1:size(self, 1)) = self%rind\n+    final_count = final_count + 1\n+  end subroutine destructor4\n+\n+  function constructor1(ind) result(res)\n+    class(simple), allocatable :: res\n+    integer, intent(in) :: ind\n+    allocate (res, source = simple (ind))\n+  end function constructor1\n+\n+  function constructor2(ind, rind) result(res)\n+    class(simple), allocatable :: res(:)\n+    integer, intent(in) :: ind(:)\n+    real, intent(in), optional :: rind(:)\n+    type(complicated), allocatable :: src(:)\n+    integer :: sz\n+    integer :: i\n+    if (present (rind)) then\n+      sz = min (size (ind, 1), size (rind, 1))\n+      src  = [(complicated (ind(i), rind(i)), i = 1, sz)]  ! { dg-warning \"has been finalized\" }\n+      allocate (res, source = src)\n+    else\n+      sz = size (ind, 1)\n+      allocate (res, source = [(simple (ind(i)), i = 1, sz)])\n+    end if\n+  end function constructor2\n+\n+  subroutine test (cnt, scalar, array, off, rind, rarray)\n+    integer :: cnt\n+    integer :: scalar\n+    integer :: array(:)\n+    integer :: off\n+    real, optional :: rind\n+    real, optional :: rarray(:)\n+    if (final_count .ne. cnt) then\n+        print *, 1 + off, final_count, '(', cnt, ')'\n+        fails = fails + 1\n+    endif\n+    if (check_scalar .ne. scalar) then\n+        print *, 2 + off, check_scalar, '(', scalar, ')'\n+        fails = fails + 1\n+    endif\n+    if (any (check_array(1:size (array, 1)) .ne. array)) then\n+        print *, 3 + off, check_array(1:size (array, 1)) , '(', array, ')'\n+        fails = fails + 1\n+    endif\n+    if (present (rind)) then\n+      if (check_real .ne. rind) then\n+        print *, 4 + off, check_real,'(', rind, ')'\n+        fails = fails + 1\n+      endif\n+    end if\n+    if (present (rarray)) then\n+      if (any (check_rarray(1:size (rarray, 1)) .ne. rarray)) then\n+        print *, 5 + off, check_rarray(1:size (rarray, 1)), '(', rarray, ')'\n+        fails = fails + 1\n+      endif\n+    end if\n+    final_count = 0\n+  end subroutine test\n+end module testmode\n+\n+program test_final\n+  use testmode\n+  implicit none\n+\n+  type(simple), allocatable :: MyType, MyType2\n+  type(simple), allocatable :: MyTypeArray(:)\n+  type(simple) :: ThyType = simple(21), ThyType2 = simple(22)\n+  class(simple), allocatable :: MyClass\n+  class(simple), allocatable :: MyClassArray(:)\n+\n+! ************************\n+! Derived type assignments\n+! ************************\n+\n+! The original PR - no finalization of 'var' before (re)allocation\n+! because it is deallocated on scope entry (para 1 of F2018 7.5.6.3.)\n+  MyType = ThyType\n+  call test(0, 0, [0,0], 0)\n+\n+  if (.not. allocated(MyType)) allocate(MyType)\n+  allocate(MyType2)\n+  MyType%ind = 1\n+  MyType2%ind = 2\n+\n+! This should result in a final call with self = simple(1) (para 1 of F2018 7.5.6.3.).\n+  MyType = MyType2\n+  call test(1, 1, [0,0], 10)\n+\n+  allocate(MyTypeArray(2))\n+  MyTypeArray%ind = [42, 43]\n+! This should result in a final call with self = [simple(42),simple(43)],\n+! followed by the finalization of the array constructor = self = [simple(21),simple(22)].\n+  MyTypeArray = [ThyType, ThyType2] ! { dg-warning \"has been finalized\" }\n+  call test(2, 0, [21,22], 20)\n+\n+! This should result in a final call 'var' = initialization = simple(22),\n+! followed by one with for the structure constructor.\n+  ThyType2 = simple(99) ! { dg-warning \"has been finalized\" }\n+  call test(2, 99, [0,0], 30)\n+\n+! This should result in a final call for 'var' with self = simple(21).\n+  ThyType = ThyType2\n+  call test(1, 21, [0,0], 40)\n+\n+! This should result in two final calls; the last is for Mytype2 = simple(2).\n+  deallocate (MyType, MyType2)\n+  call test(2, 2, [0,0], 50)\n+\n+! This should result in one final call; MyTypeArray = [simple(21),simple(22)].\n+  deallocate (MyTypeArray)\n+  call test(1, 0, [21,22], 60)\n+\n+! The lhs is finalized before assignment.\n+! The function result is finalized after the assignment.\n+  allocate (MyType, source = simple (11))\n+  MyType = constructor1 (99)\n+  call test(2, 99, [0,0], 70)\n+  deallocate (MyType)\n+! *****************\n+! Class assignments\n+! *****************\n+\n+  final_count = 0\n+\n+! This should result in a final call for MyClass, which is simple(3) and then\n+! the structure constructor with value simple(4)).\n+  allocate (MyClass, source = simple (3))\n+  MyClass = simple (4) ! { dg-warning \"has been finalized\" }\n+  call test(2, 4, [0,0], 100)\n+\n+! This should result in a final call with the assigned value of simple(4).\n+  deallocate (MyClass)\n+  call test(1, 4, [0,0], 110)\n+\n+\n+  allocate (MyClassArray, source = [simple (5), simple (6)])\n+! Make sure that there is no final call since MyClassArray is not allocated.\n+  call test(0, 4, [0,0], 120)\n+\n+  MyClassArray = [simple (7), simple (8)] ! { dg-warning \"has been finalized\" }\n+! The first final call should finalize MyClassArray and the second should return\n+! the value of the array constructor.\n+  call test(2, 0, [7,8], 130)\n+\n+! This should result in a final call with the assigned value.\n+  deallocate (MyClassArray)\n+  call test(1, 0, [7,8], 140)\n+\n+! This should produce no final calls since MyClassArray was deallocated.\n+  allocate (MyClassArray, source = [complicated(1, 2.0),complicated(3, 4.0)])\n+\n+! This should produce calls to destructor4 then destructor2.\n+  deallocate (MyClassArray)\n+\n+! F2018 7.5.6.3: \"If the entity is of extended type and the parent type is\n+! finalizable, the parent component is finalized.\n+  call test(2, 0, [1, 3], 150, rarray = [2.0, 4.0])\n+\n+! This produces 2 final calls in turn for 'src' as it goes out of scope, for\n+! MyClassArray before it is assigned to and the result of 'constructor2' after\n+! the assignment, for which the result should be should be [10,20] & [10.0,20.0].\n+  MyClassArray = constructor2 ([10,20], [10.0,20.0])\n+  call test(6, 0, [10,20], 160, rarray = [10.0,20.0])\n+\n+! This produces two final calls with the contents of 'MyClassArray. and its\n+! parent component.\n+  deallocate (MyClassArray)\n+  call test(2, 0, [10, 20], 170, rarray = [10.0,20.0])\n+\n+! Clean up for valgrind testing\n+  if (allocated (MyType)) deallocate (MyType)\n+  if (allocated (MyType2)) deallocate (MyType2)\n+  if (allocated (MyTypeArray)) deallocate (MyTypeArray)\n+  if (allocated (MyClass)) deallocate (MyClass)\n+  if (allocated (MyClassArray)) deallocate (MyClassArray)\n+\n+! Error messages printed out by 'test'.\n+  if (fails .ne. 0) then\n+   Print *, fails, \" Errors\"\n+   error stop\n+  endif\n+end program test_final"}, {"sha": "58f338d2ebc60eebd35fb6999d2024b96eaf75d2", "filename": "gcc/testsuite/gfortran.dg/finalize_39.f90", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_39.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_39.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_39.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -0,0 +1,71 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR67444 in which the finalization of a polymorphic 'var'\n+! was not being finalized before assignment. (STOP 3)\n+!\n+! Contributed by Balint Aradi  <baladi@gmail.com>\n+!\n+module classes\n+  implicit none\n+  integer :: ivalue = 0\n+  integer :: icall = 0\n+  integer :: fvalue = 0\n+\n+  type :: Basic\n+    integer :: ii = -1\n+  contains\n+    procedure :: assignBasic\n+    generic :: assignment(=) => assignBasic\n+    final :: destructBasic\n+  end type Basic\n+  interface Basic\n+    module procedure initBasic\n+  end interface Basic\n+contains\n+  function initBasic(initValue) result(this)\n+    integer, intent(in) :: initValue\n+    type(Basic) :: this\n+    this%ii = initValue\n+    icall = icall + 1\n+  end function initBasic\n+  subroutine assignBasic(this, other)\n+    class(Basic), intent(out) :: this\n+    type(Basic), intent(in) :: other\n+    this%ii = other%ii + 1\n+    icall = other%ii\n+  end subroutine assignBasic\n+  subroutine destructBasic(this)\n+    type(Basic), intent(inout) :: this\n+    fvalue = fvalue + 1\n+    select case (fvalue)\n+    case (1)\n+        if (this%ii /= -1) stop 1          ! First finalization before assignment to 'var'\n+        if (icall /= 1) stop 2             ! and before evaluation of 'expr'.\n+    case(2)\n+        if (this%ii /= ivalue) stop 3      ! Finalization of intent(out) in 'assignBasic'\n+        if (icall /= 42) stop 4            ! and after evaluation of 'expr'.\n+    case(3)\n+        if (this%ii /= ivalue + 1) stop 5  ! Finalization of 'expr' (function!) after assignment.\n+    case default\n+        stop 6                             ! Too many or no finalizations\n+    end select\n+  end subroutine destructBasic\n+end module classes\n+\n+module usage\n+  use classes\n+  implicit none\n+contains\n+  subroutine useBasic()\n+    type(Basic) :: bas\n+    ivalue = 42\n+    bas = Basic(ivalue)\n+  end subroutine useBasic\n+end module usage\n+\n+program test\n+  use usage\n+  implicit none\n+  call useBasic()\n+  if (fvalue /= 3) stop 7                  ! 3 finalizations mandated.\n+end program test"}, {"sha": "cf85f1398e18538ba058f381bb65d14caa8a5935", "filename": "gcc/testsuite/gfortran.dg/finalize_40.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_40.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_40.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_40.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do run }\n+!\n+! Test that PR67471 is fixed. Used not to call the finalizer.\n+!\n+! Contributed by Ian Harvey  <ian_harvey@bigpond.com>\n+!\n+module test_final_mod\n+  implicit none\n+  type :: my_final\n+    integer :: n = 1\n+  contains\n+    final :: destroy_scalar, destroy_rank1_array\n+  end type my_final\n+  integer :: final_calls = 0\n+contains\n+  subroutine destroy_rank1_array(self)\n+    type(my_final), intent(inout) :: self(:)\n+    if (size(self) /= 0) then\n+      if (size(self) /= 2) stop 1\n+      if (any (self%n /= [3,4])) stop 2\n+    else\n+      stop 3\n+    end if\n+    final_calls = final_calls + 1\n+  end subroutine destroy_rank1_array\n+\n+! Eliminate the warning about the lack of a scalar finalizer.\n+  subroutine destroy_scalar(self)\n+    type(my_final), intent(inout) :: self\n+    final_calls = final_calls + self%n\n+  end subroutine destroy_scalar\n+\n+end module test_final_mod\n+\n+program test_finalizer\n+  use test_final_mod\n+  implicit none\n+  type(my_final) :: b(4), c(2)\n+\n+  b%n = [2, 3, 4, 5]\n+  c%n = [6, 7]\n+  b(2:3) = c\n+  if (final_calls /= 1) stop 4\n+end program test_finalizer"}, {"sha": "9458d9c666447fca0d87f1abdbd5029459f05eb4", "filename": "gcc/testsuite/gfortran.dg/finalize_41.f90", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_41.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_41.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_41.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -0,0 +1,139 @@\n+! { dg-do run }\n+!\n+! Test that PR69298 is fixed. Used to segfault on finalization in\n+! subroutine 'in_type'.\n+!\n+! Contributed by Neil Carlson  <neil.n.carlson@gmail.com>\n+!\n+module stuff_mod\n+  implicit none\n+  private\n+  public :: stuff_type, final_calls\n+  type stuff_type\n+    private\n+    integer :: junk\n+  contains\n+    procedure get_junk\n+    procedure stuff_copy_initialiser\n+    generic :: assignment(=) => stuff_copy_initialiser\n+    final :: stuff_scalar_finaliser, &\n+             stuff_1d_finaliser\n+  end type stuff_type\n+  integer :: final_calls = 0\n+  interface stuff_type\n+    procedure stuff_initialiser\n+  end interface stuff_type\n+contains\n+\n+  function stuff_initialiser( junk ) result(new_stuff)\n+    implicit none\n+    type(stuff_type) :: new_stuff\n+    integer :: junk\n+    new_stuff%junk = junk\n+  end function stuff_initialiser\n+\n+  subroutine stuff_copy_initialiser( destination, source )\n+    implicit none\n+    class(stuff_type), intent(out) :: destination\n+    class(stuff_type), intent(in)  :: source\n+    destination%junk = source%junk\n+  end subroutine stuff_copy_initialiser\n+\n+  subroutine stuff_scalar_finaliser( this )\n+    implicit none\n+    type(stuff_type), intent(inout) :: this\n+    final_calls = final_calls + 1\n+  end subroutine stuff_scalar_finaliser\n+\n+  subroutine stuff_1d_finaliser( this )\n+    implicit none\n+    type(stuff_type), intent(inout) :: this(:)\n+    integer :: i\n+    final_calls = final_calls + 100\n+  end subroutine stuff_1d_finaliser\n+\n+  function get_junk( this ) result(junk)\n+    implicit none\n+    class(stuff_type), intent(in) :: this\n+    integer :: junk\n+    junk = this%junk\n+  end function get_junk\n+end module stuff_mod\n+\n+module test_mod\n+  use stuff_mod, only : stuff_type, final_calls\n+  implicit none\n+  private\n+  public :: test_type\n+  type test_type\n+    private\n+    type(stuff_type) :: thing\n+    type(stuff_type) :: things(3)\n+  contains\n+    procedure get_value\n+  end type test_type\n+  interface test_type\n+    procedure test_type_initialiser\n+  end interface test_type\n+contains\n+\n+  function test_type_initialiser() result(new_test)\n+    implicit none\n+    type(test_type) :: new_test\n+    integer :: i ! At entry: 1 array and 9 scalars\n+    new_test%thing = stuff_type( 4 ) ! Gives 2 scalar calls\n+    do i = 1, 3\n+      new_test%things(i) = stuff_type( i )  ! Gives 6 scalar calls\n+    end do\n+  end function test_type_initialiser\n+\n+  function get_value( this ) result(value)\n+    implicit none\n+    class(test_type) :: this\n+    integer :: value\n+    integer :: i\n+    value = this%thing%get_junk()\n+    do i = 1, 3\n+      value = value + this%things(i)%get_junk()\n+    end do\n+  end function get_value\n+end module test_mod\n+\n+program test\n+  use stuff_mod, only : stuff_type, final_calls\n+  use test_mod,  only : test_type\n+  implicit none\n+  call here()\n+! One array call and 1 scalar call after leaving scope => 1 + 9 total; NAGFOR and IFORT agree\n+  if (final_calls .ne. 109) stop 1\n+  call in_type()\n+! 21 calls to scalar finalizer and 4 to the vector version; IFORT agrees\n+! NAGFOR also produces 21 scalar calls but 5 vector calls.\n+  if (final_calls .ne. 421) print *, final_calls\n+contains\n+\n+  subroutine here()\n+    implicit none\n+    type(stuff_type) :: thing\n+    type(stuff_type) :: bits(3)\n+    integer :: i\n+    integer :: tally\n+    thing = stuff_type(4) ! Two scalar final calls; INTENT(OUT) and initialiser\n+    do i = 1, 3\n+      bits(i) = stuff_type(i) ! ditto times 3\n+    end do\n+    tally = thing%get_junk()\n+    do i = 1, 3\n+      tally = tally + bits(i)%get_junk()\n+    end do\n+    if (tally .ne. 10) stop 3 ! 8 scalar final calls by here\n+  end subroutine here\n+\n+  subroutine in_type()\n+    implicit none\n+    type(test_type) :: thing\n+    thing = test_type() ! 8 scalar in test_type + 1 vector and 1 scalar to finalize function result and\n+                        ! 1 vectors and 2 scalars from the expansion of the defined assignment.\n+    if (thing%get_value() .ne. 10) stop 4\n+  end subroutine in_type\n+end program test"}, {"sha": "09178af85b6bee24aa84bd6cfa070929700adf49", "filename": "gcc/testsuite/gfortran.dg/finalize_42.f90", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_42.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_42.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_42.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -0,0 +1,53 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR71798 in which the result of 'create_mytype'\n+! was not being finalized after the completion of the assignment\n+! statement.\n+!\n+! Contributed by Jonathan Hogg  <jhogg41@gmail.com>\n+!\n+module mymod\n+   implicit none\n+\n+   integer :: next = 0\n+\n+   type :: mytype\n+      integer :: idx = -1\n+   contains\n+      procedure :: mytype_assign\n+      generic :: assignment(=) => mytype_assign\n+      final :: mytype_final\n+   end type mytype\n+\n+contains\n+   subroutine mytype_assign(this, other)\n+      class(mytype), intent(inout) :: this\n+      class(mytype), intent(in) :: other\n+\n+      this%idx = next\n+      next = next + 1\n+   end subroutine mytype_assign\n+\n+   subroutine mytype_final(this)\n+      type(mytype) :: this\n+      next = next + 1\n+      if (this%idx /= 0) stop 1 ! finalize 'create_mtype' result\n+   end subroutine mytype_final\n+\n+   type(mytype) function create_mytype()\n+      create_mytype%idx = next\n+      next = next + 1\n+   end function create_mytype\n+\n+end module mymod\n+\n+program test\n+   use mymod\n+   implicit none\n+\n+   type(mytype) :: x\n+\n+   x = create_mytype()\n+   if (x%idx /= 1) stop 2       ! Defined assignment failed\n+   if (next /= 3) stop 3        ! Used to give 2 because finalization did not occur\n+end program test"}, {"sha": "b55ec8515c120d66205ae2fa1b76fe411783facb", "filename": "gcc/testsuite/gfortran.dg/finalize_43.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_43.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_43.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_43.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR80524, where gfortran on issued one final call\n+! For 'u' going out of scope. Two further call should be emitted; one\n+! for the lhs of the assignment in 's' and the other for the function\n+! result, which occurs after assignment.\n+!\n+! Contributed by Andrew Wood  <andrew@fluidgravity.co.uk>\n+!\n+MODULE m1\n+   IMPLICIT NONE\n+   integer :: counter = 0\n+   integer :: fval = 0\n+   TYPE t\n+      INTEGER :: i\n+      CONTAINS\n+         FINAL :: t_final\n+   END TYPE t\n+   CONTAINS\n+      SUBROUTINE t_final(this)\n+         TYPE(t) :: this\n+         counter = counter + 1\n+      END SUBROUTINE\n+      FUNCTION new_t()\n+         TYPE(t) :: new_t\n+         new_t%i = 1\n+         fval = new_t%i\n+         if (counter /= 0) stop 1   ! Finalization of 'var' after evaluation of 'expr'\n+      END FUNCTION new_t\n+      SUBROUTINE s\n+         TYPE(t) :: u\n+         u = new_t()\n+         if (counter /= 2) stop 2   ! Finalization of 'var' and 'expr'\n+      END SUBROUTINE s\n+END MODULE m1\n+PROGRAM prog\n+   USE m1\n+   IMPLICIT NONE\n+   CALL s\n+   if (counter /= 3) stop 3         ! Finalization of 'u' in 's'\n+END PROGRAM prog"}, {"sha": "a7683ae792e13c8e41e93d0a191e4988ff826241", "filename": "gcc/testsuite/gfortran.dg/finalize_44.f90", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_44.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_44.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_44.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -0,0 +1,123 @@\n+! { dg-do run }\n+!\n+! Test the fix for all three variants of PR82996, which used to\n+! segfault in the original testcase and ICE in the testcases of\n+! comments 1 and 2.\n+!\n+! Contributed by Neil Carlson  <neil.n.carlson@gmail.com>\n+!\n+module mod0\n+  integer :: final_count_foo = 0\n+  integer :: final_count_bar = 0\n+end module mod0\n+!\n+! This is the original testcase, with a final routine 'foo' but\n+! but not in the container type 'bar1'.\n+!\n+module mod1\n+  use mod0\n+  private foo, foo_destroy\n+  type foo\n+    integer, pointer :: f(:) => null()\n+  contains\n+    final :: foo_destroy\n+  end type\n+  type bar1\n+    type(foo) :: b(2)\n+  end type\n+contains\n+  impure elemental subroutine foo_destroy(this)\n+    type(foo), intent(inout) :: this\n+    final_count_foo = final_count_foo + 1\n+    if (associated(this%f)) deallocate(this%f)\n+  end subroutine\n+end module mod1\n+!\n+! Comment 1 was the same as original, except that the\n+! 'foo' finalizer is elemental and a 'bar' finalizer is added..\n+!\n+module mod2\n+  use mod0\n+  private foo, foo_destroy, bar_destroy\n+  type foo\n+    integer, pointer :: f(:) => null()\n+  contains\n+    final :: foo_destroy\n+  end type\n+  type bar2\n+    type(foo) :: b(2)\n+  contains\n+    final :: bar_destroy\n+  end type\n+contains\n+  impure elemental subroutine foo_destroy(this)\n+    type(foo), intent(inout) :: this\n+    final_count_foo = final_count_foo + 1\n+    if (associated(this%f)) deallocate(this%f)\n+  end subroutine\n+  subroutine bar_destroy(this)\n+    type(bar2), intent(inout) :: this\n+    final_count_bar = final_count_bar + 1\n+    call foo_destroy(this%b)\n+  end subroutine\n+end module mod2\n+!\n+! Comment 2 was the same as comment 1, except that the 'foo'\n+! finalizer is no longer elemental.\n+!\n+module mod3\n+  use mod0\n+  private foo, foo_destroy, bar_destroy\n+  type foo\n+    integer, pointer :: f(:) => null()\n+  contains\n+    final :: foo_destroy\n+  end type\n+  type bar3\n+    type(foo) :: b(2)\n+  contains\n+    final :: bar_destroy\n+  end type\n+contains\n+  subroutine foo_destroy(this)\n+    type(foo), intent(inout) :: this\n+    final_count_foo = final_count_foo + 1\n+    if (associated(this%f)) deallocate(this%f)\n+  end subroutine\n+  subroutine bar_destroy(this)\n+    type(bar3), intent(inout) :: this\n+    final_count_bar = final_count_bar + 1\n+    do j = 1, size(this%b)\n+      call foo_destroy(this%b(j))\n+    end do\n+  end subroutine\n+end module mod3\n+\n+program main\n+  use mod0\n+  use mod1\n+  use mod2\n+  use mod3\n+  type(bar1) :: x\n+  type(bar2) :: y\n+  type(bar3) :: z\n+  call sub1(x)\n+  if (final_count_foo /= 2) stop 1\n+  if (final_count_bar /= 0) stop 2\n+  call sub2(y)\n+  if (final_count_foo /= 6) stop 3\n+  if (final_count_bar /= 1) stop 4\n+  call sub3(z)\n+  if (final_count_foo /= 8) stop 5\n+  if (final_count_bar /= 2) stop 6\n+contains\n+  subroutine sub1(x)\n+    type(bar1), intent(out) :: x\n+  end subroutine\n+  subroutine sub2(x)\n+    type(bar2), intent(out) :: x\n+  end subroutine\n+  subroutine sub3(x)\n+    type(bar3), intent(out) :: x\n+  end subroutine\n+end program"}, {"sha": "0819cf6e1681d569da3a62adefd32779ded9373d", "filename": "gcc/testsuite/gfortran.dg/finalize_45.f90", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_45.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_45.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_45.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -0,0 +1,132 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR84472 in which the finalizations around the\n+! assignment in 'mymain' were not happening.\n+!\n+! Contributed by Vipul Parekh  <fortranfan@outlook.com>\n+!\n+module m\n+\n+   use, intrinsic :: iso_fortran_env, only : output_unit\n+\n+   implicit none\n+\n+!   private\n+\n+   integer, public :: final_counts = 0\n+   integer, public :: assoc_counts = 0\n+\n+   type :: t\n+      private\n+      character(len=:), pointer :: m_s => null()\n+   contains\n+      private\n+      final :: final_t\n+      procedure, pass(this), public :: clean => clean_t\n+      procedure, pass(this), public :: init => init_t\n+      procedure, public :: assign_t\n+      generic, public :: ASSIGNMENT(=) => assign_t\n+   end type\n+\n+   interface t\n+      module procedure :: construct_t\n+   end interface\n+\n+   public :: t, assign_t\n+\n+contains\n+\n+   impure elemental subroutine assign_t (to, from)\n+     class(t), intent(out) :: to\n+     class(t), intent(in) :: from\n+     if (associated (from%m_s)) then\n+        allocate(to%m_s, source = from%m_s)\n+     else\n+        allocate(to%m_s, source = \"new\")\n+     endif\n+   end subroutine assign_t\n+\n+   function construct_t( name ) result(new_t)\n+\n+      ! argument list\n+      character(len=*), intent(in), optional :: name\n+      ! function result\n+      type(t) :: new_t\n+\n+      if ( present(name) ) then\n+         call new_t%init( name )\n+      end if\n+\n+   end function\n+\n+   subroutine final_t( this )\n+\n+      ! argument list\n+      type(t), intent(inout) :: this\n+\n+      final_counts = final_counts + 1\n+      if ( associated(this%m_s) ) then\n+         assoc_counts = assoc_counts + 1\n+      endif\n+      call clean_t( this )\n+\n+   end subroutine\n+\n+   subroutine clean_t( this )\n+\n+      ! argument list\n+      class(t), intent(inout) :: this\n+\n+      if ( associated(this%m_s) ) then\n+         print *, this%m_s\n+         deallocate( this%m_s )\n+      end if\n+      this%m_s => null()\n+\n+   end subroutine\n+\n+   subroutine init_t( this, mname )\n+\n+      ! argument list\n+      class(t), intent(inout)      :: this\n+      character(len=*), intent(in) :: mname\n+\n+      call this%clean()\n+      allocate(character(len(mname)) :: this%m_s)\n+      this%m_s = mname\n+\n+   end subroutine\n+\n+end module\n+   use m, only : final_counts, assoc_counts\n+   call mymain\n+! See comment below.\n+   if (final_counts /= 3) stop 1\n+   if (assoc_counts /= 2) stop 2\n+\n+contains\n+   subroutine mymain\n+\n+   use m, only : t\n+\n+   implicit none\n+\n+   character(3), allocatable, target :: myname\n+\n+   type(t) :: foo\n+\n+   call foo%init( mname=\"123\" )\n+\n+   myname = \"foo\"\n+   foo = t( myname )\n+\n+   call foo%clean()\n+\n+! NAGFOR has assoc_counts =2, which is probably correct. If nullification\n+! of the pointer component is not done in gfortran, function finalization\n+! results in a double free. TODO fix this.\n+   if (final_counts /= 2) stop 3\n+   if (assoc_counts /= 2) stop 4\n+   end\n+end\n+"}, {"sha": "cd1465e6abf8b9c95e2ff9dc42ca2f2f6e971649", "filename": "gcc/testsuite/gfortran.dg/finalize_46.f90", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_46.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_46.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_46.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -0,0 +1,92 @@\n+! { dg-do run }\n+!\n+! Test the fix for pr88735.\n+!\n+! Contributed by Martin Stein  <mscfd@gmx.net>\n+!\n+module mod\n+  implicit none\n+  type, public :: t\n+     integer, pointer :: i => NULL ()\n+     character :: myname = 'z'\n+     character :: alloc = 'n'\n+  contains\n+     procedure, public :: set\n+     generic, public :: assignment(=) => set\n+     final :: finalise\n+  end type t\n+  integer, public :: assoc_in_final = 0\n+  integer, public :: calls_to_final = 0\n+  character, public :: myname1, myname2\n+\n+contains\n+\n+  subroutine set(self, x)\n+     class(t), intent(out) :: self\n+     class(t), intent(in)  :: x\n+     if (associated(self%i)) then\n+        stop 1                               ! Default init for INTENT(OUT)\n+     endif\n+     if (associated(x%i)) then\n+        myname2 = self%myname\n+        self%i => x%i\n+        self%i = self%i + 1\n+     end if\n+end subroutine set\n+\n+  subroutine finalise(self)\n+     type(t), intent(inout) :: self\n+     calls_to_final = calls_to_final + 1\n+     myname1 = self%myname\n+     if (associated(self%i)) then\n+        assoc_in_final = assoc_in_final + 1\n+        if (self%alloc .eq. 'y') deallocate (self%i)\n+     end if\n+  end subroutine finalise\n+\n+end module mod\n+\n+program finalise_assign\n+  use mod\n+  implicit none\n+  type :: s\n+     integer :: i = 0\n+     type(t) :: x\n+  end type s\n+  type(s) :: a, b\n+  type(t) :: c\n+  a%x%myname = 'a'\n+  b%x%myname = 'b'\n+  c%myname = 'c'\n+  allocate (a%x%i)\n+  a%x%i = 123\n+  a%x%alloc = 'y'\n+\n+  b = a\n+  if (assoc_in_final /= 0) stop 2  ! b%x%i not associated before finalization\n+  if (calls_to_final /= 2) stop 3  ! One finalization call\n+  if (myname1 .ne. 'b') stop 4     ! Finalization before intent out become undefined\n+  if (myname2 .ne. 'z') stop 5     ! Intent out now default initialized\n+  if (.not.associated (b%x%i, a%x%i)) stop 6\n+\n+  allocate (c%i, source = 789)\n+  c%alloc = 'y'\n+  c = a%x\n+  if (assoc_in_final /= 1) stop 6  ! c%i is allocated prior to the assignment\n+  if (calls_to_final /= 3) stop 7  ! One finalization call for the assignment\n+  if (myname1 .ne. 'c') stop 8     ! Finalization before intent out become undefined\n+  if (myname2 .ne. 'z') stop 9     ! Intent out now default initialized\n+\n+  b = a\n+  if (assoc_in_final /= 3) stop 10 ! b%i is associated by earlier assignment\n+  if (calls_to_final /= 5) stop 11 ! One finalization call for the assignment\n+  if (myname1 .ne. 'z') stop 12    ! b%x%myname was default initialized in earlier assignment\n+  if (myname2 .ne. 'z') stop 13    ! Intent out now default initialized\n+  if (b%x%i .ne. 126) stop 14      ! Three assignments with self%x%i pointing to same target\n+  deallocate (a%x%i)\n+  if (.not.associated (b%x%i, c%i)) then\n+    stop 15                        ! ditto\n+    b%x%i =>NULL ()                ! Although not needed here, clean up\n+    c%i => NULL ()\n+  endif\n+end program finalise_assign"}, {"sha": "f1ca8bd4640b6edd18abbaa5f201cc26534b47a4", "filename": "gcc/testsuite/gfortran.dg/finalize_47.f90", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_47.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_47.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_47.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -0,0 +1,105 @@\n+! { dg-do run }\n+!\n+! Check that PR91316 is fixed. Note removal of recursive I/O.\n+!\n+! Contributed by Jose Rui Faustino de Sousa  <jrfsousa@gcc.gnu.org>\n+!\n+! NAGFOR complains correctly about the finalization of an INTENT(OUT) dummy\n+! with an impure finalization subroutine, within a pure procedure.\n+! It also complains about the finalization of final_set, which does not seem\n+! to be correct (see finalize_50.f90).\n+! Both procedures have been made impure so that this testcase runs with both\n+! compilers.\n+!\n+module final_m\n+  implicit none\n+  private\n+  public ::        &\n+    assignment(=)\n+\n+  public :: &\n+    final_t\n+\n+  public ::     &\n+    final_init, &\n+    final_set,  &\n+    final_get,  &\n+    final_end\n+\n+  type :: final_t\n+    private\n+    integer :: n = -1\n+  contains\n+    final :: final_end\n+  end type final_t\n+\n+  interface assignment(=)\n+    module procedure final_init\n+  end interface assignment(=)\n+\n+  integer, public :: final_ctr = 0\n+  integer, public :: final_res = 0\n+\n+contains\n+\n+  impure elemental subroutine final_init(this, n)\n+    type(final_t), intent(out) :: this\n+    integer,       intent(in)  :: n\n+    this%n = n\n+  end subroutine final_init\n+\n+  impure elemental function final_set(n) result(this)\n+    integer, intent(in) :: n\n+    type(final_t) :: this\n+    this%n = n\n+  end function final_set\n+\n+  elemental function final_get(this) result(n)\n+    type(final_t), intent(in) :: this\n+    integer :: n\n+    n = this%n\n+  end function final_get\n+\n+  subroutine final_end(this)\n+    type(final_t), intent(inout) :: this\n+!    print *, \"DESTROY: \", this%n !< generates illegal, recursive io in 'final_s4'\n+    final_res = this%n\n+    final_ctr = final_ctr + 1\n+    this%n = -1\n+  end subroutine final_end\n+end module final_m\n+\n+program final_p\n+  use final_m\n+  implicit none\n+  type(final_t) :: f0\n+!  call final_init(f0, 0)\n+  call final_s1()\n+  call final_s2()\n+  call final_s3()\n+  call final_s4()\n+  call final_end(f0)\n+contains\n+  subroutine final_s1()\n+    type(final_t) :: f\n+    call final_init(f, 1)\n+    print *, \"f1: \", final_get(f)\n+    if ((final_ctr .ne. 1) .or. (final_res .ne. -1)) stop 1\n+  end subroutine final_s1\n+  subroutine final_s2()\n+    type(final_t) :: f\n+    f = 2\n+    print *, \"f2: \", final_get(f)\n+    if ((final_ctr .ne. 3) .or. (final_res .ne. -1)) stop 1\n+  end subroutine final_s2\n+  subroutine final_s3()\n+    type(final_t) :: f\n+    f = final_set(3)\n+    print *, \"f3: \", final_get(f)\n+    if ((final_ctr .ne. 6) .or. (final_res .ne. 3)) stop 1\n+  end subroutine final_s3\n+  subroutine final_s4()\n+    print *, \"f4: \", final_get(final_set(4))\n+    if ((final_ctr .ne. 8) .or. (final_res .ne. 4)) stop 1\n+  end subroutine final_s4\n+end program final_p"}, {"sha": "98b5006e1d3e157946928792d0c7ca56e5dcf52c", "filename": "gcc/testsuite/gfortran.dg/finalize_48.f90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_48.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_48.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_48.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do run }\n+!\n+! Check that pr106576 is fixed. The temporary from the function result\n+! was not being finalized.\n+!\n+! Contributed by Thomas Koenig  <tkoenig@gcc.gnu.org>\n+!\n+module y\n+  implicit none\n+  type foo\n+     integer :: n\n+   contains\n+     final :: cleanup\n+  end type foo\n+  interface assignment (=)\n+     module procedure assign\n+  end interface assignment (=)\n+  character(16) :: buffer(4)\n+  integer :: buffer_count = 1\n+contains\n+\n+  subroutine assign (rop, op)\n+    type(foo), intent(inout) :: rop\n+    type(foo), intent(in) :: op\n+    rop%n = op%n + 1\n+    write (buffer(buffer_count), '(A12,I4)') \"assign\", rop%n\n+    buffer_count = buffer_count + 1\n+  end subroutine assign\n+\n+  function to_foo(n) result(res)\n+    integer, intent(in) :: n\n+    type (foo) :: res\n+    res%n = n\n+    write (buffer(buffer_count),  '(A12,I4)') \"to_foo\", res%n\n+    buffer_count = buffer_count + 1\n+  end function to_foo\n+\n+  subroutine cleanup (self)\n+    type (foo), intent(inout) :: self\n+    write (buffer(buffer_count),  '(A12,I4)') \"cleanup\", self%n\n+    buffer_count = buffer_count + 1\n+  end subroutine cleanup\n+end module y\n+\n+program memain\n+  use y\n+  implicit none\n+  character(16) :: check(4) = [\"      to_foo   3\", &\n+                               \"      assign   4\", &\n+                               \"     cleanup   3\", &\n+                               \"     cleanup   4\"]\n+  call chk\n+  if (any (buffer .ne. check)) stop 1\n+contains\n+  subroutine chk\n+    type (foo) :: a\n+    a = to_foo(3)\n+  end subroutine chk\n+end program memain"}, {"sha": "49b09f78474d6fdd3639d7853a6e3bce6c6ef214", "filename": "gcc/testsuite/gfortran.dg/finalize_49.f90", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_49.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_49.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_49.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -0,0 +1,67 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Test conformance with clause 7.5.6.3, paragraph 6 of F2018. Part of PR106576.\n+!\n+! Contributed by Damian Rouson  <damian@archaeologic.codes>\n+!\n+module finalizable_m\n+  !! This module supports the main program at the bottom of this file, which\n+  !! tests compiler conformance with clause 7.5.6.3, paragraph 6 in the Fortran\n+  !! Interpretation Document (https://j3-fortran.org/doc/year/18/18-007r1.pdf):\n+  !! \"If a specification expression in a scoping unit references\n+  !! a function, the result is finalized before execution of the executable\n+  !! constructs in the scoping unit.\"\n+  implicit none\n+\n+  private\n+  public :: finalizable_t, component\n+\n+  type finalizable_t\n+    private\n+    integer, allocatable :: component_\n+  contains\n+    final :: finalize\n+  end Type\n+\n+  interface finalizable_t\n+    module procedure construct\n+  end interface\n+\n+contains\n+\n+  pure function construct(component) result(finalizable)\n+    integer, intent(in) :: component\n+    type(finalizable_t) finalizable\n+    allocate(finalizable%component_, source = component)\n+  end function\n+\n+  pure function component(self) result(self_component)\n+    type(finalizable_t), intent(in) :: self\n+    integer self_component\n+    self_component = self%component_\n+  end function\n+\n+  pure subroutine finalize(self)\n+    type(finalizable_t), intent(inout) :: self\n+    if (allocated(self%component_)) deallocate(self%component_)\n+  end subroutine\n+\n+end module\n+\n+program specification_expression_finalization\n+  use finalizable_m, only : finalizable_t, component\n+  implicit none\n+\n+  call finalize_specification_expression_result\n+\n+contains\n+\n+  subroutine finalize_specification_expression_result\n+    real tmp(component(finalizable_t(component=1))) !! Finalizes the finalizable_t function result\n+    real eliminate_unused_variable_warning\n+    tmp = eliminate_unused_variable_warning\n+  end subroutine\n+\n+end program\n+! { dg-final { scan-tree-dump-times \"_final != 0B\" 1 \"original\" } }\n\\ No newline at end of file"}, {"sha": "1825e6bbcacd42a91e0a9e11cdc21a075a6fee37", "filename": "gcc/testsuite/gfortran.dg/finalize_50.f90", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_50.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_50.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_50.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -0,0 +1,254 @@\n+! { dg-do run }\n+!\n+! Test conformance with clause 7.5.6.3, paragraph 6 of F2018. Most of PR106576:\n+! The finalization of function results within specification expressions is tested\n+! in finalize_49.f90.\n+!\n+! Contributed by Damian Rouson  <damian@archaeologic.codes>\n+!\n+module test_result_m\n+  !! Define tests for each scenario in which the Fortran 2018\n+  !! standard mandates type finalization.\n+  implicit none\n+\n+  private\n+  public :: test_result_t, get_test_results\n+\n+  type test_result_t\n+    character(len=132) description\n+    logical outcome\n+  end type\n+\n+  type object_t\n+    integer dummy\n+  contains\n+    final :: count_finalizations\n+  end type\n+\n+  type wrapper_t\n+    private\n+    type(object_t), allocatable :: object\n+  end type\n+\n+  integer :: finalizations = 0\n+  integer, parameter :: avoid_unused_variable_warning = 1\n+\n+contains\n+\n+  function get_test_results() result(test_results)\n+    type(test_result_t), allocatable :: test_results(:)\n+\n+    test_results = [ &\n+       test_result_t(\"finalizes a non-allocatable object on the LHS of an intrinsic assignment\", lhs_object()) &\n+      ,test_result_t(\"finalizes an allocated allocatable LHS of an intrinsic assignment\", allocated_allocatable_lhs()) &\n+      ,test_result_t(\"finalizes a target when the associated pointer is deallocated\", target_deallocation()) &\n+      ,test_result_t(\"finalizes an object upon explicit deallocation\", finalize_on_deallocate()) &\n+      ,test_result_t(\"finalizes a non-pointer non-allocatable object at the END statement\", finalize_on_end()) &\n+      ,test_result_t(\"finalizes a non-pointer non-allocatable object at the end of a block construct\", block_end()) &\n+      ,test_result_t(\"finalizes a function reference on the RHS of an intrinsic assignment\", rhs_function_reference()) &\n+      ,test_result_t(\"finalizes an intent(out) derived type dummy argument\", intent_out()) &\n+      ,test_result_t(\"finalizes an allocatable component object\", allocatable_component()) &\n+    ]\n+  end function\n+\n+  function construct_object() result(object)\n+    !! Constructor for object_t\n+    type(object_t) object\n+    object % dummy = avoid_unused_variable_warning\n+  end function\n+\n+  subroutine count_finalizations(self)\n+    !! Destructor for object_t\n+    type(object_t), intent(inout) :: self\n+    finalizations = finalizations + 1\n+    self % dummy = avoid_unused_variable_warning\n+  end subroutine\n+\n+  function lhs_object() result(outcome)\n+    !! Test conformance with Fortran 2018 clause 7.5.6.3, paragraph 1 behavior:\n+    !! \"not an unallocated allocatable variable\"\n+    type(object_t) lhs, rhs\n+    logical outcome\n+    integer initial_tally\n+\n+    rhs%dummy = avoid_unused_variable_warning\n+    initial_tally = finalizations\n+    lhs = rhs ! finalizes lhs\n+    associate(finalization_tally => finalizations - initial_tally)\n+      outcome = finalization_tally==1\n+    end associate\n+  end function\n+\n+  function allocated_allocatable_lhs() result(outcome)\n+    !! Test conformance with Fortran 2018 clause 7.5.6.3, paragraph 1 behavior:\n+    !! \"allocated allocatable variable\"\n+    type(object_t), allocatable :: lhs\n+    type(object_t) rhs\n+    logical outcome\n+    integer initial_tally\n+\n+    rhs%dummy = avoid_unused_variable_warning\n+    initial_tally = finalizations\n+    allocate(lhs)\n+    lhs = rhs ! finalizes lhs\n+    associate(finalization_tally => finalizations - initial_tally)\n+      outcome = finalization_tally==1\n+    end associate\n+  end function\n+\n+  function target_deallocation() result(outcome)\n+    !! Test conformance with Fortran 2018 clause 7.5.6.3, paragraph 2 behavior:\n+    !! \"pointer is deallocated\"\n+    type(object_t), pointer :: object_ptr => null()\n+    logical outcome\n+    integer initial_tally\n+\n+    allocate(object_ptr, source=object_t(dummy=0))\n+    initial_tally = finalizations\n+    deallocate(object_ptr) ! finalizes object\n+    associate(finalization_tally => finalizations - initial_tally)\n+      outcome = finalization_tally==1\n+    end associate\n+  end function\n+\n+  function allocatable_component() result(outcome)\n+    !! Test conformance with Fortran 2018 clause 7.5.6.3, para. 2 (\"allocatable entity is deallocated\")\n+    !! + 9.7.3.2, para. 6 (\"INTENT(OUT) allocatable dummy argument is deallocated\")\n+    type(wrapper_t), allocatable :: wrapper\n+    logical outcome\n+    integer initial_tally\n+\n+    initial_tally = finalizations\n+\n+    allocate(wrapper)\n+    allocate(wrapper%object)\n+    call finalize_intent_out_component(wrapper)\n+    associate(finalization_tally => finalizations - initial_tally)\n+      outcome = finalization_tally==1\n+    end associate\n+\n+  contains\n+\n+    subroutine finalize_intent_out_component(output)\n+      type(wrapper_t), intent(out) :: output ! finalizes object component\n+      allocate(output%object)\n+      output%object%dummy = avoid_unused_variable_warning\n+    end subroutine\n+\n+  end function\n+\n+  function finalize_on_deallocate() result(outcome)\n+    !! Test conformance with Fortran 2018 clause 7.5.6.3, paragraph 2:\n+    !! \"allocatable entity is deallocated\"\n+    type(object_t), allocatable :: object\n+    logical outcome\n+    integer initial_tally\n+\n+    initial_tally = finalizations\n+    allocate(object)\n+    object%dummy = 1\n+    deallocate(object)          ! finalizes object\n+    associate(final_tally => finalizations - initial_tally)\n+      outcome = final_tally==1\n+    end associate\n+  end function\n+\n+  function finalize_on_end() result(outcome)\n+    !! Test conformance with Fortran 2018 clause 7.5.6.3, paragraph 3:\n+    !! \"before return or END statement\"\n+    logical outcome\n+    integer initial_tally\n+\n+    initial_tally = finalizations\n+    call finalize_on_end_subroutine() ! Finalizes local_obj\n+    associate(final_tally => finalizations - initial_tally)\n+      outcome = final_tally==1\n+    end associate\n+\n+  contains\n+\n+    subroutine finalize_on_end_subroutine()\n+      type(object_t) local_obj\n+      local_obj % dummy = avoid_unused_variable_warning\n+    end subroutine\n+\n+  end function\n+\n+  function block_end() result(outcome)\n+    !! Test conformance with Fortran 2018 clause  7.5.6.3, paragraph 4:\n+    !! \"termination of the BLOCK construct\"\n+    logical outcome\n+    integer initial_tally\n+\n+    initial_tally = finalizations\n+    block\n+      type(object_t) object\n+      object % dummy = avoid_unused_variable_warning\n+    end block ! Finalizes object\n+    associate(finalization_tally => finalizations - initial_tally)\n+      outcome = finalization_tally==1\n+    end associate\n+  end function\n+\n+  function rhs_function_reference() result(outcome)\n+    !! Test conformance with Fortran 2018 clause 7.5.6.3, paragraph 5 behavior:\n+    !! \"nonpointer function result\"\n+    type(object_t), allocatable :: object\n+    logical outcome\n+    integer initial_tally\n+\n+    initial_tally = finalizations\n+    object = construct_object() ! finalizes object_t result\n+    associate(finalization_tally => finalizations - initial_tally)\n+      outcome = finalization_tally==1\n+    end associate\n+  end function\n+\n+  function intent_out() result(outcome)\n+    !! Test conformance with Fortran 2018 standard clause 7.5.6.3, paragraph 7:\n+    !! \"nonpointer, nonallocatable, INTENT (OUT) dummy argument\"\n+    logical outcome\n+    type(object_t) object\n+    integer initial_tally\n+\n+    initial_tally = finalizations\n+    call finalize_intent_out_arg(object)\n+    associate(finalization_tally => finalizations - initial_tally)\n+      outcome = finalization_tally==1\n+    end associate\n+  contains\n+    subroutine finalize_intent_out_arg(output)\n+      type(object_t), intent(out) :: output ! finalizes output\n+      output%dummy = avoid_unused_variable_warning\n+    end subroutine\n+  end function\n+\n+end module test_result_m\n+\n+program main\n+  !! Test each scenario in which the Fortran 2018 standard\n+  !! requires type finalization.\n+  use test_result_m, only : test_result_t, get_test_results\n+  implicit none\n+  type(test_result_t), allocatable :: test_results(:)\n+  integer i\n+\n+  test_results = get_test_results()\n+\n+  do i=1,size(test_results)\n+    print *, report(test_results(i)%outcome), test_results(i)%description\n+  end do\n+\n+  if (any(.not.test_results%outcome)) stop \"Failing tests\"\n+\n+  if (allocated (test_results)) deallocate (test_results)\n+\n+contains\n+\n+  pure function report(outcome)\n+    logical, intent(in) :: outcome\n+    character(len=:), allocatable ::  report\n+    report = merge(\"Pass: \", \"Fail: \", outcome)\n+  end function\n+\n+end program"}, {"sha": "734463a78a59bf88d54944621d67f06bb58436b0", "filename": "gcc/testsuite/gfortran.dg/finalize_51.f90", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_51.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_51.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_51.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -0,0 +1,70 @@\n+! { dg-do run }\n+!\n+! Test assumed rank finalizers\n+!\n+module finalizable_m\n+! F2018: 7.5.6.2 para 1: \"Otherwise, if there is an elemental final\n+! subroutine whose dummy argument has the same kind type parameters\n+! as the entity being finalized, or a final subroutine whose dummy\n+! argument is assumed-rank with the same kind type parameters as the\n+! entity being finalized, it is called with the entity as an actual\n+! argument.\"\n+  implicit none\n+\n+  type finalizable_t\n+    integer :: component_\n+  contains\n+    final :: finalize\n+  end Type\n+\n+  interface finalizable_type\n+    module procedure construct0, construct1\n+  end interface\n+\n+  integer :: final_ctr = 0\n+\n+contains\n+\n+  pure function construct0(component) result(finalizable)\n+    integer, intent(in) :: component\n+    type(finalizable_t) finalizable\n+    finalizable%component_ = component\n+  end function\n+\n+  impure function construct1(component) result(finalizable)\n+    integer, intent(in), dimension(:) :: component\n+    type(finalizable_t), dimension(:), allocatable :: finalizable\n+    integer :: sz\n+    sz = size(component)\n+    allocate (finalizable (sz))\n+    finalizable%component_ = component\n+  end function\n+\n+  subroutine finalize(self)\n+    type(finalizable_t), intent(inout), dimension (..) :: self\n+    select rank (self)\n+    rank (0)\n+        print *, \"rank 0 value = \", self%component_\n+    rank (1)\n+        print *, \"rank 1 value = \", self%component_\n+    rank default\n+        print *, \"rank default\"\n+    end select\n+    final_ctr = final_ctr + 1\n+  end subroutine\n+\n+end module\n+\n+program specification_expression_finalization\n+  use finalizable_m\n+  implicit none\n+\n+  type(finalizable_t) :: a = finalizable_t (1)\n+  type(finalizable_t) :: b(2) = [finalizable_t (2), finalizable_t (3)]\n+\n+  a = finalizable_type (42)\n+  if (final_ctr .ne. 2) stop 1\n+  b = finalizable_type ([42, 43])\n+  print *, b%component_\n+\n+end program"}, {"sha": "7b27ddb2e3ba4e487c0a37f122c04e7a550c8d75", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_8.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7caf313525a46f200d7f5db1ba893f853774aee/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_8.f90?ref=d7caf313525a46f200d7f5db1ba893f853774aee", "patch": "@@ -15,5 +15,5 @@ subroutine bar(this)\n   end\n end\n \n-! { dg-final { scan-tree-dump-times \"foo.0.x._data = 0B;\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"foo.0.x._vptr = .* &__vtab__STAR;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"foo.1.x._data = 0B;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"foo.1.x._vptr = .* &__vtab__STAR;\" 1 \"original\" } }"}]}