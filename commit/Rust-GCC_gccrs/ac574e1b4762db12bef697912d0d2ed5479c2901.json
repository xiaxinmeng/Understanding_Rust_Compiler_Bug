{"sha": "ac574e1b4762db12bef697912d0d2ed5479c2901", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM1NzRlMWI0NzYyZGIxMmJlZjY5NzkxMmQwZDJlZDU0NzljMjkwMQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-03-08T13:09:15Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-03-08T13:09:15Z"}, "message": "tree-ssa-opfinalize.h: Removed.\n\n\t* tree-ssa-opfinalize.h: Removed.\n\t* Makefile.in (tree-ssa-operands.o): Remove tree-ssa-opfinalize.h\n\tdependency.\n\t* tree-ssa-operands.c: Do not include tree-ssa-opfinalize.h.\n\t(ALLOC_OPTYPE, APPEND_OP_AFTER, MOVE_HEAD_AFTER, MOVE_HEAD_TO_FREELIST,\n\tINITIALIZE_USE, add_def_op, add_use_op, add_vuse_op, add_maydef_op,\n\tadd_mustdef_op, finalize_ssa_def_ops, finalize_ssa_use_ops,\n\tfinalize_ssa_v_may_def_ops, finalize_ssa_vuse_ops,\n\tfinalize_ssa_v_must_def_ops): New.\n\nFrom-SVN: r111843", "tree": {"sha": "3c3b985f409a10aa6b4a0f00800dd02eae1f16eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c3b985f409a10aa6b4a0f00800dd02eae1f16eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac574e1b4762db12bef697912d0d2ed5479c2901", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac574e1b4762db12bef697912d0d2ed5479c2901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac574e1b4762db12bef697912d0d2ed5479c2901", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac574e1b4762db12bef697912d0d2ed5479c2901/comments", "author": null, "committer": null, "parents": [{"sha": "634a11f7bf6f032aa190aa5355a1d4eea710dc28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/634a11f7bf6f032aa190aa5355a1d4eea710dc28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/634a11f7bf6f032aa190aa5355a1d4eea710dc28"}], "stats": {"total": 785, "additions": 498, "deletions": 287}, "files": [{"sha": "2b7fcebf6bb68d04fc89c3ef80e0d560250975b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac574e1b4762db12bef697912d0d2ed5479c2901/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac574e1b4762db12bef697912d0d2ed5479c2901/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac574e1b4762db12bef697912d0d2ed5479c2901", "patch": "@@ -1,3 +1,15 @@\n+2006-03-07  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-ssa-opfinalize.h: Removed.\n+\t* Makefile.in (tree-ssa-operands.o): Remove tree-ssa-opfinalize.h\n+\tdependency.\n+\t* tree-ssa-operands.c: Do not include tree-ssa-opfinalize.h.\n+\t(ALLOC_OPTYPE, APPEND_OP_AFTER, MOVE_HEAD_AFTER, MOVE_HEAD_TO_FREELIST,\n+\tINITIALIZE_USE, add_def_op, add_use_op, add_vuse_op, add_maydef_op,\n+\tadd_mustdef_op, finalize_ssa_def_ops, finalize_ssa_use_ops,\n+\tfinalize_ssa_v_may_def_ops, finalize_ssa_vuse_ops,\n+\tfinalize_ssa_v_must_def_ops): New.\n+\n 2006-03-07  Kenneth Zadeck <zadeck@naturalbridge.com>\n \n \t* df-scan.c: (df_bb_refs_record): Fix obvious typo with wrong"}, {"sha": "1b3ff18096c20f6c7fa7004aee302a048c3fedde", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac574e1b4762db12bef697912d0d2ed5479c2901/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac574e1b4762db12bef697912d0d2ed5479c2901/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ac574e1b4762db12bef697912d0d2ed5479c2901", "patch": "@@ -1945,8 +1945,7 @@ tree-dfa.o : tree-dfa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n tree-ssa-operands.o : tree-ssa-operands.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) errors.h $(TREE_INLINE_H) \\\n    $(FLAGS_H) $(FUNCTION_H) $(TM_H) $(TIMEVAR_H) tree-pass.h toplev.h \\\n-   gt-tree-ssa-operands.h coretypes.h langhooks.h tree-ssa-opfinalize.h \\\n-   $(IPA_REFERENCE_H)\n+   gt-tree-ssa-operands.h coretypes.h langhooks.h $(IPA_REFERENCE_H)\n tree-eh.o : tree-eh.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_H) $(FLAGS_H) $(FUNCTION_H) except.h langhooks.h \\\n    $(GGC_H) tree-pass.h coretypes.h $(TIMEVAR_H) $(TM_P_H) \\"}, {"sha": "bb1ea2f4af3bb457b35f88e680fa4e3dac07eaa3", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 485, "deletions": 111, "changes": 596, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac574e1b4762db12bef697912d0d2ed5479c2901/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac574e1b4762db12bef697912d0d2ed5479c2901/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=ac574e1b4762db12bef697912d0d2ed5479c2901", "patch": "@@ -130,6 +130,19 @@ static vuse_optype_p free_vuses = NULL;\n static maydef_optype_p free_maydefs = NULL;\n static mustdef_optype_p free_mustdefs = NULL;\n \n+/* Allocates operand OP of given TYPE from the appropriate free list,\n+   or of the new value if the list is empty.  */\n+\n+#define ALLOC_OPTYPE(OP, TYPE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      TYPE##_optype_p ret = free_##TYPE##s;\t\t\\\n+      if (ret)\t\t\t\t\t\t\\\n+\tfree_##TYPE##s = ret->next;\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+\tret = ssa_operand_alloc (sizeof (*ret));\t\\\n+      (OP) = ret;\t\t\t\t\t\\\n+    } while (0) \n \n /* Return the DECL_UID of the base variable of T.  */\n \n@@ -368,24 +381,185 @@ set_virtual_use_link (use_operand_p ptr, tree stmt)\n     link_imm_use (ptr, *(ptr->use));\n }\n \n+/* Appends ELT after TO, and moves the TO pointer to ELT.  */\n+\n+#define APPEND_OP_AFTER(ELT, TO)\t\\\n+  do\t\t\t\t\t\\\n+    {\t\t\t\t\t\\\n+      (TO)->next = (ELT);\t\t\\\n+      (TO) = (ELT);\t\t\t\\\n+    } while (0)\n+\n+/* Appends head of list FROM after TO, and move both pointers\n+   to their successors.  */\n+\n+#define MOVE_HEAD_AFTER(FROM, TO)\t\\\n+  do\t\t\t\t\t\\\n+    {\t\t\t\t\t\\\n+      APPEND_OP_AFTER (FROM, TO);\t\\\n+      (FROM) = (FROM)->next;\t\t\\\n+    } while (0)\n+\n+/* Moves OP to appropriate freelist.  OP is set to its successor.  */\n+\n+#define MOVE_HEAD_TO_FREELIST(OP, TYPE)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      TYPE##_optype_p next = (OP)->next;\t\t\\\n+      (OP)->next = free_##TYPE##s;\t\t\t\\\n+      free_##TYPE##s = (OP);\t\t\t\t\\\n+      (OP) = next;\t\t\t\t\t\\\n+    } while (0)\n+\n+/* Initializes immediate use at USE_PTR to value VAL, and links it to the list\n+   of immeditate uses.  STMT is the current statement.  */\n+\n+#define INITIALIZE_USE(USE_PTR, VAL, STMT)\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      (USE_PTR)->use = (VAL);\t\t\t\t\\\n+      link_imm_use_stmt ((USE_PTR), *(VAL), (STMT));\t\\\n+    } while (0)\n+\n+/* Adds OP to the list of defs after LAST, and moves\n+   LAST to the new element.  */\n \n-#define FINALIZE_OPBUILD\t\tbuild_defs\n-#define FINALIZE_OPBUILD_BASE(I)\t(tree *)VEC_index (tree,\t\\\n-\t\t\t\t\t\t\t   build_defs, (I))\n-#define FINALIZE_OPBUILD_ELEM(I)\t(tree *)VEC_index (tree,\t\\\n-\t\t\t\t\t\t\t   build_defs, (I))\n-#define FINALIZE_FUNC\t\t\tfinalize_ssa_def_ops\n-#define FINALIZE_ALLOC\t\t\talloc_def\n-#define FINALIZE_FREE\t\t\tfree_defs\n-#define FINALIZE_TYPE\t\t\tstruct def_optype_d\n-#define FINALIZE_ELEM(PTR)\t\t((PTR)->def_ptr)\n-#define FINALIZE_OPS\t\t\tDEF_OPS\n-#define FINALIZE_BASE(VAR)\t\tVAR\n-#define FINALIZE_BASE_TYPE\t\ttree *\n-#define FINALIZE_BASE_ZERO\t\tNULL\n-#define FINALIZE_INITIALIZE(PTR, VAL, STMT)\tFINALIZE_ELEM (PTR) = (VAL)\n-#include \"tree-ssa-opfinalize.h\"\n+static inline void\n+add_def_op (tree *op, def_optype_p *last)\n+{\n+  def_optype_p new;\n+\n+  ALLOC_OPTYPE (new, def);\n+  DEF_OP_PTR (new) = op;\n+  APPEND_OP_AFTER (new, *last);  \n+}\n+\n+/* Adds OP to the list of uses of statement STMT after LAST, and moves\n+   LAST to the new element.  */\n+\n+static inline void\n+add_use_op (tree stmt, tree *op, use_optype_p *last)\n+{\n+  use_optype_p new;\n+\n+  ALLOC_OPTYPE (new, use);\n+  INITIALIZE_USE (USE_OP_PTR (new), op, stmt);\n+  APPEND_OP_AFTER (new, *last);  \n+}\n+\n+/* Adds OP to the list of vuses of statement STMT after LAST, and moves\n+   LAST to the new element.  */\n+\n+static inline void\n+add_vuse_op (tree stmt, tree op, vuse_optype_p *last)\n+{\n+  vuse_optype_p new;\n+\n+  ALLOC_OPTYPE (new, vuse);\n+  VUSE_OP (new) = op;\n+  INITIALIZE_USE (VUSE_OP_PTR (new), &VUSE_OP (new), stmt);\n+  APPEND_OP_AFTER (new, *last);  \n+}\n+\n+/* Adds OP to the list of maydefs of statement STMT after LAST, and moves\n+   LAST to the new element.  */\n+\n+static inline void\n+add_maydef_op (tree stmt, tree op, maydef_optype_p *last)\n+{\n+  maydef_optype_p new;\n+\n+  ALLOC_OPTYPE (new, maydef);\n+  MAYDEF_RESULT (new) = op;\n+  MAYDEF_OP (new) = op;\n+  INITIALIZE_USE (MAYDEF_OP_PTR (new), &MAYDEF_OP (new), stmt);\n+  APPEND_OP_AFTER (new, *last);  \n+}\n+\n+/* Adds OP to the list of mustdefs of statement STMT after LAST, and moves\n+   LAST to the new element.  */\n+\n+static inline void\n+add_mustdef_op (tree stmt, tree op, mustdef_optype_p *last)\n+{\n+  mustdef_optype_p new;\n+\n+  ALLOC_OPTYPE (new, mustdef);\n+  MUSTDEF_RESULT (new) = op;\n+  MUSTDEF_KILL (new) = op;\n+  INITIALIZE_USE (MUSTDEF_KILL_PTR (new), &MUSTDEF_KILL (new), stmt);\n+  APPEND_OP_AFTER (new, *last);\n+}\n+\n+/* Takes elements from build_defs and turns them into def operands of STMT.\n+   TODO -- Given that def operands list is not neccessarily sorted, merging\n+\t   the operands this way does not make much sense.\n+\t-- Make build_defs VEC of tree *.  */\n+\n+static inline void\n+finalize_ssa_def_ops (tree stmt)\n+{\n+  unsigned new_i;\n+  struct def_optype_d new_list;\n+  def_optype_p old_ops, ptr, last;\n+  tree *old_base;\n+\n+  new_list.next = NULL;\n+  last = &new_list;\n+\n+  old_ops = DEF_OPS (stmt);\n+\n+  new_i = 0;\n+  while (old_ops && new_i < VEC_length (tree, build_defs))\n+    {\n+      tree *new_base = (tree *) VEC_index (tree, build_defs, new_i);\n+      old_base = DEF_OP_PTR (old_ops);\n+\n+      if (old_base == new_base)\n+        {\n+\t  /* if variables are the same, reuse this node.  */\n+\t  MOVE_HEAD_AFTER (old_ops, last);\n+\t  new_i++;\n+\t}\n+      else if (old_base < new_base)\n+\t{\n+\t  /* if old is less than new, old goes to the free list.  */\n+\t  MOVE_HEAD_TO_FREELIST (old_ops, def);\n+\t}\n+      else\n+\t{\n+\t  /* This is a new operand.  */\n+\t  add_def_op (new_base, &last);\n+\t  new_i++;\n+\t}\n+    }\n+\n+  /* If there is anything remaining in the build_defs list, simply emit it.  */\n+  for ( ; new_i < VEC_length (tree, build_defs); new_i++)\n+    add_def_op ((tree *) VEC_index (tree, build_defs, new_i), &last);\n \n+  last->next = NULL;\n+\n+  /* If there is anything in the old list, free it.  */\n+  if (old_ops)\n+    {\n+      old_ops->next = free_defs;\n+      free_defs = old_ops;\n+    }\n+\n+  /* Now set the stmt's operands.  */\n+  DEF_OPS (stmt) = new_list.next;\n+\n+#ifdef ENABLE_CHECKING\n+  {\n+    unsigned x = 0;\n+    for (ptr = DEF_OPS (stmt); ptr; ptr = ptr->next)\n+      x++;\n+\n+    gcc_assert (x == VEC_length (tree, build_defs));\n+  }\n+#endif\n+}\n \n /* This routine will create stmt operands for STMT from the def build list.  */\n \n@@ -403,27 +577,79 @@ finalize_ssa_defs (tree stmt)\n   VEC_truncate (tree, build_defs, 0);\n }\n \n-#define FINALIZE_OPBUILD\tbuild_uses\n-#define FINALIZE_OPBUILD_BASE(I)\t(tree *)VEC_index (tree,\t\\\n-\t\t\t\t\t\t\t   build_uses, (I))\n-#define FINALIZE_OPBUILD_ELEM(I)\t(tree *)VEC_index (tree,\t\\\n-\t\t\t\t\t\t\t   build_uses, (I))\n-#define FINALIZE_FUNC\t\tfinalize_ssa_use_ops\n-#define FINALIZE_ALLOC\t\talloc_use\n-#define FINALIZE_FREE\t\tfree_uses\n-#define FINALIZE_TYPE\t\tstruct use_optype_d\n-#define FINALIZE_ELEM(PTR)\t((PTR)->use_ptr.use)\n-#define FINALIZE_OPS\t\tUSE_OPS\n-#define FINALIZE_USE_PTR(PTR)\tUSE_OP_PTR (PTR)\n-#define FINALIZE_CORRECT_USE\tcorrect_use_link\n-#define FINALIZE_BASE(VAR)\tVAR\n-#define FINALIZE_BASE_TYPE\ttree *\n-#define FINALIZE_BASE_ZERO\tNULL\n-#define FINALIZE_INITIALIZE(PTR, VAL, STMT)\t\t\t\t\\\n-\t\t\t\t(PTR)->use_ptr.use = (VAL);             \\\n-\t\t\t\tlink_imm_use_stmt (&((PTR)->use_ptr),   \\\n-\t\t\t\t\t\t   *(VAL), (STMT))\n-#include \"tree-ssa-opfinalize.h\"\n+/* Takes elements from build_uses and turns them into use operands of STMT.\n+   TODO -- Given that use operands list is not neccessarily sorted, merging\n+\t   the operands this way does not make much sense.\n+\t-- Make build_uses VEC of tree *.  */\n+\n+static inline void\n+finalize_ssa_use_ops (tree stmt)\n+{\n+  unsigned new_i;\n+  struct use_optype_d new_list;\n+  use_optype_p old_ops, ptr, last;\n+  tree *old_base, *new_base;\n+\n+  new_list.next = NULL;\n+  last = &new_list;\n+\n+  old_ops = USE_OPS (stmt);\n+\n+  new_i = 0;\n+  while (old_ops && new_i < VEC_length (tree, build_uses))\n+    {\n+      new_base = (tree *) VEC_index (tree, build_uses, new_i);\n+      old_base = USE_OP_PTR (old_ops)->use;\n+\n+      if (old_base == new_base)\n+        {\n+\t  /* if variables are the same, reuse this node.  */\n+\t  MOVE_HEAD_AFTER (old_ops, last);\n+\t  correct_use_link (USE_OP_PTR (last), stmt);\n+\t  new_i++;\n+\t}\n+      else if (old_base < new_base)\n+\t{\n+\t  /* if old is less than new, old goes to the free list.  */\n+\t  delink_imm_use (USE_OP_PTR (old_ops));\n+\t  MOVE_HEAD_TO_FREELIST (old_ops, use);\n+\t}\n+      else\n+\t{\n+\t  /* This is a new operand.  */\n+\t  add_use_op (stmt, new_base, &last);\n+\t  new_i++;\n+\t}\n+    }\n+\n+  /* If there is anything remaining in the build_uses list, simply emit it.  */\n+  for ( ; new_i < VEC_length (tree, build_uses); new_i++)\n+    add_use_op (stmt, (tree *) VEC_index (tree, build_uses, new_i), &last);\n+\n+  last->next = NULL;\n+\n+  /* If there is anything in the old list, free it.  */\n+  if (old_ops)\n+    {\n+      for (ptr = old_ops; ptr; ptr = ptr->next)\n+\tdelink_imm_use (USE_OP_PTR (ptr));\n+      old_ops->next = free_uses;\n+      free_uses = old_ops;\n+    }\n+\n+  /* Now set the stmt's operands.  */\n+  USE_OPS (stmt) = new_list.next;\n+\n+#ifdef ENABLE_CHECKING\n+  {\n+    unsigned x = 0;\n+    for (ptr = USE_OPS (stmt); ptr; ptr = ptr->next)\n+      x++;\n+\n+    gcc_assert (x == VEC_length (tree, build_uses));\n+  }\n+#endif\n+}\n \n /* Return a new use operand vector for STMT, comparing to OLD_OPS_P.  */\n                                                                               \n@@ -446,33 +672,82 @@ finalize_ssa_uses (tree stmt)\n   finalize_ssa_use_ops (stmt);\n   VEC_truncate (tree, build_uses, 0);\n }\n-                                                                              \n-                                                                              \n-/* Return a new V_MAY_DEF operand vector for STMT, comparing to OLD_OPS_P.  */                                                                                \n-#define FINALIZE_OPBUILD\tbuild_v_may_defs\n-#define FINALIZE_OPBUILD_ELEM(I)\tVEC_index (tree, build_v_may_defs, (I))\n-#define FINALIZE_OPBUILD_BASE(I)\tget_name_decl (VEC_index (tree,\t\\\n-\t\t\t\t\t\t\tbuild_v_may_defs, (I)))\n-#define FINALIZE_FUNC\t\tfinalize_ssa_v_may_def_ops\n-#define FINALIZE_ALLOC\t\talloc_maydef\n-#define FINALIZE_FREE\t\tfree_maydefs\n-#define FINALIZE_TYPE\t\tstruct maydef_optype_d\n-#define FINALIZE_ELEM(PTR)\tMAYDEF_RESULT (PTR)\n-#define FINALIZE_OPS\t\tMAYDEF_OPS\n-#define FINALIZE_USE_PTR(PTR)\tMAYDEF_OP_PTR (PTR)\n-#define FINALIZE_CORRECT_USE\tset_virtual_use_link\n-#define FINALIZE_BASE_ZERO\t0\n-#define FINALIZE_BASE(VAR)\tget_name_decl (VAR)\n-#define FINALIZE_BASE_TYPE\tunsigned\n-#define FINALIZE_INITIALIZE(PTR, VAL, STMT)\t\t\t\t\\\n-\t\t\t\t(PTR)->def_var = (VAL);\t\t\t\\\n-\t\t\t\t(PTR)->use_var = (VAL);\t\t\t\\\n-\t\t\t\t(PTR)->use_ptr.use = &((PTR)->use_var);\t\\\n-\t\t\t\tlink_imm_use_stmt (&((PTR)->use_ptr),\t\\\n-\t\t\t\t\t\t   (VAL), (STMT))\n-#include \"tree-ssa-opfinalize.h\"\n-                                                                              \n-                                                                              \n+\n+\n+/* Takes elements from build_v_may_defs and turns them into maydef operands of\n+   STMT.  */\n+\n+static inline void\n+finalize_ssa_v_may_def_ops (tree stmt)\n+{\n+  unsigned new_i;\n+  struct maydef_optype_d new_list;\n+  maydef_optype_p old_ops, ptr, last;\n+  tree act;\n+  unsigned old_base, new_base;\n+\n+  new_list.next = NULL;\n+  last = &new_list;\n+\n+  old_ops = MAYDEF_OPS (stmt);\n+\n+  new_i = 0;\n+  while (old_ops && new_i < VEC_length (tree, build_v_may_defs))\n+    {\n+      act = VEC_index (tree, build_v_may_defs, new_i);\n+      new_base = get_name_decl (act);\n+      old_base = get_name_decl (MAYDEF_OP (old_ops));\n+\n+      if (old_base == new_base)\n+        {\n+\t  /* if variables are the same, reuse this node.  */\n+\t  MOVE_HEAD_AFTER (old_ops, last);\n+\t  set_virtual_use_link (MAYDEF_OP_PTR (last), stmt);\n+\t  new_i++;\n+\t}\n+      else if (old_base < new_base)\n+\t{\n+\t  /* if old is less than new, old goes to the free list.  */\n+\t  delink_imm_use (MAYDEF_OP_PTR (old_ops));\n+\t  MOVE_HEAD_TO_FREELIST (old_ops, maydef);\n+\t}\n+      else\n+\t{\n+\t  /* This is a new operand.  */\n+\t  add_maydef_op (stmt, act, &last);\n+\t  new_i++;\n+\t}\n+    }\n+\n+  /* If there is anything remaining in the build_v_may_defs list, simply emit it.  */\n+  for ( ; new_i < VEC_length (tree, build_v_may_defs); new_i++)\n+    add_maydef_op (stmt, VEC_index (tree, build_v_may_defs, new_i), &last);\n+\n+  last->next = NULL;\n+\n+  /* If there is anything in the old list, free it.  */\n+  if (old_ops)\n+    {\n+      for (ptr = old_ops; ptr; ptr = ptr->next)\n+\tdelink_imm_use (MAYDEF_OP_PTR (ptr));\n+      old_ops->next = free_maydefs;\n+      free_maydefs = old_ops;\n+    }\n+\n+  /* Now set the stmt's operands.  */\n+  MAYDEF_OPS (stmt) = new_list.next;\n+\n+#ifdef ENABLE_CHECKING\n+  {\n+    unsigned x = 0;\n+    for (ptr = MAYDEF_OPS (stmt); ptr; ptr = ptr->next)\n+      x++;\n+\n+    gcc_assert (x == VEC_length (tree, build_v_may_defs));\n+  }\n+#endif\n+}\n+\n static void\n finalize_ssa_v_may_defs (tree stmt)\n {\n@@ -500,30 +775,81 @@ cleanup_v_may_defs (void)\n   VEC_truncate (tree, build_v_may_defs, 0);\n }                                                                             \n \n-                                                                              \n-#define FINALIZE_OPBUILD\tbuild_vuses\n-#define FINALIZE_OPBUILD_ELEM(I)\tVEC_index (tree, build_vuses, (I))\n-#define FINALIZE_OPBUILD_BASE(I)\tget_name_decl (VEC_index (tree,\t\\\n-\t\t\t\t\t\t\tbuild_vuses, (I)))\n-#define FINALIZE_FUNC\t\tfinalize_ssa_vuse_ops\n-#define FINALIZE_ALLOC\t\talloc_vuse\n-#define FINALIZE_FREE\t\tfree_vuses\n-#define FINALIZE_TYPE\t\tstruct vuse_optype_d\n-#define FINALIZE_ELEM(PTR)\tVUSE_OP (PTR)\n-#define FINALIZE_OPS\t\tVUSE_OPS\n-#define FINALIZE_USE_PTR(PTR)\tVUSE_OP_PTR (PTR)\n-#define FINALIZE_CORRECT_USE\tset_virtual_use_link\n-#define FINALIZE_BASE_ZERO\t0\n-#define FINALIZE_BASE(VAR)\tget_name_decl (VAR)\n-#define FINALIZE_BASE_TYPE\tunsigned\n-#define FINALIZE_INITIALIZE(PTR, VAL, STMT)\t\t\t\t\\\n-\t\t\t\t(PTR)->use_var = (VAL);\t\t\t\\\n-\t\t\t\t(PTR)->use_ptr.use = &((PTR)->use_var);\t\\\n-\t\t\t\tlink_imm_use_stmt (&((PTR)->use_ptr),\t\\\n-\t\t\t\t\t\t   (VAL), (STMT))\n-#include \"tree-ssa-opfinalize.h\"\n \n+/* Takes elements from build_vuses and turns them into vuse operands of\n+   STMT.  */\n+\n+static inline void\n+finalize_ssa_vuse_ops (tree stmt)\n+{\n+  unsigned new_i;\n+  struct vuse_optype_d new_list;\n+  vuse_optype_p old_ops, ptr, last;\n+  tree act;\n+  unsigned old_base, new_base;\n+\n+  new_list.next = NULL;\n+  last = &new_list;\n \n+  old_ops = VUSE_OPS (stmt);\n+\n+  new_i = 0;\n+  while (old_ops && new_i < VEC_length (tree, build_vuses))\n+    {\n+      act = VEC_index (tree, build_vuses, new_i);\n+      new_base = get_name_decl (act);\n+      old_base = get_name_decl (VUSE_OP (old_ops));\n+\n+      if (old_base == new_base)\n+        {\n+\t  /* if variables are the same, reuse this node.  */\n+\t  MOVE_HEAD_AFTER (old_ops, last);\n+\t  set_virtual_use_link (VUSE_OP_PTR (last), stmt);\n+\t  new_i++;\n+\t}\n+      else if (old_base < new_base)\n+\t{\n+\t  /* if old is less than new, old goes to the free list.  */\n+\t  delink_imm_use (USE_OP_PTR (old_ops));\n+\t  MOVE_HEAD_TO_FREELIST (old_ops, vuse);\n+\t}\n+      else\n+\t{\n+\t  /* This is a new operand.  */\n+\t  add_vuse_op (stmt, act, &last);\n+\t  new_i++;\n+\t}\n+    }\n+\n+  /* If there is anything remaining in the build_vuses list, simply emit it.  */\n+  for ( ; new_i < VEC_length (tree, build_vuses); new_i++)\n+    add_vuse_op (stmt, VEC_index (tree, build_vuses, new_i), &last);\n+\n+  last->next = NULL;\n+\n+  /* If there is anything in the old list, free it.  */\n+  if (old_ops)\n+    {\n+      for (ptr = old_ops; ptr; ptr = ptr->next)\n+\tdelink_imm_use (VUSE_OP_PTR (ptr));\n+      old_ops->next = free_vuses;\n+      free_vuses = old_ops;\n+    }\n+\n+  /* Now set the stmt's operands.  */\n+  VUSE_OPS (stmt) = new_list.next;\n+\n+#ifdef ENABLE_CHECKING\n+  {\n+    unsigned x = 0;\n+    for (ptr = VUSE_OPS (stmt); ptr; ptr = ptr->next)\n+      x++;\n+\n+    gcc_assert (x == VEC_length (tree, build_vuses));\n+  }\n+#endif\n+}\n+                                                                              \n /* Return a new VUSE operand vector, comparing to OLD_OPS_P.  */\n                                                                               \n static void\n@@ -590,32 +916,80 @@ finalize_ssa_vuses (tree stmt)\n   VEC_truncate (tree, build_vuses, 0);\n \n }\n-                                                                              \n-/* Return a new V_MUST_DEF operand vector for STMT, comparing to OLD_OPS_P.  */\n-                                                                              \n-#define FINALIZE_OPBUILD\tbuild_v_must_defs\n-#define FINALIZE_OPBUILD_ELEM(I)\tVEC_index (tree, build_v_must_defs, (I))\n-#define FINALIZE_OPBUILD_BASE(I)\tget_name_decl (VEC_index (tree,\t\\\n-\t\t\t\t\t\t\tbuild_v_must_defs, (I)))\n-#define FINALIZE_FUNC\t\tfinalize_ssa_v_must_def_ops\n-#define FINALIZE_ALLOC\t\talloc_mustdef\n-#define FINALIZE_FREE\t\tfree_mustdefs\n-#define FINALIZE_TYPE\t\tstruct mustdef_optype_d\n-#define FINALIZE_ELEM(PTR)\tMUSTDEF_RESULT (PTR)\n-#define FINALIZE_OPS\t\tMUSTDEF_OPS\n-#define FINALIZE_USE_PTR(PTR)\tMUSTDEF_KILL_PTR (PTR)\n-#define FINALIZE_CORRECT_USE\tset_virtual_use_link\n-#define FINALIZE_BASE_ZERO\t0\n-#define FINALIZE_BASE(VAR)\tget_name_decl (VAR)\n-#define FINALIZE_BASE_TYPE\tunsigned\n-#define FINALIZE_INITIALIZE(PTR, VAL, STMT)\t\t\t\t\\\n-\t\t\t\t(PTR)->def_var = (VAL);\t\t\t\\\n-\t\t\t\t(PTR)->kill_var = (VAL);\t\t\\\n-\t\t\t\t(PTR)->use_ptr.use = &((PTR)->kill_var);\\\n-\t\t\t\tlink_imm_use_stmt (&((PTR)->use_ptr),\t\\\n-\t\t\t\t\t\t   (VAL), (STMT))\n-#include \"tree-ssa-opfinalize.h\"\n \n+/* Takes elements from build_v_must_defs and turns them into mustdef operands of\n+   STMT.  */\n+\n+static inline void\n+finalize_ssa_v_must_def_ops (tree stmt)\n+{\n+  unsigned new_i;\n+  struct mustdef_optype_d new_list;\n+  mustdef_optype_p old_ops, ptr, last;\n+  tree act;\n+  unsigned old_base, new_base;\n+\n+  new_list.next = NULL;\n+  last = &new_list;\n+\n+  old_ops = MUSTDEF_OPS (stmt);\n+\n+  new_i = 0;\n+  while (old_ops && new_i < VEC_length (tree, build_v_must_defs))\n+    {\n+      act = VEC_index (tree, build_v_must_defs, new_i);\n+      new_base = get_name_decl (act);\n+      old_base = get_name_decl (MUSTDEF_KILL (old_ops));\n+\n+      if (old_base == new_base)\n+        {\n+\t  /* If variables are the same, reuse this node.  */\n+\t  MOVE_HEAD_AFTER (old_ops, last);\n+\t  set_virtual_use_link (MUSTDEF_KILL_PTR (last), stmt);\n+\t  new_i++;\n+\t}\n+      else if (old_base < new_base)\n+\t{\n+\t  /* If old is less than new, old goes to the free list.  */\n+\t  delink_imm_use (MUSTDEF_KILL_PTR (old_ops));\n+\t  MOVE_HEAD_TO_FREELIST (old_ops, mustdef);\n+\t}\n+      else\n+\t{\n+\t  /* This is a new operand.  */\n+\t  add_mustdef_op (stmt, act, &last);\n+\t  new_i++;\n+\t}\n+    }\n+\n+  /* If there is anything remaining in the build_v_must_defs list, simply emit it.  */\n+  for ( ; new_i < VEC_length (tree, build_v_must_defs); new_i++)\n+    add_mustdef_op (stmt, VEC_index (tree, build_v_must_defs, new_i), &last);\n+\n+  last->next = NULL;\n+\n+  /* If there is anything in the old list, free it.  */\n+  if (old_ops)\n+    {\n+      for (ptr = old_ops; ptr; ptr = ptr->next)\n+\tdelink_imm_use (MUSTDEF_KILL_PTR (ptr));\n+      old_ops->next = free_mustdefs;\n+      free_mustdefs = old_ops;\n+    }\n+\n+  /* Now set the stmt's operands.  */\n+  MUSTDEF_OPS (stmt) = new_list.next;\n+\n+#ifdef ENABLE_CHECKING\n+  {\n+    unsigned x = 0;\n+    for (ptr = MUSTDEF_OPS (stmt); ptr; ptr = ptr->next)\n+      x++;\n+\n+    gcc_assert (x == VEC_length (tree, build_v_must_defs));\n+  }\n+#endif\n+}\n \n static void\n finalize_ssa_v_must_defs (tree stmt)"}, {"sha": "cc48e9ed742da0285647d456d5fe8976ea17d7e7", "filename": "gcc/tree-ssa-opfinalize.h", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634a11f7bf6f032aa190aa5355a1d4eea710dc28/gcc%2Ftree-ssa-opfinalize.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634a11f7bf6f032aa190aa5355a1d4eea710dc28/gcc%2Ftree-ssa-opfinalize.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-opfinalize.h?ref=634a11f7bf6f032aa190aa5355a1d4eea710dc28", "patch": "@@ -1,174 +0,0 @@\n-/* SSA operand allocation and finalizing.\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 2, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to the Free\n-Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301, USA.  */\n-\n-\n-/* This file contains common code which is used by each of the 5 operand \n-   types.  Macros are defined to specify the varying components.\n-\n-   FINALIZE_FUNC - name of finalize function.\n-   FINALIZE_ALLOC - name of allocation routine.\n-   FINALIZE_FREE - name of free list.\n-   FINALIZE_TYPE - type of node.\n-   FINALIZE_OPS - Lead element in list.\n-   FINALIZE_USE_PTR - How to get the use_operand_p, if this is a use operand.\n-   FINALIZE_INITIALIZE - How to initialize an element.\n-   FINALIZE_ELEM - How to retrieve an element.\n-   FINALIZE_BASE - How to retrieve the base variable of an element.\n-   FINALIZE_BASE_TYPE - Type of the base variable.\n-   FINALIZE_OPBUILD - Opbuild array for these nodes.\n-   FINALIZE_OPBUILD_ELEM - How to get an element from the opbuild list.\n-   FINALIZE_OPBUILD_BASE - How to get an element base from the opbuild list.\n-   FINALIZE_BASE_ZERO - How to zero an element.  */\n-\n-\n-/* This routine will either pick up a node from the free list, or allocate a\n-   new one if need be.  */\n-\n-static inline FINALIZE_TYPE *\n-FINALIZE_ALLOC (void)\n-{\n-  FINALIZE_TYPE *ret;\n-  if (FINALIZE_FREE)\n-    {\n-      ret = FINALIZE_FREE;\n-      FINALIZE_FREE = FINALIZE_FREE->next;\n-    }\n-  else\n-    ret = (FINALIZE_TYPE *)ssa_operand_alloc (sizeof (FINALIZE_TYPE));\n-  return ret;\n-}\n-\n-\n-\n-/* This routine will take the new operands from FINALIZE_OPBUILD and turn them\n-   into the new operands for STMT.  All required linking and deleting is u\n-   performed here.  */\n-static inline void\n-FINALIZE_FUNC (tree stmt)\n-{\n-  unsigned new_i;\n-  FINALIZE_TYPE *old_ops, *ptr, *last;\n-  FINALIZE_BASE_TYPE old_base;\n-  FINALIZE_TYPE new_list;\n-\n-  new_list.next = NULL;\n-  last = &new_list;\n-\n-  old_ops = FINALIZE_OPS (stmt);\n-  if (old_ops)\n-    old_base = FINALIZE_BASE (FINALIZE_ELEM (old_ops));\n-  else\n-    old_base = FINALIZE_BASE_ZERO;\n-\n-  new_i = 0;\n-  while (old_ops && new_i < VEC_length (tree, FINALIZE_OPBUILD))\n-    {\n-      FINALIZE_BASE_TYPE new_base = FINALIZE_OPBUILD_BASE (new_i);\n-      if (old_base == new_base)\n-        {\n-\t  /* if variables are the same, reuse this node.  */\n-\t  last->next = old_ops;\n-\t  last = old_ops;\n-#ifdef FINALIZE_CORRECT_USE\n-\t  FINALIZE_CORRECT_USE (FINALIZE_USE_PTR (last), stmt);\n-#endif\n-\t  old_ops = old_ops->next;\n-\t  new_i++;\n-\t}\n-      else\n-        if (old_base < new_base)\n-\t  {\n-\t    /* if old is less than new, old goes to the free list.  */\n-#ifdef FINALIZE_USE_PTR\n-\t    use_operand_p use_p = FINALIZE_USE_PTR (old_ops);\n-\t    delink_imm_use (use_p);\n-#endif\n-\t    ptr = old_ops;\n-\t    old_ops = old_ops->next;\n-\t    ptr->next = FINALIZE_FREE;\n-\t    FINALIZE_FREE = ptr;\n-\t  }\n-\telse\n-\t  {\n-\t    /* This is a new operand.  */\n-\t    ptr = FINALIZE_ALLOC ();\n-\t    FINALIZE_INITIALIZE (ptr, FINALIZE_OPBUILD_ELEM (new_i), stmt);\n-\t    last->next = ptr;\n-\t    last = ptr;\n-\t    new_i++;\n-\t  }\n-      if (old_ops)\n-        old_base = FINALIZE_BASE (FINALIZE_ELEM (old_ops));\n-    }\n-\n-  /* If there is anything remaining in the opbuild list, simply emit them.  */\n-  for ( ; new_i < VEC_length (tree, FINALIZE_OPBUILD); new_i++)\n-    {\n-      ptr = FINALIZE_ALLOC ();\n-      FINALIZE_INITIALIZE (ptr, FINALIZE_OPBUILD_ELEM (new_i), stmt);\n-      last->next = ptr;\n-      last = ptr;\n-    }\n-\n-  last->next = NULL;\n-\n-  /* If there is anything in the old list, free them.  */\n-  if (old_ops)\n-    {\n-#ifdef FINALIZE_USE_PTR\n-      for (ptr = old_ops; ptr; ptr = ptr->next)\n-\t{\n-\t  use_operand_p use_p = FINALIZE_USE_PTR (ptr);\n-\t  delink_imm_use (use_p);\n-\t}\n-#endif\n-      old_ops->next = FINALIZE_FREE;\n-      FINALIZE_FREE = old_ops;\n-    }\n-\n-  /* NOw set the stmt's operands.  */\n-  FINALIZE_OPS (stmt) = new_list.next;\n-\n-#ifdef ENABLE_CHECKING\n-  {\n-    unsigned x = 0;\n-    for (ptr = FINALIZE_OPS (stmt); ptr; ptr = ptr->next)\n-      x++;\n-\n-    gcc_assert (x == VEC_length (tree, FINALIZE_OPBUILD));\n-  }\n-#endif\n-}\n-\n-#undef FINALIZE_FUNC\n-#undef FINALIZE_ALLOC\n-#undef FINALIZE_FREE\n-#undef FINALIZE_TYPE\n-#undef FINALIZE_OPS\n-#undef FINALIZE_USE_PTR\n-#undef FINALIZE_INITIALIZE\n-#undef FINALIZE_ELEM\n-#undef FINALIZE_BASE\n-#undef FINALIZE_BASE_TYPE\n-#undef FINALIZE_OPBUILD\n-#undef FINALIZE_OPBUILD_ELEM\n-#undef FINALIZE_OPBUILD_BASE\n-#undef FINALIZE_BASE_ZERO\n-#undef FINALIZE_CORRECT_USE"}]}