{"sha": "156edf21fab7dd5891c72db7ec58b38ef7d52bfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU2ZWRmMjFmYWI3ZGQ1ODkxYzcyZGI3ZWM1OGIzOGVmN2Q1MmJmYQ==", "commit": {"author": {"name": "Andrea Corallo", "email": "andrea.corallo@arm.com", "date": "2020-11-13T11:42:04Z"}, "committer": {"name": "Andrea Corallo", "email": "andrea.corallo@arm.com", "date": "2020-11-13T14:45:48Z"}, "message": "arm: Make use of RTL predicates\n\n2020-11-13  Andrea Corallo  <andrea.corallo@arm.com>\n\n\t* config/arm/aarch-common.c (aarch_accumulator_forwarding): Use\n\tRTL predicates where possible.\n\t* config/arm/arm.c (legitimate_pic_operand_p)\n\t(legitimize_pic_address, arm_is_segment_info_known)\n\t(can_avoid_literal_pool_for_label_p)\n\t(thumb1_legitimate_address_p, arm_legitimize_address)\n\t(arm_tls_referenced_p, thumb_legitimate_constant_p)\n\t(REG_OR_SUBREG_REG, thumb1_rtx_costs, thumb1_size_rtx_costs)\n\t(arm_adjust_cost, arm_coproc_mem_operand_wb)\n\t(neon_vector_mem_operand, neon_struct_mem_operand)\n\t(symbol_mentioned_p, label_mentioned_p, )\n\t(load_multiple_sequence, store_multiple_sequence)\n\t(arm_select_cc_mode, arm_reload_in_hi, arm_reload_out_hi)\n\t(mem_ok_for_ldrd_strd, arm_emit_call_insn, output_move_neon)\n\t(arm_attr_length_move_neon, arm_assemble_integer)\n\t(arm_emit_coreregs_64bit_shift, arm_valid_symbolic_address_p)\n\t(extract_base_offset_in_addr, fusion_load_store): Likewise.", "tree": {"sha": "acd1ad2390cbfc9a9ae63d1d0a73e7bf9b3d4717", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acd1ad2390cbfc9a9ae63d1d0a73e7bf9b3d4717"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/156edf21fab7dd5891c72db7ec58b38ef7d52bfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/156edf21fab7dd5891c72db7ec58b38ef7d52bfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/156edf21fab7dd5891c72db7ec58b38ef7d52bfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/156edf21fab7dd5891c72db7ec58b38ef7d52bfa/comments", "author": {"login": "AndreaCorallo", "id": 6765576, "node_id": "MDQ6VXNlcjY3NjU1NzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6765576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AndreaCorallo", "html_url": "https://github.com/AndreaCorallo", "followers_url": "https://api.github.com/users/AndreaCorallo/followers", "following_url": "https://api.github.com/users/AndreaCorallo/following{/other_user}", "gists_url": "https://api.github.com/users/AndreaCorallo/gists{/gist_id}", "starred_url": "https://api.github.com/users/AndreaCorallo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AndreaCorallo/subscriptions", "organizations_url": "https://api.github.com/users/AndreaCorallo/orgs", "repos_url": "https://api.github.com/users/AndreaCorallo/repos", "events_url": "https://api.github.com/users/AndreaCorallo/events{/privacy}", "received_events_url": "https://api.github.com/users/AndreaCorallo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "AndreaCorallo", "id": 6765576, "node_id": "MDQ6VXNlcjY3NjU1NzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6765576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AndreaCorallo", "html_url": "https://github.com/AndreaCorallo", "followers_url": "https://api.github.com/users/AndreaCorallo/followers", "following_url": "https://api.github.com/users/AndreaCorallo/following{/other_user}", "gists_url": "https://api.github.com/users/AndreaCorallo/gists{/gist_id}", "starred_url": "https://api.github.com/users/AndreaCorallo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AndreaCorallo/subscriptions", "organizations_url": "https://api.github.com/users/AndreaCorallo/orgs", "repos_url": "https://api.github.com/users/AndreaCorallo/repos", "events_url": "https://api.github.com/users/AndreaCorallo/events{/privacy}", "received_events_url": "https://api.github.com/users/AndreaCorallo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47923622c663ffad8b14aa93706183290d4f6791", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47923622c663ffad8b14aa93706183290d4f6791", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47923622c663ffad8b14aa93706183290d4f6791"}], "stats": {"total": 92, "additions": 46, "deletions": 46}, "files": [{"sha": "e7b13f00fb49057f604ed7173c96d70e07dc22a3", "filename": "gcc/config/arm/aarch-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156edf21fab7dd5891c72db7ec58b38ef7d52bfa/gcc%2Fconfig%2Farm%2Faarch-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156edf21fab7dd5891c72db7ec58b38ef7d52bfa/gcc%2Fconfig%2Farm%2Faarch-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common.c?ref=156edf21fab7dd5891c72db7ec58b38ef7d52bfa", "patch": "@@ -485,7 +485,7 @@ aarch_accumulator_forwarding (rtx_insn *producer, rtx_insn *consumer)\n \treturn 0;\n     }\n \n-  if (GET_CODE (accumulator) == SUBREG)\n+  if (SUBREG_P (accumulator))\n     accumulator = SUBREG_REG (accumulator);\n \n   if (!REG_P (accumulator))"}, {"sha": "04190b1880a4b252a4009713e9543f34ae61ef92", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156edf21fab7dd5891c72db7ec58b38ef7d52bfa/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156edf21fab7dd5891c72db7ec58b38ef7d52bfa/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=156edf21fab7dd5891c72db7ec58b38ef7d52bfa", "patch": "@@ -7775,7 +7775,7 @@ arm_function_ok_for_sibcall (tree decl, tree exp)\n int\n legitimate_pic_operand_p (rtx x)\n {\n-  if (GET_CODE (x) == SYMBOL_REF\n+  if (SYMBOL_REF_P (x)\n       || (GET_CODE (x) == CONST\n \t  && GET_CODE (XEXP (x, 0)) == PLUS\n \t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF))\n@@ -7904,8 +7904,8 @@ legitimize_pic_address (rtx orig, machine_mode mode, rtx reg, rtx pic_reg,\n {\n   gcc_assert (compute_now == (pic_reg != NULL_RTX));\n \n-  if (GET_CODE (orig) == SYMBOL_REF\n-      || GET_CODE (orig) == LABEL_REF)\n+  if (SYMBOL_REF_P (orig)\n+      || LABEL_REF_P (orig))\n     {\n       if (reg == 0)\n \t{\n@@ -7922,8 +7922,8 @@ legitimize_pic_address (rtx orig, machine_mode mode, rtx reg, rtx pic_reg,\n       /* References to weak symbols cannot be resolved locally: they\n \t may be overridden by a non-weak definition at link time.  */\n       rtx_insn *insn;\n-      if ((GET_CODE (orig) == LABEL_REF\n-\t   || (GET_CODE (orig) == SYMBOL_REF\n+      if ((LABEL_REF_P (orig)\n+\t   || (SYMBOL_REF_P (orig)\n \t       && SYMBOL_REF_LOCAL_P (orig)\n \t       && (SYMBOL_REF_DECL (orig)\n \t\t   ? !DECL_WEAK (SYMBOL_REF_DECL (orig)) : 1)\n@@ -8177,7 +8177,7 @@ arm_is_segment_info_known (rtx orig, bool *is_readonly)\n {\n   *is_readonly = false;\n \n-  if (GET_CODE (orig) == LABEL_REF)\n+  if (LABEL_REF_P (orig))\n     {\n       *is_readonly = true;\n       return true;\n@@ -8437,7 +8437,7 @@ can_avoid_literal_pool_for_label_p (rtx x)\n      (set (reg r0) (mem (reg r0))).\n      No extra register is required, and (mem (reg r0)) won't cause the use\n      of literal pools.  */\n-  if (arm_disable_literal_pool && GET_CODE (x) == SYMBOL_REF\n+  if (arm_disable_literal_pool && SYMBOL_REF_P (x)\n       && CONSTANT_POOL_ADDRESS_P (x))\n     return 1;\n   return 0;\n@@ -8816,15 +8816,15 @@ thumb1_legitimate_address_p (machine_mode mode, rtx x, int strict_p)\n \n   /* This is PC relative data before arm_reorg runs.  */\n   else if (GET_MODE_SIZE (mode) >= 4 && CONSTANT_P (x)\n-\t   && GET_CODE (x) == SYMBOL_REF\n+\t   && SYMBOL_REF_P (x)\n \t   && CONSTANT_POOL_ADDRESS_P (x) && !flag_pic\n \t   && !arm_disable_literal_pool)\n     return 1;\n \n   /* This is PC relative data after arm_reorg runs.  */\n   else if ((GET_MODE_SIZE (mode) >= 4 || mode == HFmode)\n \t   && reload_completed\n-\t   && (GET_CODE (x) == LABEL_REF\n+\t   && (LABEL_REF_P (x)\n \t       || (GET_CODE (x) == CONST\n \t\t   && GET_CODE (XEXP (x, 0)) == PLUS\n \t\t   && GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF\n@@ -8884,7 +8884,7 @@ thumb1_legitimate_address_p (machine_mode mode, rtx x, int strict_p)\n \n   else if (GET_MODE_CLASS (mode) != MODE_FLOAT\n \t   && GET_MODE_SIZE (mode) == 4\n-\t   && GET_CODE (x) == SYMBOL_REF\n+\t   && SYMBOL_REF_P (x)\n \t   && CONSTANT_POOL_ADDRESS_P (x)\n \t   && !arm_disable_literal_pool\n \t   && ! (flag_pic\n@@ -9212,7 +9212,7 @@ arm_legitimize_address (rtx x, rtx orig_x, machine_mode mode)\n \t  x = XEXP (XEXP (x, 0), 0);\n \t}\n \n-      if (GET_CODE (x) != SYMBOL_REF)\n+      if (!SYMBOL_REF_P (x))\n \treturn x;\n \n       gcc_assert (SYMBOL_REF_TLS_MODEL (x) != 0);\n@@ -9421,7 +9421,7 @@ arm_tls_referenced_p (rtx x)\n   FOR_EACH_SUBRTX (iter, array, x, ALL)\n     {\n       const_rtx x = *iter;\n-      if (GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (x) != 0)\n+      if (SYMBOL_REF_P (x) && SYMBOL_REF_TLS_MODEL (x) != 0)\n \t{\n \t  /* ARM currently does not provide relocations to encode TLS variables\n \t     into AArch32 instructions, only data, so there is no way to\n@@ -9467,7 +9467,7 @@ thumb_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n   return (CONST_INT_P (x)\n \t  || CONST_DOUBLE_P (x)\n \t  || CONSTANT_ADDRESS_P (x)\n-\t  || (TARGET_HAVE_MOVT && GET_CODE (x) == SYMBOL_REF)\n+\t  || (TARGET_HAVE_MOVT && SYMBOL_REF_P (x))\n \t  /* On Thumb-1 without MOVT/MOVW and literal pool disabled,\n \t     we build the symbol address with upper/lower\n \t     relocations.  */\n@@ -9511,7 +9511,7 @@ arm_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n \f\n #define REG_OR_SUBREG_REG(X)\t\t\t\t\t\t\\\n   (REG_P (X)\t\t\t\t\t\t\t\\\n-   || (GET_CODE (X) == SUBREG && REG_P (SUBREG_REG (X))))\n+   || (SUBREG_P (X) && REG_P (SUBREG_REG (X))))\n \n #define REG_OR_SUBREG_RTX(X)\t\t\t\\\n    (REG_P (X) ? (X) : SUBREG_REG (X))\n@@ -9622,7 +9622,7 @@ thumb1_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n       /* Memory costs quite a lot for the first word, but subsequent words\n \t load at the equivalent of a single insn each.  */\n       return (10 + 4 * ((GET_MODE_SIZE (mode) - 1) / UNITS_PER_WORD)\n-\t      + ((GET_CODE (x) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (x))\n+\t      + ((SYMBOL_REF_P (x) && CONSTANT_POOL_ADDRESS_P (x))\n \t\t ? 4 : 0));\n \n     case IF_THEN_ELSE:\n@@ -9779,7 +9779,7 @@ thumb1_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n       return (COSTS_N_INSNS (1)\n \t      + COSTS_N_INSNS (1)\n \t\t* ((GET_MODE_SIZE (mode) - 1) / UNITS_PER_WORD)\n-              + ((GET_CODE (x) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (x))\n+              + ((SYMBOL_REF_P (x) && CONSTANT_POOL_ADDRESS_P (x))\n                  ? COSTS_N_INSNS (1) : 0));\n \n     case IF_THEN_ELSE:\n@@ -12399,7 +12399,7 @@ arm_adjust_cost (rtx_insn *insn, int dep_type, rtx_insn *dep, int cost,\n \t constant pool are cached, and that others will miss.  This is a\n \t hack.  */\n \n-      if ((GET_CODE (src_mem) == SYMBOL_REF\n+      if ((SYMBOL_REF_P (src_mem)\n \t   && CONSTANT_POOL_ADDRESS_P (src_mem))\n \t  || reg_mentioned_p (stack_pointer_rtx, src_mem)\n \t  || reg_mentioned_p (frame_pointer_rtx, src_mem)\n@@ -13234,7 +13234,7 @@ arm_coproc_mem_operand_wb (rtx op, int wb_level)\n   ind = XEXP (op, 0);\n \n   if (reload_completed\n-      && (GET_CODE (ind) == LABEL_REF\n+      && (LABEL_REF_P (ind)\n \t  || (GET_CODE (ind) == CONST\n \t      && GET_CODE (XEXP (ind, 0)) == PLUS\n \t      && GET_CODE (XEXP (XEXP (ind, 0), 0)) == LABEL_REF\n@@ -13410,7 +13410,7 @@ neon_vector_mem_operand (rtx op, int type, bool strict)\n   ind = XEXP (op, 0);\n \n   if (reload_completed\n-      && (GET_CODE (ind) == LABEL_REF\n+      && (LABEL_REF_P (ind)\n \t  || (GET_CODE (ind) == CONST\n \t      && GET_CODE (XEXP (ind, 0)) == PLUS\n \t      && GET_CODE (XEXP (XEXP (ind, 0), 0)) == LABEL_REF\n@@ -13476,7 +13476,7 @@ neon_struct_mem_operand (rtx op)\n   ind = XEXP (op, 0);\n \n   if (reload_completed\n-      && (GET_CODE (ind) == LABEL_REF\n+      && (LABEL_REF_P (ind)\n \t  || (GET_CODE (ind) == CONST\n \t      && GET_CODE (XEXP (ind, 0)) == PLUS\n \t      && GET_CODE (XEXP (XEXP (ind, 0), 0)) == LABEL_REF\n@@ -13592,7 +13592,7 @@ symbol_mentioned_p (rtx x)\n   const char * fmt;\n   int i;\n \n-  if (GET_CODE (x) == SYMBOL_REF)\n+  if (SYMBOL_REF_P (x))\n     return 1;\n \n   /* UNSPEC_TLS entries for a symbol include the SYMBOL_REF, but they\n@@ -13626,7 +13626,7 @@ label_mentioned_p (rtx x)\n   const char * fmt;\n   int i;\n \n-  if (GET_CODE (x) == LABEL_REF)\n+  if (LABEL_REF_P (x))\n     return 1;\n \n   /* UNSPEC_TLS entries for a symbol include a LABEL_REF for the referencing\n@@ -14264,11 +14264,11 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *saved_order,\n       offset = const0_rtx;\n \n       if ((REG_P (reg = XEXP (operands[nops + i], 0))\n-\t   || (GET_CODE (reg) == SUBREG\n+\t   || (SUBREG_P (reg)\n \t       && REG_P (reg = SUBREG_REG (reg))))\n \t  || (GET_CODE (XEXP (operands[nops + i], 0)) == PLUS\n \t      && ((REG_P (reg = XEXP (XEXP (operands[nops + i], 0), 0)))\n-\t\t  || (GET_CODE (reg) == SUBREG\n+\t\t  || (SUBREG_P (reg)\n \t\t      && REG_P (reg = SUBREG_REG (reg))))\n \t      && (CONST_INT_P (offset\n \t\t  = XEXP (XEXP (operands[nops + i], 0), 1)))))\n@@ -14418,11 +14418,11 @@ store_multiple_sequence (rtx *operands, int nops, int nops_total,\n       offset = const0_rtx;\n \n       if ((REG_P (reg = XEXP (operands[nops + i], 0))\n-\t   || (GET_CODE (reg) == SUBREG\n+\t   || (SUBREG_P (reg)\n \t       && REG_P (reg = SUBREG_REG (reg))))\n \t  || (GET_CODE (XEXP (operands[nops + i], 0)) == PLUS\n \t      && ((REG_P (reg = XEXP (XEXP (operands[nops + i], 0), 0)))\n-\t\t  || (GET_CODE (reg) == SUBREG\n+\t\t  || (SUBREG_P (reg)\n \t\t      && REG_P (reg = SUBREG_REG (reg))))\n \t      && (CONST_INT_P (offset\n \t\t  = XEXP (XEXP (operands[nops + i], 0), 1)))))\n@@ -15752,7 +15752,7 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n   /* A compare with a shifted operand.  Because of canonicalization, the\n      comparison will have to be swapped when we emit the assembler.  */\n   if (GET_MODE (y) == SImode\n-      && (REG_P (y) || (GET_CODE (y) == SUBREG))\n+      && (REG_P (y) || (SUBREG_P (y)))\n       && (GET_CODE (x) == ASHIFT || GET_CODE (x) == ASHIFTRT\n \t  || GET_CODE (x) == LSHIFTRT || GET_CODE (x) == ROTATE\n \t  || GET_CODE (x) == ROTATERT))\n@@ -15776,14 +15776,14 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n      non-canonical, but arm_gen_compare_reg uses this to generate the\n      correct canonical form.  */\n   if (GET_MODE (y) == SImode\n-      && (REG_P (y) || GET_CODE (y) == SUBREG)\n+      && (REG_P (y) || SUBREG_P (y))\n       && CONST_INT_P (x))\n     return CC_RSBmode;\n \n   /* This operation is performed swapped, but since we only rely on the Z\n      flag we don't need an additional mode.  */\n   if (GET_MODE (y) == SImode\n-      && (REG_P (y) || (GET_CODE (y) == SUBREG))\n+      && (REG_P (y) || (SUBREG_P (y)))\n       && GET_CODE (x) == NEG\n       && (op ==\tEQ || op == NE))\n     return CC_Zmode;\n@@ -16175,7 +16175,7 @@ arm_reload_in_hi (rtx *operands)\n   rtx base, scratch;\n   HOST_WIDE_INT offset = 0;\n \n-  if (GET_CODE (ref) == SUBREG)\n+  if (SUBREG_P (ref))\n     {\n       offset = SUBREG_BYTE (ref);\n       ref = SUBREG_REG (ref);\n@@ -16303,7 +16303,7 @@ arm_reload_out_hi (rtx *operands)\n   rtx base, scratch;\n   HOST_WIDE_INT offset = 0;\n \n-  if (GET_CODE (ref) == SUBREG)\n+  if (SUBREG_P (ref))\n     {\n       offset = SUBREG_BYTE (ref);\n       ref = SUBREG_REG (ref);\n@@ -16634,7 +16634,7 @@ mem_ok_for_ldrd_strd (rtx mem, rtx *base, rtx *offset, HOST_WIDE_INT *align)\n     return false;\n \n   /* Can't deal with subregs.  */\n-  if (GET_CODE (mem) == SUBREG)\n+  if (SUBREG_P (mem))\n     return false;\n \n   gcc_assert (MEM_P (mem));\n@@ -19534,7 +19534,7 @@ arm_emit_call_insn (rtx pat, rtx addr, bool sibcall)\n   if (TARGET_VXWORKS_RTP\n       && flag_pic\n       && !sibcall\n-      && GET_CODE (addr) == SYMBOL_REF\n+      && SYMBOL_REF_P (addr)\n       && (SYMBOL_REF_DECL (addr)\n \t  ? !targetm.binds_local_p (SYMBOL_REF_DECL (addr))\n \t  : !SYMBOL_REF_LOCAL_P (addr)))\n@@ -20381,7 +20381,7 @@ output_move_neon (rtx *operands)\n \t      }\n \t    else\n \t      {\n-\t\tif (TARGET_HAVE_MVE && GET_CODE (addr) == LABEL_REF)\n+\t\tif (TARGET_HAVE_MVE && LABEL_REF_P (addr))\n \t\t  sprintf (buff, \"v%sr.64\\t%%P0, %%1\", load ? \"ld\" : \"st\");\n \t\telse\n \t\t  sprintf (buff, \"v%sr%%?\\t%%P0, %%1\", load ? \"ld\" : \"st\");\n@@ -20392,7 +20392,7 @@ output_move_neon (rtx *operands)\n \t  {\n \t    ops[0] = gen_rtx_REG (DImode, REGNO (reg) + 2 * overlap);\n \t    ops[1] = adjust_address (mem, SImode, 8 * overlap);\n-\t    if (TARGET_HAVE_MVE && GET_CODE (addr) == LABEL_REF)\n+\t    if (TARGET_HAVE_MVE && LABEL_REF_P (addr))\n \t      sprintf (buff, \"v%sr.32\\t%%P0, %%1\", load ? \"ld\" : \"st\");\n \t    else\n \t      sprintf (buff, \"v%sr%%?\\t%%P0, %%1\", load ? \"ld\" : \"st\");\n@@ -20452,7 +20452,7 @@ arm_attr_length_move_neon (rtx_insn *insn)\n   if (GET_CODE (addr) == CONST && GET_CODE (XEXP (addr, 0)) == PLUS)\n     addr = XEXP (addr, 0);\n \n-  if (GET_CODE (addr) == LABEL_REF || GET_CODE (addr) == PLUS)\n+  if (LABEL_REF_P (addr) || GET_CODE (addr) == PLUS)\n     {\n       int insns = REG_NREGS (reg) / 2;\n       return insns * 4;\n@@ -24446,15 +24446,15 @@ arm_assemble_integer (rtx x, unsigned int size, int aligned_p)\n       /* Mark symbols as position independent.  We only do this in the\n \t .text segment, not in the .data segment.  */\n       if (NEED_GOT_RELOC && flag_pic && making_const_table &&\n-\t  (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF))\n+\t  (SYMBOL_REF_P (x) || LABEL_REF_P (x)))\n \t{\n \t  /* See legitimize_pic_address for an explanation of the\n \t     TARGET_VXWORKS_RTP check.  */\n \t  /* References to weak symbols cannot be resolved locally:\n \t     they may be overridden by a non-weak definition at link\n \t     time.  */\n \t  if (!arm_pic_data_is_text_relative\n-\t      || (GET_CODE (x) == SYMBOL_REF\n+\t      || (SYMBOL_REF_P (x)\n \t\t  && (!SYMBOL_REF_LOCAL_P (x)\n \t\t      || (SYMBOL_REF_DECL (x)\n \t\t\t  ? DECL_WEAK (SYMBOL_REF_DECL (x)) : 0)\n@@ -31620,13 +31620,13 @@ arm_emit_coreregs_64bit_shift (enum rtx_code code, rtx out, rtx in,\n \n   gcc_assert (code == ASHIFT || code == ASHIFTRT || code == LSHIFTRT);\n   gcc_assert (out\n-\t      && (REG_P (out) || GET_CODE (out) == SUBREG)\n+\t      && (REG_P (out) || SUBREG_P (out))\n \t      && GET_MODE (out) == DImode);\n   gcc_assert (in\n-\t      && (REG_P (in) || GET_CODE (in) == SUBREG)\n+\t      && (REG_P (in) || SUBREG_P (in))\n \t      && GET_MODE (in) == DImode);\n   gcc_assert (amount\n-\t      && (((REG_P (amount) || GET_CODE (amount) == SUBREG)\n+\t      && (((REG_P (amount) || SUBREG_P (amount))\n \t\t   && GET_MODE (amount) == SImode)\n \t\t  || CONST_INT_P (amount)));\n   gcc_assert (scratch1 == NULL\n@@ -31860,7 +31860,7 @@ arm_valid_symbolic_address_p (rtx addr)\n   if (target_word_relocations)\n     return false;\n \n-  if (GET_CODE (tmp) == SYMBOL_REF || GET_CODE (tmp) == LABEL_REF)\n+  if (SYMBOL_REF_P (tmp) || LABEL_REF_P (tmp))\n     return true;\n \n   /* (const (plus: symbol_ref const_int))  */\n@@ -33143,7 +33143,7 @@ extract_base_offset_in_addr (rtx mem, rtx *base, rtx *offset)\n   if (GET_CODE (addr) == CONST)\n     addr = XEXP (addr, 0);\n \n-  if (GET_CODE (addr) == REG)\n+  if (REG_P (addr))\n     {\n       *base = addr;\n       *offset = const0_rtx;\n@@ -33182,12 +33182,12 @@ fusion_load_store (rtx_insn *insn, rtx *base, rtx *offset, bool *is_load)\n \n   src = SET_SRC (x);\n   dest = SET_DEST (x);\n-  if (GET_CODE (src) == REG && GET_CODE (dest) == MEM)\n+  if (REG_P (src) && MEM_P (dest))\n     {\n       *is_load = false;\n       extract_base_offset_in_addr (dest, base, offset);\n     }\n-  else if (GET_CODE (src) == MEM && GET_CODE (dest) == REG)\n+  else if (MEM_P (src) && REG_P (dest))\n     {\n       *is_load = true;\n       extract_base_offset_in_addr (src, base, offset);"}]}