{"sha": "2bbd3819501b5be6468c34da63e4c130bb3530ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJiZDM4MTk1MDFiNWJlNjQ2OGMzNGRhNjNlNGMxMzBiYjM1MzBhZQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-18T02:47:09Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-18T02:47:09Z"}, "message": "Initial revision\n\nFrom-SVN: r208", "tree": {"sha": "4ecc96b661909ed5e7df4dfa75b411bdb5d0f364", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ecc96b661909ed5e7df4dfa75b411bdb5d0f364"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bbd3819501b5be6468c34da63e4c130bb3530ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bbd3819501b5be6468c34da63e4c130bb3530ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bbd3819501b5be6468c34da63e4c130bb3530ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bbd3819501b5be6468c34da63e4c130bb3530ae/comments", "author": null, "committer": null, "parents": [{"sha": "55485756204f7a1da52b606408bd46fff8a86298", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55485756204f7a1da52b606408bd46fff8a86298", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55485756204f7a1da52b606408bd46fff8a86298"}], "stats": {"total": 2621, "additions": 2621, "deletions": 0}, "files": [{"sha": "2839185a2798a405de6c07600a71733e6598f0e1", "filename": "gcc/c-aux-info.c", "status": "added", "additions": 661, "deletions": 0, "changes": 661, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bbd3819501b5be6468c34da63e4c130bb3530ae/gcc%2Fc-aux-info.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bbd3819501b5be6468c34da63e4c130bb3530ae/gcc%2Fc-aux-info.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-aux-info.c?ref=2bbd3819501b5be6468c34da63e4c130bb3530ae", "patch": "@@ -0,0 +1,661 @@\n+/* Generate information regarding function declarations and definitions based\n+   on information stored in GCC's tree structure.  This code implements the\n+   -fgen-aux-info option.\n+\n+   This code was written by Ron Guilmette (rfg@mcc.com).\n+\n+   Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include <sys/param.h>\n+#include <errno.h>\n+#include \"config.h\"\n+#include \"flags.h\"\n+#include \"tree.h\"\n+#include \"c-tree.h\"\n+\n+extern char* xmalloc ();\n+\n+enum formals_style_enum {\n+  ansi,\n+  k_and_r_names,\n+  k_and_r_decls\n+};\n+typedef enum formals_style_enum formals_style;\n+\n+\n+static char* data_type;\n+\n+static char * concat ();\n+static char * concat3 ();\n+static char * gen_formal_list_for_type ();\n+static int    deserves_ellipsis ();\n+static char * gen_formal_list_for_func_def ();\n+static char * gen_type ();\n+static char * gen_decl ();\n+void   gen_aux_info_record ();\n+\n+/* Virtually every UN*X system now in common use (except for pre-4.3-tahoe\n+   BSD systems) now provides getcwd as called for by POSIX.  Allow for\n+   the few exceptions to the general rule here.  */\n+\n+#if !(defined (USG) || defined (VMS))\n+extern char *getwd ();\n+#define getcwd(buf,len) getwd(buf)\n+#define GUESSPATHLEN (MAXPATHLEN + 1)\n+#else /* (defined (USG) || defined (VMS)) */\n+extern char *getcwd ();\n+/* We actually use this as a starting point, not a limit.  */\n+#define GUESSPATHLEN 100\n+#endif /* (defined (USG) || defined (VMS)) */\n+\f\n+/*  Take two strings and mash them together into a newly allocated area.  */\n+\n+static char*\n+concat (s1, s2)\n+     char* s1;\n+     char* s2;\n+{\n+  int size1, size2;\n+  char* ret_val;\n+\n+  if (!s1)\n+    s1 = \"\";\n+  if (!s2)\n+    s2 = \"\";\n+\n+  size1 = strlen (s1);\n+  size2 = strlen (s2);\n+  ret_val = xmalloc (size1 + size2 + 1);\n+  strcpy (ret_val, s1);\n+  strcpy (&ret_val[size1], s2);\n+  return ret_val;\n+}\n+\n+/*  Take three strings and mash them together into a newly allocated area.  */\n+\n+static char*\n+concat3 (s1, s2, s3)\n+     char* s1;\n+     char* s2;\n+     char* s3;\n+{\n+  int size1, size2, size3;\n+  char* ret_val;\n+\n+  if (!s1)\n+    s1 = \"\";\n+  if (!s2)\n+    s2 = \"\";\n+  if (!s3)\n+    s3 = \"\";\n+\n+  size1 = strlen (s1);\n+  size2 = strlen (s2);\n+  size3 = strlen (s3);\n+  ret_val = xmalloc (size1 + size2 + size3 + 1);\n+  strcpy (ret_val, s1);\n+  strcpy (&ret_val[size1], s2);\n+  strcpy (&ret_val[size1+size2], s3);\n+  return ret_val;\n+}\n+\n+/* Given a string representing an entire type or an entire declaration\n+   which only lacks the actual \"data-type\" specifier (at its left end),\n+   affix the data-type specifier to the left end of the given type\n+   specification or object declaration.\n+\n+   Because of C language weirdness, the data-type specifier (which normally\n+   goes in at the very left end) may have to be slipped in just to the\n+   right of any leading \"const\" or \"volatile\" qualifiers (there may be more\n+   than one).  Actually this may not be strictly necessary because it seems\n+   that GCC (at least) accepts `<data-type> const foo;' and treats it the\n+   same as `const <data-type> foo;' but people are accustomed to seeing\n+   `const char *foo;' and *not* `char const *foo;' so we try to create types\n+   that look as expected.  */\n+\n+static char*\n+affix_data_type (type_or_decl)\n+     char *type_or_decl;\n+{\n+  char *p = type_or_decl;\n+  char *qualifiers_then_data_type;\n+  char saved;\n+\n+  /* Skip as many leading const's or volatile's as there are.  */\n+\n+  for (;;)\n+    {\n+      if (!strncmp (p, \"volatile\", 8))\n+        {\n+          p += 9;\n+          continue;\n+        }\n+      if (!strncmp (p, \"const\", 5))\n+        {\n+          p += 6;\n+          continue;\n+        }\n+      break;\n+    }\n+\n+  /* p now points to the place where we can insert the data type.  We have to\n+     add a blank after the data-type of course.  */\n+\n+  if (p == type_or_decl)\n+    return concat3 (data_type, \" \", type_or_decl);\n+\n+  saved = *p;\n+  *p = '\\0';\n+  qualifiers_then_data_type = concat (type_or_decl, data_type);\n+  *p = saved;\n+  return concat3 (qualifiers_then_data_type, \" \", p);\n+}\n+\n+/* Given a tree node which represents some \"function type\", generate the\n+   source code version of a formal parameter list (of some given style) for\n+   this function type.  Return the whole formal parameter list (including\n+   a pair of surrounding parens) as a string.   Note that if the style\n+   we are currently aiming for is non-ansi, then we just return a pair\n+   of empty parens here. */\n+\n+static char*\n+gen_formal_list_for_type (fntype, style)\n+     tree fntype;\n+     formals_style style;\n+{\n+  char* formal_list = \"\";\n+  tree formal_type;\n+\n+  if (style != ansi)\n+    return \"()\";\n+\n+  formal_type = TYPE_ARG_TYPES (fntype);\n+  while (formal_type && TREE_VALUE (formal_type) != void_type_node)\n+    {\n+      char* this_type;\n+\n+      if (*formal_list)\n+        formal_list = concat (formal_list, \", \");\n+\n+      this_type = gen_type (\"\", TREE_VALUE (formal_type), ansi);\n+      formal_list =\n+          (strlen (this_type))\n+              ? concat (formal_list, affix_data_type (this_type))\n+              : concat (formal_list, data_type);\n+\n+      formal_type = TREE_CHAIN (formal_type);\n+    }\n+\n+  /* If we got to here, then we are trying to generate an ANSI style formal\n+     parameters list.\n+\n+     New style prototyped ANSI formal parameter lists should in theory always\n+     contain some stuff between the opening and closing parens, even if it is\n+     only \"void\".\n+\n+     The brutal truth though is that there is lots of old K&R code out there\n+     which contains declarations of \"pointer-to-function\" parameters and\n+     these almost never have fully specified formal parameter lists associated\n+     with them.  That is, the pointer-to-function parameters are declared\n+     with just empty parameter lists.\n+\n+     In cases such as these, protoize should really insert *something* into\n+     the vacant parameter lists, but what?  It has no basis on which to insert\n+     anything in particular.\n+\n+     Here, we make life easy for protoize by trying to distinguish between\n+     K&R empty parameter lists and new-style prototyped parameter lists\n+     that actually contain \"void\".  In the latter case we (obviously) want\n+     to output the \"void\" verbatim, and that what we do.  In the former case,\n+     we do our best to give protoize something nice to insert.\n+\n+     This \"something nice\" should be something that is still legal (when\n+     re-compiled) but something that can clearly indicate to the user that\n+     more typing information (for the parameter list) should be added (by\n+     hand) at some convenient moment.\n+\n+     The string chozen here is a comment with question marks in it.  */\n+\n+  if (!*formal_list)\n+    {\n+      if (TYPE_ARG_TYPES (fntype))\n+        /* assert (TREE_VALUE (TYPE_ARG_TYPES (fntype)) == void_type_node);  */\n+        formal_list = \"void\";\n+      else\n+        formal_list = \"/* ??? */\";\n+    }\n+  else\n+    {\n+      /* If there were at least some parameters, and if the formals-types-list\n+         petered out to a NULL (i.e. without being terminated by a\n+         void_type_node) then we need to tack on an ellipsis.  */\n+      if (!formal_type)\n+        formal_list = concat (formal_list, \", ...\");\n+    }\n+\n+  return concat3 (\" (\", formal_list, \")\");\n+}\n+\n+/* For the generation of an ANSI prototype for a function definition, we have\n+   to look at the formal parameter list of the function's own \"type\" to\n+   determine if the function's formal parameter list should end with an\n+   ellipsis.  Given a tree node, the following function will return non-zero\n+   if the \"function type\" parameter list should end with an ellipsis.  */\n+\n+static int\n+deserves_ellipsis (fntype)\n+     tree fntype;\n+{\n+  tree formal_type;\n+\n+  formal_type = TYPE_ARG_TYPES (fntype);\n+  while (formal_type && TREE_VALUE (formal_type) != void_type_node)\n+    formal_type = TREE_CHAIN (formal_type);\n+\n+  /* If there were at least some parameters, and if the formals-types-list\n+     petered out to a NULL (i.e. without being terminated by a void_type_node)\n+     then we need to tack on an ellipsis.  */\n+\n+  return (!formal_type && TYPE_ARG_TYPES (fntype));\n+}\n+\n+/* Generate a parameter list for a function definition (in some given style).\n+\n+   Note that this routine has to be separate (and different) from the code that\n+   generates the prototype parameter lists for function declarations, because\n+   in the case of a function declaration, all we have to go on is a tree node\n+   representing the function's own \"function type\".  This can tell us the types\n+   of all of the formal parameters for the function, but it cannot tell us the\n+   actual *names* of each of the formal parameters.  We need to output those\n+   parameter names for each function definition.\n+\n+   This routine gets a pointer to a tree node which represents the actual\n+   declaration of the given function, and this DECL node has a list of formal\n+   parameter (variable) declarations attached to it.  These formal parameter\n+   (variable) declaration nodes give us the actual names of the formal\n+   parameters for the given function definition.\n+\n+   This routine returns a string which is the source form for the entire\n+   function formal parameter list.  */\n+\n+static char*\n+gen_formal_list_for_func_def (fndecl, style)\n+     tree fndecl;\n+     formals_style style;\n+{\n+  char* formal_list = \"\";\n+  tree formal_decl;\n+\n+  formal_decl = DECL_ARGUMENTS (fndecl);\n+  while (formal_decl)\n+    {\n+      char *this_formal;\n+\n+      if (*formal_list && ((style == ansi) || (style == k_and_r_names)))\n+        formal_list = concat (formal_list, \", \");\n+      this_formal = gen_decl (formal_decl, 0, style);\n+      if (style == k_and_r_decls)\n+        formal_list = concat3 (formal_list, this_formal, \"; \");\n+      else\n+        formal_list = concat (formal_list, this_formal);\n+      formal_decl = TREE_CHAIN (formal_decl);\n+    }\n+  if (style == ansi)\n+    {\n+      if (!DECL_ARGUMENTS (fndecl))\n+        formal_list = concat (formal_list, \"void\");\n+      if (deserves_ellipsis (TREE_TYPE (fndecl)))\n+        formal_list = concat (formal_list, \", ...\");\n+    }\n+  if ((style == ansi) || (style == k_and_r_names))\n+    formal_list = concat3 (\" (\", formal_list, \")\");\n+  return formal_list;\n+}\n+\n+/* Generate a string which is the source code form for a given type (t).  This\n+   routine is ugly and complex because the C syntax for declarations is ugly\n+   and complex.  This routine is straightforward so long as *no* pointer types,\n+   array types, or function types are involved.\n+\n+   In the simple cases, this routine will return the (string) value which was\n+   passed in as the \"ret_val\" argument.  Usually, this starts out either as an\n+   empty string, or as the name of the declared item (i.e. the formal function\n+   parameter variable).\n+\n+   This routine will also return with the global variable \"data_type\" set to\n+   some string value which is the \"basic\" data-type of the given complete type.\n+   This \"data_type\" string can be concatenated onto the front of the returned\n+   string after this routine returns to its caller.\n+\n+   In complicated cases involving pointer types, array types, or function\n+   types, the C declaration syntax requires an \"inside out\" approach, i.e. if\n+   you have a type which is a \"pointer-to-function\" type, you need to handle\n+   the \"pointer\" part first, but it also has to be \"innermost\" (relative to\n+   the declaration stuff for the \"function\" type).  Thus, is this case, you\n+   must prepend a \"(*\" and append a \")\" to the name of the item (i.e. formal\n+   variable).  Then you must append and prepend the other info for the\n+   \"function type\" part of the overall type.\n+\n+   To handle the \"innermost precedence\" rules of complicated C declarators, we\n+   do the following (in this routine).  The input parameter called \"ret_val\"\n+   is treated as a \"seed\".  Each time gen_type is called (perhaps recursively)\n+   some additional strings may be appended or prepended (or both) to the \"seed\"\n+   string.  If yet another (lower) level of the GCC tree exists for the given\n+   type (as in the case of a pointer type, an array type, or a function type)\n+   then the (wrapped) seed is passed to a (recursive) invocation of gen_type()\n+   this recursive invocation may again \"wrap\" the (new) seed with yet more\n+   declarator stuff, by appending, prepending (or both).  By the time the\n+   recursion bottoms out, the \"seed value\" at that point will have a value\n+   which is (almost) the complete source version of the declarator (except\n+   for the data_type info).  Thus, this deepest \"seed\" value is simply passed\n+   back up through all of the recursive calls until it is given (as the return\n+   value) to the initial caller of the gen_type() routine.  All that remains\n+   to do at this point is for the initial caller to prepend the \"data_type\"\n+   string onto the returned \"seed\".  */\n+\n+static char*\n+gen_type (ret_val, t, style)\n+     char* ret_val;\n+     tree t;\n+     formals_style style;\n+{\n+  tree chain_p;\n+\n+  if (TYPE_NAME (t) && DECL_NAME (TYPE_NAME (t)))\n+    data_type = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t)));\n+  else\n+    {\n+      switch (TREE_CODE (t))\n+        {\n+        case POINTER_TYPE:\n+          if (TYPE_READONLY (t))\n+            ret_val = concat (\"const \", ret_val);\n+          if (TYPE_VOLATILE (t))\n+            ret_val = concat (\"volatile \", ret_val);\n+\n+          ret_val = concat (\"*\", ret_val);\n+\n+\t  if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE || TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n+\t    ret_val = concat3 (\"(\", ret_val, \")\");\n+\n+          ret_val = gen_type (ret_val, TREE_TYPE (t), style);\n+\n+          return ret_val;\n+\n+        case ARRAY_TYPE:\n+          ret_val = gen_type (concat (ret_val, \"[]\"), TREE_TYPE (t), style);\n+          break;\n+\n+        case FUNCTION_TYPE:\n+          ret_val = gen_type (concat (ret_val, gen_formal_list_for_type (t, style)), TREE_TYPE (t), style);\n+          break;\n+\n+        case IDENTIFIER_NODE:\n+          data_type = IDENTIFIER_POINTER (t);\n+          break;\n+\n+\t/* The following three cases are complicated by the fact that a\n+           user may do something really stupid, like creating a brand new\n+           \"anonymous\" type specification in a formal argument list (or as\n+           part of a function return type specification).  For example:\n+\n+\t\tint f (enum { red, green, blue } color);\n+\n+\t   In such cases, we have no name that we can put into the prototype\n+\t   to represent the (anonymous) type.  Thus, we have to generate the\n+\t   whole darn type specification.  Yuck!  */\n+\n+        case RECORD_TYPE:\n+\t  if (TYPE_NAME (t))\n+\t    data_type = IDENTIFIER_POINTER (TYPE_NAME (t));\n+\t  else\n+\t    {\n+\t      data_type = \"\";\n+\t      chain_p = TYPE_FIELDS (t);\n+\t      while (chain_p)\n+\t\t{\n+\t\t  data_type = concat (data_type, gen_decl (chain_p, 0, ansi));\n+\t\t  chain_p = TREE_CHAIN (chain_p);\n+\t\t  data_type = concat (data_type, \"; \");\n+\t\t}\n+\t      data_type = concat3 (\"{ \", data_type, \"}\");\n+\t    }\n+\t  data_type = concat (\"struct \", data_type);\n+\t  break;\n+\n+        case UNION_TYPE:\n+\t  if (TYPE_NAME (t))\n+\t    data_type = IDENTIFIER_POINTER (TYPE_NAME (t));\n+\t  else\n+\t    {\n+\t      data_type = \"\";\n+\t      chain_p = TYPE_FIELDS (t);\n+\t      while (chain_p)\n+\t\t{\n+\t\t  data_type = concat (data_type, gen_decl (chain_p, 0, ansi));\n+\t\t  chain_p = TREE_CHAIN (chain_p);\n+\t\t  data_type = concat (data_type, \"; \");\n+\t\t}\n+\t      data_type = concat3 (\"{ \", data_type, \"}\");\n+\t    }\n+\t  data_type = concat (\"union \", data_type);\n+\t  break;\n+\n+        case ENUMERAL_TYPE:\n+\t  if (TYPE_NAME (t))\n+\t    data_type = IDENTIFIER_POINTER (TYPE_NAME (t));\n+\t  else\n+\t    {\n+\t      data_type = \"\";\n+\t      chain_p = TYPE_VALUES (t);\n+\t      while (chain_p)\n+\t\t{\n+\t\t  data_type = concat (data_type,\n+\t\t\tIDENTIFIER_POINTER (TREE_PURPOSE (chain_p)));\n+\t\t  chain_p = TREE_CHAIN (chain_p);\n+\t\t  if (chain_p)\n+\t\t    data_type = concat (data_type, \", \");\n+\t\t}\n+\t      data_type = concat3 (\"{ \", data_type, \" }\");\n+\t    }\n+\t  data_type = concat (\"enum \", data_type);\n+\t  break;\n+\n+        case TYPE_DECL:\n+          data_type = IDENTIFIER_POINTER (DECL_NAME (t));\n+          break;\n+ \n+        case INTEGER_TYPE:\n+          data_type = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t)));\n+          /* Normally, `unsigned' is part of the deal.  Not so if it comes\n+    \t     with `const' or `volatile'.  */\n+          if (TREE_UNSIGNED (t) && (TYPE_READONLY (t) || TYPE_VOLATILE (t)))\n+    \t    data_type = concat (\"unsigned \", data_type);\n+\t  break;\n+\n+        case REAL_TYPE:\n+          data_type = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t)));\n+          break;\n+\n+        case VOID_TYPE:\n+          data_type = \"void\";\n+          break;\n+\n+        default:\n+          abort ();\n+        }\n+    }\n+  if (TYPE_READONLY (t))\n+    ret_val = concat (\"const \", ret_val);\n+  if (TYPE_VOLATILE (t))\n+    ret_val = concat (\"volatile \", ret_val);\n+  return ret_val;\n+}\n+\n+/* Generate a string (source) representation of an entire entity declaration\n+   (using some particular style for function types).\n+\n+   The given entity may be either a variable or a function.\n+\n+   If the \"is_func_definition\" parameter is non-zero, assume that the thing\n+   we are generating a declaration for is a FUNCTION_DECL node which is\n+   associated with a function definition.  In this case, we can assume that\n+   an attached list of DECL nodes for function formal arguments is present.  */\n+\n+static char*\n+gen_decl (decl, is_func_definition, style)\n+     tree decl;\n+     int is_func_definition;\n+     formals_style style;\n+{\n+  char* ret_val;\n+  char* outer_modifier = \"\";\n+\n+  if (DECL_NAME (decl))\n+    ret_val = IDENTIFIER_POINTER (DECL_NAME (decl));\n+  else\n+    ret_val = \"\";\n+\n+  /* If we are just generating a list of names of formal parameters, we can\n+     simply return the formal parameter name (with no typing information\n+     attached to it) now.  */\n+\n+  if (style == k_and_r_names)\n+    return ret_val;\n+\n+  /* Note that for the declaration of some entity (either a function or a\n+     data object, like for instance a parameter) if the entity itself was\n+     declared as either const or volatile, then const and volatile properties\n+     are associated with just the declaration of the entity, and *not* with\n+     the `type' of the entity.  Thus, for such declared entities, we have to\n+     generate the qualifiers here.  */\n+\n+  if (TREE_THIS_VOLATILE (decl))\n+    ret_val = concat (\"volatile \", ret_val);\n+  if (TREE_READONLY (decl))\n+    ret_val = concat (\"const \", ret_val);\n+\n+  data_type = \"\";\n+\n+  /* For FUNCTION_DECL nodes, there are two possible cases here.  First, if\n+     this FUNCTION_DECL node was generated from a function \"definition\", then\n+     we will have a list of DECL_NODE's, one for each of the function's formal\n+     parameters.  In this case, we can print out not only the types of each\n+     formal, but also each formal's name.  In the second case, this\n+     FUNCTION_DECL node came from an actual function declaration (and *not*\n+     a definition).  In this case, we do nothing here because the formal\n+     argument type-list will be output later, when the \"type\" of the function\n+     is added to the string we are building.  Note that the ANSI-style formal\n+     parameter list is considered to be a (suffix) part of the \"type\" of the\n+     function.  */\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL && is_func_definition)\n+    {\n+      ret_val = concat (ret_val, gen_formal_list_for_func_def (decl, ansi));\n+\n+      /* Since we have already added in the formals list stuff, here we don't\n+         add the whole \"type\" of the function we are considering (which\n+         would include its parameter-list info), rather, we only add in\n+         the \"type\" of the \"type\" of the function, which is really just\n+         the return-type of the function (and does not include the parameter\n+         list info).  */\n+\n+      ret_val = gen_type (ret_val, TREE_TYPE (TREE_TYPE (decl)), style);\n+    }\n+  else\n+    ret_val = gen_type (ret_val, TREE_TYPE (decl), style);\n+\n+  ret_val = affix_data_type (ret_val);\n+\n+  if (TREE_REGDECL (decl))\n+    ret_val = concat (\"register \", ret_val);\n+  if (TREE_PUBLIC (decl))\n+    ret_val = concat (\"extern \", ret_val);\n+  if (TREE_CODE (decl) == FUNCTION_DECL && !TREE_PUBLIC (decl))\n+    ret_val = concat (\"static \", ret_val);\n+\n+  return ret_val;\n+}\n+\n+extern FILE* aux_info_file;\n+\n+/* Generate and write a new line of info to the aux-info (.X) file.  This\n+   routine is called once for each function declaration, and once for each\n+   function definition (even the implicit ones).  */\n+\n+void\n+gen_aux_info_record (fndecl, is_definition, is_implicit, is_prototyped)\n+     tree fndecl;\n+     int is_definition;\n+     int is_implicit;\n+     int is_prototyped;\n+{\n+  if (flag_gen_aux_info)\n+    {\n+      static int compiled_from_record = 0;\n+\n+      /* Each output .X file must have a header line.  Write one now if we\n+\t have not yet done so.  */\n+\n+      if (! compiled_from_record++)\n+\t{\n+\t  int size;\n+\t  char *wd;\n+\t  char *value;\n+\n+\t  /* Read the working directory, avoiding arbitrary limit.  */\n+\t  size = GUESSPATHLEN;\n+\t  while (1)\n+\t    {\n+\t      wd = (char *) xmalloc (size);\n+\t      value = getcwd (wd, size);\n+\t      if (value != 0 || errno != ERANGE)\n+\t\tbreak;\n+\t      free (wd);\n+\t      size *= 2;\n+\t    }\n+\n+\t  if (value != 0)\n+\t    fprintf (aux_info_file, \"/* compiled from: %s */\\n\", wd);\n+\t}\n+\n+      /* Write the actual line of auxilliary info.  */\n+\n+      fprintf (aux_info_file, \"/* %s:%d:%c%c */ %s;\",\n+\t       DECL_SOURCE_FILE (fndecl),\n+\t       DECL_SOURCE_LINE (fndecl),\n+\t       (is_implicit) ? 'I' : (is_prototyped) ? 'N' : 'O',\n+\t       (is_definition) ? 'F' : 'C',\n+\t       gen_decl (fndecl, is_definition, ansi));\n+\n+      /* If this is an explicit function declaration, we need to also write\n+\t out an old-style (i.e. K&R) function header, just in case the user\n+\t wants to run unprotoize.  */\n+\n+      if (is_definition)\n+\t{\n+\t  fprintf (aux_info_file, \" /*%s %s*/\",\n+\t\t   gen_formal_list_for_func_def (fndecl, k_and_r_names),\n+\t\t   gen_formal_list_for_func_def (fndecl, k_and_r_decls));\n+\t}\n+\n+      fprintf (aux_info_file, \"\\n\");\n+    }\n+}"}, {"sha": "5f48a88c8dd4beeb34dde77825cd6a757debc118", "filename": "gcc/local-alloc.c", "status": "added", "additions": 1960, "deletions": 0, "changes": 1960, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bbd3819501b5be6468c34da63e4c130bb3530ae/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bbd3819501b5be6468c34da63e4c130bb3530ae/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=2bbd3819501b5be6468c34da63e4c130bb3530ae", "patch": "@@ -0,0 +1,1960 @@\n+/* Allocate registers within a basic block, for GNU compiler.\n+   Copyright (C) 1987, 1988, 1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Allocation of hard register numbers to pseudo registers is done in\n+   two passes.  In this pass we consider only regs that are born and\n+   die once within one basic block.  We do this one basic block at a\n+   time.  Then the next pass allocates the registers that remain.\n+   Two passes are used because this pass uses methods that work only\n+   on linear code, but that do a better job than the general methods\n+   used in global_alloc, and more quickly too.\n+\n+   The assignments made are recorded in the vector reg_renumber\n+   whose space is allocated here.  The rtl code itself is not altered.\n+\n+   We assign each instruction in the basic block a number\n+   which is its order from the beginning of the block.\n+   Then we can represent the lifetime of a pseudo register with\n+   a pair of numbers, and check for conflicts easily.\n+   We can record the availability of hard registers with a\n+   HARD_REG_SET for each instruction.  The HARD_REG_SET\n+   contains 0 or 1 for each hard reg.\n+\n+   To avoid register shuffling, we tie registers together when one\n+   dies by being copied into another, or dies in an instruction that\n+   does arithmetic to produce another.  The tied registers are\n+   allocated as one.  Registers with different reg class preferences\n+   can never be tied unless the class preferred by one is a subclass\n+   of the one preferred by the other.\n+\n+   Tying is represented with \"quantity numbers\".\n+   A non-tied register is given a new quantity number.\n+   Tied registers have the same quantity number.\n+   \n+   We have provision to exempt registers, even when they are contained\n+   within the block, that can be tied to others that are not contained in it.\n+   This is so that global_alloc could process them both and tie them then.\n+   But this is currently disabled since tying in global_alloc is not\n+   yet implemented.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"flags.h\"\n+#include \"basic-block.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"output.h\"\n+\f\n+/* Next quantity number available for allocation.  */\n+\n+static int next_qty;\n+\n+/* In all the following vectors indexed by quantity number.  */\n+\n+/* Element Q is the hard reg number chosen for quantity Q,\n+   or -1 if none was found.  */\n+\n+static short *qty_phys_reg;\n+\n+/* We maintain two hard register sets that indicate suggested hard registers\n+   for each quantity.  The first, qty_phys_copy_sugg, contains hard registers\n+   that are tied to the quantity by a simple copy.  The second contains all\n+   hard registers that are tied to the quantity via an arithmetic operation.\n+\n+   The former register set is given priority for allocation.  This tends to\n+   eliminate copy insns.  */\n+\n+/* Element Q is a set of hard registers that are suggested for quantity Q by\n+   copy insns.  */\n+\n+static HARD_REG_SET *qty_phys_copy_sugg;\n+\n+/* Element Q is a set of hard registers that are suggested for quantity Q by\n+   arithmetic insns.  */\n+\n+static HARD_REG_SET *qty_phys_sugg;\n+\n+/* Element Q is non-zero if there is a suggested register in\n+   qty_phys_copy_sugg.  */\n+\n+static char *qty_phys_has_copy_sugg;\n+\n+/* Element Q is non-zero if there is a suggested register in qty_phys_sugg. */\n+\n+static char *qty_phys_has_sugg;\n+\n+/* Element Q is the number of refs to quantity Q.  */\n+\n+static short *qty_n_refs;\n+\n+/* Element Q is a reg class contained in (smaller than) the\n+   preferred classes of all the pseudo regs that are tied in quantity Q.\n+   This is the preferred class for allocating that quantity.  */\n+\n+static enum reg_class *qty_min_class;\n+\n+/* Insn number (counting from head of basic block)\n+   where quantity Q was born.  -1 if birth has not been recorded.  */\n+\n+static int *qty_birth;\n+\n+/* Insn number (counting from head of basic block)\n+   where quantity Q died.  Due to the way tying is done,\n+   and the fact that we consider in this pass only regs that die but once,\n+   a quantity can die only once.  Each quantity's life span\n+   is a set of consecutive insns.  -1 if death has not been recorded.  */\n+\n+static int *qty_death;\n+\n+/* Number of words needed to hold the data in quantity Q.\n+   This depends on its machine mode.  It is used for these purposes:\n+   1. It is used in computing the relative importances of qtys,\n+      which determines the order in which we look for regs for them.\n+   2. It is used in rules that prevent tying several registers of\n+      different sizes in a way that is geometrically impossible\n+      (see combine_regs).  */\n+\n+static int *qty_size;\n+\n+/* This holds the mode of the registers that are tied to qty Q,\n+   or VOIDmode if registers with differing modes are tied together.  */\n+\n+static enum machine_mode *qty_mode;\n+\n+/* Number of times a reg tied to qty Q lives across a CALL_INSN.  */\n+\n+static int *qty_n_calls_crossed;\n+\n+/* Nonzero means don't allocate qty Q if we can't get its preferred class.  */\n+\n+static char *qty_preferred_or_nothing;\n+\n+/* Element Q is the SCRATCH expression for which this quantity is being\n+   allocated or 0 if this quantity is allocating registers.  */\n+\n+static rtx *qty_scratch_rtx;\n+\n+/* Element Q is the register number of one pseudo register whose\n+   reg_qty value is Q, or -1 is this quantity is for a SCRATCH.  This\n+   register should be the head of the chain maintained in reg_next_in_qty.  */\n+\n+static short *qty_first_reg;\n+\n+/* If (REG N) has been assigned a quantity number, is a register number\n+   of another register assigned the same quantity number, or -1 for the\n+   end of the chain.  qty_first_reg point to the head of this chain.  */\n+\n+static short *reg_next_in_qty;\n+\n+/* reg_qty[N] (where N is a pseudo reg number) is the qty number of that reg\n+   if it is >= 0,\n+   of -1 if this register cannot be allocated by local-alloc,\n+   or -2 if not known yet.\n+\n+   Note that if we see a use or death of pseudo register N with\n+   reg_qty[N] == -2, register N must be local to the current block.  If\n+   it were used in more than one block, we would have reg_qty[N] == -1.\n+   This relies on the fact that if reg_basic_block[N] is >= 0, register N\n+   will not appear in any other block.  We save a considerable number of\n+   tests by exploiting this.\n+\n+   If N is < FIRST_PSEUDO_REGISTER, reg_qty[N] is undefined and should not\n+   be referenced.  */\n+\n+static int *reg_qty;\n+\n+/* The offset (in words) of register N within its quantity.\n+   This can be nonzero if register N is SImode, and has been tied\n+   to a subreg of a DImode register.  */\n+\n+static char *reg_offset;\n+\n+/* Vector of substitutions of register numbers,\n+   used to map pseudo regs into hardware regs.\n+   This is set up as a result of register allocation.\n+   Element N is the hard reg assigned to pseudo reg N,\n+   or is -1 if no hard reg was assigned.\n+   If N is a hard reg number, element N is N.  */\n+\n+short *reg_renumber;\n+\n+/* Set of hard registers live at the current point in the scan\n+   of the instructions in a basic block.  */\n+\n+static HARD_REG_SET regs_live;\n+\n+/* Each set of hard registers indicates registers live at a particular\n+   point in the basic block.  For N even, regs_live_at[N] says which\n+   hard registers are needed *after* insn N/2 (i.e., they may not\n+   conflict with the outputs of insn N/2 or the inputs of insn N/2 + 1.\n+\n+   If an object is to conflict with the inputs of insn J but not the\n+   outputs of insn J + 1, we say it is born at index J*2 - 1.  Similarly,\n+   if it is to conflict with the outputs of insn J but not the inputs of\n+   insn J + 1, it is said to die at index J*2 + 1.  */\n+\n+static HARD_REG_SET *regs_live_at;\n+\n+/* Communicate local vars `insn_number' and `insn'\n+   from `block_alloc' to `reg_is_set', `wipe_dead_reg', and `alloc_qty'.  */\n+static int this_insn_number;\n+static rtx this_insn;\n+\n+static void block_alloc ();\n+static void update_equiv_regs ();\n+static int no_conflict_p ();\n+static int combine_regs ();\n+static void wipe_dead_reg ();\n+static int find_free_reg ();\n+static void reg_is_born ();\n+static void reg_is_set ();\n+static void mark_life ();\n+static void post_mark_life ();\n+static int qty_compare ();\n+static int qty_compare_1 ();\n+static int reg_meets_class_p ();\n+static void update_qty_class ();\n+static int requires_inout_p ();\n+\f\n+/* Allocate a new quantity (new within current basic block)\n+   for register number REGNO which is born at index BIRTH\n+   within the block.  MODE and SIZE are info on reg REGNO.  */\n+\n+static void\n+alloc_qty (regno, mode, size, birth)\n+     int regno;\n+     enum machine_mode mode;\n+     int size, birth;\n+{\n+  register int qty = next_qty++;\n+\n+  reg_qty[regno] = qty;\n+  reg_offset[regno] = 0;\n+  reg_next_in_qty[regno] = -1;\n+\n+  qty_first_reg[qty] = regno;\n+  qty_size[qty] = size;\n+  qty_mode[qty] = mode;\n+  qty_birth[qty] = birth;\n+  qty_n_calls_crossed[qty] = reg_n_calls_crossed[regno];\n+  qty_min_class[qty] = reg_preferred_class (regno);\n+  qty_preferred_or_nothing[qty] = reg_preferred_or_nothing (regno);\n+  qty_n_refs[qty] = reg_n_refs[regno];\n+}\n+\f\n+/* Similar to `alloc_qty', but allocates a quantity for a SCRATCH rtx\n+   used as operand N in INSN.  We assume here that the SCRATCH is used in\n+   a CLOBBER.  */\n+\n+static void\n+alloc_qty_for_scratch (scratch, n, insn, insn_code_num, insn_number)\n+     rtx scratch;\n+     int n;\n+     rtx insn;\n+     int insn_code_num, insn_number;\n+{\n+  register int qty;\n+  enum reg_class class;\n+  char *p, c;\n+  int i;\n+\n+  /* If we haven't yet computed which alternative will be used, do so now.\n+     Then set P to the constraints for that alternative.  */\n+  if (which_alternative == -1)\n+    if (! constrain_operands (insn_code_num, 0))\n+      return;\n+\n+  for (p = insn_operand_constraint[insn_code_num][n], i = 0;\n+       *p && i < which_alternative; p++)\n+    if (*p == ',')\n+      i++;\n+\n+  /* Compute the class required for this SCRATCH.  If we don't need a\n+     register, the class will remain NO_REGS.  If we guessed the alternative\n+     number incorrectly, reload will fix things up for us.  */\n+\n+  class = NO_REGS;\n+  while ((c = *p++) != '\\0' && c != ',')\n+    switch (c)\n+      {\n+      case '=':  case '+':  case '?':\n+      case '#':  case '&':  case '!':\n+      case '*':  case '%':  \n+      case '0':  case '1':  case '2':  case '3':  case '4':\n+      case 'm':  case '<':  case '>':  case 'V':  case 'o':\n+      case 'E':  case 'F':  case 'G':  case 'H':\n+      case 's':  case 'i':  case 'n':\n+      case 'I':  case 'J':  case 'K':  case 'L':\n+      case 'M':  case 'N':  case 'O':  case 'P':\n+#ifdef EXTRA_CONSTRAINT\n+      case 'Q':  case 'R':  case 'S':  case 'T':  case 'U':\n+#endif\n+      case 'p':\n+\t/* These don't say anything we care about.  */\n+\tbreak;\n+\n+      case 'X':\n+\t/* We don't need to allocate this SCRATCH.  */\n+\treturn;\n+\n+      case 'g': case 'r':\n+\tclass = reg_class_subunion[(int) class][(int) GENERAL_REGS];\n+\tbreak;\n+\n+      default:\n+\tclass\n+\t  = reg_class_subunion[(int) class][(int) REG_CLASS_FROM_LETTER (c)];\n+\tbreak;\n+      }\n+\n+  /* If CLASS has only one register, don't allocate the SCRATCH here since\n+     it will prevent that register from being used as a spill register.\n+     reload will do the allocation.  */\n+\n+  if (class == NO_REGS || reg_class_size[(int) class] == 1)\n+    return;\n+\n+  qty = next_qty++;\n+\n+  qty_first_reg[qty] = -1;\n+  qty_scratch_rtx[qty] = scratch;\n+  qty_size[qty] = GET_MODE_SIZE (GET_MODE (scratch));\n+  qty_mode[qty] = GET_MODE (scratch);\n+  qty_birth[qty] = 2 * insn_number - 1;\n+  qty_death[qty] = 2 * insn_number + 1;\n+  qty_n_calls_crossed[qty] = 0;\n+  qty_min_class[qty] = class;\n+  qty_preferred_or_nothing[qty] = 1;\n+  qty_n_refs[qty] = 1;\n+}\n+\f\n+/* Main entry point of this file.  */\n+\n+void\n+local_alloc ()\n+{\n+  register int b, i;\n+  int max_qty;\n+\n+  /* Leaf functions and non-leaf functions have different needs.\n+     If defined, let the machine say what kind of ordering we\n+     should use.  */\n+#ifdef ORDER_REGS_FOR_LOCAL_ALLOC\n+  ORDER_REGS_FOR_LOCAL_ALLOC;\n+#endif\n+\n+  /* Promote REG_EQUAL notes to REG_EQUIV notes and adjust status of affected\n+     registers.  */\n+  update_equiv_regs ();\n+\n+  /* This sets the maximum number of quantities we can have.  Quantity\n+     numbers start at zero and we can have one for each psuedo plus the\n+     number of SCRATCHs in the largest block, in the worst case.  */\n+  max_qty = (max_regno - FIRST_PSEUDO_REGISTER) + max_scratch;\n+\n+  /* Allocate vectors of temporary data.\n+     See the declarations of these variables, above,\n+     for what they mean.  */\n+\n+  qty_phys_reg = (short *) alloca (max_qty * sizeof (short));\n+  qty_phys_copy_sugg = (HARD_REG_SET *) alloca (max_qty * sizeof (HARD_REG_SET));\n+  qty_phys_has_copy_sugg = (char *) alloca (max_qty * sizeof (char));\n+  qty_phys_sugg = (HARD_REG_SET *) alloca (max_qty * sizeof (HARD_REG_SET));\n+  qty_phys_has_sugg = (char *) alloca (max_qty * sizeof (char));\n+  qty_birth = (int *) alloca (max_qty * sizeof (int));\n+  qty_death = (int *) alloca (max_qty * sizeof (int));\n+  qty_scratch_rtx = (rtx *) alloca (max_qty * sizeof (rtx));\n+  qty_first_reg = (short *) alloca (max_qty * sizeof (short));\n+  qty_size = (int *) alloca (max_qty * sizeof (int));\n+  qty_mode = (enum machine_mode *) alloca (max_qty * sizeof (enum machine_mode));\n+  qty_n_calls_crossed = (int *) alloca (max_qty * sizeof (int));\n+  qty_min_class = (enum reg_class *) alloca (max_qty * sizeof (enum reg_class));\n+  qty_preferred_or_nothing = (char *) alloca (max_qty);\n+  qty_n_refs = (short *) alloca (max_qty * sizeof (short));\n+\n+  reg_qty = (int *) alloca (max_regno * sizeof (int));\n+  reg_offset = (char *) alloca (max_regno * sizeof (char));\n+  reg_next_in_qty = (short *) alloca (max_regno * sizeof (short));\n+\n+  reg_renumber = (short *) oballoc (max_regno * sizeof (short));\n+  for (i = 0; i < max_regno; i++)\n+    reg_renumber[i] = -1;\n+\n+  /* Determine which pseudo-registers can be allocated by local-alloc.\n+     In general, these are the registers used only in a single block and\n+     which only die once.  However, if a register's preferred class has only\n+     one entry, don't allocate this register here unless it is preferred\n+     or nothing since retry_global_alloc won't be able to move it to\n+     GENERAL_REGS if a reload register of this class is needed.\n+\n+     We need not be concerned with which block actually uses the register\n+     since we will never see it outside that block.  */\n+\n+  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+    {\n+      if (reg_basic_block[i] >= 0 && reg_n_deaths[i] == 1\n+\t  && (reg_preferred_or_nothing (i)\n+\t      || reg_class_size[(int) reg_preferred_class (i)] > 1))\n+\treg_qty[i] = -2;\n+      else\n+\treg_qty[i] = -1;\n+    }\n+\n+  /* Force loop below to initialize entire quantity array.  */\n+  next_qty = max_qty;\n+\n+  /* Allocate each block's local registers, block by block.  */\n+\n+  for (b = 0; b < n_basic_blocks; b++)\n+    {\n+      /* NEXT_QTY indicates which elements of the `qty_...'\n+\t vectors might need to be initialized because they were used\n+\t for the previous block; it is set to the entire array before\n+\t block 0.  Initialize those, with explicit loop if there are few,\n+\t else with bzero and bcopy.  Do not initialize vectors that are\n+\t explicit set by `alloc_qty'.  */\n+\n+      if (next_qty < 6)\n+\t{\n+\t  for (i = 0; i < next_qty; i++)\n+\t    {\n+\t      qty_scratch_rtx[i] = 0;\n+\t      CLEAR_HARD_REG_SET (qty_phys_copy_sugg[i]);\n+\t      qty_phys_has_copy_sugg[i] = 0;\n+\t      CLEAR_HARD_REG_SET (qty_phys_sugg[i]);\n+\t      qty_phys_has_sugg[i] = 0;\n+\t    }\n+\t}\n+      else\n+\t{\n+#define CLEAR(vector)  \\\n+\t  bzero ((vector), (sizeof (*(vector))) * next_qty);\n+\n+\t  CLEAR (qty_scratch_rtx);\n+\t  CLEAR (qty_phys_copy_sugg);\n+\t  CLEAR (qty_phys_has_copy_sugg);\n+\t  CLEAR (qty_phys_sugg);\n+\t  CLEAR (qty_phys_has_sugg);\n+\t}\n+\n+      next_qty = 0;\n+\n+      block_alloc (b);\n+#ifdef USE_C_ALLOCA\n+      alloca (0);\n+#endif\n+    }\n+}\n+\f\n+/* Depth of loops we are in while in update_equiv_regs.  */\n+static int loop_depth;\n+\n+/* Used for communication between the following two functions: contains\n+   a MEM that we wish to ensure remains unchanged.  */\n+static rtx equiv_mem;\n+\n+/* Set nonzero if EQUIV_MEM is modified.  */\n+static int equiv_mem_modified;\n+\n+/* If EQUIV_MEM is modified by modifying DEST, indicate that it is modified.\n+   Called via note_stores.  */\n+\n+static void\n+validate_equiv_mem_from_store (dest, set)\n+     rtx dest;\n+     rtx set;\n+{\n+  if ((GET_CODE (dest) == REG\n+       && reg_overlap_mentioned_p (dest, equiv_mem))\n+      || (GET_CODE (dest) == MEM\n+\t  && true_dependence (dest, equiv_mem)))\n+    equiv_mem_modified = 1;\n+}\n+\n+/* Verify that no store between START and the death of REG invalidates\n+   MEMREF.  MEMREF is invalidated by modifying a register used in MEMREF,\n+   by storing into an overlapping memory location, or with a non-const\n+   CALL_INSN.\n+\n+   Return 1 if MEMREF remains valid.  */\n+\n+static int\n+validate_equiv_mem (start, reg, memref)\n+     rtx start;\n+     rtx reg;\n+     rtx memref;\n+{\n+  rtx insn;\n+  rtx note;\n+\n+  equiv_mem = memref;\n+  equiv_mem_modified = 0;\n+\n+  /* If the memory reference has side effects or is volatile, it isn't a\n+     valid equivalence.  */\n+  if (side_effects_p (memref))\n+    return 0;\n+\n+  for (insn = start; insn && ! equiv_mem_modified; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+\tcontinue;\n+\n+      if (find_reg_note (insn, REG_DEAD, reg))\n+\treturn 1;\n+\n+      if (GET_CODE (insn) == CALL_INSN && ! RTX_UNCHANGING_P (memref)\n+\t  && ! CONST_CALL_P (insn))\n+\treturn 0;\n+\n+      note_stores (PATTERN (insn), validate_equiv_mem_from_store);\n+\n+      /* If a register mentioned in MEMREF is modified via an\n+\t auto-increment, we lose the equivalence.  Do the same if one\n+\t dies; although we could extend the life, it doesn't seem worth\n+\t the trouble.  */\n+\n+      for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\tif ((REG_NOTE_KIND (note) == REG_INC\n+\t     || REG_NOTE_KIND (note) == REG_DEAD)\n+\t    && GET_CODE (XEXP (note, 0)) == REG\n+\t    && reg_overlap_mentioned_p (XEXP (note, 0), memref))\n+\t  return 0;\n+    }\n+\n+  return 0;\n+}\n+\f\n+/* TRUE if X references a memory location that would be affected by a store\n+   to MEMREF.  */\n+\n+static int\n+memref_referenced_p (memref, x)\n+     rtx x;\n+     rtx memref;\n+{\n+  int i, j;\n+  char *fmt;\n+  enum rtx_code code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case REG:\n+    case CONST_INT:\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_DOUBLE:\n+    case PC:\n+    case CC0:\n+    case HIGH:\n+    case LO_SUM:\n+      return 0;\n+\n+    case MEM:\n+      if (true_dependence (memref, x))\n+\treturn 1;\n+      break;\n+\n+    case SET:\n+      /* If we are setting a MEM, it doesn't count (its address does), but any\n+\t other SET_DEST that has a MEM in it is referencing the MEM.  */\n+      if (GET_CODE (SET_DEST (x)) == MEM)\n+\t{\n+\t  if (memref_referenced_p (memref, XEXP (SET_DEST (x), 0)))\n+\t    return 1;\n+\t}\n+      else if (memref_referenced_p (memref, SET_DEST (x)))\n+\treturn 1;\n+\n+      return memref_referenced_p (memref, SET_SRC (x));\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    switch (fmt[i])\n+      {\n+      case 'e':\n+\tif (memref_referenced_p (memref, XEXP (x, i)))\n+\t  return 1;\n+\tbreak;\n+      case 'E':\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  if (memref_referenced_p (memref, XVECEXP (x, i, j)))\n+\t    return 1;\n+\tbreak;\n+      }\n+\n+  return 0;\n+}\n+\n+/* TRUE if some insn in the range (START, END] references a memory location\n+   that would be affected by a store to MEMREF.  */\n+\n+static int\n+memref_used_between_p (memref, start, end)\n+     rtx memref;\n+     rtx start;\n+     rtx end;\n+{\n+  rtx insn;\n+\n+  for (insn = NEXT_INSN (start); insn != NEXT_INSN (end);\n+       insn = NEXT_INSN (insn))\n+    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t&& memref_referenced_p (memref, PATTERN (insn)))\n+      return 1;\n+\n+  return 0;\n+}\n+\f\n+/* INSN is a copy from SRC to DEST, both registers, and SRC does not die\n+   in INSN.\n+\n+   Search forward to see if SRC dies before either it or DEST is modified,\n+   but don't scan past the end of a basic block.  If so, we can replace SRC\n+   with DEST and let SRC die in INSN. \n+\n+   This will reduce the number of registers live in that range and may enable\n+   DEST to be tied to SRC, thus often saving one register in addition to a\n+   register-register copy.  */\n+\n+static void\n+optimize_reg_copy (insn, dest, src)\n+     rtx insn;\n+     rtx dest;\n+     rtx src;\n+{\n+  rtx p, q;\n+  rtx note;\n+  rtx dest_death = 0;\n+  int sregno = REGNO (src);\n+  int dregno = REGNO (dest);\n+\n+  if (sregno == dregno\n+#ifdef SMALL_REGISTER_CLASSES\n+      /* We don't want to mess with hard regs if register classes are small. */\n+      || sregno < FIRST_PSEUDO_REGISTER || dregno < FIRST_PSEUDO_REGISTER\n+#endif\n+      /* We don't see all updates to SP if they are in an auto-inc memory\n+\t reference, so we must disallow this optimization on them.  */\n+      || sregno == STACK_POINTER_REGNUM || dregno == STACK_POINTER_REGNUM)\n+    return;\n+\n+  for (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n+    {\n+      if (GET_CODE (p) == CODE_LABEL || GET_CODE (p) == JUMP_INSN\n+\t  || (GET_CODE (p) == NOTE\n+\t      && (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_BEG\n+\t\t  || NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)))\n+\tbreak;\n+\n+      if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n+\tcontinue;\n+\n+      if (reg_set_p (src, p) || reg_set_p (dest, p)\n+\t  /* Don't change a USE of a register.  */\n+\t  || (GET_CODE (PATTERN (p)) == USE\n+\t      && reg_overlap_mentioned_p (src, XEXP (PATTERN (p), 0))))\n+\tbreak;\n+\n+      if ((note = find_regno_note (p, REG_DEAD, sregno)) != 0)\n+\t{\n+\t  int failed = 0;\n+\t  int length = 0;\n+\t  int n_calls = 0;\n+\n+\t  /* We can do the optimization.  Scan forward from INSN again,\n+\t     replacing regs as we go.  Set FAILED if a replacement can't\n+\t     be done.  In that case, we can't move the death note for SRC.\n+\t     This should be rare.  */\n+\n+\t  /* Set to stop at next insn.  */\n+\t  for (q = next_real_insn (insn);\n+\t       q != next_real_insn (p);\n+\t       q = next_real_insn (q))\n+\t    {\n+\t      if (reg_mentioned_p (src, PATTERN (q)))\n+\t\t{\n+\t\t  if (validate_replace_rtx (src, dest, q))\n+\t\t    {\n+\t\t      /* We assume that a register is used exactly once per\n+\t\t\t insn in the updates below.  If this is not correct,\n+\t\t\t no great harm is done.  */\n+\t\t      if (sregno >= FIRST_PSEUDO_REGISTER)\n+\t\t\treg_n_refs[sregno] -= loop_depth;\n+\t\t      if (dregno >= FIRST_PSEUDO_REGISTER)\n+\t\t\treg_n_refs[dregno] += loop_depth;\n+\t\t    }\n+\t\t  else\n+\t\t    failed = 1;\n+\t\t}\n+\n+\t      /* Count the insns and CALL_INSNs passed.  If we passed the\n+\t\t death note of DEST, show increased live length.  */\n+\t      length++;\n+\t      if (dest_death)\n+\t\treg_live_length[dregno]++;\n+\n+\t      if (GET_CODE (q) == CALL_INSN)\n+\t\t{\n+\t\t  n_calls++;\n+\t\t  if (dest_death)\n+\t\t    reg_n_calls_crossed[dregno]++;\n+\t\t}\n+\n+\t      /* If DEST dies here, remove the death note and save it for\n+\t\t later.  */\n+\t      if (dest_death == 0\n+\t\t  && (dest_death = find_regno_note (q, REG_DEAD, dregno)) != 0)\n+\t\tremove_note (q, dest_death);\n+\t    }\n+\n+\t  if (! failed)\n+\t    {\n+\t      if (sregno >= FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  reg_live_length[sregno] -= length;\n+\t\t  reg_n_calls_crossed[sregno] -= n_calls;\n+\t\t}\n+\n+\t      /* Move death note of SRC from P to INSN.  */\n+\t      remove_note (p, note);\n+\t      XEXP (note, 1) = REG_NOTES (insn);\n+\t      REG_NOTES (insn) = note;\n+\t    }\n+\n+\t  /* Put death note of DEST on P if we saw it die.  */\n+\t  if (dest_death)\n+\t    {\n+\t      XEXP (dest_death, 1) = REG_NOTES (p);\n+\t      REG_NOTES (p) = dest_death;\n+\t    }\n+\n+\t  return;\n+\t}\n+    }\n+}\n+\f\t      \n+/* Find registers that are equivalent to a single value throughout the\n+   compilation (either because they can be referenced in memory or are set once\n+   from a single constant).  Lower their priority for a register.\n+\n+   If such a register is only referenced once, try substituting its value\n+   into the using insn.  If it succeeds, we can eliminate the register\n+   completely.  */\n+\n+static void\n+update_equiv_regs ()\n+{\n+  rtx *reg_equiv_init_insn = (rtx *) alloca (max_regno * sizeof (rtx *));\n+  rtx *reg_equiv_replacement = (rtx *) alloca (max_regno * sizeof (rtx *));\n+  rtx insn;\n+\n+  bzero (reg_equiv_init_insn, max_regno * sizeof (rtx *));\n+  bzero (reg_equiv_replacement, max_regno * sizeof (rtx *));\n+\n+  init_alias_analysis ();\n+\n+  loop_depth = 1;\n+\n+  /* Scan the insns and find which registers have equivalences.  Do this\n+     in a separate scan of the insns because (due to -fcse-follow-jumps)\n+     a register can be set below its use.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx note;\n+      rtx set = single_set (insn);\n+      rtx dest;\n+      int regno;\n+\n+      if (GET_CODE (insn) == NOTE)\n+\t{\n+\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\t    loop_depth++;\n+\t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\t    loop_depth--;\n+\t}\n+\n+      /* If this insn contains more (or less) than a single SET, ignore it.  */\n+      if (set == 0)\n+\tcontinue;\n+\n+      dest = SET_DEST (set);\n+\n+      /* If this sets a MEM to the contents of a REG that is only used\n+\t in a single basic block, see if the register is always equivalent\n+\t to that memory location and if moving the store from INSN to the\n+\t insn that set REG is safe.  If so, put a REG_EQUIV note on the\n+\t initializing insn.  */\n+\n+      if (GET_CODE (dest) == MEM && GET_CODE (SET_SRC (set)) == REG\n+\t  && (regno = REGNO (SET_SRC (set))) >= FIRST_PSEUDO_REGISTER\n+\t  && reg_basic_block[regno] >= 0\n+\t  && reg_equiv_init_insn[regno] != 0\n+\t  && validate_equiv_mem (reg_equiv_init_insn[regno], SET_SRC (set),\n+\t\t\t\t dest)\n+\t  && ! memref_used_between_p (SET_DEST (set),\n+\t\t\t\t      reg_equiv_init_insn[regno], insn))\n+\tREG_NOTES (reg_equiv_init_insn[regno])\n+\t  = gen_rtx (EXPR_LIST, REG_EQUIV, dest,\n+\t\t     REG_NOTES (reg_equiv_init_insn[regno]));\n+\n+      /* If this is a register-register copy where SRC is not dead, see if we\n+\t can optimize it.  */\n+      if (flag_expensive_optimizations && GET_CODE (dest) == REG\n+\t  && GET_CODE (SET_SRC (set)) == REG\n+\t  && ! find_reg_note (insn, REG_DEAD, SET_SRC (set)))\n+\toptimize_reg_copy (insn, dest, SET_SRC (set));\n+\n+      /* Otherwise, we only handle the case of a pseudo register being set\n+\t once.  */\n+      if (GET_CODE (dest) != REG\n+\t  || (regno = REGNO (dest)) < FIRST_PSEUDO_REGISTER\n+\t  || reg_n_sets[regno] != 1)\n+\tcontinue;\n+\n+      note = find_reg_note (insn, REG_EQUAL, 0);\n+\n+      /* Record this insn as initializing this register.  */\n+      reg_equiv_init_insn[regno] = insn;\n+\n+      /* If this register is known to be equal to a constant, record that\n+\t it is always equivalent to the constant.  */\n+      if (note && CONSTANT_P (XEXP (note, 0)))\n+\tPUT_MODE (note, (enum machine_mode) REG_EQUIV);\n+\n+      /* If this insn introduces a \"constant\" register, decrease the priority\n+\t of that register.  Record this insn if the register is only used once\n+\t more and the equivalence value is the same as our source.\n+\n+\t The latter condition is checked for two reasons:  First, it is an\n+\t indication that it may be more efficient to actually emit the insn\n+\t as written (if no registers are available, reload will substitute\n+\t the equivalence).  Secondly, it avoids problems with any registers\n+\t dying in this insn whose death notes would be missed.\n+\n+\t If we don't have a REG_EQUIV note, see if this insn is loading\n+\t a register used only in one basic block from a MEM.  If so, and the\n+\t MEM remains unchanged for the life of the register, add a REG_EQUIV\n+\t note.  */\n+\t \n+      note = find_reg_note (insn, REG_EQUIV, 0);\n+\n+      if (note == 0 && reg_basic_block[regno] >= 0\n+\t  && GET_CODE (SET_SRC (set)) == MEM\n+\t  && validate_equiv_mem (insn, dest, SET_SRC (set)))\n+\tREG_NOTES (insn) = note = gen_rtx (EXPR_LIST, REG_EQUIV, SET_SRC (set),\n+\t\t\t\t\t   REG_NOTES (insn));\n+\n+      /* Don't mess with things live during setjmp.  */\n+      if (note && reg_live_length[regno] >= 0)\n+\t{\n+\t  int regno = REGNO (dest);\n+\n+\t  /* Note that the statement below does not affect the priority\n+\t     in local-alloc!  */\n+\t  reg_live_length[regno] *= 2;\n+\n+\t  /* If the register is referenced exactly twice, meaning it is set\n+\t     once and used once, indicate that the reference may be replaced\n+\t     by the equivalence we computed above.  If the register is only\n+\t     used in one basic block, this can't succeed or combine would\n+\t     have done it.\n+\n+\t     It would be nice to use \"loop_depth * 2\" in the compare\n+\t     below.  Unfortunately, LOOP_DEPTH need not be constant within\n+\t     a basic block so this would be too complicated.\n+\n+\t     This case normally occurs when a parameter is read from memory\n+\t     and then used exactly once, not in a loop.  */\n+\n+\t  if (reg_n_refs[regno] == 2\n+\t      && reg_basic_block[regno] < 0\n+\t      && rtx_equal_p (XEXP (note, 0), SET_SRC (set)))\n+\t    reg_equiv_replacement[regno] = SET_SRC (set);\n+\t}\n+    }\n+\n+  /* Now scan all regs killed in an insn to see if any of them are registers\n+     only used that once.  If so, see if we can replace the reference with\n+     the equivalent from.  If we can, delete the initializing reference\n+     and this register will go away.  */\n+  for (insn = next_active_insn (get_insns ());\n+       insn;\n+       insn = next_active_insn (insn))\n+    {\n+      rtx link;\n+\n+      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\tif (REG_NOTE_KIND (link) == REG_DEAD\n+\t    /* Make sure this insn still refers to the register.  */\n+\t    && reg_mentioned_p (XEXP (link, 0), PATTERN (insn)))\n+\t  {\n+\t    int regno = REGNO (XEXP (link, 0));\n+\n+\t    if (reg_equiv_replacement[regno]\n+\t\t&& validate_replace_rtx (regno_reg_rtx[regno],\n+\t\t\t\t\t reg_equiv_replacement[regno], insn))\n+\t      {\n+\t\trtx equiv_insn = reg_equiv_init_insn[regno];\n+\n+\t\tremove_death (regno, insn);\n+\t\treg_n_refs[regno] = 0;\n+\t\tPUT_CODE (equiv_insn, NOTE);\n+\t\tNOTE_LINE_NUMBER (equiv_insn) = NOTE_INSN_DELETED;\n+\t\tNOTE_SOURCE_FILE (equiv_insn) = 0;\n+\t      }\n+\t  }\n+    }\n+}\n+\f\n+/* Allocate hard regs to the pseudo regs used only within block number B.\n+   Only the pseudos that die but once can be handled.  */\n+\n+static void\n+block_alloc (b)\n+     int b;\n+{\n+  register int i, q;\n+  register rtx insn;\n+  rtx note;\n+  int insn_number = 0;\n+  int insn_count = 0;\n+  int max_uid = get_max_uid ();\n+  short *qty_order;\n+  int no_conflict_combined_regno = -1;\n+\n+  /* Count the instructions in the basic block.  */\n+\n+  insn = basic_block_end[b];\n+  while (1)\n+    {\n+      if (GET_CODE (insn) != NOTE)\n+\tif (++insn_count > max_uid)\n+\t  abort ();\n+      if (insn == basic_block_head[b])\n+\tbreak;\n+      insn = PREV_INSN (insn);\n+    }\n+\n+  /* +2 to leave room for a post_mark_life at the last insn and for\n+     the birth of a CLOBBER in the first insn.  */\n+  regs_live_at = (HARD_REG_SET *) alloca ((2 * insn_count + 2)\n+\t\t\t\t\t  * sizeof (HARD_REG_SET));\n+  bzero (regs_live_at, (2 * insn_count + 2) * sizeof (HARD_REG_SET));\n+\n+  /* Initialize table of hardware registers currently live.  */\n+\n+#ifdef HARD_REG_SET\n+  regs_live = *basic_block_live_at_start[b];\n+#else\n+  COPY_HARD_REG_SET (regs_live, basic_block_live_at_start[b]);\n+#endif\n+\n+  /* This loop scans the instructions of the basic block\n+     and assigns quantities to registers.\n+     It computes which registers to tie.  */\n+\n+  insn = basic_block_head[b];\n+  while (1)\n+    {\n+      register rtx body = PATTERN (insn);\n+\n+      if (GET_CODE (insn) != NOTE)\n+\tinsn_number++;\n+\n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t{\n+\t  register rtx link, set;\n+\t  register int win = 0;\n+\t  register rtx r0, r1;\n+\t  int combined_regno = -1;\n+\t  int i;\n+\t  int insn_code_number = recog_memoized (insn);\n+\n+\t  this_insn_number = insn_number;\n+\t  this_insn = insn;\n+\n+\t  if (insn_code_number >= 0)\n+\t    insn_extract (insn);\n+\t  which_alternative = -1;\n+\n+\t  /* Is this insn suitable for tying two registers?\n+\t     If so, try doing that.\n+\t     Suitable insns are those with at least two operands and where\n+\t     operand 0 is an output that is a register that is not\n+\t     earlyclobber.\n+\t     For a commutative operation, try (set reg0 (arithop ... reg1)).\n+\t     Subregs in place of regs are also ok.\n+\n+\t     If tying is done, WIN is set nonzero.  */\n+\n+\t  if (insn_code_number >= 0\n+\t      && insn_n_operands[insn_code_number] > 1\n+\t      && insn_operand_constraint[insn_code_number][0][0] == '='\n+\t      && insn_operand_constraint[insn_code_number][0][1] != '&')\n+\t    {\n+\t      r0 = recog_operand[0];\n+\t      r1 = recog_operand[1];\n+\n+\t      /* If the first operand is an address, find a register in it.\n+\t\t There may be more than one register, but we only try one of\n+\t\t them.  */\n+\t      if (insn_operand_constraint[insn_code_number][1][0] == 'p')\n+\t\twhile (GET_CODE (r1) == PLUS || GET_CODE (r1) == MULT)\n+\t\t  r1 = XEXP (r1, 0);\n+\n+\t      if (GET_CODE (r0) == REG || GET_CODE (r0) == SUBREG)\n+\t\t{\n+\t\t  /* We have two priorities for hard register preferrences.\n+\t\t     If we have a move insn or an insn whose first input can\n+\t\t     only be in the same register as the output, give\n+\t\t     priority to an equivalence found from that insn.  */\n+\t\t  int may_save_copy\n+\t\t    = ((SET_DEST (body) == r0 && SET_SRC (body) == r1)\n+\t\t       || (r1 == recog_operand[1]\n+\t\t\t   && (requires_inout_p (insn_operand_constraint[insn_code_number][1]))));\n+\n+\t\t  if (GET_CODE (r1) == REG || GET_CODE (r1) == SUBREG)\n+\t\t    win = combine_regs (r1, r0, may_save_copy,\n+\t\t\t\t\tinsn_number, insn, 0);\n+\n+\t\t  if (win == 0\n+\t\t      && insn_n_operands[insn_code_number] > 2\n+\t\t      && insn_operand_constraint[insn_code_number][1][0] == '%'\n+\t\t      && (r1 = recog_operand[2],\n+\t\t\t  GET_CODE (r1) == REG || GET_CODE (r1) == SUBREG))\n+\t\t    win = combine_regs (r1, r0, may_save_copy,\n+\t\t\t\t\tinsn_number, insn, 0);\n+\t\t}\n+\t    }\n+\n+\t  /* Recognize an insn sequence with an ultimate result\n+\t     which can safely overlap one of the inputs.\n+\t     The sequence begins with a CLOBBER of its result,\n+\t     and ends with an insn that copies the result to itself\n+\t     and has a REG_EQUAL note for an equivalent formula.\n+\t     That note indicates what the inputs are.\n+\t     The result and the input can overlap if each insn in\n+\t     the sequence either doesn't mention the input\n+\t     or has a REG_NO_CONFLICT note to inhibit the conflict.\n+\n+\t     We do the combining test at the CLOBBER so that the\n+\t     destination register won't have had a quantity number\n+\t     assigned, since that would prevent combining.  */\n+\n+\t  if (GET_CODE (PATTERN (insn)) == CLOBBER\n+\t      && (r0 = XEXP (PATTERN (insn), 0),\n+\t\t  GET_CODE (r0) == REG)\n+\t      && (link = find_reg_note (insn, REG_LIBCALL, 0)) != 0\n+\t      && GET_CODE (XEXP (link, 0)) == INSN\n+\t      && (set = single_set (XEXP (link, 0))) != 0\n+\t      && SET_DEST (set) == r0 && SET_SRC (set) == r0\n+\t      && (note = find_reg_note (XEXP (link, 0), REG_EQUAL, 0)) != 0)\n+\t    {\n+\t      if (r1 = XEXP (note, 0), GET_CODE (r1) == REG\n+\t\t  /* Check that we have such a sequence.  */\n+\t\t  && no_conflict_p (insn, r0, r1))\n+\t\twin = combine_regs (r1, r0, 1, insn_number, insn, 1);\n+\t      else if (GET_RTX_FORMAT (GET_CODE (XEXP (note, 0)))[0] == 'e'\n+\t\t       && (r1 = XEXP (XEXP (note, 0), 0),\n+\t\t\t   GET_CODE (r1) == REG || GET_CODE (r1) == SUBREG)\n+\t\t       && no_conflict_p (insn, r0, r1))\n+\t\twin = combine_regs (r1, r0, 0, insn_number, insn, 1);\n+\n+\t      /* Here we care if the operation to be computed is\n+\t\t commutative.  */\n+\t      else if ((GET_CODE (XEXP (note, 0)) == EQ\n+\t\t\t|| GET_CODE (XEXP (note, 0)) == NE\n+\t\t\t|| GET_RTX_CLASS (GET_CODE (XEXP (note, 0))) == 'c')\n+\t\t       && (r1 = XEXP (XEXP (note, 0), 1),\n+\t\t\t   (GET_CODE (r1) == REG || GET_CODE (r1) == SUBREG))\n+\t\t       && no_conflict_p (insn, r0, r1))\n+\t\twin = combine_regs (r1, r0, 0, insn_number, insn, 1);\n+\n+\t      /* If we did combine something, show the register number\n+\t\t in question so that we know to ignore its death.  */\n+\t      if (win)\n+\t\tno_conflict_combined_regno = REGNO (r1);\n+\t    }\n+\n+\t  /* If registers were just tied, set COMBINED_REGNO\n+\t     to the number of the register used in this insn\n+\t     that was tied to the register set in this insn.\n+\t     This register's qty should not be \"killed\".  */\n+\n+\t  if (win)\n+\t    {\n+\t      while (GET_CODE (r1) == SUBREG)\n+\t\tr1 = SUBREG_REG (r1);\n+\t      combined_regno = REGNO (r1);\n+\t    }\n+\n+\t  /* Mark the death of everything that dies in this instruction,\n+\t     except for anything that was just combined.  */\n+\n+\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t    if (REG_NOTE_KIND (link) == REG_DEAD\n+\t\t&& GET_CODE (XEXP (link, 0)) == REG\n+\t\t&& combined_regno != REGNO (XEXP (link, 0))\n+\t\t&& (no_conflict_combined_regno != REGNO (XEXP (link, 0))\n+\t\t    || ! find_reg_note (insn, REG_NO_CONFLICT, XEXP (link, 0))))\n+\t      wipe_dead_reg (XEXP (link, 0), 0);\n+\n+\t  /* Allocate qty numbers for all registers local to this block\n+\t     that are born (set) in this instruction.\n+\t     A pseudo that already has a qty is not changed.  */\n+\n+\t  note_stores (PATTERN (insn), reg_is_set);\n+\n+\t  /* If anything is set in this insn and then unused, mark it as dying\n+\t     after this insn, so it will conflict with our outputs.  This\n+\t     can't match with something that combined, and it doesn't matter\n+\t     if it did.  Do this after the calls to reg_is_set since these\n+\t     die after, not during, the current insn.  */\n+\n+\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t    if (REG_NOTE_KIND (link) == REG_UNUSED\n+\t\t&& GET_CODE (XEXP (link, 0)) == REG)\n+\t      wipe_dead_reg (XEXP (link, 0), 1);\n+\n+#ifndef SMALL_REGISTER_CLASSES\n+\t  /* Allocate quantities for any SCRATCH operands of this insn.  We\n+\t     don't do this for machines with small register classes because\n+\t     those machines can use registers explicitly mentioned in the\n+\t     RTL as spill registers and our usage of hard registers\n+\t     explicitly for SCRATCH operands will conflict.  On those machines,\n+\t     reload will allocate the SCRATCH.  */\n+\n+\t  if (insn_code_number >= 0)\n+\t    for (i = 0; i < insn_n_operands[insn_code_number]; i++)\n+\t      if (GET_CODE (recog_operand[i]) == SCRATCH)\n+\t\talloc_qty_for_scratch (recog_operand[i], i, insn,\n+\t\t\t\t       insn_code_number, insn_number);\n+#endif\n+\n+\t  /* If this is an insn that has a REG_RETVAL note pointing at a \n+\t     CLOBBER insn, we have reached the end of a REG_NO_CONFLICT\n+\t     block, so clear any register number that combined within it.  */\n+\t  if ((note = find_reg_note (insn, REG_RETVAL, 0)) != 0\n+\t      && GET_CODE (XEXP (note, 0)) == INSN\n+\t      && GET_CODE (PATTERN (XEXP (note, 0))) == CLOBBER)\n+\t    no_conflict_combined_regno = -1;\n+\t}\n+\n+      /* Set the registers live after INSN_NUMBER.  Note that we never\n+\t record the registers live before the block's first insn, since no\n+\t pseudos we care about are live before that insn.  */\n+\n+      IOR_HARD_REG_SET (regs_live_at[2 * insn_number], regs_live);\n+      IOR_HARD_REG_SET (regs_live_at[2 * insn_number + 1], regs_live);\n+\n+      if (insn == basic_block_end[b])\n+\tbreak;\n+\n+      insn = NEXT_INSN (insn);\n+    }\n+\n+  /* Now every register that is local to this basic block\n+     should have been given a quantity, or else -1 meaning ignore it.\n+     Every quantity should have a known birth and death.  \n+\n+     Order the qtys so we assign them registers in order of \n+     decreasing length of life.  Normally call qsort, but if we \n+     have only a very small number of quantities, sort them ourselves.  */\n+\n+  qty_order = (short *) alloca (next_qty * sizeof (short));\n+  for (i = 0; i < next_qty; i++)\n+    qty_order[i] = i;\n+\n+#define EXCHANGE(I1, I2)  \\\n+  { i = qty_order[I1]; qty_order[I1] = qty_order[I2]; qty_order[I2] = i; }\n+\n+  switch (next_qty)\n+    {\n+    case 3:\n+      /* Make qty_order[2] be the one to allocate last.  */\n+      if (qty_compare (0, 1) > 0)\n+\tEXCHANGE (0, 1);\n+      if (qty_compare (1, 2) > 0)\n+\tEXCHANGE (2, 1);\n+\n+      /* ... Fall through ... */\n+    case 2:\n+      /* Put the best one to allocate in qty_order[0].  */\n+      if (qty_compare (0, 1) > 0)\n+\tEXCHANGE (0, 1);\n+\n+      /* ... Fall through ... */\n+\n+    case 1:\n+    case 0:\n+      /* Nothing to do here.  */\n+      break;\n+\n+    default:\n+      qsort (qty_order, next_qty, sizeof (short), qty_compare_1);\n+    }\n+\n+  /* Try to put each quantity in a suggested physical register, if it has one.\n+     This may cause registers to be allocated that otherwise wouldn't be, but\n+     this seems acceptable in local allocation (unlike global allocation).  */\n+  for (i = 0; i < next_qty; i++)\n+    {\n+      q = qty_order[i];\n+      if (qty_phys_has_sugg[q] || qty_phys_has_copy_sugg[q])\n+\tqty_phys_reg[q] = find_free_reg (qty_min_class[q], qty_mode[q], q,\n+\t\t\t\t\t 0, 1, qty_birth[q], qty_death[q]);\n+      else\n+\tqty_phys_reg[q] = -1;\n+    }\n+\n+  /* Now for each qty that is not a hardware register,\n+     look for a hardware register to put it in.\n+     First try the register class that is cheapest for this qty,\n+     if there is more than one class.  */\n+\n+  for (i = 0; i < next_qty; i++)\n+    {\n+      q = qty_order[i];\n+      if (qty_phys_reg[q] < 0)\n+\t{\n+\t  if (N_REG_CLASSES > 1)\n+\t    {\n+\t      qty_phys_reg[q] = find_free_reg (qty_min_class[q], \n+\t\t\t\t\t       qty_mode[q], q, 0, 0,\n+\t\t\t\t\t       qty_birth[q], qty_death[q]);\n+\t      if (qty_phys_reg[q] >= 0)\n+\t\tcontinue;\n+\t    }\n+\n+\t  if (!qty_preferred_or_nothing[q])\n+\t    qty_phys_reg[q] = find_free_reg (ALL_REGS, \n+\t\t\t\t\t     qty_mode[q], q, 0, 0,\n+\t\t\t\t\t     qty_birth[q], qty_death[q]);\n+\t}\n+    }\n+\n+  /* Now propagate the register assignments\n+     to the pseudo regs belonging to the qtys.  */\n+\n+  for (q = 0; q < next_qty; q++)\n+    if (qty_phys_reg[q] >= 0)\n+      {\n+\tfor (i = qty_first_reg[q]; i >= 0; i = reg_next_in_qty[i])\n+\t  reg_renumber[i] = qty_phys_reg[q] + reg_offset[i];\n+\tif (qty_scratch_rtx[q])\n+\t  {\n+\t    PUT_CODE (qty_scratch_rtx[q], REG);\n+\t    REGNO (qty_scratch_rtx[q]) = qty_phys_reg[q];\n+\n+\t    for (i = HARD_REGNO_NREGS (qty_phys_reg[q],\n+\t\t\t\t       GET_MODE (qty_scratch_rtx[q])) - 1;\n+\t\t i >= 0; i--)\n+\t      regs_ever_live[qty_phys_reg[q] + i] = 1;\n+\n+\t    /* Must clear the USED field, because it will have been set by\n+\t       copy_rtx_if_shared, but the leaf_register code expects that\n+\t       it is zero in all REG rtx.  copy_rtx_if_shared does not set the\n+\t       used bit for REGs, but does for SCRATCHes.  */\n+\t    qty_scratch_rtx[q]->used = 0;\n+\t  }\n+      }\n+}\n+\f\n+/* Compare two quantities' priority for getting real registers.\n+   We give shorter-lived quantities higher priority.\n+   Quantities with more references are also preferred, as are quanties that\n+   require multiple registers.  This is the identical prioritorization as\n+   done by global-alloc.\n+\n+   We used to give preference to registers with *longer* lives, but using\n+   the same algorithm in both local- and global-alloc can speed up execution\n+   of some programs by as much as a factor of three!  */\n+\n+static int\n+qty_compare (q1, q2)\n+     int q1, q2;\n+{\n+  /* Note that the quotient will never be bigger than\n+     the value of floor_log2 times the maximum number of\n+     times a register can occur in one insn (surely less than 100).\n+     Multiplying this by 10000 can't overflow.  */\n+  register int pri1\n+    = (((double) (floor_log2 (qty_n_refs[q1]) * qty_n_refs[q1])\n+\t/ ((qty_death[q1] - qty_birth[q1]) * qty_size[q1]))\n+       * 10000);\n+  register int pri2\n+    = (((double) (floor_log2 (qty_n_refs[q2]) * qty_n_refs[q2])\n+\t/ ((qty_death[q2] - qty_birth[q2]) * qty_size[q2]))\n+       * 10000);\n+  return pri2 - pri1;\n+}\n+\n+static int\n+qty_compare_1 (q1, q2)\n+     short *q1, *q2;\n+{\n+  register int tem;\n+\n+  /* Note that the quotient will never be bigger than\n+     the value of floor_log2 times the maximum number of\n+     times a register can occur in one insn (surely less than 100).\n+     Multiplying this by 10000 can't overflow.  */\n+  register int pri1\n+    = (((double) (floor_log2 (qty_n_refs[*q1]) * qty_n_refs[*q1])\n+\t/ ((qty_death[*q1] - qty_birth[*q1]) * qty_size[*q1]))\n+       * 10000);\n+  register int pri2\n+    = (((double) (floor_log2 (qty_n_refs[*q2]) * qty_n_refs[*q2])\n+\t/ ((qty_death[*q2] - qty_birth[*q2]) * qty_size[*q2]))\n+       * 10000);\n+\n+  tem = pri2 - pri1;\n+  if (tem != 0) return tem;\n+  /* If qtys are equally good, sort by qty number,\n+     so that the results of qsort leave nothing to chance.  */\n+  return *q1 - *q2;\n+}\n+\f\n+/* Attempt to combine the two registers (rtx's) USEDREG and SETREG.\n+   Returns 1 if have done so, or 0 if cannot.\n+\n+   Combining registers means marking them as having the same quantity\n+   and adjusting the offsets within the quantity if either of\n+   them is a SUBREG).\n+\n+   We don't actually combine a hard reg with a pseudo; instead\n+   we just record the hard reg as the suggestion for the pseudo's quantity.\n+   If we really combined them, we could lose if the pseudo lives\n+   across an insn that clobbers the hard reg (eg, movstr).\n+\n+   ALREADY_DEAD is non-zero if USEDREG is known to be dead even though\n+   there is no REG_DEAD note on INSN.  This occurs during the processing\n+   of REG_NO_CONFLICT blocks.\n+\n+   MAY_SAVE_COPYCOPY is non-zero if this insn is simply copying USEDREG to\n+   SETREG or if the input and output must share a register.\n+   In that case, we record a hard reg suggestion in QTY_PHYS_COPY_SUGG.\n+   \n+   There are elaborate checks for the validity of combining.  */\n+\n+   \n+static int\n+combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n+     rtx usedreg, setreg;\n+     int may_save_copy;\n+     int insn_number;\n+     rtx insn;\n+     int already_dead;\n+{\n+  register int ureg, sreg;\n+  register int offset = 0;\n+  int usize, ssize;\n+  register int sqty;\n+\n+  /* Determine the numbers and sizes of registers being used.  If a subreg\n+     is present that does not change the entire register, don't conside\n+     this a copy insn.  */\n+\n+  while (GET_CODE (usedreg) == SUBREG)\n+    {\n+      if (GET_MODE_SIZE (GET_MODE (SUBREG_REG (usedreg))) > UNITS_PER_WORD)\n+\tmay_save_copy = 0;\n+      offset += SUBREG_WORD (usedreg);\n+      usedreg = SUBREG_REG (usedreg);\n+    }\n+  if (GET_CODE (usedreg) != REG)\n+    return 0;\n+  ureg = REGNO (usedreg);\n+  usize = REG_SIZE (usedreg);\n+\n+  while (GET_CODE (setreg) == SUBREG)\n+    {\n+      if (GET_MODE_SIZE (GET_MODE (SUBREG_REG (setreg))) > UNITS_PER_WORD)\n+\tmay_save_copy = 0;\n+      offset -= SUBREG_WORD (setreg);\n+      setreg = SUBREG_REG (setreg);\n+    }\n+  if (GET_CODE (setreg) != REG)\n+    return 0;\n+  sreg = REGNO (setreg);\n+  ssize = REG_SIZE (setreg);\n+\n+  /* If UREG is a pseudo-register that hasn't already been assigned a\n+     quantity number, it means that it is not local to this block or dies\n+     more than once.  In either event, we can't do anything with it.  */\n+  if ((ureg >= FIRST_PSEUDO_REGISTER && reg_qty[ureg] < 0)\n+      /* Do not combine registers unless one fits within the other.  */\n+      || (offset > 0 && usize + offset > ssize)\n+      || (offset < 0 && usize + offset < ssize)\n+      /* Do not combine with a smaller already-assigned object\n+\t if that smaller object is already combined with something bigger. */\n+      || (ssize > usize && ureg >= FIRST_PSEUDO_REGISTER\n+\t  && usize < qty_size[reg_qty[ureg]])\n+      /* Can't combine if SREG is not a register we can allocate.  */\n+      || (sreg >= FIRST_PSEUDO_REGISTER && reg_qty[sreg] == -1)\n+      /* Don't combine with a pseudo mentioned in a REG_NO_CONFLICT note.\n+\t These have already been taken care of.  This probably wouldn't\n+\t combine anyway, but don't take any chances.  */\n+      || (ureg >= FIRST_PSEUDO_REGISTER\n+\t  && find_reg_note (insn, REG_NO_CONFLICT, usedreg))\n+      /* Don't tie something to itself.  In most cases it would make no\n+\t difference, but it would screw up if the reg being tied to itself\n+\t also dies in this insn.  */\n+      || ureg == sreg\n+      /* Don't try to connect two different hardware registers.  */\n+      || (ureg < FIRST_PSEUDO_REGISTER && sreg < FIRST_PSEUDO_REGISTER)\n+      /* Don't connect two different machine modes if they have different\n+\t implications as to which registers may be used.  */\n+      || !MODES_TIEABLE_P (GET_MODE (usedreg), GET_MODE (setreg)))\n+    return 0;\n+\n+  /* Now, if UREG is a hard reg and SREG is a pseudo, record the hard reg in\n+     qty_phys_sugg for the pseudo instead of tying them.\n+\n+     Return \"failure\" so that the lifespan of UREG is terminated here;\n+     that way the two lifespans will be disjoint and nothing will prevent\n+     the pseudo reg from being given this hard reg.  */\n+\n+  if (ureg < FIRST_PSEUDO_REGISTER)\n+    {\n+      /* Allocate a quantity number so we have a place to put our\n+\t suggestions.  */\n+      if (reg_qty[sreg] == -2)\n+\treg_is_born (setreg, 2 * insn_number);\n+\n+      if (reg_qty[sreg] >= 0)\n+\t{\n+\t  if (may_save_copy)\n+\t    {\n+\t      SET_HARD_REG_BIT (qty_phys_copy_sugg[reg_qty[sreg]], ureg);\n+\t      qty_phys_has_copy_sugg[reg_qty[sreg]] = 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      SET_HARD_REG_BIT (qty_phys_sugg[reg_qty[sreg]], ureg);\n+\t      qty_phys_has_sugg[reg_qty[sreg]] = 1;\n+\t    }\n+\t}\n+      return 0;\n+    }\n+\n+  /* Similarly for SREG a hard register and UREG a pseudo register.  */\n+\n+  if (sreg < FIRST_PSEUDO_REGISTER)\n+    {\n+      if (may_save_copy)\n+\t{\n+\t  SET_HARD_REG_BIT (qty_phys_copy_sugg[reg_qty[ureg]], sreg);\n+\t  qty_phys_has_copy_sugg[reg_qty[ureg]] = 1;\n+\t}\n+      else\n+\t{\n+\t  SET_HARD_REG_BIT (qty_phys_sugg[reg_qty[ureg]], sreg);\n+\t  qty_phys_has_sugg[reg_qty[ureg]] = 1;\n+\t}\n+      return 0;\n+    }\n+\n+  /* At this point we know that SREG and UREG are both pseudos.\n+     Do nothing if SREG already has a quantity or is a register that we\n+     don't allocate.  */\n+  if (reg_qty[sreg] >= -1\n+      /* If we are not going to let any regs live across calls,\n+\t don't tie a call-crossing reg to a non-call-crossing reg.  */\n+      || (current_function_has_nonlocal_label\n+\t  && ((reg_n_calls_crossed[ureg] > 0)\n+\t      != (reg_n_calls_crossed[sreg] > 0))))\n+    return 0;\n+\n+  /* We don't already know about SREG, so tie it to UREG\n+     if this is the last use of UREG, provided the classes they want\n+     are compatible.  */\n+\n+  if ((already_dead || find_regno_note (insn, REG_DEAD, ureg))\n+      && reg_meets_class_p (sreg, qty_min_class[reg_qty[ureg]]))\n+    {\n+      /* Add SREG to UREG's quantity.  */\n+      sqty = reg_qty[ureg];\n+      reg_qty[sreg] = sqty;\n+      reg_offset[sreg] = reg_offset[ureg] + offset;\n+      reg_next_in_qty[sreg] = qty_first_reg[sqty];\n+      qty_first_reg[sqty] = sreg;\n+\n+      /* If SREG's reg class is smaller, set qty_min_class[SQTY].  */\n+      update_qty_class (sqty, sreg);\n+\n+      /* Update info about quantity SQTY.  */\n+      qty_n_calls_crossed[sqty] += reg_n_calls_crossed[sreg];\n+      qty_n_refs[sqty] += reg_n_refs[sreg];\n+      if (! reg_preferred_or_nothing (sreg))\n+\tqty_preferred_or_nothing[sqty] = 0;\n+      if (usize < ssize)\n+\t{\n+\t  register int i;\n+\n+\t  for (i = qty_first_reg[sqty]; i >= 0; i = reg_next_in_qty[i])\n+\t    reg_offset[i] -= offset;\n+\n+\t  qty_size[sqty] = ssize;\n+\t  qty_mode[sqty] = GET_MODE (setreg);\n+\t}\n+    }\n+  else\n+    return 0;\n+\n+  return 1;\n+}\n+\f\n+/* Return 1 if the preferred class of REG allows it to be tied\n+   to a quantity or register whose class is CLASS.\n+   True if REG's reg class either contains or is contained in CLASS.  */\n+\n+static int\n+reg_meets_class_p (reg, class)\n+     int reg;\n+     enum reg_class class;\n+{\n+  register enum reg_class rclass = reg_preferred_class (reg);\n+  return (reg_class_subset_p (rclass, class)\n+\t  || reg_class_subset_p (class, rclass));\n+}\n+\n+/* Return 1 if the two specified classes have registers in common.\n+   If CALL_SAVED, then consider only call-saved registers.  */\n+\n+static int\n+reg_classes_overlap_p (c1, c2, call_saved)\n+     register enum reg_class c1;\n+     register enum reg_class c2;\n+     int call_saved;\n+{\n+  HARD_REG_SET c;\n+  int i;\n+\n+  COPY_HARD_REG_SET (c, reg_class_contents[(int) c1]);\n+  AND_HARD_REG_SET (c, reg_class_contents[(int) c2]);\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (TEST_HARD_REG_BIT (c, i)\n+\t&& (! call_saved || ! call_used_regs[i]))\n+      return 1;\n+\n+  return 0;\n+}\n+\n+/* Update the class of QTY assuming that REG is being tied to it.  */\n+\n+static void\n+update_qty_class (qty, reg)\n+     int qty;\n+     int reg;\n+{\n+  enum reg_class rclass = reg_preferred_class (reg);\n+  if (reg_class_subset_p (rclass, qty_min_class[qty]))\n+    qty_min_class[qty] = rclass;\n+}\n+\f\n+/* Handle something which alters the value of an rtx REG.\n+\n+   REG is whatever is set or clobbered.  SETTER is the rtx that\n+   is modifying the register.\n+\n+   If it is not really a register, we do nothing.\n+   The file-global variables `this_insn' and `this_insn_number'\n+   carry info from `block_alloc'.  */\n+\n+static void\n+reg_is_set (reg, setter)\n+     rtx reg;\n+     rtx setter;\n+{\n+  /* Note that note_stores will only pass us a SUBREG if it is a SUBREG of\n+     a hard register.  These may actually not exist any more.  */\n+\n+  if (GET_CODE (reg) != SUBREG\n+      && GET_CODE (reg) != REG)\n+    return;\n+\n+  /* Mark this register as being born.  If it is used in a CLOBBER, mark\n+     it as being born halfway between the previous insn and this insn so that\n+     it conflicts with our inputs but not the outputs of the previous insn.  */\n+\n+  reg_is_born (reg, 2 * this_insn_number - (GET_CODE (setter) == CLOBBER));\n+}\n+\f\n+/* Handle beginning of the life of register REG.\n+   BIRTH is the index at which this is happening.  */\n+\n+static void\n+reg_is_born (reg, birth)\n+     rtx reg;\n+     int birth;\n+{\n+  register int regno;\n+     \n+  if (GET_CODE (reg) == SUBREG)\n+    regno = REGNO (SUBREG_REG (reg)) + SUBREG_WORD (reg);\n+  else\n+    regno = REGNO (reg);\n+\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    {\n+      mark_life (regno, GET_MODE (reg), 1);\n+\n+      /* If the register was to have been born earlier that the present\n+\t insn, mark it as live where it is actually born.  */\n+      if (birth < 2 * this_insn_number)\n+\tpost_mark_life (regno, GET_MODE (reg), 1, birth, 2 * this_insn_number);\n+    }\n+  else\n+    {\n+      if (reg_qty[regno] == -2)\n+\talloc_qty (regno, GET_MODE (reg), PSEUDO_REGNO_SIZE (regno), birth);\n+\n+      /* If this register has a quantity number, show that it isn't dead.  */\n+      if (reg_qty[regno] >= 0)\n+\tqty_death[reg_qty[regno]] = -1;\n+    }\n+}\n+\n+/* Record the death of REG in the current insn.  If OUTPUT_P is non-zero,\n+   REG is an output that is dying (i.e., it is never used), otherwise it\n+   is an input (the normal case).  */\n+\n+static void\n+wipe_dead_reg (reg, output_p)\n+     register rtx reg;\n+     int output_p;\n+{\n+  register int regno = REGNO (reg);\n+\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    {\n+      mark_life (regno, GET_MODE (reg), 0);\n+\n+      /* If a hard register is dying as an output, mark it as in use at\n+\t the beginning of this insn (the above statement would cause this\n+\t not to happen).  */\n+      if (output_p)\n+\tpost_mark_life (regno, GET_MODE (reg), 1,\n+\t\t\t2 * this_insn_number, 2 * this_insn_number+ 1);\n+    }\n+\n+  else if (reg_qty[regno] >= 0)\n+    qty_death[reg_qty[regno]] = 2 * this_insn_number + output_p;\n+}\n+\f\n+/* Find a block of SIZE words of hard regs in reg_class CLASS\n+   that can hold something of machine-mode MODE\n+     (but actually we test only the first of the block for holding MODE)\n+   and still free between insn BORN_INDEX and insn DEAD_INDEX,\n+   and return the number of the first of them.\n+   Return -1 if such a block cannot be found. \n+   If QTY crosses calls, insist on a register preserved by calls,\n+   unless ACCEPT_CALL_CLOBBERED is nonzero.\n+\n+   If JUST_TRY_SUGGESTED is non-zero, only try to see if the suggested\n+   register is available.  If not, return -1.  */\n+\n+static int\n+find_free_reg (class, mode, qty, accept_call_clobbered, just_try_suggested,\n+\t       born_index, dead_index)\n+     enum reg_class class;\n+     enum machine_mode mode;\n+     int accept_call_clobbered;\n+     int just_try_suggested;\n+     int qty;\n+     int born_index, dead_index;\n+{\n+  register int i, ins;\n+#ifdef HARD_REG_SET\n+  register\t\t/* Declare it register if it's a scalar.  */\n+#endif\n+    HARD_REG_SET used, first_used;\n+#ifdef ELIMINABLE_REGS\n+  static struct {int from, to; } eliminables[] = ELIMINABLE_REGS;\n+#endif\n+\n+  /* Validate our parameters.  */\n+  if (born_index < 0 || born_index > dead_index)\n+    abort ();\n+\n+  /* Don't let a pseudo live in a reg across a function call\n+     if we might get a nonlocal goto.  */\n+  if (current_function_has_nonlocal_label\n+      && qty_n_calls_crossed[qty] > 0)\n+    return -1;\n+\n+  if (accept_call_clobbered)\n+    COPY_HARD_REG_SET (used, call_fixed_reg_set);\n+  else if (qty_n_calls_crossed[qty] == 0)\n+    COPY_HARD_REG_SET (used, fixed_reg_set);\n+  else\n+    COPY_HARD_REG_SET (used, call_used_reg_set);\n+\n+  for (ins = born_index; ins < dead_index; ins++)\n+    IOR_HARD_REG_SET (used, regs_live_at[ins]);\n+\n+  IOR_COMPL_HARD_REG_SET (used, reg_class_contents[(int) class]);\n+\n+  /* Don't use the frame pointer reg in local-alloc even if\n+     we may omit the frame pointer, because if we do that and then we\n+     need a frame pointer, reload won't know how to move the pseudo\n+     to another hard reg.  It can move only regs made by global-alloc.\n+\n+     This is true of any register that can be eliminated.  */\n+#ifdef ELIMINABLE_REGS\n+  for (i = 0; i < sizeof eliminables / sizeof eliminables[0]; i++)\n+    SET_HARD_REG_BIT (used, eliminables[i].from);\n+#else\n+  SET_HARD_REG_BIT (used, FRAME_POINTER_REGNUM);\n+#endif\n+\n+  /* Normally, the registers that can be used for the first register in\n+     a multi-register quantity are the same as those that can be used for\n+     subsequent registers.  However, if just trying suggested registers,\n+     restrict our consideration to them.  If there are copy-suggested\n+     register, try them.  Otherwise, try the arithmetic-suggested\n+     registers.  */\n+  COPY_HARD_REG_SET (first_used, used);\n+\n+  if (just_try_suggested)\n+    {\n+      if (qty_phys_has_copy_sugg[qty])\n+\tIOR_COMPL_HARD_REG_SET (first_used, qty_phys_copy_sugg[qty]);\n+      else\n+\tIOR_COMPL_HARD_REG_SET (first_used, qty_phys_sugg[qty]);\n+    }\n+\n+  /* If all registers are excluded, we can't do anything.  */\n+  GO_IF_HARD_REG_SUBSET (reg_class_contents[(int) ALL_REGS], first_used, fail);\n+\n+  /* If at least one would be suitable, test each hard reg.  */\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+#ifdef REG_ALLOC_ORDER\n+      int regno = reg_alloc_order[i];\n+#else\n+      int regno = i;\n+#endif\n+      if (! TEST_HARD_REG_BIT (first_used, regno)\n+\t  && HARD_REGNO_MODE_OK (regno, mode))\n+\t{\n+\t  register int j;\n+\t  register int size1 = HARD_REGNO_NREGS (regno, mode);\n+\t  for (j = 1; j < size1 && ! TEST_HARD_REG_BIT (used, regno + j); j++);\n+\t  if (j == size1)\n+\t    {\n+\t      /* Mark that this register is in use between its birth and death\n+\t\t insns.  */\n+\t      post_mark_life (regno, mode, 1, born_index, dead_index);\n+\t      return regno;\n+\t    }\n+#ifndef REG_ALLOC_ORDER\n+\t  i += j;\t\t/* Skip starting points we know will lose */\n+#endif\n+\t}\n+    }\n+\n+ fail:\n+\n+  /* If we are just trying suggested register, we have just tried copy-\n+     suggested registers, and there are arithmetic-suggested registers,\n+     try them.  */\n+  \n+  /* If it would be profitable to allocate a call-clobbered register\n+     and save and restore it around calls, do that.  */\n+  if (just_try_suggested && qty_phys_has_copy_sugg[qty]\n+      && qty_phys_has_sugg[qty])\n+    {\n+      /* Don't try the copy-suggested regs again.  */\n+      qty_phys_has_copy_sugg[qty] = 0;\n+      return find_free_reg (class, mode, qty, accept_call_clobbered, 1,\n+\t\t\t    born_index, dead_index);\n+    }\n+\n+  if (! accept_call_clobbered\n+      && flag_caller_saves\n+      && ! just_try_suggested\n+      && qty_n_calls_crossed[qty] != 0\n+      && CALLER_SAVE_PROFITABLE (qty_n_refs[qty], qty_n_calls_crossed[qty]))\n+    {\n+      i = find_free_reg (class, mode, qty, 1, 0, born_index, dead_index);\n+      if (i >= 0)\n+\tcaller_save_needed = 1;\n+      return i;\n+    }\n+  return -1;\n+}\n+\f\n+/* Mark that REGNO with machine-mode MODE is live starting from the current\n+   insn (if LIFE is non-zero) or dead starting at the current insn (if LIFE\n+   is zero).  */\n+\n+static void\n+mark_life (regno, mode, life)\n+     register int regno;\n+     enum machine_mode mode;\n+     int life;\n+{\n+  register int j = HARD_REGNO_NREGS (regno, mode);\n+  if (life)\n+    while (--j >= 0)\n+      SET_HARD_REG_BIT (regs_live, regno + j);\n+  else\n+    while (--j >= 0)\n+      CLEAR_HARD_REG_BIT (regs_live, regno + j);\n+}\n+\n+/* Mark register number REGNO (with machine-mode MODE) as live (if LIFE\n+   is non-zero) or dead (if LIFE is zero) from insn number BIRTH (inclusive)\n+   to insn number DEATH (exclusive).  */\n+\n+static void\n+post_mark_life (regno, mode, life, birth, death)\n+     register int regno, life, birth;\n+     enum machine_mode mode;\n+     int death;\n+{\n+  register int j = HARD_REGNO_NREGS (regno, mode);\n+#ifdef HARD_REG_SET\n+  register\t\t/* Declare it register if it's a scalar.  */\n+#endif\n+    HARD_REG_SET this_reg;\n+\n+  CLEAR_HARD_REG_SET (this_reg);\n+  while (--j >= 0)\n+    SET_HARD_REG_BIT (this_reg, regno + j);\n+\n+  if (life)\n+    while (birth < death)\n+      {\n+\tIOR_HARD_REG_SET (regs_live_at[birth], this_reg);\n+\tbirth++;\n+      }\n+  else\n+    while (birth < death)\n+      {\n+\tAND_COMPL_HARD_REG_SET (regs_live_at[birth], this_reg);\n+\tbirth++;\n+      }\n+}\n+\f\n+/* INSN is the CLOBBER insn that starts a REG_NO_NOCONFLICT block, R0\n+   is the register being clobbered, and R1 is a register being used in\n+   the equivalent expression.\n+\n+   If R1 dies in the block and has a REG_NO_CONFLICT note on every insn\n+   in which it is used, return 1.\n+\n+   Otherwise, return 0.  */\n+\n+static int\n+no_conflict_p (insn, r0, r1)\n+     rtx insn, r0, r1;\n+{\n+  int ok = 0;\n+  rtx note = find_reg_note (insn, REG_LIBCALL, 0);\n+  rtx p, last;\n+\n+  /* If R1 is a hard register, return 0 since we handle this case\n+     when we scan the insns that actually use it.  */\n+\n+  if (note == 0\n+      || (GET_CODE (r1) == REG && REGNO (r1) < FIRST_PSEUDO_REGISTER)\n+      || (GET_CODE (r1) == SUBREG && GET_CODE (SUBREG_REG (r1)) == REG\n+\t  && REGNO (SUBREG_REG (r1)) < FIRST_PSEUDO_REGISTER))\n+    return 0;\n+\n+  last = XEXP (note, 0);\n+\n+  for (p = NEXT_INSN (insn); p && p != last; p = NEXT_INSN (p))\n+    if (GET_RTX_CLASS (GET_CODE (p)) == 'i')\n+      {\n+\tif (find_reg_note (p, REG_DEAD, r1))\n+\t  ok = 1;\n+\n+\tif (reg_mentioned_p (r1, PATTERN (p))\n+\t    && ! find_reg_note (p, REG_NO_CONFLICT, r1))\n+\t  return 0;\n+      }\n+      \n+  return ok;\n+}\n+\f\n+/* Return 1 if the constraint string P indicates that the a the operand\n+   must be equal to operand 0 and that no register is acceptable.  */\n+\n+static int\n+requires_inout_p (p)\n+     char *p;\n+{\n+  char c;\n+  int found_zero = 0;\n+\n+  while (c = *p++)\n+    switch (c)\n+      {\n+      case '0':\n+\tfound_zero = 1;\n+\tbreak;\n+\n+      case '=':  case '+':  case '?':\n+      case '#':  case '&':  case '!':\n+      case '*':  case '%':  case ',':\n+      case '1':  case '2':  case '3':  case '4':\n+      case 'm':  case '<':  case '>':  case 'V':  case 'o':\n+      case 'E':  case 'F':  case 'G':  case 'H':\n+      case 's':  case 'i':  case 'n':\n+      case 'I':  case 'J':  case 'K':  case 'L':\n+      case 'M':  case 'N':  case 'O':  case 'P':\n+#ifdef EXTRA_CONSTRAINT\n+      case 'Q':  case 'R':  case 'S':  case 'T':  case 'U':\n+#endif\n+      case 'X':\n+\t/* These don't say anything we care about.  */\n+\tbreak;\n+\n+      case 'p':\n+      case 'g': case 'r':\n+      default:\n+\t/* These mean a register is allowed.  Fail if so.  */\n+\treturn 0;\n+      }\n+\n+  return found_zero;\n+}\n+\f\n+void\n+dump_local_alloc (file)\n+     FILE *file;\n+{\n+  register int i;\n+  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+    if (reg_renumber[i] != -1)\n+      fprintf (file, \";; Register %d in %d.\\n\", i, reg_renumber[i]);\n+}"}]}