{"sha": "473210a961853103e0155332b2df87559cc63f08", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDczMjEwYTk2MTg1MzEwM2UwMTU1MzMyYjJkZjg3NTU5Y2M2M2YwOA==", "commit": {"author": {"name": "Dalibor Topic", "email": "robilad@kaffe.org", "date": "2007-08-08T08:00:32Z"}, "committer": {"name": "Matthias Klose", "email": "doko@gcc.gnu.org", "date": "2007-08-08T08:00:32Z"}, "message": "re PR classpath/32844 (EnumSet causes code to be miscompiled)\n\n2007-07-31  Dalibor Topic  <robilad@kaffe.org>\n\n        PR 32844\n        * java/util/EnumSet.java:\n        Made class abstract per API spec.\n        (size, iterator, add, addAll, clear, contains,\n        containsAll, remove, removeAll, retainAll) Moved \n        into an anonymous inner class in of(T).\n        (allOf, noneOf, copyOf, of, range) Made more \n        implementation independent.\n        (of(T)) return an instance of an anonymous class\n        implementing EmptySet.\n\nFrom-SVN: r127291", "tree": {"sha": "964d5a02b48bb86df99ae1b3278b0daa90e72c4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/964d5a02b48bb86df99ae1b3278b0daa90e72c4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/473210a961853103e0155332b2df87559cc63f08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473210a961853103e0155332b2df87559cc63f08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/473210a961853103e0155332b2df87559cc63f08", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473210a961853103e0155332b2df87559cc63f08/comments", "author": null, "committer": null, "parents": [{"sha": "5b6693af786130f37f0b7cebe023f8004361ff7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b6693af786130f37f0b7cebe023f8004361ff7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b6693af786130f37f0b7cebe023f8004361ff7f"}], "stats": {"total": 468, "additions": 244, "deletions": 224}, "files": [{"sha": "cb34d1daaa1677fb90fe789ddced40a9cd04b765", "filename": "libjava/classpath/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473210a961853103e0155332b2df87559cc63f08/libjava%2Fclasspath%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473210a961853103e0155332b2df87559cc63f08/libjava%2Fclasspath%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog?ref=473210a961853103e0155332b2df87559cc63f08", "patch": "@@ -1,3 +1,16 @@\n+2007-07-31  Dalibor Topic  <robilad@kaffe.org>\n+\n+\tPR 32844\n+\t* java/util/EnumSet.java:\n+\tMade class abstract per API spec.\n+\t(size, iterator, add, addAll, clear, contains,\n+\tcontainsAll, remove, removeAll, retainAll) Moved \n+\tinto an anonymous inner class in of(T).\n+\t(allOf, noneOf, copyOf, of, range) Made more \n+\timplementation independent.\n+\t(of(T)) return an instance of an anonymous class\n+\timplementing EmptySet.\n+ \n 2007-07-28  Matthias Klose  <doko@ubuntu.com>\n \n \t* include/jvmti.h(jniNativeInterface): Rename type."}, {"sha": "543df0c02794ff9432aad29f6233fcc3c6ae42ec", "filename": "libjava/classpath/java/util/EnumSet.java", "status": "modified", "additions": 188, "deletions": 201, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473210a961853103e0155332b2df87559cc63f08/libjava%2Fclasspath%2Fjava%2Futil%2FEnumSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473210a961853103e0155332b2df87559cc63f08/libjava%2Fclasspath%2Fjava%2Futil%2FEnumSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Futil%2FEnumSet.java?ref=473210a961853103e0155332b2df87559cc63f08", "patch": "@@ -43,16 +43,20 @@\n /**\n  * @author Tom Tromey (tromey@redhat.com)\n  * @author Andrew John Hughes (gnu_andrew@member.fsf.org)\n+ * @author Dalibor Topic (robilad@kaffe.org)\n  * @since 1.5 \n  */\n \n-// FIXME: serialization is special.\n-public class EnumSet<T extends Enum<T>>\n+// FIXME: serialization is special, uses SerializationProxy.\n+// of(E e) is the 'bottom' method that creates a real EnumSet.\n+public abstract class EnumSet<T extends Enum<T>>\n   extends AbstractSet<T>\n   implements Cloneable, Serializable\n {\n   private static final long serialVersionUID = 4782406773684236311L;\n \n+  // These fields could go into the anonymous inner class in of(E),\n+  // complementOf would need to be refactored then, though.\n   BitSet store;\n   int cardinality;\n   Class<T> enumClass;\n@@ -78,288 +82,271 @@ public EnumSet<T> clone()\n     return r;\n   }\n \n-  public int size()\n+  public static <T extends Enum<T>> EnumSet<T> allOf(Class<T> eltType)\n   {\n-    return cardinality;\n+    // create an EnumSet from the list of values of the type\n+    return copyOf(Arrays.asList(eltType.getEnumConstants()));\n   }\n \n-  public Iterator<T> iterator()\n+  public static <T extends Enum<T>> EnumSet<T> noneOf(Class<T> eltType)\n   {\n-    return new Iterator<T>()\n-    {\n-      int next = -1;\n-      int count = 0;\n+    return complementOf(allOf(eltType));\n+  }\n \n-      public boolean hasNext()\n-      {\n-\treturn count < cardinality;\n-      }\n+  public static <T extends Enum<T>> EnumSet<T> copyOf(EnumSet<T> other)\n+  {\n+    return other.clone();\n+  }\n \n-      public T next()\n-      {\n-\tnext = store.nextSetBit(next + 1);\n-\t++count;\n-\treturn enumClass.getEnumConstants()[next];\n-      }\n+  public static <T extends Enum<T>> EnumSet<T> copyOf(Collection<T> other)\n+  {\n+    if (other instanceof EnumSet)\n+      return copyOf((EnumSet<T>) other);\n+    if (other.isEmpty())\n+\tthrow new IllegalArgumentException(\"Collection is empty\");\n \n-      public void remove()\n+    EnumSet<T> r = null;\n+\n+    for (T val : other)\n       {\n-\tif (! store.get(next))\n-\t  {\n-\t    store.clear(next);\n-\t    --cardinality;\n-\t  }\n+\tif (r == null)\n+\t  r = of(val);\n+\telse\n+\t  r.add(val);\n       }\n-    };\n+\n+    return r;\n   }\n \n-  public boolean add(T val)\n+  public static <T extends Enum<T>> EnumSet<T> complementOf(EnumSet<T> other)\n   {\n-    if (store.get(val.ordinal()))\n-      return false;\n-    store.set(val.ordinal());\n-    ++cardinality;\n-    return true;\n+    EnumSet<T> r = other.clone();\n+    r.store.flip(0, r.store.size());\n+    r.cardinality = r.store.size() - other.cardinality;\n+    return r;\n   }\n \n-  public boolean addAll(Collection<? extends T> c)\n+  public static <T extends Enum<T>> EnumSet<T> of(T first)\n   {\n-    boolean result = false;\n-    if (c instanceof EnumSet)\n+    EnumSet<T> r = new EnumSet<T>()\n+    {\n+      public boolean add(T val)\n+      {\n+\tif (store.get(val.ordinal()))\n+\t  return false;\n+\n+\tstore.set(val.ordinal());\n+\t++cardinality;\n+\treturn true;\n+      }\n+\n+      public boolean addAll(Collection<? extends T> c)\n       {\n-\tEnumSet<T> other = (EnumSet<T>) c;\n-\tif (enumClass == other.enumClass)\n+\tboolean result = false;\n+\tif (c instanceof EnumSet)\n+\t{\n+\t  EnumSet<T> other = (EnumSet<T>) c;\n+\t  if (enumClass == other.enumClass)\n \t  {\n \t    store.or(other.store);\n \t    int save = cardinality;\n \t    cardinality = store.cardinality();\n \t    result = save != cardinality;\n \t  }\n-      }\n-    else\n-      {\n-\tfor (T val : c)\n+\t}\n+\telse\n+\t{\n+\t  for (T val : c)\n \t  {\n \t    if (add (val))\n-\t      result = true;\n+\t    result = true;\n \t  }\n+\t}\n+\treturn result;\n       }\n-    return result;\n-  }\n \n-  public void clear()\n-  {\n-    store.clear();\n-    cardinality = 0;\n-  }\n-\n-  public boolean contains(Object o)\n-  {\n-    if (! (o instanceof Enum))\n-      return false;\n-    Enum<T> e = (Enum<T>) o;\n-    if (e.getDeclaringClass() != enumClass)\n-      return false;\n-    return store.get(e.ordinal());\n-  }\n-\n-  public boolean containsAll(Collection<?> c)\n-  {\n-    if (c instanceof EnumSet)\n+      public void clear()\n       {\n-\tEnumSet<T> other = (EnumSet<T>) c;\n-\tif (enumClass == other.enumClass)\n-\t  return store.containsAll(other.store);\n-\treturn false;\n+\tstore.clear();\n+\tcardinality = 0;\n       }\n-    return super.containsAll(c);\n-  }\n-\n-  public boolean remove(Object o)\n-  {\n-    if (! (o instanceof Enum))\n-      return false;\n-    Enum<T> e = (Enum<T>) o;\n-    if (e.getDeclaringClass() != enumClass)\n-      return false;\n-    store.clear(e.ordinal());\n-    --cardinality;\n-    return true;\n-  }\n \n-  public boolean removeAll(Collection<?> c)\n-  {\n-    if (c instanceof EnumSet)\n+      public boolean contains(Object o)\n       {\n-\tEnumSet<T> other = (EnumSet<T>) c;\n-\tif (enumClass != other.enumClass)\n+\tif (! (o instanceof Enum))\n+\t  return false;\n+\n+\tEnum<T> e = (Enum<T>) o;\n+\tif (e.getDeclaringClass() != enumClass)\n \t  return false;\n-\tstore.andNot(other.store);\n-\tint save = cardinality;\n-\tcardinality = store.cardinality();\n-\treturn save != cardinality;\n+\n+\treturn store.get(e.ordinal());\n       }\n-    return super.removeAll(c);\n-  }\n \n-  public boolean retainAll(Collection<?> c)\n-  {\n-    if (c instanceof EnumSet)\n+      public boolean containsAll(Collection<?> c)\n       {\n-\tEnumSet<T> other = (EnumSet<T>) c;\n-\tif (enumClass != other.enumClass)\n+\tif (c instanceof EnumSet)\n+\t{\n+\t  EnumSet<T> other = (EnumSet<T>) c;\n+\t  if (enumClass == other.enumClass)\n+\t    return store.containsAll(other.store);\n+\n \t  return false;\n-\tstore.and(other.store);\n-\tint save = cardinality;\n-\tcardinality = store.cardinality();\n-\treturn save != cardinality;\n+\t}\n+\treturn super.containsAll(c);\n       }\n-    return super.retainAll(c);\n-  }\n \n-  public static <T extends Enum<T>> EnumSet<T> allOf(Class<T> eltType)\n-  {\n-    EnumSet<T> r = new EnumSet<T>();\n-    r.store = new BitSet(eltType.getEnumConstants().length);\n-    r.store.set(0, r.store.size());\n-    r.cardinality = r.store.size();\n-    r.enumClass = eltType;\n-    return r;\n-  }\n+      public Iterator<T> iterator()\n+      {\n+\treturn new Iterator<T>()\n+\t{\n+\t  int next = -1;\n+\t  int count = 0;\n \n-  public static <T extends Enum<T>> EnumSet<T> noneOf(Class<T> eltType)\n-  {\n-    EnumSet<T> r = new EnumSet<T>();\n-    r.store = new BitSet(eltType.getEnumConstants().length);\n-    r.enumClass = eltType;\n-    return r;\n-  }\n+\t  public boolean hasNext()\n+\t  {\n+\t    return count < cardinality;\n+\t  }\n \n-  public static <T extends Enum<T>> EnumSet<T> copyOf(EnumSet<T> other)\n-  {\n-    // We can't just use `other.clone' since we don't want to make a\n-    // subclass.\n-    EnumSet<T> r = new EnumSet<T>();\n-    r.store = (BitSet) other.store.clone();\n-    r.cardinality = other.cardinality;\n-    r.enumClass = other.enumClass;\n-    return r;\n-  }\n+\t  public T next()\n+\t  {\n+\t    next = store.nextSetBit(next + 1);\n+\t    ++count;\n+\t    return enumClass.getEnumConstants()[next];\n+\t  }\n \n-  public static <T extends Enum<T>> EnumSet<T> copyOf(Collection<T> other)\n-  {\n-    if (other instanceof EnumSet)\n-      return copyOf((EnumSet<T>) other);\n-    EnumSet<T> r = new EnumSet<T>();\n-    for (T val : other)\n-      {\n-\tif (r.store == null)\n+\t  public void remove()\n \t  {\n-\t    r.enumClass = val.getDeclaringClass();\n-\t    r.store = new BitSet(r.enumClass.getEnumConstants().length);\n+\t    if (! store.get(next))\n+\t    {\n+\t\tstore.clear(next);\n+\t\t--cardinality;\n+\t    }\n \t  }\n-\tr.store.set(val.ordinal());\n+\t};\n       }\n-    // The collection must contain at least one element.\n-    if (r.store == null)\n-      throw new IllegalArgumentException();\n-    r.cardinality = r.store.cardinality();\n-    return r;\n-  }\n \n-  public static <T extends Enum<T>> EnumSet<T> complementOf(EnumSet<T> other)\n-  {\n-    EnumSet<T> r = new EnumSet<T>();\n-    r.store = (BitSet) other.store.clone();\n-    r.store.flip(0, r.store.size());\n-    r.cardinality = r.store.size() - other.cardinality;\n-    r.enumClass = other.enumClass;\n-    return r;\n-  }\n+      public boolean remove(Object o)\n+      {\n+\tif (! (o instanceof Enum))\n+\t  return false;\n \n-  public static <T extends Enum<T>> EnumSet<T> of(T first)\n-  {\n-    EnumSet<T> r = new EnumSet<T>();\n+\tEnum<T> e = (Enum<T>) o;\n+\tif (e.getDeclaringClass() != enumClass)\n+\t  return false;\n+\n+\tstore.clear(e.ordinal());\n+\t--cardinality;\n+\treturn true;\n+      }\n+\n+      public boolean removeAll(Collection<?> c)\n+      {\n+\tif (c instanceof EnumSet)\n+\t{\n+\t  EnumSet<T> other = (EnumSet<T>) c;\n+\t  if (enumClass != other.enumClass)\n+\t    return false;\n+\n+\t  store.andNot(other.store);\n+\t  int save = cardinality;\n+\t  cardinality = store.cardinality();\n+\t  return save != cardinality;\n+\t}\n+\treturn super.removeAll(c);\n+      }\n+\n+      public boolean retainAll(Collection<?> c)\n+      {\n+\tif (c instanceof EnumSet)\n+\t{\n+\t  EnumSet<T> other = (EnumSet<T>) c;\n+\t  if (enumClass != other.enumClass)\n+\t    return false;\n+\n+\t  store.and(other.store);\n+\t  int save = cardinality;\n+\t  cardinality = store.cardinality();\n+\t  return save != cardinality;\n+\t}\n+\treturn super.retainAll(c);\n+      }\n+\n+      public int size()\n+      {\n+\treturn cardinality;\n+      }\n+    };\n+\n+    // initialize the class\n     r.enumClass = first.getDeclaringClass();\n     r.store = new BitSet(r.enumClass.getEnumConstants().length);\n-    r.store.set(first.ordinal());\n-    r.cardinality = 1;\n+\n+    r.add(first);\n     return r;\n   }\n \n   public static <T extends Enum<T>> EnumSet<T> of(T first, T second)\n   {\n-    EnumSet<T> r = new EnumSet<T>();\n-    r.enumClass = first.getDeclaringClass();\n-    r.store = new BitSet(r.enumClass.getEnumConstants().length);\n-    r.store.set(first.ordinal());\n-    r.store.set(second.ordinal());\n-    r.cardinality = r.store.cardinality();\n+    EnumSet<T> r = of(first);\n+    r.add(second);\n     return r;\n   }\n \n   public static <T extends Enum<T>> EnumSet<T> of(T first, T second, T third)\n   {\n-    EnumSet<T> r = new EnumSet<T>();\n-    r.enumClass = first.getDeclaringClass();\n-    r.store = new BitSet(r.enumClass.getEnumConstants().length);\n-    r.store.set(first.ordinal());\n-    r.store.set(second.ordinal());\n-    r.store.set(third.ordinal());\n-    r.cardinality = r.store.cardinality();\n+    EnumSet<T> r = of(first, second);\n+    r.add(third);\n     return r;\n   }\n \n   public static <T extends Enum<T>> EnumSet<T> of(T first, T second, T third,\n \t\t\t\t\t\t  T fourth)\n   {\n-    EnumSet<T> r = new EnumSet<T>();\n-    r.enumClass = first.getDeclaringClass();\n-    r.store = new BitSet(r.enumClass.getEnumConstants().length);\n-    r.store.set(first.ordinal());\n-    r.store.set(second.ordinal());\n-    r.store.set(third.ordinal());\n-    r.store.set(fourth.ordinal());\n-    r.cardinality = r.store.cardinality();\n+    EnumSet<T> r = of(first, second, third);\n+    r.add(fourth);\n     return r;\n   }\n \n   public static <T extends Enum<T>> EnumSet<T> of(T first, T second, T third,\n \t\t\t\t\t\t  T fourth, T fifth)\n   {\n-    EnumSet<T> r = new EnumSet<T>();\n-    r.enumClass = first.getDeclaringClass();\n-    r.store = new BitSet(r.enumClass.getEnumConstants().length);\n-    r.store.set(first.ordinal());\n-    r.store.set(second.ordinal());\n-    r.store.set(third.ordinal());\n-    r.store.set(fourth.ordinal());\n-    r.store.set(fifth.ordinal());\n-    r.cardinality = r.store.cardinality();\n+    EnumSet<T> r = of(first, second, third, fourth);\n+    r.add(fifth);\n     return r;\n   }\n \n   public static <T extends Enum<T>> EnumSet<T> of(T first, T... rest)\n   {\n-    EnumSet<T> r = new EnumSet<T>();\n-    r.enumClass = first.getDeclaringClass();\n-    r.store = new BitSet(r.enumClass.getEnumConstants().length);\n-    r.store.set(first.ordinal());\n+    EnumSet<T> r = noneOf(first.getDeclaringClass());\n+    r.add(first);\n     for (T val : rest)\n-      r.store.set(val.ordinal());\n-    r.cardinality = r.store.cardinality();\n+      r.add(val);\n     return r;\n   }\n \n   public static <T extends Enum<T>> EnumSet<T> range(T from, T to)\n   {\n     if (from.compareTo(to) > 0)\n       throw new IllegalArgumentException();\n-    EnumSet<T> r = new EnumSet<T>();\n-    r.store = new BitSet(from.getDeclaringClass().getEnumConstants().length);\n-    r.store.set(from.ordinal(), to.ordinal() + 1);\n-    r.enumClass = from.getDeclaringClass();\n-    r.cardinality = to.ordinal() - from.ordinal() + 1;\n+    Class<T> type = from.getDeclaringClass();\n+    EnumSet<T> r = noneOf(type);\n+\n+    T[] values = type.getEnumConstants();\n+    // skip over values until start of range is found\n+    int i = 0;\n+    while (from != values[i])\n+      i++;\n+\n+    // add values until end of range is found\n+    while (to != values[i]) {\n+      r.add(values[i]);\n+      i++;\n+    }\n+\n+    // add end of range\n+    r.add(to);\n+\n     return r;\n   }\n }"}, {"sha": "c390f5bdf69a08ae2b8be9cea3af9477197e5033", "filename": "libjava/classpath/lib/java/util/EnumSet$1.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473210a961853103e0155332b2df87559cc63f08/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FEnumSet%241.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473210a961853103e0155332b2df87559cc63f08/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FEnumSet%241.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FEnumSet%241.class?ref=473210a961853103e0155332b2df87559cc63f08"}, {"sha": "59eec59f2b00a7453613f73ba73ff8ce5a539dcf", "filename": "libjava/classpath/lib/java/util/EnumSet$2.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473210a961853103e0155332b2df87559cc63f08/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FEnumSet%242.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473210a961853103e0155332b2df87559cc63f08/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FEnumSet%242.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FEnumSet%242.class?ref=473210a961853103e0155332b2df87559cc63f08"}, {"sha": "68aa8a803c125a4221ba7ae5e2230c85a480304f", "filename": "libjava/classpath/lib/java/util/EnumSet.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473210a961853103e0155332b2df87559cc63f08/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FEnumSet.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473210a961853103e0155332b2df87559cc63f08/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FEnumSet.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FEnumSet.class?ref=473210a961853103e0155332b2df87559cc63f08"}, {"sha": "3e247ec9bd5a751b53c836542bc031697a9c60dd", "filename": "libjava/java/util/EnumSet$1.h", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473210a961853103e0155332b2df87559cc63f08/libjava%2Fjava%2Futil%2FEnumSet%241.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473210a961853103e0155332b2df87559cc63f08/libjava%2Fjava%2Futil%2FEnumSet%241.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FEnumSet%241.h?ref=473210a961853103e0155332b2df87559cc63f08", "patch": "@@ -6,23 +6,25 @@\n \n #pragma interface\n \n-#include <java/lang/Object.h>\n+#include <java/util/EnumSet.h>\n \n-class java::util::EnumSet$1 : public ::java::lang::Object\n+class java::util::EnumSet$1 : public ::java::util::EnumSet\n {\n \n public: // actually package-private\n-  EnumSet$1(::java::util::EnumSet *);\n-public:\n-  jboolean hasNext();\n-  ::java::lang::Enum * EnumSet$1$next();\n-  void remove();\n-  ::java::lang::Object * next();\n-public: // actually package-private\n-  jint __attribute__((aligned(__alignof__( ::java::lang::Object)))) next__;\n-  jint count;\n-  ::java::util::EnumSet * this$0;\n+  EnumSet$1();\n public:\n+  jboolean EnumSet$1$add(::java::lang::Enum *);\n+  jboolean addAll(::java::util::Collection *);\n+  void clear();\n+  jboolean contains(::java::lang::Object *);\n+  jboolean containsAll(::java::util::Collection *);\n+  ::java::util::Iterator * iterator();\n+  jboolean remove(::java::lang::Object *);\n+  jboolean removeAll(::java::util::Collection *);\n+  jboolean retainAll(::java::util::Collection *);\n+  jint size();\n+  jboolean add(::java::lang::Object *);\n   static ::java::lang::Class class$;\n };\n "}, {"sha": "e80b9789bed8a924cfd12ddef9ed94588710c487", "filename": "libjava/java/util/EnumSet$2.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473210a961853103e0155332b2df87559cc63f08/libjava%2Fjava%2Futil%2FEnumSet%242.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473210a961853103e0155332b2df87559cc63f08/libjava%2Fjava%2Futil%2FEnumSet%242.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FEnumSet%242.h?ref=473210a961853103e0155332b2df87559cc63f08", "patch": "@@ -0,0 +1,29 @@\n+\n+// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-\n+\n+#ifndef __java_util_EnumSet$2__\n+#define __java_util_EnumSet$2__\n+\n+#pragma interface\n+\n+#include <java/lang/Object.h>\n+\n+class java::util::EnumSet$2 : public ::java::lang::Object\n+{\n+\n+public: // actually package-private\n+  EnumSet$2(::java::util::EnumSet$1 *);\n+public:\n+  jboolean hasNext();\n+  ::java::lang::Enum * EnumSet$2$next();\n+  void remove();\n+  ::java::lang::Object * next();\n+public: // actually package-private\n+  jint __attribute__((aligned(__alignof__( ::java::lang::Object)))) next__;\n+  jint count;\n+  ::java::util::EnumSet$1 * this$1;\n+public:\n+  static ::java::lang::Class class$;\n+};\n+\n+#endif // __java_util_EnumSet$2__"}, {"sha": "5497e306d8cbe619c189ca26bc804dd595bb1a0d", "filename": "libjava/java/util/EnumSet.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473210a961853103e0155332b2df87559cc63f08/libjava%2Fjava%2Futil%2FEnumSet.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473210a961853103e0155332b2df87559cc63f08/libjava%2Fjava%2Futil%2FEnumSet.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FEnumSet.h?ref=473210a961853103e0155332b2df87559cc63f08", "patch": "@@ -17,16 +17,6 @@ class java::util::EnumSet : public ::java::util::AbstractSet\n   EnumSet();\n public:\n   virtual ::java::util::EnumSet * EnumSet$clone();\n-  virtual jint size();\n-  virtual ::java::util::Iterator * iterator();\n-  virtual jboolean EnumSet$add(::java::lang::Enum *);\n-  virtual jboolean addAll(::java::util::Collection *);\n-  virtual void clear();\n-  virtual jboolean contains(::java::lang::Object *);\n-  virtual jboolean containsAll(::java::util::Collection *);\n-  virtual jboolean remove(::java::lang::Object *);\n-  virtual jboolean removeAll(::java::util::Collection *);\n-  virtual jboolean retainAll(::java::util::Collection *);\n   static ::java::util::EnumSet * allOf(::java::lang::Class *);\n   static ::java::util::EnumSet * noneOf(::java::lang::Class *);\n   static ::java::util::EnumSet * copyOf(::java::util::EnumSet *);\n@@ -40,7 +30,6 @@ class java::util::EnumSet : public ::java::util::AbstractSet\n   static ::java::util::EnumSet * of(::java::lang::Enum *, JArray< ::java::lang::Enum * > *);\n   static ::java::util::EnumSet * range(::java::lang::Enum *, ::java::lang::Enum *);\n   virtual ::java::lang::Object * clone();\n-  virtual jboolean add(::java::lang::Object *);\n private:\n   static const jlong serialVersionUID = 4782406773684236311LL;\n public: // actually package-private"}]}