{"sha": "cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IyZDg4NGQ3ZDJiNWZlODNhYmE0MmYxMzg3NTQyYjUwZDVmMDZiMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-02-20T09:11:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-02-20T09:11:44Z"}, "message": "gnat_rm.texi, [...]: Now automatically generated from sphinx in the doc directory.\n\n2015-02-20  Arnaud Charlet  <charlet@adacore.com>                      \n\n        * gnat_rm.texi, gnat_ugn.texi: Now automatically generated from\n        sphinx in the doc directory.\n        * doc: New directory containing sphinx versions of gnat_rm and gnat_ugn\n\nFrom-SVN: r220837", "tree": {"sha": "8595086bf6f09398ca79a336e320d885e52b2c66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8595086bf6f09398ca79a336e320d885e52b2c66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/comments", "author": null, "committer": null, "parents": [{"sha": "07a64c021a8fbd6df4d411b9852cfa95afb1cf08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07a64c021a8fbd6df4d411b9852cfa95afb1cf08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07a64c021a8fbd6df4d411b9852cfa95afb1cf08"}], "stats": {"total": 152773, "additions": 110854, "deletions": 41919}, "files": [{"sha": "9a8070ce612a5120b9f44ce8c5f8be2acd652b1d", "filename": "gcc/ada/doc/Makefile", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2FMakefile?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,79 @@\n+# Makefile for Sphinx documentation\n+\n+# You can set these variables from the command line.\n+SPHINXOPTS    =\n+SPHINXBUILD   = DOC_NAME=$* sphinx-build\n+PAPER         =\n+BUILDDIR      = build\n+SOURCEDIR     = .\n+\n+# Internal variables.\n+PAPEROPT_a4     = -D latex_paper_size=a4\n+PAPEROPT_letter = -D latex_paper_size=letter\n+ALLSPHINXOPTS   = $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) \\\n+\t\t  -c $(SOURCEDIR)/share \\\n+\t\t  -d $(BUILDDIR)/$*/doctrees \\\n+\t\t  $(SOURCEDIR)\n+DOC_LIST=gnat_rm gnat_ugn\n+FMT_LIST=html pdf txt info\n+\n+.PHONY: help clean\n+\n+help:\n+\t@echo \"Please use \\`make <target>' where <target> is one of\"\n+\t@echo \"  DOC_NAME.html       to make standalone HTML files\"\n+\t@echo \"  DOC_NAME.pdf        to make LaTeX files and run them through pdflatex\"\n+\t@echo \"  DOC_NAME.txt        to make text files\"\n+\t@echo \"  DOC_NAME.texinfo    to make Texinfo files\"\n+\t@echo \"  DOC_NAME.info       to make info files\"\n+\t@echo \"  DOC_NAME.all        to build DOC_NAME for all previous formats\"\n+\t@echo \"  all                 to build all documentations in all formats\"\n+\t@echo \"  html-all            same as previous rule but only for HTML format\"\n+\t@echo \"  pdf-all             same as previous rule but only for PDF format\"\n+\t@echo \"  txt-all             same as previous rule but only for text format\"\n+\t@echo \"  texinfo-all         same as previous rule but only for texinfo format\"\n+\t@echo \"  info-all            same as previous rule but only for info format\"\n+\t@echo \"\"\n+\t@echo \"DOC_NAME should be a documentation name in the following list:\"\n+\t@echo \"  $(DOC_LIST)\"\n+\t@echo \"\"\n+\t@echo \"source and location can be overriden using SOURCEDIR and BUILDDIR variables\"\n+\n+clean:\n+\t-rm -rf $(BUILDDIR)/*/html \\\n+\t\t$(BUILDDIR)/*/pdf \\\n+\t\t$(BUILDDIR)/*/txt \\\n+\t\t$(BUILDDIR)/*/info\n+\n+%.html:\n+\t$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/$*/html\n+\n+%.pdf:\n+\t$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/$*/pdf\n+\tcp $(SOURCEDIR)/share/sphinx.sty $(BUILDDIR)/$*/pdf\n+\t$(MAKE) -C $(BUILDDIR)/$*/pdf all-pdf LATEXOPTS=\"-interaction=nonstopmode\"\n+\n+%.txt:\n+\t$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/$*/txt\n+\t$(MAKE) -C $(BUILDDIR)/$*/txt plaintext\n+\n+%.info:\n+\t$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/$*/info\n+\t$(MAKE) -C $(BUILDDIR)/$*/info info\n+\n+%.texinfo:\n+\t$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/$*/texinfo\n+\n+html-all: $(foreach doc, $(DOC_LIST), $(doc).html)\n+\n+pdf-all: $(foreach doc, $(DOC_LIST), $(doc).pdf)\n+\n+txt-all: $(foreach doc, $(DOC_LIST), $(doc).txt)\n+\n+texinfo-all: $(foreach doc, $(DOC_LIST), $(doc).texinfo)\n+\n+%.all:\n+\t$(MAKE) $(foreach fmt, $(FMT_LIST), $*.$(fmt))\n+\n+all: $(foreach fmt, $(FMT_LIST), $(fmt).all)\n+"}, {"sha": "a9ea40d679ed4ba68ae1da8ec3ee29a7c515a2eb", "filename": "gcc/ada/doc/gnat_rm.rst", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,66 @@\n+GNAT Reference Manual\n+=====================\n+\n+*GNAT, The GNU Ada Development Environment*\n+\n+.. only:: PRO\n+   \n+   *GNAT Pro Edition*\n+   \n+   | Version |version|\n+   | Date: |today|\n+\n+.. only:: GPL\n+   \n+   *GNAT GPL Edition*\n+   \n+   | Version |version|\n+   | Date: |today|\n+\n+.. only:: FSF\n+   \n+   .. raw:: texinfo\n+      \n+      @include gcc-common.texi\n+      GCC version @value{version-GCC}@*\n+\n+AdaCore\n+\n+Permission is granted to copy, distribute and/or modify this document\n+under the terms of the GNU Free Documentation License, Version 1.3 or\n+any later version published by the Free Software Foundation; with no\n+Invariant Sections, with the Front-Cover Texts being \"GNAT Reference\n+Manual\", and with no Back-Cover Texts.  A copy of the license is\n+included in the section entitled :ref:`gnu_fdl`.\n+\n+.. toctree::\n+   :numbered:\n+   :maxdepth: 3\n+\n+   gnat_rm/about_this_guide\n+   gnat_rm/implementation_defined_pragmas\n+   gnat_rm/implementation_defined_aspects\n+   gnat_rm/implementation_defined_attributes\n+   gnat_rm/standard_and_implementation_defined_restrictions\n+   gnat_rm/implementation_advice\n+   gnat_rm/implementation_defined_characteristics\n+   gnat_rm/intrinsic_subprograms\n+   gnat_rm/representation_clauses_and_pragmas\n+   gnat_rm/standard_library_routines\n+   gnat_rm/the_implementation_of_standard_i_o\n+   gnat_rm/the_gnat_library\n+   gnat_rm/interfacing_to_other_languages\n+   gnat_rm/specialized_needs_annexes\n+   gnat_rm/implementation_of_specific_ada_features\n+   gnat_rm/implementation_of_ada_2012_features\n+   gnat_rm/obsolescent_features\n+   gnat_rm/compatibility_and_porting_guide\n+\n+.. raw:: latex\n+\n+   \\appendix\n+\n+.. toctree::\n+   :maxdepth: 3\n+\n+   share/gnu_free_documentation_license"}, {"sha": "ad3ca5f460a758232fb0f151b7051c14ba773884", "filename": "gcc/ada/doc/gnat_rm/about_this_guide.rst", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fabout_this_guide.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fabout_this_guide.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fabout_this_guide.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,185 @@\n+.. _About_This_Guide:\n+\n+****************\n+About This Guide\n+****************\n+\n+.. only:: PRO\n+\n+   For ease of exposition, 'GNAT Pro' will be referred to simply as\n+   'GNAT' in the remainder of this document.\n+\n+This manual contains useful information in writing programs using the\n+GNAT compiler.  It includes information on implementation dependent\n+characteristics of GNAT, including all the information required by\n+Annex M of the Ada language standard.\n+\n+GNAT implements Ada 95, Ada 2005 and Ada 2012, and it may also be\n+invoked in Ada 83 compatibility mode.\n+By default, GNAT assumes Ada 2012,\n+but you can override with a compiler switch\n+to explicitly specify the language version.\n+(Please refer to the *GNAT User's Guide* for details on these switches.)\n+Throughout this manual, references to 'Ada' without a year suffix\n+apply to all the Ada versions of the language.\n+\n+Ada is designed to be highly portable.\n+In general, a program will have the same effect even when compiled by\n+different compilers on different platforms.\n+However, since Ada is designed to be used in a\n+wide variety of applications, it also contains a number of system\n+dependent features to be used in interfacing to the external world.\n+.. index:: Implementation-dependent features\n+\n+.. index:: Portability\n+\n+Note: Any program that makes use of implementation-dependent features\n+may be non-portable.  You should follow good programming practice and\n+isolate and clearly document any sections of your program that make use\n+of these features in a non-portable manner.\n+\n+What This Reference Manual Contains\n+===================================\n+\n+This reference manual contains the following chapters:\n+\n+* :ref:`Implementation_Defined_Pragmas`, lists GNAT implementation-dependent\n+  pragmas, which can be used to extend and enhance the functionality of the\n+  compiler.\n+\n+* :ref:`Implementation_Defined_Attributes`, lists GNAT\n+  implementation-dependent attributes, which can be used to extend and\n+  enhance the functionality of the compiler.\n+\n+* :ref:`Standard_and_Implementation_Defined_Restrictions`, lists GNAT\n+  implementation-dependent restrictions, which can be used to extend and\n+  enhance the functionality of the compiler.\n+\n+* :ref:`Implementation_Advice`, provides information on generally\n+  desirable behavior which are not requirements that all compilers must\n+  follow since it cannot be provided on all systems, or which may be\n+  undesirable on some systems.\n+\n+* :ref:`Implementation_Defined_Characteristics`, provides a guide to\n+  minimizing implementation dependent features.\n+\n+* :ref:`Intrinsic_Subprograms`, describes the intrinsic subprograms\n+  implemented by GNAT, and how they can be imported into user\n+  application programs.\n+\n+* :ref:`Representation_Clauses_and_Pragmas`, describes in detail the\n+  way that GNAT represents data, and in particular the exact set\n+  of representation clauses and pragmas that is accepted.\n+\n+* :ref:`Standard_Library_Routines`, provides a listing of packages and a\n+  brief description of the functionality that is provided by Ada's\n+  extensive set of standard library routines as implemented by GNAT.\n+\n+* :ref:`The_Implementation_of_Standard_I/O`, details how the GNAT\n+  implementation of the input-output facilities.\n+\n+* :ref:`The_GNAT_Library`, is a catalog of packages that complement\n+  the Ada predefined library.\n+\n+* :ref:`Interfacing_to_Other_Languages`, describes how programs\n+  written in Ada using GNAT can be interfaced to other programming\n+  languages.\n+\n+* :ref:`Specialized_Needs_Annexes`, describes the GNAT implementation of all\n+  of the specialized needs annexes.\n+\n+* :ref:`Implementation_of_Specific_Ada_Features`, discusses issues related\n+  to GNAT's implementation of machine code insertions, tasking, and several\n+  other features.\n+\n+* :ref:`Implementation_of_Ada_2012_Features`, describes the status of the\n+  GNAT implementation of the Ada 2012 language standard.\n+\n+* :ref:`Obsolescent_Features` documents implementation dependent features,\n+  including pragmas and attributes, which are considered obsolescent, since\n+  there are other preferred ways of achieving the same results. These\n+  obsolescent forms are retained for backwards compatibility.\n+\n+* :ref:`Compatibility_and_Porting_Guide` presents some guidelines for\n+  developing portable Ada code, describes the compatibility issues that\n+  may arise between GNAT and other Ada compilation systems (including those\n+  for Ada 83), and shows how GNAT can expedite porting applications\n+  developed in other Ada environments.\n+\n+* :ref:`gnu_fdl` contains the license for this document.\n+\n+.. index:: Ada 95 Language Reference Manual\n+\n+.. index:: Ada 2005 Language Reference Manual\n+\n+This reference manual assumes a basic familiarity with the Ada 95 language, as\n+described in the \n+:title:`International Standard ANSI/ISO/IEC-8652:1995`.\n+It does not require knowledge of the new features introduced by Ada 2005,\n+(officially known as `ISO/IEC 8652:1995 with Technical Corrigendum 1\n+and Amendment 1`).\n+Both reference manuals are included in the GNAT documentation\n+package.\n+\n+Conventions\n+===========\n+.. index:: Conventions, typographical\n+\n+.. index:: Typographical conventions\n+\n+Following are examples of the typographical and graphic conventions used\n+in this guide:\n+\n+* `Functions`, `utility program names`, `standard names`,\n+  and `classes`.\n+\n+* `Option flags`\n+\n+* :file:`File names`\n+\n+* `Variables`\n+\n+* *Emphasis*\n+\n+* [optional information or parameters]\n+\n+* Examples are described by text\n+\n+  ::\n+\n+    and then shown this way.\n+    \n+* Commands that are entered by the user are shown as preceded by a prompt string\n+  comprising the ``$`` character followed by a space.\n+  \n+Related Information\n+===================\n+\n+See the following documents for further information on GNAT:\n+\n+* :title:`GNAT User's Guide for Native Platforms`,\n+  which provides information on how to use the\n+  GNAT development environment.\n+\n+* :title:`Ada 95 Reference Manual`, the Ada 95 programming language standard.\n+\n+* :title:`Ada 95 Annotated Reference Manual`, which is an annotated version\n+  of the Ada 95 standard.  The annotations describe\n+  detailed aspects of the design decision, and in particular contain useful\n+  sections on Ada 83 compatibility.\n+\n+* :title:`Ada 2005 Reference Manual`, the Ada 2005 programming language standard.\n+\n+* :title:`Ada 2005 Annotated Reference Manual`, which is an annotated version\n+  of the Ada 2005 standard.  The annotations describe\n+  detailed aspects of the design decision.\n+\n+* :title:`Ada 2012 Reference Manual`, the Ada 2012 programming language standard.\n+\n+* :title:`DEC Ada, Technical Overview and Comparison on DIGITAL Platforms`,\n+  which contains specific information on compatibility between GNAT and\n+  DEC Ada 83 systems.\n+\n+* :title:`DEC Ada, Language Reference Manual`, part number AA-PYZAB-TK, which\n+  describes in detail the pragmas and attributes provided by the DEC Ada 83\n+  compiler system."}, {"sha": "153d585b54709bb4122f36142439a45f22c7f0e9", "filename": "gcc/ada/doc/gnat_rm/compatibility_and_porting_guide.rst", "status": "added", "additions": 661, "deletions": 0, "changes": 661, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fcompatibility_and_porting_guide.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fcompatibility_and_porting_guide.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fcompatibility_and_porting_guide.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,661 @@\n+.. _Compatibility_and_Porting_Guide:\n+\n+*******************************\n+Compatibility and Porting Guide\n+*******************************\n+\n+This chapter presents some guidelines for developing portable Ada code,\n+describes the compatibility issues that may arise between\n+GNAT and other Ada compilation systems (including those for Ada 83),\n+and shows how GNAT can expedite porting\n+applications developed in other Ada environments.\n+\n+.. _Writing_Portable_Fixed-Point_Declarations:\n+\n+Writing Portable Fixed-Point Declarations\n+=========================================\n+\n+The Ada Reference Manual gives an implementation freedom to choose bounds\n+that are narrower by `Small` from the given bounds.\n+For example, if we write\n+\n+.. code-block:: ada\n+\n+     type F1 is delta 1.0 range -128.0 .. +128.0;\n+  \n+then the implementation is allowed to choose -128.0 .. +127.0 if it\n+likes, but is not required to do so.\n+\n+This leads to possible portability problems, so let's have a closer\n+look at this, and figure out how to avoid these problems.\n+\n+First, why does this freedom exist, and why would an implementation\n+take advantage of it? To answer this, take a closer look at the type\n+declaration for `F1` above. If the compiler uses the given bounds,\n+it would need 9 bits to hold the largest positive value (and typically\n+that means 16 bits on all machines). But if the implementation chooses\n+the +127.0 bound then it can fit values of the type in 8 bits.\n+\n+Why not make the user write +127.0 if that's what is wanted?\n+The rationale is that if you are thinking of fixed point\n+as a kind of 'poor man's floating-point', then you don't want\n+to be thinking about the scaled integers that are used in its\n+representation. Let's take another example:\n+\n+.. code-block:: ada\n+\n+      type F2 is delta 2.0**(-15) range -1.0 .. +1.0;\n+  \n+Looking at this declaration, it seems casually as though\n+it should fit in 16 bits, but again that extra positive value\n++1.0 has the scaled integer equivalent of 2**15 which is one too\n+big for signed 16 bits. The implementation can treat this as:\n+\n+.. code-block:: ada\n+\n+     type F2 is delta 2.0**(-15) range -1.0 .. +1.0-(2.0**(-15));\n+  \n+and the Ada language design team felt that this was too annoying\n+to require. We don't need to debate this decision at this point,\n+since it is well established (the rule about narrowing the ranges\n+dates to Ada 83).\n+\n+But the important point is that an implementation is not required\n+to do this narrowing, so we have a potential portability problem.\n+We could imagine three types of implementation:\n+\n+(a) those that narrow the range automatically if they can figure\n+    out that the narrower range will allow storage in a smaller machine unit,\n+\n+(b) those that will narrow only if forced to by a `'Size` clause, and\n+\n+(c) those that will never narrow.\n+\n+Now if we are language theoreticians, we can imagine a fourth\n+approach: to narrow all the time, e.g. to treat\n+\n+.. code-block:: ada\n+\n+     type F3 is delta 1.0 range -10.0 .. +23.0;\n+  \n+as though it had been written:\n+\n+\n+.. code-block:: ada\n+\n+      type F3 is delta 1.0 range -9.0 .. +22.0;\n+  \n+But although technically allowed, such a behavior would be hostile and silly,\n+and no real compiler would do this. All real compilers will fall into one of\n+the categories (a), (b) or (c) above.\n+\n+So, how do you get the compiler to do what you want? The answer is give the\n+actual bounds you want, and then use a `'Small` clause and a\n+`'Size` clause to absolutely pin down what the compiler does.\n+E.g., for `F2` above, we will write:\n+\n+.. code-block:: ada\n+\n+     My_Small : constant := 2.0**(-15);\n+     My_First : constant := -1.0;\n+     My_Last  : constant := +1.0 - My_Small;\n+\n+     type F2 is delta My_Small range My_First .. My_Last;\n+  \n+and then add\n+\n+.. code-block:: ada\n+\n+     for F2'Small use my_Small;\n+     for F2'Size  use 16;\n+  \n+In practice all compilers will do the same thing here and will give you\n+what you want, so the above declarations are fully portable. If you really\n+want to play language lawyer and guard against ludicrous behavior by the\n+compiler you could add\n+\n+.. code-block:: ada\n+\n+     Test1 : constant := 1 / Boolean'Pos (F2'First = My_First);\n+     Test2 : constant := 1 / Boolean'Pos (F2'Last  = My_Last);\n+  \n+One or other or both are allowed to be illegal if the compiler is\n+behaving in a silly manner, but at least the silly compiler will not\n+get away with silently messing with your (very clear) intentions.\n+\n+If you follow this scheme you will be guaranteed that your fixed-point\n+types will be portable.\n+\n+\n+\n+\n+.. _Compatibility_with_Ada_83:\n+\n+Compatibility with Ada 83\n+=========================\n+\n+.. index:: Compatibility (between Ada 83 and Ada 95 / Ada 2005 / Ada 2012)\n+\n+Ada 95 and the subsequent revisions Ada 2005 and Ada 2012\n+are highly upwards compatible with Ada 83.  In\n+particular, the design intention was that the difficulties associated\n+with moving from Ada 83 to later versions of the standard should be no greater\n+than those that occur when moving from one Ada 83 system to another.\n+\n+However, there are a number of points at which there are minor\n+incompatibilities.  The :title:`Ada 95 Annotated Reference Manual` contains\n+full details of these issues as they relate to Ada 95,\n+and should be consulted for a complete treatment.\n+In practice the\n+following subsections treat the most likely issues to be encountered.\n+\n+.. _Legal_Ada_83_programs_that_are_illegal_in_Ada_95:\n+\n+Legal Ada 83 programs that are illegal in Ada 95\n+------------------------------------------------\n+\n+Some legal Ada 83 programs are illegal (i.e., they will fail to compile) in\n+Ada 95 and later versions of the standard:\n+\n+\n+* *Character literals*\n+\n+  Some uses of character literals are ambiguous.  Since Ada 95 has introduced\n+  `Wide_Character` as a new predefined character type, some uses of\n+  character literals that were legal in Ada 83 are illegal in Ada 95.\n+  For example:\n+\n+  .. code-block:: ada\n+\n+       for Char in 'A' .. 'Z' loop ... end loop;\n+\n+  The problem is that 'A' and 'Z' could be from either\n+  `Character` or `Wide_Character`.  The simplest correction\n+  is to make the type explicit; e.g.:\n+\n+  .. code-block:: ada\n+\n+       for Char in Character range 'A' .. 'Z' loop ... end loop;\n+    \n+* *New reserved words*\n+\n+  The identifiers `abstract`, `aliased`, `protected`,\n+  `requeue`, `tagged`, and `until` are reserved in Ada 95.\n+  Existing Ada 83 code using any of these identifiers must be edited to\n+  use some alternative name.\n+\n+* *Freezing rules*\n+\n+  The rules in Ada 95 are slightly different with regard to the point at\n+  which entities are frozen, and representation pragmas and clauses are\n+  not permitted past the freeze point.  This shows up most typically in\n+  the form of an error message complaining that a representation item\n+  appears too late, and the appropriate corrective action is to move\n+  the item nearer to the declaration of the entity to which it refers.\n+\n+  A particular case is that representation pragmas\n+  cannot be applied to a subprogram body.  If necessary, a separate subprogram\n+  declaration must be introduced to which the pragma can be applied.\n+\n+* *Optional bodies for library packages*\n+\n+  In Ada 83, a package that did not require a package body was nevertheless\n+  allowed to have one.  This lead to certain surprises in compiling large\n+  systems (situations in which the body could be unexpectedly ignored by the\n+  binder).  In Ada 95, if a package does not require a body then it is not\n+  permitted to have a body.  To fix this problem, simply remove a redundant\n+  body if it is empty, or, if it is non-empty, introduce a dummy declaration\n+  into the spec that makes the body required.  One approach is to add a private\n+  part to the package declaration (if necessary), and define a parameterless\n+  procedure called `Requires_Body`, which must then be given a dummy\n+  procedure body in the package body, which then becomes required.\n+  Another approach (assuming that this does not introduce elaboration\n+  circularities) is to add an `Elaborate_Body` pragma to the package spec,\n+  since one effect of this pragma is to require the presence of a package body.\n+\n+* *Numeric_Error is the same exception as Constraint_Error*\n+\n+  In Ada 95, the exception `Numeric_Error` is a renaming of `Constraint_Error`.\n+  This means that it is illegal to have separate exception handlers for\n+  the two exceptions.  The fix is simply to remove the handler for the\n+  `Numeric_Error` case (since even in Ada 83, a compiler was free to raise\n+  `Constraint_Error` in place of `Numeric_Error` in all cases).\n+\n+* *Indefinite subtypes in generics*\n+\n+  In Ada 83, it was permissible to pass an indefinite type (e.g, `String`)\n+  as the actual for a generic formal private type, but then the instantiation\n+  would be illegal if there were any instances of declarations of variables\n+  of this type in the generic body.  In Ada 95, to avoid this clear violation\n+  of the methodological principle known as the 'contract model',\n+  the generic declaration explicitly indicates whether\n+  or not such instantiations are permitted.  If a generic formal parameter\n+  has explicit unknown discriminants, indicated by using `(<>)` after the\n+  subtype name, then it can be instantiated with indefinite types, but no\n+  stand-alone variables can be declared of this type.  Any attempt to declare\n+  such a variable will result in an illegality at the time the generic is\n+  declared.  If the `(<>)` notation is not used, then it is illegal\n+  to instantiate the generic with an indefinite type.\n+  This is the potential incompatibility issue when porting Ada 83 code to Ada 95.\n+  It will show up as a compile time error, and\n+  the fix is usually simply to add the `(<>)` to the generic declaration.\n+\n+\n+.. _More_deterministic_semantics:\n+\n+More deterministic semantics\n+----------------------------\n+\n+* *Conversions*\n+\n+  Conversions from real types to integer types round away from 0.  In Ada 83\n+  the conversion Integer(2.5) could deliver either 2 or 3 as its value.  This\n+  implementation freedom was intended to support unbiased rounding in\n+  statistical applications, but in practice it interfered with portability.\n+  In Ada 95 the conversion semantics are unambiguous, and rounding away from 0\n+  is required.  Numeric code may be affected by this change in semantics.\n+  Note, though, that this issue is no worse than already existed in Ada 83\n+  when porting code from one vendor to another.\n+\n+* *Tasking*\n+\n+  The Real-Time Annex introduces a set of policies that define the behavior of\n+  features that were implementation dependent in Ada 83, such as the order in\n+  which open select branches are executed.\n+\n+\n+.. _Changed_semantics:\n+\n+Changed semantics\n+-----------------\n+\n+The worst kind of incompatibility is one where a program that is legal in\n+Ada 83 is also legal in Ada 95 but can have an effect in Ada 95 that was not\n+possible in Ada 83.  Fortunately this is extremely rare, but the one\n+situation that you should be alert to is the change in the predefined type\n+`Character` from 7-bit ASCII to 8-bit Latin-1.\n+\n+    .. index:: Latin-1\n+\n+* *Range of type `Character`*\n+\n+  The range of `Standard.Character` is now the full 256 characters\n+  of Latin-1, whereas in most Ada 83 implementations it was restricted\n+  to 128 characters. Although some of the effects of\n+  this change will be manifest in compile-time rejection of legal\n+  Ada 83 programs it is possible for a working Ada 83 program to have\n+  a different effect in Ada 95, one that was not permitted in Ada 83.\n+  As an example, the expression\n+  `Character'Pos(Character'Last)` returned `127` in Ada 83 and now\n+  delivers `255` as its value.\n+  In general, you should look at the logic of any\n+  character-processing Ada 83 program and see whether it needs to be adapted\n+  to work correctly with Latin-1.  Note that the predefined Ada 95 API has a\n+  character handling package that may be relevant if code needs to be adapted\n+  to account for the additional Latin-1 elements.\n+  The desirable fix is to\n+  modify the program to accommodate the full character set, but in some cases\n+  it may be convenient to define a subtype or derived type of Character that\n+  covers only the restricted range.\n+\n+\n+.. _Other_language_compatibility_issues:\n+\n+Other language compatibility issues\n+-----------------------------------\n+\n+* *-gnat83* switch\n+\n+  All implementations of GNAT provide a switch that causes GNAT to operate\n+  in Ada 83 mode.  In this mode, some but not all compatibility problems\n+  of the type described above are handled automatically.  For example, the\n+  new reserved words introduced in Ada 95 and Ada 2005 are treated simply\n+  as identifiers as in Ada 83.  However,\n+  in practice, it is usually advisable to make the necessary modifications\n+  to the program to remove the need for using this switch.\n+  See the `Compiling Different Versions of Ada` section in\n+  the :title:`GNAT User's Guide`.\n+\n+\n+* Support for removed Ada 83 pragmas and attributes\n+\n+  A number of pragmas and attributes from Ada 83 were removed from Ada 95,\n+  generally because they were replaced by other mechanisms.  Ada 95 and Ada 2005\n+  compilers are allowed, but not required, to implement these missing\n+  elements.  In contrast with some other compilers, GNAT implements all\n+  such pragmas and attributes, eliminating this compatibility concern.  These\n+  include `pragma Interface` and the floating point type attributes\n+  (`Emax`, `Mantissa`, etc.), among other items.\n+\n+\n+.. _Compatibility_between_Ada_95_and_Ada_2005:\n+\n+Compatibility between Ada 95 and Ada 2005\n+=========================================\n+\n+.. index:: Compatibility between Ada 95 and Ada 2005\n+\n+Although Ada 2005 was designed to be upwards compatible with Ada 95, there are\n+a number of incompatibilities. Several are enumerated below;\n+for a complete description please see the\n+:title:`Annotated Ada 2005 Reference Manual`, or section 9.1.1 in\n+:title:`Rationale for Ada 2005`.\n+\n+* *New reserved words.*\n+\n+  The words `interface`, `overriding` and `synchronized` are\n+  reserved in Ada 2005.\n+  A pre-Ada 2005 program that uses any of these as an identifier will be\n+  illegal.\n+\n+* *New declarations in predefined packages.*\n+\n+  A number of packages in the predefined environment contain new declarations:\n+  `Ada.Exceptions`, `Ada.Real_Time`, `Ada.Strings`,\n+  `Ada.Strings.Fixed`, `Ada.Strings.Bounded`,\n+  `Ada.Strings.Unbounded`, `Ada.Strings.Wide_Fixed`,\n+  `Ada.Strings.Wide_Bounded`, `Ada.Strings.Wide_Unbounded`,\n+  `Ada.Tags`, `Ada.Text_IO`, and `Interfaces.C`.\n+  If an Ada 95 program does a `with` and `use` of any of these\n+  packages, the new declarations may cause name clashes.\n+\n+* *Access parameters.*\n+\n+  A nondispatching subprogram with an access parameter cannot be renamed\n+  as a dispatching operation.  This was permitted in Ada 95.\n+\n+* *Access types, discriminants, and constraints.*\n+\n+  Rule changes in this area have led to some incompatibilities; for example,\n+  constrained subtypes of some access types are not permitted in Ada 2005.\n+ \n+* *Aggregates for limited types.*\n+\n+  The allowance of aggregates for limited types in Ada 2005 raises the\n+  possibility of ambiguities in legal Ada 95 programs, since additional types\n+  now need to be considered in expression resolution.\n+\n+* *Fixed-point multiplication and division.*\n+\n+  Certain expressions involving '*' or '/' for a fixed-point type, which\n+  were legal in Ada 95 and invoked the predefined versions of these operations,\n+  are now ambiguous.\n+  The ambiguity may be resolved either by applying a type conversion to the\n+  expression, or by explicitly invoking the operation from package\n+  `Standard`.\n+\n+* *Return-by-reference types.*\n+\n+  The Ada 95 return-by-reference mechanism has been removed.  Instead, the user\n+  can declare a function returning a value from an anonymous access type.\n+\n+\n+.. _Implementation-dependent_characteristics:\n+\n+Implementation-dependent characteristics\n+========================================\n+\n+Although the Ada language defines the semantics of each construct as\n+precisely as practical, in some situations (for example for reasons of\n+efficiency, or where the effect is heavily dependent on the host or target\n+platform) the implementation is allowed some freedom.  In porting Ada 83\n+code to GNAT, you need to be aware of whether / how the existing code\n+exercised such implementation dependencies.  Such characteristics fall into\n+several categories, and GNAT offers specific support in assisting the\n+transition from certain Ada 83 compilers.\n+\n+.. _Implementation-defined_pragmas:\n+\n+Implementation-defined pragmas\n+------------------------------\n+\n+Ada compilers are allowed to supplement the language-defined pragmas, and\n+these are a potential source of non-portability.  All GNAT-defined pragmas\n+are described in the `Implementation Defined Pragmas` chapter of the\n+:title:`GNAT Reference Manual`, and these include several that are specifically\n+intended to correspond to other vendors' Ada 83 pragmas.\n+For migrating from VADS, the pragma `Use_VADS_Size` may be useful.\n+For compatibility with HP Ada 83, GNAT supplies the pragmas\n+`Extend_System`, `Ident`, `Inline_Generic`,\n+`Interface_Name`, `Passive`, `Suppress_All`,\n+and `Volatile`.\n+Other relevant pragmas include `External` and `Link_With`.\n+Some vendor-specific\n+Ada 83 pragmas (`Share_Generic`, `Subtitle`, and `Title`) are\n+recognized, thus\n+avoiding compiler rejection of units that contain such pragmas; they are not\n+relevant in a GNAT context and hence are not otherwise implemented.\n+\n+\n+.. _Implementation-defined_attributes:\n+\n+Implementation-defined attributes\n+---------------------------------\n+\n+Analogous to pragmas, the set of attributes may be extended by an\n+implementation.  All GNAT-defined attributes are described in\n+`Implementation Defined Attributes` section of the\n+:title:`GNAT Reference Manual`, and these include several that are specifically intended\n+to correspond to other vendors' Ada 83 attributes.  For migrating from VADS,\n+the attribute `VADS_Size` may be useful.  For compatibility with HP\n+Ada 83, GNAT supplies the attributes `Bit`, `Machine_Size` and\n+`Type_Class`.\n+\n+.. _Libraries:\n+\n+Libraries\n+---------\n+\n+Vendors may supply libraries to supplement the standard Ada API.  If Ada 83\n+code uses vendor-specific libraries then there are several ways to manage\n+this in Ada 95 and later versions of the standard:\n+\n+* If the source code for the libraries (specs and bodies) are\n+  available, then the libraries can be migrated in the same way as the\n+  application.\n+\n+* If the source code for the specs but not the bodies are\n+  available, then you can reimplement the bodies.\n+\n+* Some features introduced by Ada 95 obviate the need for library support.  For\n+  example most Ada 83 vendors supplied a package for unsigned integers.  The\n+  Ada 95 modular type feature is the preferred way to handle this need, so\n+  instead of migrating or reimplementing the unsigned integer package it may\n+  be preferable to retrofit the application using modular types.\n+\n+\n+.. _Elaboration_order:\n+\n+Elaboration order\n+-----------------\n+The implementation can choose any elaboration order consistent with the unit\n+dependency relationship.  This freedom means that some orders can result in\n+Program_Error being raised due to an 'Access Before Elaboration': an attempt\n+to invoke a subprogram its body has been elaborated, or to instantiate a\n+generic before the generic body has been elaborated.  By default GNAT\n+attempts to choose a safe order (one that will not encounter access before\n+elaboration problems) by implicitly inserting `Elaborate` or\n+`Elaborate_All` pragmas where\n+needed.  However, this can lead to the creation of elaboration circularities\n+and a resulting rejection of the program by gnatbind.  This issue is\n+thoroughly described in the `Elaboration Order Handling in GNAT` appendix\n+in the :title:`GNAT User's Guide`.\n+In brief, there are several\n+ways to deal with this situation:\n+\n+* Modify the program to eliminate the circularities, e.g., by moving\n+  elaboration-time code into explicitly-invoked procedures\n+\n+* Constrain the elaboration order by including explicit `Elaborate_Body` or\n+  `Elaborate` pragmas, and then inhibit the generation of implicit\n+  `Elaborate_All`\n+  pragmas either globally (as an effect of the *-gnatE* switch) or locally\n+  (by selectively suppressing elaboration checks via pragma\n+  `Suppress(Elaboration_Check)` when it is safe to do so).\n+\n+\n+.. _Target-specific_aspects:\n+\n+Target-specific aspects\n+-----------------------\n+\n+Low-level applications need to deal with machine addresses, data\n+representations, interfacing with assembler code, and similar issues.  If\n+such an Ada 83 application is being ported to different target hardware (for\n+example where the byte endianness has changed) then you will need to\n+carefully examine the program logic; the porting effort will heavily depend\n+on the robustness of the original design.  Moreover, Ada 95 (and thus\n+Ada 2005 and Ada 2012) are sometimes\n+incompatible with typical Ada 83 compiler practices regarding implicit\n+packing, the meaning of the Size attribute, and the size of access values.\n+GNAT's approach to these issues is described in :ref:`Representation_Clauses`.\n+\n+\n+.. _Compatibility_with_Other_Ada_Systems:\n+\n+Compatibility with Other Ada Systems\n+====================================\n+\n+If programs avoid the use of implementation dependent and\n+implementation defined features, as documented in the \n+:title:`Ada Reference Manual`, there should be a high degree of portability between\n+GNAT and other Ada systems.  The following are specific items which\n+have proved troublesome in moving Ada 95 programs from GNAT to other Ada 95\n+compilers, but do not affect porting code to GNAT.\n+(As of January 2007, GNAT is the only compiler available for Ada 2005;\n+the following issues may or may not arise for Ada 2005 programs\n+when other compilers appear.)\n+\n+* *Ada 83 Pragmas and Attributes*\n+\n+  Ada 95 compilers are allowed, but not required, to implement the missing\n+  Ada 83 pragmas and attributes that are no longer defined in Ada 95.\n+  GNAT implements all such pragmas and attributes, eliminating this as\n+  a compatibility concern, but some other Ada 95 compilers reject these\n+  pragmas and attributes.\n+\n+* *Specialized Needs Annexes*\n+\n+  GNAT implements the full set of special needs annexes.  At the\n+  current time, it is the only Ada 95 compiler to do so.  This means that\n+  programs making use of these features may not be portable to other Ada\n+  95 compilation systems.\n+\n+* *Representation Clauses*\n+\n+  Some other Ada 95 compilers implement only the minimal set of\n+  representation clauses required by the Ada 95 reference manual.  GNAT goes\n+  far beyond this minimal set, as described in the next section.\n+\n+\n+.. _Representation_Clauses:\n+\n+Representation Clauses\n+======================\n+\n+The Ada 83 reference manual was quite vague in describing both the minimal\n+required implementation of representation clauses, and also their precise\n+effects.  Ada 95 (and thus also Ada 2005) are much more explicit, but the\n+minimal set of capabilities required is still quite limited.\n+\n+GNAT implements the full required set of capabilities in\n+Ada 95 and Ada 2005, but also goes much further, and in particular\n+an effort has been made to be compatible with existing Ada 83 usage to the\n+greatest extent possible.\n+\n+A few cases exist in which Ada 83 compiler behavior is incompatible with\n+the requirements in Ada 95 (and thus also Ada 2005).  These are instances of\n+intentional or accidental dependence on specific implementation dependent\n+characteristics of these Ada 83 compilers.  The following is a list of\n+the cases most likely to arise in existing Ada 83 code.\n+\n+* *Implicit Packing*\n+\n+  Some Ada 83 compilers allowed a Size specification to cause implicit\n+  packing of an array or record.  This could cause expensive implicit\n+  conversions for change of representation in the presence of derived\n+  types, and the Ada design intends to avoid this possibility.\n+  Subsequent AI's were issued to make it clear that such implicit\n+  change of representation in response to a Size clause is inadvisable,\n+  and this recommendation is represented explicitly in the Ada 95 (and Ada 2005)\n+  Reference Manuals as implementation advice that is followed by GNAT.\n+  The problem will show up as an error\n+  message rejecting the size clause.  The fix is simply to provide\n+  the explicit pragma `Pack`, or for more fine tuned control, provide\n+  a Component_Size clause.\n+\n+* *Meaning of Size Attribute*\n+\n+  The Size attribute in Ada 95 (and Ada 2005) for discrete types is defined as\n+  the minimal number of bits required to hold values of the type.  For example,\n+  on a 32-bit machine, the size of `Natural` will typically be 31 and not\n+  32 (since no sign bit is required).  Some Ada 83 compilers gave 31, and\n+  some 32 in this situation.  This problem will usually show up as a compile\n+  time error, but not always.  It is a good idea to check all uses of the\n+  'Size attribute when porting Ada 83 code.  The GNAT specific attribute\n+  Object_Size can provide a useful way of duplicating the behavior of\n+  some Ada 83 compiler systems.\n+\n+* *Size of Access Types*\n+\n+  A common assumption in Ada 83 code is that an access type is in fact a pointer,\n+  and that therefore it will be the same size as a System.Address value.  This\n+  assumption is true for GNAT in most cases with one exception.  For the case of\n+  a pointer to an unconstrained array type (where the bounds may vary from one\n+  value of the access type to another), the default is to use a 'fat pointer',\n+  which is represented as two separate pointers, one to the bounds, and one to\n+  the array.  This representation has a number of advantages, including improved\n+  efficiency.  However, it may cause some difficulties in porting existing Ada 83\n+  code which makes the assumption that, for example, pointers fit in 32 bits on\n+  a machine with 32-bit addressing.\n+\n+  To get around this problem, GNAT also permits the use of 'thin pointers' for\n+  access types in this case (where the designated type is an unconstrained array\n+  type).  These thin pointers are indeed the same size as a System.Address value.\n+  To specify a thin pointer, use a size clause for the type, for example:\n+\n+  .. code-block:: ada\n+\n+       type X is access all String;\n+       for X'Size use Standard'Address_Size;\n+    \n+  which will cause the type X to be represented using a single pointer.\n+  When using this representation, the bounds are right behind the array.\n+  This representation is slightly less efficient, and does not allow quite\n+  such flexibility in the use of foreign pointers or in using the\n+  Unrestricted_Access attribute to create pointers to non-aliased objects.\n+  But for any standard portable use of the access type it will work in\n+  a functionally correct manner and allow porting of existing code.\n+  Note that another way of forcing a thin pointer representation\n+  is to use a component size clause for the element size in an array,\n+  or a record representation clause for an access field in a record.\n+\n+  See the documentation of Unrestricted_Access in the GNAT RM for a\n+  full discussion of possible problems using this attribute in conjunction\n+  with thin pointers.\n+\n+\n+.. _Compatibility_with_HP_Ada_83:\n+\n+Compatibility with HP Ada 83\n+============================\n+\n+All the HP Ada 83 pragmas and attributes are recognized, although only a subset\n+of them can sensibly be implemented.  The description of pragmas in\n+:ref:`Implementation_Defined_Pragmas` indicates whether or not they are\n+applicable to GNAT.\n+\n+* *Default floating-point representation*\n+\n+  In GNAT, the default floating-point format is IEEE, whereas in HP Ada 83,\n+  it is VMS format.\n+\n+* *System*\n+\n+  the package System in GNAT exactly corresponds to the definition in the\n+  Ada 95 reference manual, which means that it excludes many of the\n+  HP Ada 83 extensions.  However, a separate package Aux_DEC is provided\n+  that contains the additional definitions, and a special pragma,\n+  Extend_System allows this package to be treated transparently as an\n+  extension of package System.\n+"}, {"sha": "2ccb4e40172f8542543581313ca10516c6e96802", "filename": "gcc/ada/doc/gnat_rm/implementation_advice.rst", "status": "added", "additions": 1395, "deletions": 0, "changes": 1395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_advice.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_advice.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_advice.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,1395 @@\n+.. _Implementation_Advice:\n+\n+*********************\n+Implementation Advice\n+*********************\n+\n+The main text of the Ada Reference Manual describes the required\n+behavior of all Ada compilers, and the GNAT compiler conforms to\n+these requirements.\n+\n+In addition, there are sections throughout the Ada Reference Manual headed\n+by the phrase 'Implementation advice'.  These sections are not normative,\n+i.e., they do not specify requirements that all compilers must\n+follow.  Rather they provide advice on generally desirable behavior.\n+They are not requirements, because they describe behavior that cannot\n+be provided on all systems, or may be undesirable on some systems.\n+\n+As far as practical, GNAT follows the implementation advice in\n+the Ada Reference Manual.  Each such RM section corresponds to a section\n+in this chapter whose title specifies the\n+RM section number and paragraph number and the subject of\n+the advice.  The contents of each section consists of the RM text within\n+quotation marks,\n+followed by the GNAT interpretation of the advice.  Most often, this simply says\n+'followed', which means that GNAT follows the advice.  However, in a\n+number of cases, GNAT deliberately deviates from this advice, in which\n+case the text describes what GNAT does and why.\n+\n+.. index:: Error detection\n+\n+RM 1.1.3(20): Error Detection\n+=============================\n+\n+  \"If an implementation detects the use of an unsupported Specialized Needs\n+  Annex feature at run time, it should raise `Program_Error` if\n+  feasible.\"\n+\n+Not relevant.  All specialized needs annex features are either supported,\n+or diagnosed at compile time.\n+\n+.. index:: Child Units\n+\n+RM 1.1.3(31): Child Units\n+=========================\n+\n+\n+  \"If an implementation wishes to provide implementation-defined\n+  extensions to the functionality of a language-defined library unit, it\n+  should normally do so by adding children to the library unit.\"\n+\n+Followed.\n+\n+.. index:: Bounded errors\n+\n+RM 1.1.5(12): Bounded Errors\n+============================\n+\n+  \"If an implementation detects a bounded error or erroneous\n+  execution, it should raise `Program_Error`.\"\n+\n+Followed in all cases in which the implementation detects a bounded\n+error or erroneous execution.  Not all such situations are detected at\n+runtime.\n+\n+.. index:: Pragmas\n+\n+.. _RM_2_8_16_Pragmas:\n+\n+RM 2.8(16): Pragmas\n+===================\n+\n+  \"Normally, implementation-defined pragmas should have no semantic effect\n+  for error-free programs; that is, if the implementation-defined pragmas\n+  are removed from a working program, the program should still be legal,\n+  and should still have the same semantics.\"\n+\n+The following implementation defined pragmas are exceptions to this\n+rule:\n+\n++--------------------+-------------------+\n+| Pragma             | Explanation       |\n++====================+===================+\n+| *Abort_Defer*      | Affects semantics |\n++--------------------+-------------------+\n+|*Ada_83*            | Affects legality  |\n++--------------------+-------------------+\n+|*Assert*            | Affects semantics |\n++--------------------+-------------------+\n+|*CPP_Class*         | Affects semantics |\n++--------------------+-------------------+\n+|*CPP_Constructor*   | Affects semantics |\n++--------------------+-------------------+\n+|*Debug*             | Affects semantics |\n++--------------------+-------------------+\n+|*Interface_Name*    | Affects semantics |\n++--------------------+-------------------+\n+|*Machine_Attribute* | Affects semantics |\n++--------------------+-------------------+\n+|*Unimplemented_Unit*| Affects legality  |\n++--------------------+-------------------+\n+|*Unchecked_Union*   | Affects semantics |\n++--------------------+-------------------+\n+\n+In each of the above cases, it is essential to the purpose of the pragma\n+that this advice not be followed.  For details see\n+:ref:`Implementation_Defined_Pragmas`.\n+\n+RM 2.8(17-19): Pragmas\n+======================\n+\n+  \"Normally, an implementation should not define pragmas that can\n+  make an illegal program legal, except as follows:\n+\n+  * A pragma used to complete a declaration, such as a pragma `Import`;\n+\n+  * A pragma used to configure the environment by adding, removing, or\n+    replacing `library_items`.\"\n+\n+See :ref:`RM_2_8_16_Pragmas`.\n+\n+.. index:: Character Sets\n+\n+.. index:: Alternative Character Sets\n+\n+RM 3.5.2(5): Alternative Character Sets\n+=======================================\n+\n+  \"If an implementation supports a mode with alternative interpretations\n+  for `Character` and `Wide_Character`, the set of graphic\n+  characters of `Character` should nevertheless remain a proper\n+  subset of the set of graphic characters of `Wide_Character`.  Any\n+  character set 'localizations' should be reflected in the results of\n+  the subprograms defined in the language-defined package\n+  `Characters.Handling` (see A.3) available in such a mode.  In a mode with\n+  an alternative interpretation of `Character`, the implementation should\n+  also support a corresponding change in what is a legal\n+  `identifier_letter`.\"\n+\n+Not all wide character modes follow this advice, in particular the JIS\n+and IEC modes reflect standard usage in Japan, and in these encoding,\n+the upper half of the Latin-1 set is not part of the wide-character\n+subset, since the most significant bit is used for wide character\n+encoding.  However, this only applies to the external forms.  Internally\n+there is no such restriction.\n+\n+.. index:: Integer types\n+\n+RM 3.5.4(28): Integer Types\n+===========================\n+\n+  \"An implementation should support `Long_Integer` in addition to\n+  `Integer` if the target machine supports 32-bit (or longer)\n+  arithmetic.  No other named integer subtypes are recommended for package\n+  `Standard`.  Instead, appropriate named integer subtypes should be\n+  provided in the library package `Interfaces` (see B.2).\"\n+\n+`Long_Integer` is supported.  Other standard integer types are supported\n+so this advice is not fully followed.  These types\n+are supported for convenient interface to C, and so that all hardware\n+types of the machine are easily available.\n+\n+RM 3.5.4(29): Integer Types\n+===========================\n+\n+  \"An implementation for a two's complement machine should support\n+  modular types with a binary modulus up to ``System.Max_Int*2+2``.  An\n+  implementation should support a non-binary modules up to `Integer'Last`.\"\n+\n+Followed.\n+\n+.. index:: Enumeration values\n+\n+RM 3.5.5(8): Enumeration Values\n+===============================\n+\n+  \"For the evaluation of a call on ``S'Pos`` for an enumeration\n+  subtype, if the value of the operand does not correspond to the internal\n+  code for any enumeration literal of its type (perhaps due to an\n+  un-initialized variable), then the implementation should raise\n+  `Program_Error`.  This is particularly important for enumeration\n+  types with noncontiguous internal codes specified by an\n+  enumeration_representation_clause.\"\n+\n+Followed.\n+\n+.. index:: Float types\n+\n+RM 3.5.7(17): Float Types\n+=========================\n+\n+  \"An implementation should support `Long_Float` in addition to\n+  `Float` if the target machine supports 11 or more digits of\n+  precision.  No other named floating point subtypes are recommended for\n+  package `Standard`.  Instead, appropriate named floating point subtypes\n+  should be provided in the library package `Interfaces` (see B.2).\"\n+\n+`Short_Float` and `Long_Long_Float` are also provided.  The\n+former provides improved compatibility with other implementations\n+supporting this type.  The latter corresponds to the highest precision\n+floating-point type supported by the hardware.  On most machines, this\n+will be the same as `Long_Float`, but on some machines, it will\n+correspond to the IEEE extended form.  The notable case is all ia32\n+(x86) implementations, where `Long_Long_Float` corresponds to\n+the 80-bit extended precision format supported in hardware on this\n+processor.  Note that the 128-bit format on SPARC is not supported,\n+since this is a software rather than a hardware format.\n+\n+.. index:: Multidimensional arrays\n+\n+.. index:: Arrays, multidimensional\n+\n+RM 3.6.2(11): Multidimensional Arrays\n+=====================================\n+\n+  \"An implementation should normally represent multidimensional arrays in\n+  row-major order, consistent with the notation used for multidimensional\n+  array aggregates (see 4.3.3).  However, if a pragma `Convention`\n+  (`Fortran`, ...) applies to a multidimensional array type, then\n+  column-major order should be used instead (see B.5, `Interfacing with Fortran`).\"\n+\n+Followed.\n+\n+.. index:: Duration'Small\n+\n+RM 9.6(30-31): Duration'Small\n+=============================\n+\n+  \"Whenever possible in an implementation, the value of `Duration'Small`\n+  should be no greater than 100 microseconds.\"\n+\n+Followed.  (`Duration'Small` = 10**(-9)).\n+\n+  \"The time base for `delay_relative_statements` should be monotonic;\n+  it need not be the same time base as used for `Calendar.Clock`.\"\n+\n+Followed.\n+\n+RM 10.2.1(12): Consistent Representation\n+========================================\n+\n+  \"In an implementation, a type declared in a pre-elaborated package should\n+  have the same representation in every elaboration of a given version of\n+  the package, whether the elaborations occur in distinct executions of\n+  the same program, or in executions of distinct programs or partitions\n+  that include the given version.\"\n+\n+Followed, except in the case of tagged types.  Tagged types involve\n+implicit pointers to a local copy of a dispatch table, and these pointers\n+have representations which thus depend on a particular elaboration of the\n+package.  It is not easy to see how it would be possible to follow this\n+advice without severely impacting efficiency of execution.\n+\n+.. index:: Exception information\n+\n+RM 11.4.1(19): Exception Information\n+====================================\n+\n+  \"`Exception_Message` by default and `Exception_Information`\n+  should produce information useful for\n+  debugging.  `Exception_Message` should be short, about one\n+  line.  `Exception_Information` can be long.  `Exception_Message`\n+  should not include the\n+  `Exception_Name`.  `Exception_Information` should include both\n+  the `Exception_Name` and the `Exception_Message`.\"\n+\n+Followed.  For each exception that doesn't have a specified\n+`Exception_Message`, the compiler generates one containing the location\n+of the raise statement.  This location has the form 'file_name:line', where\n+file_name is the short file name (without path information) and line is the line\n+number in the file.  Note that in the case of the Zero Cost Exception\n+mechanism, these messages become redundant with the Exception_Information that\n+contains a full backtrace of the calling sequence, so they are disabled.\n+To disable explicitly the generation of the source location message, use the\n+Pragma `Discard_Names`.\n+\n+.. index:: Suppression of checks\n+\n+.. index:: Checks, suppression of\n+\n+RM 11.5(28): Suppression of Checks\n+==================================\n+\n+  \"The implementation should minimize the code executed for checks that\n+  have been suppressed.\"\n+\n+Followed.\n+\n+.. index:: Representation clauses\n+\n+RM 13.1 (21-24): Representation Clauses\n+=======================================\n+\n+  \"The recommended level of support for all representation items is\n+  qualified as follows:\n+\n+  An implementation need not support representation items containing\n+  non-static expressions, except that an implementation should support a\n+  representation item for a given entity if each non-static expression in\n+  the representation item is a name that statically denotes a constant\n+  declared before the entity.\"\n+\n+Followed.  In fact, GNAT goes beyond the recommended level of support\n+by allowing nonstatic expressions in some representation clauses even\n+without the need to declare constants initialized with the values of\n+such expressions.\n+For example:\n+\n+.. code-block:: ada\n+\n+    X : Integer;\n+    Y : Float;\n+    for Y'Address use X'Address;>>\n+\n+\n+  \"An implementation need not support a specification for the `Size`\n+  for a given composite subtype, nor the size or storage place for an\n+  object (including a component) of a given composite subtype, unless the\n+  constraints on the subtype and its composite subcomponents (if any) are\n+  all static constraints.\"\n+\n+Followed.  Size Clauses are not permitted on non-static components, as\n+described above.\n+\n+\n+  \"An aliased component, or a component whose type is by-reference, should\n+  always be allocated at an addressable location.\"\n+\n+Followed.\n+\n+.. index:: Packed types\n+\n+RM 13.2(6-8): Packed Types\n+==========================\n+\n+  \"If a type is packed, then the implementation should try to minimize\n+  storage allocated to objects of the type, possibly at the expense of\n+  speed of accessing components, subject to reasonable complexity in\n+  addressing calculations.\n+\n+  The recommended level of support pragma `Pack` is:\n+\n+  For a packed record type, the components should be packed as tightly as\n+  possible subject to the Sizes of the component subtypes, and subject to\n+  any `record_representation_clause` that applies to the type; the\n+  implementation may, but need not, reorder components or cross aligned\n+  word boundaries to improve the packing.  A component whose `Size` is\n+  greater than the word size may be allocated an integral number of words.\"\n+\n+Followed.  Tight packing of arrays is supported for all component sizes\n+up to 64-bits. If the array component size is 1 (that is to say, if\n+the component is a boolean type or an enumeration type with two values)\n+then values of the type are implicitly initialized to zero. This\n+happens both for objects of the packed type, and for objects that have a\n+subcomponent of the packed type.\n+\n+\n+  \"An implementation should support Address clauses for imported\n+  subprograms.\"\n+\n+Followed.\n+\n+.. index:: Address clauses\n+\n+RM 13.3(14-19): Address Clauses\n+===============================\n+\n+  \"For an array `X`, ``X'Address`` should point at the first\n+  component of the array, and not at the array bounds.\"\n+\n+Followed.\n+\n+  \"The recommended level of support for the `Address` attribute is:\n+\n+  ``X'Address`` should produce a useful result if `X` is an\n+  object that is aliased or of a by-reference type, or is an entity whose\n+  `Address` has been specified.\"\n+\n+Followed.  A valid address will be produced even if none of those\n+conditions have been met.  If necessary, the object is forced into\n+memory to ensure the address is valid.\n+\n+  \"An implementation should support `Address` clauses for imported\n+  subprograms.\"\n+\n+Followed.\n+\n+  \"Objects (including subcomponents) that are aliased or of a by-reference\n+  type should be allocated on storage element boundaries.\"\n+\n+Followed.\n+\n+  \"If the `Address` of an object is specified, or it is imported or exported,\n+  then the implementation should not perform optimizations based on\n+  assumptions of no aliases.\"\n+\n+Followed.\n+\n+.. index:: Alignment clauses\n+\n+RM 13.3(29-35): Alignment Clauses\n+=================================\n+\n+  \"The recommended level of support for the `Alignment` attribute for\n+  subtypes is:\n+\n+  An implementation should support specified Alignments that are factors\n+  and multiples of the number of storage elements per word, subject to the\n+  following:\"\n+\n+Followed.\n+\n+  \"An implementation need not support specified Alignments for\n+  combinations of Sizes and Alignments that cannot be easily\n+  loaded and stored by available machine instructions.\"\n+\n+Followed.\n+\n+  \"An implementation need not support specified Alignments that are\n+  greater than the maximum `Alignment` the implementation ever returns by\n+  default.\"\n+\n+Followed.\n+\n+  \"The recommended level of support for the `Alignment` attribute for\n+  objects is:\n+\n+  Same as above, for subtypes, but in addition:\"\n+\n+Followed.\n+\n+  \"For stand-alone library-level objects of statically constrained\n+  subtypes, the implementation should support all alignments\n+  supported by the target linker.  For example, page alignment is likely to\n+  be supported for such objects, but not for subtypes.\"\n+\n+Followed.\n+\n+.. index:: Size clauses\n+\n+RM 13.3(42-43): Size Clauses\n+============================\n+\n+  \"The recommended level of support for the `Size` attribute of\n+  objects is:\n+\n+  A `Size` clause should be supported for an object if the specified\n+  `Size` is at least as large as its subtype's `Size`, and\n+  corresponds to a size in storage elements that is a multiple of the\n+  object's `Alignment` (if the `Alignment` is nonzero).\"\n+\n+Followed.\n+\n+RM 13.3(50-56): Size Clauses\n+============================\n+\n+  \"If the `Size` of a subtype is specified, and allows for efficient\n+  independent addressability (see 9.10) on the target architecture, then\n+  the `Size` of the following objects of the subtype should equal the\n+  `Size` of the subtype:\n+\n+  Aliased objects (including components).\"\n+\n+Followed.\n+\n+  \"`Size` clause on a composite subtype should not affect the\n+  internal layout of components.\"\n+\n+Followed. But note that this can be overridden by use of the implementation\n+pragma Implicit_Packing in the case of packed arrays.\n+\n+  \"The recommended level of support for the `Size` attribute of subtypes is:\n+\n+  The `Size` (if not specified) of a static discrete or fixed point\n+  subtype should be the number of bits needed to represent each value\n+  belonging to the subtype using an unbiased representation, leaving space\n+  for a sign bit only if the subtype contains negative values.  If such a\n+  subtype is a first subtype, then an implementation should support a\n+  specified `Size` for it that reflects this representation.\"\n+\n+Followed.\n+\n+  \"For a subtype implemented with levels of indirection, the `Size`\n+  should include the size of the pointers, but not the size of what they\n+  point at.\"\n+\n+Followed.\n+\n+.. index:: Component_Size clauses\n+\n+RM 13.3(71-73): Component Size Clauses\n+======================================\n+\n+  \"The recommended level of support for the `Component_Size`\n+  attribute is:\n+\n+  An implementation need not support specified `Component_Sizes` that are\n+  less than the `Size` of the component subtype.\"\n+\n+Followed.\n+\n+  \"An implementation should support specified Component_Sizes that\n+  are factors and multiples of the word size.  For such\n+  Component_Sizes, the array should contain no gaps between\n+  components.  For other Component_Sizes (if supported), the array\n+  should contain no gaps between components when packing is also\n+  specified; the implementation should forbid this combination in cases\n+  where it cannot support a no-gaps representation.\"\n+\n+Followed.\n+\n+.. index:: Enumeration representation clauses\n+\n+.. index:: Representation clauses, enumeration\n+\n+RM 13.4(9-10): Enumeration Representation Clauses\n+=================================================\n+\n+  \"The recommended level of support for enumeration representation clauses\n+  is:\n+\n+  An implementation need not support enumeration representation clauses\n+  for boolean types, but should at minimum support the internal codes in\n+  the range `System.Min_Int .. System.Max_Int`.\"\n+\n+Followed.\n+\n+.. index:: Record representation clauses\n+\n+.. index:: Representation clauses, records\n+\n+RM 13.5.1(17-22): Record Representation Clauses\n+===============================================\n+\n+  \"The recommended level of support for\n+  `record_representation_clauses` is:\n+\n+  An implementation should support storage places that can be extracted\n+  with a load, mask, shift sequence of machine code, and set with a load,\n+  shift, mask, store sequence, given the available machine instructions\n+  and run-time model.\"\n+\n+Followed.\n+\n+  \"A storage place should be supported if its size is equal to the\n+  `Size` of the component subtype, and it starts and ends on a\n+  boundary that obeys the `Alignment` of the component subtype.\"\n+\n+Followed.\n+\n+  \"If the default bit ordering applies to the declaration of a given type,\n+  then for a component whose subtype's `Size` is less than the word\n+  size, any storage place that does not cross an aligned word boundary\n+  should be supported.\"\n+\n+Followed.\n+\n+  \"An implementation may reserve a storage place for the tag field of a\n+  tagged type, and disallow other components from overlapping that place.\"\n+\n+Followed.  The storage place for the tag field is the beginning of the tagged\n+record, and its size is Address'Size.  GNAT will reject an explicit component\n+clause for the tag field.\n+\n+  \"An implementation need not support a `component_clause` for a\n+  component of an extension part if the storage place is not after the\n+  storage places of all components of the parent type, whether or not\n+  those storage places had been specified.\"\n+\n+Followed.  The above advice on record representation clauses is followed,\n+and all mentioned features are implemented.\n+\n+.. index:: Storage place attributes\n+\n+RM 13.5.2(5): Storage Place Attributes\n+======================================\n+\n+  \"If a component is represented using some form of pointer (such as an\n+  offset) to the actual data of the component, and this data is contiguous\n+  with the rest of the object, then the storage place attributes should\n+  reflect the place of the actual data, not the pointer.  If a component is\n+  allocated discontinuously from the rest of the object, then a warning\n+  should be generated upon reference to one of its storage place\n+  attributes.\"\n+\n+Followed.  There are no such components in GNAT.\n+\n+.. index:: Bit ordering\n+\n+RM 13.5.3(7-8): Bit Ordering\n+============================\n+\n+  \"The recommended level of support for the non-default bit ordering is:\n+\n+  If `Word_Size` = `Storage_Unit`, then the implementation\n+  should support the non-default bit ordering in addition to the default\n+  bit ordering.\"\n+\n+Followed.  Word size does not equal storage size in this implementation.\n+Thus non-default bit ordering is not supported.\n+\n+.. index:: Address, as private type\n+\n+RM 13.7(37): Address as Private\n+===============================\n+\n+  \"`Address` should be of a private type.\"\n+\n+Followed.\n+\n+.. index:: Operations, on `Address`\n+\n+.. index:: Address, operations of\n+\n+RM 13.7.1(16): Address Operations\n+=================================\n+\n+  \"Operations in `System` and its children should reflect the target\n+  environment semantics as closely as is reasonable.  For example, on most\n+  machines, it makes sense for address arithmetic to 'wrap around'.\n+  Operations that do not make sense should raise `Program_Error`.\"\n+\n+Followed.  Address arithmetic is modular arithmetic that wraps around.  No\n+operation raises `Program_Error`, since all operations make sense.\n+\n+.. index:: Unchecked conversion\n+\n+RM 13.9(14-17): Unchecked Conversion\n+====================================\n+\n+  \"The `Size` of an array object should not include its bounds; hence,\n+  the bounds should not be part of the converted data.\"\n+\n+Followed.\n+\n+  \"The implementation should not generate unnecessary run-time checks to\n+  ensure that the representation of `S` is a representation of the\n+  target type.  It should take advantage of the permission to return by\n+  reference when possible.  Restrictions on unchecked conversions should be\n+  avoided unless required by the target environment.\"\n+\n+Followed.  There are no restrictions on unchecked conversion.  A warning is\n+generated if the source and target types do not have the same size since\n+the semantics in this case may be target dependent.\n+\n+  \"The recommended level of support for unchecked conversions is:\n+\n+  Unchecked conversions should be supported and should be reversible in\n+  the cases where this clause defines the result.  To enable meaningful use\n+  of unchecked conversion, a contiguous representation should be used for\n+  elementary subtypes, for statically constrained array subtypes whose\n+  component subtype is one of the subtypes described in this paragraph,\n+  and for record subtypes without discriminants whose component subtypes\n+  are described in this paragraph.\"\n+\n+Followed.\n+\n+.. index:: Heap usage, implicit\n+\n+RM 13.11(23-25): Implicit Heap Usage\n+====================================\n+\n+  \"An implementation should document any cases in which it dynamically\n+  allocates heap storage for a purpose other than the evaluation of an\n+  allocator.\"\n+\n+Followed, the only other points at which heap storage is dynamically\n+allocated are as follows:\n+\n+*\n+  At initial elaboration time, to allocate dynamically sized global\n+  objects.\n+\n+*\n+  To allocate space for a task when a task is created.\n+\n+*\n+  To extend the secondary stack dynamically when needed.  The secondary\n+  stack is used for returning variable length results.\n+\n+..\n+\n+  \"A default (implementation-provided) storage pool for an\n+  access-to-constant type should not have overhead to support deallocation of\n+  individual objects.\"\n+\n+Followed.\n+\n+  \"A storage pool for an anonymous access type should be created at the\n+  point of an allocator for the type, and be reclaimed when the designated\n+  object becomes inaccessible.\"\n+\n+Followed.\n+\n+.. index:: Unchecked deallocation\n+\n+RM 13.11.2(17): Unchecked Deallocation\n+======================================\n+\n+  \"For a standard storage pool, `Free` should actually reclaim the\n+  storage.\"\n+\n+Followed.\n+\n+.. index:: Stream oriented attributes\n+\n+RM 13.13.2(17): Stream Oriented Attributes\n+==========================================\n+\n+  \"If a stream element is the same size as a storage element, then the\n+  normal in-memory representation should be used by `Read` and\n+  `Write` for scalar objects.  Otherwise, `Read` and `Write`\n+  should use the smallest number of stream elements needed to represent\n+  all values in the base range of the scalar type.\"\n+\n+Followed.  By default, GNAT uses the interpretation suggested by AI-195,\n+which specifies using the size of the first subtype.\n+However, such an implementation is based on direct binary\n+representations and is therefore target- and endianness-dependent.\n+To address this issue, GNAT also supplies an alternate implementation\n+of the stream attributes `Read` and `Write`,\n+which uses the target-independent XDR standard representation\n+for scalar types.\n+\n+.. index:: XDR representation\n+\n+.. index:: Read attribute\n+\n+.. index:: Write attribute\n+\n+.. index:: Stream oriented attributes\n+\n+The XDR implementation is provided as an alternative body of the\n+`System.Stream_Attributes` package, in the file\n+:file:`s-stratt-xdr.adb` in the GNAT library.\n+There is no :file:`s-stratt-xdr.ads` file.\n+In order to install the XDR implementation, do the following:\n+\n+* Replace the default implementation of the\n+  `System.Stream_Attributes` package with the XDR implementation.\n+  For example on a Unix platform issue the commands:\n+\n+  .. code-block:: sh\n+\n+    $ mv s-stratt.adb s-stratt-default.adb\n+    $ mv s-stratt-xdr.adb s-stratt.adb\n+\n+\n+*\n+  Rebuild the GNAT run-time library as documented in\n+  the `GNAT and Libraries` section of the :title:`GNAT User's Guide`.\n+\n+RM A.1(52): Names of Predefined Numeric Types\n+=============================================\n+\n+  \"If an implementation provides additional named predefined integer types,\n+  then the names should end with ``Integer`` as in\n+  ``Long_Integer``.  If an implementation provides additional named\n+  predefined floating point types, then the names should end with\n+  ``Float`` as in ``Long_Float``.\"\n+\n+Followed.\n+\n+.. index:: Ada.Characters.Handling\n+\n+RM A.3.2(49): `Ada.Characters.Handling`\n+=======================================\n+\n+  \"If an implementation provides a localized definition of `Character`\n+  or `Wide_Character`, then the effects of the subprograms in\n+  `Characters.Handling` should reflect the localizations.\n+  See also 3.5.2.\"\n+\n+Followed.  GNAT provides no such localized definitions.\n+\n+.. index:: Bounded-length strings\n+\n+RM A.4.4(106): Bounded-Length String Handling\n+=============================================\n+\n+  \"Bounded string objects should not be implemented by implicit pointers\n+  and dynamic allocation.\"\n+\n+Followed.  No implicit pointers or dynamic allocation are used.\n+\n+.. index:: Random number generation\n+\n+RM A.5.2(46-47): Random Number Generation\n+=========================================\n+\n+  \"Any storage associated with an object of type `Generator` should be\n+  reclaimed on exit from the scope of the object.\"\n+\n+Followed.\n+\n+  \"If the generator period is sufficiently long in relation to the number\n+  of distinct initiator values, then each possible value of\n+  `Initiator` passed to `Reset` should initiate a sequence of\n+  random numbers that does not, in a practical sense, overlap the sequence\n+  initiated by any other value.  If this is not possible, then the mapping\n+  between initiator values and generator states should be a rapidly\n+  varying function of the initiator value.\"\n+\n+Followed.  The generator period is sufficiently long for the first\n+condition here to hold true.\n+\n+.. index:: Get_Immediate\n+\n+RM A.10.7(23): `Get_Immediate`\n+==============================\n+\n+  \"The `Get_Immediate` procedures should be implemented with\n+  unbuffered input.  For a device such as a keyboard, input should be\n+  available if a key has already been typed, whereas for a disk\n+  file, input should always be available except at end of file.  For a file\n+  associated with a keyboard-like device, any line-editing features of the\n+  underlying operating system should be disabled during the execution of\n+  `Get_Immediate`.\"\n+\n+Followed on all targets except VxWorks. For VxWorks, there is no way to\n+provide this functionality that does not result in the input buffer being\n+flushed before the `Get_Immediate` call. A special unit\n+`Interfaces.Vxworks.IO` is provided that contains routines to enable\n+this functionality.\n+\n+.. index:: Export\n+\n+RM B.1(39-41): Pragma `Export`\n+==============================\n+\n+  \"If an implementation supports pragma `Export` to a given language,\n+  then it should also allow the main subprogram to be written in that\n+  language.  It should support some mechanism for invoking the elaboration\n+  of the Ada library units included in the system, and for invoking the\n+  finalization of the environment task.  On typical systems, the\n+  recommended mechanism is to provide two subprograms whose link names are\n+  `adainit` and `adafinal`.  `adainit` should contain the\n+  elaboration code for library units.  `adafinal` should contain the\n+  finalization code.  These subprograms should have no effect the second\n+  and subsequent time they are called.\"\n+\n+Followed.\n+\n+  \"Automatic elaboration of pre-elaborated packages should be\n+  provided when pragma `Export` is supported.\"\n+\n+Followed when the main program is in Ada.  If the main program is in a\n+foreign language, then\n+`adainit` must be called to elaborate pre-elaborated\n+packages.\n+\n+  \"For each supported convention `L` other than `Intrinsic`, an\n+  implementation should support `Import` and `Export` pragmas\n+  for objects of `L`-compatible types and for subprograms, and pragma\n+  `Convention` for `L`-eligible types and for subprograms,\n+  presuming the other language has corresponding features.  Pragma\n+  `Convention` need not be supported for scalar types.\"\n+\n+Followed.\n+\n+.. index:: Package Interfaces\n+\n+.. index:: Interfaces\n+\n+RM B.2(12-13): Package `Interfaces`\n+===================================\n+\n+  \"For each implementation-defined convention identifier, there should be a\n+  child package of package Interfaces with the corresponding name.  This\n+  package should contain any declarations that would be useful for\n+  interfacing to the language (implementation) represented by the\n+  convention.  Any declarations useful for interfacing to any language on\n+  the given hardware architecture should be provided directly in\n+  `Interfaces`.\"\n+\n+Followed.\n+\n+  \"An implementation supporting an interface to C, COBOL, or Fortran should\n+  provide the corresponding package or packages described in the following\n+  clauses.\"\n+\n+Followed.  GNAT provides all the packages described in this section.\n+\n+.. index:: C, interfacing with\n+\n+RM B.3(63-71): Interfacing with C\n+=================================\n+\n+  \"An implementation should support the following interface correspondences\n+  between Ada and C.\"\n+\n+Followed.\n+\n+  \"An Ada procedure corresponds to a void-returning C function.\"\n+\n+Followed.\n+\n+  \"An Ada function corresponds to a non-void C function.\"\n+\n+Followed.\n+\n+  \"An Ada `in` scalar parameter is passed as a scalar argument to a C\n+  function.\"\n+\n+Followed.\n+\n+  \"An Ada `in` parameter of an access-to-object type with designated\n+  type `T` is passed as a ``t*`` argument to a C function,\n+  where ``t`` is the C type corresponding to the Ada type `T`.\"\n+\n+Followed.\n+\n+  \"An Ada access `T` parameter, or an Ada `out` or `in out`\n+  parameter of an elementary type `T`, is passed as a ``t*``\n+  argument to a C function, where ``t`` is the C type corresponding to\n+  the Ada type `T`.  In the case of an elementary `out` or\n+  `in out` parameter, a pointer to a temporary copy is used to\n+  preserve by-copy semantics.\"\n+\n+Followed.\n+\n+  \"An Ada parameter of a record type `T`, of any mode, is passed as a\n+  ``t*`` argument to a C function, where ``t`` is the C\n+  structure corresponding to the Ada type `T`.\"\n+\n+Followed.  This convention may be overridden by the use of the C_Pass_By_Copy\n+pragma, or Convention, or by explicitly specifying the mechanism for a given\n+call using an extended import or export pragma.\n+\n+  \"An Ada parameter of an array type with component type `T`, of any\n+  mode, is passed as a ``t*`` argument to a C function, where\n+  ``t`` is the C type corresponding to the Ada type `T`.\"\n+\n+Followed.\n+\n+  \"An Ada parameter of an access-to-subprogram type is passed as a pointer\n+  to a C function whose prototype corresponds to the designated\n+  subprogram's specification.\"\n+\n+Followed.\n+\n+.. index:: COBOL, interfacing with\n+\n+RM B.4(95-98): Interfacing with COBOL\n+=====================================\n+\n+  \"An Ada implementation should support the following interface\n+  correspondences between Ada and COBOL.\"\n+\n+Followed.\n+\n+  \"An Ada access `T` parameter is passed as a ``BY REFERENCE`` data item of\n+  the COBOL type corresponding to `T`.\"\n+\n+Followed.\n+\n+  \"An Ada in scalar parameter is passed as a ``BY CONTENT`` data item of\n+  the corresponding COBOL type.\"\n+\n+Followed.\n+\n+  \"Any other Ada parameter is passed as a ``BY REFERENCE`` data item of the\n+  COBOL type corresponding to the Ada parameter type; for scalars, a local\n+  copy is used if necessary to ensure by-copy semantics.\"\n+\n+Followed.\n+\n+.. index:: Fortran, interfacing with\n+\n+RM B.5(22-26): Interfacing with Fortran\n+=======================================\n+\n+  \"An Ada implementation should support the following interface\n+  correspondences between Ada and Fortran:\"\n+\n+Followed.\n+\n+  \"An Ada procedure corresponds to a Fortran subroutine.\"\n+\n+Followed.\n+\n+  \"An Ada function corresponds to a Fortran function.\"\n+\n+Followed.\n+\n+  \"An Ada parameter of an elementary, array, or record type `T` is\n+  passed as a `T` argument to a Fortran procedure, where `T` is\n+  the Fortran type corresponding to the Ada type `T`, and where the\n+  INTENT attribute of the corresponding dummy argument matches the Ada\n+  formal parameter mode; the Fortran implementation's parameter passing\n+  conventions are used.  For elementary types, a local copy is used if\n+  necessary to ensure by-copy semantics.\"\n+\n+Followed.\n+\n+  \"An Ada parameter of an access-to-subprogram type is passed as a\n+  reference to a Fortran procedure whose interface corresponds to the\n+  designated subprogram's specification.\"\n+\n+Followed.\n+\n+.. index:: Machine operations\n+\n+RM C.1(3-5): Access to Machine Operations\n+=========================================\n+\n+  \"The machine code or intrinsic support should allow access to all\n+  operations normally available to assembly language programmers for the\n+  target environment, including privileged instructions, if any.\"\n+\n+Followed.\n+\n+  \"The interfacing pragmas (see Annex B) should support interface to\n+  assembler; the default assembler should be associated with the\n+  convention identifier `Assembler`.\"\n+\n+Followed.\n+\n+  \"If an entity is exported to assembly language, then the implementation\n+  should allocate it at an addressable location, and should ensure that it\n+  is retained by the linking process, even if not otherwise referenced\n+  from the Ada code.  The implementation should assume that any call to a\n+  machine code or assembler subprogram is allowed to read or update every\n+  object that is specified as exported.\"\n+\n+Followed.\n+\n+RM C.1(10-16): Access to Machine Operations\n+===========================================\n+\n+  \"The implementation should ensure that little or no overhead is\n+  associated with calling intrinsic and machine-code subprograms.\"\n+\n+Followed for both intrinsics and machine-code subprograms.\n+\n+  \"It is recommended that intrinsic subprograms be provided for convenient\n+  access to any machine operations that provide special capabilities or\n+  efficiency and that are not otherwise available through the language\n+  constructs.\"\n+\n+Followed.  A full set of machine operation intrinsic subprograms is provided.\n+\n+  \"Atomic read-modify-write operations---e.g., test and set, compare and\n+  swap, decrement and test, enqueue/dequeue.\"\n+\n+Followed on any target supporting such operations.\n+\n+  \"Standard numeric functions---e.g.:, sin, log.\"\n+\n+Followed on any target supporting such operations.\n+\n+  \"String manipulation operations---e.g.:, translate and test.\"\n+\n+Followed on any target supporting such operations.\n+\n+  \"Vector operations---e.g.:, compare vector against thresholds.\"\n+\n+Followed on any target supporting such operations.\n+\n+  \"Direct operations on I/O ports.\"\n+\n+Followed on any target supporting such operations.\n+\n+.. index:: Interrupt support\n+\n+RM C.3(28): Interrupt Support\n+=============================\n+\n+  \"If the `Ceiling_Locking` policy is not in effect, the\n+  implementation should provide means for the application to specify which\n+  interrupts are to be blocked during protected actions, if the underlying\n+  system allows for a finer-grain control of interrupt blocking.\"\n+\n+Followed.  The underlying system does not allow for finer-grain control\n+of interrupt blocking.\n+\n+.. index:: Protected procedure handlers\n+\n+RM C.3.1(20-21): Protected Procedure Handlers\n+=============================================\n+\n+  \"Whenever possible, the implementation should allow interrupt handlers to\n+  be called directly by the hardware.\"\n+\n+Followed on any target where the underlying operating system permits\n+such direct calls.\n+\n+  \"Whenever practical, violations of any\n+  implementation-defined restrictions should be detected before run time.\"\n+\n+Followed.  Compile time warnings are given when possible.\n+\n+.. index:: Package `Interrupts`\n+\n+.. index:: Interrupts\n+\n+RM C.3.2(25): Package `Interrupts`\n+==================================\n+\n+  \"If implementation-defined forms of interrupt handler procedures are\n+  supported, such as protected procedures with parameters, then for each\n+  such form of a handler, a type analogous to `Parameterless_Handler`\n+  should be specified in a child package of `Interrupts`, with the\n+  same operations as in the predefined package Interrupts.\"\n+\n+Followed.\n+\n+.. index:: Pre-elaboration requirements\n+\n+RM C.4(14): Pre-elaboration Requirements\n+========================================\n+\n+  \"It is recommended that pre-elaborated packages be implemented in such a\n+  way that there should be little or no code executed at run time for the\n+  elaboration of entities not already covered by the Implementation\n+  Requirements.\"\n+\n+Followed.  Executable code is generated in some cases, e.g., loops\n+to initialize large arrays.\n+\n+RM C.5(8): Pragma `Discard_Names`\n+=================================\n+\n+  \"If the pragma applies to an entity, then the implementation should\n+  reduce the amount of storage used for storing names associated with that\n+  entity.\"\n+\n+Followed.\n+\n+.. index:: Package Task_Attributes\n+\n+.. index:: Task_Attributes\n+\n+RM C.7.2(30): The Package Task_Attributes\n+=========================================\n+\n+  \"Some implementations are targeted to domains in which memory use at run\n+  time must be completely deterministic.  For such implementations, it is\n+  recommended that the storage for task attributes will be pre-allocated\n+  statically and not from the heap.  This can be accomplished by either\n+  placing restrictions on the number and the size of the task's\n+  attributes, or by using the pre-allocated storage for the first `N`\n+  attribute objects, and the heap for the others.  In the latter case,\n+  `N` should be documented.\"\n+\n+Not followed.  This implementation is not targeted to such a domain.\n+\n+.. index:: Locking Policies\n+\n+RM D.3(17): Locking Policies\n+============================\n+\n+  \"The implementation should use names that end with ``_Locking`` for\n+  locking policies defined by the implementation.\"\n+\n+Followed.  Two implementation-defined locking policies are defined,\n+whose names (`Inheritance_Locking` and\n+`Concurrent_Readers_Locking`) follow this suggestion.\n+\n+.. index:: Entry queuing policies\n+\n+RM D.4(16): Entry Queuing Policies\n+==================================\n+\n+  \"Names that end with ``_Queuing`` should be used\n+  for all implementation-defined queuing policies.\"\n+\n+Followed.  No such implementation-defined queuing policies exist.\n+\n+.. index:: Preemptive abort\n+\n+RM D.6(9-10): Preemptive Abort\n+==============================\n+\n+  \"Even though the `abort_statement` is included in the list of\n+  potentially blocking operations (see 9.5.1), it is recommended that this\n+  statement be implemented in a way that never requires the task executing\n+  the `abort_statement` to block.\"\n+\n+Followed.\n+\n+  \"On a multi-processor, the delay associated with aborting a task on\n+  another processor should be bounded; the implementation should use\n+  periodic polling, if necessary, to achieve this.\"\n+\n+Followed.\n+\n+.. index:: Tasking restrictions\n+\n+RM D.7(21): Tasking Restrictions\n+================================\n+\n+  \"When feasible, the implementation should take advantage of the specified\n+  restrictions to produce a more efficient implementation.\"\n+\n+GNAT currently takes advantage of these restrictions by providing an optimized\n+run time when the Ravenscar profile and the GNAT restricted run time set\n+of restrictions are specified.  See pragma `Profile (Ravenscar)` and\n+pragma `Profile (Restricted)` for more details.\n+\n+.. index:: Time, monotonic\n+\n+RM D.8(47-49): Monotonic Time\n+=============================\n+\n+  \"When appropriate, implementations should provide configuration\n+  mechanisms to change the value of `Tick`.\"\n+\n+Such configuration mechanisms are not appropriate to this implementation\n+and are thus not supported.\n+\n+  \"It is recommended that `Calendar.Clock` and `Real_Time.Clock`\n+  be implemented as transformations of the same time base.\"\n+\n+Followed.\n+\n+\n+  \"It is recommended that the best time base which exists in\n+  the underlying system be available to the application through\n+  `Clock`.  `Best` may mean highest accuracy or largest range.\"\n+\n+Followed.\n+\n+.. index:: Partition communication subsystem\n+\n+.. index:: PCS\n+\n+RM E.5(28-29): Partition Communication Subsystem\n+================================================\n+\n+  \"Whenever possible, the PCS on the called partition should allow for\n+  multiple tasks to call the RPC-receiver with different messages and\n+  should allow them to block until the corresponding subprogram body\n+  returns.\"\n+\n+Followed by GLADE, a separately supplied PCS that can be used with\n+GNAT.\n+\n+  \"The `Write` operation on a stream of type `Params_Stream_Type`\n+  should raise `Storage_Error` if it runs out of space trying to\n+  write the `Item` into the stream.\"\n+\n+Followed by GLADE, a separately supplied PCS that can be used with\n+GNAT.\n+\n+.. index:: COBOL support\n+\n+RM F(7): COBOL Support\n+======================\n+\n+  \"If COBOL (respectively, C) is widely supported in the target\n+  environment, implementations supporting the Information Systems Annex\n+  should provide the child package `Interfaces.COBOL` (respectively,\n+  `Interfaces.C`) specified in Annex B and should support a\n+  `convention_identifier` of COBOL (respectively, C) in the interfacing\n+  pragmas (see Annex B), thus allowing Ada programs to interface with\n+  programs written in that language.\"\n+\n+Followed.\n+\n+.. index:: Decimal radix support\n+\n+RM F.1(2): Decimal Radix Support\n+================================\n+\n+  \"Packed decimal should be used as the internal representation for objects\n+  of subtype `S` when `S`'Machine_Radix = 10.\"\n+\n+Not followed.  GNAT ignores `S`'Machine_Radix and always uses binary\n+representations.\n+\n+.. index:: Numerics\n+\n+RM G: Numerics\n+==============\n+\n+  \"If Fortran (respectively, C) is widely supported in the target\n+  environment, implementations supporting the Numerics Annex\n+  should provide the child package `Interfaces.Fortran` (respectively,\n+  `Interfaces.C`) specified in Annex B and should support a\n+  `convention_identifier` of Fortran (respectively, C) in the interfacing\n+  pragmas (see Annex B), thus allowing Ada programs to interface with\n+  programs written in that language.\"\n+\n+Followed.\n+\n+.. index:: Complex types\n+\n+RM G.1.1(56-58): Complex Types\n+==============================\n+\n+  \"Because the usual mathematical meaning of multiplication of a complex\n+  operand and a real operand is that of the scaling of both components of\n+  the former by the latter, an implementation should not perform this\n+  operation by first promoting the real operand to complex type and then\n+  performing a full complex multiplication.  In systems that, in the\n+  future, support an Ada binding to IEC 559:1989, the latter technique\n+  will not generate the required result when one of the components of the\n+  complex operand is infinite.  (Explicit multiplication of the infinite\n+  component by the zero component obtained during promotion yields a NaN\n+  that propagates into the final result.) Analogous advice applies in the\n+  case of multiplication of a complex operand and a pure-imaginary\n+  operand, and in the case of division of a complex operand by a real or\n+  pure-imaginary operand.\"\n+\n+Not followed.\n+\n+  \"Similarly, because the usual mathematical meaning of addition of a\n+  complex operand and a real operand is that the imaginary operand remains\n+  unchanged, an implementation should not perform this operation by first\n+  promoting the real operand to complex type and then performing a full\n+  complex addition.  In implementations in which the `Signed_Zeros`\n+  attribute of the component type is `True` (and which therefore\n+  conform to IEC 559:1989 in regard to the handling of the sign of zero in\n+  predefined arithmetic operations), the latter technique will not\n+  generate the required result when the imaginary component of the complex\n+  operand is a negatively signed zero.  (Explicit addition of the negative\n+  zero to the zero obtained during promotion yields a positive zero.)\n+  Analogous advice applies in the case of addition of a complex operand\n+  and a pure-imaginary operand, and in the case of subtraction of a\n+  complex operand and a real or pure-imaginary operand.\"\n+\n+Not followed.\n+\n+  \"Implementations in which `Real'Signed_Zeros` is `True` should\n+  attempt to provide a rational treatment of the signs of zero results and\n+  result components.  As one example, the result of the `Argument`\n+  function should have the sign of the imaginary component of the\n+  parameter `X` when the point represented by that parameter lies on\n+  the positive real axis; as another, the sign of the imaginary component\n+  of the `Compose_From_Polar` function should be the same as\n+  (respectively, the opposite of) that of the `Argument` parameter when that\n+  parameter has a value of zero and the `Modulus` parameter has a\n+  nonnegative (respectively, negative) value.\"\n+\n+Followed.\n+\n+.. index:: Complex elementary functions\n+\n+RM G.1.2(49): Complex Elementary Functions\n+==========================================\n+\n+  \"Implementations in which `Complex_Types.Real'Signed_Zeros` is\n+  `True` should attempt to provide a rational treatment of the signs\n+  of zero results and result components.  For example, many of the complex\n+  elementary functions have components that are odd functions of one of\n+  the parameter components; in these cases, the result component should\n+  have the sign of the parameter component at the origin.  Other complex\n+  elementary functions have zero components whose sign is opposite that of\n+  a parameter component at the origin, or is always positive or always\n+  negative.\"\n+\n+Followed.\n+\n+.. index:: Accuracy requirements\n+\n+RM G.2.4(19): Accuracy Requirements\n+===================================\n+\n+  \"The versions of the forward trigonometric functions without a\n+  `Cycle` parameter should not be implemented by calling the\n+  corresponding version with a `Cycle` parameter of\n+  `2.0*Numerics.Pi`, since this will not provide the required\n+  accuracy in some portions of the domain.  For the same reason, the\n+  version of `Log` without a `Base` parameter should not be\n+  implemented by calling the corresponding version with a `Base`\n+  parameter of `Numerics.e`.\"\n+\n+Followed.\n+\n+.. index:: Complex arithmetic accuracy\n+\n+.. index:: Accuracy, complex arithmetic\n+\n+RM G.2.6(15): Complex Arithmetic Accuracy\n+=========================================\n+\n+  \"The version of the `Compose_From_Polar` function without a\n+  `Cycle` parameter should not be implemented by calling the\n+  corresponding version with a `Cycle` parameter of\n+  `2.0*Numerics.Pi`, since this will not provide the required\n+  accuracy in some portions of the domain.\"\n+\n+Followed.\n+\n+.. index:: Sequential elaboration policy\n+\n+RM H.6(15/2): Pragma Partition_Elaboration_Policy\n+=================================================\n+\n+  \"If the partition elaboration policy is `Sequential` and the\n+  Environment task becomes permanently blocked during elaboration then the\n+  partition is deadlocked and it is recommended that the partition be\n+  immediately terminated.\"\n+\n+Not followed."}, {"sha": "9b9fd11442aef93a41f16a149e732b9200d5f918", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_aspects.rst", "status": "added", "additions": 520, "deletions": 0, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_aspects.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_aspects.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_aspects.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,520 @@\n+.. _Implementation_Defined_Aspects:\n+\n+******************************\n+Implementation Defined Aspects\n+******************************\n+\n+Ada defines (throughout the Ada 2012 reference manual, summarized\n+in Annex K) a set of aspects that can be specified for certain entities.\n+These language defined aspects are implemented in GNAT in Ada 2012 mode\n+and work as described in the Ada 2012 Reference Manual.\n+\n+In addition, Ada 2012 allows implementations to define additional aspects\n+whose meaning is defined by the implementation.  GNAT provides\n+a number of these implementation-defined aspects which can be used\n+to extend and enhance the functionality of the compiler.  This section of\n+the GNAT reference manual describes these additional aspects.\n+\n+Note that any program using these aspects may not be portable to\n+other compilers (although GNAT implements this set of aspects on all\n+platforms).  Therefore if portability to other compilers is an important\n+consideration, you should minimize the use of these aspects.\n+\n+Note that for many of these aspects, the effect is essentially similar\n+to the use of a pragma or attribute specification with the same name\n+applied to the entity. For example, if we write:\n+\n+\n+.. code-block:: ada\n+\n+  type R is range 1 .. 100\n+    with Value_Size => 10;\n+\n+\n+then the effect is the same as:\n+\n+.. code-block:: ada\n+\n+  type R is range 1 .. 100;\n+  for R'Value_Size use 10;\n+\n+\n+and if we write:\n+\n+.. code-block:: ada\n+\n+  type R is new Integer\n+    with Shared => True;\n+\n+\n+then the effect is the same as:\n+\n+.. code-block:: ada\n+\n+  type R is new Integer;\n+  pragma Shared (R);\n+\n+\n+In the documentation below, such cases are simply marked\n+as being boolean aspects equivalent to the corresponding pragma\n+or attribute definition clause.\n+\n+Aspect Abstract_State\n+=====================\n+\n+.. index:: Abstract_State\n+\n+This aspect is equivalent to pragma `Abstract_State`.\n+\n+Annotate\n+========\n+.. index:: Annotate\n+\n+There are three forms of this aspect (where ID is an identifier,\n+and ARG is a general expression).\n+\n+\n+\n+*Annotate => ID*\n+  Equivalent to `pragma Annotate (ID, Entity => Name);`\n+\n+\n+*Annotate => (ID)*\n+  Equivalent to `pragma Annotate (ID, Entity => Name);`\n+\n+\n+*Annotate => (ID ,ID {, ARG})*\n+  Equivalent to `pragma Annotate (ID, ID {, ARG}, Entity => Name);`\n+\n+Aspect Async_Readers\n+====================\n+.. index:: Async_Readers\n+\n+This boolean aspect is equivalent to pragma `Async_Readers`.\n+\n+Aspect Async_Writers\n+====================\n+.. index:: Async_Writers\n+\n+This boolean aspect is equivalent to pragma `Async_Writers`.\n+\n+Aspect Contract_Cases\n+=====================\n+.. index:: Contract_Cases\n+\n+This aspect is equivalent to pragma `Contract_Cases`, the sequence\n+of clauses being enclosed in parentheses so that syntactically it is an\n+aggregate.\n+\n+Aspect Depends\n+==============\n+.. index:: Depends\n+\n+This aspect is equivalent to pragma `Depends`.\n+\n+Aspect Dimension\n+================\n+.. index:: Dimension\n+\n+The `Dimension` aspect is used to specify the dimensions of a given\n+subtype of a dimensioned numeric type. The aspect also specifies a symbol\n+used when doing formatted output of dimensioned quantities. The syntax is::\n+\n+  with Dimension =>\n+    ([Symbol =>] SYMBOL, DIMENSION_VALUE {, DIMENSION_Value})\n+\n+  SYMBOL ::= STRING_LITERAL | CHARACTER_LITERAL\n+\n+  DIMENSION_VALUE ::=\n+    RATIONAL\n+  | others               => RATIONAL\n+  | DISCRETE_CHOICE_LIST => RATIONAL\n+\n+  RATIONAL ::= [-] NUMERIC_LITERAL [/ NUMERIC_LITERAL]\n+\n+\n+This aspect can only be applied to a subtype whose parent type has\n+a `Dimension_Systen` aspect. The aspect must specify values for\n+all dimensions of the system. The rational values are the powers of the\n+corresponding dimensions that are used by the compiler to verify that\n+physical (numeric) computations are dimensionally consistent. For example,\n+the computation of a force must result in dimensions (L => 1, M => 1, T => -2).\n+For further examples of the usage\n+of this aspect, see package `System.Dim.Mks`.\n+Note that when the dimensioned type is an integer type, then any\n+dimension value must be an integer literal.\n+\n+Aspect Dimension_System\n+=======================\n+.. index:: Dimension_System\n+\n+The `Dimension_System` aspect is used to define a system of\n+dimensions that will be used in subsequent subtype declarations with\n+`Dimension` aspects that reference this system. The syntax is::\n+\n+  with Dimension_System => (DIMENSION {, DIMENSION});\n+\n+  DIMENSION ::= ([Unit_Name   =>] IDENTIFIER,\n+                 [Unit_Symbol =>] SYMBOL,\n+                 [Dim_Symbol  =>] SYMBOL)\n+\n+  SYMBOL ::= CHARACTER_LITERAL | STRING_LITERAL\n+\n+\n+This aspect is applied to a type, which must be a numeric derived type\n+(typically a floating-point type), that\n+will represent values within the dimension system. Each `DIMENSION`\n+corresponds to one particular dimension. A maximum of 7 dimensions may\n+be specified. `Unit_Name` is the name of the dimension (for example\n+`Meter`). `Unit_Symbol` is the shorthand used for quantities\n+of this dimension (for example `m` for `Meter`).\n+`Dim_Symbol` gives\n+the identification within the dimension system (typically this is a\n+single letter, e.g. `L` standing for length for unit name `Meter`).\n+The `Unit_Symbol` is used in formatted output of dimensioned quantities.\n+The `Dim_Symbol` is used in error messages when numeric operations have\n+inconsistent dimensions.\n+\n+GNAT provides the standard definition of the International MKS system in\n+the run-time package `System.Dim.Mks`. You can easily define\n+similar packages for cgs units or British units, and define conversion factors\n+between values in different systems. The MKS system is characterized by the\n+following aspect:\n+\n+.. code-block:: ada\n+\n+     type Mks_Type is new Long_Long_Float with\n+       Dimension_System => (\n+         (Unit_Name => Meter,    Unit_Symbol => 'm',   Dim_Symbol => 'L'),\n+         (Unit_Name => Kilogram, Unit_Symbol => \"kg\",  Dim_Symbol => 'M'),\n+         (Unit_Name => Second,   Unit_Symbol => 's',   Dim_Symbol => 'T'),\n+         (Unit_Name => Ampere,   Unit_Symbol => 'A',   Dim_Symbol => 'I'),\n+         (Unit_Name => Kelvin,   Unit_Symbol => 'K',   Dim_Symbol => '@'),\n+         (Unit_Name => Mole,     Unit_Symbol => \"mol\", Dim_Symbol => 'N'),\n+         (Unit_Name => Candela,  Unit_Symbol => \"cd\",  Dim_Symbol => 'J'));\n+\n+\n+Note that in the above type definition, we use the `at` symbol (``@``) to\n+represent a theta character (avoiding the use of extended Latin-1\n+characters in this context).\n+\n+See section 'Performing Dimensionality Analysis in GNAT' in the GNAT Users\n+Guide for detailed examples of use of the dimension system.\n+\n+Aspect Effective_Reads\n+======================\n+.. index:: Effective_Reads\n+\n+This aspect is equivalent to pragma `Effective_Reads`.\n+\n+Aspect Effective_Writes\n+=======================\n+.. index:: Effective_Writes\n+\n+This aspect is equivalent to pragma `Effective_Writes`.\n+\n+Aspect Favor_Top_Level\n+======================\n+.. index:: Favor_Top_Level\n+\n+This boolean aspect is equivalent to pragma `Favor_Top_Level`.\n+\n+Aspect Global\n+=============\n+.. index:: Global\n+\n+This aspect is equivalent to pragma `Global`.\n+\n+Aspect Initial_Condition\n+========================\n+.. index:: Initial_Condition\n+\n+This aspect is equivalent to pragma `Initial_Condition`.\n+\n+Aspect Initializes\n+==================\n+.. index:: Initializes\n+\n+This aspect is equivalent to pragma `Initializes`.\n+\n+Aspect Inline_Always\n+====================\n+.. index:: Inline_Always\n+\n+This boolean aspect is equivalent to pragma `Inline_Always`.\n+\n+Aspect Invariant\n+================\n+.. index:: Invariant\n+\n+This aspect is equivalent to pragma `Invariant`. It is a\n+synonym for the language defined aspect `Type_Invariant` except\n+that it is separately controllable using pragma `Assertion_Policy`.\n+\n+Aspect Invariant'Class\n+======================\n+.. index:: Invariant'Class\n+\n+This aspect is equivalent to pragma `Type_Invariant_Class`. It is a\n+synonym for the language defined aspect `Type_Invariant'Class` except\n+that it is separately controllable using pragma `Assertion_Policy`.\n+\n+Aspect Iterable\n+===============\n+.. index:: Iterable\n+\n+This aspect provides a light-weight mechanism for loops and quantified\n+expressions over container types, without the overhead imposed by the tampering\n+checks of standard Ada 2012 iterators. The value of the aspect is an aggregate\n+with four named components: `First`, `Next`, `Has_Element`, and `Element` (the\n+last one being optional). When only 3 components are specified, only the\n+`for .. in` form of iteration over cursors is available. When all 4 components\n+are specified, both this form and the `for .. of` form of iteration over\n+elements are available. The following is a typical example of use:\n+\n+.. code-block:: ada\n+\n+  type List is private with\n+      Iterable => (First        => First_Cursor,\n+                   Next         => Advance,\n+                   Has_Element  => Cursor_Has_Element,\n+                  [Element      => Get_Element]);\n+\n+* The value denoted by `First` must denote a primitive operation of the\n+  container type that returns a `Cursor`, which must a be a type declared in\n+  the container package or visible from it. For example:\n+\n+.. code-block:: ada\n+\n+  function First_Cursor (Cont : Container) return Cursor;\n+\n+* The value of `Next` is a primitive operation of the container type that takes\n+  both a container and a cursor and yields a cursor. For example:\n+\n+.. code-block:: ada\n+\n+  function Advance (Cont : Container; Position : Cursor) return Cursor;\n+\n+* The value of `Has_Element` is a primitive operation of the container type\n+  that takes both a container and a cursor and yields a boolean. For example:\n+\n+.. code-block:: ada\n+\n+  function Cursor_Has_Element (Cont : Container; Position : Cursor) return Boolean;\n+\n+* The value of `Element` is a primitive operation of the container type that\n+  takes both a container and a cursor and yields an `Element_Type`, which must\n+  be a type declared in the container package or visible from it. For example:\n+\n+.. code-block:: ada\n+\n+  function Get_Element (Cont : Container; Position : Cursor) return Element_Type;\n+\n+This aspect is used in the GNAT-defined formal container packages.\n+\n+Aspect Linker_Section\n+=====================\n+.. index:: Linker_Section\n+\n+This aspect is equivalent to an `Linker_Section` pragma.\n+\n+Aspect Lock_Free\n+================\n+.. index:: Lock_Free\n+\n+This boolean aspect is equivalent to pragma `Lock_Free`.\n+\n+Aspect No_Elaboration_Code_All\n+==============================\n+.. index:: No_Elaboration_Code_All\n+\n+This aspect is equivalent to a `pragma No_Elaboration_Code_All`\n+statement for a program unit.\n+\n+Aspect No_Tagged_Streams\n+========================\n+.. index:: No_Tagged_Streams\n+\n+This aspect is equivalent to a `pragma No_Tagged_Streams` with an\n+argument specifying a root tagged type (thus this aspect can only be\n+applied to such a type).\n+\n+Aspect Object_Size\n+==================\n+.. index:: Object_Size\n+\n+This aspect is equivalent to an `Object_Size` attribute definition\n+clause.\n+\n+Aspect Obsolescent\n+==================\n+.. index:: Obsolsecent\n+\n+This aspect is equivalent to an `Obsolescent` pragma. Note that the\n+evaluation of this aspect happens at the point of occurrence, it is not\n+delayed until the freeze point.\n+\n+Aspect Part_Of\n+==============\n+.. index:: Part_Of\n+\n+This aspect is equivalent to pragma `Part_Of`.\n+\n+Aspect Persistent_BSS\n+=====================\n+.. index:: Persistent_BSS\n+\n+This boolean aspect is equivalent to pragma `Persistent_BSS`.\n+\n+Aspect Predicate\n+================\n+.. index:: Predicate\n+\n+This aspect is equivalent to pragma `Predicate`. It is thus\n+similar to the language defined aspects `Dynamic_Predicate`\n+and `Static_Predicate` except that whether the resulting\n+predicate is static or dynamic is controlled by the form of the\n+expression. It is also separately controllable using pragma\n+`Assertion_Policy`.\n+\n+Aspect Pure_Function\n+====================\n+.. index:: Pure_Function\n+\n+This boolean aspect is equivalent to pragma `Pure_Function`.\n+\n+Aspect Refined_Depends\n+======================\n+.. index:: Refined_Depends\n+\n+This aspect is equivalent to pragma `Refined_Depends`.\n+\n+Aspect Refined_Global\n+=====================\n+.. index:: Refined_Global\n+\n+This aspect is equivalent to pragma `Refined_Global`.\n+\n+Aspect Refined_Post\n+===================\n+.. index:: Refined_Post\n+\n+This aspect is equivalent to pragma `Refined_Post`.\n+\n+Aspect Refined_State\n+====================\n+.. index:: Refined_State\n+\n+This aspect is equivalent to pragma `Refined_State`.\n+\n+Aspect Remote_Access_Type\n+=========================\n+.. index:: Remote_Access_Type\n+\n+This aspect is equivalent to pragma `Remote_Access_Type`.\n+\n+Aspect Scalar_Storage_Order\n+===========================\n+.. index:: Scalar_Storage_Order\n+\n+This aspect is equivalent to a `Scalar_Storage_Order`\n+attribute definition clause.\n+\n+Aspect Shared\n+=============\n+.. index:: Shared\n+\n+This boolean aspect is equivalent to pragma `Shared`,\n+and is thus a synonym for aspect `Atomic`.\n+\n+Aspect Simple_Storage_Pool\n+==========================\n+.. index:: Simple_Storage_Pool\n+\n+This aspect is equivalent to a `Simple_Storage_Pool`\n+attribute definition clause.\n+\n+Aspect Simple_Storage_Pool_Type\n+===============================\n+.. index:: Simple_Storage_Pool_Type\n+\n+This boolean aspect is equivalent to pragma `Simple_Storage_Pool_Type`.\n+\n+Aspect SPARK_Mode\n+=================\n+.. index:: SPARK_Mode\n+\n+This aspect is equivalent to pragma `SPARK_Mode` and\n+may be specified for either or both of the specification and body\n+of a subprogram or package.\n+\n+Aspect Suppress_Debug_Info\n+==========================\n+.. index:: Suppress_Debug_Info\n+\n+This boolean aspect is equivalent to pragma `Suppress_Debug_Info`.\n+\n+Aspect Suppress_Initialization\n+==============================\n+.. index:: Suppress_Initialization\n+\n+This boolean aspect is equivalent to pragma `Suppress_Initialization`.\n+\n+Aspect Test_Case\n+================\n+.. index:: Test_Case\n+\n+This aspect is equivalent to pragma `Test_Case`.\n+\n+Aspect Thread_Local_Storage\n+===========================\n+.. index:: Thread_Local_Storage\n+\n+This boolean aspect is equivalent to pragma `Thread_Local_Storage`.\n+\n+Aspect Universal_Aliasing\n+=========================\n+.. index:: Universal_Aliasing\n+\n+This boolean aspect is equivalent to pragma `Universal_Aliasing`.\n+\n+Aspect Universal_Data\n+=====================\n+.. index:: Universal_Data\n+\n+This aspect is equivalent to pragma `Universal_Data`.\n+\n+Aspect Unmodified\n+=================\n+.. index:: Unmodified\n+\n+This boolean aspect is equivalent to pragma `Unmodified`.\n+\n+Aspect Unreferenced\n+===================\n+.. index:: Unreferenced\n+\n+This boolean aspect is equivalent to pragma `Unreferenced`. Note that\n+in the case of formal parameters, it is not permitted to have aspects for\n+a formal parameter, so in this case the pragma form must be used.\n+\n+Aspect Unreferenced_Objects\n+===========================\n+.. index:: Unreferenced_Objects\n+\n+This boolean aspect is equivalent to pragma `Unreferenced_Objects`.\n+\n+Aspect Value_Size\n+=================\n+.. index:: Value_Size\n+\n+This aspect is equivalent to a `Value_Size`\n+attribute definition clause.\n+\n+Aspect Warnings\n+===============\n+.. index:: Warnings\n+\n+This aspect is equivalent to the two argument form of pragma `Warnings`,\n+where the first argument is `ON` or `OFF` and the second argument\n+is the entity."}, {"sha": "b25f9c996a60d32b9e879ff9beb115e32a5e6d5d", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_attributes.rst", "status": "added", "additions": 1589, "deletions": 0, "changes": 1589, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,1589 @@\n+.. _Implementation_Defined_Attributes:\n+\n+*********************************\n+Implementation Defined Attributes\n+*********************************\n+\n+Ada defines (throughout the Ada reference manual,\n+summarized in Annex K),\n+a set of attributes that provide useful additional functionality in all\n+areas of the language.  These language defined attributes are implemented\n+in GNAT and work as described in the Ada Reference Manual.\n+\n+In addition, Ada allows implementations to define additional\n+attributes whose meaning is defined by the implementation.  GNAT provides\n+a number of these implementation-dependent attributes which can be used\n+to extend and enhance the functionality of the compiler.  This section of\n+the GNAT reference manual describes these additional attributes.  It also\n+describes additional implementation-dependent features of standard\n+language-defined attributes.\n+\n+Note that any program using these attributes may not be portable to\n+other compilers (although GNAT implements this set of attributes on all\n+platforms).  Therefore if portability to other compilers is an important\n+consideration, you should minimize the use of these attributes.\n+\n+Attribute Abort_Signal\n+======================\n+.. index:: Abort_Signal\n+\n+`Standard'Abort_Signal` (`Standard` is the only allowed\n+prefix) provides the entity for the special exception used to signal\n+task abort or asynchronous transfer of control.  Normally this attribute\n+should only be used in the tasking runtime (it is highly peculiar, and\n+completely outside the normal semantics of Ada, for a user program to\n+intercept the abort exception).\n+\n+Attribute Address_Size\n+======================\n+.. index:: Size of `Address`\n+\n+.. index:: Address_Size\n+\n+`Standard'Address_Size` (`Standard` is the only allowed\n+prefix) is a static constant giving the number of bits in an\n+`Address`. It is the same value as System.Address'Size,\n+but has the advantage of being static, while a direct\n+reference to System.Address'Size is non-static because Address\n+is a private type.\n+\n+Attribute Asm_Input\n+===================\n+.. index:: Asm_Input\n+\n+The `Asm_Input` attribute denotes a function that takes two\n+parameters.  The first is a string, the second is an expression of the\n+type designated by the prefix.  The first (string) argument is required\n+to be a static expression, and is the constraint for the parameter,\n+(e.g., what kind of register is required).  The second argument is the\n+value to be used as the input argument.  The possible values for the\n+constant are the same as those used in the RTL, and are dependent on\n+the configuration file used to built the GCC back end.\n+:ref:`Machine_Code_Insertions`\n+\n+Attribute Asm_Output\n+====================\n+.. index:: Asm_Output\n+\n+The `Asm_Output` attribute denotes a function that takes two\n+parameters.  The first is a string, the second is the name of a variable\n+of the type designated by the attribute prefix.  The first (string)\n+argument is required to be a static expression and designates the\n+constraint for the parameter (e.g., what kind of register is\n+required).  The second argument is the variable to be updated with the\n+result.  The possible values for constraint are the same as those used in\n+the RTL, and are dependent on the configuration file used to build the\n+GCC back end.  If there are no output operands, then this argument may\n+either be omitted, or explicitly given as `No_Output_Operands`.\n+:ref:`Machine_Code_Insertions`\n+\n+Attribute Atomic_Always_Lock_Free\n+=================================\n+.. index:: Atomic_Always_Lock_Free\n+\n+The prefix of the `Atomic_Always_Lock_Free` attribute is a type.\n+The result is a Boolean value which is True if the type has discriminants,\n+and False otherwise.  The result indicate whether atomic operations are\n+supported by the target for the given type.\n+\n+Attribute Bit\n+=============\n+.. index:: Bit\n+\n+``obj'Bit``, where `obj` is any object, yields the bit\n+offset within the storage unit (byte) that contains the first bit of\n+storage allocated for the object.  The value of this attribute is of the\n+type `Universal_Integer`, and is always a non-negative number not\n+exceeding the value of `System.Storage_Unit`.\n+\n+For an object that is a variable or a constant allocated in a register,\n+the value is zero.  (The use of this attribute does not force the\n+allocation of a variable to memory).\n+\n+For an object that is a formal parameter, this attribute applies\n+to either the matching actual parameter or to a copy of the\n+matching actual parameter.\n+\n+For an access object the value is zero.  Note that\n+``obj.all'Bit`` is subject to an `Access_Check` for the\n+designated object.  Similarly for a record component\n+``X.C'Bit`` is subject to a discriminant check and\n+``X(I).Bit`` and ``X(I1..I2)'Bit``\n+are subject to index checks.\n+\n+This attribute is designed to be compatible with the DEC Ada 83 definition\n+and implementation of the `Bit` attribute.\n+\n+Attribute Bit_Position\n+======================\n+.. index:: Bit_Position\n+\n+``R.C'Bit_Position``, where `R` is a record object and `C` is one\n+of the fields of the record type, yields the bit\n+offset within the record contains the first bit of\n+storage allocated for the object.  The value of this attribute is of the\n+type `Universal_Integer`.  The value depends only on the field\n+`C` and is independent of the alignment of\n+the containing record `R`.\n+\n+Attribute Code_Address\n+======================\n+.. index:: Code_Address\n+.. index:: Subprogram address\n+\n+.. index:: Address of subprogram code\n+\n+The `'Address`\n+attribute may be applied to subprograms in Ada 95 and Ada 2005, but the\n+intended effect seems to be to provide\n+an address value which can be used to call the subprogram by means of\n+an address clause as in the following example:\n+\n+.. code-block:: ada\n+\n+  procedure K is ...\n+\n+  procedure L;\n+  for L'Address use K'Address;\n+  pragma Import (Ada, L);\n+  \n+\n+A call to `L` is then expected to result in a call to `K`.\n+In Ada 83, where there were no access-to-subprogram values, this was\n+a common work-around for getting the effect of an indirect call.\n+GNAT implements the above use of `Address` and the technique\n+illustrated by the example code works correctly.\n+\n+However, for some purposes, it is useful to have the address of the start\n+of the generated code for the subprogram.  On some architectures, this is\n+not necessarily the same as the `Address` value described above.\n+For example, the `Address` value may reference a subprogram\n+descriptor rather than the subprogram itself.\n+\n+The `'Code_Address` attribute, which can only be applied to\n+subprogram entities, always returns the address of the start of the\n+generated code of the specified subprogram, which may or may not be\n+the same value as is returned by the corresponding `'Address`\n+attribute.\n+\n+Attribute Compiler_Version\n+==========================\n+.. index:: Compiler_Version\n+\n+`Standard'Compiler_Version` (`Standard` is the only allowed\n+prefix) yields a static string identifying the version of the compiler\n+being used to compile the unit containing the attribute reference.\n+\n+Attribute Constrained\n+=====================\n+.. index:: Constrained\n+\n+In addition to the usage of this attribute in the Ada RM, `GNAT`\n+also permits the use of the `'Constrained` attribute\n+in a generic template\n+for any type, including types without discriminants. The value of this\n+attribute in the generic instance when applied to a scalar type or a\n+record type without discriminants is always `True`. This usage is\n+compatible with older Ada compilers, including notably DEC Ada.\n+\n+Attribute Default_Bit_Order\n+===========================\n+.. index:: Big endian\n+\n+.. index:: Little endian\n+\n+.. index:: Default_Bit_Order\n+\n+`Standard'Default_Bit_Order` (`Standard` is the only\n+permissible prefix), provides the value `System.Default_Bit_Order`\n+as a `Pos` value (0 for `High_Order_First`, 1 for\n+`Low_Order_First`).  This is used to construct the definition of\n+`Default_Bit_Order` in package `System`.\n+\n+Attribute Default_Scalar_Storage_Order\n+======================================\n+.. index:: Big endian\n+\n+.. index:: Little endian\n+\n+.. index:: Default_Scalar_Storage_Order\n+\n+`Standard'Default_Scalar_Storage_Order` (`Standard` is the only\n+permissible prefix), provides the current value of the default scalar storage\n+order (as specified using pragma `Default_Scalar_Storage_Order`, or\n+equal to `Default_Bit_Order` if unspecified) as a\n+`System.Bit_Order` value. This is a static attribute.\n+\n+Attribute Descriptor_Size\n+=========================\n+.. index:: Descriptor\n+\n+.. index:: Dope vector\n+\n+.. index:: Descriptor_Size\n+\n+Non-static attribute `Descriptor_Size` returns the size in bits of the\n+descriptor allocated for a type.  The result is non-zero only for unconstrained\n+array types and the returned value is of type universal integer.  In GNAT, an\n+array descriptor contains bounds information and is located immediately before\n+the first element of the array.\n+\n+.. code-block:: ada\n+\n+  type Unconstr_Array is array (Positive range <>) of Boolean;\n+  Put_Line (\"Descriptor size = \" & Unconstr_Array'Descriptor_Size'Img);\n+  \n+\n+The attribute takes into account any additional padding due to type alignment.\n+In the example above, the descriptor contains two values of type\n+`Positive` representing the low and high bound.  Since `Positive` has\n+a size of 31 bits and an alignment of 4, the descriptor size is `2 * Positive'Size + 2` or 64 bits.\n+\n+Attribute Elaborated\n+====================\n+.. index:: Elaborated\n+\n+The prefix of the `'Elaborated` attribute must be a unit name.  The\n+value is a Boolean which indicates whether or not the given unit has been\n+elaborated.  This attribute is primarily intended for internal use by the\n+generated code for dynamic elaboration checking, but it can also be used\n+in user programs.  The value will always be True once elaboration of all\n+units has been completed.  An exception is for units which need no\n+elaboration, the value is always False for such units.\n+\n+Attribute Elab_Body\n+===================\n+.. index:: Elab_Body\n+\n+This attribute can only be applied to a program unit name.  It returns\n+the entity for the corresponding elaboration procedure for elaborating\n+the body of the referenced unit.  This is used in the main generated\n+elaboration procedure by the binder and is not normally used in any\n+other context.  However, there may be specialized situations in which it\n+is useful to be able to call this elaboration procedure from Ada code,\n+e.g., if it is necessary to do selective re-elaboration to fix some\n+error.\n+\n+Attribute Elab_Spec\n+===================\n+.. index:: Elab_Spec\n+\n+This attribute can only be applied to a program unit name.  It returns\n+the entity for the corresponding elaboration procedure for elaborating\n+the spec of the referenced unit.  This is used in the main\n+generated elaboration procedure by the binder and is not normally used\n+in any other context.  However, there may be specialized situations in\n+which it is useful to be able to call this elaboration procedure from\n+Ada code, e.g., if it is necessary to do selective re-elaboration to fix\n+some error.\n+\n+Attribute Elab_Subp_Body\n+========================\n+.. index:: Elab_Subp_Body\n+\n+This attribute can only be applied to a library level subprogram\n+name and is only allowed in CodePeer mode. It returns the entity\n+for the corresponding elaboration procedure for elaborating the body\n+of the referenced subprogram unit. This is used in the main generated\n+elaboration procedure by the binder in CodePeer mode only and is unrecognized\n+otherwise.\n+\n+Attribute Emax\n+==============\n+.. index:: Ada 83 attributes\n+\n+.. index:: Emax\n+\n+The `Emax` attribute is provided for compatibility with Ada 83.  See\n+the Ada 83 reference manual for an exact description of the semantics of\n+this attribute.\n+\n+Attribute Enabled\n+=================\n+.. index:: Enabled\n+\n+The `Enabled` attribute allows an application program to check at compile\n+time to see if the designated check is currently enabled. The prefix is a\n+simple identifier, referencing any predefined check name (other than\n+`All_Checks`) or a check name introduced by pragma Check_Name. If\n+no argument is given for the attribute, the check is for the general state\n+of the check, if an argument is given, then it is an entity name, and the\n+check indicates whether an `Suppress` or `Unsuppress` has been\n+given naming the entity (if not, then the argument is ignored).\n+\n+Note that instantiations inherit the check status at the point of the\n+instantiation, so a useful idiom is to have a library package that\n+introduces a check name with `pragma Check_Name`, and then contains\n+generic packages or subprograms which use the `Enabled` attribute\n+to see if the check is enabled. A user of this package can then issue\n+a `pragma Suppress` or `pragma Unsuppress` before instantiating\n+the package or subprogram, controlling whether the check will be present.\n+\n+Attribute Enum_Rep\n+==================\n+.. index:: Representation of enums\n+\n+.. index:: Enum_Rep\n+\n+For every enumeration subtype `S`, ``S'Enum_Rep`` denotes a\n+function with the following spec:\n+\n+.. code-block:: ada\n+\n+  function S'Enum_Rep (Arg : S'Base) return <Universal_Integer>;\n+  \n+\n+It is also allowable to apply `Enum_Rep` directly to an object of an\n+enumeration type or to a non-overloaded enumeration\n+literal.  In this case ``S'Enum_Rep`` is equivalent to\n+``typ'Enum_Rep(S)`` where `typ` is the type of the\n+enumeration literal or object.\n+\n+The function returns the representation value for the given enumeration\n+value.  This will be equal to value of the `Pos` attribute in the\n+absence of an enumeration representation clause.  This is a static\n+attribute (i.e.,:the result is static if the argument is static).\n+\n+``S'Enum_Rep`` can also be used with integer types and objects,\n+in which case it simply returns the integer value.  The reason for this\n+is to allow it to be used for `(<>)` discrete formal arguments in\n+a generic unit that can be instantiated with either enumeration types\n+or integer types.  Note that if `Enum_Rep` is used on a modular\n+type whose upper bound exceeds the upper bound of the largest signed\n+integer type, and the argument is a variable, so that the universal\n+integer calculation is done at run time, then the call to `Enum_Rep`\n+may raise `Constraint_Error`.\n+\n+Attribute Enum_Val\n+==================\n+.. index:: Representation of enums\n+\n+.. index:: Enum_Val\n+\n+For every enumeration subtype `S`, ``S'Enum_Val`` denotes a\n+function with the following spec:\n+\n+.. code-block:: ada\n+\n+  function S'Enum_Val (Arg : <Universal_Integer>) return S'Base;\n+  \n+\n+The function returns the enumeration value whose representation matches the\n+argument, or raises Constraint_Error if no enumeration literal of the type\n+has the matching value.\n+This will be equal to value of the `Val` attribute in the\n+absence of an enumeration representation clause.  This is a static\n+attribute (i.e., the result is static if the argument is static).\n+\n+Attribute Epsilon\n+=================\n+.. index:: Ada 83 attributes\n+\n+.. index:: Epsilon\n+\n+The `Epsilon` attribute is provided for compatibility with Ada 83.  See\n+the Ada 83 reference manual for an exact description of the semantics of\n+this attribute.\n+\n+Attribute Fast_Math\n+===================\n+.. index:: Fast_Math\n+\n+`Standard'Fast_Math` (`Standard` is the only allowed\n+prefix) yields a static Boolean value that is True if pragma\n+`Fast_Math` is active, and False otherwise.\n+\n+Attribute Fixed_Value\n+=====================\n+.. index:: Fixed_Value\n+\n+For every fixed-point type `S`, ``S'Fixed_Value`` denotes a\n+function with the following specification:\n+\n+.. code-block:: ada\n+\n+  function S'Fixed_Value (Arg : <Universal_Integer>) return S;\n+  \n+The value returned is the fixed-point value `V` such that::\n+\n+  V = Arg * S'Small\n+  \n+\n+The effect is thus similar to first converting the argument to the\n+integer type used to represent `S`, and then doing an unchecked\n+conversion to the fixed-point type.  The difference is\n+that there are full range checks, to ensure that the result is in range.\n+This attribute is primarily intended for use in implementation of the\n+input-output functions for fixed-point values.\n+\n+Attribute From_Any\n+==================\n+.. index:: From_Any\n+\n+This internal attribute is used for the generation of remote subprogram\n+stubs in the context of the Distributed Systems Annex.\n+\n+Attribute Has_Access_Values\n+===========================\n+.. index:: Access values, testing for\n+\n+.. index:: Has_Access_Values\n+\n+The prefix of the `Has_Access_Values` attribute is a type.  The result\n+is a Boolean value which is True if the is an access type, or is a composite\n+type with a component (at any nesting depth) that is an access type, and is\n+False otherwise.\n+The intended use of this attribute is in conjunction with generic\n+definitions.  If the attribute is applied to a generic private type, it\n+indicates whether or not the corresponding actual type has access values.\n+\n+Attribute Has_Discriminants\n+===========================\n+.. index:: Discriminants, testing for\n+\n+.. index:: Has_Discriminants\n+\n+The prefix of the `Has_Discriminants` attribute is a type.  The result\n+is a Boolean value which is True if the type has discriminants, and False\n+otherwise.  The intended use of this attribute is in conjunction with generic\n+definitions.  If the attribute is applied to a generic private type, it\n+indicates whether or not the corresponding actual type has discriminants.\n+\n+Attribute Img\n+=============\n+.. index:: Img\n+\n+The `Img` attribute differs from `Image` in that it is applied\n+directly to an object, and yields the same result as\n+`Image` for the subtype of the object.  This is convenient for\n+debugging:\n+\n+.. code-block:: ada\n+\n+  Put_Line (\"X = \" & X'Img);\n+  \n+\n+has the same meaning as the more verbose:\n+\n+.. code-block:: ada\n+\n+  Put_Line (\"X = \" & T'Image (X));\n+  \n+where `T` is the (sub)type of the object `X`.\n+\n+Note that technically, in analogy to `Image`,\n+`X'Img` returns a parameterless function\n+that returns the appropriate string when called. This means that\n+`X'Img` can be renamed as a function-returning-string, or used\n+in an instantiation as a function parameter.\n+\n+Attribute Integer_Value\n+=======================\n+.. index:: Integer_Value\n+\n+For every integer type `S`, ``S'Integer_Value`` denotes a\n+function with the following spec:\n+\n+.. code-block:: ada\n+\n+  function S'Integer_Value (Arg : <Universal_Fixed>) return S;\n+\n+The value returned is the integer value `V`, such that::\n+\n+  Arg = V * T'Small\n+  \n+\n+where `T` is the type of `Arg`.\n+The effect is thus similar to first doing an unchecked conversion from\n+the fixed-point type to its corresponding implementation type, and then\n+converting the result to the target integer type.  The difference is\n+that there are full range checks, to ensure that the result is in range.\n+This attribute is primarily intended for use in implementation of the\n+standard input-output functions for fixed-point values.\n+\n+Attribute Invalid_Value\n+=======================\n+.. index:: Invalid_Value\n+\n+For every scalar type S, S'Invalid_Value returns an undefined value of the\n+type. If possible this value is an invalid representation for the type. The\n+value returned is identical to the value used to initialize an otherwise\n+uninitialized value of the type if pragma Initialize_Scalars is used,\n+including the ability to modify the value with the binder -Sxx flag and\n+relevant environment variables at run time.\n+\n+Attribute Iterable\n+==================\n+.. index:: Iterable\n+\n+Equivalent to Aspect Iterable.\n+\n+Attribute Large\n+===============\n+.. index:: Ada 83 attributes\n+\n+.. index:: Large\n+\n+The `Large` attribute is provided for compatibility with Ada 83.  See\n+the Ada 83 reference manual for an exact description of the semantics of\n+this attribute.\n+\n+Attribute Library_Level\n+=======================\n+.. index:: Library_Level\n+\n+`P'Library_Level`, where P is an entity name,\n+returns a Boolean value which is True if the entity is declared\n+at the library level, and False otherwise. Note that within a\n+generic instantition, the name of the generic unit denotes the\n+instance, which means that this attribute can be used to test\n+if a generic is instantiated at the library level, as shown\n+in this example:\n+\n+.. code-block:: ada\n+\n+  generic\n+    ...\n+  package Gen is\n+    pragma Compile_Time_Error\n+      (not Gen'Library_Level,\n+       \"Gen can only be instantiated at library level\");\n+    ...\n+  end Gen;\n+  \n+\n+Attribute Lock_Free\n+===================\n+.. index:: Lock_Free\n+\n+`P'Lock_Free`, where P is a protected object, returns True if a\n+pragma `Lock_Free` applies to P.\n+\n+Attribute Loop_Entry\n+====================\n+.. index:: Loop_Entry\n+\n+Syntax::\n+\n+  X'Loop_Entry [(loop_name)]\n+  \n+\n+The `Loop_Entry` attribute is used to refer to the value that an\n+expression had upon entry to a given loop in much the same way that the\n+`Old` attribute in a subprogram postcondition can be used to refer\n+to the value an expression had upon entry to the subprogram. The\n+relevant loop is either identified by the given loop name, or it is the\n+innermost enclosing loop when no loop name is given.\n+\n+A `Loop_Entry` attribute can only occur within a\n+`Loop_Variant` or `Loop_Invariant` pragma. A common use of\n+`Loop_Entry` is to compare the current value of objects with their\n+initial value at loop entry, in a `Loop_Invariant` pragma.\n+\n+The effect of using `X'Loop_Entry` is the same as declaring\n+a constant initialized with the initial value of `X` at loop\n+entry. This copy is not performed if the loop is not entered, or if the\n+corresponding pragmas are ignored or disabled.\n+\n+Attribute Machine_Size\n+======================\n+.. index:: Machine_Size\n+\n+This attribute is identical to the `Object_Size` attribute.  It is\n+provided for compatibility with the DEC Ada 83 attribute of this name.\n+\n+Attribute Mantissa\n+==================\n+.. index:: Ada 83 attributes\n+\n+.. index:: Mantissa\n+\n+The `Mantissa` attribute is provided for compatibility with Ada 83.  See\n+the Ada 83 reference manual for an exact description of the semantics of\n+this attribute.\n+\n+.. _Attribute_Maximum_Alignment:\n+\n+Attribute Maximum_Alignment\n+===========================\n+.. index:: Alignment, maximum\n+\n+.. index:: Maximum_Alignment\n+\n+`Standard'Maximum_Alignment` (`Standard` is the only\n+permissible prefix) provides the maximum useful alignment value for the\n+target.  This is a static value that can be used to specify the alignment\n+for an object, guaranteeing that it is properly aligned in all\n+cases.\n+\n+Attribute Mechanism_Code\n+========================\n+.. index:: Return values, passing mechanism\n+\n+.. index:: Parameters, passing mechanism\n+\n+.. index:: Mechanism_Code\n+\n+``function'Mechanism_Code`` yields an integer code for the\n+mechanism used for the result of function, and\n+``subprogram'Mechanism_Code (n)`` yields the mechanism\n+used for formal parameter number `n` (a static integer value with 1\n+meaning the first parameter) of `subprogram`.  The code returned is:\n+\n+\n+\n+*1*\n+  by copy (value)\n+\n+*2*\n+  by reference\n+\n+Attribute Null_Parameter\n+========================\n+.. index:: Zero address, passing\n+\n+.. index:: Null_Parameter\n+\n+A reference ``T'Null_Parameter`` denotes an imaginary object of\n+type or subtype `T` allocated at machine address zero.  The attribute\n+is allowed only as the default expression of a formal parameter, or as\n+an actual expression of a subprogram call.  In either case, the\n+subprogram must be imported.\n+\n+The identity of the object is represented by the address zero in the\n+argument list, independent of the passing mechanism (explicit or\n+default).\n+\n+This capability is needed to specify that a zero address should be\n+passed for a record or other composite object passed by reference.\n+There is no way of indicating this without the `Null_Parameter`\n+attribute.\n+\n+Attribute Object_Size\n+=====================\n+.. index:: Size, used for objects\n+\n+.. index:: Object_Size\n+\n+The size of an object is not necessarily the same as the size of the type\n+of an object.  This is because by default object sizes are increased to be\n+a multiple of the alignment of the object.  For example,\n+`Natural'Size` is\n+31, but by default objects of type `Natural` will have a size of 32 bits.\n+Similarly, a record containing an integer and a character:\n+\n+.. code-block:: ada\n+\n+  type Rec is record\n+     I : Integer;\n+     C : Character;\n+  end record;\n+  \n+\n+will have a size of 40 (that is `Rec'Size` will be 40).  The\n+alignment will be 4, because of the\n+integer field, and so the default size of record objects for this type\n+will be 64 (8 bytes).\n+\n+If the alignment of the above record is specified to be 1, then the\n+object size will be 40 (5 bytes). This is true by default, and also\n+an object size of 40 can be explicitly specified in this case.\n+\n+A consequence of this capability is that different object sizes can be\n+given to subtypes that would otherwise be considered in Ada to be\n+statically matching.  But it makes no sense to consider such subtypes\n+as statically matching.  Consequently, in `GNAT` we add a rule\n+to the static matching rules that requires object sizes to match.\n+Consider this example:\n+\n+.. code-block:: ada\n+\n+   1. procedure BadAVConvert is\n+   2.    type R is new Integer;\n+   3.    subtype R1 is R range 1 .. 10;\n+   4.    subtype R2 is R range 1 .. 10;\n+   5.    for R1'Object_Size use 8;\n+   6.    for R2'Object_Size use 16;\n+   7.    type R1P is access all R1;\n+   8.    type R2P is access all R2;\n+   9.    R1PV : R1P := new R1'(4);\n+  10.    R2PV : R2P;\n+  11. begin\n+  12.    R2PV := R2P (R1PV);\n+                 |\n+         >>> target designated subtype not compatible with\n+             type \"R1\" defined at line 3\n+\n+  13. end;\n+  \n+\n+In the absence of lines 5 and 6,\n+types `R1` and `R2` statically match and\n+hence the conversion on line 12 is legal. But since lines 5 and 6\n+cause the object sizes to differ, `GNAT` considers that types\n+`R1` and `R2` are not statically matching, and line 12\n+generates the diagnostic shown above.\n+\n+Similar additional checks are performed in other contexts requiring\n+statically matching subtypes.\n+\n+Attribute Old\n+=============\n+.. index:: Old\n+\n+In addition to the usage of `Old` defined in the Ada 2012 RM (usage\n+within `Post` aspect), GNAT also permits the use of this attribute\n+in implementation defined pragmas `Postcondition`,\n+`Contract_Cases` and `Test_Case`. Also usages of\n+`Old` which would be illegal according to the Ada 2012 RM\n+definition are allowed under control of\n+implementation defined pragma `Unevaluated_Use_Of_Old`.\n+\n+Attribute Passed_By_Reference\n+=============================\n+.. index:: Parameters, when passed by reference\n+\n+.. index:: Passed_By_Reference\n+\n+``type'Passed_By_Reference`` for any subtype `type` returns\n+a value of type `Boolean` value that is `True` if the type is\n+normally passed by reference and `False` if the type is normally\n+passed by copy in calls.  For scalar types, the result is always `False`\n+and is static.  For non-scalar types, the result is non-static.\n+\n+Attribute Pool_Address\n+======================\n+.. index:: Parameters, when passed by reference\n+\n+.. index:: Pool_Address\n+\n+``X'Pool_Address`` for any object `X` returns the address\n+of X within its storage pool. This is the same as\n+``X'Address``, except that for an unconstrained array whose\n+bounds are allocated just before the first component,\n+``X'Pool_Address`` returns the address of those bounds,\n+whereas ``X'Address`` returns the address of the first\n+component.\n+\n+Here, we are interpreting 'storage pool' broadly to mean \n+``wherever the object is allocated``, which could be a \n+user-defined storage pool,\n+the global heap, on the stack, or in a static memory area.\n+For an object created by `new`, ``Ptr.all'Pool_Address`` is\n+what is passed to `Allocate` and returned from `Deallocate`.\n+\n+Attribute Range_Length\n+======================\n+.. index:: Range_Length\n+\n+``type'Range_Length`` for any discrete type `type` yields\n+the number of values represented by the subtype (zero for a null\n+range).  The result is static for static subtypes.  `Range_Length`\n+applied to the index subtype of a one dimensional array always gives the\n+same result as `Length` applied to the array itself.\n+\n+Attribute Ref\n+=============\n+.. index:: Ref\n+\n+Attribute Restriction_Set\n+=========================\n+.. index:: Restriction_Set\n+.. index:: Restrictions\n+\n+This attribute allows compile time testing of restrictions that\n+are currently in effect. It is primarily intended for specializing\n+code in the run-time based on restrictions that are active (e.g.\n+don't need to save fpt registers if restriction No_Floating_Point\n+is known to be in effect), but can be used anywhere.\n+\n+There are two forms:\n+\n+.. code-block:: ada\n+\n+  System'Restriction_Set (partition_boolean_restriction_NAME)\n+  System'Restriction_Set (No_Dependence => library_unit_NAME);\n+  \n+\n+In the case of the first form, the only restriction names\n+allowed are parameterless restrictions that are checked\n+for consistency at bind time. For a complete list see the\n+subtype `System.Rident.Partition_Boolean_Restrictions`.\n+\n+The result returned is True if the restriction is known to\n+be in effect, and False if the restriction is known not to\n+be in effect. An important guarantee is that the value of\n+a Restriction_Set attribute is known to be consistent throughout\n+all the code of a partition.\n+\n+This is trivially achieved if the entire partition is compiled\n+with a consistent set of restriction pragmas. However, the\n+compilation model does not require this. It is possible to\n+compile one set of units with one set of pragmas, and another\n+set of units with another set of pragmas. It is even possible\n+to compile a spec with one set of pragmas, and then WITH the\n+same spec with a different set of pragmas. Inconsistencies\n+in the actual use of the restriction are checked at bind time.\n+\n+In order to achieve the guarantee of consistency for the\n+Restriction_Set pragma, we consider that a use of the pragma\n+that yields False is equivalent to a violation of the\n+restriction.\n+\n+So for example if you write\n+\n+.. code-block:: ada\n+\n+  if System'Restriction_Set (No_Floating_Point) then\n+     ...\n+  else\n+     ...\n+  end if;\n+  \n+\n+And the result is False, so that the else branch is executed,\n+you can assume that this restriction is not set for any unit\n+in the partition. This is checked by considering this use of\n+the restriction pragma to be a violation of the restriction\n+No_Floating_Point. This means that no other unit can attempt\n+to set this restriction (if some unit does attempt to set it,\n+the binder will refuse to bind the partition).\n+\n+Technical note: The restriction name and the unit name are\n+intepreted entirely syntactically, as in the corresponding\n+Restrictions pragma, they are not analyzed semantically,\n+so they do not have a type.\n+\n+Attribute Result\n+================\n+.. index:: Result\n+\n+``function'Result`` can only be used with in a Postcondition pragma\n+for a function. The prefix must be the name of the corresponding function. This\n+is used to refer to the result of the function in the postcondition expression.\n+For a further discussion of the use of this attribute and examples of its use,\n+see the description of pragma Postcondition.\n+\n+Attribute Safe_Emax\n+===================\n+.. index:: Ada 83 attributes\n+\n+.. index:: Safe_Emax\n+\n+The `Safe_Emax` attribute is provided for compatibility with Ada 83.  See\n+the Ada 83 reference manual for an exact description of the semantics of\n+this attribute.\n+\n+Attribute Safe_Large\n+====================\n+.. index:: Ada 83 attributes\n+\n+.. index:: Safe_Large\n+\n+The `Safe_Large` attribute is provided for compatibility with Ada 83.  See\n+the Ada 83 reference manual for an exact description of the semantics of\n+this attribute.\n+\n+Attribute Safe_Small\n+====================\n+.. index:: Ada 83 attributes\n+\n+.. index:: Safe_Small\n+\n+The `Safe_Small` attribute is provided for compatibility with Ada 83.  See\n+the Ada 83 reference manual for an exact description of the semantics of\n+this attribute.\n+\n+Attribute Scalar_Storage_Order\n+==============================\n+.. index:: Endianness\n+\n+.. index:: Scalar storage order\n+\n+.. index:: Scalar_Storage_Order\n+\n+For every array or record type `S`, the representation attribute\n+`Scalar_Storage_Order` denotes the order in which storage elements\n+that make up scalar components are ordered within S. The value given must\n+be a static expression of type System.Bit_Order. The following is an example\n+of the use of this feature:\n+\n+.. code-block:: ada\n+\n+     --  Component type definitions\n+\n+     subtype Yr_Type is Natural range 0 .. 127;\n+     subtype Mo_Type is Natural range 1 .. 12;\n+     subtype Da_Type is Natural range 1 .. 31;\n+\n+     --  Record declaration\n+\n+     type Date is record\n+        Years_Since_1980 : Yr_Type;\n+        Month            : Mo_Type;\n+        Day_Of_Month     : Da_Type;\n+     end record;\n+\n+     --  Record representation clause\n+\n+     for Date use record\n+        Years_Since_1980 at 0 range 0  ..  6;\n+        Month            at 0 range 7  .. 10;\n+        Day_Of_Month     at 0 range 11 .. 15;\n+     end record;\n+\n+     --  Attribute definition clauses\n+\n+     for Date'Bit_Order use System.High_Order_First;\n+     for Date'Scalar_Storage_Order use System.High_Order_First;\n+     --  If Scalar_Storage_Order is specified, it must be consistent with\n+     --  Bit_Order, so it's best to always define the latter explicitly if\n+     --  the former is used.\n+  \n+\n+Other properties are as for standard representation attribute `Bit_Order`,\n+as defined by Ada RM 13.5.3(4). The default is `System.Default_Bit_Order`.\n+\n+For a record type `T`, if ``T'Scalar_Storage_Order`` is\n+specified explicitly, it shall be equal to ``T'Bit_Order``. Note:\n+this means that if a `Scalar_Storage_Order` attribute definition\n+clause is not confirming, then the type's `Bit_Order` shall be\n+specified explicitly and set to the same value.\n+\n+Derived types inherit an explicitly set scalar storage order from their parent\n+types. This may be overridden for the derived type by giving an explicit scalar\n+storage order for the derived type. For a record extension, the derived type\n+must have the same scalar storage order as the parent type.\n+\n+If a component of `T` is of a record or array type, then that type must\n+also have a `Scalar_Storage_Order` attribute definition clause.\n+\n+A component of a record or array type that is a packed array, or that\n+does not start on a byte boundary, must have the same scalar storage order\n+as the enclosing record or array type.\n+\n+No component of a type that has an explicit `Scalar_Storage_Order`\n+attribute definition may be aliased.\n+\n+A confirming `Scalar_Storage_Order` attribute definition clause (i.e.\n+with a value equal to `System.Default_Bit_Order`) has no effect.\n+\n+If the opposite storage order is specified, then whenever the value of\n+a scalar component of an object of type `S` is read, the storage\n+elements of the enclosing machine scalar are first reversed (before\n+retrieving the component value, possibly applying some shift and mask\n+operatings on the enclosing machine scalar), and the opposite operation\n+is done for writes.\n+\n+In that case, the restrictions set forth in 13.5.1(10.3/2) for scalar components\n+are relaxed. Instead, the following rules apply:\n+\n+* the underlying storage elements are those at positions\n+  `(position + first_bit / storage_element_size) ..         (position + (last_bit + storage_element_size - 1) /                     storage_element_size)`\n+* the sequence of underlying storage elements shall have\n+  a size no greater than the largest machine scalar\n+* the enclosing machine scalar is defined as the smallest machine\n+  scalar starting at a position no greater than\n+  `position + first_bit / storage_element_size` and covering\n+  storage elements at least up to `position + (last_bit +         storage_element_size - 1) / storage_element_size`\n+* the position of the component is interpreted relative to that machine\n+  scalar.\n+\n+If no scalar storage order is specified for a type (either directly, or by\n+inheritance in the case of a derived type), then the default is normally\n+the native ordering of the target, but this default can be overridden using\n+pragma `Default_Scalar_Storage_Order`.\n+\n+Note that the scalar storage order only affects the in-memory data\n+representation. It has no effect on the representation used by stream\n+attributes.\n+\n+.. _Attribute_Simple_Storage_Pool:\n+\n+Attribute Simple_Storage_Pool\n+=============================\n+.. index:: Storage pool, simple\n+\n+.. index:: Simple storage pool\n+\n+.. index:: Simple_Storage_Pool\n+\n+For every nonformal, nonderived access-to-object type `Acc`, the\n+representation attribute `Simple_Storage_Pool` may be specified\n+via an attribute_definition_clause (or by specifying the equivalent aspect):\n+\n+.. code-block:: ada\n+\n+  My_Pool : My_Simple_Storage_Pool_Type;\n+\n+  type Acc is access My_Data_Type;\n+\n+  for Acc'Simple_Storage_Pool use My_Pool;\n+\n+  \n+\n+The name given in an attribute_definition_clause for the\n+`Simple_Storage_Pool` attribute shall denote a variable of\n+a 'simple storage pool type' (see pragma `Simple_Storage_Pool_Type`).\n+\n+The use of this attribute is only allowed for a prefix denoting a type\n+for which it has been specified. The type of the attribute is the type\n+of the variable specified as the simple storage pool of the access type,\n+and the attribute denotes that variable.\n+\n+It is illegal to specify both `Storage_Pool` and `Simple_Storage_Pool`\n+for the same access type.\n+\n+If the `Simple_Storage_Pool` attribute has been specified for an access\n+type, then applying the `Storage_Pool` attribute to the type is flagged\n+with a warning and its evaluation raises the exception `Program_Error`.\n+\n+If the Simple_Storage_Pool attribute has been specified for an access\n+type `S`, then the evaluation of the attribute ``S'Storage_Size``\n+returns the result of calling ``Storage_Size (S'Simple_Storage_Pool)``,\n+which is intended to indicate the number of storage elements reserved for\n+the simple storage pool. If the Storage_Size function has not been defined\n+for the simple storage pool type, then this attribute returns zero.\n+\n+If an access type `S` has a specified simple storage pool of type\n+`SSP`, then the evaluation of an allocator for that access type calls\n+the primitive `Allocate` procedure for type `SSP`, passing\n+``S'Simple_Storage_Pool`` as the pool parameter. The detailed\n+semantics of such allocators is the same as those defined for allocators\n+in section 13.11 of the :title:`Ada Reference Manual`, with the term\n+`simple storage pool` substituted for `storage pool`.\n+\n+If an access type `S` has a specified simple storage pool of type\n+`SSP`, then a call to an instance of the `Ada.Unchecked_Deallocation`\n+for that access type invokes the primitive `Deallocate` procedure\n+for type `SSP`, passing ``S'Simple_Storage_Pool`` as the pool\n+parameter. The detailed semantics of such unchecked deallocations is the same\n+as defined in section 13.11.2 of the Ada Reference Manual, except that the\n+term 'simple storage pool' is substituted for 'storage pool'.\n+\n+Attribute Small\n+===============\n+.. index:: Ada 83 attributes\n+\n+.. index:: Small\n+\n+The `Small` attribute is defined in Ada 95 (and Ada 2005) only for\n+fixed-point types.\n+GNAT also allows this attribute to be applied to floating-point types\n+for compatibility with Ada 83.  See\n+the Ada 83 reference manual for an exact description of the semantics of\n+this attribute when applied to floating-point types.\n+\n+Attribute Storage_Unit\n+======================\n+.. index:: Storage_Unit\n+\n+`Standard'Storage_Unit` (`Standard` is the only permissible\n+prefix) provides the same value as `System.Storage_Unit`.\n+\n+Attribute Stub_Type\n+===================\n+.. index:: Stub_Type\n+\n+The GNAT implementation of remote access-to-classwide types is\n+organized as described in AARM section E.4 (20.t): a value of an RACW type\n+(designating a remote object) is represented as a normal access\n+value, pointing to a \"stub\" object which in turn contains the\n+necessary information to contact the designated remote object. A\n+call on any dispatching operation of such a stub object does the\n+remote call, if necessary, using the information in the stub object\n+to locate the target partition, etc.\n+\n+For a prefix `T` that denotes a remote access-to-classwide type,\n+`T'Stub_Type` denotes the type of the corresponding stub objects.\n+\n+By construction, the layout of `T'Stub_Type` is identical to that of\n+type `RACW_Stub_Type` declared in the internal implementation-defined\n+unit `System.Partition_Interface`. Use of this attribute will create\n+an implicit dependency on this unit.\n+\n+Attribute System_Allocator_Alignment\n+====================================\n+.. index:: Alignment, allocator\n+\n+.. index:: System_Allocator_Alignment\n+\n+`Standard'System_Allocator_Alignment` (`Standard` is the only\n+permissible prefix) provides the observable guaranted to be honored by\n+the system allocator (malloc). This is a static value that can be used\n+in user storage pools based on malloc either to reject allocation\n+with alignment too large or to enable a realignment circuitry if the\n+alignment request is larger than this value.\n+\n+Attribute Target_Name\n+=====================\n+.. index:: Target_Name\n+\n+`Standard'Target_Name` (`Standard` is the only permissible\n+prefix) provides a static string value that identifies the target\n+for the current compilation. For GCC implementations, this is the\n+standard gcc target name without the terminating slash (for\n+example, GNAT 5.0 on windows yields \"i586-pc-mingw32msv\").\n+\n+Attribute To_Address\n+====================\n+.. index:: To_Address\n+\n+The `System'To_Address`\n+(`System` is the only permissible prefix)\n+denotes a function identical to\n+`System.Storage_Elements.To_Address` except that\n+it is a static attribute.  This means that if its argument is\n+a static expression, then the result of the attribute is a\n+static expression.  This means that such an expression can be\n+used in contexts (e.g., preelaborable packages) which require a\n+static expression and where the function call could not be used\n+(since the function call is always non-static, even if its\n+argument is static). The argument must be in the range\n+-(2**(m-1) .. 2**m-1, where m is the memory size\n+(typically 32 or 64). Negative values are intepreted in a\n+modular manner (e.g., -1 means the same as 16#FFFF_FFFF# on\n+a 32 bits machine).\n+\n+Attribute To_Any\n+================\n+.. index:: To_Any\n+\n+This internal attribute is used for the generation of remote subprogram\n+stubs in the context of the Distributed Systems Annex.\n+\n+Attribute Type_Class\n+====================\n+.. index:: Type_Class\n+\n+``type'Type_Class`` for any type or subtype `type` yields\n+the value of the type class for the full type of `type`.  If\n+`type` is a generic formal type, the value is the value for the\n+corresponding actual subtype.  The value of this attribute is of type\n+``System.Aux_DEC.Type_Class``, which has the following definition:\n+\n+.. code-block:: ada\n+\n+  type Type_Class is\n+    (Type_Class_Enumeration,\n+     Type_Class_Integer,\n+     Type_Class_Fixed_Point,\n+     Type_Class_Floating_Point,\n+     Type_Class_Array,\n+     Type_Class_Record,\n+     Type_Class_Access,\n+     Type_Class_Task,\n+     Type_Class_Address);\n+  \n+\n+Protected types yield the value `Type_Class_Task`, which thus\n+applies to all concurrent types.  This attribute is designed to\n+be compatible with the DEC Ada 83 attribute of the same name.\n+\n+Attribute Type_Key\n+==================\n+.. index:: Type_Key\n+\n+The `Type_Key` attribute is applicable to a type or subtype and\n+yields a value of type Standard.String containing encoded information\n+about the type or subtype. This provides improved compatibility with\n+other implementations that support this attribute.\n+\n+Attribute TypeCode\n+==================\n+.. index:: TypeCode\n+\n+This internal attribute is used for the generation of remote subprogram\n+stubs in the context of the Distributed Systems Annex.\n+\n+Attribute UET_Address\n+=====================\n+.. index:: UET_Address\n+\n+The `UET_Address` attribute can only be used for a prefix which\n+denotes a library package.  It yields the address of the unit exception\n+table when zero cost exception handling is used.  This attribute is\n+intended only for use within the GNAT implementation.  See the unit\n+`Ada.Exceptions` in files :file:`a-except.ads` and :file:`a-except.adb`\n+for details on how this attribute is used in the implementation.\n+\n+Attribute Unconstrained_Array\n+=============================\n+.. index:: Unconstrained_Array\n+\n+The `Unconstrained_Array` attribute can be used with a prefix that\n+denotes any type or subtype. It is a static attribute that yields\n+`True` if the prefix designates an unconstrained array,\n+and `False` otherwise. In a generic instance, the result is\n+still static, and yields the result of applying this test to the\n+generic actual.\n+\n+Attribute Universal_Literal_String\n+==================================\n+.. index:: Named numbers, representation of\n+\n+.. index:: Universal_Literal_String\n+\n+The prefix of `Universal_Literal_String` must be a named\n+number.  The static result is the string consisting of the characters of\n+the number as defined in the original source.  This allows the user\n+program to access the actual text of named numbers without intermediate\n+conversions and without the need to enclose the strings in quotes (which\n+would preclude their use as numbers).\n+\n+For example, the following program prints the first 50 digits of pi:\n+\n+.. code-block:: ada\n+\n+  with Text_IO; use Text_IO;\n+  with Ada.Numerics;\n+  procedure Pi is\n+  begin\n+     Put (Ada.Numerics.Pi'Universal_Literal_String);\n+  end;\n+  \n+\n+Attribute Unrestricted_Access\n+=============================\n+.. index:: Access, unrestricted\n+\n+.. index:: Unrestricted_Access\n+\n+The `Unrestricted_Access` attribute is similar to `Access`\n+except that all accessibility and aliased view checks are omitted.  This\n+is a user-beware attribute.\n+\n+For objects, it is similar to `Address`, for which it is a\n+desirable replacement where the value desired is an access type.\n+In other words, its effect is similar to first applying the\n+`Address` attribute and then doing an unchecked conversion to a\n+desired access type.\n+\n+For subprograms, `P'Unrestricted_Access` may be used where\n+`P'Access` would be illegal, to construct a value of a\n+less-nested named access type that designates a more-nested\n+subprogram. This value may be used in indirect calls, so long as the\n+more-nested subprogram still exists; once the subprogram containing it\n+has returned, such calls are erroneous. For example:\n+\n+.. code-block:: ada\n+\n+  package body P is\n+\n+     type Less_Nested is not null access procedure;\n+     Global : Less_Nested;\n+\n+     procedure P1 is\n+     begin\n+        Global.all;\n+     end P1;\n+\n+     procedure P2 is\n+        Local_Var : Integer;\n+\n+        procedure More_Nested is\n+        begin\n+           ... Local_Var ...\n+        end More_Nested;\n+     begin\n+        Global := More_Nested'Unrestricted_Access;\n+        P1;\n+     end P2;\n+\n+  end P;\n+  \n+\n+When P1 is called from P2, the call via Global is OK, but if P1 were\n+called after P2 returns, it would be an erroneous use of a dangling\n+pointer.\n+\n+For objects, it is possible to use `Unrestricted_Access` for any\n+type. However, if the result is of an access-to-unconstrained array\n+subtype, then the resulting pointer has the same scope as the context\n+of the attribute, and must not be returned to some enclosing scope.\n+For instance, if a function uses `Unrestricted_Access` to create\n+an access-to-unconstrained-array and returns that value to the caller,\n+the result will involve dangling pointers. In addition, it is only\n+valid to create pointers to unconstrained arrays using this attribute\n+if the pointer has the normal default 'fat' representation where a\n+pointer has two components, one points to the array and one points to\n+the bounds. If a size clause is used to force 'thin' representation\n+for a pointer to unconstrained where there is only space for a single\n+pointer, then the resulting pointer is not usable.\n+\n+In the simple case where a direct use of Unrestricted_Access attempts\n+to make a thin pointer for a non-aliased object, the compiler will\n+reject the use as illegal, as shown in the following example:\n+\n+.. code-block:: ada\n+\n+  with System; use System;\n+  procedure SliceUA2 is\n+     type A is access all String;\n+     for A'Size use Standard'Address_Size;\n+\n+     procedure P (Arg : A) is\n+     begin\n+        null;\n+     end P;\n+\n+     X : String := \"hello world!\";\n+     X2 : aliased String := \"hello world!\";\n+\n+     AV : A := X'Unrestricted_Access;    -- ERROR\n+               |\n+  >>> illegal use of Unrestricted_Access attribute\n+  >>> attempt to generate thin pointer to unaliased object\n+\n+  begin\n+     P (X'Unrestricted_Access);          -- ERROR\n+        |\n+  >>> illegal use of Unrestricted_Access attribute\n+  >>> attempt to generate thin pointer to unaliased object\n+\n+     P (X(7 .. 12)'Unrestricted_Access); -- ERROR\n+        |\n+  >>> illegal use of Unrestricted_Access attribute\n+  >>> attempt to generate thin pointer to unaliased object\n+\n+     P (X2'Unrestricted_Access);         -- OK\n+  end;\n+  \n+\n+but other cases cannot be detected by the compiler, and are\n+considered to be erroneous. Consider the following example:\n+\n+.. code-block:: ada\n+\n+  with System; use System;\n+  with System; use System;\n+  procedure SliceUA is\n+     type AF is access all String;\n+\n+     type A is access all String;\n+     for A'Size use Standard'Address_Size;\n+\n+     procedure P (Arg : A) is\n+     begin\n+        if Arg'Length /= 6 then\n+           raise Program_Error;\n+        end if;\n+     end P;\n+\n+     X : String := \"hello world!\";\n+     Y : AF := X (7 .. 12)'Unrestricted_Access;\n+\n+  begin\n+     P (A (Y));\n+  end;\n+  \n+\n+A normal unconstrained array value\n+or a constrained array object marked as aliased has the bounds in memory\n+just before the array, so a thin pointer can retrieve both the data and\n+the bounds.  But in this case, the non-aliased object `X` does not have the\n+bounds before the string.  If the size clause for type `A`\n+were not present, then the pointer\n+would be a fat pointer, where one component is a pointer to the bounds,\n+and all would be well.  But with the size clause present, the conversion from\n+fat pointer to thin pointer in the call loses the bounds, and so this\n+is erroneous, and the program likely raises a `Program_Error` exception.\n+\n+In general, it is advisable to completely\n+avoid mixing the use of thin pointers and the use of\n+`Unrestricted_Access` where the designated type is an\n+unconstrained array.  The use of thin pointers should be restricted to\n+cases of porting legacy code that implicitly assumes the size of pointers,\n+and such code should not in any case be using this attribute.\n+\n+Another erroneous situation arises if the attribute is\n+applied to a constant. The resulting pointer can be used to access the\n+constant, but the effect of trying to modify a constant in this manner\n+is not well-defined. Consider this example:\n+\n+.. code-block:: ada\n+\n+  P : constant Integer := 4;\n+  type R is access all Integer;\n+  RV : R := P'Unrestricted_Access;\n+  ..\n+  RV.all := 3;\n+  \n+\n+Here we attempt to modify the constant P from 4 to 3, but the compiler may\n+or may not notice this attempt, and subsequent references to P may yield\n+either the value 3 or the value 4 or the assignment may blow up if the\n+compiler decides to put P in read-only memory. One particular case where\n+`Unrestricted_Access` can be used in this way is to modify the\n+value of an `IN` parameter:\n+\n+.. code-block:: ada\n+\n+  procedure K (S : in String) is\n+     type R is access all Character;\n+     RV : R := S (3)'Unrestricted_Access;\n+  begin\n+     RV.all := 'a';\n+  end;\n+  \n+\n+In general this is a risky approach. It may appear to \"work\" but such uses of\n+`Unrestricted_Access` are potentially non-portable, even from one version\n+of `GNAT` to another, so are best avoided if possible.\n+\n+Attribute Update\n+================\n+.. index:: Update\n+\n+The `Update` attribute creates a copy of an array or record value\n+with one or more modified components. The syntax is::\n+\n+  PREFIX'Update ( RECORD_COMPONENT_ASSOCIATION_LIST )\n+  PREFIX'Update ( ARRAY_COMPONENT_ASSOCIATION {, ARRAY_COMPONENT_ASSOCIATION } )\n+  PREFIX'Update ( MULTIDIMENSIONAL_ARRAY_COMPONENT_ASSOCIATION\n+                  {, MULTIDIMENSIONAL_ARRAY_COMPONENT_ASSOCIATION } )\n+\n+  MULTIDIMENSIONAL_ARRAY_COMPONENT_ASSOCIATION ::= INDEX_EXPRESSION_LIST_LIST => EXPRESSION\n+  INDEX_EXPRESSION_LIST_LIST                   ::= INDEX_EXPRESSION_LIST {| INDEX_EXPRESSION_LIST }\n+  INDEX_EXPRESSION_LIST                        ::= ( EXPRESSION {, EXPRESSION } )\n+  \n+\n+where `PREFIX` is the name of an array or record object, the\n+association list in parentheses does not contain an `others`\n+choice and the box symbol `<>` may not appear in any\n+expression. The effect is to yield a copy of the array or record value\n+which is unchanged apart from the components mentioned in the\n+association list, which are changed to the indicated value. The\n+original value of the array or record value is not affected. For\n+example:\n+\n+.. code-block:: ada\n+\n+  type Arr is Array (1 .. 5) of Integer;\n+  ...\n+  Avar1 : Arr := (1,2,3,4,5);\n+  Avar2 : Arr := Avar1'Update (2 => 10, 3 .. 4 => 20);\n+  \n+\n+yields a value for `Avar2` of 1,10,20,20,5 with `Avar1`\n+begin unmodified. Similarly:\n+\n+.. code-block:: ada\n+\n+  type Rec is A, B, C : Integer;\n+  ...\n+  Rvar1 : Rec := (A => 1, B => 2, C => 3);\n+  Rvar2 : Rec := Rvar1'Update (B => 20);\n+  \n+\n+yields a value for `Rvar2` of (A => 1, B => 20, C => 3),\n+with `Rvar1` being unmodifed.\n+Note that the value of the attribute reference is computed\n+completely before it is used. This means that if you write:\n+\n+.. code-block:: ada\n+\n+  Avar1 := Avar1'Update (1 => 10, 2 => Function_Call);\n+  \n+\n+then the value of `Avar1` is not modified if `Function_Call`\n+raises an exception, unlike the effect of a series of direct assignments\n+to elements of `Avar1`. In general this requires that\n+two extra complete copies of the object are required, which should be\n+kept in mind when considering efficiency.\n+\n+The `Update` attribute cannot be applied to prefixes of a limited\n+type, and cannot reference discriminants in the case of a record type.\n+The accessibility level of an Update attribute result object is defined\n+as for an aggregate.\n+\n+In the record case, no component can be mentioned more than once. In\n+the array case, two overlapping ranges can appear in the association list,\n+in which case the modifications are processed left to right.\n+\n+Multi-dimensional arrays can be modified, as shown by this example:\n+\n+.. code-block:: ada\n+\n+  A : array (1 .. 10, 1 .. 10) of Integer;\n+  ..\n+  A := A'Update ((1, 2) => 20, (3, 4) => 30);\n+  \n+\n+which changes element (1,2) to 20 and (3,4) to 30.\n+\n+Attribute Valid_Scalars\n+=======================\n+.. index:: Valid_Scalars\n+\n+The `'Valid_Scalars` attribute is intended to make it easier to\n+check the validity of scalar subcomponents of composite objects. It\n+is defined for any prefix `X` that denotes an object.\n+The value of this attribute is of the predefined type Boolean.\n+`X'Valid_Scalars` yields True if and only if evaluation of\n+`P'Valid` yields True for every scalar part P of X or if X has\n+no scalar parts. It is not specified in what order the scalar parts\n+are checked, nor whether any more are checked after any one of them\n+is determined to be invalid. If the prefix `X` is of a class-wide\n+type `T'Class` (where `T` is the associated specific type),\n+or if the prefix `X` is of a specific tagged type `T`, then\n+only the scalar parts of components of `T` are traversed; in other\n+words, components of extensions of `T` are not traversed even if\n+`T'Class (X)'Tag /= T'Tag` . The compiler will issue a warning if it can\n+be determined at compile time that the prefix of the attribute has no\n+scalar parts (e.g., if the prefix is of an access type, an interface type,\n+an undiscriminated task type, or an undiscriminated protected type).\n+\n+For scalar types, `Valid_Scalars` is equivalent to `Valid`. The use\n+of this attribute is not permitted for `Unchecked_Union` types for which\n+in general it is not possible to determine the values of the discriminants.\n+\n+Note: `Valid_Scalars` can generate a lot of code, especially in the case\n+of a large variant record. If the attribute is called in many places in the\n+same program applied to objects of the same type, it can reduce program size\n+to write a function with a single use of the attribute, and then call that\n+function from multiple places.\n+\n+Attribute VADS_Size\n+===================\n+.. index:: Size, VADS compatibility\n+\n+.. index:: VADS_Size\n+\n+The `'VADS_Size` attribute is intended to make it easier to port\n+legacy code which relies on the semantics of `'Size` as implemented\n+by the VADS Ada 83 compiler.  GNAT makes a best effort at duplicating the\n+same semantic interpretation.  In particular, `'VADS_Size` applied\n+to a predefined or other primitive type with no Size clause yields the\n+Object_Size (for example, `Natural'Size` is 32 rather than 31 on\n+typical machines).  In addition `'VADS_Size` applied to an object\n+gives the result that would be obtained by applying the attribute to\n+the corresponding type.\n+\n+Attribute Value_Size\n+====================\n+.. index:: Size, setting for not-first subtype\n+\n+.. index:: Value_Size\n+\n+``type'Value_Size`` is the number of bits required to represent\n+a value of the given subtype.  It is the same as ``type'Size``,\n+but, unlike `Size`, may be set for non-first subtypes.\n+\n+Attribute Wchar_T_Size\n+======================\n+.. index:: Wchar_T_Size\n+\n+`Standard'Wchar_T_Size` (`Standard` is the only permissible\n+prefix) provides the size in bits of the C `wchar_t` type\n+primarily for constructing the definition of this type in\n+package `Interfaces.C`. The result is a static constant.\n+\n+Attribute Word_Size\n+===================\n+.. index:: Word_Size\n+\n+`Standard'Word_Size` (`Standard` is the only permissible\n+prefix) provides the value `System.Word_Size`. The result is\n+a static constant.\n+"}, {"sha": "f26dd9129988bed3f4b0e24473428e011cfc2ac6", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_characteristics.rst", "status": "added", "additions": 1295, "deletions": 0, "changes": 1295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_characteristics.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_characteristics.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_characteristics.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,1295 @@\n+.. _Implementation_Defined_Characteristics:\n+\n+**************************************\n+Implementation Defined Characteristics\n+**************************************\n+\n+In addition to the implementation dependent pragmas and attributes, and the\n+implementation advice, there are a number of other Ada features that are\n+potentially implementation dependent and are designated as\n+implementation-defined. These are mentioned throughout the Ada Reference\n+Manual, and are summarized in Annex M.\n+\n+A requirement for conforming Ada compilers is that they provide\n+documentation describing how the implementation deals with each of these\n+issues.  In this chapter you will find each point in Annex M listed,\n+followed by a description of how GNAT\n+handles the implementation dependence.\n+\n+You can use this chapter as a guide to minimizing implementation\n+dependent features in your programs if portability to other compilers\n+and other operating systems is an important consideration.  The numbers\n+in each entry below correspond to the paragraph numbers in the Ada\n+Reference Manual.\n+\n+* \n+  \"Whether or not each recommendation given in Implementation\n+  Advice is followed.  See 1.1.2(37).\"\n+\n+See :ref:`Implementation_Advice`.\n+\n+* \n+  \"Capacity limitations of the implementation.  See 1.1.3(3).\"\n+\n+The complexity of programs that can be processed is limited only by the\n+total amount of available virtual memory, and disk space for the\n+generated object files.\n+\n+* \n+  \"Variations from the standard that are impractical to avoid\n+  given the implementation's execution environment.  See 1.1.3(6).\"\n+\n+There are no variations from the standard.\n+\n+* \n+  \"Which code_statements cause external\n+  interactions.  See 1.1.3(10).\"\n+\n+Any `code_statement` can potentially cause external interactions.\n+\n+* \n+  \"The coded representation for the text of an Ada\n+  program.  See 2.1(4).\"\n+\n+See separate section on source representation.\n+\n+* \n+  \"The control functions allowed in comments.  See 2.1(14).\"\n+\n+See separate section on source representation.\n+\n+* \n+  \"The representation for an end of line.  See 2.2(2).\"\n+\n+See separate section on source representation.\n+\n+* \n+  \"Maximum supported line length and lexical element\n+  length.  See 2.2(15).\"\n+\n+The maximum line length is 255 characters and the maximum length of\n+a lexical element is also 255 characters. This is the default setting\n+if not overridden by the use of compiler switch *-gnaty* (which\n+sets the maximum to 79) or *-gnatyMnn* which allows the maximum\n+line length to be specified to be any value up to 32767. The maximum\n+length of a lexical element is the same as the maximum line length.\n+\n+* \n+  \"Implementation defined pragmas.  See 2.8(14).\"\n+\n+See :ref:`Implementation_Defined_Pragmas`.\n+\n+* \n+  \"Effect of pragma `Optimize`.  See 2.8(27).\"\n+\n+Pragma `Optimize`, if given with a `Time` or `Space`\n+parameter, checks that the optimization flag is set, and aborts if it is\n+not.\n+\n+* \n+  \"The sequence of characters of the value returned by\n+  ``S'Image`` when some of the graphic characters of\n+  ``S'Wide_Image`` are not defined in `Character`.  See\n+  3.5(37).\"\n+\n+The sequence of characters is as defined by the wide character encoding\n+method used for the source.  See section on source representation for\n+further details.\n+\n+* \n+  \"The predefined integer types declared in\n+  `Standard`.  See 3.5.4(25).\"\n+\n+====================== =======================================\n+Type                   Representation\n+====================== =======================================\n+*Short_Short_Integer*  8 bit signed\n+*Short_Integer*        (Short) 16 bit signed\n+*Integer*              32 bit signed\n+*Long_Integer*         64 bit signed (on most 64 bit targets, \n+                       depending on the C definition of long).\n+                       32 bit signed (all other targets)\n+*Long_Long_Integer*    64 bit signed\n+====================== =======================================\n+\n+* \n+  \"Any nonstandard integer types and the operators defined\n+  for them.  See 3.5.4(26).\"\n+\n+There are no nonstandard integer types.\n+\n+* \n+  \"Any nonstandard real types and the operators defined for\n+  them.  See 3.5.6(8).\"\n+\n+There are no nonstandard real types.\n+\n+* \n+  \"What combinations of requested decimal precision and range\n+  are supported for floating point types.  See 3.5.7(7).\"\n+\n+The precision and range is as defined by the IEEE standard.\n+\n+* \n+  \"The predefined floating point types declared in\n+  `Standard`.  See 3.5.7(16).\"\n+\n+====================== ====================================================\n+Type                   Representation\n+====================== ====================================================\n+*Short_Float*          32 bit IEEE short\n+*Float*                (Short) 32 bit IEEE short\n+*Long_Float*           64 bit IEEE long\n+*Long_Long_Float*      64 bit IEEE long (80 bit IEEE long on x86 processors)\n+====================== ====================================================\n+\n+* \n+  \"The small of an ordinary fixed point type.  See 3.5.9(8).\"\n+\n+`Fine_Delta` is 2**(-63)\n+\n+* \n+  \"What combinations of small, range, and digits are\n+  supported for fixed point types.  See 3.5.9(10).\"\n+\n+Any combinations are permitted that do not result in a small less than\n+`Fine_Delta` and do not result in a mantissa larger than 63 bits.\n+If the mantissa is larger than 53 bits on machines where Long_Long_Float\n+is 64 bits (true of all architectures except ia32), then the output from\n+Text_IO is accurate to only 53 bits, rather than the full mantissa.  This\n+is because floating-point conversions are used to convert fixed point.\n+\n+\n+* \n+  \"The result of `Tags.Expanded_Name` for types declared\n+  within an unnamed `block_statement`.  See 3.9(10).\"\n+\n+Block numbers of the form `B`nnn``, where `nnn` is a\n+decimal integer are allocated.\n+\n+* \n+  \"Implementation-defined attributes.  See 4.1.4(12).\"\n+\n+See :ref:`Implementation_Defined_Attributes`.\n+\n+* \n+  \"Any implementation-defined time types.  See 9.6(6).\"\n+\n+There are no implementation-defined time types.\n+\n+* \n+  \"The time base associated with relative delays.\"\n+\n+See 9.6(20).  The time base used is that provided by the C library\n+function `gettimeofday`.\n+\n+* \n+  \"The time base of the type `Calendar.Time`.  See\n+  9.6(23).\"\n+\n+The time base used is that provided by the C library function\n+`gettimeofday`.\n+\n+* \n+  \"The time zone used for package `Calendar`\n+  operations.  See 9.6(24).\"\n+\n+The time zone used by package `Calendar` is the current system time zone\n+setting for local time, as accessed by the C library function\n+`localtime`.\n+\n+* \n+  \"Any limit on `delay_until_statements` of\n+  `select_statements`.  See 9.6(29).\"\n+\n+There are no such limits.\n+\n+* \n+  \"Whether or not two non-overlapping parts of a composite\n+  object are independently addressable, in the case where packing, record\n+  layout, or `Component_Size` is specified for the object.  See\n+  9.10(1).\"\n+\n+Separate components are independently addressable if they do not share\n+overlapping storage units.\n+\n+* \n+  \"The representation for a compilation.  See 10.1(2).\"\n+\n+A compilation is represented by a sequence of files presented to the\n+compiler in a single invocation of the *gcc* command.\n+\n+* \n+  \"Any restrictions on compilations that contain multiple\n+  compilation_units.  See 10.1(4).\"\n+\n+No single file can contain more than one compilation unit, but any\n+sequence of files can be presented to the compiler as a single\n+compilation.\n+\n+* \n+  \"The mechanisms for creating an environment and for adding\n+  and replacing compilation units.  See 10.1.4(3).\"\n+\n+See separate section on compilation model.\n+\n+* \n+  \"The manner of explicitly assigning library units to a\n+  partition.  See 10.2(2).\"\n+\n+If a unit contains an Ada main program, then the Ada units for the partition\n+are determined by recursive application of the rules in the Ada Reference\n+Manual section 10.2(2-6).  In other words, the Ada units will be those that\n+are needed by the main program, and then this definition of need is applied\n+recursively to those units, and the partition contains the transitive\n+closure determined by this relationship.  In short, all the necessary units\n+are included, with no need to explicitly specify the list.  If additional\n+units are required, e.g., by foreign language units, then all units must be\n+mentioned in the context clause of one of the needed Ada units.\n+\n+If the partition contains no main program, or if the main program is in\n+a language other than Ada, then GNAT\n+provides the binder options *-z* and *-n* respectively, and in\n+this case a list of units can be explicitly supplied to the binder for\n+inclusion in the partition (all units needed by these units will also\n+be included automatically).  For full details on the use of these\n+options, refer to the `GNAT Make Program gnatmake` in the\n+:title:`GNAT User's Guide`.\n+\n+* \n+  \"The implementation-defined means, if any, of specifying\n+  which compilation units are needed by a given compilation unit.  See\n+  10.2(2).\"\n+\n+The units needed by a given compilation unit are as defined in\n+the Ada Reference Manual section 10.2(2-6).  There are no\n+implementation-defined pragmas or other implementation-defined\n+means for specifying needed units.\n+\n+* \n+  \"The manner of designating the main subprogram of a\n+  partition.  See 10.2(7).\"\n+\n+The main program is designated by providing the name of the\n+corresponding :file:`ALI` file as the input parameter to the binder.\n+\n+* \n+  \"The order of elaboration of `library_items`.  See\n+  10.2(18).\"\n+\n+The first constraint on ordering is that it meets the requirements of\n+Chapter 10 of the Ada Reference Manual.  This still leaves some\n+implementation dependent choices, which are resolved by first\n+elaborating bodies as early as possible (i.e., in preference to specs\n+where there is a choice), and second by evaluating the immediate with\n+clauses of a unit to determine the probably best choice, and\n+third by elaborating in alphabetical order of unit names\n+where a choice still remains.\n+\n+* \n+  \"Parameter passing and function return for the main\n+  subprogram.  See 10.2(21).\"\n+\n+The main program has no parameters.  It may be a procedure, or a function\n+returning an integer type.  In the latter case, the returned integer\n+value is the return code of the program (overriding any value that\n+may have been set by a call to `Ada.Command_Line.Set_Exit_Status`).\n+\n+* \n+  \"The mechanisms for building and running partitions.  See\n+  10.2(24).\"\n+\n+GNAT itself supports programs with only a single partition.  The GNATDIST\n+tool provided with the GLADE package (which also includes an implementation\n+of the PCS) provides a completely flexible method for building and running\n+programs consisting of multiple partitions.  See the separate GLADE manual\n+for details.\n+\n+* \n+  \"The details of program execution, including program\n+  termination.  See 10.2(25).\"\n+\n+See separate section on compilation model.\n+\n+* \n+  \"The semantics of any non-active partitions supported by the\n+  implementation.  See 10.2(28).\"\n+\n+Passive partitions are supported on targets where shared memory is\n+provided by the operating system.  See the GLADE reference manual for\n+further details.\n+\n+* \n+  \"The information returned by `Exception_Message`.  See\n+  11.4.1(10).\"\n+\n+Exception message returns the null string unless a specific message has\n+been passed by the program.\n+\n+* \n+  \"The result of `Exceptions.Exception_Name` for types\n+  declared within an unnamed `block_statement`.  See 11.4.1(12).\"\n+\n+Blocks have implementation defined names of the form `B`nnn``\n+where `nnn` is an integer.\n+\n+* \n+  \"The information returned by\n+  `Exception_Information`.  See 11.4.1(13).\"\n+\n+`Exception_Information` returns a string in the following format::\n+\n+  *Exception_Name:* nnnnn\n+  *Message:* mmmmm\n+  *PID:* ppp\n+  *Load address:* 0xhhhh\n+  *Call stack traceback locations:*\n+  0xhhhh 0xhhhh 0xhhhh ... 0xhhh\n+\n+where\n+\n+  *  `nnnn` is the fully qualified name of the exception in all upper\n+     case letters. This line is always present.\n+  \n+  *  `mmmm` is the message (this line present only if message is non-null)\n+  \n+  *  `ppp` is the Process Id value as a decimal integer (this line is\n+     present only if the Process Id is nonzero). Currently we are\n+     not making use of this field.\n+\n+  *  The Load address line, the Call stack traceback locations line and the\n+     following values are present only if at least one traceback location was\n+     recorded. The Load address indicates the address at which the main executable\n+     was loaded; this line may not be present if operating system hasn't relocated\n+     the main executable. The values are given in C style format, with lower case\n+     letters for a-f, and only as many digits present as are necessary.\n+     The line terminator sequence at the end of each line, including\n+     the last line is a single `LF` character (`16#0A#`).\n+\n+* \n+  \"Implementation-defined check names.  See 11.5(27).\"\n+\n+The implementation defined check name Alignment_Check controls checking of\n+address clause values for proper alignment (that is, the address supplied\n+must be consistent with the alignment of the type).\n+\n+The implementation defined check name Predicate_Check controls whether\n+predicate checks are generated.\n+\n+The implementation defined check name Validity_Check controls whether\n+validity checks are generated.\n+\n+In addition, a user program can add implementation-defined check names\n+by means of the pragma Check_Name.\n+\n+* \n+  \"The interpretation of each aspect of representation.  See\n+  13.1(20).\"\n+\n+See separate section on data representations.\n+\n+* \n+  \"Any restrictions placed upon representation items.  See\n+  13.1(20).\"\n+\n+See separate section on data representations.\n+\n+* \n+  \"The meaning of `Size` for indefinite subtypes.  See\n+  13.3(48).\"\n+\n+Size for an indefinite subtype is the maximum possible size, except that\n+for the case of a subprogram parameter, the size of the parameter object\n+is the actual size.\n+\n+* \n+  \"The default external representation for a type tag.  See\n+  13.3(75).\"\n+\n+The default external representation for a type tag is the fully expanded\n+name of the type in upper case letters.\n+\n+* \n+  \"What determines whether a compilation unit is the same in\n+  two different partitions.  See 13.3(76).\"\n+\n+A compilation unit is the same in two different partitions if and only\n+if it derives from the same source file.\n+\n+* \n+  \"Implementation-defined components.  See 13.5.1(15).\"\n+\n+The only implementation defined component is the tag for a tagged type,\n+which contains a pointer to the dispatching table.\n+\n+* \n+  \"If `Word_Size` = `Storage_Unit`, the default bit\n+  ordering.  See 13.5.3(5).\"\n+\n+`Word_Size` (32) is not the same as `Storage_Unit` (8) for this\n+implementation, so no non-default bit ordering is supported.  The default\n+bit ordering corresponds to the natural endianness of the target architecture.\n+\n+* \n+  \"The contents of the visible part of package `System`\n+  and its language-defined children.  See 13.7(2).\"\n+\n+See the definition of these packages in files :file:`system.ads` and\n+:file:`s-stoele.ads`. Note that two declarations are added to package\n+System.\n+\n+.. code-block:: ada\n+\n+  Max_Priority           : constant Positive := Priority'Last;\n+  Max_Interrupt_Priority : constant Positive := Interrupt_Priority'Last;\n+\n+* \n+  \"The contents of the visible part of package\n+  `System.Machine_Code`, and the meaning of\n+  `code_statements`.  See 13.8(7).\"\n+\n+See the definition and documentation in file :file:`s-maccod.ads`.\n+\n+* \n+  \"The effect of unchecked conversion.  See 13.9(11).\"\n+\n+Unchecked conversion between types of the same size\n+results in an uninterpreted transmission of the bits from one type\n+to the other.  If the types are of unequal sizes, then in the case of\n+discrete types, a shorter source is first zero or sign extended as\n+necessary, and a shorter target is simply truncated on the left.\n+For all non-discrete types, the source is first copied if necessary\n+to ensure that the alignment requirements of the target are met, then\n+a pointer is constructed to the source value, and the result is obtained\n+by dereferencing this pointer after converting it to be a pointer to the\n+target type. Unchecked conversions where the target subtype is an\n+unconstrained array are not permitted. If the target alignment is\n+greater than the source alignment, then a copy of the result is\n+made with appropriate alignment\n+\n+* \n+  \"The semantics of operations on invalid representations.\n+  See 13.9.2(10-11).\"\n+\n+For assignments and other operations where the use of invalid values cannot\n+result in erroneous behavior, the compiler ignores the possibility of invalid\n+values. An exception is raised at the point where an invalid value would\n+result in erroneous behavior. For example executing:\n+\n+.. code-block:: ada\n+\n+  procedure invalidvals is\n+    X : Integer := -1;\n+    Y : Natural range 1 .. 10;\n+    for Y'Address use X'Address;\n+    Z : Natural range 1 .. 10;\n+    A : array (Natural range 1 .. 10) of Integer;\n+  begin\n+    Z := Y;     -- no exception\n+    A (Z) := 3; -- exception raised;\n+  end;\n+\n+As indicated, an exception is raised on the array assignment, but not\n+on the simple assignment of the invalid negative value from Y to Z.\n+\n+* \n+  \"The manner of choosing a storage pool for an access type\n+  when `Storage_Pool` is not specified for the type.  See 13.11(17).\"\n+\n+There are 3 different standard pools used by the compiler when\n+`Storage_Pool` is not specified depending whether the type is local\n+to a subprogram or defined at the library level and whether\n+`Storage_Size`is specified or not.  See documentation in the runtime\n+library units `System.Pool_Global`, `System.Pool_Size` and\n+`System.Pool_Local` in files :file:`s-poosiz.ads`,\n+:file:`s-pooglo.ads` and :file:`s-pooloc.ads` for full details on the\n+default pools used.\n+\n+* \n+  \"Whether or not the implementation provides user-accessible\n+  names for the standard pool type(s).  See 13.11(17).\"\n+\n+See documentation in the sources of the run time mentioned in the previous\n+paragraph.  All these pools are accessible by means of `with`'ing\n+these units.\n+\n+* \n+  \"The meaning of `Storage_Size`.  See 13.11(18).\"\n+\n+`Storage_Size` is measured in storage units, and refers to the\n+total space available for an access type collection, or to the primary\n+stack space for a task.\n+\n+* \n+  \"Implementation-defined aspects of storage pools.  See\n+  13.11(22).\"\n+\n+See documentation in the sources of the run time mentioned in the\n+paragraph about standard storage pools above\n+for details on GNAT-defined aspects of storage pools.\n+\n+* \n+  \"The set of restrictions allowed in a pragma\n+  `Restrictions`.  See 13.12(7).\"\n+\n+See :ref:`Standard_and_Implementation_Defined_Restrictions`.\n+\n+* \n+  \"The consequences of violating limitations on\n+  `Restrictions` pragmas.  See 13.12(9).\"\n+\n+Restrictions that can be checked at compile time result in illegalities\n+if violated.  Currently there are no other consequences of violating\n+restrictions.\n+\n+* \n+  \"The representation used by the `Read` and\n+  `Write` attributes of elementary types in terms of stream\n+  elements.  See 13.13.2(9).\"\n+\n+The representation is the in-memory representation of the base type of\n+the type, using the number of bits corresponding to the\n+``type'Size`` value, and the natural ordering of the machine.\n+\n+* \n+  \"The names and characteristics of the numeric subtypes\n+  declared in the visible part of package `Standard`.  See A.1(3).\"\n+\n+See items describing the integer and floating-point types supported.\n+\n+* \n+  \"The string returned by `Character_Set_Version`.\n+  See A.3.5(3).\"\n+\n+`Ada.Wide_Characters.Handling.Character_Set_Version` returns\n+the string \"Unicode 4.0\", referring to version 4.0 of the\n+Unicode specification.\n+\n+* \n+  \"The accuracy actually achieved by the elementary\n+  functions.  See A.5.1(1).\"\n+\n+The elementary functions correspond to the functions available in the C\n+library.  Only fast math mode is implemented.\n+\n+* \n+  \"The sign of a zero result from some of the operators or\n+  functions in `Numerics.Generic_Elementary_Functions`, when\n+  `Float_Type'Signed_Zeros` is `True`.  See A.5.1(46).\"\n+\n+The sign of zeroes follows the requirements of the IEEE 754 standard on\n+floating-point.\n+\n+* \n+  \"The value of\n+  `Numerics.Float_Random.Max_Image_Width`.  See A.5.2(27).\"\n+\n+Maximum image width is 6864, see library file :file:`s-rannum.ads`.\n+\n+* \n+  \"The value of\n+  `Numerics.Discrete_Random.Max_Image_Width`.  See A.5.2(27).\"\n+\n+Maximum image width is 6864, see library file :file:`s-rannum.ads`.\n+\n+* \n+  \"The algorithms for random number generation.  See\n+  A.5.2(32).\"\n+\n+The algorithm is the Mersenne Twister, as documented in the source file\n+:file:`s-rannum.adb`. This version of the algorithm has a period of\n+2**19937-1.\n+\n+* \n+  \"The string representation of a random number generator's\n+  state.  See A.5.2(38).\"\n+\n+The value returned by the Image function is the concatenation of\n+the fixed-width decimal representations of the 624 32-bit integers\n+of the state vector.\n+\n+* \n+  \"The minimum time interval between calls to the\n+  time-dependent Reset procedure that are guaranteed to initiate different\n+  random number sequences.  See A.5.2(45).\"\n+\n+The minimum period between reset calls to guarantee distinct series of\n+random numbers is one microsecond.\n+\n+* \n+  \"The values of the `Model_Mantissa`,\n+  `Model_Emin`, `Model_Epsilon`, `Model`,\n+  `Safe_First`, and `Safe_Last` attributes, if the Numerics\n+  Annex is not supported.  See A.5.3(72).\"\n+\n+Run the compiler with *-gnatS* to produce a listing of package\n+`Standard`, has the values of all numeric attributes.\n+\n+* \n+  \"Any implementation-defined characteristics of the\n+  input-output packages.  See A.7(14).\"\n+\n+There are no special implementation defined characteristics for these\n+packages.\n+\n+* \n+  \"The value of `Buffer_Size` in `Storage_IO`.  See\n+  A.9(10).\"\n+\n+All type representations are contiguous, and the `Buffer_Size` is\n+the value of ``type'Size`` rounded up to the next storage unit\n+boundary.\n+\n+* \n+  \"External files for standard input, standard output, and\n+  standard error See A.10(5).\"\n+\n+These files are mapped onto the files provided by the C streams\n+libraries.  See source file :file:`i-cstrea.ads` for further details.\n+\n+* \n+  \"The accuracy of the value produced by `Put`.  See\n+  A.10.9(36).\"\n+\n+If more digits are requested in the output than are represented by the\n+precision of the value, zeroes are output in the corresponding least\n+significant digit positions.\n+\n+* \n+  \"The meaning of `Argument_Count`, `Argument`, and\n+  `Command_Name`.  See A.15(1).\"\n+\n+These are mapped onto the `argv` and `argc` parameters of the\n+main program in the natural manner.\n+\n+* \n+  \"The interpretation of the `Form` parameter in procedure\n+  `Create_Directory`.  See A.16(56).\"\n+\n+The `Form` parameter is not used.\n+\n+* \n+  \"The interpretation of the `Form` parameter in procedure\n+  `Create_Path`.  See A.16(60).\"\n+\n+The `Form` parameter is not used.\n+\n+* \n+  \"The interpretation of the `Form` parameter in procedure\n+  `Copy_File`.  See A.16(68).\"\n+\n+The `Form` parameter is case-insensitive.\n+Two fields are recognized in the `Form` parameter::\n+\n+  *preserve=<value>*\n+  *mode=<value>*\n+\n+<value> starts immediately after the character '=' and ends with the\n+character immediately preceding the next comma (',') or with the last\n+character of the parameter.\n+\n+The only possible values for preserve= are:\n+\n+================== ===================================================================\n+Value              Meaning\n+================== ===================================================================\n+*no_attributes*    Do not try to preserve any file attributes. This is the \n+                   default if no preserve= is found in Form.\n+*all_attributes*   Try to preserve all file attributes (timestamps, access rights).\n+*timestamps*       Preserve the timestamp of the copied file, but not the other\n+                   file attributes.\n+================== ===================================================================\n+\n+The only possible values for mode= are:\n+\n+============== ===============================================================================\n+Value          Meaning\n+============== ===============================================================================\n+*copy*         Only do the copy if the destination file does not already exist. \n+               If it already exists, Copy_File fails.\n+*overwrite*    Copy the file in all cases. Overwrite an already existing destination file.\n+*append*       Append the original file to the destination file. If the destination file \n+               does not exist, the destination file is a copy of the source file. \n+               When mode=append, the field preserve=, if it exists, is not taken into account.\n+============== ===============================================================================\n+\n+If the Form parameter includes one or both of the fields and the value or\n+values are incorrect, Copy_file fails with Use_Error.\n+\n+Examples of correct Forms::\n+\n+  Form => \"preserve=no_attributes,mode=overwrite\" (the default)\n+  Form => \"mode=append\"\n+  Form => \"mode=copy, preserve=all_attributes\"\n+\n+Examples of incorrect Forms::\n+\n+  Form => \"preserve=junk\"\n+  Form => \"mode=internal, preserve=timestamps\"\n+\n+* \n+  \"The interpretation of the `Pattern` parameter, when not the null string,\n+  in the `Start_Search` and `Search` procedures.\n+  See A.16(104) and A.16(112).\"\n+\n+When the `Pattern` parameter is not the null string, it is interpreted\n+according to the syntax of regular expressions as defined in the\n+`GNAT.Regexp` package.\n+\n+See :ref:`GNAT.Regexp_(g-regexp.ads)`.\n+\n+* \n+  \"Implementation-defined convention names.  See B.1(11).\"\n+\n+The following convention names are supported\n+\n+======================= ==============================================================================\n+Convention Name         Interpretation\n+======================= ==============================================================================\n+*Ada*                   Ada\n+*Ada_Pass_By_Copy*      Allowed for any types except by-reference types such as limited\n+                        records. Compatible with convention Ada, but causes any parameters\n+                        with this convention to be passed by copy.\n+*Ada_Pass_By_Reference* Allowed for any types except by-copy types such as scalars.\n+                        Compatible with convention Ada, but causes any parameters\n+                        with this convention to be passed by reference.\n+*Assembler*             Assembly language\n+*Asm*                   Synonym for Assembler\n+*Assembly*              Synonym for Assembler\n+*C*                     C\n+*C_Pass_By_Copy*        Allowed only for record types, like C, but also notes that record\n+                        is to be passed by copy rather than reference.\n+*COBOL*                 COBOL\n+*C_Plus_Plus (or CPP)*  C++\n+*Default*               Treated the same as C\n+*External*              Treated the same as C\n+*Fortran*               Fortran\n+*Intrinsic*             For support of pragma `Import` with convention Intrinsic, see\n+                        separate section on Intrinsic Subprograms.\n+*Stdcall*               Stdcall (used for Windows implementations only).  This convention correspond\n+                        to the WINAPI (previously called Pascal convention) C/C++ convention under\n+                        Windows.  A routine with this convention cleans the stack before\n+                        exit. This pragma cannot be applied to a dispatching call.\n+*DLL*                   Synonym for Stdcall\n+*Win32*                 Synonym for Stdcall\n+*Stubbed*               Stubbed is a special convention used to indicate that the body of the\n+                        subprogram will be entirely ignored.  Any call to the subprogram\n+                        is converted into a raise of the `Program_Error` exception.  If a\n+                        pragma `Import` specifies convention `stubbed` then no body need\n+                        be present at all.  This convention is useful during development for the\n+                        inclusion of subprograms whose body has not yet been written.\n+                        In addition, all otherwise unrecognized convention names are also\n+                        treated as being synonymous with convention C.  In all implementations\n+                        except for VMS, use of such other names results in a warning.  In VMS\n+                        implementations, these names are accepted silently.\n+======================= ==============================================================================\n+\n+* \n+  \"The meaning of link names.  See B.1(36).\"\n+\n+Link names are the actual names used by the linker.\n+\n+* \n+  \"The manner of choosing link names when neither the link\n+  name nor the address of an imported or exported entity is specified.  See\n+  B.1(36).\"\n+\n+The default linker name is that which would be assigned by the relevant\n+external language, interpreting the Ada name as being in all lower case\n+letters.\n+\n+* \n+  \"The effect of pragma `Linker_Options`.  See B.1(37).\"\n+\n+The string passed to `Linker_Options` is presented uninterpreted as\n+an argument to the link command, unless it contains ASCII.NUL characters.\n+NUL characters if they appear act as argument separators, so for example\n+\n+.. code-block:: ada\n+\n+  pragma Linker_Options (\"-labc\" & ASCII.NUL & \"-ldef\");\n+\n+causes two separate arguments `-labc` and `-ldef` to be passed to the\n+linker. The order of linker options is preserved for a given unit. The final\n+list of options passed to the linker is in reverse order of the elaboration\n+order. For example, linker options for a body always appear before the options\n+from the corresponding package spec.\n+\n+* \n+  \"The contents of the visible part of package\n+  `Interfaces` and its language-defined descendants.  See B.2(1).\"\n+\n+See files with prefix :file:`i-` in the distributed library.\n+\n+* \n+  \"Implementation-defined children of package\n+  `Interfaces`.  The contents of the visible part of package\n+  `Interfaces`.  See B.2(11).\"\n+\n+See files with prefix :file:`i-` in the distributed library.\n+\n+* \n+  \"The types `Floating`, `Long_Floating`,\n+  `Binary`, `Long_Binary`, `Decimal_ Element`, and\n+  `COBOL_Character`; and the initialization of the variables\n+  `Ada_To_COBOL` and `COBOL_To_Ada`, in\n+  `Interfaces.COBOL`.  See B.4(50).\"\n+\n+===================== ====================================\n+COBOL                 Ada\n+===================== ====================================\n+*Floating*            Float\n+*Long_Floating*       (Floating) Long_Float\n+*Binary*              Integer\n+*Long_Binary*         Long_Long_Integer\n+*Decimal_Element*     Character\n+*COBOL_Character*     Character\n+===================== ====================================\n+\n+For initialization, see the file :file:`i-cobol.ads` in the distributed library.\n+\n+* \n+  \"Support for access to machine instructions.  See C.1(1).\"\n+\n+See documentation in file :file:`s-maccod.ads` in the distributed library.\n+\n+* \n+  \"Implementation-defined aspects of access to machine\n+  operations.  See C.1(9).\"\n+\n+See documentation in file :file:`s-maccod.ads` in the distributed library.\n+\n+* \n+  \"Implementation-defined aspects of interrupts.  See C.3(2).\"\n+\n+Interrupts are mapped to signals or conditions as appropriate.  See\n+definition of unit\n+`Ada.Interrupt_Names` in source file :file:`a-intnam.ads` for details\n+on the interrupts supported on a particular target.\n+\n+* \n+  \"Implementation-defined aspects of pre-elaboration.  See\n+  C.4(13).\"\n+\n+GNAT does not permit a partition to be restarted without reloading,\n+except under control of the debugger.\n+\n+* \n+  \"The semantics of pragma `Discard_Names`.  See C.5(7).\"\n+\n+Pragma `Discard_Names` causes names of enumeration literals to\n+be suppressed.  In the presence of this pragma, the Image attribute\n+provides the image of the Pos of the literal, and Value accepts\n+Pos values.\n+\n+* \n+  \"The result of the `Task_Identification.Image`\n+  attribute.  See C.7.1(7).\"\n+\n+The result of this attribute is a string that identifies\n+the object or component that denotes a given task. If a variable `Var`\n+has a task type, the image for this task will have the form `Var_`XXXXXXXX``,\n+where the suffix\n+is the hexadecimal representation of the virtual address of the corresponding\n+task control block. If the variable is an array of tasks, the image of each\n+task will have the form of an indexed component indicating the position of a\n+given task in the array, e.g., `Group(5)_`XXXXXXX``. If the task is a\n+component of a record, the image of the task will have the form of a selected\n+component. These rules are fully recursive, so that the image of a task that\n+is a subcomponent of a composite object corresponds to the expression that\n+designates this task.\n+\n+If a task is created by an allocator, its image depends on the context. If the\n+allocator is part of an object declaration, the rules described above are used\n+to construct its image, and this image is not affected by subsequent\n+assignments. If the allocator appears within an expression, the image\n+includes only the name of the task type.\n+\n+If the configuration pragma Discard_Names is present, or if the restriction\n+No_Implicit_Heap_Allocation is in effect,  the image reduces to\n+the numeric suffix, that is to say the hexadecimal representation of the\n+virtual address of the control block of the task.\n+\n+* \n+  \"The value of `Current_Task` when in a protected entry\n+  or interrupt handler.  See C.7.1(17).\"\n+\n+Protected entries or interrupt handlers can be executed by any\n+convenient thread, so the value of `Current_Task` is undefined.\n+\n+* \n+  \"The effect of calling `Current_Task` from an entry\n+  body or interrupt handler.  See C.7.1(19).\"\n+\n+The effect of calling `Current_Task` from an entry body or\n+interrupt handler is to return the identification of the task currently\n+executing the code.\n+\n+* \n+  \"Implementation-defined aspects of\n+  `Task_Attributes`.  See C.7.2(19).\"\n+\n+There are no implementation-defined aspects of `Task_Attributes`.\n+\n+* \n+  \"Values of all `Metrics`.  See D(2).\"\n+\n+The metrics information for GNAT depends on the performance of the\n+underlying operating system.  The sources of the run-time for tasking\n+implementation, together with the output from *-gnatG* can be\n+used to determine the exact sequence of operating systems calls made\n+to implement various tasking constructs.  Together with appropriate\n+information on the performance of the underlying operating system,\n+on the exact target in use, this information can be used to determine\n+the required metrics.\n+\n+* \n+  \"The declarations of `Any_Priority` and\n+  `Priority`.  See D.1(11).\"\n+\n+See declarations in file :file:`system.ads`.\n+\n+* \n+  \"Implementation-defined execution resources.  See D.1(15).\"\n+\n+There are no implementation-defined execution resources.\n+\n+* \n+  \"Whether, on a multiprocessor, a task that is waiting for\n+  access to a protected object keeps its processor busy.  See D.2.1(3).\"\n+\n+On a multi-processor, a task that is waiting for access to a protected\n+object does not keep its processor busy.\n+\n+* \n+  \"The affect of implementation defined execution resources\n+  on task dispatching.  See D.2.1(9).\"\n+\n+Tasks map to threads in the threads package used by GNAT.  Where possible\n+and appropriate, these threads correspond to native threads of the\n+underlying operating system.\n+\n+* \n+  \"Implementation-defined `policy_identifiers` allowed\n+  in a pragma `Task_Dispatching_Policy`.  See D.2.2(3).\"\n+\n+There are no implementation-defined policy-identifiers allowed in this\n+pragma.\n+\n+* \n+  \"Implementation-defined aspects of priority inversion.  See\n+  D.2.2(16).\"\n+\n+Execution of a task cannot be preempted by the implementation processing\n+of delay expirations for lower priority tasks.\n+\n+* \n+  \"Implementation-defined task dispatching.  See D.2.2(18).\"\n+\n+The policy is the same as that of the underlying threads implementation.\n+\n+* \n+  \"Implementation-defined `policy_identifiers` allowed\n+  in a pragma `Locking_Policy`.  See D.3(4).\"\n+\n+The two implementation defined policies permitted in GNAT are\n+`Inheritance_Locking` and  `Conccurent_Readers_Locking`.  On\n+targets that support the `Inheritance_Locking` policy, locking is\n+implemented by inheritance, i.e., the task owning the lock operates\n+at a priority equal to the highest priority of any task currently\n+requesting the lock.  On targets that support the\n+`Conccurent_Readers_Locking` policy, locking is implemented with a\n+read/write lock allowing multiple propected object functions to enter\n+concurrently.\n+\n+* \n+  \"Default ceiling priorities.  See D.3(10).\"\n+\n+The ceiling priority of protected objects of the type\n+`System.Interrupt_Priority'Last` as described in the Ada\n+Reference Manual D.3(10),\n+\n+* \n+  \"The ceiling of any protected object used internally by\n+  the implementation.  See D.3(16).\"\n+\n+The ceiling priority of internal protected objects is\n+`System.Priority'Last`.\n+\n+* \n+  \"Implementation-defined queuing policies.  See D.4(1).\"\n+\n+There are no implementation-defined queuing policies.\n+\n+* \n+  \"On a multiprocessor, any conditions that cause the\n+  completion of an aborted construct to be delayed later than what is\n+  specified for a single processor.  See D.6(3).\"\n+\n+The semantics for abort on a multi-processor is the same as on a single\n+processor, there are no further delays.\n+\n+* \n+  \"Any operations that implicitly require heap storage\n+  allocation.  See D.7(8).\"\n+\n+The only operation that implicitly requires heap storage allocation is\n+task creation.\n+\n+* \n+  \"What happens when a task terminates in the presence of\n+  pragma `No_Task_Termination`. See D.7(15).\"\n+\n+Execution is erroneous in that case.\n+\n+* \n+  \"Implementation-defined aspects of pragma\n+  `Restrictions`.  See D.7(20).\"\n+\n+There are no such implementation-defined aspects.\n+\n+* \n+  \"Implementation-defined aspects of package\n+  `Real_Time`.  See D.8(17).\"\n+\n+There are no implementation defined aspects of package `Real_Time`.\n+\n+* \n+  \"Implementation-defined aspects of\n+  `delay_statements`.  See D.9(8).\"\n+\n+Any difference greater than one microsecond will cause the task to be\n+delayed (see D.9(7)).\n+\n+* \n+  \"The upper bound on the duration of interrupt blocking\n+  caused by the implementation.  See D.12(5).\"\n+\n+The upper bound is determined by the underlying operating system.  In\n+no cases is it more than 10 milliseconds.\n+\n+* \n+  \"The means for creating and executing distributed\n+  programs.  See E(5).\"\n+\n+The GLADE package provides a utility GNATDIST for creating and executing\n+distributed programs.  See the GLADE reference manual for further details.\n+\n+* \n+  \"Any events that can result in a partition becoming\n+  inaccessible.  See E.1(7).\"\n+\n+See the GLADE reference manual for full details on such events.\n+\n+* \n+  \"The scheduling policies, treatment of priorities, and\n+  management of shared resources between partitions in certain cases.  See\n+  E.1(11).\"\n+\n+See the GLADE reference manual for full details on these aspects of\n+multi-partition execution.\n+\n+* \n+  \"Events that cause the version of a compilation unit to\n+  change.  See E.3(5).\"\n+\n+Editing the source file of a compilation unit, or the source files of\n+any units on which it is dependent in a significant way cause the version\n+to change.  No other actions cause the version number to change.  All changes\n+are significant except those which affect only layout, capitalization or\n+comments.\n+\n+* \n+  \"Whether the execution of the remote subprogram is\n+  immediately aborted as a result of cancellation.  See E.4(13).\"\n+\n+See the GLADE reference manual for details on the effect of abort in\n+a distributed application.\n+\n+* \n+  \"Implementation-defined aspects of the PCS.  See E.5(25).\"\n+\n+See the GLADE reference manual for a full description of all implementation\n+defined aspects of the PCS.\n+\n+* \n+  \"Implementation-defined interfaces in the PCS.  See\n+  E.5(26).\"\n+\n+See the GLADE reference manual for a full description of all\n+implementation defined interfaces.\n+\n+* \n+  \"The values of named numbers in the package\n+  `Decimal`.  See F.2(7).\"\n+\n+==================== ==========\n+Named Number         Value\n+==================== ==========\n+*Max_Scale*           +18\n+*Min_Scale*           -18\n+*Min_Delta*           1.0E-18\n+*Max_Delta*           1.0E+18\n+*Max_Decimal_Digits*  18\n+==================== ==========\n+\n+* \n+  \"The value of `Max_Picture_Length` in the package\n+  `Text_IO.Editing`.  See F.3.3(16).\"\n+\n+64\n+\n+* \n+  \"The value of `Max_Picture_Length` in the package\n+  `Wide_Text_IO.Editing`.  See F.3.4(5).\"\n+\n+64\n+\n+* \n+  \"The accuracy actually achieved by the complex elementary\n+  functions and by other complex arithmetic operations.  See G.1(1).\"\n+\n+Standard library functions are used for the complex arithmetic\n+operations.  Only fast math mode is currently supported.\n+\n+* \n+  \"The sign of a zero result (or a component thereof) from\n+  any operator or function in `Numerics.Generic_Complex_Types`, when\n+  `Real'Signed_Zeros` is True.  See G.1.1(53).\"\n+\n+The signs of zero values are as recommended by the relevant\n+implementation advice.\n+\n+* \n+  \"The sign of a zero result (or a component thereof) from\n+  any operator or function in\n+  `Numerics.Generic_Complex_Elementary_Functions`, when\n+  `Real'Signed_Zeros` is `True`.  See G.1.2(45).\"\n+\n+The signs of zero values are as recommended by the relevant\n+implementation advice.\n+\n+* \n+  \"Whether the strict mode or the relaxed mode is the\n+  default.  See G.2(2).\"\n+\n+The strict mode is the default.  There is no separate relaxed mode.  GNAT\n+provides a highly efficient implementation of strict mode.\n+\n+* \n+  \"The result interval in certain cases of fixed-to-float\n+  conversion.  See G.2.1(10).\"\n+\n+For cases where the result interval is implementation dependent, the\n+accuracy is that provided by performing all operations in 64-bit IEEE\n+floating-point format.\n+\n+* \n+  \"The result of a floating point arithmetic operation in\n+  overflow situations, when the `Machine_Overflows` attribute of the\n+  result type is `False`.  See G.2.1(13).\"\n+\n+Infinite and NaN values are produced as dictated by the IEEE\n+floating-point standard.\n+Note that on machines that are not fully compliant with the IEEE\n+floating-point standard, such as Alpha, the *-mieee* compiler flag\n+must be used for achieving IEEE conforming behavior (although at the cost\n+of a significant performance penalty), so infinite and NaN values are\n+properly generated.\n+\n+* \n+  \"The result interval for division (or exponentiation by a\n+  negative exponent), when the floating point hardware implements division\n+  as multiplication by a reciprocal.  See G.2.1(16).\"\n+\n+Not relevant, division is IEEE exact.\n+\n+* \n+  \"The definition of close result set, which determines the\n+  accuracy of certain fixed point multiplications and divisions.  See\n+  G.2.3(5).\"\n+\n+Operations in the close result set are performed using IEEE long format\n+floating-point arithmetic.  The input operands are converted to\n+floating-point, the operation is done in floating-point, and the result\n+is converted to the target type.\n+\n+* \n+  \"Conditions on a `universal_real` operand of a fixed\n+  point multiplication or division for which the result shall be in the\n+  perfect result set.  See G.2.3(22).\"\n+\n+The result is only defined to be in the perfect result set if the result\n+can be computed by a single scaling operation involving a scale factor\n+representable in 64-bits.\n+\n+* \n+  \"The result of a fixed point arithmetic operation in\n+  overflow situations, when the `Machine_Overflows` attribute of the\n+  result type is `False`.  See G.2.3(27).\"\n+\n+Not relevant, `Machine_Overflows` is `True` for fixed-point\n+types.\n+\n+* \n+  \"The result of an elementary function reference in\n+  overflow situations, when the `Machine_Overflows` attribute of the\n+  result type is `False`.  See G.2.4(4).\"\n+\n+IEEE infinite and Nan values are produced as appropriate.\n+\n+* \n+  \"The value of the angle threshold, within which certain\n+  elementary functions, complex arithmetic operations, and complex\n+  elementary functions yield results conforming to a maximum relative\n+  error bound.  See G.2.4(10).\"\n+\n+Information on this subject is not yet available.\n+\n+* \n+  \"The accuracy of certain elementary functions for\n+  parameters beyond the angle threshold.  See G.2.4(10).\"\n+\n+Information on this subject is not yet available.\n+\n+* \n+  \"The result of a complex arithmetic operation or complex\n+  elementary function reference in overflow situations, when the\n+  `Machine_Overflows` attribute of the corresponding real type is\n+  `False`.  See G.2.6(5).\"\n+\n+IEEE infinite and Nan values are produced as appropriate.\n+\n+* \n+  \"The accuracy of certain complex arithmetic operations and\n+  certain complex elementary functions for parameters (or components\n+  thereof) beyond the angle threshold.  See G.2.6(8).\"\n+\n+Information on those subjects is not yet available.\n+\n+* \n+  \"Information regarding bounded errors and erroneous\n+  execution.  See H.2(1).\"\n+\n+Information on this subject is not yet available.\n+\n+* \n+  \"Implementation-defined aspects of pragma\n+  `Inspection_Point`.  See H.3.2(8).\"\n+\n+Pragma `Inspection_Point` ensures that the variable is live and can\n+be examined by the debugger at the inspection point.\n+\n+* \n+  \"Implementation-defined aspects of pragma\n+  `Restrictions`.  See H.4(25).\"\n+\n+There are no implementation-defined aspects of pragma `Restrictions`.  The\n+use of pragma `Restrictions [No_Exceptions]` has no effect on the\n+generated code.  Checks must suppressed by use of pragma `Suppress`.\n+\n+* \n+  \"Any restrictions on pragma `Restrictions`.  See\n+  H.4(27).\"\n+\n+There are no restrictions on pragma `Restrictions`."}, {"sha": "a1147adca1c1ad7dc3fc44f1fb7a7e6d686bc008", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "added", "additions": 6887, "deletions": 0, "changes": 6887, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1"}, {"sha": "5ae5faca67f75c58bfc40855dc0be5d7de6da70a", "filename": "gcc/ada/doc/gnat_rm/implementation_of_ada_2012_features.rst", "status": "added", "additions": 1328, "deletions": 0, "changes": 1328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_of_ada_2012_features.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_of_ada_2012_features.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_of_ada_2012_features.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,1328 @@\n+.. _Implementation_of_Ada_2012_Features:\n+\n+***********************************\n+Implementation of Ada 2012 Features\n+***********************************\n+\n+.. index:: Ada 2012 implementation status\n+\n+.. index:: -gnat12 option (gcc)\n+\n+.. index:: pragma Ada_2012\n+\n+.. index:: configuration pragma Ada_2012\n+\n+.. index:: Ada_2012 configuration pragma\n+\n+This chapter contains a complete list of Ada 2012 features that have been\n+implemented as of GNAT version 6.4. Generally, these features are only\n+available if the *-gnat12* (Ada 2012 features enabled) flag is set\n+or if the configuration pragma `Ada_2012` is used.\n+\n+However, new pragmas, attributes, and restrictions are\n+unconditionally available, since the Ada 95 standard allows the addition of\n+new pragmas, attributes, and restrictions (there are exceptions, which are\n+documented in the individual descriptions), and also certain packages\n+were made available in earlier versions of Ada.\n+\n+An ISO date (YYYY-MM-DD) appears in parentheses on the description line.\n+This date shows the implementation date of the feature. Any wavefront\n+subsequent to this date will contain the indicated feature, as will any\n+subsequent releases. A date of 0000-00-00 means that GNAT has always\n+implemented the feature, or implemented it as soon as it appeared as a\n+binding interpretation.\n+\n+Each feature corresponds to an Ada Issue ('AI') approved by the Ada\n+standardization group (ISO/IEC JTC1/SC22/WG9) for inclusion in Ada 2012.\n+The features are ordered based on the relevant sections of the Ada\n+Reference Manual (\"RM\").  When a given AI relates to multiple points\n+in the RM, the earliest is used.\n+\n+A complete description of the AIs may be found in\n+http://www.ada-auth.org/ai05-summary.html.\n+\n+.. index:: AI-0176 (Ada 2012 feature)\n+\n+* *AI-0176 Quantified expressions (2010-09-29)*\n+\n+  Both universally and existentially quantified expressions are implemented.\n+  They use the new syntax for iterators proposed in AI05-139-2, as well as\n+  the standard Ada loop syntax.\n+\n+  RM References:  1.01.04 (12)   2.09 (2/2)   4.04 (7)   4.05.09 (0)\n+\n+.. index:: AI-0079 (Ada 2012 feature)\n+\n+* *AI-0079 Allow other_format characters in source (2010-07-10)*\n+\n+  Wide characters in the unicode category *other_format* are now allowed in\n+  source programs between tokens, but not within a token such as an identifier.\n+\n+  RM References:  2.01 (4/2)   2.02 (7)\n+\n+.. index:: AI-0091 (Ada 2012 feature)\n+\n+* *AI-0091 Do not allow other_format in identifiers (0000-00-00)*\n+\n+  Wide characters in the unicode category *other_format* are not permitted\n+  within  an identifier, since this can be a security problem. The error\n+  message for this case has been improved to be more specific, but GNAT has\n+  never allowed such characters to appear in identifiers.\n+\n+  RM References:  2.03 (3.1/2)   2.03 (4/2)   2.03 (5/2)   2.03 (5.1/2)   2.03 (5.2/2)   2.03 (5.3/2)   2.09 (2/2)\n+\n+.. index:: AI-0100 (Ada 2012 feature)\n+\n+* *AI-0100 Placement of pragmas  (2010-07-01)*\n+\n+  This AI is an earlier version of AI-163. It simplifies the rules\n+  for legal placement of pragmas. In the case of lists that allow pragmas, if\n+  the list may have no elements, then the list may consist solely of pragmas.\n+\n+  RM References:  2.08 (7)\n+\n+.. index:: AI-0163 (Ada 2012 feature)\n+\n+* *AI-0163 Pragmas in place of null (2010-07-01)*\n+\n+  A statement sequence may be composed entirely of pragmas. It is no longer\n+  necessary to add a dummy `null` statement to make the sequence legal.\n+\n+  RM References:  2.08 (7)   2.08 (16)\n+\n+.. index:: AI-0080 (Ada 2012 feature)\n+\n+* *AI-0080 'View of' not needed if clear from context (0000-00-00)*\n+\n+  This is an editorial change only, described as non-testable in the AI.\n+\n+  RM References:  3.01 (7)\n+\n+.. index:: AI-0183 (Ada 2012 feature)\n+\n+* *AI-0183 Aspect specifications (2010-08-16)*\n+\n+  Aspect specifications have been fully implemented except for pre and post-\n+  conditions, and type invariants, which have their own separate AI's. All\n+  forms of declarations listed in the AI are supported. The following is a\n+  list of the aspects supported (with GNAT implementation aspects marked)\n+\n+================================== ===========\n+Supported Aspect                    Source\n+================================== ===========\n+  `Ada_2005`                           -- GNAT\n+  `Ada_2012`                           -- GNAT\n+  `Address`     \n+  `Alignment`     \n+  `Atomic`     \n+  `Atomic_Components`     \n+  `Bit_Order`     \n+  `Component_Size`     \n+  `Contract_Cases`                     -- GNAT\n+  `Discard_Names`     \n+  `External_Tag`     \n+  `Favor_Top_Level`                    -- GNAT\n+  `Inline`     \n+  `Inline_Always`                      -- GNAT\n+  `Invariant`                          -- GNAT\n+  `Machine_Radix`     \n+  `No_Return`     \n+  `Object_Size`                        -- GNAT\n+  `Pack`     \n+  `Persistent_BSS`                     -- GNAT\n+  `Post`     \n+  `Pre`     \n+  `Predicate`     \n+  `Preelaborable_Initialization`     \n+  `Pure_Function`                      -- GNAT\n+  `Remote_Access_Type`                 -- GNAT\n+  `Shared`                             -- GNAT\n+  `Size`     \n+  `Storage_Pool`     \n+  `Storage_Size`     \n+  `Stream_Size`     \n+  `Suppress`     \n+  `Suppress_Debug_Info`                -- GNAT\n+  `Test_Case`                          -- GNAT\n+  `Thread_Local_Storage`               -- GNAT\n+  `Type_Invariant`     \n+  `Unchecked_Union`     \n+  `Universal_Aliasing`                 -- GNAT\n+  `Unmodified`                         -- GNAT\n+  `Unreferenced`                       -- GNAT\n+  `Unreferenced_Objects`               -- GNAT\n+  `Unsuppress`     \n+  `Value_Size`                         -- GNAT\n+  `Volatile`     \n+  `Volatile_Components`\n+  `Warnings`                           -- GNAT\n+================================== ===========\n+\n+  Note that for aspects with an expression, e.g. `Size`, the expression is\n+  treated like a default expression (visibility is analyzed at the point of\n+  occurrence of the aspect, but evaluation of the expression occurs at the\n+  freeze point of the entity involved).\n+\n+  RM References:  3.02.01 (3)   3.02.02 (2)   3.03.01 (2/2)   3.08 (6)\n+  3.09.03 (1.1/2)   6.01 (2/2)   6.07 (2/2)   9.05.02 (2/2)   7.01 (3)   7.03\n+  (2)   7.03 (3)   9.01 (2/2)   9.01 (3/2)   9.04 (2/2)   9.04 (3/2)\n+  9.05.02 (2/2)   11.01 (2)   12.01 (3)   12.03 (2/2)   12.04 (2/2)   12.05 (2)\n+  12.06 (2.1/2)   12.06 (2.2/2)   12.07 (2)   13.01 (0.1/2)   13.03 (5/1)\n+  13.03.01 (0)\n+\n+.. index:: AI-0128 (Ada 2012 feature)\n+\n+* *AI-0128 Inequality is a primitive operation (0000-00-00)*\n+\n+  If an equality operator (\"=\") is declared for a type, then the implicitly\n+  declared inequality operator (\"/=\") is a primitive operation of the type.\n+  This is the only reasonable interpretation, and is the one always implemented\n+  by GNAT, but the RM was not entirely clear in making this point.\n+\n+  RM References:  3.02.03 (6)   6.06 (6)\n+\n+.. index:: AI-0003 (Ada 2012 feature)\n+\n+* *AI-0003 Qualified expressions as names (2010-07-11)*\n+\n+  In Ada 2012, a qualified expression is considered to be syntactically a name,\n+  meaning that constructs such as `A'(F(X)).B` are now legal. This is\n+  useful in disambiguating some cases of overloading.\n+\n+  RM References:  3.03 (11)   3.03 (21)   4.01 (2)   4.04 (7)   4.07 (3)\n+  5.04 (7)\n+\n+.. index:: AI-0120 (Ada 2012 feature)\n+\n+* *AI-0120 Constant instance of protected object (0000-00-00)*\n+\n+  This is an RM editorial change only. The section that lists objects that are\n+  constant failed to include the current instance of a protected object\n+  within a protected function. This has always been treated as a constant\n+  in GNAT.\n+\n+  RM References:  3.03 (21)\n+\n+.. index:: AI-0008 (Ada 2012 feature)\n+\n+* *AI-0008 General access to constrained objects (0000-00-00)*\n+\n+  The wording in the RM implied that if you have a general access to a\n+  constrained object, it could be used to modify the discriminants. This was\n+  obviously not intended. `Constraint_Error` should be raised, and GNAT\n+  has always done so in this situation.\n+\n+  RM References:  3.03 (23)   3.10.02 (26/2)   4.01 (9)   6.04.01 (17)   8.05.01 (5/2)\n+\n+.. index:: AI-0093 (Ada 2012 feature)\n+\n+* *AI-0093 Additional rules use immutably limited (0000-00-00)*\n+\n+  This is an editorial change only, to make more widespread use of the Ada 2012\n+  'immutably limited'.\n+\n+  RM References:  3.03 (23.4/3)\n+\n+.. index:: AI-0096 (Ada 2012 feature)\n+\n+* *AI-0096 Deriving from formal private types (2010-07-20)*\n+\n+  In general it is illegal for a type derived from a formal limited type to be\n+  nonlimited.  This AI makes an exception to this rule: derivation is legal\n+  if it appears in the private part of the generic, and the formal type is not\n+  tagged. If the type is tagged, the legality check must be applied to the\n+  private part of the package.\n+\n+  RM References:  3.04 (5.1/2)   6.02 (7)\n+\n+.. index:: AI-0181 (Ada 2012 feature)\n+\n+* *AI-0181 Soft hyphen is a non-graphic character (2010-07-23)*\n+\n+  From Ada 2005 on, soft hyphen is considered a non-graphic character, which\n+  means that it has a special name (`SOFT_HYPHEN`) in conjunction with the\n+  `Image` and `Value` attributes for the character types. Strictly\n+  speaking this is an inconsistency with Ada 95, but in practice the use of\n+  these attributes is so obscure that it will not cause problems.\n+\n+  RM References:  3.05.02 (2/2)   A.01 (35/2)   A.03.03 (21)\n+\n+.. index:: AI-0182 (Ada 2012 feature)\n+\n+* *AI-0182 Additional forms for `Character'Value* (0000-00-00)`\n+\n+  This AI allows `Character'Value` to accept the string `'?'` where\n+  `?` is any character including non-graphic control characters. GNAT has\n+  always accepted such strings. It also allows strings such as\n+  `HEX_00000041` to be accepted, but GNAT does not take advantage of this\n+  permission and raises `Constraint_Error`, as is certainly still\n+  permitted.\n+\n+  RM References:  3.05 (56/2)\n+\n+.. index:: AI-0214 (Ada 2012 feature)\n+\n+* *AI-0214 Defaulted discriminants for limited tagged (2010-10-01)*\n+\n+  Ada 2012 relaxes the restriction that forbids discriminants of tagged types\n+  to have default expressions by allowing them when the type is limited. It\n+  is often useful to define a default value for a discriminant even though\n+  it can't be changed by assignment.\n+\n+  RM References:  3.07 (9.1/2)   3.07.02 (3)\n+\n+.. index:: AI-0102 (Ada 2012 feature)\n+\n+* *AI-0102 Some implicit conversions are illegal (0000-00-00)*\n+\n+  It is illegal to assign an anonymous access constant to an anonymous access\n+  variable. The RM did not have a clear rule to prevent this, but GNAT has\n+  always generated an error for this usage.\n+\n+  RM References:  3.07 (16)   3.07.01 (9)   6.04.01 (6)   8.06 (27/2)\n+\n+.. index:: AI-0158 (Ada 2012 feature)\n+\n+* *AI-0158 Generalizing membership tests (2010-09-16)*\n+\n+  This AI extends the syntax of membership tests to simplify complex conditions\n+  that can be expressed as membership in a subset of values of any type. It\n+  introduces syntax for a list of expressions that may be used in loop contexts\n+  as well.\n+\n+  RM References:  3.08.01 (5)   4.04 (3)   4.05.02 (3)   4.05.02 (5)   4.05.02 (27)\n+\n+.. index:: AI-0173 (Ada 2012 feature)\n+\n+* *AI-0173 Testing if tags represent abstract types (2010-07-03)*\n+\n+  The function `Ada.Tags.Type_Is_Abstract` returns `True` if invoked\n+  with the tag of an abstract type, and `False` otherwise.\n+\n+  RM References:  3.09 (7.4/2)   3.09 (12.4/2)\n+\n+.. index:: AI-0076 (Ada 2012 feature)\n+\n+* *AI-0076 function with controlling result (0000-00-00)*\n+\n+  This is an editorial change only. The RM defines calls with controlling\n+  results, but uses the term 'function with controlling result' without an\n+  explicit definition.\n+\n+  RM References:  3.09.02 (2/2)\n+\n+.. index:: AI-0126 (Ada 2012 feature)\n+\n+* *AI-0126 Dispatching with no declared operation (0000-00-00)*\n+\n+  This AI clarifies dispatching rules, and simply confirms that dispatching\n+  executes the operation of the parent type when there is no explicitly or\n+  implicitly declared operation for the descendant type. This has always been\n+  the case in all versions of GNAT.\n+\n+  RM References:  3.09.02 (20/2)   3.09.02 (20.1/2)   3.09.02 (20.2/2)\n+\n+.. index:: AI-0097 (Ada 2012 feature)\n+\n+* *AI-0097 Treatment of abstract null extension (2010-07-19)*\n+\n+  The RM as written implied that in some cases it was possible to create an\n+  object of an abstract type, by having an abstract extension inherit a non-\n+  abstract constructor from its parent type. This mistake has been corrected\n+  in GNAT and in the RM, and this construct is now illegal.\n+\n+  RM References:  3.09.03 (4/2)\n+\n+.. index:: AI-0203 (Ada 2012 feature)\n+\n+* *AI-0203 Extended return cannot be abstract (0000-00-00)*\n+\n+  A return_subtype_indication cannot denote an abstract subtype. GNAT has never\n+  permitted such usage.\n+\n+  RM References:  3.09.03 (8/3)\n+\n+.. index:: AI-0198 (Ada 2012 feature)\n+\n+* *AI-0198 Inheriting abstract operators  (0000-00-00)*\n+\n+  This AI resolves a conflict between two rules involving inherited abstract\n+  operations and predefined operators. If a derived numeric type inherits\n+  an abstract operator, it overrides the predefined one. This interpretation\n+  was always the one implemented in GNAT.\n+\n+  RM References:  3.09.03 (4/3)\n+\n+.. index:: AI-0073 (Ada 2012 feature)\n+\n+* *AI-0073 Functions returning abstract types (2010-07-10)*\n+\n+  This AI covers a number of issues regarding returning abstract types. In\n+  particular generic functions cannot have abstract result types or access\n+  result types designated an abstract type. There are some other cases which\n+  are detailed in the AI. Note that this binding interpretation has not been\n+  retrofitted to operate before Ada 2012 mode, since it caused a significant\n+  number of regressions.\n+\n+  RM References:  3.09.03 (8)   3.09.03 (10)   6.05 (8/2)\n+\n+.. index:: AI-0070 (Ada 2012 feature)\n+\n+* *AI-0070 Elaboration of interface types (0000-00-00)*\n+\n+  This is an editorial change only, there are no testable consequences short of\n+  checking for the absence of generated code for an interface declaration.\n+\n+  RM References:  3.09.04 (18/2)\n+\n+.. index:: AI-0208 (Ada 2012 feature)\n+\n+* *AI-0208 Characteristics of incomplete views (0000-00-00)*\n+\n+  The wording in the Ada 2005 RM concerning characteristics of incomplete views\n+  was incorrect and implied that some programs intended to be legal were now\n+  illegal. GNAT had never considered such programs illegal, so it has always\n+  implemented the intent of this AI.\n+\n+  RM References:  3.10.01 (2.4/2)   3.10.01 (2.6/2)\n+\n+.. index:: AI-0162 (Ada 2012 feature)\n+\n+* *AI-0162 Incomplete type completed by partial view (2010-09-15)*\n+\n+  Incomplete types are made more useful by allowing them to be completed by\n+  private types and private extensions.\n+\n+  RM References:  3.10.01 (2.5/2)   3.10.01 (2.6/2)   3.10.01 (3)   3.10.01 (4/2)\n+\n+.. index:: AI-0098 (Ada 2012 feature)\n+\n+* *AI-0098 Anonymous subprogram access restrictions (0000-00-00)*\n+\n+  An unintentional omission in the RM implied some inconsistent restrictions on\n+  the use of anonymous access to subprogram values. These restrictions were not\n+  intentional, and have never been enforced by GNAT.\n+\n+  RM References:  3.10.01 (6)   3.10.01 (9.2/2)\n+\n+.. index:: AI-0199 (Ada 2012 feature)\n+\n+* *AI-0199 Aggregate with anonymous access components (2010-07-14)*\n+\n+  A choice list in a record aggregate can include several components of\n+  (distinct) anonymous access types as long as they have matching designated\n+  subtypes.\n+\n+  RM References:  4.03.01 (16)\n+\n+.. index:: AI-0220 (Ada 2012 feature)\n+\n+* *AI-0220 Needed components for aggregates (0000-00-00)*\n+\n+  This AI addresses a wording problem in the RM that appears to permit some\n+  complex cases of aggregates with non-static discriminants. GNAT has always\n+  implemented the intended semantics.\n+\n+  RM References:  4.03.01 (17)\n+\n+.. index:: AI-0147 (Ada 2012 feature)\n+\n+* *AI-0147 Conditional expressions (2009-03-29)*\n+\n+  Conditional expressions are permitted. The form of such an expression is:\n+\n+  ::\n+\n+        (if expr then expr {elsif expr then expr} [else expr])\n+    \n+  The parentheses can be omitted in contexts where parentheses are present\n+  anyway, such as subprogram arguments and pragma arguments. If the **else**\n+  clause is omitted, **else** *True* is assumed;\n+  thus ``(if A then B)`` is a way to conveniently represent\n+  *(A implies B)* in standard logic.\n+\n+  RM References:  4.03.03 (15)   4.04 (1)   4.04 (7)   4.05.07 (0)   4.07 (2)\n+  4.07 (3)   4.09 (12)   4.09 (33)   5.03 (3)   5.03 (4)   7.05 (2.1/2)\n+\n+.. index:: AI-0037 (Ada 2012 feature)\n+\n+* *AI-0037 Out-of-range box associations in aggregate (0000-00-00)*\n+\n+  This AI confirms that an association of the form `Indx => <>` in an\n+  array aggregate must raise `Constraint_Error` if `Indx`\n+  is out of range. The RM specified a range check on other associations, but\n+  not when the value of the association was defaulted. GNAT has always inserted\n+  a constraint check on the index value.\n+\n+  RM References:  4.03.03 (29)\n+\n+.. index:: AI-0123 (Ada 2012 feature)\n+\n+* *AI-0123 Composability of equality (2010-04-13)*\n+\n+  Equality of untagged record composes, so that the predefined equality for a\n+  composite type that includes a component of some untagged record type\n+  `R` uses the equality operation of `R` (which may be user-defined\n+  or predefined). This makes the behavior of untagged records identical to that\n+  of tagged types in this respect.\n+\n+  This change is an incompatibility with previous versions of Ada, but it\n+  corrects a non-uniformity that was often a source of confusion. Analysis of\n+  a large number of industrial programs indicates that in those rare cases\n+  where a composite type had an untagged record component with a user-defined\n+  equality, either there was no use of the composite equality, or else the code\n+  expected the same composability as for tagged types, and thus had a bug that\n+  would be fixed by this change.\n+\n+  RM References:  4.05.02 (9.7/2)   4.05.02 (14)   4.05.02 (15)   4.05.02 (24)\n+  8.05.04 (8)\n+\n+.. index:: AI-0088 (Ada 2012 feature)\n+\n+* *AI-0088 The value of exponentiation (0000-00-00)*\n+\n+  This AI clarifies the equivalence rule given for the dynamic semantics of\n+  exponentiation: the value of the operation can be obtained by repeated\n+  multiplication, but the operation can be implemented otherwise (for example\n+  using the familiar divide-by-two-and-square algorithm, even if this is less\n+  accurate), and does not imply repeated reads of a volatile base.\n+\n+  RM References:  4.05.06 (11)\n+\n+.. index:: AI-0188 (Ada 2012 feature)\n+\n+* *AI-0188 Case expressions (2010-01-09)*\n+\n+  Case expressions are permitted. This allows use of constructs such as:\n+\n+  .. code-block:: ada\n+\n+      X := (case Y is when 1 => 2, when 2 => 3, when others => 31)\n+    \n+  RM References:  4.05.07 (0)   4.05.08 (0)   4.09 (12)   4.09 (33)\n+\n+.. index:: AI-0104 (Ada 2012 feature)\n+\n+* *AI-0104 Null exclusion and uninitialized allocator (2010-07-15)*\n+\n+  The assignment ``Ptr := new not null Some_Ptr;`` will raise\n+  ``Constraint_Error`` because the default value of the allocated object is\n+  **null**. This useless construct is illegal in Ada 2012.\n+\n+  RM References:  4.08 (2)\n+\n+.. index:: AI-0157 (Ada 2012 feature)\n+\n+* *AI-0157 Allocation/Deallocation from empty pool (2010-07-11)*\n+\n+  Allocation and Deallocation from an empty storage pool (i.e. allocation or\n+  deallocation of a pointer for which a static storage size clause of zero\n+  has been given) is now illegal and is detected as such. GNAT\n+  previously gave a warning but not an error.\n+\n+  RM References:  4.08 (5.3/2)   13.11.02 (4)   13.11.02 (17)\n+\n+.. index:: AI-0179 (Ada 2012 feature)\n+\n+* *AI-0179 Statement not required after label (2010-04-10)*\n+\n+  It is not necessary to have a statement following a label, so a label\n+  can appear at the end of a statement sequence without the need for putting a\n+  null statement afterwards, but it is not allowable to have only labels and\n+  no real statements in a statement sequence.\n+\n+  RM References:  5.01 (2)\n+\n+.. index:: AI-0139-2 (Ada 2012 feature)\n+\n+* *AI-0139-2 Syntactic sugar for iterators (2010-09-29)*\n+\n+  The new syntax for iterating over arrays and containers is now implemented.\n+  Iteration over containers is for now limited to read-only iterators. Only\n+  default iterators are supported, with the syntax:  `for Elem of C`.\n+\n+  RM References:  5.05\n+\n+.. index:: AI-0134 (Ada 2012 feature)\n+\n+* *AI-0134 Profiles must match for full conformance (0000-00-00)*\n+\n+  For full conformance, the profiles of anonymous-access-to-subprogram\n+  parameters must match. GNAT has always enforced this rule.\n+\n+  RM References:  6.03.01 (18)\n+\n+.. index:: AI-0207 (Ada 2012 feature)\n+\n+* *AI-0207 Mode conformance and access constant (0000-00-00)*\n+\n+  This AI confirms that access_to_constant indication must match for mode\n+  conformance. This was implemented in GNAT when the qualifier was originally\n+  introduced in Ada 2005.\n+\n+  RM References:  6.03.01 (16/2)\n+\n+.. index:: AI-0046 (Ada 2012 feature)\n+\n+* *AI-0046 Null exclusion match for full conformance (2010-07-17)*\n+\n+  For full conformance, in the case of access parameters, the null exclusion\n+  must match (either both or neither must have ``not null``).\n+\n+  RM References:  6.03.02 (18)\n+\n+.. index:: AI-0118 (Ada 2012 feature)\n+\n+* *AI-0118 The association of parameter associations (0000-00-00)*\n+\n+  This AI clarifies the rules for named associations in subprogram calls and\n+  generic instantiations. The rules have been in place since Ada 83.\n+\n+  RM References:  6.04.01 (2)   12.03 (9)\n+\n+.. index:: AI-0196 (Ada 2012 feature)\n+\n+* *AI-0196 Null exclusion tests for out parameters (0000-00-00)*\n+\n+  Null exclusion checks are not made for `**out**` parameters when\n+  evaluating the actual parameters. GNAT has never generated these checks.\n+\n+  RM References:  6.04.01 (13)\n+\n+.. index:: AI-0015 (Ada 2012 feature)\n+\n+* *AI-0015 Constant return objects (0000-00-00)*\n+\n+  The return object declared in an *extended_return_statement* may be\n+  declared constant. This was always intended, and GNAT has always allowed it.\n+\n+  RM References:  6.05 (2.1/2)   3.03 (10/2)   3.03 (21)   6.05 (5/2)\n+  6.05 (5.7/2)\n+\n+.. index:: AI-0032 (Ada 2012 feature)\n+\n+* *AI-0032 Extended return for class-wide functions (0000-00-00)*\n+\n+  If a function returns a class-wide type, the object of an extended return\n+  statement can be declared with a specific type that is covered by the class-\n+  wide type. This has been implemented in GNAT since the introduction of\n+  extended returns. Note AI-0103 complements this AI by imposing matching\n+  rules for constrained return types.\n+\n+  RM References:  6.05 (5.2/2)   6.05 (5.3/2)   6.05 (5.6/2)   6.05 (5.8/2)\n+  6.05 (8/2)\n+\n+.. index:: AI-0103 (Ada 2012 feature)\n+\n+* *AI-0103 Static matching for extended return (2010-07-23)*\n+\n+  If the return subtype of a function is an elementary type or a constrained\n+  type, the subtype indication in an extended return statement must match\n+  statically this return subtype.\n+\n+  RM References:  6.05 (5.2/2)\n+\n+.. index:: AI-0058 (Ada 2012 feature)\n+\n+* *AI-0058 Abnormal completion of an extended return (0000-00-00)*\n+\n+  The RM had some incorrect wording implying wrong treatment of abnormal\n+  completion in an extended return. GNAT has always implemented the intended\n+  correct semantics as described by this AI.\n+\n+  RM References:  6.05 (22/2)\n+\n+.. index:: AI-0050 (Ada 2012 feature)\n+\n+* *AI-0050 Raising Constraint_Error early for function call (0000-00-00)*\n+\n+  The implementation permissions for raising `Constraint_Error` early on a function call\n+  when it was clear an exception would be raised were over-permissive and allowed\n+  mishandling of discriminants in some cases. GNAT did\n+  not take advantage of these incorrect permissions in any case.\n+\n+  RM References:  6.05 (24/2)\n+\n+.. index:: AI-0125 (Ada 2012 feature)\n+\n+* *AI-0125 Nonoverridable operations of an ancestor (2010-09-28)*\n+\n+  In Ada 2012, the declaration of a primitive operation of a type extension\n+  or private extension can also override an inherited primitive that is not\n+  visible at the point of this declaration.\n+\n+  RM References:  7.03.01 (6)   8.03 (23)   8.03.01 (5/2)   8.03.01 (6/2)\n+\n+.. index:: AI-0062 (Ada 2012 feature)\n+\n+* *AI-0062 Null exclusions and deferred constants (0000-00-00)*\n+\n+  A full constant may have a null exclusion even if its associated deferred\n+  constant does not. GNAT has always allowed this.\n+\n+  RM References:  7.04 (6/2)   7.04 (7.1/2)\n+\n+.. index:: AI-0178 (Ada 2012 feature)\n+\n+* *AI-0178 Incomplete views are limited (0000-00-00)*\n+\n+  This AI clarifies the role of incomplete views and plugs an omission in the\n+  RM. GNAT always correctly restricted the use of incomplete views and types.\n+\n+  RM References:  7.05 (3/2)   7.05 (6/2)\n+\n+.. index:: AI-0087 (Ada 2012 feature)\n+\n+* *AI-0087 Actual for formal nonlimited derived type (2010-07-15)*\n+\n+  The actual for a formal nonlimited derived type cannot be limited. In\n+  particular, a formal derived type that extends a limited interface but which\n+  is not explicitly limited cannot be instantiated with a limited type.\n+\n+  RM References:  7.05 (5/2)   12.05.01 (5.1/2)\n+\n+.. index:: AI-0099 (Ada 2012 feature)\n+\n+* *AI-0099 Tag determines whether finalization needed (0000-00-00)*\n+\n+  This AI clarifies that 'needs finalization' is part of dynamic semantics,\n+  and therefore depends on the run-time characteristics of an object (i.e. its\n+  tag) and not on its nominal type. As the AI indicates: \"we do not expect\n+  this to affect any implementation''.\n+\n+  RM References:  7.06.01 (6)   7.06.01 (7)   7.06.01 (8)   7.06.01 (9/2)\n+\n+.. index:: AI-0064 (Ada 2012 feature)\n+\n+* *AI-0064 Redundant finalization rule (0000-00-00)*\n+\n+  This is an editorial change only. The intended behavior is already checked\n+  by an existing ACATS test, which GNAT has always executed correctly.\n+\n+  RM References:  7.06.01 (17.1/1)\n+\n+.. index:: AI-0026 (Ada 2012 feature)\n+\n+* *AI-0026 Missing rules for Unchecked_Union (2010-07-07)*\n+\n+  Record representation clauses concerning Unchecked_Union types cannot mention\n+  the discriminant of the type. The type of a component declared in the variant\n+  part of an Unchecked_Union cannot be controlled, have controlled components,\n+  nor have protected or task parts. If an Unchecked_Union type is declared\n+  within the body of a generic unit or its descendants, then the type of a\n+  component declared in the variant part cannot be a formal private type or a\n+  formal private extension declared within the same generic unit.\n+\n+  RM References:  7.06 (9.4/2)   B.03.03 (9/2)   B.03.03 (10/2)\n+\n+.. index:: AI-0205 (Ada 2012 feature)\n+\n+* *AI-0205 Extended return declares visible name (0000-00-00)*\n+\n+  This AI corrects a simple omission in the RM. Return objects have always\n+  been visible within an extended return statement.\n+\n+  RM References:  8.03 (17)\n+\n+.. index:: AI-0042 (Ada 2012 feature)\n+\n+* *AI-0042 Overriding versus implemented-by (0000-00-00)*\n+\n+  This AI fixes a wording gap in the RM. An operation of a synchronized\n+  interface can be implemented by a protected or task entry, but the abstract\n+  operation is not being overridden in the usual sense, and it must be stated\n+  separately that this implementation is legal. This has always been the case\n+  in GNAT.\n+\n+  RM References:  9.01 (9.2/2)   9.04 (11.1/2)\n+\n+.. index:: AI-0030 (Ada 2012 feature)\n+\n+* *AI-0030 Requeue on synchronized interfaces (2010-07-19)*\n+\n+  Requeue is permitted to a protected, synchronized or task interface primitive\n+  providing it is known that the overriding operation is an entry. Otherwise\n+  the requeue statement has the same effect as a procedure call. Use of pragma\n+  `Implemented` provides a way to impose a static requirement on the\n+  overriding operation by adhering to one of the implementation kinds: entry,\n+  protected procedure or any of the above.\n+\n+  RM References:  9.05 (9)   9.05.04 (2)   9.05.04 (3)   9.05.04 (5)\n+  9.05.04 (6)   9.05.04 (7)   9.05.04 (12)\n+\n+.. index:: AI-0201 (Ada 2012 feature)\n+\n+* *AI-0201 Independence of atomic object components (2010-07-22)*\n+\n+  If an Atomic object has a pragma `Pack` or a `Component_Size`\n+  attribute, then individual components may not be addressable by independent\n+  tasks. However, if the representation clause has no effect (is confirming),\n+  then independence is not compromised. Furthermore, in GNAT, specification of\n+  other appropriately addressable component sizes (e.g. 16 for 8-bit\n+  characters) also preserves independence. GNAT now gives very clear warnings\n+  both for the declaration of such a type, and for any assignment to its components.\n+\n+  RM References:  9.10 (1/3)   C.06 (22/2)   C.06 (23/2)\n+\n+.. index:: AI-0009 (Ada 2012 feature)\n+\n+* *AI-0009 Pragma Independent[_Components] (2010-07-23)*\n+\n+  This AI introduces the new pragmas `Independent` and\n+  `Independent_Components`,\n+  which control guaranteeing independence of access to objects and components.\n+  The AI also requires independence not unaffected by confirming rep clauses.\n+\n+  RM References:  9.10 (1)   13.01 (15/1)   13.02 (9)   13.03 (13)   C.06 (2)\n+  C.06 (4)   C.06 (6)   C.06 (9)   C.06 (13)   C.06 (14)\n+\n+.. index:: AI-0072 (Ada 2012 feature)\n+\n+* *AI-0072 Task signalling using 'Terminated (0000-00-00)*\n+\n+  This AI clarifies that task signalling for reading `'Terminated` only\n+  occurs if the result is True. GNAT semantics has always been consistent with\n+  this notion of task signalling.\n+\n+  RM References:  9.10 (6.1/1)\n+\n+.. index:: AI-0108 (Ada 2012 feature)\n+\n+* *AI-0108 Limited incomplete view and discriminants (0000-00-00)*\n+\n+  This AI confirms that an incomplete type from a limited view does not have\n+  discriminants. This has always been the case in GNAT.\n+\n+  RM References:  10.01.01 (12.3/2)\n+\n+.. index:: AI-0129 (Ada 2012 feature)\n+\n+* *AI-0129 Limited views and incomplete types (0000-00-00)*\n+\n+  This AI clarifies the description of limited views: a limited view of a\n+  package includes only one view of a type that has an incomplete declaration\n+  and a full declaration (there is no possible ambiguity in a client package).\n+  This AI also fixes an omission: a nested package in the private part has no\n+  limited view. GNAT always implemented this correctly.\n+\n+  RM References:  10.01.01 (12.2/2)   10.01.01 (12.3/2)\n+\n+.. index:: AI-0077 (Ada 2012 feature)\n+\n+* *AI-0077 Limited withs and scope of declarations (0000-00-00)*\n+\n+  This AI clarifies that a declaration does not include a context clause,\n+  and confirms that it is illegal to have a context in which both a limited\n+  and a nonlimited view of a package are accessible. Such double visibility\n+  was always rejected by GNAT.\n+\n+  RM References:  10.01.02 (12/2)   10.01.02 (21/2)   10.01.02 (22/2)\n+\n+.. index:: AI-0122 (Ada 2012 feature)\n+\n+* *AI-0122 Private with and children of generics (0000-00-00)*\n+\n+  This AI clarifies the visibility of private children of generic units within\n+  instantiations of a parent. GNAT has always handled this correctly.\n+\n+  RM References:  10.01.02 (12/2)\n+\n+.. index:: AI-0040 (Ada 2012 feature)\n+\n+* *AI-0040 Limited with clauses on descendant (0000-00-00)*\n+\n+  This AI confirms that a limited with clause in a child unit cannot name\n+  an ancestor of the unit. This has always been checked in GNAT.\n+\n+  RM References:  10.01.02 (20/2)\n+\n+.. index:: AI-0132 (Ada 2012 feature)\n+\n+* *AI-0132 Placement of library unit pragmas (0000-00-00)*\n+\n+  This AI fills a gap in the description of library unit pragmas. The pragma\n+  clearly must apply to a library unit, even if it does not carry the name\n+  of the enclosing unit. GNAT has always enforced the required check.\n+\n+  RM References:  10.01.05 (7)\n+\n+.. index:: AI-0034 (Ada 2012 feature)\n+\n+* *AI-0034 Categorization of limited views (0000-00-00)*\n+\n+  The RM makes certain limited with clauses illegal because of categorization\n+  considerations, when the corresponding normal with would be legal. This is\n+  not intended, and GNAT has always implemented the recommended behavior.\n+\n+  RM References:  10.02.01 (11/1)   10.02.01 (17/2)\n+\n+.. index:: AI-0035 (Ada 2012 feature)\n+\n+* *AI-0035 Inconsistencies with Pure units (0000-00-00)*\n+\n+  This AI remedies some inconsistencies in the legality rules for Pure units.\n+  Derived access types are legal in a pure unit (on the assumption that the\n+  rule for a zero storage pool size has been enforced on the ancestor type).\n+  The rules are enforced in generic instances and in subunits. GNAT has always\n+  implemented the recommended behavior.\n+\n+  RM References:  10.02.01 (15.1/2)   10.02.01 (15.4/2)   10.02.01 (15.5/2)   10.02.01 (17/2)\n+\n+.. index:: AI-0219 (Ada 2012 feature)\n+\n+* *AI-0219 Pure permissions and limited parameters (2010-05-25)*\n+\n+  This AI refines the rules for the cases with limited parameters which do not\n+  allow the implementations to omit 'redundant'. GNAT now properly conforms\n+  to the requirements of this binding interpretation.\n+\n+  RM References:  10.02.01 (18/2)\n+\n+.. index:: AI-0043 (Ada 2012 feature)\n+\n+* *AI-0043 Rules about raising exceptions (0000-00-00)*\n+\n+  This AI covers various omissions in the RM regarding the raising of\n+  exceptions. GNAT has always implemented the intended semantics.\n+\n+  RM References:  11.04.01 (10.1/2)   11 (2)\n+\n+.. index:: AI-0200 (Ada 2012 feature)\n+\n+* *AI-0200 Mismatches in formal package declarations (0000-00-00)*\n+\n+  This AI plugs a gap in the RM which appeared to allow some obviously intended\n+  illegal instantiations. GNAT has never allowed these instantiations.\n+\n+  RM References:  12.07 (16)\n+\n+.. index:: AI-0112 (Ada 2012 feature)\n+\n+* *AI-0112 Detection of duplicate pragmas (2010-07-24)*\n+\n+  This AI concerns giving names to various representation aspects, but the\n+  practical effect is simply to make the use of duplicate\n+  `Atomic[_Components]`,\n+  `Volatile[_Components]`, and\n+  `Independent[_Components]` pragmas illegal, and GNAT\n+  now performs this required check.\n+\n+  RM References:  13.01 (8)\n+\n+.. index:: AI-0106 (Ada 2012 feature)\n+\n+* *AI-0106 No representation pragmas on generic formals (0000-00-00)*\n+\n+  The RM appeared to allow representation pragmas on generic formal parameters,\n+  but this was not intended, and GNAT has never permitted this usage.\n+\n+  RM References:  13.01 (9.1/1)\n+\n+.. index:: AI-0012 (Ada 2012 feature)\n+\n+* *AI-0012 Pack/Component_Size for aliased/atomic (2010-07-15)*\n+\n+  It is now illegal to give an inappropriate component size or a pragma\n+  `Pack` that attempts to change the component size in the case of atomic\n+  or aliased components. Previously GNAT ignored such an attempt with a\n+  warning.\n+\n+  RM References:  13.02 (6.1/2)   13.02 (7)   C.06 (10)   C.06 (11)   C.06 (21)\n+\n+.. index:: AI-0039 (Ada 2012 feature)\n+\n+* *AI-0039 Stream attributes cannot be dynamic (0000-00-00)*\n+\n+  The RM permitted the use of dynamic expressions (such as ``ptr.all``)`\n+  for stream attributes, but these were never useful and are now illegal. GNAT\n+  has always regarded such expressions as illegal.\n+\n+  RM References:  13.03 (4)   13.03 (6)   13.13.02 (38/2)\n+\n+.. index:: AI-0095 (Ada 2012 feature)\n+\n+* *AI-0095 Address of intrinsic subprograms (0000-00-00)*\n+\n+  The prefix of `'Address` cannot statically denote a subprogram with\n+  convention `Intrinsic`. The use of the `Address` attribute raises\n+  `Program_Error` if the prefix denotes a subprogram with convention\n+  `Intrinsic`.\n+\n+  RM References:  13.03 (11/1)\n+\n+.. index:: AI-0116 (Ada 2012 feature)\n+\n+* *AI-0116 Alignment of class-wide objects (0000-00-00)*\n+\n+  This AI requires that the alignment of a class-wide object be no greater\n+  than the alignment of any type in the class. GNAT has always followed this\n+  recommendation.\n+\n+  RM References:  13.03 (29)   13.11 (16)\n+\n+.. index:: AI-0146 (Ada 2012 feature)\n+\n+* *AI-0146 Type invariants (2009-09-21)*\n+\n+  Type invariants may be specified for private types using the aspect notation.\n+  Aspect `Type_Invariant` may be specified for any private type,\n+  `Type_Invariant'Class` can\n+  only be specified for tagged types, and is inherited by any descendent of the\n+  tagged types. The invariant is a boolean expression that is tested for being\n+  true in the following situations: conversions to the private type, object\n+  declarations for the private type that are default initialized, and\n+  [**in**] **out**\n+  parameters and returned result on return from any primitive operation for\n+  the type that is visible to a client.\n+  GNAT defines the synonyms `Invariant` for `Type_Invariant` and\n+  `Invariant'Class` for `Type_Invariant'Class`.\n+\n+  RM References:  13.03.03 (00)\n+\n+.. index:: AI-0078 (Ada 2012 feature)\n+\n+* *AI-0078 Relax Unchecked_Conversion alignment rules (0000-00-00)*\n+\n+  In Ada 2012, compilers are required to support unchecked conversion where the\n+  target alignment is a multiple of the source alignment. GNAT always supported\n+  this case (and indeed all cases of differing alignments, doing copies where\n+  required if the alignment was reduced).\n+\n+  RM References:  13.09 (7)\n+\n+.. index:: AI-0195 (Ada 2012 feature)\n+\n+* *AI-0195 Invalid value handling is implementation defined (2010-07-03)*\n+\n+  The handling of invalid values is now designated to be implementation\n+  defined. This is a documentation change only, requiring Annex M in the GNAT\n+  Reference Manual to document this handling.\n+  In GNAT, checks for invalid values are made\n+  only when necessary to avoid erroneous behavior. Operations like assignments\n+  which cannot cause erroneous behavior ignore the possibility of invalid\n+  values and do not do a check. The date given above applies only to the\n+  documentation change, this behavior has always been implemented by GNAT.\n+\n+  RM References:  13.09.01 (10)\n+\n+.. index:: AI-0193 (Ada 2012 feature)\n+\n+* *AI-0193 Alignment of allocators (2010-09-16)*\n+\n+  This AI introduces a new attribute `Max_Alignment_For_Allocation`,\n+  analogous to `Max_Size_In_Storage_Elements`, but for alignment instead\n+  of size.\n+\n+  RM References:  13.11 (16)   13.11 (21)   13.11.01 (0)   13.11.01 (1)\n+  13.11.01 (2)   13.11.01 (3)\n+\n+.. index:: AI-0177 (Ada 2012 feature)\n+\n+* *AI-0177 Parameterized expressions (2010-07-10)*\n+\n+  The new Ada 2012 notion of parameterized expressions is implemented. The form\n+  is:\n+\n+  .. code-block:: ada\n+\n+     function-specification is (expression)\n+\n+  This is exactly equivalent to the\n+  corresponding function body that returns the expression, but it can appear\n+  in a package spec. Note that the expression must be parenthesized.\n+\n+  RM References:  13.11.01 (3/2)\n+\n+.. index:: AI-0033 (Ada 2012 feature)\n+\n+* *AI-0033 Attach/Interrupt_Handler in generic (2010-07-24)*\n+\n+  Neither of these two pragmas may appear within a generic template, because\n+  the generic might be instantiated at other than the library level.\n+\n+  RM References:  13.11.02 (16)   C.03.01 (7/2)   C.03.01 (8/2)\n+\n+.. index:: AI-0161 (Ada 2012 feature)\n+\n+* *AI-0161 Restriction No_Default_Stream_Attributes (2010-09-11)*\n+\n+  A new restriction `No_Default_Stream_Attributes` prevents the use of any\n+  of the default stream attributes for elementary types. If this restriction is\n+  in force, then it is necessary to provide explicit subprograms for any\n+  stream attributes used.\n+\n+  RM References:  13.12.01 (4/2)   13.13.02 (40/2)   13.13.02 (52/2)\n+\n+.. index:: AI-0194 (Ada 2012 feature)\n+\n+* *AI-0194 Value of Stream_Size attribute (0000-00-00)*\n+\n+  The `Stream_Size` attribute returns the default number of bits in the\n+  stream representation of the given type.\n+  This value is not affected by the presence\n+  of stream subprogram attributes for the type. GNAT has always implemented\n+  this interpretation.\n+\n+  RM References:  13.13.02 (1.2/2)\n+\n+.. index:: AI-0109 (Ada 2012 feature)\n+\n+* *AI-0109 Redundant check in S'Class'Input (0000-00-00)*\n+\n+  This AI is an editorial change only. It removes the need for a tag check\n+  that can never fail.\n+\n+  RM References:  13.13.02 (34/2)\n+\n+.. index:: AI-0007 (Ada 2012 feature)\n+\n+* *AI-0007 Stream read and private scalar types (0000-00-00)*\n+\n+  The RM as written appeared to limit the possibilities of declaring read\n+  attribute procedures for private scalar types. This limitation was not\n+  intended, and has never been enforced by GNAT.\n+\n+  RM References:  13.13.02 (50/2)   13.13.02 (51/2)\n+\n+.. index:: AI-0065 (Ada 2012 feature)\n+\n+* *AI-0065 Remote access types and external streaming (0000-00-00)*\n+\n+  This AI clarifies the fact that all remote access types support external\n+  streaming. This fixes an obvious oversight in the definition of the\n+  language, and GNAT always implemented the intended correct rules.\n+\n+  RM References:  13.13.02 (52/2)\n+\n+.. index:: AI-0019 (Ada 2012 feature)\n+\n+* *AI-0019 Freezing of primitives for tagged types (0000-00-00)*\n+\n+  The RM suggests that primitive subprograms of a specific tagged type are\n+  frozen when the tagged type is frozen. This would be an incompatible change\n+  and is not intended. GNAT has never attempted this kind of freezing and its\n+  behavior is consistent with the recommendation of this AI.\n+\n+  RM References:  13.14 (2)   13.14 (3/1)   13.14 (8.1/1)   13.14 (10)   13.14 (14)   13.14 (15.1/2)\n+\n+.. index:: AI-0017 (Ada 2012 feature)\n+\n+* *AI-0017 Freezing and incomplete types (0000-00-00)*\n+\n+  So-called 'Taft-amendment types' (i.e., types that are completed in package\n+  bodies) are not frozen by the occurrence of bodies in the\n+  enclosing declarative part. GNAT always implemented this properly.\n+\n+  RM References:  13.14 (3/1)\n+\n+.. index:: AI-0060 (Ada 2012 feature)\n+\n+* *AI-0060 Extended definition of remote access types (0000-00-00)*\n+\n+  This AI extends the definition of remote access types to include access\n+  to limited, synchronized, protected or task class-wide interface types.\n+  GNAT already implemented this extension.\n+\n+  RM References:  A (4)   E.02.02 (9/1)   E.02.02 (9.2/1)   E.02.02 (14/2)   E.02.02 (18)\n+\n+.. index:: AI-0114 (Ada 2012 feature)\n+\n+* *AI-0114 Classification of letters (0000-00-00)*\n+\n+  The code points 170 (`FEMININE ORDINAL INDICATOR`),\n+  181 (`MICRO SIGN`), and\n+  186 (`MASCULINE ORDINAL INDICATOR`) are technically considered\n+  lower case letters by Unicode.\n+  However, they are not allowed in identifiers, and they\n+  return `False` to `Ada.Characters.Handling.Is_Letter/Is_Lower`.\n+  This behavior is consistent with that defined in Ada 95.\n+\n+  RM References:  A.03.02 (59)   A.04.06 (7)\n+\n+.. index:: AI-0185 (Ada 2012 feature)\n+\n+* *AI-0185 Ada.Wide_[Wide_]Characters.Handling (2010-07-06)*\n+\n+  Two new packages `Ada.Wide_[Wide_]Characters.Handling` provide\n+  classification functions for `Wide_Character` and\n+  `Wide_Wide_Character`, as well as providing\n+  case folding routines for `Wide_[Wide_]Character` and\n+  `Wide_[Wide_]String`.\n+\n+  RM References:  A.03.05 (0)   A.03.06 (0)\n+\n+.. index:: AI-0031 (Ada 2012 feature)\n+\n+* *AI-0031 Add From parameter to Find_Token (2010-07-25)*\n+\n+  A new version of `Find_Token` is added to all relevant string packages,\n+  with an extra parameter `From`. Instead of starting at the first\n+  character of the string, the search for a matching Token starts at the\n+  character indexed by the value of `From`.\n+  These procedures are available in all versions of Ada\n+  but if used in versions earlier than Ada 2012 they will generate a warning\n+  that an Ada 2012 subprogram is being used.\n+\n+  RM References:  A.04.03 (16)   A.04.03 (67)   A.04.03 (68/1)   A.04.04 (51)\n+  A.04.05 (46)\n+\n+.. index:: AI-0056 (Ada 2012 feature)\n+\n+* *AI-0056 Index on null string returns zero (0000-00-00)*\n+\n+  The wording in the Ada 2005 RM implied an incompatible handling of the\n+  `Index` functions, resulting in raising an exception instead of\n+  returning zero in some situations.\n+  This was not intended and has been corrected.\n+  GNAT always returned zero, and is thus consistent with this AI.\n+\n+  RM References:  A.04.03 (56.2/2)   A.04.03 (58.5/2)\n+\n+.. index:: AI-0137 (Ada 2012 feature)\n+\n+* *AI-0137 String encoding package (2010-03-25)*\n+\n+  The packages `Ada.Strings.UTF_Encoding`, together with its child\n+  packages, `Conversions`, `Strings`, `Wide_Strings`,\n+  and `Wide_Wide_Strings` have been\n+  implemented. These packages (whose documentation can be found in the spec\n+  files :file:`a-stuten.ads`, :file:`a-suenco.ads`, :file:`a-suenst.ads`,\n+  :file:`a-suewst.ads`, :file:`a-suezst.ads`) allow encoding and decoding of\n+  `String`, `Wide_String`, and `Wide_Wide_String`\n+  values using UTF coding schemes (including UTF-8, UTF-16LE, UTF-16BE, and\n+  UTF-16), as well as conversions between the different UTF encodings. With\n+  the exception of `Wide_Wide_Strings`, these packages are available in\n+  Ada 95 and Ada 2005 mode as well as Ada 2012 mode.\n+  The `Wide_Wide_Strings package`\n+  is available in Ada 2005 mode as well as Ada 2012 mode (but not in Ada 95\n+  mode since it uses `Wide_Wide_Character`).\n+\n+  RM References:  A.04.11\n+\n+.. index:: AI-0038 (Ada 2012 feature)\n+\n+* *AI-0038 Minor errors in Text_IO (0000-00-00)*\n+\n+  These are minor errors in the description on three points. The intent on\n+  all these points has always been clear, and GNAT has always implemented the\n+  correct intended semantics.\n+\n+  RM References:  A.10.05 (37)   A.10.07 (8/1)   A.10.07 (10)   A.10.07 (12)   A.10.08 (10)   A.10.08 (24)\n+\n+.. index:: AI-0044 (Ada 2012 feature)\n+\n+* *AI-0044 Restrictions on container instantiations (0000-00-00)*\n+\n+  This AI places restrictions on allowed instantiations of generic containers.\n+  These restrictions are not checked by the compiler, so there is nothing to\n+  change in the implementation. This affects only the RM documentation.\n+\n+  RM References:  A.18 (4/2)   A.18.02 (231/2)   A.18.03 (145/2)   A.18.06 (56/2)   A.18.08 (66/2)   A.18.09 (79/2)   A.18.26 (5/2)   A.18.26 (9/2)\n+\n+.. index:: AI-0127 (Ada 2012 feature)\n+\n+* *AI-0127 Adding Locale Capabilities (2010-09-29)*\n+\n+  This package provides an interface for identifying the current locale.\n+\n+  RM References:  A.19    A.19.01    A.19.02    A.19.03    A.19.05    A.19.06\n+  A.19.07    A.19.08    A.19.09    A.19.10    A.19.11    A.19.12    A.19.13\n+\n+.. index:: AI-0002 (Ada 2012 feature)\n+\n+* *AI-0002 Export C with unconstrained arrays (0000-00-00)*\n+\n+  The compiler is not required to support exporting an Ada subprogram with\n+  convention C if there are parameters or a return type of an unconstrained\n+  array type (such as `String`). GNAT allows such declarations but\n+  generates warnings. It is possible, but complicated, to write the\n+  corresponding C code and certainly such code would be specific to GNAT and\n+  non-portable.\n+\n+  RM References:  B.01 (17)   B.03 (62)   B.03 (71.1/2)\n+\n+.. index:: AI05-0216 (Ada 2012 feature)\n+\n+* *AI-0216 No_Task_Hierarchy forbids local tasks (0000-00-00)*\n+\n+  It is clearly the intention that `No_Task_Hierarchy` is intended to\n+  forbid tasks declared locally within subprograms, or functions returning task\n+  objects, and that is the implementation that GNAT has always provided.\n+  However the language in the RM was not sufficiently clear on this point.\n+  Thus this is a documentation change in the RM only.\n+\n+  RM References:  D.07 (3/3)\n+\n+.. index:: AI-0211 (Ada 2012 feature)\n+\n+* *AI-0211 No_Relative_Delays forbids Set_Handler use (2010-07-09)*\n+\n+  The restriction `No_Relative_Delays` forbids any calls to the subprogram\n+  `Ada.Real_Time.Timing_Events.Set_Handler`.\n+\n+  RM References:  D.07 (5)   D.07 (10/2)   D.07 (10.4/2)   D.07 (10.7/2)\n+\n+.. index:: AI-0190 (Ada 2012 feature)\n+\n+* *AI-0190 pragma Default_Storage_Pool (2010-09-15)*\n+\n+  This AI introduces a new pragma `Default_Storage_Pool`, which can be\n+  used to control storage pools globally.\n+  In particular, you can force every access\n+  type that is used for allocation (**new**) to have an explicit storage pool,\n+  or you can declare a pool globally to be used for all access types that lack\n+  an explicit one.\n+\n+  RM References:  D.07 (8)\n+\n+.. index:: AI-0189 (Ada 2012 feature)\n+\n+* *AI-0189 No_Allocators_After_Elaboration (2010-01-23)*\n+\n+  This AI introduces a new restriction `No_Allocators_After_Elaboration`,\n+  which says that no dynamic allocation will occur once elaboration is\n+  completed.\n+  In general this requires a run-time check, which is not required, and which\n+  GNAT does not attempt. But the static cases of allocators in a task body or\n+  in the body of the main program are detected and flagged at compile or bind\n+  time.\n+\n+  RM References:  D.07 (19.1/2)   H.04 (23.3/2)\n+\n+.. index:: AI-0171 (Ada 2012 feature)\n+\n+* *AI-0171 Pragma CPU and Ravenscar Profile (2010-09-24)*\n+\n+  A new package `System.Multiprocessors` is added, together with the\n+  definition of pragma `CPU` for controlling task affinity. A new no\n+  dependence restriction, on `System.Multiprocessors.Dispatching_Domains`,\n+  is added to the Ravenscar profile.\n+\n+  RM References:  D.13.01 (4/2)   D.16\n+\n+.. index:: AI-0210 (Ada 2012 feature)\n+\n+* *AI-0210 Correct Timing_Events metric (0000-00-00)*\n+\n+  This is a documentation only issue regarding wording of metric requirements,\n+  that does not affect the implementation of the compiler.\n+\n+  RM References:  D.15 (24/2)\n+\n+.. index:: AI-0206 (Ada 2012 feature)\n+\n+* *AI-0206 Remote types packages and preelaborate (2010-07-24)*\n+\n+  Remote types packages are now allowed to depend on preelaborated packages.\n+  This was formerly considered illegal.\n+\n+  RM References:  E.02.02 (6)\n+\n+.. index:: AI-0152 (Ada 2012 feature)\n+\n+* *AI-0152 Restriction No_Anonymous_Allocators (2010-09-08)*\n+\n+  Restriction `No_Anonymous_Allocators` prevents the use of allocators\n+  where the type of the returned value is an anonymous access type.\n+\n+  RM References:  H.04 (8/1)"}, {"sha": "5788929bedca7f025d315d5690d8f8d8958ca85b", "filename": "gcc/ada/doc/gnat_rm/implementation_of_specific_ada_features.rst", "status": "added", "additions": 671, "deletions": 0, "changes": 671, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_of_specific_ada_features.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_of_specific_ada_features.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_of_specific_ada_features.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,671 @@\n+.. _Implementation_of_Specific_Ada_Features:\n+\n+***************************************\n+Implementation of Specific Ada Features\n+***************************************\n+\n+This chapter describes the GNAT implementation of several Ada language\n+facilities.\n+\n+.. _Machine_Code_Insertions:\n+\n+Machine Code Insertions\n+=======================\n+\n+.. index:: Machine Code insertions\n+\n+Package `Machine_Code` provides machine code support as described\n+in the Ada Reference Manual in two separate forms:\n+\n+* \n+  Machine code statements, consisting of qualified expressions that\n+  fit the requirements of RM section 13.8.\n+* \n+  An intrinsic callable procedure, providing an alternative mechanism of\n+  including machine instructions in a subprogram.\n+\n+The two features are similar, and both are closely related to the mechanism\n+provided by the asm instruction in the GNU C compiler.  Full understanding\n+and use of the facilities in this package requires understanding the asm\n+instruction, see the section on Extended Asm in \n+:title:`Using_the_GNU_Compiler_Collection_(GCC)`.\n+\n+Calls to the function `Asm` and the procedure `Asm` have identical\n+semantic restrictions and effects as described below.  Both are provided so\n+that the procedure call can be used as a statement, and the function call\n+can be used to form a code_statement.\n+\n+Consider this C `asm` instruction:\n+\n+::\n+\n+     asm (\"fsinx %1 %0\" : \"=f\" (result) : \"f\" (angle));\n+  \n+\n+The equivalent can be written for GNAT as:\n+\n+.. code-block:: ada\n+\n+  Asm (\"fsinx %1 %0\",\n+       My_Float'Asm_Output (\"=f\", result),\n+       My_Float'Asm_Input  (\"f\",  angle));\n+  \n+\n+The first argument to `Asm` is the assembler template, and is\n+identical to what is used in GNU C.  This string must be a static\n+expression.  The second argument is the output operand list.  It is\n+either a single `Asm_Output` attribute reference, or a list of such\n+references enclosed in parentheses (technically an array aggregate of\n+such references).\n+\n+The `Asm_Output` attribute denotes a function that takes two\n+parameters.  The first is a string, the second is the name of a variable\n+of the type designated by the attribute prefix.  The first (string)\n+argument is required to be a static expression and designates the\n+constraint (see the section on Constraints in \n+:title:`Using_the_GNU_Compiler_Collection_(GCC)`)\n+for the parameter; e.g., what kind of register is required.  The second\n+argument is the variable to be written or updated with the\n+result.  The possible values for constraint are the same as those used in\n+the RTL, and are dependent on the configuration file used to build the\n+GCC back end.  If there are no output operands, then this argument may\n+either be omitted, or explicitly given as `No_Output_Operands`.\n+No support is provided for GNU C's symbolic names for output parameters.\n+\n+The second argument of ``my_float'Asm_Output`` functions as\n+though it were an `out` parameter, which is a little curious, but\n+all names have the form of expressions, so there is no syntactic\n+irregularity, even though normally functions would not be permitted\n+`out` parameters.  The third argument is the list of input\n+operands.  It is either a single `Asm_Input` attribute reference, or\n+a list of such references enclosed in parentheses (technically an array\n+aggregate of such references).\n+\n+The `Asm_Input` attribute denotes a function that takes two\n+parameters.  The first is a string, the second is an expression of the\n+type designated by the prefix.  The first (string) argument is required\n+to be a static expression, and is the constraint for the parameter,\n+(e.g., what kind of register is required).  The second argument is the\n+value to be used as the input argument.  The possible values for the\n+constraint are the same as those used in the RTL, and are dependent on\n+the configuration file used to built the GCC back end.\n+No support is provided for GNU C's symbolic names for input parameters.\n+\n+If there are no input operands, this argument may either be omitted, or\n+explicitly given as `No_Input_Operands`.  The fourth argument, not\n+present in the above example, is a list of register names, called the\n+*clobber* argument.  This argument, if given, must be a static string\n+expression, and is a space or comma separated list of names of registers\n+that must be considered destroyed as a result of the `Asm` call.  If\n+this argument is the null string (the default value), then the code\n+generator assumes that no additional registers are destroyed.\n+In addition to registers, the special clobbers `memory` and\n+`cc` as described in the GNU C docs are both supported.\n+\n+The fifth argument, not present in the above example, called the\n+*volatile* argument, is by default `False`.  It can be set to\n+the literal value `True` to indicate to the code generator that all\n+optimizations with respect to the instruction specified should be\n+suppressed, and in particular an instruction that has outputs\n+will still be generated, even if none of the outputs are\n+used.  See :title:`Using_the_GNU_Compiler_Collection_(GCC)`\n+for the full description.\n+Generally it is strongly advisable to use Volatile for any ASM statement\n+that is missing either input or output operands or to avoid unwanted\n+optimizations. A warning is generated if this advice is not followed.\n+\n+No support is provided for GNU C's `asm goto` feature.\n+\n+The `Asm` subprograms may be used in two ways.  First the procedure\n+forms can be used anywhere a procedure call would be valid, and\n+correspond to what the RM calls 'intrinsic' routines.  Such calls can\n+be used to intersperse machine instructions with other Ada statements.\n+Second, the function forms, which return a dummy value of the limited\n+private type `Asm_Insn`, can be used in code statements, and indeed\n+this is the only context where such calls are allowed.  Code statements\n+appear as aggregates of the form:\n+\n+.. code-block:: ada\n+\n+  Asm_Insn'(Asm (...));\n+  Asm_Insn'(Asm_Volatile (...));\n+  \n+In accordance with RM rules, such code statements are allowed only\n+within subprograms whose entire body consists of such statements.  It is\n+not permissible to intermix such statements with other Ada statements.\n+\n+Typically the form using intrinsic procedure calls is more convenient\n+and more flexible.  The code statement form is provided to meet the RM\n+suggestion that such a facility should be made available.  The following\n+is the exact syntax of the call to `Asm`. As usual, if named notation\n+is used, the arguments may be given in arbitrary order, following the\n+normal rules for use of positional and named arguments:\n+\n+::\n+\n+  ASM_CALL ::= Asm (\n+                   [Template =>] static_string_EXPRESSION\n+                 [,[Outputs  =>] OUTPUT_OPERAND_LIST      ]\n+                 [,[Inputs   =>] INPUT_OPERAND_LIST       ]\n+                 [,[Clobber  =>] static_string_EXPRESSION ]\n+                 [,[Volatile =>] static_boolean_EXPRESSION] )\n+\n+  OUTPUT_OPERAND_LIST ::=\n+    [PREFIX.]No_Output_Operands\n+  | OUTPUT_OPERAND_ATTRIBUTE\n+  | (OUTPUT_OPERAND_ATTRIBUTE {,OUTPUT_OPERAND_ATTRIBUTE})\n+\n+  OUTPUT_OPERAND_ATTRIBUTE ::=\n+    SUBTYPE_MARK'Asm_Output (static_string_EXPRESSION, NAME)\n+\n+  INPUT_OPERAND_LIST ::=\n+    [PREFIX.]No_Input_Operands\n+  | INPUT_OPERAND_ATTRIBUTE\n+  | (INPUT_OPERAND_ATTRIBUTE {,INPUT_OPERAND_ATTRIBUTE})\n+\n+  INPUT_OPERAND_ATTRIBUTE ::=\n+    SUBTYPE_MARK'Asm_Input (static_string_EXPRESSION, EXPRESSION)\n+  \n+The identifiers `No_Input_Operands` and `No_Output_Operands`\n+are declared in the package `Machine_Code` and must be referenced\n+according to normal visibility rules. In particular if there is no\n+`use` clause for this package, then appropriate package name\n+qualification is required.\n+\n+.. _GNAT_Implementation_of_Tasking:\n+\n+GNAT Implementation of Tasking\n+==============================\n+\n+This chapter outlines the basic GNAT approach to tasking (in particular,\n+a multi-layered library for portability) and discusses issues related\n+to compliance with the Real-Time Systems Annex.\n+\n+.. _Mapping_Ada_Tasks_onto_the_Underlying_Kernel_Threads:\n+\n+Mapping Ada Tasks onto the Underlying Kernel Threads\n+----------------------------------------------------\n+\n+GNAT's run-time support comprises two layers:\n+\n+* GNARL (GNAT Run-time Layer)\n+* GNULL (GNAT Low-level Library)\n+\n+In GNAT, Ada's tasking services rely on a platform and OS independent\n+layer known as GNARL.  This code is responsible for implementing the\n+correct semantics of Ada's task creation, rendezvous, protected\n+operations etc.\n+\n+GNARL decomposes Ada's tasking semantics into simpler lower level\n+operations such as create a thread, set the priority of a thread,\n+yield, create a lock, lock/unlock, etc.  The spec for these low-level\n+operations constitutes GNULLI, the GNULL Interface.  This interface is\n+directly inspired from the POSIX real-time API.\n+\n+If the underlying executive or OS implements the POSIX standard\n+faithfully, the GNULL Interface maps as is to the services offered by\n+the underlying kernel.  Otherwise, some target dependent glue code maps\n+the services offered by the underlying kernel to the semantics expected\n+by GNARL.\n+\n+Whatever the underlying OS (VxWorks, UNIX, Windows, etc.) the\n+key point is that each Ada task is mapped on a thread in the underlying\n+kernel.  For example, in the case of VxWorks, one Ada task = one VxWorks task.\n+\n+In addition Ada task priorities map onto the underlying thread priorities.\n+Mapping Ada tasks onto the underlying kernel threads has several advantages:\n+\n+* \n+  The underlying scheduler is used to schedule the Ada tasks.  This\n+  makes Ada tasks as efficient as kernel threads from a scheduling\n+  standpoint.\n+\n+* \n+  Interaction with code written in C containing threads is eased\n+  since at the lowest level Ada tasks and C threads map onto the same\n+  underlying kernel concept.\n+\n+* \n+  When an Ada task is blocked during I/O the remaining Ada tasks are\n+  able to proceed.\n+\n+* \n+  On multiprocessor systems Ada tasks can execute in parallel.\n+\n+Some threads libraries offer a mechanism to fork a new process, with the\n+child process duplicating the threads from the parent.\n+GNAT does not\n+support this functionality when the parent contains more than one task.\n+.. index:: Forking a new process\n+\n+.. _Ensuring_Compliance_with_the_Real-Time_Annex:\n+\n+Ensuring Compliance with the Real-Time Annex\n+--------------------------------------------\n+\n+.. index:: Real-Time Systems Annex compliance\n+\n+Although mapping Ada tasks onto\n+the underlying threads has significant advantages, it does create some\n+complications when it comes to respecting the scheduling semantics\n+specified in the real-time annex (Annex D).\n+\n+For instance the Annex D requirement for the `FIFO_Within_Priorities`\n+scheduling policy states:\n+\n+  *When the active priority of a ready task that is not running\n+  changes, or the setting of its base priority takes effect, the\n+  task is removed from the ready queue for its old active priority\n+  and is added at the tail of the ready queue for its new active\n+  priority, except in the case where the active priority is lowered\n+  due to the loss of inherited priority, in which case the task is\n+  added at the head of the ready queue for its new active priority.*\n+\n+While most kernels do put tasks at the end of the priority queue when\n+a task changes its priority, (which respects the main\n+FIFO_Within_Priorities requirement), almost none keep a thread at the\n+beginning of its priority queue when its priority drops from the loss\n+of inherited priority.\n+\n+As a result most vendors have provided incomplete Annex D implementations.\n+\n+The GNAT run-time, has a nice cooperative solution to this problem\n+which ensures that accurate FIFO_Within_Priorities semantics are\n+respected.\n+\n+The principle is as follows.  When an Ada task T is about to start\n+running, it checks whether some other Ada task R with the same\n+priority as T has been suspended due to the loss of priority\n+inheritance.  If this is the case, T yields and is placed at the end of\n+its priority queue.  When R arrives at the front of the queue it\n+executes.\n+\n+Note that this simple scheme preserves the relative order of the tasks\n+that were ready to execute in the priority queue where R has been\n+placed at the end.\n+\n+.. _GNAT_Implementation_of_Shared_Passive_Packages:\n+\n+GNAT Implementation of Shared Passive Packages\n+==============================================\n+\n+.. index:: Shared passive packages\n+\n+GNAT fully implements the pragma `Shared_Passive` for\n+.. index:: pragma `Shared_Passive`\n+\n+the purpose of designating shared passive packages.\n+This allows the use of passive partitions in the\n+context described in the Ada Reference Manual; i.e., for communication\n+between separate partitions of a distributed application using the\n+features in Annex E.\n+.. index:: Annex E\n+\n+.. index:: Distribution Systems Annex\n+\n+However, the implementation approach used by GNAT provides for more\n+extensive usage as follows:\n+\n+*Communication between separate programs*\n+  This allows separate programs to access the data in passive\n+  partitions, using protected objects for synchronization where\n+  needed. The only requirement is that the two programs have a\n+  common shared file system. It is even possible for programs\n+  running on different machines with different architectures\n+  (e.g., different endianness) to communicate via the data in\n+  a passive partition.\n+\n+*Persistence between program runs*\n+  The data in a passive package can persist from one run of a\n+  program to another, so that a later program sees the final\n+  values stored by a previous run of the same program.\n+\n+The implementation approach used is to store the data in files. A\n+separate stream file is created for each object in the package, and\n+an access to an object causes the corresponding file to be read or\n+written.\n+\n+.. index:: SHARED_MEMORY_DIRECTORY environment variable\n+\n+The environment variable `SHARED_MEMORY_DIRECTORY` should be\n+set to the directory to be used for these files.\n+The files in this directory\n+have names that correspond to their fully qualified names. For\n+example, if we have the package\n+\n+.. code-block:: ada\n+\n+  package X is\n+    pragma Shared_Passive (X);\n+    Y : Integer;\n+    Z : Float;\n+  end X;\n+\n+and the environment variable is set to `/stemp/`, then the files created\n+will have the names:\n+\n+::\n+\n+  /stemp/x.y\n+  /stemp/x.z\n+  \n+\n+These files are created when a value is initially written to the object, and\n+the files are retained until manually deleted. This provides the persistence\n+semantics. If no file exists, it means that no partition has assigned a value\n+to the variable; in this case the initial value declared in the package\n+will be used. This model ensures that there are no issues in synchronizing\n+the elaboration process, since elaboration of passive packages elaborates the\n+initial values, but does not create the files.\n+\n+The files are written using normal `Stream_IO` access.\n+If you want to be able\n+to communicate between programs or partitions running on different\n+architectures, then you should use the XDR versions of the stream attribute\n+routines, since these are architecture independent.\n+\n+If active synchronization is required for access to the variables in the\n+shared passive package, then as described in the Ada Reference Manual, the\n+package may contain protected objects used for this purpose. In this case\n+a lock file (whose name is :file:`___lock` (three underscores)\n+is created in the shared memory directory.\n+\n+.. index:: ___lock file (for shared passive packages)\n+\n+This is used to provide the required locking\n+semantics for proper protected object synchronization.\n+\n+GNAT supports shared passive packages on all platforms\n+except for OpenVMS.\n+\n+.. _Code_Generation_for_Array_Aggregates:\n+\n+Code Generation for Array Aggregates\n+====================================\n+\n+Aggregates have a rich syntax and allow the user to specify the values of\n+complex data structures by means of a single construct.  As a result, the\n+code generated for aggregates can be quite complex and involve loops, case\n+statements and multiple assignments.  In the simplest cases, however, the\n+compiler will recognize aggregates whose components and constraints are\n+fully static, and in those cases the compiler will generate little or no\n+executable code.  The following is an outline of the code that GNAT generates\n+for various aggregate constructs.  For further details, you will find it\n+useful to examine the output produced by the -gnatG flag to see the expanded\n+source that is input to the code generator.  You may also want to examine\n+the assembly code generated at various levels of optimization.\n+\n+The code generated for aggregates depends on the context, the component values,\n+and the type.  In the context of an object declaration the code generated is\n+generally simpler than in the case of an assignment.  As a general rule, static\n+component values and static subtypes also lead to simpler code.\n+\n+.. _Static_constant_aggregates_with_static_bounds:\n+\n+Static constant aggregates with static bounds\n+---------------------------------------------\n+\n+For the declarations:\n+\n+.. code-block:: ada\n+\n+      type One_Dim is array (1..10) of integer;\n+      ar0 : constant One_Dim := (1, 2, 3, 4, 5, 6, 7, 8, 9, 0);\n+  \n+\n+GNAT generates no executable code: the constant ar0 is placed in static memory.\n+The same is true for constant aggregates with named associations:\n+\n+\n+.. code-block:: ada\n+\n+      Cr1 : constant One_Dim := (4 => 16, 2 => 4, 3 => 9, 1 => 1, 5 .. 10 => 0);\n+      Cr3 : constant One_Dim := (others => 7777);\n+  \n+\n+The same is true for multidimensional constant arrays such as:\n+\n+.. code-block:: ada\n+\n+      type two_dim is array (1..3, 1..3) of integer;\n+      Unit : constant two_dim := ( (1,0,0), (0,1,0), (0,0,1));\n+  \n+\n+The same is true for arrays of one-dimensional arrays: the following are\n+static:\n+\n+\n+.. code-block:: ada\n+\n+  type ar1b  is array (1..3) of boolean;\n+  type ar_ar is array (1..3) of ar1b;\n+  None  : constant ar1b := (others => false);     --  fully static\n+  None2 : constant ar_ar := (1..3 => None);       --  fully static\n+  \n+\n+However, for multidimensional aggregates with named associations, GNAT will\n+generate assignments and loops, even if all associations are static.  The\n+following two declarations generate a loop for the first dimension, and\n+individual component assignments for the second dimension:\n+\n+\n+.. code-block:: ada\n+\n+  Zero1: constant two_dim := (1..3 => (1..3 => 0));\n+  Zero2: constant two_dim := (others => (others => 0));\n+  \n+\n+.. _Constant_aggregates_with_unconstrained_nominal_types:\n+\n+Constant aggregates with unconstrained nominal types\n+----------------------------------------------------\n+\n+In such cases the aggregate itself establishes the subtype, so that\n+associations with `others` cannot be used.  GNAT determines the\n+bounds for the actual subtype of the aggregate, and allocates the\n+aggregate statically as well.  No code is generated for the following:\n+\n+\n+.. code-block:: ada\n+\n+      type One_Unc is array (natural range <>) of integer;\n+      Cr_Unc : constant One_Unc := (12,24,36);\n+  \n+\n+.. _Aggregates_with_static_bounds:\n+\n+Aggregates with static bounds\n+-----------------------------\n+\n+In all previous examples the aggregate was the initial (and immutable) value\n+of a constant.  If the aggregate initializes a variable, then code is generated\n+for it as a combination of individual assignments and loops over the target\n+object.  The declarations\n+\n+\n+.. code-block:: ada\n+\n+         Cr_Var1 : One_Dim := (2, 5, 7, 11, 0, 0, 0, 0, 0, 0);\n+         Cr_Var2 : One_Dim := (others > -1);\n+  \n+\n+generate the equivalent of\n+\n+\n+.. code-block:: ada\n+\n+         Cr_Var1 (1) := 2;\n+         Cr_Var1 (2) := 3;\n+         Cr_Var1 (3) := 5;\n+         Cr_Var1 (4) := 11;\n+\n+         for I in Cr_Var2'range loop\n+            Cr_Var2 (I) := -1;\n+         end loop;\n+  \n+\n+.. _Aggregates_with_non-static_bounds:\n+\n+Aggregates with non-static bounds\n+---------------------------------\n+\n+If the bounds of the aggregate are not statically compatible with the bounds\n+of the nominal subtype  of the target, then constraint checks have to be\n+generated on the bounds.  For a multidimensional array, constraint checks may\n+have to be applied to sub-arrays individually, if they do not have statically\n+compatible subtypes.\n+\n+.. _Aggregates_in_assignment_statements:\n+\n+Aggregates in assignment statements\n+-----------------------------------\n+\n+In general, aggregate assignment requires the construction of a temporary,\n+and a copy from the temporary to the target of the assignment.  This is because\n+it is not always possible to convert the assignment into a series of individual\n+component assignments.  For example, consider the simple case:\n+\n+\n+.. code-block:: ada\n+\n+          A := (A(2), A(1));\n+  \n+\n+This cannot be converted into:\n+\n+\n+.. code-block:: ada\n+\n+          A(1) := A(2);\n+          A(2) := A(1);\n+  \n+\n+So the aggregate has to be built first in a separate location, and then\n+copied into the target.  GNAT recognizes simple cases where this intermediate\n+step is not required, and the assignments can be performed in place, directly\n+into the target.  The following sufficient criteria are applied:\n+\n+* \n+  The bounds of the aggregate are static, and the associations are static.\n+* \n+  The components of the aggregate are static constants, names of\n+  simple variables that are not renamings, or expressions not involving\n+  indexed components whose operands obey these rules.\n+\n+If any of these conditions are violated, the aggregate will be built in\n+a temporary (created either by the front-end or the code generator) and then\n+that temporary will be copied onto the target.\n+\n+.. _The_Size_of_Discriminated_Records_with_Default_Discriminants:\n+\n+The Size of Discriminated Records with Default Discriminants\n+============================================================\n+\n+If a discriminated type `T` has discriminants with default values, it is\n+possible to declare an object of this type without providing an explicit\n+constraint:\n+\n+\n+.. code-block:: ada\n+\n+  type Size is range 1..100;\n+\n+  type Rec (D : Size := 15) is record\n+     Name : String (1..D);\n+  end T;\n+\n+  Word : Rec;\n+  \n+\n+Such an object is said to be *unconstrained*.\n+The discriminant of the object\n+can be modified by a full assignment to the object, as long as it preserves the\n+relation between the value of the discriminant, and the value of the components\n+that depend on it:\n+\n+\n+.. code-block:: ada\n+\n+  Word := (3, \"yes\");\n+\n+  Word := (5, \"maybe\");\n+\n+  Word := (5, \"no\"); -- raises Constraint_Error\n+\n+In order to support this behavior efficiently, an unconstrained object is\n+given the maximum size that any value of the type requires. In the case\n+above, `Word` has storage for the discriminant and for\n+a `String` of length 100.\n+It is important to note that unconstrained objects do not require dynamic\n+allocation. It would be an improper implementation to place on the heap those\n+components whose size depends on discriminants. (This improper implementation\n+was used by some Ada83 compilers, where the `Name` component above\n+would have\n+been stored as a pointer to a dynamic string). Following the principle that\n+dynamic storage management should never be introduced implicitly,\n+an Ada compiler should reserve the full size for an unconstrained declared\n+object, and place it on the stack.\n+\n+This maximum size approach\n+has been a source of surprise to some users, who expect the default\n+values of the discriminants to determine the size reserved for an\n+unconstrained object: \"If the default is 15, why should the object occupy\n+a larger size?\"\n+The answer, of course, is that the discriminant may be later modified,\n+and its full range of values must be taken into account. This is why the\n+declaration:\n+\n+\n+.. code-block:: ada\n+\n+  type Rec (D : Positive := 15) is record\n+     Name : String (1..D);\n+  end record;\n+\n+  Too_Large : Rec;\n+\n+is flagged by the compiler with a warning:\n+an attempt to create `Too_Large` will raise `Storage_Error`,\n+because the required size includes `Positive'Last`\n+bytes. As the first example indicates, the proper approach is to declare an\n+index type of 'reasonable' range so that unconstrained objects are not too\n+large.\n+\n+One final wrinkle: if the object is declared to be `aliased`, or if it is\n+created in the heap by means of an allocator, then it is *not*\n+unconstrained:\n+it is constrained by the default values of the discriminants, and those values\n+cannot be modified by full assignment. This is because in the presence of\n+aliasing all views of the object (which may be manipulated by different tasks,\n+say) must be consistent, so it is imperative that the object, once created,\n+remain invariant.\n+\n+.. _Strict_Conformance_to_the_Ada_Reference_Manual:\n+\n+Strict Conformance to the Ada Reference Manual\n+==============================================\n+\n+The dynamic semantics defined by the Ada Reference Manual impose a set of\n+run-time checks to be generated. By default, the GNAT compiler will insert many\n+run-time checks into the compiled code, including most of those required by the\n+Ada Reference Manual. However, there are three checks that are not enabled\n+in the default mode for efficiency reasons: arithmetic overflow checking for\n+integer operations (including division by zero), checks for access before\n+elaboration on subprogram calls, and stack overflow checking (most operating\n+systems do not perform this check by default).\n+\n+Strict conformance to the Ada Reference Manual can be achieved by adding\n+three compiler options for overflow checking for integer operations\n+(*-gnato*), dynamic checks for access-before-elaboration on subprogram\n+calls and generic instantiations (*-gnatE*), and stack overflow\n+checking (*-fstack-check*).\n+\n+Note that the result of a floating point arithmetic operation in overflow and\n+invalid situations, when the `Machine_Overflows` attribute of the result\n+type is `False`, is to generate IEEE NaN and infinite values. This is the\n+case for machines compliant with the IEEE floating-point standard, but on\n+machines that are not fully compliant with this standard, such as Alpha, the\n+*-mieee* compiler flag must be used for achieving IEEE confirming\n+behavior (although at the cost of a significant performance penalty), so\n+infinite and NaN values are properly generated.\n+"}, {"sha": "32403e1990392d3d65b0f92cf68954d5010649bb", "filename": "gcc/ada/doc/gnat_rm/interfacing_to_other_languages.rst", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Finterfacing_to_other_languages.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Finterfacing_to_other_languages.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Finterfacing_to_other_languages.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,165 @@\n+.. _Interfacing_to_Other_Languages:\n+\n+******************************\n+Interfacing to Other Languages\n+******************************\n+\n+The facilities in Annex B of the Ada Reference Manual are fully\n+implemented in GNAT, and in addition, a full interface to C++ is\n+provided.\n+\n+.. _Interfacing_to_C:\n+\n+Interfacing to C\n+================\n+\n+Interfacing to C with GNAT can use one of two approaches:\n+\n+* \n+  The types in the package `Interfaces.C` may be used.\n+* \n+  Standard Ada types may be used directly.  This may be less portable to\n+  other compilers, but will work on all GNAT compilers, which guarantee\n+  correspondence between the C and Ada types.\n+\n+Pragma `Convention C` may be applied to Ada types, but mostly has no\n+effect, since this is the default.  The following table shows the\n+correspondence between Ada scalar types and the corresponding C types.\n+\n+\n+======================== ==================================================================\n+Ada Type                 C Type\n+======================== ==================================================================\n+``Integer``              ``int``\n+``Short_Integer``        ``short``\n+``Short_Short_Integer``  ``signed char``\n+``Long_Integer``         ``long``\n+``Long_Long_Integer``    ``long long``\n+``Short_Float``          ``float``\n+``Float``                ``float``\n+``Long_Float``           ``double``\n+``Long_Long_Float``      This is the longest floating-point type supported by the hardware.\n+======================== ==================================================================\n+\n+Additionally, there are the following general correspondences between Ada\n+and C types:\n+\n+* \n+  Ada enumeration types map to C enumeration types directly if pragma\n+  `Convention C` is specified, which causes them to have int\n+  length.  Without pragma `Convention C`, Ada enumeration types map to\n+  8, 16, or 32 bits (i.e., C types `signed char`, `short`,\n+  `int`, respectively) depending on the number of values passed.\n+  This is the only case in which pragma `Convention C` affects the\n+  representation of an Ada type.\n+\n+* \n+  Ada access types map to C pointers, except for the case of pointers to\n+  unconstrained types in Ada, which have no direct C equivalent.\n+\n+* \n+  Ada arrays map directly to C arrays.\n+\n+* \n+  Ada records map directly to C structures.\n+\n+* \n+  Packed Ada records map to C structures where all members are bit fields\n+  of the length corresponding to the ``type'Size`` value in Ada.\n+\n+.. _Interfacing_to_C++:\n+\n+Interfacing to C++\n+==================\n+\n+The interface to C++ makes use of the following pragmas, which are\n+primarily intended to be constructed automatically using a binding generator\n+tool, although it is possible to construct them by hand.\n+\n+Using these pragmas it is possible to achieve complete\n+inter-operability between Ada tagged types and C++ class definitions.\n+See :ref:`Implementation_Defined_Pragmas`, for more details.\n+\n+*pragma CPP_Class ([Entity =>] `LOCAL_NAME`)*\n+  The argument denotes an entity in the current declarative region that is\n+  declared as a tagged or untagged record type. It indicates that the type\n+  corresponds to an externally declared C++ class type, and is to be laid\n+  out the same way that C++ would lay out the type.\n+\n+  Note: Pragma `CPP_Class` is currently obsolete. It is supported\n+  for backward compatibility but its functionality is available\n+  using pragma `Import` with `Convention` = `CPP`.\n+\n+\n+*pragma CPP_Constructor ([Entity =>] `LOCAL_NAME`)*\n+  This pragma identifies an imported function (imported in the usual way\n+  with pragma `Import`) as corresponding to a C++ constructor.\n+\n+A few restrictions are placed on the use of the `Access` attribute\n+in conjunction with subprograms subject to convention `CPP`: the\n+attribute may be used neither on primitive operations of a tagged\n+record type with convention `CPP`, imported or not, nor on\n+subprograms imported with pragma `CPP_Constructor`.\n+\n+In addition, C++ exceptions are propagated and can be handled in an\n+`others` choice of an exception handler. The corresponding Ada\n+occurrence has no message, and the simple name of the exception identity\n+contains ``Foreign_Exception``. Finalization and awaiting dependent\n+tasks works properly when such foreign exceptions are propagated.\n+\n+It is also possible to import a C++ exception using the following syntax:\n+\n+\n+::\n+\n+  LOCAL_NAME : exception;\n+  pragma Import (Cpp,\n+    [Entity =>] LOCAL_NAME,\n+    [External_Name =>] static_string_EXPRESSION);\n+  \n+\n+The `External_Name` is the name of the C++ RTTI symbol. You can then\n+cover a specific C++ exception in an exception handler.\n+\n+.. _Interfacing_to_COBOL:\n+\n+Interfacing to COBOL\n+====================\n+\n+Interfacing to COBOL is achieved as described in section B.4 of\n+the Ada Reference Manual.\n+\n+.. _Interfacing_to_Fortran:\n+\n+Interfacing to Fortran\n+======================\n+\n+Interfacing to Fortran is achieved as described in section B.5 of the\n+Ada Reference Manual.  The pragma `Convention Fortran`, applied to a\n+multi-dimensional array causes the array to be stored in column-major\n+order as required for convenient interface to Fortran.\n+\n+.. _Interfacing_to_non-GNAT_Ada_code:\n+\n+Interfacing to non-GNAT Ada code\n+================================\n+\n+It is possible to specify the convention `Ada` in a pragma\n+`Import` or pragma `Export`.  However this refers to\n+the calling conventions used by GNAT, which may or may not be\n+similar enough to those used by some other Ada 83 / Ada 95 / Ada 2005\n+compiler to allow interoperation.\n+\n+If arguments types are kept simple, and if the foreign compiler generally\n+follows system calling conventions, then it may be possible to integrate\n+files compiled by other Ada compilers, provided that the elaboration\n+issues are adequately addressed (for example by eliminating the\n+need for any load time elaboration).\n+\n+In particular, GNAT running on VMS is designed to\n+be highly compatible with the DEC Ada 83 compiler, so this is one\n+case in which it is possible to import foreign units of this type,\n+provided that the data items passed are restricted to simple scalar\n+values or simple record types without variants, or simple array\n+types with fixed bounds.\n+"}, {"sha": "1558d06bef13f52f2738ea0aa0af737478d9cc7d", "filename": "gcc/ada/doc/gnat_rm/intrinsic_subprograms.rst", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fintrinsic_subprograms.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fintrinsic_subprograms.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fintrinsic_subprograms.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,225 @@\n+.. _Intrinsic_Subprograms:\n+\n+*********************\n+Intrinsic Subprograms\n+*********************\n+\n+.. index:: Intrinsic Subprograms\n+\n+GNAT allows a user application program to write the declaration:\n+\n+\n+.. code-block:: ada\n+\n+     pragma Import (Intrinsic, name);\n+  \n+\n+providing that the name corresponds to one of the implemented intrinsic\n+subprograms in GNAT, and that the parameter profile of the referenced\n+subprogram meets the requirements.  This chapter describes the set of\n+implemented intrinsic subprograms, and the requirements on parameter profiles.\n+Note that no body is supplied; as with other uses of pragma Import, the\n+body is supplied elsewhere (in this case by the compiler itself).  Note\n+that any use of this feature is potentially non-portable, since the\n+Ada standard does not require Ada compilers to implement this feature.\n+\n+.. _Intrinsic_Operators:\n+\n+Intrinsic Operators\n+===================\n+\n+.. index:: Intrinsic operator\n+\n+All the predefined numeric operators in package Standard\n+in `pragma Import (Intrinsic,..)`\n+declarations.  In the binary operator case, the operands must have the same\n+size.  The operand or operands must also be appropriate for\n+the operator.  For example, for addition, the operands must\n+both be floating-point or both be fixed-point, and the\n+right operand for `\"**\"` must have a root type of\n+`Standard.Integer'Base`.\n+You can use an intrinsic operator declaration as in the following example:\n+\n+\n+.. code-block:: ada\n+\n+     type Int1 is new Integer;\n+     type Int2 is new Integer;\n+\n+     function \"+\" (X1 : Int1; X2 : Int2) return Int1;\n+     function \"+\" (X1 : Int1; X2 : Int2) return Int2;\n+     pragma Import (Intrinsic, \"+\");\n+  \n+\n+This declaration would permit 'mixed mode' arithmetic on items\n+of the differing types `Int1` and `Int2`.\n+It is also possible to specify such operators for private types, if the\n+full views are appropriate arithmetic types.\n+\n+.. _Compilation_Date:\n+\n+Compilation_Date\n+================\n+\n+.. index:: Compilation_Date\n+\n+This intrinsic subprogram is used in the implementation of the\n+library package `GNAT.Source_Info`.  The only useful use of the\n+intrinsic import in this case is the one in this unit, so an\n+application program should simply call the function\n+`GNAT.Source_Info.Compilation_Date` to obtain the date of\n+the current compilation (in local time format MMM DD YYYY).\n+\n+.. _Compilation_Time:\n+\n+Compilation_Time\n+================\n+\n+.. index:: Compilation_Time\n+\n+This intrinsic subprogram is used in the implementation of the\n+library package `GNAT.Source_Info`.  The only useful use of the\n+intrinsic import in this case is the one in this unit, so an\n+application program should simply call the function\n+`GNAT.Source_Info.Compilation_Time` to obtain the time of\n+the current compilation (in local time format HH:MM:SS).\n+\n+.. _Enclosing_Entity:\n+\n+Enclosing_Entity\n+================\n+\n+.. index:: Enclosing_Entity\n+\n+This intrinsic subprogram is used in the implementation of the\n+library package `GNAT.Source_Info`.  The only useful use of the\n+intrinsic import in this case is the one in this unit, so an\n+application program should simply call the function\n+`GNAT.Source_Info.Enclosing_Entity` to obtain the name of\n+the current subprogram, package, task, entry, or protected subprogram.\n+\n+.. _Exception_Information:\n+\n+Exception_Information\n+=====================\n+\n+.. index:: Exception_Information'\n+\n+This intrinsic subprogram is used in the implementation of the\n+library package `GNAT.Current_Exception`.  The only useful\n+use of the intrinsic import in this case is the one in this unit,\n+so an application program should simply call the function\n+`GNAT.Current_Exception.Exception_Information` to obtain\n+the exception information associated with the current exception.\n+\n+.. _Exception_Message:\n+\n+Exception_Message\n+=================\n+\n+.. index:: Exception_Message\n+\n+This intrinsic subprogram is used in the implementation of the\n+library package `GNAT.Current_Exception`.  The only useful\n+use of the intrinsic import in this case is the one in this unit,\n+so an application program should simply call the function\n+`GNAT.Current_Exception.Exception_Message` to obtain\n+the message associated with the current exception.\n+\n+.. _Exception_Name:\n+\n+Exception_Name\n+==============\n+\n+.. index:: Exception_Name\n+\n+This intrinsic subprogram is used in the implementation of the\n+library package `GNAT.Current_Exception`.  The only useful\n+use of the intrinsic import in this case is the one in this unit,\n+so an application program should simply call the function\n+`GNAT.Current_Exception.Exception_Name` to obtain\n+the name of the current exception.\n+\n+.. _File:\n+\n+File\n+====\n+\n+.. index:: File\n+\n+This intrinsic subprogram is used in the implementation of the\n+library package `GNAT.Source_Info`.  The only useful use of the\n+intrinsic import in this case is the one in this unit, so an\n+application program should simply call the function\n+`GNAT.Source_Info.File` to obtain the name of the current\n+file.\n+\n+.. _Line:\n+\n+Line\n+====\n+\n+.. index:: Line\n+\n+This intrinsic subprogram is used in the implementation of the\n+library package `GNAT.Source_Info`.  The only useful use of the\n+intrinsic import in this case is the one in this unit, so an\n+application program should simply call the function\n+`GNAT.Source_Info.Line` to obtain the number of the current\n+source line.\n+\n+.. _Shifts_and_Rotates:\n+\n+Shifts and Rotates\n+==================\n+\n+.. index:: Shift_Left\n+\n+.. index:: Shift_Right\n+\n+.. index:: Shift_Right_Arithmetic\n+\n+.. index:: Rotate_Left\n+\n+.. index:: Rotate_Right\n+\n+In standard Ada, the shift and rotate functions are available only\n+for the predefined modular types in package `Interfaces`.  However, in\n+GNAT it is possible to define these functions for any integer\n+type (signed or modular), as in this example:\n+\n+\n+.. code-block:: ada\n+\n+     function Shift_Left\n+       (Value  : T;\n+        Amount : Natural) return T;\n+  \n+\n+The function name must be one of\n+Shift_Left, Shift_Right, Shift_Right_Arithmetic, Rotate_Left, or\n+Rotate_Right. T must be an integer type. T'Size must be\n+8, 16, 32 or 64 bits; if T is modular, the modulus\n+must be 2**8, 2**16, 2**32 or 2**64.\n+The result type must be the same as the type of `Value`.\n+The shift amount must be Natural.\n+The formal parameter names can be anything.\n+\n+A more convenient way of providing these shift operators is to use\n+the Provide_Shift_Operators pragma, which provides the function declarations\n+and corresponding pragma Import's for all five shift functions.\n+\n+.. _Source_Location:\n+\n+Source_Location\n+===============\n+\n+.. index:: Source_Location\n+\n+This intrinsic subprogram is used in the implementation of the\n+library routine `GNAT.Source_Info`.  The only useful use of the\n+intrinsic import in this case is the one in this unit, so an\n+application program should simply call the function\n+`GNAT.Source_Info.Source_Location` to obtain the current\n+source file location.\n+"}, {"sha": "f5ea188a34dfa3b9fa3113b8b3f0d96d78a03aae", "filename": "gcc/ada/doc/gnat_rm/obsolescent_features.rst", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fobsolescent_features.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fobsolescent_features.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fobsolescent_features.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,82 @@\n+.. _Obsolescent_Features:\n+\n+********************\n+Obsolescent Features\n+********************\n+\n+This chapter describes features that are provided by GNAT, but are\n+considered obsolescent since there are preferred ways of achieving\n+the same effect. These features are provided solely for historical\n+compatibility purposes.\n+\n+.. _pragma_No_Run_Time:\n+\n+pragma No_Run_Time\n+==================\n+\n+The pragma `No_Run_Time` is used to achieve an affect similar\n+to the use of the \"Zero Foot Print\" configurable run time, but without\n+requiring a specially configured run time. The result of using this\n+pragma, which must be used for all units in a partition, is to restrict\n+the use of any language features requiring run-time support code. The\n+preferred usage is to use an appropriately configured run-time that\n+includes just those features that are to be made accessible.\n+\n+.. _pragma_Ravenscar:\n+\n+pragma Ravenscar\n+================\n+\n+The pragma `Ravenscar` has exactly the same effect as pragma\n+`Profile (Ravenscar)`. The latter usage is preferred since it\n+is part of the new Ada 2005 standard.\n+\n+.. _pragma_Restricted_Run_Time:\n+\n+pragma Restricted_Run_Time\n+==========================\n+\n+The pragma `Restricted_Run_Time` has exactly the same effect as\n+pragma `Profile (Restricted)`. The latter usage is\n+preferred since the Ada 2005 pragma `Profile` is intended for\n+this kind of implementation dependent addition.\n+\n+.. _pragma_Task_Info:\n+\n+pragma Task_Info\n+================\n+\n+The functionality provided by pragma `Task_Info` is now part of the\n+Ada language. The `CPU` aspect and the package\n+`System.Multiprocessors` offer a less system-dependent way to specify\n+task affinity or to query the number of processsors.\n+\n+Syntax\n+\n+.. code-block:: ada\n+\n+  pragma Task_Info (EXPRESSION);\n+  \n+This pragma appears within a task definition (like pragma\n+`Priority`) and applies to the task in which it appears.  The\n+argument must be of type `System.Task_Info.Task_Info_Type`.\n+The `Task_Info` pragma provides system dependent control over\n+aspects of tasking implementation, for example, the ability to map\n+tasks to specific processors.  For details on the facilities available\n+for the version of GNAT that you are using, see the documentation\n+in the spec of package System.Task_Info in the runtime\n+library.\n+\n+.. _package_System_Task_Info:\n+\n+package System.Task_Info (:file:`s-tasinf.ads`)\n+===============================================\n+\n+This package provides target dependent functionality that is used\n+to support the `Task_Info` pragma. The predefined Ada package\n+`System.Multiprocessors` and the `CPU` aspect now provide a\n+standard replacement for GNAT's `Task_Info` functionality.\n+\n+.. raw:: latex\n+\n+    \\appendix"}, {"sha": "d2a19877fcc6125df10a62a8a8e7181b0d09c9db", "filename": "gcc/ada/doc/gnat_rm/representation_clauses_and_pragmas.rst", "status": "added", "additions": 2138, "deletions": 0, "changes": 2138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Frepresentation_clauses_and_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Frepresentation_clauses_and_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Frepresentation_clauses_and_pragmas.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,2138 @@\n+.. _Representation_Clauses_and_Pragmas:\n+\n+**********************************\n+Representation Clauses and Pragmas\n+**********************************\n+\n+.. index:: Representation Clauses\n+\n+.. index:: Representation Clause\n+\n+.. index:: Representation Pragma\n+\n+.. index:: Pragma, representation\n+\n+This section describes the representation clauses accepted by GNAT, and\n+their effect on the representation of corresponding data objects.\n+\n+GNAT fully implements Annex C (Systems Programming).  This means that all\n+the implementation advice sections in chapter 13 are fully implemented.\n+However, these sections only require a minimal level of support for\n+representation clauses.  GNAT provides much more extensive capabilities,\n+and this section describes the additional capabilities provided.\n+\n+.. _Alignment_Clauses:\n+\n+Alignment Clauses\n+=================\n+\n+.. index:: Alignment Clause\n+\n+GNAT requires that all alignment clauses specify a power of 2, and all\n+default alignments are always a power of 2.  The default alignment\n+values are as follows:\n+\n+* *Primitive Types*.\n+\n+  For primitive types, the alignment is the minimum of the actual size of\n+  objects of the type divided by `Storage_Unit`,\n+  and the maximum alignment supported by the target.\n+  (This maximum alignment is given by the GNAT-specific attribute\n+  `Standard'Maximum_Alignment`; see :ref:`Attribute_Maximum_Alignment`.)\n+\n+  .. index:: Maximum_Alignment attribute\n+\n+  For example, for type `Long_Float`, the object size is 8 bytes, and the\n+  default alignment will be 8 on any target that supports alignments\n+  this large, but on some targets, the maximum alignment may be smaller\n+  than 8, in which case objects of type `Long_Float` will be maximally\n+  aligned.\n+\n+* *Arrays*.\n+\n+  For arrays, the alignment is equal to the alignment of the component type\n+  for the normal case where no packing or component size is given.  If the\n+  array is packed, and the packing is effective (see separate section on\n+  packed arrays), then the alignment will be one for long packed arrays,\n+  or arrays whose length is not known at compile time.  For short packed\n+  arrays, which are handled internally as modular types, the alignment\n+  will be as described for primitive types, e.g., a packed array of length\n+  31 bits will have an object size of four bytes, and an alignment of 4.\n+\n+* *Records*.\n+\n+  For the normal non-packed case, the alignment of a record is equal to\n+  the maximum alignment of any of its components.  For tagged records, this\n+  includes the implicit access type used for the tag.  If a pragma `Pack`\n+  is used and all components are packable (see separate section on pragma\n+  `Pack`), then the resulting alignment is 1, unless the layout of the\n+  record makes it profitable to increase it.\n+\n+  A special case is when:\n+\n+  * the size of the record is given explicitly, or a\n+    full record representation clause is given, and\n+\n+  * the size of the record is 2, 4, or 8 bytes.\n+\n+  In this case, an alignment is chosen to match the\n+  size of the record. For example, if we have:\n+\n+  .. code-block:: ada\n+\n+       type Small is record\n+          A, B : Character;\n+       end record;\n+       for Small'Size use 16;\n+    \n+  then the default alignment of the record type `Small` is 2, not 1. This\n+  leads to more efficient code when the record is treated as a unit, and also\n+  allows the type to specified as `Atomic` on architectures requiring\n+  strict alignment.\n+\n+An alignment clause may specify a larger alignment than the default value\n+up to some maximum value dependent on the target (obtainable by using the\n+attribute reference `Standard'Maximum_Alignment`). It may also specify\n+a smaller alignment than the default value for enumeration, integer and\n+fixed point types, as well as for record types, for example\n+\n+.. code-block:: ada\n+\n+    type V is record\n+       A : Integer;\n+    end record;\n+\n+    for V'alignment use 1;\n+\n+.. index:: Alignment, default\n+\n+The default alignment for the type `V` is 4, as a result of the\n+Integer field in the record, but it is permissible, as shown, to\n+override the default alignment of the record with a smaller value.\n+\n+.. index:: Alignment, subtypes\n+\n+Note that according to the Ada standard, an alignment clause applies only\n+to the first named subtype. If additional subtypes are declared, then the\n+compiler is allowed to choose any alignment it likes, and there is no way\n+to control this choice. Consider:\n+\n+.. code-block:: ada\n+\n+     type R is range 1 .. 10_000;\n+     for R'Alignment use 1;\n+     subtype RS is R range 1 .. 1000;\n+  \n+The alignment clause specifies an alignment of 1 for the first named subtype\n+`R` but this does not necessarily apply to `RS`. When writing\n+portable Ada code, you should avoid writing code that explicitly or\n+implicitly relies on the alignment of such subtypes.\n+\n+For the GNAT compiler, if an explicit alignment clause is given, this\n+value is also used for any subsequent subtypes. So for GNAT, in the\n+above example, you can count on the alignment of `RS` being 1. But this\n+assumption is non-portable, and other compilers may choose different\n+alignments for the subtype `RS`.\n+\n+.. _Size_Clauses:\n+\n+Size Clauses\n+============\n+\n+.. index:: Size Clause\n+\n+The default size for a type `T` is obtainable through the\n+language-defined attribute `T'Size` and also through the\n+equivalent GNAT-defined attribute `T'Value_Size`.\n+For objects of type `T`, GNAT will generally increase the type size\n+so that the object size (obtainable through the GNAT-defined attribute\n+`T'Object_Size`)\n+is a multiple of `T'Alignment * Storage_Unit`.\n+\n+For example:\n+\n+.. code-block:: ada\n+\n+     type Smallint is range 1 .. 6;\n+\n+     type Rec is record\n+        Y1 : integer;\n+        Y2 : boolean;\n+     end record;\n+  \n+In this example, `Smallint'Size` = `Smallint'Value_Size` = 3,\n+as specified by the RM rules,\n+but objects of this type will have a size of 8\n+(`Smallint'Object_Size` = 8),\n+since objects by default occupy an integral number\n+of storage units.  On some targets, notably older\n+versions of the Digital Alpha, the size of stand\n+alone objects of this type may be 32, reflecting\n+the inability of the hardware to do byte load/stores.\n+\n+Similarly, the size of type `Rec` is 40 bits\n+(`Rec'Size` = `Rec'Value_Size` = 40), but\n+the alignment is 4, so objects of this type will have\n+their size increased to 64 bits so that it is a multiple\n+of the alignment (in bits).  This decision is\n+in accordance with the specific Implementation Advice in RM 13.3(43):\n+\n+   \"A `Size` clause should be supported for an object if the specified\n+   `Size` is at least as large as its subtype's `Size`, and corresponds\n+   to a size in storage elements that is a multiple of the object's\n+   `Alignment` (if the `Alignment` is nonzero).\"\n+\n+An explicit size clause may be used to override the default size by\n+increasing it.  For example, if we have:\n+\n+.. code-block:: ada\n+\n+     type My_Boolean is new Boolean;\n+     for My_Boolean'Size use 32;\n+  \n+then values of this type will always be 32 bits long.  In the case of\n+discrete types, the size can be increased up to 64 bits, with the effect\n+that the entire specified field is used to hold the value, sign- or\n+zero-extended as appropriate.  If more than 64 bits is specified, then\n+padding space is allocated after the value, and a warning is issued that\n+there are unused bits.\n+\n+Similarly the size of records and arrays may be increased, and the effect\n+is to add padding bits after the value.  This also causes a warning message\n+to be generated.\n+\n+The largest Size value permitted in GNAT is 2**31-1.  Since this is a\n+Size in bits, this corresponds to an object of size 256 megabytes (minus\n+one).  This limitation is true on all targets.  The reason for this\n+limitation is that it improves the quality of the code in many cases\n+if it is known that a Size value can be accommodated in an object of\n+type Integer.\n+\n+\n+.. _Storage_Size_Clauses:\n+\n+Storage_Size Clauses\n+====================\n+\n+.. index:: Storage_Size Clause\n+\n+For tasks, the `Storage_Size` clause specifies the amount of space\n+to be allocated for the task stack.  This cannot be extended, and if the\n+stack is exhausted, then `Storage_Error` will be raised (if stack\n+checking is enabled).  Use a `Storage_Size` attribute definition clause,\n+or a `Storage_Size` pragma in the task definition to set the\n+appropriate required size.  A useful technique is to include in every\n+task definition a pragma of the form:\n+\n+.. code-block:: ada\n+\n+     pragma Storage_Size (Default_Stack_Size);\n+  \n+Then `Default_Stack_Size` can be defined in a global package, and\n+modified as required. Any tasks requiring stack sizes different from the\n+default can have an appropriate alternative reference in the pragma.\n+\n+You can also use the *-d* binder switch to modify the default stack\n+size.\n+\n+For access types, the `Storage_Size` clause specifies the maximum\n+space available for allocation of objects of the type.  If this space is\n+exceeded then `Storage_Error` will be raised by an allocation attempt.\n+In the case where the access type is declared local to a subprogram, the\n+use of a `Storage_Size` clause triggers automatic use of a special\n+predefined storage pool (`System.Pool_Size`) that ensures that all\n+space for the pool is automatically reclaimed on exit from the scope in\n+which the type is declared.\n+\n+A special case recognized by the compiler is the specification of a\n+`Storage_Size` of zero for an access type.  This means that no\n+items can be allocated from the pool, and this is recognized at compile\n+time, and all the overhead normally associated with maintaining a fixed\n+size storage pool is eliminated.  Consider the following example:\n+\n+.. code-block:: ada\n+\n+     procedure p is\n+        type R is array (Natural) of Character;\n+        type P is access all R;\n+        for P'Storage_Size use 0;\n+        --  Above access type intended only for interfacing purposes\n+\n+        y : P;\n+\n+        procedure g (m : P);\n+        pragma Import (C, g);\n+\n+        --  ...\n+\n+     begin\n+        --  ...\n+        y := new R;\n+     end;\n+  \n+As indicated in this example, these dummy storage pools are often useful in\n+connection with interfacing where no object will ever be allocated.  If you\n+compile the above example, you get the warning:\n+\n+::\n+\n+     p.adb:16:09: warning: allocation from empty storage pool\n+     p.adb:16:09: warning: Storage_Error will be raised at run time\n+  \n+\n+Of course in practice, there will not be any explicit allocators in the\n+case of such an access declaration.\n+\n+.. _Size_of_Variant_Record_Objects:\n+\n+Size of Variant Record Objects\n+==============================\n+\n+.. index:: Size, variant record objects\n+\n+.. index:: Variant record objects, size\n+\n+In the case of variant record objects, there is a question whether Size gives\n+information about a particular variant, or the maximum size required\n+for any variant.  Consider the following program\n+\n+.. code-block:: ada\n+\n+  with Text_IO; use Text_IO;\n+  procedure q is\n+     type R1 (A : Boolean := False) is record\n+       case A is\n+         when True  => X : Character;\n+         when False => null;\n+       end case;\n+     end record;\n+\n+     V1 : R1 (False);\n+     V2 : R1;\n+\n+  begin\n+     Put_Line (Integer'Image (V1'Size));\n+     Put_Line (Integer'Image (V2'Size));\n+  end q;\n+  \n+Here we are dealing with a variant record, where the True variant\n+requires 16 bits, and the False variant requires 8 bits.\n+In the above example, both V1 and V2 contain the False variant,\n+which is only 8 bits long.  However, the result of running the\n+program is:\n+\n+::\n+\n+  8\n+  16\n+  \n+The reason for the difference here is that the discriminant value of\n+V1 is fixed, and will always be False.  It is not possible to assign\n+a True variant value to V1, therefore 8 bits is sufficient.  On the\n+other hand, in the case of V2, the initial discriminant value is\n+False (from the default), but it is possible to assign a True\n+variant value to V2, therefore 16 bits must be allocated for V2\n+in the general case, even fewer bits may be needed at any particular\n+point during the program execution.\n+\n+As can be seen from the output of this program, the `'Size`\n+attribute applied to such an object in GNAT gives the actual allocated\n+size of the variable, which is the largest size of any of the variants.\n+The Ada Reference Manual is not completely clear on what choice should\n+be made here, but the GNAT behavior seems most consistent with the\n+language in the RM.\n+\n+In some cases, it may be desirable to obtain the size of the current\n+variant, rather than the size of the largest variant.  This can be\n+achieved in GNAT by making use of the fact that in the case of a\n+subprogram parameter, GNAT does indeed return the size of the current\n+variant (because a subprogram has no way of knowing how much space\n+is actually allocated for the actual).\n+\n+Consider the following modified version of the above program:\n+\n+.. code-block:: ada\n+\n+  with Text_IO; use Text_IO;\n+  procedure q is\n+     type R1 (A : Boolean := False) is record\n+       case A is\n+         when True  => X : Character;\n+         when False => null;\n+       end case;\n+     end record;\n+\n+     V2 : R1;\n+\n+     function Size (V : R1) return Integer is\n+     begin\n+        return V'Size;\n+     end Size;\n+\n+  begin\n+     Put_Line (Integer'Image (V2'Size));\n+     Put_Line (Integer'IMage (Size (V2)));\n+     V2 := (True, 'x');\n+     Put_Line (Integer'Image (V2'Size));\n+     Put_Line (Integer'IMage (Size (V2)));\n+  end q;\n+  \n+The output from this program is\n+\n+::\n+\n+  16\n+  8\n+  16\n+  16\n+  \n+Here we see that while the `'Size` attribute always returns\n+the maximum size, regardless of the current variant value, the\n+`Size` function does indeed return the size of the current\n+variant value.\n+\n+\n+.. _Biased_Representation:\n+\n+Biased Representation\n+=====================\n+\n+.. index:: Size for biased representation\n+\n+.. index:: Biased representation\n+\n+In the case of scalars with a range starting at other than zero, it is\n+possible in some cases to specify a size smaller than the default minimum\n+value, and in such cases, GNAT uses an unsigned biased representation,\n+in which zero is used to represent the lower bound, and successive values\n+represent successive values of the type.\n+\n+For example, suppose we have the declaration:\n+\n+.. code-block:: ada\n+\n+     type Small is range -7 .. -4;\n+     for Small'Size use 2;\n+  \n+Although the default size of type `Small` is 4, the `Size`\n+clause is accepted by GNAT and results in the following representation\n+scheme:\n+\n+::\n+\n+    -7 is represented as 2#00#\n+    -6 is represented as 2#01#\n+    -5 is represented as 2#10#\n+    -4 is represented as 2#11#\n+  \n+Biased representation is only used if the specified `Size` clause\n+cannot be accepted in any other manner.  These reduced sizes that force\n+biased representation can be used for all discrete types except for\n+enumeration types for which a representation clause is given.\n+\n+\n+.. _Value_Size_and_Object_Size_Clauses:\n+\n+Value_Size and Object_Size Clauses\n+==================================\n+\n+.. index:: Value_Size\n+.. index:: Object_Size\n+.. index:: Size, of objects\n+\n+In Ada 95 and Ada 2005, `T'Size` for a type `T` is the minimum\n+number of bits required to hold values of type `T`.\n+Although this interpretation was allowed in Ada 83, it was not required,\n+and this requirement in practice can cause some significant difficulties.\n+For example, in most Ada 83 compilers, `Natural'Size` was 32.\n+However, in Ada 95 and Ada 2005,\n+`Natural'Size` is\n+typically 31.  This means that code may change in behavior when moving\n+from Ada 83 to Ada 95 or Ada 2005.  For example, consider:\n+\n+.. code-block:: ada\n+\n+     type Rec is record;\n+        A : Natural;\n+        B : Natural;\n+     end record;\n+\n+     for Rec use record\n+        at 0  range 0 .. Natural'Size - 1;\n+        at 0  range Natural'Size .. 2 * Natural'Size - 1;\n+     end record;\n+  \n+In the above code, since the typical size of `Natural` objects\n+is 32 bits and `Natural'Size` is 31, the above code can cause\n+unexpected inefficient packing in Ada 95 and Ada 2005, and in general\n+there are cases where the fact that the object size can exceed the\n+size of the type causes surprises.\n+\n+To help get around this problem GNAT provides two implementation\n+defined attributes, `Value_Size` and `Object_Size`.  When\n+applied to a type, these attributes yield the size of the type\n+(corresponding to the RM defined size attribute), and the size of\n+objects of the type respectively.\n+\n+The `Object_Size` is used for determining the default size of\n+objects and components.  This size value can be referred to using the\n+`Object_Size` attribute.  The phrase 'is used' here means that it is\n+the basis of the determination of the size.  The backend is free to\n+pad this up if necessary for efficiency, e.g., an 8-bit stand-alone\n+character might be stored in 32 bits on a machine with no efficient\n+byte access instructions such as the Alpha.\n+\n+The default rules for the value of `Object_Size` for\n+discrete types are as follows:\n+\n+* \n+  The `Object_Size` for base subtypes reflect the natural hardware\n+  size in bits (run the compiler with *-gnatS* to find those values\n+  for numeric types). Enumeration types and fixed-point base subtypes have\n+  8, 16, 32 or 64 bits for this size, depending on the range of values\n+  to be stored.\n+\n+* \n+  The `Object_Size` of a subtype is the same as the\n+  `Object_Size` of\n+  the type from which it is obtained.\n+\n+* \n+  The `Object_Size` of a derived base type is copied from the parent\n+  base type, and the `Object_Size` of a derived first subtype is copied\n+  from the parent first subtype.\n+\n+The `Value_Size` attribute\n+is the (minimum) number of bits required to store a value\n+of the type.\n+This value is used to determine how tightly to pack\n+records or arrays with components of this type, and also affects\n+the semantics of unchecked conversion (unchecked conversions where\n+the `Value_Size` values differ generate a warning, and are potentially\n+target dependent).\n+\n+The default rules for the value of `Value_Size` are as follows:\n+\n+* \n+  The `Value_Size` for a base subtype is the minimum number of bits\n+  required to store all values of the type (including the sign bit\n+  only if negative values are possible).\n+\n+* \n+  If a subtype statically matches the first subtype of a given type, then it has\n+  by default the same `Value_Size` as the first subtype.  This is a\n+  consequence of RM 13.1(14): \"if two subtypes statically match,\n+  then their subtype-specific aspects are the same\".)\n+\n+* \n+  All other subtypes have a `Value_Size` corresponding to the minimum\n+  number of bits required to store all values of the subtype.  For\n+  dynamic bounds, it is assumed that the value can range down or up\n+  to the corresponding bound of the ancestor\n+\n+The RM defined attribute `Size` corresponds to the\n+`Value_Size` attribute.\n+\n+The `Size` attribute may be defined for a first-named subtype.  This sets\n+the `Value_Size` of\n+the first-named subtype to the given value, and the\n+`Object_Size` of this first-named subtype to the given value padded up\n+to an appropriate boundary.  It is a consequence of the default rules\n+above that this `Object_Size` will apply to all further subtypes.  On the\n+other hand, `Value_Size` is affected only for the first subtype, any\n+dynamic subtypes obtained from it directly, and any statically matching\n+subtypes.  The `Value_Size` of any other static subtypes is not affected.\n+\n+`Value_Size` and\n+`Object_Size` may be explicitly set for any subtype using\n+an attribute definition clause.  Note that the use of these attributes\n+can cause the RM 13.1(14) rule to be violated.  If two access types\n+reference aliased objects whose subtypes have differing `Object_Size`\n+values as a result of explicit attribute definition clauses, then it\n+is illegal to convert from one access subtype to the other. For a more\n+complete description of this additional legality rule, see the\n+description of the `Object_Size` attribute.\n+\n+At the implementation level, Esize stores the Object_Size and the\n+RM_Size field stores the `Value_Size` (and hence the value of the\n+`Size` attribute,\n+which, as noted above, is equivalent to `Value_Size`).\n+\n+To get a feel for the difference, consider the following examples (note\n+that in each case the base is `Short_Short_Integer` with a size of 8):\n+\n++---------------------------------------------+-------------+-------------+\n+|Type or subtype declaration                  | Object_Size |   Value_Size|\n++=============================================+=============+=============+\n+|``type x1 is range 0 .. 5;``                 |  8          |    3        |\n++---------------------------------------------+-------------+-------------+\n+|``type x2 is range 0 .. 5;``                 | 16          |   12        |\n+|``for x2'size use 12;``                      |             |             |\n++---------------------------------------------+-------------+-------------+\n+|``subtype x3 is x2 range 0 .. 3;``           | 16          |    2        |\n++---------------------------------------------+-------------+-------------+\n+|``subtype x4 is x2'base range 0 .. 10;``     |  8          |    4        |\n++---------------------------------------------+-------------+-------------+\n+|``subtype x5 is x2 range 0 .. dynamic;``     | 16          |    3*       |\n++---------------------------------------------+-------------+-------------+\n+|``subtype x6 is x2'base range 0 .. dynamic;``|  8          |    3*       |\n++---------------------------------------------+-------------+-------------+\n+\n+Note: the entries marked '3*' are not actually specified by the Ada\n+Reference Manual, but it seems in the spirit of the RM rules to allocate\n+the minimum number of bits (here 3, given the range for `x2`)\n+known to be large enough to hold the given range of values.\n+\n+So far, so good, but GNAT has to obey the RM rules, so the question is\n+under what conditions must the RM `Size` be used.\n+The following is a list\n+of the occasions on which the RM `Size` must be used:\n+\n+* \n+  Component size for packed arrays or records\n+\n+* \n+  Value of the attribute `Size` for a type\n+\n+* \n+  Warning about sizes not matching for unchecked conversion\n+\n+For record types, the `Object_Size` is always a multiple of the\n+alignment of the type (this is true for all types). In some cases the\n+`Value_Size` can be smaller. Consider:\n+\n+\n+.. code-block:: ada\n+\n+     type R is record\n+       X : Integer;\n+       Y : Character;\n+     end record;\n+  \n+\n+On a typical 32-bit architecture, the X component will be four bytes, and\n+require four-byte alignment, and the Y component will be one byte. In this\n+case `R'Value_Size` will be 40 (bits) since this is the minimum size\n+required to store a value of this type, and for example, it is permissible\n+to have a component of type R in an outer array whose component size is\n+specified to be 48 bits. However, `R'Object_Size` will be 64 (bits),\n+since it must be rounded up so that this value is a multiple of the\n+alignment (4 bytes = 32 bits).\n+\n+For all other types, the `Object_Size`\n+and Value_Size are the same (and equivalent to the RM attribute `Size`).\n+Only `Size` may be specified for such types.\n+\n+Note that `Value_Size` can be used to force biased representation\n+for a particular subtype. Consider this example:\n+\n+\n+.. code-block:: ada\n+\n+     type R is (A, B, C, D, E, F);\n+     subtype RAB is R range A .. B;\n+     subtype REF is R range E .. F;\n+  \n+\n+By default, `RAB`\n+has a size of 1 (sufficient to accommodate the representation\n+of `A` and `B`, 0 and 1), and `REF`\n+has a size of 3 (sufficient to accommodate the representation\n+of `E` and `F`, 4 and 5). But if we add the\n+following `Value_Size` attribute definition clause:\n+\n+\n+.. code-block:: ada\n+\n+     for REF'Value_Size use 1;\n+  \n+\n+then biased representation is forced for `REF`,\n+and 0 will represent `E` and 1 will represent `F`.\n+A warning is issued when a `Value_Size` attribute\n+definition clause forces biased representation. This\n+warning can be turned off using `-gnatw.B`.\n+\n+.. _Component_Size_Clauses:\n+\n+Component_Size Clauses\n+======================\n+\n+.. index:: Component_Size Clause\n+\n+Normally, the value specified in a component size clause must be consistent\n+with the subtype of the array component with regard to size and alignment.\n+In other words, the value specified must be at least equal to the size\n+of this subtype, and must be a multiple of the alignment value.\n+\n+In addition, component size clauses are allowed which cause the array\n+to be packed, by specifying a smaller value.  A first case is for\n+component size values in the range 1 through 63.  The value specified\n+must not be smaller than the Size of the subtype.  GNAT will accurately\n+honor all packing requests in this range.  For example, if we have:\n+\n+\n+.. code-block:: ada\n+\n+  type r is array (1 .. 8) of Natural;\n+  for r'Component_Size use 31;\n+  \n+\n+then the resulting array has a length of 31 bytes (248 bits = 8 * 31).\n+Of course access to the components of such an array is considerably\n+less efficient than if the natural component size of 32 is used.\n+A second case is when the subtype of the component is a record type\n+padded because of its default alignment.  For example, if we have:\n+\n+\n+.. code-block:: ada\n+\n+  type r is record\n+    i : Integer;\n+    j : Integer;\n+    b : Boolean;\n+  end record;\n+\n+  type a is array (1 .. 8) of r;\n+  for a'Component_Size use 72;\n+  \n+\n+then the resulting array has a length of 72 bytes, instead of 96 bytes\n+if the alignment of the record (4) was obeyed.\n+\n+Note that there is no point in giving both a component size clause\n+and a pragma Pack for the same array type. if such duplicate\n+clauses are given, the pragma Pack will be ignored.\n+\n+.. _Bit_Order_Clauses:\n+\n+Bit_Order Clauses\n+=================\n+\n+.. index:: Bit_Order Clause\n+\n+.. index:: bit ordering\n+\n+.. index:: ordering, of bits\n+\n+For record subtypes, GNAT permits the specification of the `Bit_Order`\n+attribute.  The specification may either correspond to the default bit\n+order for the target, in which case the specification has no effect and\n+places no additional restrictions, or it may be for the non-standard\n+setting (that is the opposite of the default).\n+\n+In the case where the non-standard value is specified, the effect is\n+to renumber bits within each byte, but the ordering of bytes is not\n+affected.  There are certain\n+restrictions placed on component clauses as follows:\n+\n+\n+* Components fitting within a single storage unit.\n+\n+  These are unrestricted, and the effect is merely to renumber bits.  For\n+  example if we are on a little-endian machine with `Low_Order_First`\n+  being the default, then the following two declarations have exactly\n+  the same effect:\n+\n+\n+  ::\n+\n+       type R1 is record\n+          A : Boolean;\n+          B : Integer range 1 .. 120;\n+       end record;\n+\n+       for R1 use record\n+          A at 0 range 0 .. 0;\n+          B at 0 range 1 .. 7;\n+       end record;\n+\n+       type R2 is record\n+          A : Boolean;\n+          B : Integer range 1 .. 120;\n+       end record;\n+\n+       for R2'Bit_Order use High_Order_First;\n+\n+       for R2 use record\n+          A at 0 range 7 .. 7;\n+          B at 0 range 0 .. 6;\n+       end record;\n+    \n+\n+  The useful application here is to write the second declaration with the\n+  `Bit_Order` attribute definition clause, and know that it will be treated\n+  the same, regardless of whether the target is little-endian or big-endian.\n+\n+* Components occupying an integral number of bytes.\n+\n+  These are components that exactly fit in two or more bytes.  Such component\n+  declarations are allowed, but have no effect, since it is important to realize\n+  that the `Bit_Order` specification does not affect the ordering of bytes.\n+  In particular, the following attempt at getting an endian-independent integer\n+  does not work:\n+\n+\n+  ::\n+\n+       type R2 is record\n+          A : Integer;\n+       end record;\n+\n+       for R2'Bit_Order use High_Order_First;\n+\n+       for R2 use record\n+          A at 0 range 0 .. 31;\n+       end record;\n+    \n+\n+  This declaration will result in a little-endian integer on a\n+  little-endian machine, and a big-endian integer on a big-endian machine.\n+  If byte flipping is required for interoperability between big- and\n+  little-endian machines, this must be explicitly programmed.  This capability\n+  is not provided by `Bit_Order`.\n+\n+* Components that are positioned across byte boundaries\n+\n+  but do not occupy an integral number of bytes.  Given that bytes are not\n+  reordered, such fields would occupy a non-contiguous sequence of bits\n+  in memory, requiring non-trivial code to reassemble.  They are for this\n+  reason not permitted, and any component clause specifying such a layout\n+  will be flagged as illegal by GNAT.\n+\n+\n+Since the misconception that Bit_Order automatically deals with all\n+endian-related incompatibilities is a common one, the specification of\n+a component field that is an integral number of bytes will always\n+generate a warning.  This warning may be suppressed using `pragma Warnings (Off)` \n+if desired.  The following section contains additional\n+details regarding the issue of byte ordering.\n+\n+.. _Effect_of_Bit_Order_on_Byte_Ordering:\n+\n+Effect of Bit_Order on Byte Ordering\n+====================================\n+\n+.. index:: byte ordering\n+\n+.. index:: ordering, of bytes\n+\n+In this section we will review the effect of the `Bit_Order` attribute\n+definition clause on byte ordering.  Briefly, it has no effect at all, but\n+a detailed example will be helpful.  Before giving this\n+example, let us review the precise\n+definition of the effect of defining `Bit_Order`.  The effect of a\n+non-standard bit order is described in section 15.5.3 of the Ada\n+Reference Manual:\n+\n+   \"2   A bit ordering is a method of interpreting the meaning of\n+   the storage place attributes.\"\n+\n+To understand the precise definition of storage place attributes in\n+this context, we visit section 13.5.1 of the manual:\n+\n+   \"13   A record_representation_clause (without the mod_clause)\n+   specifies the layout.  The storage place attributes (see 13.5.2)\n+   are taken from the values of the position, first_bit, and last_bit\n+   expressions after normalizing those values so that first_bit is\n+   less than Storage_Unit.\"\n+\n+The critical point here is that storage places are taken from\n+the values after normalization, not before.  So the `Bit_Order`\n+interpretation applies to normalized values.  The interpretation\n+is described in the later part of the 15.5.3 paragraph:\n+\n+   \"2   A bit ordering is a method of interpreting the meaning of\n+   the storage place attributes.  High_Order_First (known in the\n+   vernacular as 'big endian') means that the first bit of a\n+   storage element (bit 0) is the most significant bit (interpreting\n+   the sequence of bits that represent a component as an unsigned\n+   integer value).  Low_Order_First (known in the vernacular as\n+   'little endian') means the opposite: the first bit is the\n+   least significant.\"\n+\n+Note that the numbering is with respect to the bits of a storage\n+unit.  In other words, the specification affects only the numbering\n+of bits within a single storage unit.\n+\n+We can make the effect clearer by giving an example.\n+\n+Suppose that we have an external device which presents two bytes, the first\n+byte presented, which is the first (low addressed byte) of the two byte\n+record is called Master, and the second byte is called Slave.\n+\n+The left most (most significant bit is called Control for each byte, and\n+the remaining 7 bits are called V1, V2, ... V7, where V7 is the rightmost\n+(least significant) bit.\n+\n+On a big-endian machine, we can write the following representation clause\n+\n+\n+.. code-block:: ada\n+\n+     type Data is record\n+        Master_Control : Bit;\n+        Master_V1      : Bit;\n+        Master_V2      : Bit;\n+        Master_V3      : Bit;\n+        Master_V4      : Bit;\n+        Master_V5      : Bit;\n+        Master_V6      : Bit;\n+        Master_V7      : Bit;\n+        Slave_Control  : Bit;\n+        Slave_V1       : Bit;\n+        Slave_V2       : Bit;\n+        Slave_V3       : Bit;\n+        Slave_V4       : Bit;\n+        Slave_V5       : Bit;\n+        Slave_V6       : Bit;\n+        Slave_V7       : Bit;\n+     end record;\n+\n+     for Data use record\n+        Master_Control at 0 range 0 .. 0;\n+        Master_V1      at 0 range 1 .. 1;\n+        Master_V2      at 0 range 2 .. 2;\n+        Master_V3      at 0 range 3 .. 3;\n+        Master_V4      at 0 range 4 .. 4;\n+        Master_V5      at 0 range 5 .. 5;\n+        Master_V6      at 0 range 6 .. 6;\n+        Master_V7      at 0 range 7 .. 7;\n+        Slave_Control  at 1 range 0 .. 0;\n+        Slave_V1       at 1 range 1 .. 1;\n+        Slave_V2       at 1 range 2 .. 2;\n+        Slave_V3       at 1 range 3 .. 3;\n+        Slave_V4       at 1 range 4 .. 4;\n+        Slave_V5       at 1 range 5 .. 5;\n+        Slave_V6       at 1 range 6 .. 6;\n+        Slave_V7       at 1 range 7 .. 7;\n+     end record;\n+  \n+\n+Now if we move this to a little endian machine, then the bit ordering within\n+the byte is backwards, so we have to rewrite the record rep clause as:\n+\n+\n+.. code-block:: ada\n+\n+     for Data use record\n+        Master_Control at 0 range 7 .. 7;\n+        Master_V1      at 0 range 6 .. 6;\n+        Master_V2      at 0 range 5 .. 5;\n+        Master_V3      at 0 range 4 .. 4;\n+        Master_V4      at 0 range 3 .. 3;\n+        Master_V5      at 0 range 2 .. 2;\n+        Master_V6      at 0 range 1 .. 1;\n+        Master_V7      at 0 range 0 .. 0;\n+        Slave_Control  at 1 range 7 .. 7;\n+        Slave_V1       at 1 range 6 .. 6;\n+        Slave_V2       at 1 range 5 .. 5;\n+        Slave_V3       at 1 range 4 .. 4;\n+        Slave_V4       at 1 range 3 .. 3;\n+        Slave_V5       at 1 range 2 .. 2;\n+        Slave_V6       at 1 range 1 .. 1;\n+        Slave_V7       at 1 range 0 .. 0;\n+     end record;\n+  \n+\n+It is a nuisance to have to rewrite the clause, especially if\n+the code has to be maintained on both machines.  However,\n+this is a case that we can handle with the\n+`Bit_Order` attribute if it is implemented.\n+Note that the implementation is not required on byte addressed\n+machines, but it is indeed implemented in GNAT.\n+This means that we can simply use the\n+first record clause, together with the declaration\n+\n+\n+.. code-block:: ada\n+\n+     for Data'Bit_Order use High_Order_First;\n+  \n+\n+and the effect is what is desired, namely the layout is exactly the same,\n+independent of whether the code is compiled on a big-endian or little-endian\n+machine.\n+\n+The important point to understand is that byte ordering is not affected.\n+A `Bit_Order` attribute definition never affects which byte a field\n+ends up in, only where it ends up in that byte.\n+To make this clear, let us rewrite the record rep clause of the previous\n+example as:\n+\n+\n+.. code-block:: ada\n+\n+     for Data'Bit_Order use High_Order_First;\n+     for Data use record\n+        Master_Control at 0 range  0 .. 0;\n+        Master_V1      at 0 range  1 .. 1;\n+        Master_V2      at 0 range  2 .. 2;\n+        Master_V3      at 0 range  3 .. 3;\n+        Master_V4      at 0 range  4 .. 4;\n+        Master_V5      at 0 range  5 .. 5;\n+        Master_V6      at 0 range  6 .. 6;\n+        Master_V7      at 0 range  7 .. 7;\n+        Slave_Control  at 0 range  8 .. 8;\n+        Slave_V1       at 0 range  9 .. 9;\n+        Slave_V2       at 0 range 10 .. 10;\n+        Slave_V3       at 0 range 11 .. 11;\n+        Slave_V4       at 0 range 12 .. 12;\n+        Slave_V5       at 0 range 13 .. 13;\n+        Slave_V6       at 0 range 14 .. 14;\n+        Slave_V7       at 0 range 15 .. 15;\n+     end record;\n+  \n+\n+This is exactly equivalent to saying (a repeat of the first example):\n+\n+\n+.. code-block:: ada\n+\n+     for Data'Bit_Order use High_Order_First;\n+     for Data use record\n+        Master_Control at 0 range 0 .. 0;\n+        Master_V1      at 0 range 1 .. 1;\n+        Master_V2      at 0 range 2 .. 2;\n+        Master_V3      at 0 range 3 .. 3;\n+        Master_V4      at 0 range 4 .. 4;\n+        Master_V5      at 0 range 5 .. 5;\n+        Master_V6      at 0 range 6 .. 6;\n+        Master_V7      at 0 range 7 .. 7;\n+        Slave_Control  at 1 range 0 .. 0;\n+        Slave_V1       at 1 range 1 .. 1;\n+        Slave_V2       at 1 range 2 .. 2;\n+        Slave_V3       at 1 range 3 .. 3;\n+        Slave_V4       at 1 range 4 .. 4;\n+        Slave_V5       at 1 range 5 .. 5;\n+        Slave_V6       at 1 range 6 .. 6;\n+        Slave_V7       at 1 range 7 .. 7;\n+     end record;\n+  \n+\n+Why are they equivalent? Well take a specific field, the `Slave_V2`\n+field.  The storage place attributes are obtained by normalizing the\n+values given so that the `First_Bit` value is less than 8.  After\n+normalizing the values (0,10,10) we get (1,2,2) which is exactly what\n+we specified in the other case.\n+\n+Now one might expect that the `Bit_Order` attribute might affect\n+bit numbering within the entire record component (two bytes in this\n+case, thus affecting which byte fields end up in), but that is not\n+the way this feature is defined, it only affects numbering of bits,\n+not which byte they end up in.\n+\n+Consequently it never makes sense to specify a starting bit number\n+greater than 7 (for a byte addressable field) if an attribute\n+definition for `Bit_Order` has been given, and indeed it\n+may be actively confusing to specify such a value, so the compiler\n+generates a warning for such usage.\n+\n+If you do need to control byte ordering then appropriate conditional\n+values must be used.  If in our example, the slave byte came first on\n+some machines we might write:\n+\n+.. code-block:: ada\n+\n+     Master_Byte_First constant Boolean := ...;\n+\n+     Master_Byte : constant Natural :=\n+                     1 - Boolean'Pos (Master_Byte_First);\n+     Slave_Byte  : constant Natural :=\n+                     Boolean'Pos (Master_Byte_First);\n+\n+     for Data'Bit_Order use High_Order_First;\n+     for Data use record\n+        Master_Control at Master_Byte range 0 .. 0;\n+        Master_V1      at Master_Byte range 1 .. 1;\n+        Master_V2      at Master_Byte range 2 .. 2;\n+        Master_V3      at Master_Byte range 3 .. 3;\n+        Master_V4      at Master_Byte range 4 .. 4;\n+        Master_V5      at Master_Byte range 5 .. 5;\n+        Master_V6      at Master_Byte range 6 .. 6;\n+        Master_V7      at Master_Byte range 7 .. 7;\n+        Slave_Control  at Slave_Byte  range 0 .. 0;\n+        Slave_V1       at Slave_Byte  range 1 .. 1;\n+        Slave_V2       at Slave_Byte  range 2 .. 2;\n+        Slave_V3       at Slave_Byte  range 3 .. 3;\n+        Slave_V4       at Slave_Byte  range 4 .. 4;\n+        Slave_V5       at Slave_Byte  range 5 .. 5;\n+        Slave_V6       at Slave_Byte  range 6 .. 6;\n+        Slave_V7       at Slave_Byte  range 7 .. 7;\n+     end record;\n+  \n+Now to switch between machines, all that is necessary is\n+to set the boolean constant `Master_Byte_First` in\n+an appropriate manner.\n+\n+.. _Pragma_Pack_for_Arrays:\n+\n+Pragma Pack for Arrays\n+======================\n+\n+.. index:: Pragma Pack (for arrays)\n+\n+Pragma `Pack` applied to an array has no effect unless the component type\n+is packable.  For a component type to be packable, it must be one of the\n+following cases:\n+\n+* \n+  Any scalar type\n+* \n+  Any type whose size is specified with a size clause\n+* \n+  Any packed array type with a static size\n+* \n+  Any record type padded because of its default alignment\n+\n+For all these cases, if the component subtype size is in the range\n+1 through 63, then the effect of the pragma `Pack` is exactly as though a\n+component size were specified giving the component subtype size.\n+For example if we have:\n+\n+.. code-block:: ada\n+\n+     type r is range 0 .. 17;\n+\n+     type ar is array (1 .. 8) of r;\n+     pragma Pack (ar);\n+  \n+Then the component size of `ar` will be set to 5 (i.e., to `r'size`,\n+and the size of the array `ar` will be exactly 40 bits.\n+\n+Note that in some cases this rather fierce approach to packing can produce\n+unexpected effects.  For example, in Ada 95 and Ada 2005,\n+subtype `Natural` typically has a size of 31, meaning that if you\n+pack an array of `Natural`, you get 31-bit\n+close packing, which saves a few bits, but results in far less efficient\n+access.  Since many other Ada compilers will ignore such a packing request,\n+GNAT will generate a warning on some uses of pragma `Pack` that it guesses\n+might not be what is intended.  You can easily remove this warning by\n+using an explicit `Component_Size` setting instead, which never generates\n+a warning, since the intention of the programmer is clear in this case.\n+\n+GNAT treats packed arrays in one of two ways.  If the size of the array is\n+known at compile time and is less than 64 bits, then internally the array\n+is represented as a single modular type, of exactly the appropriate number\n+of bits.  If the length is greater than 63 bits, or is not known at compile\n+time, then the packed array is represented as an array of bytes, and the\n+length is always a multiple of 8 bits.\n+\n+Note that to represent a packed array as a modular type, the alignment must\n+be suitable for the modular type involved. For example, on typical machines\n+a 32-bit packed array will be represented by a 32-bit modular integer with\n+an alignment of four bytes. If you explicitly override the default alignment\n+with an alignment clause that is too small, the modular representation\n+cannot be used. For example, consider the following set of declarations:\n+\n+.. code-block:: ada\n+\n+     type R is range 1 .. 3;\n+     type S is array (1 .. 31) of R;\n+     for S'Component_Size use 2;\n+     for S'Size use 62;\n+     for S'Alignment use 1;\n+\n+If the alignment clause were not present, then a 62-bit modular\n+representation would be chosen (typically with an alignment of 4 or 8\n+bytes depending on the target). But the default alignment is overridden\n+with the explicit alignment clause. This means that the modular\n+representation cannot be used, and instead the array of bytes\n+representation must be used, meaning that the length must be a multiple\n+of 8. Thus the above set of declarations will result in a diagnostic\n+rejecting the size clause and noting that the minimum size allowed is 64.\n+\n+.. index:: Pragma Pack (for type Natural)\n+\n+.. index:: Pragma Pack warning\n+\n+One special case that is worth noting occurs when the base type of the\n+component size is 8/16/32 and the subtype is one bit less. Notably this\n+occurs with subtype `Natural`. Consider:\n+\n+.. code-block:: ada\n+\n+     type Arr is array (1 .. 32) of Natural;\n+     pragma Pack (Arr);\n+  \n+In all commonly used Ada 83 compilers, this pragma Pack would be ignored,\n+since typically `Natural'Size` is 32 in Ada 83, and in any case most\n+Ada 83 compilers did not attempt 31 bit packing.\n+\n+In Ada 95 and Ada 2005, `Natural'Size` is required to be 31. Furthermore,\n+GNAT really does pack 31-bit subtype to 31 bits. This may result in a\n+substantial unintended performance penalty when porting legacy Ada 83 code.\n+To help prevent this, GNAT generates a warning in such cases. If you really\n+want 31 bit packing in a case like this, you can set the component size\n+explicitly:\n+\n+.. code-block:: ada\n+\n+     type Arr is array (1 .. 32) of Natural;\n+     for Arr'Component_Size use 31;\n+  \n+Here 31-bit packing is achieved as required, and no warning is generated,\n+since in this case the programmer intention is clear.\n+\n+.. _Pragma_Pack_for_Records:\n+\n+Pragma Pack for Records\n+=======================\n+\n+.. index:: Pragma Pack (for records)\n+\n+Pragma `Pack` applied to a record will pack the components to reduce\n+wasted space from alignment gaps and by reducing the amount of space\n+taken by components.  We distinguish between *packable* components and\n+*non-packable* components.\n+Components of the following types are considered packable:\n+\n+* \n+  Components of a primitive type are packable unless they are aliased\n+  or of an atomic type.\n+\n+* \n+  Small packed arrays, whose size does not exceed 64 bits, and where the\n+  size is statically known at compile time, are represented internally\n+  as modular integers, and so they are also packable.\n+\n+\n+All packable components occupy the exact number of bits corresponding to\n+their `Size` value, and are packed with no padding bits, i.e., they\n+can start on an arbitrary bit boundary.\n+\n+All other types are non-packable, they occupy an integral number of\n+storage units, and\n+are placed at a boundary corresponding to their alignment requirements.\n+\n+For example, consider the record\n+\n+.. code-block:: ada\n+\n+     type Rb1 is array (1 .. 13) of Boolean;\n+     pragma Pack (Rb1);\n+\n+     type Rb2 is array (1 .. 65) of Boolean;\n+     pragma Pack (Rb2);\n+\n+     type AF is new Float with Atomic;\n+\n+     type X2 is record\n+        L1 : Boolean;\n+        L2 : Duration;\n+        L3 : AF;\n+        L4 : Boolean;\n+        L5 : Rb1;\n+        L6 : Rb2;\n+     end record;\n+     pragma Pack (X2);\n+  \n+The representation for the record X2 is as follows:\n+\n+.. code-block:: ada\n+\n+  for X2'Size use 224;\n+  for X2 use record\n+     L1 at  0 range  0 .. 0;\n+     L2 at  0 range  1 .. 64;\n+     L3 at 12 range  0 .. 31;\n+     L4 at 16 range  0 .. 0;\n+     L5 at 16 range  1 .. 13;\n+     L6 at 18 range  0 .. 71;\n+  end record;\n+\n+Studying this example, we see that the packable fields `L1`\n+and `L2` are\n+of length equal to their sizes, and placed at specific bit boundaries (and\n+not byte boundaries) to\n+eliminate padding.  But `L3` is of a non-packable float type (because\n+it is aliased), so it is on the next appropriate alignment boundary.\n+\n+The next two fields are fully packable, so `L4` and `L5` are\n+minimally packed with no gaps.  However, type `Rb2` is a packed\n+array that is longer than 64 bits, so it is itself non-packable.  Thus\n+the `L6` field is aligned to the next byte boundary, and takes an\n+integral number of bytes, i.e., 72 bits.\n+\n+.. _Record_Representation_Clauses:\n+\n+Record Representation Clauses\n+=============================\n+\n+.. index:: Record Representation Clause\n+\n+Record representation clauses may be given for all record types, including\n+types obtained by record extension.  Component clauses are allowed for any\n+static component.  The restrictions on component clauses depend on the type\n+of the component.\n+\n+.. index:: Component Clause\n+\n+For all components of an elementary type, the only restriction on component\n+clauses is that the size must be at least the 'Size value of the type\n+(actually the Value_Size).  There are no restrictions due to alignment,\n+and such components may freely cross storage boundaries.\n+\n+Packed arrays with a size up to and including 64 bits are represented\n+internally using a modular type with the appropriate number of bits, and\n+thus the same lack of restriction applies.  For example, if you declare:\n+\n+.. code-block:: ada\n+\n+     type R is array (1 .. 49) of Boolean;\n+     pragma Pack (R);\n+     for R'Size use 49;\n+  \n+then a component clause for a component of type R may start on any\n+specified bit boundary, and may specify a value of 49 bits or greater.\n+\n+For packed bit arrays that are longer than 64 bits, there are two\n+cases. If the component size is a power of 2 (1,2,4,8,16,32 bits),\n+including the important case of single bits or boolean values, then\n+there are no limitations on placement of such components, and they\n+may start and end at arbitrary bit boundaries.\n+\n+If the component size is not a power of 2 (e.g., 3 or 5), then\n+an array of this type longer than 64 bits must always be placed on\n+on a storage unit (byte) boundary and occupy an integral number\n+of storage units (bytes). Any component clause that does not\n+meet this requirement will be rejected.\n+\n+Any aliased component, or component of an aliased type, must\n+have its normal alignment and size. A component clause that\n+does not meet this requirement will be rejected.\n+\n+The tag field of a tagged type always occupies an address sized field at\n+the start of the record.  No component clause may attempt to overlay this\n+tag. When a tagged type appears as a component, the tag field must have\n+proper alignment\n+\n+In the case of a record extension T1, of a type T, no component clause applied\n+to the type T1 can specify a storage location that would overlap the first\n+T'Size bytes of the record.\n+\n+For all other component types, including non-bit-packed arrays,\n+the component can be placed at an arbitrary bit boundary,\n+so for example, the following is permitted:\n+\n+.. code-block:: ada\n+\n+     type R is array (1 .. 10) of Boolean;\n+     for R'Size use 80;\n+\n+     type Q is record\n+        G, H : Boolean;\n+        L, M : R;\n+     end record;\n+\n+     for Q use record\n+        G at 0 range  0 ..   0;\n+        H at 0 range  1 ..   1;\n+        L at 0 range  2 ..  81;\n+        R at 0 range 82 .. 161;\n+     end record;\n+  \n+Note: the above rules apply to recent releases of GNAT 5.\n+In GNAT 3, there are more severe restrictions on larger components.\n+For non-primitive types, including packed arrays with a size greater than\n+64 bits, component clauses must respect the alignment requirement of the\n+type, in particular, always starting on a byte boundary, and the length\n+must be a multiple of the storage unit.\n+\n+.. _Handling_of_Records_with_Holes:\n+\n+Handling of Records with Holes\n+==============================\n+\n+.. index:: Handling of Records with Holes\n+\n+As a result of alignment considerations, records may contain \"holes\"\n+or gaps\n+which do not correspond to the data bits of any of the components.\n+Record representation clauses can also result in holes in records.\n+\n+GNAT does not attempt to clear these holes, so in record objects,\n+they should be considered to hold undefined rubbish. The generated\n+equality routine just tests components so does not access these\n+undefined bits, and assignment and copy operations may or may not\n+preserve the contents of these holes (for assignments, the holes\n+in the target will in practice contain either the bits that are\n+present in the holes in the source, or the bits that were present\n+in the target before the assignment).\n+\n+If it is necessary to ensure that holes in records have all zero\n+bits, then record objects for which this initialization is desired\n+should be explicitly set to all zero values using Unchecked_Conversion\n+or address overlays. For example\n+\n+.. code-block:: ada\n+\n+  type HRec is record\n+     C : Character;\n+     I : Integer;\n+  end record;\n+  \n+On typical machines, integers need to be aligned on a four-byte\n+boundary, resulting in three bytes of undefined rubbish following\n+the 8-bit field for C. To ensure that the hole in a variable of\n+type HRec is set to all zero bits,\n+you could for example do:\n+\n+.. code-block:: ada\n+\n+  type Base is record\n+     Dummy1, Dummy2 : Integer := 0;\n+  end record;\n+\n+  BaseVar : Base;\n+  RealVar : Hrec;\n+  for RealVar'Address use BaseVar'Address;\n+  \n+\n+Now the 8-bytes of the value of RealVar start out containing all zero\n+bits. A safer approach is to just define dummy fields, avoiding the\n+holes, as in:\n+\n+.. code-block:: ada\n+\n+  type HRec is record\n+     C      : Character;\n+     Dummy1 : Short_Short_Integer := 0;\n+     Dummy2 : Short_Short_Integer := 0;\n+     Dummy3 : Short_Short_Integer := 0;\n+     I      : Integer;\n+  end record;\n+  \n+And to make absolutely sure that the intent of this is followed, you\n+can use representation clauses:\n+\n+.. code-block:: ada\n+\n+  for Hrec use record\n+     C      at 0 range 0 .. 7;\n+     Dummy1 at 1 range 0 .. 7;\n+     Dummy2 at 2 range 0 .. 7;\n+     Dummy3 at 3 range 0 .. 7;\n+     I      at 4 range 0 .. 31;\n+  end record;\n+  for Hrec'Size use 64;\n+  \n+\n+.. _Enumeration_Clauses:\n+\n+Enumeration Clauses\n+===================\n+\n+The only restriction on enumeration clauses is that the range of values\n+must be representable.  For the signed case, if one or more of the\n+representation values are negative, all values must be in the range:\n+\n+.. code-block:: ada\n+\n+     System.Min_Int .. System.Max_Int\n+\n+For the unsigned case, where all values are nonnegative, the values must\n+be in the range:\n+\n+.. code-block:: ada\n+\n+     0 .. System.Max_Binary_Modulus;\n+  \n+\n+A *confirming* representation clause is one in which the values range\n+from 0 in sequence, i.e., a clause that confirms the default representation\n+for an enumeration type.\n+Such a confirming representation\n+is permitted by these rules, and is specially recognized by the compiler so\n+that no extra overhead results from the use of such a clause.\n+\n+If an array has an index type which is an enumeration type to which an\n+enumeration clause has been applied, then the array is stored in a compact\n+manner.  Consider the declarations:\n+\n+.. code-block:: ada\n+\n+     type r is (A, B, C);\n+     for r use (A => 1, B => 5, C => 10);\n+     type t is array (r) of Character;\n+  \n+The array type t corresponds to a vector with exactly three elements and\n+has a default size equal to `3*Character'Size`.  This ensures efficient\n+use of space, but means that accesses to elements of the array will incur\n+the overhead of converting representation values to the corresponding\n+positional values, (i.e., the value delivered by the `Pos` attribute).\n+\n+\n+.. _Address_Clauses:\n+\n+Address Clauses\n+===============\n+.. index:: Address Clause\n+\n+The reference manual allows a general restriction on representation clauses,\n+as found in RM 13.1(22):\n+\n+   \"An implementation need not support representation\n+   items containing nonstatic expressions, except that\n+   an implementation should support a representation item\n+   for a given entity if each nonstatic expression in the\n+   representation item is a name that statically denotes\n+   a constant declared before the entity.\"\n+\n+In practice this is applicable only to address clauses, since this is the\n+only case in which a non-static expression is permitted by the syntax.  As\n+the AARM notes in sections 13.1 (22.a-22.h):\n+\n+   22.a   Reason: This is to avoid the following sort of thing:\n+\n+   22.b        X : Integer := F(...);\n+   Y : Address := G(...);\n+   for X'Address use Y;\n+\n+   22.c   In the above, we have to evaluate the\n+   initialization expression for X before we\n+   know where to put the result.  This seems\n+   like an unreasonable implementation burden.\n+\n+   22.d   The above code should instead be written\n+   like this:\n+\n+   22.e        Y : constant Address := G(...);\n+   X : Integer := F(...);\n+   for X'Address use Y;\n+\n+   22.f   This allows the expression 'Y' to be safely\n+   evaluated before X is created.\n+\n+   22.g   The constant could be a formal parameter of mode in.\n+\n+   22.h   An implementation can support other nonstatic\n+   expressions if it wants to.  Expressions of type\n+   Address are hardly ever static, but their value\n+   might be known at compile time anyway in many\n+   cases.\n+\n+GNAT does indeed permit many additional cases of non-static expressions.  In\n+particular, if the type involved is elementary there are no restrictions\n+(since in this case, holding a temporary copy of the initialization value,\n+if one is present, is inexpensive).  In addition, if there is no implicit or\n+explicit initialization, then there are no restrictions.  GNAT will reject\n+only the case where all three of these conditions hold:\n+\n+* \n+  The type of the item is non-elementary (e.g., a record or array).\n+\n+* \n+  There is explicit or implicit initialization required for the object.\n+  Note that access values are always implicitly initialized.\n+\n+* \n+  The address value is non-static.  Here GNAT is more permissive than the\n+  RM, and allows the address value to be the address of a previously declared\n+  stand-alone variable, as long as it does not itself have an address clause.\n+\n+  ::\n+\n+               Anchor  : Some_Initialized_Type;\n+               Overlay : Some_Initialized_Type;\n+               for Overlay'Address use Anchor'Address;\n+    \n+  However, the prefix of the address clause cannot be an array component, or\n+  a component of a discriminated record.\n+\n+As noted above in section 22.h, address values are typically non-static.  In\n+particular the To_Address function, even if applied to a literal value, is\n+a non-static function call.  To avoid this minor annoyance, GNAT provides\n+the implementation defined attribute 'To_Address.  The following two\n+expressions have identical values:\n+\n+.. index:: Attribute\n+.. index:: To_Address\n+\n+.. code-block:: ada\n+\n+     To_Address (16#1234_0000#)\n+     System'To_Address (16#1234_0000#);\n+  \n+except that the second form is considered to be a static expression, and\n+thus when used as an address clause value is always permitted.\n+\n+Additionally, GNAT treats as static an address clause that is an\n+unchecked_conversion of a static integer value.  This simplifies the porting\n+of legacy code, and provides a portable equivalent to the GNAT attribute\n+`To_Address`.\n+\n+Another issue with address clauses is the interaction with alignment\n+requirements.  When an address clause is given for an object, the address\n+value must be consistent with the alignment of the object (which is usually\n+the same as the alignment of the type of the object).  If an address clause\n+is given that specifies an inappropriately aligned address value, then the\n+program execution is erroneous.\n+\n+Since this source of erroneous behavior can have unfortunate effects, GNAT\n+checks (at compile time if possible, generating a warning, or at execution\n+time with a run-time check) that the alignment is appropriate.  If the\n+run-time check fails, then `Program_Error` is raised.  This run-time\n+check is suppressed if range checks are suppressed, or if the special GNAT\n+check Alignment_Check is suppressed, or if\n+`pragma Restrictions (No_Elaboration_Code)` is in effect.\n+\n+Finally, GNAT does not permit overlaying of objects of controlled types or\n+composite types containing a controlled component. In most cases, the compiler\n+can detect an attempt at such overlays and will generate a warning at compile\n+time and a Program_Error exception at run time.\n+\n+.. index:: Export\n+\n+An address clause cannot be given for an exported object.  More\n+understandably the real restriction is that objects with an address\n+clause cannot be exported.  This is because such variables are not\n+defined by the Ada program, so there is no external object to export.\n+\n+.. index:: Import\n+\n+It is permissible to give an address clause and a pragma Import for the\n+same object.  In this case, the variable is not really defined by the\n+Ada program, so there is no external symbol to be linked.  The link name\n+and the external name are ignored in this case.  The reason that we allow this\n+combination is that it provides a useful idiom to avoid unwanted\n+initializations on objects with address clauses.\n+\n+When an address clause is given for an object that has implicit or\n+explicit initialization, then by default initialization takes place.  This\n+means that the effect of the object declaration is to overwrite the\n+memory at the specified address.  This is almost always not what the\n+programmer wants, so GNAT will output a warning:\n+\n+::\n+\n+    with System;\n+    package G is\n+       type R is record\n+          M : Integer := 0;\n+       end record;\n+\n+       Ext : R;\n+       for Ext'Address use System'To_Address (16#1234_1234#);\n+           |\n+    >>> warning: implicit initialization of \"Ext\" may\n+        modify overlaid storage\n+    >>> warning: use pragma Import for \"Ext\" to suppress\n+        initialization (RM B(24))\n+\n+    end G;\n+  \n+As indicated by the warning message, the solution is to use a (dummy) pragma\n+Import to suppress this initialization.  The pragma tell the compiler that the\n+object is declared and initialized elsewhere.  The following package compiles\n+without warnings (and the initialization is suppressed):\n+\n+.. code-block:: ada\n+\n+     with System;\n+     package G is\n+        type R is record\n+           M : Integer := 0;\n+        end record;\n+\n+        Ext : R;\n+        for Ext'Address use System'To_Address (16#1234_1234#);\n+        pragma Import (Ada, Ext);\n+     end G;\n+  \n+\n+A final issue with address clauses involves their use for overlaying\n+variables, as in the following example:\n+\n+.. index:: Overlaying of objects\n+\n+.. code-block:: ada\n+\n+    A : Integer;\n+    B : Integer;\n+    for B'Address use A'Address;\n+  \n+\n+or alternatively, using the form recommended by the RM:\n+\n+.. code-block:: ada\n+\n+    A    : Integer;\n+    Addr : constant Address := A'Address;\n+    B    : Integer;\n+    for B'Address use Addr;\n+  \n+\n+In both of these cases, `A`\n+and `B` become aliased to one another via the\n+address clause. This use of address clauses to overlay\n+variables, achieving an effect similar to unchecked\n+conversion was erroneous in Ada 83, but in Ada 95 and Ada 2005\n+the effect is implementation defined. Furthermore, the\n+Ada RM specifically recommends that in a situation\n+like this, `B` should be subject to the following\n+implementation advice (RM 13.3(19)):\n+\n+   \"19  If the Address of an object is specified, or it is imported\n+   or exported, then the implementation should not perform\n+   optimizations based on assumptions of no aliases.\"\n+\n+GNAT follows this recommendation, and goes further by also applying\n+this recommendation to the overlaid variable (`A`\n+in the above example) in this case. This means that the overlay\n+works \"as expected\", in that a modification to one of the variables\n+will affect the value of the other.\n+\n+Note that when address clause overlays are used in this way, there is an\n+issue of unintentional initialization, as shown by this example:\n+\n+::\n+\n+  package Overwrite_Record is\n+     type R is record\n+        A : Character := 'C';\n+        B : Character := 'A';\n+     end record;\n+     X : Short_Integer := 3;\n+     Y : R;\n+     for Y'Address use X'Address;\n+         |\n+  >>> warning: default initialization of \"Y\" may\n+      modify \"X\", use pragma Import for \"Y\" to\n+      suppress initialization (RM B.1(24))\n+\n+  end Overwrite_Record;\n+  \n+Here the default initialization of `Y` will clobber the value\n+of `X`, which justifies the warning. The warning notes that\n+this effect can be eliminated by adding a `pragma Import`\n+which suppresses the initialization:\n+\n+.. code-block:: ada\n+\n+  package Overwrite_Record is\n+     type R is record\n+        A : Character := 'C';\n+        B : Character := 'A';\n+     end record;\n+     X : Short_Integer := 3;\n+     Y : R;\n+     for Y'Address use X'Address;\n+     pragma Import (Ada, Y);\n+  end Overwrite_Record;\n+  \n+\n+Note that the use of `pragma Initialize_Scalars` may cause variables to\n+be initialized when they would not otherwise have been in the absence\n+of the use of this pragma. This may cause an overlay to have this\n+unintended clobbering effect. The compiler avoids this for scalar\n+types, but not for composite objects (where in general the effect\n+of `Initialize_Scalars` is part of the initialization routine\n+for the composite object:\n+\n+::\n+\n+  pragma Initialize_Scalars;\n+  with Ada.Text_IO;  use Ada.Text_IO;\n+  procedure Overwrite_Array is\n+     type Arr is array (1 .. 5) of Integer;\n+     X : Arr := (others => 1);\n+     A : Arr;\n+     for A'Address use X'Address;\n+         |\n+  >>> warning: default initialization of \"A\" may\n+      modify \"X\", use pragma Import for \"A\" to\n+      suppress initialization (RM B.1(24))\n+\n+  begin\n+     if X /= Arr'(others => 1) then\n+        Put_Line (\"X was clobbered\");\n+     else\n+        Put_Line (\"X was not clobbered\");\n+     end if;\n+  end Overwrite_Array;\n+  \n+The above program generates the warning as shown, and at execution\n+time, prints `X was clobbered`. If the `pragma Import` is\n+added as suggested:\n+\n+.. code-block:: ada\n+\n+  pragma Initialize_Scalars;\n+  with Ada.Text_IO;  use Ada.Text_IO;\n+  procedure Overwrite_Array is\n+     type Arr is array (1 .. 5) of Integer;\n+     X : Arr := (others => 1);\n+     A : Arr;\n+     for A'Address use X'Address;\n+     pragma Import (Ada, A);\n+  begin\n+     if X /= Arr'(others => 1) then\n+        Put_Line (\"X was clobbered\");\n+     else\n+        Put_Line (\"X was not clobbered\");\n+     end if;\n+  end Overwrite_Array;\n+  \n+then the program compiles without the warning and when run will generate\n+the output `X was not clobbered`.\n+\n+\n+.. _Use_of_Address_Clauses_for_Memory-Mapped_I/O:\n+\n+Use of Address Clauses for Memory-Mapped I/O\n+============================================\n+\n+.. index:: Memory-mapped I/O\n+\n+A common pattern is to use an address clause to map an atomic variable to\n+a location in memory that corresponds to a memory-mapped I/O operation or\n+operations, for example:\n+\n+.. code-block:: ada\n+\n+      type Mem_Word is record\n+         A,B,C,D : Byte;\n+      end record;\n+      pragma Atomic (Mem_Word);\n+      for Mem_Word_Size use 32;\n+\n+      Mem : Mem_Word;\n+      for Mem'Address use some-address;\n+      ...\n+      Temp := Mem;\n+      Temp.A := 32;\n+      Mem := Temp;\n+  \n+For a full access (reference or modification) of the variable (Mem) in\n+this case, as in the above examples, GNAT guarantees that the entire atomic\n+word will be accessed. It is not clear whether the RM requires this. For\n+example in the above, can the compiler reference only the Mem.A field as\n+an optimization? Whatever the answer to this question is, GNAT makes the\n+guarantee that for such a reference, the entire word is read or written.\n+\n+A problem arises with a component access such as:\n+\n+.. code-block:: ada\n+\n+      Mem.A := 32;\n+  \n+Note that the component A is not declared as atomic. This means that it is\n+not clear what this assignment means. It could correspond to full word read\n+and write as given in the first example, or on architectures that supported\n+such an operation it might be a single byte store instruction. The RM does\n+not have anything to say in this situation, and GNAT does not make any\n+guarantee. The code generated may vary from target to target. GNAT will issue\n+a warning in such a case:\n+\n+::\n+\n+      Mem.A := 32;\n+      |\n+      >>> warning: access to non-atomic component of atomic array,\n+          may cause unexpected accesses to atomic object\n+  \n+It is best to be explicit in this situation, by either declaring the\n+components to be atomic if you want the byte store, or explicitly writing\n+the full word access sequence if that is what the hardware requires.\n+\n+\n+.. _Effect_of_Convention_on_Representation:\n+\n+Effect of Convention on Representation\n+======================================\n+\n+.. index:: Convention, effect on representation\n+\n+Normally the specification of a foreign language convention for a type or\n+an object has no effect on the chosen representation.  In particular, the\n+representation chosen for data in GNAT generally meets the standard system\n+conventions, and for example records are laid out in a manner that is\n+consistent with C.  This means that specifying convention C (for example)\n+has no effect.\n+\n+There are four exceptions to this general rule:\n+\n+* *Convention Fortran and array subtypes*.\n+\n+  If pragma Convention Fortran is specified for an array subtype, then in\n+  accordance with the implementation advice in section 3.6.2(11) of the\n+  Ada Reference Manual, the array will be stored in a Fortran-compatible\n+  column-major manner, instead of the normal default row-major order.\n+\n+* *Convention C and enumeration types*\n+\n+  GNAT normally stores enumeration types in 8, 16, or 32 bits as required\n+  to accommodate all values of the type.  For example, for the enumeration\n+  type declared by:\n+\n+  ::\n+\n+       type Color is (Red, Green, Blue);\n+    \n+  8 bits is sufficient to store all values of the type, so by default, objects\n+  of type `Color` will be represented using 8 bits.  However, normal C\n+  convention is to use 32 bits for all enum values in C, since enum values\n+  are essentially of type int.  If pragma `Convention C` is specified for an\n+  Ada enumeration type, then the size is modified as necessary (usually to\n+  32 bits) to be consistent with the C convention for enum values.\n+\n+  Note that this treatment applies only to types. If Convention C is given for\n+  an enumeration object, where the enumeration type is not Convention C, then\n+  Object_Size bits are allocated. For example, for a normal enumeration type,\n+  with less than 256 elements, only 8 bits will be allocated for the object.\n+  Since this may be a surprise in terms of what C expects, GNAT will issue a\n+  warning in this situation. The warning can be suppressed by giving an explicit\n+  size clause specifying the desired size.\n+\n+* *Convention C/Fortran and Boolean types*\n+\n+  In C, the usual convention for boolean values, that is values used for\n+  conditions, is that zero represents false, and nonzero values represent\n+  true.  In Ada, the normal convention is that two specific values, typically\n+  0/1, are used to represent false/true respectively.\n+\n+  Fortran has a similar convention for `LOGICAL` values (any nonzero\n+  value represents true).\n+\n+  To accommodate the Fortran and C conventions, if a pragma Convention specifies\n+  C or Fortran convention for a derived Boolean, as in the following example:\n+\n+  ::\n+\n+       type C_Switch is new Boolean;\n+       pragma Convention (C, C_Switch);\n+    \n+\n+  then the GNAT generated code will treat any nonzero value as true.  For truth\n+  values generated by GNAT, the conventional value 1 will be used for True, but\n+  when one of these values is read, any nonzero value is treated as True.\n+\n+\n+.. _Conventions_and_Anonymous_Access_Types:\n+\n+Conventions and Anonymous Access Types\n+======================================\n+\n+.. index:: Anonymous access types\n+\n+.. index:: Convention for anonymous access types\n+\n+The RM is not entirely clear on convention handling in a number of cases,\n+and in particular, it is not clear on the convention to be given to\n+anonymous access types in general, and in particular what is to be\n+done for the case of anonymous access-to-subprogram.\n+\n+In GNAT, we decide that if an explicit Convention is applied\n+to an object or component, and its type is such an anonymous type,\n+then the convention will apply to this anonymous type as well. This\n+seems to make sense since it is anomolous in any case to have a\n+different convention for an object and its type, and there is clearly\n+no way to explicitly specify a convention for an anonymous type, since\n+it doesn't have a name to specify!\n+\n+Furthermore, we decide that if a convention is applied to a record type,\n+then this convention is inherited by any of its components that are of an\n+anonymous access type which do not have an explicitly specified convention.\n+\n+The following program shows these conventions in action:\n+\n+::\n+\n+  package ConvComp is\n+     type Foo is range 1 .. 10;\n+     type T1 is record\n+        A : access function (X : Foo) return Integer;\n+        B : Integer;\n+     end record;\n+     pragma Convention (C, T1);\n+\n+     type T2 is record\n+        A : access function (X : Foo) return Integer;\n+        pragma Convention  (C, A);\n+        B : Integer;\n+     end record;\n+     pragma Convention (COBOL, T2);\n+\n+     type T3 is record\n+        A : access function (X : Foo) return Integer;\n+        pragma Convention  (COBOL, A);\n+        B : Integer;\n+     end record;\n+     pragma Convention (C, T3);\n+\n+     type T4 is record\n+        A : access function (X : Foo) return Integer;\n+        B : Integer;\n+     end record;\n+     pragma Convention (COBOL, T4);\n+\n+     function F (X : Foo) return Integer;\n+     pragma Convention (C, F);\n+\n+     function F (X : Foo) return Integer is (13);\n+\n+     TV1 : T1 := (F'Access, 12);  -- OK\n+     TV2 : T2 := (F'Access, 13);  -- OK\n+\n+     TV3 : T3 := (F'Access, 13);  -- ERROR\n+                  |\n+  >>> subprogram \"F\" has wrong convention\n+  >>> does not match access to subprogram declared at line 17\n+       38.    TV4 : T4 := (F'Access, 13);  -- ERROR\n+                  |\n+  >>> subprogram \"F\" has wrong convention\n+  >>> does not match access to subprogram declared at line 24\n+       39. end ConvComp;\n+  \n+\n+.. _Determining_the_Representations_chosen_by_GNAT:\n+\n+Determining the Representations chosen by GNAT\n+==============================================\n+\n+.. index:: Representation, determination of\n+\n+.. index:: -gnatR (gcc)\n+\n+Although the descriptions in this section are intended to be complete, it is\n+often easier to simply experiment to see what GNAT accepts and what the\n+effect is on the layout of types and objects.\n+\n+As required by the Ada RM, if a representation clause is not accepted, then\n+it must be rejected as illegal by the compiler.  However, when a\n+representation clause or pragma is accepted, there can still be questions\n+of what the compiler actually does.  For example, if a partial record\n+representation clause specifies the location of some components and not\n+others, then where are the non-specified components placed? Or if pragma\n+`Pack` is used on a record, then exactly where are the resulting\n+fields placed? The section on pragma `Pack` in this chapter can be\n+used to answer the second question, but it is often easier to just see\n+what the compiler does.\n+\n+For this purpose, GNAT provides the option *-gnatR*.  If you compile\n+with this option, then the compiler will output information on the actual\n+representations chosen, in a format similar to source representation\n+clauses.  For example, if we compile the package:\n+\n+.. code-block:: ada\n+\n+  package q is\n+     type r (x : boolean) is tagged record\n+        case x is\n+           when True => S : String (1 .. 100);\n+           when False => null;\n+        end case;\n+     end record;\n+\n+     type r2 is new r (false) with record\n+        y2 : integer;\n+     end record;\n+\n+     for r2 use record\n+        y2 at 16 range 0 .. 31;\n+     end record;\n+\n+     type x is record\n+        y : character;\n+     end record;\n+\n+     type x1 is array (1 .. 10) of x;\n+     for x1'component_size use 11;\n+\n+     type ia is access integer;\n+\n+     type Rb1 is array (1 .. 13) of Boolean;\n+     pragma Pack (rb1);\n+\n+     type Rb2 is array (1 .. 65) of Boolean;\n+     pragma Pack (rb2);\n+\n+     type x2 is record\n+        l1 : Boolean;\n+        l2 : Duration;\n+        l3 : Float;\n+        l4 : Boolean;\n+        l5 : Rb1;\n+        l6 : Rb2;\n+     end record;\n+     pragma Pack (x2);\n+  end q;\n+  \n+using the switch *-gnatR* we obtain the following output:\n+\n+.. code-block:: ada\n+\n+  Representation information for unit q\n+  -------------------------------------\n+\n+  for r'Size use ??;\n+  for r'Alignment use 4;\n+  for r use record\n+     x    at 4 range  0 .. 7;\n+     _tag at 0 range  0 .. 31;\n+     s    at 5 range  0 .. 799;\n+  end record;\n+\n+  for r2'Size use 160;\n+  for r2'Alignment use 4;\n+  for r2 use record\n+     x       at  4 range  0 .. 7;\n+     _tag    at  0 range  0 .. 31;\n+     _parent at  0 range  0 .. 63;\n+     y2      at 16 range  0 .. 31;\n+  end record;\n+\n+  for x'Size use 8;\n+  for x'Alignment use 1;\n+  for x use record\n+     y at 0 range  0 .. 7;\n+  end record;\n+\n+  for x1'Size use 112;\n+  for x1'Alignment use 1;\n+  for x1'Component_Size use 11;\n+\n+  for rb1'Size use 13;\n+  for rb1'Alignment use 2;\n+  for rb1'Component_Size use 1;\n+\n+  for rb2'Size use 72;\n+  for rb2'Alignment use 1;\n+  for rb2'Component_Size use 1;\n+\n+  for x2'Size use 224;\n+  for x2'Alignment use 4;\n+  for x2 use record\n+     l1 at  0 range  0 .. 0;\n+     l2 at  0 range  1 .. 64;\n+     l3 at 12 range  0 .. 31;\n+     l4 at 16 range  0 .. 0;\n+     l5 at 16 range  1 .. 13;\n+     l6 at 18 range  0 .. 71;\n+  end record;\n+  \n+The Size values are actually the Object_Size, i.e., the default size that\n+will be allocated for objects of the type.\n+The ``??`` size for type r indicates that we have a variant record, and the\n+actual size of objects will depend on the discriminant value.\n+\n+The Alignment values show the actual alignment chosen by the compiler\n+for each record or array type.\n+\n+The record representation clause for type r shows where all fields\n+are placed, including the compiler generated tag field (whose location\n+cannot be controlled by the programmer).\n+\n+The record representation clause for the type extension r2 shows all the\n+fields present, including the parent field, which is a copy of the fields\n+of the parent type of r2, i.e., r1.\n+\n+The component size and size clauses for types rb1 and rb2 show\n+the exact effect of pragma `Pack` on these arrays, and the record\n+representation clause for type x2 shows how pragma `Pack` affects\n+this record type.\n+\n+In some cases, it may be useful to cut and paste the representation clauses\n+generated by the compiler into the original source to fix and guarantee\n+the actual representation to be used."}, {"sha": "15b4a9483d0eb16e3ede1066ab1ac0e290d27ef4", "filename": "gcc/ada/doc/gnat_rm/specialized_needs_annexes.rst", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fspecialized_needs_annexes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fspecialized_needs_annexes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fspecialized_needs_annexes.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,37 @@\n+.. _Specialized_Needs_Annexes:\n+\n+*************************\n+Specialized Needs Annexes\n+*************************\n+\n+Ada 95, Ada 2005, and Ada 2012 define a number of Specialized Needs Annexes, which are not\n+required in all implementations.  However, as described in this chapter,\n+GNAT implements all of these annexes:\n+\n+*Systems Programming (Annex C)*\n+  The Systems Programming Annex is fully implemented.\n+\n+\n+*Real-Time Systems (Annex D)*\n+  The Real-Time Systems Annex is fully implemented.\n+\n+\n+*Distributed Systems (Annex E)*\n+  Stub generation is fully implemented in the GNAT compiler.  In addition,\n+  a complete compatible PCS is available as part of the GLADE system,\n+  a separate product.  When the two\n+  products are used in conjunction, this annex is fully implemented.\n+\n+\n+*Information Systems (Annex F)*\n+  The Information Systems annex is fully implemented.\n+\n+\n+*Numerics (Annex G)*\n+  The Numerics Annex is fully implemented.\n+\n+\n+*Safety and Security / High-Integrity Systems (Annex H)*\n+  The Safety and Security Annex (termed the High-Integrity Systems Annex\n+  in Ada 2005) is fully implemented.\n+"}, {"sha": "c5cabb98af4bf8e45c48c670c6572e2145a98128", "filename": "gcc/ada/doc/gnat_rm/standard_and_implementation_defined_restrictions.rst", "status": "added", "additions": 1057, "deletions": 0, "changes": 1057, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_and_implementation_defined_restrictions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_and_implementation_defined_restrictions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_and_implementation_defined_restrictions.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,1057 @@\n+.. _Standard_and_Implementation_Defined_Restrictions:\n+\n+************************************************\n+Standard and Implementation Defined Restrictions\n+************************************************\n+\n+All Ada Reference Manual-defined Restriction identifiers are implemented:\n+\n+* language-defined restrictions (see 13.12.1)\n+* tasking restrictions (see D.7)\n+* high integrity restrictions (see H.4)\n+\n+GNAT implements additional restriction identifiers. All restrictions, whether\n+language defined or GNAT-specific, are listed in the following.\n+\n+.. _Partition-Wide_Restrictions:\n+\n+Partition-Wide Restrictions\n+===========================\n+\n+There are two separate lists of restriction identifiers. The first\n+set requires consistency throughout a partition (in other words, if the\n+restriction identifier is used for any compilation unit in the partition,\n+then all compilation units in the partition must obey the restriction).\n+\n+Immediate_Reclamation\n+---------------------\n+.. index:: Immediate_Reclamation\n+\n+[RM H.4] This restriction ensures that, except for storage occupied by\n+objects created by allocators and not deallocated via unchecked\n+deallocation, any storage reserved at run time for an object is\n+immediately reclaimed when the object no longer exists.\n+\n+Max_Asynchronous_Select_Nesting\n+-------------------------------\n+.. index:: Max_Asynchronous_Select_Nesting\n+\n+[RM D.7] Specifies the maximum dynamic nesting level of asynchronous\n+selects. Violations of this restriction with a value of zero are\n+detected at compile time. Violations of this restriction with values\n+other than zero cause Storage_Error to be raised.\n+\n+Max_Entry_Queue_Length\n+----------------------\n+.. index:: Max_Entry_Queue_Length\n+\n+[RM D.7] This restriction is a declaration that any protected entry compiled in\n+the scope of the restriction has at most the specified number of\n+tasks waiting on the entry at any one time, and so no queue is required.\n+Note that this restriction is checked at run time. Violation of this\n+restriction results in the raising of Program_Error exception at the point of\n+the call.\n+\n+.. index:: Max_Entry_Queue_Depth\n+\n+The restriction `Max_Entry_Queue_Depth` is recognized as a\n+synonym for `Max_Entry_Queue_Length`. This is retained for historical\n+compatibility purposes (and a warning will be generated for its use if\n+warnings on obsolescent features are activated).\n+\n+Max_Protected_Entries\n+---------------------\n+.. index:: Max_Protected_Entries\n+\n+[RM D.7] Specifies the maximum number of entries per protected type. The\n+bounds of every entry family of a protected unit shall be static, or shall be\n+defined by a discriminant of a subtype whose corresponding bound is static.\n+\n+Max_Select_Alternatives\n+-----------------------\n+.. index:: Max_Select_Alternatives\n+\n+[RM D.7] Specifies the maximum number of alternatives in a selective accept.\n+\n+Max_Storage_At_Blocking\n+-----------------------\n+.. index:: Max_Storage_At_Blocking\n+\n+[RM D.7] Specifies the maximum portion (in storage elements) of a task's\n+Storage_Size that can be retained by a blocked task. A violation of this\n+restriction causes Storage_Error to be raised.\n+\n+Max_Task_Entries\n+----------------\n+.. index:: Max_Task_Entries\n+\n+[RM D.7] Specifies the maximum number of entries\n+per task.  The bounds of every entry family\n+of a task unit shall be static, or shall be\n+defined by a discriminant of a subtype whose\n+corresponding bound is static.\n+\n+Max_Tasks\n+---------\n+.. index:: Max_Tasks\n+\n+[RM D.7] Specifies the maximum number of task that may be created, not\n+counting the creation of the environment task.  Violations of this\n+restriction with a value of zero are detected at compile\n+time. Violations of this restriction with values other than zero cause\n+Storage_Error to be raised.\n+\n+No_Abort_Statements\n+-------------------\n+.. index:: No_Abort_Statements\n+\n+[RM D.7] There are no abort_statements, and there are\n+no calls to Task_Identification.Abort_Task.\n+\n+No_Access_Parameter_Allocators\n+------------------------------\n+.. index:: No_Access_Parameter_Allocators\n+\n+[RM H.4] This restriction ensures at compile time that there are no\n+occurrences of an allocator as the actual parameter to an access\n+parameter.\n+\n+No_Access_Subprograms\n+---------------------\n+.. index:: No_Access_Subprograms\n+\n+[RM H.4] This restriction ensures at compile time that there are no\n+declarations of access-to-subprogram types.\n+\n+No_Allocators\n+-------------\n+.. index:: No_Allocators\n+\n+[RM H.4] This restriction ensures at compile time that there are no\n+occurrences of an allocator.\n+\n+No_Anonymous_Allocators\n+-----------------------\n+.. index:: No_Anonymous_Allocators\n+\n+[RM H.4] This restriction ensures at compile time that there are no\n+occurrences of an allocator of anonymous access type.\n+\n+No_Calendar\n+-----------\n+.. index:: No_Calendar\n+\n+[GNAT] This restriction ensures at compile time that there is no implicit or\n+explicit dependence on the package `Ada.Calendar`.\n+\n+No_Coextensions\n+---------------\n+.. index:: No_Coextensions\n+\n+[RM H.4] This restriction ensures at compile time that there are no\n+coextensions. See 3.10.2.\n+\n+No_Default_Initialization\n+-------------------------\n+.. index:: No_Default_Initialization\n+\n+[GNAT] This restriction prohibits any instance of default initialization\n+of variables.  The binder implements a consistency rule which prevents\n+any unit compiled without the restriction from with'ing a unit with the\n+restriction (this allows the generation of initialization procedures to\n+be skipped, since you can be sure that no call is ever generated to an\n+initialization procedure in a unit with the restriction active). If used\n+in conjunction with Initialize_Scalars or Normalize_Scalars, the effect\n+is to prohibit all cases of variables declared without a specific\n+initializer (including the case of OUT scalar parameters).\n+\n+No_Delay\n+--------\n+.. index:: No_Delay\n+\n+[RM H.4] This restriction ensures at compile time that there are no\n+delay statements and no dependences on package Calendar.\n+\n+No_Dependence\n+-------------\n+.. index:: No_Dependence\n+\n+[RM 13.12.1] This restriction checks at compile time that there are no\n+dependence on a library unit.\n+\n+No_Direct_Boolean_Operators\n+---------------------------\n+.. index:: No_Direct_Boolean_Operators\n+\n+[GNAT] This restriction ensures that no logical operators (and/or/xor)\n+are used on operands of type Boolean (or any type derived from Boolean).\n+This is intended for use in safety critical programs where the certification\n+protocol requires the use of short-circuit (and then, or else) forms for all\n+composite boolean operations.\n+\n+No_Dispatch\n+-----------\n+.. index:: No_Dispatch\n+\n+[RM H.4] This restriction ensures at compile time that there are no\n+occurrences of `T'Class`, for any (tagged) subtype `T`.\n+\n+No_Dispatching_Calls\n+--------------------\n+.. index:: No_Dispatching_Calls\n+\n+[GNAT] This restriction ensures at compile time that the code generated by the\n+compiler involves no dispatching calls. The use of this restriction allows the\n+safe use of record extensions, classwide membership tests and other classwide\n+features not involving implicit dispatching. This restriction ensures that\n+the code contains no indirect calls through a dispatching mechanism. Note that\n+this includes internally-generated calls created by the compiler, for example\n+in the implementation of class-wide objects assignments. The\n+membership test is allowed in the presence of this restriction, because its\n+implementation requires no dispatching.\n+This restriction is comparable to the official Ada restriction\n+`No_Dispatch` except that it is a bit less restrictive in that it allows\n+all classwide constructs that do not imply dispatching.\n+The following example indicates constructs that violate this restriction.\n+\n+\n+.. code-block:: ada\n+\n+  package Pkg is\n+    type T is tagged record\n+      Data : Natural;\n+    end record;\n+    procedure P (X : T);\n+\n+    type DT is new T with record\n+      More_Data : Natural;\n+    end record;\n+    procedure Q (X : DT);\n+  end Pkg;\n+\n+  with Pkg; use Pkg;\n+  procedure Example is\n+    procedure Test (O : T'Class) is\n+      N : Natural  := O'Size;--  Error: Dispatching call\n+      C : T'Class := O;      --  Error: implicit Dispatching Call\n+    begin\n+      if O in DT'Class then  --  OK   : Membership test\n+         Q (DT (O));         --  OK   : Type conversion plus direct call\n+      else\n+         P (O);              --  Error: Dispatching call\n+      end if;\n+    end Test;\n+\n+    Obj : DT;\n+  begin\n+    P (Obj);                 --  OK   : Direct call\n+    P (T (Obj));             --  OK   : Type conversion plus direct call\n+    P (T'Class (Obj));       --  Error: Dispatching call\n+\n+    Test (Obj);              --  OK   : Type conversion\n+\n+    if Obj in T'Class then   --  OK   : Membership test\n+       null;\n+    end if;\n+  end Example;\n+  \n+\n+No_Dynamic_Attachment\n+---------------------\n+.. index:: No_Dynamic_Attachment\n+\n+[RM D.7] This restriction ensures that there is no call to any of the\n+operations defined in package Ada.Interrupts\n+(Is_Reserved, Is_Attached, Current_Handler, Attach_Handler, Exchange_Handler,\n+Detach_Handler, and Reference).\n+\n+.. index:: No_Dynamic_Interrupts\n+\n+The restriction `No_Dynamic_Interrupts` is recognized as a\n+synonym for `No_Dynamic_Attachment`. This is retained for historical\n+compatibility purposes (and a warning will be generated for its use if\n+warnings on obsolescent features are activated).\n+\n+No_Dynamic_Priorities\n+---------------------\n+.. index:: No_Dynamic_Priorities\n+\n+[RM D.7] There are no semantic dependencies on the package Dynamic_Priorities.\n+\n+No_Entry_Calls_In_Elaboration_Code\n+----------------------------------\n+.. index:: No_Entry_Calls_In_Elaboration_Code\n+\n+[GNAT] This restriction ensures at compile time that no task or protected entry\n+calls are made during elaboration code.  As a result of the use of this\n+restriction, the compiler can assume that no code past an accept statement\n+in a task can be executed at elaboration time.\n+\n+No_Enumeration_Maps\n+-------------------\n+.. index:: No_Enumeration_Maps\n+\n+[GNAT] This restriction ensures at compile time that no operations requiring\n+enumeration maps are used (that is Image and Value attributes applied\n+to enumeration types).\n+\n+No_Exception_Handlers\n+---------------------\n+.. index:: No_Exception_Handlers\n+\n+[GNAT] This restriction ensures at compile time that there are no explicit\n+exception handlers. It also indicates that no exception propagation will\n+be provided. In this mode, exceptions may be raised but will result in\n+an immediate call to the last chance handler, a routine that the user\n+must define with the following profile:\n+\n+\n+.. code-block:: ada\n+\n+  procedure Last_Chance_Handler\n+    (Source_Location : System.Address; Line : Integer);\n+  pragma Export (C, Last_Chance_Handler,\n+                 \"__gnat_last_chance_handler\");\n+  \n+\n+The parameter is a C null-terminated string representing a message to be\n+associated with the exception (typically the source location of the raise\n+statement generated by the compiler). The Line parameter when nonzero\n+represents the line number in the source program where the raise occurs.\n+\n+No_Exception_Propagation\n+------------------------\n+.. index:: No_Exception_Propagation\n+\n+[GNAT] This restriction guarantees that exceptions are never propagated\n+to an outer subprogram scope. The only case in which an exception may\n+be raised is when the handler is statically in the same subprogram, so\n+that the effect of a raise is essentially like a goto statement. Any\n+other raise statement (implicit or explicit) will be considered\n+unhandled. Exception handlers are allowed, but may not contain an\n+exception occurrence identifier (exception choice). In addition, use of\n+the package GNAT.Current_Exception is not permitted, and reraise\n+statements (raise with no operand) are not permitted.\n+\n+No_Exception_Registration\n+-------------------------\n+.. index:: No_Exception_Registration\n+\n+[GNAT] This restriction ensures at compile time that no stream operations for\n+types Exception_Id or Exception_Occurrence are used. This also makes it\n+impossible to pass exceptions to or from a partition with this restriction\n+in a distributed environment. If this restriction is active, the generated\n+code is simplified by omitting the otherwise-required global registration\n+of exceptions when they are declared.\n+\n+No_Exceptions\n+-------------\n+.. index:: No_Exceptions\n+\n+[RM H.4] This restriction ensures at compile time that there are no\n+raise statements and no exception handlers.\n+\n+No_Finalization\n+---------------\n+.. index:: No_Finalization\n+\n+[GNAT] This restriction disables the language features described in\n+chapter 7.6 of the Ada 2005 RM as well as all form of code generation\n+performed by the compiler to support these features. The following types\n+are no longer considered controlled when this restriction is in effect:\n+\n+* \n+  `Ada.Finalization.Controlled`\n+* \n+  `Ada.Finalization.Limited_Controlled`\n+* \n+  Derivations from `Controlled` or `Limited_Controlled`\n+* \n+  Class-wide types\n+* \n+  Protected types\n+* \n+  Task types\n+* \n+  Array and record types with controlled components\n+\n+The compiler no longer generates code to initialize, finalize or adjust an\n+object or a nested component, either declared on the stack or on the heap. The\n+deallocation of a controlled object no longer finalizes its contents.\n+\n+No_Fixed_Point\n+--------------\n+.. index:: No_Fixed_Point\n+\n+[RM H.4] This restriction ensures at compile time that there are no\n+occurrences of fixed point types and operations.\n+\n+No_Floating_Point\n+-----------------\n+.. index:: No_Floating_Point\n+\n+[RM H.4] This restriction ensures at compile time that there are no\n+occurrences of floating point types and operations.\n+\n+No_Implicit_Conditionals\n+------------------------\n+.. index:: No_Implicit_Conditionals\n+\n+[GNAT] This restriction ensures that the generated code does not contain any\n+implicit conditionals, either by modifying the generated code where possible,\n+or by rejecting any construct that would otherwise generate an implicit\n+conditional. Note that this check does not include run time constraint\n+checks, which on some targets may generate implicit conditionals as\n+well. To control the latter, constraint checks can be suppressed in the\n+normal manner. Constructs generating implicit conditionals include comparisons\n+of composite objects and the Max/Min attributes.\n+\n+No_Implicit_Dynamic_Code\n+------------------------\n+.. index:: No_Implicit_Dynamic_Code\n+.. index:: trampoline\n+\n+[GNAT] This restriction prevents the compiler from building 'trampolines'.\n+This is a structure that is built on the stack and contains dynamic\n+code to be executed at run time. On some targets, a trampoline is\n+built for the following features: `Access`,\n+`Unrestricted_Access`, or `Address` of a nested subprogram;\n+nested task bodies; primitive operations of nested tagged types.\n+Trampolines do not work on machines that prevent execution of stack\n+data. For example, on windows systems, enabling DEP (data execution\n+protection) will cause trampolines to raise an exception.\n+Trampolines are also quite slow at run time.\n+\n+On many targets, trampolines have been largely eliminated. Look at the\n+version of system.ads for your target --- if it has\n+Always_Compatible_Rep equal to False, then trampolines are largely\n+eliminated. In particular, a trampoline is built for the following\n+features: `Address` of a nested subprogram;\n+`Access` or `Unrestricted_Access` of a nested subprogram,\n+but only if pragma Favor_Top_Level applies, or the access type has a\n+foreign-language convention; primitive operations of nested tagged\n+types.\n+\n+No_Implicit_Heap_Allocations\n+----------------------------\n+.. index:: No_Implicit_Heap_Allocations\n+\n+[RM D.7] No constructs are allowed to cause implicit heap allocation.\n+\n+No_Implicit_Loops\n+-----------------\n+.. index:: No_Implicit_Loops\n+\n+[GNAT] This restriction ensures that the generated code does not contain any\n+implicit `for` loops, either by modifying\n+the generated code where possible,\n+or by rejecting any construct that would otherwise generate an implicit\n+`for` loop. If this restriction is active, it is possible to build\n+large array aggregates with all static components without generating an\n+intermediate temporary, and without generating a loop to initialize individual\n+components. Otherwise, a loop is created for arrays larger than about 5000\n+scalar components.\n+\n+No_Initialize_Scalars\n+---------------------\n+.. index:: No_Initialize_Scalars\n+\n+[GNAT] This restriction ensures that no unit in the partition is compiled with\n+pragma Initialize_Scalars. This allows the generation of more efficient\n+code, and in particular eliminates dummy null initialization routines that\n+are otherwise generated for some record and array types.\n+\n+No_IO\n+-----\n+.. index:: No_IO\n+\n+[RM H.4] This restriction ensures at compile time that there are no\n+dependences on any of the library units Sequential_IO, Direct_IO,\n+Text_IO, Wide_Text_IO, Wide_Wide_Text_IO, or Stream_IO.\n+\n+No_Local_Allocators\n+-------------------\n+.. index:: No_Local_Allocators\n+\n+[RM H.4] This restriction ensures at compile time that there are no\n+occurrences of an allocator in subprograms, generic subprograms, tasks,\n+and entry bodies.\n+\n+No_Local_Protected_Objects\n+--------------------------\n+.. index:: No_Local_Protected_Objects\n+\n+[RM D.7] This restriction ensures at compile time that protected objects are\n+only declared at the library level.\n+\n+No_Local_Timing_Events\n+----------------------\n+.. index:: No_Local_Timing_Events\n+\n+[RM D.7] All objects of type Ada.Timing_Events.Timing_Event are\n+declared at the library level.\n+\n+No_Long_Long_Integers\n+---------------------\n+.. index:: No_Long_Long_Integers\n+\n+[GNAT] This partition-wide restriction forbids any explicit reference to\n+type Standard.Long_Long_Integer, and also forbids declaring range types whose\n+implicit base type is Long_Long_Integer, and modular types whose size exceeds\n+Long_Integer'Size.\n+\n+No_Multiple_Elaboration\n+-----------------------\n+.. index:: No_Multiple_Elaboration\n+\n+[GNAT] Normally each package contains a 16-bit counter used to check for access\n+before elaboration, and to control multiple elaboration attempts.\n+This counter is eliminated for units compiled with the static model\n+of elaboration if restriction `No_Elaboration_Code`\n+is active but because of\n+the need to check for multiple elaboration in the general case, these\n+counters cannot be eliminated if elaboration code may be present. The\n+restriction `No_Multiple_Elaboration`\n+allows suppression of these counters\n+in static elaboration units even if they do have elaboration code. If this\n+restriction is used, then the situations in which multiple elaboration is\n+possible, including non-Ada main programs, and Stand Alone libraries, are not\n+permitted, and will be diagnosed by the binder.\n+\n+No_Nested_Finalization\n+----------------------\n+.. index:: No_Nested_Finalization\n+\n+[RM D.7] All objects requiring finalization are declared at the library level.\n+\n+No_Protected_Type_Allocators\n+----------------------------\n+.. index:: No_Protected_Type_Allocators\n+\n+[RM D.7] This restriction ensures at compile time that there are no allocator\n+expressions that attempt to allocate protected objects.\n+\n+No_Protected_Types\n+------------------\n+.. index:: No_Protected_Types\n+\n+[RM H.4] This restriction ensures at compile time that there are no\n+declarations of protected types or protected objects.\n+\n+No_Recursion\n+------------\n+.. index:: No_Recursion\n+\n+[RM H.4] A program execution is erroneous if a subprogram is invoked as\n+part of its execution.\n+\n+No_Reentrancy\n+-------------\n+.. index:: No_Reentrancy\n+\n+[RM H.4] A program execution is erroneous if a subprogram is executed by\n+two tasks at the same time.\n+\n+No_Relative_Delay\n+-----------------\n+.. index:: No_Relative_Delay\n+\n+[RM D.7] This restriction ensures at compile time that there are no delay\n+relative statements and prevents expressions such as `delay 1.23;` from\n+appearing in source code.\n+\n+No_Requeue_Statements\n+---------------------\n+.. index:: No_Requeue_Statements\n+\n+[RM D.7] This restriction ensures at compile time that no requeue statements\n+are permitted and prevents keyword `requeue` from being used in source\n+code.\n+\n+.. index:: No_Requeue\n+\n+The restriction `No_Requeue` is recognized as a\n+synonym for `No_Requeue_Statements`. This is retained for historical\n+compatibility purposes (and a warning will be generated for its use if\n+warnings on oNobsolescent features are activated).\n+\n+No_Secondary_Stack\n+------------------\n+.. index:: No_Secondary_Stack\n+\n+[GNAT] This restriction ensures at compile time that the generated code\n+does not contain any reference to the secondary stack.  The secondary\n+stack is used to implement functions returning unconstrained objects\n+(arrays or records) on some targets.\n+\n+No_Select_Statements\n+--------------------\n+.. index:: No_Select_Statements\n+\n+[RM D.7] This restriction ensures at compile time no select statements of any\n+kind are permitted, that is the keyword `select` may not appear.\n+\n+No_Specific_Termination_Handlers\n+--------------------------------\n+.. index:: No_Specific_Termination_Handlers\n+\n+[RM D.7] There are no calls to Ada.Task_Termination.Set_Specific_Handler\n+or to Ada.Task_Termination.Specific_Handler.\n+\n+No_Specification_of_Aspect\n+--------------------------\n+.. index:: No_Specification_of_Aspect\n+\n+[RM 13.12.1] This restriction checks at compile time that no aspect\n+specification, attribute definition clause, or pragma is given for a\n+given aspect.\n+\n+No_Standard_Allocators_After_Elaboration\n+----------------------------------------\n+.. index:: No_Standard_Allocators_After_Elaboration\n+\n+[RM D.7] Specifies that an allocator using a standard storage pool\n+should never be evaluated at run time after the elaboration of the\n+library items of the partition has completed. Otherwise, Storage_Error\n+is raised.\n+\n+No_Standard_Storage_Pools\n+-------------------------\n+.. index:: No_Standard_Storage_Pools\n+\n+[GNAT] This restriction ensures at compile time that no access types\n+use the standard default storage pool.  Any access type declared must\n+have an explicit Storage_Pool attribute defined specifying a\n+user-defined storage pool.\n+\n+No_Stream_Optimizations\n+-----------------------\n+.. index:: No_Stream_Optimizations\n+\n+[GNAT] This restriction affects the performance of stream operations on types\n+`String`, `Wide_String` and `Wide_Wide_String`. By default, the\n+compiler uses block reads and writes when manipulating `String` objects\n+due to their supperior performance. When this restriction is in effect, the\n+compiler performs all IO operations on a per-character basis.\n+\n+No_Streams\n+----------\n+.. index:: No_Streams\n+\n+[GNAT] This restriction ensures at compile/bind time that there are no\n+stream objects created and no use of stream attributes.\n+This restriction does not forbid dependences on the package\n+`Ada.Streams`. So it is permissible to with\n+`Ada.Streams` (or another package that does so itself)\n+as long as no actual stream objects are created and no\n+stream attributes are used.\n+\n+Note that the use of restriction allows optimization of tagged types,\n+since they do not need to worry about dispatching stream operations.\n+To take maximum advantage of this space-saving optimization, any\n+unit declaring a tagged type should be compiled with the restriction,\n+though this is not required.\n+\n+No_Task_Allocators\n+------------------\n+.. index:: No_Task_Allocators\n+\n+[RM D.7] There are no allocators for task types\n+or types containing task subcomponents.\n+\n+No_Task_Attributes_Package\n+--------------------------\n+.. index:: No_Task_Attributes_Package\n+\n+[GNAT] This restriction ensures at compile time that there are no implicit or\n+explicit dependencies on the package `Ada.Task_Attributes`.\n+\n+.. index:: No_Task_Attributes\n+\n+The restriction `No_Task_Attributes` is recognized as a synonym\n+for `No_Task_Attributes_Package`. This is retained for historical\n+compatibility purposes (and a warning will be generated for its use if\n+warnings on obsolescent features are activated).\n+\n+No_Task_Hierarchy\n+-----------------\n+.. index:: No_Task_Hierarchy\n+\n+[RM D.7] All (non-environment) tasks depend\n+directly on the environment task of the partition.\n+\n+No_Task_Termination\n+-------------------\n+.. index:: No_Task_Termination\n+\n+[RM D.7] Tasks that terminate are erroneous.\n+\n+No_Tasking\n+----------\n+.. index:: No_Tasking\n+\n+[GNAT] This restriction prevents the declaration of tasks or task types\n+throughout the partition.  It is similar in effect to the use of\n+`Max_Tasks => 0` except that violations are caught at compile time\n+and cause an error message to be output either by the compiler or\n+binder.\n+\n+No_Terminate_Alternatives\n+-------------------------\n+.. index:: No_Terminate_Alternatives\n+\n+[RM D.7] There are no selective accepts with terminate alternatives.\n+\n+No_Unchecked_Access\n+-------------------\n+.. index:: No_Unchecked_Access\n+\n+[RM H.4] This restriction ensures at compile time that there are no\n+occurrences of the Unchecked_Access attribute.\n+\n+No_Use_Of_Entity\n+----------------\n+.. index:: No_Use_Of_Entity\n+\n+[GNAT] This restriction ensures at compile time that there are no references\n+to the entity given in the form ::\n+\n+   No_Use_Of_Entity => Name\n+\n+where ``Name`` is the fully qualified entity, for example ::\n+\n+   No_Use_Of_Entity => Ada.Text_IO.Put_Line\n+\n+Simple_Barriers\n+---------------\n+.. index:: Simple_Barriers\n+\n+[RM D.7] This restriction ensures at compile time that barriers in entry\n+declarations for protected types are restricted to either static boolean\n+expressions or references to simple boolean variables defined in the private\n+part of the protected type.  No other form of entry barriers is permitted.\n+\n+.. index:: Boolean_Entry_Barriers\n+\n+The restriction `Boolean_Entry_Barriers` is recognized as a\n+synonym for `Simple_Barriers`. This is retained for historical\n+compatibility purposes (and a warning will be generated for its use if\n+warnings on obsolescent features are activated).\n+\n+Static_Priorities\n+-----------------\n+.. index:: Static_Priorities\n+\n+[GNAT] This restriction ensures at compile time that all priority expressions\n+are static, and that there are no dependences on the package\n+`Ada.Dynamic_Priorities`.\n+\n+Static_Storage_Size\n+-------------------\n+.. index:: Static_Storage_Size\n+\n+[GNAT] This restriction ensures at compile time that any expression appearing\n+in a Storage_Size pragma or attribute definition clause is static.\n+\n+.. _Program_Unit_Level_Restrictions:\n+\n+\n+Program Unit Level Restrictions\n+===============================\n+\n+The second set of restriction identifiers\n+does not require partition-wide consistency.\n+The restriction may be enforced for a single\n+compilation unit without any effect on any of the\n+other compilation units in the partition.\n+\n+No_Elaboration_Code\n+-------------------\n+.. index:: No_Elaboration_Code\n+\n+[GNAT] This restriction ensures at compile time that no elaboration code is\n+generated.  Note that this is not the same condition as is enforced\n+by pragma `Preelaborate`.  There are cases in which pragma\n+`Preelaborate` still permits code to be generated (e.g., code\n+to initialize a large array to all zeroes), and there are cases of units\n+which do not meet the requirements for pragma `Preelaborate`,\n+but for which no elaboration code is generated.  Generally, it is\n+the case that preelaborable units will meet the restrictions, with\n+the exception of large aggregates initialized with an others_clause,\n+and exception declarations (which generate calls to a run-time\n+registry procedure).  This restriction is enforced on\n+a unit by unit basis, it need not be obeyed consistently\n+throughout a partition.\n+\n+In the case of aggregates with others, if the aggregate has a dynamic\n+size, there is no way to eliminate the elaboration code (such dynamic\n+bounds would be incompatible with `Preelaborate` in any case). If\n+the bounds are static, then use of this restriction actually modifies\n+the code choice of the compiler to avoid generating a loop, and instead\n+generate the aggregate statically if possible, no matter how many times\n+the data for the others clause must be repeatedly generated.\n+\n+It is not possible to precisely document\n+the constructs which are compatible with this restriction, since,\n+unlike most other restrictions, this is not a restriction on the\n+source code, but a restriction on the generated object code. For\n+example, if the source contains a declaration:\n+\n+\n+.. code-block:: ada\n+\n+     Val : constant Integer := X;\n+  \n+\n+where X is not a static constant, it may be possible, depending\n+on complex optimization circuitry, for the compiler to figure\n+out the value of X at compile time, in which case this initialization\n+can be done by the loader, and requires no initialization code. It\n+is not possible to document the precise conditions under which the\n+optimizer can figure this out.\n+\n+Note that this the implementation of this restriction requires full\n+code generation. If it is used in conjunction with \"semantics only\"\n+checking, then some cases of violations may be missed.\n+\n+No_Entry_Queue\n+--------------\n+.. index:: No_Entry_Queue\n+\n+[GNAT] This restriction is a declaration that any protected entry compiled in\n+the scope of the restriction has at most one task waiting on the entry\n+at any one time, and so no queue is required.  This restriction is not\n+checked at compile time.  A program execution is erroneous if an attempt\n+is made to queue a second task on such an entry.\n+\n+No_Implementation_Aspect_Specifications\n+---------------------------------------\n+.. index:: No_Implementation_Aspect_Specifications\n+\n+[RM 13.12.1] This restriction checks at compile time that no\n+GNAT-defined aspects are present.  With this restriction, the only\n+aspects that can be used are those defined in the Ada Reference Manual.\n+\n+No_Implementation_Attributes\n+----------------------------\n+.. index:: No_Implementation_Attributes\n+\n+[RM 13.12.1] This restriction checks at compile time that no\n+GNAT-defined attributes are present.  With this restriction, the only\n+attributes that can be used are those defined in the Ada Reference\n+Manual.\n+\n+No_Implementation_Identifiers\n+-----------------------------\n+.. index:: No_Implementation_Identifiers\n+\n+[RM 13.12.1] This restriction checks at compile time that no\n+implementation-defined identifiers (marked with pragma Implementation_Defined)\n+occur within language-defined packages.\n+\n+No_Implementation_Pragmas\n+-------------------------\n+.. index:: No_Implementation_Pragmas\n+\n+[RM 13.12.1] This restriction checks at compile time that no\n+GNAT-defined pragmas are present.  With this restriction, the only\n+pragmas that can be used are those defined in the Ada Reference Manual.\n+\n+No_Implementation_Restrictions\n+------------------------------\n+.. index:: No_Implementation_Restrictions\n+\n+[GNAT] This restriction checks at compile time that no GNAT-defined restriction\n+identifiers (other than `No_Implementation_Restrictions` itself)\n+are present.  With this restriction, the only other restriction identifiers\n+that can be used are those defined in the Ada Reference Manual.\n+\n+No_Implementation_Units\n+-----------------------\n+.. index:: No_Implementation_Units\n+\n+[RM 13.12.1] This restriction checks at compile time that there is no\n+mention in the context clause of any implementation-defined descendants\n+of packages Ada, Interfaces, or System.\n+\n+No_Implicit_Aliasing\n+--------------------\n+.. index:: No_Implicit_Aliasing\n+\n+[GNAT] This restriction, which is not required to be partition-wide consistent,\n+requires an explicit aliased keyword for an object to which 'Access,\n+'Unchecked_Access, or 'Address is applied, and forbids entirely the use of\n+the 'Unrestricted_Access attribute for objects. Note: the reason that\n+Unrestricted_Access is forbidden is that it would require the prefix\n+to be aliased, and in such cases, it can always be replaced by\n+the standard attribute Unchecked_Access which is preferable.\n+\n+No_Obsolescent_Features\n+-----------------------\n+.. index:: No_Obsolescent_Features\n+\n+[RM 13.12.1] This restriction checks at compile time that no obsolescent\n+features are used, as defined in Annex J of the Ada Reference Manual.\n+\n+No_Wide_Characters\n+------------------\n+.. index:: No_Wide_Characters\n+\n+[GNAT] This restriction ensures at compile time that no uses of the types\n+`Wide_Character` or `Wide_String` or corresponding wide\n+wide types\n+appear, and that no wide or wide wide string or character literals\n+appear in the program (that is literals representing characters not in\n+type `Character`).\n+\n+SPARK_05\n+--------\n+.. index:: SPARK_05\n+\n+[GNAT] This restriction checks at compile time that some constructs\n+forbidden in SPARK 2005 are not present. Error messages related to\n+SPARK restriction have the form:\n+\n+\n+::\n+\n+  violation of restriction \"SPARK_05\" at <source-location>\n+   <error message>\n+  \n+\n+.. index:: SPARK\n+\n+The restriction `SPARK` is recognized as a\n+synonym for `SPARK_05`. This is retained for historical\n+compatibility purposes (and an unconditional warning will be generated\n+for its use, advising replacement by `SPARK`).\n+\n+This is not a replacement for the semantic checks performed by the\n+SPARK Examiner tool, as the compiler currently only deals with code,\n+not SPARK 2005 annotations, and does not guarantee catching all\n+cases of constructs forbidden by SPARK 2005.\n+\n+Thus it may well be the case that code which passes the compiler with\n+the SPARK restriction is rejected by the SPARK Examiner, e.g. due to\n+the different visibility rules of the Examiner based on SPARK 2005\n+`inherit` annotations.\n+\n+This restriction can be useful in providing an initial filter for code\n+developed using SPARK 2005, or in examining legacy code to see how far\n+it is from meeting SPARK restrictions.\n+\n+The list below summarizes the checks that are performed when this\n+restriction is in force:\n+\n+* No block statements\n+* No case statements with only an others clause\n+* Exit statements in loops must respect the SPARK 2005 language restrictions\n+* No goto statements\n+* Return can only appear as last statement in function\n+* Function must have return statement\n+* Loop parameter specification must include subtype mark\n+* Prefix of expanded name cannot be a loop statement\n+* Abstract subprogram not allowed\n+* User-defined operators not allowed\n+* Access type parameters not allowed\n+* Default expressions for parameters not allowed\n+* Default expressions for record fields not allowed\n+* No tasking constructs allowed\n+* Label needed at end of subprograms and packages\n+* No mixing of positional and named parameter association\n+* No access types as result type\n+* No unconstrained arrays as result types\n+* No null procedures\n+* Initial and later declarations must be in correct order (declaration can't come after body)\n+* No attributes on private types if full declaration not visible\n+* No package declaration within package specification\n+* No controlled types\n+* No discriminant types\n+* No overloading\n+* Selector name cannot be operator symbol (i.e. operator symbol cannot be prefixed)\n+* Access attribute not allowed\n+* Allocator not allowed\n+* Result of catenation must be String\n+* Operands of catenation must be string literal, static char or another catenation\n+* No conditional expressions\n+* No explicit dereference\n+* Quantified expression not allowed\n+* Slicing not allowed\n+* No exception renaming\n+* No generic renaming\n+* No object renaming\n+* No use clause\n+* Aggregates must be qualified\n+* Non-static choice in array aggregates not allowed\n+* The only view conversions which are allowed as in-out parameters are conversions of a tagged type to an ancestor type\n+* No mixing of positional and named association in aggregate, no multi choice\n+* AND, OR and XOR for arrays only allowed when operands have same static bounds\n+* Fixed point operands to * or / must be qualified or converted\n+* Comparison operators not allowed for Booleans or arrays (except strings)\n+* Equality not allowed for arrays with non-matching static bounds (except strings)\n+* Conversion / qualification not allowed for arrays with non-matching static bounds\n+* Subprogram declaration only allowed in package spec (unless followed by import)\n+* Access types not allowed\n+* Incomplete type declaration not allowed\n+* Object and subtype declarations must respect SPARK restrictions\n+* Digits or delta constraint not allowed\n+* Decimal fixed point type not allowed\n+* Aliasing of objects not allowed\n+* Modular type modulus must be power of 2\n+* Base not allowed on subtype mark\n+* Unary operators not allowed on modular types (except not)\n+* Untagged record cannot be null\n+* No class-wide operations\n+* Initialization expressions must respect SPARK restrictions\n+* Non-static ranges not allowed except in iteration schemes\n+* String subtypes must have lower bound of 1\n+* Subtype of Boolean cannot have constraint\n+* At most one tagged type or extension per package\n+* Interface is not allowed\n+* Character literal cannot be prefixed (selector name cannot be character literal)\n+* Record aggregate cannot contain 'others'\n+* Component association in record aggregate must contain a single choice\n+* Ancestor part cannot be a type mark\n+* Attributes 'Image, 'Width and 'Value not allowed\n+* Functions may not update globals\n+* Subprograms may not contain direct calls to themselves (prevents recursion within unit)\n+* Call to subprogram not allowed in same unit before body has been seen (prevents recursion within unit)\n+\n+The following restrictions are enforced, but note that they are actually more\n+strict that the latest SPARK 2005 language definition:\n+\n+* No derived types other than tagged type extensions\n+* Subtype of unconstrained array must have constraint\n+\n+This list summarises the main SPARK 2005 language rules that are not\n+currently checked by the SPARK_05 restriction:\n+\n+* SPARK annotations are treated as comments so are not checked at all\n+* Based real literals not allowed\n+* Objects cannot be initialized at declaration by calls to user-defined functions\n+* Objects cannot be initialized at declaration by assignments from variables\n+* Objects cannot be initialized at declaration by assignments from indexed/selected components\n+* Ranges shall not be null\n+* A fixed point delta expression must be a simple expression\n+* Restrictions on where renaming declarations may be placed\n+* Externals of mode 'out' cannot be referenced\n+* Externals of mode 'in' cannot be updated\n+* Loop with no iteration scheme or exits only allowed as last statement in main program or task\n+* Subprogram cannot have parent unit name\n+* SPARK 2005 inherited subprogram must be prefixed with overriding\n+* External variables (or functions that reference them) may not be passed as actual parameters\n+* Globals must be explicitly mentioned in contract\n+* Deferred constants cannot be completed by pragma Import\n+* Package initialization cannot read/write variables from other packages\n+* Prefix not allowed for entities that are directly visible\n+* Identifier declaration can't override inherited package name\n+* Cannot use Standard or other predefined packages as identifiers\n+* After renaming, cannot use the original name\n+* Subprograms can only be renamed to remove package prefix\n+* Pragma import must be immediately after entity it names\n+* No mutual recursion between multiple units (this can be checked with gnatcheck)\n+\n+Note that if a unit is compiled in Ada 95 mode with the SPARK restriction,\n+violations will be reported for constructs forbidden in SPARK 95,\n+instead of SPARK 2005.\n+"}, {"sha": "8b8d3c279873bb309c20c01867cb690bbe839648", "filename": "gcc/ada/doc/gnat_rm/standard_library_routines.rst", "status": "added", "additions": 709, "deletions": 0, "changes": 709, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_library_routines.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_library_routines.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_library_routines.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,709 @@\n+.. _Standard_Library_Routines:\n+\n+*************************\n+Standard Library Routines\n+*************************\n+\n+The Ada Reference Manual contains in Annex A a full description of an\n+extensive set of standard library routines that can be used in any Ada\n+program, and which must be provided by all Ada compilers.  They are\n+analogous to the standard C library used by C programs.\n+\n+GNAT implements all of the facilities described in annex A, and for most\n+purposes the description in the Ada Reference Manual, or appropriate Ada\n+text book, will be sufficient for making use of these facilities.\n+\n+In the case of the input-output facilities,\n+:ref:`The_Implementation_of_Standard_I/O`,\n+gives details on exactly how GNAT interfaces to the\n+file system.  For the remaining packages, the Ada Reference Manual\n+should be sufficient.  The following is a list of the packages included,\n+together with a brief description of the functionality that is provided.\n+\n+For completeness, references are included to other predefined library\n+routines defined in other sections of the Ada Reference Manual (these are\n+cross-indexed from Annex A). For further details see the relevant\n+package declarations in the run-time library. In particular, a few units\n+are not implemented, as marked by the presence of pragma Unimplemented_Unit,\n+and in this case the package declaration contains comments explaining why\n+the unit is not implemented.\n+\n+\n+\n+``Ada`` *(A.2)*\n+  This is a parent package for all the standard library packages.  It is\n+  usually included implicitly in your program, and itself contains no\n+  useful data or routines.\n+\n+\n+``Ada.Assertions`` *(11.4.2)*\n+  `Assertions` provides the `Assert` subprograms, and also\n+  the declaration of the `Assertion_Error` exception.\n+\n+\n+``Ada.Asynchronous_Task_Control`` *(D.11)*\n+  `Asynchronous_Task_Control` provides low level facilities for task\n+  synchronization. It is typically not implemented. See package spec for details.\n+\n+\n+``Ada.Calendar`` *(9.6)*\n+  `Calendar` provides time of day access, and routines for\n+  manipulating times and durations.\n+\n+\n+``Ada.Calendar.Arithmetic`` *(9.6.1)*\n+  This package provides additional arithmetic\n+  operations for `Calendar`.\n+\n+\n+``Ada.Calendar.Formatting`` *(9.6.1)*\n+  This package provides formatting operations for `Calendar`.\n+\n+\n+``Ada.Calendar.Time_Zones`` *(9.6.1)*\n+  This package provides additional `Calendar` facilities\n+  for handling time zones.\n+\n+\n+``Ada.Characters`` *(A.3.1)*\n+  This is a dummy parent package that contains no useful entities\n+\n+\n+``Ada.Characters.Conversions`` *(A.3.2)*\n+  This package provides character conversion functions.\n+\n+\n+``Ada.Characters.Handling`` *(A.3.2)*\n+  This package provides some basic character handling capabilities,\n+  including classification functions for classes of characters (e.g., test\n+  for letters, or digits).\n+\n+\n+``Ada.Characters.Latin_1`` *(A.3.3)*\n+  This package includes a complete set of definitions of the characters\n+  that appear in type CHARACTER.  It is useful for writing programs that\n+  will run in international environments.  For example, if you want an\n+  upper case E with an acute accent in a string, it is often better to use\n+  the definition of `UC_E_Acute` in this package.  Then your program\n+  will print in an understandable manner even if your environment does not\n+  support these extended characters.\n+\n+\n+``Ada.Command_Line`` *(A.15)*\n+  This package provides access to the command line parameters and the name\n+  of the current program (analogous to the use of `argc` and `argv`\n+  in C), and also allows the exit status for the program to be set in a\n+  system-independent manner.\n+\n+\n+``Ada.Complex_Text_IO`` *(G.1.3)*\n+  This package provides text input and output of complex numbers.\n+\n+\n+``Ada.Containers`` *(A.18.1)*\n+  A top level package providing a few basic definitions used by all the\n+  following specific child packages that provide specific kinds of\n+  containers.\n+\n+``Ada.Containers.Bounded_Priority_Queues`` *(A.18.31)*\n+\n+``Ada.Containers.Bounded_Synchronized_Queues`` *(A.18.29)*\n+\n+``Ada.Containers.Doubly_Linked_Lists`` *(A.18.3)*\n+\n+``Ada.Containers.Generic_Array_Sort`` *(A.18.26)*\n+\n+``Ada.Containers.Generic_Constrained_Array_Sort`` *(A.18.26)*\n+\n+``Ada.Containers.Generic_Sort`` *(A.18.26)*\n+\n+``Ada.Containers.Hashed_Maps`` *(A.18.5)*\n+\n+``Ada.Containers.Hashed_Sets`` *(A.18.8)*\n+\n+``Ada.Containers.Indefinite_Doubly_Linked_Lists`` *(A.18.12)*\n+\n+``Ada.Containers.Indefinite_Hashed_Maps`` *(A.18.13)*\n+\n+``Ada.Containers.Indefinite_Hashed_Sets`` *(A.18.15)*\n+\n+``Ada.Containers.Indefinite_Holders`` *(A.18.18)*\n+\n+``Ada.Containers.Indefinite_Multiway_Trees`` *(A.18.17)*\n+\n+``Ada.Containers.Indefinite_Ordered_Maps`` *(A.18.14)*\n+\n+``Ada.Containers.Indefinite_Ordered_Sets`` *(A.18.16)*\n+\n+``Ada.Containers.Indefinite_Vectors`` *(A.18.11)*\n+\n+``Ada.Containers.Multiway_Trees`` *(A.18.10)*\n+\n+``Ada.Containers.Ordered_Maps`` *(A.18.6)*\n+\n+``Ada.Containers.Ordered_Sets`` *(A.18.9)*\n+\n+``Ada.Containers.Synchronized_Queue_Interfaces`` *(A.18.27)*\n+\n+``Ada.Containers.Unbounded_Priority_Queues`` *(A.18.30)*\n+\n+``Ada.Containers.Unbounded_Synchronized_Queues`` *(A.18.28)*\n+\n+``Ada.Containers.Vectors`` *(A.18.2)*\n+\n+``Ada.Directories`` *(A.16)*\n+  This package provides operations on directories.\n+\n+\n+``Ada.Directories.Hierarchical_File_Names`` *(A.16.1)*\n+  This package provides additional directory operations handling\n+  hiearchical file names.\n+\n+\n+``Ada.Directories.Information`` *(A.16)*\n+  This is an implementation defined package for additional directory\n+  operations, which is not implemented in GNAT.\n+\n+\n+``Ada.Decimal`` *(F.2)*\n+  This package provides constants describing the range of decimal numbers\n+  implemented, and also a decimal divide routine (analogous to the COBOL\n+  verb DIVIDE ... GIVING ... REMAINDER ...)\n+\n+\n+``Ada.Direct_IO`` *(A.8.4)*\n+  This package provides input-output using a model of a set of records of\n+  fixed-length, containing an arbitrary definite Ada type, indexed by an\n+  integer record number.\n+\n+\n+``Ada.Dispatching`` *(D.2.1)*\n+  A parent package containing definitions for task dispatching operations.\n+\n+\n+``Ada.Dispatching.EDF`` *(D.2.6)*\n+  Not implemented in GNAT.\n+\n+\n+``Ada.Dispatching.Non_Preemptive`` *(D.2.4)*\n+  Not implemented in GNAT.\n+\n+\n+``Ada.Dispatching.Round_Robin`` *(D.2.5)*\n+  Not implemented in GNAT.\n+\n+\n+``Ada.Dynamic_Priorities`` *(D.5)*\n+  This package allows the priorities of a task to be adjusted dynamically\n+  as the task is running.\n+\n+\n+``Ada.Environment_Variables`` *(A.17)*\n+  This package provides facilities for accessing environment variables.\n+\n+\n+``Ada.Exceptions`` *(11.4.1)*\n+  This package provides additional information on exceptions, and also\n+  contains facilities for treating exceptions as data objects, and raising\n+  exceptions with associated messages.\n+\n+\n+``Ada.Execution_Time`` *(D.14)*\n+  Not implemented in GNAT.\n+\n+\n+``Ada.Execution_Time.Group_Budgets`` *(D.14.2)*\n+  Not implemented in GNAT.\n+\n+\n+``Ada.Execution_Time.Timers`` *(D.14.1)'*\n+  Not implemented in GNAT.\n+\n+\n+``Ada.Finalization`` *(7.6)*\n+  This package contains the declarations and subprograms to support the\n+  use of controlled types, providing for automatic initialization and\n+  finalization (analogous to the constructors and destructors of C++).\n+\n+\n+``Ada.Float_Text_IO`` *(A.10.9)*\n+  A library level instantiation of Text_IO.Float_IO for type Float.\n+\n+\n+``Ada.Float_Wide_Text_IO`` *(A.10.9)*\n+  A library level instantiation of Wide_Text_IO.Float_IO for type Float.\n+\n+\n+``Ada.Float_Wide_Wide_Text_IO`` *(A.10.9)*\n+  A library level instantiation of Wide_Wide_Text_IO.Float_IO for type Float.\n+\n+\n+``Ada.Integer_Text_IO`` *(A.10.9)*\n+  A library level instantiation of Text_IO.Integer_IO for type Integer.\n+\n+\n+``Ada.Integer_Wide_Text_IO`` *(A.10.9)*\n+  A library level instantiation of Wide_Text_IO.Integer_IO for type Integer.\n+\n+\n+``Ada.Integer_Wide_Wide_Text_IO`` *(A.10.9)*\n+  A library level instantiation of Wide_Wide_Text_IO.Integer_IO for type Integer.\n+\n+\n+``Ada.Interrupts`` *(C.3.2)*\n+  This package provides facilities for interfacing to interrupts, which\n+  includes the set of signals or conditions that can be raised and\n+  recognized as interrupts.\n+\n+\n+``Ada.Interrupts.Names`` *(C.3.2)*\n+  This package provides the set of interrupt names (actually signal\n+  or condition names) that can be handled by GNAT.\n+\n+\n+``Ada.IO_Exceptions`` *(A.13)*\n+  This package defines the set of exceptions that can be raised by use of\n+  the standard IO packages.\n+\n+\n+``Ada.Iterator_Interfaces`` *(5.5.1)*\n+  This package provides a generic interface to generalized iterators.\n+\n+\n+``Ada.Locales`` *(A.19)*\n+  This package provides declarations providing information (Language\n+  and Country) about the current locale.\n+\n+\n+``Ada.Numerics``\n+  This package contains some standard constants and exceptions used\n+  throughout the numerics packages.  Note that the constants pi and e are\n+  defined here, and it is better to use these definitions than rolling\n+  your own.\n+\n+\n+``Ada.Numerics.Complex_Arrays`` *(G.3.2)*\n+  Provides operations on arrays of complex numbers.\n+\n+\n+``Ada.Numerics.Complex_Elementary_Functions``\n+  Provides the implementation of standard elementary functions (such as\n+  log and trigonometric functions) operating on complex numbers using the\n+  standard `Float` and the `Complex` and `Imaginary` types\n+  created by the package `Numerics.Complex_Types`.\n+\n+\n+``Ada.Numerics.Complex_Types``\n+  This is a predefined instantiation of\n+  `Numerics.Generic_Complex_Types` using `Standard.Float` to\n+  build the type `Complex` and `Imaginary`.\n+\n+\n+``Ada.Numerics.Discrete_Random``\n+  This generic package provides a random number generator suitable for generating\n+  uniformly distributed values of a specified discrete subtype.\n+\n+\n+``Ada.Numerics.Float_Random``\n+  This package provides a random number generator suitable for generating\n+  uniformly distributed floating point values in the unit interval.\n+\n+\n+``Ada.Numerics.Generic_Complex_Elementary_Functions``\n+  This is a generic version of the package that provides the\n+  implementation of standard elementary functions (such as log and\n+  trigonometric functions) for an arbitrary complex type.\n+\n+  The following predefined instantiations of this package are provided:\n+\n+  * ``Short_Float``\n+  \n+    `Ada.Numerics.Short_Complex_Elementary_Functions`\n+\n+  * ``Float``\n+\n+    `Ada.Numerics.Complex_Elementary_Functions`\n+\n+  * ``Long_Float``\n+\n+    `Ada.Numerics.Long_Complex_Elementary_Functions`\n+\n+``Ada.Numerics.Generic_Complex_Types``\n+  This is a generic package that allows the creation of complex types,\n+  with associated complex arithmetic operations.\n+\n+  The following predefined instantiations of this package exist\n+\n+  * ``Short_Float``\n+\n+    `Ada.Numerics.Short_Complex_Complex_Types`\n+\n+  * ``Float``\n+\n+    `Ada.Numerics.Complex_Complex_Types`\n+\n+  * ``Long_Float``\n+\n+    `Ada.Numerics.Long_Complex_Complex_Types`\n+\n+``Ada.Numerics.Generic_Elementary_Functions``\n+  This is a generic package that provides the implementation of standard\n+  elementary functions (such as log an trigonometric functions) for an\n+  arbitrary float type.\n+\n+  The following predefined instantiations of this package exist\n+\n+  * ``Short_Float``\n+\n+    `Ada.Numerics.Short_Elementary_Functions`\n+\n+  * ``Float``\n+\n+    `Ada.Numerics.Elementary_Functions`\n+\n+  * ``Long_Float``\n+\n+    `Ada.Numerics.Long_Elementary_Functions`\n+\n+``Ada.Numerics.Generic_Real_Arrays`` *(G.3.1)*\n+  Generic operations on arrays of reals\n+\n+``Ada.Numerics.Real_Arrays`` *(G.3.1)*\n+  Preinstantiation of Ada.Numerics.Generic_Real_Arrays (Float).\n+\n+``Ada.Real_Time`` *(D.8)*\n+  This package provides facilities similar to those of `Calendar`, but\n+  operating with a finer clock suitable for real time control. Note that\n+  annex D requires that there be no backward clock jumps, and GNAT generally\n+  guarantees this behavior, but of course if the external clock on which\n+  the GNAT runtime depends is deliberately reset by some external event,\n+  then such a backward jump may occur.\n+\n+``Ada.Real_Time.Timing_Events`` *(D.15)*\n+  Not implemented in GNAT.\n+\n+``Ada.Sequential_IO`` *(A.8.1)*\n+  This package provides input-output facilities for sequential files,\n+  which can contain a sequence of values of a single type, which can be\n+  any Ada type, including indefinite (unconstrained) types.\n+\n+``Ada.Storage_IO`` *(A.9)*\n+  This package provides a facility for mapping arbitrary Ada types to and\n+  from a storage buffer.  It is primarily intended for the creation of new\n+  IO packages.\n+\n+``Ada.Streams`` *(13.13.1)*\n+  This is a generic package that provides the basic support for the\n+  concept of streams as used by the stream attributes (`Input`,\n+  `Output`, `Read` and `Write`).\n+\n+``Ada.Streams.Stream_IO`` *(A.12.1)*\n+  This package is a specialization of the type `Streams` defined in\n+  package `Streams` together with a set of operations providing\n+  Stream_IO capability.  The Stream_IO model permits both random and\n+  sequential access to a file which can contain an arbitrary set of values\n+  of one or more Ada types.\n+\n+``Ada.Strings`` *(A.4.1)*\n+  This package provides some basic constants used by the string handling\n+  packages.\n+\n+\n+``Ada.Strings.Bounded`` *(A.4.4)*\n+  This package provides facilities for handling variable length\n+  strings.  The bounded model requires a maximum length.  It is thus\n+  somewhat more limited than the unbounded model, but avoids the use of\n+  dynamic allocation or finalization.\n+\n+``Ada.Strings.Bounded.Equal_Case_Insensitive`` *(A.4.10)*\n+  Provides case-insensitive comparisons of bounded strings\n+\n+``Ada.Strings.Bounded.Hash`` *(A.4.9)*\n+  This package provides a generic hash function for bounded strings\n+\n+``Ada.Strings.Bounded.Hash_Case_Insensitive`` *(A.4.9)*\n+  This package provides a generic hash function for bounded strings that\n+  converts the string to be hashed to lower case.\n+\n+``Ada.Strings.Bounded.Less_Case_Insensitive`` *(A.4.10)*\n+  This package provides a comparison function for bounded strings that works\n+  in a case insensitive manner by converting to lower case before the comparison.\n+\n+``Ada.Strings.Fixed`` *(A.4.3)*\n+  This package provides facilities for handling fixed length strings.\n+\n+``Ada.Strings.Fixed.Equal_Case_Insensitive`` *(A.4.10)*\n+  This package provides an equality function for fixed strings that compares\n+  the strings after converting both to lower case.\n+\n+``Ada.Strings.Fixed.Hash_Case_Insensitive`` *(A.4.9)*\n+  This package provides a case insensitive hash function for fixed strings that\n+  converts the string to lower case before computing the hash.\n+\n+``Ada.Strings.Fixed.Less_Case_Insensitive`` *(A.4.10)*\n+  This package provides a comparison function for fixed strings that works\n+  in a case insensitive manner by converting to lower case before the comparison.\n+\n+``Ada.Strings.Hash`` *(A.4.9)*\n+  This package provides a hash function for strings.\n+\n+``Ada.Strings.Hash_Case_Insensitive`` *(A.4.9)*\n+  This package provides a hash function for strings that is case insensitive.\n+  The string is converted to lower case before computing the hash.\n+\n+``Ada.Strings.Less_Case_Insensitive`` *(A.4.10)*\n+  This package provides a comparison function for\\\\strings that works\n+  in a case insensitive manner by converting to lower case before the comparison.\n+\n+``Ada.Strings.Maps`` *(A.4.2)*\n+  This package provides facilities for handling character mappings and\n+  arbitrarily defined subsets of characters.  For instance it is useful in\n+  defining specialized translation tables.\n+\n+``Ada.Strings.Maps.Constants`` *(A.4.6)*\n+  This package provides a standard set of predefined mappings and\n+  predefined character sets.  For example, the standard upper to lower case\n+  conversion table is found in this package.  Note that upper to lower case\n+  conversion is non-trivial if you want to take the entire set of\n+  characters, including extended characters like E with an acute accent,\n+  into account.  You should use the mappings in this package (rather than\n+  adding 32 yourself) to do case mappings.\n+\n+``Ada.Strings.Unbounded`` *(A.4.5)*\n+  This package provides facilities for handling variable length\n+  strings.  The unbounded model allows arbitrary length strings, but\n+  requires the use of dynamic allocation and finalization.\n+\n+``Ada.Strings.Unbounded.Equal_Case_Insensitive`` *(A.4.10)*\n+  Provides case-insensitive comparisons of unbounded strings\n+\n+``Ada.Strings.Unbounded.Hash`` *(A.4.9)*\n+  This package provides a generic hash function for unbounded strings\n+\n+``Ada.Strings.Unbounded.Hash_Case_Insensitive`` *(A.4.9)*\n+  This package provides a generic hash function for unbounded strings that\n+  converts the string to be hashed to lower case.\n+\n+``Ada.Strings.Unbounded.Less_Case_Insensitive`` *(A.4.10)*\n+  This package provides a comparison function for unbounded strings that works\n+  in a case insensitive manner by converting to lower case before the comparison.\n+\n+``Ada.Strings.UTF_Encoding`` *(A.4.11)*\n+  This package provides basic definitions for dealing with UTF-encoded strings.\n+\n+``Ada.Strings.UTF_Encoding.Conversions`` *(A.4.11)*\n+  This package provides conversion functions for UTF-encoded strings.\n+\n+``Ada.Strings.UTF_Encoding.Strings`` *(A.4.11)*\n+\n+``Ada.Strings.UTF_Encoding.Wide_Strings`` *(A.4.11)*\n+\n+``Ada.Strings.UTF_Encoding.Wide_Wide_Strings`` *(A.4.11)*\n+  These packages provide facilities for handling UTF encodings for\n+  Strings, Wide_Strings and Wide_Wide_Strings.\n+\n+``Ada.Strings.Wide_Bounded`` *(A.4.7)*\n+\n+``Ada.Strings.Wide_Fixed`` *(A.4.7)*\n+\n+``Ada.Strings.Wide_Maps`` *(A.4.7)*\n+\n+``Ada.Strings.Wide_Unbounded`` *(A.4.7)*\n+  These packages provide analogous capabilities to the corresponding\n+  packages without ``Wide_`` in the name, but operate with the types\n+  `Wide_String` and `Wide_Character` instead of `String`\n+  and `Character`. Versions of all the child packages are available.\n+\n+``Ada.Strings.Wide_Wide_Bounded`` *(A.4.7)*\n+\n+``Ada.Strings.Wide_Wide_Fixed`` *(A.4.7)*\n+\n+``Ada.Strings.Wide_Wide_Maps`` *(A.4.7)*\n+\n+``Ada.Strings.Wide_Wide_Unbounded`` *(A.4.7)*\n+  These packages provide analogous capabilities to the corresponding\n+  packages without ``Wide_`` in the name, but operate with the types\n+  `Wide_Wide_String` and `Wide_Wide_Character` instead\n+  of `String` and `Character`.\n+\n+``Ada.Synchronous_Barriers`` *(D.10.1)*\n+  This package provides facilities for synchronizing tasks at a low level\n+  with barriers.\n+\n+``Ada.Synchronous_Task_Control`` *(D.10)*\n+  This package provides some standard facilities for controlling task\n+  communication in a synchronous manner.\n+\n+``Ada.Synchronous_Task_Control.EDF`` *(D.10)*\n+  Not implemented in GNAT.\n+\n+``Ada.Tags``\n+  This package contains definitions for manipulation of the tags of tagged\n+  values.\n+\n+``Ada.Tags.Generic_Dispatching_Constructor`` *(3.9)*\n+  This package provides a way of constructing tagged class-wide values given\n+  only the tag value.\n+\n+``Ada.Task_Attributes`` *(C.7.2)*\n+  This package provides the capability of associating arbitrary\n+  task-specific data with separate tasks.\n+\n+``Ada.Task_Identifification`` *(C.7.1)*\n+  This package provides capabilities for task identification.\n+\n+``Ada.Task_Termination`` *(C.7.3)*\n+  This package provides control over task termination.\n+\n+``Ada.Text_IO``\n+  This package provides basic text input-output capabilities for\n+  character, string and numeric data.  The subpackages of this\n+  package are listed next. Note that although these are defined\n+  as subpackages in the RM, they are actually transparently\n+  implemented as child packages in GNAT, meaning that they\n+  are only loaded if needed.\n+\n+``Ada.Text_IO.Decimal_IO``\n+  Provides input-output facilities for decimal fixed-point types\n+\n+``Ada.Text_IO.Enumeration_IO``\n+  Provides input-output facilities for enumeration types.\n+\n+``Ada.Text_IO.Fixed_IO``\n+  Provides input-output facilities for ordinary fixed-point types.\n+\n+``Ada.Text_IO.Float_IO``\n+  Provides input-output facilities for float types.  The following\n+  predefined instantiations of this generic package are available:\n+\n+  * ``Short_Float``\n+\n+    `Short_Float_Text_IO`\n+\n+  * ``Float``\n+\n+    `Float_Text_IO`\n+\n+  * ``Long_Float``\n+\n+    `Long_Float_Text_IO`\n+\n+``Ada.Text_IO.Integer_IO``\n+  Provides input-output facilities for integer types.  The following\n+  predefined instantiations of this generic package are available:\n+\n+  * ``Short_Short_Integer``\n+\n+    `Ada.Short_Short_Integer_Text_IO`\n+\n+  * ``Short_Integer``\n+\n+    `Ada.Short_Integer_Text_IO`\n+\n+  * ``Integer``\n+\n+    `Ada.Integer_Text_IO`\n+\n+  * ``Long_Integer``\n+\n+    `Ada.Long_Integer_Text_IO`\n+\n+  * ``Long_Long_Integer``\n+\n+    `Ada.Long_Long_Integer_Text_IO`\n+\n+``Ada.Text_IO.Modular_IO``\n+  Provides input-output facilities for modular (unsigned) types.\n+\n+``Ada.Text_IO.Bounded_IO (A.10.11)``\n+  Provides input-output facilities for bounded strings.\n+\n+``Ada.Text_IO.Complex_IO (G.1.3)``\n+  This package provides basic text input-output capabilities for complex\n+  data.\n+\n+``Ada.Text_IO.Editing (F.3.3)``\n+  This package contains routines for edited output, analogous to the use\n+  of pictures in COBOL.  The picture formats used by this package are a\n+  close copy of the facility in COBOL.\n+\n+``Ada.Text_IO.Text_Streams (A.12.2)``\n+  This package provides a facility that allows Text_IO files to be treated\n+  as streams, so that the stream attributes can be used for writing\n+  arbitrary data, including binary data, to Text_IO files.\n+\n+``Ada.Text_IO.Unbounded_IO (A.10.12)``\n+  This package provides input-output facilities for unbounded strings.\n+\n+``Ada.Unchecked_Conversion (13.9)``\n+  This generic package allows arbitrary conversion from one type to\n+  another of the same size, providing for breaking the type safety in\n+  special circumstances.\n+\n+  If the types have the same Size (more accurately the same Value_Size),\n+  then the effect is simply to transfer the bits from the source to the\n+  target type without any modification.  This usage is well defined, and\n+  for simple types whose representation is typically the same across\n+  all implementations, gives a portable method of performing such\n+  conversions.\n+\n+  If the types do not have the same size, then the result is implementation\n+  defined, and thus may be non-portable.  The following describes how GNAT\n+  handles such unchecked conversion cases.\n+\n+  If the types are of different sizes, and are both discrete types, then\n+  the effect is of a normal type conversion without any constraint checking.\n+  In particular if the result type has a larger size, the result will be\n+  zero or sign extended.  If the result type has a smaller size, the result\n+  will be truncated by ignoring high order bits.\n+\n+  If the types are of different sizes, and are not both discrete types,\n+  then the conversion works as though pointers were created to the source\n+  and target, and the pointer value is converted.  The effect is that bits\n+  are copied from successive low order storage units and bits of the source\n+  up to the length of the target type.\n+\n+  A warning is issued if the lengths differ, since the effect in this\n+  case is implementation dependent, and the above behavior may not match\n+  that of some other compiler.\n+\n+  A pointer to one type may be converted to a pointer to another type using\n+  unchecked conversion.  The only case in which the effect is undefined is\n+  when one or both pointers are pointers to unconstrained array types.  In\n+  this case, the bounds information may get incorrectly transferred, and in\n+  particular, GNAT uses double size pointers for such types, and it is\n+  meaningless to convert between such pointer types.  GNAT will issue a\n+  warning if the alignment of the target designated type is more strict\n+  than the alignment of the source designated type (since the result may\n+  be unaligned in this case).\n+\n+  A pointer other than a pointer to an unconstrained array type may be\n+  converted to and from System.Address.  Such usage is common in Ada 83\n+  programs, but note that Ada.Address_To_Access_Conversions is the\n+  preferred method of performing such conversions in Ada 95 and Ada 2005.\n+  Neither\n+  unchecked conversion nor Ada.Address_To_Access_Conversions should be\n+  used in conjunction with pointers to unconstrained objects, since\n+  the bounds information cannot be handled correctly in this case.\n+\n+``Ada.Unchecked_Deallocation`` *(13.11.2)*\n+  This generic package allows explicit freeing of storage previously\n+  allocated by use of an allocator.\n+\n+``Ada.Wide_Text_IO`` *(A.11)*\n+  This package is similar to `Ada.Text_IO`, except that the external\n+  file supports wide character representations, and the internal types are\n+  `Wide_Character` and `Wide_String` instead of `Character`\n+  and `String`. The corresponding set of nested packages and child\n+  packages are defined.\n+\n+``Ada.Wide_Wide_Text_IO`` *(A.11)*\n+  This package is similar to `Ada.Text_IO`, except that the external\n+  file supports wide character representations, and the internal types are\n+  `Wide_Character` and `Wide_String` instead of `Character`\n+  and `String`. The corresponding set of nested packages and child\n+  packages are defined.\n+\n+For packages in Interfaces and System, all the RM defined packages are\n+available in GNAT, see the Ada 2012 RM for full details.\n+"}, {"sha": "a5f0aa210e6e91e2e2cf7d2c784e4e99ef2e0b16", "filename": "gcc/ada/doc/gnat_rm/the_gnat_library.rst", "status": "added", "additions": 2218, "deletions": 0, "changes": 2218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fthe_gnat_library.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fthe_gnat_library.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fthe_gnat_library.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,2218 @@\n+.. _The_GNAT_Library:\n+\n+****************\n+The GNAT Library\n+****************\n+\n+The GNAT library contains a number of general and special purpose packages.\n+It represents functionality that the GNAT developers have found useful, and\n+which is made available to GNAT users.  The packages described here are fully\n+supported, and upwards compatibility will be maintained in future releases,\n+so you can use these facilities with the confidence that the same functionality\n+will be available in future releases.\n+\n+The chapter here simply gives a brief summary of the facilities available.\n+The full documentation is found in the spec file for the package.  The full\n+sources of these library packages, including both spec and body, are provided\n+with all GNAT releases.  For example, to find out the full specifications of\n+the SPITBOL pattern matching capability, including a full tutorial and\n+extensive examples, look in the :file:`g-spipat.ads` file in the library.\n+\n+For each entry here, the package name (as it would appear in a `with`\n+clause) is given, followed by the name of the corresponding spec file in\n+parentheses.  The packages are children in four hierarchies, `Ada`,\n+`Interfaces`, `System`, and `GNAT`, the latter being a\n+GNAT-specific hierarchy.\n+\n+Note that an application program should only use packages in one of these\n+four hierarchies if the package is defined in the Ada Reference Manual,\n+or is listed in this section of the GNAT Programmers Reference Manual.\n+All other units should be considered internal implementation units and\n+should not be directly `with`'ed by application code.  The use of\n+a `with` statement that references one of these internal implementation\n+units makes an application potentially dependent on changes in versions\n+of GNAT, and will generate a warning message.\n+\n+.. _`Ada.Characters.Latin_9_(a-chlat9.ads)`:\n+\n+`Ada.Characters.Latin_9` (:file:`a-chlat9.ads`)\n+===============================================\n+\n+.. index:: Ada.Characters.Latin_9 (a-chlat9.ads)\n+\n+.. index:: Latin_9 constants for Character\n+\n+This child of `Ada.Characters`\n+provides a set of definitions corresponding to those in the\n+RM-defined package `Ada.Characters.Latin_1` but with the\n+few modifications required for `Latin-9`\n+The provision of such a package\n+is specifically authorized by the Ada Reference Manual\n+(RM A.3.3(27)).\n+\n+.. _`Ada.Characters.Wide_Latin_1_(a-cwila1.ads)`:\n+\n+`Ada.Characters.Wide_Latin_1` (:file:`a-cwila1.ads`)\n+====================================================\n+\n+.. index:: Ada.Characters.Wide_Latin_1 (a-cwila1.ads)\n+\n+.. index:: Latin_1 constants for Wide_Character\n+\n+This child of `Ada.Characters`\n+provides a set of definitions corresponding to those in the\n+RM-defined package `Ada.Characters.Latin_1` but with the\n+types of the constants being `Wide_Character`\n+instead of `Character`.  The provision of such a package\n+is specifically authorized by the Ada Reference Manual\n+(RM A.3.3(27)).\n+\n+.. _`Ada.Characters.Wide_Latin_9_(a-cwila1.ads)`:\n+\n+`Ada.Characters.Wide_Latin_9` (:file:`a-cwila1.ads`)\n+====================================================\n+\n+.. index:: Ada.Characters.Wide_Latin_9 (a-cwila1.ads)\n+\n+.. index:: Latin_9 constants for Wide_Character\n+\n+This child of `Ada.Characters`\n+provides a set of definitions corresponding to those in the\n+GNAT defined package `Ada.Characters.Latin_9` but with the\n+types of the constants being `Wide_Character`\n+instead of `Character`.  The provision of such a package\n+is specifically authorized by the Ada Reference Manual\n+(RM A.3.3(27)).\n+\n+.. _`Ada.Characters.Wide_Wide_Latin_1_(a-chzla1.ads)`:\n+\n+`Ada.Characters.Wide_Wide_Latin_1` (:file:`a-chzla1.ads`)\n+=========================================================\n+\n+.. index:: Ada.Characters.Wide_Wide_Latin_1 (a-chzla1.ads)\n+\n+.. index:: Latin_1 constants for Wide_Wide_Character\n+\n+This child of `Ada.Characters`\n+provides a set of definitions corresponding to those in the\n+RM-defined package `Ada.Characters.Latin_1` but with the\n+types of the constants being `Wide_Wide_Character`\n+instead of `Character`.  The provision of such a package\n+is specifically authorized by the Ada Reference Manual\n+(RM A.3.3(27)).\n+\n+.. _`Ada.Characters.Wide_Wide_Latin_9_(a-chzla9.ads)`:\n+\n+`Ada.Characters.Wide_Wide_Latin_9` (:file:`a-chzla9.ads`)\n+=========================================================\n+\n+.. index:: Ada.Characters.Wide_Wide_Latin_9 (a-chzla9.ads)\n+\n+.. index:: Latin_9 constants for Wide_Wide_Character\n+\n+This child of `Ada.Characters`\n+provides a set of definitions corresponding to those in the\n+GNAT defined package `Ada.Characters.Latin_9` but with the\n+types of the constants being `Wide_Wide_Character`\n+instead of `Character`.  The provision of such a package\n+is specifically authorized by the Ada Reference Manual\n+(RM A.3.3(27)).\n+\n+.. _`Ada.Containers.Formal_Doubly_Linked_Lists_(a-cfdlli.ads)`:\n+\n+`Ada.Containers.Formal_Doubly_Linked_Lists` (:file:`a-cfdlli.ads`)\n+==================================================================\n+\n+.. index:: Ada.Containers.Formal_Doubly_Linked_Lists (a-cfdlli.ads)\n+\n+.. index:: Formal container for doubly linked lists\n+\n+This child of `Ada.Containers` defines a modified version of the\n+Ada 2005 container for doubly linked lists, meant to facilitate formal\n+verification of code using such containers. The specification of this\n+unit is compatible with SPARK 2014.\n+\n+Note that although this container was designed with formal verification\n+in mind, it may well be generally useful in that it is a simplified more\n+efficient version than the one defined in the standard. In particular it\n+does not have the complex overhead required to detect cursor tampering.\n+\n+.. _`Ada.Containers.Formal_Hashed_Maps_(a-cfhama.ads)`:\n+\n+`Ada.Containers.Formal_Hashed_Maps` (:file:`a-cfhama.ads`)\n+==========================================================\n+\n+.. index:: Ada.Containers.Formal_Hashed_Maps (a-cfhama.ads)\n+\n+.. index:: Formal container for hashed maps\n+\n+This child of `Ada.Containers` defines a modified version of the\n+Ada 2005 container for hashed maps, meant to facilitate formal\n+verification of code using such containers. The specification of this\n+unit is compatible with SPARK 2014.\n+\n+Note that although this container was designed with formal verification\n+in mind, it may well be generally useful in that it is a simplified more\n+efficient version than the one defined in the standard. In particular it\n+does not have the complex overhead required to detect cursor tampering.\n+\n+.. _`Ada.Containers.Formal_Hashed_Sets_(a-cfhase.ads)`:\n+\n+`Ada.Containers.Formal_Hashed_Sets` (:file:`a-cfhase.ads`)\n+==========================================================\n+\n+.. index:: Ada.Containers.Formal_Hashed_Sets (a-cfhase.ads)\n+\n+.. index:: Formal container for hashed sets\n+\n+This child of `Ada.Containers` defines a modified version of the\n+Ada 2005 container for hashed sets, meant to facilitate formal\n+verification of code using such containers. The specification of this\n+unit is compatible with SPARK 2014.\n+\n+Note that although this container was designed with formal verification\n+in mind, it may well be generally useful in that it is a simplified more\n+efficient version than the one defined in the standard. In particular it\n+does not have the complex overhead required to detect cursor tampering.\n+\n+.. _`Ada.Containers.Formal_Ordered_Maps_(a-cforma.ads)`:\n+\n+`Ada.Containers.Formal_Ordered_Maps` (:file:`a-cforma.ads`)\n+===========================================================\n+\n+.. index:: Ada.Containers.Formal_Ordered_Maps (a-cforma.ads)\n+\n+.. index:: Formal container for ordered maps\n+\n+This child of `Ada.Containers` defines a modified version of the\n+Ada 2005 container for ordered maps, meant to facilitate formal\n+verification of code using such containers. The specification of this\n+unit is compatible with SPARK 2014.\n+\n+Note that although this container was designed with formal verification\n+in mind, it may well be generally useful in that it is a simplified more\n+efficient version than the one defined in the standard. In particular it\n+does not have the complex overhead required to detect cursor tampering.\n+\n+.. _`Ada.Containers.Formal_Ordered_Sets_(a-cforse.ads)`:\n+\n+`Ada.Containers.Formal_Ordered_Sets` (:file:`a-cforse.ads`)\n+===========================================================\n+\n+.. index:: Ada.Containers.Formal_Ordered_Sets (a-cforse.ads)\n+\n+.. index:: Formal container for ordered sets\n+\n+This child of `Ada.Containers` defines a modified version of the\n+Ada 2005 container for ordered sets, meant to facilitate formal\n+verification of code using such containers. The specification of this\n+unit is compatible with SPARK 2014.\n+\n+Note that although this container was designed with formal verification\n+in mind, it may well be generally useful in that it is a simplified more\n+efficient version than the one defined in the standard. In particular it\n+does not have the complex overhead required to detect cursor tampering.\n+\n+.. _`Ada.Containers.Formal_Vectors_(a-cofove.ads)`:\n+\n+`Ada.Containers.Formal_Vectors` (:file:`a-cofove.ads`)\n+======================================================\n+\n+.. index:: Ada.Containers.Formal_Vectors (a-cofove.ads)\n+\n+.. index:: Formal container for vectors\n+\n+This child of `Ada.Containers` defines a modified version of the\n+Ada 2005 container for vectors, meant to facilitate formal\n+verification of code using such containers. The specification of this\n+unit is compatible with SPARK 2014.\n+\n+Note that although this container was designed with formal verification\n+in mind, it may well be generally useful in that it is a simplified more\n+efficient version than the one defined in the standard. In particular it\n+does not have the complex overhead required to detect cursor tampering.\n+\n+.. _`Ada.Containers.Formal_Indefinite_Vectors_(a-cfinve.ads)`:\n+\n+`Ada.Containers.Formal_Indefinite_Vectors` (:file:`a-cfinve.ads`)\n+=================================================================\n+\n+.. index:: Ada.Containers.Formal_Indefinite_Vectors (a-cfinve.ads)\n+\n+.. index:: Formal container for vectors\n+\n+This child of `Ada.Containers` defines a modified version of the\n+Ada 2005 container for vectors of indefinite elements, meant to\n+facilitate formal verification of code using such containers. The\n+specification of this unit is compatible with SPARK 2014.\n+\n+Note that although this container was designed with formal verification\n+in mind, it may well be generally useful in that it is a simplified more\n+efficient version than the one defined in the standard. In particular it\n+does not have the complex overhead required to detect cursor tampering.\n+\n+.. _`Ada.Containers.Bounded_Holders_(a-coboho.ads)`:\n+\n+`Ada.Containers.Bounded_Holders` (:file:`a-coboho.ads`)\n+=======================================================\n+\n+.. index:: Ada.Containers.Bounded_Holders (a-coboho.ads)\n+\n+.. index:: Formal container for vectors\n+\n+This child of `Ada.Containers` defines a modified version of\n+Indefinite_Holders that avoids heap allocation.\n+\n+.. _`Ada.Command_Line.Environment_(a-colien.ads)`:\n+\n+`Ada.Command_Line.Environment` (:file:`a-colien.ads`)\n+=====================================================\n+\n+.. index:: Ada.Command_Line.Environment (a-colien.ads)\n+\n+.. index:: Environment entries\n+\n+This child of `Ada.Command_Line`\n+provides a mechanism for obtaining environment values on systems\n+where this concept makes sense.\n+\n+.. _`Ada.Command_Line.Remove_(a-colire.ads)`:\n+\n+`Ada.Command_Line.Remove` (:file:`a-colire.ads`)\n+================================================\n+\n+.. index:: Ada.Command_Line.Remove (a-colire.ads)\n+\n+.. index:: Removing command line arguments\n+\n+.. index:: Command line, argument removal\n+\n+This child of `Ada.Command_Line`\n+provides a mechanism for logically removing\n+arguments from the argument list.  Once removed, an argument is not visible\n+to further calls on the subprograms in `Ada.Command_Line` will not\n+see the removed argument.\n+\n+.. _`Ada.Command_Line.Response_File_(a-clrefi.ads)`:\n+\n+`Ada.Command_Line.Response_File` (:file:`a-clrefi.ads`)\n+=======================================================\n+\n+.. index:: Ada.Command_Line.Response_File (a-clrefi.ads)\n+\n+.. index:: Response file for command line\n+\n+.. index:: Command line, response file\n+\n+.. index:: Command line, handling long command lines\n+\n+This child of `Ada.Command_Line` provides a mechanism facilities for\n+getting command line arguments from a text file, called a \"response file\".\n+Using a response file allow passing a set of arguments to an executable longer\n+than the maximum allowed by the system on the command line.\n+\n+.. _`Ada.Direct_IO.C_Streams_(a-diocst.ads)`:\n+\n+`Ada.Direct_IO.C_Streams` (:file:`a-diocst.ads`)\n+================================================\n+\n+.. index:: Ada.Direct_IO.C_Streams (a-diocst.ads)\n+\n+.. index:: C Streams, Interfacing with Direct_IO\n+\n+This package provides subprograms that allow interfacing between\n+C streams and `Direct_IO`.  The stream identifier can be\n+extracted from a file opened on the Ada side, and an Ada file\n+can be constructed from a stream opened on the C side.\n+\n+.. _`Ada.Exceptions.Is_Null_Occurrence_(a-einuoc.ads)`:\n+\n+`Ada.Exceptions.Is_Null_Occurrence` (:file:`a-einuoc.ads`)\n+==========================================================\n+\n+.. index:: Ada.Exceptions.Is_Null_Occurrence (a-einuoc.ads)\n+\n+.. index:: Null_Occurrence, testing for\n+\n+This child subprogram provides a way of testing for the null\n+exception occurrence (`Null_Occurrence`) without raising\n+an exception.\n+\n+.. _`Ada.Exceptions.Last_Chance_Handler_(a-elchha.ads)`:\n+\n+`Ada.Exceptions.Last_Chance_Handler` (:file:`a-elchha.ads`)\n+===========================================================\n+\n+.. index:: Ada.Exceptions.Last_Chance_Handler (a-elchha.ads)\n+\n+.. index:: Null_Occurrence, testing for\n+\n+This child subprogram is used for handling otherwise unhandled\n+exceptions (hence the name last chance), and perform clean ups before\n+terminating the program. Note that this subprogram never returns.\n+\n+.. _`Ada.Exceptions.Traceback_(a-exctra.ads)`:\n+\n+`Ada.Exceptions.Traceback` (:file:`a-exctra.ads`)\n+=================================================\n+\n+.. index:: Ada.Exceptions.Traceback (a-exctra.ads)\n+\n+.. index:: Traceback for Exception Occurrence\n+\n+This child package provides the subprogram (`Tracebacks`) to\n+give a traceback array of addresses based on an exception\n+occurrence.\n+\n+.. _`Ada.Sequential_IO.C_Streams_(a-siocst.ads)`:\n+\n+`Ada.Sequential_IO.C_Streams` (:file:`a-siocst.ads`)\n+====================================================\n+\n+.. index:: Ada.Sequential_IO.C_Streams (a-siocst.ads)\n+\n+.. index:: C Streams, Interfacing with Sequential_IO\n+\n+This package provides subprograms that allow interfacing between\n+C streams and `Sequential_IO`.  The stream identifier can be\n+extracted from a file opened on the Ada side, and an Ada file\n+can be constructed from a stream opened on the C side.\n+\n+.. _`Ada.Streams.Stream_IO.C_Streams_(a-ssicst.ads)`:\n+\n+`Ada.Streams.Stream_IO.C_Streams` (:file:`a-ssicst.ads`)\n+========================================================\n+\n+.. index:: Ada.Streams.Stream_IO.C_Streams (a-ssicst.ads)\n+\n+.. index:: C Streams, Interfacing with Stream_IO\n+\n+This package provides subprograms that allow interfacing between\n+C streams and `Stream_IO`.  The stream identifier can be\n+extracted from a file opened on the Ada side, and an Ada file\n+can be constructed from a stream opened on the C side.\n+\n+.. _`Ada.Strings.Unbounded.Text_IO_(a-suteio.ads)`:\n+\n+`Ada.Strings.Unbounded.Text_IO` (:file:`a-suteio.ads`)\n+======================================================\n+\n+.. index:: Ada.Strings.Unbounded.Text_IO (a-suteio.ads)\n+\n+.. index:: Unbounded_String, IO support\n+\n+.. index:: Text_IO, extensions for unbounded strings\n+\n+This package provides subprograms for Text_IO for unbounded\n+strings, avoiding the necessity for an intermediate operation\n+with ordinary strings.\n+\n+.. _`Ada.Strings.Wide_Unbounded.Wide_Text_IO_(a-swuwti.ads)`:\n+\n+`Ada.Strings.Wide_Unbounded.Wide_Text_IO` (:file:`a-swuwti.ads`)\n+================================================================\n+\n+.. index:: Ada.Strings.Wide_Unbounded.Wide_Text_IO (a-swuwti.ads)\n+\n+.. index:: Unbounded_Wide_String, IO support\n+\n+.. index:: Text_IO, extensions for unbounded wide strings\n+\n+This package provides subprograms for Text_IO for unbounded\n+wide strings, avoiding the necessity for an intermediate operation\n+with ordinary wide strings.\n+\n+.. _`Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO_(a-szuzti.ads)`:\n+\n+`Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO` (:file:`a-szuzti.ads`)\n+==========================================================================\n+\n+.. index:: Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO (a-szuzti.ads)\n+\n+.. index:: Unbounded_Wide_Wide_String, IO support\n+\n+.. index:: Text_IO, extensions for unbounded wide wide strings\n+\n+This package provides subprograms for Text_IO for unbounded\n+wide wide strings, avoiding the necessity for an intermediate operation\n+with ordinary wide wide strings.\n+\n+.. _`Ada.Text_IO.C_Streams_(a-tiocst.ads)`:\n+\n+`Ada.Text_IO.C_Streams` (:file:`a-tiocst.ads`)\n+==============================================\n+\n+.. index:: Ada.Text_IO.C_Streams (a-tiocst.ads)\n+\n+.. index:: C Streams, Interfacing with `Text_IO`\n+\n+This package provides subprograms that allow interfacing between\n+C streams and `Text_IO`.  The stream identifier can be\n+extracted from a file opened on the Ada side, and an Ada file\n+can be constructed from a stream opened on the C side.\n+\n+.. _`Ada.Text_IO.Reset_Standard_Files_(a-tirsfi.ads)`:\n+\n+`Ada.Text_IO.Reset_Standard_Files` (:file:`a-tirsfi.ads`)\n+=========================================================\n+\n+.. index:: Ada.Text_IO.Reset_Standard_Files (a-tirsfi.ads)\n+\n+.. index:: Text_IO resetting standard files\n+\n+This procedure is used to reset the status of the standard files used\n+by Ada.Text_IO.  This is useful in a situation (such as a restart in an\n+embedded application) where the status of the files may change during\n+execution (for example a standard input file may be redefined to be\n+interactive).\n+\n+.. _`Ada.Wide_Characters.Unicode_(a-wichun.ads)`:\n+\n+`Ada.Wide_Characters.Unicode` (:file:`a-wichun.ads`)\n+====================================================\n+\n+.. index:: Ada.Wide_Characters.Unicode (a-wichun.ads)\n+\n+.. index:: Unicode categorization, Wide_Character\n+\n+This package provides subprograms that allow categorization of\n+Wide_Character values according to Unicode categories.\n+\n+.. _`Ada.Wide_Text_IO.C_Streams_(a-wtcstr.ads)`:\n+\n+`Ada.Wide_Text_IO.C_Streams` (:file:`a-wtcstr.ads`)\n+===================================================\n+\n+.. index:: Ada.Wide_Text_IO.C_Streams (a-wtcstr.ads)\n+\n+.. index:: C Streams, Interfacing with `Wide_Text_IO`\n+\n+This package provides subprograms that allow interfacing between\n+C streams and `Wide_Text_IO`.  The stream identifier can be\n+extracted from a file opened on the Ada side, and an Ada file\n+can be constructed from a stream opened on the C side.\n+\n+.. _`Ada.Wide_Text_IO.Reset_Standard_Files_(a-wrstfi.ads)`:\n+\n+`Ada.Wide_Text_IO.Reset_Standard_Files` (:file:`a-wrstfi.ads`)\n+==============================================================\n+\n+.. index:: Ada.Wide_Text_IO.Reset_Standard_Files (a-wrstfi.ads)\n+\n+.. index:: Wide_Text_IO resetting standard files\n+\n+This procedure is used to reset the status of the standard files used\n+by Ada.Wide_Text_IO.  This is useful in a situation (such as a restart in an\n+embedded application) where the status of the files may change during\n+execution (for example a standard input file may be redefined to be\n+interactive).\n+\n+.. _`Ada.Wide_Wide_Characters.Unicode_(a-zchuni.ads)`:\n+\n+`Ada.Wide_Wide_Characters.Unicode` (:file:`a-zchuni.ads`)\n+=========================================================\n+\n+.. index:: Ada.Wide_Wide_Characters.Unicode (a-zchuni.ads)\n+\n+.. index:: Unicode categorization, Wide_Wide_Character\n+\n+This package provides subprograms that allow categorization of\n+Wide_Wide_Character values according to Unicode categories.\n+\n+.. _`Ada.Wide_Wide_Text_IO.C_Streams_(a-ztcstr.ads)`:\n+\n+`Ada.Wide_Wide_Text_IO.C_Streams` (:file:`a-ztcstr.ads`)\n+========================================================\n+\n+.. index:: Ada.Wide_Wide_Text_IO.C_Streams (a-ztcstr.ads)\n+\n+.. index:: C Streams, Interfacing with `Wide_Wide_Text_IO`\n+\n+This package provides subprograms that allow interfacing between\n+C streams and `Wide_Wide_Text_IO`.  The stream identifier can be\n+extracted from a file opened on the Ada side, and an Ada file\n+can be constructed from a stream opened on the C side.\n+\n+.. _`Ada.Wide_Wide_Text_IO.Reset_Standard_Files_(a-zrstfi.ads)`:\n+\n+`Ada.Wide_Wide_Text_IO.Reset_Standard_Files` (:file:`a-zrstfi.ads`)\n+===================================================================\n+\n+.. index:: Ada.Wide_Wide_Text_IO.Reset_Standard_Files (a-zrstfi.ads)\n+\n+.. index:: Wide_Wide_Text_IO resetting standard files\n+\n+This procedure is used to reset the status of the standard files used\n+by Ada.Wide_Wide_Text_IO. This is useful in a situation (such as a\n+restart in an embedded application) where the status of the files may\n+change during execution (for example a standard input file may be\n+redefined to be interactive).\n+\n+.. _`GNAT.Altivec_(g-altive.ads)`:\n+\n+`GNAT.Altivec` (:file:`g-altive.ads`)\n+=====================================\n+\n+.. index:: GNAT.Altivec (g-altive.ads)\n+\n+.. index:: AltiVec\n+\n+This is the root package of the GNAT AltiVec binding. It provides\n+definitions of constants and types common to all the versions of the\n+binding.\n+\n+.. _`GNAT.Altivec.Conversions_(g-altcon.ads)`:\n+\n+`GNAT.Altivec.Conversions` (:file:`g-altcon.ads`)\n+=================================================\n+\n+.. index:: GNAT.Altivec.Conversions (g-altcon.ads)\n+\n+.. index:: AltiVec\n+\n+This package provides the Vector/View conversion routines.\n+\n+.. _`GNAT.Altivec.Vector_Operations_(g-alveop.ads)`:\n+\n+`GNAT.Altivec.Vector_Operations` (:file:`g-alveop.ads`)\n+=======================================================\n+\n+.. index:: GNAT.Altivec.Vector_Operations (g-alveop.ads)\n+\n+.. index:: AltiVec\n+\n+This package exposes the Ada interface to the AltiVec operations on\n+vector objects. A soft emulation is included by default in the GNAT\n+library. The hard binding is provided as a separate package. This unit\n+is common to both bindings.\n+\n+.. _`GNAT.Altivec.Vector_Types_(g-alvety.ads)`:\n+\n+`GNAT.Altivec.Vector_Types` (:file:`g-alvety.ads`)\n+==================================================\n+\n+.. index:: GNAT.Altivec.Vector_Types (g-alvety.ads)\n+\n+.. index:: AltiVec\n+\n+This package exposes the various vector types part of the Ada binding\n+to AltiVec facilities.\n+\n+.. _`GNAT.Altivec.Vector_Views_(g-alvevi.ads)`:\n+\n+`GNAT.Altivec.Vector_Views` (:file:`g-alvevi.ads`)\n+==================================================\n+\n+.. index:: GNAT.Altivec.Vector_Views (g-alvevi.ads)\n+\n+.. index:: AltiVec\n+\n+This package provides public 'View' data types from/to which private\n+vector representations can be converted via\n+GNAT.Altivec.Conversions. This allows convenient access to individual\n+vector elements and provides a simple way to initialize vector\n+objects.\n+\n+.. _`GNAT.Array_Split_(g-arrspl.ads)`:\n+\n+`GNAT.Array_Split` (:file:`g-arrspl.ads`)\n+=========================================\n+\n+.. index:: GNAT.Array_Split (g-arrspl.ads)\n+\n+.. index:: Array splitter\n+\n+Useful array-manipulation routines: given a set of separators, split\n+an array wherever the separators appear, and provide direct access\n+to the resulting slices.\n+\n+.. _`GNAT.AWK_(g-awk.ads)`:\n+\n+`GNAT.AWK` (:file:`g-awk.ads`)\n+==============================\n+\n+.. index:: GNAT.AWK (g-awk.ads)\n+\n+.. index:: Parsing\n+\n+.. index:: AWK\n+\n+Provides AWK-like parsing functions, with an easy interface for parsing one\n+or more files containing formatted data.  The file is viewed as a database\n+where each record is a line and a field is a data element in this line.\n+\n+.. _`GNAT.Bounded_Buffers_(g-boubuf.ads)`:\n+\n+`GNAT.Bounded_Buffers` (:file:`g-boubuf.ads`)\n+=============================================\n+\n+.. index:: GNAT.Bounded_Buffers (g-boubuf.ads)\n+\n+.. index:: Parsing\n+\n+.. index:: Bounded Buffers\n+\n+Provides a concurrent generic bounded buffer abstraction.  Instances are\n+useful directly or as parts of the implementations of other abstractions,\n+such as mailboxes.\n+\n+.. _`GNAT.Bounded_Mailboxes_(g-boumai.ads)`:\n+\n+`GNAT.Bounded_Mailboxes` (:file:`g-boumai.ads`)\n+===============================================\n+\n+.. index:: GNAT.Bounded_Mailboxes (g-boumai.ads)\n+\n+.. index:: Parsing\n+\n+.. index:: Mailboxes\n+\n+Provides a thread-safe asynchronous intertask mailbox communication facility.\n+\n+.. _`GNAT.Bubble_Sort_(g-bubsor.ads)`:\n+\n+`GNAT.Bubble_Sort` (:file:`g-bubsor.ads`)\n+=========================================\n+\n+.. index:: GNAT.Bubble_Sort (g-bubsor.ads)\n+\n+.. index:: Sorting\n+\n+.. index:: Bubble sort\n+\n+Provides a general implementation of bubble sort usable for sorting arbitrary\n+data items.  Exchange and comparison procedures are provided by passing\n+access-to-procedure values.\n+\n+.. _`GNAT.Bubble_Sort_A_(g-busora.ads)`:\n+\n+`GNAT.Bubble_Sort_A` (:file:`g-busora.ads`)\n+===========================================\n+\n+.. index:: GNAT.Bubble_Sort_A (g-busora.ads)\n+\n+.. index:: Sorting\n+\n+.. index:: Bubble sort\n+\n+Provides a general implementation of bubble sort usable for sorting arbitrary\n+data items.  Move and comparison procedures are provided by passing\n+access-to-procedure values. This is an older version, retained for\n+compatibility. Usually `GNAT.Bubble_Sort` will be preferable.\n+\n+.. _`GNAT.Bubble_Sort_G_(g-busorg.ads)`:\n+\n+`GNAT.Bubble_Sort_G` (:file:`g-busorg.ads`)\n+===========================================\n+\n+.. index:: GNAT.Bubble_Sort_G (g-busorg.ads)\n+\n+.. index:: Sorting\n+\n+.. index:: Bubble sort\n+\n+Similar to `Bubble_Sort_A` except that the move and sorting procedures\n+are provided as generic parameters, this improves efficiency, especially\n+if the procedures can be inlined, at the expense of duplicating code for\n+multiple instantiations.\n+\n+.. _`GNAT.Byte_Order_Mark_(g-byorma.ads)`:\n+\n+`GNAT.Byte_Order_Mark` (:file:`g-byorma.ads`)\n+=============================================\n+\n+.. index:: GNAT.Byte_Order_Mark (g-byorma.ads)\n+\n+.. index:: UTF-8 representation\n+\n+.. index:: Wide characte representations\n+\n+Provides a routine which given a string, reads the start of the string to\n+see whether it is one of the standard byte order marks (BOM's) which signal\n+the encoding of the string. The routine includes detection of special XML\n+sequences for various UCS input formats.\n+\n+.. _`GNAT.Byte_Swapping_(g-bytswa.ads)`:\n+\n+`GNAT.Byte_Swapping` (:file:`g-bytswa.ads`)\n+===========================================\n+\n+.. index:: GNAT.Byte_Swapping (g-bytswa.ads)\n+\n+.. index:: Byte swapping\n+\n+.. index:: Endianness\n+\n+General routines for swapping the bytes in 2-, 4-, and 8-byte quantities.\n+Machine-specific implementations are available in some cases.\n+\n+.. _`GNAT.Calendar_(g-calend.ads)`:\n+\n+`GNAT.Calendar` (:file:`g-calend.ads`)\n+======================================\n+\n+.. index:: GNAT.Calendar (g-calend.ads)\n+\n+.. index:: Calendar\n+\n+Extends the facilities provided by `Ada.Calendar` to include handling\n+of days of the week, an extended `Split` and `Time_Of` capability.\n+Also provides conversion of `Ada.Calendar.Time` values to and from the\n+C `timeval` format.\n+\n+.. _`GNAT.Calendar.Time_IO_(g-catiio.ads)`:\n+\n+`GNAT.Calendar.Time_IO` (:file:`g-catiio.ads`)\n+==============================================\n+\n+.. index:: Calendar\n+\n+.. index:: Time\n+\n+.. index:: GNAT.Calendar.Time_IO (g-catiio.ads)\n+\n+.. _`GNAT.CRC32_(g-crc32.ads)`:\n+\n+`GNAT.CRC32` (:file:`g-crc32.ads`)\n+==================================\n+\n+.. index:: GNAT.CRC32 (g-crc32.ads)\n+\n+.. index:: CRC32\n+\n+.. index:: Cyclic Redundancy Check\n+\n+This package implements the CRC-32 algorithm.  For a full description\n+of this algorithm see\n+*Computation of Cyclic Redundancy Checks via Table Look-Up*,\n+:title:`Communications of the ACM`, Vol. 31 No. 8, pp. 1008-1013,\n+Aug. 1988.  Sarwate, D.V.\n+\n+.. _`GNAT.Case_Util_(g-casuti.ads)`:\n+\n+`GNAT.Case_Util` (:file:`g-casuti.ads`)\n+=======================================\n+\n+.. index:: GNAT.Case_Util (g-casuti.ads)\n+\n+.. index:: Casing utilities\n+\n+.. index:: Character handling (`GNAT.Case_Util`)\n+\n+A set of simple routines for handling upper and lower casing of strings\n+without the overhead of the full casing tables\n+in `Ada.Characters.Handling`.\n+\n+.. _`GNAT.CGI_(g-cgi.ads)`:\n+\n+`GNAT.CGI` (:file:`g-cgi.ads`)\n+==============================\n+\n+.. index:: GNAT.CGI (g-cgi.ads)\n+\n+.. index:: CGI (Common Gateway Interface)\n+\n+This is a package for interfacing a GNAT program with a Web server via the\n+Common Gateway Interface (CGI).  Basically this package parses the CGI\n+parameters, which are a set of key/value pairs sent by the Web server.  It\n+builds a table whose index is the key and provides some services to deal\n+with this table.\n+\n+.. _`GNAT.CGI.Cookie_(g-cgicoo.ads)`:\n+\n+`GNAT.CGI.Cookie` (:file:`g-cgicoo.ads`)\n+========================================\n+\n+.. index:: GNAT.CGI.Cookie (g-cgicoo.ads)\n+\n+.. index:: CGI (Common Gateway Interface) cookie support\n+\n+.. index:: Cookie support in CGI\n+\n+This is a package to interface a GNAT program with a Web server via the\n+Common Gateway Interface (CGI).  It exports services to deal with Web\n+cookies (piece of information kept in the Web client software).\n+\n+.. _`GNAT.CGI.Debug_(g-cgideb.ads)`:\n+\n+`GNAT.CGI.Debug` (:file:`g-cgideb.ads`)\n+=======================================\n+\n+.. index:: GNAT.CGI.Debug (g-cgideb.ads)\n+\n+.. index:: CGI (Common Gateway Interface) debugging\n+\n+This is a package to help debugging CGI (Common Gateway Interface)\n+programs written in Ada.\n+\n+.. _`GNAT.Command_Line_(g-comlin.ads)`:\n+\n+`GNAT.Command_Line` (:file:`g-comlin.ads`)\n+==========================================\n+\n+.. index:: GNAT.Command_Line (g-comlin.ads)\n+\n+.. index:: Command line\n+\n+Provides a high level interface to `Ada.Command_Line` facilities,\n+including the ability to scan for named switches with optional parameters\n+and expand file names using wild card notations.\n+\n+.. _`GNAT.Compiler_Version_(g-comver.ads)`:\n+\n+`GNAT.Compiler_Version` (:file:`g-comver.ads`)\n+==============================================\n+\n+.. index:: GNAT.Compiler_Version (g-comver.ads)\n+\n+.. index:: Compiler Version\n+\n+.. index:: Version, of compiler\n+\n+Provides a routine for obtaining the version of the compiler used to\n+compile the program. More accurately this is the version of the binder\n+used to bind the program (this will normally be the same as the version\n+of the compiler if a consistent tool set is used to compile all units\n+of a partition).\n+\n+.. _`GNAT.Ctrl_C_(g-ctrl_c.ads)`:\n+\n+`GNAT.Ctrl_C` (:file:`g-ctrl_c.ads`)\n+====================================\n+\n+.. index:: GNAT.Ctrl_C (g-ctrl_c.ads)\n+\n+.. index:: Interrupt\n+\n+Provides a simple interface to handle Ctrl-C keyboard events.\n+\n+.. _`GNAT.Current_Exception_(g-curexc.ads)`:\n+\n+`GNAT.Current_Exception` (:file:`g-curexc.ads`)\n+===============================================\n+\n+.. index:: GNAT.Current_Exception (g-curexc.ads)\n+\n+.. index:: Current exception\n+\n+.. index:: Exception retrieval\n+\n+Provides access to information on the current exception that has been raised\n+without the need for using the Ada 95 / Ada 2005 exception choice parameter\n+specification syntax.\n+This is particularly useful in simulating typical facilities for\n+obtaining information about exceptions provided by Ada 83 compilers.\n+\n+.. _`GNAT.Debug_Pools_(g-debpoo.ads)`:\n+\n+`GNAT.Debug_Pools` (:file:`g-debpoo.ads`)\n+=========================================\n+\n+.. index:: GNAT.Debug_Pools (g-debpoo.ads)\n+\n+.. index:: Debugging\n+\n+.. index:: Debug pools\n+\n+.. index:: Memory corruption debugging\n+\n+Provide a debugging storage pools that helps tracking memory corruption\n+problems.  \n+See `The GNAT Debug_Pool Facility` section in the :title:`GNAT User's Guide`.\n+\n+.. _`GNAT.Debug_Utilities_(g-debuti.ads)`:\n+\n+`GNAT.Debug_Utilities` (:file:`g-debuti.ads`)\n+=============================================\n+\n+.. index:: GNAT.Debug_Utilities (g-debuti.ads)\n+\n+.. index:: Debugging\n+\n+Provides a few useful utilities for debugging purposes, including conversion\n+to and from string images of address values. Supports both C and Ada formats\n+for hexadecimal literals.\n+\n+.. _`GNAT.Decode_String_(g-decstr.ads)`:\n+\n+`GNAT.Decode_String` (:file:`g-decstr.ads`)\n+===========================================\n+\n+.. index:: GNAT.Decode_String (g-decstr.ads)\n+\n+.. index:: Decoding strings\n+\n+.. index:: String decoding\n+\n+.. index:: Wide character encoding\n+\n+.. index:: UTF-8\n+\n+.. index:: Unicode\n+\n+A generic package providing routines for decoding wide character and wide wide\n+character strings encoded as sequences of 8-bit characters using a specified\n+encoding method. Includes validation routines, and also routines for stepping\n+to next or previous encoded character in an encoded string.\n+Useful in conjunction with Unicode character coding. Note there is a\n+preinstantiation for UTF-8. See next entry.\n+\n+.. _`GNAT.Decode_UTF8_String_(g-deutst.ads)`:\n+\n+`GNAT.Decode_UTF8_String` (:file:`g-deutst.ads`)\n+================================================\n+\n+.. index:: GNAT.Decode_UTF8_String (g-deutst.ads)\n+\n+.. index:: Decoding strings\n+\n+.. index:: Decoding UTF-8 strings\n+\n+.. index:: UTF-8 string decoding\n+\n+.. index:: Wide character decoding\n+\n+.. index:: UTF-8\n+\n+.. index:: Unicode\n+\n+A preinstantiation of GNAT.Decode_Strings for UTF-8 encoding.\n+\n+.. _`GNAT.Directory_Operations_(g-dirope.ads)`:\n+\n+`GNAT.Directory_Operations` (:file:`g-dirope.ads`)\n+==================================================\n+\n+.. index:: GNAT.Directory_Operations (g-dirope.ads)\n+\n+.. index:: Directory operations\n+\n+Provides a set of routines for manipulating directories, including changing\n+the current directory, making new directories, and scanning the files in a\n+directory.\n+\n+.. _`GNAT.Directory_Operations.Iteration_(g-diopit.ads)`:\n+\n+`GNAT.Directory_Operations.Iteration` (:file:`g-diopit.ads`)\n+============================================================\n+\n+.. index:: GNAT.Directory_Operations.Iteration (g-diopit.ads)\n+\n+.. index:: Directory operations iteration\n+\n+A child unit of GNAT.Directory_Operations providing additional operations\n+for iterating through directories.\n+\n+.. _`GNAT.Dynamic_HTables_(g-dynhta.ads)`:\n+\n+`GNAT.Dynamic_HTables` (:file:`g-dynhta.ads`)\n+=============================================\n+\n+.. index:: GNAT.Dynamic_HTables (g-dynhta.ads)\n+\n+.. index:: Hash tables\n+\n+A generic implementation of hash tables that can be used to hash arbitrary\n+data.  Provided in two forms, a simple form with built in hash functions,\n+and a more complex form in which the hash function is supplied.\n+\n+This package provides a facility similar to that of `GNAT.HTable`,\n+except that this package declares a type that can be used to define\n+dynamic instances of the hash table, while an instantiation of\n+`GNAT.HTable` creates a single instance of the hash table.\n+\n+.. _`GNAT.Dynamic_Tables_(g-dyntab.ads)`:\n+\n+`GNAT.Dynamic_Tables` (:file:`g-dyntab.ads`)\n+============================================\n+\n+.. index:: GNAT.Dynamic_Tables (g-dyntab.ads)\n+\n+.. index:: Table implementation\n+\n+.. index:: Arrays, extendable\n+\n+A generic package providing a single dimension array abstraction where the\n+length of the array can be dynamically modified.\n+\n+This package provides a facility similar to that of `GNAT.Table`,\n+except that this package declares a type that can be used to define\n+dynamic instances of the table, while an instantiation of\n+`GNAT.Table` creates a single instance of the table type.\n+\n+.. _`GNAT.Encode_String_(g-encstr.ads)`:\n+\n+`GNAT.Encode_String` (:file:`g-encstr.ads`)\n+===========================================\n+\n+.. index:: GNAT.Encode_String (g-encstr.ads)\n+\n+.. index:: Encoding strings\n+\n+.. index:: String encoding\n+\n+.. index:: Wide character encoding\n+\n+.. index:: UTF-8\n+\n+.. index:: Unicode\n+\n+A generic package providing routines for encoding wide character and wide\n+wide character strings as sequences of 8-bit characters using a specified\n+encoding method. Useful in conjunction with Unicode character coding.\n+Note there is a preinstantiation for UTF-8. See next entry.\n+\n+.. _`GNAT.Encode_UTF8_String_(g-enutst.ads)`:\n+\n+`GNAT.Encode_UTF8_String` (:file:`g-enutst.ads`)\n+================================================\n+\n+.. index:: GNAT.Encode_UTF8_String (g-enutst.ads)\n+\n+.. index:: Encoding strings\n+\n+.. index:: Encoding UTF-8 strings\n+\n+.. index:: UTF-8 string encoding\n+\n+.. index:: Wide character encoding\n+\n+.. index:: UTF-8\n+\n+.. index:: Unicode\n+\n+A preinstantiation of GNAT.Encode_Strings for UTF-8 encoding.\n+\n+.. _`GNAT.Exception_Actions_(g-excact.ads)`:\n+\n+`GNAT.Exception_Actions` (:file:`g-excact.ads`)\n+===============================================\n+\n+.. index:: GNAT.Exception_Actions (g-excact.ads)\n+\n+.. index:: Exception actions\n+\n+Provides callbacks when an exception is raised. Callbacks can be registered\n+for specific exceptions, or when any exception is raised. This\n+can be used for instance to force a core dump to ease debugging.\n+\n+.. _`GNAT.Exception_Traces_(g-exctra.ads)`:\n+\n+`GNAT.Exception_Traces` (:file:`g-exctra.ads`)\n+==============================================\n+\n+.. index:: GNAT.Exception_Traces (g-exctra.ads)\n+\n+.. index:: Exception traces\n+\n+.. index:: Debugging\n+\n+Provides an interface allowing to control automatic output upon exception\n+occurrences.\n+\n+.. _`GNAT.Exceptions_(g-expect.ads)`:\n+\n+`GNAT.Exceptions` (:file:`g-expect.ads`)\n+========================================\n+\n+.. index:: GNAT.Exceptions (g-expect.ads)\n+\n+.. index:: Exceptions, Pure\n+\n+.. index:: Pure packages, exceptions\n+\n+Normally it is not possible to raise an exception with\n+a message from a subprogram in a pure package, since the\n+necessary types and subprograms are in `Ada.Exceptions`\n+which is not a pure unit. `GNAT.Exceptions` provides a\n+facility for getting around this limitation for a few\n+predefined exceptions, and for example allow raising\n+`Constraint_Error` with a message from a pure subprogram.\n+\n+.. _`GNAT.Expect_(g-expect.ads)`:\n+\n+`GNAT.Expect` (:file:`g-expect.ads`)\n+====================================\n+\n+.. index:: GNAT.Expect (g-expect.ads)\n+\n+Provides a set of subprograms similar to what is available\n+with the standard Tcl Expect tool.\n+It allows you to easily spawn and communicate with an external process.\n+You can send commands or inputs to the process, and compare the output\n+with some expected regular expression. Currently `GNAT.Expect`\n+is implemented on all native GNAT ports.\n+It is not implemented for cross ports, and in particular is not\n+implemented for VxWorks or LynxOS.\n+\n+.. _`GNAT.Expect.TTY_(g-exptty.ads)`:\n+\n+`GNAT.Expect.TTY` (:file:`g-exptty.ads`)\n+========================================\n+\n+.. index:: GNAT.Expect.TTY (g-exptty.ads)\n+\n+As GNAT.Expect but using pseudo-terminal.\n+Currently `GNAT.Expect.TTY` is implemented on all native GNAT\n+ports. It is not implemented for cross ports, and\n+in particular is not implemented for VxWorks or LynxOS.\n+\n+.. _`GNAT.Float_Control_(g-flocon.ads)`:\n+\n+`GNAT.Float_Control` (:file:`g-flocon.ads`)\n+===========================================\n+\n+.. index:: GNAT.Float_Control (g-flocon.ads)\n+\n+.. index:: Floating-Point Processor\n+\n+Provides an interface for resetting the floating-point processor into the\n+mode required for correct semantic operation in Ada.  Some third party\n+library calls may cause this mode to be modified, and the Reset procedure\n+in this package can be used to reestablish the required mode.\n+\n+.. _`GNAT.Formatted_String_(g-forstr.ads)`:\n+\n+`GNAT.Formatted_String` (:file:`g-forstr.ads`)\n+==============================================\n+\n+.. index:: GNAT.Formatted_String (g-forstr.ads)\n+\n+.. index:: Formatted String\n+\n+Provides support for C/C++ printf() formatted strings. The format is\n+copied from the printf() routine and should therefore gives identical\n+output. Some generic routines are provided to be able to use types\n+derived from Integer, Float or enumerations as values for the\n+formatted string.\n+\n+.. _`GNAT.Heap_Sort_(g-heasor.ads)`:\n+\n+`GNAT.Heap_Sort` (:file:`g-heasor.ads`)\n+=======================================\n+\n+.. index:: GNAT.Heap_Sort (g-heasor.ads)\n+\n+.. index:: Sorting\n+\n+Provides a general implementation of heap sort usable for sorting arbitrary\n+data items. Exchange and comparison procedures are provided by passing\n+access-to-procedure values.  The algorithm used is a modified heap sort\n+that performs approximately N*log(N) comparisons in the worst case.\n+\n+.. _`GNAT.Heap_Sort_A_(g-hesora.ads)`:\n+\n+`GNAT.Heap_Sort_A` (:file:`g-hesora.ads`)\n+=========================================\n+\n+.. index:: GNAT.Heap_Sort_A (g-hesora.ads)\n+\n+.. index:: Sorting\n+\n+Provides a general implementation of heap sort usable for sorting arbitrary\n+data items. Move and comparison procedures are provided by passing\n+access-to-procedure values.  The algorithm used is a modified heap sort\n+that performs approximately N*log(N) comparisons in the worst case.\n+This differs from `GNAT.Heap_Sort` in having a less convenient\n+interface, but may be slightly more efficient.\n+\n+.. _`GNAT.Heap_Sort_G_(g-hesorg.ads)`:\n+\n+`GNAT.Heap_Sort_G` (:file:`g-hesorg.ads`)\n+=========================================\n+\n+.. index:: GNAT.Heap_Sort_G (g-hesorg.ads)\n+\n+.. index:: Sorting\n+\n+Similar to `Heap_Sort_A` except that the move and sorting procedures\n+are provided as generic parameters, this improves efficiency, especially\n+if the procedures can be inlined, at the expense of duplicating code for\n+multiple instantiations.\n+\n+.. _`GNAT.HTable_(g-htable.ads)`:\n+\n+`GNAT.HTable` (:file:`g-htable.ads`)\n+====================================\n+\n+.. index:: GNAT.HTable (g-htable.ads)\n+\n+.. index:: Hash tables\n+\n+A generic implementation of hash tables that can be used to hash arbitrary\n+data.  Provides two approaches, one a simple static approach, and the other\n+allowing arbitrary dynamic hash tables.\n+\n+.. _`GNAT.IO_(g-io.ads)`:\n+\n+`GNAT.IO` (:file:`g-io.ads`)\n+============================\n+\n+.. index:: GNAT.IO (g-io.ads)\n+\n+.. index:: Simple I/O\n+\n+.. index:: Input/Output facilities\n+\n+A simple preelaborable input-output package that provides a subset of\n+simple Text_IO functions for reading characters and strings from\n+Standard_Input, and writing characters, strings and integers to either\n+Standard_Output or Standard_Error.\n+\n+.. _`GNAT.IO_Aux_(g-io_aux.ads)`:\n+\n+`GNAT.IO_Aux` (:file:`g-io_aux.ads`)\n+====================================\n+\n+.. index:: GNAT.IO_Aux (g-io_aux.ads)\n+\n+.. index:: Text_IO\n+\n+.. index:: Input/Output facilities\n+\n+Provides some auxiliary functions for use with Text_IO, including a test\n+for whether a file exists, and functions for reading a line of text.\n+\n+.. _`GNAT.Lock_Files_(g-locfil.ads)`:\n+\n+`GNAT.Lock_Files` (:file:`g-locfil.ads`)\n+========================================\n+\n+.. index:: GNAT.Lock_Files (g-locfil.ads)\n+\n+.. index:: File locking\n+\n+.. index:: Locking using files\n+\n+Provides a general interface for using files as locks.  Can be used for\n+providing program level synchronization.\n+\n+.. _`GNAT.MBBS_Discrete_Random_(g-mbdira.ads)`:\n+\n+`GNAT.MBBS_Discrete_Random` (:file:`g-mbdira.ads`)\n+==================================================\n+\n+.. index:: GNAT.MBBS_Discrete_Random (g-mbdira.ads)\n+\n+.. index:: Random number generation\n+\n+The original implementation of `Ada.Numerics.Discrete_Random`.  Uses\n+a modified version of the Blum-Blum-Shub generator.\n+\n+.. _`GNAT.MBBS_Float_Random_(g-mbflra.ads)`:\n+\n+`GNAT.MBBS_Float_Random` (:file:`g-mbflra.ads`)\n+===============================================\n+\n+.. index:: GNAT.MBBS_Float_Random (g-mbflra.ads)\n+\n+.. index:: Random number generation\n+\n+The original implementation of `Ada.Numerics.Float_Random`.  Uses\n+a modified version of the Blum-Blum-Shub generator.\n+\n+.. _`GNAT.MD5_(g-md5.ads)`:\n+\n+`GNAT.MD5` (:file:`g-md5.ads`)\n+==============================\n+\n+.. index:: GNAT.MD5 (g-md5.ads)\n+\n+.. index:: Message Digest MD5\n+\n+Implements the MD5 Message-Digest Algorithm as described in RFC 1321, and\n+the HMAC-MD5 message authentication function as described in RFC 2104 and\n+FIPS PUB 198.\n+\n+.. _`GNAT.Memory_Dump_(g-memdum.ads)`:\n+\n+`GNAT.Memory_Dump` (:file:`g-memdum.ads`)\n+=========================================\n+\n+.. index:: GNAT.Memory_Dump (g-memdum.ads)\n+\n+.. index:: Dump Memory\n+\n+Provides a convenient routine for dumping raw memory to either the\n+standard output or standard error files. Uses GNAT.IO for actual\n+output.\n+\n+.. _`GNAT.Most_Recent_Exception_(g-moreex.ads)`:\n+\n+`GNAT.Most_Recent_Exception` (:file:`g-moreex.ads`)\n+===================================================\n+\n+.. index:: GNAT.Most_Recent_Exception (g-moreex.ads)\n+\n+.. index:: Exception, obtaining most recent\n+\n+Provides access to the most recently raised exception.  Can be used for\n+various logging purposes, including duplicating functionality of some\n+Ada 83 implementation dependent extensions.\n+\n+.. _`GNAT.OS_Lib_(g-os_lib.ads)`:\n+\n+`GNAT.OS_Lib` (:file:`g-os_lib.ads`)\n+====================================\n+\n+.. index:: GNAT.OS_Lib (g-os_lib.ads)\n+\n+.. index:: Operating System interface\n+\n+.. index:: Spawn capability\n+\n+Provides a range of target independent operating system interface functions,\n+including time/date management, file operations, subprocess management,\n+including a portable spawn procedure, and access to environment variables\n+and error return codes.\n+\n+.. _`GNAT.Perfect_Hash_Generators_(g-pehage.ads)`:\n+\n+`GNAT.Perfect_Hash_Generators` (:file:`g-pehage.ads`)\n+=====================================================\n+\n+.. index:: GNAT.Perfect_Hash_Generators (g-pehage.ads)\n+\n+.. index:: Hash functions\n+\n+Provides a generator of static minimal perfect hash functions. No\n+collisions occur and each item can be retrieved from the table in one\n+probe (perfect property). The hash table size corresponds to the exact\n+size of the key set and no larger (minimal property). The key set has to\n+be know in advance (static property). The hash functions are also order\n+preserving. If w2 is inserted after w1 in the generator, their\n+hashcode are in the same order. These hashing functions are very\n+convenient for use with realtime applications.\n+\n+.. _`GNAT.Random_Numbers_(g-rannum.ads)`:\n+\n+`GNAT.Random_Numbers` (:file:`g-rannum.ads`)\n+============================================\n+\n+.. index:: GNAT.Random_Numbers (g-rannum.ads)\n+\n+.. index:: Random number generation\n+\n+Provides random number capabilities which extend those available in the\n+standard Ada library and are more convenient to use.\n+\n+.. _`GNAT.Regexp_(g-regexp.ads)`:\n+\n+`GNAT.Regexp` (:file:`g-regexp.ads`)\n+====================================\n+\n+.. index:: GNAT.Regexp (g-regexp.ads)\n+\n+.. index:: Regular expressions\n+\n+.. index:: Pattern matching\n+\n+A simple implementation of regular expressions, using a subset of regular\n+expression syntax copied from familiar Unix style utilities.  This is the\n+simplest of the three pattern matching packages provided, and is particularly\n+suitable for 'file globbing' applications.\n+\n+.. _`GNAT.Registry_(g-regist.ads)`:\n+\n+`GNAT.Registry` (:file:`g-regist.ads`)\n+======================================\n+\n+.. index:: GNAT.Registry (g-regist.ads)\n+\n+.. index:: Windows Registry\n+\n+This is a high level binding to the Windows registry.  It is possible to\n+do simple things like reading a key value, creating a new key.  For full\n+registry API, but at a lower level of abstraction, refer to the Win32.Winreg\n+package provided with the Win32Ada binding\n+\n+.. _`GNAT.Regpat_(g-regpat.ads)`:\n+\n+`GNAT.Regpat` (:file:`g-regpat.ads`)\n+====================================\n+\n+.. index:: GNAT.Regpat (g-regpat.ads)\n+\n+.. index:: Regular expressions\n+\n+.. index:: Pattern matching\n+\n+A complete implementation of Unix-style regular expression matching, copied\n+from the original V7 style regular expression library written in C by\n+Henry Spencer (and binary compatible with this C library).\n+\n+.. _`GNAT.Rewrite_Data_(g-rewdat.ads)`:\n+\n+`GNAT.Rewrite_Data` (:file:`g-rewdat.ads`)\n+==========================================\n+\n+.. index:: GNAT.Rewrite_Data (g-rewdat.ads)\n+\n+.. index:: Rewrite data\n+\n+A unit to rewrite on-the-fly string occurrences in a stream of\n+data. The implementation has a very minimal memory footprint as the\n+full content to be processed is not loaded into memory all at once. This makes\n+this interface usable for large files or socket streams.\n+\n+.. _`GNAT.Secondary_Stack_Info_(g-sestin.ads)`:\n+\n+`GNAT.Secondary_Stack_Info` (:file:`g-sestin.ads`)\n+==================================================\n+\n+.. index:: GNAT.Secondary_Stack_Info (g-sestin.ads)\n+\n+.. index:: Secondary Stack Info\n+\n+Provide the capability to query the high water mark of the current task's\n+secondary stack.\n+\n+.. _`GNAT.Semaphores_(g-semaph.ads)`:\n+\n+`GNAT.Semaphores` (:file:`g-semaph.ads`)\n+========================================\n+\n+.. index:: GNAT.Semaphores (g-semaph.ads)\n+\n+.. index:: Semaphores\n+\n+Provides classic counting and binary semaphores using protected types.\n+\n+.. _`GNAT.Serial_Communications_(g-sercom.ads)`:\n+\n+`GNAT.Serial_Communications` (:file:`g-sercom.ads`)\n+===================================================\n+\n+.. index:: GNAT.Serial_Communications (g-sercom.ads)\n+\n+.. index:: Serial_Communications\n+\n+Provides a simple interface to send and receive data over a serial\n+port. This is only supported on GNU/Linux and Windows.\n+\n+.. _`GNAT.SHA1_(g-sha1.ads)`:\n+\n+`GNAT.SHA1` (:file:`g-sha1.ads`)\n+================================\n+\n+.. index:: GNAT.SHA1 (g-sha1.ads)\n+\n+.. index:: Secure Hash Algorithm SHA-1\n+\n+Implements the SHA-1 Secure Hash Algorithm as described in FIPS PUB 180-3\n+and RFC 3174, and the HMAC-SHA1 message authentication function as described\n+in RFC 2104 and FIPS PUB 198.\n+\n+.. _`GNAT.SHA224_(g-sha224.ads)`:\n+\n+`GNAT.SHA224` (:file:`g-sha224.ads`)\n+====================================\n+\n+.. index:: GNAT.SHA224 (g-sha224.ads)\n+\n+.. index:: Secure Hash Algorithm SHA-224\n+\n+Implements the SHA-224 Secure Hash Algorithm as described in FIPS PUB 180-3,\n+and the HMAC-SHA224 message authentication function as described\n+in RFC 2104 and FIPS PUB 198.\n+\n+.. _`GNAT.SHA256_(g-sha256.ads)`:\n+\n+`GNAT.SHA256` (:file:`g-sha256.ads`)\n+====================================\n+\n+.. index:: GNAT.SHA256 (g-sha256.ads)\n+\n+.. index:: Secure Hash Algorithm SHA-256\n+\n+Implements the SHA-256 Secure Hash Algorithm as described in FIPS PUB 180-3,\n+and the HMAC-SHA256 message authentication function as described\n+in RFC 2104 and FIPS PUB 198.\n+\n+.. _`GNAT.SHA384_(g-sha384.ads)`:\n+\n+`GNAT.SHA384` (:file:`g-sha384.ads`)\n+====================================\n+\n+.. index:: GNAT.SHA384 (g-sha384.ads)\n+\n+.. index:: Secure Hash Algorithm SHA-384\n+\n+Implements the SHA-384 Secure Hash Algorithm as described in FIPS PUB 180-3,\n+and the HMAC-SHA384 message authentication function as described\n+in RFC 2104 and FIPS PUB 198.\n+\n+.. _`GNAT.SHA512_(g-sha512.ads)`:\n+\n+`GNAT.SHA512` (:file:`g-sha512.ads`)\n+====================================\n+\n+.. index:: GNAT.SHA512 (g-sha512.ads)\n+\n+.. index:: Secure Hash Algorithm SHA-512\n+\n+Implements the SHA-512 Secure Hash Algorithm as described in FIPS PUB 180-3,\n+and the HMAC-SHA512 message authentication function as described\n+in RFC 2104 and FIPS PUB 198.\n+\n+.. _`GNAT.Signals_(g-signal.ads)`:\n+\n+`GNAT.Signals` (:file:`g-signal.ads`)\n+=====================================\n+\n+.. index:: GNAT.Signals (g-signal.ads)\n+\n+.. index:: Signals\n+\n+Provides the ability to manipulate the blocked status of signals on supported\n+targets.\n+\n+.. _`GNAT.Sockets_(g-socket.ads)`:\n+\n+`GNAT.Sockets` (:file:`g-socket.ads`)\n+=====================================\n+\n+.. index:: GNAT.Sockets (g-socket.ads)\n+\n+.. index:: Sockets\n+\n+A high level and portable interface to develop sockets based applications.\n+This package is based on the sockets thin binding found in\n+`GNAT.Sockets.Thin`. Currently `GNAT.Sockets` is implemented\n+on all native GNAT ports and on VxWorks cross prots.  It is not implemented for\n+the LynxOS cross port.\n+\n+.. _`GNAT.Source_Info_(g-souinf.ads)`:\n+\n+`GNAT.Source_Info` (:file:`g-souinf.ads`)\n+=========================================\n+\n+.. index:: GNAT.Source_Info (g-souinf.ads)\n+\n+.. index:: Source Information\n+\n+Provides subprograms that give access to source code information known at\n+compile time, such as the current file name and line number. Also provides\n+subprograms yielding the date and time of the current compilation (like the\n+C macros `__DATE__` and `__TIME__`)\n+\n+.. _`GNAT.Spelling_Checker_(g-speche.ads)`:\n+\n+`GNAT.Spelling_Checker` (:file:`g-speche.ads`)\n+==============================================\n+\n+.. index:: GNAT.Spelling_Checker (g-speche.ads)\n+\n+.. index:: Spell checking\n+\n+Provides a function for determining whether one string is a plausible\n+near misspelling of another string.\n+\n+.. _`GNAT.Spelling_Checker_Generic_(g-spchge.ads)`:\n+\n+`GNAT.Spelling_Checker_Generic` (:file:`g-spchge.ads`)\n+======================================================\n+\n+.. index:: GNAT.Spelling_Checker_Generic (g-spchge.ads)\n+\n+.. index:: Spell checking\n+\n+Provides a generic function that can be instantiated with a string type for\n+determining whether one string is a plausible near misspelling of another\n+string.\n+\n+.. _`GNAT.Spitbol.Patterns_(g-spipat.ads)`:\n+\n+`GNAT.Spitbol.Patterns` (:file:`g-spipat.ads`)\n+==============================================\n+\n+.. index:: GNAT.Spitbol.Patterns (g-spipat.ads)\n+\n+.. index:: SPITBOL pattern matching\n+\n+.. index:: Pattern matching\n+\n+A complete implementation of SNOBOL4 style pattern matching.  This is the\n+most elaborate of the pattern matching packages provided.  It fully duplicates\n+the SNOBOL4 dynamic pattern construction and matching capabilities, using the\n+efficient algorithm developed by Robert Dewar for the SPITBOL system.\n+\n+.. _`GNAT.Spitbol_(g-spitbo.ads)`:\n+\n+`GNAT.Spitbol` (:file:`g-spitbo.ads`)\n+=====================================\n+\n+.. index:: GNAT.Spitbol (g-spitbo.ads)\n+\n+.. index:: SPITBOL interface\n+\n+The top level package of the collection of SPITBOL-style functionality, this\n+package provides basic SNOBOL4 string manipulation functions, such as\n+Pad, Reverse, Trim, Substr capability, as well as a generic table function\n+useful for constructing arbitrary mappings from strings in the style of\n+the SNOBOL4 TABLE function.\n+\n+.. _`GNAT.Spitbol.Table_Boolean_(g-sptabo.ads)`:\n+\n+`GNAT.Spitbol.Table_Boolean` (:file:`g-sptabo.ads`)\n+===================================================\n+\n+.. index:: GNAT.Spitbol.Table_Boolean (g-sptabo.ads)\n+\n+.. index:: Sets of strings\n+\n+.. index:: SPITBOL Tables\n+\n+A library level of instantiation of `GNAT.Spitbol.Patterns.Table`\n+for type `Standard.Boolean`, giving an implementation of sets of\n+string values.\n+\n+.. _`GNAT.Spitbol.Table_Integer_(g-sptain.ads)`:\n+\n+`GNAT.Spitbol.Table_Integer` (:file:`g-sptain.ads`)\n+===================================================\n+\n+.. index:: GNAT.Spitbol.Table_Integer (g-sptain.ads)\n+\n+.. index:: Integer maps\n+\n+.. index:: Maps\n+\n+.. index:: SPITBOL Tables\n+\n+A library level of instantiation of `GNAT.Spitbol.Patterns.Table`\n+for type `Standard.Integer`, giving an implementation of maps\n+from string to integer values.\n+\n+.. _`GNAT.Spitbol.Table_VString_(g-sptavs.ads)`:\n+\n+`GNAT.Spitbol.Table_VString` (:file:`g-sptavs.ads`)\n+===================================================\n+\n+.. index:: GNAT.Spitbol.Table_VString (g-sptavs.ads)\n+\n+.. index:: String maps\n+\n+.. index:: Maps\n+\n+.. index:: SPITBOL Tables\n+\n+A library level of instantiation of `GNAT.Spitbol.Patterns.Table` for\n+a variable length string type, giving an implementation of general\n+maps from strings to strings.\n+\n+.. _`GNAT.SSE_(g-sse.ads)`:\n+\n+`GNAT.SSE` (:file:`g-sse.ads`)\n+==============================\n+\n+.. index:: GNAT.SSE (g-sse.ads)\n+\n+Root of a set of units aimed at offering Ada bindings to a subset of\n+the Intel(r) Streaming SIMD Extensions with GNAT on the x86 family of\n+targets.  It exposes vector component types together with a general\n+introduction to the binding contents and use.\n+\n+.. _`GNAT.SSE.Vector_Types_(g-ssvety.ads)`:\n+\n+`GNAT.SSE.Vector_Types` (:file:`g-ssvety.ads`)\n+==============================================\n+\n+.. index:: GNAT.SSE.Vector_Types (g-ssvety.ads)\n+\n+SSE vector types for use with SSE related intrinsics.\n+\n+.. _`GNAT.Strings_(g-string.ads)`:\n+\n+`GNAT.Strings` (:file:`g-string.ads`)\n+=====================================\n+\n+.. index:: GNAT.Strings (g-string.ads)\n+\n+Common String access types and related subprograms. Basically it\n+defines a string access and an array of string access types.\n+\n+.. _`GNAT.String_Split_(g-strspl.ads)`:\n+\n+`GNAT.String_Split` (:file:`g-strspl.ads`)\n+==========================================\n+\n+.. index:: GNAT.String_Split (g-strspl.ads)\n+\n+.. index:: String splitter\n+\n+Useful string manipulation routines: given a set of separators, split\n+a string wherever the separators appear, and provide direct access\n+to the resulting slices. This package is instantiated from\n+`GNAT.Array_Split`.\n+\n+.. _`GNAT.Table_(g-table.ads)`:\n+\n+`GNAT.Table` (:file:`g-table.ads`)\n+==================================\n+\n+.. index:: GNAT.Table (g-table.ads)\n+\n+.. index:: Table implementation\n+\n+.. index:: Arrays, extendable\n+\n+A generic package providing a single dimension array abstraction where the\n+length of the array can be dynamically modified.\n+\n+This package provides a facility similar to that of `GNAT.Dynamic_Tables`,\n+except that this package declares a single instance of the table type,\n+while an instantiation of `GNAT.Dynamic_Tables` creates a type that can be\n+used to define dynamic instances of the table.\n+\n+.. _`GNAT.Task_Lock_(g-tasloc.ads)`:\n+\n+`GNAT.Task_Lock` (:file:`g-tasloc.ads`)\n+=======================================\n+\n+.. index:: GNAT.Task_Lock (g-tasloc.ads)\n+\n+.. index:: Task synchronization\n+\n+.. index:: Task locking\n+\n+.. index:: Locking\n+\n+A very simple facility for locking and unlocking sections of code using a\n+single global task lock.  Appropriate for use in situations where contention\n+between tasks is very rarely expected.\n+\n+.. _`GNAT.Time_Stamp_(g-timsta.ads)`:\n+\n+`GNAT.Time_Stamp` (:file:`g-timsta.ads`)\n+========================================\n+\n+.. index:: GNAT.Time_Stamp (g-timsta.ads)\n+\n+.. index:: Time stamp\n+\n+.. index:: Current time\n+\n+Provides a simple function that returns a string YYYY-MM-DD HH:MM:SS.SS that\n+represents the current date and time in ISO 8601 format. This is a very simple\n+routine with minimal code and there are no dependencies on any other unit.\n+\n+.. _`GNAT.Threads_(g-thread.ads)`:\n+\n+`GNAT.Threads` (:file:`g-thread.ads`)\n+=====================================\n+\n+.. index:: GNAT.Threads (g-thread.ads)\n+\n+.. index:: Foreign threads\n+\n+.. index:: Threads, foreign\n+\n+Provides facilities for dealing with foreign threads which need to be known\n+by the GNAT run-time system. Consult the documentation of this package for\n+further details if your program has threads that are created by a non-Ada\n+environment which then accesses Ada code.\n+\n+.. _`GNAT.Traceback_(g-traceb.ads)`:\n+\n+`GNAT.Traceback` (:file:`g-traceb.ads`)\n+=======================================\n+\n+.. index:: GNAT.Traceback (g-traceb.ads)\n+\n+.. index:: Trace back facilities\n+\n+Provides a facility for obtaining non-symbolic traceback information, useful\n+in various debugging situations.\n+\n+.. _`GNAT.Traceback.Symbolic_(g-trasym.ads)`:\n+\n+`GNAT.Traceback.Symbolic` (:file:`g-trasym.ads`)\n+================================================\n+\n+.. index:: GNAT.Traceback.Symbolic (g-trasym.ads)\n+\n+.. index:: Trace back facilities\n+\n+.. _`GNAT.UTF_32_(g-table.ads)`:\n+\n+`GNAT.UTF_32` (:file:`g-table.ads`)\n+===================================\n+\n+.. index:: GNAT.UTF_32 (g-table.ads)\n+\n+.. index:: Wide character codes\n+\n+This is a package intended to be used in conjunction with the\n+`Wide_Character` type in Ada 95 and the\n+`Wide_Wide_Character` type in Ada 2005 (available\n+in `GNAT` in Ada 2005 mode). This package contains\n+Unicode categorization routines, as well as lexical\n+categorization routines corresponding to the Ada 2005\n+lexical rules for identifiers and strings, and also a\n+lower case to upper case fold routine corresponding to\n+the Ada 2005 rules for identifier equivalence.\n+\n+.. _`GNAT.Wide_Spelling_Checker_(g-u3spch.ads)`:\n+\n+`GNAT.Wide_Spelling_Checker` (:file:`g-u3spch.ads`)\n+===================================================\n+\n+.. index:: GNAT.Wide_Spelling_Checker (g-u3spch.ads)\n+\n+.. index:: Spell checking\n+\n+Provides a function for determining whether one wide wide string is a plausible\n+near misspelling of another wide wide string, where the strings are represented\n+using the UTF_32_String type defined in System.Wch_Cnv.\n+\n+.. _`GNAT.Wide_Spelling_Checker_(g-wispch.ads)`:\n+\n+`GNAT.Wide_Spelling_Checker` (:file:`g-wispch.ads`)\n+===================================================\n+\n+.. index:: GNAT.Wide_Spelling_Checker (g-wispch.ads)\n+\n+.. index:: Spell checking\n+\n+Provides a function for determining whether one wide string is a plausible\n+near misspelling of another wide string.\n+\n+.. _`GNAT.Wide_String_Split_(g-wistsp.ads)`:\n+\n+`GNAT.Wide_String_Split` (:file:`g-wistsp.ads`)\n+===============================================\n+\n+.. index:: GNAT.Wide_String_Split (g-wistsp.ads)\n+\n+.. index:: Wide_String splitter\n+\n+Useful wide string manipulation routines: given a set of separators, split\n+a wide string wherever the separators appear, and provide direct access\n+to the resulting slices. This package is instantiated from\n+`GNAT.Array_Split`.\n+\n+.. _`GNAT.Wide_Wide_Spelling_Checker_(g-zspche.ads)`:\n+\n+`GNAT.Wide_Wide_Spelling_Checker` (:file:`g-zspche.ads`)\n+========================================================\n+\n+.. index:: GNAT.Wide_Wide_Spelling_Checker (g-zspche.ads)\n+\n+.. index:: Spell checking\n+\n+Provides a function for determining whether one wide wide string is a plausible\n+near misspelling of another wide wide string.\n+\n+.. _`GNAT.Wide_Wide_String_Split_(g-zistsp.ads)`:\n+\n+`GNAT.Wide_Wide_String_Split` (:file:`g-zistsp.ads`)\n+====================================================\n+\n+.. index:: GNAT.Wide_Wide_String_Split (g-zistsp.ads)\n+\n+.. index:: Wide_Wide_String splitter\n+\n+Useful wide wide string manipulation routines: given a set of separators, split\n+a wide wide string wherever the separators appear, and provide direct access\n+to the resulting slices. This package is instantiated from\n+`GNAT.Array_Split`.\n+\n+.. _`Interfaces.C.Extensions_(i-cexten.ads)`:\n+\n+`Interfaces.C.Extensions` (:file:`i-cexten.ads`)\n+================================================\n+\n+.. index:: Interfaces.C.Extensions (i-cexten.ads)\n+\n+This package contains additional C-related definitions, intended\n+for use with either manually or automatically generated bindings\n+to C libraries.\n+\n+.. _`Interfaces.C.Streams_(i-cstrea.ads)`:\n+\n+`Interfaces.C.Streams` (:file:`i-cstrea.ads`)\n+=============================================\n+\n+.. index:: Interfaces.C.Streams (i-cstrea.ads)\n+\n+.. index::  C streams, interfacing\n+\n+This package is a binding for the most commonly used operations\n+on C streams.\n+\n+.. _`Interfaces.Packed_Decimal_(i-pacdec.ads)`:\n+\n+`Interfaces.Packed_Decimal` (:file:`i-pacdec.ads`)\n+==================================================\n+\n+.. index:: Interfaces.Packed_Decimal (i-pacdec.ads)\n+\n+.. index::  IBM Packed Format\n+\n+.. index::  Packed Decimal\n+\n+This package provides a set of routines for conversions to and\n+from a packed decimal format compatible with that used on IBM\n+mainframes.\n+\n+.. _`Interfaces.VxWorks_(i-vxwork.ads)`:\n+\n+`Interfaces.VxWorks` (:file:`i-vxwork.ads`)\n+===========================================\n+\n+.. index:: Interfaces.VxWorks (i-vxwork.ads)\n+\n+.. index:: Interfacing to VxWorks\n+\n+.. index:: VxWorks, interfacing\n+\n+This package provides a limited binding to the VxWorks API.\n+In particular, it interfaces with the\n+VxWorks hardware interrupt facilities.\n+\n+.. _`Interfaces.VxWorks.IO_(i-vxwoio.ads)`:\n+\n+`Interfaces.VxWorks.IO` (:file:`i-vxwoio.ads`)\n+==============================================\n+\n+.. index:: Interfaces.VxWorks.IO (i-vxwoio.ads)\n+\n+.. index:: Interfacing to VxWorks' I/O\n+\n+.. index:: VxWorks, I/O interfacing\n+\n+.. index:: VxWorks, Get_Immediate\n+\n+.. index:: Get_Immediate, VxWorks\n+\n+This package provides a binding to the ioctl (IO/Control)\n+function of VxWorks, defining a set of option values and\n+function codes. A particular use of this package is\n+to enable the use of Get_Immediate under VxWorks.\n+\n+.. _`System.Address_Image_(s-addima.ads)`:\n+\n+`System.Address_Image` (:file:`s-addima.ads`)\n+=============================================\n+\n+.. index:: System.Address_Image (s-addima.ads)\n+\n+.. index:: Address image\n+\n+.. index:: Image, of an address\n+\n+This function provides a useful debugging\n+function that gives an (implementation dependent)\n+string which identifies an address.\n+\n+.. _`System.Assertions_(s-assert.ads)`:\n+\n+`System.Assertions` (:file:`s-assert.ads`)\n+==========================================\n+\n+.. index:: System.Assertions (s-assert.ads)\n+\n+.. index:: Assertions\n+\n+.. index:: Assert_Failure, exception\n+\n+This package provides the declaration of the exception raised\n+by an run-time assertion failure, as well as the routine that\n+is used internally to raise this assertion.\n+\n+.. _`System.Atomic_Counters_(s-atocou.ads)`:\n+\n+`System.Atomic_Counters` (:file:`s-atocou.ads`)\n+===============================================\n+\n+.. index:: System.Atomic_Counters (s-atocou.ads)\n+\n+This package provides the declaration of an atomic counter type,\n+together with efficient routines (using hardware\n+synchronization primitives) for incrementing, decrementing,\n+and testing of these counters. This package is implemented\n+on most targets, including all Alpha, ia64, PowerPC, SPARC V9,\n+x86, and x86_64 platforms.\n+\n+.. _`System.Memory_(s-memory.ads)`:\n+\n+`System.Memory` (:file:`s-memory.ads`)\n+======================================\n+\n+.. index:: System.Memory (s-memory.ads)\n+\n+.. index:: Memory allocation\n+\n+This package provides the interface to the low level routines used\n+by the generated code for allocation and freeing storage for the\n+default storage pool (analogous to the C routines malloc and free.\n+It also provides a reallocation interface analogous to the C routine\n+realloc. The body of this unit may be modified to provide alternative\n+allocation mechanisms for the default pool, and in addition, direct\n+calls to this unit may be made for low level allocation uses (for\n+example see the body of `GNAT.Tables`).\n+\n+.. _`System.Multiprocessors_(s-multip.ads)`:\n+\n+`System.Multiprocessors` (:file:`s-multip.ads`)\n+===============================================\n+\n+.. index:: System.Multiprocessors (s-multip.ads)\n+\n+.. index:: Multiprocessor interface\n+\n+This is an Ada 2012 unit defined in the Ada 2012 Reference Manual, but\n+in GNAT we also make it available in Ada 95 and Ada 2005 (where it is\n+technically an implementation-defined addition).\n+\n+.. _`System.Multiprocessors.Dispatching_Domains_(s-mudido.ads)`:\n+\n+`System.Multiprocessors.Dispatching_Domains` (:file:`s-mudido.ads`)\n+===================================================================\n+\n+.. index:: System.Multiprocessors.Dispatching_Domains (s-mudido.ads)\n+\n+.. index:: Multiprocessor interface\n+\n+This is an Ada 2012 unit defined in the Ada 2012 Reference Manual, but\n+in GNAT we also make it available in Ada 95 and Ada 2005 (where it is\n+technically an implementation-defined addition).\n+\n+.. _`System.Partition_Interface_(s-parint.ads)`:\n+\n+`System.Partition_Interface` (:file:`s-parint.ads`)\n+===================================================\n+\n+.. index:: System.Partition_Interface (s-parint.ads)\n+\n+.. index:: Partition interfacing functions\n+\n+This package provides facilities for partition interfacing.  It\n+is used primarily in a distribution context when using Annex E\n+with `GLADE`.\n+\n+.. _`System.Pool_Global_(s-pooglo.ads)`:\n+\n+`System.Pool_Global` (:file:`s-pooglo.ads`)\n+===========================================\n+\n+.. index:: System.Pool_Global (s-pooglo.ads)\n+\n+.. index:: Storage pool, global\n+\n+.. index:: Global storage pool\n+\n+This package provides a storage pool that is equivalent to the default\n+storage pool used for access types for which no pool is specifically\n+declared. It uses malloc/free to allocate/free and does not attempt to\n+do any automatic reclamation.\n+\n+.. _`System.Pool_Local_(s-pooloc.ads)`:\n+\n+`System.Pool_Local` (:file:`s-pooloc.ads`)\n+==========================================\n+\n+.. index:: System.Pool_Local (s-pooloc.ads)\n+\n+.. index:: Storage pool, local\n+\n+.. index:: Local storage pool\n+\n+This package provides a storage pool that is intended for use with locally\n+defined access types. It uses malloc/free for allocate/free, and maintains\n+a list of allocated blocks, so that all storage allocated for the pool can\n+be freed automatically when the pool is finalized.\n+\n+.. _`System.Restrictions_(s-restri.ads)`:\n+\n+`System.Restrictions` (:file:`s-restri.ads`)\n+============================================\n+\n+.. index:: System.Restrictions (s-restri.ads)\n+\n+.. index:: Run-time restrictions access\n+\n+This package provides facilities for accessing at run time\n+the status of restrictions specified at compile time for\n+the partition. Information is available both with regard\n+to actual restrictions specified, and with regard to\n+compiler determined information on which restrictions\n+are violated by one or more packages in the partition.\n+\n+.. _`System.Rident_(s-rident.ads)`:\n+\n+`System.Rident` (:file:`s-rident.ads`)\n+======================================\n+\n+.. index:: System.Rident (s-rident.ads)\n+\n+.. index:: Restrictions definitions\n+\n+This package provides definitions of the restrictions\n+identifiers supported by GNAT, and also the format of\n+the restrictions provided in package System.Restrictions.\n+It is not normally necessary to `with` this generic package\n+since the necessary instantiation is included in\n+package System.Restrictions.\n+\n+.. _`System.Strings.Stream_Ops_(s-ststop.ads)`:\n+\n+`System.Strings.Stream_Ops` (:file:`s-ststop.ads`)\n+==================================================\n+\n+.. index:: System.Strings.Stream_Ops (s-ststop.ads)\n+\n+.. index:: Stream operations\n+\n+.. index:: String stream operations\n+\n+This package provides a set of stream subprograms for standard string types.\n+It is intended primarily to support implicit use of such subprograms when\n+stream attributes are applied to string types, but the subprograms in this\n+package can be used directly by application programs.\n+\n+.. _`System.Unsigned_Types_(s-unstyp.ads)`:\n+\n+`System.Unsigned_Types` (:file:`s-unstyp.ads`)\n+==============================================\n+\n+.. index:: System.Unsigned_Types (s-unstyp.ads)\n+\n+This package contains definitions of standard unsigned types that\n+correspond in size to the standard signed types declared in Standard,\n+and (unlike the types in Interfaces) have corresponding names. It\n+also contains some related definitions for other specialized types\n+used by the compiler in connection with packed array types.\n+\n+.. _`System.Wch_Cnv_(s-wchcnv.ads)`:\n+\n+`System.Wch_Cnv` (:file:`s-wchcnv.ads`)\n+=======================================\n+\n+.. index:: System.Wch_Cnv (s-wchcnv.ads)\n+\n+.. index:: Wide Character, Representation\n+\n+.. index:: Wide String, Conversion\n+\n+.. index:: Representation of wide characters\n+\n+This package provides routines for converting between\n+wide and wide wide characters and a representation as a value of type\n+`Standard.String`, using a specified wide character\n+encoding method.  It uses definitions in\n+package `System.Wch_Con`.\n+\n+.. _`System.Wch_Con_(s-wchcon.ads)`:\n+\n+`System.Wch_Con` (:file:`s-wchcon.ads`)\n+=======================================\n+\n+.. index:: System.Wch_Con (s-wchcon.ads)\n+\n+This package provides definitions and descriptions of\n+the various methods used for encoding wide characters\n+in ordinary strings.  These definitions are used by\n+the package `System.Wch_Cnv`.\n+"}, {"sha": "3d39876c2ddea14d103ea3bc87c2b814fecb5e9b", "filename": "gcc/ada/doc/gnat_rm/the_implementation_of_standard_i_o.rst", "status": "added", "additions": 1252, "deletions": 0, "changes": 1252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fthe_implementation_of_standard_i_o.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fthe_implementation_of_standard_i_o.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fthe_implementation_of_standard_i_o.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,1252 @@\n+.. _The_Implementation_of_Standard_I/O:\n+\n+**********************************\n+The Implementation of Standard I/O\n+**********************************\n+\n+GNAT implements all the required input-output facilities described in\n+A.6 through A.14.  These sections of the Ada Reference Manual describe the\n+required behavior of these packages from the Ada point of view, and if\n+you are writing a portable Ada program that does not need to know the\n+exact manner in which Ada maps to the outside world when it comes to\n+reading or writing external files, then you do not need to read this\n+chapter.  As long as your files are all regular files (not pipes or\n+devices), and as long as you write and read the files only from Ada, the\n+description in the Ada Reference Manual is sufficient.\n+\n+However, if you want to do input-output to pipes or other devices, such\n+as the keyboard or screen, or if the files you are dealing with are\n+either generated by some other language, or to be read by some other\n+language, then you need to know more about the details of how the GNAT\n+implementation of these input-output facilities behaves.\n+\n+In this chapter we give a detailed description of exactly how GNAT\n+interfaces to the file system.  As always, the sources of the system are\n+available to you for answering questions at an even more detailed level,\n+but for most purposes the information in this chapter will suffice.\n+\n+Another reason that you may need to know more about how input-output is\n+implemented arises when you have a program written in mixed languages\n+where, for example, files are shared between the C and Ada sections of\n+the same program.  GNAT provides some additional facilities, in the form\n+of additional child library packages, that facilitate this sharing, and\n+these additional facilities are also described in this chapter.\n+\n+.. _Standard_I/O_Packages:\n+\n+Standard I/O Packages\n+=====================\n+\n+The Standard I/O packages described in Annex A for\n+\n+* \n+  Ada.Text_IO\n+* \n+  Ada.Text_IO.Complex_IO\n+* \n+  Ada.Text_IO.Text_Streams\n+* \n+  Ada.Wide_Text_IO\n+* \n+  Ada.Wide_Text_IO.Complex_IO\n+* \n+  Ada.Wide_Text_IO.Text_Streams\n+* \n+  Ada.Wide_Wide_Text_IO\n+* \n+  Ada.Wide_Wide_Text_IO.Complex_IO\n+* \n+  Ada.Wide_Wide_Text_IO.Text_Streams\n+* \n+  Ada.Stream_IO\n+* \n+  Ada.Sequential_IO\n+* \n+  Ada.Direct_IO\n+\n+are implemented using the C\n+library streams facility; where\n+\n+* \n+  All files are opened using `fopen`.\n+* \n+  All input/output operations use `fread`/`fwrite`.\n+\n+There is no internal buffering of any kind at the Ada library level. The only\n+buffering is that provided at the system level in the implementation of the\n+library routines that support streams. This facilitates shared use of these\n+streams by mixed language programs. Note though that system level buffering is\n+explicitly enabled at elaboration of the standard I/O packages and that can\n+have an impact on mixed language programs, in particular those using I/O before\n+calling the Ada elaboration routine (e.g., adainit). It is recommended to call\n+the Ada elaboration routine before performing any I/O or when impractical,\n+flush the common I/O streams and in particular Standard_Output before\n+elaborating the Ada code.\n+\n+.. _FORM_Strings:\n+\n+FORM Strings\n+============\n+\n+The format of a FORM string in GNAT is:\n+\n+\n+::\n+\n+  \"keyword=value,keyword=value,...,keyword=value\"\n+  \n+\n+where letters may be in upper or lower case, and there are no spaces\n+between values.  The order of the entries is not important.  Currently\n+the following keywords defined.\n+\n+\n+::\n+\n+  TEXT_TRANSLATION=[YES|NO|TEXT|BINARY|U8TEXT|WTEXT|U16TEXT]\n+  SHARED=[YES|NO]\n+  WCEM=[n|h|u|s|e|8|b]\n+  ENCODING=[UTF8|8BITS]\n+  \n+\n+The use of these parameters is described later in this section. If an\n+unrecognized keyword appears in a form string, it is silently ignored\n+and not considered invalid.\n+\n+.. _Direct_IO:\n+\n+Direct_IO\n+=========\n+\n+Direct_IO can only be instantiated for definite types.  This is a\n+restriction of the Ada language, which means that the records are fixed\n+length (the length being determined by ``type'Size``, rounded\n+up to the next storage unit boundary if necessary).\n+\n+The records of a Direct_IO file are simply written to the file in index\n+sequence, with the first record starting at offset zero, and subsequent\n+records following.  There is no control information of any kind.  For\n+example, if 32-bit integers are being written, each record takes\n+4-bytes, so the record at index `K` starts at offset\n+(`K`-1)*4.\n+\n+There is no limit on the size of Direct_IO files, they are expanded as\n+necessary to accommodate whatever records are written to the file.\n+\n+.. _Sequential_IO:\n+\n+Sequential_IO\n+=============\n+\n+Sequential_IO may be instantiated with either a definite (constrained)\n+or indefinite (unconstrained) type.\n+\n+For the definite type case, the elements written to the file are simply\n+the memory images of the data values with no control information of any\n+kind.  The resulting file should be read using the same type, no validity\n+checking is performed on input.\n+\n+For the indefinite type case, the elements written consist of two\n+parts.  First is the size of the data item, written as the memory image\n+of a `Interfaces.C.size_t` value, followed by the memory image of\n+the data value.  The resulting file can only be read using the same\n+(unconstrained) type.  Normal assignment checks are performed on these\n+read operations, and if these checks fail, `Data_Error` is\n+raised.  In particular, in the array case, the lengths must match, and in\n+the variant record case, if the variable for a particular read operation\n+is constrained, the discriminants must match.\n+\n+Note that it is not possible to use Sequential_IO to write variable\n+length array items, and then read the data back into different length\n+arrays.  For example, the following will raise `Data_Error`:\n+\n+\n+.. code-block:: ada\n+\n+   package IO is new Sequential_IO (String);\n+   F : IO.File_Type;\n+   S : String (1..4);\n+   ...\n+   IO.Create (F)\n+   IO.Write (F, \"hello!\")\n+   IO.Reset (F, Mode=>In_File);\n+   IO.Read (F, S);\n+   Put_Line (S);\n+\n+  \n+\n+On some Ada implementations, this will print `hell`, but the program is\n+clearly incorrect, since there is only one element in the file, and that\n+element is the string `hello!`.\n+\n+In Ada 95 and Ada 2005, this kind of behavior can be legitimately achieved\n+using Stream_IO, and this is the preferred mechanism.  In particular, the\n+above program fragment rewritten to use Stream_IO will work correctly.\n+\n+.. _Text_IO:\n+\n+Text_IO\n+=======\n+\n+Text_IO files consist of a stream of characters containing the following\n+special control characters:\n+\n+\n+::\n+\n+  LF (line feed, 16#0A#) Line Mark\n+  FF (form feed, 16#0C#) Page Mark\n+  \n+\n+A canonical Text_IO file is defined as one in which the following\n+conditions are met:\n+\n+* \n+  The character `LF` is used only as a line mark, i.e., to mark the end\n+  of the line.\n+\n+* \n+  The character `FF` is used only as a page mark, i.e., to mark the\n+  end of a page and consequently can appear only immediately following a\n+  `LF` (line mark) character.\n+\n+* \n+  The file ends with either `LF` (line mark) or `LF`-`FF`\n+  (line mark, page mark).  In the former case, the page mark is implicitly\n+  assumed to be present.\n+\n+A file written using Text_IO will be in canonical form provided that no\n+explicit `LF` or `FF` characters are written using `Put`\n+or `Put_Line`.  There will be no `FF` character at the end of\n+the file unless an explicit `New_Page` operation was performed\n+before closing the file.\n+\n+A canonical Text_IO file that is a regular file (i.e., not a device or a\n+pipe) can be read using any of the routines in Text_IO.  The\n+semantics in this case will be exactly as defined in the Ada Reference\n+Manual, and all the routines in Text_IO are fully implemented.\n+\n+A text file that does not meet the requirements for a canonical Text_IO\n+file has one of the following:\n+\n+* \n+  The file contains `FF` characters not immediately following a\n+  `LF` character.\n+\n+* \n+  The file contains `LF` or `FF` characters written by\n+  `Put` or `Put_Line`, which are not logically considered to be\n+  line marks or page marks.\n+\n+* \n+  The file ends in a character other than `LF` or `FF`,\n+  i.e., there is no explicit line mark or page mark at the end of the file.\n+\n+Text_IO can be used to read such non-standard text files but subprograms\n+to do with line or page numbers do not have defined meanings.  In\n+particular, a `FF` character that does not follow a `LF`\n+character may or may not be treated as a page mark from the point of\n+view of page and line numbering.  Every `LF` character is considered\n+to end a line, and there is an implied `LF` character at the end of\n+the file.\n+\n+.. _Stream_Pointer_Positioning:\n+\n+Stream Pointer Positioning\n+--------------------------\n+\n+`Ada.Text_IO` has a definition of current position for a file that\n+is being read.  No internal buffering occurs in Text_IO, and usually the\n+physical position in the stream used to implement the file corresponds\n+to this logical position defined by Text_IO.  There are two exceptions:\n+\n+* \n+  After a call to `End_Of_Page` that returns `True`, the stream\n+  is positioned past the `LF` (line mark) that precedes the page\n+  mark.  Text_IO maintains an internal flag so that subsequent read\n+  operations properly handle the logical position which is unchanged by\n+  the `End_Of_Page` call.\n+\n+* \n+  After a call to `End_Of_File` that returns `True`, if the\n+  Text_IO file was positioned before the line mark at the end of file\n+  before the call, then the logical position is unchanged, but the stream\n+  is physically positioned right at the end of file (past the line mark,\n+  and past a possible page mark following the line mark.  Again Text_IO\n+  maintains internal flags so that subsequent read operations properly\n+  handle the logical position.\n+\n+These discrepancies have no effect on the observable behavior of\n+Text_IO, but if a single Ada stream is shared between a C program and\n+Ada program, or shared (using ``shared=yes`` in the form string)\n+between two Ada files, then the difference may be observable in some\n+situations.\n+\n+.. _Reading_and_Writing_Non-Regular_Files:\n+\n+Reading and Writing Non-Regular Files\n+-------------------------------------\n+\n+A non-regular file is a device (such as a keyboard), or a pipe.  Text_IO\n+can be used for reading and writing.  Writing is not affected and the\n+sequence of characters output is identical to the normal file case, but\n+for reading, the behavior of Text_IO is modified to avoid undesirable\n+look-ahead as follows:\n+\n+An input file that is not a regular file is considered to have no page\n+marks.  Any `Ascii.FF` characters (the character normally used for a\n+page mark) appearing in the file are considered to be data\n+characters.  In particular:\n+\n+* \n+  `Get_Line` and `Skip_Line` do not test for a page mark\n+  following a line mark.  If a page mark appears, it will be treated as a\n+  data character.\n+\n+* \n+  This avoids the need to wait for an extra character to be typed or\n+  entered from the pipe to complete one of these operations.\n+\n+* \n+  `End_Of_Page` always returns `False`\n+\n+* \n+  `End_Of_File` will return `False` if there is a page mark at\n+  the end of the file.\n+\n+Output to non-regular files is the same as for regular files.  Page marks\n+may be written to non-regular files using `New_Page`, but as noted\n+above they will not be treated as page marks on input if the output is\n+piped to another Ada program.\n+\n+Another important discrepancy when reading non-regular files is that the end\n+of file indication is not 'sticky'.  If an end of file is entered, e.g., by\n+pressing the :kbd:`EOT` key,\n+then end of file\n+is signaled once (i.e., the test `End_Of_File`\n+will yield `True`, or a read will\n+raise `End_Error`), but then reading can resume\n+to read data past that end of\n+file indication, until another end of file indication is entered.\n+\n+.. _Get_Immediate:\n+\n+Get_Immediate\n+-------------\n+\n+.. index:: Get_Immediate\n+\n+Get_Immediate returns the next character (including control characters)\n+from the input file.  In particular, Get_Immediate will return LF or FF\n+characters used as line marks or page marks.  Such operations leave the\n+file positioned past the control character, and it is thus not treated\n+as having its normal function.  This means that page, line and column\n+counts after this kind of Get_Immediate call are set as though the mark\n+did not occur.  In the case where a Get_Immediate leaves the file\n+positioned between the line mark and page mark (which is not normally\n+possible), it is undefined whether the FF character will be treated as a\n+page mark.\n+\n+.. _Treating_Text_IO_Files_as_Streams:\n+\n+Treating Text_IO Files as Streams\n+---------------------------------\n+\n+.. index:: Stream files\n+\n+The package `Text_IO.Streams` allows a Text_IO file to be treated\n+as a stream.  Data written to a Text_IO file in this stream mode is\n+binary data.  If this binary data contains bytes 16#0A# (`LF`) or\n+16#0C# (`FF`), the resulting file may have non-standard\n+format.  Similarly if read operations are used to read from a Text_IO\n+file treated as a stream, then `LF` and `FF` characters may be\n+skipped and the effect is similar to that described above for\n+`Get_Immediate`.\n+\n+.. _Text_IO_Extensions:\n+\n+Text_IO Extensions\n+------------------\n+\n+.. index:: Text_IO extensions\n+\n+A package GNAT.IO_Aux in the GNAT library provides some useful extensions\n+to the standard `Text_IO` package:\n+\n+* function File_Exists (Name : String) return Boolean;\n+  Determines if a file of the given name exists.\n+\n+* function Get_Line return String;\n+  Reads a string from the standard input file.  The value returned is exactly\n+  the length of the line that was read.\n+\n+* function Get_Line (File : Ada.Text_IO.File_Type) return String;\n+  Similar, except that the parameter File specifies the file from which\n+  the string is to be read.\n+\n+\n+.. _Text_IO_Facilities_for_Unbounded_Strings:\n+\n+Text_IO Facilities for Unbounded Strings\n+----------------------------------------\n+\n+.. index:: Text_IO for unbounded strings\n+\n+.. index:: Unbounded_String, Text_IO operations\n+\n+The package `Ada.Strings.Unbounded.Text_IO`\n+in library files `a-suteio.ads/adb` contains some GNAT-specific\n+subprograms useful for Text_IO operations on unbounded strings:\n+\n+\n+* function Get_Line (File : File_Type) return Unbounded_String;\n+  Reads a line from the specified file\n+  and returns the result as an unbounded string.\n+\n+* procedure Put (File : File_Type; U : Unbounded_String);\n+  Writes the value of the given unbounded string to the specified file\n+  Similar to the effect of\n+  `Put (To_String (U))` except that an extra copy is avoided.\n+\n+* procedure Put_Line (File : File_Type; U : Unbounded_String);\n+  Writes the value of the given unbounded string to the specified file,\n+  followed by a `New_Line`.\n+  Similar to the effect of `Put_Line (To_String (U))` except\n+  that an extra copy is avoided.\n+\n+In the above procedures, `File` is of type `Ada.Text_IO.File_Type`\n+and is optional.  If the parameter is omitted, then the standard input or\n+output file is referenced as appropriate.\n+\n+The package `Ada.Strings.Wide_Unbounded.Wide_Text_IO` in library\n+files :file:`a-swuwti.ads` and :file:`a-swuwti.adb` provides similar extended\n+`Wide_Text_IO` functionality for unbounded wide strings.\n+\n+The package `Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO` in library\n+files :file:`a-szuzti.ads` and :file:`a-szuzti.adb` provides similar extended\n+`Wide_Wide_Text_IO` functionality for unbounded wide wide strings.\n+\n+.. _Wide_Text_IO:\n+\n+Wide_Text_IO\n+============\n+\n+`Wide_Text_IO` is similar in most respects to Text_IO, except that\n+both input and output files may contain special sequences that represent\n+wide character values.  The encoding scheme for a given file may be\n+specified using a FORM parameter:\n+\n+\n+::\n+\n+  WCEM=`x`\n+  \n+\n+as part of the FORM string (WCEM = wide character encoding method),\n+where `x` is one of the following characters\n+\n+========== ====================\n+Character  Encoding\n+========== ====================\n+*h*        Hex ESC encoding\n+*u*        Upper half encoding\n+*s*        Shift-JIS encoding\n+*e*        EUC Encoding\n+*8*        UTF-8 encoding\n+*b*        Brackets encoding\n+========== ====================\n+\n+The encoding methods match those that\n+can be used in a source\n+program, but there is no requirement that the encoding method used for\n+the source program be the same as the encoding method used for files,\n+and different files may use different encoding methods.\n+\n+The default encoding method for the standard files, and for opened files\n+for which no WCEM parameter is given in the FORM string matches the\n+wide character encoding specified for the main program (the default\n+being brackets encoding if no coding method was specified with -gnatW).\n+\n+\n+\n+*Hex Coding*\n+  In this encoding, a wide character is represented by a five character\n+  sequence:\n+\n+\n+::\n+\n+    ESC a b c d\n+    \n+..\n+\n+  where `a`, `b`, `c`, `d` are the four hexadecimal\n+  characters (using upper case letters) of the wide character code.  For\n+  example, ESC A345 is used to represent the wide character with code\n+  16#A345#.  This scheme is compatible with use of the full\n+  `Wide_Character` set.\n+\n+\n+*Upper Half Coding*\n+  The wide character with encoding 16#abcd#, where the upper bit is on\n+  (i.e., a is in the range 8-F) is represented as two bytes 16#ab# and\n+  16#cd#.  The second byte may never be a format control character, but is\n+  not required to be in the upper half.  This method can be also used for\n+  shift-JIS or EUC where the internal coding matches the external coding.\n+\n+\n+*Shift JIS Coding*\n+  A wide character is represented by a two character sequence 16#ab# and\n+  16#cd#, with the restrictions described for upper half encoding as\n+  described above.  The internal character code is the corresponding JIS\n+  character according to the standard algorithm for Shift-JIS\n+  conversion.  Only characters defined in the JIS code set table can be\n+  used with this encoding method.\n+\n+\n+*EUC Coding*\n+  A wide character is represented by a two character sequence 16#ab# and\n+  16#cd#, with both characters being in the upper half.  The internal\n+  character code is the corresponding JIS character according to the EUC\n+  encoding algorithm.  Only characters defined in the JIS code set table\n+  can be used with this encoding method.\n+\n+\n+*UTF-8 Coding*\n+  A wide character is represented using\n+  UCS Transformation Format 8 (UTF-8) as defined in Annex R of ISO\n+  10646-1/Am.2.  Depending on the character value, the representation\n+  is a one, two, or three byte sequence:\n+\n+\n+::\n+\n+    16#0000#-16#007f#: 2#0xxxxxxx#\n+    16#0080#-16#07ff#: 2#110xxxxx# 2#10xxxxxx#\n+    16#0800#-16#ffff#: 2#1110xxxx# 2#10xxxxxx# 2#10xxxxxx#\n+    \n+..\n+\n+  where the `xxx` bits correspond to the left-padded bits of the\n+  16-bit character value.  Note that all lower half ASCII characters\n+  are represented as ASCII bytes and all upper half characters and\n+  other wide characters are represented as sequences of upper-half\n+  (The full UTF-8 scheme allows for encoding 31-bit characters as\n+  6-byte sequences, but in this implementation, all UTF-8 sequences\n+  of four or more bytes length will raise a Constraint_Error, as\n+  will all invalid UTF-8 sequences.)\n+\n+\n+*Brackets Coding*\n+  In this encoding, a wide character is represented by the following eight\n+  character sequence:\n+\n+\n+::\n+\n+    [ \" a b c d \" ]\n+    \n+..\n+\n+  where `a`, `b`, `c`, `d` are the four hexadecimal\n+  characters (using uppercase letters) of the wide character code.  For\n+  example, `[\"A345\"]` is used to represent the wide character with code\n+  `16#A345#`.\n+  This scheme is compatible with use of the full Wide_Character set.\n+  On input, brackets coding can also be used for upper half characters,\n+  e.g., `[\"C1\"]` for lower case a.  However, on output, brackets notation\n+  is only used for wide characters with a code greater than `16#FF#`.\n+\n+  Note that brackets coding is not normally used in the context of\n+  Wide_Text_IO or Wide_Wide_Text_IO, since it is really just designed as\n+  a portable way of encoding source files. In the context of Wide_Text_IO\n+  or Wide_Wide_Text_IO, it can only be used if the file does not contain\n+  any instance of the left bracket character other than to encode wide\n+  character values using the brackets encoding method. In practice it is\n+  expected that some standard wide character encoding method such\n+  as UTF-8 will be used for text input output.\n+\n+  If brackets notation is used, then any occurrence of a left bracket\n+  in the input file which is not the start of a valid wide character\n+  sequence will cause Constraint_Error to be raised. It is possible to\n+  encode a left bracket as [\"5B\"] and Wide_Text_IO and Wide_Wide_Text_IO\n+  input will interpret this as a left bracket.\n+\n+  However, when a left bracket is output, it will be output as a left bracket\n+  and not as [\"5B\"]. We make this decision because for normal use of\n+  Wide_Text_IO for outputting messages, it is unpleasant to clobber left\n+  brackets. For example, if we write:\n+\n+\n+  .. code-block:: ada\n+\n+       Put_Line (\"Start of output [first run]\");\n+\n+\n+  we really do not want to have the left bracket in this message clobbered so\n+  that the output reads:\n+\n+\n+::\n+\n+       Start of output [\"5B\"]first run]\n+    \n+..\n+\n+  In practice brackets encoding is reasonably useful for normal Put_Line use\n+  since we won't get confused between left brackets and wide character\n+  sequences in the output. But for input, or when files are written out\n+  and read back in, it really makes better sense to use one of the standard\n+  encoding methods such as UTF-8.\n+\n+\n+For the coding schemes other than UTF-8, Hex, or Brackets encoding,\n+not all wide character\n+values can be represented.  An attempt to output a character that cannot\n+be represented using the encoding scheme for the file causes\n+Constraint_Error to be raised.  An invalid wide character sequence on\n+input also causes Constraint_Error to be raised.\n+\n+.. _Stream_Pointer_Positioning_1:\n+\n+Stream Pointer Positioning\n+--------------------------\n+\n+`Ada.Wide_Text_IO` is similar to `Ada.Text_IO` in its handling\n+of stream pointer positioning (:ref:`Text_IO`).  There is one additional\n+case:\n+\n+If `Ada.Wide_Text_IO.Look_Ahead` reads a character outside the\n+normal lower ASCII set (i.e., a character in the range:\n+\n+\n+.. code-block:: ada\n+\n+  Wide_Character'Val (16#0080#) .. Wide_Character'Val (16#FFFF#)\n+  \n+\n+then although the logical position of the file pointer is unchanged by\n+the `Look_Ahead` call, the stream is physically positioned past the\n+wide character sequence.  Again this is to avoid the need for buffering\n+or backup, and all `Wide_Text_IO` routines check the internal\n+indication that this situation has occurred so that this is not visible\n+to a normal program using `Wide_Text_IO`.  However, this discrepancy\n+can be observed if the wide text file shares a stream with another file.\n+\n+.. _Reading_and_Writing_Non-Regular_Files_1:\n+\n+Reading and Writing Non-Regular Files\n+-------------------------------------\n+\n+As in the case of Text_IO, when a non-regular file is read, it is\n+assumed that the file contains no page marks (any form characters are\n+treated as data characters), and `End_Of_Page` always returns\n+`False`.  Similarly, the end of file indication is not sticky, so\n+it is possible to read beyond an end of file.\n+\n+.. _Wide_Wide_Text_IO:\n+\n+Wide_Wide_Text_IO\n+=================\n+\n+`Wide_Wide_Text_IO` is similar in most respects to Text_IO, except that\n+both input and output files may contain special sequences that represent\n+wide wide character values.  The encoding scheme for a given file may be\n+specified using a FORM parameter:\n+\n+\n+::\n+\n+  WCEM=`x`\n+  \n+\n+as part of the FORM string (WCEM = wide character encoding method),\n+where `x` is one of the following characters\n+\n+========== ====================\n+Character  Encoding\n+========== ====================\n+*h*        Hex ESC encoding\n+*u*        Upper half encoding\n+*s*        Shift-JIS encoding\n+*e*        EUC Encoding\n+*8*        UTF-8 encoding\n+*b*        Brackets encoding\n+========== ====================\n+\n+\n+The encoding methods match those that\n+can be used in a source\n+program, but there is no requirement that the encoding method used for\n+the source program be the same as the encoding method used for files,\n+and different files may use different encoding methods.\n+\n+The default encoding method for the standard files, and for opened files\n+for which no WCEM parameter is given in the FORM string matches the\n+wide character encoding specified for the main program (the default\n+being brackets encoding if no coding method was specified with -gnatW).\n+\n+\n+\n+*UTF-8 Coding*\n+  A wide character is represented using\n+  UCS Transformation Format 8 (UTF-8) as defined in Annex R of ISO\n+  10646-1/Am.2.  Depending on the character value, the representation\n+  is a one, two, three, or four byte sequence:\n+\n+\n+::\n+\n+    16#000000#-16#00007f#: 2#0xxxxxxx#\n+    16#000080#-16#0007ff#: 2#110xxxxx# 2#10xxxxxx#\n+    16#000800#-16#00ffff#: 2#1110xxxx# 2#10xxxxxx# 2#10xxxxxx#\n+    16#010000#-16#10ffff#: 2#11110xxx# 2#10xxxxxx# 2#10xxxxxx# 2#10xxxxxx#\n+    \n+..\n+\n+  where the `xxx` bits correspond to the left-padded bits of the\n+  21-bit character value.  Note that all lower half ASCII characters\n+  are represented as ASCII bytes and all upper half characters and\n+  other wide characters are represented as sequences of upper-half\n+  characters.\n+\n+\n+*Brackets Coding*\n+  In this encoding, a wide wide character is represented by the following eight\n+  character sequence if is in wide character range\n+\n+\n+::\n+\n+    [ \" a b c d \" ]\n+    \n+..\n+\n+  and by the following ten character sequence if not\n+\n+\n+::\n+\n+    [ \" a b c d e f \" ]\n+    \n+..\n+\n+  where `a`, `b`, `c`, `d`, `e`, and `f`\n+  are the four or six hexadecimal\n+  characters (using uppercase letters) of the wide wide character code.  For\n+  example, `[\"01A345\"]` is used to represent the wide wide character\n+  with code `16#01A345#`.\n+\n+  This scheme is compatible with use of the full Wide_Wide_Character set.\n+  On input, brackets coding can also be used for upper half characters,\n+  e.g., `[\"C1\"]` for lower case a.  However, on output, brackets notation\n+  is only used for wide characters with a code greater than `16#FF#`.\n+\n+\n+If is also possible to use the other Wide_Character encoding methods,\n+such as Shift-JIS, but the other schemes cannot support the full range\n+of wide wide characters.\n+An attempt to output a character that cannot\n+be represented using the encoding scheme for the file causes\n+Constraint_Error to be raised.  An invalid wide character sequence on\n+input also causes Constraint_Error to be raised.\n+\n+.. _Stream_Pointer_Positioning_2:\n+\n+Stream Pointer Positioning\n+--------------------------\n+\n+`Ada.Wide_Wide_Text_IO` is similar to `Ada.Text_IO` in its handling\n+of stream pointer positioning (:ref:`Text_IO`).  There is one additional\n+case:\n+\n+If `Ada.Wide_Wide_Text_IO.Look_Ahead` reads a character outside the\n+normal lower ASCII set (i.e., a character in the range:\n+\n+\n+.. code-block:: ada\n+\n+  Wide_Wide_Character'Val (16#0080#) .. Wide_Wide_Character'Val (16#10FFFF#)\n+  \n+\n+then although the logical position of the file pointer is unchanged by\n+the `Look_Ahead` call, the stream is physically positioned past the\n+wide character sequence.  Again this is to avoid the need for buffering\n+or backup, and all `Wide_Wide_Text_IO` routines check the internal\n+indication that this situation has occurred so that this is not visible\n+to a normal program using `Wide_Wide_Text_IO`.  However, this discrepancy\n+can be observed if the wide text file shares a stream with another file.\n+\n+.. _Reading_and_Writing_Non-Regular_Files_2:\n+\n+Reading and Writing Non-Regular Files\n+-------------------------------------\n+\n+As in the case of Text_IO, when a non-regular file is read, it is\n+assumed that the file contains no page marks (any form characters are\n+treated as data characters), and `End_Of_Page` always returns\n+`False`.  Similarly, the end of file indication is not sticky, so\n+it is possible to read beyond an end of file.\n+\n+.. _Stream_IO:\n+\n+Stream_IO\n+=========\n+\n+A stream file is a sequence of bytes, where individual elements are\n+written to the file as described in the Ada Reference Manual.  The type\n+`Stream_Element` is simply a byte.  There are two ways to read or\n+write a stream file.\n+\n+* \n+  The operations `Read` and `Write` directly read or write a\n+  sequence of stream elements with no control information.\n+\n+* \n+  The stream attributes applied to a stream file transfer data in the\n+  manner described for stream attributes.\n+\n+.. _Text_Translation:\n+\n+Text Translation\n+================\n+\n+``Text_Translation=xxx`` may be used as the Form parameter\n+passed to Text_IO.Create and Text_IO.Open. ``Text_Translation=xxx``\n+has no effect on Unix systems. Possible values are:\n+\n+\n+* \n+  ``Yes`` or ``Text`` is the default, which means to\n+  translate LF to/from CR/LF on Windows systems.\n+\n+  ``No`` disables this translation; i.e. it\n+  uses binary mode. For output files, ``Text_Translation=No``\n+  may be used to create Unix-style files on\n+  Windows.\n+\n+* \n+  ``wtext`` translation enabled in Unicode mode.\n+  (corresponds to _O_WTEXT).\n+\n+* \n+  ``u8text`` translation enabled in Unicode UTF-8 mode.\n+  (corresponds to O_U8TEXT).\n+\n+* \n+  ``u16text`` translation enabled in Unicode UTF-16\n+  mode. (corresponds to_O_U16TEXT).\n+\n+\n+.. _Shared_Files:\n+\n+Shared Files\n+============\n+\n+Section A.14 of the Ada Reference Manual allows implementations to\n+provide a wide variety of behavior if an attempt is made to access the\n+same external file with two or more internal files.\n+\n+To provide a full range of functionality, while at the same time\n+minimizing the problems of portability caused by this implementation\n+dependence, GNAT handles file sharing as follows:\n+\n+* \n+  In the absence of a ``shared=xxx`` form parameter, an attempt\n+  to open two or more files with the same full name is considered an error\n+  and is not supported.  The exception `Use_Error` will be\n+  raised.  Note that a file that is not explicitly closed by the program\n+  remains open until the program terminates.\n+\n+* \n+  If the form parameter ``shared=no`` appears in the form string, the\n+  file can be opened or created with its own separate stream identifier,\n+  regardless of whether other files sharing the same external file are\n+  opened.  The exact effect depends on how the C stream routines handle\n+  multiple accesses to the same external files using separate streams.\n+\n+* \n+  If the form parameter ``shared=yes`` appears in the form string for\n+  each of two or more files opened using the same full name, the same\n+  stream is shared between these files, and the semantics are as described\n+  in Ada Reference Manual, Section A.14.\n+\n+When a program that opens multiple files with the same name is ported\n+from another Ada compiler to GNAT, the effect will be that\n+`Use_Error` is raised.\n+\n+The documentation of the original compiler and the documentation of the\n+program should then be examined to determine if file sharing was\n+expected, and ``shared=xxx`` parameters added to `Open`\n+and `Create` calls as required.\n+\n+When a program is ported from GNAT to some other Ada compiler, no\n+special attention is required unless the ``shared=xxx`` form\n+parameter is used in the program.  In this case, you must examine the\n+documentation of the new compiler to see if it supports the required\n+file sharing semantics, and form strings modified appropriately.  Of\n+course it may be the case that the program cannot be ported if the\n+target compiler does not support the required functionality.  The best\n+approach in writing portable code is to avoid file sharing (and hence\n+the use of the ``shared=xxx`` parameter in the form string)\n+completely.\n+\n+One common use of file sharing in Ada 83 is the use of instantiations of\n+Sequential_IO on the same file with different types, to achieve\n+heterogeneous input-output.  Although this approach will work in GNAT if\n+``shared=yes`` is specified, it is preferable in Ada to use Stream_IO\n+for this purpose (using the stream attributes)\n+\n+.. _Filenames_encoding:\n+\n+Filenames encoding\n+==================\n+\n+An encoding form parameter can be used to specify the filename\n+encoding ``encoding=xxx``.\n+\n+* \n+  If the form parameter ``encoding=utf8`` appears in the form string, the\n+  filename must be encoded in UTF-8.\n+\n+* \n+  If the form parameter ``encoding=8bits`` appears in the form\n+  string, the filename must be a standard 8bits string.\n+\n+In the absence of a ``encoding=xxx`` form parameter, the\n+encoding is controlled by the ``GNAT_CODE_PAGE`` environment\n+variable. And if not set ``utf8`` is assumed.\n+\n+\n+\n+*CP_ACP*\n+  The current system Windows ANSI code page.\n+\n+*CP_UTF8*\n+  UTF-8 encoding\n+\n+This encoding form parameter is only supported on the Windows\n+platform. On the other Operating Systems the run-time is supporting\n+UTF-8 natively.\n+\n+.. _File_content_encoding:\n+\n+File content encoding\n+=====================\n+\n+For text files it is possible to specify the encoding to use. This is\n+controlled by the by the ``GNAT_CCS_ENCODING`` environment\n+variable. And if not set ``TEXT`` is assumed.\n+\n+The possible values are those supported on Windows:\n+\n+\n+\n+*TEXT*\n+  Translated text mode\n+\n+*WTEXT*\n+  Translated unicode encoding\n+\n+*U16TEXT*\n+  Unicode 16-bit encoding\n+\n+*U8TEXT*\n+  Unicode 8-bit encoding\n+\n+This encoding is only supported on the Windows platform.\n+\n+.. _Open_Modes:\n+\n+Open Modes\n+==========\n+\n+`Open` and `Create` calls result in a call to `fopen`\n+using the mode shown in the following table:\n+\n++----------------------------+---------------+------------------+\n+|           `Open` and `Create` Call Modes                      |\n++----------------------------+---------------+------------------+\n+|                            |   **OPEN**    |     **CREATE**   |\n++============================+===============+==================+\n+| Append_File                |   \"r+\"        |    \"w+\"          |\n++----------------------------+---------------+------------------+\n+| In_File                    |   \"r\"         |    \"w+\"          |\n++----------------------------+---------------+------------------+\n+| Out_File (Direct_IO)       |   \"r+\"        |    \"w\"           |\n++----------------------------+---------------+------------------+\n+| Out_File (all other cases) |   \"w\"         |    \"w\"           |\n++----------------------------+---------------+------------------+\n+| Inout_File                 |   \"r+\"        |    \"w+\"          |\n++----------------------------+---------------+------------------+\n+  \n+\n+If text file translation is required, then either ``b`` or ``t``\n+is added to the mode, depending on the setting of Text.  Text file\n+translation refers to the mapping of CR/LF sequences in an external file\n+to LF characters internally.  This mapping only occurs in DOS and\n+DOS-like systems, and is not relevant to other systems.\n+\n+A special case occurs with Stream_IO.  As shown in the above table, the\n+file is initially opened in ``r`` or ``w`` mode for the\n+`In_File` and `Out_File` cases.  If a `Set_Mode` operation\n+subsequently requires switching from reading to writing or vice-versa,\n+then the file is reopened in ``r+`` mode to permit the required operation.\n+\n+.. _Operations_on_C_Streams:\n+\n+Operations on C Streams\n+=======================\n+\n+The package `Interfaces.C_Streams` provides an Ada program with direct\n+access to the C library functions for operations on C streams:\n+\n+\n+.. code-block:: ada\n+\n+  package Interfaces.C_Streams is\n+    -- Note: the reason we do not use the types that are in\n+    -- Interfaces.C is that we want to avoid dragging in the\n+    -- code in this unit if possible.\n+    subtype chars is System.Address;\n+    -- Pointer to null-terminated array of characters\n+    subtype FILEs is System.Address;\n+    -- Corresponds to the C type FILE*\n+    subtype voids is System.Address;\n+    -- Corresponds to the C type void*\n+    subtype int is Integer;\n+    subtype long is Long_Integer;\n+    -- Note: the above types are subtypes deliberately, and it\n+    -- is part of this spec that the above correspondences are\n+    -- guaranteed.  This means that it is legitimate to, for\n+    -- example, use Integer instead of int.  We provide these\n+    -- synonyms for clarity, but in some cases it may be\n+    -- convenient to use the underlying types (for example to\n+    -- avoid an unnecessary dependency of a spec on the spec\n+    -- of this unit).\n+    type size_t is mod 2 ** Standard'Address_Size;\n+    NULL_Stream : constant FILEs;\n+    -- Value returned (NULL in C) to indicate an\n+    -- fdopen/fopen/tmpfile error\n+    ----------------------------------\n+    -- Constants Defined in stdio.h --\n+    ----------------------------------\n+    EOF : constant int;\n+    -- Used by a number of routines to indicate error or\n+    -- end of file\n+    IOFBF : constant int;\n+    IOLBF : constant int;\n+    IONBF : constant int;\n+    -- Used to indicate buffering mode for setvbuf call\n+    SEEK_CUR : constant int;\n+    SEEK_END : constant int;\n+    SEEK_SET : constant int;\n+    -- Used to indicate origin for fseek call\n+    function stdin return FILEs;\n+    function stdout return FILEs;\n+    function stderr return FILEs;\n+    -- Streams associated with standard files\n+    --------------------------\n+    -- Standard C functions --\n+    --------------------------\n+    -- The functions selected below are ones that are\n+    -- available in UNIX (but not necessarily in ANSI C).\n+    -- These are very thin interfaces\n+    -- which copy exactly the C headers.  For more\n+    -- documentation on these functions, see the Microsoft C\n+    -- \"Run-Time Library Reference\" (Microsoft Press, 1990,\n+    -- ISBN 1-55615-225-6), which includes useful information\n+    -- on system compatibility.\n+    procedure clearerr (stream : FILEs);\n+    function fclose (stream : FILEs) return int;\n+    function fdopen (handle : int; mode : chars) return FILEs;\n+    function feof (stream : FILEs) return int;\n+    function ferror (stream : FILEs) return int;\n+    function fflush (stream : FILEs) return int;\n+    function fgetc (stream : FILEs) return int;\n+    function fgets (strng : chars; n : int; stream : FILEs)\n+        return chars;\n+    function fileno (stream : FILEs) return int;\n+    function fopen (filename : chars; Mode : chars)\n+        return FILEs;\n+    -- Note: to maintain target independence, use\n+    -- text_translation_required, a boolean variable defined in\n+    -- a-sysdep.c to deal with the target dependent text\n+    -- translation requirement.  If this variable is set,\n+    -- then  b/t should be appended to the standard mode\n+    -- argument to set the text translation mode off or on\n+    -- as required.\n+    function fputc (C : int; stream : FILEs) return int;\n+    function fputs (Strng : chars; Stream : FILEs) return int;\n+    function fread\n+       (buffer : voids;\n+        size : size_t;\n+        count : size_t;\n+        stream : FILEs)\n+        return size_t;\n+    function freopen\n+       (filename : chars;\n+        mode : chars;\n+        stream : FILEs)\n+        return FILEs;\n+    function fseek\n+       (stream : FILEs;\n+        offset : long;\n+        origin : int)\n+        return int;\n+    function ftell (stream : FILEs) return long;\n+    function fwrite\n+       (buffer : voids;\n+        size : size_t;\n+        count : size_t;\n+        stream : FILEs)\n+        return size_t;\n+    function isatty (handle : int) return int;\n+    procedure mktemp (template : chars);\n+    -- The return value (which is just a pointer to template)\n+    -- is discarded\n+    procedure rewind (stream : FILEs);\n+    function rmtmp return int;\n+    function setvbuf\n+       (stream : FILEs;\n+        buffer : chars;\n+        mode : int;\n+        size : size_t)\n+        return int;\n+\n+    function tmpfile return FILEs;\n+    function ungetc (c : int; stream : FILEs) return int;\n+    function unlink (filename : chars) return int;\n+    ---------------------\n+    -- Extra functions --\n+    ---------------------\n+    -- These functions supply slightly thicker bindings than\n+    -- those above.  They are derived from functions in the\n+    -- C Run-Time Library, but may do a bit more work than\n+    -- just directly calling one of the Library functions.\n+    function is_regular_file (handle : int) return int;\n+    -- Tests if given handle is for a regular file (result 1)\n+    -- or for a non-regular file (pipe or device, result 0).\n+    ---------------------------------\n+    -- Control of Text/Binary Mode --\n+    ---------------------------------\n+    -- If text_translation_required is true, then the following\n+    -- functions may be used to dynamically switch a file from\n+    -- binary to text mode or vice versa.  These functions have\n+    -- no effect if text_translation_required is false (i.e., in\n+    -- normal UNIX mode).  Use fileno to get a stream handle.\n+    procedure set_binary_mode (handle : int);\n+    procedure set_text_mode (handle : int);\n+    ----------------------------\n+    -- Full Path Name support --\n+    ----------------------------\n+    procedure full_name (nam : chars; buffer : chars);\n+    -- Given a NUL terminated string representing a file\n+    -- name, returns in buffer a NUL terminated string\n+    -- representing the full path name for the file name.\n+    -- On systems where it is relevant the   drive is also\n+    -- part of the full path name.  It is the responsibility\n+    -- of the caller to pass an actual parameter for buffer\n+    -- that is big enough for any full path name.  Use\n+    -- max_path_len given below as the size of buffer.\n+    max_path_len : integer;\n+    -- Maximum length of an allowable full path name on the\n+    -- system, including a terminating NUL character.\n+  end Interfaces.C_Streams;\n+  \n+\n+.. _Interfacing_to_C_Streams:\n+\n+Interfacing to C Streams\n+========================\n+\n+The packages in this section permit interfacing Ada files to C Stream\n+operations.\n+\n+\n+.. code-block:: ada\n+\n+   with Interfaces.C_Streams;\n+   package Ada.Sequential_IO.C_Streams is\n+      function C_Stream (F : File_Type)\n+         return Interfaces.C_Streams.FILEs;\n+      procedure Open\n+        (File : in out File_Type;\n+         Mode : in File_Mode;\n+         C_Stream : in Interfaces.C_Streams.FILEs;\n+         Form : in String := \"\");\n+   end Ada.Sequential_IO.C_Streams;\n+\n+    with Interfaces.C_Streams;\n+    package Ada.Direct_IO.C_Streams is\n+       function C_Stream (F : File_Type)\n+          return Interfaces.C_Streams.FILEs;\n+       procedure Open\n+         (File : in out File_Type;\n+          Mode : in File_Mode;\n+          C_Stream : in Interfaces.C_Streams.FILEs;\n+          Form : in String := \"\");\n+    end Ada.Direct_IO.C_Streams;\n+\n+    with Interfaces.C_Streams;\n+    package Ada.Text_IO.C_Streams is\n+       function C_Stream (F : File_Type)\n+          return Interfaces.C_Streams.FILEs;\n+       procedure Open\n+         (File : in out File_Type;\n+          Mode : in File_Mode;\n+          C_Stream : in Interfaces.C_Streams.FILEs;\n+          Form : in String := \"\");\n+    end Ada.Text_IO.C_Streams;\n+\n+    with Interfaces.C_Streams;\n+    package Ada.Wide_Text_IO.C_Streams is\n+       function C_Stream (F : File_Type)\n+          return Interfaces.C_Streams.FILEs;\n+       procedure Open\n+         (File : in out File_Type;\n+          Mode : in File_Mode;\n+          C_Stream : in Interfaces.C_Streams.FILEs;\n+          Form : in String := \"\");\n+   end Ada.Wide_Text_IO.C_Streams;\n+\n+    with Interfaces.C_Streams;\n+    package Ada.Wide_Wide_Text_IO.C_Streams is\n+       function C_Stream (F : File_Type)\n+          return Interfaces.C_Streams.FILEs;\n+       procedure Open\n+         (File : in out File_Type;\n+          Mode : in File_Mode;\n+          C_Stream : in Interfaces.C_Streams.FILEs;\n+          Form : in String := \"\");\n+   end Ada.Wide_Wide_Text_IO.C_Streams;\n+\n+   with Interfaces.C_Streams;\n+   package Ada.Stream_IO.C_Streams is\n+      function C_Stream (F : File_Type)\n+         return Interfaces.C_Streams.FILEs;\n+      procedure Open\n+        (File : in out File_Type;\n+         Mode : in File_Mode;\n+         C_Stream : in Interfaces.C_Streams.FILEs;\n+         Form : in String := \"\");\n+   end Ada.Stream_IO.C_Streams;\n+  \n+\n+In each of these six packages, the `C_Stream` function obtains the\n+`FILE` pointer from a currently opened Ada file.  It is then\n+possible to use the `Interfaces.C_Streams` package to operate on\n+this stream, or the stream can be passed to a C program which can\n+operate on it directly.  Of course the program is responsible for\n+ensuring that only appropriate sequences of operations are executed.\n+\n+One particular use of relevance to an Ada program is that the\n+`setvbuf` function can be used to control the buffering of the\n+stream used by an Ada file.  In the absence of such a call the standard\n+default buffering is used.\n+\n+The `Open` procedures in these packages open a file giving an\n+existing C Stream instead of a file name.  Typically this stream is\n+imported from a C program, allowing an Ada file to operate on an\n+existing C file.\n+"}, {"sha": "7892160b47732f9c27022e25888f432617938fba", "filename": "gcc/ada/doc/gnat_ugn.rst", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,63 @@\n+GNAT User's Guide for Native Platforms\n+======================================\n+\n+*GNAT, The GNU Ada Development Environment*\n+\n+.. only:: PRO\n+\n+   *GNAT Pro Edition*\n+\n+   | Version |version|\n+   | Date: |today|\n+\n+.. only:: GPL\n+\n+   *GNAT GPL Edition*\n+\n+   | Version |version|\n+   | Date: |today|\n+\n+.. only:: FSF\n+\n+   .. raw:: texinfo\n+\n+      @include gcc-common.texi\n+      GCC version @value{version-GCC}@*\n+\n+AdaCore\n+\n+Permission is granted to copy, distribute and/or modify this document\n+under the terms of the GNU Free Documentation License, Version 1.3 or\n+any later version published by the Free Software Foundation; with no\n+Invariant Sections, with the Front-Cover Texts being\n+\"GNAT User's Guide for Native Platforms\",\n+and with no Back-Cover Texts.  A copy of the license is\n+included in the section entitled :ref:`gnu_fdl`.\n+\n+.. toctree::\n+   :maxdepth: 3\n+   :numbered:\n+\n+   gnat_ugn/about_this_guide\n+   gnat_ugn/getting_started_with_gnat\n+   gnat_ugn/the_gnat_compilation_model\n+   gnat_ugn/building_executable_programs_with_gnat\n+   gnat_ugn/gnat_project_manager\n+   gnat_ugn/tools_supporting_project_files\n+   gnat_ugn/gnat_utility_programs\n+   gnat_ugn/gnat_and_program_execution\n+\n+.. raw:: latex\n+\n+   \\appendix\n+\n+.. toctree::\n+   :maxdepth: 3\n+\n+   A. Platform-Specific Information <gnat_ugn/platform_specific_information>\n+   B. Example of Binder Output <gnat_ugn/example_of_binder_output>\n+   C. Elaboration Order Handling in GNAT <gnat_ugn/elaboration_order_handling_in_gnat>\n+   D. Inline Assembler <gnat_ugn/inline_assembler>\n+   E. GNU Free Documentation License <share/gnu_free_documentation_license>\n+\n+"}, {"sha": "467d3366b667bc701e0e5a601bd06d0f0c687c42", "filename": "gcc/ada/doc/gnat_ugn/about_this_guide.rst", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fabout_this_guide.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fabout_this_guide.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fabout_this_guide.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,223 @@\n+.. _About_This_Guide:\n+\n+About This Guide\n+~~~~~~~~~~~~~~~~\n+\n+.. only:: PRO\n+\n+   For ease of exposition, 'GNAT Pro' will be referred to simply as\n+   'GNAT' in the remainder of this document.\n+\n+This guide describes the use of GNAT,\n+a compiler and software development\n+toolset for the full Ada programming language.\n+It documents the features of the compiler and tools, and explains\n+how to use them to build Ada applications.\n+\n+GNAT implements Ada 95, Ada 2005 and Ada 2012, and it may also be\n+invoked in Ada 83 compatibility mode.\n+By default, GNAT assumes Ada 2012, but you can override with a\n+compiler switch (:ref:`Compiling_Different_Versions_of_Ada`)\n+to explicitly specify the language version.\n+Throughout this manual, references to 'Ada' without a year suffix\n+apply to all Ada 95/2005/2012 versions of the language.\n+\n+What This Guide Contains\n+========================\n+\n+This guide contains the following chapters:\n+\n+* :ref:`Getting_Started_with_GNAT` describes how to get started compiling\n+  and running Ada programs with the GNAT Ada programming environment.\n+\n+* :ref:`The_GNAT_Compilation_Model` describes the compilation model used\n+  by GNAT.\n+\n+* :ref:`Building_Executable_Programs_With_GNAT` describes how to use the\n+  main GNAT tools to build executable programs, and it also gives examples of\n+  using the GNU make utility with GNAT.\n+\n+* :ref:`GNAT_Project_Manager` describes how to use project files\n+  to organize large projects.\n+  \n+* :ref:`Tools_Supporting_Project_Files` described how to use the project\n+  facility in conjunction with various GNAT tools.\n+\n+* :ref:`GNAT_Utility_Programs` explains the various utility programs that\n+  are included in the GNAT environment\n+\n+* :ref:`GNAT_and_Program_Execution` covers a number of topics related to\n+  running, debugging, and tuning the performace of programs developed\n+  with GNAT\n+\n+Appendices cover several additional topics:\n+  \n+* :ref:`Platform_Specific_Information` describes the different run-time\n+  library implementations and also presents information on how to use\n+  GNAT on several specific platforms\n+  \n+* :ref:`Example_of_Binder_Output_File` shows the source code for the binder\n+  output file for a sample program.\n+\n+* :ref:`Elaboration_Order_Handling_in_GNAT` describes how GNAT helps\n+  you deal with elaboration order issues.\n+\n+* :ref:`Inline_Assembler` shows how to use the inline assembly facility\n+  in an Ada program.\n+\n+\n+\n+What You Should Know before Reading This Guide\n+==============================================\n+\n+.. index:: Ada 95 Language Reference Manual\n+\n+.. index:: Ada 2005 Language Reference Manual\n+\n+This guide assumes a basic familiarity with the Ada 95 language, as\n+described in the International Standard ANSI/ISO/IEC-8652:1995, January\n+1995.\n+It does not require knowledge of the features introduced by Ada 2005\n+or Ada 2012.\n+Reference manuals for Ada 95, Ada 2005, and Ada 2012 are included in\n+the GNAT documentation package.\n+\n+\n+Related Information\n+===================\n+\n+For further information about Ada and related tools, please refer to the\n+following documents:\n+\n+* :title:`Ada 95 Reference Manual`, :title:`Ada 2005 Reference Manual`, and\n+  :title:`Ada 2012 Reference Manual`, which contain reference\n+  material for the several revisions of the Ada language standard.\n+\n+* :title:`GNAT Reference_Manual`, which contains all reference material for the GNAT\n+  implementation of Ada.\n+\n+* :title:`Using the GNAT Programming Studio`, which describes the GPS\n+  Integrated Development Environment.\n+\n+* :title:`GNAT Programming Studio Tutorial`, which introduces the\n+  main GPS features through examples.\n+\n+* :title:`Debugging with GDB`,\n+  for all details on the use of the GNU source-level debugger.\n+\n+* :title:`GNU Emacs Manual`,\n+  for full information on the extensible editor and programming\n+  environment Emacs.\n+\n+\n+A Note to Readers of Previous Versions of the Manual\n+====================================================\n+\n+In early 2015 the GNAT manuals were transitioned to the\n+reStructuredText (rst) / Sphinx documentation generator technology.\n+During that process the :title:`GNAT User's Guide` was reorganized\n+so that related topics would be described together in the same chapter\n+or appendix.  Here's a summary of the major changes realized in\n+the new document structure.\n+\n+* :ref:`The_GNAT_Compilation_Model` has been extended so that it now covers\n+  the following material:\n+\n+  - The `gnatname`, `gnatkr`, and `gnatchop` tools\n+  - :ref:`Configuration_Pragmas`\n+  - :ref:`GNAT_and_Libraries`\n+  - :ref:`Conditional_Compilation` including :ref:`Preprocessing_with_gnatprep`\n+    and :ref:`Integrated_Preprocessing`\n+  - :ref:`Generating_Ada_Bindings_for_C_and_C++_headers`\n+  - :ref:`Using_GNAT_Files_with_External_Tools`\n+\n+* :ref:`Building_Executable_Programs_With_GNAT` is a new chapter consolidating\n+  the following content:\n+\n+  - :ref:`The_GNAT_Make_Program_gnatmake`\n+  - :ref:`Compiling_with_GCC`\n+  - :ref:`Binding_with_gnatbind`\n+  - :ref:`Linking_with_gnatlink`\n+  - :ref:`Using_the_GNU_make_Utility`\n+\n+* :ref:`GNAT_Utility_Programs` is a new chapter consolidating the information about several\n+  GNAT tools:\n+  \n+  .. only:: PRO or GPL\n+\n+    - :ref:`The_File_Cleanup_Utility_gnatclean`\n+    - :ref:`The_GNAT_Library_Browser_gnatls`\n+    - :ref:`The_Cross-Referencing_Tools_gnatxref_and_gnatfind`\n+    - :ref:`The_Ada_to_HTML_Converter_gnathtml`\n+    - :ref:`The_Ada-to-XML_Converter_gnat2xml`\n+    - :ref:`The_Program_Property_Verifier_gnatcheck`\n+    - :ref:`The_GNAT_Metrics_Tool_gnatmetric`\n+    - :ref:`The_GNAT_Pretty-Printer_gnatpp`\n+    - :ref:`The_Body_Stub_Generator_gnatstub`\n+    - :ref:`The_Unit_Test_Generator_gnattest`\n+  \n+  .. only:: FSF\n+\n+    - :ref:`The_File_Cleanup_Utility_gnatclean`\n+    - :ref:`The_GNAT_Library_Browser_gnatls`\n+    - :ref:`The_Cross-Referencing_Tools_gnatxref_and_gnatfind`\n+    - :ref:`The_Ada_to_HTML_Converter_gnathtml`\n+\n+* :ref:`GNAT_and_Program_Execution` is a new chapter consolidating the following:\n+\n+  - :ref:`Running_and_Debugging_Ada_Programs`\n+  - :ref:`Code_Coverage_and_Profiling`\n+  - :ref:`Improving_Performance`\n+  - :ref:`Overflow Check Handling in GNAT <Overflow_Check_Handling_in_GNAT>`\n+  - :ref:`Performing Dimensionality Analysis in GNAT <Performing_Dimensionality_Analysis_in_GNAT>`\n+  - :ref:`Stack_Related_Facilities`\n+  - :ref:`Memory_Management_Issues`\n+\n+* :ref:`Platform_Specific_Information` is a new appendix consolidating the following:\n+\n+  - :ref:`Run_Time_Libraries`\n+  - :ref:`Microsoft_Windows_Topics`\n+  - :ref:`Mac_OS_Topics`\n+\n+* The `Compatibility and Porting Guide` appendix has been moved to the\n+  :title:`GNAT Reference Manual`. It now includes a section\n+  `Writing Portable Fixed-Point Declarations` which was previously\n+  a separate chapter in the :title:`GNAT User's Guide`.\n+\n+\n+Conventions\n+===========\n+.. index:: Conventions, typographical\n+\n+.. index:: Typographical conventions\n+\n+Following are examples of the typographical and graphic conventions used\n+in this guide:\n+\n+* `Functions`, `utility program names`, `standard names`,\n+  and `classes`.\n+\n+* `Option flags`\n+\n+* :file:`File names`\n+\n+* `Variables`\n+\n+* *Emphasis*\n+\n+* [optional information or parameters]\n+\n+* Examples are described by text\n+\n+  ::\n+\n+    and then shown this way.\n+    \n+* Commands that are entered by the user are shown as preceded by a prompt string\n+  comprising the ``$`` character followed by a space.\n+\n+* Full file names are shown with the '/' character\n+  as the directory separator; e.g., :file:`parent-dir/subdir/myfile.adb`.\n+  If you are using GNAT on a Windows platform, please note that\n+  the '\\\\' character should be used instead.\n+"}, {"sha": "495e9fa4578099cf4d3bf4bb244b541835d12bb0", "filename": "gcc/ada/doc/gnat_ugn/building_executable_programs_with_gnat.rst", "status": "added", "additions": 7381, "deletions": 0, "changes": 7381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1"}, {"sha": "90b64a7f17a0f113060c3f73818eba20b604fa8d", "filename": "gcc/ada/doc/gnat_ugn/elaboration_order_handling_in_gnat.rst", "status": "added", "additions": 1864, "deletions": 0, "changes": 1864, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Felaboration_order_handling_in_gnat.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Felaboration_order_handling_in_gnat.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Felaboration_order_handling_in_gnat.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,1864 @@\n+.. |with| replace:: *with*\n+.. |withs| replace:: *with*\\ s\n+.. |withed| replace:: *with*\\ ed\n+.. |withing| replace:: *with*\\ ing\n+\n+.. -- Example: A |withing| unit has a |with| clause, it |withs| a |withed| unit\n+\n+\n+.. _Elaboration_Order_Handling_in_GNAT:\n+\n+**********************************\n+Elaboration Order Handling in GNAT\n+**********************************\n+\n+.. index:: Order of elaboration\n+.. index:: Elaboration control\n+\n+This appendix describes the handling of elaboration code in Ada and\n+in GNAT, and discusses how the order of elaboration of program units can\n+be controlled in GNAT, either automatically or with explicit programming\n+features.\n+\n+.. _Elaboration_Code:\n+\n+Elaboration Code\n+================\n+\n+Ada provides rather general mechanisms for executing code at elaboration\n+time, that is to say before the main program starts executing. Such code arises\n+in three contexts:\n+\n+* *Initializers for variables*\n+\n+  Variables declared at the library level, in package specs or bodies, can\n+  require initialization that is performed at elaboration time, as in:\n+\n+  .. code-block:: ada\n+\n+       Sqrt_Half : Float := Sqrt (0.5);\n+\n+* *Package initialization code*\n+\n+  Code in a `BEGIN-END` section at the outer level of a package body is\n+  executed as part of the package body elaboration code.\n+\n+* *Library level task allocators*\n+\n+  Tasks that are declared using task allocators at the library level\n+  start executing immediately and hence can execute at elaboration time.\n+\n+Subprogram calls are possible in any of these contexts, which means that\n+any arbitrary part of the program may be executed as part of the elaboration\n+code. It is even possible to write a program which does all its work at\n+elaboration time, with a null main program, although stylistically this\n+would usually be considered an inappropriate way to structure\n+a program.\n+\n+An important concern arises in the context of elaboration code:\n+we have to be sure that it is executed in an appropriate order. What we\n+have is a series of elaboration code sections, potentially one section\n+for each unit in the program. It is important that these execute\n+in the correct order. Correctness here means that, taking the above\n+example of the declaration of `Sqrt_Half`,\n+if some other piece of\n+elaboration code references `Sqrt_Half`,\n+then it must run after the\n+section of elaboration code that contains the declaration of\n+`Sqrt_Half`.\n+\n+There would never be any order of elaboration problem if we made a rule\n+that whenever you |with| a unit, you must elaborate both the spec and body\n+of that unit before elaborating the unit doing the |withing|:\n+\n+.. code-block:: ada\n+\n+     with Unit_1;\n+     package Unit_2 is ...\n+  \n+would require that both the body and spec of `Unit_1` be elaborated\n+before the spec of `Unit_2`. However, a rule like that would be far too\n+restrictive. In particular, it would make it impossible to have routines\n+in separate packages that were mutually recursive.\n+\n+You might think that a clever enough compiler could look at the actual\n+elaboration code and determine an appropriate correct order of elaboration,\n+but in the general case, this is not possible. Consider the following\n+example.\n+\n+In the body of `Unit_1`, we have a procedure `Func_1`\n+that references\n+the variable `Sqrt_1`, which is declared in the elaboration code\n+of the body of `Unit_1`:\n+\n+.. code-block:: ada\n+\n+     Sqrt_1 : Float := Sqrt (0.1);\n+  \n+The elaboration code of the body of `Unit_1` also contains:\n+\n+.. code-block:: ada\n+\n+     if expression_1 = 1 then\n+        Q := Unit_2.Func_2;\n+     end if;\n+\n+`Unit_2` is exactly parallel,\n+it has a procedure `Func_2` that references\n+the variable `Sqrt_2`, which is declared in the elaboration code of\n+the body `Unit_2`:\n+\n+.. code-block:: ada\n+\n+      Sqrt_2 : Float := Sqrt (0.1);\n+  \n+The elaboration code of the body of `Unit_2` also contains:\n+\n+.. code-block:: ada\n+\n+     if expression_2 = 2 then\n+        Q := Unit_1.Func_1;\n+     end if;\n+  \n+Now the question is, which of the following orders of elaboration is\n+acceptable:\n+\n+::\n+\n+     Spec of Unit_1\n+     Spec of Unit_2\n+     Body of Unit_1\n+     Body of Unit_2\n+  \n+or\n+\n+::\n+\n+     Spec of Unit_2\n+     Spec of Unit_1\n+     Body of Unit_2\n+     Body of Unit_1\n+  \n+If you carefully analyze the flow here, you will see that you cannot tell\n+at compile time the answer to this question.\n+If `expression_1` is not equal to 1,\n+and `expression_2` is not equal to 2,\n+then either order is acceptable, because neither of the function calls is\n+executed. If both tests evaluate to true, then neither order is acceptable\n+and in fact there is no correct order.\n+\n+If one of the two expressions is true, and the other is false, then one\n+of the above orders is correct, and the other is incorrect. For example,\n+if `expression_1` /= 1 and `expression_2` = 2,\n+then the call to `Func_1`\n+will occur, but not the call to `Func_2.`\n+This means that it is essential\n+to elaborate the body of `Unit_1` before\n+the body of `Unit_2`, so the first\n+order of elaboration is correct and the second is wrong.\n+\n+By making `expression_1` and `expression_2`\n+depend on input data, or perhaps\n+the time of day, we can make it impossible for the compiler or binder\n+to figure out which of these expressions will be true, and hence it\n+is impossible to guarantee a safe order of elaboration at run time.\n+\n+.. _Checking_the_Elaboration_Order:\n+\n+Checking the Elaboration Order\n+==============================\n+\n+In some languages that involve the same kind of elaboration problems,\n+e.g., Java and C++, the programmer needs to take these\n+ordering problems into account, and it is common to\n+write a program in which an incorrect elaboration order  gives\n+surprising results, because it references variables before they\n+are initialized.\n+Ada is designed to be a safe language, and a programmer-beware approach is\n+clearly not sufficient. Consequently, the language provides three lines\n+of defense:\n+\n+* *Standard rules*\n+\n+  Some standard rules restrict the possible choice of elaboration\n+  order. In particular, if you |with| a unit, then its spec is always\n+  elaborated before the unit doing the |with|. Similarly, a parent\n+  spec is always elaborated before the child spec, and finally\n+  a spec is always elaborated before its corresponding body.\n+\n+.. index:: Elaboration checks\n+.. index:: Checks, elaboration\n+\n+* *Dynamic elaboration checks*\n+\n+  Dynamic checks are made at run time, so that if some entity is accessed\n+  before it is elaborated (typically  by means of a subprogram call)\n+  then the exception (`Program_Error`) is raised.\n+\n+* *Elaboration control*\n+\n+  Facilities are provided for the programmer to specify the desired order\n+  of elaboration.\n+\n+Let's look at these facilities in more detail. First, the rules for\n+dynamic checking. One possible rule would be simply to say that the\n+exception is raised if you access a variable which has not yet been\n+elaborated. The trouble with this approach is that it could require\n+expensive checks on every variable reference. Instead Ada has two\n+rules which are a little more restrictive, but easier to check, and\n+easier to state:\n+\n+* *Restrictions on calls*\n+\n+  A subprogram can only be called at elaboration time if its body\n+  has been elaborated. The rules for elaboration given above guarantee\n+  that the spec of the subprogram has been elaborated before the\n+  call, but not the body. If this rule is violated, then the\n+  exception `Program_Error` is raised.\n+\n+* *Restrictions on instantiations*\n+\n+  A generic unit can only be instantiated if the body of the generic\n+  unit has been elaborated. Again, the rules for elaboration given above\n+  guarantee that the spec of the generic unit has been elaborated\n+  before the instantiation, but not the body. If this rule is\n+  violated, then the exception `Program_Error` is raised.\n+\n+The idea is that if the body has been elaborated, then any variables\n+it references must have been elaborated; by checking for the body being\n+elaborated we guarantee that none of its references causes any\n+trouble. As we noted above, this is a little too restrictive, because a\n+subprogram that has no non-local references in its body may in fact be safe\n+to call. However, it really would be unsafe to rely on this, because\n+it would mean that the caller was aware of details of the implementation\n+in the body. This goes against the basic tenets of Ada.\n+\n+A plausible implementation can be described as follows.\n+A Boolean variable is associated with each subprogram\n+and each generic unit. This variable is initialized to False, and is set to\n+True at the point body is elaborated. Every call or instantiation checks the\n+variable, and raises `Program_Error` if the variable is False.\n+\n+Note that one might think that it would be good enough to have one Boolean\n+variable for each package, but that would not deal with cases of trying\n+to call a body in the same package as the call\n+that has not been elaborated yet.\n+Of course a compiler may be able to do enough analysis to optimize away\n+some of the Boolean variables as unnecessary, and `GNAT` indeed\n+does such optimizations, but still the easiest conceptual model is to\n+think of there being one variable per subprogram.\n+\n+.. _Controlling_the_Elaboration_Order:\n+\n+Controlling the Elaboration Order\n+=================================\n+\n+In the previous section we discussed the rules in Ada which ensure\n+that `Program_Error` is raised if an incorrect elaboration order is\n+chosen. This prevents erroneous executions, but we need mechanisms to\n+specify a correct execution and avoid the exception altogether.\n+To achieve this, Ada provides a number of features for controlling\n+the order of elaboration. We discuss these features in this section.\n+\n+First, there are several ways of indicating to the compiler that a given\n+unit has no elaboration problems:\n+\n+* *packages that do not require a body*\n+\n+  A library package that does not require a body does not permit\n+  a body (this rule was introduced in Ada 95).\n+  Thus if we have a such a package, as in:\n+\n+  .. code-block:: ada\n+\n+       package Definitions is\n+          generic\n+             type m is new integer;\n+          package Subp is\n+             type a is array (1 .. 10) of m;\n+             type b is array (1 .. 20) of m;\n+          end Subp;\n+       end Definitions;\n+\n+  A package that |withs| `Definitions` may safely instantiate\n+  `Definitions.Subp` because the compiler can determine that there\n+  definitely is no package body to worry about in this case\n+\n+.. index:: pragma Pure\n+\n+* *pragma Pure*\n+\n+  This pragma places sufficient restrictions on a unit to guarantee that\n+  no call to any subprogram in the unit can result in an\n+  elaboration problem. This means that the compiler does not need\n+  to worry about the point of elaboration of such units, and in\n+  particular, does not need to check any calls to any subprograms\n+  in this unit.\n+\n+.. index:: pragma Preelaborate\n+\n+* *pragma Preelaborate*\n+\n+  This pragma places slightly less stringent restrictions on a unit than\n+  does pragma Pure,\n+  but these restrictions are still sufficient to ensure that there\n+  are no elaboration problems with any calls to the unit.\n+\n+.. index:: pragma Elaborate_Body\n+\n+* *pragma Elaborate_Body*\n+\n+  This pragma requires that the body of a unit be elaborated immediately\n+  after its spec. Suppose a unit `A` has such a pragma,\n+  and unit `B` does\n+  a |with| of unit `A`. Recall that the standard rules require\n+  the spec of unit `A`\n+  to be elaborated before the |withing| unit; given the pragma in\n+  `A`, we also know that the body of `A`\n+  will be elaborated before `B`, so\n+  that calls to `A` are safe and do not need a check.\n+\n+  Note that, unlike pragma `Pure` and pragma `Preelaborate`,\n+  the use of `Elaborate_Body` does not guarantee that the program is\n+  free of elaboration problems, because it may not be possible\n+  to satisfy the requested elaboration order.\n+  Let's go back to the example with `Unit_1` and `Unit_2`.\n+  If a programmer marks `Unit_1` as `Elaborate_Body`,\n+  and not `Unit_2,` then the order of\n+  elaboration will be::\n+\n+       Spec of Unit_2\n+       Spec of Unit_1\n+       Body of Unit_1\n+       Body of Unit_2\n+\n+  Now that means that the call to `Func_1` in `Unit_2`\n+  need not be checked,\n+  it must be safe. But the call to `Func_2` in\n+  `Unit_1` may still fail if\n+  `Expression_1` is equal to 1,\n+  and the programmer must still take\n+  responsibility for this not being the case.\n+\n+  If all units carry a pragma `Elaborate_Body`, then all problems are\n+  eliminated, except for calls entirely within a body, which are\n+  in any case fully under programmer control. However, using the pragma\n+  everywhere is not always possible.\n+  In particular, for our `Unit_1`/`Unit_2` example, if\n+  we marked both of them as having pragma `Elaborate_Body`, then\n+  clearly there would be no possible elaboration order.\n+\n+The above pragmas allow a server to guarantee safe use by clients, and\n+clearly this is the preferable approach. Consequently a good rule\n+is to mark units as `Pure` or `Preelaborate` if possible,\n+and if this is not possible,\n+mark them as `Elaborate_Body` if possible.\n+As we have seen, there are situations where neither of these\n+three pragmas can be used.\n+So we also provide methods for clients to control the\n+order of elaboration of the servers on which they depend:\n+\n+.. index:: pragma Elaborate\n+\n+* *pragma Elaborate (unit)*\n+\n+  This pragma is placed in the context clause, after a |with| clause,\n+  and it requires that the body of the named unit be elaborated before\n+  the unit in which the pragma occurs. The idea is to use this pragma\n+  if the current unit calls at elaboration time, directly or indirectly,\n+  some subprogram in the named unit.\n+\n+\n+.. index:: pragma Elaborate_All\n+\n+* *pragma Elaborate_All (unit)*\n+\n+  This is a stronger version of the Elaborate pragma. Consider the\n+  following example::\n+\n+        Unit A |withs| unit B and calls B.Func in elab code\n+        Unit B |withs| unit C, and B.Func calls C.Func\n+    \n+\n+  Now if we put a pragma `Elaborate (B)`\n+  in unit `A`, this ensures that the\n+  body of `B` is elaborated before the call, but not the\n+  body of `C`, so\n+  the call to `C.Func` could still cause `Program_Error` to\n+  be raised.\n+\n+  The effect of a pragma `Elaborate_All` is stronger, it requires\n+  not only that the body of the named unit be elaborated before the\n+  unit doing the |with|, but also the bodies of all units that the\n+  named unit uses, following |with| links transitively. For example,\n+  if we put a pragma `Elaborate_All (B)` in unit `A`,\n+  then it requires not only that the body of `B` be elaborated before `A`,\n+  but also the body of `C`, because `B` |withs| `C`.\n+\n+We are now in a position to give a usage rule in Ada for avoiding\n+elaboration problems, at least if dynamic dispatching and access to\n+subprogram values are not used. We will handle these cases separately\n+later.\n+\n+The rule is simple:\n+\n+*If a unit has elaboration code that can directly or\n+indirectly make a call to a subprogram in a |withed| unit, or instantiate\n+a generic package in a |withed| unit,\n+then if the |withed| unit does not have\n+pragma `Pure` or `Preelaborate`, then the client should have\n+a pragma `Elaborate_All`for the |withed| unit.**\n+\n+By following this rule a client is\n+assured that calls can be made without risk of an exception.\n+\n+For generic subprogram instantiations, the rule can be relaxed to\n+require only a pragma `Elaborate` since elaborating the body\n+of a subprogram cannot cause any transitive elaboration (we are\n+not calling the subprogram in this case, just elaborating its\n+declaration).\n+\n+If this rule is not followed, then a program may be in one of four\n+states:\n+\n+* *No order exists*\n+\n+  No order of elaboration exists which follows the rules, taking into\n+  account any `Elaborate`, `Elaborate_All`,\n+  or `Elaborate_Body` pragmas. In\n+  this case, an Ada compiler must diagnose the situation at bind\n+  time, and refuse to build an executable program.\n+\n+* *One or more orders exist, all incorrect*\n+\n+  One or more acceptable elaboration orders exist, and all of them\n+  generate an elaboration order problem. In this case, the binder\n+  can build an executable program, but `Program_Error` will be raised\n+  when the program is run.\n+\n+* *Several orders exist, some right, some incorrect*\n+\n+  One or more acceptable elaboration orders exists, and some of them\n+  work, and some do not. The programmer has not controlled\n+  the order of elaboration, so the binder may or may not pick one of\n+  the correct orders, and the program may or may not raise an\n+  exception when it is run. This is the worst case, because it means\n+  that the program may fail when moved to another compiler, or even\n+  another version of the same compiler.\n+\n+* *One or more orders exists, all correct*\n+\n+  One ore more acceptable elaboration orders exist, and all of them\n+  work. In this case the program runs successfully. This state of\n+  affairs can be guaranteed by following the rule we gave above, but\n+  may be true even if the rule is not followed.\n+\n+Note that one additional advantage of following our rules on the use\n+of `Elaborate` and `Elaborate_All`\n+is that the program continues to stay in the ideal (all orders OK) state\n+even if maintenance\n+changes some bodies of some units. Conversely, if a program that does\n+not follow this rule happens to be safe at some point, this state of affairs\n+may deteriorate silently as a result of maintenance changes.\n+\n+You may have noticed that the above discussion did not mention\n+the use of `Elaborate_Body`. This was a deliberate omission. If you\n+|with| an `Elaborate_Body` unit, it still may be the case that\n+code in the body makes calls to some other unit, so it is still necessary\n+to use `Elaborate_All` on such units.\n+\n+\n+.. _Controlling_Elaboration_in_GNAT_-_Internal_Calls:\n+\n+Controlling Elaboration in GNAT - Internal Calls\n+================================================\n+\n+In the case of internal calls, i.e., calls within a single package, the\n+programmer has full control over the order of elaboration, and it is up\n+to the programmer to elaborate declarations in an appropriate order. For\n+example writing:\n+\n+.. code-block:: ada\n+\n+     function One return Float;\n+ \n+     Q : Float := One;\n+  \n+     function One return Float is\n+     begin\n+          return 1.0;\n+     end One;\n+  \n+will obviously raise `Program_Error` at run time, because function\n+One will be called before its body is elaborated. In this case GNAT will\n+generate a warning that the call will raise `Program_Error`::\n+\n+     1. procedure y is\n+     2.    function One return Float;\n+     3.\n+     4.    Q : Float := One;\n+                        |\n+        >>> warning: cannot call \"One\" before body is elaborated\n+        >>> warning: Program_Error will be raised at run time\n+\n+     5.\n+     6.    function One return Float is\n+     7.    begin\n+     8.         return 1.0;\n+     9.    end One;\n+    10.\n+    11. begin\n+    12.    null;\n+    13. end;\n+  \n+\n+Note that in this particular case, it is likely that the call is safe, because\n+the function `One` does not access any global variables.\n+Nevertheless in Ada, we do not want the validity of the check to depend on\n+the contents of the body (think about the separate compilation case), so this\n+is still wrong, as we discussed in the previous sections.\n+\n+The error is easily corrected by rearranging the declarations so that the\n+body of `One` appears before the declaration containing the call\n+(note that in Ada 95 as well as later versions of the Ada standard,\n+declarations can appear in any order, so there is no restriction that\n+would prevent this reordering, and if we write:\n+\n+.. code-block:: ada\n+\n+     function One return Float;\n+ \n+     function One return Float is\n+     begin\n+          return 1.0;\n+     end One;\n+\n+     Q : Float := One;\n+\n+then all is well, no warning is generated, and no\n+`Program_Error` exception\n+will be raised.\n+Things are more complicated when a chain of subprograms is executed:\n+\n+.. code-block:: ada\n+\n+     function A return Integer;\n+     function B return Integer;\n+     function C return Integer;\n+\n+     function B return Integer is begin return A; end;\n+     function C return Integer is begin return B; end;\n+\n+     X : Integer := C;\n+\n+     function A return Integer is begin return 1; end;\n+\n+Now the call to `C`\n+at elaboration time in the declaration of `X` is correct, because\n+the body of `C` is already elaborated,\n+and the call to `B` within the body of\n+`C` is correct, but the call\n+to `A` within the body of `B` is incorrect, because the body\n+of `A` has not been elaborated, so `Program_Error`\n+will be raised on the call to `A`.\n+In this case GNAT will generate a\n+warning that `Program_Error` may be\n+raised at the point of the call. Let's look at the warning::\n+\n+     1. procedure x is\n+     2.    function A return Integer;\n+     3.    function B return Integer;\n+     4.    function C return Integer;\n+     5.\n+     6.    function B return Integer is begin return A; end;\n+                                                        |\n+        >>> warning: call to \"A\" before body is elaborated may\n+                     raise Program_Error\n+        >>> warning: \"B\" called at line 7\n+        >>> warning: \"C\" called at line 9\n+\n+     7.    function C return Integer is begin return B; end;\n+     8.\n+     9.    X : Integer := C;\n+    10.\n+    11.    function A return Integer is begin return 1; end;\n+    12.\n+    13. begin\n+    14.    null;\n+    15. end;\n+  \n+\n+Note that the message here says 'may raise', instead of the direct case,\n+where the message says 'will be raised'. That's because whether\n+`A` is\n+actually called depends in general on run-time flow of control.\n+For example, if the body of `B` said\n+\n+.. code-block:: ada\n+\n+     function B return Integer is\n+     begin\n+        if some-condition-depending-on-input-data then\n+           return A;\n+        else\n+           return 1;\n+        end if;\n+     end B;\n+\n+then we could not know until run time whether the incorrect call to A would\n+actually occur, so `Program_Error` might\n+or might not be raised. It is possible for a compiler to\n+do a better job of analyzing bodies, to\n+determine whether or not `Program_Error`\n+might be raised, but it certainly\n+couldn't do a perfect job (that would require solving the halting problem\n+and is provably impossible), and because this is a warning anyway, it does\n+not seem worth the effort to do the analysis. Cases in which it\n+would be relevant are rare.\n+\n+In practice, warnings of either of the forms given\n+above will usually correspond to\n+real errors, and should be examined carefully and eliminated.\n+In the rare case where a warning is bogus, it can be suppressed by any of\n+the following methods:\n+\n+* Compile with the *-gnatws* switch set\n+\n+* Suppress `Elaboration_Check` for the called subprogram\n+\n+* Use pragma `Warnings_Off` to turn warnings off for the call\n+\n+For the internal elaboration check case,\n+GNAT by default generates the\n+necessary run-time checks to ensure\n+that `Program_Error` is raised if any\n+call fails an elaboration check. Of course this can only happen if a\n+warning has been issued as described above. The use of pragma\n+`Suppress (Elaboration_Check)` may (but is not guaranteed to) suppress\n+some of these checks, meaning that it may be possible (but is not\n+guaranteed) for a program to be able to call a subprogram whose body\n+is not yet elaborated, without raising a `Program_Error` exception.\n+\n+\n+.. _Controlling_Elaboration_in_GNAT_-_External_Calls:\n+\n+Controlling Elaboration in GNAT - External Calls\n+================================================\n+\n+The previous section discussed the case in which the execution of a\n+particular thread of elaboration code occurred entirely within a\n+single unit. This is the easy case to handle, because a programmer\n+has direct and total control over the order of elaboration, and\n+furthermore, checks need only be generated in cases which are rare\n+and which the compiler can easily detect.\n+The situation is more complex when separate compilation is taken into account.\n+Consider the following:\n+\n+.. code-block:: ada\n+\n+      package Math is\n+         function Sqrt (Arg : Float) return Float;\n+      end Math;\n+\n+      package body Math is\n+         function Sqrt (Arg : Float) return Float is\n+         begin\n+               ...\n+         end Sqrt;\n+      end Math;\n+\n+      with Math;\n+      package Stuff is\n+         X : Float := Math.Sqrt (0.5);\n+      end Stuff;\n+\n+      with Stuff;\n+      procedure Main is\n+      begin\n+         ...\n+      end Main;\n+  \n+where `Main` is the main program. When this program is executed, the\n+elaboration code must first be executed, and one of the jobs of the\n+binder is to determine the order in which the units of a program are\n+to be elaborated. In this case we have four units: the spec and body\n+of `Math`,\n+the spec of `Stuff` and the body of `Main`).\n+In what order should the four separate sections of elaboration code\n+be executed?\n+\n+There are some restrictions in the order of elaboration that the binder\n+can choose. In particular, if unit U has a |with|\n+for a package `X`, then you\n+are assured that the spec of `X`\n+is elaborated before U , but you are\n+not assured that the body of `X`\n+is elaborated before U.\n+This means that in the above case, the binder is allowed to choose the\n+order::\n+\n+     spec of Math\n+     spec of Stuff\n+     body of Math\n+     body of Main\n+\n+but that's not good, because now the call to `Math.Sqrt`\n+that happens during\n+the elaboration of the `Stuff`\n+spec happens before the body of `Math.Sqrt` is\n+elaborated, and hence causes `Program_Error` exception to be raised.\n+At first glance, one might say that the binder is misbehaving, because\n+obviously you want to elaborate the body of something you |with| first, but\n+that is not a general rule that can be followed in all cases. Consider\n+\n+.. code-block:: ada\n+\n+      package X is ...\n+\n+      package Y is ...\n+\n+      with X;\n+      package body Y is ...\n+\n+      with Y;\n+      package body X is ...\n+\n+This is a common arrangement, and, apart from the order of elaboration\n+problems that might arise in connection with elaboration code, this works fine.\n+A rule that says that you must first elaborate the body of anything you\n+|with| cannot work in this case:\n+the body of `X` |withs| `Y`,\n+which means you would have to\n+elaborate the body of `Y` first, but that |withs| `X`,\n+which means\n+you have to elaborate the body of `X` first, but ... and we have a\n+loop that cannot be broken.\n+\n+It is true that the binder can in many cases guess an order of elaboration\n+that is unlikely to cause a `Program_Error`\n+exception to be raised, and it tries to do so (in the\n+above example of `Math/Stuff/Spec`, the GNAT binder will\n+by default\n+elaborate the body of `Math` right after its spec, so all will be well).\n+\n+However, a program that blindly relies on the binder to be helpful can\n+get into trouble, as we discussed in the previous sections, so GNAT\n+provides a number of facilities for assisting the programmer in\n+developing programs that are robust with respect to elaboration order.\n+\n+\n+.. _Default_Behavior_in_GNAT_-_Ensuring_Safety:\n+\n+Default Behavior in GNAT - Ensuring Safety\n+==========================================\n+\n+The default behavior in GNAT ensures elaboration safety. In its\n+default mode GNAT implements the\n+rule we previously described as the right approach. Let's restate it:\n+\n+*If a unit has elaboration code that can directly or indirectly make a\n+call to a subprogram in a |withed| unit, or instantiate a generic\n+package in a |withed| unit, then if the |withed| unit\n+does not have pragma `Pure` or `Preelaborate`, then the client should have an\n+`Elaborate_All` pragma for the |withed| unit.*\n+\n+*In the case of instantiating a generic subprogram, it is always\n+sufficient to have only an `Elaborate` pragma for the\n+|withed| unit.*\n+\n+By following this rule a client is assured that calls and instantiations\n+can be made without risk of an exception.\n+\n+In this mode GNAT traces all calls that are potentially made from\n+elaboration code, and puts in any missing implicit `Elaborate`\n+and `Elaborate_All` pragmas.\n+The advantage of this approach is that no elaboration problems\n+are possible if the binder can find an elaboration order that is\n+consistent with these implicit `Elaborate` and\n+`Elaborate_All` pragmas. The\n+disadvantage of this approach is that no such order may exist.\n+\n+If the binder does not generate any diagnostics, then it means that it has\n+found an elaboration order that is guaranteed to be safe. However, the binder\n+may still be relying on implicitly generated `Elaborate` and\n+`Elaborate_All` pragmas so portability to other compilers than GNAT is not\n+guaranteed.\n+\n+If it is important to guarantee portability, then the compilations should\n+use the *-gnatel*\n+(info messages for elaboration pragmas) switch. This will cause info messages\n+to be generated indicating the missing `Elaborate` and\n+`Elaborate_All` pragmas.\n+Consider the following source program:\n+\n+.. code-block:: ada\n+\n+     with k;\n+     package j is\n+       m : integer := k.r;\n+     end;\n+\n+where it is clear that there\n+should be a pragma `Elaborate_All`\n+for unit `k`. An implicit pragma will be generated, and it is\n+likely that the binder will be able to honor it. However, if you want\n+to port this program to some other Ada compiler than GNAT.\n+it is safer to include the pragma explicitly in the source. If this\n+unit is compiled with the *-gnatel*\n+switch, then the compiler outputs an information message::\n+\n+     1. with k;\n+     2. package j is\n+     3.   m : integer := k.r;\n+                          |\n+        >>> info: call to \"r\" may raise Program_Error\n+        >>> info: missing pragma Elaborate_All for \"k\"\n+   \n+     4. end;\n+\n+and these messages can be used as a guide for supplying manually\n+the missing pragmas. It is usually a bad idea to use this\n+option during development. That's because it will tell you when\n+you need to put in a pragma, but cannot tell you when it is time\n+to take it out. So the use of pragma `Elaborate_All` may lead to\n+unnecessary dependencies and even false circularities.\n+\n+This default mode is more restrictive than the Ada Reference\n+Manual, and it is possible to construct programs which will compile\n+using the dynamic model described there, but will run into a\n+circularity using the safer static model we have described.\n+\n+Of course any Ada compiler must be able to operate in a mode\n+consistent with the requirements of the Ada Reference Manual,\n+and in particular must have the capability of implementing the\n+standard dynamic model of elaboration with run-time checks.\n+\n+In GNAT, this standard mode can be achieved either by the use of\n+the *-gnatE* switch on the compiler (*gcc* or\n+*gnatmake*) command, or by the use of the configuration pragma:\n+\n+.. code-block:: ada\n+\n+      pragma Elaboration_Checks (DYNAMIC);\n+  \n+Either approach will cause the unit affected to be compiled using the\n+standard dynamic run-time elaboration checks described in the Ada\n+Reference Manual. The static model is generally preferable, since it\n+is clearly safer to rely on compile and link time checks rather than\n+run-time checks. However, in the case of legacy code, it may be\n+difficult to meet the requirements of the static model. This\n+issue is further discussed in\n+:ref:`What_to_Do_If_the_Default_Elaboration_Behavior_Fails`.\n+\n+Note that the static model provides a strict subset of the allowed\n+behavior and programs of the Ada Reference Manual, so if you do\n+adhere to the static model and no circularities exist,\n+then you are assured that your program will\n+work using the dynamic model, providing that you remove any\n+pragma Elaborate statements from the source.\n+\n+\n+.. _Treatment_of_Pragma_Elaborate:\n+\n+Treatment of Pragma Elaborate\n+=============================\n+\n+.. index:: Pragma Elaborate\n+\n+The use of `pragma Elaborate`\n+should generally be avoided in Ada 95 and Ada 2005 programs,\n+since there is no guarantee that transitive calls\n+will be properly handled. Indeed at one point, this pragma was placed\n+in Annex J (Obsolescent Features), on the grounds that it is never useful.\n+\n+Now that's a bit restrictive. In practice, the case in which\n+`pragma Elaborate` is useful is when the caller knows that there\n+are no transitive calls, or that the called unit contains all necessary\n+transitive `pragma Elaborate` statements, and legacy code often\n+contains such uses.\n+\n+Strictly speaking the static mode in GNAT should ignore such pragmas,\n+since there is no assurance at compile time that the necessary safety\n+conditions are met. In practice, this would cause GNAT to be incompatible\n+with correctly written Ada 83 code that had all necessary\n+`pragma Elaborate` statements in place. Consequently, we made the\n+decision that GNAT in its default mode will believe that if it encounters\n+a `pragma Elaborate` then the programmer knows what they are doing,\n+and it will trust that no elaboration errors can occur.\n+\n+The result of this decision is two-fold. First to be safe using the\n+static mode, you should remove all `pragma Elaborate` statements.\n+Second, when fixing circularities in existing code, you can selectively\n+use `pragma Elaborate` statements to convince the static mode of\n+GNAT that it need not generate an implicit `pragma Elaborate_All`\n+statement.\n+\n+When using the static mode with *-gnatwl*, any use of\n+`pragma Elaborate` will generate a warning about possible\n+problems.\n+\n+\n+.. _Elaboration_Issues_for_Library_Tasks:\n+\n+Elaboration Issues for Library Tasks\n+====================================\n+\n+.. index:: Library tasks, elaboration issues\n+\n+.. index:: Elaboration of library tasks\n+\n+In this section we examine special elaboration issues that arise for\n+programs that declare library level tasks.\n+\n+Generally the model of execution of an Ada program is that all units are\n+elaborated, and then execution of the program starts. However, the\n+declaration of library tasks definitely does not fit this model. The\n+reason for this is that library tasks start as soon as they are declared\n+(more precisely, as soon as the statement part of the enclosing package\n+body is reached), that is to say before elaboration\n+of the program is complete. This means that if such a task calls a\n+subprogram, or an entry in another task, the callee may or may not be\n+elaborated yet, and in the standard\n+Reference Manual model of dynamic elaboration checks, you can even\n+get timing dependent Program_Error exceptions, since there can be\n+a race between the elaboration code and the task code.\n+\n+The static model of elaboration in GNAT seeks to avoid all such\n+dynamic behavior, by being conservative, and the conservative\n+approach in this particular case is to assume that all the code\n+in a task body is potentially executed at elaboration time if\n+a task is declared at the library level.\n+\n+This can definitely result in unexpected circularities. Consider\n+the following example\n+\n+.. code-block:: ada\n+\n+      package Decls is\n+        task Lib_Task is\n+           entry Start;\n+        end Lib_Task;\n+\n+        type My_Int is new Integer;\n+\n+        function Ident (M : My_Int) return My_Int;\n+      end Decls;\n+\n+      with Utils;\n+      package body Decls is\n+        task body Lib_Task is\n+        begin\n+           accept Start;\n+           Utils.Put_Val (2);\n+        end Lib_Task;\n+\n+        function Ident (M : My_Int) return My_Int is\n+        begin\n+           return M;\n+        end Ident;\n+      end Decls;\n+\n+      with Decls;\n+      package Utils is\n+        procedure Put_Val (Arg : Decls.My_Int);\n+      end Utils;\n+\n+      with Text_IO;\n+      package body Utils is\n+        procedure Put_Val (Arg : Decls.My_Int) is\n+        begin\n+           Text_IO.Put_Line (Decls.My_Int'Image (Decls.Ident (Arg)));\n+        end Put_Val;\n+      end Utils;\n+\n+      with Decls;\n+      procedure Main is\n+      begin\n+         Decls.Lib_Task.Start;\n+      end;\n+  \n+If the above example is compiled in the default static elaboration\n+mode, then a circularity occurs. The circularity comes from the call\n+`Utils.Put_Val` in the task body of `Decls.Lib_Task`. Since\n+this call occurs in elaboration code, we need an implicit pragma\n+`Elaborate_All` for `Utils`. This means that not only must\n+the spec and body of `Utils` be elaborated before the body\n+of `Decls`, but also the spec and body of any unit that is\n+|withed| by the body of `Utils` must also be elaborated before\n+the body of `Decls`. This is the transitive implication of\n+pragma `Elaborate_All` and it makes sense, because in general\n+the body of `Put_Val` might have a call to something in a\n+|withed| unit.\n+\n+In this case, the body of Utils (actually its spec) |withs|\n+`Decls`. Unfortunately this means that the body of `Decls`\n+must be elaborated before itself, in case there is a call from the\n+body of `Utils`.\n+\n+Here is the exact chain of events we are worrying about:\n+\n+* In the body of `Decls` a call is made from within the body of a library\n+  task to a subprogram in the package `Utils`. Since this call may\n+  occur at elaboration time (given that the task is activated at elaboration\n+  time), we have to assume the worst, i.e., that the\n+  call does happen at elaboration time.\n+\n+* This means that the body and spec of `Util` must be elaborated before\n+  the body of `Decls` so that this call does not cause an access before\n+  elaboration.\n+\n+* Within the body of `Util`, specifically within the body of\n+  `Util.Put_Val` there may be calls to any unit |withed|\n+  by this package.\n+\n+* One such |withed| package is package `Decls`, so there\n+  might be a call to a subprogram in `Decls` in `Put_Val`.\n+  In fact there is such a call in this example, but we would have to\n+  assume that there was such a call even if it were not there, since\n+  we are not supposed to write the body of `Decls` knowing what\n+  is in the body of `Utils`; certainly in the case of the\n+  static elaboration model, the compiler does not know what is in\n+  other bodies and must assume the worst.\n+\n+* This means that the spec and body of `Decls` must also be\n+  elaborated before we elaborate the unit containing the call, but\n+  that unit is `Decls`! This means that the body of `Decls`\n+  must be elaborated before itself, and that's a circularity.\n+\n+Indeed, if you add an explicit pragma `Elaborate_All` for `Utils` in\n+the body of `Decls` you will get a true Ada Reference Manual\n+circularity that makes the program illegal.\n+\n+In practice, we have found that problems with the static model of\n+elaboration in existing code often arise from library tasks, so\n+we must address this particular situation.\n+\n+Note that if we compile and run the program above, using the dynamic model of\n+elaboration (that is to say use the *-gnatE* switch),\n+then it compiles, binds,\n+links, and runs, printing the expected result of 2. Therefore in some sense\n+the circularity here is only apparent, and we need to capture\n+the properties of this program that  distinguish it from other library-level\n+tasks that have real elaboration problems.\n+\n+We have four possible answers to this question:\n+\n+\n+* Use the dynamic model of elaboration.\n+\n+  If we use the *-gnatE* switch, then as noted above, the program works.\n+  Why is this? If we examine the task body, it is apparent that the task cannot\n+  proceed past the\n+  `accept` statement until after elaboration has been completed, because\n+  the corresponding entry call comes from the main program, not earlier.\n+  This is why the dynamic model works here. But that's really giving\n+  up on a precise analysis, and we prefer to take this approach only if we cannot\n+  solve the\n+  problem in any other manner. So let us examine two ways to reorganize\n+  the program to avoid the potential elaboration problem.\n+\n+* Split library tasks into separate packages.\n+\n+  Write separate packages, so that library tasks are isolated from\n+  other declarations as much as possible. Let us look at a variation on\n+  the above program.\n+\n+\n+  .. code-block:: ada\n+\n+      package Decls1 is\n+        task Lib_Task is\n+           entry Start;\n+        end Lib_Task;\n+      end Decls1;\n+\n+      with Utils;\n+      package body Decls1 is\n+        task body Lib_Task is\n+        begin\n+           accept Start;\n+           Utils.Put_Val (2);\n+        end Lib_Task;\n+      end Decls1;\n+\n+      package Decls2 is\n+        type My_Int is new Integer;\n+        function Ident (M : My_Int) return My_Int;\n+      end Decls2;\n+\n+      with Utils;\n+      package body Decls2 is\n+        function Ident (M : My_Int) return My_Int is\n+        begin\n+           return M;\n+        end Ident;\n+      end Decls2;\n+\n+      with Decls2;\n+      package Utils is\n+        procedure Put_Val (Arg : Decls2.My_Int);\n+      end Utils;\n+\n+      with Text_IO;\n+      package body Utils is\n+        procedure Put_Val (Arg : Decls2.My_Int) is\n+        begin\n+           Text_IO.Put_Line (Decls2.My_Int'Image (Decls2.Ident (Arg)));\n+        end Put_Val;\n+      end Utils;\n+\n+      with Decls1;\n+      procedure Main is\n+      begin\n+         Decls1.Lib_Task.Start;\n+      end;\n+    \n+\n+  All we have done is to split `Decls` into two packages, one\n+  containing the library task, and one containing everything else. Now\n+  there is no cycle, and the program compiles, binds, links and executes\n+  using the default static model of elaboration.\n+\n+* Declare separate task types.\n+\n+  A significant part of the problem arises because of the use of the\n+  single task declaration form. This means that the elaboration of\n+  the task type, and the elaboration of the task itself (i.e., the\n+  creation of the task) happen at the same time. A good rule\n+  of style in Ada is to always create explicit task types. By\n+  following the additional step of placing task objects in separate\n+  packages from the task type declaration, many elaboration problems\n+  are avoided. Here is another modified example of the example program:\n+\n+  .. code-block:: ada\n+\n+      package Decls is\n+        task type Lib_Task_Type is\n+           entry Start;\n+        end Lib_Task_Type;\n+\n+        type My_Int is new Integer;\n+\n+        function Ident (M : My_Int) return My_Int;\n+      end Decls;\n+\n+      with Utils;\n+      package body Decls is\n+        task body Lib_Task_Type is\n+        begin\n+           accept Start;\n+           Utils.Put_Val (2);\n+        end Lib_Task_Type;\n+\n+        function Ident (M : My_Int) return My_Int is\n+        begin\n+           return M;\n+        end Ident;\n+      end Decls;\n+\n+      with Decls;\n+      package Utils is\n+        procedure Put_Val (Arg : Decls.My_Int);\n+      end Utils;\n+\n+      with Text_IO;\n+      package body Utils is\n+        procedure Put_Val (Arg : Decls.My_Int) is\n+        begin\n+           Text_IO.Put_Line (Decls.My_Int'Image (Decls.Ident (Arg)));\n+        end Put_Val;\n+      end Utils;\n+\n+      with Decls;\n+      package Declst is\n+         Lib_Task : Decls.Lib_Task_Type;\n+      end Declst;\n+\n+      with Declst;\n+      procedure Main is\n+      begin\n+         Declst.Lib_Task.Start;\n+      end;\n+    \n+\n+  What we have done here is to replace the `task` declaration in\n+  package `Decls` with a `task type` declaration. Then we\n+  introduce a separate package `Declst` to contain the actual\n+  task object. This separates the elaboration issues for\n+  the `task type`\n+  declaration, which causes no trouble, from the elaboration issues\n+  of the task object, which is also unproblematic, since it is now independent\n+  of the elaboration of  `Utils`.\n+  This separation of concerns also corresponds to\n+  a generally sound engineering principle of separating declarations\n+  from instances. This version of the program also compiles, binds, links,\n+  and executes, generating the expected output.\n+\n+.. index:: No_Entry_Calls_In_Elaboration_Code restriction\n+\n+* Use No_Entry_Calls_In_Elaboration_Code restriction.\n+\n+  The previous two approaches described how a program can be restructured\n+  to avoid the special problems caused by library task bodies. in practice,\n+  however, such restructuring may be difficult to apply to existing legacy code,\n+  so we must consider solutions that do not require massive rewriting.\n+\n+  Let us consider more carefully why our original sample program works\n+  under the dynamic model of elaboration. The reason is that the code\n+  in the task body blocks immediately on the `accept`\n+  statement. Now of course there is nothing to prohibit elaboration\n+  code from making entry calls (for example from another library level task),\n+  so we cannot tell in isolation that\n+  the task will not execute the accept statement  during elaboration.\n+\n+  However, in practice it is very unusual to see elaboration code\n+  make any entry calls, and the pattern of tasks starting\n+  at elaboration time and then immediately blocking on `accept` or\n+  `select` statements is very common. What this means is that\n+  the compiler is being too pessimistic when it analyzes the\n+  whole package body as though it might be executed at elaboration\n+  time.\n+\n+  If we know that the elaboration code contains no entry calls, (a very safe\n+  assumption most of the time, that could almost be made the default\n+  behavior), then we can compile all units of the program under control\n+  of the following configuration pragma:\n+\n+  .. code-block:: ada\n+\n+      pragma Restrictions (No_Entry_Calls_In_Elaboration_Code);\n+    \n+  This pragma can be placed in the :file:`gnat.adc` file in the usual\n+  manner. If we take our original unmodified program and compile it\n+  in the presence of a :file:`gnat.adc` containing the above pragma,\n+  then once again, we can compile, bind, link, and execute, obtaining\n+  the expected result. In the presence of this pragma, the compiler does\n+  not trace calls in a task body, that appear after the first `accept`\n+  or `select` statement, and therefore does not report a potential\n+  circularity in the original program.\n+\n+  The compiler will check to the extent it can that the above\n+  restriction is not violated, but it is not always possible to do a\n+  complete check at compile time, so it is important to use this\n+  pragma only if the stated restriction is in fact met, that is to say\n+  no task receives an entry call before elaboration of all units is completed.\n+\n+\n+.. _Mixing_Elaboration_Models:\n+\n+Mixing Elaboration Models\n+=========================\n+\n+So far, we have assumed that the entire program is either compiled\n+using the dynamic model or static model, ensuring consistency. It\n+is possible to mix the two models, but rules have to be followed\n+if this mixing is done to ensure that elaboration checks are not\n+omitted.\n+\n+The basic rule is that\n+**a unit compiled with the static model cannot\n+be |withed| by a unit compiled with the dynamic model**.\n+The reason for this is that in the static model, a unit assumes that\n+its clients guarantee to use (the equivalent of) pragma\n+`Elaborate_All` so that no elaboration checks are required\n+in inner subprograms, and this assumption is violated if the\n+client is compiled with dynamic checks.\n+\n+The precise rule is as follows. A unit that is compiled with dynamic\n+checks can only |with| a unit that meets at least one of the\n+following criteria:\n+\n+\n+* The |withed| unit is itself compiled with dynamic elaboration\n+  checks (that is with the *-gnatE* switch.\n+\n+* The |withed| unit is an internal GNAT implementation unit from\n+  the System, Interfaces, Ada, or GNAT hierarchies.\n+\n+* The |withed| unit has pragma Preelaborate or pragma Pure.\n+\n+* The |withing| unit (that is the client) has an explicit pragma\n+  `Elaborate_All` for the |withed| unit.\n+\n+\n+If this rule is violated, that is if a unit with dynamic elaboration\n+checks |withs| a unit that does not meet one of the above four\n+criteria, then the binder (`gnatbind`) will issue a warning\n+similar to that in the following example::\n+\n+     warning: \"x.ads\" has dynamic elaboration checks and with's\n+     warning:   \"y.ads\" which has static elaboration checks\n+ \n+These warnings indicate that the rule has been violated, and that as a result\n+elaboration checks may be missed in the resulting executable file.\n+This warning may be suppressed using the *-ws* binder switch\n+in the usual manner.\n+\n+One useful application of this mixing rule is in the case of a subsystem\n+which does not itself |with| units from the remainder of the\n+application. In this case, the entire subsystem can be compiled with\n+dynamic checks to resolve a circularity in the subsystem, while\n+allowing the main application that uses this subsystem to be compiled\n+using the more reliable default static model.\n+\n+\n+.. _What_to_Do_If_the_Default_Elaboration_Behavior_Fails:\n+\n+What to Do If the Default Elaboration Behavior Fails\n+====================================================\n+\n+If the binder cannot find an acceptable order, it outputs detailed\n+diagnostics. For example::\n+\n+     error: elaboration circularity detected\n+     info:   \"proc (body)\" must be elaborated before \"pack (body)\"\n+     info:     reason: Elaborate_All probably needed in unit \"pack (body)\"\n+     info:     recompile \"pack (body)\" with -gnatel\n+     info:                             for full details\n+     info:       \"proc (body)\"\n+     info:         is needed by its spec:\n+     info:       \"proc (spec)\"\n+     info:         which is withed by:\n+     info:       \"pack (body)\"\n+     info:  \"pack (body)\" must be elaborated before \"proc (body)\"\n+     info:     reason: pragma Elaborate in unit \"proc (body)\"\n+\n+In this case we have a cycle that the binder cannot break. On the one\n+hand, there is an explicit pragma Elaborate in `proc` for\n+`pack`. This means that the body of `pack` must be elaborated\n+before the body of `proc`. On the other hand, there is elaboration\n+code in `pack` that calls a subprogram in `proc`. This means\n+that for maximum safety, there should really be a pragma\n+Elaborate_All in `pack` for `proc` which would require that\n+the body of `proc` be elaborated before the body of\n+`pack`. Clearly both requirements cannot be satisfied.\n+Faced with a circularity of this kind, you have three different options.\n+\n+\n+* *Fix the program*\n+\n+  The most desirable option from the point of view of long-term maintenance\n+  is to rearrange the program so that the elaboration problems are avoided.\n+  One useful technique is to place the elaboration code into separate\n+  child packages. Another is to move some of the initialization code to\n+  explicitly called subprograms, where the program controls the order\n+  of initialization explicitly. Although this is the most desirable option,\n+  it may be impractical and involve too much modification, especially in\n+  the case of complex legacy code.\n+\n+* *Perform dynamic checks*\n+\n+  If the compilations are done using the *-gnatE*\n+  (dynamic elaboration check) switch, then GNAT behaves in a quite different\n+  manner. Dynamic checks are generated for all calls that could possibly result\n+  in raising an exception. With this switch, the compiler does not generate\n+  implicit `Elaborate` or `Elaborate_All` pragmas. The behavior then is\n+  exactly as specified in the :title:`Ada Reference Manual`.\n+  The binder will generate\n+  an executable program that may or may not raise `Program_Error`, and then\n+  it is the programmer's job to ensure that it does not raise an exception. Note\n+  that it is important to compile all units with the switch, it cannot be used\n+  selectively.\n+\n+* *Suppress checks*\n+\n+  The drawback of dynamic checks is that they generate a\n+  significant overhead at run time, both in space and time. If you\n+  are absolutely sure that your program cannot raise any elaboration\n+  exceptions, and you still want to use the dynamic elaboration model,\n+  then you can use the configuration pragma\n+  `Suppress (Elaboration_Check)` to suppress all such checks. For\n+  example this pragma could be placed in the :file:`gnat.adc` file.\n+\n+* *Suppress checks selectively*\n+\n+  When you know that certain calls or instantiations in elaboration code cannot\n+  possibly lead to an elaboration error, and the binder nevertheless complains\n+  about implicit `Elaborate` and `Elaborate_All` pragmas that lead to\n+  elaboration circularities, it is possible to remove those warnings locally and\n+  obtain a program that will bind. Clearly this can be unsafe, and it is the\n+  responsibility of the programmer to make sure that the resulting program has no\n+  elaboration anomalies. The pragma `Suppress (Elaboration_Check)` can be\n+  used with different granularity to suppress warnings and break elaboration\n+  circularities:\n+\n+  * Place the pragma that names the called subprogram in the declarative part\n+    that contains the call.\n+\n+  * Place the pragma in the declarative part, without naming an entity. This\n+    disables warnings on all calls in the corresponding  declarative region.\n+\n+  * Place the pragma in the package spec that declares the called subprogram,\n+    and name the subprogram. This disables warnings on all elaboration calls to\n+    that subprogram.\n+\n+  * Place the pragma in the package spec that declares the called subprogram,\n+    without naming any entity. This disables warnings on all elaboration calls to\n+    all subprograms declared in this spec.\n+\n+  * Use Pragma Elaborate.\n+\n+    As previously described in section :ref:`Treatment_of_Pragma_Elaborate`,\n+    GNAT in static mode assumes that a `pragma` Elaborate indicates correctly\n+    that no elaboration checks are required on calls to the designated unit.\n+    There may be cases in which the caller knows that no transitive calls\n+    can occur, so that a `pragma Elaborate` will be sufficient in a\n+    case where `pragma Elaborate_All` would cause a circularity.\n+\n+  These five cases are listed in order of decreasing safety, and therefore\n+  require increasing programmer care in their application. Consider the\n+  following program:\n+\n+  .. code-block:: ada\n+\n+        package Pack1 is\n+          function F1 return Integer;\n+          X1 : Integer;\n+        end Pack1;\n+\n+        package Pack2 is\n+          function F2 return Integer;\n+          function Pure (x : integer) return integer;\n+          --  pragma Suppress (Elaboration_Check, On => Pure);  -- (3)\n+          --  pragma Suppress (Elaboration_Check);              -- (4)\n+        end Pack2;\n+\n+        with Pack2;\n+        package body Pack1 is\n+          function F1 return Integer is\n+          begin\n+            return 100;\n+          end F1;\n+          Val : integer := Pack2.Pure (11);    --  Elab. call (1)\n+        begin\n+          declare\n+            --  pragma Suppress(Elaboration_Check, Pack2.F2);   -- (1)\n+            --  pragma Suppress(Elaboration_Check);             -- (2)\n+          begin\n+            X1 := Pack2.F2 + 1;                --  Elab. call (2)\n+          end;\n+        end Pack1;\n+\n+        with Pack1;\n+        package body Pack2 is\n+          function F2 return Integer is\n+          begin\n+             return Pack1.F1;\n+          end F2;\n+          function Pure (x : integer) return integer is\n+          begin\n+             return x ** 3 - 3 * x;\n+          end;\n+        end Pack2;\n+\n+        with Pack1, Ada.Text_IO;\n+        procedure Proc3 is\n+        begin\n+          Ada.Text_IO.Put_Line(Pack1.X1'Img); -- 101\n+        end Proc3;\n+    \n+  In the absence of any pragmas, an attempt to bind this program produces\n+  the following diagnostics::\n+\n+       error: elaboration circularity detected\n+       info:    \"pack1 (body)\" must be elaborated before \"pack1 (body)\"\n+       info:       reason: Elaborate_All probably needed in unit \"pack1 (body)\"\n+       info:       recompile \"pack1 (body)\" with -gnatel for full details\n+       info:          \"pack1 (body)\"\n+       info:             must be elaborated along with its spec:\n+       info:          \"pack1 (spec)\"\n+       info:             which is withed by:\n+       info:          \"pack2 (body)\"\n+       info:             which must be elaborated along with its spec:\n+       info:          \"pack2 (spec)\"\n+       info:             which is withed by:\n+       info:          \"pack1 (body)\"\n+    \n+  The sources of the circularity are the two calls to `Pack2.Pure` and\n+  `Pack2.F2` in the body of `Pack1`. We can see that the call to\n+  F2 is safe, even though F2 calls F1, because the call appears after the\n+  elaboration of the body of F1. Therefore the pragma (1) is safe, and will\n+  remove the warning on the call. It is also possible to use pragma (2)\n+  because there are no other potentially unsafe calls in the block.\n+\n+  The call to `Pure` is safe because this function does not depend on the\n+  state of `Pack2`. Therefore any call to this function is safe, and it\n+  is correct to place pragma (3) in the corresponding package spec.\n+\n+  Finally, we could place pragma (4) in the spec of `Pack2` to disable\n+  warnings on all calls to functions declared therein. Note that this is not\n+  necessarily safe, and requires more detailed examination of the subprogram\n+  bodies involved. In particular, a call to `F2` requires that `F1`\n+  be already elaborated.\n+\n+It is hard to generalize on which of these four approaches should be\n+taken. Obviously if it is possible to fix the program so that the default\n+treatment works, this is preferable, but this may not always be practical.\n+It is certainly simple enough to use *-gnatE*\n+but the danger in this case is that, even if the GNAT binder\n+finds a correct elaboration order, it may not always do so,\n+and certainly a binder from another Ada compiler might not. A\n+combination of testing and analysis (for which the\n+information messages generated with the *-gnatel*\n+switch can be useful) must be used to ensure that the program is free\n+of errors. One switch that is useful in this testing is the\n+*-p (pessimistic elaboration order)* switch for `gnatbind`.\n+Normally the binder tries to find an order that has the best chance\n+of avoiding elaboration problems. However, if this switch is used, the binder\n+plays a devil's advocate role, and tries to choose the order that\n+has the best chance of failing. If your program works even with this\n+switch, then it has a better chance of being error free, but this is still\n+not a guarantee.\n+\n+For an example of this approach in action, consider the C-tests (executable\n+tests) from the ACATS suite. If these are compiled and run with the default\n+treatment, then all but one of them succeed without generating any error\n+diagnostics from the binder. However, there is one test that fails, and\n+this is not surprising, because the whole point of this test is to ensure\n+that the compiler can handle cases where it is impossible to determine\n+a correct order statically, and it checks that an exception is indeed\n+raised at run time.\n+\n+This one test must be compiled and run using the *-gnatE*\n+switch, and then it passes. Alternatively, the entire suite can\n+be run using this switch. It is never wrong to run with the dynamic\n+elaboration switch if your code is correct, and we assume that the\n+C-tests are indeed correct (it is less efficient, but efficiency is\n+not a factor in running the ACATS tests.)\n+\n+\n+.. _Elaboration_for_Indirect_Calls:\n+\n+Elaboration for Indirect Calls\n+==============================\n+\n+.. index:: Dispatching calls\n+.. index:: Indirect calls\n+\n+In rare cases, the static elaboration model fails to prevent\n+dispatching calls to not-yet-elaborated subprograms. In such cases, we\n+fall back to run-time checks; premature calls to any primitive\n+operation of a tagged type before the body of the operation has been\n+elaborated will raise `Program_Error`.\n+\n+Access-to-subprogram types, however, are handled conservatively, and\n+do not require run-time checks. This was not true in earlier versions\n+of the compiler; you can use the *-gnatd.U* debug switch to\n+revert to the old behavior if the new conservative behavior causes\n+elaboration cycles. Here, 'conservative' means that if you do\n+`P'Access` during elaboration, the compiler will assume that you\n+might call `P` indirectly during elaboration, so it adds an\n+implicit `pragma Elaborate_All` on the library unit containing\n+`P`. The *-gnatd.U* switch is safe if you know there are\n+no such calls. If the program worked before, it will continue to work\n+with *-gnatd.U*. But beware that code modifications such as\n+adding an indirect call can cause erroneous behavior in the presence\n+of *-gnatd.U*.\n+\n+\n+.. _Summary_of_Procedures_for_Elaboration_Control:\n+\n+Summary of Procedures for Elaboration Control\n+=============================================\n+\n+.. index:: Elaboration control\n+\n+First, compile your program with the default options, using none of\n+the special elaboration control switches. If the binder successfully\n+binds your program, then you can be confident that, apart from issues\n+raised by the use of access-to-subprogram types and dynamic dispatching,\n+the program is free of elaboration errors. If it is important that the\n+program be portable to other compilers than GNAT, then use the\n+*-gnatel*\n+switch to generate messages about missing `Elaborate` or\n+`Elaborate_All` pragmas, and supply the missing pragmas.\n+\n+If the program fails to bind using the default static elaboration\n+handling, then you can fix the program to eliminate the binder\n+message, or recompile the entire program with the\n+*-gnatE* switch to generate dynamic elaboration checks,\n+and, if you are sure there really are no elaboration problems,\n+use a global pragma `Suppress (Elaboration_Check)`.\n+\n+\n+.. _Other_Elaboration_Order_Considerations:\n+\n+Other Elaboration Order Considerations\n+======================================\n+\n+This section has been entirely concerned with the issue of finding a valid\n+elaboration order, as defined by the Ada Reference Manual. In a case\n+where several elaboration orders are valid, the task is to find one\n+of the possible valid elaboration orders (and the static model in GNAT\n+will ensure that this is achieved).\n+\n+The purpose of the elaboration rules in the Ada Reference Manual is to\n+make sure that no entity is accessed before it has been elaborated. For\n+a subprogram, this means that the spec and body must have been elaborated\n+before the subprogram is called. For an object, this means that the object\n+must have been elaborated before its value is read or written. A violation\n+of either of these two requirements is an access before elaboration order,\n+and this section has been all about avoiding such errors.\n+\n+In the case where more than one order of elaboration is possible, in the\n+sense that access before elaboration errors are avoided, then any one of\n+the orders is 'correct' in the sense that it meets the requirements of\n+the Ada Reference Manual, and no such error occurs.\n+\n+However, it may be the case for a given program, that there are\n+constraints on the order of elaboration that come not from consideration\n+of avoiding elaboration errors, but rather from extra-lingual logic\n+requirements. Consider this example:\n+\n+.. code-block:: ada\n+\n+     with Init_Constants;\n+     package Constants is\n+        X : Integer := 0;\n+        Y : Integer := 0;\n+     end Constants;\n+\n+     package Init_Constants is\n+        procedure P; --* require a body*\n+     end Init_Constants;\n+ \n+     with Constants;\n+     package body Init_Constants is\n+        procedure P is begin null; end;\n+     begin\n+        Constants.X := 3;\n+        Constants.Y := 4;\n+     end Init_Constants;\n+\n+     with Constants;\n+     package Calc is\n+        Z : Integer := Constants.X + Constants.Y;\n+     end Calc;\n+\n+     with Calc;\n+     with Text_IO; use Text_IO;\n+     procedure Main is\n+     begin\n+        Put_Line (Calc.Z'Img);\n+     end Main;\n+  \n+In this example, there is more than one valid order of elaboration. For\n+example both the following are correct orders::\n+\n+     Init_Constants spec\n+     Constants spec\n+     Calc spec\n+     Init_Constants body\n+     Main body\n+\n+and\n+\n+::\n+  \n+    Init_Constants spec\n+    Init_Constants body\n+    Constants spec\n+    Calc spec\n+    Main body\n+  \n+There is no language rule to prefer one or the other, both are correct\n+from an order of elaboration point of view. But the programmatic effects\n+of the two orders are very different. In the first, the elaboration routine\n+of `Calc` initializes `Z` to zero, and then the main program\n+runs with this value of zero. But in the second order, the elaboration\n+routine of `Calc` runs after the body of Init_Constants has set\n+`X` and `Y` and thus `Z` is set to 7 before `Main` runs.\n+\n+One could perhaps by applying pretty clever non-artificial intelligence\n+to the situation guess that it is more likely that the second order of\n+elaboration is the one desired, but there is no formal linguistic reason\n+to prefer one over the other. In fact in this particular case, GNAT will\n+prefer the second order, because of the rule that bodies are elaborated\n+as soon as possible, but it's just luck that this is what was wanted\n+(if indeed the second order was preferred).\n+\n+If the program cares about the order of elaboration routines in a case like\n+this, it is important to specify the order required. In this particular\n+case, that could have been achieved by adding to the spec of Calc:\n+\n+.. code-block:: ada\n+\n+     pragma Elaborate_All (Constants);\n+  \n+which requires that the body (if any) and spec of `Constants`,\n+as well as the body and spec of any unit |withed| by\n+`Constants` be elaborated before `Calc` is elaborated.\n+\n+Clearly no automatic method can always guess which alternative you require,\n+and if you are working with legacy code that had constraints of this kind\n+which were not properly specified by adding `Elaborate` or\n+`Elaborate_All` pragmas, then indeed it is possible that two different\n+compilers can choose different orders.\n+\n+However, GNAT does attempt to diagnose the common situation where there\n+are uninitialized variables in the visible part of a package spec, and the\n+corresponding package body has an elaboration block that directly or\n+indirectly initialized one or more of these variables. This is the situation\n+in which a pragma Elaborate_Body is usually desirable, and GNAT will generate\n+a warning that suggests this addition if it detects this situation.\n+\n+The `gnatbind` *-p* switch may be useful in smoking\n+out problems. This switch causes bodies to be elaborated as late as possible\n+instead of as early as possible. In the example above, it would have forced\n+the choice of the first elaboration order. If you get different results\n+when using this switch, and particularly if one set of results is right,\n+and one is wrong as far as you are concerned, it shows that you have some\n+missing `Elaborate` pragmas. For the example above, we have the\n+following output:\n+\n+.. code-block:: sh\n+\n+     $ gnatmake -f -q main\n+     $ main\n+      7\n+     $ gnatmake -f -q main -bargs -p\n+     $ main\n+      0\n+  \n+It is of course quite unlikely that both these results are correct, so\n+it is up to you in a case like this to investigate the source of the\n+difference, by looking at the two elaboration orders that are chosen,\n+and figuring out which is correct, and then adding the necessary\n+`Elaborate` or `Elaborate_All` pragmas to ensure the desired order.\n+\n+\n+.. _Determining_the_Chosen_Elaboration_Order:\n+\n+Determining the Chosen Elaboration Order\n+========================================\n+\n+To see the elaboration order that the binder chooses, you can look at\n+the last part of the file:`b~xxx.adb` binder output file. Here is an example::\n+\n+     System.Soft_Links'Elab_Body;\n+     E14 := True;\n+     System.Secondary_Stack'Elab_Body;\n+     E18 := True;\n+     System.Exception_Table'Elab_Body;\n+     E24 := True;\n+     Ada.Io_Exceptions'Elab_Spec;\n+     E67 := True;\n+     Ada.Tags'Elab_Spec;\n+     Ada.Streams'Elab_Spec;\n+     E43 := True;\n+     Interfaces.C'Elab_Spec;\n+     E69 := True;\n+     System.Finalization_Root'Elab_Spec;\n+     E60 := True;\n+     System.Os_Lib'Elab_Body;\n+     E71 := True;\n+     System.Finalization_Implementation'Elab_Spec;\n+     System.Finalization_Implementation'Elab_Body;\n+     E62 := True;\n+     Ada.Finalization'Elab_Spec;\n+     E58 := True;\n+     Ada.Finalization.List_Controller'Elab_Spec;\n+     E76 := True;\n+     System.File_Control_Block'Elab_Spec;\n+     E74 := True;\n+     System.File_Io'Elab_Body;\n+     E56 := True;\n+     Ada.Tags'Elab_Body;\n+     E45 := True;\n+     Ada.Text_Io'Elab_Spec;\n+     Ada.Text_Io'Elab_Body;\n+     E07 := True;\n+  \n+Here Elab_Spec elaborates the spec\n+and Elab_Body elaborates the body. The assignments to the :samp:`E{xx}` flags\n+flag that the corresponding body is now elaborated.\n+\n+You can also ask the binder to generate a more\n+readable list of the elaboration order using the\n+`-l` switch when invoking the binder. Here is\n+an example of the output generated by this switch::\n+\n+     ada (spec)\n+     interfaces (spec)\n+     system (spec)\n+     system.case_util (spec)\n+     system.case_util (body)\n+     system.concat_2 (spec)\n+     system.concat_2 (body)\n+     system.concat_3 (spec)\n+     system.concat_3 (body)\n+     system.htable (spec)\n+     system.parameters (spec)\n+     system.parameters (body)\n+     system.crtl (spec)\n+     interfaces.c_streams (spec)\n+     interfaces.c_streams (body)\n+     system.restrictions (spec)\n+     system.restrictions (body)\n+     system.standard_library (spec)\n+     system.exceptions (spec)\n+     system.exceptions (body)\n+     system.storage_elements (spec)\n+     system.storage_elements (body)\n+     system.secondary_stack (spec)\n+     system.stack_checking (spec)\n+     system.stack_checking (body)\n+     system.string_hash (spec)\n+     system.string_hash (body)\n+     system.htable (body)\n+     system.strings (spec)\n+     system.strings (body)\n+     system.traceback (spec)\n+     system.traceback (body)\n+     system.traceback_entries (spec)\n+     system.traceback_entries (body)\n+     ada.exceptions (spec)\n+     ada.exceptions.last_chance_handler (spec)\n+     system.soft_links (spec)\n+     system.soft_links (body)\n+     ada.exceptions.last_chance_handler (body)\n+     system.secondary_stack (body)\n+     system.exception_table (spec)\n+     system.exception_table (body)\n+     ada.io_exceptions (spec)\n+     ada.tags (spec)\n+     ada.streams (spec)\n+     interfaces.c (spec)\n+     interfaces.c (body)\n+     system.finalization_root (spec)\n+     system.finalization_root (body)\n+     system.memory (spec)\n+     system.memory (body)\n+     system.standard_library (body)\n+     system.os_lib (spec)\n+     system.os_lib (body)\n+     system.unsigned_types (spec)\n+     system.stream_attributes (spec)\n+     system.stream_attributes (body)\n+     system.finalization_implementation (spec)\n+     system.finalization_implementation (body)\n+     ada.finalization (spec)\n+     ada.finalization (body)\n+     ada.finalization.list_controller (spec)\n+     ada.finalization.list_controller (body)\n+     system.file_control_block (spec)\n+     system.file_io (spec)\n+     system.file_io (body)\n+     system.val_uns (spec)\n+     system.val_util (spec)\n+     system.val_util (body)\n+     system.val_uns (body)\n+     system.wch_con (spec)\n+     system.wch_con (body)\n+     system.wch_cnv (spec)\n+     system.wch_jis (spec)\n+     system.wch_jis (body)\n+     system.wch_cnv (body)\n+     system.wch_stw (spec)\n+     system.wch_stw (body)\n+     ada.tags (body)\n+     ada.exceptions (body)\n+     ada.text_io (spec)\n+     ada.text_io (body)\n+     text_io (spec)\n+     gdbstr (body)"}, {"sha": "b2c34c0b82052044adb8aab728c96f908b569cc6", "filename": "gcc/ada/doc/gnat_ugn/example_of_binder_output.rst", "status": "added", "additions": 750, "deletions": 0, "changes": 750, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fexample_of_binder_output.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fexample_of_binder_output.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fexample_of_binder_output.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,750 @@\n+.. _Example_of_Binder_Output_File:\n+\n+*****************************\n+Example of Binder Output File\n+*****************************\n+\n+.. index:: Binder output (example)\n+\n+This Appendix displays the source code for the output file\n+generated by *gnatbind* for a simple 'Hello World' program.\n+Comments have been added for clarification purposes.\n+\n+\n+.. code-block:: ada\n+\n+  --  The package is called Ada_Main unless this name is actually used\n+  --  as a unit name in the partition, in which case some other unique\n+  --  name is used.\n+\n+  pragma Ada_95;\n+  with System;\n+  package ada_main is\n+     pragma Warnings (Off);\n+\n+     --  The main program saves the parameters (argument count,\n+     --  argument values, environment pointer) in global variables\n+     --  for later access by other units including\n+     --  Ada.Command_Line.\n+\n+     gnat_argc : Integer;\n+     gnat_argv : System.Address;\n+     gnat_envp : System.Address;\n+\n+     --  The actual variables are stored in a library routine. This\n+     --  is useful for some shared library situations, where there\n+     --  are problems if variables are not in the library.\n+\n+     pragma Import (C, gnat_argc);\n+     pragma Import (C, gnat_argv);\n+     pragma Import (C, gnat_envp);\n+\n+     --  The exit status is similarly an external location\n+\n+     gnat_exit_status : Integer;\n+     pragma Import (C, gnat_exit_status);\n+\n+     GNAT_Version : constant String :=\n+                      \"GNAT Version: Pro 7.4.0w (20141119-49)\" & ASCII.NUL;\n+     pragma Export (C, GNAT_Version, \"__gnat_version\");\n+\n+     Ada_Main_Program_Name : constant String := \"_ada_hello\" & ASCII.NUL;\n+     pragma Export (C, Ada_Main_Program_Name, \"__gnat_ada_main_program_name\");\n+\n+     --  This is the generated adainit routine that performs\n+     --  initialization at the start of execution. In the case\n+     --  where Ada is the main program, this main program makes\n+     --  a call to adainit at program startup.\n+\n+     procedure adainit;\n+     pragma Export (C, adainit, \"adainit\");\n+\n+     --  This is the generated adafinal routine that performs\n+     --  finalization at the end of execution. In the case where\n+     --  Ada is the main program, this main program makes a call\n+     --  to adafinal at program termination.\n+\n+     procedure adafinal;\n+     pragma Export (C, adafinal, \"adafinal\");\n+\n+     --  This routine is called at the start of execution. It is\n+     --  a dummy routine that is used by the debugger to breakpoint\n+     --  at the start of execution.\n+\n+     --  This is the actual generated main program (it would be\n+     --  suppressed if the no main program switch were used). As\n+     --  required by standard system conventions, this program has\n+     --  the external name main.\n+\n+     function main\n+       (argc : Integer;\n+        argv : System.Address;\n+        envp : System.Address)\n+        return Integer;\n+     pragma Export (C, main, \"main\");\n+\n+     --  The following set of constants give the version\n+     --  identification values for every unit in the bound\n+     --  partition. This identification is computed from all\n+     --  dependent semantic units, and corresponds to the\n+     --  string that would be returned by use of the\n+     --  Body_Version or Version attributes.\n+\n+     --  The following Export pragmas export the version numbers\n+     --  with symbolic names ending in B (for body) or S\n+     --  (for spec) so that they can be located in a link. The\n+     --  information provided here is sufficient to track down\n+     --  the exact versions of units used in a given build.\n+\n+     type Version_32 is mod 2 ** 32;\n+     u00001 : constant Version_32 := 16#8ad6e54a#;\n+     pragma Export (C, u00001, \"helloB\");\n+     u00002 : constant Version_32 := 16#fbff4c67#;\n+     pragma Export (C, u00002, \"system__standard_libraryB\");\n+     u00003 : constant Version_32 := 16#1ec6fd90#;\n+     pragma Export (C, u00003, \"system__standard_libraryS\");\n+     u00004 : constant Version_32 := 16#3ffc8e18#;\n+     pragma Export (C, u00004, \"adaS\");\n+     u00005 : constant Version_32 := 16#28f088c2#;\n+     pragma Export (C, u00005, \"ada__text_ioB\");\n+     u00006 : constant Version_32 := 16#f372c8ac#;\n+     pragma Export (C, u00006, \"ada__text_ioS\");\n+     u00007 : constant Version_32 := 16#2c143749#;\n+     pragma Export (C, u00007, \"ada__exceptionsB\");\n+     u00008 : constant Version_32 := 16#f4f0cce8#;\n+     pragma Export (C, u00008, \"ada__exceptionsS\");\n+     u00009 : constant Version_32 := 16#a46739c0#;\n+     pragma Export (C, u00009, \"ada__exceptions__last_chance_handlerB\");\n+     u00010 : constant Version_32 := 16#3aac8c92#;\n+     pragma Export (C, u00010, \"ada__exceptions__last_chance_handlerS\");\n+     u00011 : constant Version_32 := 16#1d274481#;\n+     pragma Export (C, u00011, \"systemS\");\n+     u00012 : constant Version_32 := 16#a207fefe#;\n+     pragma Export (C, u00012, \"system__soft_linksB\");\n+     u00013 : constant Version_32 := 16#467d9556#;\n+     pragma Export (C, u00013, \"system__soft_linksS\");\n+     u00014 : constant Version_32 := 16#b01dad17#;\n+     pragma Export (C, u00014, \"system__parametersB\");\n+     u00015 : constant Version_32 := 16#630d49fe#;\n+     pragma Export (C, u00015, \"system__parametersS\");\n+     u00016 : constant Version_32 := 16#b19b6653#;\n+     pragma Export (C, u00016, \"system__secondary_stackB\");\n+     u00017 : constant Version_32 := 16#b6468be8#;\n+     pragma Export (C, u00017, \"system__secondary_stackS\");\n+     u00018 : constant Version_32 := 16#39a03df9#;\n+     pragma Export (C, u00018, \"system__storage_elementsB\");\n+     u00019 : constant Version_32 := 16#30e40e85#;\n+     pragma Export (C, u00019, \"system__storage_elementsS\");\n+     u00020 : constant Version_32 := 16#41837d1e#;\n+     pragma Export (C, u00020, \"system__stack_checkingB\");\n+     u00021 : constant Version_32 := 16#93982f69#;\n+     pragma Export (C, u00021, \"system__stack_checkingS\");\n+     u00022 : constant Version_32 := 16#393398c1#;\n+     pragma Export (C, u00022, \"system__exception_tableB\");\n+     u00023 : constant Version_32 := 16#b33e2294#;\n+     pragma Export (C, u00023, \"system__exception_tableS\");\n+     u00024 : constant Version_32 := 16#ce4af020#;\n+     pragma Export (C, u00024, \"system__exceptionsB\");\n+     u00025 : constant Version_32 := 16#75442977#;\n+     pragma Export (C, u00025, \"system__exceptionsS\");\n+     u00026 : constant Version_32 := 16#37d758f1#;\n+     pragma Export (C, u00026, \"system__exceptions__machineS\");\n+     u00027 : constant Version_32 := 16#b895431d#;\n+     pragma Export (C, u00027, \"system__exceptions_debugB\");\n+     u00028 : constant Version_32 := 16#aec55d3f#;\n+     pragma Export (C, u00028, \"system__exceptions_debugS\");\n+     u00029 : constant Version_32 := 16#570325c8#;\n+     pragma Export (C, u00029, \"system__img_intB\");\n+     u00030 : constant Version_32 := 16#1ffca443#;\n+     pragma Export (C, u00030, \"system__img_intS\");\n+     u00031 : constant Version_32 := 16#b98c3e16#;\n+     pragma Export (C, u00031, \"system__tracebackB\");\n+     u00032 : constant Version_32 := 16#831a9d5a#;\n+     pragma Export (C, u00032, \"system__tracebackS\");\n+     u00033 : constant Version_32 := 16#9ed49525#;\n+     pragma Export (C, u00033, \"system__traceback_entriesB\");\n+     u00034 : constant Version_32 := 16#1d7cb2f1#;\n+     pragma Export (C, u00034, \"system__traceback_entriesS\");\n+     u00035 : constant Version_32 := 16#8c33a517#;\n+     pragma Export (C, u00035, \"system__wch_conB\");\n+     u00036 : constant Version_32 := 16#065a6653#;\n+     pragma Export (C, u00036, \"system__wch_conS\");\n+     u00037 : constant Version_32 := 16#9721e840#;\n+     pragma Export (C, u00037, \"system__wch_stwB\");\n+     u00038 : constant Version_32 := 16#2b4b4a52#;\n+     pragma Export (C, u00038, \"system__wch_stwS\");\n+     u00039 : constant Version_32 := 16#92b797cb#;\n+     pragma Export (C, u00039, \"system__wch_cnvB\");\n+     u00040 : constant Version_32 := 16#09eddca0#;\n+     pragma Export (C, u00040, \"system__wch_cnvS\");\n+     u00041 : constant Version_32 := 16#6033a23f#;\n+     pragma Export (C, u00041, \"interfacesS\");\n+     u00042 : constant Version_32 := 16#ece6fdb6#;\n+     pragma Export (C, u00042, \"system__wch_jisB\");\n+     u00043 : constant Version_32 := 16#899dc581#;\n+     pragma Export (C, u00043, \"system__wch_jisS\");\n+     u00044 : constant Version_32 := 16#10558b11#;\n+     pragma Export (C, u00044, \"ada__streamsB\");\n+     u00045 : constant Version_32 := 16#2e6701ab#;\n+     pragma Export (C, u00045, \"ada__streamsS\");\n+     u00046 : constant Version_32 := 16#db5c917c#;\n+     pragma Export (C, u00046, \"ada__io_exceptionsS\");\n+     u00047 : constant Version_32 := 16#12c8cd7d#;\n+     pragma Export (C, u00047, \"ada__tagsB\");\n+     u00048 : constant Version_32 := 16#ce72c228#;\n+     pragma Export (C, u00048, \"ada__tagsS\");\n+     u00049 : constant Version_32 := 16#c3335bfd#;\n+     pragma Export (C, u00049, \"system__htableB\");\n+     u00050 : constant Version_32 := 16#99e5f76b#;\n+     pragma Export (C, u00050, \"system__htableS\");\n+     u00051 : constant Version_32 := 16#089f5cd0#;\n+     pragma Export (C, u00051, \"system__string_hashB\");\n+     u00052 : constant Version_32 := 16#3bbb9c15#;\n+     pragma Export (C, u00052, \"system__string_hashS\");\n+     u00053 : constant Version_32 := 16#807fe041#;\n+     pragma Export (C, u00053, \"system__unsigned_typesS\");\n+     u00054 : constant Version_32 := 16#d27be59e#;\n+     pragma Export (C, u00054, \"system__val_lluB\");\n+     u00055 : constant Version_32 := 16#fa8db733#;\n+     pragma Export (C, u00055, \"system__val_lluS\");\n+     u00056 : constant Version_32 := 16#27b600b2#;\n+     pragma Export (C, u00056, \"system__val_utilB\");\n+     u00057 : constant Version_32 := 16#b187f27f#;\n+     pragma Export (C, u00057, \"system__val_utilS\");\n+     u00058 : constant Version_32 := 16#d1060688#;\n+     pragma Export (C, u00058, \"system__case_utilB\");\n+     u00059 : constant Version_32 := 16#392e2d56#;\n+     pragma Export (C, u00059, \"system__case_utilS\");\n+     u00060 : constant Version_32 := 16#84a27f0d#;\n+     pragma Export (C, u00060, \"interfaces__c_streamsB\");\n+     u00061 : constant Version_32 := 16#8bb5f2c0#;\n+     pragma Export (C, u00061, \"interfaces__c_streamsS\");\n+     u00062 : constant Version_32 := 16#6db6928f#;\n+     pragma Export (C, u00062, \"system__crtlS\");\n+     u00063 : constant Version_32 := 16#4e6a342b#;\n+     pragma Export (C, u00063, \"system__file_ioB\");\n+     u00064 : constant Version_32 := 16#ba56a5e4#;\n+     pragma Export (C, u00064, \"system__file_ioS\");\n+     u00065 : constant Version_32 := 16#b7ab275c#;\n+     pragma Export (C, u00065, \"ada__finalizationB\");\n+     u00066 : constant Version_32 := 16#19f764ca#;\n+     pragma Export (C, u00066, \"ada__finalizationS\");\n+     u00067 : constant Version_32 := 16#95817ed8#;\n+     pragma Export (C, u00067, \"system__finalization_rootB\");\n+     u00068 : constant Version_32 := 16#52d53711#;\n+     pragma Export (C, u00068, \"system__finalization_rootS\");\n+     u00069 : constant Version_32 := 16#769e25e6#;\n+     pragma Export (C, u00069, \"interfaces__cB\");\n+     u00070 : constant Version_32 := 16#4a38bedb#;\n+     pragma Export (C, u00070, \"interfaces__cS\");\n+     u00071 : constant Version_32 := 16#07e6ee66#;\n+     pragma Export (C, u00071, \"system__os_libB\");\n+     u00072 : constant Version_32 := 16#d7b69782#;\n+     pragma Export (C, u00072, \"system__os_libS\");\n+     u00073 : constant Version_32 := 16#1a817b8e#;\n+     pragma Export (C, u00073, \"system__stringsB\");\n+     u00074 : constant Version_32 := 16#639855e7#;\n+     pragma Export (C, u00074, \"system__stringsS\");\n+     u00075 : constant Version_32 := 16#e0b8de29#;\n+     pragma Export (C, u00075, \"system__file_control_blockS\");\n+     u00076 : constant Version_32 := 16#b5b2aca1#;\n+     pragma Export (C, u00076, \"system__finalization_mastersB\");\n+     u00077 : constant Version_32 := 16#69316dc1#;\n+     pragma Export (C, u00077, \"system__finalization_mastersS\");\n+     u00078 : constant Version_32 := 16#57a37a42#;\n+     pragma Export (C, u00078, \"system__address_imageB\");\n+     u00079 : constant Version_32 := 16#bccbd9bb#;\n+     pragma Export (C, u00079, \"system__address_imageS\");\n+     u00080 : constant Version_32 := 16#7268f812#;\n+     pragma Export (C, u00080, \"system__img_boolB\");\n+     u00081 : constant Version_32 := 16#e8fe356a#;\n+     pragma Export (C, u00081, \"system__img_boolS\");\n+     u00082 : constant Version_32 := 16#d7aac20c#;\n+     pragma Export (C, u00082, \"system__ioB\");\n+     u00083 : constant Version_32 := 16#8365b3ce#;\n+     pragma Export (C, u00083, \"system__ioS\");\n+     u00084 : constant Version_32 := 16#6d4d969a#;\n+     pragma Export (C, u00084, \"system__storage_poolsB\");\n+     u00085 : constant Version_32 := 16#e87cc305#;\n+     pragma Export (C, u00085, \"system__storage_poolsS\");\n+     u00086 : constant Version_32 := 16#e34550ca#;\n+     pragma Export (C, u00086, \"system__pool_globalB\");\n+     u00087 : constant Version_32 := 16#c88d2d16#;\n+     pragma Export (C, u00087, \"system__pool_globalS\");\n+     u00088 : constant Version_32 := 16#9d39c675#;\n+     pragma Export (C, u00088, \"system__memoryB\");\n+     u00089 : constant Version_32 := 16#445a22b5#;\n+     pragma Export (C, u00089, \"system__memoryS\");\n+     u00090 : constant Version_32 := 16#6a859064#;\n+     pragma Export (C, u00090, \"system__storage_pools__subpoolsB\");\n+     u00091 : constant Version_32 := 16#e3b008dc#;\n+     pragma Export (C, u00091, \"system__storage_pools__subpoolsS\");\n+     u00092 : constant Version_32 := 16#63f11652#;\n+     pragma Export (C, u00092, \"system__storage_pools__subpools__finalizationB\");\n+     u00093 : constant Version_32 := 16#fe2f4b3a#;\n+     pragma Export (C, u00093, \"system__storage_pools__subpools__finalizationS\");\n+\n+     --  BEGIN ELABORATION ORDER\n+     --  ada%s\n+     --  interfaces%s\n+     --  system%s\n+     --  system.case_util%s\n+     --  system.case_util%b\n+     --  system.htable%s\n+     --  system.img_bool%s\n+     --  system.img_bool%b\n+     --  system.img_int%s\n+     --  system.img_int%b\n+     --  system.io%s\n+     --  system.io%b\n+     --  system.parameters%s\n+     --  system.parameters%b\n+     --  system.crtl%s\n+     --  interfaces.c_streams%s\n+     --  interfaces.c_streams%b\n+     --  system.standard_library%s\n+     --  system.exceptions_debug%s\n+     --  system.exceptions_debug%b\n+     --  system.storage_elements%s\n+     --  system.storage_elements%b\n+     --  system.stack_checking%s\n+     --  system.stack_checking%b\n+     --  system.string_hash%s\n+     --  system.string_hash%b\n+     --  system.htable%b\n+     --  system.strings%s\n+     --  system.strings%b\n+     --  system.os_lib%s\n+     --  system.traceback_entries%s\n+     --  system.traceback_entries%b\n+     --  ada.exceptions%s\n+     --  system.soft_links%s\n+     --  system.unsigned_types%s\n+     --  system.val_llu%s\n+     --  system.val_util%s\n+     --  system.val_util%b\n+     --  system.val_llu%b\n+     --  system.wch_con%s\n+     --  system.wch_con%b\n+     --  system.wch_cnv%s\n+     --  system.wch_jis%s\n+     --  system.wch_jis%b\n+     --  system.wch_cnv%b\n+     --  system.wch_stw%s\n+     --  system.wch_stw%b\n+     --  ada.exceptions.last_chance_handler%s\n+     --  ada.exceptions.last_chance_handler%b\n+     --  system.address_image%s\n+     --  system.exception_table%s\n+     --  system.exception_table%b\n+     --  ada.io_exceptions%s\n+     --  ada.tags%s\n+     --  ada.streams%s\n+     --  ada.streams%b\n+     --  interfaces.c%s\n+     --  system.exceptions%s\n+     --  system.exceptions%b\n+     --  system.exceptions.machine%s\n+     --  system.finalization_root%s\n+     --  system.finalization_root%b\n+     --  ada.finalization%s\n+     --  ada.finalization%b\n+     --  system.storage_pools%s\n+     --  system.storage_pools%b\n+     --  system.finalization_masters%s\n+     --  system.storage_pools.subpools%s\n+     --  system.storage_pools.subpools.finalization%s\n+     --  system.storage_pools.subpools.finalization%b\n+     --  system.memory%s\n+     --  system.memory%b\n+     --  system.standard_library%b\n+     --  system.pool_global%s\n+     --  system.pool_global%b\n+     --  system.file_control_block%s\n+     --  system.file_io%s\n+     --  system.secondary_stack%s\n+     --  system.file_io%b\n+     --  system.storage_pools.subpools%b\n+     --  system.finalization_masters%b\n+     --  interfaces.c%b\n+     --  ada.tags%b\n+     --  system.soft_links%b\n+     --  system.os_lib%b\n+     --  system.secondary_stack%b\n+     --  system.address_image%b\n+     --  system.traceback%s\n+     --  ada.exceptions%b\n+     --  system.traceback%b\n+     --  ada.text_io%s\n+     --  ada.text_io%b\n+     --  hello%b\n+     --  END ELABORATION ORDER\n+\n+  end ada_main;\n+\n+.. code-block:: ada\n+\n+  pragma Ada_95;\n+  --  The following source file name pragmas allow the generated file\n+  --  names to be unique for different main programs. They are needed\n+  --  since the package name will always be Ada_Main.\n+\n+  pragma Source_File_Name (ada_main, Spec_File_Name => \"b~hello.ads\");\n+  pragma Source_File_Name (ada_main, Body_File_Name => \"b~hello.adb\");\n+\n+  pragma Suppress (Overflow_Check);\n+  with Ada.Exceptions;\n+\n+  --  Generated package body for Ada_Main starts here\n+\n+  package body ada_main is\n+     pragma Warnings (Off);\n+\n+     --  These values are reference counter associated to units which have\n+     --  been elaborated. It is also used to avoid elaborating the\n+     --  same unit twice.\n+\n+     E72 : Short_Integer; pragma Import (Ada, E72, \"system__os_lib_E\");\n+     E13 : Short_Integer; pragma Import (Ada, E13, \"system__soft_links_E\");\n+     E23 : Short_Integer; pragma Import (Ada, E23, \"system__exception_table_E\");\n+     E46 : Short_Integer; pragma Import (Ada, E46, \"ada__io_exceptions_E\");\n+     E48 : Short_Integer; pragma Import (Ada, E48, \"ada__tags_E\");\n+     E45 : Short_Integer; pragma Import (Ada, E45, \"ada__streams_E\");\n+     E70 : Short_Integer; pragma Import (Ada, E70, \"interfaces__c_E\");\n+     E25 : Short_Integer; pragma Import (Ada, E25, \"system__exceptions_E\");\n+     E68 : Short_Integer; pragma Import (Ada, E68, \"system__finalization_root_E\");\n+     E66 : Short_Integer; pragma Import (Ada, E66, \"ada__finalization_E\");\n+     E85 : Short_Integer; pragma Import (Ada, E85, \"system__storage_pools_E\");\n+     E77 : Short_Integer; pragma Import (Ada, E77, \"system__finalization_masters_E\");\n+     E91 : Short_Integer; pragma Import (Ada, E91, \"system__storage_pools__subpools_E\");\n+     E87 : Short_Integer; pragma Import (Ada, E87, \"system__pool_global_E\");\n+     E75 : Short_Integer; pragma Import (Ada, E75, \"system__file_control_block_E\");\n+     E64 : Short_Integer; pragma Import (Ada, E64, \"system__file_io_E\");\n+     E17 : Short_Integer; pragma Import (Ada, E17, \"system__secondary_stack_E\");\n+     E06 : Short_Integer; pragma Import (Ada, E06, \"ada__text_io_E\");\n+\n+     Local_Priority_Specific_Dispatching : constant String := \"\";\n+     Local_Interrupt_States : constant String := \"\";\n+\n+     Is_Elaborated : Boolean := False;\n+\n+     procedure finalize_library is\n+     begin\n+        E06 := E06 - 1;\n+        declare\n+           procedure F1;\n+           pragma Import (Ada, F1, \"ada__text_io__finalize_spec\");\n+        begin\n+           F1;\n+        end;\n+        E77 := E77 - 1;\n+        E91 := E91 - 1;\n+        declare\n+           procedure F2;\n+           pragma Import (Ada, F2, \"system__file_io__finalize_body\");\n+        begin\n+           E64 := E64 - 1;\n+           F2;\n+        end;\n+        declare\n+           procedure F3;\n+           pragma Import (Ada, F3, \"system__file_control_block__finalize_spec\");\n+        begin\n+           E75 := E75 - 1;\n+           F3;\n+        end;\n+        E87 := E87 - 1;\n+        declare\n+           procedure F4;\n+           pragma Import (Ada, F4, \"system__pool_global__finalize_spec\");\n+        begin\n+           F4;\n+        end;\n+        declare\n+           procedure F5;\n+           pragma Import (Ada, F5, \"system__storage_pools__subpools__finalize_spec\");\n+        begin\n+           F5;\n+        end;\n+        declare\n+           procedure F6;\n+           pragma Import (Ada, F6, \"system__finalization_masters__finalize_spec\");\n+        begin\n+           F6;\n+        end;\n+        declare\n+           procedure Reraise_Library_Exception_If_Any;\n+           pragma Import (Ada, Reraise_Library_Exception_If_Any, \"__gnat_reraise_library_exception_if_any\");\n+        begin\n+           Reraise_Library_Exception_If_Any;\n+        end;\n+     end finalize_library;\n+\n+     -------------\n+     -- adainit --\n+     -------------\n+\n+     procedure adainit is\n+\n+        Main_Priority : Integer;\n+        pragma Import (C, Main_Priority, \"__gl_main_priority\");\n+        Time_Slice_Value : Integer;\n+        pragma Import (C, Time_Slice_Value, \"__gl_time_slice_val\");\n+        WC_Encoding : Character;\n+        pragma Import (C, WC_Encoding, \"__gl_wc_encoding\");\n+        Locking_Policy : Character;\n+        pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n+        Queuing_Policy : Character;\n+        pragma Import (C, Queuing_Policy, \"__gl_queuing_policy\");\n+        Task_Dispatching_Policy : Character;\n+        pragma Import (C, Task_Dispatching_Policy, \"__gl_task_dispatching_policy\");\n+        Priority_Specific_Dispatching : System.Address;\n+        pragma Import (C, Priority_Specific_Dispatching, \"__gl_priority_specific_dispatching\");\n+        Num_Specific_Dispatching : Integer;\n+        pragma Import (C, Num_Specific_Dispatching, \"__gl_num_specific_dispatching\");\n+        Main_CPU : Integer;\n+        pragma Import (C, Main_CPU, \"__gl_main_cpu\");\n+        Interrupt_States : System.Address;\n+        pragma Import (C, Interrupt_States, \"__gl_interrupt_states\");\n+        Num_Interrupt_States : Integer;\n+        pragma Import (C, Num_Interrupt_States, \"__gl_num_interrupt_states\");\n+        Unreserve_All_Interrupts : Integer;\n+        pragma Import (C, Unreserve_All_Interrupts, \"__gl_unreserve_all_interrupts\");\n+        Detect_Blocking : Integer;\n+        pragma Import (C, Detect_Blocking, \"__gl_detect_blocking\");\n+        Default_Stack_Size : Integer;\n+        pragma Import (C, Default_Stack_Size, \"__gl_default_stack_size\");\n+        Leap_Seconds_Support : Integer;\n+        pragma Import (C, Leap_Seconds_Support, \"__gl_leap_seconds_support\");\n+\n+        procedure Runtime_Initialize;\n+        pragma Import (C, Runtime_Initialize, \"__gnat_runtime_initialize\");\n+\n+        Finalize_Library_Objects : No_Param_Proc;\n+        pragma Import (C, Finalize_Library_Objects, \"__gnat_finalize_library_objects\");\n+\n+     --  Start of processing for adainit\n+\n+     begin\n+\n+        --  Record various information for this partition.  The values\n+        --  are derived by the binder from information stored in the ali\n+        --  files by the compiler.\n+\n+        if Is_Elaborated then\n+           return;\n+        end if;\n+        Is_Elaborated := True;\n+        Main_Priority := -1;\n+        Time_Slice_Value := -1;\n+        WC_Encoding := 'b';\n+        Locking_Policy := ' ';\n+        Queuing_Policy := ' ';\n+        Task_Dispatching_Policy := ' ';\n+        Priority_Specific_Dispatching :=\n+          Local_Priority_Specific_Dispatching'Address;\n+        Num_Specific_Dispatching := 0;\n+        Main_CPU := -1;\n+        Interrupt_States := Local_Interrupt_States'Address;\n+        Num_Interrupt_States := 0;\n+        Unreserve_All_Interrupts := 0;\n+        Detect_Blocking := 0;\n+        Default_Stack_Size := -1;\n+        Leap_Seconds_Support := 0;\n+\n+        Runtime_Initialize;\n+\n+        Finalize_Library_Objects := finalize_library'access;\n+\n+        --  Now we have the elaboration calls for all units in the partition.\n+        --  The Elab_Spec and Elab_Body attributes generate references to the\n+        --  implicit elaboration procedures generated by the compiler for\n+        --  each unit that requires elaboration. Increment a counter of\n+        --  reference for each unit.\n+\n+        System.Soft_Links'Elab_Spec;\n+        System.Exception_Table'Elab_Body;\n+        E23 := E23 + 1;\n+        Ada.Io_Exceptions'Elab_Spec;\n+        E46 := E46 + 1;\n+        Ada.Tags'Elab_Spec;\n+        Ada.Streams'Elab_Spec;\n+        E45 := E45 + 1;\n+        Interfaces.C'Elab_Spec;\n+        System.Exceptions'Elab_Spec;\n+        E25 := E25 + 1;\n+        System.Finalization_Root'Elab_Spec;\n+        E68 := E68 + 1;\n+        Ada.Finalization'Elab_Spec;\n+        E66 := E66 + 1;\n+        System.Storage_Pools'Elab_Spec;\n+        E85 := E85 + 1;\n+        System.Finalization_Masters'Elab_Spec;\n+        System.Storage_Pools.Subpools'Elab_Spec;\n+        System.Pool_Global'Elab_Spec;\n+        E87 := E87 + 1;\n+        System.File_Control_Block'Elab_Spec;\n+        E75 := E75 + 1;\n+        System.File_Io'Elab_Body;\n+        E64 := E64 + 1;\n+        E91 := E91 + 1;\n+        System.Finalization_Masters'Elab_Body;\n+        E77 := E77 + 1;\n+        E70 := E70 + 1;\n+        Ada.Tags'Elab_Body;\n+        E48 := E48 + 1;\n+        System.Soft_Links'Elab_Body;\n+        E13 := E13 + 1;\n+        System.Os_Lib'Elab_Body;\n+        E72 := E72 + 1;\n+        System.Secondary_Stack'Elab_Body;\n+        E17 := E17 + 1;\n+        Ada.Text_Io'Elab_Spec;\n+        Ada.Text_Io'Elab_Body;\n+        E06 := E06 + 1;\n+     end adainit;\n+\n+     --------------\n+     -- adafinal --\n+     --------------\n+\n+     procedure adafinal is\n+        procedure s_stalib_adafinal;\n+        pragma Import (C, s_stalib_adafinal, \"system__standard_library__adafinal\");\n+\n+        procedure Runtime_Finalize;\n+        pragma Import (C, Runtime_Finalize, \"__gnat_runtime_finalize\");\n+\n+     begin\n+        if not Is_Elaborated then\n+           return;\n+        end if;\n+        Is_Elaborated := False;\n+        Runtime_Finalize;\n+        s_stalib_adafinal;\n+     end adafinal;\n+\n+     --  We get to the main program of the partition by using\n+     --  pragma Import because if we try to with the unit and\n+     --  call it Ada style, then not only do we waste time\n+     --  recompiling it, but also, we don't really know the right\n+     --  switches (e.g.@: identifier character set) to be used\n+     --  to compile it.\n+\n+     procedure Ada_Main_Program;\n+     pragma Import (Ada, Ada_Main_Program, \"_ada_hello\");\n+\n+     ----------\n+     -- main --\n+     ----------\n+\n+     --  main is actually a function, as in the ANSI C standard,\n+     --  defined to return the exit status. The three parameters\n+     --  are the argument count, argument values and environment\n+     --  pointer.\n+\n+     function main\n+       (argc : Integer;\n+        argv : System.Address;\n+        envp : System.Address)\n+        return Integer\n+     is\n+        --  The initialize routine performs low level system\n+        --  initialization using a standard library routine which\n+        --  sets up signal handling and performs any other\n+        --  required setup. The routine can be found in file\n+        --  a-init.c.\n+\n+        procedure initialize;\n+        pragma Import (C, initialize, \"__gnat_initialize\");\n+\n+        --  The finalize routine performs low level system\n+        --  finalization using a standard library routine. The\n+        --  routine is found in file a-final.c and in the standard\n+        --  distribution is a dummy routine that does nothing, so\n+        --  really this is a hook for special user finalization.\n+\n+        procedure finalize;\n+        pragma Import (C, finalize, \"__gnat_finalize\");\n+\n+        --  The following is to initialize the SEH exceptions\n+\n+        SEH : aliased array (1 .. 2) of Integer;\n+\n+        Ensure_Reference : aliased System.Address := Ada_Main_Program_Name'Address;\n+        pragma Volatile (Ensure_Reference);\n+\n+     --  Start of processing for main\n+\n+     begin\n+        --  Save global variables\n+\n+        gnat_argc := argc;\n+        gnat_argv := argv;\n+        gnat_envp := envp;\n+\n+        --  Call low level system initialization\n+\n+        Initialize (SEH'Address);\n+\n+        --  Call our generated Ada initialization routine\n+\n+        adainit;\n+\n+        --  Now we call the main program of the partition\n+\n+        Ada_Main_Program;\n+\n+        --  Perform Ada finalization\n+\n+        adafinal;\n+\n+        --  Perform low level system finalization\n+\n+        Finalize;\n+\n+        --  Return the proper exit status\n+        return (gnat_exit_status);\n+     end;\n+\n+  --  This section is entirely comments, so it has no effect on the\n+  --  compilation of the Ada_Main package. It provides the list of\n+  --  object files and linker options, as well as some standard\n+  --  libraries needed for the link. The gnatlink utility parses\n+  --  this b~hello.adb file to read these comment lines to generate\n+  --  the appropriate command line arguments for the call to the\n+  --  system linker. The BEGIN/END lines are used for sentinels for\n+  --  this parsing operation.\n+\n+  --  The exact file names will of course depend on the environment,\n+  --  host/target and location of files on the host system.\n+\n+  -- BEGIN Object file/option list\n+     --   ./hello.o\n+     --   -L./\n+     --   -L/usr/local/gnat/lib/gcc-lib/i686-pc-linux-gnu/2.8.1/adalib/\n+     --   /usr/local/gnat/lib/gcc-lib/i686-pc-linux-gnu/2.8.1/adalib/libgnat.a\n+  -- END Object file/option list\n+\n+  end ada_main;\n+  \n+\n+The Ada code in the above example is exactly what is generated by the\n+binder. We have added comments to more clearly indicate the function\n+of each part of the generated `Ada_Main` package.\n+\n+The code is standard Ada in all respects, and can be processed by any\n+tools that handle Ada. In particular, it is possible to use the debugger\n+in Ada mode to debug the generated `Ada_Main` package. For example,\n+suppose that for reasons that you do not understand, your program is crashing\n+during elaboration of the body of `Ada.Text_IO`. To locate this bug,\n+you can place a breakpoint on the call:\n+\n+  .. code-block:: ada\n+\n+     Ada.Text_Io'Elab_Body;\n+  \n+and trace the elaboration routine for this package to find out where\n+the problem might be (more usually of course you would be debugging\n+elaboration code in your own application).\n+"}, {"sha": "fcfb07875e493866b5df2c215f8698835f8ff81b", "filename": "gcc/ada/doc/gnat_ugn/getting_started_with_gnat.rst", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgetting_started_with_gnat.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgetting_started_with_gnat.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgetting_started_with_gnat.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1", "patch": "@@ -0,0 +1,276 @@\n+.. _Getting_Started_with_GNAT:\n+\n+*************************\n+Getting Started with GNAT\n+*************************\n+\n+This chapter describes how to use GNAT's command line interface to build\n+executable Ada programs.\n+On most platforms a visually oriented Integrated Development Environment\n+is also available, the GNAT Programming Studio (GPS).\n+GPS offers a graphical \"look and feel\", support for development in\n+other programming languages, comprehensive browsing features, and\n+many other capabilities.\n+For information on GPS please refer to\n+:title:`Using the GNAT Programming Studio`.\n+\n+\n+.. _Running_GNAT:\n+\n+Running GNAT\n+============\n+\n+Three steps are needed to create an executable file from an Ada source\n+file:\n+\n+*   The source file(s) must be compiled.\n+*   The file(s) must be bound using the GNAT binder.\n+*   All appropriate object files must be linked to produce an executable.\n+\n+All three steps are most commonly handled by using the *gnatmake*\n+utility program that, given the name of the main program, automatically\n+performs the necessary compilation, binding and linking steps.\n+\n+.. _Running_a_Simple_Ada_Program:\n+\n+Running a Simple Ada Program\n+============================\n+\n+Any text editor may be used to prepare an Ada program.\n+(If Emacs is used, the optional Ada mode may be helpful in laying out the\n+program.)\n+The program text is a normal text file. We will assume in our initial\n+example that you have used your editor to prepare the following\n+standard format text file:\n+\n+\n+.. code-block:: ada\n+\n+  with Ada.Text_IO; use Ada.Text_IO;\n+  procedure Hello is\n+  begin\n+     Put_Line (\"Hello WORLD!\");\n+  end Hello;\n+\n+This file should be named :file:`hello.adb`.\n+With the normal default file naming conventions, GNAT requires\n+that each file\n+contain a single compilation unit whose file name is the\n+unit name,\n+with periods replaced by hyphens; the\n+extension is :file:`ads` for a\n+spec and :file:`adb` for a body.\n+You can override this default file naming convention by use of the\n+special pragma `Source_File_Name` (for further information please\n+see :ref:`Using_Other_File_Names`).\n+Alternatively, if you want to rename your files according to this default\n+convention, which is probably more convenient if you will be using GNAT\n+for all your compilations, then the `gnatchop` utility\n+can be used to generate correctly-named source files\n+(see :ref:`Renaming_Files_with_gnatchop`).\n+\n+You can compile the program using the following command (`$` is used\n+as the command prompt in the examples in this document):\n+\n+.. code-block:: sh\n+\n+  $ gcc -c hello.adb\n+  \n+\n+*gcc* is the command used to run the compiler. This compiler is\n+capable of compiling programs in several languages, including Ada and\n+C. It assumes that you have given it an Ada program if the file extension is\n+either :file:`.ads` or :file:`.adb`, and it will then call\n+the GNAT compiler to compile the specified file.\n+\n+The :option:`-c` switch is required. It tells *gcc* to only do a\n+compilation. (For C programs, *gcc* can also do linking, but this\n+capability is not used directly for Ada programs, so the :option:`-c`\n+switch must always be present.)\n+\n+This compile command generates a file\n+:file:`hello.o`, which is the object\n+file corresponding to your Ada program. It also generates\n+an 'Ada Library Information' file :file:`hello.ali`,\n+which contains additional information used to check\n+that an Ada program is consistent.\n+To build an executable file,\n+use `gnatbind` to bind the program\n+and *gnatlink* to link it. The\n+argument to both `gnatbind` and *gnatlink* is the name of the\n+:file:`ALI` file, but the default extension of :file:`.ali` can\n+be omitted. This means that in the most common case, the argument\n+is simply the name of the main program:\n+\n+.. code-block:: sh\n+\n+  $ gnatbind hello\n+  $ gnatlink hello\n+\n+A simpler method of carrying out these steps is to use *gnatmake*,\n+a master program that invokes all the required\n+compilation, binding and linking tools in the correct order. In particular,\n+*gnatmake* automatically recompiles any sources that have been\n+modified since they were last compiled, or sources that depend\n+on such modified sources, so that 'version skew' is avoided.\n+\n+.. index:: Version skew (avoided by *gnatmake*)\n+\n+.. code-block:: sh\n+\n+  $ gnatmake hello.adb\n+\n+The result is an executable program called :file:`hello`, which can be\n+run by entering:\n+\n+.. code-block:: sh\n+\n+  $ hello\n+\n+assuming that the current directory is on the search path\n+for executable programs.\n+\n+and, if all has gone well, you will see::\n+\n+  Hello WORLD!\n+\n+appear in response to this command.\n+\n+.. _Running_a_Program_with_Multiple_Units:\n+\n+Running a Program with Multiple Units\n+=====================================\n+\n+Consider a slightly more complicated example that has three files: a\n+main program, and the spec and body of a package:\n+\n+\n+.. code-block:: ada\n+\n+  package Greetings is\n+     procedure Hello;\n+     procedure Goodbye;\n+  end Greetings;\n+\n+  with Ada.Text_IO; use Ada.Text_IO;\n+  package body Greetings is\n+     procedure Hello is\n+     begin\n+        Put_Line (\"Hello WORLD!\");\n+     end Hello;\n+\n+     procedure Goodbye is\n+     begin\n+        Put_Line (\"Goodbye WORLD!\");\n+     end Goodbye;\n+  end Greetings;\n+\n+  with Greetings;\n+  procedure Gmain is\n+  begin\n+     Greetings.Hello;\n+     Greetings.Goodbye;\n+  end Gmain;\n+\n+Following the one-unit-per-file rule, place this program in the\n+following three separate files:\n+\n+\n+\n+*greetings.ads*\n+  spec of package `Greetings`\n+\n+\n+*greetings.adb*\n+  body of package `Greetings`\n+\n+\n+*gmain.adb*\n+  body of main program\n+\n+To build an executable version of\n+this program, we could use four separate steps to compile, bind, and link\n+the program, as follows:\n+\n+.. code-block:: sh\n+\n+  $ gcc -c gmain.adb\n+  $ gcc -c greetings.adb\n+  $ gnatbind gmain\n+  $ gnatlink gmain\n+\n+Note that there is no required order of compilation when using GNAT.\n+In particular it is perfectly fine to compile the main program first.\n+Also, it is not necessary to compile package specs in the case where\n+there is an accompanying body; you only need to compile the body. If you want\n+to submit these files to the compiler for semantic checking and not code\n+generation, then use the :option:`-gnatc` switch:\n+\n+.. code-block:: sh\n+\n+  $ gcc -c greetings.ads -gnatc\n+\n+Although the compilation can be done in separate steps as in the\n+above example, in practice it is almost always more convenient\n+to use the *gnatmake* tool. All you need to know in this case\n+is the name of the main program's source file. The effect of the above four\n+commands can be achieved with a single one:\n+\n+.. code-block:: sh\n+\n+  $ gnatmake gmain.adb\n+\n+In the next section we discuss the advantages of using *gnatmake* in\n+more detail.\n+\n+.. _Using_the_gnatmake_Utility:\n+\n+Using the *gnatmake* Utility\n+============================\n+\n+If you work on a program by compiling single components at a time using\n+*gcc*, you typically keep track of the units you modify. In order to\n+build a consistent system, you compile not only these units, but also any\n+units that depend on the units you have modified.\n+For example, in the preceding case,\n+if you edit :file:`gmain.adb`, you only need to recompile that file. But if\n+you edit :file:`greetings.ads`, you must recompile both\n+:file:`greetings.adb` and :file:`gmain.adb`, because both files contain\n+units that depend on :file:`greetings.ads`.\n+\n+*gnatbind* will warn you if you forget one of these compilation\n+steps, so that it is impossible to generate an inconsistent program as a\n+result of forgetting to do a compilation. Nevertheless it is tedious and\n+error-prone to keep track of dependencies among units.\n+One approach to handle the dependency-bookkeeping is to use a\n+makefile. However, makefiles present maintenance problems of their own:\n+if the dependencies change as you change the program, you must make\n+sure that the makefile is kept up-to-date manually, which is also an\n+error-prone process.\n+\n+The *gnatmake* utility takes care of these details automatically.\n+Invoke it using either one of the following forms:\n+\n+.. code-block:: sh\n+\n+  $ gnatmake gmain.adb\n+  $ gnatmake gmain\n+\n+The argument is the name of the file containing the main program;\n+you may omit the extension. *gnatmake*\n+examines the environment, automatically recompiles any files that need\n+recompiling, and binds and links the resulting set of object files,\n+generating the executable file, :file:`gmain`.\n+In a large program, it\n+can be extremely helpful to use *gnatmake*, because working out by hand\n+what needs to be recompiled can be difficult.\n+\n+Note that *gnatmake* takes into account all the Ada rules that\n+establish dependencies among units. These include dependencies that result\n+from inlining subprogram bodies, and from\n+generic instantiation. Unlike some other\n+Ada make tools, *gnatmake* does not rely on the dependencies that were\n+found by the compiler on a previous compilation, which may possibly\n+be wrong when sources change. *gnatmake* determines the exact set of\n+dependencies from scratch each time it is run.\n+"}, {"sha": "9e332d9d076f2d936519f568fada6bae5d0b30d6", "filename": "gcc/ada/doc/gnat_ugn/gnat_and_program_execution.rst", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_and_program_execution.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_and_program_execution.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_and_program_execution.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1"}, {"sha": "70d3c2842763395e636368b4c5decbb24ffc1e43", "filename": "gcc/ada/doc/gnat_ugn/gnat_project_manager.rst", "status": "added", "additions": 4907, "deletions": 0, "changes": 4907, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_project_manager.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_project_manager.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_project_manager.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1"}, {"sha": "f3af60c25ea65183d662918d078897d66dc02177", "filename": "gcc/ada/doc/gnat_ugn/gnat_utility_programs.rst", "status": "added", "additions": 4997, "deletions": 0, "changes": 4997, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1"}, {"sha": "d79b70b08147048a944047f8dc9123f3e8d2be33", "filename": "gcc/ada/doc/gnat_ugn/inline_assembler.rst", "status": "added", "additions": 668, "deletions": 0, "changes": 668, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Finline_assembler.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Finline_assembler.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Finline_assembler.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1"}, {"sha": "dc3dfec22c89eae19295e2bb2d79309c5778b7c1", "filename": "gcc/ada/doc/gnat_ugn/platform_specific_information.rst", "status": "added", "additions": 2191, "deletions": 0, "changes": 2191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fplatform_specific_information.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fplatform_specific_information.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fplatform_specific_information.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1"}, {"sha": "30eb860789e9c1ebc52d3c46454a53a25a79d7fd", "filename": "gcc/ada/doc/gnat_ugn/the_gnat_compilation_model.rst", "status": "added", "additions": 4846, "deletions": 0, "changes": 4846, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fthe_gnat_compilation_model.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fthe_gnat_compilation_model.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fthe_gnat_compilation_model.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1"}, {"sha": "7360acb0b8a47570863d70669b800367143eb897", "filename": "gcc/ada/doc/gnat_ugn/tools_supporting_project_files.rst", "status": "added", "additions": 745, "deletions": 0, "changes": 745, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Ftools_supporting_project_files.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Ftools_supporting_project_files.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Ftools_supporting_project_files.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1"}, {"sha": "27462a3226d8ff6f0eb876c65069e490d615170d", "filename": "gcc/ada/doc/share/ada_pygments.py", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fshare%2Fada_pygments.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fshare%2Fada_pygments.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fshare%2Fada_pygments.py?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1"}, {"sha": "c6c45b08aa878e06bb983351e4182c862ee3f999", "filename": "gcc/ada/doc/share/conf.py", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fshare%2Fconf.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fshare%2Fconf.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fshare%2Fconf.py?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1"}, {"sha": "c18cf6673c51c35de4e490667b91a8dbe42fa547", "filename": "gcc/ada/doc/share/gnu_free_documentation_license.rst", "status": "added", "additions": 458, "deletions": 0, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fshare%2Fgnu_free_documentation_license.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fshare%2Fgnu_free_documentation_license.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fshare%2Fgnu_free_documentation_license.rst?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1"}, {"sha": "cf8fbe1a949c4b59cc10bb092b71fcd67461b67e", "filename": "gcc/ada/doc/share/latex_elements.py", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fshare%2Flatex_elements.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fshare%2Flatex_elements.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fshare%2Flatex_elements.py?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1"}, {"sha": "2af577a3b3e460dc05d7b87018e2cde4c8a60562", "filename": "gcc/ada/doc/share/sphinx.sty", "status": "added", "additions": 570, "deletions": 0, "changes": 570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fshare%2Fsphinx.sty", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fdoc%2Fshare%2Fsphinx.sty", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fshare%2Fsphinx.sty?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1"}, {"sha": "bcf9b3c69b846766b5a93e5d2eb65f03157550dd", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 21842, "deletions": 16681, "changes": 38523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1"}, {"sha": "87becc748191c7ed2d82d6524f8ffa61bbe8889f", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 31946, "deletions": 25238, "changes": 57184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2d884d7d2b5fe83aba42f1387542b50d5f06b1/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=cb2d884d7d2b5fe83aba42f1387542b50d5f06b1"}]}