{"sha": "19c0d7df9931c87307ca1eaae37b266e249b39d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTljMGQ3ZGY5OTMxYzg3MzA3Y2ExZWFhZTM3YjI2NmUyNDliMzlkNw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2012-02-28T20:08:39Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2012-02-28T20:08:39Z"}, "message": "re PR middle-end/51752 (trans-mem: publication safety violated)\n\n        PR middle-end/51752\n        * gimple.h (gimple_in_transaction): New.\n        (gimple_set_in_transaction): New.\n        (struct gimple_statement_base): Add in_transaction field.\n        * tree-ssa-loop-im.c: (movement_possibility): Restrict movement of\n        transaction loads.\n        (tree_ssa_lim_initialize): Compute transaction bits.\n        * tree.h (compute_transaction_bits): Protoize.\n        * trans-mem.c (tm_region_init): Use the heap to store BB\n        auxilliary data.\n        (compute_transaction_bits): New.\n\nFrom-SVN: r184638", "tree": {"sha": "780606e8e39dbc758d4c2e3c28e49951fa7b82fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/780606e8e39dbc758d4c2e3c28e49951fa7b82fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19c0d7df9931c87307ca1eaae37b266e249b39d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19c0d7df9931c87307ca1eaae37b266e249b39d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19c0d7df9931c87307ca1eaae37b266e249b39d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19c0d7df9931c87307ca1eaae37b266e249b39d7/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca45d3d56d8760eb36b8cf04cf8c89f01e03d93c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca45d3d56d8760eb36b8cf04cf8c89f01e03d93c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca45d3d56d8760eb36b8cf04cf8c89f01e03d93c"}], "stats": {"total": 142, "additions": 132, "deletions": 10}, "files": [{"sha": "aae247a5a38cadef4fee1ff069fe455ae29a50ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c0d7df9931c87307ca1eaae37b266e249b39d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c0d7df9931c87307ca1eaae37b266e249b39d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=19c0d7df9931c87307ca1eaae37b266e249b39d7", "patch": "@@ -1,3 +1,17 @@\n+2012-02-28  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\tPR middle-end/51752\n+\t* gimple.h (gimple_in_transaction): New.\n+\t(gimple_set_in_transaction): New.\n+\t(struct gimple_statement_base): Add in_transaction field.\n+\t* tree-ssa-loop-im.c: (movement_possibility): Restrict movement of\n+\ttransaction loads.\n+\t(tree_ssa_lim_initialize): Compute transaction bits.\n+\t* tree.h (compute_transaction_bits): Protoize.\n+\t* trans-mem.c (tm_region_init): Use the heap to store BB\n+\tauxilliary data.\n+\t(compute_transaction_bits): New.\n+\n 2012-02-28  Bernhard Reutner-Fischer  <aldot@gcc.gnu.org>\n \n \t* gcc.c (display_help): Document --help=common and sort entries"}, {"sha": "92edd181059c178375cade8b6f7af8cc41282747", "filename": "gcc/gimple.h", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c0d7df9931c87307ca1eaae37b266e249b39d7/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c0d7df9931c87307ca1eaae37b266e249b39d7/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=19c0d7df9931c87307ca1eaae37b266e249b39d7", "patch": "@@ -305,8 +305,10 @@ struct GTY(()) gimple_statement_base {\n   /* Nonzero if this statement contains volatile operands.  */\n   unsigned has_volatile_ops \t: 1;\n \n-  /* Padding to get subcode to 16 bit alignment.  */\n-  unsigned pad\t\t\t: 1;\n+  /* Nonzero if this statement appears inside a transaction.  This bit\n+     is calculated on de-mand and has relevant information only after\n+     it has been calculated with compute_transaction_bits.  */\n+  unsigned in_transaction\t: 1;\n \n   /* The SUBCODE field can be used for tuple-specific flags for tuples\n      that do not require subcodes.  Note that SUBCODE should be at\n@@ -1120,6 +1122,7 @@ extern tree omp_reduction_init (tree, tree);\n \n /* In trans-mem.c.  */\n extern void diagnose_tm_safe_errors (tree);\n+extern void compute_transaction_bits (void);\n \n /* In tree-nested.c.  */\n extern void lower_nested_functions (tree);\n@@ -1584,6 +1587,21 @@ gimple_set_has_volatile_ops (gimple stmt, bool volatilep)\n     stmt->gsbase.has_volatile_ops = (unsigned) volatilep;\n }\n \n+/* Return true if STMT is in a transaction.  */\n+\n+static inline bool\n+gimple_in_transaction (gimple stmt)\n+{\n+  return stmt->gsbase.in_transaction;\n+}\n+\n+/* Set the IN_TRANSACTION flag to TRANSACTIONP.  */\n+\n+static inline void\n+gimple_set_in_transaction (gimple stmt, bool transactionp)\n+{\n+  stmt->gsbase.in_transaction = (unsigned) transactionp;\n+}\n \n /* Return true if statement STMT may access memory.  */\n "}, {"sha": "660e9a6276730bd60cd3ba2e472aa39b79daaa8c", "filename": "gcc/testsuite/gcc.dg/tm/pub-safety-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c0d7df9931c87307ca1eaae37b266e249b39d7/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpub-safety-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c0d7df9931c87307ca1eaae37b266e249b39d7/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpub-safety-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpub-safety-1.c?ref=19c0d7df9931c87307ca1eaae37b266e249b39d7", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O1 -fdump-tree-lim1\" } */\n+\n+/* Test that thread visible loads do not get hoisted out of loops if\n+   the load would not have occurred on each path out of the loop.  */\n+\n+int x[10] = {0,0,0,0,0,0,0,0,0,0};\n+int DATA_DATA = 0;\n+\n+void reader()\n+{\n+  int i;\n+  __transaction_atomic\n+    { \n+      for (i = 0; i < 10; i++)\n+        if (x[i])\n+          x[i] += DATA_DATA;\n+      /* If we loaded DATA_DATA here, we could hoist it before the loop,\n+\t but since we don't... we can't.  */\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Cannot hoist.*DATA_DATA because it is in a transaction\" 1 \"lim1\" } } */\n+/* { dg-final { cleanup-tree-dump \"lim1\" } } */"}, {"sha": "56ef72ea5f34081fd604d525f902f533caf0639b", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 50, "deletions": 7, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c0d7df9931c87307ca1eaae37b266e249b39d7/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c0d7df9931c87307ca1eaae37b266e249b39d7/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=19c0d7df9931c87307ca1eaae37b266e249b39d7", "patch": "@@ -1858,18 +1858,25 @@ tm_region_init (struct tm_region *region)\n   VEC(basic_block, heap) *queue = NULL;\n   bitmap visited_blocks = BITMAP_ALLOC (NULL);\n   struct tm_region *old_region;\n+  struct tm_region **region_worklist;\n \n   all_tm_regions = region;\n   bb = single_succ (ENTRY_BLOCK_PTR);\n \n+  /* We could store this information in bb->aux, but we may get called\n+     through get_all_tm_blocks() from another pass that may be already\n+     using bb->aux.  */\n+  region_worklist =\n+    (struct tm_region **) xcalloc (sizeof (struct tm_region *),\n+\t\t\t\t  n_basic_blocks + NUM_FIXED_BLOCKS + 2);\n+\n   VEC_safe_push (basic_block, heap, queue, bb);\n-  gcc_assert (!bb->aux);\t/* FIXME: Remove me.  */\n-  bb->aux = region;\n+  region_worklist[bb->index] = region;\n   do\n     {\n       bb = VEC_pop (basic_block, queue);\n-      region = (struct tm_region *)bb->aux;\n-      bb->aux = NULL;\n+      region = region_worklist[bb->index];\n+      region_worklist[bb->index] = NULL;\n \n       /* Record exit and irrevocable blocks.  */\n       region = tm_region_init_1 (region, bb);\n@@ -1886,20 +1893,20 @@ tm_region_init (struct tm_region *region)\n \t  {\n \t    bitmap_set_bit (visited_blocks, e->dest->index);\n \t    VEC_safe_push (basic_block, heap, queue, e->dest);\n-\t    gcc_assert (!e->dest->aux); /* FIXME: Remove me.  */\n \n \t    /* If the current block started a new region, make sure that only\n \t       the entry block of the new region is associated with this region.\n \t       Other successors are still part of the old region.  */\n \t    if (old_region != region && e->dest != region->entry_block)\n-\t      e->dest->aux = old_region;\n+\t      region_worklist[e->dest->index] = old_region;\n \t    else\n-\t      e->dest->aux = region;\n+\t      region_worklist[e->dest->index] = region;\n \t  }\n     }\n   while (!VEC_empty (basic_block, queue));\n   VEC_free (basic_block, heap, queue);\n   BITMAP_FREE (visited_blocks);\n+  free (region_worklist);\n }\n \n /* The \"gate\" function for all transactional memory expansion and optimization\n@@ -2424,6 +2431,42 @@ get_tm_region_blocks (basic_block entry_block,\n   return bbs;\n }\n \n+/* Set the IN_TRANSACTION for all gimple statements that appear in a\n+   transaction.  */\n+\n+void\n+compute_transaction_bits (void)\n+{\n+  struct tm_region *region;\n+  VEC (basic_block, heap) *queue;\n+  unsigned int i;\n+  gimple_stmt_iterator gsi;\n+  basic_block bb;\n+\n+  /* ?? Perhaps we need to abstract gate_tm_init further, because we\n+     certainly don't need it to calculate CDI_DOMINATOR info.  */\n+  gate_tm_init ();\n+\n+  for (region = all_tm_regions; region; region = region->next)\n+    {\n+      queue = get_tm_region_blocks (region->entry_block,\n+\t\t\t\t    region->exit_blocks,\n+\t\t\t\t    region->irr_blocks,\n+\t\t\t\t    NULL,\n+\t\t\t\t    /*stop_at_irr_p=*/true);\n+      for (i = 0; VEC_iterate (basic_block, queue, i, bb); ++i)\n+\tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  {\n+\t    gimple stmt = gsi_stmt (gsi);\n+\t    gimple_set_in_transaction (stmt, true);\n+\t  }\n+      VEC_free (basic_block, heap, queue);\n+    }\n+\n+  if (all_tm_regions)\n+    bitmap_obstack_release (&tm_obstack);\n+}\n+\n /* Entry point to the MARK phase of TM expansion.  Here we replace\n    transactional memory statements with calls to builtins, and function\n    calls with their transactional clones (if available).  But we don't"}, {"sha": "ce5eb208850c60f96ed880e1430b1ff6b6212354", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c0d7df9931c87307ca1eaae37b266e249b39d7/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c0d7df9931c87307ca1eaae37b266e249b39d7/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=19c0d7df9931c87307ca1eaae37b266e249b39d7", "patch": "@@ -150,7 +150,7 @@ typedef struct mem_ref\n \n   bitmap indep_ref;\t\t/* The set of memory references on that\n \t\t\t\t   this reference is independent.  */\n-  bitmap dep_ref;\t\t/* The complement of DEP_REF.  */\n+  bitmap dep_ref;\t\t/* The complement of INDEP_REF.  */\n } *mem_ref_p;\n \n DEF_VEC_P(mem_ref_p);\n@@ -412,6 +412,26 @@ movement_possibility (gimple stmt)\n       || gimple_could_trap_p (stmt))\n     return MOVE_PRESERVE_EXECUTION;\n \n+  /* Non local loads in a transaction cannot be hoisted out.  Well,\n+     unless the load happens on every path out of the loop, but we\n+     don't take this into account yet.  */\n+  if (flag_tm\n+      && gimple_in_transaction (stmt)\n+      && gimple_assign_single_p (stmt))\n+    {\n+      tree rhs = gimple_assign_rhs1 (stmt);\n+      if (DECL_P (rhs) && is_global_var (rhs))\n+\t{\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Cannot hoist conditional load of \");\n+\t      print_generic_expr (dump_file, rhs, TDF_SLIM);\n+\t      fprintf (dump_file, \" because it is in a transaction.\\n\");\n+\t    }\n+\t  return MOVE_IMPOSSIBLE;\n+\t}\n+    }\n+\n   return ret;\n }\n \n@@ -2387,6 +2407,9 @@ tree_ssa_lim_initialize (void)\n   sbitmap_free (contains_call);\n \n   lim_aux_data_map = pointer_map_create ();\n+\n+  if (flag_tm)\n+    compute_transaction_bits ();\n }\n \n /* Cleans up after the invariant motion pass.  */"}]}