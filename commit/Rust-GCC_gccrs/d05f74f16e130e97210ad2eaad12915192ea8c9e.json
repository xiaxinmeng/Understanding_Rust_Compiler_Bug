{"sha": "d05f74f16e130e97210ad2eaad12915192ea8c9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA1Zjc0ZjE2ZTEzMGU5NzIxMGFkMmVhYWQxMjkxNTE5MmVhOGM5ZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2007-05-07T21:27:54Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2007-05-07T21:27:54Z"}, "message": "re PR other/28145 (C++ (throw() and catch(...) {/*  fall through */ } ) and pthread cancellation are incompatible (at least with NPTL))\n\n        PR c++/28145\n        * libsupc++/cxxabi.h (__forced_unwind, __foreign_exception):\n        New classes.\n        * libsupc++/eh_exception.cc: Define their destructors.\n        * config/abi/pre/gnu.ver: Export their type_infos.\n        * config/abi/pre/gnu-versioned-namespace.ver: Likewise.\n        * libsupc++/eh_personality.cc: A handler for abi::__forced_unwind\n        matches a forced unwind, and a handler for abi::__foreign_exception\n        matches a foreign exception.\n\n        * include/bits/istream.tcc: Rethrow forced unwind.\n        * include/bits/ostream.tcc: Likewise.\n        * include/bits/ostream_insert.h: Likewise.\n        * include/bits/basic_string.tcc (operator>>, getline): Likewise.\n        * include/bits/fstream.tcc (basic_filebuf::close): Likewise.\n        * include/ext/vstring.cc (operator>>, getline): Likewise.\n        * src/istream.cc: Likewise.\n        * src/compatibility.cc (basic_istream::ignore): Likewise.\n        * include/std/bitset (operator>>): Likewise.\n        * include/std/fstream (basic_filebuf::close): Remove throw() spec.\n        * libsupc++/cxxabi-internal.h: Split out from...\n        * libsupc++/cxxabi.h: ...here.\n\nFrom-SVN: r124517", "tree": {"sha": "c30258339d2a08a69bc22ef35afceb0e8fe1957c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c30258339d2a08a69bc22ef35afceb0e8fe1957c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d05f74f16e130e97210ad2eaad12915192ea8c9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d05f74f16e130e97210ad2eaad12915192ea8c9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d05f74f16e130e97210ad2eaad12915192ea8c9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d05f74f16e130e97210ad2eaad12915192ea8c9e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1e7c1ba87df3e201199408f4cef5cbd0aaad475a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e7c1ba87df3e201199408f4cef5cbd0aaad475a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e7c1ba87df3e201199408f4cef5cbd0aaad475a"}], "stats": {"total": 1487, "additions": 940, "deletions": 547}, "files": [{"sha": "7a9c35964f7ce9a74245f1ce1f4f0125055b4a79", "filename": "gcc/testsuite/g++.dg/abi/forced.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fforced.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fforced.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fforced.C?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -0,0 +1,25 @@\n+// This test only applies to glibc (NPTL) targets.\n+// { dg-do run { target *-*-linux* } }\n+// { dg-options \"-pthread\" }\n+\n+#include <pthread.h>\n+#include <cxxabi.h>\n+extern \"C\" int printf (const char *, ...);\n+\n+int main()\n+{\n+  try\n+    {\n+      pthread_exit (0);\n+    }\n+  catch (abi::__forced_unwind &)\n+    {\n+      printf (\"caught forced unwind\\n\");\n+      throw;\n+    }\n+  catch (...)\n+    {\n+      printf (\"caught ...\\n\");\n+      return 1;\n+    }\n+}"}, {"sha": "89e64b2705106c2758bdf3ca9c474ae5ac782c60", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -1,3 +1,28 @@\n+2007-05-07  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/28145\n+\t* libsupc++/cxxabi.h (__forced_unwind, __foreign_exception):\n+\tNew classes.\n+\t* libsupc++/eh_exception.cc: Define their destructors.\n+\t* config/abi/pre/gnu.ver: Export their type_infos.\n+\t* config/abi/pre/gnu-versioned-namespace.ver: Likewise.\n+\t* libsupc++/eh_personality.cc: A handler for abi::__forced_unwind\n+\tmatches a forced unwind, and a handler for abi::__foreign_exception\n+\tmatches a foreign exception.\n+\t\n+\t* include/bits/istream.tcc: Rethrow forced unwind.\n+\t* include/bits/ostream.tcc: Likewise.\n+\t* include/bits/ostream_insert.h: Likewise.\n+\t* include/bits/basic_string.tcc (operator>>, getline): Likewise.\n+\t* include/bits/fstream.tcc (basic_filebuf::close): Likewise.\n+\t* include/ext/vstring.cc (operator>>, getline): Likewise.\n+\t* src/istream.cc: Likewise.\n+\t* src/compatibility.cc (basic_istream::ignore): Likewise.\n+\t* include/std/bitset (operator>>): Likewise.\n+\t* include/std/fstream (basic_filebuf::close): Remove throw() spec.\n+\t* libsupc++/cxxabi-internal.h: Split out from...\n+\t* libsupc++/cxxabi.h: ...here.\n+\n 2007-05-07  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/stl_algobase.h: Do not include <cstring>."}, {"sha": "b3ebf829bee9146f2581d8ee53b47eb1f3cf5569", "filename": "libstdc++-v3/config/abi/pre/gnu-versioned-namespace.ver", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu-versioned-namespace.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu-versioned-namespace.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu-versioned-namespace.ver?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -178,6 +178,8 @@ CXXABI_1.7 {\n     _ZTIN10__cxxabiv119__pointer_type_infoE;\n     _ZTIN10__cxxabiv120__si_class_type_infoE;\n     _ZTIN10__cxxabiv121__vmi_class_type_infoE;\n+    _ZTIN10__cxxabiv115__forced_unwindE;\n+    _ZTIN10__cxxabiv119__foreign_exceptionE;\n \n     # typeinfo name\n     _ZTS[a-z];"}, {"sha": "729589c8c9ec84c3554a7ba6a335befc5dd77c65", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -793,6 +793,8 @@ CXXABI_1.3 {\n     _ZTIN10__cxxabiv119__pointer_type_infoE;\n     _ZTIN10__cxxabiv120__si_class_type_infoE;\n     _ZTIN10__cxxabiv121__vmi_class_type_infoE;\n+    _ZTIN10__cxxabiv115__forced_unwindE;\n+    _ZTIN10__cxxabiv119__foreign_exceptionE;\n \n     # typeinfo name\n     _ZTS[a-fh-z];"}, {"sha": "9a417741e6a6cd14d97b945526b293109084815b", "filename": "libstdc++-v3/config/locale/gnu/monetary_members.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fmonetary_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fmonetary_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fmonetary_members.cc?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -448,7 +448,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t_M_data->_M_curr_symbol = L\"\";\n \t      _M_data->_M_curr_symbol_size = wcslen(_M_data->_M_curr_symbol);\n \t    }\n-\t  catch (...)\n+\t  catch(...)\n \t    {\n \t      delete _M_data;\n \t      _M_data = 0;\n@@ -591,7 +591,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t_M_data->_M_curr_symbol = L\"\";\n               _M_data->_M_curr_symbol_size = wcslen(_M_data->_M_curr_symbol);\n \t    }\n-          catch (...)\n+          catch(...)\n \t    {\n \t      delete _M_data;\n               _M_data = 0;"}, {"sha": "4c682936e2310e7d5a5266ad54c15448b5d70eab", "filename": "libstdc++-v3/include/bits/basic_string.tcc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -46,6 +46,8 @@\n \n #pragma GCC system_header\n \n+#include <cxxabi-internal.h>\n+\n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n@@ -1015,6 +1017,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t__err |= __ios_base::eofbit;\n \t      __in.width(0);\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      __in._M_setstate(__ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    {\n \t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -1074,6 +1081,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      else\n \t\t__err |= __ios_base::failbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      __in._M_setstate(__ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    {\n \t      // _GLIBCXX_RESOLVE_LIB_DEFECTS"}, {"sha": "f9b84bf7ce23c9fa2ab25f92ac55a006ba181b24", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -42,6 +42,8 @@\n \n #pragma GCC system_header\n \n+#include <cxxabi-internal.h>\n+\n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   template<typename _CharT, typename _Traits>\n@@ -127,36 +129,51 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   template<typename _CharT, typename _Traits>\n     typename basic_filebuf<_CharT, _Traits>::__filebuf_type*\n     basic_filebuf<_CharT, _Traits>::\n-    close() throw()\n+    close()\n     {\n-      __filebuf_type* __ret = NULL;\n-      if (this->is_open())\n+      if (!this->is_open())\n+\treturn NULL;\n+\n+      bool __testfail = false;\n+      {\n+\t// NB: Do this here so that re-opened filebufs will be cool...\n+\tstruct __close_sentry\n \t{\n-\t  bool __testfail = false;\n-\t  try\n-\t    {\n-\t      if (!_M_terminate_output())\n-\t\t__testfail = true;\n-\t    }\n-\t  catch(...)\n-\t    { __testfail = true; }\n-\n-\t  // NB: Do this here so that re-opened filebufs will be cool...\n-\t  _M_mode = ios_base::openmode(0);\n-\t  _M_pback_init = false;\n-\t  _M_destroy_internal_buffer();\n-\t  _M_reading = false;\n-\t  _M_writing = false;\n-\t  _M_set_buffer(-1);\n-\t  _M_state_last = _M_state_cur = _M_state_beg;\n-\n-\t  if (!_M_file.close())\n-\t    __testfail = true;\n-\n-\t  if (!__testfail)\n-\t    __ret = this;\n-\t}\n-      return __ret;\n+\t  basic_filebuf *__fb;\n+\t  __close_sentry (basic_filebuf *__fbi): __fb(__fbi) { }\n+\t  ~__close_sentry ()\n+\t  {\n+\t    __fb->_M_mode = ios_base::openmode(0);\n+\t    __fb->_M_pback_init = false;\n+\t    __fb->_M_destroy_internal_buffer();\n+\t    __fb->_M_reading = false;\n+\t    __fb->_M_writing = false;\n+\t    __fb->_M_set_buffer(-1);\n+\t    __fb->_M_state_last = __fb->_M_state_cur = __fb->_M_state_beg;\n+\t  }\n+\t} __cs (this);\n+\n+\ttry\n+\t  {\n+\t    if (!_M_terminate_output())\n+\t      __testfail = true;\n+\t  }\n+\tcatch(__cxxabiv1::__forced_unwind&)\n+\t  {\n+\t    _M_file.close();\n+\t    __throw_exception_again;\n+\t  }\n+\tcatch(...)\n+\t  { __testfail = true; }\n+      }\n+\n+      if (!_M_file.close())\n+\t__testfail = true;\n+\n+      if (__testfail)\n+\treturn NULL;\n+      else\n+\treturn this;\n     }\n \n   template<typename _CharT, typename _Traits>"}, {"sha": "e6b18cd79b93ce6e4249fff103ee0420f1154f6e", "filename": "libstdc++-v3/include/bits/istream.tcc", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -43,6 +43,8 @@\n \n #pragma GCC system_header\n \n+#include <cxxabi-internal.h>\n+\n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   template<typename _CharT, typename _Traits>\n@@ -98,6 +100,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\tconst __num_get_type& __ng = __check_facet(this->_M_num_get);\n \t\t__ng.get(*this, 0, *this, __err, __v);\n \t      }\n+\t    catch(__cxxabiv1::__forced_unwind&)\n+\t      {\n+\t\tthis->_M_setstate(ios_base::badbit);\t\t\n+\t\t__throw_exception_again;\n+\t      }\n \t    catch(...)\n \t      { this->_M_setstate(ios_base::badbit); }\n \t    if (__err)\n@@ -163,6 +170,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      if (__ineof)\n \t\t__err |= ios_base::eofbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::failbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::failbit); }\n \t}\n@@ -194,6 +206,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      else\n \t\t__err |= ios_base::eofbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t}\n@@ -226,6 +243,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      else\n \t\t__err |= ios_base::eofbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t}\n@@ -264,6 +286,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      if (traits_type::eq_int_type(__c, __eof))\n \t\t__err |= ios_base::eofbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t}\n@@ -307,6 +334,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      if (traits_type::eq_int_type(__c, __eof))\n \t\t__err |= ios_base::eofbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t}\n@@ -355,6 +387,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n                     __err |= ios_base::failbit;\n                 }\n             }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n           catch(...)\n             { this->_M_setstate(ios_base::badbit); }\n         }\n@@ -392,6 +429,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      else\n \t\t_M_gcount = 1;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t  if (__err)\n@@ -449,6 +491,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      if (traits_type::eq_int_type(__c, __eof))\n                 __err |= ios_base::eofbit;\n             }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n           catch(...)\n             { this->_M_setstate(ios_base::badbit); }\n           if (__err)\n@@ -509,6 +556,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t  __sb->sbumpc();\n \t\t}\n             }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n           catch(...)\n             { this->_M_setstate(ios_base::badbit); }\n           if (__err)\n@@ -534,6 +586,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      if (traits_type::eq_int_type(__c, traits_type::eof()))\n \t\t__err |= ios_base::eofbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t  if (__err)\n@@ -558,6 +615,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      if (_M_gcount != __n)\n \t\t__err |= (ios_base::eofbit | ios_base::failbit);\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t  if (__err)\n@@ -585,6 +647,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      else if (__num == -1)\n \t\t__err |= ios_base::eofbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t  if (__err)\n@@ -613,6 +680,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t  || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))\n \t\t__err |= ios_base::badbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t  if (__err)\n@@ -641,6 +713,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t  || traits_type::eq_int_type(__sb->sungetc(), __eof))\n \t\t__err |= ios_base::badbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t  if (__err)\n@@ -672,6 +749,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t    __ret = 0;\n \t\t}\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t  if (__err)\n@@ -694,6 +776,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t    __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,\n \t\t\t\t\t      ios_base::in);\n \t}\n+      catch(__cxxabiv1::__forced_unwind&)\n+\t{\n+\t  this->_M_setstate(ios_base::badbit);\n+\t  __throw_exception_again;\n+\t}\n       catch(...)\n \t{ this->_M_setstate(ios_base::badbit); }\n       return __ret;\n@@ -720,6 +807,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t__err |= ios_base::failbit;\n \t    }\n \t}\n+      catch(__cxxabiv1::__forced_unwind&)\n+\t{\n+\t  this->_M_setstate(ios_base::badbit);\n+\t  __throw_exception_again;\n+\t}\n       catch(...)\n \t{ this->_M_setstate(ios_base::badbit); }\n       if (__err)\n@@ -748,6 +840,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t__err |= ios_base::failbit;\n \t    }\n \t}\n+      catch(__cxxabiv1::__forced_unwind&)\n+\t{\n+\t  this->_M_setstate(ios_base::badbit);\n+\t  __throw_exception_again;\n+\t}\n       catch(...)\n \t{ this->_M_setstate(ios_base::badbit); }\n       if (__err)\n@@ -775,6 +872,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      else\n \t\t__err |= (ios_base::eofbit | ios_base::failbit);\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      __in._M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { __in._M_setstate(ios_base::badbit); }\n \t  if (__err)\n@@ -828,6 +930,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      *__s = char_type();\n \t      __in.width(0);\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      __in._M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { __in._M_setstate(ios_base::badbit); }\n \t}"}, {"sha": "5e6a8105d8bb4e70005afc6b9d8ca9a2e575c607", "filename": "libstdc++-v3/include/bits/locale_classes.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_classes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_classes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_classes.h?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -409,7 +409,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t{\n \t  try\n \t    { delete this; }\n-\t  catch (...)\n+\t  catch(...)\n \t    { }\n \t}\n     }"}, {"sha": "4691c64827ab9c620084e5ad46948e2523662ad7", "filename": "libstdc++-v3/include/bits/ostream.tcc", "status": "modified", "additions": 59, "deletions": 19, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -43,6 +43,8 @@\n \n #pragma GCC system_header\n \n+#include <cxxabi-internal.h>\n+\n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   template<typename _CharT, typename _Traits>\n@@ -76,6 +78,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\tif (__np.put(*this, *this, this->fill(), __v).failed())\n \t\t  __err |= ios_base::badbit;\n \t      }\n+\t    catch(__cxxabiv1::__forced_unwind&)\n+\t      {\n+\t\tthis->_M_setstate(ios_base::badbit);\t\t\n+\t\t__throw_exception_again;\n+\t      }\n \t    catch(...)\n \t      { this->_M_setstate(ios_base::badbit); }\n \t    if (__err)\n@@ -126,6 +133,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      if (!__copy_streambufs(__sbin, this->rdbuf()))\n \t\t__err |= ios_base::failbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\t\t\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::failbit); }\n \t}\n@@ -157,7 +169,12 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      if (traits_type::eq_int_type(__put, traits_type::eof()))\n \t\t__err |= ios_base::badbit;\n \t    }\n-\t  catch (...)\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\t\t\n+\t      __throw_exception_again;\n+\t    }\n+\t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t  if (__err)\n \t    this->setstate(__err);\n@@ -182,7 +199,12 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t{\n \t  try\n \t    { _M_write(__s, __n); }\n-\t  catch (...)\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\t\t\n+\t      __throw_exception_again;\n+\t    }\n+\t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t}\n       return *this;\n@@ -202,6 +224,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t  if (this->rdbuf() && this->rdbuf()->pubsync() == -1)\n \t    __err |= ios_base::badbit;\n \t}\n+      catch(__cxxabiv1::__forced_unwind&)\n+\t{\n+\t  this->_M_setstate(ios_base::badbit);\t\t\n+\t  __throw_exception_again;\n+\t}\n       catch(...)\n \t{ this->_M_setstate(ios_base::badbit); }\n       if (__err)\n@@ -220,6 +247,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t  if (!this->fail())\n \t    __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);\n \t}\n+      catch(__cxxabiv1::__forced_unwind&)\n+\t{\n+\t  this->_M_setstate(ios_base::badbit);\t\t\n+\t  __throw_exception_again;\n+\t}\n       catch(...)\n \t{ this->_M_setstate(ios_base::badbit); }\n       return __ret;\n@@ -245,6 +277,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t__err |= ios_base::failbit;\n \t    }\n \t}\n+      catch(__cxxabiv1::__forced_unwind&)\n+\t{\n+\t  this->_M_setstate(ios_base::badbit);\t\t\n+\t  __throw_exception_again;\n+\t}\n       catch(...)\n \t{ this->_M_setstate(ios_base::badbit); }\n       if (__err)\n@@ -272,6 +309,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t__err |= ios_base::failbit;\n \t    }\n \t}\n+      catch(__cxxabiv1::__forced_unwind&)\n+\t{\n+\t  this->_M_setstate(ios_base::badbit);\t\t\n+\t  __throw_exception_again;\n+\t}\n       catch(...)\n \t{ this->_M_setstate(ios_base::badbit); }\n       if (__err)\n@@ -289,31 +331,29 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t{\n \t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t  // 167.  Improper use of traits_type::length()\n-\t  const size_t __clen = char_traits<char>::length(__s);      \n-\t  _CharT* __ws = 0;\n+\t  const size_t __clen = char_traits<char>::length(__s);\n \t  try\n-\t    { \n-\t      __ws = new _CharT[__clen];\n-\t      for (size_t  __i = 0; __i < __clen; ++__i)\n-\t\t__ws[__i] = __out.widen(__s[__i]);\n-\t    }\n-\t  catch(...)\n \t    {\n-\t      delete [] __ws;\n-\t      __out._M_setstate(ios_base::badbit);\n-\t      return __out;\n-\t    }\n+\t      struct __ptr_guard\n+\t      {\n+\t\t_CharT *p;\n+\t\t__ptr_guard (_CharT *ip): p(ip) { }\n+\t\t~__ptr_guard() { delete[] p; }\n+\t\t_CharT* __get() { return p; }\n+\t      } __pg (new _CharT[__clen]);\n \n-\t  try\n-\t    {\n+\t      _CharT *__ws = __pg.__get();\n+\t      for (size_t  __i = 0; __i < __clen; ++__i)\n+\t\t__ws[__i] = __out.widen(__s[__i]);\n \t      __ostream_insert(__out, __ws, __clen);\n-\t      delete [] __ws;\n \t    }\n-\t  catch(...)\n+\t  catch(__cxxabiv1::__forced_unwind&)\n \t    {\n-\t      delete [] __ws;\n+\t      __out._M_setstate(ios_base::badbit);\n \t      __throw_exception_again;\n \t    }\n+\t  catch(...)\n+\t    { __out._M_setstate(ios_base::badbit); }\n \t}\n       return __out;\n     }"}, {"sha": "5815de9ddd26531bbe83967141d5a45c69650743", "filename": "libstdc++-v3/include/bits/ostream_insert.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream_insert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream_insert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream_insert.h?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -38,6 +38,7 @@\n #pragma GCC system_header\n \n #include <iosfwd>\n+#include <cxxabi-internal.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n@@ -103,6 +104,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t__ostream_write(__out, __s, __n);\n \t      __out.width(0);\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      __out._M_setstate(__ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { __out._M_setstate(__ios_base::badbit); }\n \t}"}, {"sha": "6e523b882d4fb0a96b1d09da4b1109304c7574b8", "filename": "libstdc++-v3/include/debug/deque", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -313,7 +313,7 @@ namespace __debug\n \t\treturn iterator(_Base::erase(__first.base(), __last.base()),\n \t\t\t\tthis);\n \t      }\n-\t    catch (...)\n+\t    catch(...)\n \t      {\n \t\tthis->_M_revalidate_singular();\n \t\t__throw_exception_again;"}, {"sha": "9c6737515cbde95ac47119ff246ea0e8b29fc5e7", "filename": "libstdc++-v3/include/ext/pb_ds/detail/resize_policy/hash_load_check_resize_trigger_imp.hpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fresize_policy%2Fhash_load_check_resize_trigger_imp.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fresize_policy%2Fhash_load_check_resize_trigger_imp.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fresize_policy%2Fhash_load_check_resize_trigger_imp.hpp?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -265,7 +265,7 @@ set_loads(std::pair<float, float> load_pair)\n       m_load_max = load_pair.second;\n       do_resize(static_cast<size_type>(size_base::get_size() / ((m_load_min + m_load_max) / 2)));\n     }\n-  catch (...)\n+  catch(...)\n     {\n       m_load_min = old_load_min;\n       m_load_max = old_load_max;"}, {"sha": "7f3478aa9227b37c981139c8ac5a0b71380ca9d3", "filename": "libstdc++-v3/include/ext/vstring.tcc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring.tcc?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -38,6 +38,8 @@\n \n #pragma GCC system_header\n \n+#include <cxxabi-internal.h>\n+\n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n   template<typename _CharT, typename _Traits, typename _Alloc,\n@@ -598,6 +600,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t__err |= __ios_base::eofbit;\n \t      __in.width(0);\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      __in._M_setstate(__ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    {\n \t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -669,6 +676,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      else\n \t\t__err |= __ios_base::failbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      __in._M_setstate(__ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    {\n \t      // _GLIBCXX_RESOLVE_LIB_DEFECTS"}, {"sha": "09f05e1a5e414ff29fad9e511700cc2b8b85e96f", "filename": "libstdc++-v3/include/std/bitset", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -56,6 +56,7 @@\n #include <bits/functexcept.h>   // For invalid_argument, out_of_range,\n                                 // overflow_error\n #include <iosfwd>\n+#include <cxxabi-internal.h>\n \n #define _GLIBCXX_BITSET_BITS_PER_WORD  (__CHAR_BIT__ * sizeof(unsigned long))\n #define _GLIBCXX_BITSET_WORDS(__n) \\\n@@ -1271,6 +1272,11 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n \t\t    }\n \t\t}\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      __is._M_setstate(__ios_base::badbit);\t\t\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { __is._M_setstate(__ios_base::badbit); }\n \t}"}, {"sha": "18c24be4633ef8df0534eb4fcaa6859c3e374751", "filename": "libstdc++-v3/include/std/fstream", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffstream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffstream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffstream?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -275,7 +275,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n        *  If any operations fail, this function also fails.\n       */\n       __filebuf_type*\n-      close() throw();\n+      close();\n \n     protected:\n       void"}, {"sha": "c0d676fa89a8e1e5cc9b48beb4d22da910a544b2", "filename": "libstdc++-v3/include/tr1/hypergeometric.tcc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhypergeometric.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhypergeometric.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhypergeometric.tcc?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -613,7 +613,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n               __sgn_g1cb = __log_gamma_sign(__c - __b);\n               __ln_g1cb = __log_gamma(__c - __b);\n             }\n-          catch (...)\n+          catch(...)\n             {\n               __ok1 = false;\n             }\n@@ -628,7 +628,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n               __sgn_g2b = __log_gamma_sign(__b);\n               __ln_g2b = __log_gamma(__b);\n             }\n-          catch (...)\n+          catch(...)\n             {\n               __ok2 = false;\n             }"}, {"sha": "755c0a41228c2c433a65d4483ef0a4750196f621", "filename": "libstdc++-v3/libsupc++/cxxabi-internal.h", "status": "added", "additions": 555, "deletions": 0, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi-internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi-internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi-internal.h?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -0,0 +1,555 @@\n+// new abi support -*- C++ -*-\n+  \n+// Copyright (C) 2000, 2002, 2003, 2004, 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+// \n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+// \n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Nathan Sidwell, Codesourcery LLC, <nathan@codesourcery.com>\n+ \n+/* This file declares the new abi entry points into the runtime. It is not\n+   normally necessary for user programs to include this header, or use the\n+   entry points directly. However, this header is available should that be\n+   needed.\n+   \n+   Some of the entry points are intended for both C and C++, thus this header\n+   is includable from both C and C++. Though the C++ specific parts are not\n+   available in C, naturally enough.  */\n+\n+/** @file cxxabi.h\n+ *  The header provides an interface to the C++ ABI.\n+ */\n+\n+#ifndef _CXXABI_INTERNAL_H\n+#define _CXXABI_INTERNAL_H 1\n+\n+#pragma GCC visibility push(default)\n+\n+#include <stddef.h>\n+#include <bits/cxxabi_tweaks.h>\n+ \n+#ifdef __cplusplus\n+namespace __cxxabiv1\n+{  \n+  extern \"C\" \n+  {\n+#endif\n+\n+  typedef __cxa_cdtor_return_type (*__cxa_cdtor_type)(void *);\n+\n+  // Allocate array.\n+  void* \n+  __cxa_vec_new(size_t __element_count, size_t __element_size, \n+\t\tsize_t __padding_size, __cxa_cdtor_type constructor,\n+\t\t__cxa_cdtor_type destructor);\n+\n+  void*\n+  __cxa_vec_new2(size_t __element_count, size_t __element_size,\n+\t\t size_t __padding_size, __cxa_cdtor_type constructor,\n+\t\t __cxa_cdtor_type destructor, void *(*__alloc) (size_t), \n+\t\t void (*__dealloc) (void*));\n+\n+  void*\n+  __cxa_vec_new3(size_t __element_count, size_t __element_size,\n+\t\t size_t __padding_size, __cxa_cdtor_type constructor,\n+\t\t __cxa_cdtor_type destructor, void *(*__alloc) (size_t), \n+\t\t void (*__dealloc) (void*, size_t));\n+\n+  // Construct array.\n+  __cxa_vec_ctor_return_type\n+  __cxa_vec_ctor(void* __array_address, size_t __element_count,\n+\t\t size_t __element_size, __cxa_cdtor_type constructor,\n+\t\t __cxa_cdtor_type destructor);\n+\n+  __cxa_vec_ctor_return_type\n+  __cxa_vec_cctor(void* dest_array, void* src_array, size_t element_count, \n+\t\t  size_t element_size, \n+\t\t  __cxa_cdtor_return_type (*constructor) (void*, void*), \n+\t\t  __cxa_cdtor_type destructor);\n+ \n+  // Destruct array.\n+  void \n+  __cxa_vec_dtor(void* __array_address, size_t __element_count,\n+\t\t size_t __element_size, __cxa_cdtor_type destructor);\n+  \n+  void \n+  __cxa_vec_cleanup(void* __array_address, size_t __element_count,\n+\t\t    size_t __element_size, __cxa_cdtor_type destructor);\n+  \n+  // Destruct and release array.\n+  void \n+  __cxa_vec_delete(void* __array_address, size_t __element_size,\n+\t\t   size_t __padding_size, __cxa_cdtor_type destructor);\n+\n+  void \n+  __cxa_vec_delete2(void* __array_address, size_t __element_size,\n+\t\t    size_t __padding_size, __cxa_cdtor_type destructor,\n+\t\t    void (*__dealloc) (void*));\n+                  \n+  void \n+  __cxa_vec_delete3(void* __array_address, size_t __element_size,\n+\t\t    size_t __padding_size, __cxa_cdtor_type destructor,\n+\t\t    void (*__dealloc) (void*, size_t));\n+\n+  int \n+  __cxa_guard_acquire(__guard*);\n+\n+  void \n+  __cxa_guard_release(__guard*);\n+\n+  void \n+  __cxa_guard_abort(__guard*);\n+\n+  // Pure virtual functions.\n+  void\n+  __cxa_pure_virtual(void);\n+\n+  // Exception handling.\n+  void\n+  __cxa_bad_cast();\n+\n+  void\n+  __cxa_bad_typeid();\n+\n+  // DSO destruction.\n+  int\n+  __cxa_atexit(void (*)(void*), void*, void*)\n+#ifdef __cplusplus\n+    throw ()\n+#endif\n+    ;\n+\n+  int\n+  __cxa_finalize(void*);\n+\n+  // Demangling routines. \n+  char*\n+  __cxa_demangle(const char* __mangled_name, char* __output_buffer,\n+\t\t size_t* __length, int* __status);\n+#ifdef __cplusplus\n+  }\n+} // namespace __cxxabiv1\n+#endif\n+\n+#ifdef __cplusplus\n+\n+#include <typeinfo>\n+\n+namespace __cxxabiv1\n+{\n+  // Type information for int, float etc.\n+  class __fundamental_type_info : public std::type_info\n+  {\n+  public:\n+    explicit \n+    __fundamental_type_info(const char* __n) : std::type_info(__n) { }\n+\n+    virtual \n+    ~__fundamental_type_info();\n+  };\n+\n+  // Type information for array objects.\n+  class __array_type_info : public std::type_info\n+  {\n+  public:\n+    explicit \n+    __array_type_info(const char* __n) : std::type_info(__n) { }\n+\n+    virtual \n+    ~__array_type_info();\n+  };\n+\n+  // Type information for functions (both member and non-member).\n+  class __function_type_info : public std::type_info\n+  {\n+  public:\n+    explicit \n+    __function_type_info(const char* __n) : std::type_info(__n) { }\n+\n+    virtual \n+    ~__function_type_info();\n+\n+  protected:\n+    // Implementation defined member function.\n+    virtual bool \n+    __is_function_p() const;\n+  };\n+\n+  // Type information for enumerations.\n+  class __enum_type_info : public std::type_info\n+  {\n+  public:\n+    explicit \n+    __enum_type_info(const char* __n) : std::type_info(__n) { }\n+\n+    virtual \n+    ~__enum_type_info();\n+  };\n+\n+  // Common type information for simple pointers and pointers to member.\n+  class __pbase_type_info : public std::type_info\n+  {\n+  public:\n+    unsigned int \t\t__flags; // Qualification of the target object.\n+    const std::type_info* \t__pointee; // Type of pointed to object.\n+\n+    explicit \n+    __pbase_type_info(const char* __n, int __quals, \n+\t\t      const std::type_info* __type)\n+    : std::type_info(__n), __flags(__quals), __pointee(__type)\n+    { }\n+    \n+    virtual \n+    ~__pbase_type_info();\n+\n+    // Implementation defined type.\n+    enum __masks \n+      {\n+\t__const_mask = 0x1,\n+\t__volatile_mask = 0x2,\n+\t__restrict_mask = 0x4,\n+\t__incomplete_mask = 0x8,\n+\t__incomplete_class_mask = 0x10\n+      };\n+\n+  protected:\n+    __pbase_type_info(const __pbase_type_info&);\n+\n+    __pbase_type_info&\n+    operator=(const __pbase_type_info&);\n+\n+    // Implementation defined member functions.\n+    virtual bool \n+    __do_catch(const std::type_info* __thr_type, void** __thr_obj, \n+\t       unsigned int __outer) const;\n+\n+    inline virtual bool \n+    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,\n+\t\t    unsigned __outer) const;\n+  };\n+\n+  // Type information for simple pointers.\n+  class __pointer_type_info : public __pbase_type_info\n+  {\n+  public:\n+    explicit \n+    __pointer_type_info(const char* __n, int __quals, \n+\t\t\tconst std::type_info* __type)\n+    : __pbase_type_info (__n, __quals, __type) { }\n+\n+\n+    virtual \n+    ~__pointer_type_info();\n+\n+  protected:\n+    // Implementation defined member functions.\n+    virtual bool \n+    __is_pointer_p() const;\n+\n+    virtual bool \n+    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj, \n+\t\t    unsigned __outer) const;\n+  };\n+\n+  class __class_type_info;\n+\n+  // Type information for a pointer to member variable.\n+  class __pointer_to_member_type_info : public __pbase_type_info\n+  {\n+  public:\n+    __class_type_info* __context;   // Class of the member.\n+\n+    explicit \n+    __pointer_to_member_type_info(const char* __n, int __quals,\n+\t\t\t\t  const std::type_info* __type, \n+\t\t\t\t  __class_type_info* __klass)\n+    : __pbase_type_info(__n, __quals, __type), __context(__klass) { }\n+\n+    virtual \n+    ~__pointer_to_member_type_info();\n+\n+  protected:\n+    __pointer_to_member_type_info(const __pointer_to_member_type_info&);\n+\n+    __pointer_to_member_type_info&\n+    operator=(const __pointer_to_member_type_info&);\n+\n+    // Implementation defined member function.\n+    virtual bool \n+    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,\n+\t\t    unsigned __outer) const;\n+  };\n+\n+  // Helper class for __vmi_class_type.\n+  class __base_class_type_info\n+  {\n+  public:\n+    const __class_type_info* \t__base_type;  // Base class type.\n+    long \t\t\t__offset_flags;  // Offset and info.\n+\n+    enum __offset_flags_masks \n+      {\n+\t__virtual_mask = 0x1,\n+\t__public_mask = 0x2,\n+\t__hwm_bit = 2,\n+\t__offset_shift = 8          // Bits to shift offset.\n+      };\n+  \n+    // Implementation defined member functions.\n+    bool \n+    __is_virtual_p() const\n+    { return __offset_flags & __virtual_mask; }\n+\n+    bool \n+    __is_public_p() const\n+    { return __offset_flags & __public_mask; }\n+\n+    ptrdiff_t \n+    __offset() const\n+    { \n+      // This shift, being of a signed type, is implementation\n+      // defined. GCC implements such shifts as arithmetic, which is\n+      // what we want.\n+      return static_cast<ptrdiff_t>(__offset_flags) >> __offset_shift;\n+    }\n+  };\n+\n+  // Type information for a class.\n+  class __class_type_info : public std::type_info\n+  {\n+  public:\n+    explicit \n+    __class_type_info (const char *__n) : type_info(__n) { }\n+\n+    virtual \n+    ~__class_type_info ();\n+\n+    // Implementation defined types.\n+    // The type sub_kind tells us about how a base object is contained\n+    // within a derived object. We often do this lazily, hence the\n+    // UNKNOWN value. At other times we may use NOT_CONTAINED to mean\n+    // not publicly contained.\n+    enum __sub_kind\n+      {\n+\t// We have no idea.\n+\t__unknown = 0, \n+\n+\t// Not contained within us (in some circumstances this might\n+\t// mean not contained publicly)\n+\t__not_contained, \n+\n+\t// Contained ambiguously.\n+\t__contained_ambig, \n+    \n+\t// Via a virtual path.\n+\t__contained_virtual_mask = __base_class_type_info::__virtual_mask, \n+\n+\t// Via a public path.\n+\t__contained_public_mask = __base_class_type_info::__public_mask,   \n+\n+\t// Contained within us.\n+\t__contained_mask = 1 << __base_class_type_info::__hwm_bit,\n+    \n+\t__contained_private = __contained_mask,\n+\t__contained_public = __contained_mask | __contained_public_mask\n+      };\n+\n+    struct __upcast_result;\n+    struct __dyncast_result;\n+\n+  protected:\n+    // Implementation defined member functions.\n+    virtual bool \n+    __do_upcast(const __class_type_info* __dst_type, void**__obj_ptr) const;\n+\n+    virtual bool \n+    __do_catch(const type_info* __thr_type, void** __thr_obj, \n+\t       unsigned __outer) const;\n+\n+  public:\n+    // Helper for upcast. See if DST is us, or one of our bases. \n+    // Return false if not found, true if found. \n+    virtual bool \n+    __do_upcast(const __class_type_info* __dst, const void* __obj,\n+\t\t__upcast_result& __restrict __result) const;\n+\n+    // Indicate whether SRC_PTR of type SRC_TYPE is contained publicly\n+    // within OBJ_PTR. OBJ_PTR points to a base object of our type,\n+    // which is the destination type. SRC2DST indicates how SRC\n+    // objects might be contained within this type.  If SRC_PTR is one\n+    // of our SRC_TYPE bases, indicate the virtuality. Returns\n+    // not_contained for non containment or private containment.\n+    inline __sub_kind \n+    __find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,\n+\t\t      const __class_type_info* __src_type, \n+\t\t      const void* __src_ptr) const;\n+\n+    // Helper for dynamic cast. ACCESS_PATH gives the access from the\n+    // most derived object to this base. DST_TYPE indicates the\n+    // desired type we want. OBJ_PTR points to a base of our type\n+    // within the complete object. SRC_TYPE indicates the static type\n+    // started from and SRC_PTR points to that base within the most\n+    // derived object. Fill in RESULT with what we find. Return true\n+    // if we have located an ambiguous match.\n+    virtual bool \n+    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,\n+\t\t const __class_type_info* __dst_type, const void* __obj_ptr, \n+\t\t const __class_type_info* __src_type, const void* __src_ptr, \n+\t\t __dyncast_result& __result) const;\n+    \n+    // Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE\n+    // bases are inherited by the type started from -- which is not\n+    // necessarily the current type. The current type will be a base\n+    // of the destination type.  OBJ_PTR points to the current base.\n+    virtual __sub_kind \n+    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,\n+\t\t\t const __class_type_info* __src_type,\n+\t\t\t const void* __src_ptr) const;\n+  };\n+\n+  // Type information for a class with a single non-virtual base.\n+  class __si_class_type_info : public __class_type_info\n+  {\n+  public:\n+    const __class_type_info* __base_type;\n+\n+    explicit \n+    __si_class_type_info(const char *__n, const __class_type_info *__base)\n+    : __class_type_info(__n), __base_type(__base) { }\n+\n+    virtual \n+    ~__si_class_type_info();\n+\n+  protected:\n+    __si_class_type_info(const __si_class_type_info&);\n+\n+    __si_class_type_info&\n+    operator=(const __si_class_type_info&);\n+\n+    // Implementation defined member functions.\n+    virtual bool \n+    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,\n+\t\t const __class_type_info* __dst_type, const void* __obj_ptr,\n+\t\t const __class_type_info* __src_type, const void* __src_ptr,\n+\t\t __dyncast_result& __result) const;\n+\n+    virtual __sub_kind \n+    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,\n+\t\t\t const __class_type_info* __src_type,\n+\t\t\t const void* __sub_ptr) const;\n+\n+    virtual bool \n+    __do_upcast(const __class_type_info*__dst, const void*__obj,\n+\t\t__upcast_result& __restrict __result) const;\n+  };\n+\n+  // Type information for a class with multiple and/or virtual bases.\n+  class __vmi_class_type_info : public __class_type_info \n+  {\n+  public:\n+    unsigned int \t\t__flags;  // Details about the class hierarchy.\n+    unsigned int \t\t__base_count;  // Number of direct bases.\n+\n+    // The array of bases uses the trailing array struct hack so this\n+    // class is not constructable with a normal constructor. It is\n+    // internally generated by the compiler.\n+    __base_class_type_info \t__base_info[1];  // Array of bases.\n+\n+    explicit \n+    __vmi_class_type_info(const char* __n, int ___flags)\n+    : __class_type_info(__n), __flags(___flags), __base_count(0) { }\n+\n+    virtual \n+    ~__vmi_class_type_info();\n+\n+    // Implementation defined types.\n+    enum __flags_masks \n+      {\n+\t__non_diamond_repeat_mask = 0x1, // Distinct instance of repeated base.\n+\t__diamond_shaped_mask = 0x2, // Diamond shaped multiple inheritance.\n+\t__flags_unknown_mask = 0x10\n+      };\n+\n+  protected:\n+    // Implementation defined member functions.\n+    virtual bool \n+    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,\n+\t\t const __class_type_info* __dst_type, const void* __obj_ptr,\n+\t\t const __class_type_info* __src_type, const void* __src_ptr,\n+\t\t __dyncast_result& __result) const;\n+\n+    virtual __sub_kind \n+    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr, \n+\t\t\t const __class_type_info* __src_type,\n+\t\t\t const void* __src_ptr) const;\n+    \n+    virtual bool \n+    __do_upcast(const __class_type_info* __dst, const void* __obj,\n+\t\t__upcast_result& __restrict __result) const;\n+  };\n+\n+  // Dynamic cast runtime.\n+  // src2dst has the following possible values\n+  //  >-1: src_type is a unique public non-virtual base of dst_type\n+  //       dst_ptr + src2dst == src_ptr\n+  //   -1: unspecified relationship\n+  //   -2: src_type is not a public base of dst_type\n+  //   -3: src_type is a multiple public non-virtual base of dst_type\n+  extern \"C\" void*\n+  __dynamic_cast(const void* __src_ptr, // Starting object.\n+\t\t const __class_type_info* __src_type, // Static type of object.\n+\t\t const __class_type_info* __dst_type, // Desired target type.\n+\t\t ptrdiff_t __src2dst); // How src and dst are related.\n+\n+\n+  // Returns the type_info for the currently handled exception [15.3/8], or\n+  // null if there is none.\n+  extern \"C\" std::type_info*\n+  __cxa_current_exception_type();\n+\n+  // A magic placeholder class that can be caught by reference\n+  // to recognize forced unwinding.\n+  class __forced_unwind\n+  {\n+    virtual ~__forced_unwind() throw();\n+    virtual void __pure() = 0; // prevent catch by value\n+  };\n+\n+  // A magic placeholder class that can be caught by reference\n+  // to recognize foreign exceptions.\n+  class __foreign_exception\n+  {\n+    virtual ~__foreign_exception() throw();\n+    virtual void __pure() = 0; // prevent catch by value\n+  };\n+\n+} // namespace __cxxabiv1\n+\n+#endif // __cplusplus\n+\n+#pragma GCC visibility pop\n+\n+#endif // __CXXABI_INTERNAL_H "}, {"sha": "184eff6d738bd4ac0fc6f0014d65062fd56fb163", "filename": "libstdc++-v3/libsupc++/cxxabi.h", "status": "modified", "additions": 1, "deletions": 480, "changes": 481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -48,488 +48,9 @@\n \n #pragma GCC visibility push(default)\n \n-#include <stddef.h>\n-#include <bits/cxxabi_tweaks.h>\n+#include <cxxabi-internal.h>\n  \n #ifdef __cplusplus\n-namespace __cxxabiv1\n-{  \n-  extern \"C\" \n-  {\n-#endif\n-\n-  typedef __cxa_cdtor_return_type (*__cxa_cdtor_type)(void *);\n-\n-  // Allocate array.\n-  void* \n-  __cxa_vec_new(size_t __element_count, size_t __element_size, \n-\t\tsize_t __padding_size, __cxa_cdtor_type constructor,\n-\t\t__cxa_cdtor_type destructor);\n-\n-  void*\n-  __cxa_vec_new2(size_t __element_count, size_t __element_size,\n-\t\t size_t __padding_size, __cxa_cdtor_type constructor,\n-\t\t __cxa_cdtor_type destructor, void *(*__alloc) (size_t), \n-\t\t void (*__dealloc) (void*));\n-\n-  void*\n-  __cxa_vec_new3(size_t __element_count, size_t __element_size,\n-\t\t size_t __padding_size, __cxa_cdtor_type constructor,\n-\t\t __cxa_cdtor_type destructor, void *(*__alloc) (size_t), \n-\t\t void (*__dealloc) (void*, size_t));\n-\n-  // Construct array.\n-  __cxa_vec_ctor_return_type\n-  __cxa_vec_ctor(void* __array_address, size_t __element_count,\n-\t\t size_t __element_size, __cxa_cdtor_type constructor,\n-\t\t __cxa_cdtor_type destructor);\n-\n-  __cxa_vec_ctor_return_type\n-  __cxa_vec_cctor(void* dest_array, void* src_array, size_t element_count, \n-\t\t  size_t element_size, \n-\t\t  __cxa_cdtor_return_type (*constructor) (void*, void*), \n-\t\t  __cxa_cdtor_type destructor);\n- \n-  // Destruct array.\n-  void \n-  __cxa_vec_dtor(void* __array_address, size_t __element_count,\n-\t\t size_t __element_size, __cxa_cdtor_type destructor);\n-  \n-  void \n-  __cxa_vec_cleanup(void* __array_address, size_t __element_count,\n-\t\t    size_t __element_size, __cxa_cdtor_type destructor);\n-  \n-  // Destruct and release array.\n-  void \n-  __cxa_vec_delete(void* __array_address, size_t __element_size,\n-\t\t   size_t __padding_size, __cxa_cdtor_type destructor);\n-\n-  void \n-  __cxa_vec_delete2(void* __array_address, size_t __element_size,\n-\t\t    size_t __padding_size, __cxa_cdtor_type destructor,\n-\t\t    void (*__dealloc) (void*));\n-                  \n-  void \n-  __cxa_vec_delete3(void* __array_address, size_t __element_size,\n-\t\t    size_t __padding_size, __cxa_cdtor_type destructor,\n-\t\t    void (*__dealloc) (void*, size_t));\n-\n-  int \n-  __cxa_guard_acquire(__guard*);\n-\n-  void \n-  __cxa_guard_release(__guard*);\n-\n-  void \n-  __cxa_guard_abort(__guard*);\n-\n-  // Pure virtual functions.\n-  void\n-  __cxa_pure_virtual(void);\n-\n-  // Exception handling.\n-  void\n-  __cxa_bad_cast();\n-\n-  void\n-  __cxa_bad_typeid();\n-\n-  // DSO destruction.\n-  int\n-  __cxa_atexit(void (*)(void*), void*, void*)\n-#ifdef __cplusplus\n-    throw ()\n-#endif\n-    ;\n-\n-  int\n-  __cxa_finalize(void*);\n-\n-  // Demangling routines. \n-  char*\n-  __cxa_demangle(const char* __mangled_name, char* __output_buffer,\n-\t\t size_t* __length, int* __status);\n-#ifdef __cplusplus\n-  }\n-} // namespace __cxxabiv1\n-#endif\n-\n-#ifdef __cplusplus\n-\n-#include <typeinfo>\n-\n-namespace __cxxabiv1\n-{\n-  // Type information for int, float etc.\n-  class __fundamental_type_info : public std::type_info\n-  {\n-  public:\n-    explicit \n-    __fundamental_type_info(const char* __n) : std::type_info(__n) { }\n-\n-    virtual \n-    ~__fundamental_type_info();\n-  };\n-\n-  // Type information for array objects.\n-  class __array_type_info : public std::type_info\n-  {\n-  public:\n-    explicit \n-    __array_type_info(const char* __n) : std::type_info(__n) { }\n-\n-    virtual \n-    ~__array_type_info();\n-  };\n-\n-  // Type information for functions (both member and non-member).\n-  class __function_type_info : public std::type_info\n-  {\n-  public:\n-    explicit \n-    __function_type_info(const char* __n) : std::type_info(__n) { }\n-\n-    virtual \n-    ~__function_type_info();\n-\n-  protected:\n-    // Implementation defined member function.\n-    virtual bool \n-    __is_function_p() const;\n-  };\n-\n-  // Type information for enumerations.\n-  class __enum_type_info : public std::type_info\n-  {\n-  public:\n-    explicit \n-    __enum_type_info(const char* __n) : std::type_info(__n) { }\n-\n-    virtual \n-    ~__enum_type_info();\n-  };\n-\n-  // Common type information for simple pointers and pointers to member.\n-  class __pbase_type_info : public std::type_info\n-  {\n-  public:\n-    unsigned int \t\t__flags; // Qualification of the target object.\n-    const std::type_info* \t__pointee; // Type of pointed to object.\n-\n-    explicit \n-    __pbase_type_info(const char* __n, int __quals, \n-\t\t      const std::type_info* __type)\n-    : std::type_info(__n), __flags(__quals), __pointee(__type)\n-    { }\n-    \n-    virtual \n-    ~__pbase_type_info();\n-\n-    // Implementation defined type.\n-    enum __masks \n-      {\n-\t__const_mask = 0x1,\n-\t__volatile_mask = 0x2,\n-\t__restrict_mask = 0x4,\n-\t__incomplete_mask = 0x8,\n-\t__incomplete_class_mask = 0x10\n-      };\n-\n-  protected:\n-    __pbase_type_info(const __pbase_type_info&);\n-\n-    __pbase_type_info&\n-    operator=(const __pbase_type_info&);\n-\n-    // Implementation defined member functions.\n-    virtual bool \n-    __do_catch(const std::type_info* __thr_type, void** __thr_obj, \n-\t       unsigned int __outer) const;\n-\n-    inline virtual bool \n-    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,\n-\t\t    unsigned __outer) const;\n-  };\n-\n-  // Type information for simple pointers.\n-  class __pointer_type_info : public __pbase_type_info\n-  {\n-  public:\n-    explicit \n-    __pointer_type_info(const char* __n, int __quals, \n-\t\t\tconst std::type_info* __type)\n-    : __pbase_type_info (__n, __quals, __type) { }\n-\n-\n-    virtual \n-    ~__pointer_type_info();\n-\n-  protected:\n-    // Implementation defined member functions.\n-    virtual bool \n-    __is_pointer_p() const;\n-\n-    virtual bool \n-    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj, \n-\t\t    unsigned __outer) const;\n-  };\n-\n-  class __class_type_info;\n-\n-  // Type information for a pointer to member variable.\n-  class __pointer_to_member_type_info : public __pbase_type_info\n-  {\n-  public:\n-    __class_type_info* __context;   // Class of the member.\n-\n-    explicit \n-    __pointer_to_member_type_info(const char* __n, int __quals,\n-\t\t\t\t  const std::type_info* __type, \n-\t\t\t\t  __class_type_info* __klass)\n-    : __pbase_type_info(__n, __quals, __type), __context(__klass) { }\n-\n-    virtual \n-    ~__pointer_to_member_type_info();\n-\n-  protected:\n-    __pointer_to_member_type_info(const __pointer_to_member_type_info&);\n-\n-    __pointer_to_member_type_info&\n-    operator=(const __pointer_to_member_type_info&);\n-\n-    // Implementation defined member function.\n-    virtual bool \n-    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,\n-\t\t    unsigned __outer) const;\n-  };\n-\n-  // Helper class for __vmi_class_type.\n-  class __base_class_type_info\n-  {\n-  public:\n-    const __class_type_info* \t__base_type;  // Base class type.\n-    long \t\t\t__offset_flags;  // Offset and info.\n-\n-    enum __offset_flags_masks \n-      {\n-\t__virtual_mask = 0x1,\n-\t__public_mask = 0x2,\n-\t__hwm_bit = 2,\n-\t__offset_shift = 8          // Bits to shift offset.\n-      };\n-  \n-    // Implementation defined member functions.\n-    bool \n-    __is_virtual_p() const\n-    { return __offset_flags & __virtual_mask; }\n-\n-    bool \n-    __is_public_p() const\n-    { return __offset_flags & __public_mask; }\n-\n-    ptrdiff_t \n-    __offset() const\n-    { \n-      // This shift, being of a signed type, is implementation\n-      // defined. GCC implements such shifts as arithmetic, which is\n-      // what we want.\n-      return static_cast<ptrdiff_t>(__offset_flags) >> __offset_shift;\n-    }\n-  };\n-\n-  // Type information for a class.\n-  class __class_type_info : public std::type_info\n-  {\n-  public:\n-    explicit \n-    __class_type_info (const char *__n) : type_info(__n) { }\n-\n-    virtual \n-    ~__class_type_info ();\n-\n-    // Implementation defined types.\n-    // The type sub_kind tells us about how a base object is contained\n-    // within a derived object. We often do this lazily, hence the\n-    // UNKNOWN value. At other times we may use NOT_CONTAINED to mean\n-    // not publicly contained.\n-    enum __sub_kind\n-      {\n-\t// We have no idea.\n-\t__unknown = 0, \n-\n-\t// Not contained within us (in some circumstances this might\n-\t// mean not contained publicly)\n-\t__not_contained, \n-\n-\t// Contained ambiguously.\n-\t__contained_ambig, \n-    \n-\t// Via a virtual path.\n-\t__contained_virtual_mask = __base_class_type_info::__virtual_mask, \n-\n-\t// Via a public path.\n-\t__contained_public_mask = __base_class_type_info::__public_mask,   \n-\n-\t// Contained within us.\n-\t__contained_mask = 1 << __base_class_type_info::__hwm_bit,\n-    \n-\t__contained_private = __contained_mask,\n-\t__contained_public = __contained_mask | __contained_public_mask\n-      };\n-\n-    struct __upcast_result;\n-    struct __dyncast_result;\n-\n-  protected:\n-    // Implementation defined member functions.\n-    virtual bool \n-    __do_upcast(const __class_type_info* __dst_type, void**__obj_ptr) const;\n-\n-    virtual bool \n-    __do_catch(const type_info* __thr_type, void** __thr_obj, \n-\t       unsigned __outer) const;\n-\n-  public:\n-    // Helper for upcast. See if DST is us, or one of our bases. \n-    // Return false if not found, true if found. \n-    virtual bool \n-    __do_upcast(const __class_type_info* __dst, const void* __obj,\n-\t\t__upcast_result& __restrict __result) const;\n-\n-    // Indicate whether SRC_PTR of type SRC_TYPE is contained publicly\n-    // within OBJ_PTR. OBJ_PTR points to a base object of our type,\n-    // which is the destination type. SRC2DST indicates how SRC\n-    // objects might be contained within this type.  If SRC_PTR is one\n-    // of our SRC_TYPE bases, indicate the virtuality. Returns\n-    // not_contained for non containment or private containment.\n-    inline __sub_kind \n-    __find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,\n-\t\t      const __class_type_info* __src_type, \n-\t\t      const void* __src_ptr) const;\n-\n-    // Helper for dynamic cast. ACCESS_PATH gives the access from the\n-    // most derived object to this base. DST_TYPE indicates the\n-    // desired type we want. OBJ_PTR points to a base of our type\n-    // within the complete object. SRC_TYPE indicates the static type\n-    // started from and SRC_PTR points to that base within the most\n-    // derived object. Fill in RESULT with what we find. Return true\n-    // if we have located an ambiguous match.\n-    virtual bool \n-    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,\n-\t\t const __class_type_info* __dst_type, const void* __obj_ptr, \n-\t\t const __class_type_info* __src_type, const void* __src_ptr, \n-\t\t __dyncast_result& __result) const;\n-    \n-    // Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE\n-    // bases are inherited by the type started from -- which is not\n-    // necessarily the current type. The current type will be a base\n-    // of the destination type.  OBJ_PTR points to the current base.\n-    virtual __sub_kind \n-    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,\n-\t\t\t const __class_type_info* __src_type,\n-\t\t\t const void* __src_ptr) const;\n-  };\n-\n-  // Type information for a class with a single non-virtual base.\n-  class __si_class_type_info : public __class_type_info\n-  {\n-  public:\n-    const __class_type_info* __base_type;\n-\n-    explicit \n-    __si_class_type_info(const char *__n, const __class_type_info *__base)\n-    : __class_type_info(__n), __base_type(__base) { }\n-\n-    virtual \n-    ~__si_class_type_info();\n-\n-  protected:\n-    __si_class_type_info(const __si_class_type_info&);\n-\n-    __si_class_type_info&\n-    operator=(const __si_class_type_info&);\n-\n-    // Implementation defined member functions.\n-    virtual bool \n-    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,\n-\t\t const __class_type_info* __dst_type, const void* __obj_ptr,\n-\t\t const __class_type_info* __src_type, const void* __src_ptr,\n-\t\t __dyncast_result& __result) const;\n-\n-    virtual __sub_kind \n-    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,\n-\t\t\t const __class_type_info* __src_type,\n-\t\t\t const void* __sub_ptr) const;\n-\n-    virtual bool \n-    __do_upcast(const __class_type_info*__dst, const void*__obj,\n-\t\t__upcast_result& __restrict __result) const;\n-  };\n-\n-  // Type information for a class with multiple and/or virtual bases.\n-  class __vmi_class_type_info : public __class_type_info \n-  {\n-  public:\n-    unsigned int \t\t__flags;  // Details about the class hierarchy.\n-    unsigned int \t\t__base_count;  // Number of direct bases.\n-\n-    // The array of bases uses the trailing array struct hack so this\n-    // class is not constructable with a normal constructor. It is\n-    // internally generated by the compiler.\n-    __base_class_type_info \t__base_info[1];  // Array of bases.\n-\n-    explicit \n-    __vmi_class_type_info(const char* __n, int ___flags)\n-    : __class_type_info(__n), __flags(___flags), __base_count(0) { }\n-\n-    virtual \n-    ~__vmi_class_type_info();\n-\n-    // Implementation defined types.\n-    enum __flags_masks \n-      {\n-\t__non_diamond_repeat_mask = 0x1, // Distinct instance of repeated base.\n-\t__diamond_shaped_mask = 0x2, // Diamond shaped multiple inheritance.\n-\t__flags_unknown_mask = 0x10\n-      };\n-\n-  protected:\n-    // Implementation defined member functions.\n-    virtual bool \n-    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,\n-\t\t const __class_type_info* __dst_type, const void* __obj_ptr,\n-\t\t const __class_type_info* __src_type, const void* __src_ptr,\n-\t\t __dyncast_result& __result) const;\n-\n-    virtual __sub_kind \n-    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr, \n-\t\t\t const __class_type_info* __src_type,\n-\t\t\t const void* __src_ptr) const;\n-    \n-    virtual bool \n-    __do_upcast(const __class_type_info* __dst, const void* __obj,\n-\t\t__upcast_result& __restrict __result) const;\n-  };\n-\n-  // Dynamic cast runtime.\n-  // src2dst has the following possible values\n-  //  >-1: src_type is a unique public non-virtual base of dst_type\n-  //       dst_ptr + src2dst == src_ptr\n-  //   -1: unspecified relationship\n-  //   -2: src_type is not a public base of dst_type\n-  //   -3: src_type is a multiple public non-virtual base of dst_type\n-  extern \"C\" void*\n-  __dynamic_cast(const void* __src_ptr, // Starting object.\n-\t\t const __class_type_info* __src_type, // Static type of object.\n-\t\t const __class_type_info* __dst_type, // Desired target type.\n-\t\t ptrdiff_t __src2dst); // How src and dst are related.\n-\n-\n-  // Returns the type_info for the currently handled exception [15.3/8], or\n-  // null if there is none.\n-  extern \"C\" std::type_info*\n-  __cxa_current_exception_type();\n-} // namespace __cxxabiv1\n \n // User programs should use the alias `abi'. \n namespace abi = __cxxabiv1;"}, {"sha": "0de893043949069794894bb1453f12b817cdf33d", "filename": "libstdc++-v3/libsupc++/eh_exception.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_exception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_exception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_exception.cc?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -31,12 +31,16 @@\n \n #include \"typeinfo\"\n #include \"exception\"\n-#include \"unwind-cxx.h\"\n+#include <cxxabi.h>\n \n std::exception::~exception() throw() { }\n \n std::bad_exception::~bad_exception() throw() { }\n \n+abi::__forced_unwind::~__forced_unwind() throw() { }\n+\n+abi::__foreign_exception::~__foreign_exception() throw() { }\n+\n const char* \n std::exception::what() const throw()\n {"}, {"sha": "bbcc0072730074c3c87dd5c51b9c1bddd3c23a05", "filename": "libstdc++-v3/libsupc++/eh_personality.cc", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -30,6 +30,7 @@\n #include <bits/c++config.h>\n #include <cstdlib>\n #include <exception_defines.h>\n+#include <cxxabi.h>\n #include \"unwind-cxx.h\"\n \n using namespace __cxxabiv1;\n@@ -541,13 +542,19 @@ PERSONALITY_FUNCTION (int version,\n       bool saw_cleanup = false;\n       bool saw_handler = false;\n \n-      // During forced unwinding, we only run cleanups.  With a foreign\n-      // exception class, there's no exception type.\n-      // ??? What to do about GNU Java and GNU Ada exceptions.\n-\n-      if ((actions & _UA_FORCE_UNWIND)\n-\t  || foreign_exception)\n-\tthrow_type = 0;\n+      // During forced unwinding, match a magic exception type.\n+      if (actions & _UA_FORCE_UNWIND)\n+\t{\n+\t  throw_type = &typeid(abi::__forced_unwind);\n+\t  thrown_ptr = 0;\n+\t}\n+      // With a foreign exception class, there's no exception type.\n+      // ??? What to do about GNU Java and GNU Ada exceptions?\n+      else if (foreign_exception)\n+\t{\n+\t  throw_type = &typeid(abi::__foreign_exception);\n+\t  thrown_ptr = 0;\n+\t}\n       else\n #ifdef __ARM_EABI_UNWINDER__\n \tthrow_type = ue_header;\n@@ -590,7 +597,9 @@ PERSONALITY_FUNCTION (int version,\n \t      // object to stuff bits in for __cxa_call_unexpected to use.\n \t      // Allow them iff the exception spec is non-empty.  I.e.\n \t      // a throw() specification results in __unexpected.\n-\t      if (throw_type\n+\t      if ((throw_type\n+\t\t   && !(actions & _UA_FORCE_UNWIND)\n+\t\t   && !foreign_exception)\n \t\t  ? ! check_exception_spec (&info, throw_type, thrown_ptr,\n \t\t\t\t\t    ar_filter)\n \t\t  : empty_exception_spec (&info, ar_filter))"}, {"sha": "b29040c429aff78115f5de2624b5bb19899eb350", "filename": "libstdc++-v3/src/compatibility.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Fsrc%2Fcompatibility.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Fsrc%2Fcompatibility.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fcompatibility.cc?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -114,6 +114,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      if (traits_type::eq_int_type(__c, __eof))\n \t\t__err |= ios_base::eofbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t  if (__err)\n@@ -180,6 +185,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      if (traits_type::eq_int_type(__c, __eof))\n \t\t__err |= ios_base::eofbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t  if (__err)"}, {"sha": "fc140c0c3c37797a2b6fdd2b2caf00a0ca86a9d5", "filename": "libstdc++-v3/src/ios.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Fsrc%2Fios.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Fsrc%2Fios.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fios.cc?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -127,7 +127,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t    __newsize = __ix + 1;\n \t    try\n \t      { __words = new _Words[__newsize]; }\n-\t    catch (...)\n+\t    catch(...)\n \t      {\n \t\t_M_streambuf_state |= badbit;\n \t\tif (_M_streambuf_state & _M_exception)\n@@ -172,7 +172,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       {\n \ttry \n \t  { (*__p->_M_fn) (__e, *this, __p->_M_index); } \n-\tcatch (...) \n+\tcatch(...) \n \t  { }\n \t__p = __p->_M_next;\n       }"}, {"sha": "62d42ee65b61470ecd2bc3afc0cba11122c3f374", "filename": "libstdc++-v3/src/ios_init.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Fsrc%2Fios_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Fsrc%2Fios_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fios_init.cc?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -142,7 +142,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t    wclog.flush();    \n #endif\n \t  }\n-\tcatch (...)\n+\tcatch(...)\n \t  { }\n       }\n   } "}, {"sha": "319202ee4c3af177e8ec9ac0bd4672c5b0166e89", "filename": "libstdc++-v3/src/istream.cc", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Fsrc%2Fistream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05f74f16e130e97210ad2eaad12915192ea8c9e/libstdc%2B%2B-v3%2Fsrc%2Fistream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fistream.cc?ref=d05f74f16e130e97210ad2eaad12915192ea8c9e", "patch": "@@ -91,6 +91,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      else\n \t\t__err |= ios_base::failbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t}\n@@ -177,6 +182,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t  __sb->sbumpc();\n \t\t}\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t  if (__err)\n@@ -251,6 +261,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      *__s = __char_type();\n \t      __in.width(0);\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      __in._M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { __in._M_setstate(ios_base::badbit); }\n \t}\n@@ -321,6 +336,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t__err |= ios_base::eofbit;\n \t      __in.width(0);\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      __in._M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    {\n \t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -401,6 +421,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      else\n \t\t__err |= ios_base::failbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      __in._M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    {\n \t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -473,6 +498,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      else\n \t\t__err |= ios_base::failbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t}\n@@ -559,6 +589,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t  __sb->sbumpc();\n \t\t}\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      this->_M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t  if (__err)\n@@ -632,6 +667,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      else\n \t\t__err |= ios_base::failbit;\n \t    }\n+\t  catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      __in._M_setstate(ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n \t  catch(...)\n \t    {\n \t      // _GLIBCXX_RESOLVE_LIB_DEFECTS"}]}