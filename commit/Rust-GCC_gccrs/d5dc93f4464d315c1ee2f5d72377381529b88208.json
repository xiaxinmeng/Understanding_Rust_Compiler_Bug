{"sha": "d5dc93f4464d315c1ee2f5d72377381529b88208", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVkYzkzZjQ0NjRkMzE1YzFlZTJmNWQ3MjM3NzM4MTUyOWI4ODIwOA==", "commit": {"author": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2011-01-08T14:12:14Z"}, "committer": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2011-01-08T14:12:14Z"}, "message": "ObjC NeXT, split encode-support code from next-mapping.h \n\n\t* objc-obj-c++-shared/next-mapping.h: Move code and definitions for\n\temulation of libobjc-gnu structure layout functionality to ..\n\t* objc-obj-c++-shared/objc-test-suite-next-encode-assist.h: New.\n\t* objc-obj-c++-shared/objc-test-suite-next-encode-assist-impl.h: New.\n\t* objc/execute/bf-common.h: Adjust headers.\n\t* objc/execute/bf-1.m: Likewise.\n\t* objc/execute/bf-2.m: Likewise.\n\t* objc/execute/bf-3.m: Likewise.\n\t* objc/execute/bf-4.m: Likewise.\n\t* objc/execute/bf-5.m: Likewise.\n\t* objc/execute/bf-6.m: Likewise.\n\t* objc/execute/bf-7.m: Likewise.\n\t* objc/execute/bf-8.m: Likewise.\n\t* objc/execute/bf-9.m: Likewise.\n\t* objc/execute/bf-10.m: Likewise.\n\t* objc/execute/bf-11.m: Likewise.\n\t* objc/execute/bf-12.m: Likewise.\n\t* objc/execute/bf-13.m: Likewise.\n\t* objc/execute/bf-14.m: Likewise.\n\t* objc/execute/bf-15.m: Likewise.\n\t* objc/execute/bf-16.m: Likewise.\n\t* objc/execute/bf-17.m: Likewise.\n\t* objc/execute/bf-18.m: Likewise.\n\t* objc/execute/bf-19.m: Likewise.\n\t* objc/execute/bf-20.m: Likewise.\n\t* objc/execute/bf-21.m: Likewise.\n\t* objc/execute/bycopy-3.m: Adjust headers, add next-specific code for\n\tobjc_get_type_qualifiers ().\n\nFrom-SVN: r168597", "tree": {"sha": "c9cef10888f13a820fe64443d26bc8d8fc3d1581", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9cef10888f13a820fe64443d26bc8d8fc3d1581"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5dc93f4464d315c1ee2f5d72377381529b88208", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5dc93f4464d315c1ee2f5d72377381529b88208", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5dc93f4464d315c1ee2f5d72377381529b88208", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5dc93f4464d315c1ee2f5d72377381529b88208/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecb3baaa8e973e3963eee7929bfd2fc419a2a950", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecb3baaa8e973e3963eee7929bfd2fc419a2a950", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecb3baaa8e973e3963eee7929bfd2fc419a2a950"}], "stats": {"total": 1843, "additions": 963, "deletions": 880}, "files": [{"sha": "968564ead4ac5d9c820f13242c78c278b079f837", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,3 +1,34 @@\n+2011-01-08  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\t* objc-obj-c++-shared/next-mapping.h: Move code and definitions for\n+\temulation of libobjc-gnu structure layout functionality to ..\n+\t* objc-obj-c++-shared/objc-test-suite-next-encode-assist.h: New.\n+\t* objc-obj-c++-shared/objc-test-suite-next-encode-assist-impl.h: New.\n+\t* objc/execute/bf-common.h: Adjust headers.\n+\t* objc/execute/bf-1.m: Likewise.\n+\t* objc/execute/bf-2.m: Likewise.\n+\t* objc/execute/bf-3.m: Likewise.\n+\t* objc/execute/bf-4.m: Likewise.\n+\t* objc/execute/bf-5.m: Likewise.\n+\t* objc/execute/bf-6.m: Likewise.\n+\t* objc/execute/bf-7.m: Likewise.\n+\t* objc/execute/bf-8.m: Likewise.\n+\t* objc/execute/bf-9.m: Likewise.\n+\t* objc/execute/bf-10.m: Likewise.\n+\t* objc/execute/bf-11.m: Likewise.\n+\t* objc/execute/bf-12.m: Likewise.\n+\t* objc/execute/bf-13.m: Likewise.\n+\t* objc/execute/bf-14.m: Likewise.\n+\t* objc/execute/bf-15.m: Likewise.\n+\t* objc/execute/bf-16.m: Likewise.\n+\t* objc/execute/bf-17.m: Likewise.\n+\t* objc/execute/bf-18.m: Likewise.\n+\t* objc/execute/bf-19.m: Likewise.\n+\t* objc/execute/bf-20.m: Likewise.\n+\t* objc/execute/bf-21.m: Likewise.\n+\t* objc/execute/bycopy-3.m: Adjust headers, add next-specific code for\n+\tobjc_get_type_qualifiers ().\n+\n 2011-01-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/45777"}, {"sha": "3b141c67a67de4a4d88aedfab8d3447207f66cef", "filename": "gcc/testsuite/objc-obj-c++-shared/next-mapping.h", "status": "modified", "additions": 5, "deletions": 834, "changes": 839, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc-obj-c%2B%2B-shared%2Fnext-mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc-obj-c%2B%2B-shared%2Fnext-mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc-obj-c%2B%2B-shared%2Fnext-mapping.h?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,3 +1,6 @@\n+#ifndef _OBJC_NEXT_MAPPING_H_\n+#define _OBJC_NEXT_MAPPING_H_\n+\n /* This file \"renames\" various ObjC GNU runtime entry points\n    (and fakes the existence of several others)\n    if the NeXT runtime is being used.  */\n@@ -81,839 +84,6 @@\n #define NULL 0\n #endif\n \n-/* The following is necessary to \"cover\" the bf*.m test cases on NeXT.  */\n-\n-#undef  MAX\n-#undef  MIN\n-#undef  ROUND\n-\n-#ifdef __cplusplus\n-#  define MAX(X, Y) ((X > Y) ? X : Y)\n-#  define MIN(X, Y) ((X < Y) ? X : Y)\n-#  define ROUND(V, A) (A * ((V + A - 1) / A))\n-#else\n-#  define MAX(X, Y)                    \\\n-  ({ typeof (X) __x = (X), __y = (Y); \\\n-     (__x > __y ? __x : __y); })\n-#  define MIN(X, Y)                    \\\n-  ({ typeof (X) __x = (X), __y = (Y); \\\n-     (__x < __y ? __x : __y); })\n-#  define ROUND(V, A) \\\n-  ({ typeof (V) __v = (V); typeof (A) __a = (A); \\\n-     __a * ((__v+__a - 1)/__a); })\n-#endif\n-\n-#define BITS_PER_UNIT __CHAR_BIT__\n-typedef struct{ char a; } __small_struct;\n-#define STRUCTURE_SIZE_BOUNDARY (BITS_PER_UNIT * sizeof (__small_struct))\n-\n-/* Not sure why the following are missing from NeXT objc headers... */\n-\n-#ifndef _C_LNG_LNG\n-#define _C_LNG_LNG  'q'\n-#endif\n-#ifndef _C_ULNG_LNG\n-#define _C_ULNG_LNG 'Q'\n-#endif\n-#ifndef _C_ATOM\n-#define _C_ATOM     '%'\n-#endif\n-#ifndef _C_BOOL\n-#define _C_BOOL     'B'\n-#endif\n-\n-#define _C_CONST        'r'\n-#define _C_IN           'n'\n-#define _C_INOUT        'N'\n-#define _C_OUT          'o'\n-#define _C_BYCOPY       'O'\n-#define _C_BYREF        'R'\n-#define _C_ONEWAY       'V'\n-#define _C_GCINVISIBLE  '!'\n-   \n-#define _F_CONST        0x01\n-#define _F_IN           0x01\n-#define _F_OUT          0x02\n-#define _F_INOUT        0x03\n-#define _F_BYCOPY       0x04  \n-#define _F_BYREF        0x08  \n-#define _F_ONEWAY       0x10\n-#define _F_GCINVISIBLE  0x20\n-\n-struct objc_struct_layout\n-{\n-  const char *original_type;\n-  const char *type;\n-  const char *prev_type;\n-  unsigned int record_size; \n-  unsigned int record_align;\n-};\n-\n-typedef union arglist {\n-  char *arg_ptr;\n-  char arg_regs[sizeof (char*)];\n-} *arglist_t;                   /* argument frame */\n-\n-const char *objc_skip_typespec (const char *type);\n-void objc_layout_structure_get_info (struct objc_struct_layout *layout,\n-    unsigned int *offset, unsigned int *align, const char **type);\n-void objc_layout_structure (const char *type,\n-    struct objc_struct_layout *layout);\n-BOOL objc_layout_structure_next_member (struct objc_struct_layout *layout);\n-void objc_layout_finish_structure (struct objc_struct_layout *layout,\n-    unsigned int *size, unsigned int *align);\n-int objc_aligned_size (const char *type);\n-\n-/*\n-  return the size of an object specified by type\n-*/\n-\n-int\n-objc_sizeof_type (const char *type)\n-{\n-  /* Skip the variable name if any */\n-  if (*type == '\"')\n-    {\n-      for (type++; *type++ != '\"';)\n-\t/* do nothing */;\n-    }\n-\n-  switch (*type) {\n-  case _C_ID:\n-    return sizeof (id);\n-    break;\n-\n-  case _C_CLASS:\n-    return sizeof (Class);\n-    break;\n-\n-  case _C_SEL:\n-    return sizeof (SEL);\n-    break;\n-\n-  case _C_CHR:\n-    return sizeof (char);\n-    break;\n-\n-  case _C_UCHR:\n-    return sizeof (unsigned char);\n-    break;\n-\n-  case _C_SHT:\n-    return sizeof (short);\n-    break;\n-\n-  case _C_USHT:\n-    return sizeof (unsigned short);\n-    break;\n-\n-  case _C_INT:\n-    return sizeof (int);\n-    break;\n-\n-  case _C_UINT:\n-    return sizeof (unsigned int);\n-    break;\n-\n-  case _C_LNG:\n-    return sizeof (long);\n-    break;\n-\n-  case _C_ULNG:\n-    return sizeof (unsigned long);\n-    break;\n-\n-  case _C_LNG_LNG:\n-    return sizeof (long long);\n-    break;\n-\n-  case _C_ULNG_LNG:\n-    return sizeof (unsigned long long);\n-    break;\n-\n-  case _C_FLT:\n-    return sizeof (float);\n-    break;\n-\n-  case _C_DBL:\n-    return sizeof (double);\n-    break;\n-\n-  case _C_PTR:\n-  case _C_ATOM:\n-  case _C_CHARPTR:\n-    return sizeof (char *);\n-    break;\n-\n-  case _C_ARY_B:\n-    {\n-      int len = atoi (type + 1);\n-      while (isdigit ((unsigned char)*++type))\n-\t;\n-      return len * objc_aligned_size (type);\n-    }\n-    break;\n-\n-  case _C_BFLD:\n-    {\n-      /* The NeXT encoding of bitfields is _still_: b 'size' */\n-      int size = atoi (type + 1);\n-      /* Return an upper bound on byte size */\n-      return (size + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n-    }\n-\n-  case _C_STRUCT_B:\n-    {\n-      struct objc_struct_layout layout;\n-      unsigned int size;\n-\n-      objc_layout_structure (type, &layout);\n-      while (objc_layout_structure_next_member (&layout))\n-        /* do nothing */ ;\n-      objc_layout_finish_structure (&layout, &size, NULL);\n-\n-      return size;\n-    }\n-\n-  case _C_UNION_B:\n-    {\n-      int max_size = 0;\n-      while (*type != _C_UNION_E && *type++ != '=')\n-\t/* do nothing */;\n-      while (*type != _C_UNION_E)\n-\t{\n-\t  /* Skip the variable name if any */\n-\t  if (*type == '\"')\n-\t    {\n-\t      for (type++; *type++ != '\"';)\n-\t\t/* do nothing */;\n-\t    }\n-\t  max_size = MAX (max_size, objc_sizeof_type (type));\n-\t  type = objc_skip_typespec (type);\n-\t}\n-      return max_size;\n-    }\n-  }\n-  return 0; /* error */\n-}\n-\n-\n-/*\n-  Return the alignment of an object specified by type\n-*/\n-\n-int\n-objc_alignof_type (const char *type)\n-{\n-  /* Skip the variable name if any */\n-  if (*type == '\"')\n-    {\n-      for (type++; *type++ != '\"';)\n-\t/* do nothing */;\n-    }\n-  switch (*type) {\n-  case _C_ID:\n-    return __alignof__ (id);\n-    break;\n-\n-  case _C_CLASS:\n-    return __alignof__ (Class);\n-    break;\n-\n-  case _C_SEL:\n-    return __alignof__ (SEL);\n-    break;\n-\n-  case _C_CHR:\n-    return __alignof__ (char);\n-    break;\n-\n-  case _C_UCHR:\n-    return __alignof__ (unsigned char);\n-    break;\n-\n-  case _C_SHT:\n-    return __alignof__ (short);\n-    break;\n-\n-  case _C_USHT:\n-    return __alignof__ (unsigned short);\n-    break;\n-\n-  case _C_INT:\n-  case _C_BFLD: /* This is for the NeXT only */\n-    return __alignof__ (int);\n-    break;\n-\n-  case _C_UINT:\n-    return __alignof__ (unsigned int);\n-    break;\n-\n-  case _C_LNG:\n-    return __alignof__ (long);\n-    break;\n-\n-  case _C_ULNG:\n-    return __alignof__ (unsigned long);\n-    break;\n-\n-  case _C_LNG_LNG:\n-    return __alignof__ (long long);\n-    break;\n-\n-  case _C_ULNG_LNG:\n-    return __alignof__ (unsigned long long);\n-    break;\n-\n-  case _C_FLT:\n-    return __alignof__ (float);\n-    break;\n-\n-  case _C_DBL:\n-    return __alignof__ (double);\n-    break;\n-\n-  case _C_PTR:\n-  case _C_ATOM:\n-  case _C_CHARPTR:\n-    return __alignof__ (char *);\n-    break;\n-\n-  case _C_ARY_B:\n-    while (isdigit ((unsigned char)*++type))\n-      /* do nothing */;\n-    return objc_alignof_type (type);\n-\n-  case _C_STRUCT_B:\n-    {\n-      struct objc_struct_layout layout;\n-      unsigned int align;\n-\n-      objc_layout_structure (type, &layout);\n-      while (objc_layout_structure_next_member (&layout))\n-        /* do nothing */;\n-      objc_layout_finish_structure (&layout, NULL, &align);\n-\n-      return align;\n-    }\n-\n-  case _C_UNION_B:\n-    {\n-      int maxalign = 0;\n-      while (*type != _C_UNION_E && *type++ != '=')\n-\t/* do nothing */;\n-      while (*type != _C_UNION_E)\n-\t{\n-\t  /* Skip the variable name if any */\n-\t  if (*type == '\"')\n-\t    {\n-\t      for (type++; *type++ != '\"';)\n-\t\t/* do nothing */;\n-\t    }\n-\t  maxalign = MAX (maxalign, objc_alignof_type (type));\n-\t  type = objc_skip_typespec (type);\n-\t}\n-      return maxalign;\n-    }\n-  }\n-  return 0; /* error */\n-}\n-\n-/*\n-  The aligned size if the size rounded up to the nearest alignment.\n-*/\n-\n-int\n-objc_aligned_size (const char *type)\n-{\n-  int size, align;\n-\n-  /* Skip the variable name */\n-  if (*type == '\"')\n-    {\n-      for (type++; *type++ != '\"';)\n-\t/* do nothing */;\n-    }\n-\n-  size = objc_sizeof_type (type);\n-  align = objc_alignof_type (type);\n-\n-  return ROUND (size, align);\n-}\n-\n-/*\n-  The size rounded up to the nearest integral of the wordsize, taken\n-  to be the size of a void *.\n-*/\n-\n-int\n-objc_promoted_size (const char *type)\n-{\n-  int size, wordsize;\n-\n-  /* Skip the variable name */\n-  if (*type == '\"')\n-    {\n-      for (type++; *type++ != '\"';)\n-\t/* do nothing */;\n-    }\n-\n-  size = objc_sizeof_type (type);\n-  wordsize = sizeof (void *);\n-\n-  return ROUND (size, wordsize);\n-}\n-\n-/*\n-  Skip type qualifiers.  These may eventually precede typespecs\n-  occurring in method prototype encodings.\n-*/\n-\n-inline const char *\n-objc_skip_type_qualifiers (const char *type)\n-{\n-  while (*type == _C_CONST\n-\t || *type == _C_IN\n-\t || *type == _C_INOUT\n-\t || *type == _C_OUT\n-\t || *type == _C_BYCOPY\n-         || *type == _C_BYREF\n-\t || *type == _C_ONEWAY\n-\t || *type == _C_GCINVISIBLE)\n-    {\n-      type += 1;\n-    }\n-  return type;\n-}\n-\n-\n-/*\n-  Skip one typespec element.  If the typespec is prepended by type\n-  qualifiers, these are skipped as well.\n-*/\n-\n-const char *\n-objc_skip_typespec (const char *type)\n-{\n-  /* Skip the variable name if any */\n-  if (*type == '\"')\n-    {\n-      for (type++; *type++ != '\"';)\n-\t/* do nothing */;\n-    }\n-\n-  type = objc_skip_type_qualifiers (type);\n-\n-  switch (*type) {\n-\n-  case _C_ID:\n-    /* An id may be annotated by the actual type if it is known\n-       with the @\"ClassName\" syntax */\n-\n-    if (*++type != '\"')\n-      return type;\n-    else\n-      {\n-\twhile (*++type != '\"')\n-\t  /* do nothing */;\n-\treturn type + 1;\n-      }\n-\n-    /* The following are one character type codes */\n-  case _C_CLASS:\n-  case _C_SEL:\n-  case _C_CHR:\n-  case _C_UCHR:\n-  case _C_CHARPTR:\n-  case _C_ATOM:\n-  case _C_SHT:\n-  case _C_USHT:\n-  case _C_INT:\n-  case _C_UINT:\n-  case _C_LNG:\n-  case _C_ULNG:\n-  case _C_LNG_LNG:\n-  case _C_ULNG_LNG:\n-  case _C_FLT:\n-  case _C_DBL:\n-  case _C_VOID:\n-  case _C_UNDEF:\n-    return ++type;\n-    break;\n-\n-  case _C_ARY_B:\n-    /* skip digits, typespec and closing ']' */\n-\n-    while (isdigit ((unsigned char)*++type))\n-      ;\n-    type = objc_skip_typespec (type);\n-    if (*type == _C_ARY_E)\n-      return ++type;\n-    else\n-      break; /* error */\n-\n-  case _C_BFLD:\n-      /* The NeXT encoding for bitfields is _still_: b 'size' */\n-    while (isdigit ((unsigned char)*++type))\n-      ;\t/* skip type and size */\n-    return type;\n-\n-  case _C_STRUCT_B:\n-    /* skip name, and elements until closing '}'  */\n-\n-    while (*type != _C_STRUCT_E && *type++ != '=')\n-      ;\n-    while (*type != _C_STRUCT_E)\n-      {\n-\ttype = objc_skip_typespec (type);\n-      }\n-    return ++type;\n-\n-  case _C_UNION_B:\n-    /* skip name, and elements until closing ')'  */\n-\n-    while (*type != _C_UNION_E && *type++ != '=')\n-      ;\n-    while (*type != _C_UNION_E)\n-      {\n-\ttype = objc_skip_typespec (type);\n-      }\n-    return ++type;\n-\n-  case _C_PTR:\n-    /* Just skip the following typespec */\n-\n-    return objc_skip_typespec (++type);\n-  }\n-  return 0; /* error */\n-}\n-\n-/*\n-  Skip an offset as part of a method encoding.  This is prepended by a\n-  '+' if the argument is passed in registers.\n-*/\n-inline const char *\n-objc_skip_offset (const char *type)\n-{\n-  if (*type == '+')\n-    type++;\n-  while (isdigit ((unsigned char) *++type))\n-    ;\n-  return type;\n-}\n-\n-/*\n-  Skip an argument specification of a method encoding.\n-*/\n-const char *\n-objc_skip_argspec (const char *type)\n-{\n-  type = objc_skip_typespec (type);\n-  type = objc_skip_offset (type);\n-  return type;\n-}\n-\n-#ifdef NEXT_OBJC_USE_NEW_INTERFACE\n-typedef void *PMETH;\n-#else\n-typedef struct objc_method *PMETH;\n-#endif\n-\n-/*\n-  Return the number of arguments that the method MTH expects.\n-  Note that all methods need two implicit arguments `self' and\n-  `_cmd'.\n-*/\n-int\n-method_get_number_of_arguments (PMETH mth)\n-{\n-  int i = 0;\n-#ifdef NEXT_OBJC_USE_NEW_INTERFACE\n-  const char *type = method_getTypeEncoding((Method)mth);\n-#else\n-  const char *type = mth->method_types;\n-#endif\n-  while (*type)\n-    {\n-      type = objc_skip_argspec (type);\n-      i += 1;\n-    }\n-  return i - 1;\n-}\n-\n-/*\n-  Return the size of the argument block needed on the stack to invoke\n-  the method MTH.  This may be zero, if all arguments are passed in\n-  registers.\n-*/\n-\n-int\n-method_get_sizeof_arguments (PMETH mth)\n-{\n-#ifdef NEXT_OBJC_USE_NEW_INTERFACE\n-  const char *type = objc_skip_typespec (method_getTypeEncoding((Method)mth));\n-#else\n-  const char *type = objc_skip_typespec (mth->method_types);\n-#endif\n-  return atoi (type);\n-}\n-\n-/*\n-  Return a pointer to the next argument of ARGFRAME.  type points to\n-  the last argument.  Typical use of this look like:\n-\n-  {\n-    char *datum, *type;\n-    for (datum = method_get_first_argument (method, argframe, &type);\n-         datum; datum = method_get_next_argument (argframe, &type))\n-      {\n-        unsigned flags = objc_get_type_qualifiers (type);\n-        type = objc_skip_type_qualifiers (type);\n-\tif (*type != _C_PTR)\n-          [portal encodeData: datum ofType: type];\n-\telse\n-\t  {\n-\t    if ((flags & _F_IN) == _F_IN)\n-              [portal encodeData: *(char **) datum ofType: ++type];\n-\t  }\n-      }\n-  }\n-*/\n-\n-char *\n-method_get_next_argument (arglist_t argframe, const char **type)\n-{\n-  const char *t = objc_skip_argspec (*type);\n-\n-  if (*t == '\\0')\n-    return 0;\n-\n-  *type = t;\n-  t = objc_skip_typespec (t);\n-\n-  if (*t == '+')\n-    return argframe->arg_regs + atoi (++t);\n-  else\n-    return argframe->arg_ptr + atoi (t);\n-}\n-\n-/*\n-  Return a pointer to the value of the first argument of the method\n-  described in M with the given argumentframe ARGFRAME.  The type\n-  is returned in TYPE.  type must be passed to successive calls of\n-  method_get_next_argument.\n-*/\n-char *\n-method_get_first_argument (PMETH m,\n-\t\t\t   arglist_t argframe,\n-\t\t\t   const char **type)\n-{\n-#ifdef NEXT_OBJC_USE_NEW_INTERFACE\n-  *type = method_getTypeEncoding((Method)m);\n-#else\n-  *type = m->method_types;\n-#endif\n-\n-  return method_get_next_argument (argframe, type);\n-}\n-\n-/*\n-   Return a pointer to the ARGth argument of the method\n-   M from the frame ARGFRAME.  The type of the argument\n-   is returned in the value-result argument TYPE\n-*/\n-\n-char *\n-method_get_nth_argument (PMETH m,\n-\t\t\t arglist_t argframe, int arg,\n-\t\t\t const char **type)\n-{\n-#ifdef NEXT_OBJC_USE_NEW_INTERFACE\n-  const char *t = objc_skip_argspec (method_getTypeEncoding((Method)m));\n-#else\n-  const char *t = objc_skip_argspec (m->method_types);\n-#endif\n-\n-  if (arg > method_get_number_of_arguments (m))\n-    return 0;\n-\n-  while (arg--)\n-    t = objc_skip_argspec (t);\n-\n-  *type = t;\n-  t = objc_skip_typespec (t);\n-\n-  if (*t == '+')\n-    return argframe->arg_regs + atoi (++t);\n-  else\n-    return argframe->arg_ptr + atoi (t);\n-}\n-\n-unsigned\n-objc_get_type_qualifiers (const char *type)\n-{\n-  unsigned res = 0;\n-  BOOL flag = YES;\n-\n-  while (flag)\n-    switch (*type++)\n-      {\n-      case _C_CONST:\tres |= _F_CONST; break;\n-      case _C_IN:\tres |= _F_IN; break;\n-      case _C_INOUT:\tres |= _F_INOUT; break;\n-      case _C_OUT:\tres |= _F_OUT; break;\n-      case _C_BYCOPY:\tres |= _F_BYCOPY; break;\n-      case _C_BYREF:  res |= _F_BYREF; break;\n-      case _C_ONEWAY:\tres |= _F_ONEWAY; break;\n-      case _C_GCINVISIBLE: res |= _F_GCINVISIBLE; break;\n-      default: flag = NO;\n-    }\n-\n-  return res;\n-}\n-\n-\n-/* The following three functions can be used to determine how a\n-   structure is laid out by the compiler. For example:\n-\n-  struct objc_struct_layout layout;\n-  int i;\n-\n-  objc_layout_structure (type, &layout);\n-  while (objc_layout_structure_next_member (&layout))\n-    {\n-      int position, align;\n-      const char *type;\n-\n-      objc_layout_structure_get_info (&layout, &position, &align, &type);\n-      printf (\"element %d has offset %d, alignment %d\\n\",\n-              i++, position, align);\n-    }\n-\n-  These functions are used by objc_sizeof_type and objc_alignof_type\n-  functions to compute the size and alignment of structures. The\n-  previous method of computing the size and alignment of a structure\n-  was not working on some architectures, particulary on AIX, and in\n-  the presence of bitfields inside the structure. */\n-void\n-objc_layout_structure (const char *type,\n-                           struct objc_struct_layout *layout)\n-{\n-  const char *ntype;\n-\n-  layout->original_type = ++type;\n-\n-  /* Skip \"<name>=\" if any. Avoid embedded structures and unions. */\n-  ntype = type;\n-  while (*ntype != _C_STRUCT_E && *ntype != _C_STRUCT_B && *ntype != _C_UNION_B\n-         && *ntype++ != '=')\n-    /* do nothing */;\n-\n-  /* If there's a \"<name>=\", ntype - 1 points to '='; skip the the name */\n-  if (*(ntype - 1) == '=')\n-    type = ntype;\n-\n-  layout->type = type;\n-  layout->prev_type = NULL;\n-  layout->record_size = 0;\n-  layout->record_align = MAX (BITS_PER_UNIT, STRUCTURE_SIZE_BOUNDARY);\n-}\n-\n-\n-BOOL\n-objc_layout_structure_next_member (struct objc_struct_layout *layout)\n-{\n-  register int desired_align = 0;\n-\n-  /* The current type without the type qualifiers */\n-  const char *type;\n-\n-  /* Add the size of the previous field to the size of the record.  */\n-  if (layout->prev_type)\n-    {\n-      type = objc_skip_type_qualifiers (layout->prev_type);\n-\n-      if (*type != _C_BFLD)\n-        layout->record_size += objc_sizeof_type (type) * BITS_PER_UNIT;\n-      else\n-\tlayout->record_size += atoi (++type);\n-    }\n-\n-  if (*layout->type == _C_STRUCT_E)\n-    return NO;\n-\n-  /* Skip the variable name if any */\n-  if (*layout->type == '\"')\n-    {\n-      for (layout->type++; *layout->type++ != '\"';)\n-        /* do nothing */;\n-    }\n-\n-  type = objc_skip_type_qualifiers (layout->type);\n-\n-  desired_align = objc_alignof_type (type) * BITS_PER_UNIT;\n-\n-  /* Record must have at least as much alignment as any field.\n-     Otherwise, the alignment of the field within the record\n-     is meaningless.  */\n-  layout->record_align = MAX (layout->record_align, desired_align);\n-\n-  if (*type == _C_BFLD)\n-    {\n-      int bfld_size = atoi (++type);\n-      int int_align = __alignof__ (int) * BITS_PER_UNIT;\n-      /* If this bitfield would traverse a word alignment boundary, push it out \n-\t to that boundary instead.  */\n-      if (layout->record_size % int_align\n-\t  && (layout->record_size / int_align\n-\t      < (layout->record_size + bfld_size - 1) / int_align))\n-\tlayout->record_size = ROUND (layout->record_size, int_align);\n-    }\n-  else if (layout->record_size % desired_align != 0)\n-    {\n-      /* We need to skip space before this field.\n-         Bump the cumulative size to multiple of field alignment.  */\n-      layout->record_size = ROUND (layout->record_size, desired_align);\n-    }\n-\n-  /* Jump to the next field in record. */\n-\n-  layout->prev_type = layout->type;\n-  layout->type = objc_skip_typespec (layout->type);      /* skip component */\n-\n-  return YES;\n-}\n-\n-\n-void objc_layout_finish_structure (struct objc_struct_layout *layout,\n-                                   unsigned int *size,\n-                                   unsigned int *align)\n-{\n-  if (layout->type && *layout->type == _C_STRUCT_E)\n-    {\n-      /* Round the size up to be a multiple of the required alignment */\n-      layout->record_size = ROUND (layout->record_size, layout->record_align);\n-      layout->type = NULL;\n-    }\n-  if (size)\n-    *size = layout->record_size / BITS_PER_UNIT;\n-  if (align)\n-    *align = layout->record_align / BITS_PER_UNIT;\n-}\n-\n-\n-void objc_layout_structure_get_info (struct objc_struct_layout *layout,\n-                                     unsigned int *offset,\n-                                     unsigned int *align,\n-                                     const char **type)\n-{\n-  if (offset)\n-    *offset = layout->record_size / BITS_PER_UNIT;\n-  if (align)\n-    *align = layout->record_align / BITS_PER_UNIT;\n-  if (type)\n-    *type = layout->prev_type;\n-}\n \n /* A small, portable NSConstantString implementation for use with the NeXT\n    runtime.\n@@ -983,4 +153,5 @@ void objc_constant_string_init (void) {\n \t  sizeof (_NSConstantStringClassReference));\n }\n \n-#endif  /* #ifdef __NEXT_RUNTIME__ */\n+#endif  /*__NEXT_RUNTIME__ */\n+#endif /* _OBJC_NEXT_MAPPING_H_ */\n\\ No newline at end of file"}, {"sha": "b981880332227580172d3c6b1a2dd0446dfe3668", "filename": "gcc/testsuite/objc-obj-c++-shared/objc-test-suite-next-encode-assist-impl.h", "status": "added", "additions": 785, "deletions": 0, "changes": 785, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc-obj-c%2B%2B-shared%2Fobjc-test-suite-next-encode-assist-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc-obj-c%2B%2B-shared%2Fobjc-test-suite-next-encode-assist-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc-obj-c%2B%2B-shared%2Fobjc-test-suite-next-encode-assist-impl.h?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -0,0 +1,785 @@\n+#ifndef _OBJC_TEST_SUITE_NEXT_ENCODE_ASSIST_IMPL_H_\n+#define _OBJC_TEST_SUITE_NEXT_ENCODE_ASSIST_IMPL_H_\n+\n+#ifdef __NEXT_RUNTIME__\n+\n+/* Determine which API to use.  */\n+#include \"next-abi.h\"\n+#ifdef NEXT_OBJC_USE_NEW_INTERFACE\n+#include <objc/runtime.h>\n+typedef void * PMETH;\n+#else\n+#include <objc/objc-runtime.h>\n+typedef struct objc_method * PMETH;\n+#endif\n+\n+/* ---- */\n+\n+#undef  MAX\n+#undef  MIN\n+#undef  ROUND\n+\n+#ifdef __cplusplus\n+#  define MAX(X, Y) ((X > Y) ? X : Y)\n+#  define MIN(X, Y) ((X < Y) ? X : Y)\n+#  define ROUND(V, A) (A * ((V + A - 1) / A))\n+#else\n+#  define MAX(X, Y)                    \\\n+  ({ typeof (X) __x = (X), __y = (Y); \\\n+     (__x > __y ? __x : __y); })\n+#  define MIN(X, Y)                    \\\n+  ({ typeof (X) __x = (X), __y = (Y); \\\n+     (__x < __y ? __x : __y); })\n+#  define ROUND(V, A) \\\n+  ({ typeof (V) __v = (V); typeof (A) __a = (A); \\\n+     __a * ((__v+__a - 1)/__a); })\n+#endif\n+\n+#define BITS_PER_UNIT __CHAR_BIT__\n+typedef struct{ char a; } __small_struct;\n+#define STRUCTURE_SIZE_BOUNDARY (BITS_PER_UNIT * sizeof (__small_struct))\n+\n+/*\n+  return the size of an object specified by type\n+*/\n+\n+int\n+objc_sizeof_type (const char *type)\n+{\n+  /* Skip the variable name if any */\n+  if (*type == '\"')\n+    {\n+      for (type++; *type++ != '\"';)\n+\t/* do nothing */;\n+    }\n+\n+  switch (*type) {\n+  case _C_ID:\n+    return sizeof (id);\n+    break;\n+\n+  case _C_CLASS:\n+    return sizeof (Class);\n+    break;\n+\n+  case _C_SEL:\n+    return sizeof (SEL);\n+    break;\n+\n+  case _C_CHR:\n+    return sizeof (char);\n+    break;\n+\n+  case _C_UCHR:\n+    return sizeof (unsigned char);\n+    break;\n+\n+  case _C_SHT:\n+    return sizeof (short);\n+    break;\n+\n+  case _C_USHT:\n+    return sizeof (unsigned short);\n+    break;\n+\n+  case _C_INT:\n+    return sizeof (int);\n+    break;\n+\n+  case _C_UINT:\n+    return sizeof (unsigned int);\n+    break;\n+\n+  case _C_LNG:\n+    return sizeof (long);\n+    break;\n+\n+  case _C_ULNG:\n+    return sizeof (unsigned long);\n+    break;\n+\n+  case _C_LNG_LNG:\n+    return sizeof (long long);\n+    break;\n+\n+  case _C_ULNG_LNG:\n+    return sizeof (unsigned long long);\n+    break;\n+\n+  case _C_FLT:\n+    return sizeof (float);\n+    break;\n+\n+  case _C_DBL:\n+    return sizeof (double);\n+    break;\n+\n+  case _C_PTR:\n+  case _C_ATOM:\n+  case _C_CHARPTR:\n+    return sizeof (char *);\n+    break;\n+\n+  case _C_ARY_B:\n+    {\n+      int len = atoi (type + 1);\n+      while (isdigit ((unsigned char)*++type))\n+\t;\n+      return len * objc_aligned_size (type);\n+    }\n+    break;\n+\n+  case _C_BFLD:\n+    {\n+      /* The NeXT encoding of bitfields is _still_: b 'size' */\n+      int size = atoi (type + 1);\n+      /* Return an upper bound on byte size */\n+      return (size + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n+    }\n+\n+  case _C_STRUCT_B:\n+    {\n+      struct objc_struct_layout layout;\n+      unsigned int size;\n+\n+      objc_layout_structure (type, &layout);\n+      while (objc_layout_structure_next_member (&layout))\n+        /* do nothing */ ;\n+      objc_layout_finish_structure (&layout, &size, NULL);\n+\n+      return size;\n+    }\n+\n+  case _C_UNION_B:\n+    {\n+      int max_size = 0;\n+      while (*type != _C_UNION_E && *type++ != '=')\n+\t/* do nothing */;\n+      while (*type != _C_UNION_E)\n+\t{\n+\t  /* Skip the variable name if any */\n+\t  if (*type == '\"')\n+\t    {\n+\t      for (type++; *type++ != '\"';)\n+\t\t/* do nothing */;\n+\t    }\n+\t  max_size = MAX (max_size, objc_sizeof_type (type));\n+\t  type = objc_skip_typespec (type);\n+\t}\n+      return max_size;\n+    }\n+  }\n+  return 0; /* error */\n+}\n+\n+\n+/*\n+  Return the alignment of an object specified by type\n+*/\n+\n+int\n+objc_alignof_type (const char *type)\n+{\n+  /* Skip the variable name if any */\n+  if (*type == '\"')\n+    {\n+      for (type++; *type++ != '\"';)\n+\t/* do nothing */;\n+    }\n+  switch (*type) {\n+  case _C_ID:\n+    return __alignof__ (id);\n+    break;\n+\n+  case _C_CLASS:\n+    return __alignof__ (Class);\n+    break;\n+\n+  case _C_SEL:\n+    return __alignof__ (SEL);\n+    break;\n+\n+  case _C_CHR:\n+    return __alignof__ (char);\n+    break;\n+\n+  case _C_UCHR:\n+    return __alignof__ (unsigned char);\n+    break;\n+\n+  case _C_SHT:\n+    return __alignof__ (short);\n+    break;\n+\n+  case _C_USHT:\n+    return __alignof__ (unsigned short);\n+    break;\n+\n+  case _C_INT:\n+  case _C_BFLD: /* This is for the NeXT only */\n+    return __alignof__ (int);\n+    break;\n+\n+  case _C_UINT:\n+    return __alignof__ (unsigned int);\n+    break;\n+\n+  case _C_LNG:\n+    return __alignof__ (long);\n+    break;\n+\n+  case _C_ULNG:\n+    return __alignof__ (unsigned long);\n+    break;\n+\n+  case _C_LNG_LNG:\n+    return __alignof__ (long long);\n+    break;\n+\n+  case _C_ULNG_LNG:\n+    return __alignof__ (unsigned long long);\n+    break;\n+\n+  case _C_FLT:\n+    return __alignof__ (float);\n+    break;\n+\n+  case _C_DBL:\n+    return __alignof__ (double);\n+    break;\n+\n+  case _C_PTR:\n+  case _C_ATOM:\n+  case _C_CHARPTR:\n+    return __alignof__ (char *);\n+    break;\n+\n+  case _C_ARY_B:\n+    while (isdigit ((unsigned char)*++type))\n+      /* do nothing */;\n+    return objc_alignof_type (type);\n+\n+  case _C_STRUCT_B:\n+    {\n+      struct objc_struct_layout layout;\n+      unsigned int align;\n+\n+      objc_layout_structure (type, &layout);\n+      while (objc_layout_structure_next_member (&layout))\n+        /* do nothing */;\n+      objc_layout_finish_structure (&layout, NULL, &align);\n+\n+      return align;\n+    }\n+\n+  case _C_UNION_B:\n+    {\n+      int maxalign = 0;\n+      while (*type != _C_UNION_E && *type++ != '=')\n+\t/* do nothing */;\n+      while (*type != _C_UNION_E)\n+\t{\n+\t  /* Skip the variable name if any */\n+\t  if (*type == '\"')\n+\t    {\n+\t      for (type++; *type++ != '\"';)\n+\t\t/* do nothing */;\n+\t    }\n+\t  maxalign = MAX (maxalign, objc_alignof_type (type));\n+\t  type = objc_skip_typespec (type);\n+\t}\n+      return maxalign;\n+    }\n+  }\n+  return 0; /* error */\n+}\n+\n+/*\n+  The aligned size if the size rounded up to the nearest alignment.\n+*/\n+\n+int\n+objc_aligned_size (const char *type)\n+{\n+  int size, align;\n+\n+  /* Skip the variable name */\n+  if (*type == '\"')\n+    {\n+      for (type++; *type++ != '\"';)\n+\t/* do nothing */;\n+    }\n+\n+  size = objc_sizeof_type (type);\n+  align = objc_alignof_type (type);\n+\n+  return ROUND (size, align);\n+}\n+\n+/*\n+  The size rounded up to the nearest integral of the wordsize, taken\n+  to be the size of a void *.\n+*/\n+\n+int\n+objc_promoted_size (const char *type)\n+{\n+  int size, wordsize;\n+\n+  /* Skip the variable name */\n+  if (*type == '\"')\n+    {\n+      for (type++; *type++ != '\"';)\n+\t/* do nothing */;\n+    }\n+\n+  size = objc_sizeof_type (type);\n+  wordsize = sizeof (void *);\n+\n+  return ROUND (size, wordsize);\n+}\n+\n+/*\n+  Skip type qualifiers.  These may eventually precede typespecs\n+  occurring in method prototype encodings.\n+*/\n+\n+const char *\n+objc_skip_type_qualifiers (const char *type)\n+{\n+  while (*type == _C_CONST\n+\t || *type == _C_IN\n+\t || *type == _C_INOUT\n+\t || *type == _C_OUT\n+\t || *type == _C_BYCOPY\n+         || *type == _C_BYREF\n+\t || *type == _C_ONEWAY\n+\t || *type == _C_GCINVISIBLE)\n+    {\n+      type += 1;\n+    }\n+  return type;\n+}\n+\n+/*\n+  Skip one typespec element.  If the typespec is prepended by type\n+  qualifiers, these are skipped as well.\n+*/\n+\n+const char *\n+objc_skip_typespec (const char *type)\n+{\n+  /* Skip the variable name if any */\n+  if (*type == '\"')\n+    {\n+      for (type++; *type++ != '\"';)\n+\t/* do nothing */;\n+    }\n+\n+  type = objc_skip_type_qualifiers (type);\n+\n+  switch (*type) {\n+\n+  case _C_ID:\n+    /* An id may be annotated by the actual type if it is known\n+       with the @\"ClassName\" syntax */\n+\n+    if (*++type != '\"')\n+      return type;\n+    else\n+      {\n+\twhile (*++type != '\"')\n+\t  /* do nothing */;\n+\treturn type + 1;\n+      }\n+\n+    /* The following are one character type codes */\n+  case _C_CLASS:\n+  case _C_SEL:\n+  case _C_CHR:\n+  case _C_UCHR:\n+  case _C_CHARPTR:\n+  case _C_ATOM:\n+  case _C_SHT:\n+  case _C_USHT:\n+  case _C_INT:\n+  case _C_UINT:\n+  case _C_LNG:\n+  case _C_ULNG:\n+  case _C_LNG_LNG:\n+  case _C_ULNG_LNG:\n+  case _C_FLT:\n+  case _C_DBL:\n+  case _C_VOID:\n+  case _C_UNDEF:\n+    return ++type;\n+    break;\n+\n+  case _C_ARY_B:\n+    /* skip digits, typespec and closing ']' */\n+\n+    while (isdigit ((unsigned char)*++type))\n+      ;\n+    type = objc_skip_typespec (type);\n+    if (*type == _C_ARY_E)\n+      return ++type;\n+    else\n+      break; /* error */\n+\n+  case _C_BFLD:\n+      /* The NeXT encoding for bitfields is _still_: b 'size' */\n+    while (isdigit ((unsigned char)*++type))\n+      ;\t/* skip type and size */\n+    return type;\n+\n+  case _C_STRUCT_B:\n+    /* skip name, and elements until closing '}'  */\n+\n+    while (*type != _C_STRUCT_E && *type++ != '=')\n+      ;\n+    while (*type != _C_STRUCT_E)\n+      {\n+\ttype = objc_skip_typespec (type);\n+      }\n+    return ++type;\n+\n+  case _C_UNION_B:\n+    /* skip name, and elements until closing ')'  */\n+\n+    while (*type != _C_UNION_E && *type++ != '=')\n+      ;\n+    while (*type != _C_UNION_E)\n+      {\n+\ttype = objc_skip_typespec (type);\n+      }\n+    return ++type;\n+\n+  case _C_PTR:\n+    /* Just skip the following typespec */\n+\n+    return objc_skip_typespec (++type);\n+  }\n+  return 0; /* error */\n+}\n+\n+/*\n+  Skip an offset as part of a method encoding.  This is prepended by a\n+  '+' if the argument is passed in registers.\n+*/\n+const char *\n+objc_skip_offset (const char *type)\n+{\n+  if (*type == '+')\n+    type++;\n+  while (isdigit ((unsigned char) *++type))\n+    ;\n+  return type;\n+}\n+\n+/*\n+  Skip an argument specification of a method encoding.\n+*/\n+const char *\n+objc_skip_argspec (const char *type)\n+{\n+  type = objc_skip_typespec (type);\n+  type = objc_skip_offset (type);\n+  return type;\n+}\n+/*\n+  Return the number of arguments that the method MTH expects.\n+  Note that all methods need two implicit arguments `self' and\n+  `_cmd'.\n+*/\n+int\n+method_get_number_of_arguments (PMETH mth)\n+{\n+  int i = 0;\n+#ifdef NEXT_OBJC_USE_NEW_INTERFACE\n+  const char *type = method_getTypeEncoding((Method)mth);\n+#else\n+  const char *type = mth->method_types;\n+#endif\n+  while (*type)\n+    {\n+      type = objc_skip_argspec (type);\n+      i += 1;\n+    }\n+  return i - 1;\n+}\n+\n+/*\n+  Return the size of the argument block needed on the stack to invoke\n+  the method MTH.  This may be zero, if all arguments are passed in\n+  registers.\n+*/\n+\n+int\n+method_get_sizeof_arguments (PMETH mth)\n+{\n+#ifdef NEXT_OBJC_USE_NEW_INTERFACE\n+  const char *type = objc_skip_typespec (method_getTypeEncoding((Method)mth));\n+#else\n+  const char *type = objc_skip_typespec (mth->method_types);\n+#endif\n+  return atoi (type);\n+}\n+\n+/*\n+  Return a pointer to the next argument of ARGFRAME.  type points to\n+  the last argument.  Typical use of this look like:\n+\n+  {\n+    char *datum, *type;\n+    for (datum = method_get_first_argument (method, argframe, &type);\n+         datum; datum = method_get_next_argument (argframe, &type))\n+      {\n+        unsigned flags = objc_get_type_qualifiers (type);\n+        type = objc_skip_type_qualifiers (type);\n+\tif (*type != _C_PTR)\n+          [portal encodeData: datum ofType: type];\n+\telse\n+\t  {\n+\t    if ((flags & _F_IN) == _F_IN)\n+              [portal encodeData: *(char **) datum ofType: ++type];\n+\t  }\n+      }\n+  }\n+*/\n+\n+char *\n+method_get_next_argument (arglist_t argframe, const char **type)\n+{\n+  const char *t = objc_skip_argspec (*type);\n+\n+  if (*t == '\\0')\n+    return 0;\n+\n+  *type = t;\n+  t = objc_skip_typespec (t);\n+\n+  if (*t == '+')\n+    return argframe->arg_regs + atoi (++t);\n+  else\n+    return argframe->arg_ptr + atoi (t);\n+}\n+\n+/*\n+  Return a pointer to the value of the first argument of the method\n+  described in M with the given argumentframe ARGFRAME.  The type\n+  is returned in TYPE.  type must be passed to successive calls of\n+  method_get_next_argument.\n+*/\n+char *\n+method_get_first_argument (PMETH m,\n+\t\t\t   arglist_t argframe,\n+\t\t\t   const char **type)\n+{\n+#ifdef NEXT_OBJC_USE_NEW_INTERFACE\n+  *type = method_getTypeEncoding((Method)m);\n+#else\n+  *type = m->method_types;\n+#endif\n+\n+  return method_get_next_argument (argframe, type);\n+}\n+\n+/*\n+   Return a pointer to the ARGth argument of the method\n+   M from the frame ARGFRAME.  The type of the argument\n+   is returned in the value-result argument TYPE\n+*/\n+\n+char *\n+method_get_nth_argument (PMETH m,\n+\t\t\t arglist_t argframe, int arg,\n+\t\t\t const char **type)\n+{\n+#ifdef NEXT_OBJC_USE_NEW_INTERFACE\n+  const char *t = objc_skip_argspec (method_getTypeEncoding((Method)m));\n+#else\n+  const char *t = objc_skip_argspec (m->method_types);\n+#endif\n+\n+  if (arg > method_get_number_of_arguments (m))\n+    return 0;\n+\n+  while (arg--)\n+    t = objc_skip_argspec (t);\n+\n+  *type = t;\n+  t = objc_skip_typespec (t);\n+\n+  if (*t == '+')\n+    return argframe->arg_regs + atoi (++t);\n+  else\n+    return argframe->arg_ptr + atoi (t);\n+}\n+\n+unsigned\n+objc_get_type_qualifiers (const char *type)\n+{\n+  unsigned res = 0;\n+  BOOL flag = YES;\n+\n+  while (flag)\n+    switch (*type++)\n+      {\n+      case _C_CONST:\tres |= _F_CONST; break;\n+      case _C_IN:\tres |= _F_IN; break;\n+      case _C_INOUT:\tres |= _F_INOUT; break;\n+      case _C_OUT:\tres |= _F_OUT; break;\n+      case _C_BYCOPY:\tres |= _F_BYCOPY; break;\n+      case _C_BYREF:  res |= _F_BYREF; break;\n+      case _C_ONEWAY:\tres |= _F_ONEWAY; break;\n+      case _C_GCINVISIBLE: res |= _F_GCINVISIBLE; break;\n+      default: flag = NO;\n+    }\n+\n+  return res;\n+}\n+\n+\n+/* The following three functions can be used to determine how a\n+   structure is laid out by the compiler. For example:\n+\n+  struct objc_struct_layout layout;\n+  int i;\n+\n+  objc_layout_structure (type, &layout);\n+  while (objc_layout_structure_next_member (&layout))\n+    {\n+      int position, align;\n+      const char *type;\n+\n+      objc_layout_structure_get_info (&layout, &position, &align, &type);\n+      printf (\"element %d has offset %d, alignment %d\\n\",\n+              i++, position, align);\n+    }\n+\n+  These functions are used by objc_sizeof_type and objc_alignof_type\n+  functions to compute the size and alignment of structures. The\n+  previous method of computing the size and alignment of a structure\n+  was not working on some architectures, particulary on AIX, and in\n+  the presence of bitfields inside the structure. */\n+void\n+objc_layout_structure (const char *type,\n+                           struct objc_struct_layout *layout)\n+{\n+  const char *ntype;\n+\n+  layout->original_type = ++type;\n+\n+  /* Skip \"<name>=\" if any. Avoid embedded structures and unions. */\n+  ntype = type;\n+  while (*ntype != _C_STRUCT_E && *ntype != _C_STRUCT_B && *ntype != _C_UNION_B\n+         && *ntype++ != '=')\n+    /* do nothing */;\n+\n+  /* If there's a \"<name>=\", ntype - 1 points to '='; skip the the name */\n+  if (*(ntype - 1) == '=')\n+    type = ntype;\n+\n+  layout->type = type;\n+  layout->prev_type = NULL;\n+  layout->record_size = 0;\n+  layout->record_align = MAX (BITS_PER_UNIT, STRUCTURE_SIZE_BOUNDARY);\n+}\n+\n+BOOL\n+objc_layout_structure_next_member (struct objc_struct_layout *layout)\n+{\n+  register int desired_align = 0;\n+\n+  /* The current type without the type qualifiers */\n+  const char *type;\n+\n+  /* Add the size of the previous field to the size of the record.  */\n+  if (layout->prev_type)\n+    {\n+      type = objc_skip_type_qualifiers (layout->prev_type);\n+\n+      if (*type != _C_BFLD)\n+        layout->record_size += objc_sizeof_type (type) * BITS_PER_UNIT;\n+      else\n+\tlayout->record_size += atoi (++type);\n+    }\n+\n+  if (*layout->type == _C_STRUCT_E)\n+    return NO;\n+\n+  /* Skip the variable name if any */\n+  if (*layout->type == '\"')\n+    {\n+      for (layout->type++; *layout->type++ != '\"';)\n+        /* do nothing */;\n+    }\n+\n+  type = objc_skip_type_qualifiers (layout->type);\n+\n+  desired_align = objc_alignof_type (type) * BITS_PER_UNIT;\n+\n+  /* Record must have at least as much alignment as any field.\n+     Otherwise, the alignment of the field within the record\n+     is meaningless.  */\n+  layout->record_align = MAX (layout->record_align, desired_align);\n+\n+  if (*type == _C_BFLD)\n+    {\n+      int bfld_size = atoi (++type);\n+      int int_align = __alignof__ (int) * BITS_PER_UNIT;\n+      /* If this bitfield would traverse a word alignment boundary, push it out \n+\t to that boundary instead.  */\n+      if (layout->record_size % int_align\n+\t  && (layout->record_size / int_align\n+\t      < (layout->record_size + bfld_size - 1) / int_align))\n+\tlayout->record_size = ROUND (layout->record_size, int_align);\n+    }\n+  else if (layout->record_size % desired_align != 0)\n+    {\n+      /* We need to skip space before this field.\n+         Bump the cumulative size to multiple of field alignment.  */\n+      layout->record_size = ROUND (layout->record_size, desired_align);\n+    }\n+\n+  /* Jump to the next field in record. */\n+\n+  layout->prev_type = layout->type;\n+  layout->type = objc_skip_typespec (layout->type);      /* skip component */\n+\n+  return YES;\n+}\n+\n+\n+void objc_layout_finish_structure (struct objc_struct_layout *layout,\n+                                   unsigned int *size,\n+                                   unsigned int *align)\n+{\n+  if (layout->type && *layout->type == _C_STRUCT_E)\n+    {\n+      /* Round the size up to be a multiple of the required alignment */\n+      layout->record_size = ROUND (layout->record_size, layout->record_align);\n+      layout->type = NULL;\n+    }\n+  if (size)\n+    *size = layout->record_size / BITS_PER_UNIT;\n+  if (align)\n+    *align = layout->record_align / BITS_PER_UNIT;\n+}\n+\n+\n+void objc_layout_structure_get_info (struct objc_struct_layout *layout,\n+                                     unsigned int *offset,\n+                                     unsigned int *align,\n+                                     const char **type)\n+{\n+  if (offset)\n+    *offset = layout->record_size / BITS_PER_UNIT;\n+  if (align)\n+    *align = layout->record_align / BITS_PER_UNIT;\n+  if (type)\n+    *type = layout->prev_type;\n+}\n+\n+#endif /* __NEXT_RUNTIME__ */\n+#endif /* _OBJC_TEST_SUITE_NEXT_ENCODE_ASSIST_IMPL_H_ */"}, {"sha": "0a0f93c376a24e5e8a33f87f9d9ee0ea6cdf303a", "filename": "gcc/testsuite/objc-obj-c++-shared/objc-test-suite-next-encode-assist.h", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc-obj-c%2B%2B-shared%2Fobjc-test-suite-next-encode-assist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc-obj-c%2B%2B-shared%2Fobjc-test-suite-next-encode-assist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc-obj-c%2B%2B-shared%2Fobjc-test-suite-next-encode-assist.h?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -0,0 +1,97 @@\n+#ifndef _OBJC_TEST_SUITE_NEXT_ENCODE_ASSIST_H_\n+#define _OBJC_TEST_SUITE_NEXT_ENCODE_ASSIST_H_\n+\n+#ifdef __NEXT_RUNTIME__\n+\n+#include \"next-abi.h\"\n+#ifdef NEXT_OBJC_USE_NEW_INTERFACE\n+#include <objc/runtime.h>\n+typedef void * PMETH;\n+#else\n+#include <objc/objc-runtime.h>\n+typedef struct objc_method * PMETH;\n+#endif\n+\n+/* The NeXT headers do not define NULL.  */\n+#ifndef NULL\n+#define NULL 0\n+#endif\n+\n+/* The NeXT runtimes do not include these functions (at least not through \n+   any public API).  They are required for the objc/execute/bf-* and bycopy-3. */\n+\n+/* Not sure why the following are missing from NeXT objc headers... */\n+\n+#ifndef _C_LNG_LNG\n+#define _C_LNG_LNG  'q'\n+#endif\n+#ifndef _C_ULNG_LNG\n+#define _C_ULNG_LNG 'Q'\n+#endif\n+#ifndef _C_ATOM\n+#define _C_ATOM     '%'\n+#endif\n+#ifndef _C_BOOL\n+#define _C_BOOL     'B'\n+#endif\n+\n+#define _C_CONST        'r'\n+#define _C_IN           'n'\n+#define _C_INOUT        'N'\n+#define _C_OUT          'o'\n+#define _C_BYCOPY       'O'\n+#define _C_BYREF        'R'\n+#define _C_ONEWAY       'V'\n+#define _C_GCINVISIBLE  '!'\n+   \n+#define _F_CONST        0x01\n+#define _F_IN           0x01\n+#define _F_OUT          0x02\n+#define _F_INOUT        0x03\n+#define _F_BYCOPY       0x04  \n+#define _F_BYREF        0x08  \n+#define _F_ONEWAY       0x10\n+#define _F_GCINVISIBLE  0x20\n+\n+/* Functions available in the GNU runtime, emulated here for testing with NeXT.  */\n+\n+struct objc_struct_layout\n+{\n+  const char *original_type;\n+  const char *type;\n+  const char *prev_type;\n+  unsigned int record_size; \n+  unsigned int record_align;\n+};\n+\n+typedef union arglist {\n+  char *arg_ptr;\n+  char arg_regs[sizeof (char*)];\n+} *arglist_t;                   /* argument frame */\n+\n+void objc_layout_structure_get_info (struct objc_struct_layout *,unsigned int *,\n+\t\t\t\t     unsigned int *, const char **);\n+void objc_layout_structure (const char *, struct objc_struct_layout *);\n+BOOL objc_layout_structure_next_member (struct objc_struct_layout *);\n+void objc_layout_finish_structure (struct objc_struct_layout *, unsigned int *,\n+\t\t\t\t   unsigned int *);\n+\n+int objc_sizeof_type (const char *);\n+int objc_alignof_type (const char *);\n+int objc_aligned_size (const char *);\n+int objc_promoted_size (const char *);\n+\n+unsigned objc_get_type_qualifiers (const char *);\n+const char *objc_skip_type_qualifiers (const char *);\n+const char *objc_skip_typespec (const char *);\n+const char *objc_skip_offset (const char *);\n+const char *objc_skip_argspec (const char *);\n+\n+int method_get_number_of_arguments (PMETH);\n+int method_get_sizeof_arguments (PMETH);\n+char *method_get_next_argument (arglist_t , const char **);\n+char *method_get_first_argument (PMETH, arglist_t, const char **);\n+char *method_get_nth_argument (PMETH, arglist_t, int, const char **);\n+\n+#endif /* __NEXT_RUNTIME__ */\n+#endif /* _OBJC_TEST_SUITE_NEXT_ENCODE_ASSIST_H_ */"}, {"sha": "a5d219108bc74c673eade88a77bdff9ce6e50fd4", "filename": "gcc/testsuite/objc/execute/bf-1.m", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-1.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,5 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n-#include <objc/objc-api.h>\n+#include <objc/objc.h>\n \n @interface MyObject\n {"}, {"sha": "6cbdc225b1319cf4fbb225c1f4b49596d0cd9e4c", "filename": "gcc/testsuite/objc/execute/bf-10.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-10.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-10.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-10.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n @interface MyObject\n {"}, {"sha": "42a97a57a83373a39f58d8c174657e7d23ca8755", "filename": "gcc/testsuite/objc/execute/bf-11.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-11.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-11.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-11.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n @interface MyObject\n {"}, {"sha": "78a19d306d9f5bf995c04f2fcea9f32cede04675", "filename": "gcc/testsuite/objc/execute/bf-12.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-12.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-12.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-12.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n @interface MyObject\n {"}, {"sha": "fa47238b03703a5ced2fb43e9fe8093213bd2e4d", "filename": "gcc/testsuite/objc/execute/bf-13.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-13.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-13.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-13.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n @interface MyObject\n {"}, {"sha": "99fa8fef5a61dbae25af952220b180f391b795bf", "filename": "gcc/testsuite/objc/execute/bf-14.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-14.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-14.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-14.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n @interface MyObject\n {"}, {"sha": "c32e663317a10b18f598fab20f02c756011f77b2", "filename": "gcc/testsuite/objc/execute/bf-15.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-15.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-15.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-15.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n @interface MyObject\n {"}, {"sha": "e286de7c29b8bbc967268d1ac989c3e0018c94c0", "filename": "gcc/testsuite/objc/execute/bf-16.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-16.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-16.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-16.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n struct A {\n   int i;"}, {"sha": "7650ffae71aa8f130379fd7d13967fe7ac71065a", "filename": "gcc/testsuite/objc/execute/bf-17.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-17.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-17.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-17.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n struct A {\n   int i;"}, {"sha": "528829554efcbf7761fd8b0eca7e8d889e21ce12", "filename": "gcc/testsuite/objc/execute/bf-18.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-18.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-18.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-18.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n @interface MyObject\n {"}, {"sha": "d9306df00792c9ebdc455b135084f22b5151ce38", "filename": "gcc/testsuite/objc/execute/bf-19.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-19.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-19.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-19.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n @interface MyObject\n {"}, {"sha": "f776eea5deda5abf9082cc47aea4057ae8d51f3c", "filename": "gcc/testsuite/objc/execute/bf-2.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-2.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n @interface MyObject\n {"}, {"sha": "311a0fd5b98e4b88670927143b09ab43b3a79427", "filename": "gcc/testsuite/objc/execute/bf-20.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-20.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-20.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-20.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n @interface MyObject\n {"}, {"sha": "587060d1d4269688720c9be7be9684745882514b", "filename": "gcc/testsuite/objc/execute/bf-21.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-21.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-21.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-21.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n typedef enum \n {"}, {"sha": "52863bb6fa6e24cb1d3304d10e40678963829818", "filename": "gcc/testsuite/objc/execute/bf-3.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-3.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-3.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-3.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n @interface MyObject\n {"}, {"sha": "5654b6fedd0135e1efd2a67284ceae71329ffa3f", "filename": "gcc/testsuite/objc/execute/bf-4.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-4.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-4.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-4.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n @interface MyObject\n {"}, {"sha": "b75509ddd43dc304fc1941dc4c20b380eb20132b", "filename": "gcc/testsuite/objc/execute/bf-5.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-5.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-5.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-5.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n @interface MyObject\n {"}, {"sha": "187c7582d46f1a2b5d00f5b794b93efa583ddc2c", "filename": "gcc/testsuite/objc/execute/bf-6.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-6.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-6.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-6.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n @interface MyObject\n {"}, {"sha": "f1ee46e0c6ec3ca99b6bfa53fb611b238a8d6bc7", "filename": "gcc/testsuite/objc/execute/bf-7.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-7.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-7.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-7.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n @interface MyObject\n {"}, {"sha": "164950fca0f814a3e310429fed95c09c9d09ef05", "filename": "gcc/testsuite/objc/execute/bf-8.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-8.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-8.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-8.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n @interface MyObject\n {"}, {"sha": "9fc7c704bea22f64a8959e05c4cb258504701d35", "filename": "gcc/testsuite/objc/execute/bf-9.m", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-9.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-9.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-9.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,6 +1,4 @@\n-#import \"../../objc-obj-c++-shared/Object1.h\"\n #include <objc/objc.h>\n-#include <objc/objc-api.h>\n \n @interface MyObject\n {"}, {"sha": "c79c3efacb46bd04f16d63fa2dc20188a6403f6d", "filename": "gcc/testsuite/objc/execute/bf-common.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbf-common.h?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -1,7 +1,14 @@\n+#include <stdio.h>\n #include <stdlib.h>\n-#include \"../../objc-obj-c++-shared/next-mapping.h\"\n+\n #ifndef __NEXT_RUNTIME__\n #include <objc/encoding.h>\n+#else\n+/* The following header, together with the implementation included below,\n+   emulate functionality provided by the GNU runtime but not available from\n+   the NeXT runtime.  */\n+#include \"../../objc-obj-c++-shared/objc-test-suite-next-encode-assist.h\"\n+#define objc_get_class(C) objc_getClass(C)\n #endif\n \n void print_ivars (Class class)\n@@ -63,7 +70,6 @@ int main ()\n     };\n   int size1, size2;\n   Class class = objc_get_class (\"MyObject\");\n-\n   printf (\"type = %s\\n\", @encode (struct class_vars));\n   print_ivars (class);\n \n@@ -77,3 +83,5 @@ int main ()\n   \n   exit (0);\n }\n+\n+#include \"../../objc-obj-c++-shared/objc-test-suite-next-encode-assist-impl.h\""}, {"sha": "4c2bd27613d2bed6ddc7b9abb4cf0b6f98231978", "filename": "gcc/testsuite/objc/execute/bycopy-3.m", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbycopy-3.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dc93f4464d315c1ee2f5d72377381529b88208/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbycopy-3.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Fbycopy-3.m?ref=d5dc93f4464d315c1ee2f5d72377381529b88208", "patch": "@@ -9,8 +9,10 @@\n  * interfere with what we are testing, which is that the `bycopy'\n  * keyword generates the _F_BYCOPY qualifier for the return type.  */\n \n-#include \"../../objc-obj-c++-shared/next-mapping.h\"\n-#include \"../../objc-obj-c++-shared/Protocol1.h\"\n+extern void exit (int) __attribute__ ((noreturn));\n+extern int printf (const char *, ...);\n+\n+#include <objc/Protocol.h>\n \n #ifndef __NEXT_RUNTIME__\n #include <objc/encoding.h>\n@@ -31,6 +33,11 @@ @implementation MyObject\n }\n @end\n \n+/* The following header, together with the implementation included below,\n+   emulate functionality provided by the GNU runtime but not available from\n+   the NeXT runtime.  */\n+#include \"../../objc-obj-c++-shared/objc-test-suite-next-encode-assist.h\"\n+\n int main (void)\n {\n   struct objc_method_description *method;\n@@ -69,3 +76,28 @@ int main (void)\n   /* Else, happy end */\n   return 0;\n }\n+\n+#ifdef __NEXT_RUNTIME__\n+unsigned\n+objc_get_type_qualifiers (const char *type)\n+{\n+  unsigned res = 0;\n+  BOOL flag = YES;\n+\n+  while (flag)\n+    switch (*type++)\n+      {\n+      case _C_CONST:\tres |= _F_CONST; break;\n+      case _C_IN:\tres |= _F_IN; break;\n+      case _C_INOUT:\tres |= _F_INOUT; break;\n+      case _C_OUT:\tres |= _F_OUT; break;\n+      case _C_BYCOPY:\tres |= _F_BYCOPY; break;\n+      case _C_BYREF:  res |= _F_BYREF; break;\n+      case _C_ONEWAY:\tres |= _F_ONEWAY; break;\n+      case _C_GCINVISIBLE: res |= _F_GCINVISIBLE; break;\n+      default: flag = NO;\n+    }\n+\n+  return res;\n+}\n+#endif"}]}