{"sha": "4d451982e36b1f5a7a8412d9fb36924699aeb223", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ0NTE5ODJlMzZiMWY1YTdhODQxMmQ5ZmIzNjkyNDY5OWFlYjIyMw==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2010-07-03T21:17:46Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2010-07-03T21:17:46Z"}, "message": "c-common.c (IN_GCC_FRONTEND): Do not undef.\n\n2010-07-03  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\n\t* c-family/c-common.c (IN_GCC_FRONTEND): Do not undef.\n\tDo not include expr.h\n\t(vector_mode_valid_p): Move here.\n\t* expr.c (vector_mode_valid_p): Move to c-common.c.\n\t* expr.h (vector_mode_valid_p): Do not declare here.\n\t* system.h: Poison GCC_EXPR_H in front-ends.\n\t* Makefile.in: Update dependencies.\n\nFrom-SVN: r161785", "tree": {"sha": "d86d7f443aa6e8ad1a79e3d696dfd64d64f302db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d86d7f443aa6e8ad1a79e3d696dfd64d64f302db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d451982e36b1f5a7a8412d9fb36924699aeb223", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d451982e36b1f5a7a8412d9fb36924699aeb223", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d451982e36b1f5a7a8412d9fb36924699aeb223", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d451982e36b1f5a7a8412d9fb36924699aeb223/comments", "author": null, "committer": null, "parents": [{"sha": "3a0c7e3af1954b05fa1c12ea5818d4d6d62ffea5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a0c7e3af1954b05fa1c12ea5818d4d6d62ffea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a0c7e3af1954b05fa1c12ea5818d4d6d62ffea5"}], "stats": {"total": 94, "additions": 50, "deletions": 44}, "files": [{"sha": "3ef84a63aba6426d0d0d0f63cc134d9cae376d6f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d451982e36b1f5a7a8412d9fb36924699aeb223/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d451982e36b1f5a7a8412d9fb36924699aeb223/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d451982e36b1f5a7a8412d9fb36924699aeb223", "patch": "@@ -1,3 +1,10 @@\n+2010-07-03  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\t* expr.c (vector_mode_valid_p): Move to c-common.c.\n+\t* expr.h (vector_mode_valid_p): Do not declare here.\n+\t* system.h: Poison GCC_EXPR_H in front-ends.\n+\t* Makefile.in: Update dependencies.\n+\n 2010-07-03  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR target/44705"}, {"sha": "f57cd7100d4238cce692a0896760c1e355f2bd46", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d451982e36b1f5a7a8412d9fb36924699aeb223/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d451982e36b1f5a7a8412d9fb36924699aeb223/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4d451982e36b1f5a7a8412d9fb36924699aeb223", "patch": "@@ -2072,8 +2072,8 @@ lto-wrapper.o: lto-wrapper.c $(CONFIG_H) $(SYSTEM_H) coretypes.h intl.h \\\n c-family/c-common.o : c-family/c-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \t$(TM_H) $(TREE_H) \\\n \t$(OBSTACK_H) $(C_COMMON_H) $(FLAGS_H) $(TOPLEV_H) output.h $(C_PRAGMA_H) \\\n-\t$(GGC_H) $(EXPR_H) builtin-types.def builtin-attrs.def \\\n-\t$(DIAGNOSTIC_H) langhooks.h $(RTL_H) \\\n+\t$(GGC_H) builtin-types.def builtin-attrs.def \\\n+\t$(DIAGNOSTIC_H) langhooks.h \\\n \t$(TARGET_H) tree-iterator.h langhooks.h tree-mudflap.h \\\n \tintl.h opts.h $(CPPLIB_H) $(TREE_INLINE_H) $(HASHTAB_H) \\\n \t$(BUILTINS_DEF) $(CGRAPH_H) $(BASIC_BLOCK_H) $(TARGET_DEF_H) \\"}, {"sha": "8af57ab9b51461793e0c9bc3c669c07ae7ea4783", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d451982e36b1f5a7a8412d9fb36924699aeb223/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d451982e36b1f5a7a8412d9fb36924699aeb223/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=4d451982e36b1f5a7a8412d9fb36924699aeb223", "patch": "@@ -1,3 +1,9 @@\n+2010-07-03  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\t* c-family/c-common.c (IN_GCC_FRONTEND): Do not undef.\n+\tDo not include expr.h\n+\t(vector_mode_valid_p): Move here.\n+\n 2010-06-21  DJ Delorie  <dj@redhat.com>\n \n \t* c-pragma.c (handle_pragma_diagnostic): Add push/pop,"}, {"sha": "491dd9e9500f595296c8e46be4483da6282458c8", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d451982e36b1f5a7a8412d9fb36924699aeb223/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d451982e36b1f5a7a8412d9fb36924699aeb223/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=4d451982e36b1f5a7a8412d9fb36924699aeb223", "patch": "@@ -19,10 +19,6 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* FIXME: Still need to include rtl.h here (via expr.h) in a front-end file.\n-   Pretend this is a back-end file.  */\n-#undef IN_GCC_FRONTEND\n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -50,8 +46,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target-def.h\"\n #include \"libfuncs.h\"\n \n-#include \"expr.h\" /* For vector_mode_valid_p */\n-\n cpp_reader *parse_in;\t\t/* Declared in c-pragma.h.  */\n \n /* The following symbols are subsumed in the c_global_trees array, and\n@@ -6249,6 +6243,40 @@ handle_destructor_attribute (tree *node, tree name, tree args,\n   return NULL_TREE;\n }\n \n+/* Nonzero if the mode is a valid vector mode for this architecture.\n+   This returns nonzero even if there is no hardware support for the\n+   vector mode, but we can emulate with narrower modes.  */\n+\n+static int\n+vector_mode_valid_p (enum machine_mode mode)\n+{\n+  enum mode_class mclass = GET_MODE_CLASS (mode);\n+  enum machine_mode innermode;\n+\n+  /* Doh!  What's going on?  */\n+  if (mclass != MODE_VECTOR_INT\n+      && mclass != MODE_VECTOR_FLOAT\n+      && mclass != MODE_VECTOR_FRACT\n+      && mclass != MODE_VECTOR_UFRACT\n+      && mclass != MODE_VECTOR_ACCUM\n+      && mclass != MODE_VECTOR_UACCUM)\n+    return 0;\n+\n+  /* Hardware support.  Woo hoo!  */\n+  if (targetm.vector_mode_supported_p (mode))\n+    return 1;\n+\n+  innermode = GET_MODE_INNER (mode);\n+\n+  /* We should probably return 1 if requesting V4DI and we have no DI,\n+     but we have V2DI, but this is probably very unlikely.  */\n+\n+  /* If we have support for the inner mode, we can safely emulate it.\n+     We may not have V2DI, but me can emulate with a pair of DIs.  */\n+  return targetm.scalar_mode_supported_p (innermode);\n+}\n+\n+\n /* Handle a \"mode\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "d3ef6be92bae005017d3552e77534fcaae8f151f", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d451982e36b1f5a7a8412d9fb36924699aeb223/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d451982e36b1f5a7a8412d9fb36924699aeb223/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4d451982e36b1f5a7a8412d9fb36924699aeb223", "patch": "@@ -10295,39 +10295,6 @@ try_tablejump (tree index_type, tree index_expr, tree minval, tree range,\n   return 1;\n }\n \n-/* Nonzero if the mode is a valid vector mode for this architecture.\n-   This returns nonzero even if there is no hardware support for the\n-   vector mode, but we can emulate with narrower modes.  */\n-\n-int\n-vector_mode_valid_p (enum machine_mode mode)\n-{\n-  enum mode_class mclass = GET_MODE_CLASS (mode);\n-  enum machine_mode innermode;\n-\n-  /* Doh!  What's going on?  */\n-  if (mclass != MODE_VECTOR_INT\n-      && mclass != MODE_VECTOR_FLOAT\n-      && mclass != MODE_VECTOR_FRACT\n-      && mclass != MODE_VECTOR_UFRACT\n-      && mclass != MODE_VECTOR_ACCUM\n-      && mclass != MODE_VECTOR_UACCUM)\n-    return 0;\n-\n-  /* Hardware support.  Woo hoo!  */\n-  if (targetm.vector_mode_supported_p (mode))\n-    return 1;\n-\n-  innermode = GET_MODE_INNER (mode);\n-\n-  /* We should probably return 1 if requesting V4DI and we have no DI,\n-     but we have V2DI, but this is probably very unlikely.  */\n-\n-  /* If we have support for the inner mode, we can safely emulate it.\n-     We may not have V2DI, but me can emulate with a pair of DIs.  */\n-  return targetm.scalar_mode_supported_p (innermode);\n-}\n-\n /* Return a CONST_VECTOR rtx for a VECTOR_CST tree.  */\n static rtx\n const_vector_from_tree (tree exp)"}, {"sha": "0146343b87c4faaec5e8fb9ed239d74e9fc61761", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d451982e36b1f5a7a8412d9fb36924699aeb223/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d451982e36b1f5a7a8412d9fb36924699aeb223/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=4d451982e36b1f5a7a8412d9fb36924699aeb223", "patch": "@@ -695,6 +695,4 @@ extern tree build_libfunc_function (const char *);\n /* Get the personality libfunc for a function decl.  */\n rtx get_personality_function (tree);\n \n-extern int vector_mode_valid_p (enum machine_mode);\n-\n #endif /* GCC_EXPR_H */"}, {"sha": "a8b4fa93558ef2d3e2c20492d37c550bed75f42d", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d451982e36b1f5a7a8412d9fb36924699aeb223/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d451982e36b1f5a7a8412d9fb36924699aeb223/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=4d451982e36b1f5a7a8412d9fb36924699aeb223", "patch": "@@ -800,7 +800,7 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n /* Front ends should never have to include middle-end headers.  Enforce\n    this by poisoning the header double-include protection defines.  */\n #ifdef IN_GCC_FRONTEND\n-#pragma GCC poison GCC_RTL_H GCC_EXCEPT_H\n+#pragma GCC poison GCC_RTL_H GCC_EXCEPT_H GCC_EXPR_H\n #endif\n \n /* Note: not all uses of the `index' token (e.g. variable names and"}]}