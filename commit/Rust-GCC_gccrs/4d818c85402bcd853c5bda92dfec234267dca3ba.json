{"sha": "4d818c85402bcd853c5bda92dfec234267dca3ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ4MThjODU0MDJiY2Q4NTNjNWJkYTkyZGZlYzIzNDI2N2RjYTNiYQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "1998-05-26T07:37:15Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "1998-05-26T07:37:15Z"}, "message": "arm.c (bad_signed_byte_operand): New predicate function.\n\n* arm.c (bad_signed_byte_operand): New predicate function.\n* arm.h (PREDICATE_CODES): Add it to the list.\n* arm.md (*extendqi[sh]i_insn): Split any addresses that ldrsb\ncan't handle.\n(define_split): Two new splits for above insns.\n\nFrom-SVN: r20057", "tree": {"sha": "1be04d13d394d482a1db5c5b46d905e0f7974860", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1be04d13d394d482a1db5c5b46d905e0f7974860"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d818c85402bcd853c5bda92dfec234267dca3ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d818c85402bcd853c5bda92dfec234267dca3ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d818c85402bcd853c5bda92dfec234267dca3ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d818c85402bcd853c5bda92dfec234267dca3ba/comments", "author": null, "committer": null, "parents": [{"sha": "312a0c90730e796c40ae8e52b4575d4043668d9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/312a0c90730e796c40ae8e52b4575d4043668d9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/312a0c90730e796c40ae8e52b4575d4043668d9b"}], "stats": {"total": 121, "additions": 114, "deletions": 7}, "files": [{"sha": "13750bda9426b85972dd6fb2e5454921d8a85ac6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d818c85402bcd853c5bda92dfec234267dca3ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d818c85402bcd853c5bda92dfec234267dca3ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d818c85402bcd853c5bda92dfec234267dca3ba", "patch": "@@ -1,3 +1,11 @@\n+Tue May 26 07:31:04 1998  Richard Earnshaw (rearnsha@arm.com)\n+\n+\t* arm.c (bad_signed_byte_operand): New predicate function.\n+\t* arm.h (PREDICATE_CODES): Add it to the list.\n+\t* arm.md (*extendqi[sh]i_insn): Split any addresses that ldrsb\n+\tcan't handle.\n+\t(define_split): Two new splits for above insns.\n+\n Mon May 25 22:49:56 PDT 1998 Jeff Law  (law@cygnus.com)\n \n \t* version.c: Bump for snapshot."}, {"sha": "ab0faa835ad90eea855f53b32a915af33086fdfc", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d818c85402bcd853c5bda92dfec234267dca3ba/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d818c85402bcd853c5bda92dfec234267dca3ba/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=4d818c85402bcd853c5bda92dfec234267dca3ba", "patch": "@@ -1745,6 +1745,33 @@ reload_memory_operand (op, mode)\n \t\t  && REGNO (op) >= FIRST_PSEUDO_REGISTER)));\n }\n \n+/* Return 1 if OP is a valid memory address, but not valid for a signed byte\n+   memory access (architecture V4) */\n+int\n+bad_signed_byte_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (! memory_operand (op, mode) || GET_CODE (op) != MEM)\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+\n+  /* A sum of anything more complex than reg + reg or reg + const is bad */\n+  if ((GET_CODE (op) == PLUS || GET_CODE (op) == MINUS)\n+      && ! s_register_operand (XEXP (op, 0), VOIDmode))\n+    return 1;\n+\n+  /* Big constants are also bad */\n+  if (GET_CODE (op) == PLUS && GET_CODE (XEXP (op, 1)) == CONST_INT\n+      && (INTVAL (XEXP (op, 1)) > 0xff\n+\t  || -INTVAL (XEXP (op, 1)) > 0xff))\n+    return 1;\n+\n+  /* Everything else is good, or can will automatically be made so. */\n+  return 0;\n+}\n+\n /* Return TRUE for valid operands for the rhs of an ARM instruction.  */\n \n int"}, {"sha": "c6676da52159d8bf1dc9093a3a0a7f1effa24bf3", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d818c85402bcd853c5bda92dfec234267dca3ba/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d818c85402bcd853c5bda92dfec234267dca3ba/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=4d818c85402bcd853c5bda92dfec234267dca3ba", "patch": "@@ -1781,6 +1781,7 @@ extern int arm_compare_fp;\n   {\"fpu_rhs_operand\", {SUBREG, REG, CONST_DOUBLE}},\t\t\t\\\n   {\"arm_not_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"offsettable_memory_operand\", {MEM}},\t\t\t\t\\\n+  {\"bad_signed_byte_operand\", {MEM}},\t\t\t\t\t\\\n   {\"alignable_memory_operand\", {MEM}},\t\t\t\t\t\\\n   {\"shiftable_operator\", {PLUS, MINUS, AND, IOR, XOR}},\t\t\t\\\n   {\"minmax_operator\", {SMIN, SMAX, UMIN, UMAX}},\t\t\t\\"}, {"sha": "4df608726ed72f0c8ca6a49c6fd58f0175c2f146", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 78, "deletions": 7, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d818c85402bcd853c5bda92dfec234267dca3ba/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d818c85402bcd853c5bda92dfec234267dca3ba/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=4d818c85402bcd853c5bda92dfec234267dca3ba", "patch": "@@ -2344,16 +2344,52 @@\n   operands[2] = gen_reg_rtx (SImode);\n }\")\n \n+; Rather than restricting all byte accesses to memory addresses that ldrsb\n+; can handle, we fix up the ones that ldrsb can't grok with a split.\n (define_insn \"*extendqihi_insn\"\n   [(set (match_operand:HI 0 \"s_register_operand\" \"=r\")\n-\t(sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"o<>\")))]\n+\t(sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n   \"arm_arch4\"\n-  \"ldr%?sb\\\\t%0, %1\"\n-[(set_attr \"type\" \"load\")])\n+  \"*\n+  /* If the address is invalid, this will split the instruction into two. */\n+  if (bad_signed_byte_operand(operands[1], QImode))\n+    return \\\"#\\\";\n+  return \\\"ldr%?sb\\\\t%0, %1\\\";\n+\"\n+[(set_attr \"type\" \"load\")\n+ (set_attr \"length\" \"8\")])\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"s_register_operand\" \"\")\n+\t(sign_extend:HI (match_operand:QI 1 \"bad_signed_byte_operand\" \"\")))]\n+  \"arm_arch4 && reload_completed\"\n+  [(set (match_dup 3) (match_dup 1))\n+   (set (match_dup 0) (sign_extend:HI (match_dup 2)))]\n+  \"\n+  {\n+    HOST_WIDE_INT offset;\n+\n+    operands[3] = gen_rtx (REG, SImode, REGNO (operands[0]));\n+    operands[2] = gen_rtx (MEM, QImode, operands[3]);\n+    MEM_IN_STRUCT_P (operands[2]) = MEM_IN_STRUCT_P (operands[1]);\n+    RTX_UNCHANGING_P (operands[2]) = RTX_UNCHANGING_P (operands[1]);\n+    operands[1] = XEXP (operands[1], 0);\n+    if (GET_CODE (operands[1]) == PLUS\n+\t&& GET_CODE (XEXP (operands[1], 1)) == CONST_INT\n+\t&& ! (const_ok_for_arm (offset = INTVAL (XEXP (operands[1], 1)))\n+\t      || const_ok_for_arm (-offset)))\n+      {\n+\tHOST_WIDE_INT low = (offset > 0\n+\t\t\t     ? (offset & 0xff) : -((-offset) & 0xff));\n+\tXEXP (operands[2], 0) = plus_constant (operands[3], low);\n+\toperands[1] = plus_constant (XEXP (operands[1], 0), offset - low);\n+      }\n+  }\n+\")\n \n (define_expand \"extendqisi2\"\n   [(set (match_dup 2)\n-\t(ashift:SI (match_operand:QI 1 \"s_register_operand\" \"\")\n+\t(ashift:SI (match_operand:QI 1 \"general_operand\" \"\")\n \t\t   (const_int 24)))\n    (set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(ashiftrt:SI (match_dup 2)\n@@ -2373,12 +2409,47 @@\n   operands[2] = gen_reg_rtx (SImode);\n }\")\n \n+; Rather than restricting all byte accesses to memory addresses that ldrsb\n+; can handle, we fix up the ones that ldrsb can't grok with a split.\n (define_insn \"*extendqisi_insn\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"o<>\")))]\n+\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n   \"arm_arch4\"\n-  \"ldr%?sb\\\\t%0, %1\"\n-[(set_attr \"type\" \"load\")])\n+  \"*\n+  /* If the address is invalid, this will split the instruction into two. */\n+  if (bad_signed_byte_operand(operands[1], QImode))\n+    return \\\"#\\\";\n+  return \\\"ldr%?sb\\\\t%0, %1\\\";\n+\"\n+[(set_attr \"type\" \"load\")\n+ (set_attr \"length\" \"8\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:QI 1 \"bad_signed_byte_operand\" \"\")))]\n+  \"arm_arch4 && reload_completed\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 0) (sign_extend:SI (match_dup 2)))]\n+  \"\n+  {\n+    HOST_WIDE_INT offset;\n+\n+    operands[2] = gen_rtx (MEM, QImode, operands[0]);\n+    MEM_IN_STRUCT_P (operands[2]) = MEM_IN_STRUCT_P (operands[1]);\n+    RTX_UNCHANGING_P (operands[2]) = RTX_UNCHANGING_P (operands[1]);\n+    operands[1] = XEXP (operands[1], 0);\n+    if (GET_CODE (operands[1]) == PLUS\n+\t&& GET_CODE (XEXP (operands[1], 1)) == CONST_INT\n+\t&& ! (const_ok_for_arm (offset = INTVAL (XEXP (operands[1], 1)))\n+\t      || const_ok_for_arm (-offset)))\n+      {\n+\tHOST_WIDE_INT low = (offset > 0\n+\t\t\t     ? (offset & 0xff) : -((-offset) & 0xff));\n+\tXEXP (operands[2], 0) = plus_constant (operands[0], low);\n+\toperands[1] = plus_constant (XEXP (operands[1], 0), offset - low);\n+      }\n+  }\n+\")\n \n (define_insn \"extendsfdf2\"\n   [(set (match_operand:DF 0 \"s_register_operand\" \"=f\")"}]}