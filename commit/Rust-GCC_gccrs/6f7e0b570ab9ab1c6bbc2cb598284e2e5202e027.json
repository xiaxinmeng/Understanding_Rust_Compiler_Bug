{"sha": "6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY3ZTBiNTcwYWI5YWIxYzZiYmMyY2I1OTgyODRlMmU1MjAyZTAyNw==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2014-05-06T19:28:03Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-05-06T19:28:03Z"}, "message": "compiler: Use backend interface for expressions.\n\n\t* go-gcc.cc (Gcc_backend::nil_pointer_expression): New method.\n\t(Gcc_backend::boolean_constant_expression): New method.\n\t(Gcc_backend::zero_expression): Use this->make_expression rather\n\tthan tree_to_expr.\n\t(Gcc_backend::var_expression): Likewise.\n\t(Gcc_backend::integer_constant_expression): Likewise.\n\t(Gcc_backend::float_constant_expression): Likewise.\n\t(Gcc_backend::complex_constant_expression): Likewise.\n\t(Gcc_backend::struct_field_expression): Likewise.\n\t(tree_to_type, tree_to_expr, tree_to_stat): Remove functions.\n\t(tree_to_function, tree_to_block): Remove functions.\n\t(type_to_tree, expr_to_tree, stat_to_tree): Remove functions.\n\t(block_to_tree, var_to_tree, function_to_tree): Remove functions.\n\nFrom-SVN: r210122", "tree": {"sha": "d260b1bb70995d642f35a870ceae7f566c5f052a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d260b1bb70995d642f35a870ceae7f566c5f052a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/comments", "author": null, "committer": null, "parents": [{"sha": "3379b71f51c36c499ca5ce4ec877bd70b96a580e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3379b71f51c36c499ca5ce4ec877bd70b96a580e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3379b71f51c36c499ca5ce4ec877bd70b96a580e"}], "stats": {"total": 1272, "additions": 554, "deletions": 718}, "files": [{"sha": "26a1c45791c004468dcbb4ff7de62408c5270eec", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027", "patch": "@@ -1,3 +1,19 @@\n+2014-05-06  Chris Manghane  <cmang@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::nil_pointer_expression): New method.\n+\t(Gcc_backend::boolean_constant_expression): New method.\n+\t(Gcc_backend::zero_expression): Use this->make_expression rather\n+\tthan tree_to_expr.\n+\t(Gcc_backend::var_expression): Likewise.\n+\t(Gcc_backend::integer_constant_expression): Likewise.\n+\t(Gcc_backend::float_constant_expression): Likewise.\n+\t(Gcc_backend::complex_constant_expression): Likewise.\n+\t(Gcc_backend::struct_field_expression): Likewise.\n+\t(tree_to_type, tree_to_expr, tree_to_stat): Remove functions.\n+\t(tree_to_function, tree_to_block): Remove functions.\n+\t(type_to_tree, expr_to_tree, stat_to_tree): Remove functions.\n+\t(block_to_tree, var_to_tree, function_to_tree): Remove functions.\n+\n 2014-05-06  Kenneth Zadeck  <zadeck@naturalbridge.com>\n \t    Mike Stump  <mikestump@comcast.net>\n \t    Richard Sandiford  <rdsandiford@googlemail.com>"}, {"sha": "fc100e2389cd4961938ee8a50cec8a9ba4869f42", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 22, "deletions": 76, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027", "patch": "@@ -225,6 +225,10 @@ class Gcc_backend : public Backend\n   error_expression()\n   { return this->make_expression(error_mark_node); }\n \n+  Bexpression*\n+  nil_pointer_expression()\n+  { return this->make_expression(null_pointer_node); }\n+\n   Bexpression*\n   var_expression(Bvariable* var, Location);\n \n@@ -247,6 +251,9 @@ class Gcc_backend : public Backend\n   Bexpression*\n   string_constant_expression(const std::string& val);\n \n+  Bexpression*\n+  boolean_constant_expression(bool val);\n+\n   Bexpression*\n   real_part_expression(Bexpression* bcomplex, Location);\n \n@@ -1129,7 +1136,7 @@ Gcc_backend::zero_expression(Btype* btype)\n     ret = error_mark_node;\n   else\n     ret = build_zero_cst(t);\n-  return tree_to_expr(ret);\n+  return this->make_expression(ret);\n }\n \n // An expression that references a variable.\n@@ -1140,7 +1147,7 @@ Gcc_backend::var_expression(Bvariable* var, Location)\n   tree ret = var->get_tree();\n   if (ret == error_mark_node)\n     return this->error_expression();\n-  return tree_to_expr(ret);\n+  return this->make_expression(ret);\n }\n \n // An expression that indirectly references an expression.\n@@ -1201,7 +1208,7 @@ Gcc_backend::integer_constant_expression(Btype* btype, mpz_t val)\n     return this->error_expression();\n \n   tree ret = double_int_to_tree(t, mpz_get_double_int(t, val, true));\n-  return tree_to_expr(ret);\n+  return this->make_expression(ret);\n }\n \n // Return a typed value as a constant floating-point number.\n@@ -1219,7 +1226,7 @@ Gcc_backend::float_constant_expression(Btype* btype, mpfr_t val)\n   REAL_VALUE_TYPE r2;\n   real_convert(&r2, TYPE_MODE(t), &r1);\n   ret = build_real(t, r2);\n-  return tree_to_expr(ret);\n+  return this->make_expression(ret);\n }\n \n // Return a typed real and imaginary value as a constant complex number.\n@@ -1244,7 +1251,7 @@ Gcc_backend::complex_constant_expression(Btype* btype, mpfr_t real, mpfr_t imag)\n \n   ret = build_complex(t, build_real(TREE_TYPE(t), r2),\n                       build_real(TREE_TYPE(t), r4));\n-  return tree_to_expr(ret);\n+  return this->make_expression(ret);\n }\n \n // Make a constant string expression.\n@@ -1264,6 +1271,15 @@ Gcc_backend::string_constant_expression(const std::string& val)\n   return this->make_expression(string_val);\n }\n \n+// Make a constant boolean expression.\n+\n+Bexpression*\n+Gcc_backend::boolean_constant_expression(bool val)\n+{\n+  tree bool_cst = val ? boolean_true_node : boolean_false_node;\n+  return this->make_expression(bool_cst);\n+}\n+\n // Return the real part of a complex expression.\n \n Bexpression*\n@@ -1407,7 +1423,7 @@ Gcc_backend::struct_field_expression(Bexpression* bstruct, size_t index,\n                              NULL_TREE);\n   if (TREE_CONSTANT(struct_tree))\n     TREE_CONSTANT(ret) = 1;\n-  return tree_to_expr(ret);\n+  return this->make_expression(ret);\n }\n \n // Return an expression that executes BSTAT before BEXPR.\n@@ -2923,73 +2939,3 @@ go_get_backend()\n {\n   return new Gcc_backend();\n }\n-\n-// FIXME: Temporary functions while converting to the new backend\n-// interface.\n-\n-Btype*\n-tree_to_type(tree t)\n-{\n-  return new Btype(t);\n-}\n-\n-Bexpression*\n-tree_to_expr(tree t)\n-{\n-  return new Bexpression(t);\n-}\n-\n-Bstatement*\n-tree_to_stat(tree t)\n-{\n-  return new Bstatement(t);\n-}\n-\n-Bfunction*\n-tree_to_function(tree t)\n-{\n-  return new Bfunction(t);\n-}\n-\n-Bblock*\n-tree_to_block(tree t)\n-{\n-  gcc_assert(TREE_CODE(t) == BIND_EXPR);\n-  return new Bblock(t);\n-}\n-\n-tree\n-type_to_tree(Btype* bt)\n-{\n-  return bt->get_tree();\n-}\n-\n-tree\n-expr_to_tree(Bexpression* be)\n-{\n-  return be->get_tree();\n-}\n-\n-tree\n-stat_to_tree(Bstatement* bs)\n-{\n-  return bs->get_tree();\n-}\n-\n-tree\n-block_to_tree(Bblock* bb)\n-{\n-  return bb->get_tree();\n-}\n-\n-tree\n-var_to_tree(Bvariable* bv)\n-{\n-  return bv->get_tree();\n-}\n-\n-tree\n-function_to_tree(Bfunction* bf)\n-{\n-  return bf->get_tree();\n-}"}, {"sha": "fdcfd28e08ed17a56c0a18ce79ba4ef59e518466", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027", "patch": "@@ -247,6 +247,10 @@ class Backend\n   virtual Bexpression*\n   error_expression() = 0;\n \n+  // Create a nil pointer expression.\n+  virtual Bexpression*\n+  nil_pointer_expression() = 0;\n+\n   // Create a reference to a variable.\n   virtual Bexpression*\n   var_expression(Bvariable* var, Location) = 0;\n@@ -281,6 +285,10 @@ class Backend\n   virtual Bexpression*\n   string_constant_expression(const std::string& val) = 0;\n \n+  // Return an expression for the boolean value VAL.\n+  virtual Bexpression*\n+  boolean_constant_expression(bool val) = 0;\n+\n   // Return an expression for the real part of BCOMPLEX.\n   virtual Bexpression*\n   real_part_expression(Bexpression* bcomplex, Location) = 0;\n@@ -687,19 +695,4 @@ class Backend\n \n extern Backend* go_get_backend();\n \n-// FIXME: Temporary helper functions while converting to new backend\n-// interface.\n-\n-extern Btype* tree_to_type(tree);\n-extern Bexpression* tree_to_expr(tree);\n-extern Bstatement* tree_to_stat(tree);\n-extern Bfunction* tree_to_function(tree);\n-extern Bblock* tree_to_block(tree);\n-extern tree type_to_tree(Btype*);\n-extern tree expr_to_tree(Bexpression*);\n-extern tree stat_to_tree(Bstatement*);\n-extern tree block_to_tree(Bblock*);\n-extern tree var_to_tree(Bvariable*);\n-extern tree function_to_tree(Bfunction*);\n-\n #endif // !defined(GO_BACKEND_H)"}, {"sha": "6c9bdaccec6bd8171a22ff3f95b26492cd6b794b", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 405, "deletions": 501, "changes": 906, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027", "patch": "@@ -8,17 +8,6 @@\n \n #include <algorithm>\n \n-#include \"toplev.h\"\n-#include \"intl.h\"\n-#include \"tree.h\"\n-#include \"stringpool.h\"\n-#include \"stor-layout.h\"\n-#include \"gimple-expr.h\"\n-#include \"tree-iterator.h\"\n-#include \"convert.h\"\n-#include \"real.h\"\n-#include \"realmpfr.h\"\n-\n #include \"go-c.h\"\n #include \"gogo.h\"\n #include \"types.h\"\n@@ -400,18 +389,18 @@ Expression::convert_interface_to_type(Type *lhs_type, Expression* rhs,\n   return Expression::make_compound(check_iface, obj, location);\n }\n \n-// Convert an expression to a tree.  This is implemented by the child\n-// class.  Not that it is not in general safe to call this multiple\n+// Convert an expression to its backend representation.  This is implemented by\n+// the child class.  Not that it is not in general safe to call this multiple\n // times for a single expression, but that we don't catch such errors.\n \n-tree\n-Expression::get_tree(Translate_context* context)\n+Bexpression*\n+Expression::get_backend(Translate_context* context)\n {\n   // The child may have marked this expression as having an error.\n   if (this->classification_ == EXPRESSION_ERROR)\n-    return error_mark_node;\n+    return context->backend()->error_expression();\n \n-  return this->do_get_tree(context);\n+  return this->do_get_backend(context);\n }\n \n // Return a backend expression for VAL.\n@@ -585,9 +574,9 @@ class Error_expression : public Expression\n   do_is_addressable() const\n   { return true; }\n \n-  tree\n-  do_get_tree(Translate_context*)\n-  { return error_mark_node; }\n+  Bexpression*\n+  do_get_backend(Translate_context* context)\n+  { return context->backend()->error_expression(); }\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -640,8 +629,8 @@ Type_expression : public Expression\n   do_copy()\n   { return this; }\n \n-  tree\n-  do_get_tree(Translate_context*)\n+  Bexpression*\n+  do_get_backend(Translate_context*)\n   { go_unreachable(); }\n \n   void do_dump_expression(Ast_dump_context*) const;\n@@ -751,10 +740,10 @@ Var_expression::do_address_taken(bool escapes)\n     }\n }\n \n-// Get the tree for a reference to a variable.\n+// Get the backend representation for a reference to a variable.\n \n-tree\n-Var_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Var_expression::do_get_backend(Translate_context* context)\n {\n   Bvariable* bvar = this->variable_->get_backend_variable(context->gogo(),\n \t\t\t\t\t\t\t  context->function());\n@@ -778,7 +767,7 @@ Var_expression::do_get_tree(Translate_context* context)\n   Bexpression* ret = context->backend()->var_expression(bvar, loc);\n   if (is_in_heap)\n     ret = context->backend()->indirect_expression(btype, ret, true, loc);\n-  return expr_to_tree(ret);\n+  return ret;\n }\n \n // Ast dump for variable expression.\n@@ -823,10 +812,10 @@ Temporary_reference_expression::do_address_taken(bool)\n   this->statement_->set_is_address_taken();\n }\n \n-// Get a tree referring to the variable.\n+// Get a backend expression referring to the variable.\n \n-tree\n-Temporary_reference_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Temporary_reference_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n   Bvariable* bvar = this->statement_->get_backend_variable(context);\n@@ -845,7 +834,7 @@ Temporary_reference_expression::do_get_tree(Translate_context* context)\n       Btype* btype = this->type()->base()->get_backend(gogo);\n       ret = gogo->backend()->convert_expression(btype, ret, this->location());\n     }\n-  return expr_to_tree(ret);\n+  return ret;\n }\n \n // Ast dump for temporary reference.\n@@ -895,19 +884,19 @@ Set_and_use_temporary_expression::do_address_taken(bool)\n \n // Return the backend representation.\n \n-tree\n-Set_and_use_temporary_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Set_and_use_temporary_expression::do_get_backend(Translate_context* context)\n {\n   Location loc = this->location();\n   Gogo* gogo = context->gogo();\n   Bvariable* bvar = this->statement_->get_backend_variable(context);\n   Bexpression* var_ref = gogo->backend()->var_expression(bvar, loc);\n \n-  Bexpression* bexpr = tree_to_expr(this->expr_->get_tree(context));\n+  Bexpression* bexpr = this->expr_->get_backend(context);\n   Bstatement* set = gogo->backend()->assignment_statement(var_ref, bexpr, loc);\n   var_ref = gogo->backend()->var_expression(bvar, loc);\n   Bexpression* ret = gogo->backend()->compound_expression(set, var_ref, loc);\n-  return expr_to_tree(ret);\n+  return ret;\n }\n \n // Dump.\n@@ -957,8 +946,8 @@ class Sink_expression : public Expression\n   do_copy()\n   { return new Sink_expression(this->location()); }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -992,8 +981,8 @@ Sink_expression::do_determine_type(const Type_context* context)\n // Return a temporary variable for a sink expression.  This will\n // presumably be a write-only variable which the middle-end will drop.\n \n-tree\n-Sink_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Sink_expression::do_get_backend(Translate_context* context)\n {\n   Location loc = this->location();\n   Gogo* gogo = context->gogo();\n@@ -1010,9 +999,9 @@ Sink_expression::do_get_tree(Translate_context* context)\n \t\t\t\t\t    false, loc, &decl);\n       Bexpression* var_ref = gogo->backend()->var_expression(this->bvar_, loc);\n       var_ref = gogo->backend()->compound_expression(decl, var_ref, loc);\n-      return expr_to_tree(var_ref);\n+      return var_ref;\n     }\n-  return expr_to_tree(gogo->backend()->var_expression(this->bvar_, loc));\n+  return gogo->backend()->var_expression(this->bvar_, loc);\n }\n \n // Ast dump for sink expression.\n@@ -1061,7 +1050,7 @@ Func_expression::do_type()\n     go_unreachable();\n }\n \n-// Get the tree for the code of a function expression.\n+// Get the backend representation for the code of a function expression.\n \n Bexpression*\n Func_expression::get_code_pointer(Gogo* gogo, Named_object* no, Location loc)\n@@ -1095,15 +1084,15 @@ Func_expression::get_code_pointer(Gogo* gogo, Named_object* no, Location loc)\n   return gogo->backend()->function_code_expression(fndecl, loc);\n }\n \n-// Get the tree for a function expression.  This is used when we take\n-// the address of a function rather than simply calling it.  A func\n+// Get the backend representation for a function expression.  This is used when\n+// we take the address of a function rather than simply calling it.  A func\n // value is represented as a pointer to a block of memory.  The first\n // word of that memory is a pointer to the function code.  The\n // remaining parts of that memory are the addresses of variables that\n // the function closes over.\n \n-tree\n-Func_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Func_expression::do_get_backend(Translate_context* context)\n {\n   // If there is no closure, just use the function descriptor.\n   if (this->closure_ == NULL)\n@@ -1121,17 +1110,15 @@ Func_expression::do_get_tree(Translate_context* context)\n \t\t       (\"invalid use of special builtin function %qs; \"\n \t\t\t\"must be called\"),\n \t\t       no->message_name().c_str());\n-\t      return error_mark_node;\n+\t      return gogo->backend()->error_expression();\n \t    }\n \t  descriptor = no->func_declaration_value()->descriptor(gogo, no);\n \t}\n       else\n \tgo_unreachable();\n \n-      tree dtree = descriptor->get_tree(context);\n-      if (dtree == error_mark_node)\n-\treturn error_mark_node;\n-      return build_fold_addr_expr_loc(this->location().gcc_location(), dtree);\n+      Bexpression* bdesc = descriptor->get_backend(context);\n+      return gogo->backend()->address_expression(bdesc, this->location());\n     }\n \n   go_assert(this->function_->func_value()->enclosing() != NULL);\n@@ -1140,7 +1127,7 @@ Func_expression::do_get_tree(Translate_context* context)\n   // expression.  It is a pointer to a struct whose first field points\n   // to the function code and whose remaining fields are the addresses\n   // of the closed-over variables.\n-  return this->closure_->get_tree(context);\n+  return this->closure_->get_backend(context);\n }\n \n // Ast dump for function.\n@@ -1207,18 +1194,17 @@ Func_descriptor_expression::do_type()\n   return Func_descriptor_expression::descriptor_type;\n }\n \n-// The tree for a function descriptor.\n+// The backend representation for a function descriptor.\n \n-tree\n-Func_descriptor_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Func_descriptor_expression::do_get_backend(Translate_context* context)\n {\n-  if (this->dvar_ != NULL)\n-    return var_to_tree(this->dvar_);\n-\n-  Gogo* gogo = context->gogo();\n   Named_object* no = this->fn_;\n   Location loc = no->location();\n+  if (this->dvar_ != NULL)\n+    return context->backend()->var_expression(this->dvar_, loc);\n \n+  Gogo* gogo = context->gogo();\n   std::string var_name;\n   if (no->package() == NULL)\n     var_name = gogo->pkgpath_symbol();\n@@ -1249,13 +1235,13 @@ Func_descriptor_expression::do_get_tree(Translate_context* context)\n \tExpression::make_struct_composite_literal(this->type(), vals, bloc);\n       Translate_context bcontext(gogo, NULL, NULL, NULL);\n       bcontext.set_is_const();\n-      Bexpression* binit = tree_to_expr(init->get_tree(&bcontext));\n+      Bexpression* binit = init->get_backend(&bcontext);\n       context->backend()->immutable_struct_set_init(bvar, var_name, is_hidden,\n \t\t\t\t\t\t    false, btype, bloc, binit);\n     }\n \n   this->dvar_ = bvar;\n-  return var_to_tree(bvar);\n+  return gogo->backend()->var_expression(bvar, loc);\n }\n \n // Print a function descriptor expression.\n@@ -1316,8 +1302,8 @@ class Func_code_reference_expression : public Expression\n \t\t\t\t\t\tthis->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context* context) const\n@@ -1328,15 +1314,13 @@ class Func_code_reference_expression : public Expression\n   Named_object* function_;\n };\n \n-// Get the tree for a reference to function code.\n+// Get the backend representation for a reference to function code.\n \n-tree\n-Func_code_reference_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Func_code_reference_expression::do_get_backend(Translate_context* context)\n {\n-  Bexpression* ret =\n-      Func_expression::get_code_pointer(context->gogo(), this->function_,\n-                                        this->location());\n-  return expr_to_tree(ret);\n+  return Func_expression::get_code_pointer(context->gogo(), this->function_,\n+\t\t\t\t\t   this->location());\n }\n \n // Make a reference to the code of a function.\n@@ -1459,9 +1443,9 @@ class Boolean_expression : public Expression\n   do_copy()\n   { return this; }\n \n-  tree\n-  do_get_tree(Translate_context*)\n-  { return this->val_ ? boolean_true_node : boolean_false_node; }\n+  Bexpression*\n+  do_get_backend(Translate_context* context)\n+  { return context->backend()->boolean_constant_expression(this->val_); }\n \n   void\n   do_export(Export* exp) const\n@@ -1553,8 +1537,8 @@ String_expression::do_determine_type(const Type_context* context)\n \n // Build a string constant.\n \n-tree\n-String_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+String_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n   Btype* btype = Type::make_string_type()->get_backend(gogo);\n@@ -1571,8 +1555,7 @@ String_expression::do_get_tree(Translate_context* context)\n   init[1] = gogo->backend()->integer_constant_expression(int_btype, lenval);\n   mpz_clear(lenval);\n \n-  Bexpression* ret = gogo->backend()->constructor_expression(btype, init, loc);\n-  return expr_to_tree(ret);\n+  return gogo->backend()->constructor_expression(btype, init, loc);\n }\n \n  // Write string literal to string dump.\n@@ -1706,8 +1689,8 @@ class String_info_expression : public Expression\n \t\t\t\t      this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context* context);\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -1744,24 +1727,23 @@ String_info_expression::do_type()\n \n // Return string information in GENERIC.\n \n-tree\n-String_info_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+String_info_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n \n-  Bexpression* bstring = tree_to_expr(this->string_->get_tree(context));\n-  Bexpression* ret;\n+  Bexpression* bstring = this->string_->get_backend(context);\n   switch (this->string_info_)\n     {\n     case STRING_INFO_DATA:\n     case STRING_INFO_LENGTH:\n-      ret = gogo->backend()->struct_field_expression(bstring, this->string_info_,\n-                                                     this->location());\n+      return gogo->backend()->struct_field_expression(bstring,\n+\t\t\t\t\t\t      this->string_info_,\n+\t\t\t\t\t\t      this->location());\n       break;\n     default:\n       go_unreachable();\n     }\n-  return expr_to_tree(ret);\n }\n \n // Dump ast representation for a type info expression.\n@@ -1832,8 +1814,8 @@ class Integer_expression : public Expression\n   void\n   do_check_types(Gogo*);\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   Expression*\n   do_copy()\n@@ -1926,10 +1908,10 @@ Integer_expression::do_check_types(Gogo*)\n     this->set_is_error();\n }\n \n-// Get a tree for an integer constant.\n+// Get the backend representation for an integer constant.\n \n-tree\n-Integer_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Integer_expression::do_get_backend(Translate_context* context)\n {\n   Type* resolved_type = NULL;\n   if (this->type_ != NULL && !this->type_->is_abstract())\n@@ -1961,15 +1943,12 @@ Integer_expression::do_get_tree(Translate_context* context)\n           if (!saw_errors())\n             error_at(this->location(),\n                      \"unknown type for large integer constant\");\n-          Bexpression* ret = context->gogo()->backend()->error_expression();\n-          return expr_to_tree(ret);\n+          return context->gogo()->backend()->error_expression();\n         }\n     }\n   Numeric_constant nc;\n   nc.set_int(resolved_type, this->val_);\n-  Bexpression* ret =\n-      Expression::backend_numeric_constant_expression(context, &nc);\n-  return expr_to_tree(ret);\n+  return Expression::backend_numeric_constant_expression(context, &nc);\n }\n \n // Write VAL to export data.\n@@ -2164,8 +2143,8 @@ class Float_expression : public Expression\n   { return Expression::make_float(&this->val_, this->type_,\n \t\t\t\t  this->location()); }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_export(Export*) const;\n@@ -2222,10 +2201,10 @@ Float_expression::do_check_types(Gogo*)\n     this->set_is_error();\n }\n \n-// Get a tree for a float constant.\n+// Get the backend representation for a float constant.\n \n-tree\n-Float_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Float_expression::do_get_backend(Translate_context* context)\n {\n   Type* resolved_type;\n   if (this->type_ != NULL && !this->type_->is_abstract())\n@@ -2250,9 +2229,7 @@ Float_expression::do_get_tree(Translate_context* context)\n \n   Numeric_constant nc;\n   nc.set_float(resolved_type, this->val_);\n-  Bexpression* ret =\n-      Expression::backend_numeric_constant_expression(context, &nc);\n-  return expr_to_tree(ret);\n+  return Expression::backend_numeric_constant_expression(context, &nc);\n }\n \n // Write a floating point number to a string dump.\n@@ -2353,8 +2330,8 @@ class Complex_expression : public Expression\n \t\t\t\t    this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_export(Export*) const;\n@@ -2411,10 +2388,10 @@ Complex_expression::do_check_types(Gogo*)\n     this->set_is_error();\n }\n \n-// Get a tree for a complex constant.\n+// Get the backend representation for a complex constant.\n \n-tree\n-Complex_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Complex_expression::do_get_backend(Translate_context* context)\n {\n   Type* resolved_type;\n   if (this->type_ != NULL && !this->type_->is_abstract())\n@@ -2439,9 +2416,7 @@ Complex_expression::do_get_tree(Translate_context* context)\n \n   Numeric_constant nc;\n   nc.set_complex(resolved_type, this->real_, this->imag_);\n-  Bexpression* ret =\n-      Expression::backend_numeric_constant_expression(context, &nc);\n-  return expr_to_tree(ret);\n+  return Expression::backend_numeric_constant_expression(context, &nc);\n }\n \n // Write REAL/IMAG to export data.\n@@ -2568,8 +2543,8 @@ class Const_expression : public Expression\n   do_copy()\n   { return this; }\n \n-  tree\n-  do_get_tree(Translate_context* context);\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n \n   // When exporting a reference to a const as part of a const\n   // expression, we export the value.  We ignore the fact that it has\n@@ -2800,13 +2775,13 @@ Const_expression::do_check_types(Gogo*)\n     }\n }\n \n-// Return a tree for the const reference.\n+// Return the backend representation for a const reference.\n \n-tree\n-Const_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Const_expression::do_get_backend(Translate_context* context)\n {\n   if (this->type_ != NULL && this->type_->is_error())\n-    return error_mark_node;\n+    return context->backend()->error_expression();\n \n   // If the type has been set for this expression, but the underlying\n   // object is an abstract int or float, we try to get the abstract\n@@ -2822,13 +2797,13 @@ Const_expression::do_get_tree(Translate_context* context)\n \t  && nc.set_type(this->type_, false, this->location()))\n \t{\n \t  Expression* e = nc.expression(this->location());\n-\t  return e->get_tree(context);\n+\t  return e->get_backend(context);\n \t}\n     }\n \n   if (this->type_ != NULL)\n     expr = Expression::make_cast(this->type_, expr, this->location());\n-  return expr->get_tree(context);\n+  return expr->get_backend(context);\n }\n \n // Dump ast representation for constant expression.\n@@ -2917,9 +2892,9 @@ class Nil_expression : public Expression\n   do_copy()\n   { return this; }\n \n-  tree\n-  do_get_tree(Translate_context*)\n-  { return null_pointer_node; }\n+  Bexpression*\n+  do_get_backend(Translate_context* context)\n+  { return context->backend()->nil_pointer_expression(); }\n \n   void\n   do_export(Export* exp) const\n@@ -3060,8 +3035,8 @@ class Type_conversion_expression : public Expression\n \t\t\t\t\t  this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context* context);\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n \n   void\n   do_export(Export*) const;\n@@ -3302,32 +3277,28 @@ Type_conversion_expression::do_check_types(Gogo*)\n   this->set_is_error();\n }\n \n-// Get a tree for a type conversion.\n+// Get the backend representation for a type conversion.\n \n-tree\n-Type_conversion_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Type_conversion_expression::do_get_backend(Translate_context* context)\n {\n   Type* type = this->type_;\n   Type* expr_type = this->expr_->type();\n \n   Gogo* gogo = context->gogo();\n   Btype* btype = type->get_backend(gogo);\n-  Bexpression* bexpr = tree_to_expr(this->expr_->get_tree(context));\n+  Bexpression* bexpr = this->expr_->get_backend(context);\n   Location loc = this->location();\n \n   if (Type::are_identical(type, expr_type, false, NULL))\n-    {\n-      Bexpression* bconvert =\n-        gogo->backend()->convert_expression(btype, bexpr, loc);\n-      return expr_to_tree(bconvert);\n-    }\n+    return gogo->backend()->convert_expression(btype, bexpr, loc);\n   else if (type->interface_type() != NULL\n \t   || expr_type->interface_type() != NULL)\n     {\n       Expression* conversion =\n           Expression::convert_for_assignment(gogo, type, this->expr_,\n                                              this->location());\n-      return conversion->get_tree(context);\n+      return conversion->get_backend(context);\n     }\n   else if (type->is_string_type()\n \t   && expr_type->integer_type() != NULL)\n@@ -3342,12 +3313,12 @@ Type_conversion_expression::do_get_tree(Translate_context* context)\n \t  Lex::append_char(mpz_get_ui(intval), true, &s, loc);\n \t  mpz_clear(intval);\n \t  Expression* se = Expression::make_string(s, loc);\n-\t  return se->get_tree(context);\n+\t  return se->get_backend(context);\n \t}\n \n       Expression* i2s_expr =\n           Runtime::make_call(Runtime::INT_TO_STRING, loc, 1, this->expr_);\n-      return Expression::make_cast(type, i2s_expr, loc)->get_tree(context);\n+      return Expression::make_cast(type, i2s_expr, loc)->get_backend(context);\n     }\n   else if (type->is_string_type() && expr_type->is_slice_type())\n     {\n@@ -3366,7 +3337,8 @@ Type_conversion_expression::do_get_tree(Translate_context* context)\n         }\n       Expression* valptr = a->get_value_pointer(gogo, this->expr_);\n       Expression* len = a->get_length(gogo, this->expr_);\n-      return Runtime::make_call(code, loc, 2, valptr, len)->get_tree(context);\n+      return Runtime::make_call(code, loc, 2, valptr,\n+\t\t\t\tlen)->get_backend(context);\n     }\n   else if (type->is_slice_type() && expr_type->is_string_type())\n     {\n@@ -3382,14 +3354,12 @@ Type_conversion_expression::do_get_tree(Translate_context* context)\n \t  code = Runtime::STRING_TO_INT_ARRAY;\n \t}\n       Expression* s2a = Runtime::make_call(code, loc, 1, this->expr_);\n-      return Expression::make_unsafe_cast(type, s2a, loc)->get_tree(context);\n+      return Expression::make_unsafe_cast(type, s2a, loc)->get_backend(context);\n     }\n   else if (type->is_numeric_type())\n     {\n       go_assert(Type::are_convertible(type, expr_type, NULL));\n-      Bexpression* bconvert =\n-\tgogo->backend()->convert_expression(btype, bexpr, loc);\n-      return expr_to_tree(bconvert);\n+      return gogo->backend()->convert_expression(btype, bexpr, loc);\n     }\n   else if ((type->is_unsafe_pointer_type()\n \t    && (expr_type->points_to() != NULL\n@@ -3399,16 +3369,12 @@ Type_conversion_expression::do_get_tree(Translate_context* context)\n            || (this->may_convert_function_types_\n                && type->function_type() != NULL\n                && expr_type->function_type() != NULL))\n-    {\n-      Bexpression* bconvert =\n-\tgogo->backend()->convert_expression(btype, bexpr, loc);\n-      return expr_to_tree(bconvert);\n-    }\n+    return gogo->backend()->convert_expression(btype, bexpr, loc);\n   else\n     {\n       Expression* conversion =\n           Expression::convert_for_assignment(gogo, type, this->expr_, loc);\n-      return conversion->get_tree(context);\n+      return conversion->get_backend(context);\n     }\n }\n \n@@ -3490,8 +3456,8 @@ class Unsafe_type_conversion_expression : public Expression\n \t\t\t\t\t\t this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -3516,8 +3482,8 @@ Unsafe_type_conversion_expression::do_traverse(Traverse* traverse)\n \n // Convert to backend representation.\n \n-tree\n-Unsafe_type_conversion_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Unsafe_type_conversion_expression::do_get_backend(Translate_context* context)\n {\n   // We are only called for a limited number of cases.\n \n@@ -3533,7 +3499,7 @@ Unsafe_type_conversion_expression::do_get_tree(Translate_context* context)\n           && !Type::are_convertible(t, et, NULL))\n \t{\n \t  go_assert(saw_errors());\n-\t  return error_mark_node;\n+\t  return context->backend()->error_expression();\n \t}\n \n       go_assert(et->struct_type() != NULL\n@@ -3569,11 +3535,9 @@ Unsafe_type_conversion_expression::do_get_tree(Translate_context* context)\n \n   Gogo* gogo = context->gogo();\n   Btype* btype = t->get_backend(gogo);\n-  Bexpression* bexpr = tree_to_expr(this->expr_->get_tree(context));\n+  Bexpression* bexpr = this->expr_->get_backend(context);\n   Location loc = this->location();\n-  Bexpression* ret =\n-    gogo->backend()->convert_expression(btype, bexpr, loc);\n-  return expr_to_tree(ret);\n+  return gogo->backend()->convert_expression(btype, bexpr, loc);\n }\n \n // Dump ast representation for an unsafe type conversion expression.\n@@ -4042,10 +4006,10 @@ Unary_expression::do_check_types(Gogo*)\n     }\n }\n \n-// Get a tree for a unary expression.\n+// Get the backend representation for a unary expression.\n \n-tree\n-Unary_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Unary_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n   Location loc = this->location();\n@@ -4061,23 +4025,18 @@ Unary_expression::do_get_tree(Translate_context* context)\n \t  Temporary_statement* temp = sut->temporary();\n \t  Bvariable* bvar = temp->get_backend_variable(context);\n           Bexpression* bvar_expr = gogo->backend()->var_expression(bvar, loc);\n-\n-          Expression* val = sut->expression();\n-          Bexpression* bval = tree_to_expr(val->get_tree(context));\n+          Bexpression* bval = sut->expression()->get_backend(context);\n \n           Bstatement* bassign =\n               gogo->backend()->assignment_statement(bvar_expr, bval, loc);\n           Bexpression* bvar_addr =\n               gogo->backend()->address_expression(bvar_expr, loc);\n-          Bexpression* ret =\n-              gogo->backend()->compound_expression(bassign, bvar_addr, loc);\n-          return expr_to_tree(ret);\n+\t  return gogo->backend()->compound_expression(bassign, bvar_addr, loc);\n \t}\n     }\n \n   Bexpression* ret;\n-  tree expr = this->expr_->get_tree(context);\n-  Bexpression* bexpr = tree_to_expr(expr);\n+  Bexpression* bexpr = this->expr_->get_backend(context);\n   Btype* btype = this->expr_->type()->get_backend(gogo);\n   switch (this->op_)\n     {\n@@ -4186,17 +4145,14 @@ Unary_expression::do_get_tree(Translate_context* context)\n \t    if (s >= 4096 || this->issue_nil_check_)\n \t      {\n                 go_assert(this->expr_->is_variable());\n-\n-                Expression* nil_expr = Expression::make_nil(loc);\n-                Bexpression* nil = tree_to_expr(nil_expr->get_tree(context));\n+                Bexpression* nil =\n+\t\t  Expression::make_nil(loc)->get_backend(context);\n                 Bexpression* compare =\n                     gogo->backend()->binary_expression(OPERATOR_EQEQ, bexpr,\n                                                        nil, loc);\n-\n-\t\tExpression* crash_expr =\n-\t\t    gogo->runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE, loc);\n                 Bexpression* crash =\n-                    tree_to_expr(crash_expr->get_tree(context));\n+\t\t  gogo->runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE,\n+\t\t\t\t      loc)->get_backend(context);\n                 bexpr = gogo->backend()->conditional_expression(btype, compare,\n                                                                 crash, bexpr,\n                                                                 loc);\n@@ -4211,7 +4167,7 @@ Unary_expression::do_get_tree(Translate_context* context)\n       go_unreachable();\n     }\n \n-  return expr_to_tree(ret);\n+  return ret;\n }\n \n // Export a unary expression.\n@@ -5898,10 +5854,10 @@ Binary_expression::do_check_types(Gogo*)\n     }\n }\n \n-// Get a tree for a binary expression.\n+// Get the backend representation for a binary expression.\n \n-tree\n-Binary_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Binary_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n   Location loc = this->location();\n@@ -5919,12 +5875,8 @@ Binary_expression::do_get_tree(Translate_context* context)\n     case OPERATOR_LE:\n     case OPERATOR_GT:\n     case OPERATOR_GE:\n-      {\n-        Bexpression* ret =\n-            Expression::comparison(context, this->type_, this->op_,\n-                                   this->left_, this->right_, loc);\n-        return expr_to_tree(ret);\n-      }\n+      return Expression::comparison(context, this->type_, this->op_,\n+\t\t\t\t    this->left_, this->right_, loc);\n \n     case OPERATOR_OROR:\n     case OPERATOR_ANDAND:\n@@ -5960,7 +5912,7 @@ Binary_expression::do_get_tree(Translate_context* context)\n       Expression* string_plus =\n           Runtime::make_call(Runtime::STRING_PLUS, loc, 2,\n                              this->left_, this->right_);\n-      return string_plus->get_tree(context);\n+      return string_plus->get_backend(context);\n     }\n \n   // For complex division Go might want slightly different results than the\n@@ -5981,11 +5933,11 @@ Binary_expression::do_get_tree(Translate_context* context)\n \t}\n       Expression* complex_div =\n           Runtime::make_call(complex_code, loc, 2, this->left_, this->right_);\n-      return complex_div->get_tree(context);\n+      return complex_div->get_backend(context);\n     }\n \n-  Bexpression* left = tree_to_expr(this->left_->get_tree(context));\n-  Bexpression* right = tree_to_expr(this->right_->get_tree(context));\n+  Bexpression* left = this->left_->get_backend(context);\n+  Bexpression* right = this->right_->get_backend(context);\n \n   Type* type = use_left_type ? left_type : right_type;\n   Btype* btype = type->get_backend(gogo);\n@@ -6055,12 +6007,12 @@ Binary_expression::do_get_tree(Translate_context* context)\n \n \t  // __go_runtime_error(RUNTIME_ERROR_DIVISION_BY_ZERO)\n \t  int errcode = RUNTIME_ERROR_DIVISION_BY_ZERO;\n-\t  Expression* crash = gogo->runtime_error(errcode, loc);\n-          Bexpression* crash_expr = tree_to_expr(crash->get_tree(context));\n+\t  Bexpression* crash = gogo->runtime_error(errcode,\n+\t\t\t\t\t\t   loc)->get_backend(context);\n \n \t  // right == 0 ? (__go_runtime_error(...), 0) : ret\n-          ret = gogo->backend()->conditional_expression(btype, check,\n-                                                        crash_expr, ret, loc);\n+          ret = gogo->backend()->conditional_expression(btype, check, crash,\n+\t\t\t\t\t\t\tret, loc);\n \t}\n \n       if (gogo->check_divide_overflow())\n@@ -6107,7 +6059,7 @@ Binary_expression::do_get_tree(Translate_context* context)\n                 {\n                   Expression* negate_expr =\n                       Expression::make_unary(OPERATOR_MINUS, this->left_, loc);\n-                  overflow = tree_to_expr(negate_expr->get_tree(context));\n+                  overflow = negate_expr->get_backend(context);\n                 }\n \t      else\n                 overflow = zero_expr;\n@@ -6123,7 +6075,7 @@ Binary_expression::do_get_tree(Translate_context* context)\n   mpz_clear(zero);\n   mpz_clear(one);\n   mpz_clear(neg_one);\n-  return expr_to_tree(ret);\n+  return ret;\n }\n \n // Export a binary expression.\n@@ -6447,8 +6399,8 @@ Expression::comparison(Translate_context* context, Type* result_type,\n \t}\n     }\n \n-  Bexpression* left_bexpr = tree_to_expr(left->get_tree(context));\n-  Bexpression* right_bexpr = tree_to_expr(right->get_tree(context));\n+  Bexpression* left_bexpr = left->get_backend(context);\n+  Bexpression* right_bexpr = right->get_backend(context);\n \n   Gogo* gogo = context->gogo();\n   Bexpression* ret = gogo->backend()->binary_expression(op, left_bexpr,\n@@ -6708,18 +6660,18 @@ bme_check_nil(const Method::Field_indexes* field_indexes, Location loc,\n   return cond;\n }\n \n-// Get the tree for a method value.\n+// Get the backend representation for a method value.\n \n-tree\n-Bound_method_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Bound_method_expression::do_get_backend(Translate_context* context)\n {\n   Named_object* thunk = Bound_method_expression::create_thunk(context->gogo(),\n \t\t\t\t\t\t\t      this->method_,\n \t\t\t\t\t\t\t      this->function_);\n   if (thunk->is_erroneous())\n     {\n       go_assert(saw_errors());\n-      return error_mark_node;\n+      return context->backend()->error_expression();\n     }\n \n   // FIXME: We should lower this earlier, but we can't lower it in the\n@@ -6792,19 +6744,19 @@ Bound_method_expression::do_get_tree(Translate_context* context)\n \tnil_check = Expression::make_binary(OPERATOR_OROR, nil_check, n, loc);\n     }\n \n-  Bexpression* bme = tree_to_expr(ret->get_tree(context));\n+  Bexpression* bme = ret->get_backend(context);\n   if (nil_check != NULL)\n     {\n       Gogo* gogo = context->gogo();\n-      Expression* crash =\n-\tgogo->runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE, loc);\n-      Bexpression* bcrash = tree_to_expr(crash->get_tree(context));\n+      Bexpression* crash =\n+\tgogo->runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE,\n+\t\t\t    loc)->get_backend(context);\n       Btype* btype = ret->type()->get_backend(gogo);\n-      Bexpression* bcheck = tree_to_expr(nil_check->get_tree(context));\n-      bme = gogo->backend()->conditional_expression(btype, bcheck, bcrash,\n+      Bexpression* bcheck = nil_check->get_backend(context);\n+      bme = gogo->backend()->conditional_expression(btype, bcheck, crash,\n \t\t\t\t\t\t    bme, loc);\n     }\n-  return expr_to_tree(bme);\n+  return bme;\n }\n \n // Dump ast representation of a bound method expression.\n@@ -6879,8 +6831,8 @@ class Builtin_call_expression : public Call_expression\n \t\t\t\t       this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_export(Export*) const;\n@@ -8299,10 +8251,10 @@ Builtin_call_expression::do_check_types(Gogo*)\n     }\n }\n \n-// Return the tree for a builtin function.\n+// Return the backend representation for a builtin function.\n \n-tree\n-Builtin_call_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Builtin_call_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n   Location location = this->location();\n@@ -8324,7 +8276,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \tif (this->seen_)\n \t  {\n \t    go_assert(saw_errors());\n-\t    return error_mark_node;\n+\t    return context->backend()->error_expression();\n \t  }\n \tthis->seen_ = true;\n \tthis->seen_ = false;\n@@ -8348,7 +8300,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\tif (this->seen_)\n \t\t  {\n \t\t    go_assert(saw_errors());\n-\t\t    return error_mark_node;\n+\t\t    return context->backend()->error_expression();\n \t\t  }\n \t\tthis->seen_ = true;\n \t        val = arg_type->array_type()->get_length(gogo, arg);\n@@ -8368,7 +8320,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\tif (this->seen_)\n \t\t  {\n \t\t    go_assert(saw_errors());\n-\t\t    return error_mark_node;\n+\t\t    return context->backend()->error_expression();\n \t\t  }\n \t\tthis->seen_ = true;\n                 val = arg_type->array_type()->get_capacity(gogo, arg);\n@@ -8381,7 +8333,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t  }\n \n \treturn Expression::make_cast(int_type, val,\n-\t\t\t\t     location)->get_tree(context);\n+\t\t\t\t     location)->get_backend(context);\n       }\n \n     case BUILTIN_PRINT:\n@@ -8460,7 +8412,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\telse\n \t\t  {\n \t\t    go_assert(saw_errors());\n-\t\t    return error_mark_node;\n+\t\t    return context->backend()->error_expression();\n \t\t  }\n \n                 Expression* call = Runtime::make_call(code, location, 1, arg);\n@@ -8483,7 +8435,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n                                                       location);\n \t  }\n \n-        return print_stmts->get_tree(context);\n+        return print_stmts->get_backend(context);\n       }\n \n     case BUILTIN_PANIC:\n@@ -8497,7 +8449,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \n         Expression* panic =\n             Runtime::make_call(Runtime::PANIC, location, 1, arg);\n-        return panic->get_tree(context);\n+        return panic->get_backend(context);\n       }\n \n     case BUILTIN_RECOVER:\n@@ -8522,7 +8474,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n                                                  location, 0);\n         Expression* cond =\n             Expression::make_conditional(arg, recover, nil, location);\n-        return cond->get_tree(context);\n+        return cond->get_backend(context);\n       }\n \n     case BUILTIN_CLOSE:\n@@ -8532,7 +8484,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \tExpression* arg = args->front();\n         Expression* close = Runtime::make_call(Runtime::CLOSE, location,\n \t\t\t\t\t       1, arg);\n-        return close->get_tree(context);\n+        return close->get_backend(context);\n       }\n \n     case BUILTIN_SIZEOF:\n@@ -8545,15 +8497,15 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t    || nc.to_unsigned_long(&val) != Numeric_constant::NC_UL_VALID)\n \t  {\n \t    go_assert(saw_errors());\n-\t    return error_mark_node;\n+\t    return context->backend()->error_expression();\n \t  }\n \tType* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n         mpz_t ival;\n         nc.get_int(&ival);\n         Expression* int_cst =\n             Expression::make_integer(&ival, uintptr_type, location);\n         mpz_clear(ival);\n-        return int_cst->get_tree(context);\n+        return int_cst->get_backend(context);\n       }\n \n     case BUILTIN_COPY:\n@@ -8607,7 +8559,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n                                               arg1_val, arg2_val, bytecount);\n \n         Expression* compound = Expression::make_compound(copy, length, location);\n-        return compound->get_tree(context);\n+        return compound->get_backend(context);\n       }\n \n     case BUILTIN_APPEND:\n@@ -8650,34 +8602,31 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n                                                 arg1, arg2_val, arg2_len,\n                                                 element_size);\n         append = Expression::make_unsafe_cast(arg1->type(), append, location);\n-        return append->get_tree(context);\n+        return append->get_backend(context);\n       }\n \n     case BUILTIN_REAL:\n     case BUILTIN_IMAG:\n       {\n \tconst Expression_list* args = this->args();\n \tgo_assert(args != NULL && args->size() == 1);\n-\tExpression* arg = args->front();\n \n         Bexpression* ret;\n-        Bexpression* bcomplex = tree_to_expr(arg->get_tree(context));\n+        Bexpression* bcomplex = args->front()->get_backend(context);\n         if (this->code_ == BUILTIN_REAL)\n           ret = gogo->backend()->real_part_expression(bcomplex, location);\n         else\n           ret = gogo->backend()->imag_part_expression(bcomplex, location);\n-        return expr_to_tree(ret);\n+        return ret;\n       }\n \n     case BUILTIN_COMPLEX:\n       {\n \tconst Expression_list* args = this->args();\n \tgo_assert(args != NULL && args->size() == 2);\n-\tBexpression* breal = tree_to_expr(args->front()->get_tree(context));\n-\tBexpression* bimag = tree_to_expr(args->back()->get_tree(context));\n-        Bexpression* ret =\n-            gogo->backend()->complex_expression(breal, bimag, location);\n-        return expr_to_tree(ret);\n+\tBexpression* breal = args->front()->get_backend(context);\n+\tBexpression* bimag = args->back()->get_backend(context);\n+\treturn gogo->backend()->complex_expression(breal, bimag, location);\n       }\n \n     default:\n@@ -9400,18 +9349,18 @@ Call_expression::interface_method_function(\n \n // Build the call expression.\n \n-tree\n-Call_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Call_expression::do_get_backend(Translate_context* context)\n {\n   if (this->call_ != NULL)\n-    return expr_to_tree(this->call_);\n+    return this->call_;\n \n   Function_type* fntype = this->get_function_type();\n   if (fntype == NULL)\n-    return error_mark_node;\n+    return context->backend()->error_expression();\n \n   if (this->fn_->is_error_expression())\n-    return error_mark_node;\n+    return context->backend()->error_expression();\n \n   Gogo* gogo = context->gogo();\n   Location location = this->location();\n@@ -9448,7 +9397,7 @@ Call_expression::do_get_tree(Translate_context* context)\n \t\t&& this->args_->size() == 1);\n       nargs = 1;\n       fn_args.resize(1);\n-      fn_args[0] = tree_to_expr(this->args_->front()->get_tree(context));\n+      fn_args[0] = this->args_->front()->get_backend(context);\n     }\n   else\n     {\n@@ -9463,7 +9412,7 @@ Call_expression::do_get_tree(Translate_context* context)\n       Expression_list::const_iterator pe = this->args_->begin();\n       if (!is_interface_method && fntype->is_method())\n \t{\n-          fn_args[i] = tree_to_expr((*pe)->get_tree(context));\n+          fn_args[i] = (*pe)->get_backend(context);\n \t  ++pe;\n \t  ++i;\n \t}\n@@ -9473,7 +9422,7 @@ Call_expression::do_get_tree(Translate_context* context)\n           Expression* arg =\n               Expression::convert_for_assignment(gogo, pp->type(), *pe,\n                                                  location);\n-          fn_args[i] = tree_to_expr(arg->get_tree(context));\n+          fn_args[i] = arg->get_backend(context);\n \t}\n       go_assert(pp == params->end());\n       go_assert(i == nargs);\n@@ -9504,7 +9453,7 @@ Call_expression::do_get_tree(Translate_context* context)\n     {\n       Expression* first_arg;\n       fn = this->interface_method_function(interface_method, &first_arg);\n-      fn_args[0] = tree_to_expr(first_arg->get_tree(context));\n+      fn_args[0] = first_arg->get_backend(context);\n     }\n \n   if (!has_closure_arg)\n@@ -9521,7 +9470,7 @@ Call_expression::do_get_tree(Translate_context* context)\n       fn = Expression::make_compound(set_closure, fn, location);\n     }\n \n-  Bexpression* bfn = tree_to_expr(fn->get_tree(context));\n+  Bexpression* bfn = fn->get_backend(context);\n \n   // When not calling a named function directly, use a type conversion\n   // in case the type of the function is a recursive type which refers\n@@ -9542,7 +9491,7 @@ Call_expression::do_get_tree(Translate_context* context)\n       go_assert(this->call_temp_ != NULL);\n       Expression* call_ref =\n           Expression::make_temporary_reference(this->call_temp_, location);\n-      Bexpression* bcall_ref = tree_to_expr(call_ref->get_tree(context));\n+      Bexpression* bcall_ref = call_ref->get_backend(context);\n       Bstatement* assn_stmt =\n           gogo->backend()->assignment_statement(bcall_ref, call, location);\n \n@@ -9551,11 +9500,11 @@ Call_expression::do_get_tree(Translate_context* context)\n       Bexpression* set_and_call =\n           gogo->backend()->compound_expression(assn_stmt, this->call_,\n                                                location);\n-      return expr_to_tree(set_and_call);\n+      return set_and_call;\n     }\n \n   this->call_ = call;\n-  return expr_to_tree(this->call_);\n+  return this->call_;\n }\n \n // Set the result variables if this call returns multiple results.\n@@ -9581,7 +9530,7 @@ Call_expression::set_results(Translate_context* context, Bexpression* call)\n \tExpression::make_temporary_reference(temp, loc);\n       ref->set_is_lvalue();\n \n-      Bexpression* result_ref = tree_to_expr(ref->get_tree(context));\n+      Bexpression* result_ref = ref->get_backend(context);\n       Bexpression* call_result =\n           gogo->backend()->struct_field_expression(call, i, loc);\n       Bstatement* assn_stmt =\n@@ -9658,8 +9607,8 @@ class Call_result_expression : public Expression\n   do_must_eval_in_order() const\n   { return true; }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -9754,27 +9703,27 @@ Call_result_expression::do_determine_type(const Type_context*)\n   this->call_->determine_type_no_context();\n }\n \n-// Return the tree.  We just refer to the temporary set by the call\n-// expression.  We don't do this at lowering time because it makes it\n+// Return the backend representation.  We just refer to the temporary set by the\n+// call expression.  We don't do this at lowering time because it makes it\n // hard to evaluate the call at the right time.\n \n-tree\n-Call_result_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Call_result_expression::do_get_backend(Translate_context* context)\n {\n   Call_expression* ce = this->call_->call_expression();\n   if (ce == NULL)\n     {\n       go_assert(this->call_->is_error_expression());\n-      return error_mark_node;\n+      return context->backend()->error_expression();\n     }\n   Temporary_statement* ts = ce->result(this->index_);\n   if (ts == NULL)\n     {\n       go_assert(saw_errors());\n-      return error_mark_node;\n+      return context->backend()->error_expression();\n     }\n   Expression* ref = Expression::make_temporary_reference(ts, this->location());\n-  return ref->get_tree(context);\n+  return ref->get_backend(context);\n }\n \n // Dump ast representation for a call result expression.\n@@ -9988,8 +9937,8 @@ class Array_index_expression : public Expression\n   do_issue_nil_check()\n   { this->array_->issue_nil_check(); }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -10253,16 +10202,16 @@ Array_index_expression::do_is_addressable() const\n   return this->array_->is_addressable();\n }\n \n-// Get a tree for an array index.\n+// Get the backend representation for an array index.\n \n-tree\n-Array_index_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Array_index_expression::do_get_backend(Translate_context* context)\n {\n   Array_type* array_type = this->array_->type()->array_type();\n   if (array_type == NULL)\n     {\n       go_assert(this->array_->type()->is_error());\n-      return error_mark_node;\n+      return context->backend()->error_expression();\n     }\n   go_assert(!array_type->is_slice_type() || this->array_->is_variable());\n \n@@ -10279,22 +10228,22 @@ Array_index_expression::do_get_tree(Translate_context* context)\n   if (this->end_ == NULL || this->end_->is_nil_expression())\n     {\n       Expression* len = array_type->get_length(gogo, this->array_);\n-      length = tree_to_expr(len->get_tree(context));\n+      length = len->get_backend(context);\n       length = gogo->backend()->convert_expression(int_btype, length, loc);\n     }\n \n   Bexpression* capacity = NULL;\n   if (this->end_ != NULL)\n     {\n       Expression* cap = array_type->get_capacity(gogo, this->array_);\n-      capacity = tree_to_expr(cap->get_tree(context));\n+      capacity = cap->get_backend(context);\n       capacity = gogo->backend()->convert_expression(int_btype, capacity, loc);\n     }\n \n   Bexpression* cap_arg = capacity;\n   if (this->cap_ != NULL)\n     {\n-      cap_arg = tree_to_expr(this->cap_->get_tree(context));\n+      cap_arg = this->cap_->get_backend(context);\n       cap_arg = gogo->backend()->convert_expression(int_btype, cap_arg, loc);\n     }\n \n@@ -10308,13 +10257,12 @@ Array_index_expression::do_get_tree(Translate_context* context)\n \t      : (this->end_ == NULL\n \t\t ? RUNTIME_ERROR_SLICE_INDEX_OUT_OF_BOUNDS\n \t\t : RUNTIME_ERROR_SLICE_SLICE_OUT_OF_BOUNDS));\n-  Bexpression* crash =\n-      tree_to_expr(gogo->runtime_error(code, loc)->get_tree(context));\n+  Bexpression* crash = gogo->runtime_error(code, loc)->get_backend(context);\n \n-  Expression* bounds_check = Expression::check_bounds(this->start_, loc);\n-  Bexpression* bad_index = tree_to_expr(bounds_check->get_tree(context));\n+  Bexpression* bad_index =\n+    Expression::check_bounds(this->start_, loc)->get_backend(context);\n \n-  Bexpression* start = tree_to_expr(this->start_->get_tree(context));\n+  Bexpression* start = this->start_->get_backend(context);\n   start = gogo->backend()->convert_expression(int_btype, start, loc);\n   Bexpression* start_too_large =\n     gogo->backend()->binary_expression((this->end_ == NULL\n@@ -10339,31 +10287,30 @@ Array_index_expression::do_get_tree(Translate_context* context)\n       Bexpression* ret;\n       if (array_type->length() != NULL)\n \t{\n-\t  Bexpression* array = tree_to_expr(this->array_->get_tree(context));\n+\t  Bexpression* array = this->array_->get_backend(context);\n \t  ret = gogo->backend()->array_index_expression(array, start, loc);\n \t}\n       else\n \t{\n \t  // Slice.\n \t  Expression* valptr =\n               array_type->get_value_pointer(gogo, this->array_);\n-\t  Bexpression* ptr = tree_to_expr(valptr->get_tree(context));\n+\t  Bexpression* ptr = valptr->get_backend(context);\n           ptr = gogo->backend()->pointer_offset_expression(ptr, start, loc);\n \n \t  Type* ele_type = this->array_->type()->array_type()->element_type();\n \t  Btype* ele_btype = ele_type->get_backend(gogo);\n \t  ret = gogo->backend()->indirect_expression(ele_btype, ptr, true, loc);\n \t}\n-      return expr_to_tree(ret);\n+      return ret;\n     }\n \n   // Array slice.\n \n   if (this->cap_ != NULL)\n     {\n-      bounds_check = Expression::check_bounds(this->cap_, loc);\n       Bexpression* bounds_bcheck =\n-\ttree_to_expr(bounds_check->get_tree(context));\n+\tExpression::check_bounds(this->cap_, loc)->get_backend(context);\n       bad_index =\n \tgogo->backend()->binary_expression(OPERATOR_OROR, bounds_bcheck,\n \t\t\t\t\t   bad_index, loc);\n@@ -10385,15 +10332,14 @@ Array_index_expression::do_get_tree(Translate_context* context)\n     end = length;\n   else\n     {\n-      bounds_check = Expression::check_bounds(this->end_, loc);\n       Bexpression* bounds_bcheck =\n-\ttree_to_expr(bounds_check->get_tree(context));\n+\tExpression::check_bounds(this->end_, loc)->get_backend(context);\n \n       bad_index =\n \tgogo->backend()->binary_expression(OPERATOR_OROR, bounds_bcheck,\n \t\t\t\t\t   bad_index, loc);\n \n-      end = tree_to_expr(this->end_->get_tree(context));\n+      end = this->end_->get_backend(context);\n       end = gogo->backend()->convert_expression(int_btype, end, loc);\n       Bexpression* end_too_small =\n \tgogo->backend()->binary_expression(OPERATOR_LT, end, start, loc);\n@@ -10407,7 +10353,7 @@ Array_index_expression::do_get_tree(Translate_context* context)\n     }\n \n   Expression* valptr = array_type->get_value_pointer(gogo, this->array_);\n-  Bexpression* val = tree_to_expr(valptr->get_tree(context));\n+  Bexpression* val = valptr->get_backend(context);\n   val = gogo->backend()->pointer_offset_expression(val, start, loc);\n \n   Bexpression* result_length =\n@@ -10424,11 +10370,8 @@ Array_index_expression::do_get_tree(Translate_context* context)\n \n   Bexpression* ctor =\n     gogo->backend()->constructor_expression(struct_btype, init, loc);\n-  Bexpression* ret =\n-    gogo->backend()->conditional_expression(struct_btype, bad_index,\n-\t\t\t\t\t    crash, ctor, loc);\n-\n-  return expr_to_tree(ret);\n+  return gogo->backend()->conditional_expression(struct_btype, bad_index,\n+\t\t\t\t\t\t crash, ctor, loc);\n }\n \n // Dump ast representation for an array index expression.\n@@ -10496,8 +10439,8 @@ class String_index_expression : public Expression\n     return true;\n   }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -10639,10 +10582,10 @@ String_index_expression::do_check_types(Gogo*)\n     mpz_clear(ival);\n }\n \n-// Get a tree for a string index.\n+// Get the backend representation for a string index.\n \n-tree\n-String_index_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+String_index_expression::do_get_backend(Translate_context* context)\n {\n   Location loc = this->location();\n   Expression* string_arg = this->string_;\n@@ -10656,8 +10599,7 @@ String_index_expression::do_get_tree(Translate_context* context)\n \t      : RUNTIME_ERROR_STRING_SLICE_OUT_OF_BOUNDS);\n \n   Gogo* gogo = context->gogo();\n-  Bexpression* crash =\n-      tree_to_expr(gogo->runtime_error(code, loc)->get_tree(context));\n+  Bexpression* crash = gogo->runtime_error(code, loc)->get_backend(context);\n \n   Type* int_type = Type::lookup_integer_type(\"int\");\n \n@@ -10670,7 +10612,7 @@ String_index_expression::do_get_tree(Translate_context* context)\n       && !Type::are_convertible(int_type, this->start_->type(), NULL))\n     {\n       go_assert(saw_errors());\n-      return error_mark_node;\n+      return context->backend()->error_expression();\n     }\n \n   Expression* start = Expression::make_cast(int_type, this->start_, loc);\n@@ -10687,19 +10629,17 @@ String_index_expression::do_get_tree(Translate_context* context)\n       Expression* bytes =\n \tExpression::make_string_info(this->string_, STRING_INFO_DATA, loc);\n \n-      Bexpression* bstart = tree_to_expr(start->get_tree(context));\n-      Bexpression* ptr = tree_to_expr(bytes->get_tree(context));\n+      Bexpression* bstart = start->get_backend(context);\n+      Bexpression* ptr = bytes->get_backend(context);\n       ptr = gogo->backend()->pointer_offset_expression(ptr, bstart, loc);\n       Btype* ubtype = Type::lookup_integer_type(\"uint8\")->get_backend(gogo);\n       Bexpression* index = \n \tgogo->backend()->indirect_expression(ubtype, ptr, true, loc);\n \n       Btype* byte_btype = bytes->type()->points_to()->get_backend(gogo);\n-      Bexpression* index_error = tree_to_expr(bad_index->get_tree(context));\n-      Bexpression* ret =\n-          gogo->backend()->conditional_expression(byte_btype, index_error,\n-                                                  crash, index, loc);\n-      return expr_to_tree(ret);\n+      Bexpression* index_error = bad_index->get_backend(context);\n+      return gogo->backend()->conditional_expression(byte_btype, index_error,\n+\t\t\t\t\t\t     crash, index, loc);\n     }\n \n   Expression* end = NULL;\n@@ -10720,14 +10660,12 @@ String_index_expression::do_get_tree(Translate_context* context)\n \n   Expression* strslice = Runtime::make_call(Runtime::STRING_SLICE, loc, 3,\n                                             string_arg, start, end);\n-  Bexpression* bstrslice = tree_to_expr(strslice->get_tree(context));\n+  Bexpression* bstrslice = strslice->get_backend(context);\n \n   Btype* str_btype = strslice->type()->get_backend(gogo);\n-  Bexpression* index_error = tree_to_expr(bad_index->get_tree(context));\n-  Bexpression* ret =\n-      gogo->backend()->conditional_expression(str_btype, index_error,\n-                                              crash, bstrslice, loc);\n-  return expr_to_tree(ret);\n+  Bexpression* index_error = bad_index->get_backend(context);\n+  return gogo->backend()->conditional_expression(str_btype, index_error,\n+\t\t\t\t\t\t crash, bstrslice, loc);\n }\n \n // Dump ast representation for a string index expression.\n@@ -10862,16 +10800,16 @@ Map_index_expression::do_check_types(Gogo*)\n     }\n }\n \n-// Get a tree for a map index.\n+// Get the backend representation for a map index.\n \n-tree\n-Map_index_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Map_index_expression::do_get_backend(Translate_context* context)\n {\n   Map_type* type = this->get_map_type();\n   if (type == NULL)\n     {\n       go_assert(saw_errors());\n-      return error_mark_node;\n+      return context->backend()->error_expression();\n     }\n \n   go_assert(this->value_pointer_ != NULL\n@@ -10883,13 +10821,13 @@ Map_index_expression::do_get_tree(Translate_context* context)\n       Expression* val =\n           Expression::make_unary(OPERATOR_MULT, this->value_pointer_,\n                                  this->location());\n-      ret = tree_to_expr(val->get_tree(context));\n+      ret = val->get_backend(context);\n     }\n   else if (this->is_in_tuple_assignment_)\n     {\n       // Tuple_map_assignment_statement is responsible for using this\n       // appropriately.\n-      ret = tree_to_expr(this->value_pointer_->get_tree(context));\n+      ret = this->value_pointer_->get_backend(context);\n     }\n   else\n     {\n@@ -10898,19 +10836,18 @@ Map_index_expression::do_get_tree(Translate_context* context)\n       Expression* nil_check =\n           Expression::make_binary(OPERATOR_EQEQ, this->value_pointer_,\n                                   Expression::make_nil(loc), loc);\n-      Bexpression* bnil_check = tree_to_expr(nil_check->get_tree(context));\n+      Bexpression* bnil_check = nil_check->get_backend(context);\n       Expression* val =\n           Expression::make_unary(OPERATOR_MULT, this->value_pointer_, loc);\n-      Bexpression* bval = tree_to_expr(val->get_tree(context));\n+      Bexpression* bval = val->get_backend(context);\n \n       Gogo* gogo = context->gogo();\n       Btype* val_btype = type->val_type()->get_backend(gogo);\n       Bexpression* val_zero = gogo->backend()->zero_expression(val_btype);\n       ret = gogo->backend()->conditional_expression(val_btype, bnil_check,\n                                                     val_zero, bval, loc);\n     }\n-\n-  return expr_to_tree(ret);\n+  return ret;\n }\n \n // Get an expression for the map index.  This returns an expression which\n@@ -11093,17 +11030,15 @@ Field_reference_expression::do_check_types(Gogo*)\n   go_assert(struct_type->field(this->field_index_) != NULL);\n }\n \n-// Get a tree for a field reference.\n+// Get the backend representation for a field reference.\n \n-tree\n-Field_reference_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Field_reference_expression::do_get_backend(Translate_context* context)\n {\n-  Bexpression* bstruct = tree_to_expr(this->expr_->get_tree(context));\n-  Bexpression* ret =\n-      context->gogo()->backend()->struct_field_expression(bstruct,\n-                                                          this->field_index_,\n-                                                          this->location());\n-  return expr_to_tree(ret);\n+  Bexpression* bstruct = this->expr_->get_backend(context);\n+  return context->gogo()->backend()->struct_field_expression(bstruct,\n+\t\t\t\t\t\t\t     this->field_index_,\n+\t\t\t\t\t\t\t     this->location());\n }\n \n // Dump ast representation for a field reference expression.\n@@ -11363,16 +11298,16 @@ Interface_field_reference_expression::create_thunk(Gogo* gogo,\n   return new_no;\n }\n \n-// Get a tree for a method value.\n+// Get the backend representation for a method value.\n \n-tree\n-Interface_field_reference_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Interface_field_reference_expression::do_get_backend(Translate_context* context)\n {\n   Interface_type* type = this->expr_->type()->interface_type();\n   if (type == NULL)\n     {\n       go_assert(saw_errors());\n-      return error_mark_node;\n+      return context->backend()->error_expression();\n     }\n \n   Named_object* thunk =\n@@ -11381,7 +11316,7 @@ Interface_field_reference_expression::do_get_tree(Translate_context* context)\n   if (thunk->is_erroneous())\n     {\n       go_assert(saw_errors());\n-      return error_mark_node;\n+      return context->backend()->error_expression();\n     }\n \n   // FIXME: We should lower this earlier, but we can't it lower it in\n@@ -11405,24 +11340,22 @@ Interface_field_reference_expression::do_get_tree(Translate_context* context)\n   vals->push_back(this->expr_);\n \n   Expression* expr = Expression::make_struct_composite_literal(st, vals, loc);\n-  expr = Expression::make_heap_expression(expr, loc);\n+  Bexpression* bclosure =\n+    Expression::make_heap_expression(expr, loc)->get_backend(context);\n \n-  Bexpression* bclosure = tree_to_expr(expr->get_tree(context));\n   Expression* nil_check =\n       Expression::make_binary(OPERATOR_EQEQ, this->expr_,\n                               Expression::make_nil(loc), loc);\n-  Bexpression* bnil_check = tree_to_expr(nil_check->get_tree(context));\n+  Bexpression* bnil_check = nil_check->get_backend(context);\n \n   Gogo* gogo = context->gogo();\n-  Expression* crash = gogo->runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE, loc);\n-  Bexpression* bcrash = tree_to_expr(crash->get_tree(context));\n+  Bexpression* bcrash = gogo->runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE,\n+\t\t\t\t\t    loc)->get_backend(context);\n \n   Bexpression* bcond =\n       gogo->backend()->conditional_expression(NULL, bnil_check, bcrash, NULL, loc);\n   Bstatement* cond_statement = gogo->backend()->expression_statement(bcond);\n-  Bexpression* ret =\n-      gogo->backend()->compound_expression(cond_statement, bclosure, loc);\n-  return expr_to_tree(ret);\n+  return gogo->backend()->compound_expression(cond_statement, bclosure, loc);\n }\n \n // Dump ast representation for an interface field reference.\n@@ -11741,8 +11674,8 @@ class Allocation_expression : public Expression\n   do_copy()\n   { return new Allocation_expression(this->type_, this->location()); }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -11752,18 +11685,17 @@ class Allocation_expression : public Expression\n   Type* type_;\n };\n \n-// Return a tree for an allocation expression.\n+// Return the backend representation for an allocation expression.\n \n-tree\n-Allocation_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Allocation_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n   Location loc = this->location();\n-  Expression* space = gogo->allocate_memory(this->type_, loc);\n-  Bexpression* bspace = tree_to_expr(space->get_tree(context));\n+  Bexpression* space = \n+    gogo->allocate_memory(this->type_, loc)->get_backend(context);\n   Btype* pbtype = gogo->backend()->pointer_type(this->type_->get_backend(gogo));\n-  Bexpression* ret = gogo->backend()->convert_expression(pbtype, bspace, loc);\n-  return expr_to_tree(ret);\n+  return gogo->backend()->convert_expression(pbtype, space, loc);\n }\n \n // Dump ast representation for an allocation expression.\n@@ -11834,8 +11766,8 @@ class Struct_construction_expression : public Expression\n     return ret;\n   }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_export(Export*) const;\n@@ -12008,16 +11940,16 @@ Struct_construction_expression::do_check_types(Gogo*)\n   go_assert(pv == this->vals_->end());\n }\n \n-// Return a tree for constructing a struct.\n+// Return the backend representation for constructing a struct.\n \n-tree\n-Struct_construction_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Struct_construction_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n \n   Btype* btype = this->type_->get_backend(gogo);\n   if (this->vals_ == NULL)\n-    return expr_to_tree(gogo->backend()->zero_expression(btype));\n+    return gogo->backend()->zero_expression(btype);\n \n   const Struct_field_list* fields = this->type_->struct_type()->fields();\n   Expression_list::const_iterator pv = this->vals_->begin();\n@@ -12039,14 +11971,11 @@ Struct_construction_expression::do_get_tree(Translate_context* context)\n           Expression* val =\n               Expression::convert_for_assignment(gogo, pf->type(),\n                                                  *pv, this->location());\n-          init.push_back(tree_to_expr(val->get_tree(context)));\n+          init.push_back(val->get_backend(context));\n \t  ++pv;\n \t}\n     }\n-\n-  Bexpression* ret =\n-      gogo->backend()->constructor_expression(btype, init, this->location());\n-  return expr_to_tree(ret);\n+  return gogo->backend()->constructor_expression(btype, init, this->location());\n }\n \n // Export a struct construction.\n@@ -12298,7 +12227,7 @@ Array_construction_expression::get_constructor(Translate_context* context,\n               Expression* val_expr =\n                   Expression::convert_for_assignment(gogo, element_type, *pv,\n                                                      this->location());\n-\t      vals.push_back(tree_to_expr(val_expr->get_tree(context)));\n+\t      vals.push_back(val_expr->get_backend(context));\n \t    }\n \t  if (this->indexes_ != NULL)\n \t    ++pi;\n@@ -12407,18 +12336,18 @@ class Fixed_array_construction_expression :\n \t\t\t\t\t\t   this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n };\n \n-// Return a tree for constructing a fixed array.\n+// Return the backend representation for constructing a fixed array.\n \n-tree\n-Fixed_array_construction_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Fixed_array_construction_expression::do_get_backend(Translate_context* context)\n {\n   Type* type = this->type();\n   Btype* btype = type->get_backend(context->gogo());\n-  return expr_to_tree(this->get_constructor(context, btype));\n+  return this->get_constructor(context, btype);\n }\n \n Expression*\n@@ -12455,24 +12384,24 @@ class Slice_construction_expression : public Array_construction_expression\n \t\t\t\t\t     this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n  private:\n   // The type of the values in this slice.\n   Type* valtype_;\n };\n \n-// Return a tree for constructing a slice.\n+// Return the backend representation for constructing a slice.\n \n-tree\n-Slice_construction_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Slice_construction_expression::do_get_backend(Translate_context* context)\n {\n   Array_type* array_type = this->type()->array_type();\n   if (array_type == NULL)\n     {\n       go_assert(this->type()->is_error());\n-      return error_mark_node;\n+      return context->backend()->error_expression();\n     }\n \n   Location loc = this->location();\n@@ -12533,7 +12462,7 @@ Slice_construction_expression::do_get_tree(Translate_context* context)\n   Expression* len = this->valtype_->array_type()->length();\n   Expression* slice_val =\n     Expression::make_slice_value(this->type(), space, len, len, loc);\n-  return slice_val->get_tree(context);\n+  return slice_val->get_backend(context);\n }\n \n // Make a slice composite literal.  This is used by the type\n@@ -12582,8 +12511,8 @@ class Map_construction_expression : public Expression\n \t\t\t\t\t   this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_export(Export*) const;\n@@ -12734,13 +12663,13 @@ Map_construction_expression::do_check_types(Gogo*)\n     }\n }\n \n-// Return a tree for constructing a map.\n+// Return the backend representation for constructing a map.\n \n-tree\n-Map_construction_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Map_construction_expression::do_get_backend(Translate_context* context)\n {\n   if (this->is_error_expression())\n-    return error_mark_node;\n+    return context->backend()->error_expression();\n   Location loc = this->location();\n \n   size_t i = 0;\n@@ -12785,7 +12714,7 @@ Map_construction_expression::do_get_tree(Translate_context* context)\n   Expression* map_ctor =\n       Runtime::make_call(Runtime::CONSTRUCT_MAP, loc, 6, descriptor, count,\n                          entry_size, val_offset, val_size, ventries);\n-  return map_ctor->get_tree(context);\n+  return map_ctor->get_backend(context);\n }\n \n // Export an array construction.\n@@ -13654,10 +13583,10 @@ Type_guard_expression::do_check_types(Gogo*)\n     }\n }\n \n-// Return a tree for a type guard expression.\n+// Return the backend representation for a type guard expression.\n \n-tree\n-Type_guard_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Type_guard_expression::do_get_backend(Translate_context* context)\n {\n   Expression* conversion;\n   if (this->type_->interface_type() != NULL)\n@@ -13669,7 +13598,7 @@ Type_guard_expression::do_get_tree(Translate_context* context)\n         Expression::convert_for_assignment(context->gogo(), this->type_,\n                                            this->expr_, this->location());\n \n-  return conversion->get_tree(context);\n+  return conversion->get_backend(context);\n }\n \n // Dump ast representation for a type guard expression.\n@@ -13725,8 +13654,8 @@ class Heap_expression : public Expression\n                                             this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   // We only export global objects, and the parser does not generate\n   // this in global scope.\n@@ -13742,19 +13671,19 @@ class Heap_expression : public Expression\n   Expression* expr_;\n };\n \n-// Return a tree which allocates an expression on the heap.\n+// Return the backend representation for allocating an expression on the heap.\n \n-tree\n-Heap_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Heap_expression::do_get_backend(Translate_context* context)\n {\n   if (this->expr_->is_error_expression() || this->expr_->type()->is_error())\n-    return error_mark_node;\n+    return context->backend()->error_expression();\n \n   Location loc = this->location();\n   Gogo* gogo = context->gogo();\n   Btype* btype = this->type()->get_backend(gogo);\n-  Expression* alloc = Expression::make_allocation(this->expr_->type(), loc);\n-  Bexpression* space = tree_to_expr(alloc->get_tree(context));\n+  Bexpression* space = Expression::make_allocation(this->expr_->type(),\n+\t\t\t\t\t\t   loc)->get_backend(context);\n \n   Bstatement* decl;\n   Named_object* fn = context->function();\n@@ -13768,12 +13697,11 @@ Heap_expression::do_get_tree(Translate_context* context)\n   Bexpression* ref =\n     gogo->backend()->indirect_expression(expr_btype, space, true, loc);\n \n-  Bexpression* bexpr = tree_to_expr(this->expr_->get_tree(context));\n+  Bexpression* bexpr = this->expr_->get_backend(context);\n   Bstatement* assn = gogo->backend()->assignment_statement(ref, bexpr, loc);\n   decl = gogo->backend()->compound_statement(decl, assn);\n   space = gogo->backend()->var_expression(space_temp, loc);\n-  Bexpression* ret = gogo->backend()->compound_expression(decl, space, loc);\n-  return expr_to_tree(ret);\n+  return gogo->backend()->compound_expression(decl, space, loc);\n }\n \n // Dump ast representation for a heap expression.\n@@ -13857,18 +13785,18 @@ Receive_expression::do_flatten(Gogo*, Named_object*,\n   return this;\n }\n \n-// Get a tree for a receive expression.\n+// Get the backend representation for a receive expression.\n \n-tree\n-Receive_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Receive_expression::do_get_backend(Translate_context* context)\n {\n   Location loc = this->location();\n \n   Channel_type* channel_type = this->channel_->type()->channel_type();\n   if (channel_type == NULL)\n     {\n       go_assert(this->channel_->type()->is_error());\n-      return error_mark_node;\n+      return context->backend()->error_expression();\n     }\n   Expression* td = Expression::make_type_descriptor(channel_type, loc);\n \n@@ -13880,8 +13808,7 @@ Receive_expression::do_get_tree(Translate_context* context)\n   Expression* recv =\n     Runtime::make_call(Runtime::RECEIVE, loc, 3,\n \t\t       td, this->channel_, recv_addr);\n-  recv = Expression::make_compound(recv, recv_ref, loc);\n-  return recv->get_tree(context);\n+  return Expression::make_compound(recv, recv_ref, loc)->get_backend(context);\n }\n \n // Dump ast representation for a receive expression.\n@@ -13929,12 +13856,11 @@ class Type_descriptor_expression : public Expression\n   do_copy()\n   { return this; }\n \n-  tree\n-  do_get_tree(Translate_context* context)\n+  Bexpression*\n+  do_get_backend(Translate_context* context)\n   {\n-    Bexpression* ret = this->type_->type_descriptor_pointer(context->gogo(),\n-                                                            this->location());\n-    return expr_to_tree(ret);\n+    return this->type_->type_descriptor_pointer(context->gogo(),\n+\t\t\t\t\t\tthis->location());\n   }\n \n   void\n@@ -13992,8 +13918,8 @@ class Type_info_expression : public Expression\n   do_copy()\n   { return this; }\n \n-  tree\n-  do_get_tree(Translate_context* context);\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -14023,10 +13949,10 @@ Type_info_expression::do_type()\n     }\n }\n \n-// Return type information in GENERIC.\n+// Return the backend representation for type information.\n \n-tree\n-Type_info_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Type_info_expression::do_get_backend(Translate_context* context)\n {\n   Btype* btype = this->type_->get_backend(context->gogo());\n   Gogo* gogo = context->gogo();\n@@ -14051,7 +13977,7 @@ Type_info_expression::do_get_tree(Translate_context* context)\n   Bexpression* ret =\n     gogo->backend()->integer_constant_expression(int_btype, cst);\n   mpz_clear(cst);\n-  return expr_to_tree(ret);\n+  return ret;\n }\n \n // Dump ast representation for a type info expression.\n@@ -14106,8 +14032,8 @@ class Slice_info_expression : public Expression\n                                      this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context* context);\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -14141,27 +14067,24 @@ Slice_info_expression::do_type()\n     }\n }\n \n-// Return slice information in GENERIC.\n+// Return the backend information for slice information.\n \n-tree\n-Slice_info_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Slice_info_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n-\n-  Bexpression* bslice = tree_to_expr(this->slice_->get_tree(context));\n-  Bexpression* ret;\n+  Bexpression* bslice = this->slice_->get_backend(context);\n   switch (this->slice_info_)\n     {\n     case SLICE_INFO_VALUE_POINTER:\n     case SLICE_INFO_LENGTH:\n     case SLICE_INFO_CAPACITY:\n-      ret = gogo->backend()->struct_field_expression(bslice, this->slice_info_,\n-                                                     this->location());\n+      return gogo->backend()->struct_field_expression(bslice, this->slice_info_,\n+\t\t\t\t\t\t      this->location());\n       break;\n     default:\n       go_unreachable();\n     }\n-  return expr_to_tree(ret);\n }\n \n // Dump ast representation for a type info expression.\n@@ -14222,8 +14145,8 @@ class Slice_value_expression : public Expression\n                                       this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context* context);\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -14249,19 +14172,17 @@ Slice_value_expression::do_traverse(Traverse* traverse)\n   return TRAVERSE_CONTINUE;\n }\n \n-tree\n-Slice_value_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Slice_value_expression::do_get_backend(Translate_context* context)\n {\n   std::vector<Bexpression*> vals(3);\n-  vals[0] = tree_to_expr(this->valptr_->get_tree(context));\n-  vals[1] = tree_to_expr(this->len_->get_tree(context));\n-  vals[2] = tree_to_expr(this->cap_->get_tree(context));\n+  vals[0] = this->valptr_->get_backend(context);\n+  vals[1] = this->len_->get_backend(context);\n+  vals[2] = this->cap_->get_backend(context);\n \n   Gogo* gogo = context->gogo();\n   Btype* btype = this->type_->get_backend(gogo);\n-  Bexpression* ret =\n-      gogo->backend()->constructor_expression(btype, vals, this->location());\n-  return expr_to_tree(ret);\n+  return gogo->backend()->constructor_expression(btype, vals, this->location());\n }\n \n void\n@@ -14313,8 +14234,8 @@ class Interface_info_expression : public Expression\n                                          this->iface_info_, this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context* context);\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -14390,26 +14311,23 @@ Interface_info_expression::do_type()\n     }\n }\n \n-// Return interface information in GENERIC.\n+// Return the backend representation for interface information.\n \n-tree\n-Interface_info_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Interface_info_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n-\n-  Bexpression* biface = tree_to_expr(this->iface_->get_tree(context));\n-  Bexpression* ret;\n+  Bexpression* biface = this->iface_->get_backend(context);\n   switch (this->iface_info_)\n     {\n     case INTERFACE_INFO_METHODS:\n     case INTERFACE_INFO_OBJECT:\n-      ret = gogo->backend()->struct_field_expression(biface, this->iface_info_,\n-                                                     this->location());\n+      return gogo->backend()->struct_field_expression(biface, this->iface_info_,\n+\t\t\t\t\t\t      this->location());\n       break;\n     default:\n       go_unreachable();\n     }\n-  return expr_to_tree(ret);\n }\n \n // Dump ast representation for an interface info expression.\n@@ -14472,8 +14390,8 @@ class Interface_value_expression : public Expression\n                                           this->obj_->copy(), this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context* context);\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -14497,18 +14415,16 @@ Interface_value_expression::do_traverse(Traverse* traverse)\n   return TRAVERSE_CONTINUE;\n }\n \n-tree\n-Interface_value_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Interface_value_expression::do_get_backend(Translate_context* context)\n {\n   std::vector<Bexpression*> vals(2);\n-  vals[0] = tree_to_expr(this->first_field_->get_tree(context));\n-  vals[1] = tree_to_expr(this->obj_->get_tree(context));\n+  vals[0] = this->first_field_->get_backend(context);\n+  vals[1] = this->obj_->get_backend(context);\n \n   Gogo* gogo = context->gogo();\n   Btype* btype = this->type_->get_backend(gogo);\n-  Bexpression* ret =\n-      gogo->backend()->constructor_expression(btype, vals, this->location());\n-  return expr_to_tree(ret);\n+  return gogo->backend()->constructor_expression(btype, vals, this->location());\n }\n \n void\n@@ -14572,8 +14488,8 @@ class Interface_mtable_expression : public Expression\n   do_is_addressable() const\n   { return true; }\n \n-  tree\n-  do_get_tree(Translate_context* context);\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -14622,17 +14538,13 @@ Interface_mtable_expression::do_type()\n   return this->method_table_type_;\n }\n \n-tree\n-Interface_mtable_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Interface_mtable_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n-  Bexpression* ret;\n   Location loc = Linemap::predeclared_location();\n   if (this->bvar_ != NULL)\n-    {\n-      ret = gogo->backend()->var_expression(this->bvar_, this->location());\n-      return expr_to_tree(ret);\n-    }\n+    return gogo->backend()->var_expression(this->bvar_, this->location());\n \n   const Typed_identifier_list* interface_methods = this->itype_->methods();\n   go_assert(!interface_methods->empty());\n@@ -14666,8 +14578,7 @@ Interface_mtable_expression::do_get_tree(Translate_context* context)\n       Btype* btype = this->type()->get_backend(gogo);\n       this->bvar_ =\n           gogo->backend()->immutable_struct_reference(mangled_name, btype, loc);\n-      ret = gogo->backend()->var_expression(this->bvar_, this->location());\n-      return expr_to_tree(ret);\n+      return gogo->backend()->var_expression(this->bvar_, this->location());\n     }\n \n   // The first element is the type descriptor.\n@@ -14707,15 +14618,14 @@ Interface_mtable_expression::do_get_tree(Translate_context* context)\n   Btype* btype = this->type()->get_backend(gogo);\n   Expression* mtable = Expression::make_struct_composite_literal(this->type(),\n                                                                  svals, loc);\n-  Bexpression* ctor = tree_to_expr(mtable->get_tree(context));\n+  Bexpression* ctor = mtable->get_backend(context);\n \n   bool is_public = has_hidden_methods && this->type_->named_type() != NULL;\n   this->bvar_ = gogo->backend()->immutable_struct(mangled_name, false,\n \t\t\t\t\t\t  !is_public, btype, loc);\n   gogo->backend()->immutable_struct_set_init(this->bvar_, mangled_name, false,\n                                              !is_public, btype, loc, ctor);\n-  ret = gogo->backend()->var_expression(this->bvar_, loc);\n-  return expr_to_tree(ret);\n+  return gogo->backend()->var_expression(this->bvar_, loc);\n }\n \n void\n@@ -14766,8 +14676,8 @@ class Struct_field_offset_expression : public Expression\n   do_copy()\n   { return this; }\n \n-  tree\n-  do_get_tree(Translate_context* context);\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -14779,10 +14689,10 @@ class Struct_field_offset_expression : public Expression\n   const Struct_field* field_;\n };\n \n-// Return a struct field offset in GENERIC.\n+// Return the backend representation for a struct field offset.\n \n-tree\n-Struct_field_offset_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Struct_field_offset_expression::do_get_backend(Translate_context* context)\n {\n   const Struct_field_list* fields = this->type_->fields();\n   Struct_field_list::const_iterator p;\n@@ -14804,7 +14714,7 @@ Struct_field_offset_expression::do_get_tree(Translate_context* context)\n   Expression* ret = Expression::make_integer(&offsetval, uptr_type,\n \t\t\t\t\t     Linemap::predeclared_location());\n   mpz_clear(offsetval);\n-  return ret->get_tree(context);\n+  return ret->get_backend(context);\n }\n \n // Dump ast representation for a struct field offset expression.\n@@ -14854,12 +14764,11 @@ class Map_descriptor_expression : public Expression\n   do_copy()\n   { return this; }\n \n-  tree\n-  do_get_tree(Translate_context* context)\n+  Bexpression*\n+  do_get_backend(Translate_context* context)\n   {\n-    Bexpression* ret = this->type_->map_descriptor_pointer(context->gogo(),\n-                                                           this->location());\n-    return expr_to_tree(ret);\n+    return this->type_->map_descriptor_pointer(context->gogo(),\n+\t\t\t\t\t       this->location());\n   }\n \n   void\n@@ -14912,11 +14821,9 @@ class Label_addr_expression : public Expression\n   do_copy()\n   { return new Label_addr_expression(this->label_, this->location()); }\n \n-  tree\n-  do_get_tree(Translate_context* context)\n-  {\n-    return expr_to_tree(this->label_->get_addr(context, this->location()));\n-  }\n+  Bexpression*\n+  do_get_backend(Translate_context* context)\n+  { return this->label_->get_addr(context, this->location()); }\n \n   void\n   do_dump_expression(Ast_dump_context* ast_dump_context) const\n@@ -14963,8 +14870,8 @@ class Conditional_expression : public Expression\n                                       this->else_->copy(), this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context* context);\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -15019,18 +14926,16 @@ Conditional_expression::do_determine_type(const Type_context* context)\n \n // Get the backend representation of a conditional expression.\n \n-tree\n-Conditional_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Conditional_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n   Btype* result_btype = this->type()->get_backend(gogo);\n-  Bexpression* cond = tree_to_expr(this->cond_->get_tree(context));\n-  Bexpression* then = tree_to_expr(this->then_->get_tree(context));\n-  Bexpression* belse = tree_to_expr(this->else_->get_tree(context));\n-  Bexpression* ret =\n-      gogo->backend()->conditional_expression(result_btype, cond, then, belse,\n-                                              this->location());\n-  return expr_to_tree(ret);\n+  Bexpression* cond = this->cond_->get_backend(context);\n+  Bexpression* then = this->then_->get_backend(context);\n+  Bexpression* belse = this->else_->get_backend(context);\n+  return gogo->backend()->conditional_expression(result_btype, cond, then,\n+\t\t\t\t\t\t belse, this->location());\n }\n \n // Dump ast representation of a conditional expression.\n@@ -15083,8 +14988,8 @@ class Compound_expression : public Expression\n                                    this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context* context);\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -15126,16 +15031,15 @@ Compound_expression::do_determine_type(const Type_context* context)\n \n // Get the backend representation of a compound expression.\n \n-tree\n-Compound_expression::do_get_tree(Translate_context* context)\n+Bexpression*\n+Compound_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n-  Bexpression* binit = tree_to_expr(this->init_->get_tree(context));\n+  Bexpression* binit = this->init_->get_backend(context);\n   Bstatement* init_stmt = gogo->backend()->expression_statement(binit);\n-  Bexpression* bexpr = tree_to_expr(this->expr_->get_tree(context));\n-  Bexpression* ret = gogo->backend()->compound_expression(init_stmt, bexpr,\n-                                                          this->location());\n-  return expr_to_tree(ret);\n+  Bexpression* bexpr = this->expr_->get_backend(context);\n+  return gogo->backend()->compound_expression(init_stmt, bexpr,\n+\t\t\t\t\t      this->location());\n }\n \n // Dump ast representation of a conditional expression."}, {"sha": "8337d10e01a658e7ade5603ee855eb8fafe10e9e", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027", "patch": "@@ -747,9 +747,9 @@ class Expression\n     return this->do_must_eval_subexpressions_in_order(skip);\n   }\n \n-  // Return the tree for this expression.\n-  tree\n-  get_tree(Translate_context*);\n+  // Return the backend representation for this expression.\n+  Bexpression*\n+  get_backend(Translate_context*);\n \n   // Return an expression handling any conversions which must be done during\n   // assignment.\n@@ -883,9 +883,9 @@ class Expression\n   do_must_eval_subexpressions_in_order(int* /* skip */) const\n   { return false; }\n \n-  // Child class implements conversion to tree.\n-  virtual tree\n-  do_get_tree(Translate_context*) = 0;\n+  // Child class implements conversion to backend representation.\n+  virtual Bexpression*\n+  do_get_backend(Translate_context*) = 0;\n \n   // Child class implements export.\n   virtual void\n@@ -1068,8 +1068,8 @@ class Parser_expression : public Expression\n   do_check_types(Gogo*)\n   { go_unreachable(); }\n \n-  tree\n-  do_get_tree(Translate_context*)\n+  Bexpression*\n+  do_get_backend(Translate_context*)\n   { go_unreachable(); }\n };\n \n@@ -1109,8 +1109,8 @@ class Var_expression : public Expression\n   void\n   do_address_taken(bool);\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -1161,8 +1161,8 @@ class Temporary_reference_expression : public Expression\n   void\n   do_address_taken(bool);\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -1221,8 +1221,8 @@ class Set_and_use_temporary_expression : public Expression\n   void\n   do_address_taken(bool);\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -1277,8 +1277,8 @@ class String_expression : public Expression\n   do_copy()\n   { return this; }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   // Write string literal to a string dump.\n   static void\n@@ -1410,8 +1410,8 @@ class Unary_expression : public Expression\n   do_is_addressable() const\n   { return this->op_ == OPERATOR_MULT; }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_export(Export*) const;\n@@ -1534,8 +1534,8 @@ class Binary_expression : public Expression\n \t\t\t\t   this->right_->copy(), this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_export(Export*) const;\n@@ -1715,8 +1715,8 @@ class Call_expression : public Expression\n   bool\n   do_must_eval_in_order() const;\n \n-  virtual tree\n-  do_get_tree(Translate_context*);\n+  virtual Bexpression*\n+  do_get_backend(Translate_context*);\n \n   virtual bool\n   do_is_recover_call() const;\n@@ -1834,8 +1834,8 @@ class Func_expression : public Expression\n \t\t\t\t\t   this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -1881,8 +1881,8 @@ class Func_descriptor_expression : public Expression\n   do_is_addressable() const\n   { return true; }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context* context) const;\n@@ -2124,8 +2124,8 @@ class Map_index_expression : public Expression\n \n   // A map index expression is an lvalue but it is not addressable.\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -2210,8 +2210,8 @@ class Bound_method_expression : public Expression\n \t\t\t\t       this->function_, this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -2313,8 +2313,8 @@ class Field_reference_expression : public Expression\n   do_issue_nil_check()\n   { this->expr_->issue_nil_check(); }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -2392,8 +2392,8 @@ class Interface_field_reference_expression : public Expression\n \t\t\t\t\t\t      this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -2458,8 +2458,8 @@ class Type_guard_expression : public Expression\n \t\t\t\t     this->location());\n   }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;\n@@ -2518,8 +2518,8 @@ class Receive_expression : public Expression\n   do_must_eval_in_order() const\n   { return true; }\n \n-  tree\n-  do_get_tree(Translate_context*);\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n \n   void\n   do_dump_expression(Ast_dump_context*) const;"}, {"sha": "085218668f0a90003f7b49b55678bbee47211537", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027", "patch": "@@ -729,7 +729,7 @@ Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n                                                   builtin_loc, 1, root_addr);\n \n   Translate_context context(this, NULL, NULL, NULL);\n-  Bexpression* bcall = tree_to_expr(register_roots->get_tree(&context));\n+  Bexpression* bcall = register_roots->get_backend(&context);\n   init_stmts.push_back(this->backend()->expression_statement(bcall));\n }\n \n@@ -4065,17 +4065,17 @@ Build_method_tables::type(Type* type)\n \t      if ((*p)->implements_interface(Type::make_pointer_type(nt),\n \t\t\t\t\t     NULL))\n \t\t{\n-\t\t  nt->interface_method_table(*p, false)->get_tree(&context);\n-                  nt->interface_method_table(*p, true)->get_tree(&context);\n+\t\t  nt->interface_method_table(*p, false)->get_backend(&context);\n+                  nt->interface_method_table(*p, true)->get_backend(&context);\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      if ((*p)->implements_interface(Type::make_pointer_type(st),\n \t\t\t\t\t     NULL))\n \t\t{\n-\t\t  st->interface_method_table(*p, false)->get_tree(&context);\n-\t\t  st->interface_method_table(*p, true)->get_tree(&context);\n+\t\t  st->interface_method_table(*p, false)->get_backend(&context);\n+\t\t  st->interface_method_table(*p, true)->get_backend(&context);\n \t\t}\n \t    }\n \t}\n@@ -4916,7 +4916,7 @@ Function_declaration::build_backend_descriptor(Gogo* gogo)\n   if (this->descriptor_ != NULL)\n     {\n       Translate_context context(gogo, NULL, NULL, NULL);\n-      this->descriptor_->get_tree(&context);\n+      this->descriptor_->get_backend(&context);\n     }\n }\n \n@@ -4975,7 +4975,7 @@ Function::build(Gogo* gogo, Named_object* named_function)\n \t      parm_ref = Expression::make_unary(OPERATOR_MULT, parm_ref, loc);\n \t      if ((*p)->var_value()->is_in_heap())\n \t\tparm_ref = Expression::make_heap_expression(parm_ref, loc);\n-              var_inits.push_back(tree_to_expr(parm_ref->get_tree(&context)));\n+              var_inits.push_back(parm_ref->get_backend(&context));\n \t    }\n \t  else if ((*p)->var_value()->is_in_heap())\n \t    {\n@@ -4992,7 +4992,7 @@ Function::build(Gogo* gogo, Named_object* named_function)\n \t      Expression* var_ref =\n \t\t  Expression::make_var_reference(parm_no, loc);\n \t      var_ref = Expression::make_heap_expression(var_ref, loc);\n-              var_inits.push_back(tree_to_expr(var_ref->get_tree(&context)));\n+              var_inits.push_back(var_ref->get_backend(&context));\n \t    }\n           param_vars.push_back(parm_bvar);\n \t}\n@@ -5008,10 +5008,8 @@ Function::build(Gogo* gogo, Named_object* named_function)\n \t      init = gogo->backend()->zero_expression(btype);\n \t    }\n \t  else\n-            {\n-              Expression* alloc = Expression::make_allocation(type, loc);\n-              init = tree_to_expr(alloc->get_tree(&context));\n-            }\n+\t    init = Expression::make_allocation(type,\n+\t\t\t\t\t       loc)->get_backend(&context);\n \n           vars.push_back(bvar);\n           var_inits.push_back(init);\n@@ -5034,7 +5032,7 @@ Function::build(Gogo* gogo, Named_object* named_function)\n \n       Expression* closure =\n           Runtime::make_call(Runtime::GET_CLOSURE, this->location_, 0);\n-      var_inits.push_back(tree_to_expr(closure->get_tree(&context)));\n+      var_inits.push_back(closure->get_backend(&context));\n     }\n \n   if (this->block_ != NULL)\n@@ -5115,7 +5113,7 @@ Function::build(Gogo* gogo, Named_object* named_function)\n   if (this->descriptor_ != NULL)\n     {\n       Translate_context context(gogo, NULL, NULL, NULL);\n-      this->descriptor_->get_tree(&context);\n+      this->descriptor_->get_backend(&context);\n     }\n }\n \n@@ -5138,7 +5136,7 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n   Expression* call = Runtime::make_call(Runtime::CHECK_DEFER, end_loc, 1,\n \t\t\t\t\tthis->defer_stack(end_loc));\n   Translate_context context(gogo, named_function, NULL, NULL);\n-  Bexpression* defer = tree_to_expr(call->get_tree(&context));\n+  Bexpression* defer = call->get_backend(&context);\n   stmts.push_back(gogo->backend()->expression_statement(defer));\n \n   Bstatement* ret_bstmt = this->return_value(gogo, named_function, end_loc);\n@@ -5150,11 +5148,11 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n \n   call = Runtime::make_call(Runtime::CHECK_DEFER, end_loc, 1,\n                             this->defer_stack(end_loc));\n-  defer = tree_to_expr(call->get_tree(&context));\n+  defer = call->get_backend(&context);\n \n   call = Runtime::make_call(Runtime::UNDEFER, end_loc, 1,\n         \t\t    this->defer_stack(end_loc));\n-  Bexpression* undefer = tree_to_expr(call->get_tree(&context));\n+  Bexpression* undefer = call->get_backend(&context);\n   Bstatement* function_defer =\n       gogo->backend()->function_defer_statement(this->fndecl_, undefer, defer,\n                                                 end_loc);\n@@ -5170,13 +5168,12 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n       // variable to true if we are returning from this function.\n \n       ret_bstmt = this->return_value(gogo, named_function, end_loc);\n-      Bexpression* nil =\n-          tree_to_expr(Expression::make_nil(end_loc)->get_tree(&context));\n+      Bexpression* nil = Expression::make_nil(end_loc)->get_backend(&context);\n       Bexpression* ret =\n           gogo->backend()->compound_expression(ret_bstmt, nil, end_loc);\n       Expression* ref =\n \tExpression::make_temporary_reference(this->defer_stack_, end_loc);\n-      Bexpression* bref = tree_to_expr(ref->get_tree(&context));\n+      Bexpression* bref = ref->get_backend(&context);\n       ret = gogo->backend()->conditional_expression(NULL, bref, ret, NULL,\n                                                     end_loc);\n       stmts.push_back(gogo->backend()->expression_statement(ret));\n@@ -5982,7 +5979,7 @@ Variable::get_init(Gogo* gogo, Named_object* function)\n     {\n       Translate_context context(gogo, function, NULL, NULL);\n       Expression* init = Expression::make_cast(this->type(), this->init_, loc);\n-      return tree_to_expr(init->get_tree(&context));\n+      return init->get_backend(&context);\n     }\n }\n \n@@ -6008,16 +6005,15 @@ Variable::get_init_block(Gogo* gogo, Named_object* function,\n     {\n       if (var_decl == NULL)\n         {\n-          Bexpression* init_bexpr =\n-              tree_to_expr(this->init_->get_tree(&context));\n+          Bexpression* init_bexpr = this->init_->get_backend(&context);\n           decl_init = gogo->backend()->expression_statement(init_bexpr);\n         }\n       else\n \t{\n           Location loc = this->location();\n           Expression* val_expr =\n               Expression::make_cast(this->type(), this->init_, loc);\n-          Bexpression* val = tree_to_expr(val_expr->get_tree(&context));\n+          Bexpression* val = val_expr->get_backend(&context);\n           Bexpression* var_ref = gogo->backend()->var_expression(var_decl, loc);\n           decl_init = gogo->backend()->assignment_statement(var_ref, val, loc);\n \t}\n@@ -6241,8 +6237,7 @@ Named_constant::get_backend(Gogo* gogo, Named_object* const_no)\n       Location loc = this->location();\n \n       Expression* const_ref = Expression::make_const_reference(const_no, loc);\n-      Bexpression* const_decl =\n-\ttree_to_expr(const_ref->get_tree(&subcontext));\n+      Bexpression* const_decl = const_ref->get_backend(&subcontext);\n       if (type != NULL && type->is_numeric_type())\n \t{\n \t  Btype* btype = type->get_backend(gogo);"}, {"sha": "b2076d71b7c5c3a4f749ea8be4d1f05fb2a1ae6e", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027", "patch": "@@ -1096,7 +1096,7 @@ class Function\n   Bstatement*\n   return_value(Gogo*, Named_object*, Location) const;\n \n-  // Get a tree for the variable holding the defer stack.\n+  // Get an expression for the variable holding the defer stack.\n   Expression*\n   defer_stack(Location);\n "}, {"sha": "a4a44e76dadec28c853546776bce4b6c571cfd2f", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027", "patch": "@@ -291,12 +291,12 @@ Variable_declaration_statement::do_get_backend(Translate_context* context)\n     {\n       Expression* e = Expression::make_temporary_reference(temp, loc);\n       e = Expression::make_unary(OPERATOR_MULT, e, loc);\n-      Bexpression* be = tree_to_expr(e->get_tree(context));\n+      Bexpression* be = e->get_backend(context);\n       set = context->backend()->assignment_statement(be, binit, loc);\n     }\n \n   Expression* ref = Expression::make_temporary_reference(temp, loc);\n-  Bexpression* bref = tree_to_expr(ref->get_tree(context));\n+  Bexpression* bref = ref->get_backend(context);\n   Bstatement* sinit = context->backend()->init_statement(bvar, bref);\n \n   std::vector<Bstatement*> stats;\n@@ -443,13 +443,13 @@ Temporary_statement::do_get_backend(Translate_context* context)\n   if (this->init_ == NULL)\n     binit = NULL;\n   else if (this->type_ == NULL)\n-    binit = tree_to_expr(this->init_->get_tree(context));\n+    binit = this->init_->get_backend(context);\n   else\n     {\n       Expression* init = Expression::make_cast(this->type_, this->init_,\n \t\t\t\t\t       this->location());\n       context->gogo()->lower_expression(context->function(), NULL, &init);\n-      binit = tree_to_expr(init->get_tree(context));\n+      binit = init->get_backend(context);\n     }\n \n   Bstatement* statement;\n@@ -633,18 +633,16 @@ Assignment_statement::do_get_backend(Translate_context* context)\n {\n   if (this->lhs_->is_sink_expression())\n     {\n-      tree rhs_tree = this->rhs_->get_tree(context);\n-      return context->backend()->expression_statement(tree_to_expr(rhs_tree));\n+      Bexpression* rhs = this->rhs_->get_backend(context);\n+      return context->backend()->expression_statement(rhs);\n     }\n \n-  tree lhs_tree = this->lhs_->get_tree(context);\n-  Expression* rhs =\n+  Bexpression* lhs = this->lhs_->get_backend(context);\n+  Expression* conv =\n       Expression::convert_for_assignment(context->gogo(), this->lhs_->type(),\n                                          this->rhs_, this->location());\n-  tree rhs_tree = rhs->get_tree(context);\n-  return context->backend()->assignment_statement(tree_to_expr(lhs_tree),\n-\t\t\t\t\t\t  tree_to_expr(rhs_tree),\n-\t\t\t\t\t\t  this->location());\n+  Bexpression* rhs = conv->get_backend(context);\n+  return context->backend()->assignment_statement(lhs, rhs, this->location());\n }\n \n // Dump the AST representation for an assignment statement.\n@@ -1748,8 +1746,8 @@ Expression_statement::do_may_fall_through() const\n Bstatement*\n Expression_statement::do_get_backend(Translate_context* context)\n {\n-  tree expr_tree = this->expr_->get_tree(context);\n-  return context->backend()->expression_statement(tree_to_expr(expr_tree));\n+  Bexpression* bexpr = this->expr_->get_backend(context);\n+  return context->backend()->expression_statement(bexpr);\n }\n \n // Dump the AST representation for an expression statement\n@@ -2537,9 +2535,8 @@ Go_statement::do_get_backend(Translate_context* context)\n \n   Expression* call = Runtime::make_call(Runtime::GO, this->location(), 2,\n \t\t\t\t\tfn, arg);\n-  tree call_tree = call->get_tree(context);\n-  Bexpression* call_bexpr = tree_to_expr(call_tree);\n-  return context->backend()->expression_statement(call_bexpr);\n+  Bexpression* bcall = call->get_backend(context);\n+  return context->backend()->expression_statement(bcall);\n }\n \n // Dump the AST representation for go statement.\n@@ -2576,9 +2573,8 @@ Defer_statement::do_get_backend(Translate_context* context)\n \n   Expression* call = Runtime::make_call(Runtime::DEFER, loc, 3,\n \t\t\t\t\tds, fn, arg);\n-  tree call_tree = call->get_tree(context);\n-  Bexpression* call_bexpr = tree_to_expr(call_tree);\n-  return context->backend()->expression_statement(call_bexpr);\n+  Bexpression* bcall = call->get_backend(context);\n+  return context->backend()->expression_statement(bcall);\n }\n \n // Dump the AST representation for defer statement.\n@@ -2785,7 +2781,7 @@ Return_statement::do_get_backend(Translate_context* context)\n \t   p++)\n \t{\n \t  Expression* vr = Expression::make_var_reference(*p, loc);\n-\t  retvals.push_back(tree_to_expr(vr->get_tree(context)));\n+\t  retvals.push_back(vr->get_backend(context));\n \t}\n     }\n \n@@ -3201,14 +3197,13 @@ If_statement::do_get_backend(Translate_context* context)\n {\n   go_assert(this->cond_->type()->is_boolean_type()\n \t     || this->cond_->type()->is_error());\n-  tree cond_tree = this->cond_->get_tree(context);\n-  Bexpression* cond_expr = tree_to_expr(cond_tree);\n+  Bexpression* cond = this->cond_->get_backend(context);\n   Bblock* then_block = this->then_block_->get_backend(context);\n   Bblock* else_block = (this->else_block_ == NULL\n \t\t\t? NULL\n \t\t\t: this->else_block_->get_backend(context));\n-  return context->backend()->if_statement(cond_expr, then_block,\n-\t\t\t\t\t  else_block, this->location());\n+  return context->backend()->if_statement(cond, then_block, else_block,\n+\t\t\t\t\t  this->location());\n }\n \n // Dump the AST representation for an if statement\n@@ -3485,10 +3480,7 @@ Case_clauses::Case_clause::get_backend(Translate_context* context,\n \t      error_at(this->location_, \"duplicate case in switch\");\n \t      e = Expression::make_error(this->location_);\n \t    }\n-\n-\t  tree case_tree = e->get_tree(context);\n-\t  Bexpression* case_expr = tree_to_expr(case_tree);\n-\t  cases->push_back(case_expr);\n+\t  cases->push_back(e->get_backend(context));\n \t}\n     }\n \n@@ -3783,8 +3775,7 @@ Constant_switch_statement::do_check_types(Gogo*)\n Bstatement*\n Constant_switch_statement::do_get_backend(Translate_context* context)\n {\n-  tree switch_val_tree = this->val_->get_tree(context);\n-  Bexpression* switch_val_expr = tree_to_expr(switch_val_tree);\n+  Bexpression* switch_val_expr = this->val_->get_backend(context);\n \n   Unnamed_label* break_label = this->break_label_;\n   if (break_label == NULL)\n@@ -4519,7 +4510,7 @@ Send_statement::do_get_backend(Translate_context* context)\n   Expression* call = Runtime::make_call(code, loc, 3, td, this->channel_, val);\n \n   context->gogo()->lower_expression(context->function(), NULL, &call);\n-  Bexpression* bcall = tree_to_expr(call->get_tree(context));\n+  Bexpression* bcall = call->get_backend(context);\n   Bstatement* s = context->backend()->expression_statement(bcall);\n \n   if (btemp == NULL)\n@@ -4948,7 +4939,7 @@ Select_clauses::get_backend(Translate_context* context,\n       Expression* index_expr = Expression::make_integer(&ival, int32_type,\n \t\t\t\t\t\t\tlocation);\n       mpz_clear(ival);\n-      cases[i].push_back(tree_to_expr(index_expr->get_tree(context)));\n+      cases[i].push_back(index_expr->get_backend(context));\n \n       Bstatement* s = p->get_statements_backend(context);\n       Location gloc = (p->statements() == NULL\n@@ -4966,7 +4957,7 @@ Select_clauses::get_backend(Translate_context* context,\n   Expression* call = Runtime::make_call(Runtime::SELECTGO, location, 1,\n \t\t\t\t\tselref);\n   context->gogo()->lower_expression(context->function(), NULL, &call);\n-  Bexpression* bcall = tree_to_expr(call->get_tree(context));\n+  Bexpression* bcall = call->get_backend(context);\n \n   if (count == 0)\n     return context->backend()->expression_statement(bcall);"}, {"sha": "c36979f3d6f4ac80440f1f2206553ddc8000c94b", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027", "patch": "@@ -6,12 +6,6 @@\n \n #include \"go-system.h\"\n \n-#include \"toplev.h\"\n-#include \"intl.h\"\n-#include \"tree.h\"\n-#include \"real.h\"\n-#include \"convert.h\"\n-\n #include \"go-c.h\"\n #include \"gogo.h\"\n #include \"operator.h\"\n@@ -897,7 +891,7 @@ Type::hash_string(const std::string& s, unsigned int h)\n \n Type::Type_btypes Type::type_btypes;\n \n-// Return a tree representing this type.\n+// Return the backend representation for this type.\n \n Btype*\n Type::get_backend(Gogo* gogo)\n@@ -952,7 +946,7 @@ Type::get_backend(Gogo* gogo)\n       // We have already created a backend representation for this\n       // type.  This can happen when an unnamed type is defined using\n       // a named type which in turns uses an identical unnamed type.\n-      // Use the tree we created earlier and ignore the one we just\n+      // Use the representation we created earlier and ignore the one we just\n       // built.\n       if (this->btype_ == bt)\n \tthis->btype_ = ins.first->second.btype;\n@@ -1301,7 +1295,7 @@ Type::make_type_descriptor_var(Gogo* gogo)\n \n   Translate_context context(gogo, NULL, NULL, NULL);\n   context.set_is_const();\n-  Bexpression* binitializer = tree_to_expr(initializer->get_tree(&context));\n+  Bexpression* binitializer = initializer->get_backend(&context);\n \n   gogo->backend()->immutable_struct_set_init(this->type_descriptor_var_,\n \t\t\t\t\t     var_name, false, is_common,\n@@ -4936,7 +4930,7 @@ get_backend_struct_fields(Gogo* gogo, const Struct_field_list* fields,\n   go_assert(i == fields->size());\n }\n \n-// Get the tree for a struct type.\n+// Get the backend representation for a struct type.\n \n Btype*\n Struct_type::do_get_backend(Gogo* gogo)\n@@ -5877,9 +5871,9 @@ get_backend_slice_fields(Gogo* gogo, Array_type* type, bool use_placeholder,\n   p->location = ploc;\n }\n \n-// Get a tree for the type of this array.  A fixed array is simply\n-// represented as ARRAY_TYPE with the appropriate index--i.e., it is\n-// just like an array in C.  A slice is a struct with three\n+// Get the backend representation for the type of this array.  A fixed array is\n+// simply represented as ARRAY_TYPE with the appropriate index--i.e., it is\n+// just like an array in C.  An open array is a struct with three\n // fields: a data pointer, the length, and the capacity.\n \n Btype*\n@@ -5943,7 +5937,7 @@ Array_type::get_backend_length(Gogo* gogo)\n \t  // Make up a translation context for the array length\n \t  // expression.  FIXME: This won't work in general.\n \t  Translate_context context(gogo, NULL, NULL, NULL);\n-\t  this->blength_ = tree_to_expr(this->length_->get_tree(&context));\n+\t  this->blength_ = this->length_->get_backend(&context);\n \n \t  Btype* ibtype = Type::lookup_integer_type(\"int\")->get_backend(gogo);\n \t  this->blength_ =\n@@ -6466,7 +6460,7 @@ Map_type::map_descriptor(Gogo* gogo)\n \n   Translate_context context(gogo, NULL, NULL, NULL);\n   context.set_is_const();\n-  Bexpression* binitializer = tree_to_expr(initializer->get_tree(&context));\n+  Bexpression* binitializer = initializer->get_backend(&context);\n \n   gogo->backend()->immutable_struct_set_init(bvar, mangled_name, false, true,\n \t\t\t\t\t     map_descriptor_btype, bloc,\n@@ -6581,8 +6575,8 @@ Channel_type::is_identical(const Channel_type* t,\n \t  && this->may_receive_ == t->may_receive_);\n }\n \n-// Return the tree for a channel type.  A channel is a pointer to a\n-// __go_channel struct.  The __go_channel struct is defined in\n+// Return the backend representation for a channel type.  A channel is a pointer\n+// to a __go_channel struct.  The __go_channel struct is defined in\n // libgo/runtime/channel.h.\n \n Btype*\n@@ -7364,8 +7358,8 @@ get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n   (*bfields)[1].location = Linemap::predeclared_location();\n }\n \n-// Return a tree for an interface type.  An interface is a pointer to\n-// a struct.  The struct has three fields.  The first field is a\n+// Return the backend representation for an interface type.  An interface is a\n+// pointer to a struct.  The struct has three fields.  The first field is a\n // pointer to the type descriptor for the dynamic type of the object.\n // The second field is a pointer to a table of methods for the\n // interface to be used with the object.  The third field is the value\n@@ -8416,7 +8410,7 @@ Named_type::convert(Gogo* gogo)\n   this->verify();\n \n   // Convert all the dependencies.  If they refer indirectly back to\n-  // this type, they will pick up the intermediate tree we just\n+  // this type, they will pick up the intermediate representation we just\n   // created.\n   for (std::vector<Named_type*>::const_iterator p = this->dependencies_.begin();\n        p != this->dependencies_.end();\n@@ -8612,7 +8606,7 @@ Named_type::create_placeholder(Gogo* gogo)\n     }\n }\n \n-// Get a tree for a named type.\n+// Get the backend representation for a named type.\n \n Btype*\n Named_type::do_get_backend(Gogo* gogo)\n@@ -8648,7 +8642,7 @@ Named_type::do_get_backend(Gogo* gogo)\n \n   go_assert(bt != NULL);\n \n-  // Complete the tree.\n+  // Complete the backend representation.\n   Type* base = this->type_->base();\n   Btype* bt1;\n   switch (base->classification())"}, {"sha": "09e215578f8e2f38f3a5654235bfbc4c060df22c", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027", "patch": "@@ -1168,9 +1168,6 @@ class Type\n   method_constructor(Gogo*, Type* method_type, const std::string& name,\n \t\t     const Method*, bool only_value_methods) const;\n \n-  static tree\n-  build_receive_return_type(tree type);\n-\n   // Add all methods for TYPE to the list of methods for THIS.\n   static void\n   add_methods_for_type(const Type* type, const Method::Field_indexes*,\n@@ -2755,9 +2752,9 @@ class Interface_type : public Type\n };\n \n // The value we keep for a named type.  This lets us get the right\n-// name when we convert to trees.  Note that we don't actually keep\n+// name when we convert to backend.  Note that we don't actually keep\n // the name here; the name is in the Named_object which points to\n-// this.  This object exists to hold a unique tree which represents\n+// this.  This object exists to hold a unique backend representation for\n // the type.\n \n class Named_type : public Type"}]}