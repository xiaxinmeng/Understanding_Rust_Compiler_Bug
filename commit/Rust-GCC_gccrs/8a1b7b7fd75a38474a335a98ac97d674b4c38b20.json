{"sha": "8a1b7b7fd75a38474a335a98ac97d674b4c38b20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGExYjdiN2ZkNzVhMzg0NzRhMzM1YTk4YWM5N2Q2NzRiNGMzOGIyMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-07-08T20:23:40Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-07-08T20:23:40Z"}, "message": "P0145: Refining Expression Order for C++ (assignment)\n\n\t* gimplify.c (initial_rhs_predicate_for): New.\n\t(gimplfy_modify_expr): Gimplify RHS before LHS.\n\nCo-Authored-By: Richard Biener <rguenther@suse.de>\n\nFrom-SVN: r238175", "tree": {"sha": "57053fa5b939d159bb3af3ae4a24979748e4b2f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57053fa5b939d159bb3af3ae4a24979748e4b2f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a1b7b7fd75a38474a335a98ac97d674b4c38b20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a1b7b7fd75a38474a335a98ac97d674b4c38b20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a1b7b7fd75a38474a335a98ac97d674b4c38b20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a1b7b7fd75a38474a335a98ac97d674b4c38b20/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "642bcbdf1d63f4c20070bfa7f15998f5b833a527", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/642bcbdf1d63f4c20070bfa7f15998f5b833a527", "html_url": "https://github.com/Rust-GCC/gccrs/commit/642bcbdf1d63f4c20070bfa7f15998f5b833a527"}], "stats": {"total": 44, "additions": 38, "deletions": 6}, "files": [{"sha": "105d110a55f26f782ce4c74626c319bd568a0aba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a1b7b7fd75a38474a335a98ac97d674b4c38b20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a1b7b7fd75a38474a335a98ac97d674b4c38b20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a1b7b7fd75a38474a335a98ac97d674b4c38b20", "patch": "@@ -1,3 +1,10 @@\n+2016-06-25  Jason Merrill  <jason@redhat.com>\n+\t    Richard Biener  <rguenther@suse.de>\n+\n+\tP0145: Refining Expression Order for C++.\n+\t* gimplify.c (initial_rhs_predicate_for): New.\n+\t(gimplfy_modify_expr): Gimplify RHS before LHS.\n+\n 2016-07-08  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \tPR target/71297"}, {"sha": "393bcc12208b2b81e334e68a1e20b9217ce0cc28", "filename": "gcc/gimplify.c", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a1b7b7fd75a38474a335a98ac97d674b4c38b20/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a1b7b7fd75a38474a335a98ac97d674b4c38b20/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=8a1b7b7fd75a38474a335a98ac97d674b4c38b20", "patch": "@@ -3813,6 +3813,18 @@ rhs_predicate_for (tree lhs)\n     return is_gimple_mem_rhs_or_call;\n }\n \n+/* Return the initial guess for an appropriate RHS predicate for this LHS,\n+   before the LHS has been gimplified.  */\n+\n+static gimple_predicate\n+initial_rhs_predicate_for (tree lhs)\n+{\n+  if (is_gimple_reg_type (TREE_TYPE (lhs)))\n+    return is_gimple_reg_rhs_or_call;\n+  else\n+    return is_gimple_mem_rhs_or_call;\n+}\n+\n /* Gimplify a C99 compound literal expression.  This just means adding\n    the DECL_EXPR before the current statement and using its anonymous\n    decl instead.  */\n@@ -4778,10 +4790,6 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n      that is what we must do here.  */\n   maybe_with_size_expr (from_p);\n \n-  ret = gimplify_expr (to_p, pre_p, post_p, is_gimple_lvalue, fb_lvalue);\n-  if (ret == GS_ERROR)\n-    return ret;\n-\n   /* As a special case, we have to temporarily allow for assignments\n      with a CALL_EXPR on the RHS.  Since in GIMPLE a function call is\n      a toplevel statement, when gimplifying the GENERIC expression\n@@ -4794,11 +4802,28 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n      reaches the CALL_EXPR.  On return from gimplify_expr, the newly\n      created GIMPLE_CALL <foo> will be the last statement in *PRE_P\n      and all we need to do here is set 'a' to be its LHS.  */\n-  ret = gimplify_expr (from_p, pre_p, post_p, rhs_predicate_for (*to_p),\n-\t\t       fb_rvalue);\n+\n+  /* Gimplify the RHS first for C++17 and bug 71104.  */\n+  gimple_predicate initial_pred = initial_rhs_predicate_for (*to_p);\n+  ret = gimplify_expr (from_p, pre_p, post_p, initial_pred, fb_rvalue);\n+  if (ret == GS_ERROR)\n+    return ret;\n+\n+  /* Then gimplify the LHS.  */\n+  ret = gimplify_expr (to_p, pre_p, post_p, is_gimple_lvalue, fb_lvalue);\n   if (ret == GS_ERROR)\n     return ret;\n \n+  /* Now that the LHS is gimplified, re-gimplify the RHS if our initial\n+     guess for the predicate was wrong.  */\n+  gimple_predicate final_pred = rhs_predicate_for (*to_p);\n+  if (final_pred != initial_pred)\n+    {\n+      ret = gimplify_expr (from_p, pre_p, post_p, final_pred, fb_rvalue);\n+      if (ret == GS_ERROR)\n+\treturn ret;\n+    }\n+\n   /* In case of va_arg internal fn wrappped in a WITH_SIZE_EXPR, add the type\n      size as argument to the call.  */\n   if (TREE_CODE (*from_p) == WITH_SIZE_EXPR)"}]}