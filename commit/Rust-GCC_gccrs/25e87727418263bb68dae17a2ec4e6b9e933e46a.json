{"sha": "25e87727418263bb68dae17a2ec4e6b9e933e46a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVlODc3Mjc0MTgyNjNiYjY4ZGFlMTdhMmVjNGU2YjllOTMzZTQ2YQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2008-06-26T20:06:49Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2008-06-26T20:06:49Z"}, "message": "cfganal.c: Include vec.h and vecprim.h.\n\n\t* cfganal.c: Include vec.h and vecprim.h.\n\t(compute_idf): Import from...\n\t* tree-into-ssa (compute_idf): ...here.\n\t* basic-block.h (compute_idf): Export.\n\nFrom-SVN: r137158", "tree": {"sha": "b0ecfc44a05f007acec41cfa8851bdad92d5b499", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0ecfc44a05f007acec41cfa8851bdad92d5b499"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25e87727418263bb68dae17a2ec4e6b9e933e46a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e87727418263bb68dae17a2ec4e6b9e933e46a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25e87727418263bb68dae17a2ec4e6b9e933e46a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e87727418263bb68dae17a2ec4e6b9e933e46a/comments", "author": null, "committer": null, "parents": [{"sha": "ddb649244037750743d9edef131f07e21795b045", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddb649244037750743d9edef131f07e21795b045", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddb649244037750743d9edef131f07e21795b045"}], "stats": {"total": 131, "additions": 71, "deletions": 60}, "files": [{"sha": "e175dddb7ef02b48529a647a06cd06e915a0da1f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e87727418263bb68dae17a2ec4e6b9e933e46a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e87727418263bb68dae17a2ec4e6b9e933e46a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25e87727418263bb68dae17a2ec4e6b9e933e46a", "patch": "@@ -1,3 +1,10 @@\n+2008-06-26  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* cfganal.c: Include vec.h and vecprim.h.\n+\t(compute_idf): Import from...\n+\t* tree-into-ssa (compute_idf): ...here.\n+\t* basic-block.h (compute_idf): Export.\n+\n 2008-06-26  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-decl.c (merge_decls): Use !current_function_decl to check for"}, {"sha": "4aa864d66cffec2b5540c0a69fd92a6163e9c4e0", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e87727418263bb68dae17a2ec4e6b9e933e46a/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e87727418263bb68dae17a2ec4e6b9e933e46a/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=25e87727418263bb68dae17a2ec4e6b9e933e46a", "patch": "@@ -529,6 +529,7 @@ extern int dfs_enumerate_from (basic_block, int,\n \t\t\t       bool (*)(const_basic_block, const void *),\n \t\t\t       basic_block *, int, const void *);\n extern void compute_dominance_frontiers (bitmap *);\n+extern bitmap compute_idf (bitmap, bitmap *);\n extern void dump_bb_info (basic_block, bool, bool, int, const char *, FILE *);\n extern void dump_edge_info (FILE *, edge, int);\n extern void brief_dump_cfg (FILE *);"}, {"sha": "663fbdcb6e42c29b11d15beeb978d5e214b2bdec", "filename": "gcc/cfganal.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e87727418263bb68dae17a2ec4e6b9e933e46a/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e87727418263bb68dae17a2ec4e6b9e933e46a/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=25e87727418263bb68dae17a2ec4e6b9e933e46a", "patch": "@@ -31,6 +31,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"recog.h\"\n #include \"toplev.h\"\n #include \"tm_p.h\"\n+#include \"vec.h\"\n+#include \"vecprim.h\"\n #include \"timevar.h\"\n \n /* Store the data structures necessary for depth-first search.  */\n@@ -1292,3 +1294,64 @@ compute_dominance_frontiers (bitmap *frontiers)\n \n   timevar_pop (TV_DOM_FRONTIERS);\n }\n+\n+/* Given a set of blocks with variable definitions (DEF_BLOCKS),\n+   return a bitmap with all the blocks in the iterated dominance\n+   frontier of the blocks in DEF_BLOCKS.  DFS contains dominance\n+   frontier information as returned by compute_dominance_frontiers.\n+\n+   The resulting set of blocks are the potential sites where PHI nodes\n+   are needed.  The caller is responsible for freeing the memory\n+   allocated for the return value.  */\n+\n+bitmap\n+compute_idf (bitmap def_blocks, bitmap *dfs)\n+{\n+  bitmap_iterator bi;\n+  unsigned bb_index, i;\n+  VEC(int,heap) *work_stack;\n+  bitmap phi_insertion_points;\n+\n+  work_stack = VEC_alloc (int, heap, n_basic_blocks);\n+  phi_insertion_points = BITMAP_ALLOC (NULL);\n+\n+  /* Seed the work list with all the blocks in DEF_BLOCKS.  We use\n+     VEC_quick_push here for speed.  This is safe because we know that\n+     the number of definition blocks is no greater than the number of\n+     basic blocks, which is the initial capacity of WORK_STACK.  */\n+  EXECUTE_IF_SET_IN_BITMAP (def_blocks, 0, bb_index, bi)\n+    VEC_quick_push (int, work_stack, bb_index);\n+\n+  /* Pop a block off the worklist, add every block that appears in\n+     the original block's DF that we have not already processed to\n+     the worklist.  Iterate until the worklist is empty.   Blocks\n+     which are added to the worklist are potential sites for\n+     PHI nodes.  */\n+  while (VEC_length (int, work_stack) > 0)\n+    {\n+      bb_index = VEC_pop (int, work_stack);\n+\n+      /* Since the registration of NEW -> OLD name mappings is done\n+\t separately from the call to update_ssa, when updating the SSA\n+\t form, the basic blocks where new and/or old names are defined\n+\t may have disappeared by CFG cleanup calls.  In this case,\n+\t we may pull a non-existing block from the work stack.  */\n+      gcc_assert (bb_index < (unsigned) last_basic_block);\n+\n+      EXECUTE_IF_AND_COMPL_IN_BITMAP (dfs[bb_index], phi_insertion_points,\n+\t                              0, i, bi)\n+\t{\n+\t  /* Use a safe push because if there is a definition of VAR\n+\t     in every basic block, then WORK_STACK may eventually have\n+\t     more than N_BASIC_BLOCK entries.  */\n+\t  VEC_safe_push (int, heap, work_stack, i);\n+\t  bitmap_set_bit (phi_insertion_points, i);\n+\t}\n+    }\n+\n+  VEC_free (int, heap, work_stack);\n+\n+  return phi_insertion_points;\n+}\n+\n+"}, {"sha": "0eb2ded11b912e635972605b175813dee0a2ba47", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e87727418263bb68dae17a2ec4e6b9e933e46a/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e87727418263bb68dae17a2ec4e6b9e933e46a/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=25e87727418263bb68dae17a2ec4e6b9e933e46a", "patch": "@@ -985,66 +985,6 @@ prune_unused_phi_nodes (bitmap phis, bitmap kills, bitmap uses)\n   free (defs);\n }\n \n-/* Given a set of blocks with variable definitions (DEF_BLOCKS),\n-   return a bitmap with all the blocks in the iterated dominance\n-   frontier of the blocks in DEF_BLOCKS.  DFS contains dominance\n-   frontier information as returned by compute_dominance_frontiers.\n-\n-   The resulting set of blocks are the potential sites where PHI nodes\n-   are needed.  The caller is responsible for freeing the memory\n-   allocated for the return value.  */\n-\n-static bitmap\n-compute_idf (bitmap def_blocks, bitmap *dfs)\n-{\n-  bitmap_iterator bi;\n-  unsigned bb_index, i;\n-  VEC(int,heap) *work_stack;\n-  bitmap phi_insertion_points;\n-\n-  work_stack = VEC_alloc (int, heap, n_basic_blocks);\n-  phi_insertion_points = BITMAP_ALLOC (NULL);\n-\n-  /* Seed the work list with all the blocks in DEF_BLOCKS.  We use\n-     VEC_quick_push here for speed.  This is safe because we know that\n-     the number of definition blocks is no greater than the number of\n-     basic blocks, which is the initial capacity of WORK_STACK.  */\n-  EXECUTE_IF_SET_IN_BITMAP (def_blocks, 0, bb_index, bi)\n-    VEC_quick_push (int, work_stack, bb_index);\n-\n-  /* Pop a block off the worklist, add every block that appears in\n-     the original block's DF that we have not already processed to\n-     the worklist.  Iterate until the worklist is empty.   Blocks\n-     which are added to the worklist are potential sites for\n-     PHI nodes.  */\n-  while (VEC_length (int, work_stack) > 0)\n-    {\n-      bb_index = VEC_pop (int, work_stack);\n-\n-      /* Since the registration of NEW -> OLD name mappings is done\n-\t separately from the call to update_ssa, when updating the SSA\n-\t form, the basic blocks where new and/or old names are defined\n-\t may have disappeared by CFG cleanup calls.  In this case,\n-\t we may pull a non-existing block from the work stack.  */\n-      gcc_assert (bb_index < (unsigned) last_basic_block);\n-\n-      EXECUTE_IF_AND_COMPL_IN_BITMAP (dfs[bb_index], phi_insertion_points,\n-\t                              0, i, bi)\n-\t{\n-\t  /* Use a safe push because if there is a definition of VAR\n-\t     in every basic block, then WORK_STACK may eventually have\n-\t     more than N_BASIC_BLOCK entries.  */\n-\t  VEC_safe_push (int, heap, work_stack, i);\n-\t  bitmap_set_bit (phi_insertion_points, i);\n-\t}\n-    }\n-\n-  VEC_free (int, heap, work_stack);\n-\n-  return phi_insertion_points;\n-}\n-\n-\n /* Return the set of blocks where variable VAR is defined and the blocks\n    where VAR is live on entry (livein).  Return NULL, if no entry is\n    found in DEF_BLOCKS.  */"}]}