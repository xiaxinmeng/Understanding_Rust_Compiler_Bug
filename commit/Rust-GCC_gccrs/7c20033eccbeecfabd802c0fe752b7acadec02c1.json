{"sha": "7c20033eccbeecfabd802c0fe752b7acadec02c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2MyMDAzM2VjY2JlZWNmYWJkODAyYzBmZTc1MmI3YWNhZGVjMDJjMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-09-08T19:40:00Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-09-08T19:40:00Z"}, "message": "decl.c (gnat_to_gnu_entity): Tidy flow of control.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Subtype>: Tidy\n\tflow of control.\n\tAvoid useless work when processing the Treat_As_Volatile flag.\n\nFrom-SVN: r151535", "tree": {"sha": "a277cbde9a2b11a8e253fc58593148c63db4b40a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a277cbde9a2b11a8e253fc58593148c63db4b40a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c20033eccbeecfabd802c0fe752b7acadec02c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c20033eccbeecfabd802c0fe752b7acadec02c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c20033eccbeecfabd802c0fe752b7acadec02c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c20033eccbeecfabd802c0fe752b7acadec02c1/comments", "author": null, "committer": null, "parents": [{"sha": "d5df7223bf191d99fe03df0e9e0f6652622563a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5df7223bf191d99fe03df0e9e0f6652622563a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5df7223bf191d99fe03df0e9e0f6652622563a4"}], "stats": {"total": 195, "additions": 100, "deletions": 95}, "files": [{"sha": "9ebc3d22edfb61609323cea511d007bec04bd904", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c20033eccbeecfabd802c0fe752b7acadec02c1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c20033eccbeecfabd802c0fe752b7acadec02c1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7c20033eccbeecfabd802c0fe752b7acadec02c1", "patch": "@@ -1,3 +1,9 @@\n+2009-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Subtype>: Tidy\n+\tflow of control.\n+\tAvoid useless work when processing the Treat_As_Volatile flag.\n+\n 2009-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/targtyps.c: Reorder include directives."}, {"sha": "255821e49c8845681116e884085d5d395dad1f1a", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 94, "deletions": 95, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c20033eccbeecfabd802c0fe752b7acadec02c1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c20033eccbeecfabd802c0fe752b7acadec02c1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=7c20033eccbeecfabd802c0fe752b7acadec02c1", "patch": "@@ -2093,7 +2093,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n       /* This is the actual data type for array variables.  Multidimensional\n \t arrays are implemented as arrays of arrays.  Note that arrays which\n- \t have sparse enumeration subtypes as index components create sparse\n+\t have sparse enumeration subtypes as index components create sparse\n \t arrays, which is obviously space inefficient but so much easier to\n \t code for now.\n \n@@ -2105,7 +2105,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n       gnu_type = gnat_to_gnu_type (Etype (gnat_entity));\n       if (!Is_Constrained (gnat_entity))\n-\tbreak;\n+\t;\n       else\n \t{\n \t  Entity_Id gnat_index, gnat_base_index;\n@@ -2538,105 +2538,104 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  /* Set our alias set to that of our base type.  This gives all\n \t     array subtypes the same alias set.  */\n \t  relate_alias_sets (gnu_type, gnu_base_type, ALIAS_SET_COPY);\n-\t}\n-\n-      /* If this is a packed type, make this type the same as the packed\n-\t array type, but do some adjusting in the type first.  */\n-      if (Present (Packed_Array_Type (gnat_entity)))\n-\t{\n-\t  Entity_Id gnat_index;\n-\t  tree gnu_inner_type;\n \n-\t  /* First finish the type we had been making so that we output\n-\t     debugging information for it.  */\n-\t  gnu_type\n-\t    = build_qualified_type (gnu_type,\n-\t\t\t\t    (TYPE_QUALS (gnu_type)\n-\t\t\t\t     | (TYPE_QUAL_VOLATILE\n-\t\t\t\t\t* Treat_As_Volatile (gnat_entity))));\n-\n-\t  /* Make it artificial only if the base type was artificial as well.\n-\t     That's sort of \"morally\" true and will make it possible for the\n-\t     debugger to look it up by name in DWARF, which is necessary in\n-\t     order to decode the packed array type.  */\n-\t  gnu_decl\n-\t    = create_type_decl (gnu_entity_name, gnu_type, attr_list,\n-\t\t\t\t!Comes_From_Source (gnat_entity)\n-\t\t\t\t&& !Comes_From_Source (Etype (gnat_entity)),\n-\t\t\t\tdebug_info_p, gnat_entity);\n-\n-\t  /* Save it as our equivalent in case the call below elaborates\n-\t     this type again.  */\n-\t  save_gnu_tree (gnat_entity, gnu_decl, false);\n-\n-\t  gnu_decl = gnat_to_gnu_entity (Packed_Array_Type (gnat_entity),\n-\t\t\t\t\t NULL_TREE, 0);\n-\t  this_made_decl = true;\n-\t  gnu_type = TREE_TYPE (gnu_decl);\n-\t  save_gnu_tree (gnat_entity, NULL_TREE, false);\n-\n-\t  gnu_inner_type = gnu_type;\n-\t  while (TREE_CODE (gnu_inner_type) == RECORD_TYPE\n-\t\t && (TYPE_JUSTIFIED_MODULAR_P (gnu_inner_type)\n-\t\t     || TYPE_IS_PADDING_P (gnu_inner_type)))\n-\t    gnu_inner_type = TREE_TYPE (TYPE_FIELDS (gnu_inner_type));\n-\n-\t  /* We need to attach the index type to the type we just made so\n-\t     that the actual bounds can later be put into a template.  */\n-\t  if ((TREE_CODE (gnu_inner_type) == ARRAY_TYPE\n-\t       && !TYPE_ACTUAL_BOUNDS (gnu_inner_type))\n-\t      || (TREE_CODE (gnu_inner_type) == INTEGER_TYPE\n-\t\t  && !TYPE_HAS_ACTUAL_BOUNDS_P (gnu_inner_type)))\n+\t  /* If this is a packed type, make this type the same as the packed\n+\t     array type, but do some adjusting in the type first.  */\n+\t  if (Present (Packed_Array_Type (gnat_entity)))\n \t    {\n-\t      if (TREE_CODE (gnu_inner_type) == INTEGER_TYPE)\n+\t      Entity_Id gnat_index;\n+\t      tree gnu_inner;\n+\n+\t      /* First finish the type we had been making so that we output\n+\t\t debugging information for it.  */\n+\t      if (Treat_As_Volatile (gnat_entity))\n+\t\tgnu_type\n+\t\t  = build_qualified_type (gnu_type,\n+\t\t\t\t\t  TYPE_QUALS (gnu_type)\n+\t\t\t\t\t  | TYPE_QUAL_VOLATILE);\n+\n+\t      /* Make it artificial only if the base type was artificial too.\n+\t\t That's sort of \"morally\" true and will make it possible for\n+\t\t the debugger to look it up by name in DWARF, which is needed\n+\t\t in order to decode the packed array type.  */\n+\t      gnu_decl\n+\t\t= create_type_decl (gnu_entity_name, gnu_type, attr_list,\n+\t\t\t\t    !Comes_From_Source (Etype (gnat_entity))\n+\t\t\t\t    && !Comes_From_Source (gnat_entity),\n+\t\t\t\t    debug_info_p, gnat_entity);\n+\n+\t      /* Save it as our equivalent in case the call below elaborates\n+\t\t this type again.  */\n+\t      save_gnu_tree (gnat_entity, gnu_decl, false);\n+\n+\t      gnu_decl = gnat_to_gnu_entity (Packed_Array_Type (gnat_entity),\n+\t\t\t\t\t     NULL_TREE, 0);\n+\t      this_made_decl = true;\n+\t      gnu_type = TREE_TYPE (gnu_decl);\n+\t      save_gnu_tree (gnat_entity, NULL_TREE, false);\n+\n+\t      gnu_inner = gnu_type;\n+\t      while (TREE_CODE (gnu_inner) == RECORD_TYPE\n+\t\t     && (TYPE_JUSTIFIED_MODULAR_P (gnu_inner)\n+\t\t\t || TYPE_IS_PADDING_P (gnu_inner)))\n+\t\tgnu_inner = TREE_TYPE (TYPE_FIELDS (gnu_inner));\n+\n+\t      /* We need to attach the index type to the type we just made so\n+\t\t that the actual bounds can later be put into a template.  */\n+\t      if ((TREE_CODE (gnu_inner) == ARRAY_TYPE\n+\t\t   && !TYPE_ACTUAL_BOUNDS (gnu_inner))\n+\t\t  || (TREE_CODE (gnu_inner) == INTEGER_TYPE\n+\t\t      && !TYPE_HAS_ACTUAL_BOUNDS_P (gnu_inner)))\n \t\t{\n-\t\t  /* The TYPE_ACTUAL_BOUNDS field is overloaded with the\n-\t\t     TYPE_MODULUS for modular types so we make an extra\n-\t\t     subtype if necessary.  */\n-\t\t  if (TYPE_MODULAR_P (gnu_inner_type))\n+\t\t  if (TREE_CODE (gnu_inner) == INTEGER_TYPE)\n \t\t    {\n-\t\t      tree gnu_subtype\n-\t\t\t= make_unsigned_type (TYPE_PRECISION (gnu_inner_type));\n-\t\t      TREE_TYPE (gnu_subtype) = gnu_inner_type;\n-\t\t      TYPE_EXTRA_SUBTYPE_P (gnu_subtype) = 1;\n-\t\t      SET_TYPE_RM_MIN_VALUE (gnu_subtype,\n-\t\t\t\t\t     TYPE_MIN_VALUE (gnu_inner_type));\n-\t\t      SET_TYPE_RM_MAX_VALUE (gnu_subtype,\n-\t\t\t\t\t     TYPE_MAX_VALUE (gnu_inner_type));\n-\t\t      gnu_inner_type = gnu_subtype;\n-\t\t    }\n-\n-\t\t  TYPE_HAS_ACTUAL_BOUNDS_P (gnu_inner_type) = 1;\n+\t\t      /* The TYPE_ACTUAL_BOUNDS field is overloaded with the\n+\t\t\t TYPE_MODULUS for modular types so we make an extra\n+\t\t\t subtype if necessary.  */\n+\t\t      if (TYPE_MODULAR_P (gnu_inner))\n+\t\t\t{\n+\t\t\t  tree gnu_subtype\n+\t\t\t    = make_unsigned_type (TYPE_PRECISION (gnu_inner));\n+\t\t\t  TREE_TYPE (gnu_subtype) = gnu_inner;\n+\t\t\t  TYPE_EXTRA_SUBTYPE_P (gnu_subtype) = 1;\n+\t\t\t  SET_TYPE_RM_MIN_VALUE (gnu_subtype,\n+\t\t\t\t\t\t TYPE_MIN_VALUE (gnu_inner));\n+\t\t\t  SET_TYPE_RM_MAX_VALUE (gnu_subtype,\n+\t\t\t\t\t\t TYPE_MAX_VALUE (gnu_inner));\n+\t\t\t  gnu_inner = gnu_subtype;\n+\t\t\t}\n+\n+\t\t      TYPE_HAS_ACTUAL_BOUNDS_P (gnu_inner) = 1;\n \n #ifdef ENABLE_CHECKING\n-\t\t  /* Check for other cases of overloading.  */\n-\t\t  gcc_assert (!TYPE_ACTUAL_BOUNDS (gnu_inner_type));\n+\t\t      /* Check for other cases of overloading.  */\n+\t\t      gcc_assert (!TYPE_ACTUAL_BOUNDS (gnu_inner));\n #endif\n-\t\t}\n+\t\t    }\n \n-\t      for (gnat_index = First_Index (gnat_entity);\n-\t\t   Present (gnat_index); gnat_index = Next_Index (gnat_index))\n-\t\tSET_TYPE_ACTUAL_BOUNDS\n-\t\t  (gnu_inner_type,\n-\t\t   tree_cons (NULL_TREE,\n-\t\t\t      get_unpadded_type (Etype (gnat_index)),\n-\t\t\t      TYPE_ACTUAL_BOUNDS (gnu_inner_type)));\n-\n-\t      if (Convention (gnat_entity) != Convention_Fortran)\n-\t\tSET_TYPE_ACTUAL_BOUNDS\n-\t\t  (gnu_inner_type,\n-\t\t   nreverse (TYPE_ACTUAL_BOUNDS (gnu_inner_type)));\n-\n-\t      if (TREE_CODE (gnu_type) == RECORD_TYPE\n-\t\t  && TYPE_JUSTIFIED_MODULAR_P (gnu_type))\n-\t\tTREE_TYPE (TYPE_FIELDS (gnu_type)) = gnu_inner_type;\n+\t\t  for (gnat_index = First_Index (gnat_entity);\n+\t\t       Present (gnat_index);\n+\t\t       gnat_index = Next_Index (gnat_index))\n+\t\t    SET_TYPE_ACTUAL_BOUNDS\n+\t\t      (gnu_inner,\n+\t\t       tree_cons (NULL_TREE,\n+\t\t\t\t  get_unpadded_type (Etype (gnat_index)),\n+\t\t\t\t  TYPE_ACTUAL_BOUNDS (gnu_inner)));\n+\n+\t\t  if (Convention (gnat_entity) != Convention_Fortran)\n+\t\t    SET_TYPE_ACTUAL_BOUNDS\n+\t\t      (gnu_inner, nreverse (TYPE_ACTUAL_BOUNDS (gnu_inner)));\n+\n+\t\t  if (TREE_CODE (gnu_type) == RECORD_TYPE\n+\t\t      && TYPE_JUSTIFIED_MODULAR_P (gnu_type))\n+\t\t    TREE_TYPE (TYPE_FIELDS (gnu_type)) = gnu_inner;\n+\t\t}\n \t    }\n-\t}\n-\n-      /* Abort if packed array with no packed array type field set.  */\n-      else\n-\tgcc_assert (!Is_Packed (gnat_entity));\n \n+\t  else\n+\t    /* Abort if packed array with no Packed_Array_Type field set.  */\n+\t    gcc_assert (!Is_Packed (gnat_entity));\n+\t}\n       break;\n \n     case E_String_Literal_Subtype:\n@@ -4634,10 +4633,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t}\n \t    }\n \n-      gnu_type = build_qualified_type (gnu_type,\n-\t\t\t\t       (TYPE_QUALS (gnu_type)\n-\t\t\t\t\t| (TYPE_QUAL_VOLATILE\n-\t\t\t\t\t   * Treat_As_Volatile (gnat_entity))));\n+      if (Treat_As_Volatile (gnat_entity))\n+\tgnu_type\n+\t  = build_qualified_type (gnu_type,\n+\t\t\t\t  TYPE_QUALS (gnu_type) | TYPE_QUAL_VOLATILE);\n \n       if (Is_Atomic (gnat_entity))\n \tcheck_ok_for_atomic (gnu_type, gnat_entity, false);"}]}