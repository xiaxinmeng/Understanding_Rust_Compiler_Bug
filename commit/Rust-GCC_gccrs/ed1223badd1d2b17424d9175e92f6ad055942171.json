{"sha": "ed1223badd1d2b17424d9175e92f6ad055942171", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQxMjIzYmFkZDFkMmIxNzQyNGQ5MTc1ZTkyZjZhZDA1NTk0MjE3MQ==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@apple.com", "date": "2007-06-01T00:08:26Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2007-06-01T00:08:26Z"}, "message": "expr.c (convert_move): Assert that we don't have a BLKmode operand.\n\n2007-05-31  Eric Christopher  <echristo@apple.com>\n\n\t* expr.c (convert_move): Assert that we don't have a BLKmode\n\toperand.\n\t(store_expr): Handle BLKmode moves by calling emit_block_move.\n\nFrom-SVN: r125246", "tree": {"sha": "8a7778f78b6478b913f11b234a51c342ef41b0c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a7778f78b6478b913f11b234a51c342ef41b0c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed1223badd1d2b17424d9175e92f6ad055942171", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed1223badd1d2b17424d9175e92f6ad055942171", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed1223badd1d2b17424d9175e92f6ad055942171", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed1223badd1d2b17424d9175e92f6ad055942171/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e133ace8d907bf42754c86106fc3f04a9d9fe70f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e133ace8d907bf42754c86106fc3f04a9d9fe70f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e133ace8d907bf42754c86106fc3f04a9d9fe70f"}], "stats": {"total": 159, "additions": 86, "deletions": 73}, "files": [{"sha": "e622c34817b3eaae63af4bf6c6cb0e06f198e7ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed1223badd1d2b17424d9175e92f6ad055942171/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed1223badd1d2b17424d9175e92f6ad055942171/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed1223badd1d2b17424d9175e92f6ad055942171", "patch": "@@ -1,3 +1,9 @@\n+2007-05-31  Eric Christopher  <echristo@apple.com>\n+\n+\t* expr.c (convert_move): Assert that we don't have a BLKmode\n+\toperand.\n+\t(store_expr): Handle BLKmode moves by calling emit_block_move.\n+\n 2007-05-31  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* c-typeck.c (build_indirect_ref): Include type in error message."}, {"sha": "3033ec8369f72e65f99bb9f7f7a6179ddff9b1d8", "filename": "gcc/expr.c", "status": "modified", "additions": 80, "deletions": 73, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed1223badd1d2b17424d9175e92f6ad055942171/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed1223badd1d2b17424d9175e92f6ad055942171/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ed1223badd1d2b17424d9175e92f6ad055942171", "patch": "@@ -359,6 +359,8 @@ convert_move (rtx to, rtx from, int unsignedp)\n \n \n   gcc_assert (to_real == from_real);\n+  gcc_assert (to_mode != BLKmode);\n+  gcc_assert (from_mode != BLKmode);\n \n   /* If the source and destination are already the same, then there's\n      nothing to do.  */\n@@ -413,7 +415,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n \t\t   != GET_MODE_PRECISION (to_mode))\n \t\t  || (DECIMAL_FLOAT_MODE_P (from_mode)\n \t\t      != DECIMAL_FLOAT_MODE_P (to_mode)));\n-      \n+\n       if (GET_MODE_PRECISION (from_mode) == GET_MODE_PRECISION (to_mode))\n \t/* Conversion between decimal float and binary float, same size.  */\n \ttab = DECIMAL_FLOAT_MODE_P (from_mode) ? trunc_optab : sext_optab;\n@@ -2144,7 +2146,7 @@ void\n use_reg (rtx *call_fusage, rtx reg)\n {\n   gcc_assert (REG_P (reg) && REGNO (reg) < FIRST_PSEUDO_REGISTER);\n-  \n+\n   *call_fusage\n     = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t gen_rtx_USE (VOIDmode, reg), *call_fusage);\n@@ -2701,7 +2703,7 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n \t  pred = insn_data[(int) code].operand[1].predicate;\n \t  if (pred != 0 && ! (*pred) (opsize, mode))\n \t    opsize = copy_to_mode_reg (mode, opsize);\n-\t  \n+\n \t  opchar = val;\n \t  char_mode = insn_data[(int) code].operand[2].mode;\n \t  if (char_mode != VOIDmode)\n@@ -3179,9 +3181,9 @@ emit_move_multi_word (enum machine_mode mode, rtx x, rtx y)\n   rtx seq, inner;\n   bool need_clobber;\n   int i;\n-      \n+\n   gcc_assert (GET_MODE_SIZE (mode) >= UNITS_PER_WORD);\n-      \n+\n   /* If X is a push on the stack, do the push now and replace\n      X with a reference to the stack pointer.  */\n   if (push_operand (x, mode))\n@@ -4504,6 +4506,11 @@ store_expr (tree exp, rtx target, int call_param_p)\n \t      temp = convert_to_mode (GET_MODE (target), temp, unsignedp);\n \t      emit_move_insn (target, temp);\n \t    }\n+\t  else if (GET_MODE (target) == BLKmode)\n+\t    emit_block_move (target, temp, expr_size (exp),\n+\t\t\t     (call_param_p\n+\t\t\t      ? BLOCK_OP_CALL_PARM\n+\t\t\t      : BLOCK_OP_NORMAL));\n \t  else\n \t    convert_move (target, temp, unsignedp);\n \t}\n@@ -4635,7 +4642,7 @@ categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n \tcase CONSTRUCTOR:\n \t  {\n \t    HOST_WIDE_INT nz = 0, ic = 0;\n-\t    \n+\n \t    bool const_elt_p\n \t      = categorize_ctor_elements_1 (value, &nz, &ic, p_must_clear);\n \n@@ -4712,7 +4719,7 @@ categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n \t     largest element.  Which would avoid comparing the size of the\n \t     initialized element against any tail padding in the union.\n \t     Doesn't seem worth the effort...  */\n-\t  if (simple_cst_equal (TYPE_SIZE (TREE_TYPE (ctor)), \n+\t  if (simple_cst_equal (TYPE_SIZE (TREE_TYPE (ctor)),\n \t\t\t\tTYPE_SIZE (init_sub_type)) == 1)\n \t    {\n \t      /* And now we have to find out if the element itself is fully\n@@ -5015,24 +5022,24 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t    HOST_WIDE_INT bitpos = 0;\n \t    tree offset;\n \t    rtx to_rtx = target;\n-\t    \n+\n \t    /* Just ignore missing fields.  We cleared the whole\n \t       structure, above, if any fields are missing.  */\n \t    if (field == 0)\n \t      continue;\n-\t    \n+\n \t    if (cleared && initializer_zerop (value))\n \t      continue;\n-\t    \n+\n \t    if (host_integerp (DECL_SIZE (field), 1))\n \t      bitsize = tree_low_cst (DECL_SIZE (field), 1);\n \t    else\n \t      bitsize = -1;\n-\t    \n+\n \t    mode = DECL_MODE (field);\n \t    if (DECL_BIT_FIELD (field))\n \t      mode = VOIDmode;\n-\t    \n+\n \t    offset = DECL_FIELD_OFFSET (field);\n \t    if (host_integerp (offset, 0)\n \t\t&& host_integerp (bit_position (field), 0))\n@@ -5042,19 +5049,19 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t      }\n \t    else\n \t      bitpos = tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 0);\n-\t    \n+\n \t    if (offset)\n \t      {\n \t\trtx offset_rtx;\n-\t\t\n+\n \t\toffset\n \t\t  = SUBSTITUTE_PLACEHOLDER_IN_EXPR (offset,\n \t\t\t\t\t\t    make_tree (TREE_TYPE (exp),\n \t\t\t\t\t\t\t       target));\n \n \t\toffset_rtx = expand_normal (offset);\n \t\tgcc_assert (MEM_P (to_rtx));\n-\t\t\n+\n #ifdef POINTERS_EXTEND_UNSIGNED\n \t\tif (GET_MODE (offset_rtx) != Pmode)\n \t\t  offset_rtx = convert_to_mode (Pmode, offset_rtx, 0);\n@@ -5082,14 +5089,14 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t&& bitpos + BITS_PER_WORD <= exp_size * BITS_PER_UNIT)\n \t      {\n \t\ttree type = TREE_TYPE (value);\n-\t\t\n+\n \t\tif (TYPE_PRECISION (type) < BITS_PER_WORD)\n \t\t  {\n \t\t    type = lang_hooks.types.type_for_size\n \t\t      (BITS_PER_WORD, TYPE_UNSIGNED (type));\n \t\t    value = fold_convert (type, value);\n \t\t  }\n-\t\t\n+\n \t\tif (BYTES_BIG_ENDIAN)\n \t\t  value\n \t\t   = fold_build2 (LSHIFT_EXPR, type, value,\n@@ -5106,7 +5113,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\tto_rtx = copy_rtx (to_rtx);\n \t\tMEM_KEEP_ALIAS_SET_P (to_rtx) = 1;\n \t      }\n-\t    \n+\n \t    store_constructor_field (to_rtx, bitsize, bitpos, mode,\n \t\t\t\t     value, type, cleared,\n \t\t\t\t     get_alias_set (TREE_TYPE (field)));\n@@ -5150,7 +5157,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t    tree index, value;\n \t    HOST_WIDE_INT count = 0, zero_count = 0;\n \t    need_to_clear = ! const_bounds_p;\n-\t    \n+\n \t    /* This loop is a more accurate version of the loop in\n \t       mostly_zeros_p (it handles RANGE_EXPR in an index).  It\n \t       is also needed to check for missing elements.  */\n@@ -5160,30 +5167,30 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \n \t\tif (need_to_clear)\n \t\t  break;\n-\t\t\n+\n \t\tif (index != NULL_TREE && TREE_CODE (index) == RANGE_EXPR)\n \t\t  {\n \t\t    tree lo_index = TREE_OPERAND (index, 0);\n \t\t    tree hi_index = TREE_OPERAND (index, 1);\n-\t\t    \n+\n \t\t    if (! host_integerp (lo_index, 1)\n \t\t\t|| ! host_integerp (hi_index, 1))\n \t\t      {\n \t\t\tneed_to_clear = 1;\n \t\t\tbreak;\n \t\t      }\n-\t\t    \n+\n \t\t    this_node_count = (tree_low_cst (hi_index, 1)\n \t\t\t\t       - tree_low_cst (lo_index, 1) + 1);\n \t\t  }\n \t\telse\n \t\t  this_node_count = 1;\n-\t\t\n+\n \t\tcount += this_node_count;\n \t\tif (mostly_zeros_p (value))\n \t\t  zero_count += this_node_count;\n \t      }\n-\t    \n+\n \t    /* Clear the entire array first if there are any missing\n \t       elements, or if the incidence of zero elements is >=\n \t       75%.  */\n@@ -5192,7 +5199,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t    || 4 * zero_count >= 3 * count))\n \t      need_to_clear = 1;\n \t  }\n-\t\n+\n \tif (need_to_clear && size > 0)\n \t  {\n \t    if (REG_P (target))\n@@ -5216,10 +5223,10 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t    HOST_WIDE_INT bitpos;\n \t    int unsignedp;\n \t    rtx xtarget = target;\n-\t    \n+\n \t    if (cleared && initializer_zerop (value))\n \t      continue;\n-\t    \n+\n \t    unsignedp = TYPE_UNSIGNED (elttype);\n \t    mode = TYPE_MODE (elttype);\n \t    if (mode == BLKmode)\n@@ -5228,15 +5235,15 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t\t : -1);\n \t    else\n \t      bitsize = GET_MODE_BITSIZE (mode);\n-\t    \n+\n \t    if (index != NULL_TREE && TREE_CODE (index) == RANGE_EXPR)\n \t      {\n \t\ttree lo_index = TREE_OPERAND (index, 0);\n \t\ttree hi_index = TREE_OPERAND (index, 1);\n \t\trtx index_r, pos_rtx;\n \t\tHOST_WIDE_INT lo, hi, count;\n \t\ttree position;\n-\t\t\n+\n \t\t/* If the range is constant and \"small\", unroll the loop.  */\n \t\tif (const_bounds_p\n \t\t    && host_integerp (lo_index, 0)\n@@ -5254,7 +5261,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t    for (; lo <= hi; lo++)\n \t\t      {\n \t\t\tbitpos = lo * tree_low_cst (TYPE_SIZE (elttype), 0);\n-\t\t\t\n+\n \t\t\tif (MEM_P (target)\n \t\t\t    && !MEM_KEEP_ALIAS_SET_P (target)\n \t\t\t    && TREE_CODE (type) == ARRAY_TYPE\n@@ -5263,7 +5270,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t\t    target = copy_rtx (target);\n \t\t\t    MEM_KEEP_ALIAS_SET_P (target) = 1;\n \t\t\t  }\n-\t\t\t\n+\n \t\t\tstore_constructor_field\n \t\t\t  (target, bitsize, bitpos, mode, value, type, cleared,\n \t\t\t   get_alias_set (elttype));\n@@ -5274,18 +5281,18 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t    rtx loop_start = gen_label_rtx ();\n \t\t    rtx loop_end = gen_label_rtx ();\n \t\t    tree exit_cond;\n-\t\t    \n+\n \t\t    expand_normal (hi_index);\n \t\t    unsignedp = TYPE_UNSIGNED (domain);\n-\t\t    \n+\n \t\t    index = build_decl (VAR_DECL, NULL_TREE, domain);\n-\t\t    \n+\n \t\t    index_r\n \t\t      = gen_reg_rtx (promote_mode (domain, DECL_MODE (index),\n \t\t\t\t\t\t   &unsignedp, 0));\n \t\t    SET_DECL_RTL (index, index_r);\n \t\t    store_expr (lo_index, index_r, 0);\n-\t\t    \n+\n \t\t    /* Build the head of the loop.  */\n \t\t    do_pending_stack_adjust ();\n \t\t    emit_label (loop_start);\n@@ -5302,7 +5309,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t\tsize_binop (MULT_EXPR, position,\n \t\t\t\t    fold_convert (ssizetype,\n \t\t\t\t\t\t  TYPE_SIZE_UNIT (elttype)));\n-\t\t    \n+\n \t\t    pos_rtx = expand_normal (position);\n \t\t    xtarget = offset_address (target, pos_rtx,\n \t\t\t\t\t      highest_pow2_factor (position));\n@@ -5317,15 +5324,15 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t    exit_cond = build2 (LT_EXPR, integer_type_node,\n \t\t\t\t\tindex, hi_index);\n \t\t    jumpif (exit_cond, loop_end);\n-\t\t    \n+\n \t\t    /* Update the loop counter, and jump to the head of\n \t\t       the loop.  */\n \t\t    expand_assignment (index,\n \t\t\t\t       build2 (PLUS_EXPR, TREE_TYPE (index),\n \t\t\t\t\t       index, integer_one_node));\n-\t\t    \n+\n \t\t    emit_jump (loop_start);\n-\t\t    \n+\n \t\t    /* Build the end of the loop.  */\n \t\t    emit_label (loop_end);\n \t\t  }\n@@ -5334,17 +5341,17 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t     || ! host_integerp (TYPE_SIZE (elttype), 1))\n \t      {\n \t\ttree position;\n-\t\t\n+\n \t\tif (index == 0)\n \t\t  index = ssize_int (1);\n-\t\t\n+\n \t\tif (minelt)\n \t\t  index = fold_convert (ssizetype,\n \t\t\t\t\tfold_build2 (MINUS_EXPR,\n \t\t\t\t\t\t     TREE_TYPE (index),\n \t\t\t\t\t\t     index,\n \t\t\t\t\t\t     TYPE_MIN_VALUE (domain)));\n-\t\t\n+\n \t\tposition =\n \t\t  size_binop (MULT_EXPR, index,\n \t\t\t      fold_convert (ssizetype,\n@@ -5362,7 +5369,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t\t    * tree_low_cst (TYPE_SIZE (elttype), 1));\n \t\telse\n \t\t  bitpos = (i * tree_low_cst (TYPE_SIZE (elttype), 1));\n-\t\t\n+\n \t\tif (MEM_P (target) && !MEM_KEEP_ALIAS_SET_P (target)\n \t\t    && TREE_CODE (type) == ARRAY_TYPE\n \t\t    && TYPE_NONALIASED_COMPONENT (type))\n@@ -5391,25 +5398,25 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \tHOST_WIDE_INT bitpos;\n \trtvec vector = NULL;\n \tunsigned n_elts;\n-\t\n+\n \tgcc_assert (eltmode != BLKmode);\n-\t\n+\n \tn_elts = TYPE_VECTOR_SUBPARTS (type);\n \tif (REG_P (target) && VECTOR_MODE_P (GET_MODE (target)))\n \t  {\n \t    enum machine_mode mode = GET_MODE (target);\n-\t    \n+\n \t    icode = (int) vec_init_optab->handlers[mode].insn_code;\n \t    if (icode != CODE_FOR_nothing)\n \t      {\n \t\tunsigned int i;\n-\t\t\n+\n \t\tvector = rtvec_alloc (n_elts);\n \t\tfor (i = 0; i < n_elts; i++)\n \t\t  RTVEC_ELT (vector, i) = CONST0_RTX (GET_MODE_INNER (mode));\n \t      }\n \t  }\n-\t\n+\n \t/* If the constructor has fewer elements than the vector,\n \t   clear the whole array first.  Similarly if this is static\n \t   constructor of a non-BLKmode object.  */\n@@ -5421,14 +5428,14 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t  {\n \t    unsigned HOST_WIDE_INT count = 0, zero_count = 0;\n \t    tree value;\n-\t    \n+\n \t    FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), idx, value)\n \t      {\n \t\tint n_elts_here = tree_low_cst\n \t\t  (int_const_binop (TRUNC_DIV_EXPR,\n \t\t\t\t    TYPE_SIZE (TREE_TYPE (value)),\n \t\t\t\t    TYPE_SIZE (elttype), 0), 1);\n-\t\t\n+\n \t\tcount += n_elts_here;\n \t\tif (mostly_zeros_p (value))\n \t\t  zero_count += n_elts_here;\n@@ -5438,7 +5445,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t       or if the incidence of zero elements is >= 75%.  */\n \t    need_to_clear = (count < n_elts || 4 * zero_count >= 3 * count);\n \t  }\n-\t\n+\n \tif (need_to_clear && size > 0 && !vector)\n \t  {\n \t    if (REG_P (target))\n@@ -5447,7 +5454,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t      clear_storage (target, GEN_INT (size), BLOCK_OP_NORMAL);\n \t    cleared = 1;\n \t  }\n-\t\n+\n \t/* Inform later passes that the old value is dead.  */\n \tif (!cleared && !vector && REG_P (target))\n \t  emit_move_insn (target, CONST0_RTX (GET_MODE (target)));\n@@ -5460,16 +5467,16 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t  {\n \t    HOST_WIDE_INT eltpos;\n \t    tree value = ce->value;\n-\t    \n+\n \t    bitsize = tree_low_cst (TYPE_SIZE (TREE_TYPE (value)), 1);\n \t    if (cleared && initializer_zerop (value))\n \t      continue;\n-\t    \n+\n \t    if (ce->index)\n \t      eltpos = tree_low_cst (ce->index, 1);\n \t    else\n \t      eltpos = i;\n-\t    \n+\n \t    if (vector)\n \t      {\n \t        /* Vector CONSTRUCTORs should only be built from smaller\n@@ -5490,14 +5497,14 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t\t\t\t cleared, get_alias_set (elttype));\n \t      }\n \t  }\n-\t\n+\n \tif (vector)\n \t  emit_insn (GEN_FCN (icode)\n \t\t     (target,\n \t\t      gen_rtx_PARALLEL (GET_MODE (target), vector)));\n \tbreak;\n       }\n-      \n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -5734,7 +5741,7 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n     {\n       size_tree = TREE_OPERAND (exp, 1);\n       *punsignedp = BIT_FIELD_REF_UNSIGNED (exp);\n-      \n+\n       /* For vector types, with the correct size of access, use the mode of\n \t inner type.  */\n       if (TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == VECTOR_TYPE\n@@ -7038,7 +7045,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  && GET_MODE (decl_rtl) != DECL_MODE (exp))\n \t{\n \t  enum machine_mode pmode;\n-\t  \n+\n \t  /* Get the signedness used for this variable.  Ensure we get the\n \t     same mode we got when the variable was declared.  */\n \t  pmode = promote_mode (type, DECL_MODE (exp), &unsignedp,\n@@ -7409,19 +7416,19 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t    tree index1 = index;\n \t\t    tree low_bound = array_ref_low_bound (exp);\n \t\t    index1 = fold_convert (sizetype, TREE_OPERAND (exp, 1));\n-\t\t    \n+\n \t\t    /* Optimize the special-case of a zero lower bound.\n-\t\t    \n+\n \t\t       We convert the low_bound to sizetype to avoid some problems\n \t\t       with constant folding.  (E.g. suppose the lower bound is 1,\n \t\t       and its mode is QI.  Without the conversion,l (ARRAY\n \t\t       +(INDEX-(unsigned char)1)) becomes ((ARRAY+(-(unsigned char)1))\n \t\t       +INDEX), which becomes (ARRAY+255+INDEX).  Opps!)  */\n-\t\t    \n+\n \t\t    if (! integer_zerop (low_bound))\n \t\t      index1 = size_diffop (index1, fold_convert (sizetype,\n \t\t\t\t\t\t\t\t  low_bound));\n-\t\t  \n+\n \t\t    if (0 > compare_tree_int (index1,\n \t\t\t\t\t      TREE_STRING_LENGTH (init)))\n \t\t      {\n@@ -7833,7 +7840,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  else\n \t    {\n \t      gcc_assert (REG_P (target));\n-\t      \n+\n \t      /* Store this field into a union of the proper type.  */\n \t      store_field (target,\n \t\t\t   MIN ((int_size_in_bytes (TREE_TYPE\n@@ -7919,9 +7926,9 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t other.  */\n       else if (SCALAR_INT_MODE_P (GET_MODE (op0))\n \t       && SCALAR_INT_MODE_P (TYPE_MODE (type)))\n-\top0 = convert_modes (TYPE_MODE (type), GET_MODE (op0), op0, \n+\top0 = convert_modes (TYPE_MODE (type), GET_MODE (op0), op0,\n \t\t\t     TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n-      /* As a last resort, spill op0 to memory, and reload it in a \n+      /* As a last resort, spill op0 to memory, and reload it in a\n \t different mode.  */\n       else if (!MEM_P (op0))\n \t{\n@@ -8914,15 +8921,15 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n     case REALIGN_LOAD_EXPR:\n       {\n-        tree oprnd0 = TREE_OPERAND (exp, 0); \n+        tree oprnd0 = TREE_OPERAND (exp, 0);\n         tree oprnd1 = TREE_OPERAND (exp, 1);\n         tree oprnd2 = TREE_OPERAND (exp, 2);\n         rtx op2;\n \n         this_optab = optab_for_tree_code (code, type);\n         expand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n         op2 = expand_normal (oprnd2);\n-        temp = expand_ternary_op (mode, this_optab, op0, op1, op2, \n+        temp = expand_ternary_op (mode, this_optab, op0, op1, op2,\n \t\t\t\t  target, unsignedp);\n         gcc_assert (temp);\n         return temp;\n@@ -8937,7 +8944,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \texpand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n \top2 = expand_normal (oprnd2);\n-\ttarget = expand_widen_pattern_expr (exp, op0, op1, op2, \n+\ttarget = expand_widen_pattern_expr (exp, op0, op1, op2,\n \t\t\t\t\t    target, unsignedp);\n \treturn target;\n       }\n@@ -8946,7 +8953,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       {\n         tree oprnd0 = TREE_OPERAND (exp, 0);\n         tree oprnd1 = TREE_OPERAND (exp, 1);\n-                                                                               \n+\n         expand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, 0);\n         target = expand_widen_pattern_expr (exp, op0, NULL_RTX, op1,\n                                             target, unsignedp);\n@@ -9184,7 +9191,7 @@ string_constant (tree arg, tree *ptr_offset)\n \t      if (TREE_CODE (offset) != INTEGER_CST)\n \t\treturn 0;\n \t      /* Adjust offset by the lower bound.  */\n-\t      offset = size_diffop (fold_convert (sizetype, offset), \n+\t      offset = size_diffop (fold_convert (sizetype, offset),\n \t\t\t\t    fold_convert (sizetype, lower_bound));\n \t    }\n \t}\n@@ -9439,7 +9446,7 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode, int only_cheap)\n   if (icode == CODE_FOR_nothing)\n     {\n       enum machine_mode wmode;\n-      \n+\n       for (wmode = operand_mode;\n \t   icode == CODE_FOR_nothing && wmode != VOIDmode;\n \t   wmode = GET_MODE_WIDER_MODE (wmode))\n@@ -9494,7 +9501,7 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode, int only_cheap)\n   label = gen_label_rtx ();\n   do_compare_rtx_and_jump (op0, op1, code, unsignedp, operand_mode, NULL_RTX,\n \t\t\t   NULL_RTX, label);\n-  \n+\n   emit_move_insn (target, invert ? const1_rtx : const0_rtx);\n   emit_label (label);\n "}]}