{"sha": "91e50b2aa2dece9e22ae793d2a1a14b33bf3859d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFlNTBiMmFhMmRlY2U5ZTIyYWU3OTNkMmExYTE0YjMzYmYzODU5ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-02-21T14:36:00Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-02-21T14:36:00Z"}, "message": "tree-optimization: fix access path oracle on mismatched array refs [PR93586]\n\nnonoverlapping_array_refs_p is not supposed to give meaningful results when\nbases of ref1 and ref2 are not same or completely disjoint and here it is\ncalled on c[0][j_2][0] and c[0][1] so bases in sence of this functions are\n\"c[0][j_2]\" and \"c[0]\" which do partially overlap.  nonoverlapping_array_refs\nhowever walks pair of array references and in this case it misses to note the\nfact that if it walked across first mismatched pair it is no longer safe to\ncompare rest.\n\nThe reason why it continues matching is because it hopes it will\neventually get pair of COMPONENT_REFs from types of same size and use\nTBAA to conclude that their addresses must be either same or completely\ndisjoint.\n\nThis patch makes the loop to terminate early but popping all the\nremaining pairs so walking can continue.  We could re-synchronize on\narrays of same size with TBAA but this is bit fishy (because we try to\nsupport some sort of partial array overlaps) and hard to implement\n(because of zero sized arrays and VLAs) so I think it is not worth the\neffort.\n\nIn addition I notied that the function is not !flag_strict_aliasing safe\nand added early exits on places we set seen_unmatched_ref_p since later\nwe do not check that in:\n\n       /* If we skipped array refs on type of different sizes, we can\n \t no longer be sure that there are not partial overlaps.  */\n       if (seen_unmatched_ref_p\n \t  && !operand_equal_p (TYPE_SIZE (type1), TYPE_SIZE (type2), 0))\n \t{\n \t  ++alias_stats\n \t    .nonoverlapping_refs_since_match_p_may_alias;\n\t}\n\n  \tPR tree-optimization/93586\n\t* tree-ssa-alias.c (nonoverlapping_array_refs_p): Finish array walk\n\tafter mismatched array refs; do not sure type size information to\n\trecover from unmatched referneces with !flag_strict_aliasing_p.\n\n\t* gcc.dg/torture/pr93586.c: New testcase.", "tree": {"sha": "c07cc9a38c80730fe953d5b3c245db682ac00f8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c07cc9a38c80730fe953d5b3c245db682ac00f8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91e50b2aa2dece9e22ae793d2a1a14b33bf3859d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91e50b2aa2dece9e22ae793d2a1a14b33bf3859d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91e50b2aa2dece9e22ae793d2a1a14b33bf3859d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91e50b2aa2dece9e22ae793d2a1a14b33bf3859d/comments", "author": null, "committer": null, "parents": [{"sha": "b5fb73b6bed11aaa87919c3885349e6f1ca0349f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5fb73b6bed11aaa87919c3885349e6f1ca0349f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5fb73b6bed11aaa87919c3885349e6f1ca0349f"}], "stats": {"total": 77, "additions": 73, "deletions": 4}, "files": [{"sha": "85630f3613f3398bb5e75e39b9cb1b973ba20128", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e50b2aa2dece9e22ae793d2a1a14b33bf3859d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e50b2aa2dece9e22ae793d2a1a14b33bf3859d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91e50b2aa2dece9e22ae793d2a1a14b33bf3859d", "patch": "@@ -1,3 +1,11 @@\n+2020-02-21  Jan Hubicka  <hubicka@ucw.cz>\n+\t    Richard Biener  <rguenther@suse.de>\n+\n+  \tPR tree-optimization/93586\n+\t* tree-ssa-alias.c (nonoverlapping_array_refs_p): Finish array walk\n+\tafter mismatched array refs; do not sure type size information to\n+\trecover from unmatched referneces with !flag_strict_aliasing_p.\n+\n 2020-02-21  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* config/gcn/gcn-valu.md (gather_load<mode>): Rename to ..."}, {"sha": "606d00920d1e0d95cc7fbfd4d771fb41a130b175", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e50b2aa2dece9e22ae793d2a1a14b33bf3859d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e50b2aa2dece9e22ae793d2a1a14b33bf3859d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=91e50b2aa2dece9e22ae793d2a1a14b33bf3859d", "patch": "@@ -1,3 +1,9 @@\n+2020-02-21  Jan Hubicka  <hubicka@ucw.cz>\n+\t    Richard Biener  <rguenther@suse.de>\n+\n+  \tPR tree-optimization/93586\n+\t* gcc.dg/torture/pr93586.c: New testcase.\n+\n 2020-02-21  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/93845"}, {"sha": "e861bdcd78ee81bc8f3eca50deb76622638f6e18", "filename": "gcc/testsuite/gcc.dg/torture/pr93586.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e50b2aa2dece9e22ae793d2a1a14b33bf3859d/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93586.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e50b2aa2dece9e22ae793d2a1a14b33bf3859d/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93586.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93586.c?ref=91e50b2aa2dece9e22ae793d2a1a14b33bf3859d", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-fgimple\" } */\n+\n+int __GIMPLE(ssa) foo(int j)\n+{\n+  int c[1][10][1];\n+  int _1;\n+\n+__BB(2):\n+  c[0][1][0] = 1;\n+  c[0][1] = _Literal (int[1]) {};\n+  _1 = c[0][j_2(D)][0];\n+  return _1;\n+}\n+\n+int main()\n+{\n+  if (foo (1) != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "7554e209efa19e07904d8f07ef19afa210e202d7", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e50b2aa2dece9e22ae793d2a1a14b33bf3859d/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e50b2aa2dece9e22ae793d2a1a14b33bf3859d/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=91e50b2aa2dece9e22ae793d2a1a14b33bf3859d", "patch": "@@ -1486,9 +1486,27 @@ nonoverlapping_refs_since_match_p (tree match1, tree ref1,\n \t\t    .nonoverlapping_refs_since_match_p_no_alias;\n \t\t  return 1;\n \t\t}\n-\t      partial_overlap = false;\n \t      if (cmp == -1)\n-\t\tseen_unmatched_ref_p = true;\n+\t\t{\n+\t\t  seen_unmatched_ref_p = true;\n+\t\t  /* We can not maintain the invariant that bases are either\n+\t\t     same or completely disjoint.  However we can still recover\n+\t\t     from type based alias analysis if we reach referneces to\n+\t\t     same sizes.  We do not attempt to match array sizes, so\n+\t\t     just finish array walking and look for component refs.  */\n+\t\t  if (!flag_strict_aliasing)\n+\t\t    {\n+\t\t      ++alias_stats.nonoverlapping_refs_since_match_p_may_alias;\n+\t\t      return -1;\n+\t\t    }\n+\t\t  for (i++; i < narray_refs1; i++)\n+\t\t    {\n+\t\t      component_refs1.pop ();\n+\t\t      component_refs2.pop ();\n+\t\t    }\n+\t\t  break;\n+\t\t}\n+\t      partial_overlap = false;\n \t    }\n \t}\n \n@@ -1503,7 +1521,14 @@ nonoverlapping_refs_since_match_p (tree match1, tree ref1,\n \t    }\n \t  ref1 = component_refs1.pop ();\n \t  if (TREE_CODE (ref1) != COMPONENT_REF)\n-\t    seen_unmatched_ref_p = true;\n+\t    {\n+\t      seen_unmatched_ref_p = true;\n+\t      if (!flag_strict_aliasing)\n+\t\t{\n+\t\t  ++alias_stats.nonoverlapping_refs_since_match_p_may_alias;\n+\t\t  return -1;\n+\t\t}\n+\t    }\n \t}\n       while (!RECORD_OR_UNION_TYPE_P (TREE_TYPE (TREE_OPERAND (ref1, 0))));\n \n@@ -1517,7 +1542,14 @@ nonoverlapping_refs_since_match_p (tree match1, tree ref1,\n \t    }\n \t  ref2 = component_refs2.pop ();\n \t  if (TREE_CODE (ref2) != COMPONENT_REF)\n-\t    seen_unmatched_ref_p = true;\n+\t    {\n+\t      if (!flag_strict_aliasing)\n+\t\t{\n+\t\t  ++alias_stats.nonoverlapping_refs_since_match_p_may_alias;\n+\t\t  return -1;\n+\t\t}\n+\t      seen_unmatched_ref_p = true;\n+\t    }\n \t}\n       while (!RECORD_OR_UNION_TYPE_P (TREE_TYPE (TREE_OPERAND (ref2, 0))));\n \n@@ -1537,6 +1569,8 @@ nonoverlapping_refs_since_match_p (tree match1, tree ref1,\n \n       partial_overlap = false;\n \n+      gcc_checking_assert (!seen_unmatched_ref_p || flag_strict_aliasing);\n+\n       /* If we skipped array refs on type of different sizes, we can\n \t no longer be sure that there are not partial overlaps.  */\n       if (seen_unmatched_ref_p"}]}