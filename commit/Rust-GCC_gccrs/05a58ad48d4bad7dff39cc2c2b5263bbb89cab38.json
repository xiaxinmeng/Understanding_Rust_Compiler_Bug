{"sha": "05a58ad48d4bad7dff39cc2c2b5263bbb89cab38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVhNThhZDQ4ZDRiYWQ3ZGZmMzljYzJjMmI1MjYzYmJiODljYWIzOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2006-05-25T14:11:36Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-05-25T14:11:36Z"}, "message": "tree-ssa-structalias.h (PTR_IS_REF_ALL): New macro.\n\n\t* tree-ssa-structalias.h (PTR_IS_REF_ALL): New macro.\n\t(struct alias_info): Add new field ref_all_symbol_mem_tag.\n\t* tree-ssa-alias.c (compute_may_aliases): If the program contains\n\tref-all pointers, run a finalization pass for them.\n\t(compute_flow_insensitive_aliasing): Skip ref-all pointers.\n\t(finalize_ref_all_pointers): New function.\n\t(is_escape_site): Return ESCAPE_BAD_CAST for conversion from a\n\tregular pointer type to a ref-all pointer type.\n\t(get_tmt_for): Return the special memory tag for ref-all pointers.\n\nFrom-SVN: r114116", "tree": {"sha": "cd992f56010b4612bd7ca96d7b77a5d5b92fcc04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd992f56010b4612bd7ca96d7b77a5d5b92fcc04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05a58ad48d4bad7dff39cc2c2b5263bbb89cab38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05a58ad48d4bad7dff39cc2c2b5263bbb89cab38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05a58ad48d4bad7dff39cc2c2b5263bbb89cab38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05a58ad48d4bad7dff39cc2c2b5263bbb89cab38/comments", "author": null, "committer": null, "parents": [{"sha": "e803fecc5200c7d08c5079142c44d1b77b7bdcf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e803fecc5200c7d08c5079142c44d1b77b7bdcf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e803fecc5200c7d08c5079142c44d1b77b7bdcf1"}], "stats": {"total": 111, "additions": 102, "deletions": 9}, "files": [{"sha": "8ab803dabd45e8740ac0c76677fb1e19b922d168", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a58ad48d4bad7dff39cc2c2b5263bbb89cab38/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a58ad48d4bad7dff39cc2c2b5263bbb89cab38/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=05a58ad48d4bad7dff39cc2c2b5263bbb89cab38", "patch": "@@ -1,3 +1,15 @@\n+2006-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree-ssa-structalias.h (PTR_IS_REF_ALL): New macro.\n+\t(struct alias_info): Add new field ref_all_symbol_mem_tag.\n+\t* tree-ssa-alias.c (compute_may_aliases): If the program contains\n+\tref-all pointers, run a finalization pass for them.\n+\t(compute_flow_insensitive_aliasing): Skip ref-all pointers.\n+\t(finalize_ref_all_pointers): New function.\n+\t(is_escape_site): Return ESCAPE_BAD_CAST for conversion from a\n+\tregular pointer type to a ref-all pointer type.\n+\t(get_tmt_for): Return the special memory tag for ref-all pointers.\n+\n 2006-05-25  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/27743"}, {"sha": "121f645bcd6d56c9cb5fbbf0c7a254d1661d1cde", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 84, "deletions": 9, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a58ad48d4bad7dff39cc2c2b5263bbb89cab38/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a58ad48d4bad7dff39cc2c2b5263bbb89cab38/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=05a58ad48d4bad7dff39cc2c2b5263bbb89cab38", "patch": "@@ -98,6 +98,7 @@ static struct alias_stats_d alias_stats;\n \n /* Local functions.  */\n static void compute_flow_insensitive_aliasing (struct alias_info *);\n+static void finalize_ref_all_pointers (struct alias_info *);\n static void dump_alias_stats (FILE *);\n static bool may_alias_p (tree, HOST_WIDE_INT, tree, HOST_WIDE_INT, bool);\n static tree create_memory_tag (tree type, bool is_type_tag);\n@@ -692,6 +693,12 @@ compute_may_aliases (void)\n      aliasing precision.  */\n   maybe_create_global_var (ai);\n \n+  /* If the program contains ref-all pointers, finalize may-alias information\n+     for them.  This pass needs to be run after call-clobbering information\n+     has been computed.  */\n+  if (ai->ref_all_symbol_mem_tag)\n+    finalize_ref_all_pointers (ai);\n+\n   /* Debugging dumps.  */\n   if (dump_file)\n     {\n@@ -1156,6 +1163,10 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n       tree tag = var_ann (p_map->var)->symbol_mem_tag;\n       var_ann_t tag_ann = var_ann (tag);\n \n+      /* Call-clobbering information is not finalized yet at this point.  */\n+      if (PTR_IS_REF_ALL (p_map->var))\n+\tcontinue;\n+\n       p_map->total_alias_vops = 0;\n       p_map->may_aliases = BITMAP_ALLOC (&alias_obstack);\n \n@@ -1246,12 +1257,18 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n       tree tag1 = var_ann (p_map1->var)->symbol_mem_tag;\n       bitmap may_aliases1 = p_map1->may_aliases;\n \n+      if (PTR_IS_REF_ALL (p_map1->var))\n+\tcontinue;\n+\n       for (j = i + 1; j < ai->num_pointers; j++)\n \t{\n \t  struct alias_map_d *p_map2 = ai->pointers[j];\n \t  tree tag2 = var_ann (p_map2->var)->symbol_mem_tag;\n \t  bitmap may_aliases2 = p_map2->may_aliases;\n \n+\t  if (PTR_IS_REF_ALL (p_map2->var))\n+\t    continue;\n+\n \t  /* If the pointers may not point to each other, do nothing.  */\n \t  if (!may_alias_p (p_map1->var, p_map1->set, tag2, p_map2->set, true))\n \t    continue;\n@@ -1289,6 +1306,47 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n }\n \n \n+/* Finalize may-alias information for ref-all pointers.  Traverse all\n+   the addressable variables found in setup_pointers_and_addressables.\n+\n+   If flow-sensitive alias analysis has attached a name memory tag to\n+   a ref-all pointer, we will use it for the dereferences because that\n+   will have more precise aliasing information.  But if there is no\n+   name tag, we will use a special symbol tag that aliases all the\n+   call-clobbered addressable variables.  */\n+\n+static void\n+finalize_ref_all_pointers (struct alias_info *ai)\n+{\n+  size_t i;\n+\n+  if (global_var)\n+    add_may_alias (ai->ref_all_symbol_mem_tag, global_var);\n+  else\n+    {\n+      /* First add the real call-clobbered variables.  */\n+      for (i = 0; i < ai->num_addressable_vars; i++)\n+\t{\n+\t  tree var = ai->addressable_vars[i]->var;\n+\t  if (is_call_clobbered (var))\n+\t    add_may_alias (ai->ref_all_symbol_mem_tag, var);\n+        }\n+\n+      /* Then add the call-clobbered pointer memory tags.  See\n+\t compute_flow_insensitive_aliasing for the rationale.  */\n+      for (i = 0; i < ai->num_pointers; i++)\n+\t{\n+\t  tree ptr = ai->pointers[i]->var, tag;\n+\t  if (PTR_IS_REF_ALL (ptr))\n+\t    continue;\n+\t  tag = var_ann (ptr)->symbol_mem_tag;\n+\t  if (is_call_clobbered (tag))\n+\t    add_may_alias (ai->ref_all_symbol_mem_tag, tag);\n+\t}\n+    }\n+}\n+\n+\n /* Comparison function for qsort used in group_aliases.  */\n \n static int\n@@ -2060,15 +2118,24 @@ is_escape_site (tree stmt, struct alias_info *ai)\n       if (lhs == NULL_TREE)\n \treturn ESCAPE_UNKNOWN;\n \n-      /* If the RHS is a conversion between a pointer and an integer, the\n-\t pointer escapes since we can't track the integer.  */\n-      if ((TREE_CODE (TREE_OPERAND (stmt, 1)) == NOP_EXPR\n-\t   || TREE_CODE (TREE_OPERAND (stmt, 1)) == CONVERT_EXPR\n-\t   || TREE_CODE (TREE_OPERAND (stmt, 1)) == VIEW_CONVERT_EXPR)\n-\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND\n-\t\t\t\t\t(TREE_OPERAND (stmt, 1), 0)))\n-\t  && !POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (stmt, 1))))\n-\treturn ESCAPE_BAD_CAST;\n+      if (TREE_CODE (TREE_OPERAND (stmt, 1)) == NOP_EXPR\n+\t  || TREE_CODE (TREE_OPERAND (stmt, 1)) == CONVERT_EXPR\n+\t  || TREE_CODE (TREE_OPERAND (stmt, 1)) == VIEW_CONVERT_EXPR)\n+\t{\n+\t  tree from = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (stmt, 1), 0));\n+\t  tree to = TREE_TYPE (TREE_OPERAND (stmt, 1));\n+\n+\t  /* If the RHS is a conversion between a pointer and an integer, the\n+\t     pointer escapes since we can't track the integer.  */\n+\t  if (POINTER_TYPE_P (from) && !POINTER_TYPE_P (to))\n+\t    return ESCAPE_BAD_CAST;\n+\n+\t  /* Same if the RHS is a conversion between a regular pointer and a\n+\t     ref-all pointer since we can't track the SMT of the former.  */\n+\t  if (POINTER_TYPE_P (from) && !TYPE_REF_CAN_ALIAS_ALL (from)\n+\t      && POINTER_TYPE_P (to) && TYPE_REF_CAN_ALIAS_ALL (to))\n+\t    return ESCAPE_BAD_CAST;\n+\t}\n \n       /* If the LHS is an SSA name, it can't possibly represent a non-local\n \t memory store.  */\n@@ -2180,6 +2247,14 @@ get_tmt_for (tree ptr, struct alias_info *ai)\n   tree tag_type = TREE_TYPE (TREE_TYPE (ptr));\n   HOST_WIDE_INT tag_set = get_alias_set (tag_type);\n \n+  /* We use a unique memory tag for all the ref-all pointers.  */\n+  if (PTR_IS_REF_ALL (ptr))\n+    {\n+      if (!ai->ref_all_symbol_mem_tag)\n+\tai->ref_all_symbol_mem_tag = create_memory_tag (void_type_node, true);\n+      return ai->ref_all_symbol_mem_tag;\n+    }\n+\n   /* To avoid creating unnecessary memory tags, only create one memory tag\n      per alias set class.  Note that it may be tempting to group\n      memory tags based on conflicting alias sets instead of"}, {"sha": "5283202e9f88580ca63612c7bdff76e9e659d78a", "filename": "gcc/tree-ssa-structalias.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a58ad48d4bad7dff39cc2c2b5263bbb89cab38/gcc%2Ftree-ssa-structalias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a58ad48d4bad7dff39cc2c2b5263bbb89cab38/gcc%2Ftree-ssa-structalias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.h?ref=05a58ad48d4bad7dff39cc2c2b5263bbb89cab38", "patch": "@@ -22,6 +22,9 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n #ifndef TREE_SSA_STRUCTALIAS_H\n #define TREE_SSA_STRUCTALIAS_H\n \n+/* True if the data pointed to by PTR can alias anything.  */\n+#define PTR_IS_REF_ALL(PTR) TYPE_REF_CAN_ALIAS_ALL (TREE_TYPE (PTR))\n+\n struct constraint;\n typedef struct constraint *constraint_t;\n \n@@ -64,6 +67,9 @@ struct alias_info\n \n   /* Pointers that have been used in an indirect load operation.  */\n   bitmap dereferenced_ptrs_load;\n+\n+  /* Memory tag for all the PTR_IS_REF_ALL pointers.  */\n+  tree ref_all_symbol_mem_tag;\n };\n \n /* Keep track of how many times each pointer has been dereferenced in"}]}