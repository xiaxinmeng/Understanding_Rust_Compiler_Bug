{"sha": "0a62889c7a155f8ed971860d68870dc9c46bb004", "node_id": "C_kwDOANBUbNoAKDBhNjI4ODljN2ExNTVmOGVkOTcxODYwZDY4ODcwZGM5YzQ2YmIwMDQ", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-11-11T12:48:29Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-11-19T11:10:22Z"}, "message": "jit: Use std::mutex instead of pthread_mutex_t\n\nThis allows JIT to be built with a different thread model from posix\nwhere pthread isn't available\n\nBy renaming the acquire_mutex () and release_mutex () member functions\nto lock() and unlock() we make the playback::context type meet the C++\nLockable requirements. This allows it to be used with a scoped lock\n(i.e. RAII) type as std::lock_guard. This automatically releases the\nmutex when leaving the scope.\n\nCo-authored-by: LIU Hao <lh_mouse@126.com>\n\ngcc/jit/ChangeLog:\n\n\t* jit-playback.cc (playback::context::scoped_lock): Define RAII\n\tlock type.\n\t(playback::context::compile): Use scoped_lock to acquire mutex\n\tfor the active playback context.\n\t(jit_mutex): Change to std::mutex.\n\t(playback::context::acquire_mutex): Rename to ...\n\t(playback::context::lock): ... this.\n\t(playback::context::release_mutex): Rename to ...\n\t(playback::context::unlock): ... this.\n\t* jit-playback.h (playback::context): Rename members and declare\n\tscoped_lock.\n\t* jit-recording.cc (INCLUDE_PTHREAD_H): Remove unused define.\n\t* libgccjit.cc (version_mutex): Change to std::mutex.\n\t(struct jit_version_info): Use std::lock_guard to acquire and\n\trelease mutex.\n\ngcc/ChangeLog:\n\n\t* system.h [INCLUDE_MUTEX]: Include header for std::mutex.", "tree": {"sha": "6f9cdbfaa40430d129e13cb35bbfe39a8e4481d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f9cdbfaa40430d129e13cb35bbfe39a8e4481d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a62889c7a155f8ed971860d68870dc9c46bb004", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a62889c7a155f8ed971860d68870dc9c46bb004", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a62889c7a155f8ed971860d68870dc9c46bb004", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a62889c7a155f8ed971860d68870dc9c46bb004/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c05d8cd4300f74bf2698f0a6b96464b5be571be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c05d8cd4300f74bf2698f0a6b96464b5be571be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c05d8cd4300f74bf2698f0a6b96464b5be571be"}], "stats": {"total": 57, "additions": 33, "deletions": 24}, "files": [{"sha": "bf006903a445f9182d5da5c491f6e9fa534959ae", "filename": "gcc/jit/jit-playback.cc", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a62889c7a155f8ed971860d68870dc9c46bb004/gcc%2Fjit%2Fjit-playback.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a62889c7a155f8ed971860d68870dc9c46bb004/gcc%2Fjit%2Fjit-playback.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.cc?ref=0a62889c7a155f8ed971860d68870dc9c46bb004", "patch": "@@ -19,7 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n-#define INCLUDE_PTHREAD_H\n+#define INCLUDE_MUTEX\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"target.h\"\n@@ -2302,6 +2302,20 @@ block (function *func,\n   m_label_expr = NULL;\n }\n \n+// This is basically std::lock_guard but it can call the private lock/unlock\n+// members of playback::context.\n+struct playback::context::scoped_lock\n+{\n+  scoped_lock (context &ctx) : m_ctx (&ctx) { m_ctx->lock (); }\n+  ~scoped_lock () { m_ctx->unlock (); }\n+\n+  context *m_ctx;\n+\n+  // Not movable or copyable.\n+  scoped_lock (scoped_lock &&) = delete;\n+  scoped_lock &operator= (scoped_lock &&) = delete;\n+};\n+\n /* Compile a playback::context:\n \n    - Use the context's options to cconstruct command-line options, and\n@@ -2353,15 +2367,12 @@ compile ()\n   m_recording_ctxt->get_all_requested_dumps (&requested_dumps);\n \n   /* Acquire the JIT mutex and set \"this\" as the active playback ctxt.  */\n-  acquire_mutex ();\n+  scoped_lock lock(*this);\n \n   auto_string_vec fake_args;\n   make_fake_args (&fake_args, ctxt_progname, &requested_dumps);\n   if (errors_occurred ())\n-    {\n-      release_mutex ();\n-      return;\n-    }\n+    return;\n \n   /* This runs the compiler.  */\n   toplev toplev (get_timer (), /* external_timer */\n@@ -2388,10 +2399,7 @@ compile ()\n      followup activities use timevars, which are global state.  */\n \n   if (errors_occurred ())\n-    {\n-      release_mutex ();\n-      return;\n-    }\n+    return;\n \n   if (get_bool_option (GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE))\n     dump_generated_code ();\n@@ -2403,8 +2411,6 @@ compile ()\n      convert the .s file to the requested output format, and copy it to a\n      given file (playback::compile_to_file).  */\n   postprocess (ctxt_progname);\n-\n-  release_mutex ();\n }\n \n /* Implementation of class gcc::jit::playback::compile_to_memory,\n@@ -2662,32 +2668,32 @@ playback::compile_to_file::copy_file (const char *src_path,\n /* This mutex guards gcc::jit::recording::context::compile, so that only\n    one thread can be accessing the bulk of GCC's state at once.  */\n \n-static pthread_mutex_t jit_mutex = PTHREAD_MUTEX_INITIALIZER;\n+static std::mutex jit_mutex;\n \n /* Acquire jit_mutex and set \"this\" as the active playback ctxt.  */\n \n void\n-playback::context::acquire_mutex ()\n+playback::context::lock ()\n {\n   auto_timevar tv (get_timer (), TV_JIT_ACQUIRING_MUTEX);\n \n   /* Acquire the big GCC mutex. */\n   JIT_LOG_SCOPE (get_logger ());\n-  pthread_mutex_lock (&jit_mutex);\n+  jit_mutex.lock ();\n   gcc_assert (active_playback_ctxt == NULL);\n   active_playback_ctxt = this;\n }\n \n /* Release jit_mutex and clear the active playback ctxt.  */\n \n void\n-playback::context::release_mutex ()\n+playback::context::unlock ()\n {\n   /* Release the big GCC mutex. */\n   JIT_LOG_SCOPE (get_logger ());\n   gcc_assert (active_playback_ctxt == this);\n   active_playback_ctxt = NULL;\n-  pthread_mutex_unlock (&jit_mutex);\n+  jit_mutex.unlock ();\n }\n \n /* Callback used by gcc::jit::playback::context::make_fake_args when"}, {"sha": "1aeee2c8046cebad4098fba70fc4f398577752f0", "filename": "gcc/jit/jit-playback.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a62889c7a155f8ed971860d68870dc9c46bb004/gcc%2Fjit%2Fjit-playback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a62889c7a155f8ed971860d68870dc9c46bb004/gcc%2Fjit%2Fjit-playback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.h?ref=0a62889c7a155f8ed971860d68870dc9c46bb004", "patch": "@@ -314,8 +314,9 @@ class context : public log_user\n \n   /* Functions for implementing \"compile\".  */\n \n-  void acquire_mutex ();\n-  void release_mutex ();\n+  void lock ();\n+  void unlock ();\n+  struct scoped_lock;\n \n   void\n   make_fake_args (vec <char *> *argvec,"}, {"sha": "6ae5a667e90fcdcec1a182e4bf07d63b33cb8c5a", "filename": "gcc/jit/jit-recording.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a62889c7a155f8ed971860d68870dc9c46bb004/gcc%2Fjit%2Fjit-recording.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a62889c7a155f8ed971860d68870dc9c46bb004/gcc%2Fjit%2Fjit-recording.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.cc?ref=0a62889c7a155f8ed971860d68870dc9c46bb004", "patch": "@@ -19,7 +19,6 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n-#define INCLUDE_PTHREAD_H\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\""}, {"sha": "8884128e8d8ff7f9cde2a3f646c288f18720834f", "filename": "gcc/jit/libgccjit.cc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a62889c7a155f8ed971860d68870dc9c46bb004/gcc%2Fjit%2Flibgccjit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a62889c7a155f8ed971860d68870dc9c46bb004/gcc%2Fjit%2Flibgccjit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.cc?ref=0a62889c7a155f8ed971860d68870dc9c46bb004", "patch": "@@ -19,7 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n-#define INCLUDE_PTHREAD_H\n+#define INCLUDE_MUTEX\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"timevar.h\"\n@@ -4060,17 +4060,16 @@ gcc_jit_context_new_rvalue_from_vector (gcc_jit_context *ctxt,\n    Ideally this would be within parse_basever, but the mutex is only needed\n    by libgccjit.  */\n \n-static pthread_mutex_t version_mutex = PTHREAD_MUTEX_INITIALIZER;\n+static std::mutex version_mutex;\n \n struct jit_version_info\n {\n   /* Default constructor.  Populate via parse_basever,\n      guarded by version_mutex.  */\n   jit_version_info ()\n   {\n-    pthread_mutex_lock (&version_mutex);\n+    std::lock_guard<std::mutex> g (version_mutex);\n     parse_basever (&major, &minor, &patchlevel);\n-    pthread_mutex_unlock (&version_mutex);\n   }\n \n   int major;"}, {"sha": "4f9256efbcff0cfb5eccb8689d6346080e724db7", "filename": "gcc/system.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a62889c7a155f8ed971860d68870dc9c46bb004/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a62889c7a155f8ed971860d68870dc9c46bb004/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=0a62889c7a155f8ed971860d68870dc9c46bb004", "patch": "@@ -747,6 +747,10 @@ extern int vsnprintf (char *, size_t, const char *, va_list);\n # include <memory>\n #endif\n \n+#ifdef INCLUDE_MUTEX\n+# include <mutex>\n+#endif\n+\n #ifdef INCLUDE_MALLOC_H\n #if defined(HAVE_MALLINFO) || defined(HAVE_MALLINFO2)\n #include <malloc.h>"}]}