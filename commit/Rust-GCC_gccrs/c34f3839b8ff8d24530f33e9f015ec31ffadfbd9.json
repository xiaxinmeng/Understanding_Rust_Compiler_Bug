{"sha": "c34f3839b8ff8d24530f33e9f015ec31ffadfbd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM0ZjM4MzliOGZmOGQyNDUzMGYzM2U5ZjAxNWVjMzFmZmFkZmJkOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-12T08:54:00Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-12T08:54:00Z"}, "message": "trans.c (Identifier_to_gnu): Use boolean variable.\n\n\t* gcc-interface/trans.c (Identifier_to_gnu): Use boolean variable.\n\t(call_to_gnu): Test gigi's flag TYPE_BY_REFERENCE_P instead of calling\n\tfront-end's predicate Is_By_Reference_Type.  Use consistent order and\n\tremove ??? comment.  Use original conversion in all cases, if any.\n\t* gcc-interface/utils.c (make_dummy_type): Minor tweak.\n\t(convert): Use local copy in more cases.\n\t<INDIRECT_REF>: Remove deactivated code.\n\t(unchecked_convert): Use a couple of local copies.\n\nFrom-SVN: r158216", "tree": {"sha": "9c0e24429a0e07076d9c047871f1f09b9bbce251", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c0e24429a0e07076d9c047871f1f09b9bbce251"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c34f3839b8ff8d24530f33e9f015ec31ffadfbd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34f3839b8ff8d24530f33e9f015ec31ffadfbd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c34f3839b8ff8d24530f33e9f015ec31ffadfbd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34f3839b8ff8d24530f33e9f015ec31ffadfbd9/comments", "author": null, "committer": null, "parents": [{"sha": "c4712597e1c5c51dc348628a52846026083c467d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4712597e1c5c51dc348628a52846026083c467d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4712597e1c5c51dc348628a52846026083c467d"}], "stats": {"total": 178, "additions": 75, "deletions": 103}, "files": [{"sha": "22a68c4cc89a09747b2a7315c6ed5bcfc458c6d9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34f3839b8ff8d24530f33e9f015ec31ffadfbd9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34f3839b8ff8d24530f33e9f015ec31ffadfbd9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c34f3839b8ff8d24530f33e9f015ec31ffadfbd9", "patch": "@@ -1,3 +1,14 @@\n+2010-04-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (Identifier_to_gnu): Use boolean variable.\n+\t(call_to_gnu): Test gigi's flag TYPE_BY_REFERENCE_P instead of calling\n+\tfront-end's predicate Is_By_Reference_Type.  Use consistent order and\n+\tremove ??? comment.  Use original conversion in all cases, if any.\n+\t* gcc-interface/utils.c (make_dummy_type): Minor tweak.\n+\t(convert): Use local copy in more cases.\n+\t<INDIRECT_REF>: Remove deactivated code.\n+\t(unchecked_convert): Use a couple of local copies.\n+\n 2010-04-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (lvalue_required_for_attribute_p): New static"}, {"sha": "42e07b5d17024c63f420d9c489e9c078b3aaa67f", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 40, "deletions": 55, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34f3839b8ff8d24530f33e9f015ec31ffadfbd9/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34f3839b8ff8d24530f33e9f015ec31ffadfbd9/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=c34f3839b8ff8d24530f33e9f015ec31ffadfbd9", "patch": "@@ -997,18 +997,17 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       && DECL_P (gnu_result)\n       && DECL_INITIAL (gnu_result))\n     {\n-      tree object\n-\t= (TREE_CODE (gnu_result) == CONST_DECL\n-\t   ? DECL_CONST_CORRESPONDING_VAR (gnu_result) : gnu_result);\n+      bool constant_only = (TREE_CODE (gnu_result) == CONST_DECL\n+\t\t\t    && !DECL_CONST_CORRESPONDING_VAR (gnu_result));\n \n-      /* If there is a corresponding variable, we only want to return\n-\t the CST value if an lvalue is not required.  Evaluate this\n+      /* If there is a (corresponding) variable, we only want to return\n+\t the constant value if an lvalue is not required.  Evaluate this\n \t now if we have not already done so.  */\n-      if (object && require_lvalue < 0)\n+      if (!constant_only && require_lvalue < 0)\n \trequire_lvalue = lvalue_required_p (gnat_node, gnu_result_type, true,\n \t\t\t\t\t    Is_Aliased (gnat_temp));\n \n-      if (!object || !require_lvalue)\n+      if (constant_only || !require_lvalue)\n \tgnu_result = unshare_expr (DECL_INITIAL (gnu_result));\n     }\n \n@@ -2500,14 +2499,14 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       tree gnu_formal = present_gnu_tree (gnat_formal)\n \t\t\t? get_gnu_tree (gnat_formal) : NULL_TREE;\n       tree gnu_formal_type = gnat_to_gnu_type (Etype (gnat_formal));\n-      /* We must suppress conversions that can cause the creation of a\n-\t temporary in the Out or In Out case because we need the real\n-\t object in this case, either to pass its address if it's passed\n-\t by reference or as target of the back copy done after the call\n-\t if it uses the copy-in copy-out mechanism.  We do it in the In\n-\t case too, except for an unchecked conversion because it alone\n-\t can cause the actual to be misaligned and the addressability\n-\t test is applied to the real object.  */\n+      /* In the Out or In Out case, we must suppress conversions that yield\n+\t an lvalue but can nevertheless cause the creation of a temporary,\n+\t because we need the real object in this case, either to pass its\n+\t address if it's passed by reference or as target of the back copy\n+\t done after the call if it uses the copy-in copy-out mechanism.\n+\t We do it in the In case too, except for an unchecked conversion\n+\t because it alone can cause the actual to be misaligned and the\n+\t addressability test is applied to the real object.  */\n       bool suppress_type_conversion\n \t= ((Nkind (gnat_actual) == N_Unchecked_Type_Conversion\n \t    && Ekind (gnat_formal) != E_In_Parameter)\n@@ -2539,8 +2538,9 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t{\n \t  tree gnu_copy = gnu_name;\n \n-\t  /* If the type is by_reference, a copy is not allowed.  */\n-\t  if (Is_By_Reference_Type (Etype (gnat_formal)))\n+\t  /* If the type is passed by reference, a copy is not allowed.  */\n+\t  if (AGGREGATE_TYPE_P (gnu_formal_type)\n+\t      && TYPE_BY_REFERENCE_P (gnu_formal_type))\n \t    post_error\n \t      (\"misaligned actual cannot be passed by reference\", gnat_actual);\n \n@@ -2610,44 +2610,29 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t So do it here for the part we will use as an input, if any.  */\n       if (Ekind (gnat_formal) != E_Out_Parameter\n \t  && TYPE_IS_PADDING_P (TREE_TYPE (gnu_actual)))\n-\tgnu_actual = convert (get_unpadded_type (Etype (gnat_actual)),\n-\t\t\t      gnu_actual);\n-\n-      /* Do any needed conversions for the actual and make sure that it is\n-\t in range of the formal's type.  */\n-      if (suppress_type_conversion)\n-\t{\n-\t  /* Put back the conversion we suppressed above in the computation\n-\t     of the real object.  Note that we treat a conversion between\n-\t     aggregate types as if it is an unchecked conversion here.  */\n-\t  gnu_actual\n-\t    = unchecked_convert (gnat_to_gnu_type (Etype (gnat_actual)),\n-\t\t\t\t gnu_actual,\n-\t\t\t\t (Nkind (gnat_actual)\n-\t\t\t\t  == N_Unchecked_Type_Conversion)\n-\t\t\t\t && No_Truncation (gnat_actual));\n-\n-\t  if (Ekind (gnat_formal) != E_Out_Parameter\n-\t      && Do_Range_Check (gnat_actual))\n-\t    gnu_actual = emit_range_check (gnu_actual, Etype (gnat_formal),\n-\t\t\t\t\t   gnat_actual);\n-\t}\n+\tgnu_actual\n+\t  = convert (get_unpadded_type (Etype (gnat_actual)), gnu_actual);\n+\n+      /* Put back the conversion we suppressed above in the computation of the\n+\t real object.  And even if we didn't suppress any conversion there, we\n+\t may have suppressed a conversion to the Etype of the actual earlier,\n+\t since the parent is a procedure call, so put it back here.  */\n+      if (suppress_type_conversion\n+\t  && Nkind (gnat_actual) == N_Unchecked_Type_Conversion)\n+\tgnu_actual\n+\t  = unchecked_convert (gnat_to_gnu_type (Etype (gnat_actual)),\n+\t\t\t       gnu_actual, No_Truncation (gnat_actual));\n       else\n-\t{\n-\t  if (Ekind (gnat_formal) != E_Out_Parameter\n-\t      && Do_Range_Check (gnat_actual))\n-\t    gnu_actual = emit_range_check (gnu_actual, Etype (gnat_formal),\n-\t\t\t\t\t   gnat_actual);\n-\n-\t  /* We may have suppressed a conversion to the Etype of the actual\n-\t     since the parent is a procedure call.  So put it back here.\n-\t     ??? We use the reverse order compared to the case above because\n-\t     of an awkward interaction with the check.  */\n-\t  if (TREE_CODE (gnu_actual) != SAVE_EXPR)\n-\t    gnu_actual = convert (gnat_to_gnu_type (Etype (gnat_actual)),\n-\t\t\t\t  gnu_actual);\n-\t}\n+\tgnu_actual\n+\t  = convert (gnat_to_gnu_type (Etype (gnat_actual)), gnu_actual);\n+\n+      /* Make sure that the actual is in range of the formal's type.  */\n+      if (Ekind (gnat_formal) != E_Out_Parameter\n+\t  && Do_Range_Check (gnat_actual))\n+\tgnu_actual\n+\t  = emit_range_check (gnu_actual, Etype (gnat_formal), gnat_actual);\n \n+      /* And convert it to this type.  */\n       if (TREE_CODE (gnu_actual) != SAVE_EXPR)\n \tgnu_actual = convert (gnu_formal_type, gnu_actual);\n \n@@ -2657,8 +2642,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t  && TREE_CODE (gnu_name) == CONSTRUCTOR\n \t  && TREE_CODE (TREE_TYPE (gnu_name)) == RECORD_TYPE\n \t  && TYPE_JUSTIFIED_MODULAR_P (TREE_TYPE (gnu_name)))\n-\tgnu_name = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_name))),\n-\t\t\t    gnu_name);\n+\tgnu_name\n+\t  = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_name))), gnu_name);\n \n       /* If we have not saved a GCC object for the formal, it means it is an\n \t Out parameter not passed by reference and that need not be copied in."}, {"sha": "cf0ff60b485aff1014bad6c4c8acab31b14df5e1", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 24, "deletions": 48, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34f3839b8ff8d24530f33e9f015ec31ffadfbd9/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34f3839b8ff8d24530f33e9f015ec31ffadfbd9/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=c34f3839b8ff8d24530f33e9f015ec31ffadfbd9", "patch": "@@ -294,8 +294,8 @@ make_dummy_type (Entity_Id gnat_type)\n   TYPE_DUMMY_P (gnu_type) = 1;\n   TYPE_STUB_DECL (gnu_type)\n     = create_type_stub_decl (TYPE_NAME (gnu_type), gnu_type);\n-  if (AGGREGATE_TYPE_P (gnu_type))\n-    TYPE_BY_REFERENCE_P (gnu_type) = Is_By_Reference_Type (gnat_type);\n+  if (AGGREGATE_TYPE_P (gnu_type) && Is_By_Reference_Type (gnat_type))\n+    TYPE_BY_REFERENCE_P (gnu_type) = 1;\n \n   SET_DUMMY_NODE (gnat_underlying, gnu_type);\n \n@@ -3656,12 +3656,12 @@ convert_to_thin_pointer (tree type, tree expr)\n tree\n convert (tree type, tree expr)\n {\n-  enum tree_code code = TREE_CODE (type);\n   tree etype = TREE_TYPE (expr);\n   enum tree_code ecode = TREE_CODE (etype);\n+  enum tree_code code = TREE_CODE (type);\n \n-  /* If EXPR is already the right type, we are done.  */\n-  if (type == etype)\n+  /* If the expression is already of the right type, we are done.  */\n+  if (etype == type)\n     return expr;\n \n   /* If both input and output have padding and are of variable size, do this\n@@ -3708,7 +3708,7 @@ convert (tree type, tree expr)\n       /* If the inner type is of self-referential size and the expression type\n \t is a record, do this as an unchecked conversion.  But first pad the\n \t expression if possible to have the same size on both sides.  */\n-      if (TREE_CODE (etype) == RECORD_TYPE\n+      if (ecode == RECORD_TYPE\n \t  && CONTAINS_PLACEHOLDER_P (DECL_SIZE (TYPE_FIELDS (type))))\n \t{\n \t  if (TREE_CONSTANT (TYPE_SIZE (etype)))\n@@ -3721,7 +3721,7 @@ convert (tree type, tree expr)\n \t final conversion as an unchecked conversion, again to avoid the need\n \t for some variable-sized temporaries.  If valid, this conversion is\n \t very likely purely technical and without real effects.  */\n-      if (TREE_CODE (etype) == ARRAY_TYPE\n+      if (ecode == ARRAY_TYPE\n \t  && TREE_CODE (TREE_TYPE (TYPE_FIELDS (type))) == ARRAY_TYPE\n \t  && !TREE_CONSTANT (TYPE_SIZE (etype))\n \t  && !TREE_CONSTANT (TYPE_SIZE (type)))\n@@ -4000,25 +4000,6 @@ convert (tree type, tree expr)\n       }\n       break;\n \n-    case INDIRECT_REF:\n-      /* If both types are record types, just convert the pointer and\n-\t make a new INDIRECT_REF.\n-\n-\t ??? Disable this for now since it causes problems with the\n-\t code in build_binary_op for MODIFY_EXPR which wants to\n-\t strip off conversions.  But that code really is a mess and\n-\t we need to do this a much better way some time.  */\n-      if (0\n-\t  && (TREE_CODE (type) == RECORD_TYPE\n-\t      || TREE_CODE (type) == UNION_TYPE)\n-\t  && (TREE_CODE (etype) == RECORD_TYPE\n-\t      || TREE_CODE (etype) == UNION_TYPE)\n-\t  && !TYPE_IS_FAT_POINTER_P (type) && !TYPE_IS_FAT_POINTER_P (etype))\n-\treturn build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t       convert (build_pointer_type (type),\n-\t\t\t\t\tTREE_OPERAND (expr, 0)));\n-      break;\n-\n     default:\n       break;\n     }\n@@ -4359,38 +4340,34 @@ tree\n unchecked_convert (tree type, tree expr, bool notrunc_p)\n {\n   tree etype = TREE_TYPE (expr);\n+  enum tree_code ecode = TREE_CODE (etype);\n+  enum tree_code code = TREE_CODE (type);\n \n-  /* If the expression is already the right type, we are done.  */\n+  /* If the expression is already of the right type, we are done.  */\n   if (etype == type)\n     return expr;\n \n   /* If both types types are integral just do a normal conversion.\n      Likewise for a conversion to an unconstrained array.  */\n   if ((((INTEGRAL_TYPE_P (type)\n-\t && !(TREE_CODE (type) == INTEGER_TYPE\n-\t      && TYPE_VAX_FLOATING_POINT_P (type)))\n+\t && !(code == INTEGER_TYPE && TYPE_VAX_FLOATING_POINT_P (type)))\n \t|| (POINTER_TYPE_P (type) && ! TYPE_IS_THIN_POINTER_P (type))\n-\t|| (TREE_CODE (type) == RECORD_TYPE\n-\t    && TYPE_JUSTIFIED_MODULAR_P (type)))\n+\t|| (code == RECORD_TYPE && TYPE_JUSTIFIED_MODULAR_P (type)))\n        && ((INTEGRAL_TYPE_P (etype)\n-\t    && !(TREE_CODE (etype) == INTEGER_TYPE\n-\t\t && TYPE_VAX_FLOATING_POINT_P (etype)))\n+\t    && !(ecode == INTEGER_TYPE && TYPE_VAX_FLOATING_POINT_P (etype)))\n \t   || (POINTER_TYPE_P (etype) && !TYPE_IS_THIN_POINTER_P (etype))\n-\t   || (TREE_CODE (etype) == RECORD_TYPE\n-\t       && TYPE_JUSTIFIED_MODULAR_P (etype))))\n-      || TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n+\t   || (ecode == RECORD_TYPE && TYPE_JUSTIFIED_MODULAR_P (etype))))\n+      || code == UNCONSTRAINED_ARRAY_TYPE)\n     {\n-      if (TREE_CODE (etype) == INTEGER_TYPE\n-\t  && TYPE_BIASED_REPRESENTATION_P (etype))\n+      if (ecode == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (etype))\n \t{\n \t  tree ntype = copy_type (etype);\n \t  TYPE_BIASED_REPRESENTATION_P (ntype) = 0;\n \t  TYPE_MAIN_VARIANT (ntype) = ntype;\n \t  expr = build1 (NOP_EXPR, ntype, expr);\n \t}\n \n-      if (TREE_CODE (type) == INTEGER_TYPE\n-\t  && TYPE_BIASED_REPRESENTATION_P (type))\n+      if (code == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (type))\n \t{\n \t  tree rtype = copy_type (type);\n \t  TYPE_BIASED_REPRESENTATION_P (rtype) = 0;\n@@ -4441,17 +4418,16 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n   /* We have a special case when we are converting between two unconstrained\n      array types.  In that case, take the address, convert the fat pointer\n      types, and dereference.  */\n-  else if (TREE_CODE (etype) == UNCONSTRAINED_ARRAY_TYPE\n-\t   && TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n+  else if (ecode == code && code == UNCONSTRAINED_ARRAY_TYPE)\n     expr = build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t   build1 (VIEW_CONVERT_EXPR, TREE_TYPE (type),\n \t\t\t\t   build_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t\t\t\t   expr)));\n \n   /* Another special case is when we are converting to a vector type from its\n      representative array type; this a regular conversion.  */\n-  else if (TREE_CODE (type) == VECTOR_TYPE\n-\t   && TREE_CODE (etype) == ARRAY_TYPE\n+  else if (code == VECTOR_TYPE\n+\t   && ecode == ARRAY_TYPE\n \t   && gnat_types_compatible_p (TYPE_REPRESENTATIVE_ARRAY (type),\n \t\t\t\t       etype))\n     expr = convert (type, expr);\n@@ -4460,6 +4436,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n     {\n       expr = maybe_unconstrained_array (expr);\n       etype = TREE_TYPE (expr);\n+      ecode = TREE_CODE (etype);\n       if (can_fold_for_view_convert_p (expr))\n \texpr = fold_build1 (VIEW_CONVERT_EXPR, type, expr);\n       else\n@@ -4472,8 +4449,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n      is a biased type or if both the input and output are unsigned.  */\n   if (!notrunc_p\n       && INTEGRAL_TYPE_P (type) && TYPE_RM_SIZE (type)\n-      && !(TREE_CODE (type) == INTEGER_TYPE\n-\t   && TYPE_BIASED_REPRESENTATION_P (type))\n+      && !(code == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (type))\n       && 0 != compare_tree_int (TYPE_RM_SIZE (type),\n \t\t\t\tGET_MODE_BITSIZE (TYPE_MODE (type)))\n       && !(INTEGRAL_TYPE_P (etype)\n@@ -4484,8 +4460,8 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \t\t\t       0))\n       && !(TYPE_UNSIGNED (type) && TYPE_UNSIGNED (etype)))\n     {\n-      tree base_type = gnat_type_for_mode (TYPE_MODE (type),\n-\t\t\t\t\t   TYPE_UNSIGNED (type));\n+      tree base_type\n+\t= gnat_type_for_mode (TYPE_MODE (type), TYPE_UNSIGNED (type));\n       tree shift_expr\n \t= convert (base_type,\n \t\t   size_binop (MINUS_EXPR,"}]}