{"sha": "9208e4b25c6909de6e7032be427c8be101c14ffd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIwOGU0YjI1YzY5MDlkZTZlNzAzMmJlNDI3YzhiZTEwMWMxNGZmZA==", "commit": {"author": {"name": "David S. Miller", "email": "davem@pierdol.cobaltmicro.com", "date": "1998-08-14T01:49:23Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-08-14T01:49:23Z"}, "message": "sparc.c (const64_operand, [...]): Get it right when HOST_BITS_PER_WIDE_INT is not 64.\n\n\t* config/sparc/sparc.c (const64_operand, const64_high_operand):\n\tGet it right when HOST_BITS_PER_WIDE_INT is not 64.\n\t(input_operand): Fixup test for what we accept for constant\n\tintegers.\n\t(sparc_emit_set_const32, sparc_emit_set_symbolic_const64): Give\n\tset VOIDmode.\n\t(safe_constDI): Remove.\n\t(sparc_emit_set_safe_HIGH64, gen_safe_SET64, gen_safe_OR64,\n\tgen_safe_XOR64): New functions.\n\t(sparc_emit_set_const64_quick1, sparc_emit_set_const64_quick2,\n\tsparc_emit_set_const64_longway, sparc_emit_set_const64): Use\n\tthem.\n\t* config/sparc/sparc.md (define_insn xordi3_sp64_dbl): Only make\n\tavailable when HOST_BITS_PER_WIDE_INT is not 64.\n\t(define_insn movdi_sp64_dbl, movdi_const64_special): Likewise and\n\tmove before movdi_insn_sp64 pattern.\n\t(define_insn movdi_lo_sum_sp64_dbl, movdi_high_sp64_dbl): Remove.\n\t(define_insn sethi_di_medlow, seth44, setm44, sethh): Use\n\tsymbolic_operand as predicate for second operand.\n\t(DImode minus split on arch32, negsi2 expander, one_cmplsi2\n\texpander): Give set VOIDmode.\n\nFrom-SVN: r21724", "tree": {"sha": "e1d5d273d6ad51a8e580f7ac2bf13de6fe5a122a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1d5d273d6ad51a8e580f7ac2bf13de6fe5a122a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9208e4b25c6909de6e7032be427c8be101c14ffd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9208e4b25c6909de6e7032be427c8be101c14ffd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9208e4b25c6909de6e7032be427c8be101c14ffd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9208e4b25c6909de6e7032be427c8be101c14ffd/comments", "author": null, "committer": null, "parents": [{"sha": "a2cd38a9f83408401e59231579cc6bc73ae4b902", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2cd38a9f83408401e59231579cc6bc73ae4b902", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2cd38a9f83408401e59231579cc6bc73ae4b902"}], "stats": {"total": 374, "additions": 227, "deletions": 147}, "files": [{"sha": "312fb0e16d64d1a67138a2da4f39eb58661ea24c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9208e4b25c6909de6e7032be427c8be101c14ffd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9208e4b25c6909de6e7032be427c8be101c14ffd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9208e4b25c6909de6e7032be427c8be101c14ffd", "patch": "@@ -1,3 +1,27 @@\n+Fri Aug 14 00:34:34 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n+\n+\t* config/sparc/sparc.c (const64_operand, const64_high_operand):\n+\tGet it right when HOST_BITS_PER_WIDE_INT is not 64.\n+\t(input_operand): Fixup test for what we accept for constant\n+\tintegers.\n+\t(sparc_emit_set_const32, sparc_emit_set_symbolic_const64): Give\n+\tset VOIDmode.\n+\t(safe_constDI): Remove.\n+\t(sparc_emit_set_safe_HIGH64, gen_safe_SET64, gen_safe_OR64,\n+\tgen_safe_XOR64): New functions.\n+\t(sparc_emit_set_const64_quick1, sparc_emit_set_const64_quick2,\n+\tsparc_emit_set_const64_longway, sparc_emit_set_const64): Use\n+\tthem.\n+\t* config/sparc/sparc.md (define_insn xordi3_sp64_dbl): Only make\n+\tavailable when HOST_BITS_PER_WIDE_INT is not 64.\n+\t(define_insn movdi_sp64_dbl, movdi_const64_special): Likewise and\n+\tmove before movdi_insn_sp64 pattern.\n+\t(define_insn movdi_lo_sum_sp64_dbl, movdi_high_sp64_dbl): Remove.\n+\t(define_insn sethi_di_medlow, seth44, setm44, sethh): Use\n+\tsymbolic_operand as predicate for second operand.\n+\t(DImode minus split on arch32, negsi2 expander, one_cmplsi2\n+\texpander): Give set VOIDmode.\n+\t\n Fri Aug 14 01:45:06 1998  Mumit Khan  <khan@xraylith.wisc.edu>\n \n \t* i386/cygwin32 (DEFAULT_PCC_STRUCT_RETURN): Define."}, {"sha": "d6861b12f60daa82481d6a135e00f0fda7376dc9", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 172, "deletions": 118, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9208e4b25c6909de6e7032be427c8be101c14ffd/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9208e4b25c6909de6e7032be427c8be101c14ffd/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=9208e4b25c6909de6e7032be427c8be101c14ffd", "patch": "@@ -791,22 +791,35 @@ const64_operand (op, mode)\n {\n   return ((GET_CODE (op) == CONST_INT\n \t   && SPARC_SIMM13_P (INTVAL (op)))\n+#if HOST_BITS_PER_WIDE_INT != 64\n \t  || (GET_CODE (op) == CONST_DOUBLE\n-\t      && CONST_DOUBLE_HIGH (op) == 0\n-\t      && SPARC_SIMM13_P (CONST_DOUBLE_LOW (op)))\n+\t      && SPARC_SIMM13_P (CONST_DOUBLE_LOW (op))\n+\t      && (CONST_DOUBLE_HIGH (op) ==\n+\t\t  ((CONST_DOUBLE_LOW (op) & 0x80000000) != 0 ?\n+\t\t   0xffffffff : 0)))\n+#endif\n \t  || GET_CODE (op) == CONSTANT_P_RTX);\n }\n \n-/* The same, but considering what can fit for a sethi instruction.  */\n+/* The same, but only for sethi instructions.  */\n int\n const64_high_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n   return ((GET_CODE (op) == CONST_INT\n-\t   && SPARC_SETHI_P (INTVAL (op)))\n+\t   && (INTVAL (op) & 0xfffffc00) != 0\n+\t   && SPARC_SETHI_P (INTVAL (op))\n+#if HOST_BITS_PER_WIDE_INT != 64\n+\t   /* Must be positive on non-64bit host else the\n+\t      optimizer is fooled into thinking that sethi\n+\t      sign extends, even though it does not.  */\n+\t   && INTVAL (op) >= 0\n+#endif\n+\t   )\n \t  || (GET_CODE (op) == CONST_DOUBLE\n \t      && CONST_DOUBLE_HIGH (op) == 0\n+\t      && (CONST_DOUBLE_LOW (op) & 0xfffffc00) != 0\n \t      && SPARC_SETHI_P (CONST_DOUBLE_LOW (op)))\n \t  || GET_CODE (op) == CONSTANT_P_RTX);\n }\n@@ -1006,14 +1019,29 @@ input_operand (op, mode)\n   /* Allow any one instruction integer constant, and all CONST_INT\n      variants when we are working in DImode and !arch64.  */\n   if (GET_MODE_CLASS (mode) == MODE_INT\n-      && GET_CODE (op) == CONST_INT\n-      && ((SPARC_SETHI_P (INTVAL (op))\n-\t   && (! TARGET_ARCH64\n-\t       || (INTVAL (op) >= 0)\n-\t       || mode == SImode))\n-\t  || SPARC_SIMM13_P (INTVAL (op))\n-\t  || (mode == DImode\n-\t      && ! TARGET_ARCH64)))\n+      && ((GET_CODE (op) == CONST_INT\n+\t   && ((SPARC_SETHI_P (INTVAL (op))\n+\t\t&& (! TARGET_ARCH64\n+\t\t    || (INTVAL (op) >= 0)\n+\t\t    || mode == SImode))\n+\t       || SPARC_SIMM13_P (INTVAL (op))\n+\t       || (mode == DImode\n+\t\t   && ! TARGET_ARCH64)))\n+\t  || (TARGET_ARCH64\n+\t      && GET_CODE (op) == CONST_DOUBLE\n+\t      && ((CONST_DOUBLE_HIGH (op) == 0\n+\t\t   && SPARC_SETHI_P (CONST_DOUBLE_LOW (op)))\n+\t\t  ||\n+#if HOST_BITS_PER_WIDE_INT == 64\n+\t\t  (CONST_DOUBLE_HIGH (op) == 0\n+\t\t   && SPARC_SIMM13_P (CONST_DOUBLE_LOW (op)))\n+#else\n+\t\t  (SPARC_SIMM13_P (CONST_DOUBLE_LOW (op))\n+\t\t   && (((CONST_DOUBLE_LOW (op) & 0x80000000) == 0\n+\t\t\t&& CONST_DOUBLE_HIGH (op) == 0)\n+\t\t       || (CONST_DOUBLE_HIGH (op) == -1)))\n+#endif\n+\t\t  ))))\n     return 1;\n \n   /* Always match this.  */\n@@ -1084,11 +1112,11 @@ sparc_emit_set_const32 (op0, op1)\n   else\n     temp = gen_reg_rtx (mode);\n \n-  emit_insn (gen_rtx_SET (mode,\n+  emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t  temp,\n \t\t\t  gen_rtx_HIGH (mode,\n \t\t\t\t\top1)));\n-  emit_insn (gen_rtx_SET (mode,\n+  emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t  op0,\n \t\t\t  gen_rtx_LO_SUM (mode,\n \t\t\t\t\t  temp,\n@@ -1116,8 +1144,8 @@ sparc_emit_set_symbolic_const64 (op0, op1, temp1)\n \n \t sethi\t%hi(symbol), %temp\n \t or\t%temp, %lo(symbol), %reg  */\n-      emit_insn (gen_rtx_SET (DImode, temp1, gen_rtx_HIGH (DImode, op1)));\n-      emit_insn (gen_rtx_SET (DImode, op0, gen_rtx_LO_SUM (DImode, temp1, op1)));\n+      emit_insn (gen_rtx_SET (VOIDmode, temp1, gen_rtx_HIGH (DImode, op1)));\n+      emit_insn (gen_rtx_SET (VOIDmode, op0, gen_rtx_LO_SUM (DImode, temp1, op1)));\n       break;\n \n     case CM_MEDMID:\n@@ -1135,7 +1163,7 @@ sparc_emit_set_symbolic_const64 (op0, op1, temp1)\n \t or\t%temp3, %l44(symbol), %reg  */\n       emit_insn (gen_seth44 (op0, op1));\n       emit_insn (gen_setm44 (op0, op0, op1));\n-      emit_insn (gen_rtx_SET (DImode, temp1,\n+      emit_insn (gen_rtx_SET (VOIDmode, temp1,\n \t\t\t      gen_rtx_ASHIFT (DImode, op0, GEN_INT (12))));\n       emit_insn (gen_setl44 (op0, temp1, op1));\n       break;\n@@ -1166,9 +1194,9 @@ sparc_emit_set_symbolic_const64 (op0, op1, temp1)\n       emit_insn (gen_sethh (op0, op1));\n       emit_insn (gen_setlm (temp1, op1));\n       emit_insn (gen_sethm (op0, op0, op1));\n-      emit_insn (gen_rtx_SET (DImode, op0,\n+      emit_insn (gen_rtx_SET (VOIDmode, op0,\n \t\t\t      gen_rtx_ASHIFT (DImode, op0, GEN_INT (32))));\n-      emit_insn (gen_rtx_SET (DImode, op0,\n+      emit_insn (gen_rtx_SET (VOIDmode, op0,\n \t\t\t      gen_rtx_PLUS (DImode, op0, temp1)));\n       emit_insn (gen_setlo (op0, op0, op1));\n       break;\n@@ -1209,9 +1237,9 @@ sparc_emit_set_symbolic_const64 (op0, op1, temp1)\n \t  emit_insn (gen_embmedany_textuhi (op0, op1));\n \t  emit_insn (gen_embmedany_texthi  (temp1, op1));\n \t  emit_insn (gen_embmedany_textulo (op0, op0, op1));\n-\t  emit_insn (gen_rtx_SET (DImode, op0,\n+\t  emit_insn (gen_rtx_SET (VOIDmode, op0,\n \t\t\t\t  gen_rtx_ASHIFT (DImode, op0, GEN_INT (32))));\n-\t  emit_insn (gen_rtx_SET (DImode, op0,\n+\t  emit_insn (gen_rtx_SET (VOIDmode, op0,\n \t\t\t\t  gen_rtx_PLUS (DImode, op0, temp1)));\n \t  emit_insn (gen_embmedany_textlo  (op0, op0, op1));\n \t}\n@@ -1222,19 +1250,63 @@ sparc_emit_set_symbolic_const64 (op0, op1, temp1)\n     }\n }\n \n-/* This avoids problems when cross compiling. */\n-static rtx safe_constDI\tPROTO((HOST_WIDE_INT));\n+/* These avoid problems when cross compiling.  If we do not\n+   go through all this hair then the optimizer will see\n+   invalid REG_EQUAL notes or in some cases none at all.  */\n+static void sparc_emit_set_safe_HIGH64 PROTO ((rtx, HOST_WIDE_INT));\n+static rtx gen_safe_SET64 PROTO ((rtx, HOST_WIDE_INT));\n+static rtx gen_safe_OR64 PROTO ((rtx, HOST_WIDE_INT));\n+static rtx gen_safe_XOR64 PROTO ((rtx, HOST_WIDE_INT));\n+\n+#if HOST_BITS_PER_WIDE_INT == 64\n+#define GEN_HIGHINT64(__x)\t\tGEN_INT ((__x) & 0xfffffc00)\n+#define GEN_INT64(__x)\t\t\tGEN_INT (__x)\n+#else\n+#define GEN_HIGHINT64(__x) \\\n+\tgen_rtx_CONST_DOUBLE (VOIDmode, const0_rtx, \\\n+\t\t\t      (__x) & 0xfffffc00, 0)\n+#define GEN_INT64(__x) \\\n+\tgen_rtx_CONST_DOUBLE (VOIDmode, const0_rtx, \\\n+\t\t\t      (__x) & 0xffffffff, \\\n+\t\t\t      ((__x) & 0x80000000 \\\n+\t\t\t       ? 0xffffffff : 0))\n+#endif\n+\n+/* The optimizer is not to assume anything about exactly\n+   which bits are set for a HIGH, they are unspecified.\n+   Unfortunately this leads to many missed optimizations\n+   during CSE.  We mask out the non-HIGH bits, and matches\n+   a plain movdi, to alleviate this problem.  */\n+static void\n+sparc_emit_set_safe_HIGH64 (dest, val)\n+     rtx dest;\n+     HOST_WIDE_INT val;\n+{\n+  emit_insn (gen_rtx_SET (VOIDmode, dest, GEN_HIGHINT64 (val)));\n+}\n \n static rtx\n-safe_constDI(val)\n+gen_safe_SET64 (dest, val)\n+     rtx dest;\n      HOST_WIDE_INT val;\n {\n-#if HOST_BITS_PER_WIDE_INT != 64\n-  if (val & 0x80000000)\n-    return immed_double_const (val, 0, DImode);\n-  else\n-#endif\n-    return GEN_INT (val);\n+  return gen_rtx_SET (VOIDmode, dest, GEN_INT64 (val));\n+}\n+\n+static rtx\n+gen_safe_OR64 (src, val)\n+     rtx src;\n+     HOST_WIDE_INT val;\n+{\n+  return gen_rtx_IOR (DImode, src, GEN_INT64 (val));\n+}\n+\n+static rtx\n+gen_safe_XOR64 (src, val)\n+     rtx src;\n+     HOST_WIDE_INT val;\n+{\n+  return gen_rtx_XOR (DImode, src, GEN_INT64 (val));\n }\n \n /* Worker routines for 64-bit constant formation on arch64.\n@@ -1262,21 +1334,14 @@ sparc_emit_set_const64_quick1 (op0, temp, low_bits, is_neg)\n   else\n     high_bits = low_bits;\n \n-  emit_insn (gen_rtx_SET (DImode, temp,\n-\t\t\t  gen_rtx_HIGH (DImode,\n-\t\t\t\t\tsafe_constDI (high_bits))));\n+  sparc_emit_set_safe_HIGH64 (temp, high_bits);\n   if (!is_neg)\n-    {\n-      emit_insn (gen_rtx_SET (DImode, op0,\n-\t\t\t      gen_rtx_LO_SUM (DImode, temp,\n-\t\t\t\t\t      safe_constDI (high_bits))));\n-    }\n+    emit_insn (gen_rtx_SET (VOIDmode, op0,\n+\t\t\t    gen_safe_OR64 (temp, (high_bits & 0x3ff))));\n   else\n-    { /* as opposed to, say, tricky dick... */\n-      rtx tricky_bits = safe_constDI (-0x400 | (low_bits & 0x3ff));\n-      emit_insn (gen_rtx_SET (DImode, op0,\n-\t\t\t      gen_rtx_XOR (DImode, temp, tricky_bits)));\n-    }\n+    emit_insn (gen_rtx_SET (VOIDmode, op0,\n+\t\t\t    gen_safe_XOR64 (temp,\n+\t\t\t\t\t    (-0x400 | (low_bits & 0x3ff)))));\n }\n \n static void sparc_emit_set_const64_quick2\n@@ -1295,33 +1360,29 @@ sparc_emit_set_const64_quick2 (op0, temp, high_bits, low_immediate, shift_count)\n \n   if ((high_bits & 0xfffffc00) != 0)\n     {\n-      emit_insn (gen_rtx_SET (DImode, temp,\n-\t\t\t      gen_rtx_HIGH (DImode,\n-\t\t\t\t\t    safe_constDI (high_bits))));\n+      sparc_emit_set_safe_HIGH64 (temp, high_bits);\n       if ((high_bits & ~0xfffffc00) != 0)\n-\temit_insn (gen_rtx_SET (DImode, op0,\n-\t\t\t\tgen_rtx_LO_SUM (DImode, temp,\n-\t\t\t\t\t\tsafe_constDI (high_bits))));\n+\temit_insn (gen_rtx_SET (VOIDmode, op0,\n+\t\t\t\tgen_safe_OR64 (temp, (high_bits & 0x3ff))));\n       else\n \ttemp2 = temp;\n     }\n   else\n     {\n-      emit_insn (gen_rtx_SET (DImode, temp, safe_constDI (high_bits)));\n+      emit_insn (gen_rtx_SET (VOIDmode, temp, GEN_INT (high_bits)));\n       temp2 = temp;\n     }\n \n   /* Now shift it up into place. */\n-  emit_insn (gen_rtx_SET (DImode, op0,\n+  emit_insn (gen_rtx_SET (VOIDmode, op0,\n \t\t\t  gen_rtx_ASHIFT (DImode, temp2,\n \t\t\t\t\t  GEN_INT (shift_count))));\n \n   /* If there is a low immediate part piece, finish up by\n      putting that in as well.  */\n   if (low_immediate != 0)\n-    emit_insn (gen_rtx_SET (DImode, op0,\n-\t\t\t    gen_rtx_IOR (DImode, op0,\n-\t\t\t\t\t safe_constDI (low_immediate & 0x3ff))));\n+    emit_insn (gen_rtx_SET (VOIDmode, op0,\n+\t\t\t    gen_safe_OR64 (op0, low_immediate)));\n }\n \n static void sparc_emit_set_const64_longway\n@@ -1345,21 +1406,17 @@ sparc_emit_set_const64_longway (op0, temp, high_bits, low_bits)\n \n   if ((high_bits & 0xfffffc00) != 0)\n     {\n-      emit_insn (gen_rtx_SET (DImode,\n-\t\t\t      temp,\n-\t\t\t      gen_rtx_HIGH (DImode,\n-\t\t\t\t\t    safe_constDI (high_bits))));\n+      sparc_emit_set_safe_HIGH64 (temp, high_bits);\n       if ((high_bits & ~0xfffffc00) != 0)\n-\temit_insn (gen_rtx_SET (DImode,\n+\temit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\tsub_temp,\n-\t\t\t\tgen_rtx_LO_SUM (DImode, temp,\n-\t\t\t\t\t\tsafe_constDI (high_bits))));\n+\t\t\t\tgen_safe_OR64 (temp, (high_bits & 0x3ff))));\n       else\n \tsub_temp = temp;\n     }\n   else\n     {\n-      emit_insn (gen_rtx_SET (DImode, temp, safe_constDI (high_bits)));\n+      emit_insn (gen_rtx_SET (VOIDmode, temp, GEN_INT (high_bits)));\n       sub_temp = temp;\n     }\n \n@@ -1369,39 +1426,33 @@ sparc_emit_set_const64_longway (op0, temp, high_bits, low_bits)\n       rtx temp3 = gen_reg_rtx (DImode);\n       rtx temp4 = gen_reg_rtx (DImode);\n \n-      emit_insn (gen_rtx_SET (DImode, temp4,\n+      emit_insn (gen_rtx_SET (VOIDmode, temp4,\n \t\t\t      gen_rtx_ASHIFT (DImode, sub_temp,\n \t\t\t\t\t      GEN_INT (32))));\n \n-      /* Be careful, we must mask the bits here because otherwise\n-\t on a 32-bit host the optimizer will think we're putting\n-\t something like \"-1\" here and optimize it away.  */\n-      emit_insn (gen_rtx_SET (DImode, temp2,\n-\t\t\t      gen_rtx_HIGH (DImode,\n-\t\t\t\t\t    safe_constDI (low_bits))));\n+      sparc_emit_set_safe_HIGH64 (temp2, low_bits);\n       if ((low_bits & ~0xfffffc00) != 0)\n-\temit_insn (gen_rtx_SET (DImode, temp3,\n-\t\t\t\tgen_rtx_LO_SUM (DImode, temp2,\n-\t\t\t\t\t\tsafe_constDI (low_bits))));\n-      emit_insn (gen_rtx_SET (DImode, op0,\n+\temit_insn (gen_rtx_SET (VOIDmode, temp3,\n+\t\t\t\tgen_safe_OR64 (temp2, (low_bits & 0x3ff))));\n+      emit_insn (gen_rtx_SET (VOIDmode, op0,\n \t\t\t      gen_rtx_PLUS (DImode, temp4, temp3)));\n     }\n   else\n     {\n-      rtx low1 = safe_constDI ((low_bits >> (32 - 12))          & 0xfff);\n-      rtx low2 = safe_constDI ((low_bits >> (32 - 12 - 12))     & 0xfff);\n-      rtx low3 = safe_constDI ((low_bits >> (32 - 12 - 12 - 8)) & 0x0ff);\n+      rtx low1 = GEN_INT ((low_bits >> (32 - 12))          & 0xfff);\n+      rtx low2 = GEN_INT ((low_bits >> (32 - 12 - 12))     & 0xfff);\n+      rtx low3 = GEN_INT ((low_bits >> (32 - 12 - 12 - 8)) & 0x0ff);\n       int to_shift = 12;\n \n       /* We are in the middle of reload, so this is really\n \t painful.  However we do still make an attempt to\n \t avoid emmitting truly stupid code.  */\n       if (low1 != const0_rtx)\n \t{\n-\t  emit_insn (gen_rtx_SET (DImode, op0,\n+\t  emit_insn (gen_rtx_SET (VOIDmode, op0,\n \t\t\t\t  gen_rtx_ASHIFT (DImode, sub_temp,\n \t\t\t\t\t\t  GEN_INT (to_shift))));\n-\t  emit_insn (gen_rtx_SET (DImode, op0,\n+\t  emit_insn (gen_rtx_SET (VOIDmode, op0,\n \t\t\t\t  gen_rtx_IOR (DImode, op0, low1)));\n \t  sub_temp = op0;\n \t  to_shift = 12;\n@@ -1412,10 +1463,10 @@ sparc_emit_set_const64_longway (op0, temp, high_bits, low_bits)\n \t}\n       if (low2 != const0_rtx)\n \t{\n-\t  emit_insn (gen_rtx_SET (DImode, op0,\n+\t  emit_insn (gen_rtx_SET (VOIDmode, op0,\n \t\t\t\t  gen_rtx_ASHIFT (DImode, sub_temp,\n \t\t\t\t\t\t  GEN_INT (to_shift))));\n-\t  emit_insn (gen_rtx_SET (DImode, op0,\n+\t  emit_insn (gen_rtx_SET (VOIDmode, op0,\n \t\t\t\t  gen_rtx_IOR (DImode, op0, low2)));\n \t  sub_temp = op0;\n \t  to_shift = 8;\n@@ -1424,11 +1475,11 @@ sparc_emit_set_const64_longway (op0, temp, high_bits, low_bits)\n \t{\n \t  to_shift += 8;\n \t}\n-      emit_insn (gen_rtx_SET (DImode, op0,\n+      emit_insn (gen_rtx_SET (VOIDmode, op0,\n \t\t\t      gen_rtx_ASHIFT (DImode, sub_temp,\n \t\t\t\t\t      GEN_INT (to_shift))));\n       if (low3 != const0_rtx)\n-\temit_insn (gen_rtx_SET (DImode, op0,\n+\temit_insn (gen_rtx_SET (VOIDmode, op0,\n \t\t\t\tgen_rtx_IOR (DImode, op0, low3)));\n       /* phew... */\n     }\n@@ -1482,7 +1533,7 @@ analyze_64bit_constant (high_bits, low_bits, hbsp, lbsp, abbasp)\n      as one instruction!  */\n   if (lowest_bit_set == -1\n       || highest_bit_set == -1)\n-    abort();\n+    abort ();\n   all_bits_between_are_set = 1;\n   for (i = lowest_bit_set; i <= highest_bit_set; i++)\n     {\n@@ -1525,7 +1576,11 @@ const64_is_2insns (high_bits, low_bits)\n       && all_bits_between_are_set != 0)\n     return 1;\n \n-  if ((highest_bit_set - lowest_bit_set) < 22)\n+  if ((highest_bit_set - lowest_bit_set) < 21)\n+    return 1;\n+\n+  if (high_bits == 0\n+      || high_bits == 0xffffffff)\n     return 1;\n \n   return 0;\n@@ -1553,7 +1608,7 @@ create_simple_focus_bits (high_bits, low_bits, highest_bit_set, lowest_bit_set,\n       hi = ((high_bits >> (lowest_bit_set - 32)) << shift);\n     }\n   if (hi & lo)\n-    abort();\n+    abort ();\n   return (hi | lo);\n }\n \n@@ -1577,7 +1632,7 @@ sparc_emit_set_const64 (op0, op1)\n       || GET_CODE (op0) != REG\n       || (REGNO (op0) >= SPARC_FIRST_FP_REG\n \t  && REGNO (op0) <= SPARC_LAST_V9_FP_REG))\n-    abort();\n+    abort ();\n \n   if (GET_CODE (op1) != CONST_DOUBLE\n       && GET_CODE (op1) != CONST_INT)\n@@ -1641,7 +1696,7 @@ sparc_emit_set_const64 (op0, op1)\n        && all_bits_between_are_set != 0)\n       || ((highest_bit_set - lowest_bit_set) < 12))\n     {\n-      rtx the_const = constm1_rtx;\n+      HOST_WIDE_INT the_const = -1;\n       int shift = lowest_bit_set;\n \n       if (highest_bit_set == lowest_bit_set)\n@@ -1650,29 +1705,29 @@ sparc_emit_set_const64 (op0, op1)\n \t     can be done in one instruction.  */\n \t  if (lowest_bit_set < 32)\n \t    abort ();\n-\t  the_const = const1_rtx;\n+\t  the_const = 1;\n \t}\n       else if (all_bits_between_are_set == 0)\n \t{\n \t  the_const =\n-\t    safe_constDI (create_simple_focus_bits (high_bits, low_bits,\n-\t\t\t\t\t\t    highest_bit_set,\n-\t\t\t\t\t\t    lowest_bit_set, 0));\n+\t    create_simple_focus_bits (high_bits, low_bits,\n+\t\t\t\t      highest_bit_set,\n+\t\t\t\t      lowest_bit_set, 0);\n \t}\n       else if (lowest_bit_set == 0)\n-\tshift = -(64 - highest_bit_set);\n-      emit_insn (gen_rtx_SET (DImode, temp, the_const));\n+\tshift = -(63 - highest_bit_set);\n \n+      emit_insn (gen_safe_SET64 (temp, the_const));\n       if (shift > 0)\n-\temit_insn (gen_rtx_SET (DImode,\n+\temit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\top0,\n \t\t\t\tgen_rtx_ASHIFT (DImode,\n \t\t\t\t\t\ttemp,\n \t\t\t\t\t\tGEN_INT (shift))));\n       else if (shift < 0)\n-\temit_insn (gen_rtx_SET (DImode,\n+\temit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\top0,\n-\t\t\t\tgen_rtx_ASHIFTRT (DImode,\n+\t\t\t\tgen_rtx_LSHIFTRT (DImode,\n \t\t\t\t\t\t  temp,\n \t\t\t\t\t\t  GEN_INT (-shift))));\n       else\n@@ -1691,22 +1746,21 @@ sparc_emit_set_const64 (op0, op1)\n       unsigned HOST_WIDE_INT focus_bits =\n \tcreate_simple_focus_bits (high_bits, low_bits,\n \t\t\t\t  highest_bit_set, lowest_bit_set, 10);\n-      emit_insn (gen_rtx_SET (DImode,\n-\t\t\t      temp,\n-\t\t\t      gen_rtx_HIGH (DImode, safe_constDI (focus_bits))));\n+      sparc_emit_set_safe_HIGH64 (temp, focus_bits);\n \n+      /* If lowest_bit_set == 10 then a sethi alone could have done it.  */\n       if (lowest_bit_set < 10)\n-\temit_insn (gen_rtx_SET (DImode,\n+\temit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\top0,\n-\t\t\t\tgen_rtx_ASHIFTRT (DImode, temp,\n+\t\t\t\tgen_rtx_LSHIFTRT (DImode, temp,\n \t\t\t\t\t\t  GEN_INT (10 - lowest_bit_set))));\n-      else if (lowest_bit_set >= 10)\n-\temit_insn (gen_rtx_SET (DImode,\n+      else if (lowest_bit_set > 10)\n+\temit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\top0,\n \t\t\t\tgen_rtx_ASHIFT (DImode, temp,\n \t\t\t\t\t\tGEN_INT (lowest_bit_set - 10))));\n       else\n-\tabort();\n+\tabort ();\n       return;\n     }\n \n@@ -1747,13 +1801,13 @@ sparc_emit_set_const64 (op0, op1)\n \t  || (((~high_bits) & 0xffffffff) == 0xffffffff\n \t      && ((~low_bits) & 0x80000000) != 0))\n \t{\n-\t  rtx fast_int = GEN_INT (~low_bits & 0xffffffff);\n+\t  HOST_WIDE_INT fast_int = (~low_bits & 0xffffffff);\n \n-\t  if (input_operand (fast_int, DImode))\n-\t    emit_insn (gen_rtx_SET (DImode, temp,\n-\t\t\t\t    safe_constDI (~low_bits & 0xffffffff)));\n+\t  if (SPARC_SETHI_P (fast_int)\n+\t      || SPARC_SIMM13_P (((int)fast_int)))\n+\t    emit_insn (gen_safe_SET64 (temp, fast_int));\n \t  else\n-\t    sparc_emit_set_const64 (temp, fast_int);\n+\t    sparc_emit_set_const64 (temp, GEN_INT64 (fast_int));\n \t}\n       else\n \t{\n@@ -1762,16 +1816,16 @@ sparc_emit_set_const64 (op0, op1)\n \t  negated_const = GEN_INT (((~low_bits) & 0xfffffc00) |\n \t\t\t\t   (((HOST_WIDE_INT)((~high_bits) & 0xffffffff))<<32));\n #else\n-\t  negated_const = gen_rtx_CONST_DOUBLE (DImode, NULL_RTX,\n+\t  negated_const = gen_rtx_CONST_DOUBLE (DImode, const0_rtx,\n \t\t\t\t\t\t(~low_bits) & 0xfffffc00,\n \t\t\t\t\t\t(~high_bits) & 0xffffffff);\n #endif\n \t  sparc_emit_set_const64 (temp, negated_const);\n \t}\n-      emit_insn (gen_rtx_SET (DImode,\n+      emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t      op0,\n-\t\t\t      gen_rtx_XOR (DImode, temp,\n-\t\t\t\t\t   safe_constDI (-0x400 | trailing_bits))));\n+\t\t\t      gen_safe_XOR64 (temp,\n+\t\t\t\t\t      (-0x400 | trailing_bits))));\n       return;\n     }\n \n@@ -1786,14 +1840,14 @@ sparc_emit_set_const64 (op0, op1)\n       /* We can't get here in this state.  */\n       if (highest_bit_set < 32\n \t  || lowest_bit_set >= 32)\n-\tabort();\n+\tabort ();\n \n       /* So what we know is that the set bits straddle the\n \t middle of the 64-bit word.  */\n       hi = (low_bits >> lowest_bit_set);\n       lo = (high_bits << (32 - lowest_bit_set));\n       if (hi & lo)\n-\tabort();\n+\tabort ();\n       focus_bits = (hi | lo);\n       sparc_emit_set_const64_quick2 (op0, temp,\n \t\t\t\t     focus_bits, 0,\n@@ -3685,7 +3739,7 @@ function_arg_record_value (type, mode, slotno, named, regbase)\n \tnregs = SPARC_INT_ARG_MAX - slotno;\n     }\n   if (nregs == 0)\n-    abort();\n+    abort ();\n \n   parms.ret = gen_rtx_PARALLEL (mode, rtvec_alloc (nregs));\n \n@@ -4489,7 +4543,7 @@ epilogue_renumber (where)\n \n     default:\n       debug_rtx (*where);\n-      abort();\n+      abort ();\n     }\n }\n \n@@ -4611,7 +4665,7 @@ sparc_splitdi_legitimate(reg, mem)\n \n   /* Punt if we are here by mistake.  */\n   if (! reload_completed)\n-    abort();\n+    abort ();\n \n   /* We must have an offsettable memory reference.  */\n   if (! offsettable_memref_p (mem))"}, {"sha": "2047bb2d5ab0df1d720f1bc9d2b9909bfeeef299", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9208e4b25c6909de6e7032be427c8be101c14ffd/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9208e4b25c6909de6e7032be427c8be101c14ffd/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=9208e4b25c6909de6e7032be427c8be101c14ffd", "patch": "@@ -2328,6 +2328,24 @@\n   [(set_attr \"type\" \"store,load,*,*,*,*,fpstore,fpload,*,*,*\")\n    (set_attr \"length\" \"1,1,2,2,2,2,1,1,2,2,2\")])\n \n+(define_insn \"*movdi_sp64_dbl\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (match_operand:DI 1 \"const64_operand\" \"\"))]\n+  \"(TARGET_ARCH64\n+    && HOST_BITS_PER_WIDE_INT != 64)\"\n+  \"mov\\\\t%1, %0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"*movdi_const64_special\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(match_operand:DI 1 \"const64_high_operand\" \"\"))]\n+  \"(TARGET_ARCH64\n+    && HOST_BITS_PER_WIDE_INT != 64)\"\n+  \"sethi\\\\t%%hi(%a1), %0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n (define_insn \"*movdi_insn_sp64\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=r,r,r,r,m,?e,?e,?m\")\n         (match_operand:DI 1 \"input_operand\"   \"rI,K,J,m,rJ,e,m,e\"))]\n@@ -2346,7 +2364,7 @@\n   [(set_attr \"type\" \"move,move,move,load,store,fpmove,fpload,fpstore\")\n    (set_attr \"length\" \"1\")])\n \n-;; The following two are generated by sparc_emit_set_const64\n+;; The following are generated by sparc_emit_set_const64\n (define_insn \"*movdi_lo_sum_sp64_cint\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n@@ -2356,15 +2374,6 @@\n   [(set_attr \"type\" \"ialu\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"*movdi_lo_sum_sp64_dbl\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-                   (match_operand:DI 2 \"const64_operand\" \"\")))]\n-  \"TARGET_ARCH64\"\n-  \"or\\\\t%1, %%lo(%a2), %0\"\n-  [(set_attr \"type\" \"ialu\")\n-   (set_attr \"length\" \"1\")])\n-\n (define_insn \"*movdi_high_sp64_cint\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(high:DI (match_operand:DI 1 \"const_int_operand\" \"in\")))]\n@@ -2373,14 +2382,6 @@\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"*movdi_high_sp64_dbl\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(high:DI (match_operand:DI 1 \"const64_high_operand\" \"\")))]\n-  \"TARGET_ARCH64\"\n-  \"sethi\\\\t%%hi(%a1), %0\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"1\")])\n-\n ;; ??? revisit this...\n (define_insn \"move_label_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -2425,7 +2426,7 @@\n \n (define_insn \"*sethi_di_medlow\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (high:DI (match_operand:DI 1 \"\" \"\")))]\n+        (high:DI (match_operand:DI 1 \"symbolic_operand\" \"\")))]\n   \"TARGET_CM_MEDLOW && check_pic (1)\"\n   \"sethi\\\\t%%hi(%a1), %0\"\n   [(set_attr \"type\" \"move\")\n@@ -2441,7 +2442,7 @@\n \n (define_insn \"seth44\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (high:DI (unspec:DI [(match_operand:DI 1 \"\" \"\")] 6)))]\n+        (high:DI (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")] 6)))]\n   \"TARGET_CM_MEDMID\"\n   \"sethi\\\\t%%h44(%a1), %0\"\n   [(set_attr \"type\" \"move\")\n@@ -2450,7 +2451,7 @@\n (define_insn \"setm44\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-                   (unspec:DI [(match_operand:DI 2 \"\" \"\")] 7)))]\n+                   (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")] 7)))]\n   \"TARGET_CM_MEDMID\"\n   \"or\\\\t%1, %%m44(%a2), %0\"\n   [(set_attr \"type\" \"move\")\n@@ -2466,15 +2467,15 @@\n \n (define_insn \"sethh\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (high:DI (unspec:DI [(match_operand:DI 1 \"\" \"\")] 9)))]\n+        (high:DI (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")] 9)))]\n   \"TARGET_CM_MEDANY\"\n   \"sethi\\\\t%%hh(%a1), %0\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n \n (define_insn \"setlm\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (high:DI (unspec:DI [(match_operand:DI 1 \"\" \"\")] 10)))]\n+        (high:DI (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")] 10)))]\n   \"TARGET_CM_MEDANY\"\n   \"sethi\\\\t%%lm(%a1), %0\"\n   [(set_attr \"type\" \"move\")\n@@ -4673,7 +4674,7 @@\n   if ((lowp == const0_rtx)\n       && (operands[0] == operands[1]))\n     {\n-      emit_insn (gen_rtx_SET (SImode,\n+      emit_insn (gen_rtx_SET (VOIDmode,\n                               gen_highpart (SImode, operands[0]),\n                               gen_rtx_MINUS (SImode,\n                                              gen_highpart (SImode, operands[1]),\n@@ -5652,7 +5653,8 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(xor:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n \t\t(match_operand:DI 2 \"const64_operand\" \"\")))]\n-  \"TARGET_ARCH64\"\n+  \"(TARGET_ARCH64\n+    && HOST_BITS_PER_WIDE_INT != 64)\"\n   \"xor\\\\t%1, %2, %0\"\n   [(set_attr \"type\" \"ialu\")\n    (set_attr \"length\" \"1\")])\n@@ -5971,8 +5973,8 @@\n     {\n       rtx zero_reg = gen_reg_rtx (SImode);\n \n-      emit_insn (gen_rtx_SET (SImode, zero_reg, const0_rtx));\n-      emit_insn (gen_rtx_SET (SImode, operands[0],\n+      emit_insn (gen_rtx_SET (VOIDmode, zero_reg, const0_rtx));\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n                                       gen_rtx_MINUS (SImode, zero_reg,\n                                                              operands[1])));\n       DONE;\n@@ -6078,8 +6080,8 @@\n     {\n       rtx zero_reg = gen_reg_rtx (SImode);\n \n-      emit_insn (gen_rtx_SET (SImode, zero_reg, const0_rtx));\n-      emit_insn (gen_rtx_SET (SImode,\n+      emit_insn (gen_rtx_SET (VOIDmode, zero_reg, const0_rtx));\n+      emit_insn (gen_rtx_SET (VOIDmode,\n                               operands[0],\n                               gen_rtx_NOT (SImode,\n                                            gen_rtx_XOR (SImode,"}]}