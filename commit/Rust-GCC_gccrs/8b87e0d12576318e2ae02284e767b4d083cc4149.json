{"sha": "8b87e0d12576318e2ae02284e767b4d083cc4149", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI4N2UwZDEyNTc2MzE4ZTJhZTAyMjg0ZTc2N2I0ZDA4M2NjNDE0OQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-11-21T07:59:03Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-11-21T07:59:03Z"}, "message": "re PR debug/82718 (Bad DWARF5 .debug_loclists generation)\n\n\tPR debug/82718\n\t* dwarf2out.c (dw_loc_list): If crtl->has_bb_partition, temporarily\n\tset in_cold_section_p to the partition containing loc_list->first.\n\tWhen seeing loc_list->last_before_switch node, update secname and\n\tperform range_across_switch second partition handling only after that.\n\n\t* gcc.dg/debug/dwarf2/pr82718-1.c: New test.\n\t* gcc.dg/debug/dwarf2/pr82718-2.c: New test.\n\nFrom-SVN: r254989", "tree": {"sha": "cb8105420b51b50135fc21ae493584d22fba72ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb8105420b51b50135fc21ae493584d22fba72ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b87e0d12576318e2ae02284e767b4d083cc4149", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b87e0d12576318e2ae02284e767b4d083cc4149", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b87e0d12576318e2ae02284e767b4d083cc4149", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b87e0d12576318e2ae02284e767b4d083cc4149/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "83087d6521689c6200065537640b953972fbd76b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83087d6521689c6200065537640b953972fbd76b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83087d6521689c6200065537640b953972fbd76b"}], "stats": {"total": 246, "additions": 164, "deletions": 82}, "files": [{"sha": "207e6f32b2e0dc000dd75eec4f76cc7db12274c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b87e0d12576318e2ae02284e767b4d083cc4149/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b87e0d12576318e2ae02284e767b4d083cc4149/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b87e0d12576318e2ae02284e767b4d083cc4149", "patch": "@@ -1,5 +1,11 @@\n 2017-11-21  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR debug/82718\n+\t* dwarf2out.c (dw_loc_list): If crtl->has_bb_partition, temporarily\n+\tset in_cold_section_p to the partition containing loc_list->first.\n+\tWhen seeing loc_list->last_before_switch node, update secname and\n+\tperform range_across_switch second partition handling only after that.\n+\n \tPR debug/82933\n \t* run-rtl-passes.c: Include debug.h.\n \t(run_rtl_passes): Call debug_hooks->assembly_start."}, {"sha": "89e119c3dcad352925e34c5880e16af4c59cdca7", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 101, "deletions": 82, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b87e0d12576318e2ae02284e767b4d083cc4149/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b87e0d12576318e2ae02284e767b4d083cc4149/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=8b87e0d12576318e2ae02284e767b4d083cc4149", "patch": "@@ -16366,92 +16366,111 @@ dw_loc_list (var_loc_list *loc_list, tree decl, int want_address)\n      This means we have to special case the last node, and generate\n      a range of [last location start, end of function label].  */\n \n-  secname = secname_for_decl (decl);\n+  if (cfun && crtl->has_bb_partition)\n+    {\n+      bool save_in_cold_section_p = in_cold_section_p;\n+      in_cold_section_p = first_function_block_is_cold;\n+      if (loc_list->last_before_switch == NULL)\n+\tin_cold_section_p = !in_cold_section_p;\n+      secname = secname_for_decl (decl);\n+      in_cold_section_p = save_in_cold_section_p;\n+    }\n+  else\n+    secname = secname_for_decl (decl);\n \n   for (node = loc_list->first; node; node = node->next)\n-    if (GET_CODE (node->loc) == EXPR_LIST\n-\t|| NOTE_VAR_LOCATION_LOC (node->loc) != NULL_RTX)\n-      {\n-\tif (GET_CODE (node->loc) == EXPR_LIST)\n-\t  {\n-\t    /* This requires DW_OP_{,bit_}piece, which is not usable\n-\t       inside DWARF expressions.  */\n-\t    if (want_address != 2)\n-\t      continue;\n-\t    descr = dw_sra_loc_expr (decl, node->loc);\n-\t    if (descr == NULL)\n-\t      continue;\n-\t  }\n-\telse\n-\t  {\n-\t    initialized = NOTE_VAR_LOCATION_STATUS (node->loc);\n-\t    varloc = NOTE_VAR_LOCATION (node->loc);\n-\t    descr = dw_loc_list_1 (decl, varloc, want_address, initialized);\n-\t  }\n-\tif (descr)\n-\t  {\n-\t    bool range_across_switch = false;\n-\t    /* If section switch happens in between node->label\n-\t       and node->next->label (or end of function) and\n-\t       we can't emit it as a single entry list,\n-\t       emit two ranges, first one ending at the end\n-\t       of first partition and second one starting at the\n-\t       beginning of second partition.  */\n-\t    if (node == loc_list->last_before_switch\n-\t\t&& (node != loc_list->first || loc_list->first->next)\n-\t\t&& current_function_decl)\n-\t      {\n-\t\tendname = cfun->fde->dw_fde_end;\n-\t\trange_across_switch = true;\n-\t      }\n-\t    /* The variable has a location between NODE->LABEL and\n-\t       NODE->NEXT->LABEL.  */\n-\t    else if (node->next)\n-\t      endname = node->next->label;\n-\t    /* If the variable has a location at the last label\n-\t       it keeps its location until the end of function.  */\n-\t    else if (!current_function_decl)\n-\t      endname = text_end_label;\n-\t    else\n-\t      {\n-\t\tASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,\n-\t\t\t\t\t     current_function_funcdef_no);\n-\t\tendname = ggc_strdup (label_id);\n-\t      }\n+    {\n+      bool range_across_switch = false;\n+      if (GET_CODE (node->loc) == EXPR_LIST\n+\t  || NOTE_VAR_LOCATION_LOC (node->loc) != NULL_RTX)\n+\t{\n+\t  if (GET_CODE (node->loc) == EXPR_LIST)\n+\t    {\n+\t      descr = NULL;\n+\t      /* This requires DW_OP_{,bit_}piece, which is not usable\n+\t\t inside DWARF expressions.  */\n+\t      if (want_address == 2)\n+\t\tdescr = dw_sra_loc_expr (decl, node->loc);\n+\t    }\n+\t  else\n+\t    {\n+\t      initialized = NOTE_VAR_LOCATION_STATUS (node->loc);\n+\t      varloc = NOTE_VAR_LOCATION (node->loc);\n+\t      descr = dw_loc_list_1 (decl, varloc, want_address, initialized);\n+\t    }\n+\t  if (descr)\n+\t    {\n+\t      /* If section switch happens in between node->label\n+\t\t and node->next->label (or end of function) and\n+\t\t we can't emit it as a single entry list,\n+\t\t emit two ranges, first one ending at the end\n+\t\t of first partition and second one starting at the\n+\t\t beginning of second partition.  */\n+\t      if (node == loc_list->last_before_switch\n+\t\t  && (node != loc_list->first || loc_list->first->next)\n+\t\t  && current_function_decl)\n+\t\t{\n+\t\t  endname = cfun->fde->dw_fde_end;\n+\t\t  range_across_switch = true;\n+\t\t}\n+\t      /* The variable has a location between NODE->LABEL and\n+\t\t NODE->NEXT->LABEL.  */\n+\t      else if (node->next)\n+\t\tendname = node->next->label;\n+\t      /* If the variable has a location at the last label\n+\t\t it keeps its location until the end of function.  */\n+\t      else if (!current_function_decl)\n+\t\tendname = text_end_label;\n+\t      else\n+\t\t{\n+\t\t  ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,\n+\t\t\t\t\t       current_function_funcdef_no);\n+\t\t  endname = ggc_strdup (label_id);\n+\t\t}\n \n-\t    *listp = new_loc_list (descr, node->label, endname, secname);\n-\t    if (TREE_CODE (decl) == PARM_DECL\n-\t\t&& node == loc_list->first\n-\t\t&& NOTE_P (node->loc)\n-\t\t&& strcmp (node->label, endname) == 0)\n-\t      (*listp)->force = true;\n-\t    listp = &(*listp)->dw_loc_next;\n+\t      *listp = new_loc_list (descr, node->label, endname, secname);\n+\t      if (TREE_CODE (decl) == PARM_DECL\n+\t\t  && node == loc_list->first\n+\t\t  && NOTE_P (node->loc)\n+\t\t  && strcmp (node->label, endname) == 0)\n+\t\t(*listp)->force = true;\n+\t      listp = &(*listp)->dw_loc_next;\n+\t    }\n+\t}\n \n-\t    if (range_across_switch)\n-\t      {\n-\t\tif (GET_CODE (node->loc) == EXPR_LIST)\n-\t\t  descr = dw_sra_loc_expr (decl, node->loc);\n-\t\telse\n-\t\t  {\n-\t\t    initialized = NOTE_VAR_LOCATION_STATUS (node->loc);\n-\t\t    varloc = NOTE_VAR_LOCATION (node->loc);\n-\t\t    descr = dw_loc_list_1 (decl, varloc, want_address,\n-\t\t\t\t\t   initialized);\n-\t\t  }\n-\t\tgcc_assert (descr);\n-\t\t/* The variable has a location between NODE->LABEL and\n-\t\t   NODE->NEXT->LABEL.  */\n-\t\tif (node->next)\n-\t\t  endname = node->next->label;\n-\t\telse\n-\t\t  endname = cfun->fde->dw_fde_second_end;\n-\t\t*listp = new_loc_list (descr,\n-\t\t\t\t       cfun->fde->dw_fde_second_begin,\n-\t\t\t\t       endname, secname);\n-\t\tlistp = &(*listp)->dw_loc_next;\n-\t      }\n-\t  }\n-      }\n+      if (cfun\n+\t  && crtl->has_bb_partition\n+\t  && node == loc_list->last_before_switch)\n+\t{\n+\t  bool save_in_cold_section_p = in_cold_section_p;\n+\t  in_cold_section_p = !first_function_block_is_cold;\n+\t  secname = secname_for_decl (decl);\n+\t  in_cold_section_p = save_in_cold_section_p;\n+\t}\n+\n+      if (range_across_switch)\n+\t{\n+\t  if (GET_CODE (node->loc) == EXPR_LIST)\n+\t    descr = dw_sra_loc_expr (decl, node->loc);\n+\t  else\n+\t    {\n+\t      initialized = NOTE_VAR_LOCATION_STATUS (node->loc);\n+\t      varloc = NOTE_VAR_LOCATION (node->loc);\n+\t      descr = dw_loc_list_1 (decl, varloc, want_address,\n+\t\t\t\t     initialized);\n+\t    }\n+\t  gcc_assert (descr);\n+\t  /* The variable has a location between NODE->LABEL and\n+\t     NODE->NEXT->LABEL.  */\n+\t  if (node->next)\n+\t    endname = node->next->label;\n+\t  else\n+\t    endname = cfun->fde->dw_fde_second_end;\n+\t  *listp = new_loc_list (descr, cfun->fde->dw_fde_second_begin,\n+\t\t\t\t endname, secname);\n+\t  listp = &(*listp)->dw_loc_next;\n+\t}\n+    }\n \n   /* Try to avoid the overhead of a location list emitting a location\n      expression instead, but only if we didn't have more than one"}, {"sha": "ca2206c575cb6a4e17c79566716afffccf09577f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b87e0d12576318e2ae02284e767b4d083cc4149/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b87e0d12576318e2ae02284e767b4d083cc4149/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b87e0d12576318e2ae02284e767b4d083cc4149", "patch": "@@ -1,5 +1,9 @@\n 2017-11-21  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR debug/82718\n+\t* gcc.dg/debug/dwarf2/pr82718-1.c: New test.\n+\t* gcc.dg/debug/dwarf2/pr82718-2.c: New test.\n+\n \tPR debug/82933\n \t* gcc.dg/rtl/x86_64/pr82933.c: New test.\n "}, {"sha": "1ed92bfe90f7ac76a5cbefe02317f0aab5c41e5e", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/pr82718-1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b87e0d12576318e2ae02284e767b4d083cc4149/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr82718-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b87e0d12576318e2ae02284e767b4d083cc4149/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr82718-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr82718-1.c?ref=8b87e0d12576318e2ae02284e767b4d083cc4149", "patch": "@@ -0,0 +1,41 @@\n+/* PR debug/82718 */\n+/* { dg-do assemble } */\n+/* { dg-options \"-O2 -gdwarf-5\" } */\n+\n+extern int e;\n+extern long foo (int, void *, unsigned long, unsigned long);\n+struct S\n+{\n+  int f;\n+  unsigned long t, s;\n+};\n+\n+static inline long\n+bv (int x, void *y, unsigned long z, unsigned long w)\n+{\n+  long a = 0;\n+  do\n+    {\n+      long g;\n+      do\n+\tg = (long int) (foo (x, y + a, z - a, w + a));\n+      while (g == -1L && e == 9959);\n+      if (g <= 0)\n+\treturn g < 0 ? g : a;\n+      a += g;\n+    }\n+  while ((unsigned long) a < z);\n+  return a;\n+}\n+\n+const char *\n+baz (struct S *x)\n+{\n+  unsigned long h = 8;\n+  char *j = 0;\n+  unsigned long z = x->f;\n+  if (__builtin_expect (!!((unsigned long) bv (x->f, j, z, x->t + h + 10) != z), 0))\n+    return 0;\n+  x->s = z;\n+  return j;\n+}"}, {"sha": "85279e15bd0f690578df93a1c4086288f6b67183", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/pr82718-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b87e0d12576318e2ae02284e767b4d083cc4149/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr82718-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b87e0d12576318e2ae02284e767b4d083cc4149/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr82718-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr82718-2.c?ref=8b87e0d12576318e2ae02284e767b4d083cc4149", "patch": "@@ -0,0 +1,12 @@\n+/* PR debug/82718 */\n+/* { dg-do assemble } */\n+/* { dg-options \"-O2 -gdwarf-5\" } */\n+\n+extern int bar (void);\n+\n+int\n+foo (int x)\n+{\n+  if (bar ())\n+    __builtin_abort ();\n+}"}]}