{"sha": "f6cad4c9e950e2985565e7d0ca6bc2eb6af2c776", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZjYWQ0YzllOTUwZTI5ODU1NjVlN2QwY2E2YmMyZWI2YWYyYzc3Ng==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "2000-01-07T18:30:43Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-01-07T18:30:43Z"}, "message": "Merge duplicate definitions in svr4.h into elfos.h\n\nFrom-SVN: r31274", "tree": {"sha": "94702c6a18afd1674acd336b2a2ba3744ab7910f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94702c6a18afd1674acd336b2a2ba3744ab7910f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6cad4c9e950e2985565e7d0ca6bc2eb6af2c776", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6cad4c9e950e2985565e7d0ca6bc2eb6af2c776", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6cad4c9e950e2985565e7d0ca6bc2eb6af2c776", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6cad4c9e950e2985565e7d0ca6bc2eb6af2c776/comments", "author": null, "committer": null, "parents": [{"sha": "a47ce296b7e821a61388028a5e92ed5728881448", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a47ce296b7e821a61388028a5e92ed5728881448", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a47ce296b7e821a61388028a5e92ed5728881448"}], "stats": {"total": 1457, "additions": 438, "deletions": 1019}, "files": [{"sha": "b730eea040474ca69e70360ad41fc48a44dbe0e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6cad4c9e950e2985565e7d0ca6bc2eb6af2c776/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6cad4c9e950e2985565e7d0ca6bc2eb6af2c776/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6cad4c9e950e2985565e7d0ca6bc2eb6af2c776", "patch": "@@ -1,3 +1,11 @@\n+2000-01-07  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/elfos.h: Tidy up formatting of marcos.  Make sure\n+\tthat .section directives are always prefixed by a tab.\n+\n+\t* config/svr4.h: Add #include \"elfos.h\" and remove duplicate\n+\tdefinitions.\n+\n 2000-01-07  Matt Austern <austern@sgi.com>\n \n \t* fold-const.c (real_hex_to_f): Remove duplicate declaration of"}, {"sha": "4b4b87662c667513b7218b5794c45aa4ada72033", "filename": "gcc/config/elfos.h", "status": "modified", "additions": 414, "deletions": 314, "changes": 728, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6cad4c9e950e2985565e7d0ca6bc2eb6af2c776/gcc%2Fconfig%2Felfos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6cad4c9e950e2985565e7d0ca6bc2eb6af2c776/gcc%2Fconfig%2Felfos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felfos.h?ref=f6cad4c9e950e2985565e7d0ca6bc2eb6af2c776", "patch": "@@ -1,6 +1,6 @@\n /* elfos.h  --  operating system specific defines to be used when\n    targeting GCC for some generic ELF system\n-   Copyright (C) 1991, 1994, 1995, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 1994, 1995, 1999, 2000 Free Software Foundation, Inc.\n    Based on svr4.h contributed by Ron Guilmette (rfg@netcom.com).\n \n This file is part of GNU CC.\n@@ -20,6 +20,22 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+/* The prefix to add to user-visible assembler symbols.\n+\n+   For ELF systems the convention is *not* to prepend a leading\n+   underscore onto user-level symbol names.  */\n+\n+#undef  USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"\"\n+\n+/* Biggest alignment supported by the object file format of this\n+   machine.  Use this macro to limit the alignment which can be\n+   specified using the `__attribute__ ((aligned (N)))' construct.  If\n+   not defined, the default value is `BIGGEST_ALIGNMENT'.  */\n+#ifndef MAX_OFILE_ALIGNMENT\n+#define MAX_OFILE_ALIGNMENT (32768 * 8)\n+#endif\n+\n #undef  ENDFILE_SPEC\n #define ENDFILE_SPEC \"crtend.o%s\"\n \n@@ -29,25 +45,6 @@ Boston, MA 02111-1307, USA.  */\n \t\t\t  %{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}}\\\n \t\t\tcrtbegin.o%s\"\n \n-/* Attach a special .ident directive to the end of the file to identify\n-   the version of GCC which compiled this code.  The format of the\n-   .ident string is patterned after the ones produced by native svr4\n-   C compilers.  */\n-\n-#define IDENT_ASM_OP \".ident\"\n-\n-#define ASM_FILE_END(FILE)\t\t\t\t\t\\\n-do {\t\t\t\t \t\t\t\t\\\n-     if (!flag_no_ident)\t\t\t\t\t\\\n-\tfprintf ((FILE), \"\\t%s\\t\\\"GCC: (GNU) %s\\\"\\n\",\t\t\\\n-\t\t IDENT_ASM_OP, version_string);\t\t\t\\\n-   } while (0)\n-\n-/* Output #ident as a .ident.  */\n-\n-#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n-  fprintf (FILE, \"\\t%s\\t\\\"%s\\\"\\n\", IDENT_ASM_OP, NAME);\n-\n /* Use periods rather than dollar signs in special g++ assembler names.  */\n \n #define NO_DOLLAR_IN_LABEL\n@@ -87,10 +84,44 @@ do {\t\t\t\t \t\t\t\t\\\n #define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n #endif\n \n-#undef ASM_BYTE_OP\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.\n+\n+   For most ELF systems the convention is *not* to prepend a leading\n+   underscore onto user-level symbol names.  */\n+\n+#undef  ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE,NAME) fprintf (FILE, \"%s\", NAME)\n+     \n+/* All SVR4 targets use the ELF object file format.  */\n+#define OBJECT_FORMAT_ELF\n+\n+\n+/* Output #ident as a .ident.  */\n+\n+#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n+  fprintf (FILE, \"\\t%s\\t\\\"%s\\\"\\n\", IDENT_ASM_OP, NAME);\n+\n+/* Attach a special .ident directive to the end of the file to identify\n+   the version of GCC which compiled this code.  The format of the\n+   .ident string is patterned after the ones produced by native svr4\n+   C compilers.  */\n+\n+#define IDENT_ASM_OP \".ident\"\n+\n+#define ASM_FILE_END(FILE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t \t\t\t\\\n+      if (!flag_no_ident)\t\t\t\t\\\n+\tfprintf ((FILE), \"\\t%s\\t\\\"GCC: (GNU) %s\\\"\\n\",\t\\\n+\t\t IDENT_ASM_OP, version_string);\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#undef  ASM_BYTE_OP\n #define ASM_BYTE_OP\t\".byte\"\n \n-#undef SET_ASM_OP\n+#undef  SET_ASM_OP\n #define SET_ASM_OP\t\".set\"\n \n /* This is how to begin an assembly language file.  Most svr4 assemblers want\n@@ -101,38 +132,31 @@ do {\t\t\t\t \t\t\t\t\\\n    in the target-specific file which includes this one.  */\n \n #undef ASM_FILE_START\n-#define ASM_FILE_START(FILE)                                    \\\n+#define ASM_FILE_START(FILE)                            \\\n   output_file_directive ((FILE), main_input_filename)\n \n /* This is how to allocate empty space in some section.  The .zero\n    pseudo-op is used for this on most svr4 assemblers.  */\n \n #define SKIP_ASM_OP\t\".zero\"\n \n-#undef ASM_OUTPUT_SKIP\n-#define ASM_OUTPUT_SKIP(FILE,SIZE) \\\n+#undef  ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(FILE, SIZE) \\\n   fprintf (FILE, \"\\t%s\\t%u\\n\", SKIP_ASM_OP, (SIZE))\n \n-/* This is how to output a reference to a user-level label named NAME.\n-   `assemble_name' uses this.\n-\n-   For System V Release 4 the convention is *not* to prepend a leading\n-   underscore onto user-level symbol names.  */\n-\n-#undef ASM_OUTPUT_LABELREF\n-#define ASM_OUTPUT_LABELREF(FILE,NAME) fprintf (FILE, \"%s\", NAME)\n-\n /* This is how to output an internal numbered label where\n    PREFIX is the class of label and NUM is the number within the class.\n \n    For most svr4 systems, the convention is that any symbol which begins\n    with a period is not put into the linker symbol table by the assembler.  */\n \n-#undef ASM_OUTPUT_INTERNAL_LABEL\n-#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM);\t\t\t\t\\\n-} while (0)\n+#undef  ASM_OUTPUT_INTERNAL_LABEL\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM)\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM);\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* This is how to store into the string LABEL\n    the symbol_ref name of an internal numbered label where\n@@ -142,11 +166,13 @@ do {\t\t\t\t\t\t\t\t\t\\\n    For most svr4 systems, the convention is that any symbol which begins\n    with a period is not put into the linker symbol table by the assembler.  */\n \n-#undef ASM_GENERATE_INTERNAL_LABEL\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  sprintf (LABEL, \"*.%s%d\", PREFIX, NUM);\t\t\t\t\\\n-} while (0)\n+#undef  ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      sprintf (LABEL, \"*.%s%d\", PREFIX, (unsigned) (NUM));\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Output the label which precedes a jumptable.  Note that for all svr4\n    systems where we actually generate jumptables (which is to say every\n@@ -159,22 +185,24 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define ALIGN_ASM_OP \".align\"\n \n #ifndef ASM_OUTPUT_BEFORE_CASE_LABEL\n-#define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE,PREFIX,NUM,TABLE) \\\n+#define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE, PREFIX, NUM, TABLE) \\\n   ASM_OUTPUT_ALIGN ((FILE), 2);\n #endif\n \n-#undef ASM_OUTPUT_CASE_LABEL\n-#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,JUMPTABLE)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    ASM_OUTPUT_BEFORE_CASE_LABEL (FILE, PREFIX, NUM, JUMPTABLE)\t\t\\\n-    ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM);\t\t\t\\\n-  } while (0)\n+#undef  ASM_OUTPUT_CASE_LABEL\n+#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, JUMPTABLE)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      ASM_OUTPUT_BEFORE_CASE_LABEL (FILE, PREFIX, NUM, JUMPTABLE)\t\\\n+\tASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* The standard SVR4 assembler seems to require that certain builtin\n    library routines (e.g. .udiv) be explicitly declared as .globl\n    in each assembly file where they are referenced.  */\n \n-#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)\t\t\t\t\\\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)\t\\\n   ASM_GLOBALIZE_LABEL (FILE, XSTR (FUN, 0))\n \n /* This says how to output assembler code to declare an\n@@ -184,13 +212,15 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define COMMON_ASM_OP\t\".comm\"\n \n-#undef ASM_OUTPUT_ALIGNED_COMMON\n+#undef  ASM_OUTPUT_ALIGNED_COMMON\n #define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf ((FILE), \"\\t%s\\t\", COMMON_ASM_OP);\t\t\t\t\\\n-  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n-  fprintf ((FILE), \",%u,%u\\n\", (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n-} while (0)\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\t%s\\t\", COMMON_ASM_OP);\t\t\t\\\n+      assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+      fprintf ((FILE), \",%u,%u\\n\", (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* This says how to output assembler code to declare an\n    uninitialized internal linkage data object.  Under SVR4,\n@@ -199,14 +229,16 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define LOCAL_ASM_OP\t\".local\"\n \n-#undef ASM_OUTPUT_ALIGNED_LOCAL\n-#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf ((FILE), \"\\t%s\\t\", LOCAL_ASM_OP);\t\t\t\t\\\n-  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n-  fprintf ((FILE), \"\\n\");\t\t\t\t\t\t\\\n-  ASM_OUTPUT_ALIGNED_COMMON (FILE, NAME, SIZE, ALIGN);\t\t\t\\\n-} while (0)\n+#undef  ASM_OUTPUT_ALIGNED_LOCAL\n+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\t%s\\t\", LOCAL_ASM_OP);\t\t\t\\\n+      assemble_name ((FILE), (NAME));\t\t\t\t\\\n+      fprintf ((FILE), \"\\n\");\t\t\t\t\t\\\n+      ASM_OUTPUT_ALIGNED_COMMON (FILE, NAME, SIZE, ALIGN);\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* This is the pseudo-op used to generate a 32-bit word of data with a\n    specific value in some section.  This is the same for all known svr4\n@@ -218,7 +250,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    values from a double-quoted string WITHOUT HAVING A TERMINATING NUL\n    AUTOMATICALLY APPENDED.  This is the same for most svr4 assemblers.  */\n \n-#undef ASCII_DATA_ASM_OP\n+#undef  ASCII_DATA_ASM_OP\n #define ASCII_DATA_ASM_OP\t\".ascii\"\n \n /* Support const sections and the ctors and dtors sections for g++.\n@@ -231,7 +263,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define USE_CONST_SECTION\t1\n \n-#define CONST_SECTION_ASM_OP\t\".section\\t.rodata\"\n+#define CONST_SECTION_ASM_OP\t\"\\t.section\\t.rodata\"\n \n /* Define the pseudo-ops used to switch to the .ctors and .dtors sections.\n \n@@ -248,206 +280,234 @@ do {\t\t\t\t\t\t\t\t\t\\\n    errors unless the .ctors and .dtors sections are marked as writable\n    via the SHF_WRITE attribute.)  */\n \n-#define CTORS_SECTION_ASM_OP\t\".section\\t.ctors,\\\"aw\\\"\"\n-#define DTORS_SECTION_ASM_OP\t\".section\\t.dtors,\\\"aw\\\"\"\n+#define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"aw\\\"\"\n+#define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"aw\\\"\"\n \n /* On svr4, we *do* have support for the .init and .fini sections, and we\n    can put stuff in there to be executed before and after `main'.  We let\n    crtstuff.c and other files know this by defining the following symbols.\n    The definitions say how to change sections to the .init and .fini\n    sections.  This is the same for all known svr4 assemblers.  */\n \n-#define INIT_SECTION_ASM_OP\t\".section\\t.init\"\n-#define FINI_SECTION_ASM_OP\t\".section\\t.fini\"\n+#define INIT_SECTION_ASM_OP\t\"\\t.section\\t.init\"\n+#define FINI_SECTION_ASM_OP\t\"\\t.section\\t.fini\"\n \n /* A default list of other sections which we might be \"in\" at any given\n    time.  For targets that use additional sections (e.g. .tdesc) you\n    should override this definition in the target-specific file which\n    includes this file.  */\n \n-#undef EXTRA_SECTIONS\n+#undef  EXTRA_SECTIONS\n #define EXTRA_SECTIONS in_const, in_ctors, in_dtors\n \n /* A default list of extra section function definitions.  For targets\n    that use additional sections (e.g. .tdesc) you should override this\n    definition in the target-specific file which includes this file.  */\n \n-#undef EXTRA_SECTION_FUNCTIONS\n-#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n-  CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n-  CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+#undef  EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\\\n+  CONST_SECTION_FUNCTION\t\t\\\n+  CTORS_SECTION_FUNCTION\t\t\\\n   DTORS_SECTION_FUNCTION\n \n #define READONLY_DATA_SECTION() const_section ()\n \n-#define CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-const_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (!USE_CONST_SECTION)\t\t\t\t\t\t\\\n-    text_section();\t\t\t\t\t\t\t\\\n-  else if (in_section != in_const)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"\\t%s\\n\", CONST_SECTION_ASM_OP);\t\t\\\n-      in_section = in_const;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n+#define CONST_SECTION_FUNCTION\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+const_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (!USE_CONST_SECTION)\t\t\t\t\t\\\n+    text_section ();\t\t\t\t\t\t\\\n+  else if (in_section != in_const)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\t%s\\n\", CONST_SECTION_ASM_OP);\t\\\n+      in_section = in_const;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n }\n \n-#define CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-ctors_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_ctors)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"\\t%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n-      in_section = in_ctors;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n+#define CTORS_SECTION_FUNCTION\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\t%s\\n\", CTORS_SECTION_ASM_OP);\t\\\n+      in_section = in_ctors;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n }\n \n-#define DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-dtors_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_dtors)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"\\t%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n-      in_section = in_dtors;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n+#define DTORS_SECTION_FUNCTION\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\t%s\\n\", DTORS_SECTION_ASM_OP);\t\\\n+      in_section = in_dtors;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n }\n \n-/* Switch into a generic section.\n-   This is currently only used to support section attributes.  */\n+#define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)\n \n-#define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME, RELOC)\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  static struct section_info\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      struct section_info *next;\t\t\t\t        \\\n-      char *name;\t\t\t\t\t\t        \\\n-      enum sect_enum {SECT_RW, SECT_RO, SECT_EXEC} type;\t\t\\\n-    } *sections;\t\t\t\t\t\t\t\\\n-  struct section_info *s;\t\t\t\t\t\t\\\n-  char *mode;\t\t\t\t\t\t\t\t\\\n-  enum sect_enum type;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  for (s = sections; s; s = s->next)\t\t\t\t\t\\\n-    if (!strcmp (NAME, s->name))\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (DECL && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n-    type = SECT_EXEC, mode = \"ax\";\t\t\t\t\t\\\n-  else if (DECL && DECL_READONLY_SECTION (DECL, RELOC))\t\t\t\\\n-    type = SECT_RO, mode = \"a\";\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    type = SECT_RW, mode = \"aw\";\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (s == 0)\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      s = (struct section_info *) xmalloc (sizeof (struct section_info));  \\\n-      s->name = xmalloc ((strlen (NAME) + 1) * sizeof (*NAME));\t\t\\\n-      strcpy (s->name, NAME);\t\t\t\t\t\t\\\n-      s->type = type;\t\t\t\t\t\t\t\\\n-      s->next = sections;\t\t\t\t\t\t\\\n-      sections = s;\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.section\\t%s,\\\"%s\\\",@progbits\\n\", NAME, mode);\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (DECL && s->type != type)\t\t\t\t\t\\\n-\terror_with_decl (DECL, \"%s causes a section type conflict\");\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.section\\t%s\\n\", NAME);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n+#define UNIQUE_SECTION_P(DECL)   (DECL_ONE_ONLY (DECL))\n \n-#define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)\n-#define UNIQUE_SECTION_P(DECL) (DECL_ONE_ONLY (DECL))\n-#define UNIQUE_SECTION(DECL,RELOC)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  int len;\t\t\t\t\t\t\t\\\n-  char *name, *string, *prefix;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (DECL));\t\\\n-\t\t\t\t\t\t\t\t\\\n-  if (! DECL_ONE_ONLY (DECL))\t\t\t\t\t\\\n+#define UNIQUE_SECTION(DECL, RELOC)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n+      int len;\t\t\t\t\t\t\t\\\n+      int sec;\t\t\t\t\t\t\t\\\n+      char *name;\t\t\t\t\t\t\\\n+      char *string;\t\t\t\t\t\t\\\n+      char *prefix;\t\t\t\t\t\t\\\n+      static char *prefixes[4][2] =\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\t{ \".text.\",   \".gnu.linkonce.t.\" },\t\t\t\\\n+\t{ \".rodata.\", \".gnu.linkonce.r.\" },\t\t\t\\\n+\t{ \".data.\",   \".gnu.linkonce.d.\" },\t\t\t\\\n+\t/* Do not generate unique sections for uninitialised \t\\\n+\t   data since we do not have support for this in the    \\\n+\t   linker scripts yet...\t\t\t\t\\\n+        { \".bss.\",    \".gnu.linkonce.b.\" }  */\t\t\t\\\n+\t{ \"\", \"\" }\t\t\t\t\t\t\\\n+      };\t\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\\\n       if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n-\tprefix = \".text.\";\t\t\t\t\t\\\n+\tsec = 0;\t\t\t\t\t\t\\\n+      else if (DECL_INITIAL (DECL) == 0\t\t\t\t\\\n+\t       || DECL_INITIAL (DECL) == error_mark_node)\t\\\n+\tsec = 3;\t\t\t\t\t\t\\\n       else if (DECL_READONLY_SECTION (DECL, RELOC))\t\t\\\n-\tprefix = \".rodata.\";\t\t\t\t\t\\\n+\tsec = 1;\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\\\n-\tprefix = \".data.\";\t\t\t\t\t\\\n+\tsec = 2;\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\\\n+      name   = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (DECL));\t\\\n+      prefix = prefixes[sec][DECL_ONE_ONLY(DECL)];\t\t\\\n+      len    = strlen (name) + strlen (prefix);\t\t\t\\\n+      string = alloca (len + 1);\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\\\n+      sprintf (string, \"%s%s\", prefix, name);\t\t\t\\\n+      \t\t\t\t\t\t\t\t\\\n+      DECL_SECTION_NAME (DECL) = build_string (len, string);\t\\\n     }\t\t\t\t\t\t\t\t\\\n-  else if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n-    prefix = \".gnu.linkonce.t.\";\t\t\t\t\\\n-  else if (DECL_READONLY_SECTION (DECL, RELOC))\t\t\t\\\n-    prefix = \".gnu.linkonce.r.\";\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    prefix = \".gnu.linkonce.d.\";\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  len = strlen (name) + strlen (prefix);\t\t\t\\\n-  string = alloca (len + 1);\t\t\t\t\t\\\n-  sprintf (string, \"%s%s\", prefix, name);\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  DECL_SECTION_NAME (DECL) = build_string (len, string);\t\\\n-} while (0)\n-/* A C statement (sans semicolon) to output an element in the table of\n-   global constructors.  */\n-#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    ctors_section ();\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t%s\\t \", INT_ASM_OP);\t\t\t\t\\\n-    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n-  } while (0)\n-\n-/* A C statement (sans semicolon) to output an element in the table of\n-   global destructors.  */\n-#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    dtors_section ();                   \t\t\t\t\\\n-    fprintf (FILE, \"\\t%s\\t \", INT_ASM_OP);\t\t\t\t\\\n-    assemble_name (FILE, NAME);              \t\t\t\t\\\n-    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n-  } while (0)\n+  while (0)\n+     \n+/* A C statement (sans semicolon) to output an\n+   element in the table of global constructors.  */\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE, NAME)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      ctors_section ();\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t%s\\t \", INT_ASM_OP);\t\t\t\\\n+      assemble_name (FILE, NAME);\t\t\t\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n-/* A C statement or statements to switch to the appropriate\n-   section for output of DECL.  DECL is either a `VAR_DECL' node\n-   or a constant of some sort.  RELOC indicates whether forming\n-   the initial value of DECL requires link-time relocations.  */\n+/* A C statement (sans semicolon) to output an\n+   element in the table of global destructors.  */\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      dtors_section ();                   \t\t\t\\\n+      fprintf (FILE, \"\\t%s\\t \", INT_ASM_OP);\t\t\t\\\n+      assemble_name (FILE, NAME);              \t\t\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n-#define SELECT_SECTION(DECL,RELOC)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (TREE_CODE (DECL) == STRING_CST)\t\t\t\t\t\\\n+/* Switch into a generic section.\n+ \n+   We make the section read-only and executable for a function decl,\n+   read-only for a const data decl, and writable for a non-const data decl.\n+ \n+   If the section has already been defined, we must not\n+   emit the attributes here. The SVR4 assembler does not\n+   recognize section redefinitions.\n+   If DECL is NULL, no attributes are emitted.  */\n+\n+#define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME, RELOC)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      if (! flag_writable_strings)\t\t\t\t\t\\\n-\tconst_section ();\t\t\t\t\t\t\\\n+      static struct section_info\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tstruct section_info *next;\t\t\t\t        \\\n+\tchar *name;\t\t\t\t\t\t        \\\n+\tenum sect_enum {SECT_RW, SECT_RO, SECT_EXEC} type;\t\t\\\n+      } *sections;\t\t\t\t\t\t\t\\\n+      struct section_info *s;\t\t\t\t\t\t\\\n+      const char *mode;\t\t\t\t\t\t\t\\\n+      enum sect_enum type;\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+      for (s = sections; s; s = s->next)\t\t\t\t\\\n+\tif (!strcmp (NAME, s->name))\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+      if (DECL && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n+\ttype = SECT_EXEC, mode = \"ax\";\t\t\t\t\t\\\n+      else if (DECL && DECL_READONLY_SECTION (DECL, RELOC))\t\t\\\n+\ttype = SECT_RO, mode = \"a\";\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n-\tdata_section ();\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if ((flag_pic && RELOC)\t\t\t\t\t\t\\\n-\t  || !TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL)\t\t\\\n-\t  || !DECL_INITIAL (DECL)\t\t\t\t\t\\\n-\t  || (DECL_INITIAL (DECL) != error_mark_node\t\t\t\\\n-\t      && !TREE_CONSTANT (DECL_INITIAL (DECL))))\t\t\t\\\n-\tdata_section ();\t\t\t\t\t\t\\\n+\ttype = SECT_RW, mode = \"aw\";\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+      if (s == 0)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  s = (struct section_info *) xmalloc (sizeof (* s));\t\t\\\n+\t  s->name = xmalloc ((strlen (NAME) + 1) * sizeof (* NAME));\t\\\n+\t  strcpy (s->name, NAME);\t\t\t\t\t\\\n+\t  s->type = type;\t\t\t\t\t\t\\\n+\t  s->next = sections;\t\t\t\t\t\t\\\n+\t  sections = s;\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t.section\\t%s,\\\"%s\\\",@progbits\\n\",\t\t\\\n+\t\t   NAME, mode);\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n-\tconst_section ();\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (DECL && s->type != type)\t\t\t\t\t\\\n+\t    error_with_decl (DECL, \"%s causes a section type conflict\");\\\n+\t  \t\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t.section\\t%s\\n\", NAME);\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    const_section ();\t\t\t\t\t\t\t\\\n-}\n+  while (0)\n \n /* A C statement or statements to switch to the appropriate\n    section for output of RTX in mode MODE.  RTX is some kind\n    of constant in RTL.  The argument MODE is redundant except\n    in the case of a `const_int' rtx.  Currently, these always\n    go into the const section.  */\n \n-#undef SELECT_RTX_SECTION\n-#define SELECT_RTX_SECTION(MODE,RTX) const_section()\n+#undef  SELECT_RTX_SECTION\n+#define SELECT_RTX_SECTION(MODE, RTX) const_section ()\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of DECL.  DECL is either a `VAR_DECL' node\n+   or a constant of some sort.  RELOC indicates whether forming\n+   the initial value of DECL requires link-time relocations.  */\n+\n+#define SELECT_SECTION(DECL, RELOC)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (TREE_CODE (DECL) == STRING_CST)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (! flag_writable_strings)\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if ((flag_pic && RELOC)\t\t\t\t\t\\\n+\t  || !TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL)\t\\\n+\t  || !DECL_INITIAL (DECL)\t\t\t\t\\\n+\t  || (DECL_INITIAL (DECL) != error_mark_node\t\t\\\n+\t      && !TREE_CONSTANT (DECL_INITIAL (DECL))))\t\t\\\n+\tdata_section ();\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    const_section ();\t\t\t\t\t\t\\\n+}\n \n /* Define the strings used for the special svr4 .type and .size directives.\n    These strings generally do not vary from one system running svr4 to\n@@ -460,9 +520,14 @@ do {\t\t\t\t\t\t\t\t\\\n \n /* This is how we tell the assembler that a symbol is weak.  */\n \n-#define ASM_WEAKEN_LABEL(FILE,NAME) \\\n-  do { fputs (\"\\t.weak\\t\", FILE); assemble_name (FILE, NAME); \\\n-       fputc ('\\n', FILE); } while (0)\n+#define ASM_WEAKEN_LABEL(FILE, NAME) \t\\\n+  do\t\t\t\t\t\\\n+    {\t\t\t\t\t\\\n+      fputs (\"\\t.weak\\t\", (FILE));\t\\\n+      assemble_name ((FILE), (NAME)); \t\\\n+      fputc ('\\n', (FILE));\t\t\\\n+    }\t\t\t\t\t\\\n+  while (0)\n \n /* The following macro defines the format used to output the second\n    operand of the .type assembler directive.  Different svr4 assemblers\n@@ -490,78 +555,102 @@ do {\t\t\t\t\t\t\t\t\\\n    function's return value.  We allow for that here.  */\n \n #ifndef ASM_DECLARE_FUNCTION_NAME\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n-    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n-    putc (',', FILE);\t\t\t\t\t\t\t\\\n-    fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\t\t\\\n-    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n-    ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\t\\\n-    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n-  } while (0)\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\\\n+      assemble_name (FILE, NAME);\t\t\t\\\n+      putc (',', FILE);\t\t\t\t\t\\\n+      fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\\\n+      putc ('\\n', FILE);\t\t\t\t\\\n+      \t\t\t\t\t\t\t\\\n+      ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\\\n+      ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n #endif\n+\n /* Write the extra assembler code needed to declare an object properly.  */\n \n-#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n-    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n-    putc (',', FILE);\t\t\t\t\t\t\t\\\n-    fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\t\t\\\n-    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n-    size_directive_output = 0;\t\t\t\t\t\t\\\n-    if (!flag_inhibit_size_directive && DECL_SIZE (DECL))\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tsize_directive_output = 1;\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n-\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n-\tfprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL)));\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n-  } while (0)\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\\\n+      assemble_name (FILE, NAME);\t\t\t\t\\\n+      putc (',', FILE);\t\t\t\t\t\t\\\n+      fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\\\n+      putc ('\\n', FILE);\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\\\n+      size_directive_output = 0;\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\\\n+      if (!flag_inhibit_size_directive && DECL_SIZE (DECL))\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  size_directive_output = 1;\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\\\n+\t  assemble_name (FILE, NAME);\t\t\t\t\\\n+\t  putc (',', FILE);\t\t\t\t\t\\\n+\t  fprintf (FILE, HOST_WIDE_INT_PRINT_DEC,\t\t\\\n+\t\t   int_size_in_bytes (TREE_TYPE (DECL)));\t\\\n+\t  fputc ('\\n', FILE);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\\\n+      ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Output the size directive for a decl in rest_of_decl_compilation\n    in the case where we did not do so before the initializer.\n    Once we find the error_mark_node, we know that the value of\n    size_directive_output was set\n    by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */\n \n-#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t \\\n-do {\t\t\t\t\t\t\t\t\t \\\n-     char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t\t \\\n-     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t \\\n-         && ! AT_END && TOP_LEVEL\t\t\t\t\t \\\n-\t && DECL_INITIAL (DECL) == error_mark_node\t\t\t \\\n-\t && !size_directive_output)\t\t\t\t\t \\\n-       {\t\t\t\t\t\t\t\t \\\n-\t size_directive_output = 1;\t\t\t\t\t \\\n-\t fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t \\\n-\t assemble_name (FILE, name);\t\t\t\t\t \\\n-\t fprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL))); \\\n-       }\t\t\t\t\t\t\t\t \\\n-   } while (0)\n+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      const char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\\\n+      \t\t\t\t\t\t\t\t\\\n+      if (!flag_inhibit_size_directive\t\t\t\t\\\n+\t  && DECL_SIZE (DECL)\t\t\t\t\t\\\n+\t  && ! AT_END && TOP_LEVEL\t\t\t\t\\\n+\t  && DECL_INITIAL (DECL) == error_mark_node\t\t\\\n+\t  && !size_directive_output)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  size_directive_output = 1;\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\\\n+\t  assemble_name (FILE, name);\t\t\t\t\\\n+\t  putc (',', FILE);\t\t\t\t\t\\\n+\t  fprintf (FILE, HOST_WIDE_INT_PRINT_DEC,\t\t\\\n+\t\t   int_size_in_bytes (TREE_TYPE (DECL))); \t\\\n+\t  fputc ('\\n', FILE);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* This is how to declare the size of a function.  */\n #ifndef ASM_DECLARE_FUNCTION_SIZE\n-#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-        char label[256];\t\t\t\t\t\t\\\n-\tstatic int labelno;\t\t\t\t\t\t\\\n-\tlabelno++;\t\t\t\t\t\t\t\\\n-\tASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\t\\\n-\tASM_OUTPUT_INTERNAL_LABEL (FILE, \"Lfe\", labelno);\t\t\\\n-\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n-\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n-        fprintf (FILE, \",\");\t\t\t\t\t\t\\\n-\tassemble_name (FILE, label);\t\t\t\t\t\\\n-        fprintf (FILE, \"-\");\t\t\t\t\t\t\\\n-\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n-\tputc ('\\n', FILE);\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (!flag_inhibit_size_directive)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  char label[256];\t\t\t\t\t\\\n+\t  static int labelno;\t\t\t\t\t\\\n+\t  \t\t\t\t\t\t\t\\\n+\t  labelno++;\t\t\t\t\t\t\\\n+\t  \t\t\t\t\t\t\t\\\n+\t  ASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\\\n+\t  ASM_OUTPUT_INTERNAL_LABEL (FILE, \"Lfe\", labelno);\t\\\n+\t  \t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\\\n+\t  assemble_name (FILE, (FNAME));\t\t\t\\\n+\t  fprintf (FILE, \",\");\t\t\t\t\t\\\n+\t  assemble_name (FILE, label);\t\t\t\t\\\n+\t  fprintf (FILE, \"-\");\t\t\t\t\t\\\n+\t  assemble_name (FILE, (FNAME));\t\t\t\\\n+\t  putc ('\\n', FILE);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n #endif\n \n /* A table of bytes codes used by the ASM_OUTPUT_ASCII and\n@@ -611,31 +700,36 @@ do {\t\t\t\t\t\t\t\t\t \\\n    (where the only alternative is to output character sequences as\n    comma separated lists of numbers).   */\n \n-#define ASM_OUTPUT_LIMITED_STRING(FILE, STR)\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      register unsigned char *_limited_str = (unsigned char *) (STR);\t\\\n-      register unsigned ch;\t\t\t\t\t\t\\\n-      fprintf ((FILE), \"\\t%s\\t\\\"\", STRING_ASM_OP);\t\t\t\\\n-      for (; ch = *_limited_str; _limited_str++)\t\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-\t  register int escape;\t\t\t\t\t\t\\\n-\t  switch (escape = ESCAPES[ch])\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t    case 0:\t\t\t\t\t\t\t\\\n-\t      putc (ch, (FILE));\t\t\t\t\t\\\n-\t      break;\t\t\t\t\t\t\t\\\n-\t    case 1:\t\t\t\t\t\t\t\\\n-\t      fprintf ((FILE), \"\\\\%03o\", ch);\t\t\t\t\\\n-\t      break;\t\t\t\t\t\t\t\\\n-\t    default:\t\t\t\t\t\t\t\\\n-\t      putc ('\\\\', (FILE));\t\t\t\t\t\\\n-\t      putc (escape, (FILE));\t\t\t\t\t\\\n-\t      break;\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-      fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n+#define ASM_OUTPUT_LIMITED_STRING(FILE, STR)\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      register const unsigned char *_limited_str =\t\\\n+\t(const unsigned char *) (STR);\t\t\t\\\n+      register unsigned ch;\t\t\t\t\\\n+      \t\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\t%s\\t\\\"\", STRING_ASM_OP);\t\\\n+      \t\t\t\t\t\t\t\\\n+      for (; ch = *_limited_str; _limited_str++)\t\\\n+        {\t\t\t\t\t\t\\\n+\t  register int escape;\t\t\t\t\\\n+\t  \t\t\t\t\t\t\\\n+\t  switch (escape = ESCAPES[ch])\t\t\t\\\n+\t    {\t\t\t\t\t\t\\\n+\t    case 0:\t\t\t\t\t\\\n+\t      putc (ch, (FILE));\t\t\t\\\n+\t      break;\t\t\t\t\t\\\n+\t    case 1:\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"\\\\%03o\", ch);\t\t\\\n+\t      break;\t\t\t\t\t\\\n+\t    default:\t\t\t\t\t\\\n+\t      putc ('\\\\', (FILE));\t\t\t\\\n+\t      putc (escape, (FILE));\t\t\t\\\n+\t      break;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n   while (0)\n \n /* The routine used to output sequences of byte values.  We use a special\n@@ -645,39 +739,47 @@ do {\t\t\t\t\t\t\t\t\t \\\n    character sequence which end with NUL (and which are shorter than\n    STRING_LIMIT) we output those using ASM_OUTPUT_LIMITED_STRING.  */\n \n-#undef ASM_OUTPUT_ASCII\n+#undef  ASM_OUTPUT_ASCII\n #define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)\t\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      register unsigned char *_ascii_bytes = (unsigned char *) (STR);\t\\\n-      register unsigned char *limit = _ascii_bytes + (LENGTH);\t\t\\\n+      register const unsigned char *_ascii_bytes =\t\t\t\\\n+\t(const unsigned char *) (STR);\t\t\t\t\t\\\n+      register const unsigned char *limit = _ascii_bytes + (LENGTH);\t\\\n       register unsigned bytes_in_chunk = 0;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n       for (; _ascii_bytes < limit; _ascii_bytes++)\t\t\t\\\n         {\t\t\t\t\t\t\t\t\\\n-\t  register unsigned char *p;\t\t\t\t\t\\\n+\t  register const unsigned char *p;\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n \t  if (bytes_in_chunk >= 60)\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n \t      fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\\n \t      bytes_in_chunk = 0;\t\t\t\t\t\\\n \t    }\t\t\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n \t  for (p = _ascii_bytes; p < limit && *p != '\\0'; p++)\t\t\\\n \t    continue;\t\t\t\t\t\t\t\\\n-\t  if (p < limit && (p - _ascii_bytes) <= STRING_LIMIT)\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+\t  if (p < limit && (p - _ascii_bytes) <= (long)STRING_LIMIT)\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n \t      if (bytes_in_chunk > 0)\t\t\t\t\t\\\n \t\t{\t\t\t\t\t\t\t\\\n \t\t  fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\\\n \t\t  bytes_in_chunk = 0;\t\t\t\t\t\\\n \t\t}\t\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n \t      ASM_OUTPUT_LIMITED_STRING ((FILE), _ascii_bytes);\t\t\\\n \t      _ascii_bytes = p;\t\t\t\t\t\t\\\n \t    }\t\t\t\t\t\t\t\t\\\n \t  else\t\t\t\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n \t      register int escape;\t\t\t\t\t\\\n \t      register unsigned ch;\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n \t      if (bytes_in_chunk == 0)\t\t\t\t\t\\\n \t\tfprintf ((FILE), \"\\t%s\\t\\\"\", ASCII_DATA_ASM_OP);\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n \t      switch (escape = ESCAPES[ch = *_ascii_bytes])\t\t\\\n \t\t{\t\t\t\t\t\t\t\\\n \t\tcase 0:\t\t\t\t\t\t\t\\\n@@ -696,10 +798,8 @@ do {\t\t\t\t\t\t\t\t\t \\\n \t\t}\t\t\t\t\t\t\t\\\n \t    }\t\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n       if (bytes_in_chunk > 0)\t\t\t\t\t\t\\\n         fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n-\n-/* All SVR4 targets use the ELF object file format.  */\n-#define OBJECT_FORMAT_ELF"}, {"sha": "a1ebaa6513c5708237cb972e782f5e8fa50eaf96", "filename": "gcc/config/svr4.h", "status": "modified", "additions": 16, "deletions": 705, "changes": 721, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6cad4c9e950e2985565e7d0ca6bc2eb6af2c776/gcc%2Fconfig%2Fsvr4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6cad4c9e950e2985565e7d0ca6bc2eb6af2c776/gcc%2Fconfig%2Fsvr4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsvr4.h?ref=f6cad4c9e950e2985565e7d0ca6bc2eb6af2c776", "patch": "@@ -1,6 +1,6 @@\n /* Operating system specific defines to be used when targeting GCC for some\n    generic System V Release 4 system.\n-   Copyright (C) 1991, 94-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 94-99, 2000 Free Software Foundation, Inc.\n    Contributed by Ron Guilmette (rfg@monkeys.com).\n \n This file is part of GNU CC.\n@@ -42,17 +42,19 @@ Boston, MA 02111-1307, USA.\n /* Define a symbol indicating that we are using svr4.h.  */\n #define USING_SVR4_H\n \n+#include \"elfos.h\"\n+\n /* Cpp, assembler, linker, library, and startfile spec's.  */\n \n /* This defines which switch letters take arguments.  On svr4, most of\n    the normal cases (defined in gcc.c) apply, and we also have -h* and\n    -z* options (for the linker).  Note however that there is no such\n    thing as a -T option for svr4.  */\n \n-#define SWITCH_TAKES_ARG(CHAR) \\\n-  (DEFAULT_SWITCH_TAKES_ARG (CHAR) \\\n-   || (CHAR) == 'h' \\\n-   || (CHAR) == 'x' \\\n+#define SWITCH_TAKES_ARG(CHAR)\t\t\\\n+  (DEFAULT_SWITCH_TAKES_ARG (CHAR)\t\\\n+   || (CHAR) == 'h'\t\t\t\\\n+   || (CHAR) == 'x'\t\t\t\\\n    || (CHAR) == 'z')\n \n /* This defines which multi-letter switches take arguments.  On svr4,\n@@ -85,7 +87,7 @@ Boston, MA 02111-1307, USA.\n    option.\n */\n \n-#undef ASM_SPEC\n+#undef  ASM_SPEC\n #define ASM_SPEC \\\n   \"%{v:-V} %{Qy:} %{!Qn:-Qy} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*}\"\n \n@@ -97,22 +99,22 @@ Boston, MA 02111-1307, USA.\n    cause totally confuse the assembler, resulting in many spurious error\n    messages.  */\n \n-#undef ASM_FINAL_SPEC\n+#undef  ASM_FINAL_SPEC\n #define ASM_FINAL_SPEC \"%|\"\n \n /* Under svr4, the normal location of the `ld' and `as' programs is the\n    /usr/ccs/bin directory.  */\n \n #ifndef CROSS_COMPILE\n-#undef MD_EXEC_PREFIX\n+#undef  MD_EXEC_PREFIX\n #define MD_EXEC_PREFIX \"/usr/ccs/bin/\"\n #endif\n \n /* Under svr4, the normal location of the various *crt*.o files is the\n    /usr/ccs/lib directory.  */\n \n #ifndef CROSS_COMPILE\n-#undef MD_STARTFILE_PREFIX\n+#undef  MD_STARTFILE_PREFIX\n #define MD_STARTFILE_PREFIX \"/usr/ccs/lib/\"\n #endif\n \n@@ -186,8 +188,7 @@ Boston, MA 02111-1307, USA.\n    The SVR4 library routines query the value of `_lib_version' at run\n    to decide how they should behave.  Specifically, they decide (based\n    upon the value of `_lib_version') if they will act in a strictly ANSI\n-   conforming manner or not.\n-*/\n+   conforming manner or not.  */\n \n #undef\tSTARTFILE_SPEC\n #define STARTFILE_SPEC \"%{!shared: \\\n@@ -200,54 +201,10 @@ Boston, MA 02111-1307, USA.\n \t\t\t %{!traditional:values-Xa.o%s}} \\\n  \t\t\tcrtbegin.o%s\"\n \n-/* Attach a special .ident directive to the end of the file to identify\n-   the version of GCC which compiled this code.  The format of the\n-   .ident string is patterned after the ones produced by native svr4\n-   C compilers.  */\n-\n-#define IDENT_ASM_OP \".ident\"\n-\n-#define ASM_FILE_END(FILE)\t\t\t\t\t\\\n-do {\t\t\t\t \t\t\t\t\\\n-     if (!flag_no_ident)\t\t\t\t\t\\\n-\tfprintf ((FILE), \"\\t%s\\t\\\"GCC: (GNU) %s\\\"\\n\",\t\t\\\n-\t\t IDENT_ASM_OP, version_string);\t\t\t\\\n-   } while (0)\n-\n /* Allow #sccs in preprocessor.  */\n \n #define SCCS_DIRECTIVE\n \n-/* Output #ident as a .ident.  */\n-\n-#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n-  fprintf (FILE, \"\\t%s\\t\\\"%s\\\"\\n\", IDENT_ASM_OP, NAME);\n-\n-/* Use periods rather than dollar signs in special g++ assembler names.  */\n-\n-#define NO_DOLLAR_IN_LABEL\n-\n-/* Writing `int' for a bitfield forces int alignment for the structure.  */\n-\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\n-/* Implicit library calls should use memcpy, not bcopy, etc.  */\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n-/* Handle #pragma weak and #pragma pack.  */\n-\n-#define HANDLE_SYSV_PRAGMA\n-\n-/* System V Release 4 uses DWARF debugging info.  */\n-\n-#define DWARF_DEBUGGING_INFO\n-\n-/* All ELF targets can support DWARF-2.  */\n-#ifndef DWARF2_DEBUGGING_INFO\n-#define DWARF2_DEBUGGING_INFO\n-#endif\n-\n /* The numbers used to denote specific machine registers in the System V\n    Release 4 DWARF debugging information are quite likely to be totally\n    different from the numbers used in BSD stabs debugging information\n@@ -259,668 +216,22 @@ do {\t\t\t\t \t\t\t\t\\\n \n #undef DBX_REGISTER_NUMBER\n \n-/* Use DWARF debugging info by default.  */\n-\n-#ifndef PREFERRED_DEBUGGING_TYPE\n-#define PREFERRED_DEBUGGING_TYPE DWARF_DEBUG\n-#endif\n-\n-/* But allow STABS to be supoorted as well.  */\n-#include \"dbxelf.h\"\n-\n /* Define the actual types of some ANSI-mandated types.  (These\n    definitions should work for most SVR4 systems).  */\n \n-#undef SIZE_TYPE\n+#undef  SIZE_TYPE\n #define SIZE_TYPE \"unsigned int\"\n \n-#undef PTRDIFF_TYPE\n+#undef  PTRDIFF_TYPE\n #define PTRDIFF_TYPE \"int\"\n \n-#undef WCHAR_TYPE\n+#undef  WCHAR_TYPE\n #define WCHAR_TYPE \"long int\"\n \n-#undef WCHAR_TYPE_SIZE\n+#undef  WCHAR_TYPE_SIZE\n #define WCHAR_TYPE_SIZE BITS_PER_WORD\n \n /* This causes trouble, because it requires the host machine\n    to support ANSI C.  */\n /* #define MULTIBYTE_CHARS */\n \n-#undef ASM_BYTE_OP\n-#define ASM_BYTE_OP\t\".byte\"\n-\n-#undef SET_ASM_OP\n-#define SET_ASM_OP\t\".set\"\n-\n-/* This is how to begin an assembly language file.  Most svr4 assemblers want\n-   at least a .file directive to come first, and some want to see a .version\n-   directive come right after that.  Here we just establish a default\n-   which generates only the .file directive.  If you need a .version\n-   directive for any specific target, you should override this definition\n-   in the target-specific file which includes this one.  */\n-\n-#undef ASM_FILE_START\n-#define ASM_FILE_START(FILE)                                    \\\n-  output_file_directive ((FILE), main_input_filename)\n-\n-/* This is how to allocate empty space in some section.  The .zero\n-   pseudo-op is used for this on most svr4 assemblers.  */\n-\n-#define SKIP_ASM_OP\t\".zero\"\n-\n-#undef ASM_OUTPUT_SKIP\n-#define ASM_OUTPUT_SKIP(FILE,SIZE) \\\n-  fprintf (FILE, \"\\t%s\\t%u\\n\", SKIP_ASM_OP, (SIZE))\n-\n-/* The prefix to add to user-visible assembler symbols.\n-\n-   For System V Release 4 the convention is *not* to prepend a leading\n-   underscore onto user-level symbol names.  */\n-\n-#undef USER_LABEL_PREFIX\n-#define USER_LABEL_PREFIX \"\"\n-\n-/* This is how to output an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-\n-   For most svr4 systems, the convention is that any symbol which begins\n-   with a period is not put into the linker symbol table by the assembler.  */\n-\n-#undef ASM_OUTPUT_INTERNAL_LABEL\n-#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM);\t\t\t\t\\\n-} while (0)\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.\n-\n-   For most svr4 systems, the convention is that any symbol which begins\n-   with a period is not put into the linker symbol table by the assembler.  */\n-\n-#undef ASM_GENERATE_INTERNAL_LABEL\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  sprintf (LABEL, \"*.%s%d\", PREFIX, (unsigned) (NUM));\t\t\t\\\n-} while (0)\n-\n-/* Output the label which precedes a jumptable.  Note that for all svr4\n-   systems where we actually generate jumptables (which is to say every\n-   svr4 target except i386, where we use casesi instead) we put the jump-\n-   tables into the .rodata section and since other stuff could have been\n-   put into the .rodata section prior to any given jumptable, we have to\n-   make sure that the location counter for the .rodata section gets pro-\n-   perly re-aligned prior to the actual beginning of the jump table.  */\n-\n-#define ALIGN_ASM_OP \".align\"\n-\n-#ifndef ASM_OUTPUT_BEFORE_CASE_LABEL\n-#define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE,PREFIX,NUM,TABLE) \\\n-  ASM_OUTPUT_ALIGN ((FILE), 2);\n-#endif\n-\n-#undef ASM_OUTPUT_CASE_LABEL\n-#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,JUMPTABLE)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    ASM_OUTPUT_BEFORE_CASE_LABEL (FILE, PREFIX, NUM, JUMPTABLE)\t\t\\\n-    ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM);\t\t\t\\\n-  } while (0)\n-\n-/* The standard SVR4 assembler seems to require that certain builtin\n-   library routines (e.g. .udiv) be explicitly declared as .globl\n-   in each assembly file where they are referenced.  */\n-\n-#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)\t\t\t\t\\\n-  ASM_GLOBALIZE_LABEL (FILE, XSTR (FUN, 0))\n-\n-/* This says how to output assembler code to declare an\n-   uninitialized external linkage data object.  Under SVR4,\n-   the linker seems to want the alignment of data objects\n-   to depend on their types.  We do exactly that here.  */\n-\n-#define COMMON_ASM_OP\t\".comm\"\n-\n-#undef ASM_OUTPUT_ALIGNED_COMMON\n-#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf ((FILE), \"\\t%s\\t\", COMMON_ASM_OP);\t\t\t\t\\\n-  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n-  fprintf ((FILE), \",%u,%u\\n\", (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n-} while (0)\n-\n-/* This says how to output assembler code to declare an\n-   uninitialized internal linkage data object.  Under SVR4,\n-   the linker seems to want the alignment of data objects\n-   to depend on their types.  We do exactly that here.  */\n-\n-#define LOCAL_ASM_OP\t\".local\"\n-\n-#undef ASM_OUTPUT_ALIGNED_LOCAL\n-#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf ((FILE), \"\\t%s\\t\", LOCAL_ASM_OP);\t\t\t\t\\\n-  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n-  fprintf ((FILE), \"\\n\");\t\t\t\t\t\t\\\n-  ASM_OUTPUT_ALIGNED_COMMON (FILE, NAME, SIZE, ALIGN);\t\t\t\\\n-} while (0)\n-\n-/* Biggest alignment supported by the object file format of this\n-   machine.  Use this macro to limit the alignment which can be\n-   specified using the `__attribute__ ((aligned (N)))' construct.  If\n-   not defined, the default value is `BIGGEST_ALIGNMENT'.  */\n-\n-#define MAX_OFILE_ALIGNMENT (32768*8)\n-\n-/* This is the pseudo-op used to generate a 32-bit word of data with a\n-   specific value in some section.  This is the same for all known svr4\n-   assemblers.  */\n-\n-#define INT_ASM_OP\t\t\".long\"\n-\n-/* This is the pseudo-op used to generate a contiguous sequence of byte\n-   values from a double-quoted string WITHOUT HAVING A TERMINATING NUL\n-   AUTOMATICALLY APPENDED.  This is the same for most svr4 assemblers.  */\n-\n-#undef ASCII_DATA_ASM_OP\n-#define ASCII_DATA_ASM_OP\t\".ascii\"\n-\n-/* Support const sections and the ctors and dtors sections for g++.\n-   Note that there appears to be two different ways to support const\n-   sections at the moment.  You can either #define the symbol\n-   READONLY_DATA_SECTION (giving it some code which switches to the\n-   readonly data section) or else you can #define the symbols\n-   EXTRA_SECTIONS, EXTRA_SECTION_FUNCTIONS, SELECT_SECTION, and\n-   SELECT_RTX_SECTION.  We do both here just to be on the safe side.  */\n-\n-#define USE_CONST_SECTION\t1\n-\n-#define CONST_SECTION_ASM_OP\t\"\\t.section\\t.rodata\"\n-\n-/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.\n-\n-   Note that we want to give these sections the SHF_WRITE attribute\n-   because these sections will actually contain data (i.e. tables of\n-   addresses of functions in the current root executable or shared library\n-   file) and, in the case of a shared library, the relocatable addresses\n-   will have to be properly resolved/relocated (and then written into) by\n-   the dynamic linker when it actually attaches the given shared library\n-   to the executing process.  (Note that on SVR4, you may wish to use the\n-   `-z text' option to the ELF linker, when building a shared library, as\n-   an additional check that you are doing everything right.  But if you do\n-   use the `-z text' option when building a shared library, you will get\n-   errors unless the .ctors and .dtors sections are marked as writable\n-   via the SHF_WRITE attribute.)  */\n-\n-#define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"aw\\\"\"\n-#define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"aw\\\"\"\n-\n-/* On svr4, we *do* have support for the .init and .fini sections, and we\n-   can put stuff in there to be executed before and after `main'.  We let\n-   crtstuff.c and other files know this by defining the following symbols.\n-   The definitions say how to change sections to the .init and .fini\n-   sections.  This is the same for all known svr4 assemblers.  */\n-\n-#define INIT_SECTION_ASM_OP\t\"\\t.section\\t.init\"\n-#define FINI_SECTION_ASM_OP\t\"\\t.section\\t.fini\"\n-\n-/* A default list of other sections which we might be \"in\" at any given\n-   time.  For targets that use additional sections (e.g. .tdesc) you\n-   should override this definition in the target-specific file which\n-   includes this file.  */\n-\n-#undef EXTRA_SECTIONS\n-#define EXTRA_SECTIONS in_const, in_ctors, in_dtors\n-\n-/* A default list of extra section function definitions.  For targets\n-   that use additional sections (e.g. .tdesc) you should override this\n-   definition in the target-specific file which includes this file.  */\n-\n-#undef EXTRA_SECTION_FUNCTIONS\n-#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n-  CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n-  CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n-  DTORS_SECTION_FUNCTION\n-\n-#define READONLY_DATA_SECTION() const_section ()\n-\n-#define CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-const_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (!USE_CONST_SECTION)\t\t\t\t\t\t\\\n-    text_section();\t\t\t\t\t\t\t\\\n-  else if (in_section != in_const)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", CONST_SECTION_ASM_OP);\t\t\\\n-      in_section = in_const;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-ctors_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_ctors)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n-      in_section = in_ctors;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-dtors_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_dtors)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n-      in_section = in_dtors;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Switch into a generic section.\n- \n-   We make the section read-only and executable for a function decl,\n-   read-only for a const data decl, and writable for a non-const data decl.\n- \n-   If the section has already been defined, we must not\n-   emit the attributes here. The SVR4 assembler does not\n-   recognize section redefinitions.\n-   If DECL is NULL, no attributes are emitted.  */\n-\n-#define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME, RELOC)\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  static struct section_info\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      struct section_info *next;\t\t\t\t        \\\n-      char *name;\t\t\t\t\t\t        \\\n-      enum sect_enum {SECT_RW, SECT_RO, SECT_EXEC} type;\t\t\\\n-    } *sections;\t\t\t\t\t\t\t\\\n-  struct section_info *s;\t\t\t\t\t\t\\\n-  const char *mode;\t\t\t\t\t\t\t\\\n-  enum sect_enum type;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  for (s = sections; s; s = s->next)\t\t\t\t\t\\\n-    if (!strcmp (NAME, s->name))\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (DECL && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n-    type = SECT_EXEC, mode = \"ax\";\t\t\t\t\t\\\n-  else if (DECL && DECL_READONLY_SECTION (DECL, RELOC))\t\t\t\\\n-    type = SECT_RO, mode = \"a\";\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    type = SECT_RW, mode = \"aw\";\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (s == 0)\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      s = (struct section_info *) xmalloc (sizeof (struct section_info));  \\\n-      s->name = xmalloc ((strlen (NAME) + 1) * sizeof (*NAME));\t\t\\\n-      strcpy (s->name, NAME);\t\t\t\t\t\t\\\n-      s->type = type;\t\t\t\t\t\t\t\\\n-      s->next = sections;\t\t\t\t\t\t\\\n-      sections = s;\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.section\\t%s,\\\"%s\\\",@progbits\\n\", NAME, mode);\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (DECL && s->type != type)\t\t\t\t\t\\\n-\terror_with_decl (DECL, \"%s causes a section type conflict\");\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.section\\t%s\\n\", NAME);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-#define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)\n-#define UNIQUE_SECTION_P(DECL) (DECL_ONE_ONLY (DECL))\n-#define UNIQUE_SECTION(DECL,RELOC)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  int len;\t\t\t\t\t\t\t\\\n-  const char *name, *prefix;\t\t\t\t\t\\\n-  char *string;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (DECL));\t\\\n-\t\t\t\t\t\t\t\t\\\n-  if (! DECL_ONE_ONLY (DECL))\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      prefix = \".\";                                             \\\n-      if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n-\tprefix = \".text.\";\t\t\t\t\t\\\n-      else if (DECL_READONLY_SECTION (DECL, RELOC))\t\t\\\n-\tprefix = \".rodata.\";\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\tprefix = \".data.\";\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n-    prefix = \".gnu.linkonce.t.\";\t\t\t\t\\\n-  else if (DECL_READONLY_SECTION (DECL, RELOC))\t\t\t\\\n-    prefix = \".gnu.linkonce.r.\";\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    prefix = \".gnu.linkonce.d.\";\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  len = strlen (name) + strlen (prefix);\t\t\t\\\n-  string = alloca (len + 1);\t\t\t\t\t\\\n-  sprintf (string, \"%s%s\", prefix, name);\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  DECL_SECTION_NAME (DECL) = build_string (len, string);\t\\\n-} while (0)\n-/* A C statement (sans semicolon) to output an element in the table of\n-   global constructors.  */\n-#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    ctors_section ();\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t%s\\t \", INT_ASM_OP);\t\t\t\t\\\n-    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n-  } while (0)\n-\n-/* A C statement (sans semicolon) to output an element in the table of\n-   global destructors.  */\n-#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    dtors_section ();                   \t\t\t\t\\\n-    fprintf (FILE, \"\\t%s\\t \", INT_ASM_OP);\t\t\t\t\\\n-    assemble_name (FILE, NAME);              \t\t\t\t\\\n-    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n-  } while (0)\n-\n-/* A C statement or statements to switch to the appropriate\n-   section for output of DECL.  DECL is either a `VAR_DECL' node\n-   or a constant of some sort.  RELOC indicates whether forming\n-   the initial value of DECL requires link-time relocations.  */\n-\n-#define SELECT_SECTION(DECL,RELOC)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (flag_pic && RELOC)\t\t\t\t\t\t\\\n-    data_section ();\t\t\t\t\t\t\t\\\n-  else if (TREE_CODE (DECL) == STRING_CST)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (! flag_writable_strings)\t\t\t\t\t\\\n-\tconst_section ();\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tdata_section ();\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (! DECL_READONLY_SECTION (DECL, RELOC))\t\t\t\\\n-\tdata_section ();\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tconst_section ();\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    const_section ();\t\t\t\t\t\t\t\\\n-}\n-\n-/* A C statement or statements to switch to the appropriate\n-   section for output of RTX in mode MODE.  RTX is some kind\n-   of constant in RTL.  The argument MODE is redundant except\n-   in the case of a `const_int' rtx.  Currently, these always\n-   go into the const section.  */\n-\n-#undef SELECT_RTX_SECTION\n-#define SELECT_RTX_SECTION(MODE,RTX) const_section()\n-\n-/* Define the strings used for the special svr4 .type and .size directives.\n-   These strings generally do not vary from one system running svr4 to\n-   another, but if a given system (e.g. m88k running svr) needs to use\n-   different pseudo-op names for these, they may be overridden in the\n-   file which includes this one.  */\n-\n-#define TYPE_ASM_OP\t\".type\"\n-#define SIZE_ASM_OP\t\".size\"\n-\n-/* This is how we tell the assembler that a symbol is weak.  */\n-\n-#define ASM_WEAKEN_LABEL(FILE,NAME) \\\n-  do { fputs (\"\\t.weak\\t\", FILE); assemble_name (FILE, NAME); \\\n-       fputc ('\\n', FILE); } while (0)\n-\n-/* The following macro defines the format used to output the second\n-   operand of the .type assembler directive.  Different svr4 assemblers\n-   expect various different forms for this operand.  The one given here\n-   is just a default.  You may need to override it in your machine-\n-   specific tm.h file (depending upon the particulars of your assembler).  */\n-\n-#define TYPE_OPERAND_FMT\t\"@%s\"\n-\n-/* Write the extra assembler code needed to declare a function's result.\n-   Most svr4 assemblers don't require any special declaration of the\n-   result value, but there are exceptions.  */\n-\n-#ifndef ASM_DECLARE_RESULT\n-#define ASM_DECLARE_RESULT(FILE, RESULT)\n-#endif\n-\n-/* These macros generate the special .type and .size directives which\n-   are used to set the corresponding fields of the linker symbol table\n-   entries in an ELF object file under SVR4.  These macros also output\n-   the starting labels for the relevant functions/objects.  */\n-\n-/* Write the extra assembler code needed to declare a function properly.\n-   Some svr4 assemblers need to also have something extra said about the\n-   function's return value.  We allow for that here.  */\n-\n-#ifndef ASM_DECLARE_FUNCTION_NAME\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n-    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n-    putc (',', FILE);\t\t\t\t\t\t\t\\\n-    fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\t\t\\\n-    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n-    ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\t\\\n-    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n-  } while (0)\n-#endif\n-\n-/* Write the extra assembler code needed to declare an object properly.  */\n-\n-#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n-    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n-    putc (',', FILE);\t\t\t\t\t\t\t\\\n-    fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\t\t\\\n-    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n-    size_directive_output = 0;\t\t\t\t\t\t\\\n-    if (!flag_inhibit_size_directive && DECL_SIZE (DECL))\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tsize_directive_output = 1;\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n-\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n-\tputc (',', FILE);\t\t\t\t\t\t\\\n-\tfprintf (FILE, HOST_WIDE_INT_PRINT_DEC,\t\t\t\t\\\n-\t\t int_size_in_bytes (TREE_TYPE (DECL)));\t\t\t\\\n-\tfputc ('\\n', FILE);\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n-  } while (0)\n-\n-/* Output the size directive for a decl in rest_of_decl_compilation\n-   in the case where we did not do so before the initializer.\n-   Once we find the error_mark_node, we know that the value of\n-   size_directive_output was set\n-   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */\n-\n-#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t \\\n-do {\t\t\t\t\t\t\t\t\t \\\n-     const char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t \\\n-     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t \\\n-         && ! AT_END && TOP_LEVEL\t\t\t\t\t \\\n-\t && DECL_INITIAL (DECL) == error_mark_node\t\t\t \\\n-\t && !size_directive_output)\t\t\t\t\t \\\n-       {\t\t\t\t\t\t\t\t \\\n-\t size_directive_output = 1;\t\t\t\t\t \\\n-\t fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t \\\n-\t assemble_name (FILE, name);\t\t\t\t\t \\\n-\t putc (',', FILE);\t\t\t\t\t\t \\\n-\t fprintf (FILE, HOST_WIDE_INT_PRINT_DEC,\t\t\t \\\n-\t\t  int_size_in_bytes (TREE_TYPE (DECL))); \t\t \\\n-\tfputc ('\\n', FILE);\t\t\t\t\t\t \\\n-       }\t\t\t\t\t\t\t\t \\\n-   } while (0)\n-\n-/* This is how to declare the size of a function.  */\n-#ifndef ASM_DECLARE_FUNCTION_SIZE\n-#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-        char label[256];\t\t\t\t\t\t\\\n-\tstatic int labelno;\t\t\t\t\t\t\\\n-\tlabelno++;\t\t\t\t\t\t\t\\\n-\tASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\t\\\n-\tASM_OUTPUT_INTERNAL_LABEL (FILE, \"Lfe\", labelno);\t\t\\\n-\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n-\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n-        fprintf (FILE, \",\");\t\t\t\t\t\t\\\n-\tassemble_name (FILE, label);\t\t\t\t\t\\\n-        fprintf (FILE, \"-\");\t\t\t\t\t\t\\\n-\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n-\tputc ('\\n', FILE);\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n-#endif\n-/* A table of bytes codes used by the ASM_OUTPUT_ASCII and\n-   ASM_OUTPUT_LIMITED_STRING macros.  Each byte in the table\n-   corresponds to a particular byte value [0..255].  For any\n-   given byte value, if the value in the corresponding table\n-   position is zero, the given character can be output directly.\n-   If the table value is 1, the byte must be output as a \\ooo\n-   octal escape.  If the tables value is anything else, then the\n-   byte value should be output as a \\ followed by the value\n-   in the table.  Note that we can use standard UN*X escape\n-   sequences for many control characters, but we don't use\n-   \\a to represent BEL because some svr4 assemblers (e.g. on\n-   the i386) don't know about that.  Also, we don't use \\v\n-   since some versions of gas, such as 2.2 did not accept it.  */\n-\n-#define ESCAPES \\\n-\"\\1\\1\\1\\1\\1\\1\\1\\1btn\\1fr\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n-\\0\\0\\\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\n-\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\\\\0\\0\\0\\\n-\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\1\\\n-\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n-\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n-\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n-\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\"\n-\n-/* Some svr4 assemblers have a limit on the number of characters which\n-   can appear in the operand of a .string directive.  If your assembler\n-   has such a limitation, you should define STRING_LIMIT to reflect that\n-   limit.  Note that at least some svr4 assemblers have a limit on the\n-   actual number of bytes in the double-quoted string, and that they\n-   count each character in an escape sequence as one byte.  Thus, an\n-   escape sequence like \\377 would count as four bytes.\n-\n-   If your target assembler doesn't support the .string directive, you\n-   should define this to zero.\n-*/\n-\n-#define STRING_LIMIT\t((unsigned) 256)\n-\n-#define STRING_ASM_OP\t\".string\"\n-\n-/* The routine used to output NUL terminated strings.  We use a special\n-   version of this for most svr4 targets because doing so makes the\n-   generated assembly code more compact (and thus faster to assemble)\n-   as well as more readable, especially for targets like the i386\n-   (where the only alternative is to output character sequences as\n-   comma separated lists of numbers).   */\n-\n-#define ASM_OUTPUT_LIMITED_STRING(FILE, STR)\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      register const unsigned char *_limited_str =\t\t\t\\\n-\t(const unsigned char *) (STR);\t\t\t\t\t\\\n-      register unsigned ch;\t\t\t\t\t\t\\\n-      fprintf ((FILE), \"\\t%s\\t\\\"\", STRING_ASM_OP);\t\t\t\\\n-      for (; (ch = *_limited_str); _limited_str++)\t\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-\t  register int escape;\t\t\t\t\t\t\\\n-\t  switch (escape = ESCAPES[ch])\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t    case 0:\t\t\t\t\t\t\t\\\n-\t      putc (ch, (FILE));\t\t\t\t\t\\\n-\t      break;\t\t\t\t\t\t\t\\\n-\t    case 1:\t\t\t\t\t\t\t\\\n-\t      fprintf ((FILE), \"\\\\%03o\", ch);\t\t\t\t\\\n-\t      break;\t\t\t\t\t\t\t\\\n-\t    default:\t\t\t\t\t\t\t\\\n-\t      putc ('\\\\', (FILE));\t\t\t\t\t\\\n-\t      putc (escape, (FILE));\t\t\t\t\t\\\n-\t      break;\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-      fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* The routine used to output sequences of byte values.  We use a special\n-   version of this for most svr4 targets because doing so makes the\n-   generated assembly code more compact (and thus faster to assemble)\n-   as well as more readable.  Note that if we find subparts of the\n-   character sequence which end with NUL (and which are shorter than\n-   STRING_LIMIT) we output those using ASM_OUTPUT_LIMITED_STRING.  */\n-\n-#undef ASM_OUTPUT_ASCII\n-#define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      register const unsigned char *_ascii_bytes =\t\t\t\\\n-\t(const unsigned char *) (STR);\t\t\t\t\t\\\n-      register const unsigned char *limit = _ascii_bytes + (LENGTH);\t\\\n-      register unsigned bytes_in_chunk = 0;\t\t\t\t\\\n-      for (; _ascii_bytes < limit; _ascii_bytes++)\t\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-\t  register const unsigned char *p;\t\t\t\t\\\n-\t  if (bytes_in_chunk >= 60)\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\\n-\t      bytes_in_chunk = 0;\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  for (p = _ascii_bytes; p < limit && *p != '\\0'; p++)\t\t\\\n-\t    continue;\t\t\t\t\t\t\t\\\n-\t  if (p < limit && (p - _ascii_bytes) <= (long)STRING_LIMIT)\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      if (bytes_in_chunk > 0)\t\t\t\t\t\\\n-\t\t{\t\t\t\t\t\t\t\\\n-\t\t  fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\\\n-\t\t  bytes_in_chunk = 0;\t\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\t\\\n-\t      ASM_OUTPUT_LIMITED_STRING ((FILE), _ascii_bytes);\t\t\\\n-\t      _ascii_bytes = p;\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      register int escape;\t\t\t\t\t\\\n-\t      register unsigned ch;\t\t\t\t\t\\\n-\t      if (bytes_in_chunk == 0)\t\t\t\t\t\\\n-\t\tfprintf ((FILE), \"\\t%s\\t\\\"\", ASCII_DATA_ASM_OP);\t\\\n-\t      switch (escape = ESCAPES[ch = *_ascii_bytes])\t\t\\\n-\t\t{\t\t\t\t\t\t\t\\\n-\t\tcase 0:\t\t\t\t\t\t\t\\\n-\t\t  putc (ch, (FILE));\t\t\t\t\t\\\n-\t\t  bytes_in_chunk++;\t\t\t\t\t\\\n-\t\t  break;\t\t\t\t\t\t\\\n-\t\tcase 1:\t\t\t\t\t\t\t\\\n-\t\t  fprintf ((FILE), \"\\\\%03o\", ch);\t\t\t\\\n-\t\t  bytes_in_chunk += 4;\t\t\t\t\t\\\n-\t\t  break;\t\t\t\t\t\t\\\n-\t\tdefault:\t\t\t\t\t\t\\\n-\t\t  putc ('\\\\', (FILE));\t\t\t\t\t\\\n-\t\t  putc (escape, (FILE));\t\t\t\t\\\n-\t\t  bytes_in_chunk += 2;\t\t\t\t\t\\\n-\t\t  break;\t\t\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (bytes_in_chunk > 0)\t\t\t\t\t\t\\\n-        fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* All SVR4 targets use the ELF object file format.  */\n-#define OBJECT_FORMAT_ELF"}]}