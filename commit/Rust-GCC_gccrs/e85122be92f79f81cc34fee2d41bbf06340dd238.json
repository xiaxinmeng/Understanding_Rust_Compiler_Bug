{"sha": "e85122be92f79f81cc34fee2d41bbf06340dd238", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg1MTIyYmU5MmY3OWY4MWNjMzRmZWUyZDQxYmJmMDYzNDBkZDIzOA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2009-08-30T06:09:42Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2009-08-30T06:09:42Z"}, "message": "re PR target/41081 (redundant ZERO_EXTENDs)\n\n\tPR target/41081\n\t* fwprop.c (get_reg_use_in): Delete.\n\t(free_load_extend): New function.\n\t(forward_propagate_subreg): Use it.\n\nFrom-SVN: r151221", "tree": {"sha": "85c88ae5c0ec2c25cfc07833f8954fc9586ed4be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85c88ae5c0ec2c25cfc07833f8954fc9586ed4be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e85122be92f79f81cc34fee2d41bbf06340dd238", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e85122be92f79f81cc34fee2d41bbf06340dd238", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e85122be92f79f81cc34fee2d41bbf06340dd238", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e85122be92f79f81cc34fee2d41bbf06340dd238/comments", "author": null, "committer": null, "parents": [{"sha": "d1eda1365c8529a19f055a0d2bcf8916636d788a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1eda1365c8529a19f055a0d2bcf8916636d788a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1eda1365c8529a19f055a0d2bcf8916636d788a"}], "stats": {"total": 66, "additions": 45, "deletions": 21}, "files": [{"sha": "58171fa68c752e1c1b79da5da1c163d560be60b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e85122be92f79f81cc34fee2d41bbf06340dd238/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e85122be92f79f81cc34fee2d41bbf06340dd238/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e85122be92f79f81cc34fee2d41bbf06340dd238", "patch": "@@ -1,3 +1,10 @@\n+2009-08-30  Alan Modra  <amodra@bigpond.net.au>\n+\n+\tPR target/41081\n+\t* fwprop.c (get_reg_use_in): Delete.\n+\t(free_load_extend): New function.\n+\t(forward_propagate_subreg): Use it.\n+\n 2009-08-29  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config.gcc (sh*-*-elf): Add superh stuff only for sh*-superh-elf."}, {"sha": "df8c45d3b6b18cb446bed3eaedd5f54547bb0d78", "filename": "gcc/fwprop.c", "status": "modified", "additions": 38, "deletions": 21, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e85122be92f79f81cc34fee2d41bbf06340dd238/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e85122be92f79f81cc34fee2d41bbf06340dd238/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=e85122be92f79f81cc34fee2d41bbf06340dd238", "patch": "@@ -1014,24 +1014,54 @@ try_fwprop_subst (df_ref use, rtx *loc, rtx new_rtx, rtx def_insn, bool set_reg_\n   return ok;\n }\n \n-#ifdef LOAD_EXTEND_OP\n-static df_ref\n-get_reg_use_in (rtx insn, rtx reg)\n+/* For the given single_set INSN, containing SRC known to be a\n+   ZERO_EXTEND or SIGN_EXTEND of a register, return true if INSN\n+   is redundant due to the register being set by a LOAD_EXTEND_OP\n+   load from memory.  */\n+\n+static bool\n+free_load_extend (rtx src, rtx insn)\n {\n+  rtx reg;\n   df_ref *use_vec;\n+  df_ref use, def;\n+\n+  reg = XEXP (src, 0);\n+#ifdef LOAD_EXTEND_OP\n+  if (LOAD_EXTEND_OP (GET_MODE (reg)) != GET_CODE (src))\n+#endif\n+    return false;\n \n   for (use_vec = DF_INSN_USES (insn); *use_vec; use_vec++)\n     {\n-      df_ref use = *use_vec;\n+      use = *use_vec;\n \n       if (!DF_REF_IS_ARTIFICIAL (use)\n \t  && DF_REF_TYPE (use) == DF_REF_REG_USE\n \t  && DF_REF_REG (use) == reg)\n-\treturn use;\n+\tbreak;\n     }\n-  return NULL;\n+  if (!use)\n+    return false;\n+\n+  def = get_def_for_use (use);\n+  if (!def)\n+    return false;\n+\n+  if (DF_REF_IS_ARTIFICIAL (def))\n+    return false;\n+\n+  if (NONJUMP_INSN_P (DF_REF_INSN (def)))\n+    {\n+      rtx patt = PATTERN (DF_REF_INSN (def));\n+\n+      if (GET_CODE (patt) == SET\n+\t  && GET_CODE (SET_SRC (patt)) == MEM\n+\t  && rtx_equal_p (SET_DEST (patt), reg))\n+\treturn true;\n+    }\n+  return false;\n }\n-#endif\n \n /* If USE is a subreg, see if it can be replaced by a pseudo.  */\n \n@@ -1073,26 +1103,13 @@ forward_propagate_subreg (df_ref use, rtx def_insn, rtx def_set)\n      be removed due to it matching a LOAD_EXTEND_OP load from memory.  */\n   else if (subreg_lowpart_p (use_reg))\n     {\n-#ifdef LOAD_EXTEND_OP\n-      df_ref prev_use, prev_def;\n-#endif\n       use_insn = DF_REF_INSN (use);\n       src = SET_SRC (def_set);\n       if ((GET_CODE (src) == ZERO_EXTEND\n \t   || GET_CODE (src) == SIGN_EXTEND)\n \t  && REG_P (XEXP (src, 0))\n \t  && GET_MODE (XEXP (src, 0)) == use_mode\n-#ifdef LOAD_EXTEND_OP\n-\t  && !(LOAD_EXTEND_OP (use_mode) == GET_CODE (src)\n-\t       && (prev_use = get_reg_use_in (def_insn, XEXP (src, 0))) != NULL\n-\t       && (prev_def = get_def_for_use (prev_use)) != NULL\n-\t       && !DF_REF_IS_ARTIFICIAL (prev_def)\n-\t       && NONJUMP_INSN_P (DF_REF_INSN (prev_def))\n-\t       && GET_CODE (PATTERN (DF_REF_INSN (prev_def))) == SET\n-\t       && GET_CODE (SET_SRC (PATTERN (DF_REF_INSN (prev_def)))) == MEM\n-\t       && rtx_equal_p (SET_DEST (PATTERN (DF_REF_INSN (prev_def))),\n-\t\t\t       XEXP (src, 0)))\n-#endif\n+\t  && !free_load_extend (src, def_insn)\n \t  && all_uses_available_at (def_insn, use_insn))\n \treturn try_fwprop_subst (use, DF_REF_LOC (use), XEXP (src, 0),\n \t\t\t\t def_insn, false);"}]}