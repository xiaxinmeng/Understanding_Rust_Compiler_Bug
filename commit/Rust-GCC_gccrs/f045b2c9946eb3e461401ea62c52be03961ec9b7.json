{"sha": "f045b2c9946eb3e461401ea62c52be03961ec9b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA0NWIyYzk5NDZlYjNlNDYxNDAxZWE2MmM1MmJlMDM5NjFlYzliNw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-18T19:41:16Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-18T19:41:16Z"}, "message": "Initial revision\n\nFrom-SVN: r341", "tree": {"sha": "e87801f59b46c5bcb6426ecf04e16e4fa2f98b33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e87801f59b46c5bcb6426ecf04e16e4fa2f98b33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f045b2c9946eb3e461401ea62c52be03961ec9b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f045b2c9946eb3e461401ea62c52be03961ec9b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f045b2c9946eb3e461401ea62c52be03961ec9b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f045b2c9946eb3e461401ea62c52be03961ec9b7/comments", "author": null, "committer": null, "parents": [{"sha": "35cc5e7d25d707fcd029f012ea52acc14504686c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35cc5e7d25d707fcd029f012ea52acc14504686c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35cc5e7d25d707fcd029f012ea52acc14504686c"}], "stats": {"total": 1809, "additions": 1809, "deletions": 0}, "files": [{"sha": "2280f433624714c4eb7ce882a3fa1648b925ae12", "filename": "gcc/config/rs6000/rs6000.h", "status": "added", "additions": 1809, "deletions": 0, "changes": 1809, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f045b2c9946eb3e461401ea62c52be03961ec9b7/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f045b2c9946eb3e461401ea62c52be03961ec9b7/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=f045b2c9946eb3e461401ea62c52be03961ec9b7", "patch": "@@ -0,0 +1,1809 @@\n+/* Definitions of target machine for GNU compiler, for IBM RS/6000.\n+   Copyright (C) 1992 Free Software Foundation, Inc.\n+   Contributed by Richard Kenner (kenner@nyu.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Note that some other tm.h files include this one and then override\n+   many of the definitions that relate to assembler syntax.  */\n+\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-D_IBMR2 -D_AIX\"\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+#define TARGET_VERSION ;\n+\n+/* Tell the assembler to assume that all undefined names are external.  Don't\n+   do this until the fixed IBM assembler is more generally available.  */\n+\n+/* #define ASM_SPEC \"-u\" */\n+\n+/* Define the options for the binder: Start text at 512, align all segments\n+   to 512 bytes, and warn if there is text relocation.\n+\n+   The -bhalt:4 option supposedly changes the level at which ld will abort,\n+   but it also suppresses warnings about multiply defined symbols and is\n+   used by the AIX cc command.  So we use it here.\n+\n+   -bnodelcsect undoes a poor choice of default relating to multiply-defined\n+   csects.  See AIX documentation for more information about this.  */\n+\n+#define LINK_SPEC \"-T512 -H512 -btextro -bhalt:4 -bnodelcsect\"\n+\n+/* Add -lfp_p when running with -p or -pg.  */\n+#define LIB_SPEC \"%{pg:-lfp_p}%{p:-lfp_p} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}\"\n+\n+/* gcc must do the search itself to find libgcc.a, not use -l.  */\n+#define LINK_LIBGCC_SPECIAL\n+\n+/* Don't turn -B into -L if the argument specifies a relative file name.  */\n+#define RELATIVE_PREFIX_NOT_LINKDIR\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+/* Flag to allow putting fp constants in the TOC; can be turned off when\n+   the TOC overflows.  */\n+\n+#define TARGET_FP_IN_TOC  (target_flags & 1)\n+\n+extern int target_flags;\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES\t\t\\\n+  {{\"fp-in-toc\", 1},\t\t\\\n+   {\"no-fp-in-toc\", -1},\t\\\n+   { \"\", TARGET_DEFAULT}}\n+\n+#define TARGET_DEFAULT 1\n+\n+/* On the RS/6000, we turn on various flags if optimization is selected.  */\n+\n+#define OPTIMIZATION_OPTIONS(LEVEL)\t\\\n+{\t\t\t\t\t\\\n+  if ((LEVEL) > 0)\t\t\t\\\n+    {\t\t\t\t\t\\\n+      flag_force_mem = 1;\t\t\\\n+      flag_omit_frame_pointer = 1;\t\\\n+    }\t\t\t\t\t\\\n+}\n+\n+/* Define this to modify the options specified by the user.\n+\n+   We turn off profiling because we don't know how to do it.  */\n+\n+#define OVERRIDE_OPTIONS\t\t\\\n+{\t\t\t\t\t\\\n+   profile_flag = profile_block_flag = 0; \\\n+}\n+\f\n+/* target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields. */\n+/* That is true on RS/6000. */\n+#define BITS_BIG_ENDIAN 1\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* That is true on RS/6000.  */\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if most significant word of a multiword number is lowest\n+   numbered. \n+\n+   For RS/6000 we can decide arbitrarily since there are no machine\n+   instructions for them.  Might as well be consistent with bits and bytes. */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Type used for wchar_t, as a string used in a declaration.  */\n+#define WCHAR_TYPE \"short unsigned int\"\n+\n+/* Width of wchar_t in bits.  */\n+#define WCHAR_TYPE_SIZE 16\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 64\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 32\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  (TREE_CODE (EXP) == STRING_CST\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+/* #define STRICT_ALIGNMENT */\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   RS/6000 has 32 fixed-point registers, 32 floating-point registers,\n+   an MQ register, a count register, a link register, and 8 condition\n+   register fields, which we view here as separate registers.\n+\n+   In addition, the difference between the frame and argument pointers is\n+   a function of the number of registers saved, so we need to have a\n+   register for AP that will later be eliminated in favor of SP or FP.\n+   This is a normal register, but it is fixed.  */\n+\n+#define FIRST_PSEUDO_REGISTER 76\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+\n+   On RS/6000, r1 is used for the stack and r2 is used as the TOC pointer.  \n+\n+   cr5 is not supposed to be used.  */\n+\n+#define FIXED_REGISTERS  \\\n+  {0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+   0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+\n+#define CALL_USED_REGISTERS  \\\n+  {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, \\\n+   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, \\\n+   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+   1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1}\n+\n+/* List the order in which to allocate registers.  Each register must be\n+   listed once, even those in FIXED_REGISTERS.\n+\n+   We allocate in the following order:\n+\tfp0\t\t(not saved or used for anything)\n+\tfp13 - fp2\t(not saved; incoming fp arg registers)\n+\tfp1\t\t(not saved; return value)\n+ \tfp31 - fp14\t(saved; order given to save least number)\n+\tcr1, cr6, cr7\t(not saved or special)\n+\tcr0\t\t(not saved, but used for arithmetic operations)\n+\tcr2, cr3, cr4\t(saved)\n+        r0\t\t(not saved; cannot be base reg)\n+\tr9\t\t(not saved; best for TImode)\n+\tr11, r10, r8-r4\t(not saved; highest used first to make less conflict)\n+\tr3     \t\t(not saved; return value register)\n+\tr31 - r13\t(saved; order given to save least number)\n+\tr12\t\t(not saved; if used for DImode or DFmode would use r13)\n+\tmq\t\t(not saved; best to use it if we can)\n+\tctr\t\t(not saved; when we have the choice ctr is better)\n+\tlr\t\t(saved)\n+        cr5, r1, r2, ap\t(fixed)  */\n+\n+#define REG_ALLOC_ORDER\t\t\t\t\t\\\n+  {32, \t\t\t\t\t\t\t\\\n+   45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34,\t\\\n+   33,\t\t\t\t\t\t\t\\\n+   63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51,\t\\\n+   50, 49, 48, 47, 46, \t\t\t\t\t\\\n+   69, 74, 75, 68, 70, 71, 72,\t\t\t\t\\\n+   0,\t\t\t\t\t\t\t\\\n+   9, 11, 10, 8, 7, 6, 5, 4,\t\t\t\t\\\n+   3,\t\t\t\t\t\t\t\\\n+   31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19,\t\\\n+   18, 17, 16, 15, 14, 13, 12,\t\t\t\t\\\n+   64, 66, 65, \t\t\t\t\t\t\\\n+   73, 1, 2, 67}\n+\n+/* True if register is floating-point.  */\n+#define FP_REGNO_P(N) ((N) >= 32 && (N) <= 63)\n+\n+/* True if register is a condition register.  */\n+#define CR_REGNO_P(N) ((N) >= 68 && (N) <= 75)\n+\n+/* True if register is an integer register.  */\n+#define INT_REGNO_P(N) ((N) <= 31 || (N) == 67)\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+\n+   On RS/6000, ordinary registers hold 32 bits worth;\n+   a single floating point register holds 64 bits worth.  */\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  (FP_REGNO_P (REGNO)\t\t\t\\\n+   ? ((GET_MODE_SIZE (MODE) + 2 * UNITS_PER_WORD - 1) / (2 * UNITS_PER_WORD)) \\\n+   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On RS/6000, the cpu registers can hold any mode but the float registers\n+   can hold only floating modes and CR register can only hold CC modes.  We\n+   cannot put DImode or TImode anywhere except general register and they\n+   must be able to fit within the register set.  */\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+  (FP_REGNO_P (REGNO) ? GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n+   : CR_REGNO_P (REGNO) ? GET_MODE_CLASS (MODE) == MODE_CC\t\\\n+   : ! INT_REGNO_P (REGNO) ? GET_MODE_CLASS (MODE) == MODE_INT\t\\\n+   : 1)\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+  (GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\\\n+   ? GET_MODE_CLASS (MODE2) == MODE_FLOAT\t\\\n+   : GET_MODE_CLASS (MODE2) == MODE_FLOAT\t\\\n+   ? GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\\\n+   : GET_MODE_CLASS (MODE1) == MODE_CC\t\t\\\n+   ? GET_MODE_CLASS (MODE2) == MODE_CC\t\t\\\n+   : GET_MODE_CLASS (MODE2) == MODE_CC\t\t\\\n+   ? GET_MODE_CLASS (MODE1) == MODE_CC\t\t\\\n+   : 1)\n+\n+/* A C expression returning the cost of moving data from a register of class\n+   CLASS1 to one of CLASS2.\n+\n+   On the RS/6000, copying between floating-point and fixed-point\n+   registers is expensive.  */\n+\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\t\t\\\n+  ((CLASS1) == FLOAT_REGS && (CLASS2) == FLOAT_REGS ? 2\t\t\\\n+   : (CLASS1) == FLOAT_REGS && (CLASS2) != FLOAT_REGS ? 10\t\\\n+   : (CLASS1) != FLOAT_REGS && (CLASS2) == FLOAT_REGS ? 10\t\\\n+   : 2)\n+\n+/* A C expressions returning the cost of moving data of MODE from a register to\n+   or from memory.\n+\n+   On the RS/6000, bump this up a bit.  */\n+\n+#define MEMORY_MOVE_COST(MODE)  4\n+\n+/* Specify the cost of a branch insn; roughly the number of extra insns that\n+   should be added to avoid a branch.\n+\n+   Set this to 2 on the RS/6000 since that is roughly the average cost of an\n+   unscheduled conditional branch.  */\n+\n+#define BRANCH_COST 2\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* RS/6000 pc isn't overloaded on a register that the compiler knows about.  */\n+/* #define PC_REGNUM  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 1\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 31\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED 0\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 67\n+\n+/* Place to put static chain when calling a function that requires it.  */\n+#define STATIC_CHAIN_REGNUM 11\n+\n+/* Place that structure value return address is placed.\n+\n+   On the RS/6000, it is passed as an extra parameter.  */\n+#define STRUCT_VALUE\t0\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+/* The RS/6000 has three types of registers, fixed-point, floating-point,\n+   and condition registers, plus three special registers, MQ, CTR, and the\n+   link register.\n+\n+   However, r0 is special in that it cannot be used as a base register.\n+   So make a class for registers valid as base registers.\n+\n+   Also, cr0 is the only condition code register that can be used in\n+   arithmetic insns, so make a separate class for it. */\n+\n+enum reg_class { NO_REGS, BASE_REGS, GENERAL_REGS, FLOAT_REGS,\n+  NON_SPECIAL_REGS, MQ_REGS, LINK_REGS, CTR_REGS, LINK_OR_CTR_REGS,\n+  SPECIAL_REGS, CR0_REGS, CR_REGS, ALL_REGS, LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES\t\t\t\t\t \t\\\n+  { \"NO_REGS\", \"BASE_REGS\", \"GENERAL_REGS\", \"FLOAT_REGS\",\t\\\n+    \"NON_SPECIAL_REGS\", \"MQ_REGS\", \"LINK_REGS\", \"CTR_REGS\",\t\\\n+    \"LINK_OR_CTR_REGS\", \"SPECIAL_REGS\", \"CR0_REGS\", \"CR_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS\t\t\t\t\\\n+  { {0, 0, 0}, {0xfffffffe, 0, 8}, {~0, 0, 8},\t\t\\\n+    {0, ~0, 0}, {~0, ~0, 0}, {0, 0, 1}, {0, 0, 2},\t\\\n+    {0, 0, 4}, {0, 0, 6}, {0, 0, 7}, {0, 0, 16}, \t\\\n+    {0, 0, 0xff0}, {~0, ~0, 0xfff5} }\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO)\t\\\n+ ((REGNO) == 0 ? GENERAL_REGS\t\\\n+  : (REGNO) < 32 ? BASE_REGS\t\\\n+  : FP_REGNO_P (REGNO) ? FLOAT_REGS \\\n+  : (REGNO) == 68 ? CR0_REGS\t\\\n+  : CR_REGNO_P (REGNO) ? CR_REGS \\\n+  : (REGNO) == 64 ? MQ_REGS\t\\\n+  : (REGNO) == 65 ? LINK_REGS\t\\\n+  : (REGNO) == 66 ? CTR_REGS\t\\\n+  : (REGNO) == 67 ? BASE_REGS\t\\\n+  : NO_REGS)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+#define INDEX_REG_CLASS GENERAL_REGS\n+#define BASE_REG_CLASS BASE_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'f' ? FLOAT_REGS\t\\\n+   : (C) == 'b' ? BASE_REGS\t\\\n+   : (C) == 'h' ? SPECIAL_REGS\t\\\n+   : (C) == 'q' ? MQ_REGS\t\\\n+   : (C) == 'c' ? CTR_REGS\t\\\n+   : (C) == 'l' ? LINK_REGS\t\\\n+   : (C) == 'x' ? CR0_REGS\t\\\n+   : (C) == 'y' ? CR_REGS\t\\\n+   : NO_REGS)\n+\n+/* The letters I, J, K, L, M, N, and P in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   `I' is signed 16-bit constants \n+   `J' is a constant with only the high-order 16 bits non-zero\n+   `K' is a constant with only the low-order 16 bits non-zero\n+   `L' is a constant that can be placed into a mask operand\n+   `M' is a constant that is greater than 31\n+   `N' is a constant that is an exact power of two\n+   `O' is the constant zero\n+   `P' is a constant whose negation is a signed 16-bit constant */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n+   ( (C) == 'I' ? (unsigned) ((VALUE) + 0x8000) < 0x10000\t\\\n+   : (C) == 'J' ? ((VALUE) & 0xffff) == 0\t\t\t\\\n+   : (C) == 'K' ? ((VALUE) & 0xffff0000) == 0\t\t\t\\\n+   : (C) == 'L' ? mask_constant (VALUE)\t\t\t\t\\\n+   : (C) == 'M' ? (VALUE) > 31\t\t\t\t\t\\\n+   : (C) == 'N' ? exact_log2 (VALUE) >= 0\t\t\t\\\n+   : (C) == 'O' ? (VALUE) == 0\t\t\t\t\t\\\n+   : (C) == 'P' ? (unsigned) ((- (VALUE)) + 0x8000) < 0x1000\t\\\n+   : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.\n+\n+   We flag for special constants when we can copy the constant into\n+   a general register in two insns for DF and one insn for SF.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((C) == 'G' ? easy_fp_constant (VALUE, GET_MODE (VALUE)) : 0)\n+\n+/* Optional extra constraints for this machine.\n+\n+   For the RS/6000, `Q' means that this is a memory operand that is just\n+   an offset from a register.  */\n+\n+#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n+  ((C) == 'Q' ? indirect_operand (OP, VOIDmode) : 0)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class. \n+\n+   On the RS/6000, we have to return NO_REGS when we want to reload a\n+   floating-point CONST_DOUBLE to force it to be copied to memory.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\\\n+  ((GET_CODE (X) == CONST_DOUBLE\t\t\t\\\n+    && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT)\t\\\n+   ? NO_REGS : (CLASS))\n+   \n+/* Return the register class of a scratch register needed to copy IN into\n+   or out of a register in CLASS in MODE.  If it can be done directly,\n+   NO_REGS is returned.  */\n+\n+#define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n+  secondary_reload_class (CLASS, MODE, IN)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.\n+\n+   On RS/6000, this is the size of MODE in words,\n+   except in the FP regs, where a single reg is enough for two words.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+ ((CLASS) == FLOAT_REGS\t\t\t\\\n+  ? ((GET_MODE_SIZE (MODE) + 2 * UNITS_PER_WORD - 1) / (2 * UNITS_PER_WORD)) \\\n+  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.\n+\n+   On the RS/6000, we grow upwards, from the area after the outgoing\n+   arguments.  */\n+/* #define FRAME_GROWS_DOWNWARD */\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated. \n+\n+   On the RS/6000, the frame pointer is the same as the stack pointer,\n+   except for dynamic allocations.  So we start after the fixed area and\n+   outgoing parameter area.  */\n+\n+#define STARTING_FRAME_OFFSET (current_function_outgoing_args_size + 24)\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.\n+   On RS/6000, don't define this because there are no push insns.  */\n+/*  #define PUSH_ROUNDING(BYTES) */\n+\n+/* Offset of first parameter from the argument pointer register value.\n+   On the RS/6000, we define the argument pointer to the start of the fixed\n+   area.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 24\n+\n+/* Define this if stack space is still allocated for a parameter passed\n+   in a register.  The value is the number of bytes allocated to this\n+   area.  */\n+#define REG_PARM_STACK_SPACE(FNDECL)\t32\n+\n+/* Define this if the above stack space is to be considered part of the\n+   space allocated by the caller.  */\n+#define OUTGOING_REG_PARM_STACK_SPACE\n+\n+/* This is the difference between the logical top of stack and the actual sp.\n+\n+   For the RS/6000, sp points past the fixed area. */\n+#define STACK_POINTER_OFFSET 24\n+\n+/* Define this if the maximum size of all the outgoing args is to be\n+   accumulated and pushed during the prologue.  The amount can be\n+   found in the variable current_function_outgoing_args_size.  */\n+#define ACCUMULATE_OUTGOING_ARGS\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.  */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) 0\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.\n+\n+   On RS/6000 an integer value is in r3 and a floating-point value is in \n+   fp1.  */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)\t\\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE),\t\\\n+\t   TREE_CODE (VALTYPE) == REAL_TYPE ? 33 : 3)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE)\t\t\\\n+  gen_rtx (REG, MODE, GET_MODE_CLASS (MODE) == MODE_FLOAT ? 33 : 3)\n+\n+/* The definition of this macro implies that there are cases where\n+   a scalar value cannot be returned in registers.\n+\n+   For the RS/6000, any structure or union type is returned in memory.  */\n+\n+#define RETURN_IN_MEMORY(TYPE) \\\n+  (TREE_CODE (TYPE) == RECORD_TYPE || TREE_CODE (TYPE) == UNION_TYPE)\n+\n+/* 1 if N is a possible register number for a function value\n+   as seen by the caller.\n+\n+   On RS/6000, this is r3 and fp1.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N)  ((N) == 3 || ((N) == 33))\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On RS/6000, these are r3-r10 and fp1-fp13.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N)\t\\\n+  (((N) <= 10 && (N) >= 3) || ((N) >= 33 && (N) <= 45))\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On the RS/6000, this is a structure.  The first element is the number of\n+   total argument words, the second is used to store the next\n+   floating-point register number, and the third says how many more args we\n+   have prototype types for.  */\n+\n+struct rs6000_args {int words, fregno, nargs_prototype; };\n+#define CUMULATIVE_ARGS struct rs6000_args\n+\n+/* Define intermediate macro to compute the size (in registers) of an argument\n+   for the RS/6000.  */\n+\n+#define RS6000_ARG_SIZE(MODE, TYPE, NAMED)\t\t\t\t\\\n+(! (NAMED) ? 0\t\t\t\t\t\t\t\t\\\n+ : (MODE) != BLKmode\t\t\t\t\t\t\t\\\n+ ? (GET_MODE_SIZE (MODE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD \t\\\n+ : (int_size_in_bytes (TYPE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n+  (CUM).words = 0,\t\t\t\t\\\n+  (CUM).fregno = 33,\t\t\t\t\\\n+  (CUM).nargs_prototype = (FNTYPE && TYPE_ARG_TYPES (FNTYPE)\t\t\\\n+\t\t\t   ? (list_length (TYPE_ARG_TYPES (FNTYPE)) - 1 \\\n+\t\t\t      + (TYPE_MODE (TREE_TYPE (FNTYPE)) == BLKmode \\\n+\t\t\t\t || RETURN_IN_MEMORY (TREE_TYPE (FNTYPE)))) \\\n+\t\t\t   : 0)\n+\n+/* Similar, but when scanning the definition of a procedure.  We always\n+   set NARGS_PROTOTYPE large so we never return an EXPR_LIST.  */\n+\n+#define INIT_CUMULATIVE_INCOMING_ARGS(CUM,FNTYPE,IGNORE) \\\n+  (CUM).words = 0,\t\t\t\t\\\n+  (CUM).fregno = 33,\t\t\t\t\\\n+  (CUM).nargs_prototype = 1000\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+{ (CUM).nargs_prototype--;\t\t\t\t\\\n+  if (NAMED)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      (CUM).words += RS6000_ARG_SIZE (MODE, TYPE, NAMED); \\\n+      if (GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\t\\\n+\t(CUM).fregno++;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\n+\n+/* Non-zero if we can use a floating-point register to pass this arg.  */\n+#define USE_FP_FOR_ARG_P(CUM,MODE,TYPE)\t\\\n+  (GET_MODE_CLASS (MODE) == MODE_FLOAT && (CUM).fregno < 46)\n+\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).\n+\n+   On RS/6000 the first eight words of non-FP are normally in registers\n+   and the rest are pushed.  The first 13 FP args are in registers.\n+\n+   If this is floating-point and no prototype is specified, we use\n+   both an FP and integer register (or possibly FP reg and stack).  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\t\\\n+  (! (NAMED) ? 0\t\t\t\t\t\t\t\\\n+  : USE_FP_FOR_ARG_P (CUM, MODE, TYPE)\t\t\t\t\t\\\n+   ? ((CUM).nargs_prototype > 0\t\t\t\t\t\t\\\n+      ? gen_rtx (REG, MODE, (CUM).fregno)\t\t\t\t\\\n+      : ((CUM).words < 8\t\t\t\t\t\t\\\n+\t ? gen_rtx (EXPR_LIST, VOIDmode,\t\t\t\t\\\n+\t\t    gen_rtx (REG, (MODE), 3 + (CUM).words),\t\t\\\n+\t\t    gen_rtx (REG, (MODE), (CUM).fregno))\t\t\\\n+\t : gen_rtx (EXPR_LIST, VOIDmode, 0,\t\t\t\t\\\n+\t\t    gen_rtx (REG, (MODE), (CUM).fregno))))\t\t\\\n+   : (CUM).words < 8 ? gen_rtx(REG, (MODE), 3 + (CUM).words) : 0)\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\t\\\n+  (! (NAMED) ? 0\t\t\t\t\t\t\t\\\n+   : USE_FP_FOR_ARG_P (CUM, MODE, TYPE) && (CUM).nargs_prototype >= 0 ? 0 \\\n+   : (((CUM).words < 8\t\t\t\t\t\t\t\\\n+       && 8 < ((CUM).words + RS6000_ARG_SIZE (MODE, TYPE, NAMED)))\t\\\n+      ? 8 - (CUM).words : 0))\n+\n+/* Perform any needed actions needed for a function that is receiving a\n+   variable number of arguments. \n+\n+   CUM is as above.\n+\n+   MODE and TYPE are the mode and type of the current parameter.\n+\n+   PRETEND_SIZE is a variable that should be set to the amount of stack\n+   that must be pushed by the prolog to pretend that our caller pushed\n+   it.\n+\n+   Normally, this macro will push all remaining incoming registers on the\n+   stack and set PRETEND_SIZE to the length of the registers pushed.  */\n+\n+#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n+{ if ((CUM).words < 8)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int first_reg_offset = (CUM).words;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (MUST_PASS_IN_STACK (MODE, TYPE))\t\t\t\t\\\n+\tfirst_reg_offset += RS6000_ARG_SIZE (TYPE_MODE (TYPE), TYPE, 1); \\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (first_reg_offset > 8)\t\t\t\t\t\t\\\n+\tfirst_reg_offset = 8;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (! (NO_RTL) && first_reg_offset != 8)\t\t\t\t\\\n+\tmove_block_from_reg\t\t\t\t\t\t\\\n+\t  (3 + first_reg_offset,\t\t\t\t\t\\\n+\t   gen_rtx (MEM, BLKmode,\t\t\t\t\t\\\n+\t\t    plus_constant (virtual_incoming_args_rtx,\t\t\\\n+\t\t\t\t   first_reg_offset * 4)),\t\t\\\n+\t   8 - first_reg_offset);\t\t\t\t\t\\\n+      PRETEND_SIZE = (8 - first_reg_offset) * UNITS_PER_WORD;\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE) output_prolog (FILE, SIZE)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.\n+\n+   I have no real idea what r3 should point to here.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\\\n+  fprintf(FILE, \"\\tbl mcount\\n\");\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter. No definition is equivalent to\n+   always zero.\n+\n+   On the RS/6000, this is non-zero because we can restore the stack from\n+   its backpointer, which we maintain.  */\n+#define EXIT_IGNORE_STACK\t1\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE) output_epilog (FILE, SIZE)\n+\f\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.\n+\n+   The trampoline should set the static chain pointer to value placed\n+   into the trampoline and should branch to the specified routine.\n+\n+   On the RS/6000, this is not code at all, but merely a data area,\n+   since that is the way all functions are called.  The first word is\n+   the address of the function, the second word is the TOC pointer (r2),\n+   and the third word is the static chain value.  */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE) { fprintf (FILE, \"\\t.long 0, 0, 0\\n\"); }\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE    12\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, CXT)\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, memory_address (SImode, ADDR)), \\\n+\t\t  force_reg (SImode, FNADDR));\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode,\t\t\t\t\\\n+\t\t\t   memory_address (SImode, plus_constant (ADDR, 4))), \\\n+\t\t  gen_rtx (REG, SImode, 2));\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode,\t\t\t\t\\\n+\t\t\t   memory_address (SImode, plus_constant (ADDR, 8))), \\\n+\t\t  force_reg (SImode, CXT));\t\t\t\\\n+}\n+\f\n+/* Definitions for register eliminations.\n+\n+   We have two registers that can be eliminated on the RS/6000.  First, the\n+   frame pointer register can often be eliminated in favor of the stack\n+   pointer register.  Secondly, the argument pointer register can always be\n+   eliminated; it is replaced with either the stack or frame pointer.  */\n+\n+/* This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.  */\n+#define ELIMINABLE_REGS\t\t\t\t\\\n+{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n+ { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n+ { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM} }\n+\n+/* Given FROM and TO register numbers, say whether this elimination is allowed.\n+   Frame pointer elimination is automatically handled.\n+\n+   For the RS/6000, if frame pointer elimination is being done, we would like\n+   to convert ap into fp, not sp.  */\n+\n+#define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\\\n+ ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM\t\\\n+  ? ! frame_pointer_needed\t\t\t\t\t\\\n+  : 1)\n+\n+/* Define the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int total_stack_size = (rs6000_sa_size () + get_frame_size ()\t\t\\\n+\t\t\t  + current_function_outgoing_args_size);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  total_stack_size = (total_stack_size + 7) & ~7;\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+ if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (rs6000_pushes_stack ())\t\t\t\t\t\\\n+\t(OFFSET) = 0;\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t(OFFSET) = - total_stack_size;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM) \\\n+      (OFFSET) = total_stack_size;\t\t\t\t\t\\\n+  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM) \\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (rs6000_pushes_stack ())\t\t\t\t\t\\\n+\t(OFFSET) = total_stack_size;\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t(OFFSET) = 0;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    abort ();\t\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* #define HAVE_POST_INCREMENT */\n+/* #define HAVE_POST_DECREMENT */\n+\n+#define HAVE_PRE_DECREMENT\n+#define HAVE_PRE_INCREMENT\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO)\t\t\t\t\\\n+((REGNO) < FIRST_PSEUDO_REGISTER\t\t\t\t\\\n+ ? (REGNO) <= 31 || (REGNO) == 67\t\t\t\t\\\n+ : (reg_renumber[REGNO] >= 0\t\t\t\t\t\\\n+    && (reg_renumber[REGNO] <= 31 || reg_renumber[REGNO] == 67)))\n+\n+#define REGNO_OK_FOR_BASE_P(REGNO)\t\t\t\t\\\n+((REGNO) < FIRST_PSEUDO_REGISTER\t\t\t\t\\\n+ ? ((REGNO) > 0 && (REGNO) <= 31) || (REGNO) == 67\t\t\\\n+ : (reg_renumber[REGNO] > 0\t\t\t\t\t\\\n+    && (reg_renumber[REGNO] <= 31 || reg_renumber[REGNO] == 67)))\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* Recognize any constant value that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X)  CONSTANT_P (X)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n+\n+   On the RS/6000, all integer constants are acceptable, most won't be valid\n+   for particular insns, though.  Only easy FP constants are\n+   acceptable.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\\\n+  (GET_CODE (X) != CONST_DOUBLE || GET_MODE (X) == VOIDmode\t\\\n+   || easy_fp_constant (X, GET_MODE (X)))\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X)\t\t\t\\\n+  (REGNO (X) <= 31 || REGNO (X) == 67 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X)\t\t\t\t\t \\\n+  (REGNO (X) > 0 && REG_OK_FOR_INDEX_P (X))\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   On the RS/6000, there are four valid address: a SYMBOL_REF that\n+   refers to a constant pool entry of an address (or the sum of it\n+   plus a constant), a short (16-bit signed) constant plus a register,\n+   the sum of two registers, or a register indirect, possibly with an\n+   auto-increment.  For DFmode and DImode with an constant plus register,\n+   we must ensure that both words are addressable.  */\n+\n+#define LEGITIMATE_CONSTANT_POOL_BASE_P(X)\t\t\t\t\\\n+  (GET_CODE (X) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (X)\t\t\\\n+   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (X)))\n+\n+#define LEGITIMATE_CONSTANT_POOL_ADDRESS_P(X)\t\t\t\t\\\n+  (LEGITIMATE_CONSTANT_POOL_BASE_P (X)\t\t\t\t\t\\\n+   || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS\t\t\\\n+       && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\t\\\n+       && LEGITIMATE_CONSTANT_POOL_BASE_P (XEXP (XEXP (X, 0), 0))))\n+\n+#define LEGITIMATE_ADDRESS_INTEGER_P(X,OFFSET)\t\t\t\t\\\n+ (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n+  && (unsigned) (INTVAL (X) + (OFFSET) + 0x8000) < 0x10000)\n+\n+#define LEGITIMATE_OFFSET_ADDRESS_P(MODE,X)\t\t\\\n+ (GET_CODE (X) == PLUS\t\t\t\t\t\\\n+  && GET_CODE (XEXP (X, 0)) == REG\t\t\t\\\n+  && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\\\n+  && LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 0)\t\\\n+  && (((MODE) != DFmode && (MODE) != DImode)\t\t\\\n+      || LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 4)))\n+\n+#define LEGITIMATE_INDEXED_ADDRESS_P(X)\t\t\\\n+ (GET_CODE (X) == PLUS\t\t\t\t\\\n+  && GET_CODE (XEXP (X, 0)) == REG\t\t\\\n+  && GET_CODE (XEXP (X, 1)) == REG\t\t\\\n+  && ((REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\\\n+       && REG_OK_FOR_INDEX_P (XEXP (X, 1)))\t\\\n+      || (REG_OK_FOR_BASE_P (XEXP (X, 1))\t\\\n+\t  && REG_OK_FOR_INDEX_P (XEXP (X, 0)))))\n+\n+#define LEGITIMATE_INDIRECT_ADDRESS_P(X)\t\\\n+  (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n+{ if (LEGITIMATE_INDIRECT_ADDRESS_P (X))\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PRE_INC\t\t\t\t\\\n+      && LEGITIMATE_INDIRECT_ADDRESS_P (XEXP (X, 0)))\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PRE_DEC\t\t\t\t\\\n+      && LEGITIMATE_INDIRECT_ADDRESS_P (XEXP (X, 0)))\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  if (LEGITIMATE_CONSTANT_POOL_ADDRESS_P (X))\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  if (LEGITIMATE_OFFSET_ADDRESS_P (MODE, X))\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  if ((MODE) != DImode && (MODE) != TImode\t\t\\\n+      && LEGITIMATE_INDEXED_ADDRESS_P (X))\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+}\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   On RS/6000, first check for the sum of a register with a constant\n+   integer that is out of range.  If so, generate code to add the\n+   constant with the low-order 16 bits masked to the register and force\n+   this result into another register (this can be done with `cau').\n+   Then generate an address of REG+(CONST&0xffff), allowing for the \n+   possibility of bit 16 being a one.\n+\n+   Then check for the sum of a register and something not constant, try to\n+   load the other things into a register and return the sum.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n+{ if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG\t\\\n+    && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n+    && (unsigned) (INTVAL (XEXP (X, 1)) + 0x8000) >= 0x10000)\t\\\n+    { int high_int, low_int;\t\t\t\t\t\\\n+      high_int = INTVAL (XEXP (X, 1)) >> 16;\t\t\t\\\n+      low_int = INTVAL (XEXP (X, 1)) & 0xffff;\t\t\t\\\n+      if (low_int & 0x8000)\t\t\t\t\t\\\n+\thigh_int += 1, low_int |= 0xffff0000;\t\t\t\\\n+      (X) = gen_rtx (PLUS, SImode,\t\t\t\t\\\n+\t\t     force_operand\t\t\t\t\\\n+\t\t     \t(gen_rtx (PLUS, SImode, XEXP (X, 0), \\\n+\t\t\t\t  gen_rtx (CONST_INT, VOIDmode, \\\n+\t\t\t\t\t\t      high_int << 16)), 0),\\\n+\t\t     gen_rtx (CONST_INT, VOIDmode, low_int));\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG \\\n+\t   && GET_CODE (XEXP (X, 1)) != CONST_INT) \t\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n+\t\t   force_operand (XEXP (X, 1), 0));\t\t\\\n+}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+\n+   On the RS/6000 this is true if the address is valid with a zero offset\n+   but not with an offset of four (this means it cannot be used as an\n+   address for DImode or DFmode) or is a pre-increment or decrement.  Since\n+   we know it is valid, we just check for an address that is not valid with\n+   an offset of four.  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\t\\\n+{ if (GET_CODE (ADDR) == PLUS\t\t\t\t\t\\\n+      && LEGITIMATE_ADDRESS_INTEGER_P (XEXP (ADDR, 1), 0)\t\\\n+      && ! LEGITIMATE_ADDRESS_INTEGER_P (XEXP (ADDR, 1), 4))\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\\\n+  if (GET_CODE (ADDR) == PRE_INC)\t\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\\\n+  if (GET_CODE (ADDR) == PRE_DEC)\t\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Define this if some processing needs to be done immediately before\n+   emitting code for an insn. */\n+\n+/* #define FINAL_PRESCAN_INSN(INSN,OPERANDS,NOPERANDS) */\n+\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+#define CASE_VECTOR_PC_RELATIVE\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 0\n+\n+/* This flag, if defined, says the same insns that convert to a signed fixnum\n+   also convert validly to an unsigned one.  */\n+\n+/* #define FIXUNS_TRUNC_LIKE_FIX_TRUNC */\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 16\n+\n+/* Nonzero if access to memory by bytes is no faster than for words.\n+   Also non-zero if doing byte operations (specifically shifts) in registers\n+   is undesirable.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* Define if normal loads of shorter-than-word items from memory clears\n+   the rest of the bigs in the register.  */\n+#define BYTE_LOADS_ZERO_EXTEND\n+\n+/* We can't support any debugging info on the RS/6000 since it has its\n+   own format.  */\n+/* #define DBX_DEBUGGING_INFO  */\n+/* #define SDB_DEBUGGING_INFO  */\n+\n+/* We don't have GAS for the RS/6000 yet, so don't write out special\n+   .stabs in cc1plus.  */\n+   \n+#define FASCIST_ASSEMBLER\n+\n+/* Do not break .stabs pseudos into continuations.  */\n+#define DBX_CONTIN_LENGTH 0\n+\n+/* Don't try to use the `x' type-cross-reference character in DBX data.\n+   Also has the consequence of putting each struct, union or enum\n+   into a separate .stabs, containing only cross-refs to the others.  */\n+#define DBX_NO_XREFS\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* Mode of a function address in a call instruction (for indexing purposes).\n+\n+   Doesn't matter on RS/6000.  */\n+#define FUNCTION_MODE SImode\n+\n+/* Define this if addresses of constant functions\n+   shouldn't be put through pseudo regs where they can be cse'd.\n+   Desirable on machines where ordinary constants are expensive\n+   but a CALL with constant address is cheap.  */\n+#define NO_FUNCTION_CSE\n+\n+/* Define this if shift instructions ignore all but the low-order\n+   few bits. */\n+#define SHIFT_COUNT_TRUNCATED\n+\n+/* Use atexit for static constructors/destructors, instead of defining\n+   our own exit function.  */\n+#define HAVE_ATEXIT\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.\n+\n+   On the RS/6000, if it is legal in the insn, it is free.  So this\n+   always returns 0.  */\n+\n+#define CONST_COSTS(RTX,CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    return 0;\n+\n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE.  */\n+\n+#define RTX_COSTS(X,CODE)\t\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\\\n+    return (GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\\\n+\t    ? COSTS_N_INSNS (5)\t\t\t\t\\\n+\t    : INTVAL (XEXP (X, 1)) >= -256 && INTVAL (XEXP (X, 1)) <= 255 \\\n+\t    ? COSTS_N_INSNS (3) : COSTS_N_INSNS (4));\t\\\n+  case DIV:\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\\\n+    if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\\\n+\t&& exact_log2 (INTVAL (XEXP (X, 1))) >= 0)\t\\\n+      return COSTS_N_INSNS (2);\t\t\t\t\\\n+    /* otherwise fall through to normal divide.  */\t\\\n+  case UDIV:\t\t\t\t\t\t\\\n+  case UMOD:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (19);\t\t\t\t\\\n+  case MEM:\t\t\t\t\t\t\\\n+    /* MEM should be slightly more expensive than (plus (reg) (const)) */ \\\n+    return 5;\n+\n+/* Compute the cost of an address.  This is meant to approximate the size\n+   and/or execution delay of an insn using that address.  If the cost is\n+   approximated by the RTL complexity, including CONST_COSTS above, as\n+   is usually the case for CISC machines, this macro should not be defined.\n+   For aggressively RISCy machines, only one insn format is allowed, so\n+   this macro should be a constant.  The value of this macro only matters\n+   for valid addresses.\n+\n+   For the RS/6000, everything is cost 0.  */\n+\n+#define ADDRESS_COST(RTX) 0\n+\n+/* Adjust the length of an INSN.  LENGTH is the currently-computed length and\n+   should be adjusted to reflect any required changes.  This macro is used when\n+   there is some systematic length adjustment required that would be difficult\n+   to express in the length attribute.  */\n+\n+/* #define ADJUST_INSN_LENGTH(X,LENGTH) */\n+\n+/* Add any extra modes needed to represent the condition code.\n+\n+   For the RS/6000, we need separate modes when unsigned (logical) comparisons\n+   are being done and we need a separate mode for floating-point.  */\n+\n+#define EXTRA_CC_MODES CCUNSmode, CCFPmode\n+\n+/* Define the names for the modes specified above.  */\n+#define EXTRA_CC_NAMES \"CCUNS\", \"CCFP\"\n+\n+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n+   return the mode to be used for the comparison.  For floating-point, CCFPmode\n+   should be used.  CC_NOOVmode should be used when the first operand is a\n+   PLUS, MINUS, or NEG.  CCmode should be used when no special processing is\n+   needed.  */\n+#define SELECT_CC_MODE(OP,X) \\\n+  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT ? CCFPmode\t\\\n+   : ((OP) == GTU || (OP) == LTU || (OP) == GEU || (OP) == LEU\t\\\n+      ? CCUNSmode : CCmode))\n+\n+/* Define the information needed to generate branch and scc insns.  This is\n+   stored from the compare operation.  Note that we can't use \"rtx\" here\n+   since it hasn't been defined!  */\n+\n+extern struct rtx_def *rs6000_compare_op0, *rs6000_compare_op1;\n+extern int rs6000_compare_fp_p;\n+\n+/* Set to non-zero by \"fix\" operation to indicate that itrunc and\n+   uitrunc must be defined.  */\n+\n+extern int rs6000_trunc_used;\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Output at beginning of assembler file.\n+\n+   On the RS/6000, we want to go into the TOC section so at least one\n+   .toc will be emitted.\n+\n+   Also initialize the section names for the RS/6000 at this point.  */\n+\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  rs6000_gen_section_name (&rs6000_bss_section_name,\t\t\\\n+\t\t\t   main_input_filename, \".bss_\");\t\\\n+  rs6000_gen_section_name (&rs6000_private_data_section_name,\t\\\n+\t\t\t   main_input_filename, \".rw_\");\t\\\n+  rs6000_gen_section_name (&rs6000_read_only_section_name,\t\\\n+\t\t\t   main_input_filename, \".ro_\");\t\\\n+\t\t\t\t\t\t\t\t\\\n+  toc_section ();\t\t\t\t\t\t\\\n+  bss_section ();\t\t\t\t\t\t\\\n+}\n+\n+/* Output at end of assembler file.\n+\n+   On the RS/6000, referencing data should automatically pull in text.  */\n+\n+#define ASM_FILE_END(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  text_section ();\t\t\t\t\t\t\\\n+  fprintf (FILE, \"_section_.text:\\n\");\t\t\t\t\\\n+  data_section ();\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.long _section_.text\\n\");\t\t\t\\\n+}\n+\n+/* Names of bss and data sections.  These should be unique names for each\n+   compilation unit.  */\n+\n+extern char *rs6000_bss_section_name;\n+extern char *rs6000_private_data_section_name;\n+extern char *rs6000_read_only_section_name;\n+\n+/* We define this to prevent the name mangler from putting dollar signs into\n+   function names.  */\n+\n+#define NO_DOLLAR_IN_LABEL\n+\n+/* We define this to 0 so that gcc will never accept a dollar sign in a\n+   variable name.  This is needed because the AIX assembler will not accept\n+   dollar signs.  */\n+\n+#define DOLLARS_IN_IDENTIFIERS 0\n+\n+/* Define the extra sections we need.  We define three: one is the read-only\n+   data section which is used for constants.  This is a csect whose name is\n+   derived from the name of the input file.  The second is for initialized\n+   global variables.  This is a csect whose name is that of the variable.\n+   The third is the TOC.  */\n+\n+#define EXTRA_SECTIONS \\\n+   read_only_data, private_data, read_only_private_data, toc, bss\n+\n+/* Define the name of our readonly data section.  */\n+\n+#define READONLY_DATA_SECTION read_only_data_section\n+\n+/* Indicate that jump tables go in the text section.  */\n+\n+#define JUMP_TABLES_IN_TEXT_SECTION\n+\n+/* Define the routines to implement these extra sections.  */\n+\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\\\n+read_only_data_section ()\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (in_section != read_only_data)\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\t.csect\\t%s[RO]\\n\",\t\\\n+\t       rs6000_read_only_section_name);\t\t\\\n+      in_section = read_only_data;\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\\\n+private_data_section ()\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (in_section != private_data)\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\t.csect %s[RW]\\n\",\t\\\n+\t       rs6000_private_data_section_name);\t\\\n+\t\t\t\t\t\t\t\\\n+      in_section = private_data;\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\\\n+read_only_private_data_section ()\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (in_section != read_only_private_data)\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\t.csect\\t%s[RO]\\n\",\t\\\n+\t       rs6000_private_data_section_name);\t\\\n+      in_section = read_only_private_data;\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\\\n+toc_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (in_section != toc)\t\t\t\t\\\n+    fprintf (asm_out_file, \"\\t.toc\\n\");\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  in_section = toc;\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\\\n+bss_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (in_section != bss)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\t.csect\\t%s[BS]\\n\",\t\\\n+\t       rs6000_bss_section_name);\t\t\\\n+      in_section = bss;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\\\n+\n+/* This macro produces the initial definition of a function name.\n+   On the RS/6000, we need to place an extra '.' in the function name and\n+   output the function descriptor.  \n+\n+   The csect for the function will have already been created by the\n+   `text_section' call previously done.  We do have to go back to that\n+   csect, however.  */\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)\t\t\\\n+{ if (TREE_PUBLIC (DECL))\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.globl .\");\t\t\t\t\\\n+      RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\\\n+      fprintf (FILE,\"\\n\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.csect \");\t\t\t\t\t\\\n+  RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n+  fprintf (FILE, \"[DS]\\n\");\t\t\t\t\t\\\n+  RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n+  fprintf (FILE, \":\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.long .\");\t\t\t\t\t\\\n+  RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n+  fprintf (FILE, \", TOC[tc0], 0\\n\");\t\t\t\\\n+  fprintf (FILE, \"\\t.csect [PR]\\n.\");\t\t\t\t\\\n+  RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n+  fprintf (FILE, \":\\n\");\t\t\t\t\t\\\n+}\n+\n+/* Return non-zero if this entry is to be written into the constant pool\n+   in a special way.  We do so if this is a SYMBOL_REF, LABEL_REF or a CONST\n+   containing one of them.  If -mfp-in-toc (the default), we also do\n+   this for floating-point constants.  We actually can only do this\n+   if the FP formats of the target and host machines are the same, but\n+   we can't check that since not every file that uses\n+   GO_IF_LEGITIMATE_ADDRESS_P includes real.h.  */\n+\n+#define ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X)\t\t\t\\\n+  (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\\\n+   || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS\t\\\n+       && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)\t\\\n+   || GET_CODE (X) == LABEL_REF\t\t\t\t\t\\\n+   || (TARGET_FP_IN_TOC && GET_CODE (X) == CONST_DOUBLE\t\t\\\n+       && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\\\n+       && BITS_PER_WORD == HOST_BITS_PER_INT))\n+\n+/* Select section for constant in constant pool.\n+\n+   On RS/6000, all constants are in the private read-only data area.\n+   However, if this is being placed in the TOC it must be output as a\n+   toc entry.  */\n+\n+#define SELECT_RTX_SECTION(MODE, X)\t\t\\\n+{ if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (X))\t\\\n+    toc_section ();\t\t\t\t\\\n+  else\t\t\t\t\t\t\\\n+    read_only_private_data_section ();\t\t\\\n+}\n+\n+/* Macro to output a special constant pool entry.  Go to WIN if we output\n+   it.  Otherwise, it is written the usual way.\n+\n+   On the RS/6000, toc entries are handled this way.  */\n+\n+#define ASM_OUTPUT_SPECIAL_POOL_ENTRY(FILE, X, MODE, ALIGN, LABELNO, WIN)  \\\n+{ if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (X))\t\\\n+    {\t\t\t\t\t\t\\\n+      output_toc (FILE, X, LABELNO);\t\t\\\n+      goto WIN;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+}\n+\n+/* Select the section for an initialized data object.\n+\n+   On the RS/6000, we have a special section for all variables except those\n+   that are static.  */\n+\n+#define SELECT_SECTION(EXP,RELOC)\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  if ((TREE_READONLY (EXP)\t\t\t\t\\\n+       || (TREE_CODE (EXP) == STRING_CST\t\t\\\n+\t   && !flag_writable_strings))\t\t\t\\\n+      && ! TREE_THIS_VOLATILE (EXP)\t\t\t\\\n+      && ! (RELOC))\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (TREE_PUBLIC (EXP))\t\t\t\t\\\n+        read_only_data_section ();\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+        read_only_private_data_section ();\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (TREE_PUBLIC (EXP))\t\t\t\t\\\n+        data_section ();\t\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+        private_data_section ();\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\n+\n+/* This outputs NAME to FILE up to the first null or '['.  */\n+\n+#define RS6000_OUTPUT_BASENAME(FILE, NAME)\t\\\n+  if ((NAME)[0] == '*')\t\t\t\t\\\n+    assemble_name (FILE, NAME);  \t\t\\\n+  else\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      char *_p;\t\t\t\t\t\\\n+      for (_p = (NAME); *_p && *_p != '['; _p++) \\\n+        fputc (*_p, FILE);\t\t\t\t\\\n+    }\n+\n+/* Output something to declare an external symbol to the assembler.  Most\n+   assemblers don't need this.  \n+\n+   If we haven't already, add \"[RW]\" (or \"[DS]\" for a function) to the\n+   name.  Normally we write this out along with the name.  In the few cases\n+   where we can't, it gets stripped off.  */\n+\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\\\n+{ rtx _symref = XEXP (DECL_RTL (DECL), 0);\t\\\n+  if ((TREE_CODE (DECL) == VAR_DECL\t\t\\\n+       || TREE_CODE (DECL) == FUNCTION_DECL)\t\\\n+      && (NAME)[0] != '*'\t\t\t\\\n+      && (NAME)[strlen (NAME) - 1] != ']')\t\\\n+    {\t\t\t\t\t\t\\\n+      char *_name = (char *) permalloc (strlen (XSTR (_symref, 0)) + 5); \\\n+      strcpy (_name, XSTR (_symref, 0));\t\\\n+      strcat (_name, TREE_CODE (DECL) == FUNCTION_DECL ? \"[DS]\" : \"[RW]\"); \\\n+      XSTR (_symref, 0) = _name;\t\t\\\n+    }\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.extern \");\t\t\t\\\n+  assemble_name (FILE, XSTR (_symref, 0));\t\\\n+  if (TREE_CODE (DECL) == FUNCTION_DECL)\t\\\n+    {\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\n\\t.extern .\");\t\t\\\n+      RS6000_OUTPUT_BASENAME (FILE, XSTR (_symref, 0));\t\\\n+    }\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\n\");\t\t\t\t\\\n+}\n+\n+/* Similar, but for libcall.  We only have to worry about the function name,\n+   not that of the descriptor. */\n+\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)\t\\\n+{ fprintf (FILE, \"\\t.extern .\");\t\t\\\n+  assemble_name (FILE, XSTR (FUN, 0));\t\t\\\n+  fprintf (FILE, \"\\n\");\t\t\t\t\\\n+}\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"\"\n+\n+/* Output before instructions.  */\n+\n+#define TEXT_SECTION_ASM_OP \"\\t.csect [PR]\"\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \"\\t.csect .data[RW]\"\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+ {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \t\t\\\n+  \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\t\t\\\n+  \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\",\t\\\n+  \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\",\t\\\n+  \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\",\t\t\\\n+  \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\t\t\\\n+  \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\",\t\\\n+  \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\",\t\\\n+  \"mq\", \"lr\", \"ctr\", \"ap\",\t\t\t\t\\\n+  \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\" }\n+\n+/* Table of additional register names to use in user input.  */\n+\n+#define ADDITIONAL_REGISTER_NAMES \\\n+ {\"r0\",    0, \"r1\",    1, \"r2\",    2, \"r3\",    3,\t\\\n+  \"r4\",    4, \"r5\",    5, \"r6\",    6, \"r7\",    7,\t\\\n+  \"r8\",    8, \"r9\",    9, \"r10\",  10, \"r11\",  11,\t\\\n+  \"r12\",  12, \"r13\",  13, \"r14\",  14, \"r15\",  15,\t\\\n+  \"r16\",  16, \"r17\",  17, \"r18\",  18, \"r19\",  19,\t\\\n+  \"r20\",  20, \"r21\",  21, \"r22\",  22, \"r23\",  23,\t\\\n+  \"r24\",  24, \"r25\",  25, \"r26\",  26, \"r27\",  27,\t\\\n+  \"r28\",  28, \"r29\",  29, \"r30\",  30, \"r31\",  31,\t\\\n+  \"fr0\",  32, \"fr1\",  33, \"fr2\",  34, \"fr3\",  35,\t\\\n+  \"fr4\",  36, \"fr5\",  37, \"fr6\",  38, \"fr7\",  39,\t\\\n+  \"fr8\",  40, \"fr9\",  41, \"fr10\", 42, \"fr11\", 43,\t\\\n+  \"fr12\", 44, \"fr13\", 45, \"fr14\", 46, \"fr15\", 47,\t\\\n+  \"fr16\", 48, \"fr17\", 49, \"fr18\", 50, \"fr19\", 51,\t\\\n+  \"fr20\", 52, \"fr21\", 53, \"fr22\", 54, \"fr23\", 55,\t\\\n+  \"fr24\", 56, \"fr25\", 57, \"fr26\", 58, \"fr27\", 59,\t\\\n+  \"fr28\", 60, \"fr29\", 61, \"fr30\", 62, \"fr31\", 63,\t\\\n+  /* no additional names for: mq, lr, ctr, ap */\t\\\n+  \"cr0\",  68, \"cr1\",  69, \"cr2\",  70, \"cr3\",  71,\t\\\n+  \"cr4\",  72, \"cr5\",  73, \"cr6\",  74, \"cr7\",  75 }\n+\n+/* How to renumber registers for dbx and gdb.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { RS6000_OUTPUT_BASENAME (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\"\\t.globl \", FILE);\t\\\n+       RS6000_OUTPUT_BASENAME (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \"%s..%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to output a label for a jump table.  Arguments are the same as\n+   for ASM_OUTPUT_INTERNAL_LABEL, except the insn for the jump table is\n+   passed. */\n+\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLEINSN)\t\\\n+{ ASM_OUTPUT_ALIGN (FILE, 2); ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM); }\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"%s..%d\", PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\\\n+  fprintf (FILE, \"\\t.double 0d%.20e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\\\n+  fprintf (FILE, \"\\t.float 0d%.20e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.short \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+/* This is how to output an assembler line to define N characters starting\n+   at P to FILE.  */\n+\n+#define ASM_OUTPUT_ASCII(FILE, P, N)  output_ascii ((FILE), (P), (N))\n+\n+/* This is how to output code to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tstu %s,-4(r1)\\n\", reg_names[REGNO]);\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tl %s,0(r1)\\n\\tai r1,r1,4\\n\", reg_names[REGNO])\n+\n+/* This is how to output an element of a case-vector that is absolute. \n+   (RS/6000 does not use such vectors, but we must define this macro\n+   anyway.)   */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.long L..%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\t\\\n+  fprintf (FILE, \"\\t.long L..%d-L..%d\\n\", VALUE, REL)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.space %d\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n+  do { fputs (\".comm \", (FILE));\t\t\t\\\n+       RS6000_OUTPUT_BASENAME ((FILE), (NAME));\t\t\\\n+       fprintf ((FILE), \",%d\\n\", (SIZE)); } while (0)\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE,ROUNDED)\t\\\n+  do { fputs (\".lcomm \", (FILE));\t\t\t\\\n+       RS6000_OUTPUT_BASENAME ((FILE), (NAME));\t\t\\\n+       fprintf ((FILE), \",%d,%s\\n\", (SIZE), rs6000_bss_section_name); \\\n+     } while (0)\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  print_operand (FILE, X, CODE)\n+\n+/* Define which CODE values are valid.  */\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE)  0\n+\n+/* Print a memory address as an operand to reference that memory location.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n+\n+/* Define the codes that are matched by predicates in rs6000.c.  */\n+\n+#define PREDICATE_CODES \\\n+  {\"short_cint_operand\", {CONST_INT}},\t\t\t\t\\\n+  {\"u_short_cint_operand\", {CONST_INT}},\t\t\t\\\n+  {\"gen_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n+  {\"cc_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n+  {\"reg_or_short_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n+  {\"reg_or_neg_short_operand\", {SUBREG, REG, CONST_INT}},\t\\\n+  {\"reg_or_u_short_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n+  {\"reg_or_cint_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n+  {\"easy_fp_constant\", {CONST_DOUBLE}},\t\t\t\t\\\n+  {\"reg_or_mem_operand\", {SUBREG, MEM, REG}},\t\t\t\\\n+  {\"fp_reg_or_mem_operand\", {SUBREG, MEM, REG}},\t\t\\\n+  {\"mem_or_easy_const_operand\", {SUBREG, MEM, CONST_DOUBLE}},\t\\\n+  {\"add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"logical_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n+  {\"mask_operand\", {CONST_INT}},\t\t\t\t\\\n+  {\"call_operand\", {SYMBOL_REF, REG}},\t\t\t\t\\\n+  {\"input_operand\", {SUBREG, MEM, REG, CONST_INT}},\t\t\\\n+  {\"branch_comparison_operation\", {EQ, NE, LE, LT, GE,\t\t\\\n+\t\t\t\t   LT, LEU, LTU, GEU, GTU}},\t\\\n+  {\"scc_comparison_operation\", {EQ, NE, LE, LT, GE,\t\t\\\n+\t\t\t\tLT, LEU, LTU, GEU, GTU}},"}]}