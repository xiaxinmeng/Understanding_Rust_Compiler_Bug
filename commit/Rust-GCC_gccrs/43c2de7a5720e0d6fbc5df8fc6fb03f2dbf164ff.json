{"sha": "43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNjMmRlN2E1NzIwZTBkNmZiYzVkZjhmYzZmYjAzZjJkYmYxNjRmZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-12-09T16:41:30Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-12-09T16:41:30Z"}, "message": "tree.c (build_array_type_1): Add SET_CANONICAL parameter and compute TYPE_CANONICAL from the element type...\n\n\t* tree.c (build_array_type_1): Add SET_CANONICAL parameter and compute\n\tTYPE_CANONICAL from the element type only if it is true.  Remove a few\n\tobsolete lines and adjust recursive call.\n\t(fld_process_array_type): Adjust call to build_array_type_1.\n\t(build_array_type): Likewise.\n\t(build_nonshared_array_type): Likewise.\n\nFrom-SVN: r279133", "tree": {"sha": "2e8a6937054d054b20ce6263b5b6ca97962bdc3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e8a6937054d054b20ce6263b5b6ca97962bdc3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff/comments", "author": null, "committer": null, "parents": [{"sha": "9b4c16f2c93a089d81c9e6f3ea6d1abc36fd1ad1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b4c16f2c93a089d81c9e6f3ea6d1abc36fd1ad1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b4c16f2c93a089d81c9e6f3ea6d1abc36fd1ad1"}], "stats": {"total": 60, "additions": 45, "deletions": 15}, "files": [{"sha": "f4d1b47699018abdf04e5b533bd902e2c4e3a0fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff", "patch": "@@ -1,3 +1,12 @@\n+2019-12-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree.c (build_array_type_1): Add SET_CANONICAL parameter and compute\n+\tTYPE_CANONICAL from the element type only if it is true.  Remove a few\n+\tobsolete lines and adjust recursive call.\n+\t(fld_process_array_type): Adjust call to build_array_type_1.\n+\t(build_array_type): Likewise.\n+\t(build_nonshared_array_type): Likewise.\n+\n 2019-12-09  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* config/gcn/gcn-valu.md (gather<mode>_insn_1offset<exec>): Change"}, {"sha": "088718e8e2fdf2b3af040d9c9d06bc30ef20bc4f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff", "patch": "@@ -1,3 +1,7 @@\n+2019-12-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/lto23.adb: New test.\n+\n 2019-12-09  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR middle-end/91226"}, {"sha": "88615c9a6c19f780a7cfcf637d450dbf6ee37e92", "filename": "gcc/testsuite/gnat.dg/lto23.adb", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff/gcc%2Ftestsuite%2Fgnat.dg%2Flto23.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff/gcc%2Ftestsuite%2Fgnat.dg%2Flto23.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Flto23.adb?ref=43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff", "patch": "@@ -0,0 +1,20 @@\n+-- { dg-do compile }\r\n+-- { dg-options \"-flto\" { target lto } }\r\n+\r\n+procedure Lto23 (N : Natural) is\r\n+\r\n+  type Root is tagged null record;\r\n+\r\n+  type Vec is array (Positive range <>) of Root;\r\n+\r\n+  type Rec is record\r\n+    V : Vec (1 .. N);\r\n+  end record;\r\n+\r\n+  type Arr is array (Positive range <>) of Rec;\r\n+\r\n+  A : Arr (1 .. 4);\r\n+\r\n+begin\r\n+  null;\r\n+end;\r"}, {"sha": "d4d9d62cfc622040bcf1cf48b41bcb0d7ef5d608", "filename": "gcc/tree.c", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff", "patch": "@@ -266,7 +266,7 @@ static void print_type_hash_statistics (void);\n static void print_debug_expr_statistics (void);\n static void print_value_expr_statistics (void);\n \n-static tree build_array_type_1 (tree, tree, bool, bool);\n+static tree build_array_type_1 (tree, tree, bool, bool, bool);\n \n tree global_trees[TI_MAX];\n tree integer_types[itk_none];\n@@ -5303,8 +5303,9 @@ fld_process_array_type (tree t, tree t2, hash_map<tree, tree> *map,\n      = map->get_or_insert (t, &existed);\n   if (!existed)\n     {\n-      array = build_array_type_1 (t2, TYPE_DOMAIN (t),\n-\t\t\t\t  TYPE_TYPELESS_STORAGE (t), false);\n+      array\n+\t= build_array_type_1 (t2, TYPE_DOMAIN (t), TYPE_TYPELESS_STORAGE (t),\n+\t\t\t      false, false);\n       TYPE_CANONICAL (array) = TYPE_CANONICAL (t);\n       if (!fld->pset.add (array))\n \tadd_tree_to_fld_list (array, fld);\n@@ -8155,11 +8156,12 @@ subrange_type_for_debug_p (const_tree type, tree *lowval, tree *highval)\n /* Construct, lay out and return the type of arrays of elements with ELT_TYPE\n    and number of elements specified by the range of values of INDEX_TYPE.\n    If TYPELESS_STORAGE is true, TYPE_TYPELESS_STORAGE flag is set on the type.\n-   If SHARED is true, reuse such a type that has already been constructed.  */\n+   If SHARED is true, reuse such a type that has already been constructed.\n+   If SET_CANONICAL is true, compute TYPE_CANONICAL from the element type.  */\n \n static tree\n build_array_type_1 (tree elt_type, tree index_type, bool typeless_storage,\n-\t\t    bool shared)\n+\t\t    bool shared, bool set_canonical)\n {\n   tree t;\n \n@@ -8176,19 +8178,13 @@ build_array_type_1 (tree elt_type, tree index_type, bool typeless_storage,\n   TYPE_TYPELESS_STORAGE (t) = typeless_storage;\n   layout_type (t);\n \n-  /* If the element type is incomplete at this point we get marked for\n-     structural equality.  Do not record these types in the canonical\n-     type hashtable.  */\n-  if (TYPE_STRUCTURAL_EQUALITY_P (t))\n-    return t;\n-\n   if (shared)\n     {\n       hashval_t hash = type_hash_canon_hash (t);\n       t = type_hash_canon (hash, t);\n     }\n \n-  if (TYPE_CANONICAL (t) == t)\n+  if (TYPE_CANONICAL (t) == t && set_canonical)\n     {\n       if (TYPE_STRUCTURAL_EQUALITY_P (elt_type)\n \t  || (index_type && TYPE_STRUCTURAL_EQUALITY_P (index_type))\n@@ -8200,7 +8196,7 @@ build_array_type_1 (tree elt_type, tree index_type, bool typeless_storage,\n \t  = build_array_type_1 (TYPE_CANONICAL (elt_type),\n \t\t\t\tindex_type\n \t\t\t\t? TYPE_CANONICAL (index_type) : NULL_TREE,\n-\t\t\t\ttypeless_storage, shared);\n+\t\t\t\ttypeless_storage, shared, set_canonical);\n     }\n \n   return t;\n@@ -8211,15 +8207,16 @@ build_array_type_1 (tree elt_type, tree index_type, bool typeless_storage,\n tree\n build_array_type (tree elt_type, tree index_type, bool typeless_storage)\n {\n-  return build_array_type_1 (elt_type, index_type, typeless_storage, true);\n+  return\n+    build_array_type_1 (elt_type, index_type, typeless_storage, true, true);\n }\n \n /* Wrapper around build_array_type_1 with SHARED set to false.  */\n \n tree\n build_nonshared_array_type (tree elt_type, tree index_type)\n {\n-  return build_array_type_1 (elt_type, index_type, false, false);\n+  return build_array_type_1 (elt_type, index_type, false, false, true);\n }\n \n /* Return a representation of ELT_TYPE[NELTS], using indices of type"}]}